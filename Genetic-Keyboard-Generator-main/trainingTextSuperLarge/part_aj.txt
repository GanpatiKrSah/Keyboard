 getMaximumSize() {
				return this.maximumSize;
			}
			public void setMaximumSize(long maximumSize) {
				this.maximumSize = maximumSize;
			}
			public int getInitialCapacity() {
				return this.initialCapacity;
			}
			public void setInitialCapacity(int initialCapacity) {
				this.initialCapacity = initialCapacity;
			}
		}
	}
	public static class Consumer {
		/**
		 * Consumer name to identify a particular consumer from the topic stats.
		 */
		private String name;
		/**
		 * Topics the consumer subscribes to.
		 */
		private List<String> topics;
		/**
		 * Pattern for topics the consumer subscribes to.
		 */
		private Pattern topicsPattern;
		/**
		 * Priority level for shared subscription consumers.
		 */
		private int priorityLevel = 0;
		/**
		 * Whether to read messages from the compacted topic rather than the full message
		 * backlog.
		 */
		private boolean readCompacted = false;
		/**
		 * Dead letter policy to use.
		 */
		@NestedConfigurationProperty
		private DeadLetterPolicy deadLetterPolicy;
		/**
		 * Consumer subscription properties.
		 */
		private final Subscription subscription = new Subscription();
		/**
		 * Whether to auto retry messages.
		 */
		private boolean retryEnable = false;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public Consumer.Subscription getSubscription() {
			return this.subscription;
		}
		public List<String> getTopics() {
			return this.topics;
		}
		public void setTopics(List<String> topics) {
			this.topics = topics;
		}
		public Pattern getTopicsPattern() {
			return this.topicsPattern;
		}
		public void setTopicsPattern(Pattern topicsPattern) {
			this.topicsPattern = topicsPattern;
		}
		public int getPriorityLevel() {
			return this.priorityLevel;
		}
		public void setPriorityLevel(int priorityLevel) {
			this.priorityLevel = priorityLevel;
		}
		public boolean isReadCompacted() {
			return this.readCompacted;
		}
		public void setReadCompacted(boolean readCompacted) {
			this.readCompacted = readCompacted;
		}
		public DeadLetterPolicy getDeadLetterPolicy() {
			return this.deadLetterPolicy;
		}
		public void setDeadLetterPolicy(DeadLetterPolicy deadLetterPolicy) {
			this.deadLetterPolicy = deadLetterPolicy;
		}
		public boolean isRetryEnable() {
			return this.retryEnable;
		}
		public void setRetryEnable(boolean retryEnable) {
			this.retryEnable = retryEnable;
		}
		public static class Subscription {
			/**
			 * Subscription name for the consumer.
			 */
			private String name;
			/**
			 * Position where to initialize a newly created subscription.
			 */
			private SubscriptionInitialPosition initialPosition = SubscriptionInitialPosition.Latest;
			/**
			 * Subscription mode to be used when subscribing to the topic.
			 */
			private SubscriptionMode mode = SubscriptionMode.Durable;
			/**
			 * Determines which type of topics (persistent, non-persistent, or all) the
			 * consumer should be subscribed to when using pattern subscriptions.
			 */
			private RegexSubscriptionMode topicsMode = RegexSubscriptionMode.PersistentOnly;
			/**
			 * Subscription type to be used when subscribing to a topic.
			 */
			private SubscriptionType type = SubscriptionType.Exclusive;
			public String getName() {
				return this.name;
			}
			public void setName(String name) {
				this.name = name;
			}
			public SubscriptionInitialPosition getInitialPosition() {
				return this.initialPosition;
			}
			public void setInitialPosition(SubscriptionInitialPosition initialPosition) {
				this.initialPosition = initialPosition;
			}
			public SubscriptionMode getMode() {
				return this.mode;
			}
			public void setMode(SubscriptionMode mode) {
				this.mode = mode;
			}
			public RegexSubscriptionMode getTopicsMode() {
				return this.topicsMode;
			}
			public void setTopicsMode(RegexSubscriptionMode topicsMode) {
				this.topicsMode = topicsMode;
			}
			public SubscriptionType getType() {
				return this.type;
			}
			public void setType(SubscriptionType type) {
				this.type = type;
			}
		}
		public static class DeadLetterPolicy {
			/**
			 * Maximum number of times that a message will be redelivered before being
			 * sent to the dead letter queue.
			 */
			private int maxRedeliverCount;
			/**
			 * Name of the retry topic where the failing messages will be sent.
			 */
			private String retryLetterTopic;
			/**
			 * Name of the dead topic where the failing messages will be sent.
			 */
			private String deadLetterTopic;
			/**
			 * Name of the initial subscription of the dead letter topic. When not set,
			 * the initial subscription will not be created. However, when the property is
			 * set then the broker"s "allowAutoSubscriptionCreation" must be enabled or
			 * the DLQ producer will fail.
			 */
			private String initialSubscriptionName;
			public int getMaxRedeliverCount() {
				return this.maxRedeliverCount;
			}
			public void setMaxRedeliverCount(int maxRedeliverCount) {
				this.maxRedeliverCount = maxRedeliverCount;
			}
			public String getRetryLetterTopic() {
				return this.retryLetterTopic;
			}
			public void setRetryLetterTopic(String retryLetterTopic) {
				this.retryLetterTopic = retryLetterTopic;
			}
			public String getDeadLetterTopic() {
				return this.deadLetterTopic;
			}
			public void setDeadLetterTopic(String deadLetterTopic) {
				this.deadLetterTopic = deadLetterTopic;
			}
			public String getInitialSubscriptionName() {
				return this.initialSubscriptionName;
			}
			public void setInitialSubscriptionName(String initialSubscriptionName) {
				this.initialSubscriptionName = initialSubscriptionName;
			}
		}
	}
	public static class Listener {
		/**
		 * SchemaType of the consumed messages.
		 */
		private SchemaType schemaType;
		/**
		 * Number of threads used by listener container.
		 */
		private Integer concurrency;
		/**
		 * Whether to record observations for when the Observations API is available and
		 * the client supports it.
		 */
		private boolean observationEnabled;
		public SchemaType getSchemaType() {
			return this.schemaType;
		}
		public void setSchemaType(SchemaType schemaType) {
			this.schemaType = schemaType;
		}
		public Integer getConcurrency() {
			return this.concurrency;
		}
		public void setConcurrency(Integer concurrency) {
			this.concurrency = concurrency;
		}
		public boolean isObservationEnabled() {
			return this.observationEnabled;
		}
		public void setObservationEnabled(boolean observationEnabled) {
			this.observationEnabled = observationEnabled;
		}
	}
	public static class Reader {
		/**
		 * Reader name.
		 */
		private String name;
		/**
		 * Topics the reader subscribes to.
		 */
		private List<String> topics;
		/**
		 * Subscription name.
		 */
		private String subscriptionName;
		/**
		 * Prefix of subscription role.
		 */
		private String subscriptionRolePrefix;
		/**
		 * Whether to read messages from a compacted topic rather than a full message
		 * backlog of a topic.
		 */
		private boolean readCompacted;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public List<String> getTopics() {
			return this.topics;
		}
		public void setTopics(List<String> topics) {
			this.topics = topics;
		}
		public String getSubscriptionName() {
			return this.subscriptionName;
		}
		public void setSubscriptionName(String subscriptionName) {
			this.subscriptionName = subscriptionName;
		}
		public String getSubscriptionRolePrefix() {
			return this.subscriptionRolePrefix;
		}
		public void setSubscriptionRolePrefix(String subscriptionRolePrefix) {
			this.subscriptionRolePrefix = subscriptionRolePrefix;
		}
		public boolean isReadCompacted() {
			return this.readCompacted;
		}
		public void setReadCompacted(boolean readCompacted) {
			this.readCompacted = readCompacted;
		}
	}
	public static class Template {
		/**
		 * Whether to record observations for when the Observations API is available.
		 */
		private boolean observationsEnabled;
		public boolean isObservationsEnabled() {
			return this.observationsEnabled;
		}
		public void setObservationsEnabled(boolean observationsEnabled) {
			this.observationsEnabled = observationsEnabled;
		}
	}
	public static class Transaction {
		/**
		 * Whether transaction support is enabled.
		 */
		private boolean enabled;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
	public static class Authentication {
		/**
		 * Fully qualified class name of the authentication plugin.
		 */
		private String pluginClassName;
		/**
		 * Authentication parameter(s) as a map of parameter names to parameter values.
		 */
		private Map<String, String> param = new LinkedHashMap<>();
		public String getPluginClassName() {
			return this.pluginClassName;
		}
		public void setPluginClassName(String pluginClassName) {
			this.pluginClassName = pluginClassName;
		}
		public Map<String, String> getParam() {
			return this.param;
		}
		public void setParam(Map<String, String> param) {
			this.param = param;
		}
	}
	public static class Threads {
		/**
		 * Number of threads to be used for handling connections to brokers.
		 */
		private Integer io;
		/**
		 * Number of threads to be used for message listeners.
		 */
		private Integer listener;
		public Integer getIo() {
			return this.io;
		}
		public void setIo(Integer io) {
			this.io = io;
		}
		public Integer getListener() {
			return this.listener;
		}
		public void setListener(Integer listener) {
			this.listener = listener;
		}
	}
	public static class Failover {
		/**
		 * Cluster failover policy.
		 */
		private FailoverPolicy policy = FailoverPolicy.ORDER;
		/**
		 * Delay before the Pulsar client switches from the primary cluster to the backup
		 * cluster.
		 */
		private Duration delay;
		/**
		 * Delay before the Pulsar client switches from the backup cluster to the primary
		 * cluster.
		 */
		private Duration switchBackDelay;
		/**
		 * Frequency of performing a probe task.
		 */
		private Duration checkInterval;
		/**
		 * List of backup clusters. The backup cluster is chosen in the sequence of the
		 * given list. If all backup clusters are available, the Pulsar client chooses the
		 * first backup cluster.
		 */
		private List<BackupCluster> backupClusters = new ArrayList<>();
		public FailoverPolicy getPolicy() {
			return this.policy;
		}
		public void setPolicy(FailoverPolicy policy) {
			this.policy = policy;
		}
		public Duration getDelay() {
			return this.delay;
		}
		public void setDelay(Duration delay) {
			this.delay = delay;
		}
		public Duration getSwitchBackDelay() {
			return this.switchBackDelay;
		}
		public void setSwitchBackDelay(Duration switchBackDelay) {
			this.switchBackDelay = switchBackDelay;
		}
		public Duration getCheckInterval() {
			return this.checkInterval;
		}
		public void setCheckInterval(Duration checkInterval) {
			this.checkInterval = checkInterval;
		}
		public List<BackupCluster> getBackupClusters() {
			return this.backupClusters;
		}
		public void setBackupClusters(List<BackupCluster> backupClusters) {
			this.backupClusters = backupClusters;
		}
		public static class BackupCluster {
			/**
			 * Pulsar service URL in the format "(pulsar|pulsar+ssl)://host:port".
			 */
			private String serviceUrl = 'pulsar://localhost:6650';
			/**
			 * Authentication settings.
			 */
			private final Authentication authentication = new Authentication();
			public String getServiceUrl() {
				return this.serviceUrl;
			}
			public void setServiceUrl(String serviceUrl) {
				this.serviceUrl = serviceUrl;
			}
			public Authentication getAuthentication() {
				return this.authentication;
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarContainerFactoryCustomizers {
	private final List<PulsarContainerFactoryCustomizer<?>> customizers;
	PulsarContainerFactoryCustomizers(List<? extends PulsarContainerFactoryCustomizer<?>> customizers) {
		this.customizers = (customizers != null) ? new ArrayList<>(customizers) : Collections.emptyList();
	}
	/**
	 * Customize the specified {@link PulsarContainerFactory}. Locates all
	 * {@link PulsarContainerFactoryCustomizer} beans able to handle the specified
	 * instance and invoke {@link PulsarContainerFactoryCustomizer#customize} on them.
	 * @param <T> the type of container factory
	 * @param containerFactory the container factory to customize
	 * @return the customized container factory
	 */
	@SuppressWarnings('unchecked')
	<T extends PulsarContainerFactory<?, ?>> T customize(T containerFactory) {
		LambdaSafe.callbacks(PulsarContainerFactoryCustomizer.class, this.customizers, containerFactory)
			.withLogger(PulsarContainerFactoryCustomizers.class)
			.invoke((customizer) -> customizer.customize(containerFactory));
		return containerFactory;
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
final class PulsarReactivePropertiesMapper {
	private final PulsarProperties properties;
	PulsarReactivePropertiesMapper(PulsarProperties properties) {
		this.properties = properties;
	}
	<T> void customizeMessageSenderBuilder(ReactiveMessageSenderBuilder<T> builder) {
		PulsarProperties.Producer properties = this.properties.getProducer();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(builder::producerName);
		map.from(properties::getTopicName).to(builder::topic);
		map.from(properties::getSendTimeout).to(builder::sendTimeout);
		map.from(properties::getMessageRoutingMode).to(builder::messageRoutingMode);
		map.from(properties::getHashingScheme).to(builder::hashingScheme);
		map.from(properties::isBatchingEnabled).to(builder::batchingEnabled);
		map.from(properties::isChunkingEnabled).to(builder::chunkingEnabled);
		map.from(properties::getCompressionType).to(builder::compressionType);
		map.from(properties::getAccessMode).to(builder::accessMode);
	}
	<T> void customizeMessageConsumerBuilder(ReactiveMessageConsumerBuilder<T> builder) {
		PulsarProperties.Consumer properties = this.properties.getConsumer();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(builder::consumerName);
		map.from(properties::getTopics).as(ArrayList::new).to(builder::topics);
		map.from(properties::getTopicsPattern).to(builder::topicsPattern);
		map.from(properties::getPriorityLevel).to(builder::priorityLevel);
		map.from(properties::isReadCompacted).to(builder::readCompacted);
		map.from(properties::getDeadLetterPolicy).as(DeadLetterPolicyMapper::map).to(builder::deadLetterPolicy);
		map.from(properties::isRetryEnable).to(builder::retryLetterTopicEnable);
		customizerMessageConsumerBuilderSubscription(builder);
	}
	private <T> void customizerMessageConsumerBuilderSubscription(ReactiveMessageConsumerBuilder<T> builder) {
		PulsarProperties.Consumer.Subscription properties = this.properties.getConsumer().getSubscription();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(builder::subscriptionName);
		map.from(properties::getInitialPosition).to(builder::subscriptionInitialPosition);
		map.from(properties::getMode).to(builder::subscriptionMode);
		map.from(properties::getTopicsMode).to(builder::topicsPatternSubscriptionMode);
		map.from(properties::getType).to(builder::subscriptionType);
	}
	<T> void customizeContainerProperties(ReactivePulsarContainerProperties<T> containerProperties) {
		customizePulsarContainerConsumerSubscriptionProperties(containerProperties);
		customizePulsarContainerListenerProperties(containerProperties);
	}
	private void customizePulsarContainerConsumerSubscriptionProperties(
			ReactivePulsarContainerProperties<?> containerProperties) {
		PulsarProperties.Consumer.Subscription properties = this.properties.getConsumer().getSubscription();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getType).to(containerProperties::setSubscriptionType);
		map.from(properties::getName).to(containerProperties::setSubscriptionName);
	}
	private void customizePulsarContainerListenerProperties(ReactivePulsarContainerProperties<?> containerProperties) {
		PulsarProperties.Listener properties = this.properties.getListener();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getSchemaType).to(containerProperties::setSchemaType);
		map.from(properties::getConcurrency).to(containerProperties::setConcurrency);
	}
	void customizeMessageReaderBuilder(ReactiveMessageReaderBuilder<?> builder) {
		PulsarProperties.Reader properties = this.properties.getReader();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(builder::readerName);
		map.from(properties::getTopics).to(builder::topics);
		map.from(properties::getSubscriptionName).to(builder::subscriptionName);
		map.from(properties::getSubscriptionRolePrefix).to(builder::generatedSubscriptionNamePrefix);
		map.from(properties::isReadCompacted).to(builder::readCompacted);
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PropertiesPulsarConnectionDetails implements PulsarConnectionDetails {
	private final PulsarProperties pulsarProperties;
	PropertiesPulsarConnectionDetails(PulsarProperties pulsarProperties) {
		this.pulsarProperties = pulsarProperties;
	}
	@Override
	public String getBrokerUrl() {
		return this.pulsarProperties.getClient().getServiceUrl();
	}
	@Override
	public String getAdminUrl() {
		return this.pulsarProperties.getAdmin().getServiceUrl();
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
public interface PulsarConnectionDetails extends ConnectionDetails {
	/**
	 * URL used to connect to the broker.
	 * @return the service URL
	 */
	String getBrokerUrl();
	/**
	 * URL user to connect to the admin endpoint.
	 * @return the admin URL
	 */
	String getAdminUrl();
}
/*
/**
package org.springframework.boot.autoconfigure.pulsar;
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
@FunctionalInterface
public interface PulsarContainerFactoryCustomizer<T extends PulsarContainerFactory<?, ?>> {
	/**
	 * Customize the container factory.
	 * @param containerFactory the {@code PulsarContainerFactory} to customize
	 */
	void customize(T containerFactory);
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
@AutoConfiguration
@ConditionalOnClass({ PulsarClient.class, PulsarTemplate.class })
@Import(PulsarConfiguration.class)
public class PulsarAutoConfiguration {
	private final PulsarProperties properties;
	private final PulsarPropertiesMapper propertiesMapper;
	PulsarAutoConfiguration(PulsarProperties properties) {
		this.properties = properties;
		this.propertiesMapper = new PulsarPropertiesMapper(properties);
	}
	@Bean
	@ConditionalOnMissingBean(PulsarProducerFactory.class)
	@ConditionalOnProperty(name = 'spring.pulsar.producer.cache.enabled', havingValue = 'false')
	DefaultPulsarProducerFactory<?> pulsarProducerFactory(PulsarClient pulsarClient, TopicResolver topicResolver,
			ObjectProvider<ProducerBuilderCustomizer<?>> customizersProvider,
			ObjectProvider<PulsarTopicBuilder> topicBuilderProvider) {
		List<ProducerBuilderCustomizer<Object>> lambdaSafeCustomizers = lambdaSafeProducerBuilderCustomizers(
				customizersProvider);
		DefaultPulsarProducerFactory<?> producerFactory = new DefaultPulsarProducerFactory<>(pulsarClient,
				this.properties.getProducer().getTopicName(), lambdaSafeCustomizers, topicResolver);
		topicBuilderProvider.ifAvailable(producerFactory::setTopicBuilder);
		return producerFactory;
	}
	@Bean
	@ConditionalOnMissingBean(PulsarProducerFactory.class)
	@ConditionalOnProperty(name = 'spring.pulsar.producer.cache.enabled', havingValue = 'true', matchIfMissing = true)
	CachingPulsarProducerFactory<?> cachingPulsarProducerFactory(PulsarClient pulsarClient, TopicResolver topicResolver,
			ObjectProvider<ProducerBuilderCustomizer<?>> customizersProvider,
			ObjectProvider<PulsarTopicBuilder> topicBuilderProvider) {
		PulsarProperties.Producer.Cache cacheProperties = this.properties.getProducer().getCache();
		List<ProducerBuilderCustomizer<Object>> lambdaSafeCustomizers = lambdaSafeProducerBuilderCustomizers(
				customizersProvider);
		CachingPulsarProducerFactory<?> producerFactory = new CachingPulsarProducerFactory<>(pulsarClient,
				this.properties.getProducer().getTopicName(), lambdaSafeCustomizers, topicResolver,
				cacheProperties.getExpireAfterAccess(), cacheProperties.getMaximumSize(),
				cacheProperties.getInitialCapacity());
		topicBuilderProvider.ifAvailable(producerFactory::setTopicBuilder);
		return producerFactory;
	}
	private List<ProducerBuilderCustomizer<Object>> lambdaSafeProducerBuilderCustomizers(
			ObjectProvider<ProducerBuilderCustomizer<?>> customizersProvider) {
		List<ProducerBuilderCustomizer<?>> customizers = new ArrayList<>();
		customizers.add(this.propertiesMapper::customizeProducerBuilder);
		customizers.addAll(customizersProvider.orderedStream().toList());
		return List.of((builder) -> applyProducerBuilderCustomizers(customizers, builder));
	}
	@SuppressWarnings('unchecked')
	private void applyProducerBuilderCustomizers(List<ProducerBuilderCustomizer<?>> customizers,
			ProducerBuilder<?> builder) {
		LambdaSafe.callbacks(ProducerBuilderCustomizer.class, customizers, builder)
			.invoke((customizer) -> customizer.customize(builder));
	}
	@Bean
	@ConditionalOnMissingBean
	PulsarTemplate<?> pulsarTemplate(PulsarProducerFactory<?> pulsarProducerFactory,
			ObjectProvider<ProducerInterceptor> producerInterceptors, SchemaResolver schemaResolver,
			TopicResolver topicResolver) {
		PulsarTemplate<?> template = new PulsarTemplate<>(pulsarProducerFactory,
				producerInterceptors.orderedStream().toList(), schemaResolver, topicResolver,
				this.properties.getTemplate().isObservationsEnabled());
		this.propertiesMapper.customizeTemplate(template);
		return template;
	}
	@Bean
	@ConditionalOnMissingBean(PulsarConsumerFactory.class)
	DefaultPulsarConsumerFactory<?> pulsarConsumerFactory(PulsarClient pulsarClient,
			ObjectProvider<ConsumerBuilderCustomizer<?>> customizersProvider,
			ObjectProvider<PulsarTopicBuilder> topicBuilderProvider) {
		List<ConsumerBuilderCustomizer<?>> customizers = new ArrayList<>();
		customizers.add(this.propertiesMapper::customizeConsumerBuilder);
		customizers.addAll(customizersProvider.orderedStream().toList());
		List<ConsumerBuilderCustomizer<Object>> lambdaSafeCustomizers = List
			.of((builder) -> applyConsumerBuilderCustomizers(customizers, builder));
		DefaultPulsarConsumerFactory<?> consumerFactory = new DefaultPulsarConsumerFactory<>(pulsarClient,
				lambdaSafeCustomizers);
		topicBuilderProvider.ifAvailable(consumerFactory::setTopicBuilder);
		return consumerFactory;
	}
	@Bean
	@ConditionalOnMissingBean(PulsarAwareTransactionManager.class)
	@ConditionalOnProperty(prefix = 'spring.pulsar.transaction', name = 'enabled')
	public PulsarTransactionManager pulsarTransactionManager(PulsarClient pulsarClient) {
		return new PulsarTransactionManager(pulsarClient);
	}
	@SuppressWarnings('unchecked')
	private void applyConsumerBuilderCustomizers(List<ConsumerBuilderCustomizer<?>> customizers,
			ConsumerBuilder<?> builder) {
		LambdaSafe.callbacks(ConsumerBuilderCustomizer.class, customizers, builder)
			.invoke((customizer) -> customizer.customize(builder));
	}
	@Bean
	@ConditionalOnMissingBean(name = 'pulsarListenerContainerFactory')
	ConcurrentPulsarListenerContainerFactory<?> pulsarListenerContainerFactory(
			PulsarConsumerFactory<Object> pulsarConsumerFactory, SchemaResolver schemaResolver,
			TopicResolver topicResolver, ObjectProvider<PulsarAwareTransactionManager> pulsarTransactionManager,
			Environment environment, PulsarContainerFactoryCustomizers containerFactoryCustomizers) {
		PulsarContainerProperties containerProperties = new PulsarContainerProperties();
		containerProperties.setSchemaResolver(schemaResolver);
		containerProperties.setTopicResolver(topicResolver);
		if (Threading.VIRTUAL.isActive(environment)) {
			containerProperties.setConsumerTaskExecutor(new VirtualThreadTaskExecutor('pulsar-consumer-'));
		}
		pulsarTransactionManager.ifUnique(containerProperties.transactions()::setTransactionManager);
		this.propertiesMapper.customizeContainerProperties(containerProperties);
		ConcurrentPulsarListenerContainerFactory<?> containerFactory = new ConcurrentPulsarListenerContainerFactory<>(
				pulsarConsumerFactory, containerProperties);
		containerFactoryCustomizers.customize(containerFactory);
		return containerFactory;
	}
	@Bean
	@ConditionalOnMissingBean(PulsarReaderFactory.class)
	DefaultPulsarReaderFactory<?> pulsarReaderFactory(PulsarClient pulsarClient,
			ObjectProvider<ReaderBuilderCustomizer<?>> customizersProvider,
			ObjectProvider<PulsarTopicBuilder> topicBuilderProvider) {
		List<ReaderBuilderCustomizer<?>> customizers = new ArrayList<>();
		customizers.add(this.propertiesMapper::customizeReaderBuilder);
		customizers.addAll(customizersProvider.orderedStream().toList());
		List<ReaderBuilderCustomizer<Object>> lambdaSafeCustomizers = List
			.of((builder) -> applyReaderBuilderCustomizers(customizers, builder));
		DefaultPulsarReaderFactory<?> readerFactory = new DefaultPulsarReaderFactory<>(pulsarClient,
				lambdaSafeCustomizers);
		topicBuilderProvider.ifAvailable(readerFactory::setTopicBuilder);
		return readerFactory;
	}
	@SuppressWarnings('unchecked')
	private void applyReaderBuilderCustomizers(List<ReaderBuilderCustomizer<?>> customizers, ReaderBuilder<?> builder) {
		LambdaSafe.callbacks(ReaderBuilderCustomizer.class, customizers, builder)
			.invoke((customizer) -> customizer.customize(builder));
	}
	@Bean
	@ConditionalOnMissingBean(name = 'pulsarReaderContainerFactory')
	DefaultPulsarReaderContainerFactory<?> pulsarReaderContainerFactory(PulsarReaderFactory<?> pulsarReaderFactory,
			SchemaResolver schemaResolver, Environment environment,
			PulsarContainerFactoryCustomizers containerFactoryCustomizers) {
		PulsarReaderContainerProperties readerContainerProperties = new PulsarReaderContainerProperties();
		readerContainerProperties.setSchemaResolver(schemaResolver);
		if (Threading.VIRTUAL.isActive(environment)) {
			readerContainerProperties.setReaderTaskExecutor(new VirtualThreadTaskExecutor('pulsar-reader-'));
		}
		this.propertiesMapper.customizeReaderContainerProperties(readerContainerProperties);
		DefaultPulsarReaderContainerFactory<?> containerFactory = new DefaultPulsarReaderContainerFactory<>(
				pulsarReaderFactory, readerContainerProperties);
		containerFactoryCustomizers.customize(containerFactory);
		return containerFactory;
	}
	@Configuration(proxyBeanMethods = false)
	@EnablePulsar
	@ConditionalOnMissingBean(name = { PulsarAnnotationSupportBeanNames.PULSAR_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME,
			PulsarAnnotationSupportBeanNames.PULSAR_READER_ANNOTATION_PROCESSOR_BEAN_NAME })
	static class EnablePulsarConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
@AutoConfiguration(after = PulsarAutoConfiguration.class)
@ConditionalOnClass({ PulsarClient.class, ReactivePulsarClient.class, ReactivePulsarTemplate.class })
@Import(PulsarConfiguration.class)
public class PulsarReactiveAutoConfiguration {
	private final PulsarProperties properties;
	private final PulsarReactivePropertiesMapper propertiesMapper;
	PulsarReactiveAutoConfiguration(PulsarProperties properties) {
		this.properties = properties;
		this.propertiesMapper = new PulsarReactivePropertiesMapper(properties);
	}
	@Bean
	@ConditionalOnMissingBean
	ReactivePulsarClient reactivePulsarClient(PulsarClient pulsarClient) {
		return AdaptedReactivePulsarClientFactory.create(pulsarClient);
	}
	@Bean
	@ConditionalOnMissingBean(ProducerCacheProvider.class)
	@ConditionalOnClass(CaffeineShadedProducerCacheProvider.class)
	@ConditionalOnProperty(name = 'spring.pulsar.producer.cache.enabled', havingValue = 'true', matchIfMissing = true)
	CaffeineShadedProducerCacheProvider reactivePulsarProducerCacheProvider() {
		PulsarProperties.Producer.Cache properties = this.properties.getProducer().getCache();
		return new CaffeineShadedProducerCacheProvider(properties.getExpireAfterAccess(), Duration.ofMinutes(10),
				properties.getMaximumSize(), properties.getInitialCapacity());
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(name = 'spring.pulsar.producer.cache.enabled', havingValue = 'true', matchIfMissing = true)
	ReactiveMessageSenderCache reactivePulsarMessageSenderCache(
			ObjectProvider<ProducerCacheProvider> producerCacheProvider) {
		return reactivePulsarMessageSenderCache(producerCacheProvider.getIfAvailable());
	}
	private ReactiveMessageSenderCache reactivePulsarMessageSenderCache(ProducerCacheProvider producerCacheProvider) {
		return (producerCacheProvider != null) ? AdaptedReactivePulsarClientFactory.createCache(producerCacheProvider)
				: AdaptedReactivePulsarClientFactory.createCache();
	}
	@Bean
	@ConditionalOnMissingBean(ReactivePulsarSenderFactory.class)
	DefaultReactivePulsarSenderFactory<?> reactivePulsarSenderFactory(ReactivePulsarClient reactivePulsarClient,
			ObjectProvider<ReactiveMessageSenderCache> reactiveMessageSenderCache, TopicResolver topicResolver,
			ObjectProvider<ReactiveMessageSenderBuilderCustomizer<?>> customizersProvider,
			ObjectProvider<PulsarTopicBuilder> topicBuilderProvider) {
		List<ReactiveMessageSenderBuilderCustomizer<?>> customizers = new ArrayList<>();
		customizers.add(this.propertiesMapper::customizeMessageSenderBuilder);
		customizers.addAll(customizersProvider.orderedStream().toList());
		List<ReactiveMessageSenderBuilderCustomizer<Object>> lambdaSafeCustomizers = List
			.of((builder) -> applyMessageSenderBuilderCustomizers(customizers, builder));
		Builder<Object> senderFactoryBuilder = DefaultReactivePulsarSenderFactory.builderFor(reactivePulsarClient)
			.withDefaultConfigCustomizers(lambdaSafeCustomizers)
			.withMessageSenderCache(reactiveMessageSenderCache.getIfAvailable())
			.withTopicResolver(topicResolver);
		topicBuilderProvider.ifAvailable(senderFactoryBuilder::withTopicBuilder);
		return senderFactoryBuilder.build();
	}
	@SuppressWarnings('unchecked')
	private void applyMessageSenderBuilderCustomizers(List<ReactiveMessageSenderBuilderCustomizer<?>> customizers,
			ReactiveMessageSenderBuilder<?> builder) {
		LambdaSafe.callbacks(ReactiveMessageSenderBuilderCustomizer.class, customizers, builder)
			.invoke((customizer) -> customizer.customize(builder));
	}
	@Bean
	@ConditionalOnMissingBean(ReactivePulsarConsumerFactory.class)
	DefaultReactivePulsarConsumerFactory<?> reactivePulsarConsumerFactory(
			ReactivePulsarClient pulsarReactivePulsarClient,
			ObjectProvider<ReactiveMessageConsumerBuilderCustomizer<?>> customizersProvider,
			ObjectProvider<PulsarTopicBuilder> topicBuilderProvider) {
		List<ReactiveMessageConsumerBuilderCustomizer<?>> customizers = new ArrayList<>();
		customizers.add(this.propertiesMapper::customizeMessageConsumerBuilder);
		customizers.addAll(customizersProvider.orderedStream().toList());
		List<ReactiveMessageConsumerBuilderCustomizer<Object>> lambdaSafeCustomizers = List
			.of((builder) -> applyMessageConsumerBuilderCustomizers(customizers, builder));
		DefaultReactivePulsarConsumerFactory<?> consumerFactory = new DefaultReactivePulsarConsumerFactory<>(
				pulsarReactivePulsarClient, lambdaSafeCustomizers);
		topicBuilderProvider.ifAvailable(consumerFactory::setTopicBuilder);
		return consumerFactory;
	}
	@SuppressWarnings('unchecked')
	private void applyMessageConsumerBuilderCustomizers(List<ReactiveMessageConsumerBuilderCustomizer<?>> customizers,
			ReactiveMessageConsumerBuilder<?> builder) {
		LambdaSafe.callbacks(ReactiveMessageConsumerBuilderCustomizer.class, customizers, builder)
			.invoke((customizer) -> customizer.customize(builder));
	}
	@Bean
	@ConditionalOnMissingBean(name = 'reactivePulsarListenerContainerFactory')
	DefaultReactivePulsarListenerContainerFactory<?> reactivePulsarListenerContainerFactory(
			ReactivePulsarConsumerFactory<Object> reactivePulsarConsumerFactory, SchemaResolver schemaResolver,
			TopicResolver topicResolver, PulsarContainerFactoryCustomizers containerFactoryCustomizers) {
		ReactivePulsarContainerProperties<Object> containerProperties = new ReactivePulsarContainerProperties<>();
		containerProperties.setSchemaResolver(schemaResolver);
		containerProperties.setTopicResolver(topicResolver);
		this.propertiesMapper.customizeContainerProperties(containerProperties);
		DefaultReactivePulsarListenerContainerFactory<?> containerFactory = new DefaultReactivePulsarListenerContainerFactory<>(
				reactivePulsarConsumerFactory, containerProperties);
		containerFactoryCustomizers.customize(containerFactory);
		return containerFactory;
	}
	@Bean
	@ConditionalOnMissingBean(ReactivePulsarReaderFactory.class)
	DefaultReactivePulsarReaderFactory<?> reactivePulsarReaderFactory(ReactivePulsarClient reactivePulsarClient,
			ObjectProvider<ReactiveMessageReaderBuilderCustomizer<?>> customizersProvider,
			ObjectProvider<PulsarTopicBuilder> topicBuilderProvider) {
		List<ReactiveMessageReaderBuilderCustomizer<?>> customizers = new ArrayList<>();
		customizers.add(this.propertiesMapper::customizeMessageReaderBuilder);
		customizers.addAll(customizersProvider.orderedStream().toList());
		List<ReactiveMessageReaderBuilderCustomizer<Object>> lambdaSafeCustomizers = List
			.of((builder) -> applyMessageReaderBuilderCustomizers(customizers, builder));
		DefaultReactivePulsarReaderFactory<?> readerFactory = new DefaultReactivePulsarReaderFactory<>(
				reactivePulsarClient, lambdaSafeCustomizers);
		topicBuilderProvider.ifAvailable(readerFactory::setTopicBuilder);
		return readerFactory;
	}
	@SuppressWarnings('unchecked')
	private void applyMessageReaderBuilderCustomizers(List<ReactiveMessageReaderBuilderCustomizer<?>> customizers,
			ReactiveMessageReaderBuilder<?> builder) {
		LambdaSafe.callbacks(ReactiveMessageReaderBuilderCustomizer.class, customizers, builder)
			.invoke((customizer) -> customizer.customize(builder));
	}
	@Bean
	@ConditionalOnMissingBean
	ReactivePulsarTemplate<?> pulsarReactiveTemplate(ReactivePulsarSenderFactory<?> reactivePulsarSenderFactory,
			SchemaResolver schemaResolver, TopicResolver topicResolver) {
		return new ReactivePulsarTemplate<>(reactivePulsarSenderFactory, schemaResolver, topicResolver);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableReactivePulsar
	@ConditionalOnMissingBean(
			name = PulsarAnnotationSupportBeanNames.REACTIVE_PULSAR_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)
	static class EnableReactivePulsarConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
@AutoConfiguration
@ConditionalOnClass({ freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class })
@EnableConfigurationProperties(FreeMarkerProperties.class)
@Import({ FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class,
		FreeMarkerNonWebConfiguration.class })
public class FreeMarkerAutoConfiguration {
	private static final Log logger = LogFactory.getLog(FreeMarkerAutoConfiguration.class);
	private final ApplicationContext applicationContext;
	private final FreeMarkerProperties properties;
	public FreeMarkerAutoConfiguration(ApplicationContext applicationContext, FreeMarkerProperties properties) {
		this.applicationContext = applicationContext;
		this.properties = properties;
		checkTemplateLocationExists();
	}
	public void checkTemplateLocationExists() {
		if (logger.isWarnEnabled() && this.properties.isCheckTemplateLocation()) {
			List<TemplateLocation> locations = getLocations();
			if (locations.stream().noneMatch(this::locationExists)) {
				String suffix = (locations.size() == 1) ? '' : 's';
				logger.warn('Cannot find template location' + suffix + ': ' + locations
						+ ' (please add some templates, ' + 'check your FreeMarker configuration, or set '
						+ 'spring.freemarker.check-template-location=false)');
			}
		}
	}
	private List<TemplateLocation> getLocations() {
		List<TemplateLocation> locations = new ArrayList<>();
		for (String templateLoaderPath : this.properties.getTemplateLoaderPath()) {
			TemplateLocation location = new TemplateLocation(templateLoaderPath);
			locations.add(location);
		}
		return locations;
	}
	private boolean locationExists(TemplateLocation location) {
		return location.exists(this.applicationContext);
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnNotWebApplication
class FreeMarkerNonWebConfiguration extends AbstractFreeMarkerConfiguration {
	FreeMarkerNonWebConfiguration(FreeMarkerProperties properties,
			ObjectProvider<FreeMarkerVariablesCustomizer> variablesCustomizers) {
		super(properties, variablesCustomizers);
	}
	@Bean
	@ConditionalOnMissingBean
	FreeMarkerConfigurationFactoryBean freeMarkerConfiguration() {
		FreeMarkerConfigurationFactoryBean freeMarkerFactoryBean = new FreeMarkerConfigurationFactoryBean();
		applyProperties(freeMarkerFactoryBean);
		return freeMarkerFactoryBean;
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@AutoConfigureAfter(WebFluxAutoConfiguration.class)
class FreeMarkerReactiveWebConfiguration extends AbstractFreeMarkerConfiguration {
	FreeMarkerReactiveWebConfiguration(FreeMarkerProperties properties,
			ObjectProvider<FreeMarkerVariablesCustomizer> variablesCustomizers) {
		super(properties, variablesCustomizers);
	}
	@Bean
	@ConditionalOnMissingBean(FreeMarkerConfig.class)
	FreeMarkerConfigurer freeMarkerConfigurer() {
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		applyProperties(configurer);
		return configurer;
	}
	@Bean
	freemarker.template.Configuration freeMarkerConfiguration(FreeMarkerConfig configurer) {
		return configurer.getConfiguration();
	}
	@Bean
	@ConditionalOnMissingBean(name = 'freeMarkerViewResolver')
	@ConditionalOnProperty(name = 'spring.freemarker.enabled', matchIfMissing = true)
	FreeMarkerViewResolver freeMarkerViewResolver() {
		FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();
		resolver.setPrefix(getProperties().getPrefix());
		resolver.setSuffix(getProperties().getSuffix());
		resolver.setRequestContextAttribute(getProperties().getRequestContextAttribute());
		resolver.setViewNames(getProperties().getViewNames());
		return resolver;
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass({ Servlet.class, FreeMarkerConfigurer.class })
@AutoConfigureAfter(WebMvcAutoConfiguration.class)
class FreeMarkerServletWebConfiguration extends AbstractFreeMarkerConfiguration {
	protected FreeMarkerServletWebConfiguration(FreeMarkerProperties properties,
			ObjectProvider<FreeMarkerVariablesCustomizer> variablesCustomizers) {
		super(properties, variablesCustomizers);
	}
	@Bean
	@ConditionalOnMissingBean(FreeMarkerConfig.class)
	FreeMarkerConfigurer freeMarkerConfigurer() {
		FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();
		applyProperties(configurer);
		return configurer;
	}
	@Bean
	freemarker.template.Configuration freeMarkerConfiguration(FreeMarkerConfig configurer) {
		return configurer.getConfiguration();
	}
	@Bean
	@ConditionalOnMissingBean(name = 'freeMarkerViewResolver')
	@ConditionalOnProperty(name = 'spring.freemarker.enabled', matchIfMissing = true)
	FreeMarkerViewResolver freeMarkerViewResolver() {
		FreeMarkerViewResolver resolver = new FreeMarkerViewResolver();
		getProperties().applyToMvcViewResolver(resolver);
		return resolver;
	}
	@Bean
	@ConditionalOnEnabledResourceChain
	@ConditionalOnMissingFilterBean(ResourceUrlEncodingFilter.class)
	FilterRegistrationBean<ResourceUrlEncodingFilter> resourceUrlEncodingFilter() {
		FilterRegistrationBean<ResourceUrlEncodingFilter> registration = new FilterRegistrationBean<>(
				new ResourceUrlEncodingFilter());
		registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR);
		return registration;
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
@FunctionalInterface
public interface FreeMarkerVariablesCustomizer {
	/**
	 * Customize the {@code variables} to be set as well-known FreeMarker objects.
	 * @param variables the variables to customize
	 * @see FreeMarkerConfigurationFactory#setFreemarkerVariables(Map)
	 */
	void customizeFreeMarkerVariables(Map<String, Object> variables);
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
abstract class AbstractFreeMarkerConfiguration {
	private final FreeMarkerProperties properties;
	private final List<FreeMarkerVariablesCustomizer> variablesCustomizers;
	protected AbstractFreeMarkerConfiguration(FreeMarkerProperties properties,
			ObjectProvider<FreeMarkerVariablesCustomizer> variablesCustomizers) {
		this.properties = properties;
		this.variablesCustomizers = variablesCustomizers.orderedStream().toList();
	}
	protected final FreeMarkerProperties getProperties() {
		return this.properties;
	}
	protected void applyProperties(FreeMarkerConfigurationFactory factory) {
		factory.setTemplateLoaderPaths(this.properties.getTemplateLoaderPath());
		factory.setPreferFileSystemAccess(this.properties.isPreferFileSystemAccess());
		factory.setDefaultEncoding(this.properties.getCharsetName());
		factory.setFreemarkerSettings(createFreeMarkerSettings());
		factory.setFreemarkerVariables(createFreeMarkerVariables());
	}
	private Properties createFreeMarkerSettings() {
		Properties settings = new Properties();
		settings.put('recognize_standard_file_extensions', 'true');
		settings.putAll(this.properties.getSettings());
		return settings;
	}
	private Map<String, Object> createFreeMarkerVariables() {
		Map<String, Object> variables = new HashMap<>();
		for (FreeMarkerVariablesCustomizer customizer : this.variablesCustomizers) {
			customizer.customizeFreeMarkerVariables(variables);
		}
		return variables;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.freemarker;
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
public class FreeMarkerTemplateAvailabilityProvider extends PathBasedTemplateAvailabilityProvider {
	private static final String REQUIRED_CLASS_NAME = 'freemarker.template.Configuration';
	public FreeMarkerTemplateAvailabilityProvider() {
		super(REQUIRED_CLASS_NAME, FreeMarkerTemplateAvailabilityProperties.class, 'spring.freemarker');
	}
	protected static final class FreeMarkerTemplateAvailabilityProperties extends TemplateAvailabilityProperties {
		private List<String> templateLoaderPath = new ArrayList<>(
				Arrays.asList(FreeMarkerProperties.DEFAULT_TEMPLATE_LOADER_PATH));
		FreeMarkerTemplateAvailabilityProperties() {
			super(FreeMarkerProperties.DEFAULT_PREFIX, FreeMarkerProperties.DEFAULT_SUFFIX);
		}
		@Override
		protected List<String> getLoaderPath() {
			return this.templateLoaderPath;
		}
		public List<String> getTemplateLoaderPath() {
			return this.templateLoaderPath;
		}
		public void setTemplateLoaderPath(List<String> templateLoaderPath) {
			this.templateLoaderPath = templateLoaderPath;
		}
	}
	static class FreeMarkerTemplateAvailabilityRuntimeHints extends BindableRuntimeHintsRegistrar {
		FreeMarkerTemplateAvailabilityRuntimeHints() {
			super(FreeMarkerTemplateAvailabilityProperties.class);
		}
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			if (ClassUtils.isPresent(REQUIRED_CLASS_NAME, classLoader)) {
				super.registerHints(hints, classLoader);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
@ConfigurationProperties(prefix = 'spring.freemarker')
public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties {
	public static final String DEFAULT_TEMPLATE_LOADER_PATH = 'classpath:/templates/';
	public static final String DEFAULT_PREFIX = '';
	public static final String DEFAULT_SUFFIX = '.ftlh';
	/**
	 * Well-known FreeMarker keys which are passed to FreeMarker"s Configuration.
	 */
	private Map<String, String> settings = new HashMap<>();
	/**
	 * List of template paths.
	 */
	private String[] templateLoaderPath = new String[] { DEFAULT_TEMPLATE_LOADER_PATH };
	/**
	 * Whether to prefer file system access for template loading to enable hot detection
	 * of template changes. When a template path is detected as a directory, templates are
	 * loaded from the directory only and other matching classpath locations will not be
	 * considered.
	 */
	private boolean preferFileSystemAccess;
	public FreeMarkerProperties() {
		super(DEFAULT_PREFIX, DEFAULT_SUFFIX);
	}
	public Map<String, String> getSettings() {
		return this.settings;
	}
	public void setSettings(Map<String, String> settings) {
		this.settings = settings;
	}
	public String[] getTemplateLoaderPath() {
		return this.templateLoaderPath;
	}
	public void setTemplateLoaderPath(String... templateLoaderPaths) {
		this.templateLoaderPath = templateLoaderPaths;
	}
	public boolean isPreferFileSystemAccess() {
		return this.preferFileSystemAccess;
	}
	public void setPreferFileSystemAccess(boolean preferFileSystemAccess) {
		this.preferFileSystemAccess = preferFileSystemAccess;
	}
}
/*
package org.springframework.boot.autoconfigure.data.jdbc;
/**
@ConfigurationProperties(prefix = 'spring.data.jdbc')
public class JdbcDataProperties {
	/**
	 * Dialect to use. By default, the dialect is determined by inspecting the database
	 * connection.
	 */
	private JdbcDatabaseDialect dialect;
	public JdbcDatabaseDialect getDialect() {
		return this.dialect;
	}
	public void setDialect(JdbcDatabaseDialect dialect) {
		this.dialect = dialect;
	}
}
/*
package org.springframework.boot.autoconfigure.data.jdbc;
/**
@AutoConfiguration(after = { JdbcTemplateAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class })
@ConditionalOnBean({ NamedParameterJdbcOperations.class, PlatformTransactionManager.class })
@ConditionalOnClass({ NamedParameterJdbcOperations.class, AbstractJdbcConfiguration.class })
@ConditionalOnProperty(prefix = 'spring.data.jdbc.repositories', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
@EnableConfigurationProperties(JdbcDataProperties.class)
public class JdbcRepositoriesAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(JdbcRepositoryConfigExtension.class)
	@Import(JdbcRepositoriesRegistrar.class)
	static class JdbcRepositoriesConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(AbstractJdbcConfiguration.class)
	static class SpringBootJdbcConfiguration extends AbstractJdbcConfiguration {
		private final ApplicationContext applicationContext;
		private final JdbcDataProperties properties;
		SpringBootJdbcConfiguration(ApplicationContext applicationContext, JdbcDataProperties properties) {
			this.applicationContext = applicationContext;
			this.properties = properties;
		}
		@Override
		protected Set<Class<?>> getInitialEntitySet() throws ClassNotFoundException {
			return new EntityScanner(this.applicationContext).scan(Table.class);
		}
		@Override
		@Bean
		@ConditionalOnMissingBean
		public RelationalManagedTypes jdbcManagedTypes() throws ClassNotFoundException {
			return super.jdbcManagedTypes();
		}
		@Override
		@Bean
		@ConditionalOnMissingBean
		public JdbcMappingContext jdbcMappingContext(Optional<NamingStrategy> namingStrategy,
				JdbcCustomConversions customConversions, RelationalManagedTypes jdbcManagedTypes) {
			return super.jdbcMappingContext(namingStrategy, customConversions, jdbcManagedTypes);
		}
		@Override
		@Bean
		@ConditionalOnMissingBean
		public JdbcConverter jdbcConverter(JdbcMappingContext mappingContext, NamedParameterJdbcOperations operations,
				@Lazy RelationResolver relationResolver, JdbcCustomConversions conversions, Dialect dialect) {
			return super.jdbcConverter(mappingContext, operations, relationResolver, conversions, dialect);
		}
		@Override
		@Bean
		@ConditionalOnMissingBean
		public JdbcCustomConversions jdbcCustomConversions() {
			return super.jdbcCustomConversions();
		}
		@Override
		@Bean
		@ConditionalOnMissingBean
		public JdbcAggregateTemplate jdbcAggregateTemplate(ApplicationContext applicationContext,
				JdbcMappingContext mappingContext, JdbcConverter converter, DataAccessStrategy dataAccessStrategy) {
			return super.jdbcAggregateTemplate(applicationContext, mappingContext, converter, dataAccessStrategy);
		}
		@Override
		@Bean
		@ConditionalOnMissingBean
		public DataAccessStrategy dataAccessStrategyBean(NamedParameterJdbcOperations operations,
				JdbcConverter jdbcConverter, JdbcMappingContext context, Dialect dialect) {
			return super.dataAccessStrategyBean(operations, jdbcConverter, context, dialect);
		}
		@Override
		@Bean
		@ConditionalOnMissingBean
		public Dialect jdbcDialect(NamedParameterJdbcOperations operations) {
			JdbcDatabaseDialect dialect = this.properties.getDialect();
			return (dialect != null) ? dialect.getDialect() : super.jdbcDialect(operations);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.jdbc;
/**
public enum JdbcDatabaseDialect {
	/**
	 * Provides an instance of {@link JdbcDb2Dialect}.
	 */
	DB2(JdbcDb2Dialect.INSTANCE),
	/**
	 * Provides an instance of {@link H2Dialect}.
	 */
	H2(H2Dialect.INSTANCE),
	/**
	 * Provides an instance of {@link HsqlDbDialect}.
	 */
	HSQL(HsqlDbDialect.INSTANCE),
	/**
	 * Provides an instance of {@link MariaDbDialect}.
	 */
	MARIA(MySqlDialect.INSTANCE),
	/**
	 * Provides an instance of {@link JdbcMySqlDialect}.
	 */
	MYSQL(MySqlDialect.INSTANCE),
	/**
	 * Provides an instance of {@link OracleDialect}.
	 */
	ORACLE(OracleDialect.INSTANCE),
	/**
	 * Provides an instance of {@link JdbcPostgresDialect}.
	 */
	POSTGRESQL(JdbcPostgresDialect.INSTANCE),
	/**
	 * Provides an instance of {@link JdbcSqlServerDialect}.
	 */
	SQL_SERVER(JdbcSqlServerDialect.INSTANCE);
	private final Dialect dialect;
	JdbcDatabaseDialect(Dialect dialect) {
		this.dialect = dialect;
	}
	final Dialect getDialect() {
		return this.dialect;
	}
}
/*
package org.springframework.boot.autoconfigure.data.jdbc;
/**
class JdbcRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableJdbcRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableJdbcRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new JdbcRepositoryConfigExtension();
	}
	@EnableJdbcRepositories
	private static final class EnableJdbcRepositoriesConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.jdbc;
/*
package org.springframework.boot.autoconfigure.data;
/**
public enum RepositoryType {
	/**
	 * Enables all repository types automatically based on their availability.
	 */
	AUTO,
	/**
	 * Enables imperative repositories.
	 */
	IMPERATIVE,
	/**
	 * Enables no repositories.
	 */
	NONE,
	/**
	 * Enables reactive repositories.
	 */
	REACTIVE
}
/*
package org.springframework.boot.autoconfigure.data.web;
/**
@AutoConfiguration(after = RepositoryRestMvcAutoConfiguration.class)
@EnableSpringDataWebSupport
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ PageableHandlerMethodArgumentResolver.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(PageableHandlerMethodArgumentResolver.class)
@EnableConfigurationProperties(SpringDataWebProperties.class)
public class SpringDataWebAutoConfiguration {
	private final SpringDataWebProperties properties;
	public SpringDataWebAutoConfiguration(SpringDataWebProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	public PageableHandlerMethodArgumentResolverCustomizer pageableCustomizer() {
		return (resolver) -> {
			Pageable pageable = this.properties.getPageable();
			resolver.setPageParameterName(pageable.getPageParameter());
			resolver.setSizeParameterName(pageable.getSizeParameter());
			resolver.setOneIndexedParameters(pageable.isOneIndexedParameters());
			resolver.setPrefix(pageable.getPrefix());
			resolver.setQualifierDelimiter(pageable.getQualifierDelimiter());
			resolver.setFallbackPageable(PageRequest.of(0, pageable.getDefaultPageSize()));
			resolver.setMaxPageSize(pageable.getMaxPageSize());
		};
	}
	@Bean
	@ConditionalOnMissingBean
	public SortHandlerMethodArgumentResolverCustomizer sortCustomizer() {
		return (resolver) -> resolver.setSortParameter(this.properties.getSort().getSortParameter());
	}
	@Bean
	@ConditionalOnMissingBean
	public SpringDataWebSettings springDataWebSettings() {
		return new SpringDataWebSettings(this.properties.getPageable().getSerializationMode());
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.web;
/*
package org.springframework.boot.autoconfigure.data.web;
/**
@ConfigurationProperties('spring.data.web')
public class SpringDataWebProperties {
	private final Pageable pageable = new Pageable();
	private final Sort sort = new Sort();
	public Pageable getPageable() {
		return this.pageable;
	}
	public Sort getSort() {
		return this.sort;
	}
	/**
	 * Pageable properties.
	 */
	public static class Pageable {
		/**
		 * Page index parameter name.
		 */
		private String pageParameter = 'page';
		/**
		 * Page size parameter name.
		 */
		private String sizeParameter = 'size';
		/**
		 * Whether to expose and assume 1-based page number indexes. Defaults to 'false',
		 * meaning a page number of 0 in the request equals the first page.
		 */
		private boolean oneIndexedParameters = false;
		/**
		 * General prefix to be prepended to the page number and page size parameters.
		 */
		private String prefix = '';
		/**
		 * Delimiter to be used between the qualifier and the actual page number and size
		 * properties.
		 */
		private String qualifierDelimiter = '_';
		/**
		 * Default page size.
		 */
		private int defaultPageSize = 20;
		/**
		 * Maximum page size to be accepted.
		 */
		private int maxPageSize = 2000;
		/**
		 * Configures how to render Spring Data Pageable instances.
		 */
		private PageSerializationMode serializationMode = PageSerializationMode.DIRECT;
		public String getPageParameter() {
			return this.pageParameter;
		}
		public void setPageParameter(String pageParameter) {
			this.pageParameter = pageParameter;
		}
		public String getSizeParameter() {
			return this.sizeParameter;
		}
		public void setSizeParameter(String sizeParameter) {
			this.sizeParameter = sizeParameter;
		}
		public boolean isOneIndexedParameters() {
			return this.oneIndexedParameters;
		}
		public void setOneIndexedParameters(boolean oneIndexedParameters) {
			this.oneIndexedParameters = oneIndexedParameters;
		}
		public String getPrefix() {
			return this.prefix;
		}
		public void setPrefix(String prefix) {
			this.prefix = prefix;
		}
		public String getQualifierDelimiter() {
			return this.qualifierDelimiter;
		}
		public void setQualifierDelimiter(String qualifierDelimiter) {
			this.qualifierDelimiter = qualifierDelimiter;
		}
		public int getDefaultPageSize() {
			return this.defaultPageSize;
		}
		public void setDefaultPageSize(int defaultPageSize) {
			this.defaultPageSize = defaultPageSize;
		}
		public int getMaxPageSize() {
			return this.maxPageSize;
		}
		public void setMaxPageSize(int maxPageSize) {
			this.maxPageSize = maxPageSize;
		}
		public PageSerializationMode getSerializationMode() {
			return this.serializationMode;
		}
		public void setSerializationMode(PageSerializationMode serializationMode) {
			this.serializationMode = serializationMode;
		}
	}
	/**
	 * Sort properties.
	 */
	public static class Sort {
		/**
		 * Sort parameter name.
		 */
		private String sortParameter = 'sort';
		public String getSortParameter() {
			return this.sortParameter;
		}
		public void setSortParameter(String sortParameter) {
			this.sortParameter = sortParameter;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
@AutoConfiguration(after = CassandraDataAutoConfiguration.class)
@ConditionalOnClass({ CqlSession.class, ReactiveCassandraTemplate.class, Flux.class })
@ConditionalOnBean(CqlSession.class)
public class CassandraReactiveDataAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ReactiveSession reactiveCassandraSession(CqlSession session) {
		return new DefaultBridgedReactiveSession(session);
	}
	@Bean
	@ConditionalOnMissingBean
	public ReactiveSessionFactory reactiveCassandraSessionFactory(ReactiveSession reactiveCassandraSession) {
		return new DefaultReactiveSessionFactory(reactiveCassandraSession);
	}
	@Bean
	@ConditionalOnMissingBean(ReactiveCassandraOperations.class)
	public ReactiveCassandraTemplate reactiveCassandraTemplate(ReactiveSession reactiveCassandraSession,
			CassandraConverter converter) {
		return new ReactiveCassandraTemplate(reactiveCassandraSession, converter);
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
@AutoConfiguration(after = CassandraReactiveDataAutoConfiguration.class)
@ConditionalOnClass({ ReactiveSession.class, ReactiveCassandraRepository.class })
@ConditionalOnRepositoryType(store = 'cassandra', type = RepositoryType.REACTIVE)
@ConditionalOnMissingBean(ReactiveCassandraRepositoryFactoryBean.class)
@Import(CassandraReactiveRepositoriesRegistrar.class)
public class CassandraReactiveRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
@AutoConfiguration(after = CassandraAutoConfiguration.class)
@ConditionalOnClass({ CqlSession.class, CassandraAdminOperations.class })
@ConditionalOnBean(CqlSession.class)
public class CassandraDataAutoConfiguration {
	private final CqlSession session;
	public CassandraDataAutoConfiguration(@Lazy CqlSession session) {
		this.session = session;
	}
	@Bean
	@ConditionalOnMissingBean
	public static CassandraManagedTypes cassandraManagedTypes(BeanFactory beanFactory) throws ClassNotFoundException {
		List<String> packages = EntityScanPackages.get(beanFactory).getPackageNames();
		if (packages.isEmpty() && AutoConfigurationPackages.has(beanFactory)) {
			packages = AutoConfigurationPackages.get(beanFactory);
		}
		if (!packages.isEmpty()) {
			return CassandraManagedTypes.fromIterable(CassandraEntityClassScanner.scan(packages));
		}
		return CassandraManagedTypes.empty();
	}
	@Bean
	@ConditionalOnMissingBean
	public CassandraMappingContext cassandraMappingContext(CassandraManagedTypes cassandraManagedTypes,
			CassandraCustomConversions conversions) {
		CassandraMappingContext context = new CassandraMappingContext();
		context.setManagedTypes(cassandraManagedTypes);
		context.setSimpleTypeHolder(conversions.getSimpleTypeHolder());
		return context;
	}
	@Bean
	@ConditionalOnMissingBean
	public CassandraConverter cassandraConverter(CassandraMappingContext mapping,
			CassandraCustomConversions conversions) {
		MappingCassandraConverter converter = new MappingCassandraConverter(mapping);
		converter.setCodecRegistry(() -> this.session.getContext().getCodecRegistry());
		converter.setCustomConversions(conversions);
		converter.setUserTypeResolver(new SimpleUserTypeResolver(this.session));
		return converter;
	}
	@Bean
	@ConditionalOnMissingBean(SessionFactory.class)
	public SessionFactoryFactoryBean cassandraSessionFactory(Environment environment, CassandraConverter converter) {
		SessionFactoryFactoryBean session = new SessionFactoryFactoryBean();
		session.setSession(this.session);
		session.setConverter(converter);
		Binder binder = Binder.get(environment);
		binder.bind('spring.cassandra.schema-action', SchemaAction.class).ifBound(session::setSchemaAction);
		return session;
	}
	@Bean
	@ConditionalOnMissingBean(CassandraOperations.class)
	public CassandraTemplate cassandraTemplate(SessionFactory sessionFactory, CassandraConverter converter) {
		return new CassandraTemplate(sessionFactory, converter);
	}
	@Bean
	@ConditionalOnMissingBean
	public CassandraCustomConversions cassandraCustomConversions() {
		return new CassandraCustomConversions(Collections.emptyList());
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
class CassandraRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableCassandraRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableCassandraRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new CassandraRepositoryConfigurationExtension();
	}
	@EnableCassandraRepositories
	private static final class EnableCassandraRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
class CassandraReactiveRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableReactiveCassandraRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableReactiveCassandraRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new ReactiveCassandraRepositoryConfigurationExtension();
	}
	@EnableReactiveCassandraRepositories
	private static final class EnableReactiveCassandraRepositoriesConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.cassandra;
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
@AutoConfiguration
@ConditionalOnClass({ CqlSession.class, CassandraRepository.class })
@ConditionalOnRepositoryType(store = 'cassandra', type = RepositoryType.IMPERATIVE)
@ConditionalOnMissingBean(CassandraRepositoryFactoryBean.class)
@Import(CassandraRepositoriesRegistrar.class)
public class CassandraRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableCouchbaseRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableCouchbaseRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new CouchbaseRepositoryConfigurationExtension();
	}
	@EnableCouchbaseRepositories
	private static final class EnableCouchbaseRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseReactiveRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableReactiveCouchbaseRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableReactiveCouchbaseRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new ReactiveCouchbaseRepositoryConfigurationExtension();
	}
	@EnableReactiveCouchbaseRepositories
	private static final class EnableReactiveCouchbaseRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@AutoConfiguration(after = { CouchbaseAutoConfiguration.class, ValidationAutoConfiguration.class })
@ConditionalOnClass({ Bucket.class, CouchbaseRepository.class })
@EnableConfigurationProperties(CouchbaseDataProperties.class)
@Import({ CouchbaseDataConfiguration.class, CouchbaseClientFactoryConfiguration.class,
		CouchbaseClientFactoryDependentConfiguration.class })
public class CouchbaseDataAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Validator.class)
	public static class ValidationConfiguration {
		@Bean
		@ConditionalOnSingleCandidate(Validator.class)
		public ValidatingCouchbaseEventListener validationEventListener(Validator validator) {
			return new ValidatingCouchbaseEventListener(validator);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@AutoConfiguration
@ConditionalOnClass({ Bucket.class, CouchbaseRepository.class })
@ConditionalOnBean(RepositoryOperationsMapping.class)
@ConditionalOnRepositoryType(store = 'couchbase', type = RepositoryType.IMPERATIVE)
@ConditionalOnMissingBean(CouchbaseRepositoryFactoryBean.class)
@Import(CouchbaseRepositoriesRegistrar.class)
public class CouchbaseRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnSingleCandidate(CouchbaseClientFactory.class)
class CouchbaseReactiveDataConfiguration {
	@Bean(name = BeanNames.REACTIVE_COUCHBASE_TEMPLATE)
	@ConditionalOnMissingBean(name = BeanNames.REACTIVE_COUCHBASE_TEMPLATE)
	ReactiveCouchbaseTemplate reactiveCouchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
			MappingCouchbaseConverter mappingCouchbaseConverter) {
		return new ReactiveCouchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter);
	}
	@Bean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
	@ConditionalOnMissingBean(name = BeanNames.REACTIVE_COUCHBASE_OPERATIONS_MAPPING)
	ReactiveRepositoryOperationsMapping reactiveCouchbaseRepositoryOperationsMapping(
			ReactiveCouchbaseTemplate reactiveCouchbaseTemplate) {
		return new ReactiveRepositoryOperationsMapping(reactiveCouchbaseTemplate);
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@AutoConfiguration(after = CouchbaseDataAutoConfiguration.class)
@ConditionalOnClass({ Cluster.class, ReactiveCouchbaseRepository.class, Flux.class })
@Import(CouchbaseReactiveDataConfiguration.class)
public class CouchbaseReactiveDataAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@AutoConfiguration(after = CouchbaseReactiveDataAutoConfiguration.class)
@ConditionalOnClass({ Cluster.class, ReactiveCouchbaseRepository.class, Flux.class })
@ConditionalOnRepositoryType(store = 'couchbase', type = RepositoryType.REACTIVE)
@ConditionalOnBean(ReactiveRepositoryOperationsMapping.class)
@ConditionalOnMissingBean(ReactiveCouchbaseRepositoryFactoryBean.class)
@Import(CouchbaseReactiveRepositoriesRegistrar.class)
public class CouchbaseReactiveRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnSingleCandidate(Cluster.class)
@ConditionalOnProperty('spring.data.couchbase.bucket-name')
class CouchbaseClientFactoryConfiguration {
	@Bean
	@ConditionalOnMissingBean
	CouchbaseClientFactory couchbaseClientFactory(Cluster cluster, CouchbaseDataProperties properties) {
		return new SimpleCouchbaseClientFactory(cluster, properties.getBucketName(), properties.getScopeName());
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@Configuration(proxyBeanMethods = false)
class CouchbaseDataConfiguration {
	@Bean
	@ConditionalOnMissingBean
	MappingCouchbaseConverter couchbaseMappingConverter(CouchbaseDataProperties properties,
			CouchbaseMappingContext couchbaseMappingContext, CouchbaseCustomConversions couchbaseCustomConversions) {
		MappingCouchbaseConverter converter = new MappingCouchbaseConverter(couchbaseMappingContext,
				properties.getTypeKey());
		converter.setCustomConversions(couchbaseCustomConversions);
		return converter;
	}
	@Bean
	@ConditionalOnMissingBean
	TranslationService couchbaseTranslationService() {
		return new JacksonTranslationService();
	}
	@Bean(name = BeanNames.COUCHBASE_MAPPING_CONTEXT)
	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_MAPPING_CONTEXT)
	CouchbaseMappingContext couchbaseMappingContext(CouchbaseDataProperties properties,
			ApplicationContext applicationContext, CouchbaseCustomConversions couchbaseCustomConversions)
			throws ClassNotFoundException {
		CouchbaseMappingContext mappingContext = new CouchbaseMappingContext();
		mappingContext.setInitialEntitySet(new EntityScanner(applicationContext).scan(Document.class));
		mappingContext.setSimpleTypeHolder(couchbaseCustomConversions.getSimpleTypeHolder());
		Class<?> fieldNamingStrategy = properties.getFieldNamingStrategy();
		if (fieldNamingStrategy != null) {
			mappingContext
				.setFieldNamingStrategy((FieldNamingStrategy) BeanUtils.instantiateClass(fieldNamingStrategy));
		}
		mappingContext.setAutoIndexCreation(properties.isAutoIndex());
		return mappingContext;
	}
	@Bean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
	CouchbaseCustomConversions couchbaseCustomConversions() {
		return new CouchbaseCustomConversions(Collections.emptyList());
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@ConfigurationProperties(prefix = 'spring.data.couchbase')
public class CouchbaseDataProperties {
	/**
	 * Automatically create views and indexes. Use the meta-data provided by
	 * '@ViewIndexed', '@N1qlPrimaryIndexed' and '@N1qlSecondaryIndexed'.
	 */
	private boolean autoIndex;
	/**
	 * Name of the bucket to connect to.
	 */
	private String bucketName;
	/**
	 * Name of the scope used for all collection access.
	 */
	private String scopeName;
	/**
	 * Fully qualified name of the FieldNamingStrategy to use.
	 */
	private Class<?> fieldNamingStrategy;
	/**
	 * Name of the field that stores the type information for complex types when using
	 * 'MappingCouchbaseConverter'.
	 */
	private String typeKey = '_class';
	public boolean isAutoIndex() {
		return this.autoIndex;
	}
	public void setAutoIndex(boolean autoIndex) {
		this.autoIndex = autoIndex;
	}
	public String getBucketName() {
		return this.bucketName;
	}
	public void setBucketName(String bucketName) {
		this.bucketName = bucketName;
	}
	public String getScopeName() {
		return this.scopeName;
	}
	public void setScopeName(String scopeName) {
		this.scopeName = scopeName;
	}
	public Class<?> getFieldNamingStrategy() {
		return this.fieldNamingStrategy;
	}
	public void setFieldNamingStrategy(Class<?> fieldNamingStrategy) {
		this.fieldNamingStrategy = fieldNamingStrategy;
	}
	public String getTypeKey() {
		return this.typeKey;
	}
	public void setTypeKey(String typeKey) {
		this.typeKey = typeKey;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.couchbase;
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnSingleCandidate(CouchbaseClientFactory.class)
class CouchbaseClientFactoryDependentConfiguration {
	@Bean(name = BeanNames.COUCHBASE_TEMPLATE)
	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_TEMPLATE)
	CouchbaseTemplate couchbaseTemplate(CouchbaseClientFactory couchbaseClientFactory,
			MappingCouchbaseConverter mappingCouchbaseConverter) {
		return new CouchbaseTemplate(couchbaseClientFactory, mappingCouchbaseConverter);
	}
	@Bean(name = BeanNames.COUCHBASE_OPERATIONS_MAPPING)
	@ConditionalOnMissingBean(name = BeanNames.COUCHBASE_OPERATIONS_MAPPING)
	RepositoryOperationsMapping couchbaseRepositoryOperationsMapping(CouchbaseTemplate couchbaseTemplate) {
		return new RepositoryOperationsMapping(couchbaseTemplate);
	}
}
/*
package org.springframework.boot.autoconfigure.data;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnRepositoryTypeCondition.class)
public @interface ConditionalOnRepositoryType {
	/**
	 * The name of the store that backs the repositories.
	 * @return the store
	 */
	String store();
	/**
	 * The required repository type.
	 * @return the required repository type
	 */
	RepositoryType type();
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
@AutoConfiguration(after = Neo4jDataAutoConfiguration.class)
@ConditionalOnClass({ Driver.class, ReactiveNeo4jTemplate.class, ReactiveTransactionManager.class, Flux.class })
@ConditionalOnBean(Driver.class)
public class Neo4jReactiveDataAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ReactiveDatabaseSelectionProvider reactiveDatabaseSelectionProvider(Neo4jDataProperties dataProperties) {
		String database = dataProperties.getDatabase();
		return (database != null) ? ReactiveDatabaseSelectionProvider.createStaticDatabaseSelectionProvider(database)
				: ReactiveDatabaseSelectionProvider.getDefaultSelectionProvider();
	}
	@Bean(ReactiveNeo4jRepositoryConfigurationExtension.DEFAULT_NEO4J_CLIENT_BEAN_NAME)
	@ConditionalOnMissingBean
	public ReactiveNeo4jClient reactiveNeo4jClient(Driver driver,
			ReactiveDatabaseSelectionProvider databaseNameProvider) {
		return ReactiveNeo4jClient.create(driver, databaseNameProvider);
	}
	@Bean(ReactiveNeo4jRepositoryConfigurationExtension.DEFAULT_NEO4J_TEMPLATE_BEAN_NAME)
	@ConditionalOnMissingBean(ReactiveNeo4jOperations.class)
	public ReactiveNeo4jTemplate reactiveNeo4jTemplate(ReactiveNeo4jClient neo4jClient,
			Neo4jMappingContext neo4jMappingContext) {
		return new ReactiveNeo4jTemplate(neo4jClient, neo4jMappingContext);
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
@AutoConfiguration(after = Neo4jDataAutoConfiguration.class)
@ConditionalOnClass({ Driver.class, Neo4jRepository.class })
@ConditionalOnMissingBean({ Neo4jRepositoryFactoryBean.class, Neo4jRepositoryConfigurationExtension.class })
@ConditionalOnRepositoryType(store = 'neo4j', type = RepositoryType.IMPERATIVE)
@Import(Neo4jRepositoriesRegistrar.class)
public class Neo4jRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
class Neo4jReactiveRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableReactiveNeo4jRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableReactiveNeo4jRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new ReactiveNeo4jRepositoryConfigurationExtension();
	}
	@EnableReactiveNeo4jRepositories
	private static final class EnableReactiveNeo4jRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
class Neo4jRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableNeo4jRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableNeo4jRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new Neo4jRepositoryConfigurationExtension();
	}
	@EnableNeo4jRepositories
	private static final class EnableNeo4jRepositoriesConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.neo4j;
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
@ConfigurationProperties(prefix = 'spring.data.neo4j')
public class Neo4jDataProperties {
	/**
	 * Database name to use. By default, the server decides the default database to use.
	 */
	private String database;
	public String getDatabase() {
		return this.database;
	}
	public void setDatabase(String database) {
		this.database = database;
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
@AutoConfiguration(after = Neo4jReactiveDataAutoConfiguration.class)
@ConditionalOnClass({ Driver.class, ReactiveNeo4jRepository.class, Flux.class })
@ConditionalOnMissingBean({ ReactiveNeo4jRepositoryFactoryBean.class,
		ReactiveNeo4jRepositoryConfigurationExtension.class })
@ConditionalOnRepositoryType(store = 'neo4j', type = RepositoryType.REACTIVE)
@Import(Neo4jReactiveRepositoriesRegistrar.class)
public class Neo4jReactiveRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
@AutoConfiguration(before = TransactionAutoConfiguration.class,
		after = { Neo4jAutoConfiguration.class, TransactionManagerCustomizationAutoConfiguration.class })
@ConditionalOnClass({ Driver.class, Neo4jTransactionManager.class, PlatformTransactionManager.class })
@EnableConfigurationProperties(Neo4jDataProperties.class)
@ConditionalOnBean(Driver.class)
public class Neo4jDataAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public Neo4jConversions neo4jConversions() {
		return new Neo4jConversions();
	}
	@Bean
	@ConditionalOnMissingBean
	Neo4jManagedTypes neo4jManagedTypes(ApplicationContext applicationContext) throws ClassNotFoundException {
		Set<Class<?>> initialEntityClasses = new EntityScanner(applicationContext).scan(Node.class,
				RelationshipProperties.class);
		return Neo4jManagedTypes.fromIterable(initialEntityClasses);
	}
	@Bean
	@ConditionalOnMissingBean
	public Neo4jMappingContext neo4jMappingContext(Neo4jManagedTypes managedTypes, Neo4jConversions neo4jConversions) {
		Neo4jMappingContext context = new Neo4jMappingContext(neo4jConversions);
		context.setManagedTypes(managedTypes);
		return context;
	}
	@Bean
	@ConditionalOnMissingBean
	public DatabaseSelectionProvider databaseSelectionProvider(Neo4jDataProperties properties) {
		String database = properties.getDatabase();
		return (database != null) ? DatabaseSelectionProvider.createStaticDatabaseSelectionProvider(database)
				: DatabaseSelectionProvider.getDefaultSelectionProvider();
	}
	@Bean(Neo4jRepositoryConfigurationExtension.DEFAULT_NEO4J_CLIENT_BEAN_NAME)
	@ConditionalOnMissingBean
	public Neo4jClient neo4jClient(Driver driver, DatabaseSelectionProvider databaseNameProvider) {
		return Neo4jClient.create(driver, databaseNameProvider);
	}
	@Bean(Neo4jRepositoryConfigurationExtension.DEFAULT_NEO4J_TEMPLATE_BEAN_NAME)
	@ConditionalOnMissingBean(Neo4jOperations.class)
	public Neo4jTemplate neo4jTemplate(Neo4jClient neo4jClient, Neo4jMappingContext neo4jMappingContext) {
		return new Neo4jTemplate(neo4jClient, neo4jMappingContext);
	}
	@Bean(Neo4jRepositoryConfigurationExtension.DEFAULT_TRANSACTION_MANAGER_BEAN_NAME)
	@ConditionalOnMissingBean(TransactionManager.class)
	public Neo4jTransactionManager transactionManager(Driver driver, DatabaseSelectionProvider databaseNameProvider,
			ObjectProvider<TransactionManagerCustomizers> optionalCustomizers) {
		Neo4jTransactionManager transactionManager = new Neo4jTransactionManager(driver, databaseNameProvider);
		optionalCustomizers.ifAvailable((customizer) -> customizer.customize(transactionManager));
		return transactionManager;
	}
}
/*
package org.springframework.boot.autoconfigure.data.jpa;
/**
@AutoConfiguration(after = { HibernateJpaAutoConfiguration.class, TaskExecutionAutoConfiguration.class })
@ConditionalOnBean(DataSource.class)
@ConditionalOnClass(JpaRepository.class)
@ConditionalOnMissingBean({ JpaRepositoryFactoryBean.class, JpaRepositoryConfigExtension.class })
@ConditionalOnProperty(prefix = 'spring.data.jpa.repositories', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
@Import(JpaRepositoriesImportSelector.class)
public class JpaRepositoriesAutoConfiguration {
	@Bean
	@Conditional(BootstrapExecutorCondition.class)
	public EntityManagerFactoryBuilderCustomizer entityManagerFactoryBootstrapExecutorCustomizer(
			Map<String, AsyncTaskExecutor> taskExecutors) {
		return (builder) -> {
			AsyncTaskExecutor bootstrapExecutor = determineBootstrapExecutor(taskExecutors);
			if (bootstrapExecutor != null) {
				builder.setBootstrapExecutor(bootstrapExecutor);
			}
		};
	}
	private AsyncTaskExecutor determineBootstrapExecutor(Map<String, AsyncTaskExecutor> taskExecutors) {
		if (taskExecutors.size() == 1) {
			return taskExecutors.values().iterator().next();
		}
		return taskExecutors.get(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME);
	}
	private static final class BootstrapExecutorCondition extends AnyNestedCondition {
		BootstrapExecutorCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnProperty(prefix = 'spring.data.jpa.repositories', name = 'bootstrap-mode',
				havingValue = 'deferred')
		static class DeferredBootstrapMode {
		}
		@ConditionalOnProperty(prefix = 'spring.data.jpa.repositories', name = 'bootstrap-mode', havingValue = 'lazy')
		static class LazyBootstrapMode {
		}
	}
	static class JpaRepositoriesImportSelector implements ImportSelector {
		private static final boolean ENVERS_AVAILABLE = ClassUtils.isPresent(
				'org.springframework.data.envers.repository.config.EnableEnversRepositories',
				JpaRepositoriesImportSelector.class.getClassLoader());
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			return new String[] { determineImport() };
		}
		private String determineImport() {
			return ENVERS_AVAILABLE ? EnversRevisionRepositoriesRegistrar.class.getName()
					: JpaRepositoriesRegistrar.class.getName();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.jpa;
/**
class EnversRevisionRepositoriesRegistrar extends JpaRepositoriesRegistrar {
	@Override
	protected Class<?> getConfiguration() {
		return EnableJpaRepositoriesConfiguration.class;
	}
	@EnableJpaRepositories(repositoryFactoryBeanClass = EnversRevisionRepositoryFactoryBean.class)
	private static final class EnableJpaRepositoriesConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.jpa;
/*
package org.springframework.boot.autoconfigure.data.jpa;
/**
class JpaRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	private BootstrapMode bootstrapMode = null;
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableJpaRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableJpaRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new JpaRepositoryConfigExtension();
	}
	@Override
	protected BootstrapMode getBootstrapMode() {
		return (this.bootstrapMode == null) ? BootstrapMode.DEFAULT : this.bootstrapMode;
	}
	@Override
	public void setEnvironment(Environment environment) {
		super.setEnvironment(environment);
		configureBootstrapMode(environment);
	}
	private void configureBootstrapMode(Environment environment) {
		String property = environment.getProperty('spring.data.jpa.repositories.bootstrap-mode');
		if (StringUtils.hasText(property)) {
			this.bootstrapMode = BootstrapMode.valueOf(property.toUpperCase(Locale.ENGLISH));
		}
	}
	@EnableJpaRepositories
	private static final class EnableJpaRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.rest;
/**
@Order(0)
class SpringBootRepositoryRestConfigurer implements RepositoryRestConfigurer {
	private final Jackson2ObjectMapperBuilder objectMapperBuilder;
	private final RepositoryRestProperties properties;
	SpringBootRepositoryRestConfigurer(Jackson2ObjectMapperBuilder objectMapperBuilder,
			RepositoryRestProperties properties) {
		this.objectMapperBuilder = objectMapperBuilder;
		this.properties = properties;
	}
	@Override
	public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config, CorsRegistry cors) {
		this.properties.applyTo(config);
	}
	@Override
	public void configureJacksonObjectMapper(ObjectMapper objectMapper) {
		if (this.objectMapperBuilder != null) {
			this.objectMapperBuilder.configure(objectMapper);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.rest;
/**
@AutoConfiguration(after = { HttpMessageConvertersAutoConfiguration.class, JacksonAutoConfiguration.class })
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnMissingBean(RepositoryRestMvcConfiguration.class)
@ConditionalOnClass(RepositoryRestMvcConfiguration.class)
@EnableConfigurationProperties(RepositoryRestProperties.class)
@Import(RepositoryRestMvcConfiguration.class)
public class RepositoryRestMvcAutoConfiguration {
	@Bean
	public SpringBootRepositoryRestConfigurer springBootRepositoryRestConfigurer(
			ObjectProvider<Jackson2ObjectMapperBuilder> objectMapperBuilder, RepositoryRestProperties properties) {
		return new SpringBootRepositoryRestConfigurer(objectMapperBuilder.getIfAvailable(), properties);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.rest;
/*
package org.springframework.boot.autoconfigure.data.rest;
/**
@ConfigurationProperties(prefix = 'spring.data.rest')
public class RepositoryRestProperties {
	/**
	 * Base path to be used by Spring Data REST to expose repository resources.
	 */
	private String basePath;
	/**
	 * Default size of pages.
	 */
	private Integer defaultPageSize;
	/**
	 * Maximum size of pages.
	 */
	private Integer maxPageSize;
	/**
	 * Name of the URL query string parameter that indicates what page to return.
	 */
	private String pageParamName;
	/**
	 * Name of the URL query string parameter that indicates how many results to return at
	 * once.
	 */
	private String limitParamName;
	/**
	 * Name of the URL query string parameter that indicates what direction to sort
	 * results.
	 */
	private String sortParamName;
	/**
	 * Strategy to use to determine which repositories get exposed.
	 */
	private RepositoryDetectionStrategies detectionStrategy = RepositoryDetectionStrategies.DEFAULT;
	/**
	 * Content type to use as a default when none is specified.
	 */
	private MediaType defaultMediaType;
	/**
	 * Whether to return a response body after creating an entity.
	 */
	private Boolean returnBodyOnCreate;
	/**
	 * Whether to return a response body after updating an entity.
	 */
	private Boolean returnBodyOnUpdate;
	/**
	 * Whether to enable enum value translation through the Spring Data REST default
	 * resource bundle.
	 */
	private Boolean enableEnumTranslation;
	public String getBasePath() {
		return this.basePath;
	}
	public void setBasePath(String basePath) {
		this.basePath = basePath;
	}
	public Integer getDefaultPageSize() {
		return this.defaultPageSize;
	}
	public void setDefaultPageSize(Integer defaultPageSize) {
		this.defaultPageSize = defaultPageSize;
	}
	public Integer getMaxPageSize() {
		return this.maxPageSize;
	}
	public void setMaxPageSize(Integer maxPageSize) {
		this.maxPageSize = maxPageSize;
	}
	public String getPageParamName() {
		return this.pageParamName;
	}
	public void setPageParamName(String pageParamName) {
		this.pageParamName = pageParamName;
	}
	public String getLimitParamName() {
		return this.limitParamName;
	}
	public void setLimitParamName(String limitParamName) {
		this.limitParamName = limitParamName;
	}
	public String getSortParamName() {
		return this.sortParamName;
	}
	public void setSortParamName(String sortParamName) {
		this.sortParamName = sortParamName;
	}
	public RepositoryDetectionStrategies getDetectionStrategy() {
		return this.detectionStrategy;
	}
	public void setDetectionStrategy(RepositoryDetectionStrategies detectionStrategy) {
		this.detectionStrategy = detectionStrategy;
	}
	public MediaType getDefaultMediaType() {
		return this.defaultMediaType;
	}
	public void setDefaultMediaType(MediaType defaultMediaType) {
		this.defaultMediaType = defaultMediaType;
	}
	public Boolean getReturnBodyOnCreate() {
		return this.returnBodyOnCreate;
	}
	public void setReturnBodyOnCreate(Boolean returnBodyOnCreate) {
		this.returnBodyOnCreate = returnBodyOnCreate;
	}
	public Boolean getReturnBodyOnUpdate() {
		return this.returnBodyOnUpdate;
	}
	public void setReturnBodyOnUpdate(Boolean returnBodyOnUpdate) {
		this.returnBodyOnUpdate = returnBodyOnUpdate;
	}
	public Boolean getEnableEnumTranslation() {
		return this.enableEnumTranslation;
	}
	public void setEnableEnumTranslation(Boolean enableEnumTranslation) {
		this.enableEnumTranslation = enableEnumTranslation;
	}
	public void applyTo(RepositoryRestConfiguration rest) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this::getBasePath).to(rest::setBasePath);
		map.from(this::getDefaultPageSize).to(rest::setDefaultPageSize);
		map.from(this::getMaxPageSize).to(rest::setMaxPageSize);
		map.from(this::getPageParamName).to(rest::setPageParamName);
		map.from(this::getLimitParamName).to(rest::setLimitParamName);
		map.from(this::getSortParamName).to(rest::setSortParamName);
		map.from(this::getDetectionStrategy).to(rest::setRepositoryDetectionStrategy);
		map.from(this::getDefaultMediaType).to(rest::setDefaultMediaType);
		map.from(this::getReturnBodyOnCreate).to(rest::setReturnBodyOnCreate);
		map.from(this::getReturnBodyOnUpdate).to(rest::setReturnBodyOnUpdate);
		map.from(this::getEnableEnumTranslation).to(rest::setEnableEnumTranslation);
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
class ElasticsearchRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableElasticsearchRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableElasticsearchRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new ElasticsearchRepositoryConfigExtension();
	}
	@EnableElasticsearchRepositories
	private static final class EnableElasticsearchRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
@AutoConfiguration
@ConditionalOnClass(ElasticsearchRepository.class)
@ConditionalOnProperty(prefix = 'spring.data.elasticsearch.repositories', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
@ConditionalOnMissingBean(ElasticsearchRepositoryFactoryBean.class)
@Import(ElasticsearchRepositoriesRegistrar.class)
public class ElasticsearchRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
@AutoConfiguration(
		after = { ElasticsearchClientAutoConfiguration.class, ReactiveElasticsearchClientAutoConfiguration.class })
@ConditionalOnClass({ ElasticsearchTemplate.class })
@Import({ ElasticsearchDataConfiguration.BaseConfiguration.class,
		ElasticsearchDataConfiguration.JavaClientConfiguration.class,
		ElasticsearchDataConfiguration.ReactiveRestClientConfiguration.class })
public class ElasticsearchDataAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
@AutoConfiguration
@ConditionalOnClass({ ReactiveElasticsearchClient.class, ReactiveElasticsearchRepository.class, Mono.class })
@ConditionalOnProperty(prefix = 'spring.data.elasticsearch.repositories', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
@ConditionalOnMissingBean(ReactiveElasticsearchRepositoryFactoryBean.class)
@Import(ReactiveElasticsearchRepositoriesRegistrar.class)
public class ReactiveElasticsearchRepositoriesAutoConfiguration {
}
/*
/**
package org.springframework.boot.autoconfigure.data.elasticsearch;
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
abstract class ElasticsearchDataConfiguration {
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ElasticsearchCustomConversions elasticsearchCustomConversions() {
			return new ElasticsearchCustomConversions(Collections.emptyList());
		}
		@Bean
		@ConditionalOnMissingBean
		SimpleElasticsearchMappingContext elasticsearchMappingContext(ApplicationContext applicationContext,
				ElasticsearchCustomConversions elasticsearchCustomConversions) throws ClassNotFoundException {
			SimpleElasticsearchMappingContext mappingContext = new SimpleElasticsearchMappingContext();
			mappingContext.setInitialEntitySet(new EntityScanner(applicationContext).scan(Document.class));
			mappingContext.setSimpleTypeHolder(elasticsearchCustomConversions.getSimpleTypeHolder());
			return mappingContext;
		}
		@Bean
		@ConditionalOnMissingBean
		ElasticsearchConverter elasticsearchConverter(SimpleElasticsearchMappingContext mappingContext,
				ElasticsearchCustomConversions elasticsearchCustomConversions) {
			MappingElasticsearchConverter converter = new MappingElasticsearchConverter(mappingContext);
			converter.setConversions(elasticsearchCustomConversions);
			return converter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ElasticsearchClient.class)
	static class JavaClientConfiguration {
		@Bean
		@ConditionalOnMissingBean(value = ElasticsearchOperations.class, name = 'elasticsearchTemplate')
		@ConditionalOnBean(ElasticsearchClient.class)
		ElasticsearchTemplate elasticsearchTemplate(ElasticsearchClient client, ElasticsearchConverter converter) {
			return new ElasticsearchTemplate(client, converter);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveRestClientConfiguration {
		@Bean
		@ConditionalOnMissingBean(value = ReactiveElasticsearchOperations.class, name = 'reactiveElasticsearchTemplate')
		@ConditionalOnBean(ReactiveElasticsearchClient.class)
		ReactiveElasticsearchTemplate reactiveElasticsearchTemplate(ReactiveElasticsearchClient client,
				ElasticsearchConverter converter) {
			return new ReactiveElasticsearchTemplate(client, converter);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
class ReactiveElasticsearchRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableReactiveElasticsearchRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableElasticsearchRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new ReactiveElasticsearchRepositoryConfigurationExtension();
	}
	@EnableReactiveElasticsearchRepositories
	private static final class EnableElasticsearchRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
public interface ClientResourcesBuilderCustomizer {
	/**
	 * Customize the {@link Builder}.
	 * @param clientResourcesBuilder the builder to customize
	 */
	void customize(Builder clientResourcesBuilder);
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class RedisUrlSyntaxFailureAnalyzer extends AbstractFailureAnalyzer<RedisUrlSyntaxException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, RedisUrlSyntaxException cause) {
		try {
			URI uri = new URI(cause.getUrl());
			if ('redis-sentinel'.equals(uri.getScheme())) {
				return new FailureAnalysis(getUnsupportedSchemeDescription(cause.getUrl(), uri.getScheme()),
						'Use spring.data.redis.sentinel properties instead of spring.data.redis.url to configure Redis sentinel addresses.',
						cause);
			}
			if ('redis-socket'.equals(uri.getScheme())) {
				return new FailureAnalysis(getUnsupportedSchemeDescription(cause.getUrl(), uri.getScheme()),
						'Configure the appropriate Spring Data Redis connection beans directly instead of setting the property "spring.data.redis.url".',
						cause);
			}
			if (!'redis'.equals(uri.getScheme()) && !'rediss'.equals(uri.getScheme())) {
				return new FailureAnalysis(getUnsupportedSchemeDescription(cause.getUrl(), uri.getScheme()),
						'Use the scheme "redis://" for insecure or "rediss://" for secure Redis standalone configuration.',
						cause);
			}
		}
		catch (URISyntaxException ex) {
			// fall through to default description and action
		}
		return new FailureAnalysis(getDefaultDescription(cause.getUrl()),
				'Review the value of the property "spring.data.redis.url".', cause);
	}
	private String getDefaultDescription(String url) {
		return 'The URL "' + url + '" is not valid for configuring Spring Data Redis. ';
	}
	private String getUnsupportedSchemeDescription(String url, String scheme) {
		return getDefaultDescription(url) + 'The scheme "' + scheme + '" is not supported.';
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@FunctionalInterface
public interface JedisClientConfigurationBuilderCustomizer {
	/**
	 * Customize the {@link JedisClientConfigurationBuilder}.
	 * @param clientConfigurationBuilder the builder to customize
	 */
	void customize(JedisClientConfigurationBuilder clientConfigurationBuilder);
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ GenericObjectPool.class, JedisConnection.class, Jedis.class })
@ConditionalOnMissingBean(RedisConnectionFactory.class)
@ConditionalOnProperty(name = 'spring.data.redis.client-type', havingValue = 'jedis', matchIfMissing = true)
class JedisConnectionConfiguration extends RedisConnectionConfiguration {
	JedisConnectionConfiguration(RedisProperties properties,
			ObjectProvider<RedisStandaloneConfiguration> standaloneConfigurationProvider,
			ObjectProvider<RedisSentinelConfiguration> sentinelConfiguration,
			ObjectProvider<RedisClusterConfiguration> clusterConfiguration, RedisConnectionDetails connectionDetails,
			ObjectProvider<SslBundles> sslBundles) {
		super(properties, connectionDetails, standaloneConfigurationProvider, sentinelConfiguration,
				clusterConfiguration, sslBundles);
	}
	@Bean
	@ConditionalOnThreading(Threading.PLATFORM)
	JedisConnectionFactory redisConnectionFactory(
			ObjectProvider<JedisClientConfigurationBuilderCustomizer> builderCustomizers) {
		return createJedisConnectionFactory(builderCustomizers);
	}
	@Bean
	@ConditionalOnThreading(Threading.VIRTUAL)
	JedisConnectionFactory redisConnectionFactoryVirtualThreads(
			ObjectProvider<JedisClientConfigurationBuilderCustomizer> builderCustomizers) {
		JedisConnectionFactory factory = createJedisConnectionFactory(builderCustomizers);
		SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor('redis-');
		executor.setVirtualThreads(true);
		factory.setExecutor(executor);
		return factory;
	}
	private JedisConnectionFactory createJedisConnectionFactory(
			ObjectProvider<JedisClientConfigurationBuilderCustomizer> builderCustomizers) {
		JedisClientConfiguration clientConfiguration = getJedisClientConfiguration(builderCustomizers);
		if (getSentinelConfig() != null) {
			return new JedisConnectionFactory(getSentinelConfig(), clientConfiguration);
		}
		if (getClusterConfiguration() != null) {
			return new JedisConnectionFactory(getClusterConfiguration(), clientConfiguration);
		}
		return new JedisConnectionFactory(getStandaloneConfig(), clientConfiguration);
	}
	private JedisClientConfiguration getJedisClientConfiguration(
			ObjectProvider<JedisClientConfigurationBuilderCustomizer> builderCustomizers) {
		JedisClientConfigurationBuilder builder = applyProperties(JedisClientConfiguration.builder());
		if (isSslEnabled()) {
			applySsl(builder);
		}
		RedisProperties.Pool pool = getProperties().getJedis().getPool();
		if (isPoolEnabled(pool)) {
			applyPooling(pool, builder);
		}
		if (StringUtils.hasText(getProperties().getUrl())) {
			customizeConfigurationFromUrl(builder);
		}
		builderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	private JedisClientConfigurationBuilder applyProperties(JedisClientConfigurationBuilder builder) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(getProperties().getTimeout()).to(builder::readTimeout);
		map.from(getProperties().getConnectTimeout()).to(builder::connectTimeout);
		map.from(getProperties().getClientName()).whenHasText().to(builder::clientName);
		return builder;
	}
	private void applySsl(JedisClientConfigurationBuilder builder) {
		JedisSslClientConfigurationBuilder sslBuilder = builder.useSsl();
		if (getProperties().getSsl().getBundle() != null) {
			SslBundle sslBundle = getSslBundles().getBundle(getProperties().getSsl().getBundle());
			sslBuilder.sslSocketFactory(sslBundle.createSslContext().getSocketFactory());
			SslOptions sslOptions = sslBundle.getOptions();
			SSLParameters sslParameters = new SSLParameters();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(sslOptions.getCiphers()).to(sslParameters::setCipherSuites);
			map.from(sslOptions.getEnabledProtocols()).to(sslParameters::setProtocols);
			sslBuilder.sslParameters(sslParameters);
		}
	}
	private void applyPooling(RedisProperties.Pool pool,
			JedisClientConfiguration.JedisClientConfigurationBuilder builder) {
		builder.usePooling().poolConfig(jedisPoolConfig(pool));
	}
	private JedisPoolConfig jedisPoolConfig(RedisProperties.Pool pool) {
		JedisPoolConfig config = new JedisPoolConfig();
		config.setMaxTotal(pool.getMaxActive());
		config.setMaxIdle(pool.getMaxIdle());
		config.setMinIdle(pool.getMinIdle());
		if (pool.getTimeBetweenEvictionRuns() != null) {
			config.setTimeBetweenEvictionRuns(pool.getTimeBetweenEvictionRuns());
		}
		if (pool.getMaxWait() != null) {
			config.setMaxWait(pool.getMaxWait());
		}
		return config;
	}
	private void customizeConfigurationFromUrl(JedisClientConfiguration.JedisClientConfigurationBuilder builder) {
		if (urlUsesSsl()) {
			builder.useSsl();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@AutoConfiguration(after = RedisAutoConfiguration.class)
@ConditionalOnClass({ ReactiveRedisConnectionFactory.class, ReactiveRedisTemplate.class, Flux.class })
public class RedisReactiveAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(name = 'reactiveRedisTemplate')
	@ConditionalOnBean(ReactiveRedisConnectionFactory.class)
	public ReactiveRedisTemplate<Object, Object> reactiveRedisTemplate(
			ReactiveRedisConnectionFactory reactiveRedisConnectionFactory, ResourceLoader resourceLoader) {
		RedisSerializer<Object> javaSerializer = RedisSerializer.java(resourceLoader.getClassLoader());
		RedisSerializationContext<Object, Object> serializationContext = RedisSerializationContext
			.newSerializationContext()
			.key(javaSerializer)
			.value(javaSerializer)
			.hashKey(javaSerializer)
			.hashValue(javaSerializer)
			.build();
		return new ReactiveRedisTemplate<>(reactiveRedisConnectionFactory, serializationContext);
	}
	@Bean
	@ConditionalOnMissingBean(name = 'reactiveStringRedisTemplate')
	@ConditionalOnBean(ReactiveRedisConnectionFactory.class)
	public ReactiveStringRedisTemplate reactiveStringRedisTemplate(
			ReactiveRedisConnectionFactory reactiveRedisConnectionFactory) {
		return new ReactiveStringRedisTemplate(reactiveRedisConnectionFactory);
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@AutoConfiguration
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(RedisConnectionDetails.class)
	PropertiesRedisConnectionDetails redisConnectionDetails(RedisProperties properties) {
		return new PropertiesRedisConnectionDetails(properties);
	}
	@Bean
	@ConditionalOnMissingBean(name = 'redisTemplate')
	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)
	public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {
		RedisTemplate<Object, Object> template = new RedisTemplate<>();
		template.setConnectionFactory(redisConnectionFactory);
		return template;
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnSingleCandidate(RedisConnectionFactory.class)
	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) {
		return new StringRedisTemplate(redisConnectionFactory);
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@FunctionalInterface
public interface LettuceClientConfigurationBuilderCustomizer {
	/**
	 * Customize the {@link LettuceClientConfigurationBuilder}.
	 * @param clientConfigurationBuilder the builder to customize
	 */
	void customize(LettuceClientConfigurationBuilder clientConfigurationBuilder);
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@AutoConfiguration(after = RedisAutoConfiguration.class)
@ConditionalOnClass(EnableRedisRepositories.class)
@ConditionalOnBean(RedisConnectionFactory.class)
@ConditionalOnProperty(prefix = 'spring.data.redis.repositories', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
@ConditionalOnMissingBean(RedisRepositoryFactoryBean.class)
@Import(RedisRepositoriesRegistrar.class)
public class RedisRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class PropertiesRedisConnectionDetails implements RedisConnectionDetails {
	private final RedisProperties properties;
	PropertiesRedisConnectionDetails(RedisProperties properties) {
		this.properties = properties;
	}
	@Override
	public String getUsername() {
		if (this.properties.getUrl() != null) {
			ConnectionInfo connectionInfo = connectionInfo(this.properties.getUrl());
			return connectionInfo.getUsername();
		}
		return this.properties.getUsername();
	}
	@Override
	public String getPassword() {
		if (this.properties.getUrl() != null) {
			ConnectionInfo connectionInfo = connectionInfo(this.properties.getUrl());
			return connectionInfo.getPassword();
		}
		return this.properties.getPassword();
	}
	@Override
	public Standalone getStandalone() {
		if (this.properties.getUrl() != null) {
			ConnectionInfo connectionInfo = connectionInfo(this.properties.getUrl());
			return Standalone.of(connectionInfo.getUri().getHost(), connectionInfo.getUri().getPort(),
					this.properties.getDatabase());
		}
		return Standalone.of(this.properties.getHost(), this.properties.getPort(), this.properties.getDatabase());
	}
	private ConnectionInfo connectionInfo(String url) {
		return (url != null) ? RedisConnectionConfiguration.parseUrl(url) : null;
	}
	@Override
	public Sentinel getSentinel() {
		org.springframework.boot.autoconfigure.data.redis.RedisProperties.Sentinel sentinel = this.properties
			.getSentinel();
		if (sentinel == null) {
			return null;
		}
		return new Sentinel() {
			@Override
			public int getDatabase() {
				return PropertiesRedisConnectionDetails.this.properties.getDatabase();
			}
			@Override
			public String getMaster() {
				return sentinel.getMaster();
			}
			@Override
			public List<Node> getNodes() {
				return sentinel.getNodes().stream().map(PropertiesRedisConnectionDetails.this::asNode).toList();
			}
			@Override
			public String getUsername() {
				return sentinel.getUsername();
			}
			@Override
			public String getPassword() {
				return sentinel.getPassword();
			}
		};
	}
	@Override
	public Cluster getCluster() {
		RedisProperties.Cluster cluster = this.properties.getCluster();
		List<Node> nodes = (cluster != null) ? cluster.getNodes().stream().map(this::asNode).toList() : null;
		return (nodes != null) ? () -> nodes : null;
	}
	private Node asNode(String node) {
		int portSeparatorIndex = node.lastIndexOf(":");
		String host = node.substring(0, portSeparatorIndex);
		int port = Integer.parseInt(node.substring(portSeparatorIndex + 1));
		return new Node(host, port);
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
abstract class RedisConnectionConfiguration {
	private static final boolean COMMONS_POOL2_AVAILABLE = ClassUtils.isPresent('org.apache.commons.pool2.ObjectPool',
			RedisConnectionConfiguration.class.getClassLoader());
	private final RedisProperties properties;
	private final RedisStandaloneConfiguration standaloneConfiguration;
	private final RedisSentinelConfiguration sentinelConfiguration;
	private final RedisClusterConfiguration clusterConfiguration;
	private final RedisConnectionDetails connectionDetails;
	private final SslBundles sslBundles;
	protected RedisConnectionConfiguration(RedisProperties properties, RedisConnectionDetails connectionDetails,
			ObjectProvider<RedisStandaloneConfiguration> standaloneConfigurationProvider,
			ObjectProvider<RedisSentinelConfiguration> sentinelConfigurationProvider,
			ObjectProvider<RedisClusterConfiguration> clusterConfigurationProvider,
			ObjectProvider<SslBundles> sslBundles) {
		this.properties = properties;
		this.standaloneConfiguration = standaloneConfigurationProvider.getIfAvailable();
		this.sentinelConfiguration = sentinelConfigurationProvider.getIfAvailable();
		this.clusterConfiguration = clusterConfigurationProvider.getIfAvailable();
		this.connectionDetails = connectionDetails;
		this.sslBundles = sslBundles.getIfAvailable();
	}
	protected final RedisStandaloneConfiguration getStandaloneConfig() {
		if (this.standaloneConfiguration != null) {
			return this.standaloneConfiguration;
		}
		RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
		config.setHostName(this.connectionDetails.getStandalone().getHost());
		config.setPort(this.connectionDetails.getStandalone().getPort());
		config.setUsername(this.connectionDetails.getUsername());
		config.setPassword(RedisPassword.of(this.connectionDetails.getPassword()));
		config.setDatabase(this.connectionDetails.getStandalone().getDatabase());
		return config;
	}
	protected final RedisSentinelConfiguration getSentinelConfig() {
		if (this.sentinelConfiguration != null) {
			return this.sentinelConfiguration;
		}
		if (this.connectionDetails.getSentinel() != null) {
			RedisSentinelConfiguration config = new RedisSentinelConfiguration();
			config.master(this.connectionDetails.getSentinel().getMaster());
			config.setSentinels(createSentinels(this.connectionDetails.getSentinel()));
			config.setUsername(this.connectionDetails.getUsername());
			String password = this.connectionDetails.getPassword();
			if (password != null) {
				config.setPassword(RedisPassword.of(password));
			}
			config.setSentinelUsername(this.connectionDetails.getSentinel().getUsername());
			String sentinelPassword = this.connectionDetails.getSentinel().getPassword();
			if (sentinelPassword != null) {
				config.setSentinelPassword(RedisPassword.of(sentinelPassword));
			}
			config.setDatabase(this.connectionDetails.getSentinel().getDatabase());
			return config;
		}
		return null;
	}
	/**
	 * Create a {@link RedisClusterConfiguration} if necessary.
	 * @return {@literal null} if no cluster settings are set.
	 */
	protected final RedisClusterConfiguration getClusterConfiguration() {
		if (this.clusterConfiguration != null) {
			return this.clusterConfiguration;
		}
		RedisProperties.Cluster clusterProperties = this.properties.getCluster();
		if (this.connectionDetails.getCluster() != null) {
			RedisClusterConfiguration config = new RedisClusterConfiguration();
			config.setClusterNodes(getNodes(this.connectionDetails.getCluster()));
			if (clusterProperties != null && clusterProperties.getMaxRedirects() != null) {
				config.setMaxRedirects(clusterProperties.getMaxRedirects());
			}
			config.setUsername(this.connectionDetails.getUsername());
			String password = this.connectionDetails.getPassword();
			if (password != null) {
				config.setPassword(RedisPassword.of(password));
			}
			return config;
		}
		return null;
	}
	private List<RedisNode> getNodes(Cluster cluster) {
		return cluster.getNodes().stream().map(this::asRedisNode).toList();
	}
	private RedisNode asRedisNode(Node node) {
		return new RedisNode(node.host(), node.port());
	}
	protected final RedisProperties getProperties() {
		return this.properties;
	}
	protected SslBundles getSslBundles() {
		return this.sslBundles;
	}
	protected boolean isSslEnabled() {
		return getProperties().getSsl().isEnabled();
	}
	protected boolean isPoolEnabled(Pool pool) {
		Boolean enabled = pool.getEnabled();
		return (enabled != null) ? enabled : COMMONS_POOL2_AVAILABLE;
	}
	private List<RedisNode> createSentinels(Sentinel sentinel) {
		List<RedisNode> nodes = new ArrayList<>();
		for (Node node : sentinel.getNodes()) {
			nodes.add(asRedisNode(node));
		}
		return nodes;
	}
	protected final boolean urlUsesSsl() {
		return parseUrl(this.properties.getUrl()).isUseSsl();
	}
	protected final RedisConnectionDetails getConnectionDetails() {
		return this.connectionDetails;
	}
	static ConnectionInfo parseUrl(String url) {
		try {
			URI uri = new URI(url);
			String scheme = uri.getScheme();
			if (!'redis'.equals(scheme) && !'rediss'.equals(scheme)) {
				throw new RedisUrlSyntaxException(url);
			}
			boolean useSsl = ('rediss'.equals(scheme));
			String username = null;
			String password = null;
			if (uri.getUserInfo() != null) {
				String candidate = uri.getUserInfo();
				int index = candidate.indexOf(":");
				if (index >= 0) {
					username = candidate.substring(0, index);
					password = candidate.substring(index + 1);
				}
				else {
					password = candidate;
				}
			}
			return new ConnectionInfo(uri, useSsl, username, password);
		}
		catch (URISyntaxException ex) {
			throw new RedisUrlSyntaxException(url, ex);
		}
	}
	static class ConnectionInfo {
		private final URI uri;
		private final boolean useSsl;
		private final String username;
		private final String password;
		ConnectionInfo(URI uri, boolean useSsl, String username, String password) {
			this.uri = uri;
			this.useSsl = useSsl;
			this.username = username;
			this.password = password;
		}
		URI getUri() {
			return this.uri;
		}
		boolean isUseSsl() {
			return this.useSsl;
		}
		String getUsername() {
			return this.username;
		}
		String getPassword() {
			return this.password;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.redis;
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class RedisRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableRedisRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableRedisRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new RedisRepositoryConfigurationExtension();
	}
	@EnableRedisRepositories
	private static final class EnableRedisRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@ConfigurationProperties(prefix = 'spring.data.redis')
public class RedisProperties {
	/**
	 * Database index used by the connection factory.
	 */
	private int database = 0;
	/**
	 * Connection URL. Overrides host, port, username, and password. Example:
	 * redis://user:password@example.com:6379
	 */
	private String url;
	/**
	 * Redis server host.
	 */
	private String host = 'localhost';
	/**
	 * Login username of the redis server.
	 */
	private String username;
	/**
	 * Login password of the redis server.
	 */
	private String password;
	/**
	 * Redis server port.
	 */
	private int port = 6379;
	/**
	 * Read timeout.
	 */
	private Duration timeout;
	/**
	 * Connection timeout.
	 */
	private Duration connectTimeout;
	/**
	 * Client name to be set on connections with CLIENT SETNAME.
	 */
	private String clientName;
	/**
	 * Type of client to use. By default, auto-detected according to the classpath.
	 */
	private ClientType clientType;
	private Sentinel sentinel;
	private Cluster cluster;
	private final Ssl ssl = new Ssl();
	private final Jedis jedis = new Jedis();
	private final Lettuce lettuce = new Lettuce();
	public int getDatabase() {
		return this.database;
	}
	public void setDatabase(int database) {
		this.database = database;
	}
	public String getUrl() {
		return this.url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public int getPort() {
		return this.port;
	}
	public void setPort(int port) {
		this.port = port;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public void setTimeout(Duration timeout) {
		this.timeout = timeout;
	}
	public Duration getTimeout() {
		return this.timeout;
	}
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public String getClientName() {
		return this.clientName;
	}
	public void setClientName(String clientName) {
		this.clientName = clientName;
	}
	public ClientType getClientType() {
		return this.clientType;
	}
	public void setClientType(ClientType clientType) {
		this.clientType = clientType;
	}
	public Sentinel getSentinel() {
		return this.sentinel;
	}
	public void setSentinel(Sentinel sentinel) {
		this.sentinel = sentinel;
	}
	public Cluster getCluster() {
		return this.cluster;
	}
	public void setCluster(Cluster cluster) {
		this.cluster = cluster;
	}
	public Jedis getJedis() {
		return this.jedis;
	}
	public Lettuce getLettuce() {
		return this.lettuce;
	}
	/**
	 * Type of Redis client to use.
	 */
	public enum ClientType {
		/**
		 * Use the Lettuce redis client.
		 */
		LETTUCE,
		/**
		 * Use the Jedis redis client.
		 */
		JEDIS
	}
	/**
	 * Pool properties.
	 */
	public static class Pool {
		/**
		 * Whether to enable the pool. Enabled automatically if 'commons-pool2' is
		 * available. With Jedis, pooling is implicitly enabled in sentinel mode and this
		 * setting only applies to single node setup.
		 */
		private Boolean enabled;
		/**
		 * Maximum number of 'idle' connections in the pool. Use a negative value to
		 * indicate an unlimited number of idle connections.
		 */
		private int maxIdle = 8;
		/**
		 * Target for the minimum number of idle connections to maintain in the pool. This
		 * setting only has an effect if both it and time between eviction runs are
		 * positive.
		 */
		private int minIdle = 0;
		/**
		 * Maximum number of connections that can be allocated by the pool at a given
		 * time. Use a negative value for no limit.
		 */
		private int maxActive = 8;
		/**
		 * Maximum amount of time a connection allocation should block before throwing an
		 * exception when the pool is exhausted. Use a negative value to block
		 * indefinitely.
		 */
		private Duration maxWait = Duration.ofMillis(-1);
		/**
		 * Time between runs of the idle object evictor thread. When positive, the idle
		 * object evictor thread starts, otherwise no idle object eviction is performed.
		 */
		private Duration timeBetweenEvictionRuns;
		public Boolean getEnabled() {
			return this.enabled;
		}
		public void setEnabled(Boolean enabled) {
			this.enabled = enabled;
		}
		public int getMaxIdle() {
			return this.maxIdle;
		}
		public void setMaxIdle(int maxIdle) {
			this.maxIdle = maxIdle;
		}
		public int getMinIdle() {
			return this.minIdle;
		}
		public void setMinIdle(int minIdle) {
			this.minIdle = minIdle;
		}
		public int getMaxActive() {
			return this.maxActive;
		}
		public void setMaxActive(int maxActive) {
			this.maxActive = maxActive;
		}
		public Duration getMaxWait() {
			return this.maxWait;
		}
		public void setMaxWait(Duration maxWait) {
			this.maxWait = maxWait;
		}
		public Duration getTimeBetweenEvictionRuns() {
			return this.timeBetweenEvictionRuns;
		}
		public void setTimeBetweenEvictionRuns(Duration timeBetweenEvictionRuns) {
			this.timeBetweenEvictionRuns = timeBetweenEvictionRuns;
		}
	}
	/**
	 * Cluster properties.
	 */
	public static class Cluster {
		/**
		 * List of 'host:port' pairs to bootstrap from. This represents an 'initial' list
		 * of cluster nodes and is required to have at least one entry.
		 */
		private List<String> nodes;
		/**
		 * Maximum number of redirects to follow when executing commands across the
		 * cluster.
		 */
		private Integer maxRedirects;
		public List<String> getNodes() {
			return this.nodes;
		}
		public void setNodes(List<String> nodes) {
			this.nodes = nodes;
		}
		public Integer getMaxRedirects() {
			return this.maxRedirects;
		}
		public void setMaxRedirects(Integer maxRedirects) {
			this.maxRedirects = maxRedirects;
		}
	}
	/**
	 * Redis sentinel properties.
	 */
	public static class Sentinel {
		/**
		 * Name of the Redis server.
		 */
		private String master;
		/**
		 * List of 'host:port' pairs.
		 */
		private List<String> nodes;
		/**
		 * Login username for authenticating with sentinel(s).
		 */
		private String username;
		/**
		 * Password for authenticating with sentinel(s).
		 */
		private String password;
		public String getMaster() {
			return this.master;
		}
		public void setMaster(String master) {
			this.master = master;
		}
		public List<String> getNodes() {
			return this.nodes;
		}
		public void setNodes(List<String> nodes) {
			this.nodes = nodes;
		}
		public String getUsername() {
			return this.username;
		}
		public void setUsername(String username) {
			this.username = username;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
	}
	public static class Ssl {
		/**
		 * Whether to enable SSL support. Enabled automatically if 'bundle' is provided
		 * unless specified otherwise.
		 */
		private Boolean enabled;
		/**
		 * SSL bundle name.
		 */
		private String bundle;
		public boolean isEnabled() {
			return (this.enabled != null) ? this.enabled : this.bundle != null;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
	}
	/**
	 * Jedis client properties.
	 */
	public static class Jedis {
		/**
		 * Jedis pool configuration.
		 */
		private final Pool pool = new Pool();
		public Pool getPool() {
			return this.pool;
		}
	}
	/**
	 * Lettuce client properties.
	 */
	public static class Lettuce {
		/**
		 * Shutdown timeout.
		 */
		private Duration shutdownTimeout = Duration.ofMillis(100);
		/**
		 * Lettuce pool configuration.
		 */
		private final Pool pool = new Pool();
		private final Cluster cluster = new Cluster();
		public Duration getShutdownTimeout() {
			return this.shutdownTimeout;
		}
		public void setShutdownTimeout(Duration shutdownTimeout) {
			this.shutdownTimeout = shutdownTimeout;
		}
		public Pool getPool() {
			return this.pool;
		}
		public Cluster getCluster() {
			return this.cluster;
		}
		public static class Cluster {
			private final Refresh refresh = new Refresh();
			public Refresh getRefresh() {
				return this.refresh;
			}
			public static class Refresh {
				/**
				 * Whether to discover and query all cluster nodes for obtaining the
				 * cluster topology. When set to false, only the initial seed nodes are
				 * used as sources for topology discovery.
				 */
				private boolean dynamicRefreshSources = true;
				/**
				 * Cluster topology refresh period.
				 */
				private Duration period;
				/**
				 * Whether adaptive topology refreshing using all available refresh
				 * triggers should be used.
				 */
				private boolean adaptive;
				public boolean isDynamicRefreshSources() {
					return this.dynamicRefreshSources;
				}
				public void setDynamicRefreshSources(boolean dynamicRefreshSources) {
					this.dynamicRefreshSources = dynamicRefreshSources;
				}
				public Duration getPeriod() {
					return this.period;
				}
				public void setPeriod(Duration period) {
					this.period = period;
				}
				public boolean isAdaptive() {
					return this.adaptive;
				}
				public void setAdaptive(boolean adaptive) {
					this.adaptive = adaptive;
				}
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@FunctionalInterface
public interface LettuceClientOptionsBuilderCustomizer {
	/**
	 * Customize the {@link Builder}.
	 * @param clientOptionsBuilder the builder to customize
	 */
	void customize(Builder clientOptionsBuilder);
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisClient.class)
@ConditionalOnProperty(name = 'spring.data.redis.client-type', havingValue = 'lettuce', matchIfMissing = true)
class LettuceConnectionConfiguration extends RedisConnectionConfiguration {
	LettuceConnectionConfiguration(RedisProperties properties,
			ObjectProvider<RedisStandaloneConfiguration> standaloneConfigurationProvider,
			ObjectProvider<RedisSentinelConfiguration> sentinelConfigurationProvider,
			ObjectProvider<RedisClusterConfiguration> clusterConfigurationProvider,
			RedisConnectionDetails connectionDetails, ObjectProvider<SslBundles> sslBundles) {
		super(properties, connectionDetails, standaloneConfigurationProvider, sentinelConfigurationProvider,
				clusterConfigurationProvider, sslBundles);
	}
	@Bean(destroyMethod = 'shutdown')
	@ConditionalOnMissingBean(ClientResources.class)
	DefaultClientResources lettuceClientResources(ObjectProvider<ClientResourcesBuilderCustomizer> customizers) {
		DefaultClientResources.Builder builder = DefaultClientResources.builder();
		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean(RedisConnectionFactory.class)
	@ConditionalOnThreading(Threading.PLATFORM)
	LettuceConnectionFactory redisConnectionFactory(
			ObjectProvider<LettuceClientConfigurationBuilderCustomizer> clientConfigurationBuilderCustomizers,
			ObjectProvider<LettuceClientOptionsBuilderCustomizer> clientOptionsBuilderCustomizers,
			ClientResources clientResources) {
		return createConnectionFactory(clientConfigurationBuilderCustomizers, clientOptionsBuilderCustomizers,
				clientResources);
	}
	@Bean
	@ConditionalOnMissingBean(RedisConnectionFactory.class)
	@ConditionalOnThreading(Threading.VIRTUAL)
	LettuceConnectionFactory redisConnectionFactoryVirtualThreads(
			ObjectProvider<LettuceClientConfigurationBuilderCustomizer> clientConfigurationBuilderCustomizers,
			ObjectProvider<LettuceClientOptionsBuilderCustomizer> clientOptionsBuilderCustomizers,
			ClientResources clientResources) {
		LettuceConnectionFactory factory = createConnectionFactory(clientConfigurationBuilderCustomizers,
				clientOptionsBuilderCustomizers, clientResources);
		SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor('redis-');
		executor.setVirtualThreads(true);
		factory.setExecutor(executor);
		return factory;
	}
	private LettuceConnectionFactory createConnectionFactory(
			ObjectProvider<LettuceClientConfigurationBuilderCustomizer> clientConfigurationBuilderCustomizers,
			ObjectProvider<LettuceClientOptionsBuilderCustomizer> clientOptionsBuilderCustomizers,
			ClientResources clientResources) {
		LettuceClientConfiguration clientConfig = getLettuceClientConfiguration(clientConfigurationBuilderCustomizers,
				clientOptionsBuilderCustomizers, clientResources, getProperties().getLettuce().getPool());
		return createLettuceConnectionFactory(clientConfig);
	}
	private LettuceConnectionFactory createLettuceConnectionFactory(LettuceClientConfiguration clientConfiguration) {
		if (getSentinelConfig() != null) {
			return new LettuceConnectionFactory(getSentinelConfig(), clientConfiguration);
		}
		if (getClusterConfiguration() != null) {
			return new LettuceConnectionFactory(getClusterConfiguration(), clientConfiguration);
		}
		return new LettuceConnectionFactory(getStandaloneConfig(), clientConfiguration);
	}
	private LettuceClientConfiguration getLettuceClientConfiguration(
			ObjectProvider<LettuceClientConfigurationBuilderCustomizer> clientConfigurationBuilderCustomizers,
			ObjectProvider<LettuceClientOptionsBuilderCustomizer> clientOptionsBuilderCustomizers,
			ClientResources clientResources, Pool pool) {
		LettuceClientConfigurationBuilder builder = createBuilder(pool);
		applyProperties(builder);
		if (StringUtils.hasText(getProperties().getUrl())) {
			customizeConfigurationFromUrl(builder);
		}
		builder.clientOptions(createClientOptions(clientOptionsBuilderCustomizers));
		builder.clientResources(clientResources);
		clientConfigurationBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	private LettuceClientConfigurationBuilder createBuilder(Pool pool) {
		if (isPoolEnabled(pool)) {
			return new PoolBuilderFactory().createBuilder(pool);
		}
		return LettuceClientConfiguration.builder();
	}
	private void applyProperties(LettuceClientConfiguration.LettuceClientConfigurationBuilder builder) {
		if (isSslEnabled()) {
			builder.useSsl();
		}
		if (getProperties().getTimeout() != null) {
			builder.commandTimeout(getProperties().getTimeout());
		}
		if (getProperties().getLettuce() != null) {
			RedisProperties.Lettuce lettuce = getProperties().getLettuce();
			if (lettuce.getShutdownTimeout() != null && !lettuce.getShutdownTimeout().isZero()) {
				builder.shutdownTimeout(getProperties().getLettuce().getShutdownTimeout());
			}
		}
		if (StringUtils.hasText(getProperties().getClientName())) {
			builder.clientName(getProperties().getClientName());
		}
	}
	private ClientOptions createClientOptions(
			ObjectProvider<LettuceClientOptionsBuilderCustomizer> clientConfigurationBuilderCustomizers) {
		ClientOptions.Builder builder = initializeClientOptionsBuilder();
		Duration connectTimeout = getProperties().getConnectTimeout();
		if (connectTimeout != null) {
			builder.socketOptions(SocketOptions.builder().connectTimeout(connectTimeout).build());
		}
		if (isSslEnabled() && getProperties().getSsl().getBundle() != null) {
			SslBundle sslBundle = getSslBundles().getBundle(getProperties().getSsl().getBundle());
			io.lettuce.core.SslOptions.Builder sslOptionsBuilder = io.lettuce.core.SslOptions.builder();
			sslOptionsBuilder.keyManager(sslBundle.getManagers().getKeyManagerFactory());
			sslOptionsBuilder.trustManager(sslBundle.getManagers().getTrustManagerFactory());
			SslOptions sslOptions = sslBundle.getOptions();
			if (sslOptions.getCiphers() != null) {
				sslOptionsBuilder.cipherSuites(sslOptions.getCiphers());
			}
			if (sslOptions.getEnabledProtocols() != null) {
				sslOptionsBuilder.protocols(sslOptions.getEnabledProtocols());
			}
			builder.sslOptions(sslOptionsBuilder.build());
		}
		builder.timeoutOptions(TimeoutOptions.enabled());
		clientConfigurationBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	private ClientOptions.Builder initializeClientOptionsBuilder() {
		if (getProperties().getCluster() != null) {
			ClusterClientOptions.Builder builder = ClusterClientOptions.builder();
			Refresh refreshProperties = getProperties().getLettuce().getCluster().getRefresh();
			Builder refreshBuilder = ClusterTopologyRefreshOptions.builder()
				.dynamicRefreshSources(refreshProperties.isDynamicRefreshSources());
			if (refreshProperties.getPeriod() != null) {
				refreshBuilder.enablePeriodicRefresh(refreshProperties.getPeriod());
			}
			if (refreshProperties.isAdaptive()) {
				refreshBuilder.enableAllAdaptiveRefreshTriggers();
			}
			return builder.topologyRefreshOptions(refreshBuilder.build());
		}
		return ClientOptions.builder();
	}
	private void customizeConfigurationFromUrl(LettuceClientConfiguration.LettuceClientConfigurationBuilder builder) {
		if (urlUsesSsl()) {
			builder.useSsl();
		}
	}
	/**
	 * Inner class to allow optional commons-pool2 dependency.
	 */
	private static final class PoolBuilderFactory {
		LettuceClientConfigurationBuilder createBuilder(Pool properties) {
			return LettucePoolingClientConfiguration.builder().poolConfig(getPoolConfig(properties));
		}
		private GenericObjectPoolConfig<?> getPoolConfig(Pool properties) {
			GenericObjectPoolConfig<?> config = new GenericObjectPoolConfig<>();
			config.setMaxTotal(properties.getMaxActive());
			config.setMaxIdle(properties.getMaxIdle());
			config.setMinIdle(properties.getMinIdle());
			if (properties.getTimeBetweenEvictionRuns() != null) {
				config.setTimeBetweenEvictionRuns(properties.getTimeBetweenEvictionRuns());
			}
			if (properties.getMaxWait() != null) {
				config.setMaxWait(properties.getMaxWait());
			}
			return config;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
public interface RedisConnectionDetails extends ConnectionDetails {
	/**
	 * Login username of the redis server.
	 * @return the login username of the redis server
	 */
	default String getUsername() {
		return null;
	}
	/**
	 * Login password of the redis server.
	 * @return the login password of the redis server
	 */
	default String getPassword() {
		return null;
	}
	/**
	 * Redis standalone configuration. Mutually exclusive with {@link #getSentinel()} and
	 * {@link #getCluster()}.
	 * @return the Redis standalone configuration
	 */
	default Standalone getStandalone() {
		return null;
	}
	/**
	 * Redis sentinel configuration. Mutually exclusive with {@link #getStandalone()} and
	 * {@link #getCluster()}.
	 * @return the Redis sentinel configuration
	 */
	default Sentinel getSentinel() {
		return null;
	}
	/**
	 * Redis cluster configuration. Mutually exclusive with {@link #getStandalone()} and
	 * {@link #getSentinel()}.
	 * @return the Redis cluster configuration
	 */
	default Cluster getCluster() {
		return null;
	}
	/**
	 * Redis standalone configuration.
	 */
	interface Standalone {
		/**
		 * Redis server host.
		 * @return the redis server host
		 */
		String getHost();
		/**
		 * Redis server port.
		 * @return the redis server port
		 */
		int getPort();
		/**
		 * Database index used by the connection factory.
		 * @return the database index used by the connection factory
		 */
		default int getDatabase() {
			return 0;
		}
		static Standalone of(String host, int port) {
			return of(host, port, 0);
		}
		static Standalone of(String host, int port, int database) {
			Assert.hasLength(host, 'Host must not be empty');
			return new Standalone() {
				@Override
				public String getHost() {
					return host;
				}
				@Override
				public int getPort() {
					return port;
				}
				@Override
				public int getDatabase() {
					return database;
				}
			};
		}
	}
	/**
	 * Redis sentinel configuration.
	 */
	interface Sentinel {
		/**
		 * Database index used by the connection factory.
		 * @return the database index used by the connection factory
		 */
		int getDatabase();
		/**
		 * Name of the Redis server.
		 * @return the name of the Redis server
		 */
		String getMaster();
		/**
		 * List of nodes.
		 * @return the list of nodes
		 */
		List<Node> getNodes();
		/**
		 * Login username for authenticating with sentinel(s).
		 * @return the login username for authenticating with sentinel(s) or {@code null}
		 */
		String getUsername();
		/**
		 * Password for authenticating with sentinel(s).
		 * @return the password for authenticating with sentinel(s) or {@code null}
		 */
		String getPassword();
	}
	/**
	 * Redis cluster configuration.
	 */
	interface Cluster {
		/**
		 * Nodes to bootstrap from. This represents an 'initial' list of cluster nodes and
		 * is required to have at least one entry.
		 * @return nodes to bootstrap from
		 */
		List<Node> getNodes();
	}
	/**
	 * A node in a sentinel or cluster configuration.
	 *
	 * @param host the hostname of the node
	 * @param port the port of the node
	 */
	record Node(String host, int port) {
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class RedisUrlSyntaxException extends RuntimeException {
	private final String url;
	RedisUrlSyntaxException(String url, Exception cause) {
		super(buildMessage(url), cause);
		this.url = url;
	}
	RedisUrlSyntaxException(String url) {
		super(buildMessage(url));
		this.url = url;
	}
	String getUrl() {
		return this.url;
	}
	private static String buildMessage(String url) {
		return 'Invalid Redis URL "' + url + '"';
	}
}
/*
package org.springframework.boot.autoconfigure.data;
/**
class OnRepositoryTypeCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnRepositoryType.class.getName(),
				true);
		RepositoryType configuredType = getTypeProperty(context.getEnvironment(), (String) attributes.get('store'));
		RepositoryType requiredType = (RepositoryType) attributes.get('type');
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnRepositoryType.class);
		if (configuredType == requiredType || configuredType == RepositoryType.AUTO) {
			return ConditionOutcome
				.match(message.because('configured type of "' + configuredType.name() + '" matched required type'));
		}
		return ConditionOutcome.noMatch(message.because('configured type (' + configuredType.name()
				+ ') did not match required type (' + requiredType.name() + ')'));
	}
	private RepositoryType getTypeProperty(Environment environment, String store) {
		return RepositoryType
			.valueOf(environment.getProperty(String.format('spring.data.%s.repositories.type', store), 'auto')
				.toUpperCase(Locale.ENGLISH));
	}
}
/*
package org.springframework.boot.autoconfigure.data;
/**
public abstract class AbstractRepositoryConfigurationSourceSupport
		implements ImportBeanDefinitionRegistrar, BeanFactoryAware, ResourceLoaderAware, EnvironmentAware {
	private ResourceLoader resourceLoader;
	private BeanFactory beanFactory;
	private Environment environment;
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,
			BeanNameGenerator importBeanNameGenerator) {
		RepositoryConfigurationDelegate delegate = new RepositoryConfigurationDelegate(
				getConfigurationSource(registry, importBeanNameGenerator), this.resourceLoader, this.environment);
		delegate.registerRepositoriesIn(registry, getRepositoryConfigurationExtension());
	}
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		registerBeanDefinitions(importingClassMetadata, registry, null);
	}
	private AnnotationRepositoryConfigurationSource getConfigurationSource(BeanDefinitionRegistry registry,
			BeanNameGenerator importBeanNameGenerator) {
		AnnotationMetadata metadata = AnnotationMetadata.introspect(getConfiguration());
		return new AutoConfiguredAnnotationRepositoryConfigurationSource(metadata, getAnnotation(), this.resourceLoader,
				this.environment, registry, importBeanNameGenerator) {
		};
	}
	protected Streamable<String> getBasePackages() {
		return Streamable.of(AutoConfigurationPackages.get(this.beanFactory));
	}
	/**
	 * The Spring Data annotation used to enable the particular repository support.
	 * @return the annotation class
	 */
	protected abstract Class<? extends Annotation> getAnnotation();
	/**
	 * The configuration class that will be used by Spring Boot as a template.
	 * @return the configuration class
	 */
	protected abstract Class<?> getConfiguration();
	/**
	 * The {@link RepositoryConfigurationExtension} for the particular repository support.
	 * @return the repository configuration extension
	 */
	protected abstract RepositoryConfigurationExtension getRepositoryConfigurationExtension();
	/**
	 * The {@link BootstrapMode} for the particular repository support. Defaults to
	 * {@link BootstrapMode#DEFAULT}.
	 * @return the bootstrap mode
	 */
	protected BootstrapMode getBootstrapMode() {
		return BootstrapMode.DEFAULT;
	}
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		this.beanFactory = beanFactory;
	}
	@Override
	public void setEnvironment(Environment environment) {
		this.environment = environment;
	}
	/**
	 * An auto-configured {@link AnnotationRepositoryConfigurationSource}.
	 */
	private class AutoConfiguredAnnotationRepositoryConfigurationSource
			extends AnnotationRepositoryConfigurationSource {
		AutoConfiguredAnnotationRepositoryConfigurationSource(AnnotationMetadata metadata,
				Class<? extends Annotation> annotation, ResourceLoader resourceLoader, Environment environment,
				BeanDefinitionRegistry registry, BeanNameGenerator generator) {
			super(metadata, annotation, resourceLoader, environment, registry, generator);
		}
		@Override
		public Streamable<String> getBasePackages() {
			return AbstractRepositoryConfigurationSourceSupport.this.getBasePackages();
		}
		@Override
		public BootstrapMode getBootstrapMode() {
			return AbstractRepositoryConfigurationSourceSupport.this.getBootstrapMode();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.r2dbc;
/**
@AutoConfiguration(after = R2dbcDataAutoConfiguration.class)
@ConditionalOnClass({ ConnectionFactory.class, R2dbcRepository.class })
@ConditionalOnBean(DatabaseClient.class)
@ConditionalOnProperty(prefix = 'spring.data.r2dbc.repositories', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
@ConditionalOnMissingBean(R2dbcRepositoryFactoryBean.class)
@Import(R2dbcRepositoriesAutoConfigureRegistrar.class)
public class R2dbcRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.r2dbc;
/**
class R2dbcRepositoriesAutoConfigureRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableR2dbcRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableR2dbcRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new R2dbcRepositoryConfigurationExtension();
	}
	@EnableR2dbcRepositories
	private static final class EnableR2dbcRepositoriesConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.r2dbc;
/*
package org.springframework.boot.autoconfigure.data.r2dbc;
/**
@AutoConfiguration(after = R2dbcAutoConfiguration.class)
@ConditionalOnClass({ DatabaseClient.class, R2dbcEntityTemplate.class })
@ConditionalOnSingleCandidate(DatabaseClient.class)
public class R2dbcDataAutoConfiguration {
	private final DatabaseClient databaseClient;
	private final R2dbcDialect dialect;
	public R2dbcDataAutoConfiguration(DatabaseClient databaseClient) {
		this.databaseClient = databaseClient;
		this.dialect = DialectResolver.getDialect(this.databaseClient.getConnectionFactory());
	}
	@Bean
	@ConditionalOnMissingBean
	public R2dbcEntityTemplate r2dbcEntityTemplate(R2dbcConverter r2dbcConverter) {
		return new R2dbcEntityTemplate(this.databaseClient, this.dialect, r2dbcConverter);
	}
	@Bean
	@ConditionalOnMissingBean
	static RelationalManagedTypes r2dbcManagedTypes(ApplicationContext applicationContext)
			throws ClassNotFoundException {
		return RelationalManagedTypes.fromIterable(new EntityScanner(applicationContext).scan(Table.class));
	}
	@Bean
	@ConditionalOnMissingBean
	public R2dbcMappingContext r2dbcMappingContext(ObjectProvider<NamingStrategy> namingStrategy,
			R2dbcCustomConversions r2dbcCustomConversions, RelationalManagedTypes r2dbcManagedTypes) {
		R2dbcMappingContext relationalMappingContext = new R2dbcMappingContext(
				namingStrategy.getIfAvailable(() -> DefaultNamingStrategy.INSTANCE));
		relationalMappingContext.setSimpleTypeHolder(r2dbcCustomConversions.getSimpleTypeHolder());
		relationalMappingContext.setManagedTypes(r2dbcManagedTypes);
		return relationalMappingContext;
	}
	@Bean
	@ConditionalOnMissingBean
	public MappingR2dbcConverter r2dbcConverter(R2dbcMappingContext mappingContext,
			R2dbcCustomConversions r2dbcCustomConversions) {
		return new MappingR2dbcConverter(mappingContext, r2dbcCustomConversions);
	}
	@Bean
	@ConditionalOnMissingBean
	public R2dbcCustomConversions r2dbcCustomConversions() {
		List<Object> converters = new ArrayList<>(this.dialect.getConverters());
		converters.addAll(R2dbcCustomConversions.STORE_CONVERTERS);
		return new R2dbcCustomConversions(
				CustomConversions.StoreConversions.of(this.dialect.getSimpleTypeHolder(), converters),
				Collections.emptyList());
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data;
/*
package org.springframework.boot.autoconfigure.data.ldap;
/**
@AutoConfiguration
@ConditionalOnClass({ LdapContext.class, LdapRepository.class })
@ConditionalOnProperty(prefix = 'spring.data.ldap.repositories', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
@ConditionalOnMissingBean(LdapRepositoryFactoryBean.class)
@Import(LdapRepositoriesRegistrar.class)
public class LdapRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.ldap;
/**
class LdapRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableLdapRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableLdapRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new LdapRepositoryConfigurationExtension();
	}
	@EnableLdapRepositories
	private static final class EnableLdapRepositoriesConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.data.ldap;
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
@AutoConfiguration(after = MongoDataAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, MongoRepository.class })
@ConditionalOnMissingBean({ MongoRepositoryFactoryBean.class, MongoRepositoryConfigurationExtension.class })
@ConditionalOnRepositoryType(store = 'mongodb', type = RepositoryType.IMPERATIVE)
@Import(MongoRepositoriesRegistrar.class)
public class MongoRepositoriesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
@AutoConfiguration(after = MongoAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, MongoTemplate.class })
@EnableConfigurationProperties(MongoProperties.class)
@Import({ MongoDataConfiguration.class, MongoDatabaseFactoryConfiguration.class,
		MongoDatabaseFactoryDependentConfiguration.class })
public class MongoDataAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(MongoConnectionDetails.class)
	PropertiesMongoConnectionDetails mongoConnectionDetails(MongoProperties properties) {
		return new PropertiesMongoConnectionDetails(properties);
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
@AutoConfiguration(after = MongoReactiveAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, ReactiveMongoTemplate.class })
@ConditionalOnBean(MongoClient.class)
@EnableConfigurationProperties(MongoProperties.class)
@Import(MongoDataConfiguration.class)
public class MongoReactiveDataAutoConfiguration {
	private final MongoConnectionDetails connectionDetails;
	MongoReactiveDataAutoConfiguration(MongoConnectionDetails connectionDetails) {
		this.connectionDetails = connectionDetails;
	}
	@Bean
	@ConditionalOnMissingBean(ReactiveMongoDatabaseFactory.class)
	public SimpleReactiveMongoDatabaseFactory reactiveMongoDatabaseFactory(MongoClient mongo,
			MongoProperties properties) {
		String database = properties.getDatabase();
		if (database == null) {
			database = this.connectionDetails.getConnectionString().getDatabase();
		}
		return new SimpleReactiveMongoDatabaseFactory(mongo, database);
	}
	@Bean
	@ConditionalOnMissingBean(ReactiveMongoOperations.class)
	public ReactiveMongoTemplate reactiveMongoTemplate(ReactiveMongoDatabaseFactory reactiveMongoDatabaseFactory,
			MongoConverter converter) {
		return new ReactiveMongoTemplate(reactiveMongoDatabaseFactory, converter);
	}
	@Bean
	@ConditionalOnMissingBean(DataBufferFactory.class)
	public DefaultDataBufferFactory dataBufferFactory() {
		return new DefaultDataBufferFactory();
	}
	@Bean
	@ConditionalOnMissingBean(ReactiveGridFsOperations.class)
	public ReactiveGridFsTemplate reactiveGridFsTemplate(ReactiveMongoDatabaseFactory reactiveMongoDatabaseFactory,
			MappingMongoConverter mappingMongoConverter, DataBufferFactory dataBufferFactory) {
		return new ReactiveGridFsTemplate(dataBufferFactory,
				new GridFsReactiveMongoDatabaseFactory(reactiveMongoDatabaseFactory, this.connectionDetails),
				mappingMongoConverter,
				(this.connectionDetails.getGridFs() != null) ? this.connectionDetails.getGridFs().getBucket() : null);
	}
	/**
	 * {@link ReactiveMongoDatabaseFactory} decorator to use {@link GridFs#getGridFs()}
	 * from the {@link MongoConnectionDetails} when set.
	 */
	static class GridFsReactiveMongoDatabaseFactory implements ReactiveMongoDatabaseFactory {
		private final ReactiveMongoDatabaseFactory delegate;
		private final MongoConnectionDetails connectionDetails;
		GridFsReactiveMongoDatabaseFactory(ReactiveMongoDatabaseFactory delegate,
				MongoConnectionDetails connectionDetails) {
			this.delegate = delegate;
			this.connectionDetails = connectionDetails;
		}
		@Override
		public boolean hasCodecFor(Class<?> type) {
			return this.delegate.hasCodecFor(type);
		}
		@Override
		public Mono<MongoDatabase> getMongoDatabase() throws DataAccessException {
			String gridFsDatabase = getGridFsDatabase(this.connectionDetails);
			if (StringUtils.hasText(gridFsDatabase)) {
				return this.delegate.getMongoDatabase(gridFsDatabase);
			}
			return this.delegate.getMongoDatabase();
		}
		private String getGridFsDatabase(MongoConnectionDetails connectionDetails) {
			return (connectionDetails.getGridFs() != null) ? connectionDetails.getGridFs().getDatabase() : null;
		}
		@Override
		public Mono<MongoDatabase> getMongoDatabase(String dbName) throws DataAccessException {
			return this.delegate.getMongoDatabase(dbName);
		}
		@Override
		public <T> Optional<Codec<T>> getCodecFor(Class<T> type) {
			return this.delegate.getCodecFor(type);
		}
		@Override
		public PersistenceExceptionTranslator getExceptionTranslator() {
			return this.delegate.getExceptionTranslator();
		}
		@Override
		public CodecRegistry getCodecRegistry() {
			return this.delegate.getCodecRegistry();
		}
		@Override
		public Mono<ClientSession> getSession(ClientSessionOptions options) {
			return this.delegate.getSession(options);
		}
		@Override
		public ReactiveMongoDatabaseFactory withSession(ClientSession session) {
			return this.delegate.withSession(session);
		}
		@Override
		public boolean isTransactionActive() {
			return this.delegate.isTransactionActive();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
@Configuration(proxyBeanMethods = false)
class MongoDataConfiguration {
	@Bean
	@ConditionalOnMissingBean
	static MongoManagedTypes mongoManagedTypes(ApplicationContext applicationContext) throws ClassNotFoundException {
		return MongoManagedTypes.fromIterable(new EntityScanner(applicationContext).scan(Document.class));
	}
	@Bean
	@ConditionalOnMissingBean
	MongoMappingContext mongoMappingContext(MongoProperties properties, MongoCustomConversions conversions,
			MongoManagedTypes managedTypes) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		MongoMappingContext context = new MongoMappingContext();
		map.from(properties.isAutoIndexCreation()).to(context::setAutoIndexCreation);
		context.setManagedTypes(managedTypes);
		Class<?> strategyClass = properties.getFieldNamingStrategy();
		if (strategyClass != null) {
			context.setFieldNamingStrategy((FieldNamingStrategy) BeanUtils.instantiateClass(strategyClass));
		}
		context.setSimpleTypeHolder(conversions.getSimpleTypeHolder());
		return context;
	}
	@Bean
	@ConditionalOnMissingBean
	MongoCustomConversions mongoCustomConversions() {
		return new MongoCustomConversions(Collections.emptyList());
	}
	@Bean
	@ConditionalOnMissingBean(MongoConverter.class)
	MappingMongoConverter mappingMongoConverter(ObjectProvider<MongoDatabaseFactory> factory,
			MongoMappingContext context, MongoCustomConversions conversions) {
		MongoDatabaseFactory mongoDatabaseFactory = factory.getIfAvailable();
		DbRefResolver dbRefResolver = (mongoDatabaseFactory != null) ? new DefaultDbRefResolver(mongoDatabaseFactory)
				: NoOpDbRefResolver.INSTANCE;
		MappingMongoConverter mappingConverter = new MappingMongoConverter(dbRefResolver, context);
		mappingConverter.setCustomConversions(conversions);
		return mappingConverter;
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MongoReactiveRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableReactiveMongoRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableReactiveMongoRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new ReactiveMongoRepositoryConfigurationExtension();
	}
	@EnableReactiveMongoRepositories
	private static final class EnableReactiveMongoRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean(MongoDatabaseFactory.class)
class MongoDatabaseFactoryDependentConfiguration {
	@Bean
	@ConditionalOnMissingBean(MongoOperations.class)
	MongoTemplate mongoTemplate(MongoDatabaseFactory factory, MongoConverter converter) {
		return new MongoTemplate(factory, converter);
	}
	@Bean
	@ConditionalOnMissingBean(GridFsOperations.class)
	GridFsTemplate gridFsTemplate(MongoProperties properties, MongoDatabaseFactory factory, MongoTemplate mongoTemplate,
			MongoConnectionDetails connectionDetails) {
		return new GridFsTemplate(new GridFsMongoDatabaseFactory(factory, connectionDetails),
				mongoTemplate.getConverter(),
				(connectionDetails.getGridFs() != null) ? connectionDetails.getGridFs().getBucket() : null);
	}
	/**
	 * {@link MongoDatabaseFactory} decorator to respect {@link Gridfs#getDatabase()} or
	 * {@link GridFs#getGridFs()} from the {@link MongoConnectionDetails} if set.
	 */
	static class GridFsMongoDatabaseFactory implements MongoDatabaseFactory {
		private final MongoDatabaseFactory mongoDatabaseFactory;
		private final MongoConnectionDetails connectionDetails;
		GridFsMongoDatabaseFactory(MongoDatabaseFactory mongoDatabaseFactory,
				MongoConnectionDetails connectionDetails) {
			Assert.notNull(mongoDatabaseFactory, 'MongoDatabaseFactory must not be null');
			Assert.notNull(connectionDetails, 'ConnectionDetails must not be null');
			this.mongoDatabaseFactory = mongoDatabaseFactory;
			this.connectionDetails = connectionDetails;
		}
		@Override
		public MongoDatabase getMongoDatabase() throws DataAccessException {
			String gridFsDatabase = getGridFsDatabase(this.connectionDetails);
			if (StringUtils.hasText(gridFsDatabase)) {
				return this.mongoDatabaseFactory.getMongoDatabase(gridFsDatabase);
			}
			return this.mongoDatabaseFactory.getMongoDatabase();
		}
		@Override
		public MongoDatabase getMongoDatabase(String dbName) throws DataAccessException {
			return this.mongoDatabaseFactory.getMongoDatabase(dbName);
		}
		@Override
		public PersistenceExceptionTranslator getExceptionTranslator() {
			return this.mongoDatabaseFactory.getExceptionTranslator();
		}
		@Override
		public ClientSession getSession(ClientSessionOptions options) {
			return this.mongoDatabaseFactory.getSession(options);
		}
		@Override
		public MongoDatabaseFactory withSession(ClientSession session) {
			return this.mongoDatabaseFactory.withSession(session);
		}
		private String getGridFsDatabase(MongoConnectionDetails connectionDetails) {
			return (connectionDetails.getGridFs() != null) ? connectionDetails.getGridFs().getDatabase() : null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(MongoDatabaseFactory.class)
@ConditionalOnSingleCandidate(MongoClient.class)
class MongoDatabaseFactoryConfiguration {
	@Bean
	MongoDatabaseFactorySupport<?> mongoDatabaseFactory(MongoClient mongoClient, MongoProperties properties,
			MongoConnectionDetails connectionDetails) {
		String database = properties.getDatabase();
		if (database == null) {
			database = connectionDetails.getConnectionString().getDatabase();
		}
		return new SimpleMongoClientDatabaseFactory(mongoClient, database);
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
@AutoConfiguration(after = MongoReactiveDataAutoConfiguration.class)
@ConditionalOnClass({ MongoClient.class, ReactiveMongoRepository.class })
@ConditionalOnMissingBean({ ReactiveMongoRepositoryFactoryBean.class,
		ReactiveMongoRepositoryConfigurationExtension.class })
@ConditionalOnRepositoryType(store = 'mongodb', type = RepositoryType.REACTIVE)
@Import(MongoReactiveRepositoriesRegistrar.class)
public class MongoReactiveRepositoriesAutoConfiguration {
}
/*
/**
package org.springframework.boot.autoconfigure.data.mongo;
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MongoRepositoriesRegistrar extends AbstractRepositoryConfigurationSourceSupport {
	@Override
	protected Class<? extends Annotation> getAnnotation() {
		return EnableMongoRepositories.class;
	}
	@Override
	protected Class<?> getConfiguration() {
		return EnableMongoRepositoriesConfiguration.class;
	}
	@Override
	protected RepositoryConfigurationExtension getRepositoryConfigurationExtension() {
		return new MongoRepositoryConfigurationExtension();
	}
	@EnableMongoRepositories
	private static final class EnableMongoRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.logging;
/**
class ConditionEvaluationReportLoggingProcessor implements BeanFactoryInitializationAotProcessor {
	@Override
	public BeanFactoryInitializationAotContribution processAheadOfTime(ConfigurableListableBeanFactory beanFactory) {
		logConditionEvaluationReport(beanFactory);
		return null;
	}
	private void logConditionEvaluationReport(ConfigurableListableBeanFactory beanFactory) {
		new ConditionEvaluationReportLogger(LogLevel.DEBUG, () -> ConditionEvaluationReport.get(beanFactory))
			.logReport(false);
	}
}
/*
package org.springframework.boot.autoconfigure.logging;
/**
public class ConditionEvaluationReportMessage {
	private final StringBuilder message;
	public ConditionEvaluationReportMessage(ConditionEvaluationReport report) {
		this(report, 'CONDITIONS EVALUATION REPORT');
	}
	public ConditionEvaluationReportMessage(ConditionEvaluationReport report, String title) {
		this.message = getLogMessage(report, title);
	}
	private StringBuilder getLogMessage(ConditionEvaluationReport report, String title) {
		String separator = '='.repeat(title.length());
		StringBuilder message = new StringBuilder();
		message.append(String.format('%n%n%n'));
		message.append(String.format('%s%n', separator));
		message.append(String.format('%s%n', title));
		message.append(String.format('%s%n%n%n', separator));
		Map<String, ConditionAndOutcomes> shortOutcomes = orderByName(report.getConditionAndOutcomesBySource());
		logPositiveMatches(message, shortOutcomes);
		logNegativeMatches(message, shortOutcomes);
		logExclusions(report, message);
		logUnconditionalClasses(report, message);
		message.append(String.format('%n%n'));
		return message;
	}
	private void logPositiveMatches(StringBuilder message, Map<String, ConditionAndOutcomes> shortOutcomes) {
		message.append(String.format('Positive matches:%n'));
		message.append(String.format('-----------------%n'));
		List<Entry<String, ConditionAndOutcomes>> matched = shortOutcomes.entrySet()
			.stream()
			.filter((entry) -> entry.getValue().isFullMatch())
			.toList();
		if (matched.isEmpty()) {
			message.append(String.format('%n    None%n'));
		}
		else {
			matched.forEach((entry) -> addMatchLogMessage(message, entry.getKey(), entry.getValue()));
		}
		message.append(String.format('%n%n'));
	}
	private void logNegativeMatches(StringBuilder message, Map<String, ConditionAndOutcomes> shortOutcomes) {
		message.append(String.format('Negative matches:%n'));
		message.append(String.format('-----------------%n'));
		List<Entry<String, ConditionAndOutcomes>> nonMatched = shortOutcomes.entrySet()
			.stream()
			.filter((entry) -> !entry.getValue().isFullMatch())
			.toList();
		if (nonMatched.isEmpty()) {
			message.append(String.format('%n    None%n'));
		}
		else {
			nonMatched.forEach((entry) -> addNonMatchLogMessage(message, entry.getKey(), entry.getValue()));
		}
		message.append(String.format('%n%n'));
	}
	private void logExclusions(ConditionEvaluationReport report, StringBuilder message) {
		message.append(String.format('Exclusions:%n'));
		message.append(String.format('-----------%n'));
		if (report.getExclusions().isEmpty()) {
			message.append(String.format('%n    None%n'));
		}
		else {
			for (String exclusion : report.getExclusions()) {
				message.append(String.format('%n    %s%n', exclusion));
			}
		}
		message.append(String.format('%n%n'));
	}
	private void logUnconditionalClasses(ConditionEvaluationReport report, StringBuilder message) {
		message.append(String.format('Unconditional classes:%n'));
		message.append(String.format('----------------------%n'));
		if (report.getUnconditionalClasses().isEmpty()) {
			message.append(String.format('%n    None%n'));
		}
		else {
			for (String unconditionalClass : report.getUnconditionalClasses()) {
				message.append(String.format('%n    %s%n', unconditionalClass));
			}
		}
	}
	private Map<String, ConditionAndOutcomes> orderByName(Map<String, ConditionAndOutcomes> outcomes) {
		MultiValueMap<String, String> map = mapToFullyQualifiedNames(outcomes.keySet());
		List<String> shortNames = new ArrayList<>(map.keySet());
		Collections.sort(shortNames);
		Map<String, ConditionAndOutcomes> result = new LinkedHashMap<>();
		for (String shortName : shortNames) {
			List<String> fullyQualifiedNames = map.get(shortName);
			if (fullyQualifiedNames.size() > 1) {
				fullyQualifiedNames
					.forEach((fullyQualifiedName) -> result.put(fullyQualifiedName, outcomes.get(fullyQualifiedName)));
			}
			else {
				result.put(shortName, outcomes.get(fullyQualifiedNames.get(0)));
			}
		}
		return result;
	}
	private MultiValueMap<String, String> mapToFullyQualifiedNames(Set<String> keySet) {
		LinkedMultiValueMap<String, String> map = new LinkedMultiValueMap<>();
		keySet
			.forEach((fullyQualifiedName) -> map.add(ClassUtils.getShortName(fullyQualifiedName), fullyQualifiedName));
		return map;
	}
	private void addMatchLogMessage(StringBuilder message, String source, ConditionAndOutcomes matches) {
		message.append(String.format('%n   %s matched:%n', source));
		for (ConditionAndOutcome match : matches) {
			logConditionAndOutcome(message, '      ', match);
		}
	}
	private void addNonMatchLogMessage(StringBuilder message, String source,
			ConditionAndOutcomes conditionAndOutcomes) {
		message.append(String.format('%n   %s:%n', source));
		List<ConditionAndOutcome> matches = new ArrayList<>();
		List<ConditionAndOutcome> nonMatches = new ArrayList<>();
		for (ConditionAndOutcome conditionAndOutcome : conditionAndOutcomes) {
			if (conditionAndOutcome.getOutcome().isMatch()) {
				matches.add(conditionAndOutcome);
			}
			else {
				nonMatches.add(conditionAndOutcome);
			}
		}
		message.append(String.format('      Did not match:%n'));
		for (ConditionAndOutcome nonMatch : nonMatches) {
			logConditionAndOutcome(message, '         ', nonMatch);
		}
		if (!matches.isEmpty()) {
			message.append(String.format('      Matched:%n'));
			for (ConditionAndOutcome match : matches) {
				logConditionAndOutcome(message, '         ', match);
			}
		}
	}
	private void logConditionAndOutcome(StringBuilder message, String indent, ConditionAndOutcome conditionAndOutcome) {
		message.append(String.format('%s- ', indent));
		String outcomeMessage = conditionAndOutcome.getOutcome().getMessage();
		if (StringUtils.hasLength(outcomeMessage)) {
			message.append(outcomeMessage);
		}
		else {
			message.append(conditionAndOutcome.getOutcome().isMatch() ? 'matched' : 'did not match');
		}
		message.append(' (');
		message.append(ClassUtils.getShortName(conditionAndOutcome.getCondition().getClass()));
		message.append(String.format(')%n'));
	}
	@Override
	public String toString() {
		return this.message.toString();
	}
}
/*
package org.springframework.boot.autoconfigure.logging;
/**
public class ConditionEvaluationReportLoggingListener
		implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	private final LogLevel logLevelForReport;
	public ConditionEvaluationReportLoggingListener() {
		this(LogLevel.DEBUG);
	}
	private ConditionEvaluationReportLoggingListener(LogLevel logLevelForReport) {
		Assert.isTrue(isInfoOrDebug(logLevelForReport), 'LogLevel must be INFO or DEBUG');
		this.logLevelForReport = logLevelForReport;
	}
	private boolean isInfoOrDebug(LogLevel logLevelForReport) {
		return LogLevel.INFO.equals(logLevelForReport) || LogLevel.DEBUG.equals(logLevelForReport);
	}
	/**
	 * Static factory method that creates a
	 * {@link ConditionEvaluationReportLoggingListener} which logs the report at the
	 * specified log level.
	 * @param logLevelForReport the log level to log the report at
	 * @return a {@link ConditionEvaluationReportLoggingListener} instance.
	 * @since 3.0.0
	 */
	public static ConditionEvaluationReportLoggingListener forLogLevel(LogLevel logLevelForReport) {
		return new ConditionEvaluationReportLoggingListener(logLevelForReport);
	}
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		applicationContext.addApplicationListener(new ConditionEvaluationReportListener(applicationContext));
	}
	private final class ConditionEvaluationReportListener implements GenericApplicationListener {
		private final ConfigurableApplicationContext context;
		private final ConditionEvaluationReportLogger logger;
		private ConditionEvaluationReportListener(ConfigurableApplicationContext context) {
			this.context = context;
			Supplier<ConditionEvaluationReport> reportSupplier;
			if (context instanceof GenericApplicationContext) {
				// Get the report early when the context allows early access to the bean
				// factory in case the context subsequently fails to load
				ConditionEvaluationReport report = getReport();
				reportSupplier = () -> report;
			}
			else {
				reportSupplier = this::getReport;
			}
			this.logger = new ConditionEvaluationReportLogger(
					ConditionEvaluationReportLoggingListener.this.logLevelForReport, reportSupplier);
		}
		private ConditionEvaluationReport getReport() {
			return ConditionEvaluationReport.get(this.context.getBeanFactory());
		}
		@Override
		public int getOrder() {
			return Ordered.LOWEST_PRECEDENCE;
		}
		@Override
		public boolean supportsEventType(ResolvableType resolvableType) {
			Class<?> type = resolvableType.getRawClass();
			if (type == null) {
				return false;
			}
			return ContextRefreshedEvent.class.isAssignableFrom(type)
					|| ApplicationFailedEvent.class.isAssignableFrom(type);
		}
		@Override
		public boolean supportsSourceType(Class<?> sourceType) {
			return true;
		}
		@Override
		public void onApplicationEvent(ApplicationEvent event) {
			if (event instanceof ContextRefreshedEvent contextRefreshedEvent) {
				if (contextRefreshedEvent.getApplicationContext() == this.context) {
					this.logger.logReport(false);
				}
			}
			else if (event instanceof ApplicationFailedEvent applicationFailedEvent
					&& applicationFailedEvent.getApplicationContext() == this.context) {
				this.logger.logReport(true);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.logging;
/**
class ConditionEvaluationReportLogger {
	private final Log logger = LogFactory.getLog(getClass());
	private final Supplier<ConditionEvaluationReport> reportSupplier;
	private final LogLevel logLevel;
	ConditionEvaluationReportLogger(LogLevel logLevel, Supplier<ConditionEvaluationReport> reportSupplier) {
		Assert.isTrue(isInfoOrDebug(logLevel), 'LogLevel must be INFO or DEBUG');
		this.logLevel = logLevel;
		this.reportSupplier = reportSupplier;
	}
	private boolean isInfoOrDebug(LogLevel logLevelForReport) {
		return LogLevel.INFO.equals(logLevelForReport) || LogLevel.DEBUG.equals(logLevelForReport);
	}
	void logReport(boolean isCrashReport) {
		ConditionEvaluationReport report = this.reportSupplier.get();
		if (report == null) {
			this.logger.info('Unable to provide the condition evaluation report');
			return;
		}
		if (!report.getConditionAndOutcomesBySource().isEmpty()) {
			if (this.logLevel.equals(LogLevel.INFO)) {
				if (this.logger.isInfoEnabled()) {
					this.logger.info(new ConditionEvaluationReportMessage(report));
				}
				else if (isCrashReport) {
					logMessage('info');
				}
			}
			else {
				if (this.logger.isDebugEnabled()) {
					this.logger.debug(new ConditionEvaluationReportMessage(report));
				}
				else if (isCrashReport) {
					logMessage('debug');
				}
			}
		}
	}
	private void logMessage(String logLevel) {
		this.logger.info(String.format('%n%nError starting ApplicationContext. To display the '
				+ 'condition evaluation report re-run your application with "%s" enabled.', logLevel));
	}
}
/*
/**
package org.springframework.boot.autoconfigure.logging;
/*
package org.springframework.boot.autoconfigure.gson;
/**
@ConfigurationProperties(prefix = 'spring.gson')
public class GsonProperties {
	/**
	 * Whether to generate non-executable JSON by prefixing the output with some special
	 * text.
	 */
	private Boolean generateNonExecutableJson;
	/**
	 * Whether to exclude all fields from consideration for serialization or
	 * deserialization that do not have the 'Expose' annotation.
	 */
	private Boolean excludeFieldsWithoutExposeAnnotation;
	/**
	 * Whether to serialize null fields.
	 */
	private Boolean serializeNulls;
	/**
	 * Whether to enable serialization of complex map keys (i.e. non-primitives).
	 */
	private Boolean enableComplexMapKeySerialization;
	/**
	 * Whether to exclude inner classes during serialization.
	 */
	private Boolean disableInnerClassSerialization;
	/**
	 * Serialization policy for Long and long types.
	 */
	private LongSerializationPolicy longSerializationPolicy;
	/**
	 * Naming policy that should be applied to an object"s field during serialization and
	 * deserialization.
	 */
	private FieldNamingPolicy fieldNamingPolicy;
	/**
	 * Whether to output serialized JSON that fits in a page for pretty printing.
	 */
	private Boolean prettyPrinting;
	/**
	 * Sets how strictly the RFC 8259 specification will be enforced when reading and
	 * writing JSON.
	 */
	private Strictness strictness;
	/**
	 * Whether to disable the escaping of HTML characters such as "<", ">", etc.
	 */
	private Boolean disableHtmlEscaping;
	/**
	 * Format to use when serializing Date objects.
	 */
	private String dateFormat;
	public Boolean getGenerateNonExecutableJson() {
		return this.generateNonExecutableJson;
	}
	public void setGenerateNonExecutableJson(Boolean generateNonExecutableJson) {
		this.generateNonExecutableJson = generateNonExecutableJson;
	}
	public Boolean getExcludeFieldsWithoutExposeAnnotation() {
		return this.excludeFieldsWithoutExposeAnnotation;
	}
	public void setExcludeFieldsWithoutExposeAnnotation(Boolean excludeFieldsWithoutExposeAnnotation) {
		this.excludeFieldsWithoutExposeAnnotation = excludeFieldsWithoutExposeAnnotation;
	}
	public Boolean getSerializeNulls() {
		return this.serializeNulls;
	}
	public void setSerializeNulls(Boolean serializeNulls) {
		this.serializeNulls = serializeNulls;
	}
	public Boolean getEnableComplexMapKeySerialization() {
		return this.enableComplexMapKeySerialization;
	}
	public void setEnableComplexMapKeySerialization(Boolean enableComplexMapKeySerialization) {
		this.enableComplexMapKeySerialization = enableComplexMapKeySerialization;
	}
	public Boolean getDisableInnerClassSerialization() {
		return this.disableInnerClassSerialization;
	}
	public void setDisableInnerClassSerialization(Boolean disableInnerClassSerialization) {
		this.disableInnerClassSerialization = disableInnerClassSerialization;
	}
	public LongSerializationPolicy getLongSerializationPolicy() {
		return this.longSerializationPolicy;
	}
	public void setLongSerializationPolicy(LongSerializationPolicy longSerializationPolicy) {
		this.longSerializationPolicy = longSerializationPolicy;
	}
	public FieldNamingPolicy getFieldNamingPolicy() {
		return this.fieldNamingPolicy;
	}
	public void setFieldNamingPolicy(FieldNamingPolicy fieldNamingPolicy) {
		this.fieldNamingPolicy = fieldNamingPolicy;
	}
	public Boolean getPrettyPrinting() {
		return this.prettyPrinting;
	}
	public void setPrettyPrinting(Boolean prettyPrinting) {
		this.prettyPrinting = prettyPrinting;
	}
	public Strictness getStrictness() {
		return this.strictness;
	}
	public void setStrictness(Strictness strictness) {
		this.strictness = strictness;
	}
	@Deprecated(since = '3.4.0', forRemoval = true)
	@DeprecatedConfigurationProperty(replacement = 'spring.gson.strictness', since = '3.4.0')
	public Boolean getLenient() {
		return (this.strictness != null) && (this.strictness == Strictness.LENIENT);
	}
	public void setLenient(Boolean lenient) {
		setStrictness((lenient != null && lenient) ? Strictness.LENIENT : Strictness.STRICT);
	}
	public Boolean getDisableHtmlEscaping() {
		return this.disableHtmlEscaping;
	}
	public void setDisableHtmlEscaping(Boolean disableHtmlEscaping) {
		this.disableHtmlEscaping = disableHtmlEscaping;
	}
	public String getDateFormat() {
		return this.dateFormat;
	}
	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}
}
/*
package org.springframework.boot.autoconfigure.gson;
/**
@FunctionalInterface
public interface GsonBuilderCustomizer {
	/**
	 * Customize the GsonBuilder.
	 * @param gsonBuilder the GsonBuilder to customize
	 */
	void customize(GsonBuilder gsonBuilder);
}
/*
package org.springframework.boot.autoconfigure.gson;
/**
@AutoConfiguration
@ConditionalOnClass(Gson.class)
@EnableConfigurationProperties(GsonProperties.class)
public class GsonAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public GsonBuilder gsonBuilder(List<GsonBuilderCustomizer> customizers) {
		GsonBuilder builder = new GsonBuilder();
		customizers.forEach((c) -> c.customize(builder));
		return builder;
	}
	@Bean
	@ConditionalOnMissingBean
	public Gson gson(GsonBuilder gsonBuilder) {
		return gsonBuilder.create();
	}
	@Bean
	public StandardGsonBuilderCustomizer standardGsonBuilderCustomizer(GsonProperties gsonProperties) {
		return new StandardGsonBuilderCustomizer(gsonProperties);
	}
	static final class StandardGsonBuilderCustomizer implements GsonBuilderCustomizer, Ordered {
		private final GsonProperties properties;
		StandardGsonBuilderCustomizer(GsonProperties properties) {
			this.properties = properties;
		}
		@Override
		public int getOrder() {
			return 0;
		}
		@Override
		public void customize(GsonBuilder builder) {
			GsonProperties properties = this.properties;
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(properties::getGenerateNonExecutableJson).whenTrue().toCall(builder::generateNonExecutableJson);
			map.from(properties::getExcludeFieldsWithoutExposeAnnotation)
				.whenTrue()
				.toCall(builder::excludeFieldsWithoutExposeAnnotation);
			map.from(properties::getSerializeNulls).whenTrue().toCall(builder::serializeNulls);
			map.from(properties::getEnableComplexMapKeySerialization)
				.whenTrue()
				.toCall(builder::enableComplexMapKeySerialization);
			map.from(properties::getDisableInnerClassSerialization)
				.whenTrue()
				.toCall(builder::disableInnerClassSerialization);
			map.from(properties::getLongSerializationPolicy).to(builder::setLongSerializationPolicy);
			map.from(properties::getFieldNamingPolicy).to(builder::setFieldNamingPolicy);
			map.from(properties::getPrettyPrinting).whenTrue().toCall(builder::setPrettyPrinting);
			map.from(properties::getStrictness).to(builder::setStrictness);
			map.from(properties::getDisableHtmlEscaping).whenTrue().toCall(builder::disableHtmlEscaping);
			map.from(properties::getDateFormat).to(builder::setDateFormat);
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.gson;
/*
package org.springframework.boot.autoconfigure;
/**
class ImportAutoConfigurationImportSelector extends AutoConfigurationImportSelector implements DeterminableImports {
	private static final String OPTIONAL_PREFIX = 'optional:';
	private static final Set<String> ANNOTATION_NAMES;
	static {
		Set<String> names = new LinkedHashSet<>();
		names.add(ImportAutoConfiguration.class.getName());
		names.add('org.springframework.boot.autoconfigure.test.ImportAutoConfiguration');
		ANNOTATION_NAMES = Collections.unmodifiableSet(names);
	}
	@Override
	public Set<Object> determineImports(AnnotationMetadata metadata) {
		List<String> candidateConfigurations = getCandidateConfigurations(metadata, null);
		Set<String> result = new LinkedHashSet<>(candidateConfigurations);
		result.removeAll(getExclusions(metadata, null));
		return Collections.unmodifiableSet(result);
	}
	@Override
	protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) {
		return null;
	}
	@Override
	protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		List<String> candidates = new ArrayList<>();
		Map<Class<?>, List<Annotation>> annotations = getAnnotations(metadata);
		annotations.forEach(
				(source, sourceAnnotations) -> collectCandidateConfigurations(source, sourceAnnotations, candidates));
		return candidates;
	}
	private void collectCandidateConfigurations(Class<?> source, List<Annotation> annotations,
			List<String> candidates) {
		for (Annotation annotation : annotations) {
			candidates.addAll(getConfigurationsForAnnotation(source, annotation));
		}
	}
	private Collection<String> getConfigurationsForAnnotation(Class<?> source, Annotation annotation) {
		String[] classes = (String[]) AnnotationUtils.getAnnotationAttributes(annotation, true).get('classes');
		if (classes.length > 0) {
			return Arrays.asList(classes);
		}
		return loadFactoryNames(source).stream().map(this::mapFactoryName).filter(Objects::nonNull).toList();
	}
	private String mapFactoryName(String name) {
		if (!name.startsWith(OPTIONAL_PREFIX)) {
			return name;
		}
		name = name.substring(OPTIONAL_PREFIX.length());
		return (!present(name)) ? null : name;
	}
	private boolean present(String className) {
		String resourcePath = ClassUtils.convertClassNameToResourcePath(className) + '.class';
		return new ClassPathResource(resourcePath).exists();
	}
	protected Collection<String> loadFactoryNames(Class<?> source) {
		return ImportCandidates.load(source, getBeanClassLoader()).getCandidates();
	}
	@Override
	protected Set<String> getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		Set<String> exclusions = new LinkedHashSet<>();
		Class<?> source = ClassUtils.resolveClassName(metadata.getClassName(), getBeanClassLoader());
		for (String annotationName : ANNOTATION_NAMES) {
			AnnotationAttributes merged = AnnotatedElementUtils.getMergedAnnotationAttributes(source, annotationName);
			Class<?>[] exclude = (merged != null) ? merged.getClassArray('exclude') : null;
			if (exclude != null) {
				for (Class<?> excludeClass : exclude) {
					exclusions.add(excludeClass.getName());
				}
			}
		}
		for (List<Annotation> annotations : getAnnotations(metadata).values()) {
			for (Annotation annotation : annotations) {
				String[] exclude = (String[]) AnnotationUtils.getAnnotationAttributes(annotation, true).get('exclude');
				if (!ObjectUtils.isEmpty(exclude)) {
					exclusions.addAll(Arrays.asList(exclude));
				}
			}
		}
		exclusions.addAll(getExcludeAutoConfigurationsProperty());
		return exclusions;
	}
	protected final Map<Class<?>, List<Annotation>> getAnnotations(AnnotationMetadata metadata) {
		MultiValueMap<Class<?>, Annotation> annotations = new LinkedMultiValueMap<>();
		Class<?> source = ClassUtils.resolveClassName(metadata.getClassName(), getBeanClassLoader());
		collectAnnotations(source, annotations, new HashSet<>());
		return Collections.unmodifiableMap(annotations);
	}
	private void collectAnnotations(Class<?> source, MultiValueMap<Class<?>, Annotation> annotations,
			HashSet<Class<?>> seen) {
		if (source != null && seen.add(source)) {
			for (Annotation annotation : source.getDeclaredAnnotations()) {
				if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation)) {
					if (ANNOTATION_NAMES.contains(annotation.annotationType().getName())) {
						annotations.add(source, annotation);
					}
					collectAnnotations(annotation.annotationType(), annotations, seen);
				}
			}
			collectAnnotations(source.getSuperclass(), annotations, seen);
		}
	}
	@Override
	public int getOrder() {
		return super.getOrder() - 1;
	}
	@Override
	protected void handleInvalidExcludes(List<String> invalidExcludes) {
		// Ignore for test
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
public abstract class HazelcastConfigResourceCondition extends ResourceCondition {
	protected static final String HAZELCAST_CONFIG_PROPERTY = 'spring.hazelcast.config';
	private final String configSystemProperty;
	protected HazelcastConfigResourceCondition(String configSystemProperty, String... resourceLocations) {
		super('Hazelcast', HAZELCAST_CONFIG_PROPERTY, resourceLocations);
		Assert.notNull(configSystemProperty, 'ConfigSystemProperty must not be null');
		this.configSystemProperty = configSystemProperty;
	}
	@Override
	protected ConditionOutcome getResourceOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		if (System.getProperty(this.configSystemProperty) != null) {
			return ConditionOutcome
				.match(startConditionMessage().because('System property "' + this.configSystemProperty + '" is set.'));
		}
		return super.getResourceOutcome(context, metadata);
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(HazelcastClient.class)
@ConditionalOnMissingBean(HazelcastInstance.class)
@Import({ HazelcastConnectionDetailsConfiguration.class, HazelcastClientInstanceConfiguration.class })
class HazelcastClientConfiguration {
	static final String CONFIG_SYSTEM_PROPERTY = 'hazelcast.client.config';
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@AutoConfiguration(after = { HazelcastAutoConfiguration.class, HibernateJpaAutoConfiguration.class })
@ConditionalOnClass({ HazelcastInstance.class, LocalContainerEntityManagerFactoryBean.class })
@Import(HazelcastInstanceEntityManagerFactoryDependsOnPostProcessor.class)
public class HazelcastJpaDependencyAutoConfiguration {
	@Conditional(OnHazelcastAndJpaCondition.class)
	static class HazelcastInstanceEntityManagerFactoryDependsOnPostProcessor
			extends EntityManagerFactoryDependsOnPostProcessor {
		HazelcastInstanceEntityManagerFactoryDependsOnPostProcessor() {
			super('hazelcastInstance');
		}
	}
	static class OnHazelcastAndJpaCondition extends AllNestedConditions {
		OnHazelcastAndJpaCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnBean(name = 'hazelcastInstance')
		static class HasHazelcastInstance {
		}
		@ConditionalOnBean(AbstractEntityManagerFactoryBean.class)
		static class HasJpa {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean(HazelcastConnectionDetails.class)
class HazelcastClientInstanceConfiguration {
	@Bean
	HazelcastInstance hazelcastInstance(HazelcastConnectionDetails hazelcastConnectionDetails) {
		ClientConfig config = hazelcastConnectionDetails.getClientConfig();
		return (!StringUtils.hasText(config.getInstanceName())) ? HazelcastClient.newHazelcastClient(config)
				: HazelcastClient.getOrCreateHazelcastClient(config);
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(HazelcastInstance.class)
class HazelcastServerConfiguration {
	static final String CONFIG_SYSTEM_PROPERTY = 'hazelcast.config';
	static final String HAZELCAST_LOGGING_TYPE = 'hazelcast.logging.type';
	private static HazelcastInstance getHazelcastInstance(Config config) {
		if (StringUtils.hasText(config.getInstanceName())) {
			return Hazelcast.getOrCreateHazelcastInstance(config);
		}
		return Hazelcast.newHazelcastInstance(config);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(Config.class)
	@Conditional(ConfigAvailableCondition.class)
	static class HazelcastServerConfigFileConfiguration {
		@Bean
		HazelcastInstance hazelcastInstance(HazelcastProperties properties, ResourceLoader resourceLoader,
				ObjectProvider<HazelcastConfigCustomizer> hazelcastConfigCustomizers) throws IOException {
			Resource configLocation = properties.resolveConfigLocation();
			Config config = (configLocation != null) ? loadConfig(configLocation) : Config.load();
			config.setClassLoader(resourceLoader.getClassLoader());
			hazelcastConfigCustomizers.orderedStream().forEach((customizer) -> customizer.customize(config));
			return getHazelcastInstance(config);
		}
		private Config loadConfig(Resource configLocation) throws IOException {
			URL configUrl = configLocation.getURL();
			Config config = loadConfig(configUrl);
			if (ResourceUtils.isFileURL(configUrl)) {
				config.setConfigurationFile(configLocation.getFile());
			}
			else {
				config.setConfigurationUrl(configUrl);
			}
			return config;
		}
		private Config loadConfig(URL configUrl) throws IOException {
			try (InputStream stream = configUrl.openStream()) {
				return Config.loadFromStream(stream);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(Config.class)
	static class HazelcastServerConfigConfiguration {
		@Bean
		HazelcastInstance hazelcastInstance(Config config) {
			return getHazelcastInstance(config);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(SpringManagedContext.class)
	static class SpringManagedContextHazelcastConfigCustomizerConfiguration {
		@Bean
		@Order(0)
		HazelcastConfigCustomizer springManagedContextHazelcastConfigCustomizer(ApplicationContext applicationContext) {
			return (config) -> {
				SpringManagedContext managementContext = new SpringManagedContext();
				managementContext.setApplicationContext(applicationContext);
				config.setManagedContext(managementContext);
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(org.slf4j.Logger.class)
	static class HazelcastLoggingConfigCustomizerConfiguration {
		@Bean
		@Order(0)
		HazelcastConfigCustomizer loggingHazelcastConfigCustomizer() {
			return (config) -> {
				if (!config.getProperties().containsKey(HAZELCAST_LOGGING_TYPE)) {
					config.setProperty(HAZELCAST_LOGGING_TYPE, 'slf4j');
				}
			};
		}
	}
	/**
	 * {@link HazelcastConfigResourceCondition} that checks if the
	 * {@code spring.hazelcast.config} configuration key is defined.
	 */
	static class ConfigAvailableCondition extends HazelcastConfigResourceCondition {
		ConfigAvailableCondition() {
			super(CONFIG_SYSTEM_PROPERTY, 'file:./hazelcast.xml', 'classpath:/hazelcast.xml', 'file:./hazelcast.yaml',
					'classpath:/hazelcast.yaml', 'file:./hazelcast.yml', 'classpath:/hazelcast.yml');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
public interface HazelcastConnectionDetails extends ConnectionDetails {
	/**
	 * The {@link ClientConfig} for Hazelcast client.
	 * @return the client config
	 */
	ClientConfig getClientConfig();
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
class PropertiesHazelcastConnectionDetails implements HazelcastConnectionDetails {
	private final HazelcastProperties properties;
	private final ResourceLoader resourceLoader;
	PropertiesHazelcastConnectionDetails(HazelcastProperties properties, ResourceLoader resourceLoader) {
		this.properties = properties;
		this.resourceLoader = resourceLoader;
	}
	@Override
	public ClientConfig getClientConfig() {
		Resource configLocation = this.properties.resolveConfigLocation();
		ClientConfig config = (configLocation != null) ? loadClientConfig(configLocation) : ClientConfig.load();
		config.setClassLoader(this.resourceLoader.getClassLoader());
		return config;
	}
	private ClientConfig loadClientConfig(Resource configLocation) {
		try {
			URL configUrl = configLocation.getURL();
			String configFileName = configUrl.getPath().toLowerCase(Locale.ROOT);
			return (!isYaml(configFileName)) ? new XmlClientConfigBuilder(configUrl).build()
					: new YamlClientConfigBuilder(configUrl).build();
		}
		catch (IOException ex) {
			throw new UncheckedIOException('Failed to load Hazelcast config', ex);
		}
	}
	private boolean isYaml(String configFileName) {
		return configFileName.endsWith('.yaml') || configFileName.endsWith('.yml');
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@ConfigurationProperties(prefix = 'spring.hazelcast')
public class HazelcastProperties {
	/**
	 * The location of the configuration file to use to initialize Hazelcast.
	 */
	private Resource config;
	public Resource getConfig() {
		return this.config;
	}
	public void setConfig(Resource config) {
		this.config = config;
	}
	/**
	 * Resolve the config location if set.
	 * @return the location or {@code null} if it is not set
	 * @throws IllegalArgumentException if the config attribute is set to an unknown
	 * location
	 */
	public Resource resolveConfigLocation() {
		if (this.config == null) {
			return null;
		}
		Assert.isTrue(this.config.exists(),
				() -> 'Hazelcast configuration does not exist "' + this.config.getDescription() + '"');
		return this.config;
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(HazelcastConnectionDetails.class)
class HazelcastConnectionDetailsConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ClientConfig.class)
	@Conditional(HazelcastClientConfigAvailableCondition.class)
	static class HazelcastClientConfigFileConfiguration {
		@Bean
		HazelcastConnectionDetails hazelcastConnectionDetails(HazelcastProperties properties,
				ResourceLoader resourceLoader) {
			return new PropertiesHazelcastConnectionDetails(properties, resourceLoader);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(ClientConfig.class)
	static class HazelcastClientConfigConfiguration {
		@Bean
		HazelcastConnectionDetails hazelcastConnectionDetails(ClientConfig config) {
			return () -> config;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.hazelcast;
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
class HazelcastClientConfigAvailableCondition extends HazelcastConfigResourceCondition {
	HazelcastClientConfigAvailableCondition() {
		super(HazelcastClientConfiguration.CONFIG_SYSTEM_PROPERTY, 'file:./hazelcast-client.xml',
				'classpath:/hazelcast-client.xml', 'file:./hazelcast-client.yaml', 'classpath:/hazelcast-client.yaml',
				'file:./hazelcast-client.yml', 'classpath:/hazelcast-client.yml');
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		if (context.getEnvironment().containsProperty(HAZELCAST_CONFIG_PROPERTY)) {
			ConditionOutcome configValidationOutcome = HazelcastClientValidation.clientConfigOutcome(context,
					HAZELCAST_CONFIG_PROPERTY, startConditionMessage());
			return (configValidationOutcome != null) ? configValidationOutcome : ConditionOutcome
				.match(startConditionMessage().foundExactly('property ' + HAZELCAST_CONFIG_PROPERTY));
		}
		return getResourceOutcome(context, metadata);
	}
	static class HazelcastClientValidation {
		static ConditionOutcome clientConfigOutcome(ConditionContext context, String propertyName, Builder builder) {
			String resourcePath = context.getEnvironment().getProperty(propertyName);
			Resource resource = context.getResourceLoader().getResource(resourcePath);
			if (!resource.exists()) {
				return ConditionOutcome.noMatch(builder.because('Hazelcast configuration does not exist'));
			}
			try (InputStream in = resource.getInputStream()) {
				boolean clientConfig = new ClientConfigRecognizer().isRecognized(new ConfigStream(in));
				return new ConditionOutcome(clientConfig, existingConfigurationOutcome(resource, clientConfig));
			}
			catch (Throwable ex) {
				return null;
			}
		}
		private static String existingConfigurationOutcome(Resource resource, boolean client) throws IOException {
			URL location = resource.getURL();
			return client ? 'Hazelcast client configuration detected at "' + location + '"'
					: 'Hazelcast server configuration detected  at "' + location + '"';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@FunctionalInterface
public interface HazelcastConfigCustomizer {
	/**
	 * Customize the configuration.
	 * @param config the {@link Config} to customize
	 */
	void customize(Config config);
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@AutoConfiguration
@ConditionalOnClass(HazelcastInstance.class)
@EnableConfigurationProperties(HazelcastProperties.class)
@Import({ HazelcastClientConfiguration.class, HazelcastServerConfiguration.class })
public class HazelcastAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.info;
/**
@ConfigurationProperties(prefix = 'spring.info')
public class ProjectInfoProperties {
	private final Build build = new Build();
	private final Git git = new Git();
	public Build getBuild() {
		return this.build;
	}
	public Git getGit() {
		return this.git;
	}
	/**
	 * Build specific info properties.
	 */
	public static class Build {
		/**
		 * Location of the generated build-info.properties file.
		 */
		private Resource location = new ClassPathResource('META-INF/build-info.properties');
		/**
		 * File encoding.
		 */
		private Charset encoding = StandardCharsets.UTF_8;
		public Resource getLocation() {
			return this.location;
		}
		public void setLocation(Resource location) {
			this.location = location;
		}
		public Charset getEncoding() {
			return this.encoding;
		}
		public void setEncoding(Charset encoding) {
			this.encoding = encoding;
		}
	}
	/**
	 * Git specific info properties.
	 */
	public static class Git {
		/**
		 * Location of the generated git.properties file.
		 */
		private Resource location = new ClassPathResource('git.properties');
		/**
		 * File encoding.
		 */
		private Charset encoding = StandardCharsets.UTF_8;
		public Resource getLocation() {
			return this.location;
		}
		public void setLocation(Resource location) {
			this.location = location;
		}
		public Charset getEncoding() {
			return this.encoding;
		}
		public void setEncoding(Charset encoding) {
			this.encoding = encoding;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.info;
/*
package org.springframework.boot.autoconfigure.info;
/**
@AutoConfiguration
@EnableConfigurationProperties(ProjectInfoProperties.class)
public class ProjectInfoAutoConfiguration {
	private final ProjectInfoProperties properties;
	public ProjectInfoAutoConfiguration(ProjectInfoProperties properties) {
		this.properties = properties;
	}
	@Conditional(GitResourceAvailableCondition.class)
	@ConditionalOnMissingBean
	@Bean
	public GitProperties gitProperties() throws Exception {
		return new GitProperties(
				loadFrom(this.properties.getGit().getLocation(), 'git', this.properties.getGit().getEncoding()));
	}
	@ConditionalOnResource(resources = '${spring.info.build.location:classpath:META-INF/build-info.properties}')
	@ConditionalOnMissingBean
	@Bean
	public BuildProperties buildProperties() throws Exception {
		return new BuildProperties(
				loadFrom(this.properties.getBuild().getLocation(), 'build', this.properties.getBuild().getEncoding()));
	}
	protected Properties loadFrom(Resource location, String prefix, Charset encoding) throws IOException {
		prefix = prefix.endsWith('.') ? prefix : prefix + '.';
		Properties source = loadSource(location, encoding);
		Properties target = new Properties();
		for (String key : source.stringPropertyNames()) {
			if (key.startsWith(prefix)) {
				target.put(key.substring(prefix.length()), source.get(key));
			}
		}
		return target;
	}
	private Properties loadSource(Resource location, Charset encoding) throws IOException {
		if (encoding != null) {
			return PropertiesLoaderUtils.loadProperties(new EncodedResource(location, encoding));
		}
		return PropertiesLoaderUtils.loadProperties(location);
	}
	static class GitResourceAvailableCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ResourceLoader loader = context.getResourceLoader();
			Environment environment = context.getEnvironment();
			String location = environment.getProperty('spring.info.git.location');
			if (location == null) {
				location = 'classpath:git.properties';
			}
			ConditionMessage.Builder message = ConditionMessage.forCondition('GitResource');
			if (loader.getResource(location).exists()) {
				return ConditionOutcome.match(message.found('git info at').items(location));
			}
			return ConditionOutcome.noMatch(message.didNotFind('git info at').items(location));
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {
	/**
	 * Environment property that can be used to override when auto-configuration is
	 * enabled.
	 */
	String ENABLED_OVERRIDE_PROPERTY = 'spring.boot.enableautoconfiguration';
	/**
	 * Exclude specific auto-configuration classes such that they will never be applied.
	 * @return the classes to exclude
	 */
	Class<?>[] exclude() default {};
	/**
	 * Exclude specific auto-configuration class names such that they will never be
	 * applied.
	 * @return the class names to exclude
	 * @since 1.3.0
	 */
	String[] excludeName() default {};
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@AutoConfiguration(after = { HibernateJpaAutoConfiguration.class, TransactionAutoConfiguration.class })
@ConditionalOnClass({ JobLauncher.class, DataSource.class, DatabasePopulator.class })
@ConditionalOnBean({ DataSource.class, PlatformTransactionManager.class })
@ConditionalOnMissingBean(value = DefaultBatchConfiguration.class, annotation = EnableBatchProcessing.class)
@EnableConfigurationProperties(BatchProperties.class)
@Import(DatabaseInitializationDependencyConfigurer.class)
public class BatchAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(prefix = 'spring.batch.job', name = 'enabled', havingValue = 'true', matchIfMissing = true)
	public JobLauncherApplicationRunner jobLauncherApplicationRunner(JobLauncher jobLauncher, JobExplorer jobExplorer,
			JobRepository jobRepository, BatchProperties properties) {
		JobLauncherApplicationRunner runner = new JobLauncherApplicationRunner(jobLauncher, jobExplorer, jobRepository);
		String jobName = properties.getJob().getName();
		if (StringUtils.hasText(jobName)) {
			runner.setJobName(jobName);
		}
		return runner;
	}
	@Bean
	@ConditionalOnMissingBean(ExitCodeGenerator.class)
	public JobExecutionExitCodeGenerator jobExecutionExitCodeGenerator() {
		return new JobExecutionExitCodeGenerator();
	}
	@Configuration(proxyBeanMethods = false)
	static class SpringBootBatchConfiguration extends DefaultBatchConfiguration {
		private final DataSource dataSource;
		private final PlatformTransactionManager transactionManager;
		private final TaskExecutor taskExector;
		private final BatchProperties properties;
		private final List<BatchConversionServiceCustomizer> batchConversionServiceCustomizers;
		private final ExecutionContextSerializer executionContextSerializer;
		SpringBootBatchConfiguration(DataSource dataSource, @BatchDataSource ObjectProvider<DataSource> batchDataSource,
				PlatformTransactionManager transactionManager,
				@BatchTransactionManager ObjectProvider<PlatformTransactionManager> batchTransactionManager,
				@BatchTaskExecutor ObjectProvider<TaskExecutor> batchTaskExecutor, BatchProperties properties,
				ObjectProvider<BatchConversionServiceCustomizer> batchConversionServiceCustomizers,
				ObjectProvider<ExecutionContextSerializer> executionContextSerializer) {
			this.dataSource = batchDataSource.getIfAvailable(() -> dataSource);
			this.transactionManager = batchTransactionManager.getIfAvailable(() -> transactionManager);
			this.taskExector = batchTaskExecutor.getIfAvailable();
			this.properties = properties;
			this.batchConversionServiceCustomizers = batchConversionServiceCustomizers.orderedStream().toList();
			this.executionContextSerializer = executionContextSerializer.getIfAvailable();
		}
		@Override
		protected DataSource getDataSource() {
			return this.dataSource;
		}
		@Override
		protected PlatformTransactionManager getTransactionManager() {
			return this.transactionManager;
		}
		@Override
		protected String getTablePrefix() {
			String tablePrefix = this.properties.getJdbc().getTablePrefix();
			return (tablePrefix != null) ? tablePrefix : super.getTablePrefix();
		}
		@Override
		protected Isolation getIsolationLevelForCreate() {
			Isolation isolation = this.properties.getJdbc().getIsolationLevelForCreate();
			return (isolation != null) ? isolation : super.getIsolationLevelForCreate();
		}
		@Override
		protected ConfigurableConversionService getConversionService() {
			ConfigurableConversionService conversionService = super.getConversionService();
			for (BatchConversionServiceCustomizer customizer : this.batchConversionServiceCustomizers) {
				customizer.customize(conversionService);
			}
			return conversionService;
		}
		@Override
		protected ExecutionContextSerializer getExecutionContextSerializer() {
			return (this.executionContextSerializer != null) ? this.executionContextSerializer
					: super.getExecutionContextSerializer();
		}
		@Override
		protected TaskExecutor getTaskExecutor() {
			return (this.taskExector != null) ? this.taskExector : super.getTaskExecutor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(OnBatchDatasourceInitializationCondition.class)
	static class DataSourceInitializerConfiguration {
		@Bean
		@ConditionalOnMissingBean(BatchDataSourceScriptDatabaseInitializer.class)
		BatchDataSourceScriptDatabaseInitializer batchDataSourceInitializer(DataSource dataSource,
				@BatchDataSource ObjectProvider<DataSource> batchDataSource, BatchProperties properties) {
			return new BatchDataSourceScriptDatabaseInitializer(batchDataSource.getIfAvailable(() -> dataSource),
					properties.getJdbc());
		}
	}
	static class OnBatchDatasourceInitializationCondition extends OnDatabaseInitializationCondition {
		OnBatchDatasourceInitializationCondition() {
			super('Batch', 'spring.batch.jdbc.initialize-schema', 'spring.batch.initialize-schema');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface BatchTaskExecutor {
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
public class JobExecutionExitCodeGenerator implements ApplicationListener<JobExecutionEvent>, ExitCodeGenerator {
	private final List<JobExecution> executions = new CopyOnWriteArrayList<>();
	@Override
	public void onApplicationEvent(JobExecutionEvent event) {
		this.executions.add(event.getJobExecution());
	}
	@Override
	public int getExitCode() {
		for (JobExecution execution : this.executions) {
			if (execution.getStatus().ordinal() > 0) {
				return execution.getStatus().ordinal();
			}
		}
		return 0;
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@SuppressWarnings('serial')
public class JobExecutionEvent extends ApplicationEvent {
	private final JobExecution execution;
	/**
	 * Create a new {@link JobExecutionEvent} instance.
	 * @param execution the job execution
	 */
	public JobExecutionEvent(JobExecution execution) {
		super(execution);
		this.execution = execution;
	}
	/**
	 * Return the job execution.
	 * @return the job execution
	 */
	public JobExecution getJobExecution() {
		return this.execution;
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@FunctionalInterface
public interface BatchConversionServiceCustomizer {
	/**
	 * Customize the {@link ConfigurableConversionService}.
	 * @param configurableConversionService the ConfigurableConversionService to customize
	 */
	void customize(ConfigurableConversionService configurableConversionService);
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
public class BatchDataSourceScriptDatabaseInitializer extends DataSourceScriptDatabaseInitializer {
	/**
	 * Create a new {@link BatchDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Spring Batch data source
	 * @param properties the Spring Batch JDBC properties
	 * @see #getSettings
	 */
	public BatchDataSourceScriptDatabaseInitializer(DataSource dataSource, BatchProperties.Jdbc properties) {
		this(dataSource, getSettings(dataSource, properties));
	}
	/**
	 * Create a new {@link BatchDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Spring Batch data source
	 * @param settings the database initialization settings
	 * @see #getSettings
	 */
	public BatchDataSourceScriptDatabaseInitializer(DataSource dataSource, DatabaseInitializationSettings settings) {
		super(dataSource, settings);
	}
	/**
	 * Adapts {@link BatchProperties.Jdbc Spring Batch JDBC properties} to
	 * {@link DatabaseInitializationSettings} replacing any {@literal @@platform@@}
	 * placeholders.
	 * @param dataSource the Spring Batch data source
	 * @param properties batch JDBC properties
	 * @return a new {@link DatabaseInitializationSettings} instance
	 * @see #BatchDataSourceScriptDatabaseInitializer(DataSource,
	 * DatabaseInitializationSettings)
	 */
	public static DatabaseInitializationSettings getSettings(DataSource dataSource, BatchProperties.Jdbc properties) {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(resolveSchemaLocations(dataSource, properties));
		settings.setMode(properties.getInitializeSchema());
		settings.setContinueOnError(true);
		return settings;
	}
	private static List<String> resolveSchemaLocations(DataSource dataSource, BatchProperties.Jdbc properties) {
		PlatformPlaceholderDatabaseDriverResolver platformResolver = new PlatformPlaceholderDatabaseDriverResolver();
		if (StringUtils.hasText(properties.getPlatform())) {
			return platformResolver.resolveAll(properties.getPlatform(), properties.getSchema());
		}
		return platformResolver.resolveAll(dataSource, properties.getSchema());
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@ConfigurationProperties(prefix = 'spring.batch')
public class BatchProperties {
	private final Job job = new Job();
	private final Jdbc jdbc = new Jdbc();
	public Job getJob() {
		return this.job;
	}
	public Jdbc getJdbc() {
		return this.jdbc;
	}
	public static class Job {
		/**
		 * Job name to execute on startup. Must be specified if multiple Jobs are found in
		 * the context.
		 */
		private String name = '';
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
	public static class Jdbc {
		private static final String DEFAULT_SCHEMA_LOCATION = 'classpath:org/springframework/'
				+ 'batch/core/schema-@@platform@@.sql';
		/**
		 * Transaction isolation level to use when creating job meta-data for new jobs.
		 */
		private Isolation isolationLevelForCreate;
		/**
		 * Path to the SQL file to use to initialize the database schema.
		 */
		private String schema = DEFAULT_SCHEMA_LOCATION;
		/**
		 * Platform to use in initialization scripts if the @@platform@@ placeholder is
		 * used. Auto-detected by default.
		 */
		private String platform;
		/**
		 * Table prefix for all the batch meta-data tables.
		 */
		private String tablePrefix;
		/**
		 * Database schema initialization mode.
		 */
		private DatabaseInitializationMode initializeSchema = DatabaseInitializationMode.EMBEDDED;
		public Isolation getIsolationLevelForCreate() {
			return this.isolationLevelForCreate;
		}
		public void setIsolationLevelForCreate(Isolation isolationLevelForCreate) {
			this.isolationLevelForCreate = isolationLevelForCreate;
		}
		public String getSchema() {
			return this.schema;
		}
		public void setSchema(String schema) {
			this.schema = schema;
		}
		public String getPlatform() {
			return this.platform;
		}
		public void setPlatform(String platform) {
			this.platform = platform;
		}
		public String getTablePrefix() {
			return this.tablePrefix;
		}
		public void setTablePrefix(String tablePrefix) {
			this.tablePrefix = tablePrefix;
		}
		public DatabaseInitializationMode getInitializeSchema() {
			return this.initializeSchema;
		}
		public void setInitializeSchema(DatabaseInitializationMode initializeSchema) {
			this.initializeSchema = initializeSchema;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface BatchTransactionManager {
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface BatchDataSource {
}
/*
/**
package org.springframework.boot.autoconfigure.batch;
/*
package org.springframework.boot.autoconfigure.batch;
/**
class JobRepositoryDependsOnDatabaseInitializationDetector
		extends AbstractBeansOfTypeDependsOnDatabaseInitializationDetector {
	@Override
	protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
		return Collections.singleton(JobRepository.class);
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
public class JobLauncherApplicationRunner
		implements ApplicationRunner, InitializingBean, Ordered, ApplicationEventPublisherAware {
	/**
	 * The default order for the command line runner.
	 */
	public static final int DEFAULT_ORDER = 0;
	private static final Log logger = LogFactory.getLog(JobLauncherApplicationRunner.class);
	private JobParametersConverter converter = new DefaultJobParametersConverter();
	private final JobLauncher jobLauncher;
	private final JobExplorer jobExplorer;
	private final JobRepository jobRepository;
	private JobRegistry jobRegistry;
	private String jobName;
	private Collection<Job> jobs = Collections.emptySet();
	private int order = DEFAULT_ORDER;
	private ApplicationEventPublisher publisher;
	/**
	 * Create a new {@link JobLauncherApplicationRunner}.
	 * @param jobLauncher to launch jobs
	 * @param jobExplorer to check the job repository for previous executions
	 * @param jobRepository to check if a job instance exists with the given parameters
	 * when running a job
	 */
	public JobLauncherApplicationRunner(JobLauncher jobLauncher, JobExplorer jobExplorer, JobRepository jobRepository) {
		Assert.notNull(jobLauncher, 'JobLauncher must not be null');
		Assert.notNull(jobExplorer, 'JobExplorer must not be null');
		Assert.notNull(jobRepository, 'JobRepository must not be null');
		this.jobLauncher = jobLauncher;
		this.jobExplorer = jobExplorer;
		this.jobRepository = jobRepository;
	}
	@Override
	public void afterPropertiesSet() {
		Assert.isTrue(this.jobs.size() <= 1 || StringUtils.hasText(this.jobName),
				'Job name must be specified in case of multiple jobs');
		if (StringUtils.hasText(this.jobName)) {
			Assert.isTrue(isLocalJob(this.jobName) || isRegisteredJob(this.jobName),
					() -> 'No job found with name "' + this.jobName + '"');
		}
	}
	@Deprecated(since = '3.0.10', forRemoval = true)
	public void validate() {
		afterPropertiesSet();
	}
	public void setOrder(int order) {
		this.order = order;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	@Override
	public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
		this.publisher = publisher;
	}
	@Autowired(required = false)
	public void setJobRegistry(JobRegistry jobRegistry) {
		this.jobRegistry = jobRegistry;
	}
	public void setJobName(String jobName) {
		this.jobName = jobName;
	}
	@Autowired(required = false)
	public void setJobParametersConverter(JobParametersConverter converter) {
		this.converter = converter;
	}
	@Autowired(required = false)
	public void setJobs(Collection<Job> jobs) {
		this.jobs = jobs;
	}
	@Override
	public void run(ApplicationArguments args) throws Exception {
		String[] jobArguments = args.getNonOptionArgs().toArray(new String[0]);
		run(jobArguments);
	}
	public void run(String... args) throws JobExecutionException {
		logger.info('Running default command line with: ' + Arrays.asList(args));
		launchJobFromProperties(StringUtils.splitArrayElementsIntoProperties(args, '='));
	}
	protected void launchJobFromProperties(Properties properties) throws JobExecutionException {
		JobParameters jobParameters = this.converter.getJobParameters(properties);
		executeLocalJobs(jobParameters);
		executeRegisteredJobs(jobParameters);
	}
	private boolean isLocalJob(String jobName) {
		return this.jobs.stream().anyMatch((job) -> job.getName().equals(jobName));
	}
	private boolean isRegisteredJob(String jobName) {
		return this.jobRegistry != null && this.jobRegistry.getJobNames().contains(jobName);
	}
	private void executeLocalJobs(JobParameters jobParameters) throws JobExecutionException {
		for (Job job : this.jobs) {
			if (StringUtils.hasText(this.jobName)) {
				if (!this.jobName.equals(job.getName())) {
					logger.debug(LogMessage.format('Skipped job: %s', job.getName()));
					continue;
				}
			}
			execute(job, jobParameters);
		}
	}
	private void executeRegisteredJobs(JobParameters jobParameters) throws JobExecutionException {
		if (this.jobRegistry != null && StringUtils.hasText(this.jobName)) {
			if (!isLocalJob(this.jobName)) {
				Job job = this.jobRegistry.getJob(this.jobName);
				execute(job, jobParameters);
			}
		}
	}
	protected void execute(Job job, JobParameters jobParameters) throws JobExecutionAlreadyRunningException,
			JobRestartException, JobInstanceAlreadyCompleteException, JobParametersInvalidException {
		JobParameters parameters = getNextJobParameters(job, jobParameters);
		JobExecution execution = this.jobLauncher.run(job, parameters);
		if (this.publisher != null) {
			this.publisher.publishEvent(new JobExecutionEvent(execution));
		}
	}
	private JobParameters getNextJobParameters(Job job, JobParameters jobParameters) {
		if (this.jobRepository != null && this.jobRepository.isJobInstanceExists(job.getName(), jobParameters)) {
			return getNextJobParametersForExisting(job, jobParameters);
		}
		if (job.getJobParametersIncrementer() == null) {
			return jobParameters;
		}
		JobParameters nextParameters = new JobParametersBuilder(jobParameters, this.jobExplorer)
			.getNextJobParameters(job)
			.toJobParameters();
		return merge(nextParameters, jobParameters);
	}
	private JobParameters getNextJobParametersForExisting(Job job, JobParameters jobParameters) {
		JobExecution lastExecution = this.jobRepository.getLastJobExecution(job.getName(), jobParameters);
		if (isStoppedOrFailed(lastExecution) && job.isRestartable()) {
			JobParameters previousIdentifyingParameters = new JobParameters(
					lastExecution.getJobParameters().getIdentifyingParameters());
			return merge(previousIdentifyingParameters, jobParameters);
		}
		return jobParameters;
	}
	private boolean isStoppedOrFailed(JobExecution execution) {
		BatchStatus status = (execution != null) ? execution.getStatus() : null;
		return (status == BatchStatus.STOPPED || status == BatchStatus.FAILED);
	}
	private JobParameters merge(JobParameters parameters, JobParameters additionals) {
		Map<String, JobParameter<?>> merged = new LinkedHashMap<>();
		merged.putAll(parameters.getParameters());
		merged.putAll(additionals.getParameters());
		return new JobParameters(merged);
	}
}
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
@ConfigurationProperties(prefix = 'spring.neo4j')
public class Neo4jProperties {
	/**
	 * URI used by the driver.
	 */
	private URI uri;
	/**
	 * Timeout for borrowing connections from the pool.
	 */
	private Duration connectionTimeout = Duration.ofSeconds(30);
	/**
	 * Maximum time transactions are allowed to retry.
	 */
	private Duration maxTransactionRetryTime = Duration.ofSeconds(30);
	private final Authentication authentication = new Authentication();
	private final Pool pool = new Pool();
	private final Security security = new Security();
	public URI getUri() {
		return this.uri;
	}
	public void setUri(URI uri) {
		this.uri = uri;
	}
	public Duration getConnectionTimeout() {
		return this.connectionTimeout;
	}
	public void setConnectionTimeout(Duration connectionTimeout) {
		this.connectionTimeout = connectionTimeout;
	}
	public Duration getMaxTransactionRetryTime() {
		return this.maxTransactionRetryTime;
	}
	public void setMaxTransactionRetryTime(Duration maxTransactionRetryTime) {
		this.maxTransactionRetryTime = maxTransactionRetryTime;
	}
	public Authentication getAuthentication() {
		return this.authentication;
	}
	public Pool getPool() {
		return this.pool;
	}
	public Security getSecurity() {
		return this.security;
	}
	public static class Authentication {
		/**
		 * Login user of the server.
		 */
		private String username;
		/**
		 * Login password of the server.
		 */
		private String password;
		/**
		 * Realm to connect to.
		 */
		private String realm;
		/**
		 * Kerberos ticket for connecting to the database. Mutual exclusive with a given
		 * username.
		 */
		private String kerberosTicket;
		public String getUsername() {
			return this.username;
		}
		public void setUsername(String username) {
			this.username = username;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
		public String getRealm() {
			return this.realm;
		}
		public void setRealm(String realm) {
			this.realm = realm;
		}
		public String getKerberosTicket() {
			return this.kerberosTicket;
		}
		public void setKerberosTicket(String kerberosTicket) {
			this.kerberosTicket = kerberosTicket;
		}
	}
	public static class Pool {
		/**
		 * Whether to enable metrics.
		 */
		private boolean metricsEnabled = false;
		/**
		 * Whether to log leaked sessions.
		 */
		private boolean logLeakedSessions = false;
		/**
		 * Maximum amount of connections in the connection pool towards a single database.
		 */
		private int maxConnectionPoolSize = 100;
		/**
		 * Pooled connections that have been idle in the pool for longer than this
		 * threshold will be tested before they are used again.
		 */
		private Duration idleTimeBeforeConnectionTest;
		/**
		 * Pooled connections older than this threshold will be closed and removed from
		 * the pool.
		 */
		private Duration maxConnectionLifetime = Duration.ofHours(1);
		/**
		 * Acquisition of new connections will be attempted for at most configured
		 * timeout.
		 */
		private Duration connectionAcquisitionTimeout = Duration.ofSeconds(60);
		public boolean isLogLeakedSessions() {
			return this.logLeakedSessions;
		}
		public void setLogLeakedSessions(boolean logLeakedSessions) {
			this.logLeakedSessions = logLeakedSessions;
		}
		public int getMaxConnectionPoolSize() {
			return this.maxConnectionPoolSize;
		}
		public void setMaxConnectionPoolSize(int maxConnectionPoolSize) {
			this.maxConnectionPoolSize = maxConnectionPoolSize;
		}
		public Duration getIdleTimeBeforeConnectionTest() {
			return this.idleTimeBeforeConnectionTest;
		}
		public void setIdleTimeBeforeConnectionTest(Duration idleTimeBeforeConnectionTest) {
			this.idleTimeBeforeConnectionTest = idleTimeBeforeConnectionTest;
		}
		public Duration getMaxConnectionLifetime() {
			return this.maxConnectionLifetime;
		}
		public void setMaxConnectionLifetime(Duration maxConnectionLifetime) {
			this.maxConnectionLifetime = maxConnectionLifetime;
		}
		public Duration getConnectionAcquisitionTimeout() {
			return this.connectionAcquisitionTimeout;
		}
		public void setConnectionAcquisitionTimeout(Duration connectionAcquisitionTimeout) {
			this.connectionAcquisitionTimeout = connectionAcquisitionTimeout;
		}
		public boolean isMetricsEnabled() {
			return this.metricsEnabled;
		}
		public void setMetricsEnabled(boolean metricsEnabled) {
			this.metricsEnabled = metricsEnabled;
		}
	}
	public static class Security {
		/**
		 * Whether the driver should use encrypted traffic.
		 */
		private boolean encrypted = false;
		/**
		 * Trust strategy to use.
		 */
		private TrustStrategy trustStrategy = TrustStrategy.TRUST_SYSTEM_CA_SIGNED_CERTIFICATES;
		/**
		 * Path to the file that holds the trusted certificates.
		 */
		private File certFile;
		/**
		 * Whether hostname verification is required.
		 */
		private boolean hostnameVerificationEnabled = true;
		public boolean isEncrypted() {
			return this.encrypted;
		}
		public void setEncrypted(boolean encrypted) {
			this.encrypted = encrypted;
		}
		public TrustStrategy getTrustStrategy() {
			return this.trustStrategy;
		}
		public void setTrustStrategy(TrustStrategy trustStrategy) {
			this.trustStrategy = trustStrategy;
		}
		public File getCertFile() {
			return this.certFile;
		}
		public void setCertFile(File certFile) {
			this.certFile = certFile;
		}
		public boolean isHostnameVerificationEnabled() {
			return this.hostnameVerificationEnabled;
		}
		public void setHostnameVerificationEnabled(boolean hostnameVerificationEnabled) {
			this.hostnameVerificationEnabled = hostnameVerificationEnabled;
		}
		public enum TrustStrategy {
			/**
			 * Trust all certificates.
			 */
			TRUST_ALL_CERTIFICATES,
			/**
			 * Trust certificates that are signed by a trusted certificate.
			 */
			TRUST_CUSTOM_CA_SIGNED_CERTIFICATES,
			/**
			 * Trust certificates that can be verified through the local system store.
			 */
			TRUST_SYSTEM_CA_SIGNED_CERTIFICATES
		}
	}
}
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
@AutoConfiguration
@ConditionalOnClass(Driver.class)
@EnableConfigurationProperties(Neo4jProperties.class)
public class Neo4jAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(Neo4jConnectionDetails.class)
	PropertiesNeo4jConnectionDetails neo4jConnectionDetails(Neo4jProperties properties,
			ObjectProvider<AuthTokenManager> authTokenManager) {
		return new PropertiesNeo4jConnectionDetails(properties, authTokenManager.getIfUnique());
	}
	@Bean
	@ConditionalOnMissingBean
	public Driver neo4jDriver(Neo4jProperties properties, Environment environment,
			Neo4jConnectionDetails connectionDetails,
			ObjectProvider<ConfigBuilderCustomizer> configBuilderCustomizers) {
		Config config = mapDriverConfig(properties, connectionDetails,
				configBuilderCustomizers.orderedStream().toList());
		AuthTokenManager authTokenManager = connectionDetails.getAuthTokenManager();
		if (authTokenManager != null) {
			return GraphDatabase.driver(connectionDetails.getUri(), authTokenManager, config);
		}
		AuthToken authToken = connectionDetails.getAuthToken();
		return GraphDatabase.driver(connectionDetails.getUri(), authToken, config);
	}
	Config mapDriverConfig(Neo4jProperties properties, Neo4jConnectionDetails connectionDetails,
			List<ConfigBuilderCustomizer> customizers) {
		Config.ConfigBuilder builder = Config.builder();
		configurePoolSettings(builder, properties.getPool());
		URI uri = connectionDetails.getUri();
		String scheme = (uri != null) ? uri.getScheme() : 'bolt';
		configureDriverSettings(builder, properties, isSimpleScheme(scheme));
		builder.withLogging(new Neo4jSpringJclLogging());
		customizers.forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	private boolean isSimpleScheme(String scheme) {
		String lowerCaseScheme = scheme.toLowerCase(Locale.ENGLISH);
		try {
			Scheme.validateScheme(lowerCaseScheme);
		}
		catch (IllegalArgumentException ex) {
			throw new IllegalArgumentException(String.format('"%s" is not a supported scheme.', scheme));
		}
		return lowerCaseScheme.equals('bolt') || lowerCaseScheme.equals('neo4j');
	}
	private void configurePoolSettings(Config.ConfigBuilder builder, Pool pool) {
		if (pool.isLogLeakedSessions()) {
			builder.withLeakedSessionsLogging();
		}
		builder.withMaxConnectionPoolSize(pool.getMaxConnectionPoolSize());
		Duration idleTimeBeforeConnectionTest = pool.getIdleTimeBeforeConnectionTest();
		if (idleTimeBeforeConnectionTest != null) {
			builder.withConnectionLivenessCheckTimeout(idleTimeBeforeConnectionTest.toMillis(), TimeUnit.MILLISECONDS);
		}
		builder.withMaxConnectionLifetime(pool.getMaxConnectionLifetime().toMillis(), TimeUnit.MILLISECONDS);
		builder.withConnectionAcquisitionTimeout(pool.getConnectionAcquisitionTimeout().toMillis(),
				TimeUnit.MILLISECONDS);
		if (pool.isMetricsEnabled()) {
			builder.withDriverMetrics();
		}
		else {
			builder.withoutDriverMetrics();
		}
	}
	private void configureDriverSettings(Config.ConfigBuilder builder, Neo4jProperties properties,
			boolean withEncryptionAndTrustSettings) {
		if (withEncryptionAndTrustSettings) {
			applyEncryptionAndTrustSettings(builder, properties.getSecurity());
		}
		builder.withConnectionTimeout(properties.getConnectionTimeout().toMillis(), TimeUnit.MILLISECONDS);
		builder.withMaxTransactionRetryTime(properties.getMaxTransactionRetryTime().toMillis(), TimeUnit.MILLISECONDS);
	}
	private void applyEncryptionAndTrustSettings(Config.ConfigBuilder builder,
			Neo4jProperties.Security securityProperties) {
		if (securityProperties.isEncrypted()) {
			builder.withEncryption();
		}
		else {
			builder.withoutEncryption();
		}
		builder.withTrustStrategy(mapTrustStrategy(securityProperties));
	}
	private Config.TrustStrategy mapTrustStrategy(Neo4jProperties.Security securityProperties) {
		String propertyName = 'spring.neo4j.security.trust-strategy';
		Security.TrustStrategy strategy = securityProperties.getTrustStrategy();
		TrustStrategy trustStrategy = createTrustStrategy(securityProperties, propertyName, strategy);
		if (securityProperties.isHostnameVerificationEnabled()) {
			trustStrategy.withHostnameVerification();
		}
		else {
			trustStrategy.withoutHostnameVerification();
		}
		return trustStrategy;
	}
	private TrustStrategy createTrustStrategy(Neo4jProperties.Security securityProperties, String propertyName,
			Security.TrustStrategy strategy) {
		return switch (strategy) {
			case TRUST_ALL_CERTIFICATES -> TrustStrategy.trustAllCertificates();
			case TRUST_SYSTEM_CA_SIGNED_CERTIFICATES -> TrustStrategy.trustSystemCertificates();
			case TRUST_CUSTOM_CA_SIGNED_CERTIFICATES -> {
				File certFile = securityProperties.getCertFile();
				if (certFile == null || !certFile.isFile()) {
					throw new InvalidConfigurationPropertyValueException(propertyName, strategy.name(),
							'Configured trust strategy requires a certificate file.');
				}
				yield TrustStrategy.trustCustomCertificateSignedBy(certFile);
			}
			default -> throw new InvalidConfigurationPropertyValueException(propertyName, strategy.name(),
					'Unknown strategy.');
		};
	}
	/**
	 * Adapts {@link Neo4jProperties} to {@link Neo4jConnectionDetails}.
	 */
	static class PropertiesNeo4jConnectionDetails implements Neo4jConnectionDetails {
		private final Neo4jProperties properties;
		private final AuthTokenManager authTokenManager;
		PropertiesNeo4jConnectionDetails(Neo4jProperties properties, AuthTokenManager authTokenManager) {
			this.properties = properties;
			this.authTokenManager = authTokenManager;
		}
		@Override
		public URI getUri() {
			URI uri = this.properties.getUri();
			return (uri != null) ? uri : Neo4jConnectionDetails.super.getUri();
		}
		@Override
		public AuthToken getAuthToken() {
			Authentication authentication = this.properties.getAuthentication();
			String username = authentication.getUsername();
			String kerberosTicket = authentication.getKerberosTicket();
			boolean hasUsername = StringUtils.hasText(username);
			boolean hasKerberosTicket = StringUtils.hasText(kerberosTicket);
			Assert.state(!(hasUsername && hasKerberosTicket),
					() -> 'Cannot specify both username ("%s") and kerberos ticket ("%s")'.formatted(username,
							kerberosTicket));
			String password = authentication.getPassword();
			if (hasUsername && StringUtils.hasText(password)) {
				return AuthTokens.basic(username, password, authentication.getRealm());
			}
			if (hasKerberosTicket) {
				return AuthTokens.kerberos(kerberosTicket);
			}
			return AuthTokens.none();
		}
		@Override
		public AuthTokenManager getAuthTokenManager() {
			return this.authTokenManager;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
class Neo4jSpringJclLogging implements Logging {
	/**
	 * This prefix gets added to the log names the driver requests to add some namespace
	 * around it in a bigger application scenario.
	 */
	private static final String AUTOMATIC_PREFIX = 'org.neo4j.driver.';
	@Override
	public Logger getLog(String name) {
		String requestedLog = name;
		if (!requestedLog.startsWith(AUTOMATIC_PREFIX)) {
			requestedLog = AUTOMATIC_PREFIX + name;
		}
		Log springJclLog = LogFactory.getLog(requestedLog);
		return new SpringJclLogger(springJclLog);
	}
	private static final class SpringJclLogger implements Logger {
		private final Log delegate;
		SpringJclLogger(Log delegate) {
			this.delegate = delegate;
		}
		@Override
		public void error(String message, Throwable cause) {
			this.delegate.error(message, cause);
		}
		@Override
		public void info(String format, Object... params) {
			this.delegate.info(String.format(format, params));
		}
		@Override
		public void warn(String format, Object... params) {
			this.delegate.warn(String.format(format, params));
		}
		@Override
		public void warn(String message, Throwable cause) {
			this.delegate.warn(message, cause);
		}
		@Override
		public void debug(String format, Object... params) {
			if (isDebugEnabled()) {
				this.delegate.debug(String.format(format, params));
			}
		}
		@Override
		public void debug(String message, Throwable throwable) {
			if (isDebugEnabled()) {
				this.delegate.debug(message, throwable);
			}
		}
		@Override
		public void trace(String format, Object... params) {
			if (isTraceEnabled()) {
				this.delegate.trace(String.format(format, params));
			}
		}
		@Override
		public boolean isTraceEnabled() {
			return this.delegate.isTraceEnabled();
		}
		@Override
		public boolean isDebugEnabled() {
			return this.delegate.isDebugEnabled();
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.neo4j;
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
public interface Neo4jConnectionDetails extends ConnectionDetails {
	/**
	 * Returns the URI of the Neo4j server. Defaults to {@code bolt://localhost:7687'}.
	 * @return the Neo4j server URI
	 */
	default URI getUri() {
		return URI.create('bolt://localhost:7687');
	}
	/**
	 * Returns the token to use for authentication. Defaults to {@link AuthTokens#none()}.
	 * @return the auth token
	 */
	default AuthToken getAuthToken() {
		return AuthTokens.none();
	}
	/**
	 * Returns the {@link AuthTokenManager} to use for authentication. Defaults to
	 * {@code null} in which case the {@link #getAuthToken() auth token} should be used.
	 * @return the auth token manager
	 * @since 3.2.0
	 */
	default AuthTokenManager getAuthTokenManager() {
		return null;
	}
}
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
@FunctionalInterface
public interface ConfigBuilderCustomizer {
	/**
	 * Customize the {@link ConfigBuilder}.
	 * @param configBuilder the {@link ConfigBuilder} to customize
	 */
	void customize(ConfigBuilder configBuilder);
}
/*
package org.springframework.boot.autoconfigure.admin;
/**
@AutoConfiguration(after = JmxAutoConfiguration.class)
@ConditionalOnProperty(prefix = 'spring.application.admin', value = 'enabled', havingValue = 'true',
		matchIfMissing = false)
public class SpringApplicationAdminJmxAutoConfiguration {
	/**
	 * The property to use to customize the {@code ObjectName} of the application admin
	 * mbean.
	 */
	private static final String JMX_NAME_PROPERTY = 'spring.application.admin.jmx-name';
	/**
	 * The default {@code ObjectName} of the application admin mbean.
	 */
	private static final String DEFAULT_JMX_NAME = 'org.springframework.boot:type=Admin,name=SpringApplication';
	@Bean
	@ConditionalOnMissingBean
	public SpringApplicationAdminMXBeanRegistrar springApplicationAdminRegistrar(
			ObjectProvider<MBeanExporter> mbeanExporters, Environment environment) throws MalformedObjectNameException {
		String jmxName = environment.getProperty(JMX_NAME_PROPERTY, DEFAULT_JMX_NAME);
		if (mbeanExporters != null) { // Make sure to not register that MBean twice
			for (MBeanExporter mbeanExporter : mbeanExporters) {
				mbeanExporter.addExcludedBean(jmxName);
			}
		}
		return new SpringApplicationAdminMXBeanRegistrar(jmxName);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.admin;
/*
package org.springframework.boot.autoconfigure.aop;
/**
@AutoConfiguration
@ConditionalOnProperty(prefix = 'spring.aop', name = 'auto', havingValue = 'true', matchIfMissing = true)
public class AopAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Advice.class)
	static class AspectJAutoProxyingConfiguration {
		@Configuration(proxyBeanMethods = false)
		@EnableAspectJAutoProxy(proxyTargetClass = false)
		@ConditionalOnProperty(prefix = 'spring.aop', name = 'proxy-target-class', havingValue = 'false')
		static class JdkDynamicAutoProxyConfiguration {
		}
		@Configuration(proxyBeanMethods = false)
		@EnableAspectJAutoProxy(proxyTargetClass = true)
		@ConditionalOnProperty(prefix = 'spring.aop', name = 'proxy-target-class', havingValue = 'true',
				matchIfMissing = true)
		static class CglibAutoProxyConfiguration {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingClass('org.aspectj.weaver.Advice')
	@ConditionalOnProperty(prefix = 'spring.aop', name = 'proxy-target-class', havingValue = 'true',
			matchIfMissing = true)
	static class ClassProxyingConfiguration {
		@Bean
		static BeanFactoryPostProcessor forceAutoProxyCreatorToUseClassProxying() {
			return (beanFactory) -> {
				if (beanFactory instanceof BeanDefinitionRegistry registry) {
					AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry);
					AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
				}
			};
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.aop;
/*
package org.springframework.boot.autoconfigure.jooq;
/**
final class DefaultExceptionTranslatorExecuteListener implements ExceptionTranslatorExecuteListener {
	// Based on the jOOQ-spring-example from https://github.com/jOOQ/jOOQ
	private static final Log defaultLogger = LogFactory.getLog(ExceptionTranslatorExecuteListener.class);
	private final Log logger;
	private Function<ExecuteContext, SQLExceptionTranslator> translatorFactory;
	DefaultExceptionTranslatorExecuteListener() {
		this(defaultLogger, new DefaultTranslatorFactory());
	}
	DefaultExceptionTranslatorExecuteListener(Function<ExecuteContext, SQLExceptionTranslator> translatorFactory) {
		this(defaultLogger, translatorFactory);
	}
	DefaultExceptionTranslatorExecuteListener(Log logger) {
		this(logger, new DefaultTranslatorFactory());
	}
	private DefaultExceptionTranslatorExecuteListener(Log logger,
			Function<ExecuteContext, SQLExceptionTranslator> translatorFactory) {
		Assert.notNull(translatorFactory, 'TranslatorFactory must not be null');
		this.logger = logger;
		this.translatorFactory = translatorFactory;
	}
	@Override
	public void exception(ExecuteContext context) {
		SQLExceptionTranslator translator = this.translatorFactory.apply(context);
		// The exception() callback is not only triggered for SQL exceptions but also for
		// 'normal' exceptions. In those cases sqlException() returns null.
		SQLException exception = context.sqlException();
		while (exception != null) {
			handle(context, translator, exception);
			exception = exception.getNextException();
		}
	}
	/**
	 * Handle a single exception in the chain. SQLExceptions might be nested multiple
	 * levels deep. The outermost exception is usually the least interesting one ('Call
	 * getNextException to see the cause.'). Therefore the innermost exception is
	 * propagated and all other exceptions are logged.
	 * @param context the execute context
	 * @param translator the exception translator
	 * @param exception the exception
	 */
	private void handle(ExecuteContext context, SQLExceptionTranslator translator, SQLException exception) {
		DataAccessException translated = translator.translate('jOOQ', context.sql(), exception);
		if (exception.getNextException() != null) {
			this.logger.error('Execution of SQL statement failed.', (translated != null) ? translated : exception);
			return;
		}
		if (translated != null) {
			context.exception(translated);
		}
	}
	/**
	 * Default {@link SQLExceptionTranslator} factory that creates the translator based on
	 * the Spring DB name.
	 */
	private static final class DefaultTranslatorFactory implements Function<ExecuteContext, SQLExceptionTranslator> {
		@Override
		public SQLExceptionTranslator apply(ExecuteContext context) {
			return apply(context.configuration().dialect());
		}
		private SQLExceptionTranslator apply(SQLDialect dialect) {
			String dbName = getSpringDbName(dialect);
			return (dbName != null) ? new SQLErrorCodeSQLExceptionTranslator(dbName)
					: new SQLStateSQLExceptionTranslator();
		}
		private String getSpringDbName(SQLDialect dialect) {
			return (dialect != null && dialect.thirdParty() != null) ? dialect.thirdParty().springDbName() : null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
class NoDslContextBeanFailureAnalyzer extends AbstractFailureAnalyzer<NoSuchBeanDefinitionException>
		implements Ordered {
	private final BeanFactory beanFactory;
	NoDslContextBeanFailureAnalyzer(BeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchBeanDefinitionException cause) {
		if (DSLContext.class.equals(cause.getBeanType()) && hasR2dbcAutoConfiguration()) {
			return new FailureAnalysis(
					'jOOQ has not been auto-configured as R2DBC has been auto-configured in favor of JDBC and jOOQ '
							+ 'auto-configuration does not yet support R2DBC. ',
					'To use jOOQ with JDBC, exclude R2dbcAutoConfiguration. To use jOOQ with R2DBC, define your own '
							+ 'jOOQ configuration.',
					cause);
		}
		return null;
	}
	private boolean hasR2dbcAutoConfiguration() {
		try {
			this.beanFactory.getBean(R2dbcAutoConfiguration.class);
			return true;
		}
		catch (Exception ex) {
			return false;
		}
	}
	@Override
	public int getOrder() {
		return 0;
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
final class SqlDialectLookup {
	private static final Log logger = LogFactory.getLog(SqlDialectLookup.class);
	private SqlDialectLookup() {
	}
	/**
	 * Return the most suitable {@link SQLDialect} for the given {@link DataSource}.
	 * @param dataSource the source {@link DataSource}
	 * @return the most suitable {@link SQLDialect}
	 */
	static SQLDialect getDialect(DataSource dataSource) {
		try (Connection connection = (dataSource != null) ? dataSource.getConnection() : null) {
			return JDBCUtils.dialect(connection);
		}
		catch (SQLException ex) {
			logger.warn('Unable to determine dialect from datasource', ex);
		}
		return SQLDialect.DEFAULT;
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
public class SpringTransactionProvider implements TransactionProvider {
	// Based on the jOOQ-spring-example from https://github.com/jOOQ/jOOQ
	private final PlatformTransactionManager transactionManager;
	public SpringTransactionProvider(PlatformTransactionManager transactionManager) {
		this.transactionManager = transactionManager;
	}
	@Override
	public void begin(TransactionContext context) {
		TransactionDefinition definition = new DefaultTransactionDefinition(TransactionDefinition.PROPAGATION_NESTED);
		TransactionStatus status = this.transactionManager.getTransaction(definition);
		context.transaction(new SpringTransaction(status));
	}
	@Override
	public void commit(TransactionContext ctx) {
		this.transactionManager.commit(getTransactionStatus(ctx));
	}
	@Override
	public void rollback(TransactionContext ctx) {
		this.transactionManager.rollback(getTransactionStatus(ctx));
	}
	private TransactionStatus getTransactionStatus(TransactionContext ctx) {
		SpringTransaction transaction = (SpringTransaction) ctx.transaction();
		return transaction.getTxStatus();
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
public interface ExceptionTranslatorExecuteListener extends ExecuteListener {
	/**
	 * Default {@link ExceptionTranslatorExecuteListener} suitable for most applications.
	 */
	ExceptionTranslatorExecuteListener DEFAULT = new DefaultExceptionTranslatorExecuteListener();
	/**
	 * Creates a new {@link ExceptionTranslatorExecuteListener} backed by an
	 * {@link SQLExceptionTranslator}.
	 * @param translatorFactory factory function used to create the
	 * {@link SQLExceptionTranslator}
	 * @return a new {@link ExceptionTranslatorExecuteListener} instance
	 */
	static ExceptionTranslatorExecuteListener of(Function<ExecuteContext, SQLExceptionTranslator> translatorFactory) {
		return new DefaultExceptionTranslatorExecuteListener(translatorFactory);
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
@FunctionalInterface
public interface DefaultConfigurationCustomizer {
	/**
	 * Customize the {@link DefaultConfiguration jOOQ Configuration}.
	 * @param configuration the configuration to customize
	 */
	void customize(DefaultConfiguration configuration);
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
@Deprecated(since = '3.3.0', forRemoval = true)
public class JooqExceptionTranslator implements ExecuteListener {
	private final DefaultExceptionTranslatorExecuteListener delegate = new DefaultExceptionTranslatorExecuteListener(
			LogFactory.getLog(JooqExceptionTranslator.class));
	@Override
	public void exception(ExecuteContext context) {
		this.delegate.exception(context);
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
@ConfigurationProperties(prefix = 'spring.jooq')
public class JooqProperties {
	/**
	 * SQL dialect to use. Auto-detected by default.
	 */
	private SQLDialect sqlDialect;
	public SQLDialect getSqlDialect() {
		return this.sqlDialect;
	}
	public void setSqlDialect(SQLDialect sqlDialect) {
		this.sqlDialect = sqlDialect;
	}
	/**
	 * Determine the {@link SQLDialect} to use based on this configuration and the primary
	 * {@link DataSource}.
	 * @param dataSource the data source
	 * @return the {@code SQLDialect} to use for that {@link DataSource}
	 */
	public SQLDialect determineSqlDialect(DataSource dataSource) {
		if (this.sqlDialect != null) {
			return this.sqlDialect;
		}
		return SqlDialectLookup.getDialect(dataSource);
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
@AutoConfiguration(after = { DataSourceAutoConfiguration.class, TransactionAutoConfiguration.class })
@ConditionalOnClass(DSLContext.class)
@ConditionalOnBean(DataSource.class)
@EnableConfigurationProperties(JooqProperties.class)
public class JooqAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(ConnectionProvider.class)
	public DataSourceConnectionProvider dataSourceConnectionProvider(DataSource dataSource) {
		return new DataSourceConnectionProvider(new TransactionAwareDataSourceProxy(dataSource));
	}
	@Bean
	@ConditionalOnBean(PlatformTransactionManager.class)
	@ConditionalOnMissingBean(TransactionProvider.class)
	public SpringTransactionProvider transactionProvider(PlatformTransactionManager txManager) {
		return new SpringTransactionProvider(txManager);
	}
	@Bean
	@Order(0)
	public DefaultExecuteListenerProvider jooqExceptionTranslatorExecuteListenerProvider(
			ExceptionTranslatorExecuteListener exceptionTranslatorExecuteListener) {
		return new DefaultExecuteListenerProvider(exceptionTranslatorExecuteListener);
	}
	@Bean
	@ConditionalOnMissingBean(ExceptionTranslatorExecuteListener.class)
	public ExceptionTranslatorExecuteListener jooqExceptionTranslator() {
		return ExceptionTranslatorExecuteListener.DEFAULT;
	}
	@Bean
	@ConditionalOnMissingBean(DSLContext.class)
	public DefaultDSLContext dslContext(org.jooq.Configuration configuration) {
		return new DefaultDSLContext(configuration);
	}
	@Bean
	@ConditionalOnMissingBean(org.jooq.Configuration.class)
	public DefaultConfiguration jooqConfiguration(JooqProperties properties, ConnectionProvider connectionProvider,
			DataSource dataSource, ObjectProvider<TransactionProvider> transactionProvider,
			ObjectProvider<ExecuteListenerProvider> executeListenerProviders,
			ObjectProvider<DefaultConfigurationCustomizer> configurationCustomizers) {
		DefaultConfiguration configuration = new DefaultConfiguration();
		configuration.set(properties.determineSqlDialect(dataSource));
		configuration.set(connectionProvider);
		transactionProvider.ifAvailable(configuration::set);
		configuration.set(executeListenerProviders.orderedStream().toArray(ExecuteListenerProvider[]::new));
		configurationCustomizers.orderedStream().forEach((customizer) -> customizer.customize(configuration));
		return configuration;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jooq;
/*
package org.springframework.boot.autoconfigure.jooq;
/**
class SpringTransaction implements Transaction {
	// Based on the jOOQ-spring-example from https://github.com/jOOQ/jOOQ
	private final TransactionStatus transactionStatus;
	SpringTransaction(TransactionStatus transactionStatus) {
		this.transactionStatus = transactionStatus;
	}
	TransactionStatus getTxStatus() {
		return this.transactionStatus;
	}
}
/*
package org.springframework.boot.autoconfigure.dao;
/**
@AutoConfiguration
@ConditionalOnClass(PersistenceExceptionTranslationPostProcessor.class)
public class PersistenceExceptionTranslationAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(prefix = 'spring.dao.exceptiontranslation', name = 'enabled', matchIfMissing = true)
	public static PersistenceExceptionTranslationPostProcessor persistenceExceptionTranslationPostProcessor(
			Environment environment) {
		PersistenceExceptionTranslationPostProcessor postProcessor = new PersistenceExceptionTranslationPostProcessor();
		boolean proxyTargetClass = environment.getProperty('spring.aop.proxy-target-class', Boolean.class,
				Boolean.TRUE);
		postProcessor.setProxyTargetClass(proxyTargetClass);
		return postProcessor;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.dao;
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public class RabbitStreamTemplateConfigurer {
	private MessageConverter messageConverter;
	private StreamMessageConverter streamMessageConverter;
	private ProducerCustomizer producerCustomizer;
	/**
	 * Set the {@link MessageConverter} to use or {@code null} if the out-of-the-box
	 * converter should be used.
	 * @param messageConverter the {@link MessageConverter}
	 */
	public void setMessageConverter(MessageConverter messageConverter) {
		this.messageConverter = messageConverter;
	}
	/**
	 * Set the {@link StreamMessageConverter} to use or {@code null} if the out-of-the-box
	 * stream message converter should be used.
	 * @param streamMessageConverter the {@link StreamMessageConverter}
	 */
	public void setStreamMessageConverter(StreamMessageConverter streamMessageConverter) {
		this.streamMessageConverter = streamMessageConverter;
	}
	/**
	 * Set the {@link ProducerCustomizer} instances to use.
	 * @param producerCustomizer the producer customizer
	 */
	public void setProducerCustomizer(ProducerCustomizer producerCustomizer) {
		this.producerCustomizer = producerCustomizer;
	}
	/**
	 * Configure the specified {@link RabbitStreamTemplate}. The template can be further
	 * tuned and default settings can be overridden.
	 * @param template the {@link RabbitStreamTemplate} instance to configure
	 */
	public void configure(RabbitStreamTemplate template) {
		if (this.messageConverter != null) {
			template.setMessageConverter(this.messageConverter);
		}
		if (this.streamMessageConverter != null) {
			template.setStreamConverter(this.streamMessageConverter);
		}
		if (this.producerCustomizer != null) {
			template.setProducerCustomizer(this.producerCustomizer);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public class RabbitTemplateConfigurer {
	private MessageConverter messageConverter;
	private List<RabbitRetryTemplateCustomizer> retryTemplateCustomizers;
	private final RabbitProperties rabbitProperties;
	/**
	 * Creates a new configurer that will use the given {@code rabbitProperties}.
	 * @param rabbitProperties properties to use
	 * @since 2.6.0
	 */
	public RabbitTemplateConfigurer(RabbitProperties rabbitProperties) {
		Assert.notNull(rabbitProperties, 'RabbitProperties must not be null');
		this.rabbitProperties = rabbitProperties;
	}
	/**
	 * Set the {@link MessageConverter} to use or {@code null} if the out-of-the-box
	 * converter should be used.
	 * @param messageConverter the {@link MessageConverter}
	 * @since 2.6.0
	 */
	public void setMessageConverter(MessageConverter messageConverter) {
		this.messageConverter = messageConverter;
	}
	/**
	 * Set the {@link RabbitRetryTemplateCustomizer} instances to use.
	 * @param retryTemplateCustomizers the retry template customizers
	 * @since 2.6.0
	 */
	public void setRetryTemplateCustomizers(List<RabbitRetryTemplateCustomizer> retryTemplateCustomizers) {
		this.retryTemplateCustomizers = retryTemplateCustomizers;
	}
	protected final RabbitProperties getRabbitProperties() {
		return this.rabbitProperties;
	}
	/**
	 * Configure the specified {@link RabbitTemplate}. The template can be further tuned
	 * and default settings can be overridden.
	 * @param template the {@link RabbitTemplate} instance to configure
	 * @param connectionFactory the {@link ConnectionFactory} to use
	 */
	public void configure(RabbitTemplate template, ConnectionFactory connectionFactory) {
		PropertyMapper map = PropertyMapper.get();
		template.setConnectionFactory(connectionFactory);
		if (this.messageConverter != null) {
			template.setMessageConverter(this.messageConverter);
		}
		template.setMandatory(determineMandatoryFlag());
		RabbitProperties.Template templateProperties = this.rabbitProperties.getTemplate();
		if (templateProperties.getRetry().isEnabled()) {
			template.setRetryTemplate(new RetryTemplateFactory(this.retryTemplateCustomizers)
				.createRetryTemplate(templateProperties.getRetry(), RabbitRetryTemplateCustomizer.Target.SENDER));
		}
		map.from(templateProperties::getReceiveTimeout)
			.whenNonNull()
			.as(Duration::toMillis)
			.to(template::setReceiveTimeout);
		map.from(templateProperties::getReplyTimeout)
			.whenNonNull()
			.as(Duration::toMillis)
			.to(template::setReplyTimeout);
		map.from(templateProperties::getExchange).to(template::setExchange);
		map.from(templateProperties::getRoutingKey).to(template::setRoutingKey);
		map.from(templateProperties::getDefaultReceiveQueue).whenNonNull().to(template::setDefaultReceiveQueue);
		map.from(templateProperties::isObservationEnabled).to(template::setObservationEnabled);
		map.from(templateProperties::getAllowedListPatterns)
			.whenNot(CollectionUtils::isEmpty)
			.to((allowedListPatterns) -> setAllowedListPatterns(template.getMessageConverter(), allowedListPatterns));
	}
	private void setAllowedListPatterns(MessageConverter messageConverter, List<String> allowedListPatterns) {
		if (messageConverter instanceof AllowedListDeserializingMessageConverter allowedListDeserializingMessageConverter) {
			allowedListDeserializingMessageConverter.setAllowedListPatterns(allowedListPatterns);
			return;
		}
		throw new InvalidConfigurationPropertyValueException('spring.rabbitmq.template.allowed-list-patterns',
				allowedListPatterns,
				'Allowed list patterns can only be applied to an AllowedListDeserializingMessageConverter');
	}
	private boolean determineMandatoryFlag() {
		Boolean mandatory = this.rabbitProperties.getTemplate().getMandatory();
		return (mandatory != null) ? mandatory : this.rabbitProperties.isPublisherReturns();
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public final class DirectRabbitListenerContainerFactoryConfigurer
		extends AbstractRabbitListenerContainerFactoryConfigurer<DirectRabbitListenerContainerFactory> {
	/**
	 * Creates a new configurer that will use the given {@code rabbitProperties}.
	 * @param rabbitProperties properties to use
	 * @since 2.6.0
	 */
	public DirectRabbitListenerContainerFactoryConfigurer(RabbitProperties rabbitProperties) {
		super(rabbitProperties);
	}
	@Override
	public void configure(DirectRabbitListenerContainerFactory factory, ConnectionFactory connectionFactory) {
		PropertyMapper map = PropertyMapper.get();
		RabbitProperties.DirectContainer config = getRabbitProperties().getListener().getDirect();
		configure(factory, connectionFactory, config);
		map.from(config::getConsumersPerQueue).whenNonNull().to(factory::setConsumersPerQueue);
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
class RetryTemplateFactory {
	private final List<RabbitRetryTemplateCustomizer> customizers;
	RetryTemplateFactory(List<RabbitRetryTemplateCustomizer> customizers) {
		this.customizers = customizers;
	}
	RetryTemplate createRetryTemplate(RabbitProperties.Retry properties, RabbitRetryTemplateCustomizer.Target target) {
		PropertyMapper map = PropertyMapper.get();
		RetryTemplate template = new RetryTemplate();
		SimpleRetryPolicy policy = new SimpleRetryPolicy();
		map.from(properties::getMaxAttempts).to(policy::setMaxAttempts);
		template.setRetryPolicy(policy);
		ExponentialBackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
		map.from(properties::getInitialInterval)
			.whenNonNull()
			.as(Duration::toMillis)
			.to(backOffPolicy::setInitialInterval);
		map.from(properties::getMultiplier).to(backOffPolicy::setMultiplier);
		map.from(properties::getMaxInterval).whenNonNull().as(Duration::toMillis).to(backOffPolicy::setMaxInterval);
		template.setBackOffPolicy(backOffPolicy);
		if (this.customizers != null) {
			for (RabbitRetryTemplateCustomizer customizer : this.customizers) {
				customizer.customize(target, template);
			}
		}
		return template;
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
class SslBundleRabbitConnectionFactoryBean extends RabbitConnectionFactoryBean {
	private SslBundle sslBundle;
	private boolean enableHostnameVerification;
	@Override
	protected void setUpSSL() {
		if (this.sslBundle != null) {
			this.connectionFactory.useSslProtocol(this.sslBundle.createSslContext());
			if (this.enableHostnameVerification) {
				this.connectionFactory.enableHostnameVerification();
			}
		}
		else {
			super.setUpSSL();
		}
	}
	void setSslBundle(SslBundle sslBundle) {
		this.sslBundle = sslBundle;
	}
	@Override
	public void setEnableHostnameVerification(boolean enable) {
		this.enableHostnameVerification = enable;
		super.setEnableHostnameVerification(enable);
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@FunctionalInterface
public interface EnvironmentBuilderCustomizer {
	/**
	 * Customize the {@code EnvironmentBuilder}.
	 * @param builder the builder to customize
	 */
	void customize(EnvironmentBuilder builder);
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public abstract class AbstractRabbitListenerContainerFactoryConfigurer<T extends AbstractRabbitListenerContainerFactory<?>> {
	private MessageConverter messageConverter;
	private MessageRecoverer messageRecoverer;
	private List<RabbitRetryTemplateCustomizer> retryTemplateCustomizers;
	private final RabbitProperties rabbitProperties;
	private Executor taskExecutor;
	/**
	 * Creates a new configurer that will use the given {@code rabbitProperties}.
	 * @param rabbitProperties properties to use
	 * @since 2.6.0
	 */
	protected AbstractRabbitListenerContainerFactoryConfigurer(RabbitProperties rabbitProperties) {
		this.rabbitProperties = rabbitProperties;
	}
	/**
	 * Set the {@link MessageConverter} to use or {@code null} if the out-of-the-box
	 * converter should be used.
	 * @param messageConverter the {@link MessageConverter}
	 */
	protected void setMessageConverter(MessageConverter messageConverter) {
		this.messageConverter = messageConverter;
	}
	/**
	 * Set the {@link MessageRecoverer} to use or {@code null} to rely on the default.
	 * @param messageRecoverer the {@link MessageRecoverer}
	 */
	protected void setMessageRecoverer(MessageRecoverer messageRecoverer) {
		this.messageRecoverer = messageRecoverer;
	}
	/**
	 * Set the {@link RabbitRetryTemplateCustomizer} instances to use.
	 * @param retryTemplateCustomizers the retry template customizers
	 */
	protected void setRetryTemplateCustomizers(List<RabbitRetryTemplateCustomizer> retryTemplateCustomizers) {
		this.retryTemplateCustomizers = retryTemplateCustomizers;
	}
	/**
	 * Set the task executor to use.
	 * @param taskExecutor the task executor
	 * @since 3.2.0
	 */
	public void setTaskExecutor(Executor taskExecutor) {
		this.taskExecutor = taskExecutor;
	}
	protected final RabbitProperties getRabbitProperties() {
		return this.rabbitProperties;
	}
	/**
	 * Configure the specified rabbit listener container factory. The factory can be
	 * further tuned and default settings can be overridden.
	 * @param factory the {@link AbstractRabbitListenerContainerFactory} instance to
	 * configure
	 * @param connectionFactory the {@link ConnectionFactory} to use
	 */
	public abstract void configure(T factory, ConnectionFactory connectionFactory);
	protected void configure(T factory, ConnectionFactory connectionFactory,
			RabbitProperties.AmqpContainer configuration) {
		Assert.notNull(factory, 'Factory must not be null');
		Assert.notNull(connectionFactory, 'ConnectionFactory must not be null');
		Assert.notNull(configuration, 'Configuration must not be null');
		factory.setConnectionFactory(connectionFactory);
		if (this.messageConverter != null) {
			factory.setMessageConverter(this.messageConverter);
		}
		factory.setAutoStartup(configuration.isAutoStartup());
		if (configuration.getAcknowledgeMode() != null) {
			factory.setAcknowledgeMode(configuration.getAcknowledgeMode());
		}
		if (configuration.getPrefetch() != null) {
			factory.setPrefetchCount(configuration.getPrefetch());
		}
		if (configuration.getDefaultRequeueRejected() != null) {
			factory.setDefaultRequeueRejected(configuration.getDefaultRequeueRejected());
		}
		if (configuration.getIdleEventInterval() != null) {
			factory.setIdleEventInterval(configuration.getIdleEventInterval().toMillis());
		}
		factory.setMissingQueuesFatal(configuration.isMissingQueuesFatal());
		factory.setDeBatchingEnabled(configuration.isDeBatchingEnabled());
		factory.setForceStop(configuration.isForceStop());
		if (this.taskExecutor != null) {
			factory.setTaskExecutor(this.taskExecutor);
		}
		factory.setObservationEnabled(configuration.isObservationEnabled());
		ListenerRetry retryConfig = configuration.getRetry();
		if (retryConfig.isEnabled()) {
			RetryInterceptorBuilder<?, ?> builder = (retryConfig.isStateless()) ? RetryInterceptorBuilder.stateless()
					: RetryInterceptorBuilder.stateful();
			RetryTemplate retryTemplate = new RetryTemplateFactory(this.retryTemplateCustomizers)
				.createRetryTemplate(retryConfig, RabbitRetryTemplateCustomizer.Target.LISTENER);
			builder.retryOperations(retryTemplate);
			MessageRecoverer recoverer = (this.messageRecoverer != null) ? this.messageRecoverer
					: new RejectAndDontRequeueRecoverer();
			builder.recoverer(recoverer);
			factory.setAdviceChain(builder.build());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public class RabbitConnectionFactoryBeanConfigurer {
	private final RabbitProperties rabbitProperties;
	private final ResourceLoader resourceLoader;
	private final RabbitConnectionDetails connectionDetails;
	private final SslBundles sslBundles;
	private CredentialsProvider credentialsProvider;
	private CredentialsRefreshService credentialsRefreshService;
	/**
	 * Creates a new configurer that will use the given {@code resourceLoader} and
	 * {@code properties}.
	 * @param resourceLoader the resource loader
	 * @param properties the properties
	 */
	public RabbitConnectionFactoryBeanConfigurer(ResourceLoader resourceLoader, RabbitProperties properties) {
		this(resourceLoader, properties, new PropertiesRabbitConnectionDetails(properties));
	}
	/**
	 * Creates a new configurer that will use the given {@code resourceLoader},
	 * {@code properties}, and {@code connectionDetails}. The connection details have
	 * priority over the properties.
	 * @param resourceLoader the resource loader
	 * @param properties the properties
	 * @param connectionDetails the connection details
	 * @since 3.1.0
	 */
	public RabbitConnectionFactoryBeanConfigurer(ResourceLoader resourceLoader, RabbitProperties properties,
			RabbitConnectionDetails connectionDetails) {
		this(resourceLoader, properties, connectionDetails, null);
	}
	/**
	 * Creates a new configurer that will use the given {@code resourceLoader},
	 * {@code properties}, {@code connectionDetails}, and {@code sslBundles}. The
	 * connection details have priority over the properties.
	 * @param resourceLoader the resource loader
	 * @param properties the properties
	 * @param connectionDetails the connection details
	 * @param sslBundles the SSL bundles
	 * @since 3.2.0
	 */
	public RabbitConnectionFactoryBeanConfigurer(ResourceLoader resourceLoader, RabbitProperties properties,
			RabbitConnectionDetails connectionDetails, SslBundles sslBundles) {
		Assert.notNull(resourceLoader, 'ResourceLoader must not be null');
		Assert.notNull(properties, 'Properties must not be null');
		Assert.notNull(connectionDetails, 'ConnectionDetails must not be null');
		this.resourceLoader = resourceLoader;
		this.rabbitProperties = properties;
		this.connectionDetails = connectionDetails;
		this.sslBundles = sslBundles;
	}
	public void setCredentialsProvider(CredentialsProvider credentialsProvider) {
		this.credentialsProvider = credentialsProvider;
	}
	public void setCredentialsRefreshService(CredentialsRefreshService credentialsRefreshService) {
		this.credentialsRefreshService = credentialsRefreshService;
	}
	/**
	 * Configure the specified rabbit connection factory bean. The factory bean can be
	 * further tuned and default settings can be overridden. It is the responsibility of
	 * the caller to invoke {@link RabbitConnectionFactoryBean#afterPropertiesSet()}
	 * though.
	 * @param factory the {@link RabbitConnectionFactoryBean} instance to configure
	 */
	public void configure(RabbitConnectionFactoryBean factory) {
		Assert.notNull(factory, 'RabbitConnectionFactoryBean must not be null');
		factory.setResourceLoader(this.resourceLoader);
		Address address = this.connectionDetails.getFirstAddress();
		PropertyMapper map = PropertyMapper.get();
		map.from(address::host).whenNonNull().to(factory::setHost);
		map.from(address::port).to(factory::setPort);
		map.from(this.connectionDetails::getUsername).whenNonNull().to(factory::setUsername);
		map.from(this.connectionDetails::getPassword).whenNonNull().to(factory::setPassword);
		map.from(this.connectionDetails::getVirtualHost).whenNonNull().to(factory::setVirtualHost);
		map.from(this.rabbitProperties::getRequestedHeartbeat)
			.whenNonNull()
			.asInt(Duration::getSeconds)
			.to(factory::setRequestedHeartbeat);
		map.from(this.rabbitProperties::getRequestedChannelMax).to(factory::setRequestedChannelMax);
		RabbitProperties.Ssl ssl = this.rabbitProperties.getSsl();
		if (ssl.determineEnabled()) {
			factory.setUseSSL(true);
			if (ssl.getBundle() != null) {
				SslBundle bundle = this.sslBundles.getBundle(ssl.getBundle());
				if (factory instanceof SslBundleRabbitConnectionFactoryBean sslFactory) {
					sslFactory.setSslBundle(bundle);
				}
			}
			else {
				map.from(ssl::getAlgorithm).whenNonNull().to(factory::setSslAlgorithm);
				map.from(ssl::getKeyStoreType).to(factory::setKeyStoreType);
				map.from(ssl::getKeyStore).to(factory::setKeyStore);
				map.from(ssl::getKeyStorePassword).to(factory::setKeyStorePassphrase);
				map.from(ssl::getKeyStoreAlgorithm).whenNonNull().to(factory::setKeyStoreAlgorithm);
				map.from(ssl::getTrustStoreType).to(factory::setTrustStoreType);
				map.from(ssl::getTrustStore).to(factory::setTrustStore);
				map.from(ssl::getTrustStorePassword).to(factory::setTrustStorePassphrase);
				map.from(ssl::getTrustStoreAlgorithm).whenNonNull().to(factory::setTrustStoreAlgorithm);
			}
			map.from(ssl::isValidateServerCertificate)
				.to((validate) -> factory.setSkipServerCertificateValidation(!validate));
			map.from(ssl::getVerifyHostname).to(factory::setEnableHostnameVerification);
		}
		map.from(this.rabbitProperties::getConnectionTimeout)
			.whenNonNull()
			.asInt(Duration::toMillis)
			.to(factory::setConnectionTimeout);
		map.from(this.rabbitProperties::getChannelRpcTimeout)
			.whenNonNull()
			.asInt(Duration::toMillis)
			.to(factory::setChannelRpcTimeout);
		map.from(this.credentialsProvider).whenNonNull().to(factory::setCredentialsProvider);
		map.from(this.credentialsRefreshService).whenNonNull().to(factory::setCredentialsRefreshService);
		map.from(this.rabbitProperties.getMaxInboundMessageBodySize())
			.whenNonNull()
			.asInt(DataSize::toBytes)
			.to(factory::setMaxInboundMessageBodySize);
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(EnableRabbit.class)
class RabbitAnnotationDrivenConfiguration {
	private final ObjectProvider<MessageConverter> messageConverter;
	private final ObjectProvider<MessageRecoverer> messageRecoverer;
	private final ObjectProvider<RabbitRetryTemplateCustomizer> retryTemplateCustomizers;
	private final RabbitProperties properties;
	RabbitAnnotationDrivenConfiguration(ObjectProvider<MessageConverter> messageConverter,
			ObjectProvider<MessageRecoverer> messageRecoverer,
			ObjectProvider<RabbitRetryTemplateCustomizer> retryTemplateCustomizers, RabbitProperties properties) {
		this.messageConverter = messageConverter;
		this.messageRecoverer = messageRecoverer;
		this.retryTemplateCustomizers = retryTemplateCustomizers;
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.PLATFORM)
	SimpleRabbitListenerContainerFactoryConfigurer simpleRabbitListenerContainerFactoryConfigurer() {
		return simpleListenerConfigurer();
	}
	@Bean(name = 'simpleRabbitListenerContainerFactoryConfigurer')
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.VIRTUAL)
	SimpleRabbitListenerContainerFactoryConfigurer simpleRabbitListenerContainerFactoryConfigurerVirtualThreads() {
		SimpleRabbitListenerContainerFactoryConfigurer configurer = simpleListenerConfigurer();
		configurer.setTaskExecutor(new VirtualThreadTaskExecutor('rabbit-simple-'));
		return configurer;
	}
	@Bean(name = 'rabbitListenerContainerFactory')
	@ConditionalOnMissingBean(name = 'rabbitListenerContainerFactory')
	@ConditionalOnProperty(prefix = 'spring.rabbitmq.listener', name = 'type', havingValue = 'simple',
			matchIfMissing = true)
	SimpleRabbitListenerContainerFactory simpleRabbitListenerContainerFactory(
			SimpleRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory,
			ObjectProvider<ContainerCustomizer<SimpleMessageListenerContainer>> simpleContainerCustomizer) {
		SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
		configurer.configure(factory, connectionFactory);
		simpleContainerCustomizer.ifUnique(factory::setContainerCustomizer);
		return factory;
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.PLATFORM)
	DirectRabbitListenerContainerFactoryConfigurer directRabbitListenerContainerFactoryConfigurer() {
		return directListenerConfigurer();
	}
	@Bean(name = 'directRabbitListenerContainerFactoryConfigurer')
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.VIRTUAL)
	DirectRabbitListenerContainerFactoryConfigurer directRabbitListenerContainerFactoryConfigurerVirtualThreads() {
		DirectRabbitListenerContainerFactoryConfigurer configurer = directListenerConfigurer();
		configurer.setTaskExecutor(new VirtualThreadTaskExecutor('rabbit-direct-'));
		return configurer;
	}
	@Bean(name = 'rabbitListenerContainerFactory')
	@ConditionalOnMissingBean(name = 'rabbitListenerContainerFactory')
	@ConditionalOnProperty(prefix = 'spring.rabbitmq.listener', name = 'type', havingValue = 'direct')
	DirectRabbitListenerContainerFactory directRabbitListenerContainerFactory(
			DirectRabbitListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory,
			ObjectProvider<ContainerCustomizer<DirectMessageListenerContainer>> directContainerCustomizer) {
		DirectRabbitListenerContainerFactory factory = new DirectRabbitListenerContainerFactory();
		configurer.configure(factory, connectionFactory);
		directContainerCustomizer.ifUnique(factory::setContainerCustomizer);
		return factory;
	}
	private SimpleRabbitListenerContainerFactoryConfigurer simpleListenerConfigurer() {
		SimpleRabbitListenerContainerFactoryConfigurer configurer = new SimpleRabbitListenerContainerFactoryConfigurer(
				this.properties);
		configurer.setMessageConverter(this.messageConverter.getIfUnique());
		configurer.setMessageRecoverer(this.messageRecoverer.getIfUnique());
		configurer.setRetryTemplateCustomizers(this.retryTemplateCustomizers.orderedStream().toList());
		return configurer;
	}
	private DirectRabbitListenerContainerFactoryConfigurer directListenerConfigurer() {
		DirectRabbitListenerContainerFactoryConfigurer configurer = new DirectRabbitListenerContainerFactoryConfigurer(
				this.properties);
		configurer.setMessageConverter(this.messageConverter.getIfUnique());
		configurer.setMessageRecoverer(this.messageRecoverer.getIfUnique());
		configurer.setRetryTemplateCustomizers(this.retryTemplateCustomizers.orderedStream().toList());
		return configurer;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableRabbit
	@ConditionalOnMissingBean(name = RabbitListenerConfigUtils.RABBIT_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)
	static class EnableRabbitConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@AutoConfiguration
@ConditionalOnClass({ RabbitTemplate.class, Channel.class })
@EnableConfigurationProperties(RabbitProperties.class)
@Import({ RabbitAnnotationDrivenConfiguration.class, RabbitStreamConfiguration.class })
public class RabbitAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	protected static class RabbitConnectionFactoryCreator {
		private final RabbitProperties properties;
		protected RabbitConnectionFactoryCreator(RabbitProperties properties) {
			this.properties = properties;
		}
		@Bean
		@ConditionalOnMissingBean(RabbitConnectionDetails.class)
		RabbitConnectionDetails rabbitConnectionDetails() {
			return new PropertiesRabbitConnectionDetails(this.properties);
		}
		@Bean
		@ConditionalOnMissingBean
		RabbitConnectionFactoryBeanConfigurer rabbitConnectionFactoryBeanConfigurer(ResourceLoader resourceLoader,
				RabbitConnectionDetails connectionDetails, ObjectProvider<CredentialsProvider> credentialsProvider,
				ObjectProvider<CredentialsRefreshService> credentialsRefreshService,
				ObjectProvider<SslBundles> sslBundles) {
			RabbitConnectionFactoryBeanConfigurer configurer = new RabbitConnectionFactoryBeanConfigurer(resourceLoader,
					this.properties, connectionDetails, sslBundles.getIfAvailable());
			configurer.setCredentialsProvider(credentialsProvider.getIfUnique());
			configurer.setCredentialsRefreshService(credentialsRefreshService.getIfUnique());
			return configurer;
		}
		@Bean
		@ConditionalOnMissingBean
		CachingConnectionFactoryConfigurer rabbitConnectionFactoryConfigurer(RabbitConnectionDetails connectionDetails,
				ObjectProvider<ConnectionNameStrategy> connectionNameStrategy) {
			CachingConnectionFactoryConfigurer configurer = new CachingConnectionFactoryConfigurer(this.properties,
					connectionDetails);
			configurer.setConnectionNameStrategy(connectionNameStrategy.getIfUnique());
			return configurer;
		}
		@Bean
		@ConditionalOnMissingBean(ConnectionFactory.class)
		CachingConnectionFactory rabbitConnectionFactory(
				RabbitConnectionFactoryBeanConfigurer rabbitConnectionFactoryBeanConfigurer,
				CachingConnectionFactoryConfigurer rabbitCachingConnectionFactoryConfigurer,
				ObjectProvider<ConnectionFactoryCustomizer> connectionFactoryCustomizers) throws Exception {
			RabbitConnectionFactoryBean connectionFactoryBean = new SslBundleRabbitConnectionFactoryBean();
			rabbitConnectionFactoryBeanConfigurer.configure(connectionFactoryBean);
			connectionFactoryBean.afterPropertiesSet();
			com.rabbitmq.client.ConnectionFactory connectionFactory = connectionFactoryBean.getObject();
			connectionFactoryCustomizers.orderedStream()
				.forEach((customizer) -> customizer.customize(connectionFactory));
			CachingConnectionFactory factory = new CachingConnectionFactory(connectionFactory);
			rabbitCachingConnectionFactoryConfigurer.configure(factory);
			return factory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(RabbitConnectionFactoryCreator.class)
	protected static class RabbitTemplateConfiguration {
		@Bean
		@ConditionalOnMissingBean
		public RabbitTemplateConfigurer rabbitTemplateConfigurer(RabbitProperties properties,
				ObjectProvider<MessageConverter> messageConverter,
				ObjectProvider<RabbitRetryTemplateCustomizer> retryTemplateCustomizers) {
			RabbitTemplateConfigurer configurer = new RabbitTemplateConfigurer(properties);
			configurer.setMessageConverter(messageConverter.getIfUnique());
			configurer.setRetryTemplateCustomizers(retryTemplateCustomizers.orderedStream().toList());
			return configurer;
		}
		@Bean
		@ConditionalOnSingleCandidate(ConnectionFactory.class)
		@ConditionalOnMissingBean(RabbitOperations.class)
		public RabbitTemplate rabbitTemplate(RabbitTemplateConfigurer configurer, ConnectionFactory connectionFactory,
				ObjectProvider<RabbitTemplateCustomizer> customizers) {
			RabbitTemplate template = new RabbitTemplate();
			configurer.configure(template, connectionFactory);
			customizers.orderedStream().forEach((customizer) -> customizer.customize(template));
			return template;
		}
		@Bean
		@ConditionalOnSingleCandidate(ConnectionFactory.class)
		@ConditionalOnProperty(prefix = 'spring.rabbitmq', name = 'dynamic', matchIfMissing = true)
		@ConditionalOnMissingBean
		public AmqpAdmin amqpAdmin(ConnectionFactory connectionFactory) {
			return new RabbitAdmin(connectionFactory);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(RabbitMessagingTemplate.class)
	@ConditionalOnMissingBean(RabbitMessagingTemplate.class)
	@Import(RabbitTemplateConfiguration.class)
	protected static class MessagingTemplateConfiguration {
		@Bean
		@ConditionalOnSingleCandidate(RabbitTemplate.class)
		public RabbitMessagingTemplate rabbitMessagingTemplate(RabbitTemplate rabbitTemplate) {
			return new RabbitMessagingTemplate(rabbitTemplate);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public final class SimpleRabbitListenerContainerFactoryConfigurer
		extends AbstractRabbitListenerContainerFactoryConfigurer<SimpleRabbitListenerContainerFactory> {
	/**
	 * Creates a new configurer that will use the given {@code rabbitProperties}.
	 * @param rabbitProperties properties to use
	 * @since 2.6.0
	 */
	public SimpleRabbitListenerContainerFactoryConfigurer(RabbitProperties rabbitProperties) {
		super(rabbitProperties);
	}
	@Override
	public void configure(SimpleRabbitListenerContainerFactory factory, ConnectionFactory connectionFactory) {
		PropertyMapper map = PropertyMapper.get();
		RabbitProperties.SimpleContainer config = getRabbitProperties().getListener().getSimple();
		configure(factory, connectionFactory, config);
		map.from(config::getConcurrency).whenNonNull().to(factory::setConcurrentConsumers);
		map.from(config::getMaxConcurrency).whenNonNull().to(factory::setMaxConcurrentConsumers);
		map.from(config::getBatchSize).whenNonNull().to(factory::setBatchSize);
		map.from(config::isConsumerBatchEnabled).to(factory::setConsumerBatchEnabled);
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public class CachingConnectionFactoryConfigurer extends AbstractConnectionFactoryConfigurer<CachingConnectionFactory> {
	/**
	 * Creates a new configurer that will configure the connection factory using the given
	 * {@code properties}.
	 * @param properties the properties to use to configure the connection factory
	 */
	public CachingConnectionFactoryConfigurer(RabbitProperties properties) {
		this(properties, new PropertiesRabbitConnectionDetails(properties));
	}
	/**
	 * Creates a new configurer that will configure the connection factory using the given
	 * {@code properties} and {@code connectionDetails}, with the latter taking priority.
	 * @param properties the properties to use to configure the connection factory
	 * @param connectionDetails the connection details to use to configure the connection
	 * factory
	 * @since 3.1.0
	 */
	public CachingConnectionFactoryConfigurer(RabbitProperties properties, RabbitConnectionDetails connectionDetails) {
		super(properties, connectionDetails);
	}
	@Override
	public void configure(CachingConnectionFactory connectionFactory, RabbitProperties rabbitProperties) {
		PropertyMapper map = PropertyMapper.get();
		map.from(rabbitProperties::isPublisherReturns).to(connectionFactory::setPublisherReturns);
		map.from(rabbitProperties::getPublisherConfirmType)
			.whenNonNull()
			.to(connectionFactory::setPublisherConfirmType);
		RabbitProperties.Cache.Channel channel = rabbitProperties.getCache().getChannel();
		map.from(channel::getSize).whenNonNull().to(connectionFactory::setChannelCacheSize);
		map.from(channel::getCheckoutTimeout)
			.whenNonNull()
			.as(Duration::toMillis)
			.to(connectionFactory::setChannelCheckoutTimeout);
		RabbitProperties.Cache.Connection connection = rabbitProperties.getCache().getConnection();
		map.from(connection::getMode).whenNonNull().to(connectionFactory::setCacheMode);
		map.from(connection::getSize).whenNonNull().to(connectionFactory::setConnectionCacheSize);
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public interface RabbitConnectionDetails extends ConnectionDetails {
	/**
	 * Login user to authenticate to the broker.
	 * @return the login user to authenticate to the broker or {@code null}
	 */
	default String getUsername() {
		return null;
	}
	/**
	 * Login to authenticate against the broker.
	 * @return the login to authenticate against the broker or {@code null}
	 */
	default String getPassword() {
		return null;
	}
	/**
	 * Virtual host to use when connecting to the broker.
	 * @return the virtual host to use when connecting to the broker or {@code null}
	 */
	default String getVirtualHost() {
		return null;
	}
	/**
	 * List of addresses to which the client should connect. Must return at least one
	 * address.
	 * @return the list of addresses to which the client should connect
	 */
	List<Address> getAddresses();
	/**
	 * Returns the first address.
	 * @return the first address
	 * @throws IllegalStateException if the address list is empty
	 */
	default Address getFirstAddress() {
		List<Address> addresses = getAddresses();
		Assert.state(!addresses.isEmpty(), 'Address list is empty');
		return addresses.get(0);
	}
	/**
	 * A RabbitMQ address.
	 *
	 * @param host the host
	 * @param port the port
	 */
	record Address(String host, int port) {
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@FunctionalInterface
public interface RabbitTemplateCustomizer {
	/**
	 * Callback to customize a {@link RabbitTemplate} instance.
	 * @param rabbitTemplate the rabbitTemplate to customize
	 */
	void customize(RabbitTemplate rabbitTemplate);
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
public abstract class AbstractConnectionFactoryConfigurer<T extends AbstractConnectionFactory> {
	private final RabbitProperties rabbitProperties;
	private ConnectionNameStrategy connectionNameStrategy;
	private final RabbitConnectionDetails connectionDetails;
	/**
	 * Creates a new configurer that will configure the connection factory using the given
	 * {@code properties}.
	 * @param properties the properties to use to configure the connection factory
	 */
	protected AbstractConnectionFactoryConfigurer(RabbitProperties properties) {
		this(properties, new PropertiesRabbitConnectionDetails(properties));
	}
	/**
	 * Creates a new configurer that will configure the connection factory using the given
	 * {@code properties} and {@code connectionDetails}, with the latter taking priority.
	 * @param properties the properties to use to configure the connection factory
	 * @param connectionDetails the connection details to use to configure the connection
	 * factory
	 * @since 3.1.0
	 */
	protected AbstractConnectionFactoryConfigurer(RabbitProperties properties,
			RabbitConnectionDetails connectionDetails) {
		Assert.notNull(properties, 'Properties must not be null');
		Assert.notNull(connectionDetails, 'ConnectionDetails must not be null');
		this.rabbitProperties = properties;
		this.connectionDetails = connectionDetails;
	}
	protected final ConnectionNameStrategy getConnectionNameStrategy() {
		return this.connectionNameStrategy;
	}
	public final void setConnectionNameStrategy(ConnectionNameStrategy connectionNameStrategy) {
		this.connectionNameStrategy = connectionNameStrategy;
	}
	/**
	 * Configures the given {@code connectionFactory} with sensible defaults.
	 * @param connectionFactory connection factory to configure
	 */
	public final void configure(T connectionFactory) {
		Assert.notNull(connectionFactory, 'ConnectionFactory must not be null');
		PropertyMapper map = PropertyMapper.get();
		String addresses = this.connectionDetails.getAddresses()
			.stream()
			.map((address) -> address.host() + ':' + address.port())
			.collect(Collectors.joining(','));
		map.from(addresses).to(connectionFactory::setAddresses);
		map.from(this.rabbitProperties::getAddressShuffleMode)
			.whenNonNull()
			.to(connectionFactory::setAddressShuffleMode);
		map.from(this.connectionNameStrategy).whenNonNull().to(connectionFactory::setConnectionNameStrategy);
		configure(connectionFactory, this.rabbitProperties);
	}
	/**
	 * Configures the given {@code connectionFactory} using the given
	 * {@code rabbitProperties}.
	 * @param connectionFactory connection factory to configure
	 * @param rabbitProperties properties to use for the configuration
	 */
	protected abstract void configure(T connectionFactory, RabbitProperties rabbitProperties);
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(StreamRabbitListenerContainerFactory.class)
class RabbitStreamConfiguration {
	@Bean(name = 'rabbitListenerContainerFactory')
	@ConditionalOnMissingBean(name = 'rabbitListenerContainerFactory')
	@ConditionalOnProperty(prefix = 'spring.rabbitmq.listener', name = 'type', havingValue = 'stream')
	StreamRabbitListenerContainerFactory streamRabbitListenerContainerFactory(Environment rabbitStreamEnvironment,
			RabbitProperties properties, ObjectProvider<ConsumerCustomizer> consumerCustomizer,
			ObjectProvider<ContainerCustomizer<StreamListenerContainer>> containerCustomizer) {
		StreamRabbitListenerContainerFactory factory = new StreamRabbitListenerContainerFactory(
				rabbitStreamEnvironment);
		StreamContainer stream = properties.getListener().getStream();
		factory.setObservationEnabled(stream.isObservationEnabled());
		factory.setNativeListener(stream.isNativeListener());
		consumerCustomizer.ifUnique(factory::setConsumerCustomizer);
		containerCustomizer.ifUnique(factory::setContainerCustomizer);
		return factory;
	}
	@Bean(name = 'rabbitStreamEnvironment')
	@ConditionalOnMissingBean(name = 'rabbitStreamEnvironment')
	Environment rabbitStreamEnvironment(RabbitProperties properties, RabbitConnectionDetails connectionDetails,
			ObjectProvider<EnvironmentBuilderCustomizer> customizers) {
		EnvironmentBuilder builder = configure(Environment.builder(), properties, connectionDetails);
		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	RabbitStreamTemplateConfigurer rabbitStreamTemplateConfigurer(RabbitProperties properties,
			ObjectProvider<MessageConverter> messageConverter,
			ObjectProvider<StreamMessageConverter> streamMessageConverter,
			ObjectProvider<ProducerCustomizer> producerCustomizer) {
		RabbitStreamTemplateConfigurer configurer = new RabbitStreamTemplateConfigurer();
		configurer.setMessageConverter(messageConverter.getIfUnique());
		configurer.setStreamMessageConverter(streamMessageConverter.getIfUnique());
		configurer.setProducerCustomizer(producerCustomizer.getIfUnique());
		return configurer;
	}
	@Bean
	@ConditionalOnMissingBean(RabbitStreamOperations.class)
	@ConditionalOnProperty(prefix = 'spring.rabbitmq.stream', name = 'name')
	RabbitStreamTemplate rabbitStreamTemplate(Environment rabbitStreamEnvironment, RabbitProperties properties,
			RabbitStreamTemplateConfigurer configurer) {
		RabbitStreamTemplate template = new RabbitStreamTemplate(rabbitStreamEnvironment,
				properties.getStream().getName());
		configurer.configure(template);
		return template;
	}
	static EnvironmentBuilder configure(EnvironmentBuilder builder, RabbitProperties properties,
			RabbitConnectionDetails connectionDetails) {
		return configure(builder, properties.getStream(), connectionDetails);
	}
	private static EnvironmentBuilder configure(EnvironmentBuilder builder, RabbitProperties.Stream stream,
			RabbitConnectionDetails connectionDetails) {
		builder.lazyInitialization(true);
		PropertyMapper map = PropertyMapper.get();
		map.from(stream.getHost()).to(builder::host);
		map.from(stream.getPort()).to(builder::port);
		map.from(stream.getVirtualHost())
			.as(withFallback(connectionDetails::getVirtualHost))
			.whenNonNull()
			.to(builder::virtualHost);
		map.from(stream.getUsername())
			.as(withFallback(connectionDetails::getUsername))
			.whenNonNull()
			.to(builder::username);
		map.from(stream.getPassword())
			.as(withFallback(connectionDetails::getPassword))
			.whenNonNull()
			.to(builder::password);
		return builder;
	}
	private static Function<String, String> withFallback(Supplier<String> fallback) {
		return (value) -> (value != null) ? value : fallback.get();
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
class PropertiesRabbitConnectionDetails implements RabbitConnectionDetails {
	private final RabbitProperties properties;
	PropertiesRabbitConnectionDetails(RabbitProperties properties) {
		this.properties = properties;
	}
	@Override
	public String getUsername() {
		return this.properties.determineUsername();
	}
	@Override
	public String getPassword() {
		return this.properties.determinePassword();
	}
	@Override
	public String getVirtualHost() {
		return this.properties.determineVirtualHost();
	}
	@Override
	public List<Address> getAddresses() {
		List<Address> addresses = new ArrayList<>();
		for (String address : this.properties.determineAddresses()) {
			int portSeparatorIndex = address.lastIndexOf(":");
			String host = address.substring(0, portSeparatorIndex);
			String port = address.substring(portSeparatorIndex + 1);
			addresses.add(new Address(host, Integer.parseInt(port)));
		}
		return addresses;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.amqp;
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@FunctionalInterface
public interface RabbitRetryTemplateCustomizer {
	/**
	 * Callback to customize a {@link RetryTemplate} instance used in the context of the
	 * specified {@link Target}.
	 * @param target the {@link Target} of the retry template
	 * @param retryTemplate the template to customize
	 */
	void customize(Target target, RetryTemplate retryTemplate);
	/**
	 * Define the available target for a {@link RetryTemplate}.
	 */
	enum Target {
		/**
		 * {@link RabbitTemplate} target.
		 */
		SENDER,
		/**
		 * {@link AbstractMessageListenerContainer} target.
		 */
		LISTENER
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@FunctionalInterface
public interface ConnectionFactoryCustomizer {
	/**
	 * Customize the {@link ConnectionFactory}.
	 * @param factory the factory to customize
	 */
	void customize(ConnectionFactory factory);
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@ConfigurationProperties(prefix = 'spring.rabbitmq')
public class RabbitProperties {
	private static final int DEFAULT_PORT = 5672;
	private static final int DEFAULT_PORT_SECURE = 5671;
	private static final int DEFAULT_STREAM_PORT = 5552;
	/**
	 * RabbitMQ host. Ignored if an address is set.
	 */
	private String host = 'localhost';
	/**
	 * RabbitMQ port. Ignored if an address is set. Default to 5672, or 5671 if SSL is
	 * enabled.
	 */
	private Integer port;
	/**
	 * Login user to authenticate to the broker.
	 */
	private String username = 'guest';
	/**
	 * Login to authenticate against the broker.
	 */
	private String password = 'guest';
	/**
	 * SSL configuration.
	 */
	private final Ssl ssl = new Ssl();
	/**
	 * Virtual host to use when connecting to the broker.
	 */
	private String virtualHost;
	/**
	 * List of addresses to which the client should connect. When set, the host and port
	 * are ignored.
	 */
	private List<String> addresses;
	/**
	 * Mode used to shuffle configured addresses.
	 */
	private AddressShuffleMode addressShuffleMode = AddressShuffleMode.NONE;
	/**
	 * Requested heartbeat timeout; zero for none. If a duration suffix is not specified,
	 * seconds will be used.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration requestedHeartbeat;
	/**
	 * Number of channels per connection requested by the client. Use 0 for unlimited.
	 */
	private int requestedChannelMax = 2047;
	/**
	 * Whether to enable publisher returns.
	 */
	private boolean publisherReturns;
	/**
	 * Type of publisher confirms to use.
	 */
	private ConfirmType publisherConfirmType;
	/**
	 * Connection timeout. Set it to zero to wait forever.
	 */
	private Duration connectionTimeout;
	/**
	 * Continuation timeout for RPC calls in channels. Set it to zero to wait forever.
	 */
	private Duration channelRpcTimeout = Duration.ofMinutes(10);
	/**
	 * Maximum size of the body of inbound (received) messages.
	 */
	private DataSize maxInboundMessageBodySize = DataSize.ofMegabytes(64);
	/**
	 * Cache configuration.
	 */
	private final Cache cache = new Cache();
	/**
	 * Listener container configuration.
	 */
	private final Listener listener = new Listener();
	private final Template template = new Template();
	private final Stream stream = new Stream();
	private List<Address> parsedAddresses;
	public String getHost() {
		return this.host;
	}
	/**
	 * Returns the host from the first address, or the configured host if no addresses
	 * have been set.
	 * @return the host
	 * @see #setAddresses(List)
	 * @see #getHost()
	 */
	public String determineHost() {
		if (CollectionUtils.isEmpty(this.parsedAddresses)) {
			return getHost();
		}
		return this.parsedAddresses.get(0).host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public Integer getPort() {
		return this.port;
	}
	/**
	 * Returns the port from the first address, or the configured port if no addresses
	 * have been set.
	 * @return the port
	 * @see #setAddresses(List)
	 * @see #getPort()
	 */
	public int determinePort() {
		if (CollectionUtils.isEmpty(this.parsedAddresses)) {
			Integer port = getPort();
			if (port != null) {
				return port;
			}
			return (Optional.ofNullable(getSsl().getEnabled()).orElse(false)) ? DEFAULT_PORT_SECURE : DEFAULT_PORT;
		}
		return this.parsedAddresses.get(0).port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
	public List<String> getAddresses() {
		return this.addresses;
	}
	/**
	 * Returns the configured addresses or a single address ({@code host:port}) created
	 * from the configured host and port if no addresses have been set.
	 * @return the addresses
	 */
	public List<String> determineAddresses() {
		if (CollectionUtils.isEmpty(this.parsedAddresses)) {
			if (this.host.contains(',')) {
				throw new InvalidConfigurationPropertyValueException('spring.rabbitmq.host', this.host,
						'Invalid character ",". Value must be a single host. For multiple hosts, use property "spring.rabbitmq.addresses" instead.');
			}
			return List.of(this.host + ':' + determinePort());
		}
		List<String> addressStrings = new ArrayList<>();
		for (Address parsedAddress : this.parsedAddresses) {
			addressStrings.add(parsedAddress.host + ':' + parsedAddress.port);
		}
		return addressStrings;
	}
	public void setAddresses(List<String> addresses) {
		this.addresses = addresses;
		this.parsedAddresses = parseAddresses(addresses);
	}
	private List<Address> parseAddresses(List<String> addresses) {
		List<Address> parsedAddresses = new ArrayList<>();
		for (String address : addresses) {
			parsedAddresses.add(new Address(address, Optional.ofNullable(getSsl().getEnabled()).orElse(false)));
		}
		return parsedAddresses;
	}
	public String getUsername() {
		return this.username;
	}
	/**
	 * If addresses have been set and the first address has a username it is returned.
	 * Otherwise returns the result of calling {@code getUsername()}.
	 * @return the username
	 * @see #setAddresses(List)
	 * @see #getUsername()
	 */
	public String determineUsername() {
		if (CollectionUtils.isEmpty(this.parsedAddresses)) {
			return this.username;
		}
		Address address = this.parsedAddresses.get(0);
		return (address.username != null) ? address.username : this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	/**
	 * If addresses have been set and the first address has a password it is returned.
	 * Otherwise returns the result of calling {@code getPassword()}.
	 * @return the password or {@code null}
	 * @see #setAddresses(List)
	 * @see #getPassword()
	 */
	public String determinePassword() {
		if (CollectionUtils.isEmpty(this.parsedAddresses)) {
			return getPassword();
		}
		Address address = this.parsedAddresses.get(0);
		return (address.password != null) ? address.password : getPassword();
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public String getVirtualHost() {
		return this.virtualHost;
	}
	/**
	 * If addresses have been set and the first address has a virtual host it is returned.
	 * Otherwise returns the result of calling {@code getVirtualHost()}.
	 * @return the virtual host or {@code null}
	 * @see #setAddresses(List)
	 * @see #getVirtualHost()
	 */
	public String determineVirtualHost() {
		if (CollectionUtils.isEmpty(this.parsedAddresses)) {
			return getVirtualHost();
		}
		Address address = this.parsedAddresses.get(0);
		return (address.virtualHost != null) ? address.virtualHost : getVirtualHost();
	}
	public void setVirtualHost(String virtualHost) {
		this.virtualHost = StringUtils.hasText(virtualHost) ? virtualHost : '/';
	}
	public AddressShuffleMode getAddressShuffleMode() {
		return this.addressShuffleMode;
	}
	public void setAddressShuffleMode(AddressShuffleMode addressShuffleMode) {
		this.addressShuffleMode = addressShuffleMode;
	}
	public Duration getRequestedHeartbeat() {
		return this.requestedHeartbeat;
	}
	public void setRequestedHeartbeat(Duration requestedHeartbeat) {
		this.requestedHeartbeat = requestedHeartbeat;
	}
	public int getRequestedChannelMax() {
		return this.requestedChannelMax;
	}
	public void setRequestedChannelMax(int requestedChannelMax) {
		this.requestedChannelMax = requestedChannelMax;
	}
	public boolean isPublisherReturns() {
		return this.publisherReturns;
	}
	public void setPublisherReturns(boolean publisherReturns) {
		this.publisherReturns = publisherReturns;
	}
	public Duration getConnectionTimeout() {
		return this.connectionTimeout;
	}
	public void setPublisherConfirmType(ConfirmType publisherConfirmType) {
		this.publisherConfirmType = publisherConfirmType;
	}
	public ConfirmType getPublisherConfirmType() {
		return this.publisherConfirmType;
	}
	public void setConnectionTimeout(Duration connectionTimeout) {
		this.connectionTimeout = connectionTimeout;
	}
	public Duration getChannelRpcTimeout() {
		return this.channelRpcTimeout;
	}
	public void setChannelRpcTimeout(Duration channelRpcTimeout) {
		this.channelRpcTimeout = channelRpcTimeout;
	}
	public DataSize getMaxInboundMessageBodySize() {
		return this.maxInboundMessageBodySize;
	}
	public void setMaxInboundMessageBodySize(DataSize maxInboundMessageBodySize) {
		this.maxInboundMessageBodySize = maxInboundMessageBodySize;
	}
	public Cache getCache() {
		return this.cache;
	}
	public Listener getListener() {
		return this.listener;
	}
	public Template getTemplate() {
		return this.template;
	}
	public Stream getStream() {
		return this.stream;
	}
	public class Ssl {
		private static final String SUN_X509 = 'SunX509';
		/**
		 * Whether to enable SSL support. Determined automatically if an address is
		 * provided with the protocol (amqp:// vs. amqps://).
		 */
		private Boolean enabled;
		/**
		 * SSL bundle name.
		 */
		private String bundle;
		/**
		 * Path to the key store that holds the SSL certificate.
		 */
		private String keyStore;
		/**
		 * Key store type.
		 */
		private String keyStoreType = 'PKCS12';
		/**
		 * Password used to access the key store.
		 */
		private String keyStorePassword;
		/**
		 * Key store algorithm.
		 */
		private String keyStoreAlgorithm = SUN_X509;
		/**
		 * Trust store that holds SSL certificates.
		 */
		private String trustStore;
		/**
		 * Trust store type.
		 */
		private String trustStoreType = 'JKS';
		/**
		 * Password used to access the trust store.
		 */
		private String trustStorePassword;
		/**
		 * Trust store algorithm.
		 */
		private String trustStoreAlgorithm = SUN_X509;
		/**
		 * SSL algorithm to use. By default, configured by the Rabbit client library.
		 */
		private String algorithm;
		/**
		 * Whether to enable server side certificate validation.
		 */
		private boolean validateServerCertificate = true;
		/**
		 * Whether to enable hostname verification.
		 */
		private boolean verifyHostname = true;
		public Boolean getEnabled() {
			return this.enabled;
		}
		/**
		 * Returns whether SSL is enabled from the first address, or the configured ssl
		 * enabled flag if no addresses have been set.
		 * @return whether ssl is enabled
		 * @see #setAddresses(List)
		 * @see #getEnabled() ()
		 */
		public boolean determineEnabled() {
			boolean defaultEnabled = Optional.ofNullable(getEnabled()).orElse(false) || this.bundle != null;
			if (CollectionUtils.isEmpty(RabbitProperties.this.parsedAddresses)) {
				return defaultEnabled;
			}
			Address address = RabbitProperties.this.parsedAddresses.get(0);
			return address.determineSslEnabled(defaultEnabled);
		}
		public void setEnabled(Boolean enabled) {
			this.enabled = enabled;
		}
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
		public String getKeyStore() {
			return this.keyStore;
		}
		public void setKeyStore(String keyStore) {
			this.keyStore = keyStore;
		}
		public String getKeyStoreType() {
			return this.keyStoreType;
		}
		public void setKeyStoreType(String keyStoreType) {
			this.keyStoreType = keyStoreType;
		}
		public String getKeyStorePassword() {
			return this.keyStorePassword;
		}
		public void setKeyStorePassword(String keyStorePassword) {
			this.keyStorePassword = keyStorePassword;
		}
		public String getKeyStoreAlgorithm() {
			return this.keyStoreAlgorithm;
		}
		public void setKeyStoreAlgorithm(String keyStoreAlgorithm) {
			this.keyStoreAlgorithm = keyStoreAlgorithm;
		}
		public String getTrustStore() {
			return this.trustStore;
		}
		public void setTrustStore(String trustStore) {
			this.trustStore = trustStore;
		}
		public String getTrustStoreType() {
			return this.trustStoreType;
		}
		public void setTrustStoreType(String trustStoreType) {
			this.trustStoreType = trustStoreType;
		}
		public String getTrustStorePassword() {
			return this.trustStorePassword;
		}
		public void setTrustStorePassword(String trustStorePassword) {
			this.trustStorePassword = trustStorePassword;
		}
		public String getTrustStoreAlgorithm() {
			return this.trustStoreAlgorithm;
		}
		public void setTrustStoreAlgorithm(String trustStoreAlgorithm) {
			this.trustStoreAlgorithm = trustStoreAlgorithm;
		}
		public String getAlgorithm() {
			return this.algorithm;
		}
		public void setAlgorithm(String sslAlgorithm) {
			this.algorithm = sslAlgorithm;
		}
		public boolean isValidateServerCertificate() {
			return this.validateServerCertificate;
		}
		public void setValidateServerCertificate(boolean validateServerCertificate) {
			this.validateServerCertificate = validateServerCertificate;
		}
		public boolean getVerifyHostname() {
			return this.verifyHostname;
		}
		public void setVerifyHostname(boolean verifyHostname) {
			this.verifyHostname = verifyHostname;
		}
	}
	public static class Cache {
		private final Channel channel = new Channel();
		private final Connection connection = new Connection();
		public Channel getChannel() {
			return this.channel;
		}
		public Connection getConnection() {
			return this.connection;
		}
		public static class Channel {
			/**
			 * Number of channels to retain in the cache. When 'check-timeout' > 0, max
			 * channels per connection.
			 */
			private Integer size;
			/**
			 * Duration to wait to obtain a channel if the cache size has been reached. If
			 * 0, always create a new channel.
			 */
			private Duration checkoutTimeout;
			public Integer getSize() {
				return this.size;
			}
			public void setSize(Integer size) {
				this.size = size;
			}
			public Duration getCheckoutTimeout() {
				return this.checkoutTimeout;
			}
			public void setCheckoutTimeout(Duration checkoutTimeout) {
				this.checkoutTimeout = checkoutTimeout;
			}
		}
		public static class Connection {
			/**
			 * Connection factory cache mode.
			 */
			private CacheMode mode = CacheMode.CHANNEL;
			/**
			 * Number of connections to cache. Only applies when mode is CONNECTION.
			 */
			private Integer size;
			public CacheMode getMode() {
				return this.mode;
			}
			public void setMode(CacheMode mode) {
				this.mode = mode;
			}
			public Integer getSize() {
				return this.size;
			}
			public void setSize(Integer size) {
				this.size = size;
			}
		}
	}
	public enum ContainerType {
		/**
		 * Container where the RabbitMQ consumer dispatches messages to an invoker thread.
		 */
		SIMPLE,
		/**
		 * Container where the listener is invoked directly on the RabbitMQ consumer
		 * thread.
		 */
		DIRECT,
		/**
		 * Container that uses the RabbitMQ Stream Client.
		 */
		STREAM
	}
	public static class Listener {
		/**
		 * Listener container type.
		 */
		private ContainerType type = ContainerType.SIMPLE;
		private final SimpleContainer simple = new SimpleContainer();
		private final DirectContainer direct = new DirectContainer();
		private final StreamContainer stream = new StreamContainer();
		public ContainerType getType() {
			return this.type;
		}
		public void setType(ContainerType containerType) {
			this.type = containerType;
		}
		public SimpleContainer getSimple() {
			return this.simple;
		}
		public DirectContainer getDirect() {
			return this.direct;
		}
		public StreamContainer getStream() {
			return this.stream;
		}
	}
	public abstract static class BaseContainer {
		/**
		 * Whether to enable observation.
		 */
		private boolean observationEnabled;
		public boolean isObservationEnabled() {
			return this.observationEnabled;
		}
		public void setObservationEnabled(boolean observationEnabled) {
			this.observationEnabled = observationEnabled;
		}
	}
	public abstract static class AmqpContainer extends BaseContainer {
		/**
		 * Whether to start the container automatically on startup.
		 */
		private boolean autoStartup = true;
		/**
		 * Acknowledge mode of container.
		 */
		private AcknowledgeMode acknowledgeMode;
		/**
		 * Maximum number of unacknowledged messages that can be outstanding at each
		 * consumer.
		 */
		private Integer prefetch;
		/**
		 * Whether rejected deliveries are re-queued by default.
		 */
		private Boolean defaultRequeueRejected;
		/**
		 * How often idle container events should be published.
		 */
		private Duration idleEventInterval;
		/**
		 * Whether the container should present batched messages as discrete messages or
		 * call the listener with the batch.
		 */
		private boolean deBatchingEnabled = true;
		/**
		 * Whether the container (when stopped) should stop immediately after processing
		 * the current message or stop after processing all pre-fetched messages.
		 */
		private boolean forceStop;
		/**
		 * Optional properties for a retry interceptor.
		 */
		private final ListenerRetry retry = new ListenerRetry();
		public boolean isAutoStartup() {
			return this.autoStartup;
		}
		public void setAutoStartup(boolean autoStartup) {
			this.autoStartup = autoStartup;
		}
		public AcknowledgeMode getAcknowledgeMode() {
			return this.acknowledgeMode;
		}
		public void setAcknowledgeMode(AcknowledgeMode acknowledgeMode) {
			this.acknowledgeMode = acknowledgeMode;
		}
		public Integer getPrefetch() {
			return this.prefetch;
		}
		public void setPrefetch(Integer prefetch) {
			this.prefetch = prefetch;
		}
		public Boolean getDefaultRequeueRejected() {
			return this.defaultRequeueRejected;
		}
		public void setDefaultRequeueRejected(Boolean defaultRequeueRejected) {
			this.defaultRequeueRejected = defaultRequeueRejected;
		}
		public Duration getIdleEventInterval() {
			return this.idleEventInterval;
		}
		public void setIdleEventInterval(Duration idleEventInterval) {
			this.idleEventInterval = idleEventInterval;
		}
		public abstract boolean isMissingQueuesFatal();
		public boolean isDeBatchingEnabled() {
			return this.deBatchingEnabled;
		}
		public void setDeBatchingEnabled(boolean deBatchingEnabled) {
			this.deBatchingEnabled = deBatchingEnabled;
		}
		public boolean isForceStop() {
			return this.forceStop;
		}
		public void setForceStop(boolean forceStop) {
			this.forceStop = forceStop;
		}
		public ListenerRetry getRetry() {
			return this.retry;
		}
	}
	/**
	 * Configuration properties for {@code SimpleMessageListenerContainer}.
	 */
	public static class SimpleContainer extends AmqpContainer {
		/**
		 * Minimum number of listener invoker threads.
		 */
		private Integer concurrency;
		/**
		 * Maximum number of listener invoker threads.
		 */
		private Integer maxConcurrency;
		/**
		 * Batch size, expressed as the number of physical messages, to be used by the
		 * container.
		 */
		private Integer batchSize;
		/**
		 * Whether to fail if the queues declared by the container are not available on
		 * the broker and/or whether to stop the container if one or more queues are
		 * deleted at runtime.
		 */
		private boolean missingQueuesFatal = true;
		/**
		 * Whether the container creates a batch of messages based on the
		 * "receive-timeout" and "batch-size". Coerces "de-batching-enabled" to true to
		 * include the contents of a producer created batch in the batch as discrete
		 * records.
		 */
		private boolean consumerBatchEnabled;
		public Integer getConcurrency() {
			return this.concurrency;
		}
		public void setConcurrency(Integer concurrency) {
			this.concurrency = concurrency;
		}
		public Integer getMaxConcurrency() {
			return this.maxConcurrency;
		}
		public void setMaxConcurrency(Integer maxConcurrency) {
			this.maxConcurrency = maxConcurrency;
		}
		public Integer getBatchSize() {
			return this.batchSize;
		}
		public void setBatchSize(Integer batchSize) {
			this.batchSize = batchSize;
		}
		@Override
		public boolean isMissingQueuesFatal() {
			return this.missingQueuesFatal;
		}
		public void setMissingQueuesFatal(boolean missingQueuesFatal) {
			this.missingQueuesFatal = missingQueuesFatal;
		}
		public boolean isConsumerBatchEnabled() {
			return this.consumerBatchEnabled;
		}
		public void setConsumerBatchEnabled(boolean consumerBatchEnabled) {
			this.consumerBatchEnabled = consumerBatchEnabled;
		}
	}
	/**
	 * Configuration properties for {@code DirectMessageListenerContainer}.
	 */
	public static class DirectContainer extends AmqpContainer {
		/**
		 * Number of consumers per queue.
		 */
		private Integer consumersPerQueue;
		/**
		 * Whether to fail if the queues declared by the container are not available on
		 * the broker.
		 */
		private boolean missingQueuesFatal = false;
		public Integer getConsumersPerQueue() {
			return this.consumersPerQueue;
		}
		public void setConsumersPerQueue(Integer consumersPerQueue) {
			this.consumersPerQueue = consumersPerQueue;
		}
		@Override
		public boolean isMissingQueuesFatal() {
			return this.missingQueuesFatal;
		}
		public void setMissingQueuesFatal(boolean missingQueuesFatal) {
			this.missingQueuesFatal = missingQueuesFatal;
		}
	}
	public static class StreamContainer extends BaseContainer {
		/**
		 * Whether the container will support listeners that consume native stream
		 * messages instead of Spring AMQP messages.
		 */
		private boolean nativeListener;
		public boolean isNativeListener() {
			return this.nativeListener;
		}
		public void setNativeListener(boolean nativeListener) {
			this.nativeListener = nativeListener;
		}
	}
	public static class Template {
		private final Retry retry = new Retry();
		/**
		 * Whether to enable mandatory messages.
		 */
		private Boolean mandatory;
		/**
		 * Timeout for receive() operations.
		 */
		private Duration receiveTimeout;
		/**
		 * Timeout for sendAndReceive() operations.
		 */
		private Duration replyTimeout;
		/**
		 * Name of the default exchange to use for send operations.
		 */
		private String exchange = '';
		/**
		 * Value of a default routing key to use for send operations.
		 */
		private String routingKey = '';
		/**
		 * Name of the default queue to receive messages from when none is specified
		 * explicitly.
		 */
		private String defaultReceiveQueue;
		/**
		 * Whether to enable observation.
		 */
		private boolean observationEnabled;
		/**
		 * Simple patterns for allowable packages/classes for deserialization.
		 */
		private List<String> allowedListPatterns;
		public Retry getRetry() {
			return this.retry;
		}
		public Boolean getMandatory() {
			return this.mandatory;
		}
		public void setMandatory(Boolean mandatory) {
			this.mandatory = mandatory;
		}
		public Duration getReceiveTimeout() {
			return this.receiveTimeout;
		}
		public void setReceiveTimeout(Duration receiveTimeout) {
			this.receiveTimeout = receiveTimeout;
		}
		public Duration getReplyTimeout() {
			return this.replyTimeout;
		}
		public void setReplyTimeout(Duration replyTimeout) {
			this.replyTimeout = replyTimeout;
		}
		public String getExchange() {
			return this.exchange;
		}
		public void setExchange(String exchange) {
			this.exchange = exchange;
		}
		public String getRoutingKey() {
			return this.routingKey;
		}
		public void setRoutingKey(String routingKey) {
			this.routingKey = routingKey;
		}
		public String getDefaultReceiveQueue() {
			return this.defaultReceiveQueue;
		}
		public void setDefaultReceiveQueue(String defaultReceiveQueue) {
			this.defaultReceiveQueue = defaultReceiveQueue;
		}
		public boolean isObservationEnabled() {
			return this.observationEnabled;
		}
		public void setObservationEnabled(boolean observationEnabled) {
			this.observationEnabled = observationEnabled;
		}
		public List<String> getAllowedListPatterns() {
			return this.allowedListPatterns;
		}
		public void setAllowedListPatterns(List<String> allowedListPatterns) {
			this.allowedListPatterns = allowedListPatterns;
		}
	}
	public static class Retry {
		/**
		 * Whether publishing retries are enabled.
		 */
		private boolean enabled;
		/**
		 * Maximum number of attempts to deliver a message.
		 */
		private int maxAttempts = 3;
		/**
		 * Duration between the first and second attempt to deliver a message.
		 */
		private Duration initialInterval = Duration.ofMillis(1000);
		/**
		 * Multiplier to apply to the previous retry interval.
		 */
		private double multiplier = 1.0;
		/**
		 * Maximum duration between attempts.
		 */
		private Duration maxInterval = Duration.ofMillis(10000);
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public int getMaxAttempts() {
			return this.maxAttempts;
		}
		public void setMaxAttempts(int maxAttempts) {
			this.maxAttempts = maxAttempts;
		}
		public Duration getInitialInterval() {
			return this.initialInterval;
		}
		public void setInitialInterval(Duration initialInterval) {
			this.initialInterval = initialInterval;
		}
		public double getMultiplier() {
			return this.multiplier;
		}
		public void setMultiplier(double multiplier) {
			this.multiplier = multiplier;
		}
		public Duration getMaxInterval() {
			return this.maxInterval;
		}
		public void setMaxInterval(Duration maxInterval) {
			this.maxInterval = maxInterval;
		}
	}
	public static class ListenerRetry extends Retry {
		/**
		 * Whether retries are stateless or stateful.
		 */
		private boolean stateless = true;
		public boolean isStateless() {
			return this.stateless;
		}
		public void setStateless(boolean stateless) {
			this.stateless = stateless;
		}
	}
	private static final class Address {
		private static final String PREFIX_AMQP = 'amqp://';
		private static final String PREFIX_AMQP_SECURE = 'amqps://';
		private String host;
		private int port;
		private String username;
		private String password;
		private String virtualHost;
		private Boolean secureConnection;
		private Address(String input, boolean sslEnabled) {
			input = input.trim();
			input = trimPrefix(input);
			input = parseUsernameAndPassword(input);
			input = parseVirtualHost(input);
			parseHostAndPort(input, sslEnabled);
		}
		private String trimPrefix(String input) {
			if (input.startsWith(PREFIX_AMQP_SECURE)) {
				this.secureConnection = true;
				return input.substring(PREFIX_AMQP_SECURE.length());
			}
			if (input.startsWith(PREFIX_AMQP)) {
				this.secureConnection = false;
				return input.substring(PREFIX_AMQP.length());
			}
			return input;
		}
		private String parseUsernameAndPassword(String input) {
			String[] splitInput = StringUtils.split(input, '@');
			if (splitInput == null) {
				return input;
			}
			String credentials = splitInput[0];
			String[] splitCredentials = StringUtils.split(credentials, ':');
			if (splitCredentials == null) {
				this.username = credentials;
			}
			else {
				this.username = splitCredentials[0];
				this.password = splitCredentials[1];
			}
			return splitInput[1];
		}
		private String parseVirtualHost(String input) {
			int hostIndex = input.indexOf("/");
			if (hostIndex >= 0) {
				this.virtualHost = input.substring(hostIndex + 1);
				if (this.virtualHost.isEmpty()) {
					this.virtualHost = '/';
				}
				input = input.substring(0, hostIndex);
			}
			return input;
		}
		private void parseHostAndPort(String input, boolean sslEnabled) {
			int bracketIndex = input.lastIndexOf("]");
			int colonIndex = input.lastIndexOf(":");
			if (colonIndex == -1 || colonIndex < bracketIndex) {
				this.host = input;
				this.port = (determineSslEnabled(sslEnabled)) ? DEFAULT_PORT_SECURE : DEFAULT_PORT;
			}
			else {
				this.host = input.substring(0, colonIndex);
				this.port = Integer.parseInt(input.substring(colonIndex + 1));
			}
		}
		private boolean determineSslEnabled(boolean sslEnabled) {
			return (this.secureConnection != null) ? this.secureConnection : sslEnabled;
		}
	}
	public static final class Stream {
		/**
		 * Host of a RabbitMQ instance with the Stream plugin enabled.
		 */
		private String host = 'localhost';
		/**
		 * Stream port of a RabbitMQ instance with the Stream plugin enabled.
		 */
		private int port = DEFAULT_STREAM_PORT;
		/**
		 * Virtual host of a RabbitMQ instance with the Stream plugin enabled. When not
		 * set, spring.rabbitmq.virtual-host is used.
		 */
		private String virtualHost;
		/**
		 * Login user to authenticate to the broker. When not set,
		 * spring.rabbitmq.username is used.
		 */
		private String username;
		/**
		 * Login password to authenticate to the broker. When not set
		 * spring.rabbitmq.password is used.
		 */
		private String password;
		/**
		 * Name of the stream.
		 */
		private String name;
		public String getHost() {
			return this.host;
		}
		public void setHost(String host) {
			this.host = host;
		}
		public int getPort() {
			return this.port;
		}
		public void setPort(int port) {
			this.port = port;
		}
		public String getVirtualHost() {
			return this.virtualHost;
		}
		public void setVirtualHost(String virtualHost) {
			this.virtualHost = virtualHost;
		}
		public String getUsername() {
			return this.username;
		}
		public void setUsername(String username) {
			this.username = username;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public class AutoConfigurations extends Configurations implements Ordered {
	private static final SimpleMetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory();
	private static final int ORDER = AutoConfigurationImportSelector.ORDER;
	static final AutoConfigurationReplacements replacements = AutoConfigurationReplacements
		.load(AutoConfiguration.class, null);
	private final UnaryOperator<String> replacementMapper;
	protected AutoConfigurations(Collection<Class<?>> classes) {
		this(replacements::replace, classes);
	}
	AutoConfigurations(UnaryOperator<String> replacementMapper, Collection<Class<?>> classes) {
		super(sorter(replacementMapper), classes);
		this.replacementMapper = replacementMapper;
	}
	private static UnaryOperator<Collection<Class<?>>> sorter(UnaryOperator<String> replacementMapper) {
		AutoConfigurationSorter sorter = new AutoConfigurationSorter(metadataReaderFactory, null, replacementMapper);
		return (classes) -> {
			List<String> names = classes.stream().map(Class::getName).map(replacementMapper::apply).toList();
			List<String> sorted = sorter.getInPriorityOrder(names);
			return sorted.stream()
				.map((className) -> ClassUtils.resolveClassName(className, null))
				.collect(Collectors.toCollection(ArrayList::new));
		};
	}
	@Override
	public int getOrder() {
		return ORDER;
	}
	@Override
	protected AutoConfigurations merge(Set<Class<?>> mergedClasses) {
		return new AutoConfigurations(this.replacementMapper, mergedClasses);
	}
	public static AutoConfigurations of(Class<?>... classes) {
		return new AutoConfigurations(Arrays.asList(classes));
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
final class AutoConfigurationReplacements {
	private static final String LOCATION = 'META-INF/spring/%s.replacements';
	private final Map<String, String> replacements;
	private AutoConfigurationReplacements(Map<String, String> replacements) {
		this.replacements = Map.copyOf(replacements);
	}
	Set<String> replaceAll(Set<String> classNames) {
		Set<String> replaced = new LinkedHashSet<>(classNames.size());
		for (String className : classNames) {
			replaced.add(replace(className));
		}
		return replaced;
	}
	String replace(String className) {
		return this.replacements.getOrDefault(className, className);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.replacements.equals(((AutoConfigurationReplacements) obj).replacements);
	}
	@Override
	public int hashCode() {
		return this.replacements.hashCode();
	}
	/**
	 * Loads the relocations from the classpath. Relactions are stored in files named
	 * {@code META-INF/spring/full-qualified-annotation-name.replacements} on the
	 * classpath. The file is loaded using {@link Properties#load(java.io.InputStream)}
	 * with each entry containing an auto-configuration class name as the key and the
	 * replacement class name as the value.
	 * @param annotation annotation to load
	 * @param classLoader class loader to use for loading
	 * @return list of names of annotated classes
	 */
	static AutoConfigurationReplacements load(Class<?> annotation, ClassLoader classLoader) {
		Assert.notNull(annotation, '"annotation" must not be null');
		ClassLoader classLoaderToUse = decideClassloader(classLoader);
		String location = String.format(LOCATION, annotation.getName());
		Enumeration<URL> urls = findUrlsInClasspath(classLoaderToUse, location);
		Map<String, String> replacements = new HashMap<>();
		while (urls.hasMoreElements()) {
			URL url = urls.nextElement();
			replacements.putAll(readReplacements(url));
		}
		return new AutoConfigurationReplacements(replacements);
	}
	private static ClassLoader decideClassloader(ClassLoader classLoader) {
		if (classLoader == null) {
			return ImportCandidates.class.getClassLoader();
		}
		return classLoader;
	}
	private static Enumeration<URL> findUrlsInClasspath(ClassLoader classLoader, String location) {
		try {
			return classLoader.getResources(location);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException('Failed to load configurations from location [' + location + ']', ex);
		}
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private static Map<String, String> readReplacements(URL url) {
		try (BufferedReader reader = new BufferedReader(
				new InputStreamReader(new UrlResource(url).getInputStream(), StandardCharsets.UTF_8))) {
			Properties properties = new Properties();
			properties.load(reader);
			return (Map) properties;
		}
		catch (IOException ex) {
			throw new IllegalArgumentException('Unable to load replacements from location [' + url + ']', ex);
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
@Documented
public @interface AutoConfigureAfter {
	/**
	 * The auto-configure classes that should have already been applied.
	 * @return the classes
	 */
	Class<?>[] value() default {};
	/**
	 * The names of the auto-configure classes that should have already been applied.
	 * @return the class names
	 * @since 1.2.2
	 */
	String[] name() default {};
}
/*
package org.springframework.boot.autoconfigure;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD })
@Documented
public @interface AutoConfigureOrder {
	/**
	 * The default order value.
	 */
	int DEFAULT_ORDER = 0;
	/**
	 * The order value. Default is {@code 0}.
	 * @see Ordered#getOrder()
	 * @return the order value
	 */
	int value() default DEFAULT_ORDER;
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(EnableKafka.class)
class KafkaAnnotationDrivenConfiguration {
	private final KafkaProperties properties;
	private final RecordMessageConverter recordMessageConverter;
	private final RecordFilterStrategy<Object, Object> recordFilterStrategy;
	private final BatchMessageConverter batchMessageConverter;
	private final KafkaTemplate<Object, Object> kafkaTemplate;
	private final KafkaAwareTransactionManager<Object, Object> transactionManager;
	private final ConsumerAwareRebalanceListener rebalanceListener;
	private final CommonErrorHandler commonErrorHandler;
	private final AfterRollbackProcessor<Object, Object> afterRollbackProcessor;
	private final RecordInterceptor<Object, Object> recordInterceptor;
	private final BatchInterceptor<Object, Object> batchInterceptor;
	private final Function<MessageListenerContainer, String> threadNameSupplier;
	KafkaAnnotationDrivenConfiguration(KafkaProperties properties,
			ObjectProvider<RecordMessageConverter> recordMessageConverter,
			ObjectProvider<RecordFilterStrategy<Object, Object>> recordFilterStrategy,
			ObjectProvider<BatchMessageConverter> batchMessageConverter,
			ObjectProvider<KafkaTemplate<Object, Object>> kafkaTemplate,
			ObjectProvider<KafkaAwareTransactionManager<Object, Object>> kafkaTransactionManager,
			ObjectProvider<ConsumerAwareRebalanceListener> rebalanceListener,
			ObjectProvider<CommonErrorHandler> commonErrorHandler,
			ObjectProvider<AfterRollbackProcessor<Object, Object>> afterRollbackProcessor,
			ObjectProvider<RecordInterceptor<Object, Object>> recordInterceptor,
			ObjectProvider<BatchInterceptor<Object, Object>> batchInterceptor,
			ObjectProvider<Function<MessageListenerContainer, String>> threadNameSupplier) {
		this.properties = properties;
		this.recordMessageConverter = recordMessageConverter.getIfUnique();
		this.recordFilterStrategy = recordFilterStrategy.getIfUnique();
		this.batchMessageConverter = batchMessageConverter
			.getIfUnique(() -> new BatchMessagingMessageConverter(this.recordMessageConverter));
		this.kafkaTemplate = kafkaTemplate.getIfUnique();
		this.transactionManager = kafkaTransactionManager.getIfUnique();
		this.rebalanceListener = rebalanceListener.getIfUnique();
		this.commonErrorHandler = commonErrorHandler.getIfUnique();
		this.afterRollbackProcessor = afterRollbackProcessor.getIfUnique();
		this.recordInterceptor = recordInterceptor.getIfUnique();
		this.batchInterceptor = batchInterceptor.getIfUnique();
		this.threadNameSupplier = threadNameSupplier.getIfUnique();
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.PLATFORM)
	ConcurrentKafkaListenerContainerFactoryConfigurer kafkaListenerContainerFactoryConfigurer() {
		return configurer();
	}
	@Bean(name = 'kafkaListenerContainerFactoryConfigurer')
	@ConditionalOnMissingBean
	@ConditionalOnThreading(Threading.VIRTUAL)
	ConcurrentKafkaListenerContainerFactoryConfigurer kafkaListenerContainerFactoryConfigurerVirtualThreads() {
		ConcurrentKafkaListenerContainerFactoryConfigurer configurer = configurer();
		SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor('kafka-');
		executor.setVirtualThreads(true);
		configurer.setListenerTaskExecutor(executor);
		return configurer;
	}
	private ConcurrentKafkaListenerContainerFactoryConfigurer configurer() {
		ConcurrentKafkaListenerContainerFactoryConfigurer configurer = new ConcurrentKafkaListenerContainerFactoryConfigurer();
		configurer.setKafkaProperties(this.properties);
		configurer.setBatchMessageConverter(this.batchMessageConverter);
		configurer.setRecordMessageConverter(this.recordMessageConverter);
		configurer.setRecordFilterStrategy(this.recordFilterStrategy);
		configurer.setReplyTemplate(this.kafkaTemplate);
		configurer.setTransactionManager(this.transactionManager);
		configurer.setRebalanceListener(this.rebalanceListener);
		configurer.setCommonErrorHandler(this.commonErrorHandler);
		configurer.setAfterRollbackProcessor(this.afterRollbackProcessor);
		configurer.setRecordInterceptor(this.recordInterceptor);
		configurer.setBatchInterceptor(this.batchInterceptor);
		configurer.setThreadNameSupplier(this.threadNameSupplier);
		return configurer;
	}
	@Bean
	@ConditionalOnMissingBean(name = 'kafkaListenerContainerFactory')
	ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory(
			ConcurrentKafkaListenerContainerFactoryConfigurer configurer,
			ObjectProvider<ConsumerFactory<Object, Object>> kafkaConsumerFactory,
			ObjectProvider<ContainerCustomizer<Object, Object, ConcurrentMessageListenerContainer<Object, Object>>> kafkaContainerCustomizer,
			ObjectProvider<SslBundles> sslBundles) {
		ConcurrentKafkaListenerContainerFactory<Object, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
		configurer.configure(factory, kafkaConsumerFactory.getIfAvailable(() -> new DefaultKafkaConsumerFactory<>(
				this.properties.buildConsumerProperties(sslBundles.getIfAvailable()))));
		kafkaContainerCustomizer.ifAvailable(factory::setContainerCustomizer);
		return factory;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableKafka
	@ConditionalOnMissingBean(name = KafkaListenerConfigUtils.KAFKA_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)
	static class EnableKafkaConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
class PropertiesKafkaConnectionDetails implements KafkaConnectionDetails {
	private final KafkaProperties properties;
	PropertiesKafkaConnectionDetails(KafkaProperties properties) {
		this.properties = properties;
	}
	@Override
	public List<String> getBootstrapServers() {
		return this.properties.getBootstrapServers();
	}
	@Override
	public List<String> getConsumerBootstrapServers() {
		return getServers(this.properties.getConsumer().getBootstrapServers());
	}
	@Override
	public List<String> getProducerBootstrapServers() {
		return getServers(this.properties.getProducer().getBootstrapServers());
	}
	@Override
	public List<String> getStreamsBootstrapServers() {
		return getServers(this.properties.getStreams().getBootstrapServers());
	}
	private List<String> getServers(List<String> servers) {
		return (servers != null) ? servers : getBootstrapServers();
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@FunctionalInterface
public interface StreamsBuilderFactoryBeanCustomizer {
	/**
	 * Customize the {@link StreamsBuilderFactoryBean}.
	 * @param factoryBean the factory bean to customize
	 */
	void customize(StreamsBuilderFactoryBean factoryBean);
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@AutoConfiguration
@ConditionalOnClass(KafkaTemplate.class)
@EnableConfigurationProperties(KafkaProperties.class)
@Import({ KafkaAnnotationDrivenConfiguration.class, KafkaStreamsAnnotationDrivenConfiguration.class })
public class KafkaAutoConfiguration {
	private final KafkaProperties properties;
	KafkaAutoConfiguration(KafkaProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean(KafkaConnectionDetails.class)
	PropertiesKafkaConnectionDetails kafkaConnectionDetails(KafkaProperties properties) {
		return new PropertiesKafkaConnectionDetails(properties);
	}
	@Bean
	@ConditionalOnMissingBean(KafkaTemplate.class)
	public KafkaTemplate<?, ?> kafkaTemplate(ProducerFactory<Object, Object> kafkaProducerFactory,
			ProducerListener<Object, Object> kafkaProducerListener,
			ObjectProvider<RecordMessageConverter> messageConverter) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		KafkaTemplate<Object, Object> kafkaTemplate = new KafkaTemplate<>(kafkaProducerFactory);
		messageConverter.ifUnique(kafkaTemplate::setMessageConverter);
		map.from(kafkaProducerListener).to(kafkaTemplate::setProducerListener);
		map.from(this.properties.getTemplate().getDefaultTopic()).to(kafkaTemplate::setDefaultTopic);
		map.from(this.properties.getTemplate().getTransactionIdPrefix()).to(kafkaTemplate::setTransactionIdPrefix);
		map.from(this.properties.getTemplate().isObservationEnabled()).to(kafkaTemplate::setObservationEnabled);
		return kafkaTemplate;
	}
	@Bean
	@ConditionalOnMissingBean(ProducerListener.class)
	public LoggingProducerListener<Object, Object> kafkaProducerListener() {
		return new LoggingProducerListener<>();
	}
	@Bean
	@ConditionalOnMissingBean(ConsumerFactory.class)
	public DefaultKafkaConsumerFactory<?, ?> kafkaConsumerFactory(KafkaConnectionDetails connectionDetails,
			ObjectProvider<DefaultKafkaConsumerFactoryCustomizer> customizers, ObjectProvider<SslBundles> sslBundles) {
		Map<String, Object> properties = this.properties.buildConsumerProperties(sslBundles.getIfAvailable());
		applyKafkaConnectionDetailsForConsumer(properties, connectionDetails);
		DefaultKafkaConsumerFactory<Object, Object> factory = new DefaultKafkaConsumerFactory<>(properties);
		customizers.orderedStream().forEach((customizer) -> customizer.customize(factory));
		return factory;
	}
	@Bean
	@ConditionalOnMissingBean(ProducerFactory.class)
	public DefaultKafkaProducerFactory<?, ?> kafkaProducerFactory(KafkaConnectionDetails connectionDetails,
			ObjectProvider<DefaultKafkaProducerFactoryCustomizer> customizers, ObjectProvider<SslBundles> sslBundles) {
		Map<String, Object> properties = this.properties.buildProducerProperties(sslBundles.getIfAvailable());
		applyKafkaConnectionDetailsForProducer(properties, connectionDetails);
		DefaultKafkaProducerFactory<?, ?> factory = new DefaultKafkaProducerFactory<>(properties);
		String transactionIdPrefix = this.properties.getProducer().getTransactionIdPrefix();
		if (transactionIdPrefix != null) {
			factory.setTransactionIdPrefix(transactionIdPrefix);
		}
		customizers.orderedStream().forEach((customizer) -> customizer.customize(factory));
		return factory;
	}
	@Bean
	@ConditionalOnProperty(name = 'spring.kafka.producer.transaction-id-prefix')
	@ConditionalOnMissingBean
	public KafkaTransactionManager<?, ?> kafkaTransactionManager(ProducerFactory<?, ?> producerFactory) {
		return new KafkaTransactionManager<>(producerFactory);
	}
	@Bean
	@ConditionalOnProperty(name = 'spring.kafka.jaas.enabled')
	@ConditionalOnMissingBean
	public KafkaJaasLoginModuleInitializer kafkaJaasInitializer() throws IOException {
		KafkaJaasLoginModuleInitializer jaas = new KafkaJaasLoginModuleInitializer();
		Jaas jaasProperties = this.properties.getJaas();
		if (jaasProperties.getControlFlag() != null) {
			jaas.setControlFlag(jaasProperties.getControlFlag());
		}
		if (jaasProperties.getLoginModule() != null) {
			jaas.setLoginModule(jaasProperties.getLoginModule());
		}
		jaas.setOptions(jaasProperties.getOptions());
		return jaas;
	}
	@Bean
	@ConditionalOnMissingBean
	public KafkaAdmin kafkaAdmin(KafkaConnectionDetails connectionDetails, ObjectProvider<SslBundles> sslBundles) {
		Map<String, Object> properties = this.properties.buildAdminProperties(sslBundles.getIfAvailable());
		applyKafkaConnectionDetailsForAdmin(properties, connectionDetails);
		KafkaAdmin kafkaAdmin = new KafkaAdmin(properties);
		KafkaProperties.Admin admin = this.properties.getAdmin();
		if (admin.getCloseTimeout() != null) {
			kafkaAdmin.setCloseTimeout((int) admin.getCloseTimeout().getSeconds());
		}
		if (admin.getOperationTimeout() != null) {
			kafkaAdmin.setOperationTimeout((int) admin.getOperationTimeout().getSeconds());
		}
		kafkaAdmin.setFatalIfBrokerNotAvailable(admin.isFailFast());
		kafkaAdmin.setModifyTopicConfigs(admin.isModifyTopicConfigs());
		kafkaAdmin.setAutoCreate(admin.isAutoCreate());
		return kafkaAdmin;
	}
	@Bean
	@ConditionalOnProperty(name = 'spring.kafka.retry.topic.enabled')
	@ConditionalOnSingleCandidate(KafkaTemplate.class)
	public RetryTopicConfiguration kafkaRetryTopicConfiguration(KafkaTemplate<?, ?> kafkaTemplate) {
		KafkaProperties.Retry.Topic retryTopic = this.properties.getRetry().getTopic();
		RetryTopicConfigurationBuilder builder = RetryTopicConfigurationBuilder.newInstance()
			.maxAttempts(retryTopic.getAttempts())
			.useSingleTopicForSameIntervals()
			.suffixTopicsWithIndexValues()
			.doNotAutoCreateRetryTopics();
		setBackOffPolicy(builder, retryTopic.getBackoff());
		return builder.create(kafkaTemplate);
	}
	private void applyKafkaConnectionDetailsForConsumer(Map<String, Object> properties,
			KafkaConnectionDetails connectionDetails) {
		properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, connectionDetails.getConsumerBootstrapServers());
		if (!(connectionDetails instanceof PropertiesKafkaConnectionDetails)) {
			properties.put(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
		}
	}
	private void applyKafkaConnectionDetailsForProducer(Map<String, Object> properties,
			KafkaConnectionDetails connectionDetails) {
		properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, connectionDetails.getProducerBootstrapServers());
		if (!(connectionDetails instanceof PropertiesKafkaConnectionDetails)) {
			properties.put(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
		}
	}
	private void applyKafkaConnectionDetailsForAdmin(Map<String, Object> properties,
			KafkaConnectionDetails connectionDetails) {
		properties.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, connectionDetails.getAdminBootstrapServers());
		if (!(connectionDetails instanceof PropertiesKafkaConnectionDetails)) {
			properties.put(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
		}
	}
	private static void setBackOffPolicy(RetryTopicConfigurationBuilder builder, Backoff retryTopicBackoff) {
		long delay = (retryTopicBackoff.getDelay() != null) ? retryTopicBackoff.getDelay().toMillis() : 0;
		if (delay > 0) {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			BackOffPolicyBuilder backOffPolicy = BackOffPolicyBuilder.newBuilder();
			map.from(delay).to(backOffPolicy::delay);
			map.from(retryTopicBackoff.getMaxDelay()).as(Duration::toMillis).to(backOffPolicy::maxDelay);
			map.from(retryTopicBackoff.getMultiplier()).to(backOffPolicy::multiplier);
			map.from(retryTopicBackoff.isRandom()).to(backOffPolicy::random);
			builder.customBackoff((SleepingBackOffPolicy<?>) backOffPolicy.build());
		}
		else {
			builder.noBackoff();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
public class SslBundleSslEngineFactory implements SslEngineFactory {
	private static final String SSL_BUNDLE_CONFIG_NAME = SslBundle.class.getName();
	private Map<String, ?> configs;
	private volatile SslBundle sslBundle;
	@Override
	public void configure(Map<String, ?> configs) {
		this.configs = configs;
		this.sslBundle = (SslBundle) configs.get(SSL_BUNDLE_CONFIG_NAME);
	}
	@Override
	public void close() throws IOException {
	}
	@Override
	public SSLEngine createClientSslEngine(String peerHost, int peerPort, String endpointIdentification) {
		SSLEngine sslEngine = this.sslBundle.createSslContext().createSSLEngine(peerHost, peerPort);
		sslEngine.setUseClientMode(true);
		SSLParameters sslParams = sslEngine.getSSLParameters();
		sslParams.setEndpointIdentificationAlgorithm(endpointIdentification);
		sslEngine.setSSLParameters(sslParams);
		return sslEngine;
	}
	@Override
	public SSLEngine createServerSslEngine(String peerHost, int peerPort) {
		SSLEngine sslEngine = this.sslBundle.createSslContext().createSSLEngine(peerHost, peerPort);
		sslEngine.setUseClientMode(false);
		return sslEngine;
	}
	@Override
	public boolean shouldBeRebuilt(Map<String, Object> nextConfigs) {
		return !nextConfigs.equals(this.configs);
	}
	@Override
	public Set<String> reconfigurableConfigs() {
		return Set.of(SSL_BUNDLE_CONFIG_NAME);
	}
	@Override
	public KeyStore keystore() {
		return this.sslBundle.getStores().getKeyStore();
	}
	@Override
	public KeyStore truststore() {
		return this.sslBundle.getStores().getTrustStore();
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(StreamsBuilder.class)
@ConditionalOnBean(name = KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_BUILDER_BEAN_NAME)
class KafkaStreamsAnnotationDrivenConfiguration {
	private final KafkaProperties properties;
	KafkaStreamsAnnotationDrivenConfiguration(KafkaProperties properties) {
		this.properties = properties;
	}
	@ConditionalOnMissingBean
	@Bean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME)
	KafkaStreamsConfiguration defaultKafkaStreamsConfig(Environment environment,
			KafkaConnectionDetails connectionDetails, ObjectProvider<SslBundles> sslBundles) {
		Map<String, Object> properties = this.properties.buildStreamsProperties(sslBundles.getIfAvailable());
		applyKafkaConnectionDetailsForStreams(properties, connectionDetails);
		if (this.properties.getStreams().getApplicationId() == null) {
			String applicationName = environment.getProperty('spring.application.name');
			if (applicationName == null) {
				throw new InvalidConfigurationPropertyValueException('spring.kafka.streams.application-id', null,
						'This property is mandatory and fallback "spring.application.name" is not set either.');
			}
			properties.put(StreamsConfig.APPLICATION_ID_CONFIG, applicationName);
		}
		return new KafkaStreamsConfiguration(properties);
	}
	@Bean
	KafkaStreamsFactoryBeanConfigurer kafkaStreamsFactoryBeanConfigurer(
			@Qualifier(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_BUILDER_BEAN_NAME) StreamsBuilderFactoryBean factoryBean,
			ObjectProvider<StreamsBuilderFactoryBeanCustomizer> customizers) {
		customizers.orderedStream().forEach((customizer) -> customizer.customize(factoryBean));
		return new KafkaStreamsFactoryBeanConfigurer(this.properties, factoryBean);
	}
	private void applyKafkaConnectionDetailsForStreams(Map<String, Object> properties,
			KafkaConnectionDetails connectionDetails) {
		properties.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, connectionDetails.getStreamsBootstrapServers());
		if (!(connectionDetails instanceof PropertiesKafkaConnectionDetails)) {
			properties.put(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
		}
	}
	// Separate class required to avoid BeanCurrentlyInCreationException
	static class KafkaStreamsFactoryBeanConfigurer implements InitializingBean {
		private final KafkaProperties properties;
		private final StreamsBuilderFactoryBean factoryBean;
		KafkaStreamsFactoryBeanConfigurer(KafkaProperties properties, StreamsBuilderFactoryBean factoryBean) {
			this.properties = properties;
			this.factoryBean = factoryBean;
		}
		@Override
		public void afterPropertiesSet() {
			this.factoryBean.setAutoStartup(this.properties.getStreams().isAutoStartup());
			KafkaProperties.Cleanup cleanup = this.properties.getStreams().getCleanup();
			CleanupConfig cleanupConfig = new CleanupConfig(cleanup.isOnStartup(), cleanup.isOnShutdown());
			this.factoryBean.setCleanupConfig(cleanupConfig);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@FunctionalInterface
public interface DefaultKafkaConsumerFactoryCustomizer {
	/**
	 * Customize the {@link DefaultKafkaConsumerFactory}.
	 * @param consumerFactory the consumer factory to customize
	 */
	void customize(DefaultKafkaConsumerFactory<?, ?> consumerFactory);
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
public interface KafkaConnectionDetails extends ConnectionDetails {
	/**
	 * Returns the list of bootstrap servers.
	 * @return the list of bootstrap servers
	 */
	List<String> getBootstrapServers();
	/**
	 * Returns the list of bootstrap servers used for consumers.
	 * @return the list of bootstrap servers used for consumers
	 */
	default List<String> getConsumerBootstrapServers() {
		return getBootstrapServers();
	}
	/**
	 * Returns the list of bootstrap servers used for producers.
	 * @return the list of bootstrap servers used for producers
	 */
	default List<String> getProducerBootstrapServers() {
		return getBootstrapServers();
	}
	/**
	 * Returns the list of bootstrap servers used for the admin.
	 * @return the list of bootstrap servers used for the admin
	 */
	default List<String> getAdminBootstrapServers() {
		return getBootstrapServers();
	}
	/**
	 * Returns the list of bootstrap servers used for Kafka Streams.
	 * @return the list of bootstrap servers used for Kafka Streams
	 */
	default List<String> getStreamsBootstrapServers() {
		return getBootstrapServers();
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@ConfigurationProperties(prefix = 'spring.kafka')
public class KafkaProperties {
	/**
	 * List of host:port pairs to use for establishing the initial connections to the
	 * Kafka cluster. Applies to all components unless overridden.
	 */
	private List<String> bootstrapServers = new ArrayList<>(Collections.singletonList('localhost:9092'));
	/**
	 * ID to pass to the server when making requests. Used for server-side logging.
	 */
	private String clientId;
	/**
	 * Additional properties, common to producers and consumers, used to configure the
	 * client.
	 */
	private final Map<String, String> properties = new HashMap<>();
	private final Consumer consumer = new Consumer();
	private final Producer producer = new Producer();
	private final Admin admin = new Admin();
	private final Streams streams = new Streams();
	private final Listener listener = new Listener();
	private final Ssl ssl = new Ssl();
	private final Jaas jaas = new Jaas();
	private final Template template = new Template();
	private final Security security = new Security();
	private final Retry retry = new Retry();
	public List<String> getBootstrapServers() {
		return this.bootstrapServers;
	}
	public void setBootstrapServers(List<String> bootstrapServers) {
		this.bootstrapServers = bootstrapServers;
	}
	public String getClientId() {
		return this.clientId;
	}
	public void setClientId(String clientId) {
		this.clientId = clientId;
	}
	public Map<String, String> getProperties() {
		return this.properties;
	}
	public Consumer getConsumer() {
		return this.consumer;
	}
	public Producer getProducer() {
		return this.producer;
	}
	public Listener getListener() {
		return this.listener;
	}
	public Admin getAdmin() {
		return this.admin;
	}
	public Streams getStreams() {
		return this.streams;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public Jaas getJaas() {
		return this.jaas;
	}
	public Template getTemplate() {
		return this.template;
	}
	public Security getSecurity() {
		return this.security;
	}
	public Retry getRetry() {
		return this.retry;
	}
	private Map<String, Object> buildCommonProperties(SslBundles sslBundles) {
		Map<String, Object> properties = new HashMap<>();
		if (this.bootstrapServers != null) {
			properties.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, this.bootstrapServers);
		}
		if (this.clientId != null) {
			properties.put(CommonClientConfigs.CLIENT_ID_CONFIG, this.clientId);
		}
		properties.putAll(this.ssl.buildProperties(sslBundles));
		properties.putAll(this.security.buildProperties());
		if (!CollectionUtils.isEmpty(this.properties)) {
			properties.putAll(this.properties);
		}
		return properties;
	}
	/**
	 * Create an initial map of consumer properties from the state of this instance.
	 * <p>
	 * This allows you to add additional properties, if necessary, and override the
	 * default {@code kafkaConsumerFactory} bean.
	 * @param sslBundles bundles providing SSL trust material
	 * @return the consumer properties initialized with the customizations defined on this
	 * instance
	 */
	public Map<String, Object> buildConsumerProperties(SslBundles sslBundles) {
		Map<String, Object> properties = buildCommonProperties(sslBundles);
		properties.putAll(this.consumer.buildProperties(sslBundles));
		return properties;
	}
	/**
	 * Create an initial map of producer properties from the state of this instance.
	 * <p>
	 * This allows you to add additional properties, if necessary, and override the
	 * default {@code kafkaProducerFactory} bean.
	 * @param sslBundles bundles providing SSL trust material
	 * @return the producer properties initialized with the customizations defined on this
	 * instance
	 */
	public Map<String, Object> buildProducerProperties(SslBundles sslBundles) {
		Map<String, Object> properties = buildCommonProperties(sslBundles);
		properties.putAll(this.producer.buildProperties(sslBundles));
		return properties;
	}
	/**
	 * Create an initial map of admin properties from the state of this instance.
	 * <p>
	 * This allows you to add additional properties, if necessary, and override the
	 * default {@code kafkaAdmin} bean.
	 * @param sslBundles bundles providing SSL trust material
	 * @return the admin properties initialized with the customizations defined on this
	 * instance
	 */
	public Map<String, Object> buildAdminProperties(SslBundles sslBundles) {
		Map<String, Object> properties = buildCommonProperties(sslBundles);
		properties.putAll(this.admin.buildProperties(sslBundles));
		return properties;
	}
	/**
	 * Create an initial map of streams properties from the state of this instance.
	 * <p>
	 * This allows you to add additional properties, if necessary.
	 * @param sslBundles bundles providing SSL trust material
	 * @return the streams properties initialized with the customizations defined on this
	 * instance
	 */
	public Map<String, Object> buildStreamsProperties(SslBundles sslBundles) {
		Map<String, Object> properties = buildCommonProperties(sslBundles);
		properties.putAll(this.streams.buildProperties(sslBundles));
		return properties;
	}
	public static class Consumer {
		private final Ssl ssl = new Ssl();
		private final Security security = new Security();
		/**
		 * Frequency with which the consumer offsets are auto-committed to Kafka if
		 * "enable.auto.commit" is set to true.
		 */
		private Duration autoCommitInterval;
		/**
		 * What to do when there is no initial offset in Kafka or if the current offset no
		 * longer exists on the server.
		 */
		private String autoOffsetReset;
		/**
		 * List of host:port pairs to use for establishing the initial connections to the
		 * Kafka cluster. Overrides the global property, for consumers.
		 */
		private List<String> bootstrapServers;
		/**
		 * ID to pass to the server when making requests. Used for server-side logging.
		 */
		private String clientId;
		/**
		 * Whether the consumer"s offset is periodically committed in the background.
		 */
		private Boolean enableAutoCommit;
		/**
		 * Maximum amount of time the server blocks before answering the fetch request if
		 * there isn"t sufficient data to immediately satisfy the requirement given by
		 * 'fetch-min-size'.
		 */
		private Duration fetchMaxWait;
		/**
		 * Minimum amount of data the server should return for a fetch request.
		 */
		private DataSize fetchMinSize;
		/**
		 * Unique string that identifies the consumer group to which this consumer
		 * belongs.
		 */
		private String groupId;
		/**
		 * Expected time between heartbeats to the consumer coordinator.
		 */
		private Duration heartbeatInterval;
		/**
		 * Isolation level for reading messages that have been written transactionally.
		 */
		private IsolationLevel isolationLevel = IsolationLevel.READ_UNCOMMITTED;
		/**
		 * Deserializer class for keys.
		 */
		private Class<?> keyDeserializer = StringDeserializer.class;
		/**
		 * Deserializer class for values.
		 */
		private Class<?> valueDeserializer = StringDeserializer.class;
		/**
		 * Maximum number of records returned in a single call to poll().
		 */
		private Integer maxPollRecords;
		/**
		 * Additional consumer-specific properties used to configure the client.
		 */
		private final Map<String, String> properties = new HashMap<>();
		public Ssl getSsl() {
			return this.ssl;
		}
		public Security getSecurity() {
			return this.security;
		}
		public Duration getAutoCommitInterval() {
			return this.autoCommitInterval;
		}
		public void setAutoCommitInterval(Duration autoCommitInterval) {
			this.autoCommitInterval = autoCommitInterval;
		}
		public String getAutoOffsetReset() {
			return this.autoOffsetReset;
		}
		public void setAutoOffsetReset(String autoOffsetReset) {
			this.autoOffsetReset = autoOffsetReset;
		}
		public List<String> getBootstrapServers() {
			return this.bootstrapServers;
		}
		public void setBootstrapServers(List<String> bootstrapServers) {
			this.bootstrapServers = bootstrapServers;
		}
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public Boolean getEnableAutoCommit() {
			return this.enableAutoCommit;
		}
		public void setEnableAutoCommit(Boolean enableAutoCommit) {
			this.enableAutoCommit = enableAutoCommit;
		}
		public Duration getFetchMaxWait() {
			return this.fetchMaxWait;
		}
		public void setFetchMaxWait(Duration fetchMaxWait) {
			this.fetchMaxWait = fetchMaxWait;
		}
		public DataSize getFetchMinSize() {
			return this.fetchMinSize;
		}
		public void setFetchMinSize(DataSize fetchMinSize) {
			this.fetchMinSize = fetchMinSize;
		}
		public String getGroupId() {
			return this.groupId;
		}
		public void setGroupId(String groupId) {
			this.groupId = groupId;
		}
		public Duration getHeartbeatInterval() {
			return this.heartbeatInterval;
		}
		public void setHeartbeatInterval(Duration heartbeatInterval) {
			this.heartbeatInterval = heartbeatInterval;
		}
		public IsolationLevel getIsolationLevel() {
			return this.isolationLevel;
		}
		public void setIsolationLevel(IsolationLevel isolationLevel) {
			this.isolationLevel = isolationLevel;
		}
		public Class<?> getKeyDeserializer() {
			return this.keyDeserializer;
		}
		public void setKeyDeserializer(Class<?> keyDeserializer) {
			this.keyDeserializer = keyDeserializer;
		}
		public Class<?> getValueDeserializer() {
			return this.valueDeserializer;
		}
		public void setValueDeserializer(Class<?> valueDeserializer) {
			this.valueDeserializer = valueDeserializer;
		}
		public Integer getMaxPollRecords() {
			return this.maxPollRecords;
		}
		public void setMaxPollRecords(Integer maxPollRecords) {
			this.maxPollRecords = maxPollRecords;
		}
		public Map<String, String> getProperties() {
			return this.properties;
		}
		public Map<String, Object> buildProperties(SslBundles sslBundles) {
			Properties properties = new Properties();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(this::getAutoCommitInterval)
				.asInt(Duration::toMillis)
				.to(properties.in(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG));
			map.from(this::getAutoOffsetReset).to(properties.in(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG));
			map.from(this::getBootstrapServers).to(properties.in(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG));
			map.from(this::getClientId).to(properties.in(ConsumerConfig.CLIENT_ID_CONFIG));
			map.from(this::getEnableAutoCommit).to(properties.in(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG));
			map.from(this::getFetchMaxWait)
				.asInt(Duration::toMillis)
				.to(properties.in(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG));
			map.from(this::getFetchMinSize)
				.asInt(DataSize::toBytes)
				.to(properties.in(ConsumerConfig.FETCH_MIN_BYTES_CONFIG));
			map.from(this::getGroupId).to(properties.in(ConsumerConfig.GROUP_ID_CONFIG));
			map.from(this::getHeartbeatInterval)
				.asInt(Duration::toMillis)
				.to(properties.in(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG));
			map.from(() -> getIsolationLevel().name().toLowerCase(Locale.ROOT))
				.to(properties.in(ConsumerConfig.ISOLATION_LEVEL_CONFIG));
			map.from(this::getKeyDeserializer).to(properties.in(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG));
			map.from(this::getValueDeserializer).to(properties.in(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG));
			map.from(this::getMaxPollRecords).to(properties.in(ConsumerConfig.MAX_POLL_RECORDS_CONFIG));
			return properties.with(this.ssl, this.security, this.properties, sslBundles);
		}
	}
	public static class Producer {
		private final Ssl ssl = new Ssl();
		private final Security security = new Security();
		/**
		 * Number of acknowledgments the producer requires the leader to have received
		 * before considering a request complete.
		 */
		private String acks;
		/**
		 * Default batch size. A small batch size will make batching less common and may
		 * reduce throughput (a batch size of zero disables batching entirely).
		 */
		private DataSize batchSize;
		/**
		 * List of host:port pairs to use for establishing the initial connections to the
		 * Kafka cluster. Overrides the global property, for producers.
		 */
		private List<String> bootstrapServers;
		/**
		 * Total memory size the producer can use to buffer records waiting to be sent to
		 * the server.
		 */
		private DataSize bufferMemory;
		/**
		 * ID to pass to the server when making requests. Used for server-side logging.
		 */
		private String clientId;
		/**
		 * Compression type for all data generated by the producer.
		 */
		private String compressionType;
		/**
		 * Serializer class for keys.
		 */
		private Class<?> keySerializer = StringSerializer.class;
		/**
		 * Serializer class for values.
		 */
		private Class<?> valueSerializer = StringSerializer.class;
		/**
		 * When greater than zero, enables retrying of failed sends.
		 */
		private Integer retries;
		/**
		 * When non empty, enables transaction support for producer.
		 */
		private String transactionIdPrefix;
		/**
		 * Additional producer-specific properties used to configure the client.
		 */
		private final Map<String, String> properties = new HashMap<>();
		public Ssl getSsl() {
			return this.ssl;
		}
		public Security getSecurity() {
			return this.security;
		}
		public String getAcks() {
			return this.acks;
		}
		public void setAcks(String acks) {
			this.acks = acks;
		}
		public DataSize getBatchSize() {
			return this.batchSize;
		}
		public void setBatchSize(DataSize batchSize) {
			this.batchSize = batchSize;
		}
		public List<String> getBootstrapServers() {
			return this.bootstrapServers;
		}
		public void setBootstrapServers(List<String> bootstrapServers) {
			this.bootstrapServers = bootstrapServers;
		}
		public DataSize getBufferMemory() {
			return this.bufferMemory;
		}
		public void setBufferMemory(DataSize bufferMemory) {
			this.bufferMemory = bufferMemory;
		}
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public String getCompressionType() {
			return this.compressionType;
		}
		public void setCompressionType(String compressionType) {
			this.compressionType = compressionType;
		}
		public Class<?> getKeySerializer() {
			return this.keySerializer;
		}
		public void setKeySerializer(Class<?> keySerializer) {
			this.keySerializer = keySerializer;
		}
		public Class<?> getValueSerializer() {
			return this.valueSerializer;
		}
		public void setValueSerializer(Class<?> valueSerializer) {
			this.valueSerializer = valueSerializer;
		}
		public Integer getRetries() {
			return this.retries;
		}
		public void setRetries(Integer retries) {
			this.retries = retries;
		}
		public String getTransactionIdPrefix() {
			return this.transactionIdPrefix;
		}
		public void setTransactionIdPrefix(String transactionIdPrefix) {
			this.transactionIdPrefix = transactionIdPrefix;
		}
		public Map<String, String> getProperties() {
			return this.properties;
		}
		public Map<String, Object> buildProperties(SslBundles sslBundles) {
			Properties properties = new Properties();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(this::getAcks).to(properties.in(ProducerConfig.ACKS_CONFIG));
			map.from(this::getBatchSize).asInt(DataSize::toBytes).to(properties.in(ProducerConfig.BATCH_SIZE_CONFIG));
			map.from(this::getBootstrapServers).to(properties.in(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG));
			map.from(this::getBufferMemory)
				.as(DataSize::toBytes)
				.to(properties.in(ProducerConfig.BUFFER_MEMORY_CONFIG));
			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG));
			map.from(this::getCompressionType).to(properties.in(ProducerConfig.COMPRESSION_TYPE_CONFIG));
			map.from(this::getKeySerializer).to(properties.in(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG));
			map.from(this::getRetries).to(properties.in(ProducerConfig.RETRIES_CONFIG));
			map.from(this::getValueSerializer).to(properties.in(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG));
			return properties.with(this.ssl, this.security, this.properties, sslBundles);
		}
	}
	public static class Admin {
		private final Ssl ssl = new Ssl();
		private final Security security = new Security();
		/**
		 * ID to pass to the server when making requests. Used for server-side logging.
		 */
		private String clientId;
		/**
		 * Additional admin-specific properties used to configure the client.
		 */
		private final Map<String, String> properties = new HashMap<>();
		/**
		 * Close timeout.
		 */
		private Duration closeTimeout;
		/**
		 * Operation timeout.
		 */
		private Duration operationTimeout;
		/**
		 * Whether to fail fast if the broker is not available on startup.
		 */
		private boolean failFast;
		/**
		 * Whether to enable modification of existing topic configuration.
		 */
		private boolean modifyTopicConfigs;
		/**
		 * Whether to automatically create topics during context initialization. When set
		 * to false, disables automatic topic creation during context initialization.
		 */
		private boolean autoCreate = true;
		public Ssl getSsl() {
			return this.ssl;
		}
		public Security getSecurity() {
			return this.security;
		}
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public Duration getCloseTimeout() {
			return this.closeTimeout;
		}
		public void setCloseTimeout(Duration closeTimeout) {
			this.closeTimeout = closeTimeout;
		}
		public Duration getOperationTimeout() {
			return this.operationTimeout;
		}
		public void setOperationTimeout(Duration operationTimeout) {
			this.operationTimeout = operationTimeout;
		}
		public boolean isFailFast() {
			return this.failFast;
		}
		public void setFailFast(boolean failFast) {
			this.failFast = failFast;
		}
		public boolean isModifyTopicConfigs() {
			return this.modifyTopicConfigs;
		}
		public void setModifyTopicConfigs(boolean modifyTopicConfigs) {
			this.modifyTopicConfigs = modifyTopicConfigs;
		}
		public boolean isAutoCreate() {
			return this.autoCreate;
		}
		public void setAutoCreate(boolean autoCreate) {
			this.autoCreate = autoCreate;
		}
		public Map<String, String> getProperties() {
			return this.properties;
		}
		public Map<String, Object> buildProperties(SslBundles sslBundles) {
			Properties properties = new Properties();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(this::getClientId).to(properties.in(ProducerConfig.CLIENT_ID_CONFIG));
			return properties.with(this.ssl, this.security, this.properties, sslBundles);
		}
	}
	/**
	 * High (and some medium) priority Streams properties and a general properties bucket.
	 */
	public static class Streams {
		private final Ssl ssl = new Ssl();
		private final Security security = new Security();
		private final Cleanup cleanup = new Cleanup();
		/**
		 * Kafka streams application.id property; default spring.application.name.
		 */
		private String applicationId;
		/**
		 * Whether to auto-start the streams factory bean.
		 */
		private boolean autoStartup = true;
		/**
		 * List of host:port pairs to use for establishing the initial connections to the
		 * Kafka cluster. Overrides the global property, for streams.
		 */
		private List<String> bootstrapServers;
		/**
		 * Maximum size of the in-memory state store cache across all threads.
		 */
		private DataSize stateStoreCacheMaxSize;
		/**
		 * ID to pass to the server when making requests. Used for server-side logging.
		 */
		private String clientId;
		/**
		 * The replication factor for change log topics and repartition topics created by
		 * the stream processing application.
		 */
		private Integer replicationFactor;
		/**
		 * Directory location for the state store.
		 */
		private String stateDir;
		/**
		 * Additional Kafka properties used to configure the streams.
		 */
		private final Map<String, String> properties = new HashMap<>();
		public Ssl getSsl() {
			return this.ssl;
		}
		public Security getSecurity() {
			return this.security;
		}
		public Cleanup getCleanup() {
			return this.cleanup;
		}
		public String getApplicationId() {
			return this.applicationId;
		}
		public void setApplicationId(String applicationId) {
			this.applicationId = applicationId;
		}
		public boolean isAutoStartup() {
			return this.autoStartup;
		}
		public void setAutoStartup(boolean autoStartup) {
			this.autoStartup = autoStartup;
		}
		public List<String> getBootstrapServers() {
			return this.bootstrapServers;
		}
		public void setBootstrapServers(List<String> bootstrapServers) {
			this.bootstrapServers = bootstrapServers;
		}
		public DataSize getStateStoreCacheMaxSize() {
			return this.stateStoreCacheMaxSize;
		}
		public void setStateStoreCacheMaxSize(DataSize stateStoreCacheMaxSize) {
			this.stateStoreCacheMaxSize = stateStoreCacheMaxSize;
		}
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public Integer getReplicationFactor() {
			return this.replicationFactor;
		}
		public void setReplicationFactor(Integer replicationFactor) {
			this.replicationFactor = replicationFactor;
		}
		public String getStateDir() {
			return this.stateDir;
		}
		public void setStateDir(String stateDir) {
			this.stateDir = stateDir;
		}
		public Map<String, String> getProperties() {
			return this.properties;
		}
		public Map<String, Object> buildProperties(SslBundles sslBundles) {
			Properties properties = new Properties();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(this::getApplicationId).to(properties.in('application.id'));
			map.from(this::getBootstrapServers).to(properties.in(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG));
			map.from(this::getStateStoreCacheMaxSize)
				.asInt(DataSize::toBytes)
				.to(properties.in('statestore.cache.max.bytes'));
			map.from(this::getClientId).to(properties.in(CommonClientConfigs.CLIENT_ID_CONFIG));
			map.from(this::getReplicationFactor).to(properties.in('replication.factor'));
			map.from(this::getStateDir).to(properties.in('state.dir'));
			return properties.with(this.ssl, this.security, this.properties, sslBundles);
		}
	}
	public static class Template {
		/**
		 * Default topic to which messages are sent.
		 */
		private String defaultTopic;
		/**
		 * Transaction id prefix, override the transaction id prefix in the producer
		 * factory.
		 */
		private String transactionIdPrefix;
		/**
		 * Whether to enable observation.
		 */
		private boolean observationEnabled;
		public String getDefaultTopic() {
			return this.defaultTopic;
		}
		public void setDefaultTopic(String defaultTopic) {
			this.defaultTopic = defaultTopic;
		}
		public String getTransactionIdPrefix() {
			return this.transactionIdPrefix;
		}
		public void setTransactionIdPrefix(String transactionIdPrefix) {
			this.transactionIdPrefix = transactionIdPrefix;
		}
		public boolean isObservationEnabled() {
			return this.observationEnabled;
		}
		public void setObservationEnabled(boolean observationEnabled) {
			this.observationEnabled = observationEnabled;
		}
	}
	public static class Listener {
		public enum Type {
			/**
			 * Invokes the endpoint with one ConsumerRecord at a time.
			 */
			SINGLE,
			/**
			 * Invokes the endpoint with a batch of ConsumerRecords.
			 */
			BATCH
		}
		/**
		 * Listener type.
		 */
		private Type type = Type.SINGLE;
		/**
		 * Listener AckMode. See the spring-kafka documentation.
		 */
		private AckMode ackMode;
		/**
		 * Support for asynchronous record acknowledgements. Only applies when
		 * spring.kafka.listener.ack-mode is manual or manual-immediate.
		 */
		private Boolean asyncAcks;
		/**
		 * Prefix for the listener"s consumer client.id property.
		 */
		private String clientId;
		/**
		 * Number of threads to run in the listener containers.
		 */
		private Integer concurrency;
		/**
		 * Timeout to use when polling the consumer.
		 */
		private Duration pollTimeout;
		/**
		 * Multiplier applied to 'pollTimeout' to determine if a consumer is
		 * non-responsive.
		 */
		private Float noPollThreshold;
		/**
		 * Number of records between offset commits when ackMode is 'COUNT' or
		 * 'COUNT_TIME'.
		 */
		private Integer ackCount;
		/**
		 * Time between offset commits when ackMode is 'TIME' or 'COUNT_TIME'.
		 */
		private Duration ackTime;
		/**
		 * Sleep interval between Consumer.poll(Duration) calls.
		 */
		private Duration idleBetweenPolls = Duration.ZERO;
		/**
		 * Time between publishing idle consumer events (no data received).
		 */
		private Duration idleEventInterval;
		/**
		 * Time between publishing idle partition consumer events (no data received for
		 * partition).
		 */
		private Duration idlePartitionEventInterval;
		/**
		 * Time between checks for non-responsive consumers. If a duration suffix is not
		 * specified, seconds will be used.
		 */
		@DurationUnit(ChronoUnit.SECONDS)
		private Duration monitorInterval;
		/**
		 * Whether to log the container configuration during initialization (INFO level).
		 */
		private Boolean logContainerConfig;
		/**
		 * Whether the container should fail to start if at least one of the configured
		 * topics are not present on the broker.
		 */
		private boolean missingTopicsFatal = false;
		/**
		 * Whether the container stops after the current record is processed or after all
		 * the records from the previous poll are processed.
		 */
		private boolean immediateStop = false;
		/**
		 * Whether to auto start the container.
		 */
		private boolean autoStartup = true;
		/**
		 * Whether to instruct the container to change the consumer thread name during
		 * initialization.
		 */
		private Boolean changeConsumerThreadName;
		/**
		 * Whether to enable observation.
		 */
		private boolean observationEnabled;
		public Type getType() {
			return this.type;
		}
		public void setType(Type type) {
			this.type = type;
		}
		public AckMode getAckMode() {
			return this.ackMode;
		}
		public void setAckMode(AckMode ackMode) {
			this.ackMode = ackMode;
		}
		public Boolean getAsyncAcks() {
			return this.asyncAcks;
		}
		public void setAsyncAcks(Boolean asyncAcks) {
			this.asyncAcks = asyncAcks;
		}
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public Integer getConcurrency() {
			return this.concurrency;
		}
		public void setConcurrency(Integer concurrency) {
			this.concurrency = concurrency;
		}
		public Duration getPollTimeout() {
			return this.pollTimeout;
		}
		public void setPollTimeout(Duration pollTimeout) {
			this.pollTimeout = pollTimeout;
		}
		public Float getNoPollThreshold() {
			return this.noPollThreshold;
		}
		public void setNoPollThreshold(Float noPollThreshold) {
			this.noPollThreshold = noPollThreshold;
		}
		public Integer getAckCount() {
			return this.ackCount;
		}
		public void setAckCount(Integer ackCount) {
			this.ackCount = ackCount;
		}
		public Duration getAckTime() {
			return this.ackTime;
		}
		public void setAckTime(Duration ackTime) {
			this.ackTime = ackTime;
		}
		public Duration getIdleBetweenPolls() {
			return this.idleBetweenPolls;
		}
		public void setIdleBetweenPolls(Duration idleBetweenPolls) {
			this.idleBetweenPolls = idleBetweenPolls;
		}
		public Duration getIdleEventInterval() {
			return this.idleEventInterval;
		}
		public void setIdleEventInterval(Duration idleEventInterval) {
			this.idleEventInterval = idleEventInterval;
		}
		public Duration getIdlePartitionEventInterval() {
			return this.idlePartitionEventInterval;
		}
		public void setIdlePartitionEventInterval(Duration idlePartitionEventInterval) {
			this.idlePartitionEventInterval = idlePartitionEventInterval;
		}
		public Duration getMonitorInterval() {
			return this.monitorInterval;
		}
		public void setMonitorInterval(Duration monitorInterval) {
			this.monitorInterval = monitorInterval;
		}
		public Boolean getLogContainerConfig() {
			return this.logContainerConfig;
		}
		public void setLogContainerConfig(Boolean logContainerConfig) {
			this.logContainerConfig = logContainerConfig;
		}
		public boolean isMissingTopicsFatal() {
			return this.missingTopicsFatal;
		}
		public void setMissingTopicsFatal(boolean missingTopicsFatal) {
			this.missingTopicsFatal = missingTopicsFatal;
		}
		public boolean isImmediateStop() {
			return this.immediateStop;
		}
		public void setImmediateStop(boolean immediateStop) {
			this.immediateStop = immediateStop;
		}
		public boolean isAutoStartup() {
			return this.autoStartup;
		}
		public void setAutoStartup(boolean autoStartup) {
			this.autoStartup = autoStartup;
		}
		public Boolean getChangeConsumerThreadName() {
			return this.changeConsumerThreadName;
		}
		public void setChangeConsumerThreadName(Boolean changeConsumerThreadName) {
			this.changeConsumerThreadName = changeConsumerThreadName;
		}
		public boolean isObservationEnabled() {
			return this.observationEnabled;
		}
		public void setObservationEnabled(boolean observationEnabled) {
			this.observationEnabled = observationEnabled;
		}
	}
	public static class Ssl {
		/**
		 * Name of the SSL bundle to use.
		 */
		private String bundle;
		/**
		 * Password of the private key in either key store key or key store file.
		 */
		private String keyPassword;
		/**
		 * Certificate chain in PEM format with a list of X.509 certificates.
		 */
		private String keyStoreCertificateChain;
		/**
		 * Private key in PEM format with PKCS#8 keys.
		 */
		private String keyStoreKey;
		/**
		 * Location of the key store file.
		 */
		private Resource keyStoreLocation;
		/**
		 * Store password for the key store file.
		 */
		private String keyStorePassword;
		/**
		 * Type of the key store.
		 */
		private String keyStoreType;
		/**
		 * Trusted certificates in PEM format with X.509 certificates.
		 */
		private String trustStoreCertificates;
		/**
		 * Location of the trust store file.
		 */
		private Resource trustStoreLocation;
		/**
		 * Store password for the trust store file.
		 */
		private String trustStorePassword;
		/**
		 * Type of the trust store.
		 */
		private String trustStoreType;
		/**
		 * SSL protocol to use.
		 */
		private String protocol;
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
		public String getKeyPassword() {
			return this.keyPassword;
		}
		public void setKeyPassword(String keyPassword) {
			this.keyPassword = keyPassword;
		}
		public String getKeyStoreCertificateChain() {
			return this.keyStoreCertificateChain;
		}
		public void setKeyStoreCertificateChain(String keyStoreCertificateChain) {
			this.keyStoreCertificateChain = keyStoreCertificateChain;
		}
		public String getKeyStoreKey() {
			return this.keyStoreKey;
		}
		public void setKeyStoreKey(String keyStoreKey) {
			this.keyStoreKey = keyStoreKey;
		}
		public Resource getKeyStoreLocation() {
			return this.keyStoreLocation;
		}
		public void setKeyStoreLocation(Resource keyStoreLocation) {
			this.keyStoreLocation = keyStoreLocation;
		}
		public String getKeyStorePassword() {
			return this.keyStorePassword;
		}
		public void setKeyStorePassword(String keyStorePassword) {
			this.keyStorePassword = keyStorePassword;
		}
		public String getKeyStoreType() {
			return this.keyStoreType;
		}
		public void setKeyStoreType(String keyStoreType) {
			this.keyStoreType = keyStoreType;
		}
		public String getTrustStoreCertificates() {
			return this.trustStoreCertificates;
		}
		public void setTrustStoreCertificates(String trustStoreCertificates) {
			this.trustStoreCertificates = trustStoreCertificates;
		}
		public Resource getTrustStoreLocation() {
			return this.trustStoreLocation;
		}
		public void setTrustStoreLocation(Resource trustStoreLocation) {
			this.trustStoreLocation = trustStoreLocation;
		}
		public String getTrustStorePassword() {
			return this.trustStorePassword;
		}
		public void setTrustStorePassword(String trustStorePassword) {
			this.trustStorePassword = trustStorePassword;
		}
		public String getTrustStoreType() {
			return this.trustStoreType;
		}
		public void setTrustStoreType(String trustStoreType) {
			this.trustStoreType = trustStoreType;
		}
		public String getProtocol() {
			return this.protocol;
		}
		public void setProtocol(String protocol) {
			this.protocol = protocol;
		}
		@Deprecated(since = '3.2.0', forRemoval = true)
		public Map<String, Object> buildProperties() {
			return buildProperties(null);
		}
		public Map<String, Object> buildProperties(SslBundles sslBundles) {
			validate();
			Properties properties = new Properties();
			if (getBundle() != null) {
				properties.in(SslConfigs.SSL_ENGINE_FACTORY_CLASS_CONFIG)
					.accept(SslBundleSslEngineFactory.class.getName());
				properties.in(SslBundle.class.getName()).accept(sslBundles.getBundle(getBundle()));
			}
			else {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(this::getKeyPassword).to(properties.in(SslConfigs.SSL_KEY_PASSWORD_CONFIG));
				map.from(this::getKeyStoreCertificateChain)
					.to(properties.in(SslConfigs.SSL_KEYSTORE_CERTIFICATE_CHAIN_CONFIG));
				map.from(this::getKeyStoreKey).to(properties.in(SslConfigs.SSL_KEYSTORE_KEY_CONFIG));
				map.from(this::getKeyStoreLocation)
					.as(this::resourceToPath)
					.to(properties.in(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG));
				map.from(this::getKeyStorePassword).to(properties.in(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG));
				map.from(this::getKeyStoreType).to(properties.in(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG));
				map.from(this::getTrustStoreCertificates)
					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_CERTIFICATES_CONFIG));
				map.from(this::getTrustStoreLocation)
					.as(this::resourceToPath)
					.to(properties.in(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG));
				map.from(this::getTrustStorePassword).to(properties.in(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG));
				map.from(this::getTrustStoreType).to(properties.in(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG));
				map.from(this::getProtocol).to(properties.in(SslConfigs.SSL_PROTOCOL_CONFIG));
			}
			return properties;
		}
		private void validate() {
			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
				entries.put('spring.kafka.ssl.key-store-key', getKeyStoreKey());
				entries.put('spring.kafka.ssl.key-store-location', getKeyStoreLocation());
			});
			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
				entries.put('spring.kafka.ssl.trust-store-certificates', getTrustStoreCertificates());
				entries.put('spring.kafka.ssl.trust-store-location', getTrustStoreLocation());
			});
			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
				entries.put('spring.kafka.ssl.bundle', getBundle());
				entries.put('spring.kafka.ssl.key-store-key', getKeyStoreKey());
			});
			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
				entries.put('spring.kafka.ssl.bundle', getBundle());
				entries.put('spring.kafka.ssl.key-store-location', getKeyStoreLocation());
			});
			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
				entries.put('spring.kafka.ssl.bundle', getBundle());
				entries.put('spring.kafka.ssl.trust-store-certificates', getTrustStoreCertificates());
			});
			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
				entries.put('spring.kafka.ssl.bundle', getBundle());
				entries.put('spring.kafka.ssl.trust-store-location', getTrustStoreLocation());
			});
		}
		private String resourceToPath(Resource resource) {
			try {
				return resource.getFile().getAbsolutePath();
			}
			catch (IOException ex) {
				throw new IllegalStateException('Resource "' + resource + '" must be on a file system', ex);
			}
		}
	}
	public static class Jaas {
		/**
		 * Whether to enable JAAS configuration.
		 */
		private boolean enabled;
		/**
		 * Login module.
		 */
		private String loginModule = 'com.sun.security.auth.module.Krb5LoginModule';
		/**
		 * Control flag for login configuration.
		 */
		private KafkaJaasLoginModuleInitializer.ControlFlag controlFlag = KafkaJaasLoginModuleInitializer.ControlFlag.REQUIRED;
		/**
		 * Additional JAAS options.
		 */
		private final Map<String, String> options = new HashMap<>();
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public String getLoginModule() {
			return this.loginModule;
		}
		public void setLoginModule(String loginModule) {
			this.loginModule = loginModule;
		}
		public KafkaJaasLoginModuleInitializer.ControlFlag getControlFlag() {
			return this.controlFlag;
		}
		public void setControlFlag(KafkaJaasLoginModuleInitializer.ControlFlag controlFlag) {
			this.controlFlag = controlFlag;
		}
		public Map<String, String> getOptions() {
			return this.options;
		}
		public void setOptions(Map<String, String> options) {
			if (options != null) {
				this.options.putAll(options);
			}
		}
	}
	public static class Security {
		/**
		 * Security protocol used to communicate with brokers.
		 */
		private String protocol;
		public String getProtocol() {
			return this.protocol;
		}
		public void setProtocol(String protocol) {
			this.protocol = protocol;
		}
		public Map<String, Object> buildProperties() {
			Properties properties = new Properties();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(this::getProtocol).to(properties.in(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG));
			return properties;
		}
	}
	public static class Retry {
		private final Topic topic = new Topic();
		public Topic getTopic() {
			return this.topic;
		}
		/**
		 * Properties for non-blocking, topic-based retries.
		 */
		public static class Topic {
			/**
			 * Whether to enable topic-based non-blocking retries.
			 */
			private boolean enabled;
			/**
			 * Total number of processing attempts made before sending the message to the
			 * DLT.
			 */
			private int attempts = 3;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
			public int getAttempts() {
				return this.attempts;
			}
			public void setAttempts(int attempts) {
				this.attempts = attempts;
			}
			@DeprecatedConfigurationProperty(replacement = 'spring.kafka.retry.topic.backoff.delay', since = '3.4.0')
			@Deprecated(since = '3.4.0', forRemoval = true)
			public Duration getDelay() {
				return getBackoff().getDelay();
			}
			@Deprecated(since = '3.4.0', forRemoval = true)
			public void setDelay(Duration delay) {
				getBackoff().setDelay(delay);
			}
			@DeprecatedConfigurationProperty(replacement = 'spring.kafka.retry.topic.backoff.multiplier',
					since = '3.4.0')
			@Deprecated(since = '3.4.0', forRemoval = true)
			public double getMultiplier() {
				return getBackoff().getMultiplier();
			}
			@Deprecated(since = '3.4.0', forRemoval = true)
			public void setMultiplier(double multiplier) {
				getBackoff().setMultiplier(multiplier);
			}
			@DeprecatedConfigurationProperty(replacement = 'spring.kafka.retry.topic.backoff.maxDelay', since = '3.4.0')
			@Deprecated(since = '3.4.0', forRemoval = true)
			public Duration getMaxDelay() {
				return getBackoff().getMaxDelay();
			}
			@Deprecated(since = '3.4.0', forRemoval = true)
			public void setMaxDelay(Duration maxDelay) {
				getBackoff().setMaxDelay(maxDelay);
			}
			@DeprecatedConfigurationProperty(replacement = 'spring.kafka.retry.topic.backoff.random', since = '3.4.0')
			@Deprecated(since = '3.4.0', forRemoval = true)
			public boolean isRandomBackOff() {
				return getBackoff().isRandom();
			}
			@Deprecated(since = '3.4.0', forRemoval = true)
			public void setRandomBackOff(boolean randomBackOff) {
				getBackoff().setRandom(randomBackOff);
			}
			private final Backoff backoff = new Backoff();
			public Backoff getBackoff() {
				return this.backoff;
			}
			public static class Backoff {
				/**
				 * Canonical backoff period. Used as an initial value in the exponential
				 * case, and as a minimum value in the uniform case.
				 */
				private Duration delay = Duration.ofSeconds(1);
				/**
				 * Multiplier to use for generating the next backoff delay.
				 */
				private double multiplier = 0.0;
				/**
				 * Maximum wait between retries. If less than the delay then the default
				 * of 30 seconds is applied.
				 */
				private Duration maxDelay = Duration.ZERO;
				/**
				 * Whether to have the backoff delays.
				 */
				private boolean random = false;
				public Duration getDelay() {
					return this.delay;
				}
				public void setDelay(Duration delay) {
					this.delay = delay;
				}
				public double getMultiplier() {
					return this.multiplier;
				}
				public void setMultiplier(double multiplier) {
					this.multiplier = multiplier;
				}
				public Duration getMaxDelay() {
					return this.maxDelay;
				}
				public void setMaxDelay(Duration maxDelay) {
					this.maxDelay = maxDelay;
				}
				public boolean isRandom() {
					return this.random;
				}
				public void setRandom(boolean random) {
					this.random = random;
				}
			}
		}
	}
	public static class Cleanup {
		/**
		 * Cleanup the applications local state directory on startup.
		 */
		private boolean onStartup = false;
		/**
		 * Cleanup the applications local state directory on shutdown.
		 */
		private boolean onShutdown = false;
		public boolean isOnStartup() {
			return this.onStartup;
		}
		public void setOnStartup(boolean onStartup) {
			this.onStartup = onStartup;
		}
		public boolean isOnShutdown() {
			return this.onShutdown;
		}
		public void setOnShutdown(boolean onShutdown) {
			this.onShutdown = onShutdown;
		}
	}
	public enum IsolationLevel {
		/**
		 * Read everything including aborted transactions.
		 */
		READ_UNCOMMITTED((byte) 0),
		/**
		 * Read records from committed transactions, in addition to records not part of
		 * transactions.
		 */
		READ_COMMITTED((byte) 1);
		private final byte id;
		IsolationLevel(byte id) {
			this.id = id;
		}
		public byte id() {
			return this.id;
		}
	}
	@SuppressWarnings('serial')
	private static final class Properties extends HashMap<String, Object> {
		<V> java.util.function.Consumer<V> in(String key) {
			return (value) -> put(key, value);
		}
		Properties with(Ssl ssl, Security security, Map<String, String> properties, SslBundles sslBundles) {
			putAll(ssl.buildProperties(sslBundles));
			putAll(security.buildProperties());
			putAll(properties);
			return this;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
public class ConcurrentKafkaListenerContainerFactoryConfigurer {
	private KafkaProperties properties;
	private BatchMessageConverter batchMessageConverter;
	private RecordMessageConverter recordMessageConverter;
	private RecordFilterStrategy<Object, Object> recordFilterStrategy;
	private KafkaTemplate<Object, Object> replyTemplate;
	private KafkaAwareTransactionManager<Object, Object> transactionManager;
	private ConsumerAwareRebalanceListener rebalanceListener;
	private CommonErrorHandler commonErrorHandler;
	private AfterRollbackProcessor<Object, Object> afterRollbackProcessor;
	private RecordInterceptor<Object, Object> recordInterceptor;
	private BatchInterceptor<Object, Object> batchInterceptor;
	private Function<MessageListenerContainer, String> threadNameSupplier;
	private SimpleAsyncTaskExecutor listenerTaskExecutor;
	/**
	 * Set the {@link KafkaProperties} to use.
	 * @param properties the properties
	 */
	void setKafkaProperties(KafkaProperties properties) {
		this.properties = properties;
	}
	/**
	 * Set the {@link BatchMessageConverter} to use.
	 * @param batchMessageConverter the message converter
	 */
	void setBatchMessageConverter(BatchMessageConverter batchMessageConverter) {
		this.batchMessageConverter = batchMessageConverter;
	}
	/**
	 * Set the {@link RecordMessageConverter} to use.
	 * @param recordMessageConverter the message converter
	 */
	void setRecordMessageConverter(RecordMessageConverter recordMessageConverter) {
		this.recordMessageConverter = recordMessageConverter;
	}
	/**
	 * Set the {@link RecordFilterStrategy} to use to filter incoming records.
	 * @param recordFilterStrategy the record filter strategy
	 */
	void setRecordFilterStrategy(RecordFilterStrategy<Object, Object> recordFilterStrategy) {
		this.recordFilterStrategy = recordFilterStrategy;
	}
	/**
	 * Set the {@link KafkaTemplate} to use to send replies.
	 * @param replyTemplate the reply template
	 */
	void setReplyTemplate(KafkaTemplate<Object, Object> replyTemplate) {
		this.replyTemplate = replyTemplate;
	}
	/**
	 * Set the {@link KafkaAwareTransactionManager} to use.
	 * @param transactionManager the transaction manager
	 */
	void setTransactionManager(KafkaAwareTransactionManager<Object, Object> transactionManager) {
		this.transactionManager = transactionManager;
	}
	/**
	 * Set the {@link ConsumerAwareRebalanceListener} to use.
	 * @param rebalanceListener the rebalance listener.
	 * @since 2.2
	 */
	void setRebalanceListener(ConsumerAwareRebalanceListener rebalanceListener) {
		this.rebalanceListener = rebalanceListener;
	}
	/**
	 * Set the {@link CommonErrorHandler} to use.
	 * @param commonErrorHandler the error handler.
	 * @since 2.6.0
	 */
	public void setCommonErrorHandler(CommonErrorHandler commonErrorHandler) {
		this.commonErrorHandler = commonErrorHandler;
	}
	/**
	 * Set the {@link AfterRollbackProcessor} to use.
	 * @param afterRollbackProcessor the after rollback processor
	 */
	void setAfterRollbackProcessor(AfterRollbackProcessor<Object, Object> afterRollbackProcessor) {
		this.afterRollbackProcessor = afterRollbackProcessor;
	}
	/**
	 * Set the {@link RecordInterceptor} to use.
	 * @param recordInterceptor the record interceptor.
	 */
	void setRecordInterceptor(RecordInterceptor<Object, Object> recordInterceptor) {
		this.recordInterceptor = recordInterceptor;
	}
	/**
	 * Set the {@link BatchInterceptor} to use.
	 * @param batchInterceptor the batch interceptor.
	 */
	void setBatchInterceptor(BatchInterceptor<Object, Object> batchInterceptor) {
		this.batchInterceptor = batchInterceptor;
	}
	/**
	 * Set the thread name supplier to use.
	 * @param threadNameSupplier the thread name supplier to use
	 */
	void setThreadNameSupplier(Function<MessageListenerContainer, String> threadNameSupplier) {
		this.threadNameSupplier = threadNameSupplier;
	}
	/**
	 * Set the executor for threads that poll the consumer.
	 * @param listenerTaskExecutor task executor
	 */
	void setListenerTaskExecutor(SimpleAsyncTaskExecutor listenerTaskExecutor) {
		this.listenerTaskExecutor = listenerTaskExecutor;
	}
	/**
	 * Configure the specified Kafka listener container factory. The factory can be
	 * further tuned and default settings can be overridden.
	 * @param listenerFactory the {@link ConcurrentKafkaListenerContainerFactory} instance
	 * to configure
	 * @param consumerFactory the {@link ConsumerFactory} to use
	 */
	public void configure(ConcurrentKafkaListenerContainerFactory<Object, Object> listenerFactory,
			ConsumerFactory<Object, Object> consumerFactory) {
		listenerFactory.setConsumerFactory(consumerFactory);
		configureListenerFactory(listenerFactory);
		configureContainer(listenerFactory.getContainerProperties());
	}
	private void configureListenerFactory(ConcurrentKafkaListenerContainerFactory<Object, Object> factory) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		Listener properties = this.properties.getListener();
		map.from(properties::getConcurrency).to(factory::setConcurrency);
		map.from(properties::isAutoStartup).to(factory::setAutoStartup);
		map.from(this.batchMessageConverter).to(factory::setBatchMessageConverter);
		map.from(this.recordMessageConverter).to(factory::setRecordMessageConverter);
		map.from(this.recordFilterStrategy).to(factory::setRecordFilterStrategy);
		map.from(this.replyTemplate).to(factory::setReplyTemplate);
		if (properties.getType().equals(Listener.Type.BATCH)) {
			factory.setBatchListener(true);
		}
		map.from(this.commonErrorHandler).to(factory::setCommonErrorHandler);
		map.from(this.afterRollbackProcessor).to(factory::setAfterRollbackProcessor);
		map.from(this.recordInterceptor).to(factory::setRecordInterceptor);
		map.from(this.batchInterceptor).to(factory::setBatchInterceptor);
		map.from(this.threadNameSupplier).to(factory::setThreadNameSupplier);
		map.from(properties::getChangeConsumerThreadName).to(factory::setChangeConsumerThreadName);
	}
	private void configureContainer(ContainerProperties container) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		Listener properties = this.properties.getListener();
		map.from(properties::getAckMode).to(container::setAckMode);
		map.from(properties::getAsyncAcks).to(container::setAsyncAcks);
		map.from(properties::getClientId).to(container::setClientId);
		map.from(properties::getAckCount).to(container::setAckCount);
		map.from(properties::getAckTime).as(Duration::toMillis).to(container::setAckTime);
		map.from(properties::getPollTimeout).as(Duration::toMillis).to(container::setPollTimeout);
		map.from(properties::getNoPollThreshold).to(container::setNoPollThreshold);
		map.from(properties.getIdleBetweenPolls()).as(Duration::toMillis).to(container::setIdleBetweenPolls);
		map.from(properties::getIdleEventInterval).as(Duration::toMillis).to(container::setIdleEventInterval);
		map.from(properties::getIdlePartitionEventInterval)
			.as(Duration::toMillis)
			.to(container::setIdlePartitionEventInterval);
		map.from(properties::getMonitorInterval)
			.as(Duration::getSeconds)
			.as(Number::intValue)
			.to(container::setMonitorInterval);
		map.from(properties::getLogContainerConfig).to(container::setLogContainerConfig);
		map.from(properties::isMissingTopicsFatal).to(container::setMissingTopicsFatal);
		map.from(properties::isImmediateStop).to(container::setStopImmediate);
		map.from(properties::isObservationEnabled).to(container::setObservationEnabled);
		map.from(this.transactionManager).to(container::setKafkaAwareTransactionManager);
		map.from(this.rebalanceListener).to(container::setConsumerRebalanceListener);
		map.from(this.listenerTaskExecutor).to(container::setListenerTaskExecutor);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.kafka;
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@FunctionalInterface
public interface DefaultKafkaProducerFactoryCustomizer {
	/**
	 * Customize the {@link DefaultKafkaProducerFactory}.
	 * @param producerFactory the producer factory to customize
	 */
	void customize(DefaultKafkaProducerFactory<?, ?> producerFactory);
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@AutoConfiguration(after = { JsonbAutoConfiguration.class, ElasticsearchRestClientAutoConfiguration.class })
@ConditionalOnBean(RestClient.class)
@ConditionalOnClass(ElasticsearchClient.class)
@Import({ JsonpMapperConfiguration.class, ElasticsearchTransportConfiguration.class,
		ElasticsearchClientConfiguration.class })
public class ElasticsearchClientAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
class ElasticsearchClientConfigurations {
	@Import({ JacksonJsonpMapperConfiguration.class, JsonbJsonpMapperConfiguration.class,
			SimpleJsonpMapperConfiguration.class })
	static class JsonpMapperConfiguration {
	}
	@ConditionalOnMissingBean(JsonpMapper.class)
	@ConditionalOnClass(ObjectMapper.class)
	@Configuration(proxyBeanMethods = false)
	static class JacksonJsonpMapperConfiguration {
		@Bean
		JacksonJsonpMapper jacksonJsonpMapper() {
			return new JacksonJsonpMapper();
		}
	}
	@ConditionalOnMissingBean(JsonpMapper.class)
	@ConditionalOnBean(Jsonb.class)
	@Configuration(proxyBeanMethods = false)
	static class JsonbJsonpMapperConfiguration {
		@Bean
		JsonbJsonpMapper jsonbJsonpMapper(Jsonb jsonb) {
			return new JsonbJsonpMapper(JsonProvider.provider(), jsonb);
		}
	}
	@ConditionalOnMissingBean(JsonpMapper.class)
	@Configuration(proxyBeanMethods = false)
	static class SimpleJsonpMapperConfiguration {
		@Bean
		SimpleJsonpMapper simpleJsonpMapper() {
			return new SimpleJsonpMapper();
		}
	}
	@ConditionalOnMissingBean(ElasticsearchTransport.class)
	static class ElasticsearchTransportConfiguration {
		@Bean
		RestClientTransport restClientTransport(RestClient restClient, JsonpMapper jsonMapper,
				ObjectProvider<RestClientOptions> restClientOptions) {
			return new RestClientTransport(restClient, jsonMapper, restClientOptions.getIfAvailable());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(ElasticsearchTransport.class)
	static class ElasticsearchClientConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ElasticsearchClient elasticsearchClient(ElasticsearchTransport transport) {
			return new ElasticsearchClient(transport);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@AutoConfiguration(after = SslAutoConfiguration.class)
@ConditionalOnClass(RestClientBuilder.class)
@EnableConfigurationProperties(ElasticsearchProperties.class)
@Import({ RestClientBuilderConfiguration.class, RestClientConfiguration.class, RestClientSnifferConfiguration.class })
public class ElasticsearchRestClientAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
class ElasticsearchRestClientConfigurations {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(RestClientBuilder.class)
	static class RestClientBuilderConfiguration {
		private final ElasticsearchProperties properties;
		RestClientBuilderConfiguration(ElasticsearchProperties properties) {
			this.properties = properties;
		}
		@Bean
		@ConditionalOnMissingBean(ElasticsearchConnectionDetails.class)
		PropertiesElasticsearchConnectionDetails elasticsearchConnectionDetails() {
			return new PropertiesElasticsearchConnectionDetails(this.properties);
		}
		@Bean
		RestClientBuilderCustomizer defaultRestClientBuilderCustomizer(
				ElasticsearchConnectionDetails connectionDetails) {
			return new DefaultRestClientBuilderCustomizer(this.properties, connectionDetails);
		}
		@Bean
		RestClientBuilder elasticsearchRestClientBuilder(ElasticsearchConnectionDetails connectionDetails,
				ObjectProvider<RestClientBuilderCustomizer> builderCustomizers, ObjectProvider<SslBundles> sslBundles) {
			RestClientBuilder builder = RestClient.builder(connectionDetails.getNodes()
				.stream()
				.map((node) -> new HttpHost(node.hostname(), node.port(), node.protocol().getScheme()))
				.toArray(HttpHost[]::new));
			builder.setHttpClientConfigCallback((httpClientBuilder) -> {
				builderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(httpClientBuilder));
				String sslBundleName = this.properties.getRestclient().getSsl().getBundle();
				if (StringUtils.hasText(sslBundleName)) {
					configureSsl(httpClientBuilder, sslBundles.getObject().getBundle(sslBundleName));
				}
				return httpClientBuilder;
			});
			builder.setRequestConfigCallback((requestConfigBuilder) -> {
				builderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(requestConfigBuilder));
				return requestConfigBuilder;
			});
			String pathPrefix = connectionDetails.getPathPrefix();
			if (pathPrefix != null) {
				builder.setPathPrefix(pathPrefix);
			}
			builderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
			return builder;
		}
		private void configureSsl(HttpAsyncClientBuilder httpClientBuilder, SslBundle sslBundle) {
			SSLContext sslcontext = sslBundle.createSslContext();
			SslOptions sslOptions = sslBundle.getOptions();
			httpClientBuilder.setSSLStrategy(new SSLIOSessionStrategy(sslcontext, sslOptions.getEnabledProtocols(),
					sslOptions.getCiphers(), (HostnameVerifier) null));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(RestClient.class)
	static class RestClientConfiguration {
		@Bean
		RestClient elasticsearchRestClient(RestClientBuilder restClientBuilder) {
			return restClientBuilder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Sniffer.class)
	@ConditionalOnSingleCandidate(RestClient.class)
	static class RestClientSnifferConfiguration {
		@Bean
		@ConditionalOnMissingBean
		Sniffer elasticsearchSniffer(RestClient client, ElasticsearchProperties properties) {
			SnifferBuilder builder = Sniffer.builder(client);
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			Duration interval = properties.getRestclient().getSniffer().getInterval();
			map.from(interval).asInt(Duration::toMillis).to(builder::setSniffIntervalMillis);
			Duration delayAfterFailure = properties.getRestclient().getSniffer().getDelayAfterFailure();
			map.from(delayAfterFailure).asInt(Duration::toMillis).to(builder::setSniffAfterFailureDelayMillis);
			return builder.build();
		}
	}
	static class DefaultRestClientBuilderCustomizer implements RestClientBuilderCustomizer {
		private static final PropertyMapper map = PropertyMapper.get();
		private final ElasticsearchProperties properties;
		private final ElasticsearchConnectionDetails connectionDetails;
		DefaultRestClientBuilderCustomizer(ElasticsearchProperties properties,
				ElasticsearchConnectionDetails connectionDetails) {
			this.properties = properties;
			this.connectionDetails = connectionDetails;
		}
		@Override
		public void customize(RestClientBuilder builder) {
		}
		@Override
		public void customize(HttpAsyncClientBuilder builder) {
			builder.setDefaultCredentialsProvider(new ConnectionDetailsCredentialsProvider(this.connectionDetails));
			map.from(this.properties::isSocketKeepAlive)
				.to((keepAlive) -> builder
					.setDefaultIOReactorConfig(IOReactorConfig.custom().setSoKeepAlive(keepAlive).build()));
		}
		@Override
		public void customize(RequestConfig.Builder builder) {
			map.from(this.properties::getConnectionTimeout)
				.whenNonNull()
				.asInt(Duration::toMillis)
				.to(builder::setConnectTimeout);
			map.from(this.properties::getSocketTimeout)
				.whenNonNull()
				.asInt(Duration::toMillis)
				.to(builder::setSocketTimeout);
		}
	}
	private static class ConnectionDetailsCredentialsProvider extends BasicCredentialsProvider {
		ConnectionDetailsCredentialsProvider(ElasticsearchConnectionDetails connectionDetails) {
			String username = connectionDetails.getUsername();
			if (StringUtils.hasText(username)) {
				Credentials credentials = new UsernamePasswordCredentials(username, connectionDetails.getPassword());
				setCredentials(AuthScope.ANY, credentials);
			}
			Stream<URI> uris = getUris(connectionDetails);
			uris.filter(this::hasUserInfo).forEach(this::addUserInfoCredentials);
		}
		private Stream<URI> getUris(ElasticsearchConnectionDetails connectionDetails) {
			return connectionDetails.getNodes().stream().map(Node::toUri);
		}
		private boolean hasUserInfo(URI uri) {
			return uri != null && StringUtils.hasLength(uri.getUserInfo());
		}
		private void addUserInfoCredentials(URI uri) {
			AuthScope authScope = new AuthScope(uri.getHost(), uri.getPort());
			Credentials credentials = createUserInfoCredentials(uri.getUserInfo());
			setCredentials(authScope, credentials);
		}
		private Credentials createUserInfoCredentials(String userInfo) {
			int delimiter = userInfo.indexOf(':');
			if (delimiter == -1) {
				return new UsernamePasswordCredentials(userInfo, null);
			}
			String username = userInfo.substring(0, delimiter);
			String password = userInfo.substring(delimiter + 1);
			return new UsernamePasswordCredentials(username, password);
		}
	}
	/**
	 * Adapts {@link ElasticsearchProperties} to {@link ElasticsearchConnectionDetails}.
	 */
	static class PropertiesElasticsearchConnectionDetails implements ElasticsearchConnectionDetails {
		private final ElasticsearchProperties properties;
		PropertiesElasticsearchConnectionDetails(ElasticsearchProperties properties) {
			this.properties = properties;
		}
		@Override
		public List<Node> getNodes() {
			return this.properties.getUris().stream().map(this::createNode).toList();
		}
		@Override
		public String getUsername() {
			return this.properties.getUsername();
		}
		@Override
		public String getPassword() {
			return this.properties.getPassword();
		}
		@Override
		public String getPathPrefix() {
			return this.properties.getPathPrefix();
		}
		private Node createNode(String uri) {
			if (!(uri.startsWith('http://') || uri.startsWith('https://'))) {
				uri = 'http://' + uri;
			}
			return createNode(URI.create(uri));
		}
		private Node createNode(URI uri) {
			String userInfo = uri.getUserInfo();
			Protocol protocol = Protocol.forScheme(uri.getScheme());
			if (!StringUtils.hasLength(userInfo)) {
				return new Node(uri.getHost(), uri.getPort(), protocol, null, null);
			}
			int separatorIndex = userInfo.indexOf(":");
			if (separatorIndex == -1) {
				return new Node(uri.getHost(), uri.getPort(), protocol, userInfo, null);
			}
			String[] components = userInfo.split(':');
			return new Node(uri.getHost(), uri.getPort(), protocol, components[0],
					(components.length > 1) ? components[1] : '');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
public interface ElasticsearchConnectionDetails extends ConnectionDetails {
	/**
	 * List of the Elasticsearch nodes to use.
	 * @return list of the Elasticsearch nodes to use
	 */
	List<Node> getNodes();
	/**
	 * Username for authentication with Elasticsearch.
	 * @return username for authentication with Elasticsearch or {@code null}
	 */
	default String getUsername() {
		return null;
	}
	/**
	 * Password for authentication with Elasticsearch.
	 * @return password for authentication with Elasticsearch or {@code null}
	 */
	default String getPassword() {
		return null;
	}
	/**
	 * Prefix added to the path of every request sent to Elasticsearch.
	 * @return prefix added to the path of every request sent to Elasticsearch or
	 * {@code null}
	 */
	default String getPathPrefix() {
		return null;
	}
	/**
	 * An Elasticsearch node.
	 *
	 * @param hostname the hostname
	 * @param port the port
	 * @param protocol the protocol
	 * @param username the username or {@code null}
	 * @param password the password or {@code null}
	 */
	record Node(String hostname, int port, Node.Protocol protocol, String username, String password) {
		public Node(String host, int port, Node.Protocol protocol) {
			this(host, port, protocol, null, null);
		}
		URI toUri() {
			try {
				return new URI(this.protocol.getScheme(), userInfo(), this.hostname, this.port, null, null, null);
			}
			catch (URISyntaxException ex) {
				throw new IllegalStateException('Can"t construct URI', ex);
			}
		}
		private String userInfo() {
			if (this.username == null) {
				return null;
			}
			return (this.password != null) ? (this.username + ':' + this.password) : this.username;
		}
		/**
		 * Connection protocol.
		 */
		public enum Protocol {
			/**
			 * HTTP.
			 */
			HTTP('http'),
			/**
			 * HTTPS.
			 */
			HTTPS('https');
			private final String scheme;
			Protocol(String scheme) {
				this.scheme = scheme;
			}
			String getScheme() {
				return this.scheme;
			}
			static Protocol forScheme(String scheme) {
				for (Protocol protocol : values()) {
					if (protocol.scheme.equals(scheme)) {
						return protocol;
					}
				}
				throw new IllegalArgumentException('Unknown scheme "' + scheme + '"');
			}
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.elasticsearch;
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@ConfigurationProperties('spring.elasticsearch')
public class ElasticsearchProperties {
	/**
	 * List of the Elasticsearch instances to use.
	 */
	private List<String> uris = new ArrayList<>(Collections.singletonList('http://localhost:9200'));
	/**
	 * Username for authentication with Elasticsearch.
	 */
	private String username;
	/**
	 * Password for authentication with Elasticsearch.
	 */
	private String password;
	/**
	 * Connection timeout used when communicating with Elasticsearch.
	 */
	private Duration connectionTimeout = Duration.ofSeconds(1);
	/**
	 * Socket timeout used when communicating with Elasticsearch.
	 */
	private Duration socketTimeout = Duration.ofSeconds(30);
	/**
	 * Whether to enable socket keep alive between client and Elasticsearch.
	 */
	private boolean socketKeepAlive = false;
	/**
	 * Prefix added to the path of every request sent to Elasticsearch.
	 */
	private String pathPrefix;
	private final Restclient restclient = new Restclient();
	public List<String> getUris() {
		return this.uris;
	}
	public void setUris(List<String> uris) {
		this.uris = uris;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Duration getConnectionTimeout() {
		return this.connectionTimeout;
	}
	public void setConnectionTimeout(Duration connectionTimeout) {
		this.connectionTimeout = connectionTimeout;
	}
	public Duration getSocketTimeout() {
		return this.socketTimeout;
	}
	public void setSocketTimeout(Duration socketTimeout) {
		this.socketTimeout = socketTimeout;
	}
	public boolean isSocketKeepAlive() {
		return this.socketKeepAlive;
	}
	public void setSocketKeepAlive(boolean socketKeepAlive) {
		this.socketKeepAlive = socketKeepAlive;
	}
	public String getPathPrefix() {
		return this.pathPrefix;
	}
	public void setPathPrefix(String pathPrefix) {
		this.pathPrefix = pathPrefix;
	}
	public Restclient getRestclient() {
		return this.restclient;
	}
	public static class Restclient {
		private final Sniffer sniffer = new Sniffer();
		private final Ssl ssl = new Ssl();
		public Sniffer getSniffer() {
			return this.sniffer;
		}
		public Ssl getSsl() {
			return this.ssl;
		}
		public static class Sniffer {
			/**
			 * Interval between consecutive ordinary sniff executions.
			 */
			private Duration interval = Duration.ofMinutes(5);
			/**
			 * Delay of a sniff execution scheduled after a failure.
			 */
			private Duration delayAfterFailure = Duration.ofMinutes(1);
			public Duration getInterval() {
				return this.interval;
			}
			public void setInterval(Duration interval) {
				this.interval = interval;
			}
			public Duration getDelayAfterFailure() {
				return this.delayAfterFailure;
			}
			public void setDelayAfterFailure(Duration delayAfterFailure) {
				this.delayAfterFailure = delayAfterFailure;
			}
		}
		public static class Ssl {
			/**
			 * SSL bundle name.
			 */
			private String bundle;
			public String getBundle() {
				return this.bundle;
			}
			public void setBundle(String bundle) {
				this.bundle = bundle;
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@FunctionalInterface
public interface RestClientBuilderCustomizer {
	/**
	 * Customize the {@link RestClientBuilder}.
	 * <p>
	 * Possibly overrides customizations made with the {@code 'spring.elasticsearch.rest'}
	 * configuration properties namespace. For more targeted changes, see
	 * {@link #customize(HttpAsyncClientBuilder)} and
	 * {@link #customize(RequestConfig.Builder)}.
	 * @param builder the builder to customize
	 */
	void customize(RestClientBuilder builder);
	/**
	 * Customize the {@link HttpAsyncClientBuilder}.
	 * @param builder the builder
	 * @since 2.3.0
	 */
	default void customize(HttpAsyncClientBuilder builder) {
	}
	/**
	 * Customize the {@link Builder}.
	 * @param builder the builder
	 * @since 2.3.0
	 */
	default void customize(Builder builder) {
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@AutoConfiguration(after = ElasticsearchClientAutoConfiguration.class)
@ConditionalOnBean(RestClient.class)
@ConditionalOnClass({ ReactiveElasticsearchClient.class, ElasticsearchTransport.class, Mono.class })
@EnableConfigurationProperties(ElasticsearchProperties.class)
@Import({ ElasticsearchClientConfigurations.JsonpMapperConfiguration.class,
		ElasticsearchClientConfigurations.ElasticsearchTransportConfiguration.class })
public class ReactiveElasticsearchClientAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(ElasticsearchTransport.class)
	ReactiveElasticsearchClient reactiveElasticsearchClient(ElasticsearchTransport transport) {
		return new ReactiveElasticsearchClient(transport);
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.LOWEST_PRECEDENCE - 20)
class OnJndiCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		AnnotationAttributes annotationAttributes = AnnotationAttributes
			.fromMap(metadata.getAnnotationAttributes(ConditionalOnJndi.class.getName()));
		String[] locations = annotationAttributes.getStringArray('value');
		try {
			return getMatchOutcome(locations);
		}
		catch (NoClassDefFoundError ex) {
			return ConditionOutcome
				.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class).because('JNDI class not found'));
		}
	}
	private ConditionOutcome getMatchOutcome(String[] locations) {
		if (!isJndiAvailable()) {
			return ConditionOutcome
				.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class).notAvailable('JNDI environment'));
		}
		if (locations.length == 0) {
			return ConditionOutcome
				.match(ConditionMessage.forCondition(ConditionalOnJndi.class).available('JNDI environment'));
		}
		JndiLocator locator = getJndiLocator(locations);
		String location = locator.lookupFirstLocation();
		String details = '(' + StringUtils.arrayToCommaDelimitedString(locations) + ')';
		if (location != null) {
			return ConditionOutcome.match(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
				.foundExactly('\'' + location + '\''));
		}
		return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnJndi.class, details)
			.didNotFind('any matching JNDI location')
			.atAll());
	}
	protected boolean isJndiAvailable() {
		return JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable();
	}
	protected JndiLocator getJndiLocator(String[] locations) {
		return new JndiLocator(locations);
	}
	protected static class JndiLocator extends JndiLocatorSupport {
		private final String[] locations;
		public JndiLocator(String[] locations) {
			this.locations = locations;
		}
		public String lookupFirstLocation() {
			for (String location : this.locations) {
				try {
					lookup(location);
					return location;
				}
				catch (NamingException ex) {
					// Swallow and continue
				}
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.LOWEST_PRECEDENCE)
class OnBeanCondition extends FilteringSpringBootCondition implements ConfigurationCondition {
	@Override
	public ConfigurationPhase getConfigurationPhase() {
		return ConfigurationPhase.REGISTER_BEAN;
	}
	@Override
	protected final ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,
			AutoConfigurationMetadata autoConfigurationMetadata) {
		ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length];
		for (int i = 0; i < outcomes.length; i++) {
			String autoConfigurationClass = autoConfigurationClasses[i];
			if (autoConfigurationClass != null) {
				Set<String> onBeanTypes = autoConfigurationMetadata.getSet(autoConfigurationClass, 'ConditionalOnBean');
				outcomes[i] = getOutcome(onBeanTypes, ConditionalOnBean.class);
				if (outcomes[i] == null) {
					Set<String> onSingleCandidateTypes = autoConfigurationMetadata.getSet(autoConfigurationClass,
							'ConditionalOnSingleCandidate');
					outcomes[i] = getOutcome(onSingleCandidateTypes, ConditionalOnSingleCandidate.class);
				}
			}
		}
		return outcomes;
	}
	private ConditionOutcome getOutcome(Set<String> requiredBeanTypes, Class<? extends Annotation> annotation) {
		List<String> missing = filter(requiredBeanTypes, ClassNameFilter.MISSING, getBeanClassLoader());
		if (!missing.isEmpty()) {
			ConditionMessage message = ConditionMessage.forCondition(annotation)
				.didNotFind('required type', 'required types')
				.items(Style.QUOTE, missing);
			return ConditionOutcome.noMatch(message);
		}
		return null;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionOutcome matchOutcome = ConditionOutcome.match();
		MergedAnnotations annotations = metadata.getAnnotations();
		if (annotations.isPresent(ConditionalOnBean.class)) {
			Spec<ConditionalOnBean> spec = new Spec<>(context, metadata, annotations, ConditionalOnBean.class);
			matchOutcome = evaluateConditionalOnBean(spec, matchOutcome.getConditionMessage());
			if (!matchOutcome.isMatch()) {
				return matchOutcome;
			}
		}
		if (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) {
			Spec<ConditionalOnSingleCandidate> spec = new SingleCandidateSpec(context, metadata,
					metadata.getAnnotations());
			matchOutcome = evaluateConditionalOnSingleCandidate(spec, matchOutcome.getConditionMessage());
			if (!matchOutcome.isMatch()) {
				return matchOutcome;
			}
		}
		if (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) {
			Spec<ConditionalOnMissingBean> spec = new Spec<>(context, metadata, annotations,
					ConditionalOnMissingBean.class);
			matchOutcome = evaluateConditionalOnMissingBean(spec, matchOutcome.getConditionMessage());
			if (!matchOutcome.isMatch()) {
				return matchOutcome;
			}
		}
		return matchOutcome;
	}
	private ConditionOutcome evaluateConditionalOnBean(Spec<ConditionalOnBean> spec, ConditionMessage matchMessage) {
		MatchResult matchResult = getMatchingBeans(spec);
		if (!matchResult.isAllMatched()) {
			String reason = createOnBeanNoMatchReason(matchResult);
			return ConditionOutcome.noMatch(spec.message().because(reason));
		}
		return ConditionOutcome.match(spec.message(matchMessage)
			.found('bean', 'beans')
			.items(Style.QUOTE, matchResult.getNamesOfAllMatches()));
	}
	private ConditionOutcome evaluateConditionalOnSingleCandidate(Spec<ConditionalOnSingleCandidate> spec,
			ConditionMessage matchMessage) {
		MatchResult matchResult = getMatchingBeans(spec);
		if (!matchResult.isAllMatched()) {
			return ConditionOutcome.noMatch(spec.message().didNotFind('any beans').atAll());
		}
		Set<String> allBeans = matchResult.getNamesOfAllMatches();
		if (allBeans.size() == 1) {
			return ConditionOutcome
				.match(spec.message(matchMessage).found('a single bean').items(Style.QUOTE, allBeans));
		}
		Map<String, BeanDefinition> beanDefinitions = getBeanDefinitions(spec.context.getBeanFactory(), allBeans,
				spec.getStrategy() == SearchStrategy.ALL);
		List<String> primaryBeans = getPrimaryBeans(beanDefinitions);
		if (primaryBeans.size() == 1) {
			return ConditionOutcome.match(spec.message(matchMessage)
				.found('a single primary bean "' + primaryBeans.get(0) + '" from beans')
				.items(Style.QUOTE, allBeans));
		}
		if (primaryBeans.size() > 1) {
			return ConditionOutcome
				.noMatch(spec.message().found('multiple primary beans').items(Style.QUOTE, primaryBeans));
		}
		List<String> nonFallbackBeans = getNonFallbackBeans(beanDefinitions);
		if (nonFallbackBeans.size() == 1) {
			return ConditionOutcome.match(spec.message(matchMessage)
				.found('a single non-fallback bean "' + nonFallbackBeans.get(0) + '" from beans')
				.items(Style.QUOTE, allBeans));
		}
		return ConditionOutcome.noMatch(spec.message().found('multiple beans').items(Style.QUOTE, allBeans));
	}
	private ConditionOutcome evaluateConditionalOnMissingBean(Spec<ConditionalOnMissingBean> spec,
			ConditionMessage matchMessage) {
		MatchResult matchResult = getMatchingBeans(spec);
		if (matchResult.isAnyMatched()) {
			String reason = createOnMissingBeanNoMatchReason(matchResult);
			return ConditionOutcome.noMatch(spec.message().because(reason));
		}
		return ConditionOutcome.match(spec.message(matchMessage).didNotFind('any beans').atAll());
	}
	protected final MatchResult getMatchingBeans(Spec<?> spec) {
		ClassLoader classLoader = spec.getContext().getClassLoader();
		ConfigurableListableBeanFactory beanFactory = spec.getContext().getBeanFactory();
		boolean considerHierarchy = spec.getStrategy() != SearchStrategy.CURRENT;
		Set<Class<?>> parameterizedContainers = spec.getParameterizedContainers();
		if (spec.getStrategy() == SearchStrategy.ANCESTORS) {
			BeanFactory parent = beanFactory.getParentBeanFactory();
			Assert.isInstanceOf(ConfigurableListableBeanFactory.class, parent,
					'Unable to use SearchStrategy.ANCESTORS');
			beanFactory = (ConfigurableListableBeanFactory) parent;
		}
		MatchResult result = new MatchResult();
		Set<String> beansIgnoredByType = getNamesOfBeansIgnoredByType(classLoader, beanFactory, considerHierarchy,
				spec.getIgnoredTypes(), parameterizedContainers);
		for (String type : spec.getTypes()) {
			Map<String, BeanDefinition> typeMatchedDefinitions = getBeanDefinitionsForType(classLoader,
					considerHierarchy, beanFactory, type, parameterizedContainers);
			Set<String> typeMatchedNames = matchedNamesFrom(typeMatchedDefinitions,
					(name, definition) -> isCandidate(name, definition, beansIgnoredByType)
							&& !ScopedProxyUtils.isScopedTarget(name));
			if (typeMatchedNames.isEmpty()) {
				result.recordUnmatchedType(type);
			}
			else {
				result.recordMatchedType(type, typeMatchedNames);
			}
		}
		for (String annotation : spec.getAnnotations()) {
			Map<String, BeanDefinition> annotationMatchedDefinitions = getBeanDefinitionsForAnnotation(classLoader,
					beanFactory, annotation, considerHierarchy);
			Set<String> annotationMatchedNames = matchedNamesFrom(annotationMatchedDefinitions,
					(name, definition) -> isCandidate(name, definition, beansIgnoredByType));
			if (annotationMatchedNames.isEmpty()) {
				result.recordUnmatchedAnnotation(annotation);
			}
			else {
				result.recordMatchedAnnotation(annotation, annotationMatchedNames);
			}
		}
		for (String beanName : spec.getNames()) {
			if (!beansIgnoredByType.contains(beanName) && containsBean(beanFactory, beanName, considerHierarchy)) {
				result.recordMatchedName(beanName);
			}
			else {
				result.recordUnmatchedName(beanName);
			}
		}
		return result;
	}
	private Set<String> matchedNamesFrom(Map<String, BeanDefinition> namedDefinitions,
			BiPredicate<String, BeanDefinition> filter) {
		Set<String> matchedNames = new LinkedHashSet<>(namedDefinitions.size());
		for (Entry<String, BeanDefinition> namedDefinition : namedDefinitions.entrySet()) {
			if (filter.test(namedDefinition.getKey(), namedDefinition.getValue())) {
				matchedNames.add(namedDefinition.getKey());
			}
		}
		return matchedNames;
	}
	private boolean isCandidate(String name, BeanDefinition definition, Set<String> ignoredBeans) {
		return (!ignoredBeans.contains(name))
				&& (definition == null || (definition.isAutowireCandidate() && isDefaultCandidate(definition)));
	}
	private boolean isDefaultCandidate(BeanDefinition definition) {
		if (definition instanceof AbstractBeanDefinition abstractBeanDefinition) {
			return abstractBeanDefinition.isDefaultCandidate();
		}
		return true;
	}
	private Set<String> getNamesOfBeansIgnoredByType(ClassLoader classLoader, ListableBeanFactory beanFactory,
			boolean considerHierarchy, Set<String> ignoredTypes, Set<Class<?>> parameterizedContainers) {
		Set<String> result = null;
		for (String ignoredType : ignoredTypes) {
			Collection<String> ignoredNames = getBeanDefinitionsForType(classLoader, considerHierarchy, beanFactory,
					ignoredType, parameterizedContainers)
				.keySet();
			result = addAll(result, ignoredNames);
		}
		return (result != null) ? result : Collections.emptySet();
	}
	private Map<String, BeanDefinition> getBeanDefinitionsForType(ClassLoader classLoader, boolean considerHierarchy,
			ListableBeanFactory beanFactory, String type, Set<Class<?>> parameterizedContainers) throws LinkageError {
		try {
			return getBeanDefinitionsForType(beanFactory, considerHierarchy, resolve(type, classLoader),
					parameterizedContainers);
		}
		catch (ClassNotFoundException | NoClassDefFoundError ex) {
			return Collections.emptyMap();
		}
	}
	private Map<String, BeanDefinition> getBeanDefinitionsForType(ListableBeanFactory beanFactory,
			boolean considerHierarchy, Class<?> type, Set<Class<?>> parameterizedContainers) {
		Map<String, BeanDefinition> result = collectBeanDefinitionsForType(beanFactory, considerHierarchy, type,
				parameterizedContainers, null);
		return (result != null) ? result : Collections.emptyMap();
	}
	private Map<String, BeanDefinition> collectBeanDefinitionsForType(ListableBeanFactory beanFactory,
			boolean considerHierarchy, Class<?> type, Set<Class<?>> parameterizedContainers,
			Map<String, BeanDefinition> result) {
		result = putAll(result, beanFactory.getBeanNamesForType(type, true, false), beanFactory);
		for (Class<?> container : parameterizedContainers) {
			ResolvableType generic = ResolvableType.forClassWithGenerics(container, type);
			result = putAll(result, beanFactory.getBeanNamesForType(generic, true, false), beanFactory);
		}
		if (considerHierarchy && beanFactory instanceof HierarchicalBeanFactory hierarchicalBeanFactory) {
			BeanFactory parent = hierarchicalBeanFactory.getParentBeanFactory();
			if (parent instanceof ListableBeanFactory listableBeanFactory) {
				result = collectBeanDefinitionsForType(listableBeanFactory, considerHierarchy, type,
						parameterizedContainers, result);
			}
		}
		return result;
	}
	private Map<String, BeanDefinition> getBeanDefinitionsForAnnotation(ClassLoader classLoader,
			ConfigurableListableBeanFactory beanFactory, String type, boolean considerHierarchy) throws LinkageError {
		Map<String, BeanDefinition> result = null;
		try {
			result = collectBeanDefinitionsForAnnotation(beanFactory, resolveAnnotationType(classLoader, type),
					considerHierarchy, result);
		}
		catch (ClassNotFoundException ex) {
			// Continue
		}
		return (result != null) ? result : Collections.emptyMap();
	}
	@SuppressWarnings('unchecked')
	private Class<? extends Annotation> resolveAnnotationType(ClassLoader classLoader, String type)
			throws ClassNotFoundException {
		return (Class<? extends Annotation>) resolve(type, classLoader);
	}
	private Map<String, BeanDefinition> collectBeanDefinitionsForAnnotation(ListableBeanFactory beanFactory,
			Class<? extends Annotation> annotationType, boolean considerHierarchy, Map<String, BeanDefinition> result) {
		result = putAll(result, getBeanNamesForAnnotation(beanFactory, annotationType), beanFactory);
		if (considerHierarchy) {
			BeanFactory parent = ((HierarchicalBeanFactory) beanFactory).getParentBeanFactory();
			if (parent instanceof ListableBeanFactory listableBeanFactory) {
				result = collectBeanDefinitionsForAnnotation(listableBeanFactory, annotationType, considerHierarchy,
						result);
			}
		}
		return result;
	}
	private String[] getBeanNamesForAnnotation(ListableBeanFactory beanFactory,
			Class<? extends Annotation> annotationType) {
		Set<String> foundBeanNames = new LinkedHashSet<>();
		for (String beanName : beanFactory.getBeanDefinitionNames()) {
			if (beanFactory instanceof ConfigurableListableBeanFactory configurableListableBeanFactory) {
				BeanDefinition beanDefinition = configurableListableBeanFactory.getBeanDefinition(beanName);
				if (beanDefinition != null && beanDefinition.isAbstract()) {
					continue;
				}
			}
			if (beanFactory.findAnnotationOnBean(beanName, annotationType, false) != null) {
				foundBeanNames.add(beanName);
			}
		}
		if (beanFactory instanceof SingletonBeanRegistry singletonBeanRegistry) {
			for (String beanName : singletonBeanRegistry.getSingletonNames()) {
				if (beanFactory.findAnnotationOnBean(beanName, annotationType) != null) {
					foundBeanNames.add(beanName);
				}
			}
		}
		return foundBeanNames.toArray(String[]::new);
	}
	private boolean containsBean(ConfigurableListableBeanFactory beanFactory, String beanName,
			boolean considerHierarchy) {
		if (considerHierarchy) {
			return beanFactory.containsBean(beanName);
		}
		return beanFactory.containsLocalBean(beanName);
	}
	private String createOnBeanNoMatchReason(MatchResult matchResult) {
		StringBuilder reason = new StringBuilder();
		appendMessageForNoMatches(reason, matchResult.getUnmatchedAnnotations(), 'annotated with');
		appendMessageForNoMatches(reason, matchResult.getUnmatchedTypes(), 'of type');
		appendMessageForNoMatches(reason, matchResult.getUnmatchedNames(), 'named');
		return reason.toString();
	}
	private void appendMessageForNoMatches(StringBuilder reason, Collection<String> unmatched, String description) {
		if (!unmatched.isEmpty()) {
			if (!reason.isEmpty()) {
				reason.append(' and ');
			}
			reason.append('did not find any beans ');
			reason.append(description);
			reason.append(' ');
			reason.append(StringUtils.collectionToDelimitedString(unmatched, ', '));
		}
	}
	private String createOnMissingBeanNoMatchReason(MatchResult matchResult) {
		StringBuilder reason = new StringBuilder();
		appendMessageForMatches(reason, matchResult.getMatchedAnnotations(), 'annotated with');
		appendMessageForMatches(reason, matchResult.getMatchedTypes(), 'of type');
		if (!matchResult.getMatchedNames().isEmpty()) {
			if (!reason.isEmpty()) {
				reason.append(' and ');
			}
			reason.append('found beans named ');
			reason.append(StringUtils.collectionToDelimitedString(matchResult.getMatchedNames(), ', '));
		}
		return reason.toString();
	}
	private void appendMessageForMatches(StringBuilder reason, Map<String, Collection<String>> matches,
			String description) {
		if (!matches.isEmpty()) {
			matches.forEach((key, value) -> {
				if (!reason.isEmpty()) {
					reason.append(' and ');
				}
				reason.append('found beans ');
				reason.append(description);
				reason.append(' "');
				reason.append(key);
				reason.append('" ');
				reason.append(StringUtils.collectionToDelimitedString(value, ', '));
			});
		}
	}
	private Map<String, BeanDefinition> getBeanDefinitions(ConfigurableListableBeanFactory beanFactory,
			Set<String> beanNames, boolean considerHierarchy) {
		Map<String, BeanDefinition> definitions = new HashMap<>(beanNames.size());
		for (String beanName : beanNames) {
			BeanDefinition beanDefinition = findBeanDefinition(beanFactory, beanName, considerHierarchy);
			definitions.put(beanName, beanDefinition);
		}
		return definitions;
	}
	private List<String> getPrimaryBeans(Map<String, BeanDefinition> beanDefinitions) {
		return getMatchingBeans(beanDefinitions, BeanDefinition::isPrimary);
	}
	private List<String> getNonFallbackBeans(Map<String, BeanDefinition> beanDefinitions) {
		return getMatchingBeans(beanDefinitions, Predicate.not(BeanDefinition::isFallback));
	}
	private List<String> getMatchingBeans(Map<String, BeanDefinition> beanDefinitions, Predicate<BeanDefinition> test) {
		List<String> matches = new ArrayList<>();
		for (Entry<String, BeanDefinition> namedBeanDefinition : beanDefinitions.entrySet()) {
			if (test.test(namedBeanDefinition.getValue())) {
				matches.add(namedBeanDefinition.getKey());
			}
		}
		return matches;
	}
	private BeanDefinition findBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName,
			boolean considerHierarchy) {
		if (beanFactory.containsBeanDefinition(beanName)) {
			return beanFactory.getBeanDefinition(beanName);
		}
		if (considerHierarchy
				&& beanFactory.getParentBeanFactory() instanceof ConfigurableListableBeanFactory listableBeanFactory) {
			return findBeanDefinition(listableBeanFactory, beanName, considerHierarchy);
		}
		return null;
	}
	private static Set<String> addAll(Set<String> result, Collection<String> additional) {
		if (CollectionUtils.isEmpty(additional)) {
			return result;
		}
		result = (result != null) ? result : new LinkedHashSet<>();
		result.addAll(additional);
		return result;
	}
	private static Map<String, BeanDefinition> putAll(Map<String, BeanDefinition> result, String[] beanNames,
			ListableBeanFactory beanFactory) {
		if (ObjectUtils.isEmpty(beanNames)) {
			return result;
		}
		if (result == null) {
			result = new LinkedHashMap<>();
		}
		for (String beanName : beanNames) {
			if (beanFactory instanceof ConfigurableListableBeanFactory clbf) {
				try {
					result.put(beanName, clbf.getBeanDefinition(beanName));
				}
				catch (NoSuchBeanDefinitionException ex) {
					result.put(beanName, null);
				}
			}
			else {
				result.put(beanName, null);
			}
		}
		return result;
	}
	/**
	 * A search specification extracted from the underlying annotation.
	 */
	private static class Spec<A extends Annotation> {
		private final ConditionContext context;
		private final Class<? extends Annotation> annotationType;
		private final Set<String> names;
		private final Set<String> types;
		private final Set<String> annotations;
		private final Set<String> ignoredTypes;
		private final Set<Class<?>> parameterizedContainers;
		private final SearchStrategy strategy;
		Spec(ConditionContext context, AnnotatedTypeMetadata metadata, MergedAnnotations annotations,
				Class<A> annotationType) {
			MultiValueMap<String, Object> attributes = annotations.stream(annotationType)
				.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))
				.collect(MergedAnnotationCollectors.toMultiValueMap(Adapt.CLASS_TO_STRING));
			MergedAnnotation<A> annotation = annotations.get(annotationType);
			this.context = context;
			this.annotationType = annotationType;
			this.names = extract(attributes, 'name');
			this.annotations = extract(attributes, 'annotation');
			this.ignoredTypes = extract(attributes, 'ignored', 'ignoredType');
			this.parameterizedContainers = resolveWhenPossible(extract(attributes, 'parameterizedContainer'));
			this.strategy = annotation.getValue('search', SearchStrategy.class).orElse(null);
			Set<String> types = extractTypes(attributes);
			BeanTypeDeductionException deductionException = null;
			if (types.isEmpty() && this.names.isEmpty() && this.annotations.isEmpty()) {
				try {
					types = deducedBeanType(context, metadata);
				}
				catch (BeanTypeDeductionException ex) {
					deductionException = ex;
				}
			}
			this.types = types;
			validate(deductionException);
		}
		protected Set<String> extractTypes(MultiValueMap<String, Object> attributes) {
			return extract(attributes, 'value', 'type');
		}
		private Set<String> extract(MultiValueMap<String, Object> attributes, String... attributeNames) {
			if (attributes.isEmpty()) {
				return Collections.emptySet();
			}
			Set<String> result = new LinkedHashSet<>();
			for (String attributeName : attributeNames) {
				List<Object> values = attributes.getOrDefault(attributeName, Collections.emptyList());
				for (Object value : values) {
					if (value instanceof String[] stringArray) {
						merge(result, stringArray);
					}
					else if (value instanceof String string) {
						merge(result, string);
					}
				}
			}
			return result.isEmpty() ? Collections.emptySet() : result;
		}
		private void merge(Set<String> result, String... additional) {
			Collections.addAll(result, additional);
		}
		private Set<Class<?>> resolveWhenPossible(Set<String> classNames) {
			if (classNames.isEmpty()) {
				return Collections.emptySet();
			}
			Set<Class<?>> resolved = new LinkedHashSet<>(classNames.size());
			for (String className : classNames) {
				try {
					resolved.add(resolve(className, this.context.getClassLoader()));
				}
				catch (ClassNotFoundException | NoClassDefFoundError ex) {
					// Ignore
				}
			}
			return resolved;
		}
		protected void validate(BeanTypeDeductionException ex) {
			if (!hasAtLeastOneElement(getTypes(), getNames(), getAnnotations())) {
				String message = getAnnotationName() + ' did not specify a bean using type, name or annotation';
				if (ex == null) {
					throw new IllegalStateException(message);
				}
				throw new IllegalStateException(message + ' and the attempt to deduce the bean"s type failed', ex);
			}
		}
		private boolean hasAtLeastOneElement(Set<?>... sets) {
			for (Set<?> set : sets) {
				if (!set.isEmpty()) {
					return true;
				}
			}
			return false;
		}
		protected final String getAnnotationName() {
			return '@' + ClassUtils.getShortName(this.annotationType);
		}
		private Set<String> deducedBeanType(ConditionContext context, AnnotatedTypeMetadata metadata) {
			if (metadata instanceof MethodMetadata && metadata.isAnnotated(Bean.class.getName())) {
				return deducedBeanTypeForBeanMethod(context, (MethodMetadata) metadata);
			}
			return Collections.emptySet();
		}
		private Set<String> deducedBeanTypeForBeanMethod(ConditionContext context, MethodMetadata metadata) {
			try {
				Class<?> returnType = getReturnType(context, metadata);
				return Collections.singleton(returnType.getName());
			}
			catch (Throwable ex) {
				throw new BeanTypeDeductionException(metadata.getDeclaringClassName(), metadata.getMethodName(), ex);
			}
		}
		private Class<?> getReturnType(ConditionContext context, MethodMetadata metadata)
				throws ClassNotFoundException, LinkageError {
			// Safe to load at this point since we are in the REGISTER_BEAN phase
			ClassLoader classLoader = context.getClassLoader();
			Class<?> returnType = resolve(metadata.getReturnTypeName(), classLoader);
			if (isParameterizedContainer(returnType)) {
				returnType = getReturnTypeGeneric(metadata, classLoader);
			}
			return returnType;
		}
		private boolean isParameterizedContainer(Class<?> type) {
			for (Class<?> parameterizedContainer : this.parameterizedContainers) {
				if (parameterizedContainer.isAssignableFrom(type)) {
					return true;
				}
			}
			return false;
		}
		private Class<?> getReturnTypeGeneric(MethodMetadata metadata, ClassLoader classLoader)
				throws ClassNotFoundException, LinkageError {
			Class<?> declaringClass = resolve(metadata.getDeclaringClassName(), classLoader);
			Method beanMethod = findBeanMethod(declaringClass, metadata.getMethodName());
			return ResolvableType.forMethodReturnType(beanMethod).resolveGeneric();
		}
		private Method findBeanMethod(Class<?> declaringClass, String methodName) {
			Method method = ReflectionUtils.findMethod(declaringClass, methodName);
			if (isBeanMethod(method)) {
				return method;
			}
			Method[] candidates = ReflectionUtils.getAllDeclaredMethods(declaringClass);
			for (Method candidate : candidates) {
				if (candidate.getName().equals(methodName) && isBeanMethod(candidate)) {
					return candidate;
				}
			}
			throw new IllegalStateException('Unable to find bean method ' + methodName);
		}
		private boolean isBeanMethod(Method method) {
			return method != null && MergedAnnotations.from(method, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY)
				.isPresent(Bean.class);
		}
		private SearchStrategy getStrategy() {
			return (this.strategy != null) ? this.strategy : SearchStrategy.ALL;
		}
		private ConditionContext getContext() {
			return this.context;
		}
		private Set<String> getNames() {
			return this.names;
		}
		protected Set<String> getTypes() {
			return this.types;
		}
		private Set<String> getAnnotations() {
			return this.annotations;
		}
		private Set<String> getIgnoredTypes() {
			return this.ignoredTypes;
		}
		private Set<Class<?>> getParameterizedContainers() {
			return this.parameterizedContainers;
		}
		private ConditionMessage.Builder message() {
			return ConditionMessage.forCondition(this.annotationType, this);
		}
		private ConditionMessage.Builder message(ConditionMessage message) {
			return message.andCondition(this.annotationType, this);
		}
		@Override
		public String toString() {
			boolean hasNames = !this.names.isEmpty();
			boolean hasTypes = !this.types.isEmpty();
			boolean hasIgnoredTypes = !this.ignoredTypes.isEmpty();
			StringBuilder string = new StringBuilder();
			string.append('(');
			if (hasNames) {
				string.append('names: ');
				string.append(StringUtils.collectionToCommaDelimitedString(this.names));
				string.append(hasTypes ? ' ' : '; ');
			}
			if (hasTypes) {
				string.append('types: ');
				string.append(StringUtils.collectionToCommaDelimitedString(this.types));
				string.append(hasIgnoredTypes ? ' ' : '; ');
			}
			if (hasIgnoredTypes) {
				string.append('ignored: ');
				string.append(StringUtils.collectionToCommaDelimitedString(this.ignoredTypes));
				string.append('; ');
			}
			string.append('SearchStrategy: ');
			string.append(this.strategy.toString().toLowerCase(Locale.ENGLISH));
			string.append(')');
			return string.toString();
		}
	}
	/**
	 * Specialized {@link Spec specification} for
	 * {@link ConditionalOnSingleCandidate @ConditionalOnSingleCandidate}.
	 */
	private static class SingleCandidateSpec extends Spec<ConditionalOnSingleCandidate> {
		private static final Collection<String> FILTERED_TYPES = Arrays.asList('', Object.class.getName());
		SingleCandidateSpec(ConditionContext context, AnnotatedTypeMetadata metadata, MergedAnnotations annotations) {
			super(context, metadata, annotations, ConditionalOnSingleCandidate.class);
		}
		@Override
		protected Set<String> extractTypes(MultiValueMap<String, Object> attributes) {
			Set<String> types = super.extractTypes(attributes);
			types.removeAll(FILTERED_TYPES);
			return types;
		}
		@Override
		protected void validate(BeanTypeDeductionException ex) {
			Assert.isTrue(getTypes().size() == 1,
					() -> getAnnotationName() + ' annotations must specify only one type (got '
							+ StringUtils.collectionToCommaDelimitedString(getTypes()) + ')');
		}
	}
	/**
	 * Results collected during the condition evaluation.
	 */
	private static final class MatchResult {
		private final Map<String, Collection<String>> matchedAnnotations = new HashMap<>();
		private final List<String> matchedNames = new ArrayList<>();
		private final Map<String, Collection<String>> matchedTypes = new HashMap<>();
		private final List<String> unmatchedAnnotations = new ArrayList<>();
		private final List<String> unmatchedNames = new ArrayList<>();
		private final List<String> unmatchedTypes = new ArrayList<>();
		private final Set<String> namesOfAllMatches = new HashSet<>();
		private void recordMatchedName(String name) {
			this.matchedNames.add(name);
			this.namesOfAllMatches.add(name);
		}
		private void recordUnmatchedName(String name) {
			this.unmatchedNames.add(name);
		}
		private void recordMatchedAnnotation(String annotation, Collection<String> matchingNames) {
			this.matchedAnnotations.put(annotation, matchingNames);
			this.namesOfAllMatches.addAll(matchingNames);
		}
		private void recordUnmatchedAnnotation(String annotation) {
			this.unmatchedAnnotations.add(annotation);
		}
		private void recordMatchedType(String type, Collection<String> matchingNames) {
			this.matchedTypes.put(type, matchingNames);
			this.namesOfAllMatches.addAll(matchingNames);
		}
		private void recordUnmatchedType(String type) {
			this.unmatchedTypes.add(type);
		}
		boolean isAllMatched() {
			return this.unmatchedAnnotations.isEmpty() && this.unmatchedNames.isEmpty()
					&& this.unmatchedTypes.isEmpty();
		}
		boolean isAnyMatched() {
			return (!this.matchedAnnotations.isEmpty()) || (!this.matchedNames.isEmpty())
					|| (!this.matchedTypes.isEmpty());
		}
		Map<String, Collection<String>> getMatchedAnnotations() {
			return this.matchedAnnotations;
		}
		List<String> getMatchedNames() {
			return this.matchedNames;
		}
		Map<String, Collection<String>> getMatchedTypes() {
			return this.matchedTypes;
		}
		List<String> getUnmatchedAnnotations() {
			return this.unmatchedAnnotations;
		}
		List<String> getUnmatchedNames() {
			return this.unmatchedNames;
		}
		List<String> getUnmatchedTypes() {
			return this.unmatchedTypes;
		}
		Set<String> getNamesOfAllMatches() {
			return this.namesOfAllMatches;
		}
	}
	/**
	 * Exception thrown when the bean type cannot be deduced.
	 */
	static final class BeanTypeDeductionException extends RuntimeException {
		private BeanTypeDeductionException(String className, String beanMethodName, Throwable cause) {
			super('Failed to deduce bean type for ' + className + '.' + beanMethodName, cause);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ConditionalOnClass(name = 'org.crac.Resource')
public @interface ConditionalOnCheckpointRestore {
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.LOWEST_PRECEDENCE - 20)
public abstract class AnyNestedCondition extends AbstractNestedCondition {
	public AnyNestedCondition(ConfigurationPhase configurationPhase) {
		super(configurationPhase);
	}
	@Override
	protected ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes) {
		boolean match = !memberOutcomes.getMatches().isEmpty();
		List<ConditionMessage> messages = new ArrayList<>();
		messages.add(ConditionMessage.forCondition('AnyNestedCondition')
			.because(memberOutcomes.getMatches().size() + ' matched ' + memberOutcomes.getNonMatches().size()
					+ ' did not'));
		for (ConditionOutcome outcome : memberOutcomes.getAll()) {
			messages.add(outcome.getConditionMessage());
		}
		return new ConditionOutcome(match, ConditionMessage.of(messages));
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public class OnPropertyListCondition extends SpringBootCondition {
	private static final Bindable<List<String>> STRING_LIST = Bindable.listOf(String.class);
	private final String propertyName;
	private final Supplier<ConditionMessage.Builder> messageBuilder;
	/**
	 * Create a new instance with the property to check and the message builder to use.
	 * @param propertyName the name of the property
	 * @param messageBuilder a message builder supplier that should provide a fresh
	 * instance on each call
	 */
	protected OnPropertyListCondition(String propertyName, Supplier<ConditionMessage.Builder> messageBuilder) {
		this.propertyName = propertyName;
		this.messageBuilder = messageBuilder;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		BindResult<?> property = Binder.get(context.getEnvironment()).bind(this.propertyName, STRING_LIST);
		ConditionMessage.Builder messageBuilder = this.messageBuilder.get();
		if (property.isBound()) {
			return ConditionOutcome.match(messageBuilder.found('property').items(this.propertyName));
		}
		return ConditionOutcome.noMatch(messageBuilder.didNotFind('property').items(this.propertyName));
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.HIGHEST_PRECEDENCE + 20)
class OnResourceCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		MultiValueMap<String, Object> attributes = metadata
			.getAllAnnotationAttributes(ConditionalOnResource.class.getName(), true);
		ResourceLoader loader = context.getResourceLoader();
		List<String> locations = new ArrayList<>();
		collectValues(locations, attributes.get('resources'));
		Assert.isTrue(!locations.isEmpty(),
				'@ConditionalOnResource annotations must specify at least one resource location');
		List<String> missing = new ArrayList<>();
		for (String location : locations) {
			String resource = context.getEnvironment().resolvePlaceholders(location);
			if (!loader.getResource(resource).exists()) {
				missing.add(location);
			}
		}
		if (!missing.isEmpty()) {
			return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnResource.class)
				.didNotFind('resource', 'resources')
				.items(Style.QUOTE, missing));
		}
		return ConditionOutcome.match(ConditionMessage.forCondition(ConditionalOnResource.class)
			.found('location', 'locations')
			.items(locations));
	}
	private void collectValues(List<String> names, List<Object> values) {
		for (Object value : values) {
			for (Object item : (Object[]) value) {
				names.add((String) item);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public abstract class ResourceCondition extends SpringBootCondition {
	private final String name;
	private final String property;
	private final String[] resourceLocations;
	/**
	 * Create a new condition.
	 * @param name the name of the component
	 * @param property the configuration property
	 * @param resourceLocations default location(s) where the configuration file can be
	 * found if the configuration key is not specified
	 * @since 2.0.0
	 */
	protected ResourceCondition(String name, String property, String... resourceLocations) {
		this.name = name;
		this.property = property;
		this.resourceLocations = resourceLocations;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		if (context.getEnvironment().containsProperty(this.property)) {
			return ConditionOutcome.match(startConditionMessage().foundExactly('property ' + this.property));
		}
		return getResourceOutcome(context, metadata);
	}
	/**
	 * Check if one of the default resource locations actually exists.
	 * @param context the condition context
	 * @param metadata the annotation metadata
	 * @return the condition outcome
	 */
	protected ConditionOutcome getResourceOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		List<String> found = new ArrayList<>();
		for (String location : this.resourceLocations) {
			Resource resource = context.getResourceLoader().getResource(location);
			if (resource != null && resource.exists()) {
				found.add(location);
			}
		}
		if (found.isEmpty()) {
			ConditionMessage message = startConditionMessage().didNotFind('resource', 'resources')
				.items(Style.QUOTE, Arrays.asList(this.resourceLocations));
			return ConditionOutcome.noMatch(message);
		}
		ConditionMessage message = startConditionMessage().found('resource', 'resources').items(Style.QUOTE, found);
		return ConditionOutcome.match(message);
	}
	protected final Builder startConditionMessage() {
		return ConditionMessage.forCondition('ResourceCondition', '(' + this.name + ')');
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionEvaluationReportAutoConfigurationImportListener
		implements AutoConfigurationImportListener, BeanFactoryAware {
	private ConfigurableListableBeanFactory beanFactory;
	@Override
	public void onAutoConfigurationImportEvent(AutoConfigurationImportEvent event) {
		if (this.beanFactory != null) {
			ConditionEvaluationReport report = ConditionEvaluationReport.get(this.beanFactory);
			report.recordEvaluationCandidates(event.getCandidateConfigurations());
			report.recordExclusions(event.getExclusions());
		}
	}
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		this.beanFactory = (beanFactory instanceof ConfigurableListableBeanFactory listableBeanFactory)
				? listableBeanFactory : null;
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnPropertyCondition.class)
public @interface ConditionalOnProperty {
	/**
	 * Alias for {@link #name()}.
	 * @return the names
	 */
	String[] value() default {};
	/**
	 * A prefix that should be applied to each property. The prefix automatically ends
	 * with a dot if not specified. A valid prefix is defined by one or more words
	 * separated with dots (e.g. {@code 'acme.system.feature'}).
	 * @return the prefix
	 */
	String prefix() default '';
	/**
	 * The name of the properties to test. If a prefix has been defined, it is applied to
	 * compute the full key of each property. For instance if the prefix is
	 * {@code app.config} and one value is {@code my-value}, the full key would be
	 * {@code app.config.my-value}
	 * <p>
	 * Use the dashed notation to specify each property, that is all lower case with a '-'
	 * to separate words (e.g. {@code my-long-property}).
	 * <p>
	 * If multiple names are specified, all of the properties have to pass the test for
	 * the condition to match.
	 * @return the names
	 */
	String[] name() default {};
	/**
	 * The string representation of the expected value for the properties. If not
	 * specified, the property must <strong>not</strong> be equal to {@code false}.
	 * @return the expected value
	 */
	String havingValue() default '';
	/**
	 * Specify if the condition should match if the property is not set. Defaults to
	 * {@code false}.
	 * @return if the condition should match if the property is missing
	 */
	boolean matchIfMissing() default false;
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public final class ConditionMessage {
	private final String message;
	private ConditionMessage() {
		this(null);
	}
	private ConditionMessage(String message) {
		this.message = message;
	}
	private ConditionMessage(ConditionMessage prior, String message) {
		this.message = prior.isEmpty() ? message : prior + '; ' + message;
	}
	/**
	 * Return {@code true} if the message is empty.
	 * @return if the message is empty
	 */
	public boolean isEmpty() {
		return !StringUtils.hasLength(this.message);
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj instanceof ConditionMessage other) {
			return ObjectUtils.nullSafeEquals(other.message, this.message);
		}
		return false;
	}
	@Override
	public int hashCode() {
		return ObjectUtils.nullSafeHashCode(this.message);
	}
	@Override
	public String toString() {
		return (this.message != null) ? this.message : '';
	}
	/**
	 * Return a new {@link ConditionMessage} based on the instance and an appended
	 * message.
	 * @param message the message to append
	 * @return a new {@link ConditionMessage} instance
	 */
	public ConditionMessage append(String message) {
		if (!StringUtils.hasLength(message)) {
			return this;
		}
		if (!StringUtils.hasLength(this.message)) {
			return new ConditionMessage(message);
		}
		return new ConditionMessage(this.message + ' ' + message);
	}
	/**
	 * Return a new builder to construct a new {@link ConditionMessage} based on the
	 * instance and a new condition outcome.
	 * @param condition the condition
	 * @param details details of the condition
	 * @return a {@link Builder} builder
	 * @see #andCondition(String, Object...)
	 * @see #forCondition(Class, Object...)
	 */
	public Builder andCondition(Class<? extends Annotation> condition, Object... details) {
		Assert.notNull(condition, 'Condition must not be null');
		return andCondition('@' + ClassUtils.getShortName(condition), details);
	}
	/**
	 * Return a new builder to construct a new {@link ConditionMessage} based on the
	 * instance and a new condition outcome.
	 * @param condition the condition
	 * @param details details of the condition
	 * @return a {@link Builder} builder
	 * @see #andCondition(Class, Object...)
	 * @see #forCondition(String, Object...)
	 */
	public Builder andCondition(String condition, Object... details) {
		Assert.notNull(condition, 'Condition must not be null');
		String detail = StringUtils.arrayToDelimitedString(details, ' ');
		if (StringUtils.hasLength(detail)) {
			return new Builder(condition + ' ' + detail);
		}
		return new Builder(condition);
	}
	/**
	 * Factory method to return a new empty {@link ConditionMessage}.
	 * @return a new empty {@link ConditionMessage}
	 */
	public static ConditionMessage empty() {
		return new ConditionMessage();
	}
	/**
	 * Factory method to create a new {@link ConditionMessage} with a specific message.
	 * @param message the source message (may be a format string if {@code args} are
	 * specified)
	 * @param args format arguments for the message
	 * @return a new {@link ConditionMessage} instance
	 */
	public static ConditionMessage of(String message, Object... args) {
		if (ObjectUtils.isEmpty(args)) {
			return new ConditionMessage(message);
		}
		return new ConditionMessage(String.format(message, args));
	}
	/**
	 * Factory method to create a new {@link ConditionMessage} comprised of the specified
	 * messages.
	 * @param messages the source messages (may be {@code null})
	 * @return a new {@link ConditionMessage} instance
	 */
	public static ConditionMessage of(Collection<? extends ConditionMessage> messages) {
		ConditionMessage result = new ConditionMessage();
		if (messages != null) {
			for (ConditionMessage message : messages) {
				result = new ConditionMessage(result, message.toString());
			}
		}
		return result;
	}
	/**
	 * Factory method for a builder to construct a new {@link ConditionMessage} for a
	 * condition.
	 * @param condition the condition
	 * @param details details of the condition
	 * @return a {@link Builder} builder
	 * @see #forCondition(String, Object...)
	 * @see #andCondition(String, Object...)
	 */
	public static Builder forCondition(Class<? extends Annotation> condition, Object... details) {
		return new ConditionMessage().andCondition(condition, details);
	}
	/**
	 * Factory method for a builder to construct a new {@link ConditionMessage} for a
	 * condition.
	 * @param condition the condition
	 * @param details details of the condition
	 * @return a {@link Builder} builder
	 * @see #forCondition(Class, Object...)
	 * @see #andCondition(String, Object...)
	 */
	public static Builder forCondition(String condition, Object... details) {
		return new ConditionMessage().andCondition(condition, details);
	}
	/**
	 * Builder used to create a {@link ConditionMessage} for a condition.
	 */
	public final class Builder {
		private final String condition;
		private Builder(String condition) {
			this.condition = condition;
		}
		/**
		 * Indicate that an exact result was found. For example
		 * {@code foundExactly('foo')} results in the message 'found foo'.
		 * @param result the result that was found
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage foundExactly(Object result) {
			return found('').items(result);
		}
		/**
		 * Indicate that one or more results were found. For example
		 * {@code found('bean').items('x')} results in the message 'found bean x'.
		 * @param article the article found
		 * @return an {@link ItemsBuilder}
		 */
		public ItemsBuilder found(String article) {
			return found(article, article);
		}
		/**
		 * Indicate that one or more results were found. For example
		 * {@code found('bean', 'beans').items('x', 'y')} results in the message 'found
		 * beans x, y'.
		 * @param singular the article found in singular form
		 * @param plural the article found in plural form
		 * @return an {@link ItemsBuilder}
		 */
		public ItemsBuilder found(String singular, String plural) {
			return new ItemsBuilder(this, 'found', singular, plural);
		}
		/**
		 * Indicate that one or more results were not found. For example
		 * {@code didNotFind('bean').items('x')} results in the message 'did not find bean
		 * x'.
		 * @param article the article found
		 * @return an {@link ItemsBuilder}
		 */
		public ItemsBuilder didNotFind(String article) {
			return didNotFind(article, article);
		}
		/**
		 * Indicate that one or more results were found. For example
		 * {@code didNotFind('bean', 'beans').items('x', 'y')} results in the message 'did
		 * not find beans x, y'.
		 * @param singular the article found in singular form
		 * @param plural the article found in plural form
		 * @return an {@link ItemsBuilder}
		 */
		public ItemsBuilder didNotFind(String singular, String plural) {
			return new ItemsBuilder(this, 'did not find', singular, plural);
		}
		/**
		 * Indicates a single result. For example {@code resultedIn('yes')} results in the
		 * message 'resulted in yes'.
		 * @param result the result
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage resultedIn(Object result) {
			return because('resulted in ' + result);
		}
		/**
		 * Indicates something is available. For example {@code available('money')}
		 * results in the message 'money is available'.
		 * @param item the item that is available
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage available(String item) {
			return because(item + ' is available');
		}
		/**
		 * Indicates something is not available. For example {@code notAvailable('time')}
		 * results in the message 'time is not available'.
		 * @param item the item that is not available
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage notAvailable(String item) {
			return because(item + ' is not available');
		}
		/**
		 * Indicates the reason. For example {@code because('running Linux')} results in
		 * the message 'running Linux'.
		 * @param reason the reason for the message
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage because(String reason) {
			if (StringUtils.hasLength(reason)) {
				return new ConditionMessage(ConditionMessage.this,
						StringUtils.hasLength(this.condition) ? this.condition + ' ' + reason : reason);
			}
			return new ConditionMessage(ConditionMessage.this, this.condition);
		}
	}
	/**
	 * Builder used to create an {@link ItemsBuilder} for a condition.
	 */
	public final class ItemsBuilder {
		private final Builder condition;
		private final String reason;
		private final String singular;
		private final String plural;
		private ItemsBuilder(Builder condition, String reason, String singular, String plural) {
			this.condition = condition;
			this.reason = reason;
			this.singular = singular;
			this.plural = plural;
		}
		/**
		 * Used when no items are available. For example
		 * {@code didNotFind('any beans').atAll()} results in the message 'did not find
		 * any beans'.
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage atAll() {
			return items(Collections.emptyList());
		}
		/**
		 * Indicate the items. For example
		 * {@code didNotFind('bean', 'beans').items('x', 'y')} results in the message 'did
		 * not find beans x, y'.
		 * @param items the items (may be {@code null})
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage items(Object... items) {
			return items(Style.NORMAL, items);
		}
		/**
		 * Indicate the items. For example
		 * {@code didNotFind('bean', 'beans').items('x', 'y')} results in the message 'did
		 * not find beans x, y'.
		 * @param style the render style
		 * @param items the items (may be {@code null})
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage items(Style style, Object... items) {
			return items(style, (items != null) ? Arrays.asList(items) : null);
		}
		/**
		 * Indicate the items. For example
		 * {@code didNotFind('bean', 'beans').items(Collections.singleton('x')} results in
		 * the message 'did not find bean x'.
		 * @param items the source of the items (may be {@code null})
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage items(Collection<?> items) {
			return items(Style.NORMAL, items);
		}
		/**
		 * Indicate the items with a {@link Style}. For example
		 * {@code didNotFind('bean', 'beans').items(Style.QUOTE, Collections.singleton('x')}
		 * results in the message 'did not find bean "x"'.
		 * @param style the render style
		 * @param items the source of the items (may be {@code null})
		 * @return a built {@link ConditionMessage}
		 */
		public ConditionMessage items(Style style, Collection<?> items) {
			Assert.notNull(style, 'Style must not be null');
			StringBuilder message = new StringBuilder(this.reason);
			items = style.applyTo(items);
			if ((this.condition == null || items == null || items.size() <= 1)
					&& StringUtils.hasLength(this.singular)) {
				message.append(' ').append(this.singular);
			}
			else if (StringUtils.hasLength(this.plural)) {
				message.append(' ').append(this.plural);
			}
			if (!CollectionUtils.isEmpty(items)) {
				message.append(' ').append(StringUtils.collectionToDelimitedString(items, ', '));
			}
			return this.condition.because(message.toString());
		}
	}
	/**
	 * Render styles.
	 */
	public enum Style {
		/**
		 * Render with normal styling.
		 */
		NORMAL {
			@Override
			protected Object applyToItem(Object item) {
				return item;
			}
		},
		/**
		 * Render with the item surrounded by quotes.
		 */
		QUOTE {
			@Override
			protected String applyToItem(Object item) {
				return (item != null) ? '"' + item + '"' : null;
			}
		};
		public Collection<?> applyTo(Collection<?> items) {
			if (items == null) {
				return null;
			}
			List<Object> result = new ArrayList<>(items.size());
			for (Object item : items) {
				result.add(applyToItem(item));
			}
			return result;
		}
		protected abstract Object applyToItem(Object item);
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnWarDeploymentCondition.class)
public @interface ConditionalOnWarDeployment {
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public class ConditionOutcome {
	private final boolean match;
	private final ConditionMessage message;
	/**
	 * Create a new {@link ConditionOutcome} instance. For more consistent messages
	 * consider using {@link #ConditionOutcome(boolean, ConditionMessage)}.
	 * @param match if the condition is a match
	 * @param message the condition message
	 */
	public ConditionOutcome(boolean match, String message) {
		this(match, ConditionMessage.of(message));
	}
	/**
	 * Create a new {@link ConditionOutcome} instance.
	 * @param match if the condition is a match
	 * @param message the condition message
	 */
	public ConditionOutcome(boolean match, ConditionMessage message) {
		Assert.notNull(message, 'ConditionMessage must not be null');
		this.match = match;
		this.message = message;
	}
	/**
	 * Create a new {@link ConditionOutcome} instance for a "match".
	 * @return the {@link ConditionOutcome}
	 */
	public static ConditionOutcome match() {
		return match(ConditionMessage.empty());
	}
	/**
	 * Create a new {@link ConditionOutcome} instance for "match". For more consistent
	 * messages consider using {@link #match(ConditionMessage)}.
	 * @param message the message
	 * @return the {@link ConditionOutcome}
	 */
	public static ConditionOutcome match(String message) {
		return new ConditionOutcome(true, message);
	}
	/**
	 * Create a new {@link ConditionOutcome} instance for "match".
	 * @param message the message
	 * @return the {@link ConditionOutcome}
	 */
	public static ConditionOutcome match(ConditionMessage message) {
		return new ConditionOutcome(true, message);
	}
	/**
	 * Create a new {@link ConditionOutcome} instance for "no match". For more consistent
	 * messages consider using {@link #noMatch(ConditionMessage)}.
	 * @param message the message
	 * @return the {@link ConditionOutcome}
	 */
	public static ConditionOutcome noMatch(String message) {
		return new ConditionOutcome(false, message);
	}
	/**
	 * Create a new {@link ConditionOutcome} instance for "no match".
	 * @param message the message
	 * @return the {@link ConditionOutcome}
	 */
	public static ConditionOutcome noMatch(ConditionMessage message) {
		return new ConditionOutcome(false, message);
	}
	/**
	 * Return {@code true} if the outcome was a match.
	 * @return {@code true} if the outcome matches
	 */
	public boolean isMatch() {
		return this.match;
	}
	/**
	 * Return an outcome message or {@code null}.
	 * @return the message or {@code null}
	 */
	public String getMessage() {
		return this.message.isEmpty() ? null : this.message.toString();
	}
	/**
	 * Return an outcome message or {@code null}.
	 * @return the message or {@code null}
	 */
	public ConditionMessage getConditionMessage() {
		return this.message;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() == obj.getClass()) {
			ConditionOutcome other = (ConditionOutcome) obj;
			return (this.match == other.match && ObjectUtils.nullSafeEquals(this.message, other.message));
		}
		return super.equals(obj);
	}
	@Override
	public int hashCode() {
		return Boolean.hashCode(this.match) * 31 + ObjectUtils.nullSafeHashCode(this.message);
	}
	@Override
	public String toString() {
		return (this.message != null) ? this.message.toString() : '';
	}
	/**
	 * Return the inverse of the specified condition outcome.
	 * @param outcome the outcome to inverse
	 * @return the inverse of the condition outcome
	 * @since 1.3.0
	 */
	public static ConditionOutcome inverse(ConditionOutcome outcome) {
		return new ConditionOutcome(!outcome.isMatch(), outcome.getConditionMessage());
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnClassCondition.class)
public @interface ConditionalOnClass {
	/**
	 * The classes that must be present. Since this annotation is parsed by loading class
	 * bytecode, it is safe to specify classes here that may ultimately not be on the
	 * classpath, only if this annotation is directly on the affected component and
	 * <b>not</b> if this annotation is used as a composed, meta-annotation. In order to
	 * use this annotation as a meta-annotation, only use the {@link #name} attribute.
	 * @return the classes that must be present
	 */
	Class<?>[] value() default {};
	/**
	 * The classes names that must be present.
	 * @return the class names that must be present.
	 */
	String[] name() default {};
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnClassCondition.class)
public @interface ConditionalOnMissingClass {
	/**
	 * The names of the classes that must not be present.
	 * @return the names of the classes that must not be present
	 */
	String[] value() default {};
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public abstract class NoneNestedConditions extends AbstractNestedCondition {
	public NoneNestedConditions(ConfigurationPhase configurationPhase) {
		super(configurationPhase);
	}
	@Override
	protected ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes) {
		boolean match = memberOutcomes.getMatches().isEmpty();
		List<ConditionMessage> messages = new ArrayList<>();
		messages.add(ConditionMessage.forCondition('NoneNestedConditions')
			.because(memberOutcomes.getMatches().size() + ' matched ' + memberOutcomes.getNonMatches().size()
					+ ' did not'));
		for (ConditionOutcome outcome : memberOutcomes.getAll()) {
			messages.add(outcome.getConditionMessage());
		}
		return new ConditionOutcome(match, ConditionMessage.of(messages));
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public abstract class AbstractNestedCondition extends SpringBootCondition implements ConfigurationCondition {
	private final ConfigurationPhase configurationPhase;
	AbstractNestedCondition(ConfigurationPhase configurationPhase) {
		Assert.notNull(configurationPhase, 'ConfigurationPhase must not be null');
		this.configurationPhase = configurationPhase;
	}
	@Override
	public ConfigurationPhase getConfigurationPhase() {
		return this.configurationPhase;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		String className = getClass().getName();
		MemberConditions memberConditions = new MemberConditions(context, this.configurationPhase, className);
		MemberMatchOutcomes memberOutcomes = new MemberMatchOutcomes(memberConditions);
		return getFinalMatchOutcome(memberOutcomes);
	}
	protected abstract ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes);
	protected static class MemberMatchOutcomes {
		private final List<ConditionOutcome> all;
		private final List<ConditionOutcome> matches;
		private final List<ConditionOutcome> nonMatches;
		public MemberMatchOutcomes(MemberConditions memberConditions) {
			this.all = Collections.unmodifiableList(memberConditions.getMatchOutcomes());
			List<ConditionOutcome> matches = new ArrayList<>();
			List<ConditionOutcome> nonMatches = new ArrayList<>();
			for (ConditionOutcome outcome : this.all) {
				(outcome.isMatch() ? matches : nonMatches).add(outcome);
			}
			this.matches = Collections.unmodifiableList(matches);
			this.nonMatches = Collections.unmodifiableList(nonMatches);
		}
		public List<ConditionOutcome> getAll() {
			return this.all;
		}
		public List<ConditionOutcome> getMatches() {
			return this.matches;
		}
		public List<ConditionOutcome> getNonMatches() {
			return this.nonMatches;
		}
	}
	private static class MemberConditions {
		private final ConditionContext context;
		private final MetadataReaderFactory readerFactory;
		private final Map<AnnotationMetadata, List<Condition>> memberConditions;
		MemberConditions(ConditionContext context, ConfigurationPhase phase, String className) {
			this.context = context;
			this.readerFactory = new SimpleMetadataReaderFactory(context.getResourceLoader());
			String[] members = getMetadata(className).getMemberClassNames();
			this.memberConditions = getMemberConditions(members, phase, className);
		}
		private Map<AnnotationMetadata, List<Condition>> getMemberConditions(String[] members, ConfigurationPhase phase,
				String className) {
			MultiValueMap<AnnotationMetadata, Condition> memberConditions = new LinkedMultiValueMap<>();
			for (String member : members) {
				AnnotationMetadata metadata = getMetadata(member);
				for (String[] conditionClasses : getConditionClasses(metadata)) {
					for (String conditionClass : conditionClasses) {
						Condition condition = getCondition(conditionClass);
						validateMemberCondition(condition, phase, className);
						memberConditions.add(metadata, condition);
					}
				}
			}
			return Collections.unmodifiableMap(memberConditions);
		}
		private void validateMemberCondition(Condition condition, ConfigurationPhase nestedPhase,
				String nestedClassName) {
			if (nestedPhase == ConfigurationPhase.PARSE_CONFIGURATION
					&& condition instanceof ConfigurationCondition configurationCondition) {
				ConfigurationPhase memberPhase = configurationCondition.getConfigurationPhase();
				if (memberPhase == ConfigurationPhase.REGISTER_BEAN) {
					throw new IllegalStateException('Nested condition ' + nestedClassName + ' uses a configuration '
							+ 'phase that is inappropriate for ' + condition.getClass());
				}
			}
		}
		private AnnotationMetadata getMetadata(String className) {
			try {
				return this.readerFactory.getMetadataReader(className).getAnnotationMetadata();
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
		@SuppressWarnings('unchecked')
		private List<String[]> getConditionClasses(AnnotatedTypeMetadata metadata) {
			MultiValueMap<String, Object> attributes = metadata.getAllAnnotationAttributes(Conditional.class.getName(),
					true);
			Object values = (attributes != null) ? attributes.get('value') : null;
			return (List<String[]>) ((values != null) ? values : Collections.emptyList());
		}
		private Condition getCondition(String conditionClassName) {
			Class<?> conditionClass = ClassUtils.resolveClassName(conditionClassName, this.context.getClassLoader());
			return (Condition) BeanUtils.instantiateClass(conditionClass);
		}
		List<ConditionOutcome> getMatchOutcomes() {
			List<ConditionOutcome> outcomes = new ArrayList<>();
			this.memberConditions.forEach((metadata, conditions) -> outcomes
				.add(new MemberOutcomes(this.context, metadata, conditions).getUltimateOutcome()));
			return Collections.unmodifiableList(outcomes);
		}
	}
	private static class MemberOutcomes {
		private final ConditionContext context;
		private final AnnotationMetadata metadata;
		private final List<ConditionOutcome> outcomes;
		MemberOutcomes(ConditionContext context, AnnotationMetadata metadata, List<Condition> conditions) {
			this.context = context;
			this.metadata = metadata;
			this.outcomes = new ArrayList<>(conditions.size());
			for (Condition condition : conditions) {
				this.outcomes.add(getConditionOutcome(metadata, condition));
			}
		}
		private ConditionOutcome getConditionOutcome(AnnotationMetadata metadata, Condition condition) {
			if (condition instanceof SpringBootCondition springBootCondition) {
				return springBootCondition.getMatchOutcome(this.context, metadata);
			}
			return new ConditionOutcome(condition.matches(this.context, metadata), ConditionMessage.empty());
		}
		ConditionOutcome getUltimateOutcome() {
			ConditionMessage.Builder message = ConditionMessage
				.forCondition('NestedCondition on ' + ClassUtils.getShortName(this.metadata.getClassName()));
			if (this.outcomes.size() == 1) {
				ConditionOutcome outcome = this.outcomes.get(0);
				return new ConditionOutcome(outcome.isMatch(), message.because(outcome.getMessage()));
			}
			List<ConditionOutcome> match = new ArrayList<>();
			List<ConditionOutcome> nonMatch = new ArrayList<>();
			for (ConditionOutcome outcome : this.outcomes) {
				(outcome.isMatch() ? match : nonMatch).add(outcome);
			}
			if (nonMatch.isEmpty()) {
				return ConditionOutcome.match(message.found('matching nested conditions').items(match));
			}
			return ConditionOutcome.noMatch(message.found('non-matching nested conditions').items(nonMatch));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.HIGHEST_PRECEDENCE + 20)
class OnJavaCondition extends SpringBootCondition {
	private static final JavaVersion JVM_VERSION = JavaVersion.getJavaVersion();
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnJava.class.getName());
		Range range = (Range) attributes.get('range');
		JavaVersion version = (JavaVersion) attributes.get('value');
		return getMatchOutcome(range, JVM_VERSION, version);
	}
	protected ConditionOutcome getMatchOutcome(Range range, JavaVersion runningVersion, JavaVersion version) {
		boolean match = isWithin(runningVersion, range, version);
		String expected = String.format((range != Range.EQUAL_OR_NEWER) ? '(older than %s)' : '(%s or newer)', version);
		ConditionMessage message = ConditionMessage.forCondition(ConditionalOnJava.class, expected)
			.foundExactly(runningVersion);
		return new ConditionOutcome(match, message);
	}
	/**
	 * Determines if the {@code runningVersion} is within the specified range of versions.
	 * @param runningVersion the current version.
	 * @param range the range
	 * @param version the bounds of the range
	 * @return if this version is within the specified range
	 */
	private boolean isWithin(JavaVersion runningVersion, Range range, JavaVersion version) {
		if (range == Range.EQUAL_OR_NEWER) {
			return runningVersion.isEqualOrNewerThan(version);
		}
		if (range == Range.OLDER_THAN) {
			return runningVersion.isOlderThan(version);
		}
		throw new IllegalStateException('Unknown range ' + range);
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class OnCloudPlatformCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnCloudPlatform.class.getName());
		CloudPlatform cloudPlatform = (CloudPlatform) attributes.get('value');
		return getMatchOutcome(context.getEnvironment(), cloudPlatform);
	}
	private ConditionOutcome getMatchOutcome(Environment environment, CloudPlatform cloudPlatform) {
		String name = cloudPlatform.name();
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnCloudPlatform.class);
		if (cloudPlatform.isActive(environment)) {
			return ConditionOutcome.match(message.foundExactly(name));
		}
		return ConditionOutcome.noMatch(message.didNotFind(name).atAll());
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnWarDeploymentCondition.class)
public @interface ConditionalOnNotWarDeployment {
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.HIGHEST_PRECEDENCE)
class OnClassCondition extends FilteringSpringBootCondition {
	@Override
	protected final ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,
			AutoConfigurationMetadata autoConfigurationMetadata) {
		// Split the work and perform half in a background thread if more than one
		// processor is available. Using a single additional thread seems to offer the
		// best performance. More threads make things worse.
		if (autoConfigurationClasses.length > 1 && Runtime.getRuntime().availableProcessors() > 1) {
			return resolveOutcomesThreaded(autoConfigurationClasses, autoConfigurationMetadata);
		}
		else {
			OutcomesResolver outcomesResolver = new StandardOutcomesResolver(autoConfigurationClasses, 0,
					autoConfigurationClasses.length, autoConfigurationMetadata, getBeanClassLoader());
			return outcomesResolver.resolveOutcomes();
		}
	}
	private ConditionOutcome[] resolveOutcomesThreaded(String[] autoConfigurationClasses,
			AutoConfigurationMetadata autoConfigurationMetadata) {
		int split = autoConfigurationClasses.length / 2;
		OutcomesResolver firstHalfResolver = createOutcomesResolver(autoConfigurationClasses, 0, split,
				autoConfigurationMetadata);
		OutcomesResolver secondHalfResolver = new StandardOutcomesResolver(autoConfigurationClasses, split,
				autoConfigurationClasses.length, autoConfigurationMetadata, getBeanClassLoader());
		ConditionOutcome[] secondHalf = secondHalfResolver.resolveOutcomes();
		ConditionOutcome[] firstHalf = firstHalfResolver.resolveOutcomes();
		ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length];
		System.arraycopy(firstHalf, 0, outcomes, 0, firstHalf.length);
		System.arraycopy(secondHalf, 0, outcomes, split, secondHalf.length);
		return outcomes;
	}
	private OutcomesResolver createOutcomesResolver(String[] autoConfigurationClasses, int start, int end,
			AutoConfigurationMetadata autoConfigurationMetadata) {
		OutcomesResolver outcomesResolver = new StandardOutcomesResolver(autoConfigurationClasses, start, end,
				autoConfigurationMetadata, getBeanClassLoader());
		return new ThreadedOutcomesResolver(outcomesResolver);
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ClassLoader classLoader = context.getClassLoader();
		ConditionMessage matchMessage = ConditionMessage.empty();
		List<String> onClasses = getCandidates(metadata, ConditionalOnClass.class);
		if (onClasses != null) {
			List<String> missing = filter(onClasses, ClassNameFilter.MISSING, classLoader);
			if (!missing.isEmpty()) {
				return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)
					.didNotFind('required class', 'required classes')
					.items(Style.QUOTE, missing));
			}
			matchMessage = matchMessage.andCondition(ConditionalOnClass.class)
				.found('required class', 'required classes')
				.items(Style.QUOTE, filter(onClasses, ClassNameFilter.PRESENT, classLoader));
		}
		List<String> onMissingClasses = getCandidates(metadata, ConditionalOnMissingClass.class);
		if (onMissingClasses != null) {
			List<String> present = filter(onMissingClasses, ClassNameFilter.PRESENT, classLoader);
			if (!present.isEmpty()) {
				return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnMissingClass.class)
					.found('unwanted class', 'unwanted classes')
					.items(Style.QUOTE, present));
			}
			matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)
				.didNotFind('unwanted class', 'unwanted classes')
				.items(Style.QUOTE, filter(onMissingClasses, ClassNameFilter.MISSING, classLoader));
		}
		return ConditionOutcome.match(matchMessage);
	}
	private List<String> getCandidates(AnnotatedTypeMetadata metadata, Class<?> annotationType) {
		MultiValueMap<String, Object> attributes = metadata.getAllAnnotationAttributes(annotationType.getName(), true);
		if (attributes == null) {
			return null;
		}
		List<String> candidates = new ArrayList<>();
		addAll(candidates, attributes.get('value'));
		addAll(candidates, attributes.get('name'));
		return candidates;
	}
	private void addAll(List<String> list, List<Object> itemsToAdd) {
		if (itemsToAdd != null) {
			for (Object item : itemsToAdd) {
				Collections.addAll(list, (String[]) item);
			}
		}
	}
	private interface OutcomesResolver {
		ConditionOutcome[] resolveOutcomes();
	}
	private static final class ThreadedOutcomesResolver implements OutcomesResolver {
		private final Thread thread;
		private volatile ConditionOutcome[] outcomes;
		private volatile Throwable failure;
		private ThreadedOutcomesResolver(OutcomesResolver outcomesResolver) {
			this.thread = new Thread(() -> {
				try {
					this.outcomes = outcomesResolver.resolveOutcomes();
				}
				catch (Throwable ex) {
					this.failure = ex;
				}
			});
			this.thread.start();
		}
		@Override
		public ConditionOutcome[] resolveOutcomes() {
			try {
				this.thread.join();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
			if (this.failure != null) {
				ReflectionUtils.rethrowRuntimeException(this.failure);
			}
			return this.outcomes;
		}
	}
	private static final class StandardOutcomesResolver implements OutcomesResolver {
		private final String[] autoConfigurationClasses;
		private final int start;
		private final int end;
		private final AutoConfigurationMetadata autoConfigurationMetadata;
		private final ClassLoader beanClassLoader;
		private StandardOutcomesResolver(String[] autoConfigurationClasses, int start, int end,
				AutoConfigurationMetadata autoConfigurationMetadata, ClassLoader beanClassLoader) {
			this.autoConfigurationClasses = autoConfigurationClasses;
			this.start = start;
			this.end = end;
			this.autoConfigurationMetadata = autoConfigurationMetadata;
			this.beanClassLoader = beanClassLoader;
		}
		@Override
		public ConditionOutcome[] resolveOutcomes() {
			return getOutcomes(this.autoConfigurationClasses, this.start, this.end, this.autoConfigurationMetadata);
		}
		private ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, int start, int end,
				AutoConfigurationMetadata autoConfigurationMetadata) {
			ConditionOutcome[] outcomes = new ConditionOutcome[end - start];
			for (int i = start; i < end; i++) {
				String autoConfigurationClass = autoConfigurationClasses[i];
				if (autoConfigurationClass != null) {
					String candidates = autoConfigurationMetadata.get(autoConfigurationClass, 'ConditionalOnClass');
					if (candidates != null) {
						outcomes[i - start] = getOutcome(candidates);
					}
				}
			}
			return outcomes;
		}
		private ConditionOutcome getOutcome(String candidates) {
			try {
				if (!candidates.contains(',')) {
					return getOutcome(candidates, this.beanClassLoader);
				}
				for (String candidate : StringUtils.commaDelimitedListToStringArray(candidates)) {
					ConditionOutcome outcome = getOutcome(candidate, this.beanClassLoader);
					if (outcome != null) {
						return outcome;
					}
				}
			}
			catch (Exception ex) {
				// We"ll get another chance later
			}
			return null;
		}
		private ConditionOutcome getOutcome(String className, ClassLoader classLoader) {
			if (ClassNameFilter.MISSING.matches(className, classLoader)) {
				return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)
					.didNotFind('required class')
					.items(Style.QUOTE, className));
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnJndiCondition.class)
public @interface ConditionalOnJndi {
	/**
	 * JNDI Locations, one of which must exist. If no locations are specific the condition
	 * matches solely based on the presence of an {@link InitialContext}.
	 * @return the JNDI locations
	 */
	String[] value() default {};
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnWebApplicationCondition.class)
public @interface ConditionalOnNotWebApplication {
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
abstract class FilteringSpringBootCondition extends SpringBootCondition
		implements AutoConfigurationImportFilter, BeanFactoryAware, BeanClassLoaderAware {
	private BeanFactory beanFactory;
	private ClassLoader beanClassLoader;
	@Override
	public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) {
		ConditionEvaluationReport report = ConditionEvaluationReport.find(this.beanFactory);
		ConditionOutcome[] outcomes = getOutcomes(autoConfigurationClasses, autoConfigurationMetadata);
		boolean[] match = new boolean[outcomes.length];
		for (int i = 0; i < outcomes.length; i++) {
			match[i] = (outcomes[i] == null || outcomes[i].isMatch());
			if (!match[i] && outcomes[i] != null) {
				logOutcome(autoConfigurationClasses[i], outcomes[i]);
				if (report != null) {
					report.recordConditionEvaluation(autoConfigurationClasses[i], this, outcomes[i]);
				}
			}
		}
		return match;
	}
	protected abstract ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,
			AutoConfigurationMetadata autoConfigurationMetadata);
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		this.beanFactory = beanFactory;
	}
	protected final BeanFactory getBeanFactory() {
		return this.beanFactory;
	}
	protected final ClassLoader getBeanClassLoader() {
		return this.beanClassLoader;
	}
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.beanClassLoader = classLoader;
	}
	protected final List<String> filter(Collection<String> classNames, ClassNameFilter classNameFilter,
			ClassLoader classLoader) {
		if (CollectionUtils.isEmpty(classNames)) {
			return Collections.emptyList();
		}
		List<String> matches = new ArrayList<>(classNames.size());
		for (String candidate : classNames) {
			if (classNameFilter.matches(candidate, classLoader)) {
				matches.add(candidate);
			}
		}
		return matches;
	}
	/**
	 * Slightly faster variant of {@link ClassUtils#forName(String, ClassLoader)} that
	 * doesn"t deal with primitives, arrays or inner types.
	 * @param className the class name to resolve
	 * @param classLoader the class loader to use
	 * @return a resolved class
	 * @throws ClassNotFoundException if the class cannot be found
	 */
	protected static Class<?> resolve(String className, ClassLoader classLoader) throws ClassNotFoundException {
		if (classLoader != null) {
			return Class.forName(className, false, classLoader);
		}
		return Class.forName(className);
	}
	protected enum ClassNameFilter {
		PRESENT {
			@Override
			public boolean matches(String className, ClassLoader classLoader) {
				return isPresent(className, classLoader);
			}
		},
		MISSING {
			@Override
			public boolean matches(String className, ClassLoader classLoader) {
				return !isPresent(className, classLoader);
			}
		};
		abstract boolean matches(String className, ClassLoader classLoader);
		private static boolean isPresent(String className, ClassLoader classLoader) {
			if (classLoader == null) {
				classLoader = ClassUtils.getDefaultClassLoader();
			}
			try {
				resolve(className, classLoader);
				return true;
			}
			catch (Throwable ex) {
				return false;
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.HIGHEST_PRECEDENCE + 20)
class OnWebApplicationCondition extends FilteringSpringBootCondition {
	private static final String SERVLET_WEB_APPLICATION_CLASS = 'org.springframework.web.context.support.GenericWebApplicationContext';
	private static final String REACTIVE_WEB_APPLICATION_CLASS = 'org.springframework.web.reactive.HandlerResult';
	@Override
	protected ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses,
			AutoConfigurationMetadata autoConfigurationMetadata) {
		ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length];
		for (int i = 0; i < outcomes.length; i++) {
			String autoConfigurationClass = autoConfigurationClasses[i];
			if (autoConfigurationClass != null) {
				outcomes[i] = getOutcome(
						autoConfigurationMetadata.get(autoConfigurationClass, 'ConditionalOnWebApplication'));
			}
		}
		return outcomes;
	}
	private ConditionOutcome getOutcome(String type) {
		if (type == null) {
			return null;
		}
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnWebApplication.class);
		ClassNameFilter missingClassFilter = ClassNameFilter.MISSING;
		if (ConditionalOnWebApplication.Type.SERVLET.name().equals(type)) {
			if (missingClassFilter.matches(SERVLET_WEB_APPLICATION_CLASS, getBeanClassLoader())) {
				return ConditionOutcome.noMatch(message.didNotFind('servlet web application classes').atAll());
			}
		}
		if (ConditionalOnWebApplication.Type.REACTIVE.name().equals(type)) {
			if (missingClassFilter.matches(REACTIVE_WEB_APPLICATION_CLASS, getBeanClassLoader())) {
				return ConditionOutcome.noMatch(message.didNotFind('reactive web application classes').atAll());
			}
		}
		if (missingClassFilter.matches(SERVLET_WEB_APPLICATION_CLASS, getBeanClassLoader())
				&& !ClassUtils.isPresent(REACTIVE_WEB_APPLICATION_CLASS, getBeanClassLoader())) {
			return ConditionOutcome.noMatch(message.didNotFind('reactive or servlet web application classes').atAll());
		}
		return null;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		boolean required = metadata.isAnnotated(ConditionalOnWebApplication.class.getName());
		ConditionOutcome outcome = isWebApplication(context, metadata, required);
		if (required && !outcome.isMatch()) {
			return ConditionOutcome.noMatch(outcome.getConditionMessage());
		}
		if (!required && outcome.isMatch()) {
			return ConditionOutcome.noMatch(outcome.getConditionMessage());
		}
		return ConditionOutcome.match(outcome.getConditionMessage());
	}
	private ConditionOutcome isWebApplication(ConditionContext context, AnnotatedTypeMetadata metadata,
			boolean required) {
		return switch (deduceType(metadata)) {
			case SERVLET -> isServletWebApplication(context);
			case REACTIVE -> isReactiveWebApplication(context);
			default -> isAnyWebApplication(context, required);
		};
	}
	private ConditionOutcome isAnyWebApplication(ConditionContext context, boolean required) {
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnWebApplication.class,
				required ? '(required)' : '');
		ConditionOutcome servletOutcome = isServletWebApplication(context);
		if (servletOutcome.isMatch() && required) {
			return new ConditionOutcome(servletOutcome.isMatch(), message.because(servletOutcome.getMessage()));
		}
		ConditionOutcome reactiveOutcome = isReactiveWebApplication(context);
		if (reactiveOutcome.isMatch() && required) {
			return new ConditionOutcome(reactiveOutcome.isMatch(), message.because(reactiveOutcome.getMessage()));
		}
		return new ConditionOutcome(servletOutcome.isMatch() || reactiveOutcome.isMatch(),
				message.because(servletOutcome.getMessage()).append('and').append(reactiveOutcome.getMessage()));
	}
	private ConditionOutcome isServletWebApplication(ConditionContext context) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('');
		if (ClassNameFilter.MISSING.matches(SERVLET_WEB_APPLICATION_CLASS, context.getClassLoader())) {
			return ConditionOutcome.noMatch(message.didNotFind('servlet web application classes').atAll());
		}
		if (context.getBeanFactory() != null) {
			String[] scopes = context.getBeanFactory().getRegisteredScopeNames();
			if (ObjectUtils.containsElement(scopes, 'session')) {
				return ConditionOutcome.match(message.foundExactly('"session" scope'));
			}
		}
		if (context.getEnvironment() instanceof ConfigurableWebEnvironment) {
			return ConditionOutcome.match(message.foundExactly('ConfigurableWebEnvironment'));
		}
		if (context.getResourceLoader() instanceof WebApplicationContext) {
			return ConditionOutcome.match(message.foundExactly('WebApplicationContext'));
		}
		return ConditionOutcome.noMatch(message.because('not a servlet web application'));
	}
	private ConditionOutcome isReactiveWebApplication(ConditionContext context) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('');
		if (ClassNameFilter.MISSING.matches(REACTIVE_WEB_APPLICATION_CLASS, context.getClassLoader())) {
			return ConditionOutcome.noMatch(message.didNotFind('reactive web application classes').atAll());
		}
		if (context.getEnvironment() instanceof ConfigurableReactiveWebEnvironment) {
			return ConditionOutcome.match(message.foundExactly('ConfigurableReactiveWebEnvironment'));
		}
		if (context.getResourceLoader() instanceof ReactiveWebApplicationContext) {
			return ConditionOutcome.match(message.foundExactly('ReactiveWebApplicationContext'));
		}
		return ConditionOutcome.noMatch(message.because('not a reactive web application'));
	}
	private Type deduceType(AnnotatedTypeMetadata metadata) {
		Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnWebApplication.class.getName());
		if (attributes != null) {
			return (Type) attributes.get('type');
		}
		return Type.ANY;
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class OnWarDeploymentCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		boolean required = metadata.isAnnotated(ConditionalOnWarDeployment.class.getName());
		ResourceLoader resourceLoader = context.getResourceLoader();
		if (resourceLoader instanceof WebApplicationContext applicationContext) {
			ServletContext servletContext = applicationContext.getServletContext();
			if (servletContext != null) {
				return new ConditionOutcome(required, 'Application is deployed as a WAR file.');
			}
		}
		return new ConditionOutcome(!required, ConditionMessage.forCondition(ConditionalOnWarDeployment.class)
			.because('the application is not deployed as a WAR file.'));
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnResourceCondition.class)
public @interface ConditionalOnResource {
	/**
	 * The resources that must be present.
	 * @return the resource paths that must be present.
	 */
	String[] resources() default {};
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnExpressionCondition.class)
public @interface ConditionalOnExpression {
	/**
	 * The SpEL expression to evaluate. Expression should return {@code true} if the
	 * condition passes or {@code false} if it fails.
	 * @return the SpEL expression
	 */
	String value() default 'true';
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public enum SearchStrategy {
	/**
	 * Search only the current context.
	 */
	CURRENT,
	/**
	 * Search all ancestors, but not the current context.
	 */
	ANCESTORS,
	/**
	 * Search the entire hierarchy.
	 */
	ALL
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnJavaCondition.class)
public @interface ConditionalOnJava {
	/**
	 * Configures whether the value configured in {@link #value()} shall be considered the
	 * upper exclusive or lower inclusive boundary. Defaults to
	 * {@link Range#EQUAL_OR_NEWER}.
	 * @return the range
	 */
	Range range() default Range.EQUAL_OR_NEWER;
	/**
	 * The {@link JavaVersion} to check for. Use {@link #range()} to specify whether the
	 * configured value is an upper-exclusive or lower-inclusive boundary.
	 * @return the java version
	 */
	JavaVersion value();
	/**
	 * Range options.
	 */
	enum Range {
		/**
		 * Equal to, or newer than the specified {@link JavaVersion}.
		 */
		EQUAL_OR_NEWER,
		/**
		 * Older than the specified {@link JavaVersion}.
		 */
		OLDER_THAN
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnBeanCondition.class)
public @interface ConditionalOnMissingBean {
	/**
	 * The class types of beans that should be checked. The condition matches when no bean
	 * of each class specified is contained in the {@link BeanFactory}. Beans that are not
	 * autowire candidates or that are not default candidates are ignored.
	 * @return the class types of beans to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	Class<?>[] value() default {};
	/**
	 * The class type names of beans that should be checked. The condition matches when no
	 * bean of each class specified is contained in the {@link BeanFactory}. Beans that
	 * are not autowire candidates or that are not default candidates are ignored.
	 * @return the class type names of beans to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	String[] type() default {};
	/**
	 * The class types of beans that should be ignored when identifying matching beans.
	 * @return the class types of beans to ignore
	 * @since 1.2.5
	 */
	Class<?>[] ignored() default {};
	/**
	 * The class type names of beans that should be ignored when identifying matching
	 * beans.
	 * @return the class type names of beans to ignore
	 * @since 1.2.5
	 */
	String[] ignoredType() default {};
	/**
	 * The annotation type decorating a bean that should be checked. The condition matches
	 * when each annotation specified is missing from all beans in the
	 * {@link BeanFactory}. Beans that are not autowire candidates or that are not default
	 * candidates are ignored.
	 * @return the class-level annotation types to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	Class<? extends Annotation>[] annotation() default {};
	/**
	 * The names of beans to check. The condition matches when each bean name specified is
	 * missing in the {@link BeanFactory}.
	 * @return the names of beans to check
	 */
	String[] name() default {};
	/**
	 * Strategy to decide if the application context hierarchy (parent contexts) should be
	 * considered.
	 * @return the search strategy
	 */
	SearchStrategy search() default SearchStrategy.ALL;
	/**
	 * Additional classes that may contain the specified bean types within their generic
	 * parameters. For example, an annotation declaring {@code value=Name.class} and
	 * {@code parameterizedContainer=NameRegistration.class} would detect both
	 * {@code Name} and {@code NameRegistration<Name>}.
	 * @return the container types
	 * @since 2.1.0
	 */
	Class<?>[] parameterizedContainer() default {};
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnThreadingCondition.class)
public @interface ConditionalOnThreading {
	/**
	 * The {@link Threading threading} that must be active.
	 * @return the expected threading
	 */
	Threading value();
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnBeanCondition.class)
public @interface ConditionalOnSingleCandidate {
	/**
	 * The class type of bean that should be checked. The condition matches if a bean of
	 * the class specified is contained in the {@link BeanFactory} and a primary candidate
	 * exists in case of multiple instances. Beans that are not autowire candidates or
	 * that are not default candidates are ignored.
	 * <p>
	 * This attribute may <strong>not</strong> be used in conjunction with
	 * {@link #type()}, but it may be used instead of {@link #type()}.
	 * @return the class type of the bean to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	Class<?> value() default Object.class;
	/**
	 * The class type name of bean that should be checked. The condition matches if a bean
	 * of the class specified is contained in the {@link BeanFactory} and a primary
	 * candidate exists in case of multiple instances. Beans that are not autowire
	 * candidates or that are not default candidates are ignored.
	 * <p>
	 * This attribute may <strong>not</strong> be used in conjunction with
	 * {@link #value()}, but it may be used instead of {@link #value()}.
	 * @return the class type name of the bean to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	String type() default '';
	/**
	 * Strategy to decide if the application context hierarchy (parent contexts) should be
	 * considered.
	 * @return the search strategy
	 */
	SearchStrategy search() default SearchStrategy.ALL;
}
/*
/**
package org.springframework.boot.autoconfigure.condition;
/*
package org.springframework.boot.autoconfigure.condition;
/**
class OnThreadingCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		Map<String, Object> attributes = metadata.getAnnotationAttributes(ConditionalOnThreading.class.getName());
		Threading threading = (Threading) attributes.get('value');
		return getMatchOutcome(context.getEnvironment(), threading);
	}
	private ConditionOutcome getMatchOutcome(Environment environment, Threading threading) {
		String name = threading.name();
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnThreading.class);
		if (threading.isActive(environment)) {
			return ConditionOutcome.match(message.foundExactly(name));
		}
		return ConditionOutcome.noMatch(message.didNotFind(name).atAll());
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public abstract class AllNestedConditions extends AbstractNestedCondition {
	public AllNestedConditions(ConfigurationPhase configurationPhase) {
		super(configurationPhase);
	}
	@Override
	protected ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes) {
		boolean match = hasSameSize(memberOutcomes.getMatches(), memberOutcomes.getAll());
		List<ConditionMessage> messages = new ArrayList<>();
		messages.add(ConditionMessage.forCondition('AllNestedConditions')
			.because(memberOutcomes.getMatches().size() + ' matched ' + memberOutcomes.getNonMatches().size()
					+ ' did not'));
		for (ConditionOutcome outcome : memberOutcomes.getAll()) {
			messages.add(outcome.getConditionMessage());
		}
		return new ConditionOutcome(match, ConditionMessage.of(messages));
	}
	private boolean hasSameSize(List<?> list1, List<?> list2) {
		return list1.size() == list2.size();
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.HIGHEST_PRECEDENCE + 40)
class OnPropertyCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		List<AnnotationAttributes> allAnnotationAttributes = metadata.getAnnotations()
			.stream(ConditionalOnProperty.class.getName())
			.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))
			.map(MergedAnnotation::asAnnotationAttributes)
			.toList();
		List<ConditionMessage> noMatch = new ArrayList<>();
		List<ConditionMessage> match = new ArrayList<>();
		for (AnnotationAttributes annotationAttributes : allAnnotationAttributes) {
			ConditionOutcome outcome = determineOutcome(annotationAttributes, context.getEnvironment());
			(outcome.isMatch() ? match : noMatch).add(outcome.getConditionMessage());
		}
		if (!noMatch.isEmpty()) {
			return ConditionOutcome.noMatch(ConditionMessage.of(noMatch));
		}
		return ConditionOutcome.match(ConditionMessage.of(match));
	}
	private ConditionOutcome determineOutcome(AnnotationAttributes annotationAttributes, PropertyResolver resolver) {
		Spec spec = new Spec(annotationAttributes);
		List<String> missingProperties = new ArrayList<>();
		List<String> nonMatchingProperties = new ArrayList<>();
		spec.collectProperties(resolver, missingProperties, nonMatchingProperties);
		if (!missingProperties.isEmpty()) {
			return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnProperty.class, spec)
				.didNotFind('property', 'properties')
				.items(Style.QUOTE, missingProperties));
		}
		if (!nonMatchingProperties.isEmpty()) {
			return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnProperty.class, spec)
				.found('different value in property', 'different value in properties')
				.items(Style.QUOTE, nonMatchingProperties));
		}
		return ConditionOutcome
			.match(ConditionMessage.forCondition(ConditionalOnProperty.class, spec).because('matched'));
	}
	private static class Spec {
		private final String prefix;
		private final String havingValue;
		private final String[] names;
		private final boolean matchIfMissing;
		Spec(AnnotationAttributes annotationAttributes) {
			String prefix = annotationAttributes.getString('prefix').trim();
			if (StringUtils.hasText(prefix) && !prefix.endsWith('.')) {
				prefix = prefix + '.';
			}
			this.prefix = prefix;
			this.havingValue = annotationAttributes.getString('havingValue');
			this.names = getNames(annotationAttributes);
			this.matchIfMissing = annotationAttributes.getBoolean('matchIfMissing');
		}
		private String[] getNames(Map<String, Object> annotationAttributes) {
			String[] value = (String[]) annotationAttributes.get('value');
			String[] name = (String[]) annotationAttributes.get('name');
			Assert.state(value.length > 0 || name.length > 0,
					'The name or value attribute of @ConditionalOnProperty must be specified');
			Assert.state(value.length == 0 || name.length == 0,
					'The name and value attributes of @ConditionalOnProperty are exclusive');
			return (value.length > 0) ? value : name;
		}
		private void collectProperties(PropertyResolver resolver, List<String> missing, List<String> nonMatching) {
			for (String name : this.names) {
				String key = this.prefix + name;
				if (resolver.containsProperty(key)) {
					if (!isMatch(resolver.getProperty(key), this.havingValue)) {
						nonMatching.add(name);
					}
				}
				else {
					if (!this.matchIfMissing) {
						missing.add(name);
					}
				}
			}
		}
		private boolean isMatch(String value, String requiredValue) {
			if (StringUtils.hasLength(requiredValue)) {
				return requiredValue.equalsIgnoreCase(value);
			}
			return !'false'.equalsIgnoreCase(value);
		}
		@Override
		public String toString() {
			StringBuilder result = new StringBuilder();
			result.append('(');
			result.append(this.prefix);
			if (this.names.length == 1) {
				result.append(this.names[0]);
			}
			else {
				result.append('[');
				result.append(StringUtils.arrayToCommaDelimitedString(this.names));
				result.append(']');
			}
			if (StringUtils.hasLength(this.havingValue)) {
				result.append('=').append(this.havingValue);
			}
			result.append(')');
			return result.toString();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public final class ConditionEvaluationReport {
	private static final String BEAN_NAME = 'autoConfigurationReport';
	private static final AncestorsMatchedCondition ANCESTOR_CONDITION = new AncestorsMatchedCondition();
	private final SortedMap<String, ConditionAndOutcomes> outcomes = new TreeMap<>();
	private boolean addedAncestorOutcomes;
	private ConditionEvaluationReport parent;
	private final List<String> exclusions = new ArrayList<>();
	private final Set<String> unconditionalClasses = new HashSet<>();
	/**
	 * Private constructor.
	 * @see #get(ConfigurableListableBeanFactory)
	 */
	private ConditionEvaluationReport() {
	}
	/**
	 * Record the occurrence of condition evaluation.
	 * @param source the source of the condition (class or method name)
	 * @param condition the condition evaluated
	 * @param outcome the condition outcome
	 */
	public void recordConditionEvaluation(String source, Condition condition, ConditionOutcome outcome) {
		Assert.notNull(source, 'Source must not be null');
		Assert.notNull(condition, 'Condition must not be null');
		Assert.notNull(outcome, 'Outcome must not be null');
		this.unconditionalClasses.remove(source);
		this.outcomes.computeIfAbsent(source, (key) -> new ConditionAndOutcomes()).add(condition, outcome);
		this.addedAncestorOutcomes = false;
	}
	/**
	 * Records the names of the classes that have been excluded from condition evaluation.
	 * @param exclusions the names of the excluded classes
	 */
	public void recordExclusions(Collection<String> exclusions) {
		Assert.notNull(exclusions, 'exclusions must not be null');
		this.exclusions.addAll(exclusions);
	}
	/**
	 * Records the names of the classes that are candidates for condition evaluation.
	 * @param evaluationCandidates the names of the classes whose conditions will be
	 * evaluated
	 */
	public void recordEvaluationCandidates(List<String> evaluationCandidates) {
		Assert.notNull(evaluationCandidates, 'evaluationCandidates must not be null');
		this.unconditionalClasses.addAll(evaluationCandidates);
	}
	/**
	 * Returns condition outcomes from this report, grouped by the source.
	 * @return the condition outcomes
	 */
	public Map<String, ConditionAndOutcomes> getConditionAndOutcomesBySource() {
		if (!this.addedAncestorOutcomes) {
			this.outcomes.forEach((source, sourceOutcomes) -> {
				if (!sourceOutcomes.isFullMatch()) {
					addNoMatchOutcomeToAncestors(source);
				}
			});
			this.addedAncestorOutcomes = true;
		}
		return Collections.unmodifiableMap(this.outcomes);
	}
	private void addNoMatchOutcomeToAncestors(String source) {
		String prefix = source + '$';
		this.outcomes.forEach((candidateSource, sourceOutcomes) -> {
			if (candidateSource.startsWith(prefix)) {
				ConditionOutcome outcome = ConditionOutcome
					.noMatch(ConditionMessage.forCondition('Ancestor ' + source).because('did not match'));
				sourceOutcomes.add(ANCESTOR_CONDITION, outcome);
			}
		});
	}
	/**
	 * Returns the names of the classes that have been excluded from condition evaluation.
	 * @return the names of the excluded classes
	 */
	public List<String> getExclusions() {
		return Collections.unmodifiableList(this.exclusions);
	}
	/**
	 * Returns the names of the classes that were evaluated but were not conditional.
	 * @return the names of the unconditional classes
	 */
	public Set<String> getUnconditionalClasses() {
		Set<String> filtered = new HashSet<>(this.unconditionalClasses);
		this.exclusions.forEach(filtered::remove);
		return Collections.unmodifiableSet(filtered);
	}
	/**
	 * The parent report (from a parent BeanFactory if there is one).
	 * @return the parent report (or null if there isn"t one)
	 */
	public ConditionEvaluationReport getParent() {
		return this.parent;
	}
	/**
	 * Attempt to find the {@link ConditionEvaluationReport} for the specified bean
	 * factory.
	 * @param beanFactory the bean factory (may be {@code null})
	 * @return the {@link ConditionEvaluationReport} or {@code null}
	 */
	public static ConditionEvaluationReport find(BeanFactory beanFactory) {
		if (beanFactory instanceof ConfigurableListableBeanFactory) {
			return ConditionEvaluationReport.get((ConfigurableListableBeanFactory) beanFactory);
		}
		return null;
	}
	/**
	 * Obtain a {@link ConditionEvaluationReport} for the specified bean factory.
	 * @param beanFactory the bean factory
	 * @return an existing or new {@link ConditionEvaluationReport}
	 */
	public static ConditionEvaluationReport get(ConfigurableListableBeanFactory beanFactory) {
		synchronized (beanFactory) {
			ConditionEvaluationReport report;
			if (beanFactory.containsSingleton(BEAN_NAME)) {
				report = beanFactory.getBean(BEAN_NAME, ConditionEvaluationReport.class);
			}
			else {
				report = new ConditionEvaluationReport();
				beanFactory.registerSingleton(BEAN_NAME, report);
			}
			locateParent(beanFactory.getParentBeanFactory(), report);
			return report;
		}
	}
	private static void locateParent(BeanFactory beanFactory, ConditionEvaluationReport report) {
		if (beanFactory != null && report.parent == null && beanFactory.containsBean(BEAN_NAME)) {
			report.parent = beanFactory.getBean(BEAN_NAME, ConditionEvaluationReport.class);
		}
	}
	public ConditionEvaluationReport getDelta(ConditionEvaluationReport previousReport) {
		ConditionEvaluationReport delta = new ConditionEvaluationReport();
		this.outcomes.forEach((source, sourceOutcomes) -> {
			ConditionAndOutcomes previous = previousReport.outcomes.get(source);
			if (previous == null || previous.isFullMatch() != sourceOutcomes.isFullMatch()) {
				sourceOutcomes.forEach((conditionAndOutcome) -> delta.recordConditionEvaluation(source,
						conditionAndOutcome.getCondition(), conditionAndOutcome.getOutcome()));
			}
		});
		List<String> newExclusions = new ArrayList<>(this.exclusions);
		newExclusions.removeAll(previousReport.getExclusions());
		delta.recordExclusions(newExclusions);
		List<String> newUnconditionalClasses = new ArrayList<>(this.unconditionalClasses);
		newUnconditionalClasses.removeAll(previousReport.unconditionalClasses);
		delta.unconditionalClasses.addAll(newUnconditionalClasses);
		return delta;
	}
	/**
	 * Provides access to a number of {@link ConditionAndOutcome} items.
	 */
	public static class ConditionAndOutcomes implements Iterable<ConditionAndOutcome> {
		private final Set<ConditionAndOutcome> outcomes = new LinkedHashSet<>();
		public void add(Condition condition, ConditionOutcome outcome) {
			this.outcomes.add(new ConditionAndOutcome(condition, outcome));
		}
		/**
		 * Return {@code true} if all outcomes match.
		 * @return {@code true} if a full match
		 */
		public boolean isFullMatch() {
			for (ConditionAndOutcome conditionAndOutcomes : this) {
				if (!conditionAndOutcomes.getOutcome().isMatch()) {
					return false;
				}
			}
			return true;
		}
		@Override
		public Iterator<ConditionAndOutcome> iterator() {
			return Collections.unmodifiableSet(this.outcomes).iterator();
		}
	}
	/**
	 * Provides access to a single {@link Condition} and {@link ConditionOutcome}.
	 */
	public static class ConditionAndOutcome {
		private final Condition condition;
		private final ConditionOutcome outcome;
		public ConditionAndOutcome(Condition condition, ConditionOutcome outcome) {
			this.condition = condition;
			this.outcome = outcome;
		}
		public Condition getCondition() {
			return this.condition;
		}
		public ConditionOutcome getOutcome() {
			return this.outcome;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			ConditionAndOutcome other = (ConditionAndOutcome) obj;
			return (ObjectUtils.nullSafeEquals(this.condition.getClass(), other.condition.getClass())
					&& ObjectUtils.nullSafeEquals(this.outcome, other.outcome));
		}
		@Override
		public int hashCode() {
			return this.condition.getClass().hashCode() * 31 + this.outcome.hashCode();
		}
		@Override
		public String toString() {
			return this.condition.getClass() + ' ' + this.outcome;
		}
	}
	private static final class AncestorsMatchedCondition implements Condition {
		@Override
		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
			throw new UnsupportedOperationException();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnWebApplicationCondition.class)
public @interface ConditionalOnWebApplication {
	/**
	 * The required type of the web application.
	 * @return the required web application type
	 */
	Type type() default Type.ANY;
	/**
	 * Available application types.
	 */
	enum Type {
		/**
		 * Any web application will match.
		 */
		ANY,
		/**
		 * Only servlet-based web application will match.
		 */
		SERVLET,
		/**
		 * Only reactive-based web application will match.
		 */
		REACTIVE
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnBeanCondition.class)
public @interface ConditionalOnBean {
	/**
	 * The class types of beans that should be checked. The condition matches when beans
	 * of all classes specified are contained in the {@link BeanFactory}. Beans that are
	 * not autowire candidates or that are not default candidates are ignored.
	 * @return the class types of beans to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	Class<?>[] value() default {};
	/**
	 * The class type names of beans that should be checked. The condition matches when
	 * beans of all classes specified are contained in the {@link BeanFactory}. Beans that
	 * are not autowire candidates or that are not default candidates are ignored.
	 * @return the class type names of beans to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	String[] type() default {};
	/**
	 * The annotation type decorating a bean that should be checked. The condition matches
	 * when all the annotations specified are defined on beans in the {@link BeanFactory}.
	 * Beans that are not autowire candidates or that are not default candidates are
	 * ignored.
	 * @return the class-level annotation types to check
	 * @see Bean#autowireCandidate()
	 * @see BeanDefinition#isAutowireCandidate
	 * @see Bean#defaultCandidate()
	 * @see AbstractBeanDefinition#isDefaultCandidate
	 */
	Class<? extends Annotation>[] annotation() default {};
	/**
	 * The names of beans to check. The condition matches when all the bean names
	 * specified are contained in the {@link BeanFactory}.
	 * @return the names of beans to check
	 */
	String[] name() default {};
	/**
	 * Strategy to decide if the application context hierarchy (parent contexts) should be
	 * considered.
	 * @return the search strategy
	 */
	SearchStrategy search() default SearchStrategy.ALL;
	/**
	 * Additional classes that may contain the specified bean types within their generic
	 * parameters. For example, an annotation declaring {@code value=Name.class} and
	 * {@code parameterizedContainer=NameRegistration.class} would detect both
	 * {@code Name} and {@code NameRegistration<Name>}.
	 * @return the container types
	 * @since 2.1.0
	 */
	Class<?>[] parameterizedContainer() default {};
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Order(Ordered.LOWEST_PRECEDENCE - 20)
class OnExpressionCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		String expression = (String) metadata.getAnnotationAttributes(ConditionalOnExpression.class.getName())
			.get('value');
		expression = wrapIfNecessary(expression);
		ConditionMessage.Builder messageBuilder = ConditionMessage.forCondition(ConditionalOnExpression.class,
				'(' + expression + ')');
		expression = context.getEnvironment().resolvePlaceholders(expression);
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		if (beanFactory != null) {
			boolean result = evaluateExpression(beanFactory, expression);
			return new ConditionOutcome(result, messageBuilder.resultedIn(result));
		}
		return ConditionOutcome.noMatch(messageBuilder.because('no BeanFactory available.'));
	}
	private boolean evaluateExpression(ConfigurableListableBeanFactory beanFactory, String expression) {
		BeanExpressionResolver resolver = beanFactory.getBeanExpressionResolver();
		if (resolver == null) {
			resolver = new StandardBeanExpressionResolver();
		}
		BeanExpressionContext expressionContext = new BeanExpressionContext(beanFactory, null);
		Object result = resolver.evaluate(expression, expressionContext);
		return (result != null && (boolean) result);
	}
	/**
	 * Allow user to provide bare expression with no "#{}" wrapper.
	 * @param expression source expression
	 * @return wrapped expression
	 */
	private String wrapIfNecessary(String expression) {
		if (!expression.startsWith('#{')) {
			return '#{' + expression + '}';
		}
		return expression;
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public abstract class SpringBootCondition implements Condition {
	private final Log logger = LogFactory.getLog(getClass());
	@Override
	public final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
		String classOrMethodName = getClassOrMethodName(metadata);
		try {
			ConditionOutcome outcome = getMatchOutcome(context, metadata);
			logOutcome(classOrMethodName, outcome);
			recordEvaluation(context, classOrMethodName, outcome);
			return outcome.isMatch();
		}
		catch (NoClassDefFoundError ex) {
			throw new IllegalStateException('Could not evaluate condition on ' + classOrMethodName + ' due to '
					+ ex.getMessage() + ' not found. Make sure your own configuration does not rely on '
					+ 'that class. This can also happen if you are '
					+ '@ComponentScanning a springframework package (e.g. if you '
					+ 'put a @ComponentScan in the default package by mistake)', ex);
		}
		catch (RuntimeException ex) {
			throw new IllegalStateException('Error processing condition on ' + getName(metadata), ex);
		}
	}
	private String getName(AnnotatedTypeMetadata metadata) {
		if (metadata instanceof AnnotationMetadata annotationMetadata) {
			return annotationMetadata.getClassName();
		}
		if (metadata instanceof MethodMetadata methodMetadata) {
			return methodMetadata.getDeclaringClassName() + '.' + methodMetadata.getMethodName();
		}
		return metadata.toString();
	}
	private static String getClassOrMethodName(AnnotatedTypeMetadata metadata) {
		if (metadata instanceof ClassMetadata classMetadata) {
			return classMetadata.getClassName();
		}
		MethodMetadata methodMetadata = (MethodMetadata) metadata;
		return methodMetadata.getDeclaringClassName() + '#' + methodMetadata.getMethodName();
	}
	protected final void logOutcome(String classOrMethodName, ConditionOutcome outcome) {
		if (this.logger.isTraceEnabled()) {
			this.logger.trace(getLogMessage(classOrMethodName, outcome));
		}
	}
	private StringBuilder getLogMessage(String classOrMethodName, ConditionOutcome outcome) {
		StringBuilder message = new StringBuilder();
		message.append('Condition ');
		message.append(ClassUtils.getShortName(getClass()));
		message.append(' on ');
		message.append(classOrMethodName);
		message.append(outcome.isMatch() ? ' matched' : ' did not match');
		if (StringUtils.hasLength(outcome.getMessage())) {
			message.append(' due to ');
			message.append(outcome.getMessage());
		}
		return message;
	}
	private void recordEvaluation(ConditionContext context, String classOrMethodName, ConditionOutcome outcome) {
		if (context.getBeanFactory() != null) {
			ConditionEvaluationReport.get(context.getBeanFactory())
				.recordConditionEvaluation(classOrMethodName, this, outcome);
		}
	}
	/**
	 * Determine the outcome of the match along with suitable log output.
	 * @param context the condition context
	 * @param metadata the annotation metadata
	 * @return the condition outcome
	 */
	public abstract ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata);
	/**
	 * Return true if any of the specified conditions match.
	 * @param context the context
	 * @param metadata the annotation meta-data
	 * @param conditions conditions to test
	 * @return {@code true} if any condition matches.
	 */
	protected final boolean anyMatches(ConditionContext context, AnnotatedTypeMetadata metadata,
			Condition... conditions) {
		for (Condition condition : conditions) {
			if (matches(context, metadata, condition)) {
				return true;
			}
		}
		return false;
	}
	/**
	 * Return true if any of the specified condition matches.
	 * @param context the context
	 * @param metadata the annotation meta-data
	 * @param condition condition to test
	 * @return {@code true} if the condition matches.
	 */
	protected final boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata, Condition condition) {
		if (condition instanceof SpringBootCondition springBootCondition) {
			return springBootCondition.getMatchOutcome(context, metadata).isMatch();
		}
		return condition.matches(context, metadata);
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnCloudPlatformCondition.class)
public @interface ConditionalOnCloudPlatform {
	/**
	 * The {@link CloudPlatform cloud platform} that must be active.
	 * @return the expected cloud platform
	 */
	CloudPlatform value();
}
/*
package org.springframework.boot.autoconfigure.hateoas;
/**
@ConfigurationProperties(prefix = 'spring.hateoas')
public class HateoasProperties {
	/**
	 * Whether application/hal+json responses should be sent to requests that accept
	 * application/json.
	 */
	private boolean useHalAsDefaultJsonMediaType = true;
	public boolean getUseHalAsDefaultJsonMediaType() {
		return this.useHalAsDefaultJsonMediaType;
	}
	public void setUseHalAsDefaultJsonMediaType(boolean useHalAsDefaultJsonMediaType) {
		this.useHalAsDefaultJsonMediaType = useHalAsDefaultJsonMediaType;
	}
}
/*
package org.springframework.boot.autoconfigure.hateoas;
/**
@AutoConfiguration(after = { WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,
		HttpMessageConvertersAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class })
@ConditionalOnClass({ EntityModel.class, RequestMapping.class, RequestMappingHandlerAdapter.class, Plugin.class })
@ConditionalOnWebApplication
@EnableConfigurationProperties(HateoasProperties.class)
public class HypermediaAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnClass(name = 'com.fasterxml.jackson.databind.ObjectMapper')
	@ConditionalOnProperty(prefix = 'spring.hateoas', name = 'use-hal-as-default-json-media-type',
			matchIfMissing = true)
	HalConfiguration applicationJsonHalConfiguration() {
		return new HalConfiguration().withMediaType(MediaType.APPLICATION_JSON);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(LinkDiscoverers.class)
	@ConditionalOnClass(ObjectMapper.class)
	@EnableHypermediaSupport(type = HypermediaType.HAL)
	protected static class HypermediaConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.hateoas;
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
abstract class ConnectionFactoryConfigurations {
	protected static ConnectionFactory createConnectionFactory(R2dbcProperties properties,
			R2dbcConnectionDetails connectionDetails, ClassLoader classLoader,
			List<ConnectionFactoryOptionsBuilderCustomizer> optionsCustomizers,
			List<ConnectionFactoryDecorator> decorators) {
		try {
			return org.springframework.boot.r2dbc.ConnectionFactoryBuilder
				.withOptions(new ConnectionFactoryOptionsInitializer().initialize(properties, connectionDetails,
						() -> EmbeddedDatabaseConnection.get(classLoader)))
				.configure((options) -> {
					for (ConnectionFactoryOptionsBuilderCustomizer optionsCustomizer : optionsCustomizers) {
						optionsCustomizer.customize(options);
					}
				})
				.decorators(decorators)
				.build();
		}
		catch (IllegalStateException ex) {
			String message = ex.getMessage();
			if (message != null && message.contains('driver=pool')
					&& !ClassUtils.isPresent('io.r2dbc.pool.ConnectionPool', classLoader)) {
				throw new MissingR2dbcPoolDependencyException();
			}
			throw ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(PooledConnectionFactoryCondition.class)
	@ConditionalOnMissingBean(ConnectionFactory.class)
	static class PoolConfiguration {
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(ConnectionPool.class)
		static class PooledConnectionFactoryConfiguration {
			@Bean(destroyMethod = 'dispose')
			ConnectionPool connectionFactory(R2dbcProperties properties,
					ObjectProvider<R2dbcConnectionDetails> connectionDetails, ResourceLoader resourceLoader,
					ObjectProvider<ConnectionFactoryOptionsBuilderCustomizer> customizers,
					ObjectProvider<ConnectionFactoryDecorator> decorators) {
				ConnectionFactory connectionFactory = createConnectionFactory(properties,
						connectionDetails.getIfAvailable(), resourceLoader.getClassLoader(),
						customizers.orderedStream().toList(), decorators.orderedStream().toList());
				R2dbcProperties.Pool pool = properties.getPool();
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				ConnectionPoolConfiguration.Builder builder = ConnectionPoolConfiguration.builder(connectionFactory);
				map.from(pool.getMaxIdleTime()).to(builder::maxIdleTime);
				map.from(pool.getMaxLifeTime()).to(builder::maxLifeTime);
				map.from(pool.getMaxAcquireTime()).to(builder::maxAcquireTime);
				map.from(pool.getMaxCreateConnectionTime()).to(builder::maxCreateConnectionTime);
				map.from(pool.getInitialSize()).to(builder::initialSize);
				map.from(pool.getMaxSize()).to(builder::maxSize);
				map.from(pool.getValidationQuery()).whenHasText().to(builder::validationQuery);
				map.from(pool.getValidationDepth()).to(builder::validationDepth);
				map.from(pool.getMinIdle()).to(builder::minIdle);
				map.from(pool.getMaxValidationTime()).to(builder::maxValidationTime);
				return new ConnectionPool(builder.build());
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.r2dbc.pool', value = 'enabled', havingValue = 'false',
			matchIfMissing = true)
	@ConditionalOnMissingBean(ConnectionFactory.class)
	static class GenericConfiguration {
		@Bean
		ConnectionFactory connectionFactory(R2dbcProperties properties,
				ObjectProvider<R2dbcConnectionDetails> connectionDetails, ResourceLoader resourceLoader,
				ObjectProvider<ConnectionFactoryOptionsBuilderCustomizer> customizers,
				ObjectProvider<ConnectionFactoryDecorator> decorators) {
			return createConnectionFactory(properties, connectionDetails.getIfAvailable(),
					resourceLoader.getClassLoader(), customizers.orderedStream().toList(),
					decorators.orderedStream().toList());
		}
	}
	/**
	 * {@link Condition} that checks that a {@link ConnectionPool} is requested. The
	 * condition matches if pooling was opt-in through configuration. If any of the
	 * spring.r2dbc.pool.* properties have been configured, an exception is thrown if the
	 * URL also contains pooling-related options or io.r2dbc.pool.ConnectionPool is not on
	 * the class path.
	 */
	static class PooledConnectionFactoryCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			BindResult<Pool> pool = Binder.get(context.getEnvironment())
				.bind('spring.r2dbc.pool', Bindable.of(Pool.class));
			if (hasPoolUrl(context.getEnvironment())) {
				if (pool.isBound()) {
					throw new MultipleConnectionPoolConfigurationsException();
				}
				return ConditionOutcome.noMatch('URL-based pooling has been configured');
			}
			if (pool.isBound() && !ClassUtils.isPresent('io.r2dbc.pool.ConnectionPool', context.getClassLoader())) {
				throw new MissingR2dbcPoolDependencyException();
			}
			if (pool.orElseGet(Pool::new).isEnabled()) {
				return ConditionOutcome.match('Property-based pooling is enabled');
			}
			return ConditionOutcome.noMatch('Property-based pooling is disabled');
		}
		private boolean hasPoolUrl(Environment environment) {
			String url = environment.getProperty('spring.r2dbc.url');
			return StringUtils.hasText(url) && url.contains(':pool:');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@AutoConfiguration(before = { DataSourceAutoConfiguration.class, SqlInitializationAutoConfiguration.class })
@ConditionalOnClass(ConnectionFactory.class)
@ConditionalOnResource(resources = 'classpath:META-INF/services/io.r2dbc.spi.ConnectionFactoryProvider')
@EnableConfigurationProperties(R2dbcProperties.class)
@Import({ ConnectionFactoryConfigurations.PoolConfiguration.class,
		ConnectionFactoryConfigurations.GenericConfiguration.class, ConnectionFactoryDependentConfiguration.class })
public class R2dbcAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(R2dbcConnectionDetails.class)
	@ConditionalOnProperty('spring.r2dbc.url')
	PropertiesR2dbcConnectionDetails propertiesR2dbcConnectionDetails(R2dbcProperties properties) {
		return new PropertiesR2dbcConnectionDetails(properties);
	}
	/**
	 * Adapts {@link R2dbcProperties} to {@link R2dbcConnectionDetails}.
	 */
	static class PropertiesR2dbcConnectionDetails implements R2dbcConnectionDetails {
		private final R2dbcProperties properties;
		PropertiesR2dbcConnectionDetails(R2dbcProperties properties) {
			this.properties = properties;
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			ConnectionFactoryOptions urlOptions = ConnectionFactoryOptions.parse(this.properties.getUrl());
			Builder optionsBuilder = urlOptions.mutate();
			configureIf(optionsBuilder, urlOptions, ConnectionFactoryOptions.USER, this.properties::getUsername,
					StringUtils::hasText);
			configureIf(optionsBuilder, urlOptions, ConnectionFactoryOptions.PASSWORD, this.properties::getPassword,
					StringUtils::hasText);
			configureIf(optionsBuilder, urlOptions, ConnectionFactoryOptions.DATABASE,
					() -> determineDatabaseName(this.properties), StringUtils::hasText);
			if (this.properties.getProperties() != null) {
				this.properties.getProperties()
					.forEach((key, value) -> optionsBuilder.option(Option.valueOf(key), value));
			}
			return optionsBuilder.build();
		}
		private <T extends CharSequence> void configureIf(Builder optionsBuilder,
				ConnectionFactoryOptions originalOptions, Option<T> option, Supplier<T> valueSupplier,
				Predicate<T> setIf) {
			if (originalOptions.hasOption(option)) {
				return;
			}
			T value = valueSupplier.get();
			if (setIf.test(value)) {
				optionsBuilder.option(option, value);
			}
		}
		private String determineDatabaseName(R2dbcProperties properties) {
			if (properties.isGenerateUniqueName()) {
				return properties.determineUniqueName();
			}
			if (StringUtils.hasLength(properties.getName())) {
				return properties.getName();
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
public interface R2dbcConnectionDetails extends ConnectionDetails {
	/**
	 * Connection factory options for connecting to the database.
	 * @return the connection factory options
	 */
	ConnectionFactoryOptions getConnectionFactoryOptions();
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class ConnectionFactoryBeanCreationFailureAnalyzer
		extends AbstractFailureAnalyzer<ConnectionFactoryBeanCreationException> {
	private final Environment environment;
	ConnectionFactoryBeanCreationFailureAnalyzer(Environment environment) {
		this.environment = environment;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, ConnectionFactoryBeanCreationException cause) {
		return getFailureAnalysis(cause);
	}
	private FailureAnalysis getFailureAnalysis(ConnectionFactoryBeanCreationException cause) {
		String description = getDescription(cause);
		String action = getAction(cause);
		return new FailureAnalysis(description, action, cause);
	}
	private String getDescription(ConnectionFactoryBeanCreationException cause) {
		StringBuilder description = new StringBuilder();
		description.append('Failed to configure a ConnectionFactory: ');
		if (!StringUtils.hasText(cause.getUrl())) {
			description.append('"url" attribute is not specified and ');
		}
		description.append(String.format('no embedded database could be configured.%n'));
		description.append(String.format('%nReason: %s%n', cause.getMessage()));
		return description.toString();
	}
	private String getAction(ConnectionFactoryBeanCreationException cause) {
		StringBuilder action = new StringBuilder();
		action.append(String.format('Consider the following:%n'));
		if (EmbeddedDatabaseConnection.NONE == cause.getEmbeddedDatabaseConnection()) {
			action.append(String.format('\tIf you want an embedded database (H2), please put it on the classpath.%n'));
		}
		else {
			action.append(String.format('\tReview the configuration of %s%n.', cause.getEmbeddedDatabaseConnection()));
		}
		action
			.append('\tIf you have database settings to be loaded from a particular '
					+ 'profile you may need to activate it')
			.append(getActiveProfiles());
		return action.toString();
	}
	private String getActiveProfiles() {
		StringBuilder message = new StringBuilder();
		String[] profiles = this.environment.getActiveProfiles();
		if (ObjectUtils.isEmpty(profiles)) {
			message.append(' (no profiles are currently active).');
		}
		else {
			message.append(' (the profiles ');
			message.append(StringUtils.arrayToCommaDelimitedString(profiles));
			message.append(' are currently active).');
		}
		return message.toString();
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class MissingR2dbcPoolDependencyFailureAnalyzer extends AbstractFailureAnalyzer<MissingR2dbcPoolDependencyException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, MissingR2dbcPoolDependencyException cause) {
		return new FailureAnalysis(cause.getMessage(),
				'Update your application"s build to depend on io.r2dbc:r2dbc-pool or your application"s configuration '
						+ 'to disable R2DBC connection pooling.',
				cause);
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@AutoConfiguration
@ConditionalOnClass({ ConnectionFactory.class, ProxyConnectionFactory.class })
public class R2dbcProxyAutoConfiguration {
	@Bean
	ConnectionFactoryDecorator connectionFactoryDecorator(
			ObjectProvider<ProxyConnectionFactoryCustomizer> customizers) {
		return (connectionFactory) -> {
			ProxyConnectionFactory.Builder builder = ProxyConnectionFactory.builder(connectionFactory);
			customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
			return builder.build();
		};
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@AutoConfiguration(before = TransactionAutoConfiguration.class)
@ConditionalOnClass({ R2dbcTransactionManager.class, ReactiveTransactionManager.class })
@ConditionalOnSingleCandidate(ConnectionFactory.class)
@AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE)
public class R2dbcTransactionManagerAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(ReactiveTransactionManager.class)
	public R2dbcTransactionManager connectionFactoryTransactionManager(ConnectionFactory connectionFactory) {
		return new R2dbcTransactionManager(connectionFactory);
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class NoConnectionFactoryBeanFailureAnalyzer extends AbstractFailureAnalyzer<NoSuchBeanDefinitionException>
		implements Ordered {
	private final ClassLoader classLoader;
	NoConnectionFactoryBeanFailureAnalyzer() {
		this(NoConnectionFactoryBeanFailureAnalyzer.class.getClassLoader());
	}
	NoConnectionFactoryBeanFailureAnalyzer(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchBeanDefinitionException cause) {
		if (ConnectionFactory.class.equals(cause.getBeanType())
				&& this.classLoader.getResource('META-INF/services/io.r2dbc.spi.ConnectionFactoryProvider') == null) {
			return new FailureAnalysis('No R2DBC ConnectionFactory bean is available '
					+ 'and no /META-INF/services/io.r2dbc.spi.ConnectionFactoryProvider resource could be found.',
					'Check that the R2DBC driver for your database is on the classpath.', cause);
		}
		return null;
	}
	@Override
	public int getOrder() {
		return 0;
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class ConnectionFactoryOptionsInitializer {
	/**
	 * Initialize a {@link Builder ConnectionFactoryOptions.Builder} using the specified
	 * properties.
	 * @param properties the properties to use to initialize the builder
	 * @param connectionDetails the connection details to use to initialize the builder
	 * @param embeddedDatabaseConnection the embedded connection to use as a fallback
	 * @return an initialized builder
	 * @throws ConnectionFactoryBeanCreationException if no suitable connection could be
	 * determined
	 */
	ConnectionFactoryOptions.Builder initialize(R2dbcProperties properties, R2dbcConnectionDetails connectionDetails,
			Supplier<EmbeddedDatabaseConnection> embeddedDatabaseConnection) {
		if (connectionDetails != null) {
			return connectionDetails.getConnectionFactoryOptions().mutate();
		}
		EmbeddedDatabaseConnection embeddedConnection = embeddedDatabaseConnection.get();
		if (embeddedConnection != EmbeddedDatabaseConnection.NONE) {
			return initializeEmbeddedOptions(properties, embeddedConnection);
		}
		throw connectionFactoryBeanCreationException('Failed to determine a suitable R2DBC Connection URL', null,
				embeddedConnection);
	}
	private Builder initializeEmbeddedOptions(R2dbcProperties properties,
			EmbeddedDatabaseConnection embeddedDatabaseConnection) {
		String url = embeddedDatabaseConnection.getUrl(determineEmbeddedDatabaseName(properties));
		if (url == null) {
			throw connectionFactoryBeanCreationException('Failed to determine a suitable R2DBC Connection URL', url,
					embeddedDatabaseConnection);
		}
		Builder builder = ConnectionFactoryOptions.parse(url).mutate();
		String username = determineEmbeddedUsername(properties);
		if (StringUtils.hasText(username)) {
			builder.option(ConnectionFactoryOptions.USER, username);
		}
		if (StringUtils.hasText(properties.getPassword())) {
			builder.option(ConnectionFactoryOptions.PASSWORD, properties.getPassword());
		}
		return builder;
	}
	private String determineEmbeddedDatabaseName(R2dbcProperties properties) {
		String databaseName = determineDatabaseName(properties);
		return (databaseName != null) ? databaseName : 'testdb';
	}
	private String determineDatabaseName(R2dbcProperties properties) {
		if (properties.isGenerateUniqueName()) {
			return properties.determineUniqueName();
		}
		if (StringUtils.hasLength(properties.getName())) {
			return properties.getName();
		}
		return null;
	}
	private String determineEmbeddedUsername(R2dbcProperties properties) {
		String username = ifHasText(properties.getUsername());
		return (username != null) ? username : 'sa';
	}
	private ConnectionFactoryBeanCreationException connectionFactoryBeanCreationException(String message,
			String r2dbcUrl, EmbeddedDatabaseConnection embeddedDatabaseConnection) {
		return new ConnectionFactoryBeanCreationException(message, r2dbcUrl, embeddedDatabaseConnection);
	}
	private String ifHasText(String candidate) {
		return (StringUtils.hasText(candidate)) ? candidate : null;
	}
	static class ConnectionFactoryBeanCreationException extends BeanCreationException {
		private final String url;
		private final EmbeddedDatabaseConnection embeddedDatabaseConnection;
		ConnectionFactoryBeanCreationException(String message, String url,
				EmbeddedDatabaseConnection embeddedDatabaseConnection) {
			super(message);
			this.url = url;
			this.embeddedDatabaseConnection = embeddedDatabaseConnection;
		}
		String getUrl() {
			return this.url;
		}
		EmbeddedDatabaseConnection getEmbeddedDatabaseConnection() {
			return this.embeddedDatabaseConnection;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(DatabaseClient.class)
@ConditionalOnSingleCandidate(ConnectionFactory.class)
class ConnectionFactoryDependentConfiguration {
	@Bean
	@ConditionalOnMissingBean
	DatabaseClient r2dbcDatabaseClient(ConnectionFactory connectionFactory) {
		return DatabaseClient.builder().connectionFactory(connectionFactory).build();
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@ConfigurationProperties(prefix = 'spring.r2dbc')
public class R2dbcProperties {
	/**
	 * Database name. Set if no name is specified in the url. Default to 'testdb' when
	 * using an embedded database.
	 */
	private String name;
	/**
	 * Whether to generate a random database name. Ignore any configured name when
	 * enabled.
	 */
	private boolean generateUniqueName;
	/**
	 * R2DBC URL of the database. database name, username, password and pooling options
	 * specified in the url take precedence over individual options.
	 */
	private String url;
	/**
	 * Login username of the database. Set if no username is specified in the url.
	 */
	private String username;
	/**
	 * Login password of the database. Set if no password is specified in the url.
	 */
	private String password;
	/**
	 * Additional R2DBC options.
	 */
	private final Map<String, String> properties = new LinkedHashMap<>();
	private final Pool pool = new Pool();
	private String uniqueName;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public boolean isGenerateUniqueName() {
		return this.generateUniqueName;
	}
	public void setGenerateUniqueName(boolean generateUniqueName) {
		this.generateUniqueName = generateUniqueName;
	}
	public String getUrl() {
		return this.url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Map<String, String> getProperties() {
		return this.properties;
	}
	public Pool getPool() {
		return this.pool;
	}
	/**
	 * Provide a unique name specific to this instance. Calling this method several times
	 * return the same unique name.
	 * @return a unique name for this instance
	 */
	public String determineUniqueName() {
		if (this.uniqueName == null) {
			this.uniqueName = UUID.randomUUID().toString();
		}
		return this.uniqueName;
	}
	public static class Pool {
		/**
		 * Minimal number of idle connections.
		 */
		private int minIdle = 0;
		/**
		 * Maximum amount of time that a connection is allowed to sit idle in the pool.
		 */
		private Duration maxIdleTime = Duration.ofMinutes(30);
		/**
		 * Maximum lifetime of a connection in the pool. By default, connections have an
		 * infinite lifetime.
		 */
		private Duration maxLifeTime;
		/**
		 * Maximum time to acquire a connection from the pool. By default, wait
		 * indefinitely.
		 */
		private Duration maxAcquireTime;
		/**
		 * Maximum time to validate a connection from the pool. By default, wait
		 * indefinitely.
		 */
		private Duration maxValidationTime;
		/**
		 * Maximum time to wait to create a new connection. By default, wait indefinitely.
		 */
		private Duration maxCreateConnectionTime;
		/**
		 * Initial connection pool size.
		 */
		private int initialSize = 10;
		/**
		 * Maximal connection pool size.
		 */
		private int maxSize = 10;
		/**
		 * Validation query.
		 */
		private String validationQuery;
		/**
		 * Validation depth.
		 */
		private ValidationDepth validationDepth = ValidationDepth.LOCAL;
		/**
		 * Whether pooling is enabled. Requires r2dbc-pool.
		 */
		private boolean enabled = true;
		public int getMinIdle() {
			return this.minIdle;
		}
		public void setMinIdle(int minIdle) {
			this.minIdle = minIdle;
		}
		public Duration getMaxIdleTime() {
			return this.maxIdleTime;
		}
		public void setMaxIdleTime(Duration maxIdleTime) {
			this.maxIdleTime = maxIdleTime;
		}
		public Duration getMaxLifeTime() {
			return this.maxLifeTime;
		}
		public void setMaxLifeTime(Duration maxLifeTime) {
			this.maxLifeTime = maxLifeTime;
		}
		public Duration getMaxValidationTime() {
			return this.maxValidationTime;
		}
		public void setMaxValidationTime(Duration maxValidationTime) {
			this.maxValidationTime = maxValidationTime;
		}
		public Duration getMaxAcquireTime() {
			return this.maxAcquireTime;
		}
		public void setMaxAcquireTime(Duration maxAcquireTime) {
			this.maxAcquireTime = maxAcquireTime;
		}
		public Duration getMaxCreateConnectionTime() {
			return this.maxCreateConnectionTime;
		}
		public void setMaxCreateConnectionTime(Duration maxCreateConnectionTime) {
			this.maxCreateConnectionTime = maxCreateConnectionTime;
		}
		public int getInitialSize() {
			return this.initialSize;
		}
		public void setInitialSize(int initialSize) {
			this.initialSize = initialSize;
		}
		public int getMaxSize() {
			return this.maxSize;
		}
		public void setMaxSize(int maxSize) {
			this.maxSize = maxSize;
		}
		public String getValidationQuery() {
			return this.validationQuery;
		}
		public void setValidationQuery(String validationQuery) {
			this.validationQuery = validationQuery;
		}
		public ValidationDepth getValidationDepth() {
			return this.validationDepth;
		}
		public void setValidationDepth(ValidationDepth validationDepth) {
			this.validationDepth = validationDepth;
		}
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class MultipleConnectionPoolConfigurationsFailureAnalyzer
		extends AbstractFailureAnalyzer<MultipleConnectionPoolConfigurationsException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, MultipleConnectionPoolConfigurationsException cause) {
		return new FailureAnalysis(cause.getMessage(),
				'Update your configuration so that R2DBC connection pooling is configured using either the '
						+ 'spring.r2dbc.url property or the spring.r2dbc.pool.* properties',
				cause);
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class MissingR2dbcPoolDependencyException extends RuntimeException {
	MissingR2dbcPoolDependencyException() {
		super('R2DBC connection pooling has been configured but the io.r2dbc.pool.ConnectionPool class is not '
				+ 'present.');
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class MultipleConnectionPoolConfigurationsException extends RuntimeException {
	MultipleConnectionPoolConfigurationsException() {
		super('R2DBC connection pooling configuration should be provided by either the spring.r2dbc.pool.* '
				+ 'properties or the spring.r2dbc.url property but both have been used.');
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@FunctionalInterface
public interface ConnectionFactoryOptionsBuilderCustomizer {
	/**
	 * Customize the {@link Builder}.
	 * @param builder the builder to customize
	 */
	void customize(Builder builder);
}
/*
/**
package org.springframework.boot.autoconfigure.r2dbc;
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@FunctionalInterface
public interface ProxyConnectionFactoryCustomizer {
	/**
	 * Callback to customize a {@link Builder} instance.
	 * @param builder the builder to customize
	 */
	void customize(Builder builder);
}
/*
package org.springframework.boot.autoconfigure.mustache;
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(MustacheViewResolver.class)
class MustacheServletWebConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(prefix = 'spring.mustache', name = 'enabled', matchIfMissing = true)
	MustacheViewResolver mustacheViewResolver(Compiler mustacheCompiler, MustacheProperties mustache) {
		MustacheViewResolver resolver = new MustacheViewResolver(mustacheCompiler);
		resolver.setPrefix(mustache.getPrefix());
		resolver.setSuffix(mustache.getSuffix());
		resolver.setCache(mustache.getServlet().isCache());
		if (mustache.getServlet().getContentType() != null) {
			resolver.setContentType(mustache.getServlet().getContentType().toString());
		}
		resolver.setViewNames(mustache.getViewNames());
		resolver.setExposeRequestAttributes(mustache.getServlet().isExposeRequestAttributes());
		resolver.setAllowRequestOverride(mustache.getServlet().isAllowRequestOverride());
		resolver.setAllowSessionOverride(mustache.getServlet().isAllowSessionOverride());
		resolver.setExposeSessionAttributes(mustache.getServlet().isExposeSessionAttributes());
		resolver.setExposeSpringMacroHelpers(mustache.getServlet().isExposeSpringMacroHelpers());
		resolver.setRequestContextAttribute(mustache.getRequestContextAttribute());
		resolver.setCharset(mustache.getCharsetName());
		resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
		return resolver;
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
@AutoConfiguration
@ConditionalOnClass(Mustache.class)
@EnableConfigurationProperties(MustacheProperties.class)
@Import({ MustacheServletWebConfiguration.class, MustacheReactiveWebConfiguration.class })
public class MustacheAutoConfiguration {
	private static final Log logger = LogFactory.getLog(MustacheAutoConfiguration.class);
	private final MustacheProperties mustache;
	private final ApplicationContext applicationContext;
	public MustacheAutoConfiguration(MustacheProperties mustache, ApplicationContext applicationContext) {
		this.mustache = mustache;
		this.applicationContext = applicationContext;
		checkTemplateLocationExists();
	}
	public void checkTemplateLocationExists() {
		if (this.mustache.isCheckTemplateLocation()) {
			TemplateLocation location = new TemplateLocation(this.mustache.getPrefix());
			if (!location.exists(this.applicationContext) && logger.isWarnEnabled()) {
				logger.warn('Cannot find template location: ' + location
						+ ' (please add some templates, check your Mustache configuration, or set spring.mustache.'
						+ 'check-template-location=false)');
			}
		}
	}
	@Bean
	@ConditionalOnMissingBean
	public Mustache.Compiler mustacheCompiler(TemplateLoader mustacheTemplateLoader) {
		return Mustache.compiler().withLoader(mustacheTemplateLoader);
	}
	@Bean
	@ConditionalOnMissingBean(TemplateLoader.class)
	public MustacheResourceTemplateLoader mustacheTemplateLoader() {
		MustacheResourceTemplateLoader loader = new MustacheResourceTemplateLoader(this.mustache.getPrefix(),
				this.mustache.getSuffix());
		loader.setCharset(this.mustache.getCharsetName());
		return loader;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.mustache;
/*
package org.springframework.boot.autoconfigure.mustache;
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.REACTIVE)
class MustacheReactiveWebConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(prefix = 'spring.mustache', name = 'enabled', matchIfMissing = true)
	MustacheViewResolver mustacheViewResolver(Compiler mustacheCompiler, MustacheProperties mustache) {
		MustacheViewResolver resolver = new MustacheViewResolver(mustacheCompiler);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(mustache::getPrefix).to(resolver::setPrefix);
		map.from(mustache::getSuffix).to(resolver::setSuffix);
		map.from(mustache::getViewNames).to(resolver::setViewNames);
		map.from(mustache::getRequestContextAttribute).to(resolver::setRequestContextAttribute);
		map.from(mustache::getCharsetName).to(resolver::setCharset);
		map.from(mustache.getReactive()::getMediaTypes).to(resolver::setSupportedMediaTypes);
		resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
		return resolver;
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
public class MustacheResourceTemplateLoader implements TemplateLoader, ResourceLoaderAware {
	private String prefix = '';
	private String suffix = '';
	private String charSet = 'UTF-8';
	private ResourceLoader resourceLoader = new DefaultResourceLoader(null);
	public MustacheResourceTemplateLoader() {
	}
	public MustacheResourceTemplateLoader(String prefix, String suffix) {
		this.prefix = prefix;
		this.suffix = suffix;
	}
	/**
	 * Set the charset.
	 * @param charSet the charset
	 */
	public void setCharset(String charSet) {
		this.charSet = charSet;
	}
	/**
	 * Set the resource loader.
	 * @param resourceLoader the resource loader
	 */
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	@Override
	public Reader getTemplate(String name) throws Exception {
		return new InputStreamReader(this.resourceLoader.getResource(this.prefix + name + this.suffix).getInputStream(),
				this.charSet);
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
public class MustacheTemplateAvailabilityProvider implements TemplateAvailabilityProvider {
	@Override
	public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader,
			ResourceLoader resourceLoader) {
		if (ClassUtils.isPresent('com.samskivert.mustache.Template', classLoader)) {
			String prefix = environment.getProperty('spring.mustache.prefix', MustacheProperties.DEFAULT_PREFIX);
			String suffix = environment.getProperty('spring.mustache.suffix', MustacheProperties.DEFAULT_SUFFIX);
			return resourceLoader.getResource(prefix + view + suffix).exists();
		}
		return false;
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
@ConfigurationProperties(prefix = 'spring.mustache')
public class MustacheProperties {
	private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf('text/html');
	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	public static final String DEFAULT_PREFIX = 'classpath:/templates/';
	public static final String DEFAULT_SUFFIX = '.mustache';
	private final Servlet servlet = new Servlet();
	private final Reactive reactive = new Reactive();
	/**
	 * View names that can be resolved.
	 */
	private String[] viewNames;
	/**
	 * Name of the RequestContext attribute for all views.
	 */
	private String requestContextAttribute;
	/**
	 * Whether to enable MVC view resolution for Mustache.
	 */
	private boolean enabled = true;
	/**
	 * Template encoding.
	 */
	private Charset charset = DEFAULT_CHARSET;
	/**
	 * Whether to check that the templates location exists.
	 */
	private boolean checkTemplateLocation = true;
	/**
	 * Prefix to apply to template names.
	 */
	private String prefix = DEFAULT_PREFIX;
	/**
	 * Suffix to apply to template names.
	 */
	private String suffix = DEFAULT_SUFFIX;
	public Servlet getServlet() {
		return this.servlet;
	}
	public Reactive getReactive() {
		return this.reactive;
	}
	public String getPrefix() {
		return this.prefix;
	}
	public void setPrefix(String prefix) {
		this.prefix = prefix;
	}
	public String getSuffix() {
		return this.suffix;
	}
	public void setSuffix(String suffix) {
		this.suffix = suffix;
	}
	public String[] getViewNames() {
		return this.viewNames;
	}
	public void setViewNames(String[] viewNames) {
		this.viewNames = viewNames;
	}
	public String getRequestContextAttribute() {
		return this.requestContextAttribute;
	}
	public void setRequestContextAttribute(String requestContextAttribute) {
		this.requestContextAttribute = requestContextAttribute;
	}
	public Charset getCharset() {
		return this.charset;
	}
	public String getCharsetName() {
		return (this.charset != null) ? this.charset.name() : null;
	}
	public void setCharset(Charset charset) {
		this.charset = charset;
	}
	public boolean isCheckTemplateLocation() {
		return this.checkTemplateLocation;
	}
	public void setCheckTemplateLocation(boolean checkTemplateLocation) {
		this.checkTemplateLocation = checkTemplateLocation;
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public static class Servlet {
		/**
		 * Whether HttpServletRequest attributes are allowed to override (hide) controller
		 * generated model attributes of the same name.
		 */
		private boolean allowRequestOverride = false;
		/**
		 * Whether HttpSession attributes are allowed to override (hide) controller
		 * generated model attributes of the same name.
		 */
		private boolean allowSessionOverride = false;
		/**
		 * Whether to enable template caching.
		 */
		private boolean cache;
		/**
		 * Content-Type value.
		 */
		private MimeType contentType = DEFAULT_CONTENT_TYPE;
		/**
		 * Whether all request attributes should be added to the model prior to merging
		 * with the template.
		 */
		private boolean exposeRequestAttributes = false;
		/**
		 * Whether all HttpSession attributes should be added to the model prior to
		 * merging with the template.
		 */
		private boolean exposeSessionAttributes = false;
		/**
		 * Whether to expose a RequestContext for use by Spring"s macro library, under the
		 * name 'springMacroRequestContext'.
		 */
		private boolean exposeSpringMacroHelpers = true;
		public boolean isAllowRequestOverride() {
			return this.allowRequestOverride;
		}
		public void setAllowRequestOverride(boolean allowRequestOverride) {
			this.allowRequestOverride = allowRequestOverride;
		}
		public boolean isAllowSessionOverride() {
			return this.allowSessionOverride;
		}
		public void setAllowSessionOverride(boolean allowSessionOverride) {
			this.allowSessionOverride = allowSessionOverride;
		}
		public boolean isCache() {
			return this.cache;
		}
		public void setCache(boolean cache) {
			this.cache = cache;
		}
		public MimeType getContentType() {
			return this.contentType;
		}
		public void setContentType(MimeType contentType) {
			this.contentType = contentType;
		}
		public boolean isExposeRequestAttributes() {
			return this.exposeRequestAttributes;
		}
		public void setExposeRequestAttributes(boolean exposeRequestAttributes) {
			this.exposeRequestAttributes = exposeRequestAttributes;
		}
		public boolean isExposeSessionAttributes() {
			return this.exposeSessionAttributes;
		}
		public void setExposeSessionAttributes(boolean exposeSessionAttributes) {
			this.exposeSessionAttributes = exposeSessionAttributes;
		}
		public boolean isExposeSpringMacroHelpers() {
			return this.exposeSpringMacroHelpers;
		}
		public void setExposeSpringMacroHelpers(boolean exposeSpringMacroHelpers) {
			this.exposeSpringMacroHelpers = exposeSpringMacroHelpers;
		}
	}
	public static class Reactive {
		/**
		 * Media types supported by Mustache views.
		 */
		private List<MediaType> mediaTypes;
		public List<MediaType> getMediaTypes() {
			return this.mediaTypes;
		}
		public void setMediaTypes(List<MediaType> mediaTypes) {
			this.mediaTypes = mediaTypes;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
@AutoConfiguration(after = JacksonAutoConfiguration.class)
@ConditionalOnClass({ io.rsocket.RSocket.class, RSocketStrategies.class, PooledByteBufAllocator.class })
public class RSocketStrategiesAutoConfiguration {
	private static final String PATHPATTERN_ROUTEMATCHER_CLASS = 'org.springframework.web.util.pattern.PathPatternRouteMatcher';
	@Bean
	@ConditionalOnMissingBean
	public RSocketStrategies rSocketStrategies(ObjectProvider<RSocketStrategiesCustomizer> customizers) {
		RSocketStrategies.Builder builder = RSocketStrategies.builder();
		if (ClassUtils.isPresent(PATHPATTERN_ROUTEMATCHER_CLASS, null)) {
			builder.routeMatcher(new PathPatternRouteMatcher());
		}
		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ ObjectMapper.class, CBORFactory.class })
	protected static class JacksonCborStrategyConfiguration {
		private static final MediaType[] SUPPORTED_TYPES = { MediaType.APPLICATION_CBOR };
		@Bean
		@Order(0)
		@ConditionalOnBean(Jackson2ObjectMapperBuilder.class)
		public RSocketStrategiesCustomizer jacksonCborRSocketStrategyCustomizer(Jackson2ObjectMapperBuilder builder) {
			return (strategy) -> {
				ObjectMapper objectMapper = builder.createXmlMapper(false).factory(new CBORFactory()).build();
				strategy.decoder(new Jackson2CborDecoder(objectMapper, SUPPORTED_TYPES));
				strategy.encoder(new Jackson2CborEncoder(objectMapper, SUPPORTED_TYPES));
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ObjectMapper.class)
	protected static class JacksonJsonStrategyConfiguration {
		private static final MediaType[] SUPPORTED_TYPES = { MediaType.APPLICATION_JSON,
				new MediaType('application', '*+json') };
		@Bean
		@Order(1)
		@ConditionalOnBean(ObjectMapper.class)
		public RSocketStrategiesCustomizer jacksonJsonRSocketStrategyCustomizer(ObjectMapper objectMapper) {
			return (strategy) -> {
				strategy.decoder(new Jackson2JsonDecoder(objectMapper, SUPPORTED_TYPES));
				strategy.encoder(new Jackson2JsonEncoder(objectMapper, SUPPORTED_TYPES));
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
@FunctionalInterface
public interface RSocketMessageHandlerCustomizer {
	/**
	 * Customize the {@link RSocketMessageHandler}.
	 * @param messageHandler the message handler to customize
	 */
	void customize(RSocketMessageHandler messageHandler);
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
@ConfigurationProperties('spring.rsocket')
public class RSocketProperties {
	@NestedConfigurationProperty
	private final Server server = new Server();
	public Server getServer() {
		return this.server;
	}
	public static class Server {
		/**
		 * Server port.
		 */
		private Integer port;
		/**
		 * Network address to which the server should bind.
		 */
		private InetAddress address;
		/**
		 * RSocket transport protocol.
		 */
		private RSocketServer.Transport transport = RSocketServer.Transport.TCP;
		/**
		 * Path under which RSocket handles requests (only works with websocket
		 * transport).
		 */
		private String mappingPath;
		/**
		 * Maximum transmission unit. Frames larger than the specified value are
		 * fragmented.
		 */
		private DataSize fragmentSize;
		@NestedConfigurationProperty
		private Ssl ssl;
		private final Spec spec = new Spec();
		public Integer getPort() {
			return this.port;
		}
		public void setPort(Integer port) {
			this.port = port;
		}
		public InetAddress getAddress() {
			return this.address;
		}
		public void setAddress(InetAddress address) {
			this.address = address;
		}
		public RSocketServer.Transport getTransport() {
			return this.transport;
		}
		public void setTransport(RSocketServer.Transport transport) {
			this.transport = transport;
		}
		public String getMappingPath() {
			return this.mappingPath;
		}
		public void setMappingPath(String mappingPath) {
			this.mappingPath = mappingPath;
		}
		public DataSize getFragmentSize() {
			return this.fragmentSize;
		}
		public void setFragmentSize(DataSize fragmentSize) {
			this.fragmentSize = fragmentSize;
		}
		public Ssl getSsl() {
			return this.ssl;
		}
		public void setSsl(Ssl ssl) {
			this.ssl = ssl;
		}
		public Spec getSpec() {
			return this.spec;
		}
		public static class Spec {
			/**
			 * Sub-protocols to use in websocket handshake signature.
			 */
			private String protocols;
			/**
			 * Maximum allowable frame payload length.
			 */
			private DataSize maxFramePayloadLength = DataSize.ofBytes(65536);
			/**
			 * Whether to proxy websocket ping frames or respond to them.
			 */
			private boolean handlePing;
			/**
			 * Whether the websocket compression extension is enabled.
			 */
			private boolean compress;
			public String getProtocols() {
				return this.protocols;
			}
			public void setProtocols(String protocols) {
				this.protocols = protocols;
			}
			public DataSize getMaxFramePayloadLength() {
				return this.maxFramePayloadLength;
			}
			public void setMaxFramePayloadLength(DataSize maxFramePayloadLength) {
				this.maxFramePayloadLength = maxFramePayloadLength;
			}
			public boolean isHandlePing() {
				return this.handlePing;
			}
			public void setHandlePing(boolean handlePing) {
				this.handlePing = handlePing;
			}
			public boolean isCompress() {
				return this.compress;
			}
			public void setCompress(boolean compress) {
				this.compress = compress;
			}
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.rsocket;
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
@AutoConfiguration(after = RSocketStrategiesAutoConfiguration.class)
@ConditionalOnClass({ RSocketRequester.class, io.rsocket.RSocket.class, HttpServer.class, TcpServerTransport.class })
public class RSocketRequesterAutoConfiguration {
	@Bean
	@Scope('prototype')
	@ConditionalOnMissingBean
	public RSocketRequester.Builder rSocketRequesterBuilder(RSocketStrategies strategies,
			ObjectProvider<RSocketConnectorConfigurer> connectorConfigurers) {
		Builder builder = RSocketRequester.builder().rsocketStrategies(strategies);
		connectorConfigurers.orderedStream().forEach(builder::rsocketConnector);
		return builder;
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
class RSocketWebSocketNettyRouteProvider implements NettyRouteProvider {
	private final String mappingPath;
	private final SocketAcceptor socketAcceptor;
	private final List<RSocketServerCustomizer> customizers;
	private final Consumer<Builder> serverSpecCustomizer;
	RSocketWebSocketNettyRouteProvider(String mappingPath, SocketAcceptor socketAcceptor,
			Consumer<Builder> serverSpecCustomizer, Stream<RSocketServerCustomizer> customizers) {
		this.mappingPath = mappingPath;
		this.socketAcceptor = socketAcceptor;
		this.serverSpecCustomizer = serverSpecCustomizer;
		this.customizers = customizers.toList();
	}
	@Override
	public HttpServerRoutes apply(HttpServerRoutes httpServerRoutes) {
		RSocketServer server = RSocketServer.create(this.socketAcceptor);
		this.customizers.forEach((customizer) -> customizer.customize(server));
		ServerTransport.ConnectionAcceptor connectionAcceptor = server.asConnectionAcceptor();
		return httpServerRoutes.ws(this.mappingPath, WebsocketRouteTransport.newHandler(connectionAcceptor),
				createWebsocketServerSpec());
	}
	private WebsocketServerSpec createWebsocketServerSpec() {
		WebsocketServerSpec.Builder builder = WebsocketServerSpec.builder();
		this.serverSpecCustomizer.accept(builder);
		return builder.build();
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
@AutoConfiguration(after = RSocketStrategiesAutoConfiguration.class)
@ConditionalOnClass({ RSocketServer.class, RSocketStrategies.class, HttpServer.class, TcpServerTransport.class })
@ConditionalOnBean(RSocketMessageHandler.class)
@EnableConfigurationProperties(RSocketProperties.class)
public class RSocketServerAutoConfiguration {
	@Conditional(OnRSocketWebServerCondition.class)
	@Configuration(proxyBeanMethods = false)
	static class WebFluxServerConfiguration {
		@Bean
		@ConditionalOnMissingBean
		RSocketWebSocketNettyRouteProvider rSocketWebsocketRouteProvider(RSocketProperties properties,
				RSocketMessageHandler messageHandler, ObjectProvider<RSocketServerCustomizer> customizers) {
			return new RSocketWebSocketNettyRouteProvider(properties.getServer().getMappingPath(),
					messageHandler.responder(), customizeWebsocketServerSpec(properties.getServer().getSpec()),
					customizers.orderedStream());
		}
		private Consumer<Builder> customizeWebsocketServerSpec(Spec spec) {
			return (builder) -> {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(spec.getProtocols()).to(builder::protocols);
				map.from(spec.getMaxFramePayloadLength()).asInt(DataSize::toBytes).to(builder::maxFramePayloadLength);
				map.from(spec.isHandlePing()).to(builder::handlePing);
				map.from(spec.isCompress()).to(builder::compress);
			};
		}
	}
	@ConditionalOnProperty(prefix = 'spring.rsocket.server', name = 'port')
	@ConditionalOnClass(ReactorResourceFactory.class)
	@Configuration(proxyBeanMethods = false)
	@Import(ReactorNettyConfigurations.ReactorResourceFactoryConfiguration.class)
	static class EmbeddedServerConfiguration {
		@Bean
		@ConditionalOnMissingBean
		RSocketServerFactory rSocketServerFactory(RSocketProperties properties, ReactorResourceFactory resourceFactory,
				ObjectProvider<RSocketServerCustomizer> customizers, ObjectProvider<SslBundles> sslBundles) {
			NettyRSocketServerFactory factory = new NettyRSocketServerFactory();
			factory.setResourceFactory(resourceFactory);
			factory.setTransport(properties.getServer().getTransport());
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(properties.getServer().getAddress()).to(factory::setAddress);
			map.from(properties.getServer().getPort()).to(factory::setPort);
			map.from(properties.getServer().getFragmentSize()).to(factory::setFragmentSize);
			map.from(properties.getServer().getSsl()).to(factory::setSsl);
			factory.setSslBundles(sslBundles.getIfAvailable());
			factory.setRSocketServerCustomizers(customizers.orderedStream().toList());
			return factory;
		}
		@Bean
		@ConditionalOnMissingBean
		RSocketServerBootstrap rSocketServerBootstrap(RSocketServerFactory rSocketServerFactory,
				RSocketMessageHandler rSocketMessageHandler) {
			return new RSocketServerBootstrap(rSocketServerFactory, rSocketMessageHandler.responder());
		}
		@Bean
		RSocketServerCustomizer frameDecoderRSocketServerCustomizer(RSocketMessageHandler rSocketMessageHandler) {
			return (server) -> {
				if (rSocketMessageHandler.getRSocketStrategies()
					.dataBufferFactory() instanceof NettyDataBufferFactory) {
					server.payloadDecoder(PayloadDecoder.ZERO_COPY);
				}
			};
		}
	}
	static class OnRSocketWebServerCondition extends AllNestedConditions {
		OnRSocketWebServerCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
		static class IsReactiveWebApplication {
		}
		@ConditionalOnProperty(prefix = 'spring.rsocket.server', name = 'port', matchIfMissing = true)
		static class HasNoPortConfigured {
		}
		@ConditionalOnProperty(prefix = 'spring.rsocket.server', name = 'mapping-path')
		static class HasMappingPathConfigured {
		}
		@ConditionalOnProperty(prefix = 'spring.rsocket.server', name = 'transport', havingValue = 'websocket')
		static class HasWebsocketTransportConfigured {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
@AutoConfiguration(after = RSocketStrategiesAutoConfiguration.class)
@ConditionalOnClass({ RSocketRequester.class, io.rsocket.RSocket.class, TcpServerTransport.class })
public class RSocketMessagingAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public RSocketMessageHandler messageHandler(RSocketStrategies rSocketStrategies,
			ObjectProvider<RSocketMessageHandlerCustomizer> customizers) {
		RSocketMessageHandler messageHandler = new RSocketMessageHandler();
		messageHandler.setRSocketStrategies(rSocketStrategies);
		customizers.orderedStream().forEach((customizer) -> customizer.customize(messageHandler));
		return messageHandler;
	}
}
/*
/**
package org.springframework.boot.autoconfigure;
/*
package org.springframework.boot.autoconfigure.websocket.servlet;
/**
public class TomcatWebSocketServletWebServerCustomizer
		implements WebServerFactoryCustomizer<TomcatServletWebServerFactory>, Ordered {
	@Override
	public void customize(TomcatServletWebServerFactory factory) {
		factory.addContextCustomizers((context) -> context.addServletContainerInitializer(new WsSci(), null));
	}
	@Override
	public int getOrder() {
		return 0;
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.servlet;
/**
public class UndertowWebSocketServletWebServerCustomizer
		implements WebServerFactoryCustomizer<UndertowServletWebServerFactory>, Ordered {
	@Override
	public void customize(UndertowServletWebServerFactory factory) {
		WebsocketDeploymentInfoCustomizer customizer = new WebsocketDeploymentInfoCustomizer();
		factory.addDeploymentInfoCustomizers(customizer);
	}
	@Override
	public int getOrder() {
		return 0;
	}
	private static final class WebsocketDeploymentInfoCustomizer implements UndertowDeploymentInfoCustomizer {
		@Override
		public void customize(DeploymentInfo deploymentInfo) {
			WebSocketDeploymentInfo info = new WebSocketDeploymentInfo();
			deploymentInfo.addServletContextAttribute(WebSocketDeploymentInfo.ATTRIBUTE_NAME, info);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.servlet;
/**
@AutoConfiguration(before = ServletWebServerFactoryAutoConfiguration.class)
@ConditionalOnClass({ Servlet.class, ServerContainer.class })
@ConditionalOnWebApplication(type = Type.SERVLET)
public class WebSocketServletAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Tomcat.class, WsSci.class })
	static class TomcatWebSocketConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'websocketServletWebServerCustomizer')
		TomcatWebSocketServletWebServerCustomizer websocketServletWebServerCustomizer() {
			return new TomcatWebSocketServletWebServerCustomizer();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(JakartaWebSocketServletContainerInitializer.class)
	static class JettyWebSocketConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'websocketServletWebServerCustomizer')
		JettyWebSocketServletWebServerCustomizer websocketServletWebServerCustomizer() {
			return new JettyWebSocketServletWebServerCustomizer();
		}
		@Bean
		@ConditionalOnNotWarDeployment
		@Order(Ordered.LOWEST_PRECEDENCE)
		@ConditionalOnMissingBean(name = 'websocketUpgradeFilterWebServerCustomizer')
		WebServerFactoryCustomizer<JettyServletWebServerFactory> websocketUpgradeFilterWebServerCustomizer() {
			return (factory) -> {
				factory.addInitializers((servletContext) -> {
					Dynamic registration = servletContext.addFilter(WebSocketUpgradeFilter.class.getName(),
							new WebSocketUpgradeFilter());
					registration.setAsyncSupported(true);
					registration.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, '/*');
				});
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(io.undertow.websockets.jsr.Bootstrap.class)
	static class UndertowWebSocketConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'websocketServletWebServerCustomizer')
		UndertowWebSocketServletWebServerCustomizer websocketServletWebServerCustomizer() {
			return new UndertowWebSocketServletWebServerCustomizer();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.servlet;
/**
public class JettyWebSocketServletWebServerCustomizer
		implements WebServerFactoryCustomizer<JettyServletWebServerFactory>, Ordered {
	@Override
	public void customize(JettyServletWebServerFactory factory) {
		factory.addConfigurations(new AbstractConfiguration(new AbstractConfiguration.Builder()) {
			@Override
			public void configure(WebAppContext context) throws Exception {
				if (JettyWebSocketServerContainer.getContainer(context.getServletContext()) == null) {
					WebSocketServerComponents.ensureWebSocketComponents(context.getServer(),
							context.getContext().getContextHandler());
					JettyWebSocketServerContainer.ensureContainer(context.getServletContext());
				}
				if (JakartaWebSocketServerContainer.getContainer(context.getServletContext()) == null) {
					WebSocketServerComponents.ensureWebSocketComponents(context.getServer(),
							context.getContext().getContextHandler());
					WebSocketUpgradeFilter.ensureFilter(context.getServletContext());
					WebSocketMappings.ensureMappings(context.getContext().getContextHandler());
					JakartaWebSocketServerContainer.ensureContainer(context.getServletContext());
				}
			}
		});
	}
	@Override
	public int getOrder() {
		return 0;
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.servlet;
/**
@AutoConfiguration(after = JacksonAutoConfiguration.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(WebSocketMessageBrokerConfigurer.class)
public class WebSocketMessagingAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean({ DelegatingWebSocketMessageBrokerConfiguration.class, ObjectMapper.class })
	@ConditionalOnClass({ ObjectMapper.class, AbstractMessageBrokerConfiguration.class })
	static class WebSocketMessageConverterConfiguration implements WebSocketMessageBrokerConfigurer {
		private final ObjectMapper objectMapper;
		private final AsyncTaskExecutor executor;
		WebSocketMessageConverterConfiguration(ObjectMapper objectMapper,
				Map<String, AsyncTaskExecutor> taskExecutors) {
			this.objectMapper = objectMapper;
			this.executor = determineAsyncTaskExecutor(taskExecutors);
		}
		private static AsyncTaskExecutor determineAsyncTaskExecutor(Map<String, AsyncTaskExecutor> taskExecutors) {
			if (taskExecutors.size() == 1) {
				return taskExecutors.values().iterator().next();
			}
			return taskExecutors.get(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME);
		}
		@Override
		public boolean configureMessageConverters(List<MessageConverter> messageConverters) {
			MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter(this.objectMapper);
			DefaultContentTypeResolver resolver = new DefaultContentTypeResolver();
			resolver.setDefaultMimeType(MimeTypeUtils.APPLICATION_JSON);
			converter.setContentTypeResolver(resolver);
			messageConverters.add(new StringMessageConverter());
			messageConverters.add(new ByteArrayMessageConverter());
			messageConverters.add(converter);
			return false;
		}
		@Override
		public void configureClientInboundChannel(ChannelRegistration registration) {
			if (this.executor != null) {
				registration.executor(this.executor);
			}
		}
		@Override
		public void configureClientOutboundChannel(ChannelRegistration registration) {
			if (this.executor != null) {
				registration.executor(this.executor);
			}
		}
		@Bean
		static LazyInitializationExcludeFilter eagerStompWebSocketHandlerMapping() {
			return (name, definition, type) -> name.equals('stompWebSocketHandlerMapping');
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.websocket.servlet;
/*
package org.springframework.boot.autoconfigure.websocket.reactive;
/**
public class JettyWebSocketReactiveWebServerCustomizer
		implements WebServerFactoryCustomizer<JettyReactiveWebServerFactory>, Ordered {
	@Override
	public void customize(JettyReactiveWebServerFactory factory) {
		factory.addServerCustomizers((server) -> {
			ServletContextHandler servletContextHandler = findServletContextHandler(server);
			if (servletContextHandler != null) {
				ServletContext servletContext = servletContextHandler.getServletContext();
				if (JettyWebSocketServerContainer.getContainer(servletContext) == null) {
					WebSocketServerComponents.ensureWebSocketComponents(server, servletContextHandler);
					JettyWebSocketServerContainer.ensureContainer(servletContext);
				}
				if (JakartaWebSocketServerContainer.getContainer(servletContext) == null) {
					WebSocketServerComponents.ensureWebSocketComponents(server, servletContextHandler);
					WebSocketUpgradeFilter.ensureFilter(servletContext);
					WebSocketMappings.ensureMappings(servletContextHandler);
					JakartaWebSocketServerContainer.ensureContainer(servletContext);
				}
			}
		});
	}
	private ServletContextHandler findServletContextHandler(Handler handler) {
		if (handler instanceof ServletContextHandler servletContextHandler) {
			return servletContextHandler;
		}
		if (handler instanceof Handler.Wrapper handlerWrapper) {
			return findServletContextHandler(handlerWrapper.getHandler());
		}
		if (handler instanceof Handler.Collection handlerCollection) {
			for (Handler contained : handlerCollection.getHandlers()) {
				ServletContextHandler servletContextHandler = findServletContextHandler(contained);
				if (servletContextHandler != null) {
					return servletContextHandler;
				}
			}
		}
		return null;
	}
	@Override
	public int getOrder() {
		return 0;
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.reactive;
/**
public class TomcatWebSocketReactiveWebServerCustomizer
		implements WebServerFactoryCustomizer<TomcatReactiveWebServerFactory>, Ordered {
	@Override
	public void customize(TomcatReactiveWebServerFactory factory) {
		factory.addContextCustomizers((context) -> context.addServletContainerInitializer(new WsSci(), null));
	}
	@Override
	public int getOrder() {
		return 0;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.websocket.reactive;
/*
package org.springframework.boot.autoconfigure.websocket.reactive;
/**
@AutoConfiguration(before = ReactiveWebServerFactoryAutoConfiguration.class)
@ConditionalOnClass({ Servlet.class, ServerContainer.class })
@ConditionalOnWebApplication(type = Type.REACTIVE)
public class WebSocketReactiveAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Tomcat.class, WsSci.class })
	static class TomcatWebSocketConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'websocketReactiveWebServerCustomizer')
		TomcatWebSocketReactiveWebServerCustomizer websocketReactiveWebServerCustomizer() {
			return new TomcatWebSocketReactiveWebServerCustomizer();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(JakartaWebSocketServletContainerInitializer.class)
	static class JettyWebSocketConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'websocketReactiveWebServerCustomizer')
		JettyWebSocketReactiveWebServerCustomizer websocketServletWebServerCustomizer() {
			return new JettyWebSocketReactiveWebServerCustomizer();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jsonb;
/**
@AutoConfiguration
@ConditionalOnClass(Jsonb.class)
@ConditionalOnResource(resources = { 'classpath:META-INF/services/jakarta.json.bind.spi.JsonbProvider',
		'classpath:META-INF/services/jakarta.json.spi.JsonProvider' })
public class JsonbAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public Jsonb jsonb() {
		return JsonbBuilder.create();
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jsonb;
/*
package org.springframework.boot.autoconfigure.diagnostics.analyzer;
/**
class NoSuchBeanDefinitionFailureAnalyzer extends AbstractInjectionFailureAnalyzer<NoSuchBeanDefinitionException> {
	private final ConfigurableListableBeanFactory beanFactory;
	private final MetadataReaderFactory metadataReaderFactory;
	private final ConditionEvaluationReport report;
	NoSuchBeanDefinitionFailureAnalyzer(BeanFactory beanFactory) {
		Assert.isInstanceOf(ConfigurableListableBeanFactory.class, beanFactory);
		this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
		this.metadataReaderFactory = new CachingMetadataReaderFactory(this.beanFactory.getBeanClassLoader());
		// Get early as won"t be accessible once context has failed to start
		this.report = ConditionEvaluationReport.get(this.beanFactory);
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, NoSuchBeanDefinitionException cause, String description) {
		if (cause.getNumberOfBeansFound() != 0) {
			return null;
		}
		List<AutoConfigurationResult> autoConfigurationResults = getAutoConfigurationResults(cause);
		List<UserConfigurationResult> userConfigurationResults = getUserConfigurationResults(cause);
		StringBuilder message = new StringBuilder();
		message.append(String.format('%s required %s that could not be found.%n',
				(description != null) ? description : 'A component', getBeanDescription(cause)));
		InjectionPoint injectionPoint = findInjectionPoint(rootFailure);
		if (injectionPoint != null) {
			Annotation[] injectionAnnotations = injectionPoint.getAnnotations();
			if (injectionAnnotations.length > 0) {
				message.append(String.format('%nThe injection point has the following annotations:%n'));
				for (Annotation injectionAnnotation : injectionAnnotations) {
					message.append(String.format('\t- %s%n', injectionAnnotation));
				}
			}
		}
		if (!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty()) {
			message.append(String.format('%nThe following candidates were found but could not be injected:%n'));
			for (AutoConfigurationResult result : autoConfigurationResults) {
				message.append(String.format('\t- %s%n', result));
			}
			for (UserConfigurationResult result : userConfigurationResults) {
				message.append(String.format('\t- %s%n', result));
			}
		}
		String action = String.format('Consider %s %s in your configuration.',
				(!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty())
						? 'revisiting the entries above or defining' : 'defining',
				getBeanDescription(cause));
		return new FailureAnalysis(message.toString(), action, cause);
	}
	private String getBeanDescription(NoSuchBeanDefinitionException cause) {
		if (cause.getResolvableType() != null) {
			Class<?> type = extractBeanType(cause.getResolvableType());
			return 'a bean of type "' + type.getName() + '"';
		}
		return 'a bean named "' + cause.getBeanName() + '"';
	}
	private Class<?> extractBeanType(ResolvableType resolvableType) {
		return resolvableType.getRawClass();
	}
	private List<AutoConfigurationResult> getAutoConfigurationResults(NoSuchBeanDefinitionException cause) {
		List<AutoConfigurationResult> results = new ArrayList<>();
		collectReportedConditionOutcomes(cause, results);
		collectExcludedAutoConfiguration(cause, results);
		return results;
	}
	private List<UserConfigurationResult> getUserConfigurationResults(NoSuchBeanDefinitionException cause) {
		ResolvableType type = cause.getResolvableType();
		if (type == null) {
			return Collections.emptyList();
		}
		String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, type);
		return Arrays.stream(beanNames)
			.map((beanName) -> new UserConfigurationResult(getFactoryMethodMetadata(beanName),
					this.beanFactory.getBean(beanName).equals(null)))
			.toList();
	}
	private MethodMetadata getFactoryMethodMetadata(String beanName) {
		BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(beanName);
		if (beanDefinition instanceof AnnotatedBeanDefinition annotatedBeanDefinition) {
			return annotatedBeanDefinition.getFactoryMethodMetadata();
		}
		return null;
	}
	private void collectReportedConditionOutcomes(NoSuchBeanDefinitionException cause,
			List<AutoConfigurationResult> results) {
		this.report.getConditionAndOutcomesBySource()
			.forEach((source, sourceOutcomes) -> collectReportedConditionOutcomes(cause, new Source(source),
					sourceOutcomes, results));
	}
	private void collectReportedConditionOutcomes(NoSuchBeanDefinitionException cause, Source source,
			ConditionAndOutcomes sourceOutcomes, List<AutoConfigurationResult> results) {
		if (sourceOutcomes.isFullMatch()) {
			return;
		}
		BeanMethods methods = new BeanMethods(source, cause);
		for (ConditionAndOutcome conditionAndOutcome : sourceOutcomes) {
			if (!conditionAndOutcome.getOutcome().isMatch()) {
				for (MethodMetadata method : methods) {
					results.add(new AutoConfigurationResult(method, conditionAndOutcome.getOutcome()));
				}
			}
		}
	}
	private void collectExcludedAutoConfiguration(NoSuchBeanDefinitionException cause,
			List<AutoConfigurationResult> results) {
		for (String excludedClass : this.report.getExclusions()) {
			Source source = new Source(excludedClass);
			BeanMethods methods = new BeanMethods(source, cause);
			for (MethodMetadata method : methods) {
				String message = String.format('auto-configuration "%s" was excluded',
						ClassUtils.getShortName(excludedClass));
				results.add(new AutoConfigurationResult(method, new ConditionOutcome(false, message)));
			}
		}
	}
	private InjectionPoint findInjectionPoint(Throwable failure) {
		UnsatisfiedDependencyException unsatisfiedDependencyException = findCause(failure,
				UnsatisfiedDependencyException.class);
		if (unsatisfiedDependencyException == null) {
			return null;
		}
		return unsatisfiedDependencyException.getInjectionPoint();
	}
	private static class Source {
		private final String className;
		private final String methodName;
		Source(String source) {
			String[] tokens = source.split('#');
			this.className = (tokens.length > 1) ? tokens[0] : source;
			this.methodName = (tokens.length != 2) ? null : tokens[1];
		}
		String getClassName() {
			return this.className;
		}
		String getMethodName() {
			return this.methodName;
		}
	}
	private class BeanMethods implements Iterable<MethodMetadata> {
		private final List<MethodMetadata> methods;
		BeanMethods(Source source, NoSuchBeanDefinitionException cause) {
			this.methods = findBeanMethods(source, cause);
		}
		private List<MethodMetadata> findBeanMethods(Source source, NoSuchBeanDefinitionException cause) {
			try {
				MetadataReader classMetadata = NoSuchBeanDefinitionFailureAnalyzer.this.metadataReaderFactory
					.getMetadataReader(source.getClassName());
				Set<MethodMetadata> candidates = classMetadata.getAnnotationMetadata()
					.getAnnotatedMethods(Bean.class.getName());
				List<MethodMetadata> result = new ArrayList<>();
				for (MethodMetadata candidate : candidates) {
					if (isMatch(candidate, source, cause)) {
						result.add(candidate);
					}
				}
				return Collections.unmodifiableList(result);
			}
			catch (Exception ex) {
				return Collections.emptyList();
			}
		}
		private boolean isMatch(MethodMetadata candidate, Source source, NoSuchBeanDefinitionException cause) {
			if (source.getMethodName() != null && !source.getMethodName().equals(candidate.getMethodName())) {
				return false;
			}
			String name = cause.getBeanName();
			ResolvableType resolvableType = cause.getResolvableType();
			return ((name != null && hasName(candidate, name))
					|| (resolvableType != null && hasType(candidate, extractBeanType(resolvableType))));
		}
		private boolean hasName(MethodMetadata methodMetadata, String name) {
			Map<String, Object> attributes = methodMetadata.getAnnotationAttributes(Bean.class.getName());
			String[] candidates = (attributes != null) ? (String[]) attributes.get('name') : null;
			if (candidates != null) {
				for (String candidate : candidates) {
					if (candidate.equals(name)) {
						return true;
					}
				}
				return false;
			}
			return methodMetadata.getMethodName().equals(name);
		}
		private boolean hasType(MethodMetadata candidate, Class<?> type) {
			String returnTypeName = candidate.getReturnTypeName();
			if (type.getName().equals(returnTypeName)) {
				return true;
			}
			try {
				Class<?> returnType = ClassUtils.forName(returnTypeName,
						NoSuchBeanDefinitionFailureAnalyzer.this.beanFactory.getBeanClassLoader());
				return type.isAssignableFrom(returnType);
			}
			catch (Throwable ex) {
				return false;
			}
		}
		@Override
		public Iterator<MethodMetadata> iterator() {
			return this.methods.iterator();
		}
	}
	private static class AutoConfigurationResult {
		private final MethodMetadata methodMetadata;
		private final ConditionOutcome conditionOutcome;
		AutoConfigurationResult(MethodMetadata methodMetadata, ConditionOutcome conditionOutcome) {
			this.methodMetadata = methodMetadata;
			this.conditionOutcome = conditionOutcome;
		}
		@Override
		public String toString() {
			return String.format('Bean method "%s" in "%s" not loaded because %s', this.methodMetadata.getMethodName(),
					ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()),
					this.conditionOutcome.getMessage());
		}
	}
	private static class UserConfigurationResult {
		private final MethodMetadata methodMetadata;
		private final boolean nullBean;
		UserConfigurationResult(MethodMetadata methodMetadata, boolean nullBean) {
			this.methodMetadata = methodMetadata;
			this.nullBean = nullBean;
		}
		@Override
		public String toString() {
			StringBuilder sb = new StringBuilder('User-defined bean');
			if (this.methodMetadata != null) {
				sb.append(String.format(' method "%s" in "%s"', this.methodMetadata.getMethodName(),
						ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName())));
			}
			if (this.nullBean) {
				sb.append(' ignored as the bean value is null');
			}
			return sb.toString();
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.diagnostics.analyzer;
/*
package org.springframework.boot.autoconfigure;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
	/**
	 * Exclude specific auto-configuration classes such that they will never be applied.
	 * @return the classes to exclude
	 */
	@AliasFor(annotation = EnableAutoConfiguration.class)
	Class<?>[] exclude() default {};
	/**
	 * Exclude specific auto-configuration class names such that they will never be
	 * applied.
	 * @return the class names to exclude
	 * @since 1.3.0
	 */
	@AliasFor(annotation = EnableAutoConfiguration.class)
	String[] excludeName() default {};
	/**
	 * Base packages to scan for annotated components. Use {@link #scanBasePackageClasses}
	 * for a type-safe alternative to String-based package names.
	 * <p>
	 * <strong>Note:</strong> this setting is an alias for
	 * {@link ComponentScan @ComponentScan} only. It has no effect on {@code @Entity}
	 * scanning or Spring Data {@link Repository} scanning. For those you should add
	 * {@link org.springframework.boot.autoconfigure.domain.EntityScan @EntityScan} and
	 * {@code @Enable...Repositories} annotations.
	 * @return base packages to scan
	 * @since 1.3.0
	 */
	@AliasFor(annotation = ComponentScan.class, attribute = 'basePackages')
	String[] scanBasePackages() default {};
	/**
	 * Type-safe alternative to {@link #scanBasePackages} for specifying the packages to
	 * scan for annotated components. The package of each class specified will be scanned.
	 * <p>
	 * Consider creating a special no-op marker class or interface in each package that
	 * serves no purpose other than being referenced by this attribute.
	 * <p>
	 * <strong>Note:</strong> this setting is an alias for
	 * {@link ComponentScan @ComponentScan} only. It has no effect on {@code @Entity}
	 * scanning or Spring Data {@link Repository} scanning. For those you should add
	 * {@link org.springframework.boot.autoconfigure.domain.EntityScan @EntityScan} and
	 * {@code @Enable...Repositories} annotations.
	 * @return base packages to scan
	 * @since 1.3.0
	 */
	@AliasFor(annotation = ComponentScan.class, attribute = 'basePackageClasses')
	Class<?>[] scanBasePackageClasses() default {};
	/**
	 * The {@link BeanNameGenerator} class to be used for naming detected components
	 * within the Spring container.
	 * <p>
	 * The default value of the {@link BeanNameGenerator} interface itself indicates that
	 * the scanner used to process this {@code @SpringBootApplication} annotation should
	 * use its inherited bean name generator, e.g. the default
	 * {@link AnnotationBeanNameGenerator} or any custom instance supplied to the
	 * application context at bootstrap time.
	 * @return {@link BeanNameGenerator} to use
	 * @see SpringApplication#setBeanNameGenerator(BeanNameGenerator)
	 * @since 2.3.0
	 */
	@AliasFor(annotation = ComponentScan.class, attribute = 'nameGenerator')
	Class<? extends BeanNameGenerator> nameGenerator() default BeanNameGenerator.class;
	/**
	 * Specify whether {@link Bean @Bean} methods should get proxied in order to enforce
	 * bean lifecycle behavior, e.g. to return shared singleton bean instances even in
	 * case of direct {@code @Bean} method calls in user code. This feature requires
	 * method interception, implemented through a runtime-generated CGLIB subclass which
	 * comes with limitations such as the configuration class and its methods not being
	 * allowed to declare {@code final}.
	 * <p>
	 * The default is {@code true}, allowing for "inter-bean references" within the
	 * configuration class as well as for external calls to this configuration"s
	 * {@code @Bean} methods, e.g. from another configuration class. If this is not needed
	 * since each of this particular configuration"s {@code @Bean} methods is
	 * self-contained and designed as a plain factory method for container use, switch
	 * this flag to {@code false} in order to avoid CGLIB subclass processing.
	 * <p>
	 * Turning off bean method interception effectively processes {@code @Bean} methods
	 * individually like when declared on non-{@code @Configuration} classes, a.k.a.
	 * '@Bean Lite Mode' (see {@link Bean @Bean"s javadoc}). It is therefore behaviorally
	 * equivalent to removing the {@code @Configuration} stereotype.
	 * @since 2.2
	 * @return whether to proxy {@code @Bean} methods
	 */
	@AliasFor(annotation = Configuration.class)
	boolean proxyBeanMethods() default true;
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface LiquibaseDataSource {
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
@ConfigurationProperties(prefix = 'spring.liquibase', ignoreUnknownFields = false)
public class LiquibaseProperties {
	/**
	 * Change log configuration path.
	 */
	private String changeLog = 'classpath:/db/changelog/db.changelog-master.yaml';
	/**
	 * Whether to clear all checksums in the current changelog, so they will be
	 * recalculated upon the next update.
	 */
	private boolean clearChecksums;
	/**
	 * List of runtime contexts to use.
	 */
	private List<String> contexts;
	/**
	 * Default database schema.
	 */
	private String defaultSchema;
	/**
	 * Schema to use for Liquibase objects.
	 */
	private String liquibaseSchema;
	/**
	 * Tablespace to use for Liquibase objects.
	 */
	private String liquibaseTablespace;
	/**
	 * Name of table to use for tracking change history.
	 */
	private String databaseChangeLogTable = 'DATABASECHANGELOG';
	/**
	 * Name of table to use for tracking concurrent Liquibase usage.
	 */
	private String databaseChangeLogLockTable = 'DATABASECHANGELOGLOCK';
	/**
	 * Whether to first drop the database schema.
	 */
	private boolean dropFirst;
	/**
	 * Whether to enable Liquibase support.
	 */
	private boolean enabled = true;
	/**
	 * Login user of the database to migrate.
	 */
	private String user;
	/**
	 * Login password of the database to migrate.
	 */
	private String password;
	/**
	 * Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.
	 */
	private String driverClassName;
	/**
	 * JDBC URL of the database to migrate. If not set, the primary configured data source
	 * is used.
	 */
	private String url;
	/**
	 * List of runtime labels to use.
	 */
	private List<String> labelFilter;
	/**
	 * Change log parameters.
	 */
	private Map<String, String> parameters;
	/**
	 * File to which rollback SQL is written when an update is performed.
	 */
	private File rollbackFile;
	/**
	 * Whether rollback should be tested before update is performed.
	 */
	private boolean testRollbackOnUpdate;
	/**
	 * Tag name to use when applying database changes. Can also be used with
	 * 'rollbackFile' to generate a rollback script for all existing changes associated
	 * with that tag.
	 */
	private String tag;
	/**
	 * Whether to print a summary of the update operation.
	 */
	private ShowSummary showSummary;
	/**
	 * Where to print a summary of the update operation.
	 */
	private ShowSummaryOutput showSummaryOutput;
	/**
	 * Which UIService to use.
	 */
	private UiService uiService;
	public String getChangeLog() {
		return this.changeLog;
	}
	public void setChangeLog(String changeLog) {
		Assert.notNull(changeLog, 'ChangeLog must not be null');
		this.changeLog = changeLog;
	}
	public List<String> getContexts() {
		return this.contexts;
	}
	public void setContexts(List<String> contexts) {
		this.contexts = contexts;
	}
	public String getDefaultSchema() {
		return this.defaultSchema;
	}
	public void setDefaultSchema(String defaultSchema) {
		this.defaultSchema = defaultSchema;
	}
	public String getLiquibaseSchema() {
		return this.liquibaseSchema;
	}
	public void setLiquibaseSchema(String liquibaseSchema) {
		this.liquibaseSchema = liquibaseSchema;
	}
	public String getLiquibaseTablespace() {
		return this.liquibaseTablespace;
	}
	public void setLiquibaseTablespace(String liquibaseTablespace) {
		this.liquibaseTablespace = liquibaseTablespace;
	}
	public String getDatabaseChangeLogTable() {
		return this.databaseChangeLogTable;
	}
	public void setDatabaseChangeLogTable(String databaseChangeLogTable) {
		this.databaseChangeLogTable = databaseChangeLogTable;
	}
	public String getDatabaseChangeLogLockTable() {
		return this.databaseChangeLogLockTable;
	}
	public void setDatabaseChangeLogLockTable(String databaseChangeLogLockTable) {
		this.databaseChangeLogLockTable = databaseChangeLogLockTable;
	}
	public boolean isDropFirst() {
		return this.dropFirst;
	}
	public void setDropFirst(boolean dropFirst) {
		this.dropFirst = dropFirst;
	}
	public boolean isClearChecksums() {
		return this.clearChecksums;
	}
	public void setClearChecksums(boolean clearChecksums) {
		this.clearChecksums = clearChecksums;
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public String getUser() {
		return this.user;
	}
	public void setUser(String user) {
		this.user = user;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getDriverClassName() {
		return this.driverClassName;
	}
	public void setDriverClassName(String driverClassName) {
		this.driverClassName = driverClassName;
	}
	public String getUrl() {
		return this.url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public List<String> getLabelFilter() {
		return this.labelFilter;
	}
	public void setLabelFilter(List<String> labelFilter) {
		this.labelFilter = labelFilter;
	}
	public Map<String, String> getParameters() {
		return this.parameters;
	}
	public void setParameters(Map<String, String> parameters) {
		this.parameters = parameters;
	}
	public File getRollbackFile() {
		return this.rollbackFile;
	}
	public void setRollbackFile(File rollbackFile) {
		this.rollbackFile = rollbackFile;
	}
	public boolean isTestRollbackOnUpdate() {
		return this.testRollbackOnUpdate;
	}
	public void setTestRollbackOnUpdate(boolean testRollbackOnUpdate) {
		this.testRollbackOnUpdate = testRollbackOnUpdate;
	}
	public String getTag() {
		return this.tag;
	}
	public void setTag(String tag) {
		this.tag = tag;
	}
	public ShowSummary getShowSummary() {
		return this.showSummary;
	}
	public void setShowSummary(ShowSummary showSummary) {
		this.showSummary = showSummary;
	}
	public ShowSummaryOutput getShowSummaryOutput() {
		return this.showSummaryOutput;
	}
	public void setShowSummaryOutput(ShowSummaryOutput showSummaryOutput) {
		this.showSummaryOutput = showSummaryOutput;
	}
	public UiService getUiService() {
		return this.uiService;
	}
	public void setUiService(UiService uiService) {
		this.uiService = uiService;
	}
	/**
	 * Enumeration of types of summary to show. Values are the same as those on
	 * {@link UpdateSummaryEnum}. To maximize backwards compatibility, the Liquibase enum
	 * is not used directly.
	 *
	 * @since 3.2.1
	 */
	public enum ShowSummary {
		/**
		 * Do not show a summary.
		 */
		OFF,
		/**
		 * Show a summary.
		 */
		SUMMARY,
		/**
		 * Show a verbose summary.
		 */
		VERBOSE
	}
	/**
	 * Enumeration of destinations to which the summary should be output. Values are the
	 * same as those on {@link UpdateSummaryOutputEnum}. To maximize backwards
	 * compatibility, the Liquibase enum is not used directly.
	 *
	 * @since 3.2.1
	 */
	public enum ShowSummaryOutput {
		/**
		 * Log the summary.
		 */
		LOG,
		/**
		 * Output the summary to the console.
		 */
		CONSOLE,
		/**
		 * Log the summary and output it to the console.
		 */
		ALL
	}
	/**
	 * Enumeration of types of UIService. Values are the same as those on
	 * {@link UIServiceEnum}. To maximize backwards compatibility, the Liquibase enum is
	 * not used directly.
	 */
	public enum UiService {
		/**
		 * Console-based UIService.
		 */
		CONSOLE,
		/**
		 * Logging-based UIService.
		 */
		LOGGER
	}
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
public interface LiquibaseConnectionDetails extends ConnectionDetails {
	/**
	 * Username for the database or {@code null} if no Liquibase-specific configuration is
	 * required.
	 * @return the username for the database or {@code null}
	 */
	String getUsername();
	/**
	 * Password for the database or {@code null} if no Liquibase-specific configuration is
	 * required.
	 * @return the password for the database or {@code null}
	 */
	String getPassword();
	/**
	 * JDBC URL for the database or {@code null} if no Liquibase-specific configuration is
	 * required.
	 * @return the JDBC URL for the database or {@code null}
	 */
	String getJdbcUrl();
	/**
	 * The name of the JDBC driver class. Defaults to the class name of the driver
	 * specified in the JDBC URL or {@code null} when no JDBC URL is configured.
	 * @return the JDBC driver class name or {@code null}
	 * @see #getJdbcUrl()
	 * @see DatabaseDriver#fromJdbcUrl(String)
	 * @see DatabaseDriver#getDriverClassName()
	 */
	default String getDriverClassName() {
		String jdbcUrl = getJdbcUrl();
		return (jdbcUrl != null) ? DatabaseDriver.fromJdbcUrl(jdbcUrl).getDriverClassName() : null;
	}
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
public class DataSourceClosingSpringLiquibase extends SpringLiquibase implements DisposableBean {
	private volatile boolean closeDataSourceOnceMigrated = true;
	public void setCloseDataSourceOnceMigrated(boolean closeDataSourceOnceMigrated) {
		this.closeDataSourceOnceMigrated = closeDataSourceOnceMigrated;
	}
	@Override
	public void afterPropertiesSet() throws LiquibaseException {
		super.afterPropertiesSet();
		if (this.closeDataSourceOnceMigrated) {
			closeDataSource();
		}
	}
	private void closeDataSource() {
		Class<?> dataSourceClass = getDataSource().getClass();
		Method closeMethod = ReflectionUtils.findMethod(dataSourceClass, 'close');
		if (closeMethod != null) {
			ReflectionUtils.invokeMethod(closeMethod, getDataSource());
		}
	}
	@Override
	public void destroy() throws Exception {
		if (!this.closeDataSourceOnceMigrated) {
			closeDataSource();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
@AutoConfiguration(after = { DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class })
@ConditionalOnClass({ SpringLiquibase.class, DatabaseChange.class })
@ConditionalOnProperty(prefix = 'spring.liquibase', name = 'enabled', matchIfMissing = true)
@Conditional(LiquibaseDataSourceCondition.class)
@Import(DatabaseInitializationDependencyConfigurer.class)
@ImportRuntimeHints(LiquibaseAutoConfigurationRuntimeHints.class)
public class LiquibaseAutoConfiguration {
	@Bean
	public LiquibaseSchemaManagementProvider liquibaseDefaultDdlModeProvider(
			ObjectProvider<SpringLiquibase> liquibases) {
		return new LiquibaseSchemaManagementProvider(liquibases);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ConnectionCallback.class)
	@ConditionalOnMissingBean(SpringLiquibase.class)
	@EnableConfigurationProperties(LiquibaseProperties.class)
	public static class LiquibaseConfiguration {
		@Bean
		@ConditionalOnMissingBean(LiquibaseConnectionDetails.class)
		PropertiesLiquibaseConnectionDetails liquibaseConnectionDetails(LiquibaseProperties properties) {
			return new PropertiesLiquibaseConnectionDetails(properties);
		}
		@Bean
		SpringLiquibase liquibase(ObjectProvider<DataSource> dataSource,
				@LiquibaseDataSource ObjectProvider<DataSource> liquibaseDataSource, LiquibaseProperties properties,
				ObjectProvider<SpringLiquibaseCustomizer> customizers, LiquibaseConnectionDetails connectionDetails) {
			SpringLiquibase liquibase = createSpringLiquibase(liquibaseDataSource.getIfAvailable(),
					dataSource.getIfUnique(), connectionDetails);
			liquibase.setChangeLog(properties.getChangeLog());
			liquibase.setClearCheckSums(properties.isClearChecksums());
			if (!CollectionUtils.isEmpty(properties.getContexts())) {
				liquibase.setContexts(StringUtils.collectionToCommaDelimitedString(properties.getContexts()));
			}
			liquibase.setDefaultSchema(properties.getDefaultSchema());
			liquibase.setLiquibaseSchema(properties.getLiquibaseSchema());
			liquibase.setLiquibaseTablespace(properties.getLiquibaseTablespace());
			liquibase.setDatabaseChangeLogTable(properties.getDatabaseChangeLogTable());
			liquibase.setDatabaseChangeLogLockTable(properties.getDatabaseChangeLogLockTable());
			liquibase.setDropFirst(properties.isDropFirst());
			liquibase.setShouldRun(properties.isEnabled());
			if (!CollectionUtils.isEmpty(properties.getLabelFilter())) {
				liquibase.setLabelFilter(StringUtils.collectionToCommaDelimitedString(properties.getLabelFilter()));
			}
			liquibase.setChangeLogParameters(properties.getParameters());
			liquibase.setRollbackFile(properties.getRollbackFile());
			liquibase.setTestRollbackOnUpdate(properties.isTestRollbackOnUpdate());
			liquibase.setTag(properties.getTag());
			if (properties.getShowSummary() != null) {
				liquibase.setShowSummary(UpdateSummaryEnum.valueOf(properties.getShowSummary().name()));
			}
			if (properties.getShowSummaryOutput() != null) {
				liquibase
					.setShowSummaryOutput(UpdateSummaryOutputEnum.valueOf(properties.getShowSummaryOutput().name()));
			}
			if (properties.getUiService() != null) {
				liquibase.setUiService(UIServiceEnum.valueOf(properties.getUiService().name()));
			}
			customizers.orderedStream().forEach((customizer) -> customizer.customize(liquibase));
			return liquibase;
		}
		private SpringLiquibase createSpringLiquibase(DataSource liquibaseDataSource, DataSource dataSource,
				LiquibaseConnectionDetails connectionDetails) {
			DataSource migrationDataSource = getMigrationDataSource(liquibaseDataSource, dataSource, connectionDetails);
			SpringLiquibase liquibase = (migrationDataSource == liquibaseDataSource
					|| migrationDataSource == dataSource) ? new SpringLiquibase()
							: new DataSourceClosingSpringLiquibase();
			liquibase.setDataSource(migrationDataSource);
			return liquibase;
		}
		private DataSource getMigrationDataSource(DataSource liquibaseDataSource, DataSource dataSource,
				LiquibaseConnectionDetails connectionDetails) {
			if (liquibaseDataSource != null) {
				return liquibaseDataSource;
			}
			String url = connectionDetails.getJdbcUrl();
			if (url != null) {
				DataSourceBuilder<?> builder = DataSourceBuilder.create().type(SimpleDriverDataSource.class);
				builder.url(url);
				applyConnectionDetails(connectionDetails, builder);
				return builder.build();
			}
			String user = connectionDetails.getUsername();
			if (user != null && dataSource != null) {
				DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource)
					.type(SimpleDriverDataSource.class);
				applyConnectionDetails(connectionDetails, builder);
				return builder.build();
			}
			Assert.state(dataSource != null, 'Liquibase migration DataSource missing');
			return dataSource;
		}
		private void applyConnectionDetails(LiquibaseConnectionDetails connectionDetails,
				DataSourceBuilder<?> builder) {
			builder.username(connectionDetails.getUsername());
			builder.password(connectionDetails.getPassword());
			String driverClassName = connectionDetails.getDriverClassName();
			if (StringUtils.hasText(driverClassName)) {
				builder.driverClassName(driverClassName);
			}
		}
	}
	@ConditionalOnClass(Customizer.class)
	static class CustomizerConfiguration {
		@Bean
		@ConditionalOnBean(Customizer.class)
		SpringLiquibaseCustomizer springLiquibaseCustomizer(Customizer<Liquibase> customizer) {
			return (springLiquibase) -> springLiquibase.setCustomizer(customizer);
		}
	}
	static final class LiquibaseDataSourceCondition extends AnyNestedCondition {
		LiquibaseDataSourceCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnBean(DataSource.class)
		private static final class DataSourceBeanCondition {
		}
		@ConditionalOnBean(JdbcConnectionDetails.class)
		private static final class JdbcConnectionDetailsCondition {
		}
		@ConditionalOnProperty(prefix = 'spring.liquibase', name = 'url')
		private static final class LiquibaseUrlCondition {
		}
	}
	static class LiquibaseAutoConfigurationRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('db/changelog/*');
		}
	}
	/**
	 * Adapts {@link LiquibaseProperties} to {@link LiquibaseConnectionDetails}.
	 */
	static final class PropertiesLiquibaseConnectionDetails implements LiquibaseConnectionDetails {
		private final LiquibaseProperties properties;
		PropertiesLiquibaseConnectionDetails(LiquibaseProperties properties) {
			this.properties = properties;
		}
		@Override
		public String getUsername() {
			return this.properties.getUser();
		}
		@Override
		public String getPassword() {
			return this.properties.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.properties.getUrl();
		}
		@Override
		public String getDriverClassName() {
			String driverClassName = this.properties.getDriverClassName();
			return (driverClassName != null) ? driverClassName : LiquibaseConnectionDetails.super.getDriverClassName();
		}
	}
	@FunctionalInterface
	private interface SpringLiquibaseCustomizer {
		/**
		 * Customize the given {@link SpringLiquibase} instance.
		 * @param springLiquibase the instance to configure
		 */
		void customize(SpringLiquibase springLiquibase);
	}
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
class LiquibaseSchemaManagementProvider implements SchemaManagementProvider {
	private final Iterable<SpringLiquibase> liquibaseInstances;
	LiquibaseSchemaManagementProvider(ObjectProvider<SpringLiquibase> liquibases) {
		this.liquibaseInstances = liquibases;
	}
	@Override
	public SchemaManagement getSchemaManagement(DataSource dataSource) {
		return StreamSupport.stream(this.liquibaseInstances.spliterator(), false)
			.map(SpringLiquibase::getDataSource)
			.filter(dataSource::equals)
			.findFirst()
			.map((managedDataSource) -> SchemaManagement.MANAGED)
			.orElse(SchemaManagement.UNMANAGED);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.liquibase;
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class NativeImageResourceProvider implements ResourceProvider {
	private final Scanner<?> scanner;
	private final ClassLoader classLoader;
	private final Collection<Location> locations;
	private final Charset encoding;
	private final boolean failOnMissingLocations;
	private final List<LocatedResource> locatedResources = new ArrayList<>();
	private final Lock lock = new ReentrantLock();
	private boolean initialized;
	NativeImageResourceProvider(Scanner<?> scanner, ClassLoader classLoader, Collection<Location> locations,
			Charset encoding, boolean failOnMissingLocations) {
		this.scanner = scanner;
		this.classLoader = classLoader;
		this.locations = locations;
		this.encoding = encoding;
		this.failOnMissingLocations = failOnMissingLocations;
	}
	@Override
	public LoadableResource getResource(String name) {
		if (!NativeDetector.inNativeImage()) {
			return this.scanner.getResource(name);
		}
		LoadableResource resource = this.scanner.getResource(name);
		if (resource != null) {
			return resource;
		}
		if (this.classLoader.getResource(name) == null) {
			return null;
		}
		return new ClassPathResource(null, name, this.classLoader, this.encoding);
	}
	@Override
	public Collection<LoadableResource> getResources(String prefix, String[] suffixes) {
		if (!NativeDetector.inNativeImage()) {
			return this.scanner.getResources(prefix, suffixes);
		}
		ensureInitialized();
		Predicate<LocatedResource> matchesPrefixAndSuffixes = (locatedResource) -> StringUtils
			.startsAndEndsWith(locatedResource.resource.getFilename(), prefix, suffixes);
		List<LoadableResource> result = new ArrayList<>(this.scanner.getResources(prefix, suffixes));
		this.locatedResources.stream()
			.filter(matchesPrefixAndSuffixes)
			.map(this::asClassPathResource)
			.forEach(result::add);
		return result;
	}
	private ClassPathResource asClassPathResource(LocatedResource locatedResource) {
		Location location = locatedResource.location();
		String fileNameWithAbsolutePath = location.getPath() + '/' + locatedResource.resource().getFilename();
		return new ClassPathResource(location, fileNameWithAbsolutePath, this.classLoader, this.encoding);
	}
	private void ensureInitialized() {
		this.lock.lock();
		try {
			if (!this.initialized) {
				initialize();
				this.initialized = true;
			}
		}
		finally {
			this.lock.unlock();
		}
	}
	private void initialize() {
		PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
		for (Location location : this.locations) {
			if (!location.isClassPath()) {
				continue;
			}
			Resource root = resolver.getResource(location.getDescriptor());
			if (!root.exists()) {
				if (this.failOnMissingLocations) {
					throw new FlywayException('Location ' + location.getDescriptor() + ' doesn"t exist');
				}
				continue;
			}
			Resource[] resources = getResources(resolver, location, root);
			for (Resource resource : resources) {
				this.locatedResources.add(new LocatedResource(resource, location));
			}
		}
	}
	private Resource[] getResources(PathMatchingResourcePatternResolver resolver, Location location, Resource root) {
		try {
			return resolver.getResources(root.getURI() + '/*');
		}
		catch (IOException ex) {
			throw new UncheckedIOException('Failed to list resources for ' + location.getDescriptor(), ex);
		}
	}
	private record LocatedResource(Resource resource, Location location) {
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class FlywaySchemaManagementProvider implements SchemaManagementProvider {
	private final Iterable<Flyway> flywayInstances;
	FlywaySchemaManagementProvider(Iterable<Flyway> flywayInstances) {
		this.flywayInstances = flywayInstances;
	}
	@Override
	public SchemaManagement getSchemaManagement(DataSource dataSource) {
		return StreamSupport.stream(this.flywayInstances.spliterator(), false)
			.map((flyway) -> flyway.getConfiguration().getDataSource())
			.filter(dataSource::equals)
			.findFirst()
			.map((managedDataSource) -> SchemaManagement.MANAGED)
			.orElse(SchemaManagement.UNMANAGED);
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
@FunctionalInterface
public interface FlywayMigrationStrategy {
	/**
	 * Trigger flyway migration.
	 * @param flyway the flyway instance
	 */
	void migrate(Flyway flyway);
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class FlywayMigrationInitializerDatabaseInitializerDetector extends AbstractBeansOfTypeDatabaseInitializerDetector {
	@Override
	protected Set<Class<?>> getDatabaseInitializerBeanTypes() {
		return Collections.singleton(FlywayMigrationInitializer.class);
	}
	@Override
	public int getOrder() {
		return 1;
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
public interface FlywayConnectionDetails extends ConnectionDetails {
	/**
	 * Username for the database or {@code null} if no Flyway-specific configuration is
	 * required.
	 * @return the username for the database or {@code null}
	 */
	String getUsername();
	/**
	 * Password for the database or {@code null} if no Flyway-specific configuration is
	 * required.
	 * @return the password for the database or {@code null}
	 */
	String getPassword();
	/**
	 * JDBC URL for the database or {@code null} if no Flyway-specific configuration is
	 * required.
	 * @return the JDBC URL for the database or {@code null}
	 */
	String getJdbcUrl();
	/**
	 * The name of the JDBC driver class. Defaults to the class name of the driver
	 * specified in the JDBC URL or {@code null} when no JDBC URL is configured.
	 * @return the JDBC driver class name or {@code null}
	 * @see #getJdbcUrl()
	 * @see DatabaseDriver#fromJdbcUrl(String)
	 * @see DatabaseDriver#getDriverClassName()
	 */
	default String getDriverClassName() {
		String jdbcUrl = getJdbcUrl();
		return (jdbcUrl != null) ? DatabaseDriver.fromJdbcUrl(jdbcUrl).getDriverClassName() : null;
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
@FunctionalInterface
public interface FlywayConfigurationCustomizer {
	/**
	 * Customize the flyway configuration.
	 * @param configuration the {@link FluentConfiguration} to customize
	 */
	void customize(FluentConfiguration configuration);
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
@ConfigurationProperties(prefix = 'spring.flyway')
public class FlywayProperties {
	/**
	 * Whether to enable flyway.
	 */
	private boolean enabled = true;
	/**
	 * Whether to fail if a location of migration scripts doesn"t exist.
	 */
	private boolean failOnMissingLocations;
	/**
	 * Locations of migrations scripts. Can contain the special '{vendor}' placeholder to
	 * use vendor-specific locations.
	 */
	private List<String> locations = new ArrayList<>(Collections.singletonList('classpath:db/migration'));
	/**
	 * Encoding of SQL migrations.
	 */
	private Charset encoding = StandardCharsets.UTF_8;
	/**
	 * Maximum number of retries when attempting to connect to the database.
	 */
	private int connectRetries;
	/**
	 * Maximum time between retries when attempting to connect to the database. If a
	 * duration suffix is not specified, seconds will be used.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration connectRetriesInterval = Duration.ofSeconds(120);
	/**
	 * Maximum number of retries when trying to obtain a lock.
	 */
	private int lockRetryCount = 50;
	/**
	 * Default schema name managed by Flyway (case-sensitive).
	 */
	private String defaultSchema;
	/**
	 * Scheme names managed by Flyway (case-sensitive).
	 */
	private List<String> schemas = new ArrayList<>();
	/**
	 * Whether Flyway should attempt to create the schemas specified in the schemas
	 * property.
	 */
	private boolean createSchemas = true;
	/**
	 * Name of the schema history table that will be used by Flyway.
	 */
	private String table = 'flyway_schema_history';
	/**
	 * Tablespace in which the schema history table is created. Ignored when using a
	 * database that does not support tablespaces. Defaults to the default tablespace of
	 * the connection used by Flyway.
	 */
	private String tablespace;
	/**
	 * Description to tag an existing schema with when applying a baseline.
	 */
	private String baselineDescription = '<< Flyway Baseline >>';
	/**
	 * Version to tag an existing schema with when executing baseline.
	 */
	private String baselineVersion = '1';
	/**
	 * Username recorded in the schema history table as having applied the migration.
	 */
	private String installedBy;
	/**
	 * Placeholders and their replacements to apply to sql migration scripts.
	 */
	private Map<String, String> placeholders = new HashMap<>();
	/**
	 * Prefix of placeholders in migration scripts.
	 */
	private String placeholderPrefix = '${';
	/**
	 * Suffix of placeholders in migration scripts.
	 */
	private String placeholderSuffix = '}';
	/**
	 * Separator of default placeholders.
	 */
	private String placeholderSeparator = ':';
	/**
	 * Perform placeholder replacement in migration scripts.
	 */
	private boolean placeholderReplacement = true;
	/**
	 * File name prefix for SQL migrations.
	 */
	private String sqlMigrationPrefix = 'V';
	/**
	 * File name suffix for SQL migrations.
	 */
	private List<String> sqlMigrationSuffixes = new ArrayList<>(Collections.singleton('.sql'));
	/**
	 * File name separator for SQL migrations.
	 */
	private String sqlMigrationSeparator = '__';
	/**
	 * File name prefix for repeatable SQL migrations.
	 */
	private String repeatableSqlMigrationPrefix = 'R';
	/**
	 * Target version up to which migrations should be considered.
	 */
	private String target = 'latest';
	/**
	 * Login user of the database to migrate.
	 */
	private String user;
	/**
	 * Login password of the database to migrate.
	 */
	private String password;
	/**
	 * Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.
	 */
	private String driverClassName;
	/**
	 * JDBC url of the database to migrate. If not set, the primary configured data source
	 * is used.
	 */
	private String url;
	/**
	 * SQL statements to execute to initialize a connection immediately after obtaining
	 * it.
	 */
	private List<String> initSqls = new ArrayList<>();
	/**
	 * Whether to automatically call baseline when migrating a non-empty schema.
	 */
	private boolean baselineOnMigrate;
	/**
	 * Whether to disable cleaning of the database.
	 */
	private boolean cleanDisabled = true;
	/**
	 * Whether to automatically call clean when a validation error occurs.
	 */
	private boolean cleanOnValidationError;
	/**
	 * Whether to group all pending migrations together in the same transaction when
	 * applying them.
	 */
	private boolean group;
	/**
	 * Whether to allow mixing transactional and non-transactional statements within the
	 * same migration.
	 */
	private boolean mixed;
	/**
	 * Whether to allow migrations to be run out of order.
	 */
	private boolean outOfOrder;
	/**
	 * Whether to skip default callbacks. If true, only custom callbacks are used.
	 */
	private boolean skipDefaultCallbacks;
	/**
	 * Whether to skip default resolvers. If true, only custom resolvers are used.
	 */
	private boolean skipDefaultResolvers;
	/**
	 * Whether to validate migrations and callbacks whose scripts do not obey the correct
	 * naming convention.
	 */
	private boolean validateMigrationNaming = false;
	/**
	 * Whether to automatically call validate when performing a migration.
	 */
	private boolean validateOnMigrate = true;
	/**
	 * Prefix of placeholders in migration scripts.
	 */
	private String scriptPlaceholderPrefix = 'FP__';
	/**
	 * Suffix of placeholders in migration scripts.
	 */
	private String scriptPlaceholderSuffix = '__';
	/**
	 * Whether Flyway should execute SQL within a transaction.
	 */
	private boolean executeInTransaction = true;
	/**
	 * Loggers Flyway should use.
	 */
	private String[] loggers = { 'slf4j' };
	/**
	 * Whether to batch SQL statements when executing them. Requires Flyway Teams.
	 */
	private Boolean batch;
	/**
	 * File to which the SQL statements of a migration dry run should be output. Requires
	 * Flyway Teams.
	 */
	private File dryRunOutput;
	/**
	 * Rules for the built-in error handling to override specific SQL states and error
	 * codes. Requires Flyway Teams.
	 */
	private String[] errorOverrides;
	/**
	 * Whether to stream SQL migrations when executing them. Requires Flyway Teams.
	 */
	private Boolean stream;
	/**
	 * Properties to pass to the JDBC driver. Requires Flyway Teams.
	 */
	private Map<String, String> jdbcProperties = new HashMap<>();
	/**
	 * Path of the Kerberos config file. Requires Flyway Teams.
	 */
	private String kerberosConfigFile;
	/**
	 * Whether Flyway should output a table with the results of queries when executing
	 * migrations. Requires Flyway Teams.
	 */
	private Boolean outputQueryResults;
	/**
	 * Whether Flyway should skip executing the contents of the migrations and only update
	 * the schema history table. Requires Flyway teams.
	 */
	private Boolean skipExecutingMigrations;
	/**
	 * List of patterns that identify migrations to ignore when performing validation.
	 * Requires Flyway Teams.
	 */
	private List<String> ignoreMigrationPatterns;
	/**
	 * Whether to attempt to automatically detect SQL migration file encoding. Requires
	 * Flyway Teams.
	 */
	private Boolean detectEncoding;
	/**
	 * Whether to enable community database support.
	 */
	private Boolean communityDbSupportEnabled;
	private final Oracle oracle = new Oracle();
	private final Postgresql postgresql = new Postgresql();
	private final Sqlserver sqlserver = new Sqlserver();
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public boolean isFailOnMissingLocations() {
		return this.failOnMissingLocations;
	}
	public void setFailOnMissingLocations(boolean failOnMissingLocations) {
		this.failOnMissingLocations = failOnMissingLocations;
	}
	public List<String> getLocations() {
		return this.locations;
	}
	public void setLocations(List<String> locations) {
		this.locations = locations;
	}
	public Charset getEncoding() {
		return this.encoding;
	}
	public void setEncoding(Charset encoding) {
		this.encoding = encoding;
	}
	public int getConnectRetries() {
		return this.connectRetries;
	}
	public void setConnectRetries(int connectRetries) {
		this.connectRetries = connectRetries;
	}
	public Duration getConnectRetriesInterval() {
		return this.connectRetriesInterval;
	}
	public void setConnectRetriesInterval(Duration connectRetriesInterval) {
		this.connectRetriesInterval = connectRetriesInterval;
	}
	public int getLockRetryCount() {
		return this.lockRetryCount;
	}
	public void setLockRetryCount(Integer lockRetryCount) {
		this.lockRetryCount = lockRetryCount;
	}
	public String getDefaultSchema() {
		return this.defaultSchema;
	}
	public void setDefaultSchema(String defaultSchema) {
		this.defaultSchema = defaultSchema;
	}
	public List<String> getSchemas() {
		return this.schemas;
	}
	public void setSchemas(List<String> schemas) {
		this.schemas = schemas;
	}
	public boolean isCreateSchemas() {
		return this.createSchemas;
	}
	public void setCreateSchemas(boolean createSchemas) {
		this.createSchemas = createSchemas;
	}
	public String getTable() {
		return this.table;
	}
	public void setTable(String table) {
		this.table = table;
	}
	public String getTablespace() {
		return this.tablespace;
	}
	public void setTablespace(String tablespace) {
		this.tablespace = tablespace;
	}
	public String getBaselineDescription() {
		return this.baselineDescription;
	}
	public void setBaselineDescription(String baselineDescription) {
		this.baselineDescription = baselineDescription;
	}
	public String getBaselineVersion() {
		return this.baselineVersion;
	}
	public void setBaselineVersion(String baselineVersion) {
		this.baselineVersion = baselineVersion;
	}
	public String getInstalledBy() {
		return this.installedBy;
	}
	public void setInstalledBy(String installedBy) {
		this.installedBy = installedBy;
	}
	public Map<String, String> getPlaceholders() {
		return this.placeholders;
	}
	public void setPlaceholders(Map<String, String> placeholders) {
		this.placeholders = placeholders;
	}
	public String getPlaceholderPrefix() {
		return this.placeholderPrefix;
	}
	public void setPlaceholderPrefix(String placeholderPrefix) {
		this.placeholderPrefix = placeholderPrefix;
	}
	public String getPlaceholderSuffix() {
		return this.placeholderSuffix;
	}
	public void setPlaceholderSuffix(String placeholderSuffix) {
		this.placeholderSuffix = placeholderSuffix;
	}
	public String getPlaceholderSeparator() {
		return this.placeholderSeparator;
	}
	public void setPlaceholderSeparator(String placeholderSeparator) {
		this.placeholderSeparator = placeholderSeparator;
	}
	public boolean isPlaceholderReplacement() {
		return this.placeholderReplacement;
	}
	public void setPlaceholderReplacement(boolean placeholderReplacement) {
		this.placeholderReplacement = placeholderReplacement;
	}
	public String getSqlMigrationPrefix() {
		return this.sqlMigrationPrefix;
	}
	public void setSqlMigrationPrefix(String sqlMigrationPrefix) {
		this.sqlMigrationPrefix = sqlMigrationPrefix;
	}
	public List<String> getSqlMigrationSuffixes() {
		return this.sqlMigrationSuffixes;
	}
	public void setSqlMigrationSuffixes(List<String> sqlMigrationSuffixes) {
		this.sqlMigrationSuffixes = sqlMigrationSuffixes;
	}
	public String getSqlMigrationSeparator() {
		return this.sqlMigrationSeparator;
	}
	public void setSqlMigrationSeparator(String sqlMigrationSeparator) {
		this.sqlMigrationSeparator = sqlMigrationSeparator;
	}
	public String getRepeatableSqlMigrationPrefix() {
		return this.repeatableSqlMigrationPrefix;
	}
	public void setRepeatableSqlMigrationPrefix(String repeatableSqlMigrationPrefix) {
		this.repeatableSqlMigrationPrefix = repeatableSqlMigrationPrefix;
	}
	public String getTarget() {
		return this.target;
	}
	public void setTarget(String target) {
		this.target = target;
	}
	public String getUser() {
		return this.user;
	}
	public void setUser(String user) {
		this.user = user;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getDriverClassName() {
		return this.driverClassName;
	}
	public void setDriverClassName(String driverClassName) {
		this.driverClassName = driverClassName;
	}
	public String getUrl() {
		return this.url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	public List<String> getInitSqls() {
		return this.initSqls;
	}
	public void setInitSqls(List<String> initSqls) {
		this.initSqls = initSqls;
	}
	public boolean isBaselineOnMigrate() {
		return this.baselineOnMigrate;
	}
	public void setBaselineOnMigrate(boolean baselineOnMigrate) {
		this.baselineOnMigrate = baselineOnMigrate;
	}
	public boolean isCleanDisabled() {
		return this.cleanDisabled;
	}
	public void setCleanDisabled(boolean cleanDisabled) {
		this.cleanDisabled = cleanDisabled;
	}
	@Deprecated(since = '3.4.0', forRemoval = true)
	@DeprecatedConfigurationProperty(since = '3.4.0', reason = 'Deprecated in Flyway 10.18')
	public boolean isCleanOnValidationError() {
		return this.cleanOnValidationError;
	}
	@Deprecated(since = '3.4.0', forRemoval = true)
	public void setCleanOnValidationError(boolean cleanOnValidationError) {
		this.cleanOnValidationError = cleanOnValidationError;
	}
	public boolean isGroup() {
		return this.group;
	}
	public void setGroup(boolean group) {
		this.group = group;
	}
	public boolean isMixed() {
		return this.mixed;
	}
	public void setMixed(boolean mixed) {
		this.mixed = mixed;
	}
	public boolean isOutOfOrder() {
		return this.outOfOrder;
	}
	public void setOutOfOrder(boolean outOfOrder) {
		this.outOfOrder = outOfOrder;
	}
	public boolean isSkipDefaultCallbacks() {
		return this.skipDefaultCallbacks;
	}
	public void setSkipDefaultCallbacks(boolean skipDefaultCallbacks) {
		this.skipDefaultCallbacks = skipDefaultCallbacks;
	}
	public boolean isSkipDefaultResolvers() {
		return this.skipDefaultResolvers;
	}
	public void setSkipDefaultResolvers(boolean skipDefaultResolvers) {
		this.skipDefaultResolvers = skipDefaultResolvers;
	}
	public boolean isValidateMigrationNaming() {
		return this.validateMigrationNaming;
	}
	public void setValidateMigrationNaming(boolean validateMigrationNaming) {
		this.validateMigrationNaming = validateMigrationNaming;
	}
	public boolean isValidateOnMigrate() {
		return this.validateOnMigrate;
	}
	public void setValidateOnMigrate(boolean validateOnMigrate) {
		this.validateOnMigrate = validateOnMigrate;
	}
	public String getScriptPlaceholderPrefix() {
		return this.scriptPlaceholderPrefix;
	}
	public void setScriptPlaceholderPrefix(String scriptPlaceholderPrefix) {
		this.scriptPlaceholderPrefix = scriptPlaceholderPrefix;
	}
	public String getScriptPlaceholderSuffix() {
		return this.scriptPlaceholderSuffix;
	}
	public void setScriptPlaceholderSuffix(String scriptPlaceholderSuffix) {
		this.scriptPlaceholderSuffix = scriptPlaceholderSuffix;
	}
	public boolean isExecuteInTransaction() {
		return this.executeInTransaction;
	}
	public void setExecuteInTransaction(boolean executeInTransaction) {
		this.executeInTransaction = executeInTransaction;
	}
	public String[] getLoggers() {
		return this.loggers;
	}
	public void setLoggers(String[] loggers) {
		this.loggers = loggers;
	}
	public Boolean getBatch() {
		return this.batch;
	}
	public void setBatch(Boolean batch) {
		this.batch = batch;
	}
	public File getDryRunOutput() {
		return this.dryRunOutput;
	}
	public void setDryRunOutput(File dryRunOutput) {
		this.dryRunOutput = dryRunOutput;
	}
	public String[] getErrorOverrides() {
		return this.errorOverrides;
	}
	public void setErrorOverrides(String[] errorOverrides) {
		this.errorOverrides = errorOverrides;
	}
	@DeprecatedConfigurationProperty(replacement = 'spring.flyway.oracle.sqlplus', since = '3.2.0')
	@Deprecated(since = '3.2.0', forRemoval = true)
	public Boolean getOracleSqlplus() {
		return getOracle().getSqlplus();
	}
	@Deprecated(since = '3.2.0', forRemoval = true)
	public void setOracleSqlplus(Boolean oracleSqlplus) {
		getOracle().setSqlplus(oracleSqlplus);
	}
	@DeprecatedConfigurationProperty(replacement = 'spring.flyway.oracle.sqlplus-warn', since = '3.2.0')
	@Deprecated(since = '3.2.0', forRemoval = true)
	public Boolean getOracleSqlplusWarn() {
		return getOracle().getSqlplusWarn();
	}
	@Deprecated(since = '3.2.0', forRemoval = true)
	public void setOracleSqlplusWarn(Boolean oracleSqlplusWarn) {
		getOracle().setSqlplusWarn(oracleSqlplusWarn);
	}
	@DeprecatedConfigurationProperty(replacement = 'spring.flyway.oracle.wallet-location', since = '3.2.0')
	@Deprecated(since = '3.2.0', forRemoval = true)
	public String getOracleWalletLocation() {
		return getOracle().getWalletLocation();
	}
	@Deprecated(since = '3.2.0', forRemoval = true)
	public void setOracleWalletLocation(String oracleWalletLocation) {
		getOracle().setWalletLocation(oracleWalletLocation);
	}
	public Boolean getStream() {
		return this.stream;
	}
	public void setStream(Boolean stream) {
		this.stream = stream;
	}
	public Map<String, String> getJdbcProperties() {
		return this.jdbcProperties;
	}
	public void setJdbcProperties(Map<String, String> jdbcProperties) {
		this.jdbcProperties = jdbcProperties;
	}
	public String getKerberosConfigFile() {
		return this.kerberosConfigFile;
	}
	public void setKerberosConfigFile(String kerberosConfigFile) {
		this.kerberosConfigFile = kerberosConfigFile;
	}
	@DeprecatedConfigurationProperty(replacement = 'spring.flyway.oracle.kerberos-cache-file', since = '3.2.0')
	@Deprecated(since = '3.2.0', forRemoval = true)
	public String getOracleKerberosCacheFile() {
		return getOracle().getKerberosCacheFile();
	}
	@Deprecated(since = '3.2.0', forRemoval = true)
	public void setOracleKerberosCacheFile(String oracleKerberosCacheFile) {
		getOracle().setKerberosCacheFile(oracleKerberosCacheFile);
	}
	public Boolean getOutputQueryResults() {
		return this.outputQueryResults;
	}
	public void setOutputQueryResults(Boolean outputQueryResults) {
		this.outputQueryResults = outputQueryResults;
	}
	@DeprecatedConfigurationProperty(replacement = 'spring.flyway.sqlserver.kerberos-login-file')
	@Deprecated(since = '3.2.0', forRemoval = true)
	public String getSqlServerKerberosLoginFile() {
		return getSqlserver().getKerberosLoginFile();
	}
	@Deprecated(since = '3.2.0', forRemoval = true)
	public void setSqlServerKerberosLoginFile(String sqlServerKerberosLoginFile) {
		getSqlserver().setKerberosLoginFile(sqlServerKerberosLoginFile);
	}
	public Boolean getSkipExecutingMigrations() {
		return this.skipExecutingMigrations;
	}
	public void setSkipExecutingMigrations(Boolean skipExecutingMigrations) {
		this.skipExecutingMigrations = skipExecutingMigrations;
	}
	public List<String> getIgnoreMigrationPatterns() {
		return this.ignoreMigrationPatterns;
	}
	public void setIgnoreMigrationPatterns(List<String> ignoreMigrationPatterns) {
		this.ignoreMigrationPatterns = ignoreMigrationPatterns;
	}
	public Boolean getDetectEncoding() {
		return this.detectEncoding;
	}
	public void setDetectEncoding(final Boolean detectEncoding) {
		this.detectEncoding = detectEncoding;
	}
	public Boolean getCommunityDbSupportEnabled() {
		return this.communityDbSupportEnabled;
	}
	public void setCommunityDbSupportEnabled(Boolean communityDbSupportEnabled) {
		this.communityDbSupportEnabled = communityDbSupportEnabled;
	}
	public Oracle getOracle() {
		return this.oracle;
	}
	public Postgresql getPostgresql() {
		return this.postgresql;
	}
	public Sqlserver getSqlserver() {
		return this.sqlserver;
	}
	/**
	 * {@code OracleConfigurationExtension} properties.
	 */
	public static class Oracle {
		/**
		 * Whether to enable support for Oracle SQL*Plus commands. Requires Flyway Teams.
		 */
		private Boolean sqlplus;
		/**
		 * Whether to issue a warning rather than an error when a not-yet-supported Oracle
		 * SQL*Plus statement is encountered. Requires Flyway Teams.
		 */
		private Boolean sqlplusWarn;
		/**
		 * Path of the Oracle Kerberos cache file. Requires Flyway Teams.
		 */
		private String kerberosCacheFile;
		/**
		 * Location of the Oracle Wallet, used to sign in to the database automatically.
		 * Requires Flyway Teams.
		 */
		private String walletLocation;
		public Boolean getSqlplus() {
			return this.sqlplus;
		}
		public void setSqlplus(Boolean sqlplus) {
			this.sqlplus = sqlplus;
		}
		public Boolean getSqlplusWarn() {
			return this.sqlplusWarn;
		}
		public void setSqlplusWarn(Boolean sqlplusWarn) {
			this.sqlplusWarn = sqlplusWarn;
		}
		public String getKerberosCacheFile() {
			return this.kerberosCacheFile;
		}
		public void setKerberosCacheFile(String kerberosCacheFile) {
			this.kerberosCacheFile = kerberosCacheFile;
		}
		public String getWalletLocation() {
			return this.walletLocation;
		}
		public void setWalletLocation(String walletLocation) {
			this.walletLocation = walletLocation;
		}
	}
	/**
	 * {@code PostgreSQLConfigurationExtension} properties.
	 */
	public static class Postgresql {
		/**
		 * Whether transactional advisory locks should be used. If set to false,
		 * session-level locks are used instead.
		 */
		private Boolean transactionalLock;
		public Boolean getTransactionalLock() {
			return this.transactionalLock;
		}
		public void setTransactionalLock(Boolean transactionalLock) {
			this.transactionalLock = transactionalLock;
		}
	}
	/**
	 * {@code SQLServerConfigurationExtension} properties.
	 */
	public static class Sqlserver {
		/**
		 * Path to the SQL Server Kerberos login file. Requires Flyway Teams.
		 */
		private String kerberosLoginFile;
		public String getKerberosLoginFile() {
			return this.kerberosLoginFile;
		}
		public void setKerberosLoginFile(String kerberosLoginFile) {
			this.kerberosLoginFile = kerberosLoginFile;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class NativeImageResourceProviderCustomizer extends ResourceProviderCustomizer {
	@Override
	public void customize(FluentConfiguration configuration) {
		if (configuration.getResourceProvider() == null) {
			Scanner<JavaMigration> scanner = new Scanner<>(JavaMigration.class, false, new ResourceNameCache(),
					new LocationScannerCache(), configuration);
			NativeImageResourceProvider resourceProvider = new NativeImageResourceProvider(scanner,
					configuration.getClassLoader(), Arrays.asList(configuration.getLocations()),
					configuration.getEncoding(), configuration.isFailOnMissingLocations());
			configuration.resourceProvider(resourceProvider);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
@AutoConfiguration(after = { DataSourceAutoConfiguration.class, JdbcTemplateAutoConfiguration.class,
		HibernateJpaAutoConfiguration.class })
@ConditionalOnClass(Flyway.class)
@Conditional(FlywayDataSourceCondition.class)
@ConditionalOnProperty(prefix = 'spring.flyway', name = 'enabled', matchIfMissing = true)
@Import(DatabaseInitializationDependencyConfigurer.class)
@ImportRuntimeHints(FlywayAutoConfigurationRuntimeHints.class)
public class FlywayAutoConfiguration {
	@Bean
	@ConfigurationPropertiesBinding
	public StringOrNumberToMigrationVersionConverter stringOrNumberMigrationVersionConverter() {
		return new StringOrNumberToMigrationVersionConverter();
	}
	@Bean
	public FlywaySchemaManagementProvider flywayDefaultDdlModeProvider(ObjectProvider<Flyway> flyways) {
		return new FlywaySchemaManagementProvider(flyways);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(JdbcUtils.class)
	@ConditionalOnMissingBean(Flyway.class)
	@EnableConfigurationProperties(FlywayProperties.class)
	public static class FlywayConfiguration {
		private final FlywayProperties properties;
		FlywayConfiguration(FlywayProperties properties) {
			this.properties = properties;
		}
		@Bean
		ResourceProviderCustomizer resourceProviderCustomizer() {
			return new ResourceProviderCustomizer();
		}
		@Bean
		@ConditionalOnMissingBean(FlywayConnectionDetails.class)
		PropertiesFlywayConnectionDetails flywayConnectionDetails() {
			return new PropertiesFlywayConnectionDetails(this.properties);
		}
		@Bean
		@ConditionalOnClass(name = 'org.flywaydb.database.sqlserver.SQLServerConfigurationExtension')
		SqlServerFlywayConfigurationCustomizer sqlServerFlywayConfigurationCustomizer() {
			return new SqlServerFlywayConfigurationCustomizer(this.properties);
		}
		@Bean
		@ConditionalOnClass(name = 'org.flywaydb.database.oracle.OracleConfigurationExtension')
		OracleFlywayConfigurationCustomizer oracleFlywayConfigurationCustomizer() {
			return new OracleFlywayConfigurationCustomizer(this.properties);
		}
		@Bean
		@ConditionalOnClass(name = 'org.flywaydb.database.postgresql.PostgreSQLConfigurationExtension')
		PostgresqlFlywayConfigurationCustomizer postgresqlFlywayConfigurationCustomizer() {
			return new PostgresqlFlywayConfigurationCustomizer(this.properties);
		}
		@Bean
		Flyway flyway(FlywayConnectionDetails connectionDetails, ResourceLoader resourceLoader,
				ObjectProvider<DataSource> dataSource, @FlywayDataSource ObjectProvider<DataSource> flywayDataSource,
				ObjectProvider<FlywayConfigurationCustomizer> fluentConfigurationCustomizers,
				ObjectProvider<JavaMigration> javaMigrations, ObjectProvider<Callback> callbacks,
				ResourceProviderCustomizer resourceProviderCustomizer) {
			FluentConfiguration configuration = new FluentConfiguration(resourceLoader.getClassLoader());
			configureDataSource(configuration, flywayDataSource.getIfAvailable(), dataSource.getIfUnique(),
					connectionDetails);
			configureProperties(configuration, this.properties);
			configureCallbacks(configuration, callbacks.orderedStream().toList());
			configureJavaMigrations(configuration, javaMigrations.orderedStream().toList());
			fluentConfigurationCustomizers.orderedStream().forEach((customizer) -> customizer.customize(configuration));
			resourceProviderCustomizer.customize(configuration);
			return configuration.load();
		}
		private void configureDataSource(FluentConfiguration configuration, DataSource flywayDataSource,
				DataSource dataSource, FlywayConnectionDetails connectionDetails) {
			DataSource migrationDataSource = getMigrationDataSource(flywayDataSource, dataSource, connectionDetails);
			configuration.dataSource(migrationDataSource);
		}
		private DataSource getMigrationDataSource(DataSource flywayDataSource, DataSource dataSource,
				FlywayConnectionDetails connectionDetails) {
			if (flywayDataSource != null) {
				return flywayDataSource;
			}
			String url = connectionDetails.getJdbcUrl();
			if (url != null) {
				DataSourceBuilder<?> builder = DataSourceBuilder.create().type(SimpleDriverDataSource.class);
				builder.url(url);
				applyConnectionDetails(connectionDetails, builder);
				return builder.build();
			}
			String user = connectionDetails.getUsername();
			if (user != null && dataSource != null) {
				DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource)
					.type(SimpleDriverDataSource.class);
				applyConnectionDetails(connectionDetails, builder);
				return builder.build();
			}
			Assert.state(dataSource != null, 'Flyway migration DataSource missing');
			return dataSource;
		}
		private void applyConnectionDetails(FlywayConnectionDetails connectionDetails, DataSourceBuilder<?> builder) {
			builder.username(connectionDetails.getUsername());
			builder.password(connectionDetails.getPassword());
			String driverClassName = connectionDetails.getDriverClassName();
			if (StringUtils.hasText(driverClassName)) {
				builder.driverClassName(driverClassName);
			}
		}
		/**
		 * Configure the given {@code configuration} using the given {@code properties}.
		 * <p>
		 * To maximize forwards- and backwards-compatibility method references are not
		 * used.
		 * @param configuration the configuration
		 * @param properties the properties
		 */
		@SuppressWarnings('removal')
		private void configureProperties(FluentConfiguration configuration, FlywayProperties properties) {
			// NOTE: Using method references in the mapper methods can break
			// back-compatibility (see gh-38164)
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			String[] locations = new LocationResolver(configuration.getDataSource())
				.resolveLocations(properties.getLocations())
				.toArray(new String[0]);
			configuration.locations(locations);
			map.from(properties.isFailOnMissingLocations())
				.to((failOnMissingLocations) -> configuration.failOnMissingLocations(failOnMissingLocations));
			map.from(properties.getEncoding()).to((encoding) -> configuration.encoding(encoding));
			map.from(properties.getConnectRetries())
				.to((connectRetries) -> configuration.connectRetries(connectRetries));
			map.from(properties.getConnectRetriesInterval())
				.as(Duration::getSeconds)
				.as(Long::intValue)
				.to((connectRetriesInterval) -> configuration.connectRetriesInterval(connectRetriesInterval));
			map.from(properties.getLockRetryCount())
				.to((lockRetryCount) -> configuration.lockRetryCount(lockRetryCount));
			map.from(properties.getDefaultSchema()).to((schema) -> configuration.defaultSchema(schema));
			map.from(properties.getSchemas())
				.as(StringUtils::toStringArray)
				.to((schemas) -> configuration.schemas(schemas));
			map.from(properties.isCreateSchemas()).to((createSchemas) -> configuration.createSchemas(createSchemas));
			map.from(properties.getTable()).to((table) -> configuration.table(table));
			map.from(properties.getTablespace()).to((tablespace) -> configuration.tablespace(tablespace));
			map.from(properties.getBaselineDescription())
				.to((baselineDescription) -> configuration.baselineDescription(baselineDescription));
			map.from(properties.getBaselineVersion())
				.to((baselineVersion) -> configuration.baselineVersion(baselineVersion));
			map.from(properties.getInstalledBy()).to((installedBy) -> configuration.installedBy(installedBy));
			map.from(properties.getPlaceholders()).to((placeholders) -> configuration.placeholders(placeholders));
			map.from(properties.getPlaceholderPrefix())
				.to((placeholderPrefix) -> configuration.placeholderPrefix(placeholderPrefix));
			map.from(properties.getPlaceholderSuffix())
				.to((placeholderSuffix) -> configuration.placeholderSuffix(placeholderSuffix));
			map.from(properties.getPlaceholderSeparator())
				.to((placeHolderSeparator) -> configuration.placeholderSeparator(placeHolderSeparator));
			map.from(properties.isPlaceholderReplacement())
				.to((placeholderReplacement) -> configuration.placeholderReplacement(placeholderReplacement));
			map.from(properties.getSqlMigrationPrefix())
				.to((sqlMigrationPrefix) -> configuration.sqlMigrationPrefix(sqlMigrationPrefix));
			map.from(properties.getSqlMigrationSuffixes())
				.as(StringUtils::toStringArray)
				.to((sqlMigrationSuffixes) -> configuration.sqlMigrationSuffixes(sqlMigrationSuffixes));
			map.from(properties.getSqlMigrationSeparator())
				.to((sqlMigrationSeparator) -> configuration.sqlMigrationSeparator(sqlMigrationSeparator));
			map.from(properties.getRepeatableSqlMigrationPrefix())
				.to((repeatableSqlMigrationPrefix) -> configuration
					.repeatableSqlMigrationPrefix(repeatableSqlMigrationPrefix));
			map.from(properties.getTarget()).to((target) -> configuration.target(target));
			map.from(properties.isBaselineOnMigrate())
				.to((baselineOnMigrate) -> configuration.baselineOnMigrate(baselineOnMigrate));
			map.from(properties.isCleanDisabled()).to((cleanDisabled) -> configuration.cleanDisabled(cleanDisabled));
			map.from(properties.isCleanOnValidationError())
				.to((cleanOnValidationError) -> configuration.cleanOnValidationError(cleanOnValidationError));
			map.from(properties.isGroup()).to((group) -> configuration.group(group));
			map.from(properties.isMixed()).to((mixed) -> configuration.mixed(mixed));
			map.from(properties.isOutOfOrder()).to((outOfOrder) -> configuration.outOfOrder(outOfOrder));
			map.from(properties.isSkipDefaultCallbacks())
				.to((skipDefaultCallbacks) -> configuration.skipDefaultCallbacks(skipDefaultCallbacks));
			map.from(properties.isSkipDefaultResolvers())
				.to((skipDefaultResolvers) -> configuration.skipDefaultResolvers(skipDefaultResolvers));
			map.from(properties.isValidateMigrationNaming())
				.to((validateMigrationNaming) -> configuration.validateMigrationNaming(validateMigrationNaming));
			map.from(properties.isValidateOnMigrate())
				.to((validateOnMigrate) -> configuration.validateOnMigrate(validateOnMigrate));
			map.from(properties.getInitSqls())
				.whenNot(CollectionUtils::isEmpty)
				.as((initSqls) -> StringUtils.collectionToDelimitedString(initSqls, '\n'))
				.to((initSql) -> configuration.initSql(initSql));
			map.from(properties.getScriptPlaceholderPrefix())
				.to((prefix) -> configuration.scriptPlaceholderPrefix(prefix));
			map.from(properties.getScriptPlaceholderSuffix())
				.to((suffix) -> configuration.scriptPlaceholderSuffix(suffix));
			configureExecuteInTransaction(configuration, properties, map);
			map.from(properties::getLoggers).to((loggers) -> configuration.loggers(loggers));
			map.from(properties::getCommunityDbSupportEnabled)
				.to((communityDbSupportEnabled) -> configuration.communityDBSupportEnabled(communityDbSupportEnabled));
			// Flyway Teams properties
			map.from(properties.getBatch()).to((batch) -> configuration.batch(batch));
			map.from(properties.getDryRunOutput()).to((dryRunOutput) -> configuration.dryRunOutput(dryRunOutput));
			map.from(properties.getErrorOverrides())
				.to((errorOverrides) -> configuration.errorOverrides(errorOverrides));
			map.from(properties.getStream()).to((stream) -> configuration.stream(stream));
			map.from(properties.getJdbcProperties())
				.whenNot(Map::isEmpty)
				.to((jdbcProperties) -> configuration.jdbcProperties(jdbcProperties));
			map.from(properties.getKerberosConfigFile())
				.to((configFile) -> configuration.kerberosConfigFile(configFile));
			map.from(properties.getOutputQueryResults())
				.to((outputQueryResults) -> configuration.outputQueryResults(outputQueryResults));
			map.from(properties.getSkipExecutingMigrations())
				.to((skipExecutingMigrations) -> configuration.skipExecutingMigrations(skipExecutingMigrations));
			map.from(properties.getIgnoreMigrationPatterns())
				.whenNot(List::isEmpty)
				.to((ignoreMigrationPatterns) -> configuration
					.ignoreMigrationPatterns(ignoreMigrationPatterns.toArray(new String[0])));
			map.from(properties.getDetectEncoding())
				.to((detectEncoding) -> configuration.detectEncoding(detectEncoding));
		}
		private void configureExecuteInTransaction(FluentConfiguration configuration, FlywayProperties properties,
				PropertyMapper map) {
			try {
				map.from(properties.isExecuteInTransaction()).to(configuration::executeInTransaction);
			}
			catch (NoSuchMethodError ex) {
				// Flyway < 9.14
			}
		}
		private void configureCallbacks(FluentConfiguration configuration, List<Callback> callbacks) {
			if (!callbacks.isEmpty()) {
				configuration.callbacks(callbacks.toArray(new Callback[0]));
			}
		}
		private void configureJavaMigrations(FluentConfiguration flyway, List<JavaMigration> migrations) {
			if (!migrations.isEmpty()) {
				flyway.javaMigrations(migrations.toArray(new JavaMigration[0]));
			}
		}
		@Bean
		@ConditionalOnMissingBean
		public FlywayMigrationInitializer flywayInitializer(Flyway flyway,
				ObjectProvider<FlywayMigrationStrategy> migrationStrategy) {
			return new FlywayMigrationInitializer(flyway, migrationStrategy.getIfAvailable());
		}
	}
	private static class LocationResolver {
		private static final String VENDOR_' = '{vendor}';
		private final DataSource dataSource;
		LocationResolver(DataSource dataSource) {
			this.dataSource = dataSource;
		}
		List<String> resolveLocations(List<String> locations) {
			if (usesVendorLocation(locations)) {
				DatabaseDriver databaseDriver = getDatabaseDriver();
				return replaceVendorLocations(locations, databaseDriver);
			}
			return locations;
		}
		private List<String> replaceVendorLocations(List<String> locations, DatabaseDriver databaseDriver) {
			if (databaseDriver == DatabaseDriver.UNKNOWN) {
				return locations;
			}
			String vendor = databaseDriver.getId();
			return locations.stream().map((location) -> location.replace(VENDOR_', vendor)).toList();
		}
		private DatabaseDriver getDatabaseDriver() {
			try {
				String url = JdbcUtils.extractDatabaseMetaData(this.dataSource, DatabaseMetaData::getURL);
				return DatabaseDriver.fromJdbcUrl(url);
			}
			catch (MetaDataAccessException ex) {
				throw new IllegalStateException(ex);
			}
		}
		private boolean usesVendorLocation(Collection<String> locations) {
			for (String location : locations) {
				if (location.contains(VENDOR_')) {
					return true;
				}
			}
			return false;
		}
	}
	/**
	 * Convert a String or Number to a {@link MigrationVersion}.
	 */
	static class StringOrNumberToMigrationVersionConverter implements GenericConverter {
		private static final Set<ConvertiblePair> CONVERTIBLE_TYPES;
		static {
			Set<ConvertiblePair> types = new HashSet<>(2);
			types.add(new ConvertiblePair(String.class, MigrationVersion.class));
			types.add(new ConvertiblePair(Number.class, MigrationVersion.class));
			CONVERTIBLE_TYPES = Collections.unmodifiableSet(types);
		}
		@Override
		public Set<ConvertiblePair> getConvertibleTypes() {
			return CONVERTIBLE_TYPES;
		}
		@Override
		public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
			String value = ObjectUtils.nullSafeToString(source);
			return MigrationVersion.fromVersion(value);
		}
	}
	static final class FlywayDataSourceCondition extends AnyNestedCondition {
		FlywayDataSourceCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnBean(DataSource.class)
		private static final class DataSourceBeanCondition {
		}
		@ConditionalOnBean(JdbcConnectionDetails.class)
		private static final class JdbcConnectionDetailsCondition {
		}
		@ConditionalOnProperty(prefix = 'spring.flyway', name = 'url')
		private static final class FlywayUrlCondition {
		}
	}
	static class FlywayAutoConfigurationRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('db/migration/*');
		}
	}
	/**
	 * Adapts {@link FlywayProperties} to {@link FlywayConnectionDetails}.
	 */
	static final class PropertiesFlywayConnectionDetails implements FlywayConnectionDetails {
		private final FlywayProperties properties;
		PropertiesFlywayConnectionDetails(FlywayProperties properties) {
			this.properties = properties;
		}
		@Override
		public String getUsername() {
			return this.properties.getUser();
		}
		@Override
		public String getPassword() {
			return this.properties.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.properties.getUrl();
		}
		@Override
		public String getDriverClassName() {
			return this.properties.getDriverClassName();
		}
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	static final class OracleFlywayConfigurationCustomizer implements FlywayConfigurationCustomizer {
		private final FlywayProperties properties;
		OracleFlywayConfigurationCustomizer(FlywayProperties properties) {
			this.properties = properties;
		}
		@Override
		public void customize(FluentConfiguration configuration) {
			Extension<OracleConfigurationExtension> extension = new Extension<>(configuration,
					OracleConfigurationExtension.class, 'Oracle');
			Oracle properties = this.properties.getOracle();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(properties::getSqlplus).to(extension.via((ext, sqlplus) -> ext.setSqlplus(sqlplus)));
			map.from(properties::getSqlplusWarn)
				.to(extension.via((ext, sqlplusWarn) -> ext.setSqlplusWarn(sqlplusWarn)));
			map.from(properties::getWalletLocation)
				.to(extension.via((ext, walletLocation) -> ext.setWalletLocation(walletLocation)));
			map.from(properties::getKerberosCacheFile)
				.to(extension.via((ext, kerberosCacheFile) -> ext.setKerberosCacheFile(kerberosCacheFile)));
		}
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	static final class PostgresqlFlywayConfigurationCustomizer implements FlywayConfigurationCustomizer {
		private final FlywayProperties properties;
		PostgresqlFlywayConfigurationCustomizer(FlywayProperties properties) {
			this.properties = properties;
		}
		@Override
		public void customize(FluentConfiguration configuration) {
			Extension<PostgreSQLConfigurationExtension> extension = new Extension<>(configuration,
					PostgreSQLConfigurationExtension.class, 'PostgreSQL');
			Postgresql properties = this.properties.getPostgresql();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(properties::getTransactionalLock)
				.to(extension.via((ext, transactionalLock) -> ext.setTransactionalLock(transactionalLock)));
		}
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	static final class SqlServerFlywayConfigurationCustomizer implements FlywayConfigurationCustomizer {
		private final FlywayProperties properties;
		SqlServerFlywayConfigurationCustomizer(FlywayProperties properties) {
			this.properties = properties;
		}
		@Override
		public void customize(FluentConfiguration configuration) {
			Extension<SQLServerConfigurationExtension> extension = new Extension<>(configuration,
					SQLServerConfigurationExtension.class, 'SQL Server');
			Sqlserver properties = this.properties.getSqlserver();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(properties::getKerberosLoginFile).to(extension.via(this::setKerberosLoginFile));
		}
		private void setKerberosLoginFile(SQLServerConfigurationExtension configuration, String file) {
			configuration.getKerberos().getLogin().setFile(file);
		}
	}
	/**
	 * Helper class used to map properties to a {@link ConfigurationExtension}.
	 *
	 * @param <E> the extension type
	 */
	static class Extension<E extends ConfigurationExtension> {
		private SingletonSupplier<E> extension;
		Extension(FluentConfiguration configuration, Class<E> type, String name) {
			this.extension = SingletonSupplier.of(() -> {
				E extension = configuration.getPluginRegister().getPlugin(type);
				Assert.notNull(extension, () -> 'Flyway %s extension missing'.formatted(name));
				return extension;
			});
		}
		<T> Consumer<T> via(BiConsumer<E, T> action) {
			return (value) -> action.accept(this.extension.get(), value);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class ResourceProviderCustomizerBeanRegistrationAotProcessor implements BeanRegistrationAotProcessor {
	@Override
	public BeanRegistrationAotContribution processAheadOfTime(RegisteredBean registeredBean) {
		if (registeredBean.getBeanClass().equals(ResourceProviderCustomizer.class)) {
			return BeanRegistrationAotContribution
				.withCustomCodeFragments((codeFragments) -> new AotContribution(codeFragments, registeredBean));
		}
		return null;
	}
	private static class AotContribution extends BeanRegistrationCodeFragmentsDecorator {
		private final RegisteredBean registeredBean;
		protected AotContribution(BeanRegistrationCodeFragments delegate, RegisteredBean registeredBean) {
			super(delegate);
			this.registeredBean = registeredBean;
		}
		@Override
		public CodeBlock generateInstanceSupplierCode(GenerationContext generationContext,
				BeanRegistrationCode beanRegistrationCode, boolean allowDirectSupplierShortcut) {
			GeneratedMethod generatedMethod = beanRegistrationCode.getMethods().add('getInstance', (method) -> {
				method.addJavadoc('Get the bean instance for "$L".', this.registeredBean.getBeanName());
				method.addModifiers(Modifier.PRIVATE, Modifier.STATIC);
				method.returns(NativeImageResourceProviderCustomizer.class);
				CodeBlock.Builder code = CodeBlock.builder();
				code.addStatement('return new $T()', NativeImageResourceProviderCustomizer.class);
				method.addCode(code.build());
			});
			return generatedMethod.toMethodReference().toCodeBlock();
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.flyway;
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class ResourceProviderCustomizer {
	void customize(FluentConfiguration configuration) {
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
public class FlywayMigrationInitializer implements InitializingBean, Ordered {
	private final Flyway flyway;
	private final FlywayMigrationStrategy migrationStrategy;
	private int order = 0;
	/**
	 * Create a new {@link FlywayMigrationInitializer} instance.
	 * @param flyway the flyway instance
	 */
	public FlywayMigrationInitializer(Flyway flyway) {
		this(flyway, null);
	}
	/**
	 * Create a new {@link FlywayMigrationInitializer} instance.
	 * @param flyway the flyway instance
	 * @param migrationStrategy the migration strategy or {@code null}
	 */
	public FlywayMigrationInitializer(Flyway flyway, FlywayMigrationStrategy migrationStrategy) {
		Assert.notNull(flyway, 'Flyway must not be null');
		this.flyway = flyway;
		this.migrationStrategy = migrationStrategy;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		if (this.migrationStrategy != null) {
			this.migrationStrategy.migrate(this.flyway);
		}
		else {
			try {
				this.flyway.migrate();
			}
			catch (NoSuchMethodError ex) {
				// Flyway < 7.0
				this.flyway.getClass().getMethod('migrate').invoke(this.flyway);
			}
		}
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface FlywayDataSource {
}
/*
/**
package org.springframework.boot.autoconfigure.container;
/*
package org.springframework.boot.autoconfigure.container;
/**
public record ContainerImageMetadata(String imageName) {
	static final String NAME = ContainerImageMetadata.class.getName();
	/**
	 * Add this container image metadata to the given attributes.
	 * @param attributes the attributes to add the metadata to
	 */
	public void addTo(AttributeAccessor attributes) {
		if (attributes != null) {
			attributes.setAttribute(NAME, this);
		}
	}
	/**
	 * Return {@code true} if {@link ContainerImageMetadata} has been added to the given
	 * attributes.
	 * @param attributes the attributes to check
	 * @return if metadata is present
	 */
	public static boolean isPresent(AttributeAccessor attributes) {
		return getFrom(attributes) != null;
	}
	/**
	 * Return {@link ContainerImageMetadata} from the given attributes or {@code null} if
	 * no metadata has been added.
	 * @param attributes the attributes
	 * @return the metadata or {@code null}
	 */
	public static ContainerImageMetadata getFrom(AttributeAccessor attributes) {
		return (attributes != null) ? (ContainerImageMetadata) attributes.getAttribute(NAME) : null;
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage {
	/**
	 * Base packages that should be registered with {@link AutoConfigurationPackages}.
	 * <p>
	 * Use {@link #basePackageClasses} for a type-safe alternative to String-based package
	 * names.
	 * @return the back package names
	 * @since 2.3.0
	 */
	String[] basePackages() default {};
	/**
	 * Type-safe alternative to {@link #basePackages} for specifying the packages to be
	 * registered with {@link AutoConfigurationPackages}.
	 * <p>
	 * Consider creating a special no-op marker class or interface in each package that
	 * serves no purpose other than being referenced by this attribute.
	 * @return the base package classes
	 * @since 2.3.0
	 */
	Class<?>[] basePackageClasses() default {};
}
/*
package org.springframework.boot.autoconfigure;
/**
public class AutoConfigurationExcludeFilter implements TypeFilter, BeanClassLoaderAware {
	private ClassLoader beanClassLoader;
	private volatile List<String> autoConfigurations;
	@Override
	public void setBeanClassLoader(ClassLoader beanClassLoader) {
		this.beanClassLoader = beanClassLoader;
	}
	@Override
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		return isConfiguration(metadataReader) && isAutoConfiguration(metadataReader);
	}
	private boolean isConfiguration(MetadataReader metadataReader) {
		return metadataReader.getAnnotationMetadata().isAnnotated(Configuration.class.getName());
	}
	private boolean isAutoConfiguration(MetadataReader metadataReader) {
		boolean annotatedWithAutoConfiguration = metadataReader.getAnnotationMetadata()
			.isAnnotated(AutoConfiguration.class.getName());
		return annotatedWithAutoConfiguration
				|| getAutoConfigurations().contains(metadataReader.getClassMetadata().getClassName());
	}
	protected List<String> getAutoConfigurations() {
		if (this.autoConfigurations == null) {
			ImportCandidates importCandidates = ImportCandidates.load(AutoConfiguration.class, this.beanClassLoader);
			this.autoConfigurations = importCandidates.getCandidates();
		}
		return this.autoConfigurations;
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@FunctionalInterface
public interface AutoConfigurationImportListener extends EventListener {
	/**
	 * Handle an auto-configuration import event.
	 * @param event the event to respond to
	 */
	void onAutoConfigurationImportEvent(AutoConfigurationImportEvent event);
}
/*
package org.springframework.boot.autoconfigure.netty;
/**
@AutoConfiguration
@ConditionalOnClass(NettyRuntime.class)
@EnableConfigurationProperties(NettyProperties.class)
public class NettyAutoConfiguration {
	public NettyAutoConfiguration(NettyProperties properties) {
		if (properties.getLeakDetection() != null) {
			NettyProperties.LeakDetection leakDetection = properties.getLeakDetection();
			ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.valueOf(leakDetection.name()));
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.netty;
/*
package org.springframework.boot.autoconfigure.netty;
/**
@ConfigurationProperties(prefix = 'spring.netty')
public class NettyProperties {
	/**
	 * Level of leak detection for reference-counted buffers. If not configured via
	 * "ResourceLeakDetector.setLevel" or the "io.netty.leakDetection.level" system
	 * property, default to "simple".
	 */
	private LeakDetection leakDetection;
	public LeakDetection getLeakDetection() {
		return this.leakDetection;
	}
	public void setLeakDetection(LeakDetection leakDetection) {
		this.leakDetection = leakDetection;
	}
	public enum LeakDetection {
		/**
		 * Disable leak detection completely.
		 */
		DISABLED,
		/**
		 * Detect leaks for 1% of buffers.
		 */
		SIMPLE,
		/**
		 * Detect leaks for 1% of buffers and track where they were accessed.
		 */
		ADVANCED,
		/**
		 * Detect leaks for 100% of buffers and track where they were accessed.
		 */
		PARANOID
	}
}
/*
package org.springframework.boot.autoconfigure.ldap.embedded;
/**
@ConfigurationProperties(prefix = 'spring.ldap.embedded')
public class EmbeddedLdapProperties {
	/**
	 * Embedded LDAP port.
	 */
	private int port = 0;
	/**
	 * Embedded LDAP credentials.
	 */
	private Credential credential = new Credential();
	/**
	 * List of base DNs.
	 */
	@Delimiter(Delimiter.NONE)
	private List<String> baseDn = new ArrayList<>();
	/**
	 * Schema (LDIF) script resource reference.
	 */
	private String ldif = 'classpath:schema.ldif';
	/**
	 * Schema validation.
	 */
	private final Validation validation = new Validation();
	public int getPort() {
		return this.port;
	}
	public void setPort(int port) {
		this.port = port;
	}
	public Credential getCredential() {
		return this.credential;
	}
	public void setCredential(Credential credential) {
		this.credential = credential;
	}
	public List<String> getBaseDn() {
		return this.baseDn;
	}
	public void setBaseDn(List<String> baseDn) {
		this.baseDn = baseDn;
	}
	public String getLdif() {
		return this.ldif;
	}
	public void setLdif(String ldif) {
		this.ldif = ldif;
	}
	public Validation getValidation() {
		return this.validation;
	}
	public static class Credential {
		/**
		 * Embedded LDAP username.
		 */
		private String username;
		/**
		 * Embedded LDAP password.
		 */
		private String password;
		public String getUsername() {
			return this.username;
		}
		public void setUsername(String username) {
			this.username = username;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
		boolean isAvailable() {
			return StringUtils.hasText(this.username) && StringUtils.hasText(this.password);
		}
	}
	public static class Validation {
		/**
		 * Whether to enable LDAP schema validation.
		 */
		private boolean enabled = true;
		/**
		 * Path to the custom schema.
		 */
		private Resource schema;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public Resource getSchema() {
			return this.schema;
		}
		public void setSchema(Resource schema) {
			this.schema = schema;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ldap.embedded;
/**
@AutoConfiguration(before = LdapAutoConfiguration.class)
@EnableConfigurationProperties({ LdapProperties.class, EmbeddedLdapProperties.class })
@ConditionalOnClass(InMemoryDirectoryServer.class)
@Conditional(EmbeddedLdapAutoConfiguration.EmbeddedLdapCondition.class)
@ImportRuntimeHints(EmbeddedLdapAutoConfigurationRuntimeHints.class)
public class EmbeddedLdapAutoConfiguration {
	private static final String PROPERTY_SOURCE_NAME = 'ldap.ports';
	private final EmbeddedLdapProperties embeddedProperties;
	private InMemoryDirectoryServer server;
	public EmbeddedLdapAutoConfiguration(EmbeddedLdapProperties embeddedProperties) {
		this.embeddedProperties = embeddedProperties;
	}
	@Bean
	public InMemoryDirectoryServer directoryServer(ApplicationContext applicationContext) throws LDAPException {
		String[] baseDn = StringUtils.toStringArray(this.embeddedProperties.getBaseDn());
		InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(baseDn);
		if (this.embeddedProperties.getCredential().isAvailable()) {
			config.addAdditionalBindCredentials(this.embeddedProperties.getCredential().getUsername(),
					this.embeddedProperties.getCredential().getPassword());
		}
		setSchema(config);
		InMemoryListenerConfig listenerConfig = InMemoryListenerConfig.createLDAPConfig('LDAP',
				this.embeddedProperties.getPort());
		config.setListenerConfigs(listenerConfig);
		this.server = new InMemoryDirectoryServer(config);
		importLdif(applicationContext);
		this.server.startListening();
		setPortProperty(applicationContext, this.server.getListenPort());
		return this.server;
	}
	private void setSchema(InMemoryDirectoryServerConfig config) {
		if (!this.embeddedProperties.getValidation().isEnabled()) {
			config.setSchema(null);
			return;
		}
		Resource schema = this.embeddedProperties.getValidation().getSchema();
		if (schema != null) {
			setSchema(config, schema);
		}
	}
	private void setSchema(InMemoryDirectoryServerConfig config, Resource resource) {
		try {
			Schema defaultSchema = Schema.getDefaultStandardSchema();
			Schema schema = Schema.getSchema(resource.getInputStream());
			config.setSchema(Schema.mergeSchemas(defaultSchema, schema));
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to load schema ' + resource.getDescription(), ex);
		}
	}
	private void importLdif(ApplicationContext applicationContext) {
		String location = this.embeddedProperties.getLdif();
		if (StringUtils.hasText(location)) {
			try {
				Resource resource = applicationContext.getResource(location);
				if (resource.exists()) {
					try (InputStream inputStream = resource.getInputStream()) {
						this.server.importFromLDIF(true, new LDIFReader(inputStream));
					}
				}
			}
			catch (Exception ex) {
				throw new IllegalStateException('Unable to load LDIF ' + location, ex);
			}
		}
	}
	private void setPortProperty(ApplicationContext context, int port) {
		if (context instanceof ConfigurableApplicationContext configurableContext) {
			MutablePropertySources sources = configurableContext.getEnvironment().getPropertySources();
			getLdapPorts(sources).put('local.ldap.port', port);
		}
		if (context.getParent() != null) {
			setPortProperty(context.getParent(), port);
		}
	}
	@SuppressWarnings('unchecked')
	private Map<String, Object> getLdapPorts(MutablePropertySources sources) {
		PropertySource<?> propertySource = sources.get(PROPERTY_SOURCE_NAME);
		if (propertySource == null) {
			propertySource = new MapPropertySource(PROPERTY_SOURCE_NAME, new HashMap<>());
			sources.addFirst(propertySource);
		}
		return (Map<String, Object>) propertySource.getSource();
	}
	@PreDestroy
	public void close() {
		if (this.server != null) {
			this.server.shutDown(true);
		}
	}
	/**
	 * {@link SpringBootCondition} to determine when to apply embedded LDAP
	 * auto-configuration.
	 */
	static class EmbeddedLdapCondition extends SpringBootCondition {
		private static final Bindable<List<String>> STRING_LIST = Bindable.listOf(String.class);
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			Builder message = ConditionMessage.forCondition('Embedded LDAP');
			Environment environment = context.getEnvironment();
			if (environment != null && !Binder.get(environment)
				.bind('spring.ldap.embedded.base-dn', STRING_LIST)
				.orElseGet(Collections::emptyList)
				.isEmpty()) {
				return ConditionOutcome.match(message.because('Found base-dn property'));
			}
			return ConditionOutcome.noMatch(message.because('No base-dn property found'));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ContextSource.class)
	static class EmbeddedLdapContextConfiguration {
		@Bean
		@DependsOn('directoryServer')
		@ConditionalOnMissingBean
		LdapContextSource ldapContextSource(Environment environment, LdapProperties properties,
				EmbeddedLdapProperties embeddedProperties) {
			LdapContextSource source = new LdapContextSource();
			source.setBase(properties.getBase());
			if (embeddedProperties.getCredential().isAvailable()) {
				source.setUserDn(embeddedProperties.getCredential().getUsername());
				source.setPassword(embeddedProperties.getCredential().getPassword());
			}
			source.setUrls(properties.determineUrls(environment));
			return source;
		}
	}
	static class EmbeddedLdapAutoConfigurationRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources()
				.registerPatternIfPresent(classLoader, 'schema.ldif', (hint) -> hint.includes('schema.ldif'));
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.ldap.embedded;
/*
package org.springframework.boot.autoconfigure.ldap;
/**
@ConfigurationProperties(prefix = 'spring.ldap')
public class LdapProperties {
	private static final int DEFAULT_PORT = 389;
	/**
	 * LDAP URLs of the server.
	 */
	private String[] urls;
	/**
	 * Base suffix from which all operations should originate.
	 */
	private String base;
	/**
	 * Login username of the server.
	 */
	private String username;
	/**
	 * Login password of the server.
	 */
	private String password;
	/**
	 * Whether read-only operations should use an anonymous environment. Disabled by
	 * default unless a username is set.
	 */
	private Boolean anonymousReadOnly;
	/**
	 * LDAP specification settings.
	 */
	private final Map<String, String> baseEnvironment = new HashMap<>();
	private final Template template = new Template();
	public String[] getUrls() {
		return this.urls;
	}
	public void setUrls(String[] urls) {
		this.urls = urls;
	}
	public String getBase() {
		return this.base;
	}
	public void setBase(String base) {
		this.base = base;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Boolean getAnonymousReadOnly() {
		return this.anonymousReadOnly;
	}
	public void setAnonymousReadOnly(Boolean anonymousReadOnly) {
		this.anonymousReadOnly = anonymousReadOnly;
	}
	public Map<String, String> getBaseEnvironment() {
		return this.baseEnvironment;
	}
	public Template getTemplate() {
		return this.template;
	}
	public String[] determineUrls(Environment environment) {
		if (ObjectUtils.isEmpty(this.urls)) {
			return new String[] { 'ldap://localhost:' + determinePort(environment) };
		}
		return this.urls;
	}
	private int determinePort(Environment environment) {
		Assert.notNull(environment, 'Environment must not be null');
		String localPort = environment.getProperty('local.ldap.port');
		if (localPort != null) {
			return Integer.parseInt(localPort);
		}
		return DEFAULT_PORT;
	}
	/**
	 * {@link LdapTemplate settings}.
	 */
	public static class Template {
		/**
		 * Whether PartialResultException should be ignored in searches through the
		 * LdapTemplate.
		 */
		private boolean ignorePartialResultException = false;
		/**
		 * Whether NameNotFoundException should be ignored in searches through the
		 * LdapTemplate.
		 */
		private boolean ignoreNameNotFoundException = false;
		/**
		 * Whether SizeLimitExceededException should be ignored in searches through the
		 * LdapTemplate.
		 */
		private boolean ignoreSizeLimitExceededException = true;
		public boolean isIgnorePartialResultException() {
			return this.ignorePartialResultException;
		}
		public void setIgnorePartialResultException(boolean ignorePartialResultException) {
			this.ignorePartialResultException = ignorePartialResultException;
		}
		public boolean isIgnoreNameNotFoundException() {
			return this.ignoreNameNotFoundException;
		}
		public void setIgnoreNameNotFoundException(boolean ignoreNameNotFoundException) {
			this.ignoreNameNotFoundException = ignoreNameNotFoundException;
		}
		public boolean isIgnoreSizeLimitExceededException() {
			return this.ignoreSizeLimitExceededException;
		}
		public void setIgnoreSizeLimitExceededException(Boolean ignoreSizeLimitExceededException) {
			this.ignoreSizeLimitExceededException = ignoreSizeLimitExceededException;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ldap;
/**
public interface LdapConnectionDetails extends ConnectionDetails {
	/**
	 * LDAP URLs of the server.
	 * @return the LDAP URLs to use
	 */
	String[] getUrls();
	/**
	 * Base suffix from which all operations should originate.
	 * @return base suffix
	 */
	default String getBase() {
		return null;
	}
	/**
	 * Login username of the server.
	 * @return login username
	 */
	default String getUsername() {
		return null;
	}
	/**
	 * Login password of the server.
	 * @return login password
	 */
	default String getPassword() {
		return null;
	}
}
/*
package org.springframework.boot.autoconfigure.ldap;
/**
class PropertiesLdapConnectionDetails implements LdapConnectionDetails {
	private final LdapProperties properties;
	private final Environment environment;
	PropertiesLdapConnectionDetails(LdapProperties properties, Environment environment) {
		this.properties = properties;
		this.environment = environment;
	}
	@Override
	public String[] getUrls() {
		return this.properties.determineUrls(this.environment);
	}
	@Override
	public String getBase() {
		return this.properties.getBase();
	}
	@Override
	public String getUsername() {
		return this.properties.getUsername();
	}
	@Override
	public String getPassword() {
		return this.properties.getPassword();
	}
}
/*
package org.springframework.boot.autoconfigure.ldap;
/**
@AutoConfiguration
@ConditionalOnClass(ContextSource.class)
@EnableConfigurationProperties(LdapProperties.class)
public class LdapAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(LdapConnectionDetails.class)
	PropertiesLdapConnectionDetails propertiesLdapConnectionDetails(LdapProperties properties,
			Environment environment) {
		return new PropertiesLdapConnectionDetails(properties, environment);
	}
	@Bean
	@ConditionalOnMissingBean
	public LdapContextSource ldapContextSource(LdapConnectionDetails connectionDetails, LdapProperties properties,
			ObjectProvider<DirContextAuthenticationStrategy> dirContextAuthenticationStrategy) {
		LdapContextSource source = new LdapContextSource();
		dirContextAuthenticationStrategy.ifUnique(source::setAuthenticationStrategy);
		PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
		propertyMapper.from(connectionDetails.getUsername()).to(source::setUserDn);
		propertyMapper.from(connectionDetails.getPassword()).to(source::setPassword);
		propertyMapper.from(properties.getAnonymousReadOnly()).to(source::setAnonymousReadOnly);
		propertyMapper.from(connectionDetails.getBase()).to(source::setBase);
		propertyMapper.from(connectionDetails.getUrls()).to(source::setUrls);
		propertyMapper.from(properties.getBaseEnvironment())
			.to((baseEnvironment) -> source.setBaseEnvironmentProperties(Collections.unmodifiableMap(baseEnvironment)));
		return source;
	}
	@Bean
	@ConditionalOnMissingBean(LdapOperations.class)
	public LdapTemplate ldapTemplate(LdapProperties properties, ContextSource contextSource) {
		Template template = properties.getTemplate();
		PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplyingWhenNonNull();
		LdapTemplate ldapTemplate = new LdapTemplate(contextSource);
		propertyMapper.from(template.isIgnorePartialResultException())
			.to(ldapTemplate::setIgnorePartialResultException);
		propertyMapper.from(template.isIgnoreNameNotFoundException()).to(ldapTemplate::setIgnoreNameNotFoundException);
		propertyMapper.from(template.isIgnoreSizeLimitExceededException())
			.to(ldapTemplate::setIgnoreSizeLimitExceededException);
		return ldapTemplate;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.ldap;
/*
package org.springframework.boot.autoconfigure.mongo;
/**
@AutoConfiguration
@ConditionalOnClass(MongoClient.class)
@EnableConfigurationProperties(MongoProperties.class)
@ConditionalOnMissingBean(type = 'org.springframework.data.mongodb.MongoDatabaseFactory')
public class MongoAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(MongoConnectionDetails.class)
	PropertiesMongoConnectionDetails mongoConnectionDetails(MongoProperties properties) {
		return new PropertiesMongoConnectionDetails(properties);
	}
	@Bean
	@ConditionalOnMissingBean(MongoClient.class)
	public MongoClient mongo(ObjectProvider<MongoClientSettingsBuilderCustomizer> builderCustomizers,
			MongoClientSettings settings) {
		return new MongoClientFactory(builderCustomizers.orderedStream().toList()).createMongoClient(settings);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(MongoClientSettings.class)
	static class MongoClientSettingsConfiguration {
		@Bean
		MongoClientSettings mongoClientSettings() {
			return MongoClientSettings.builder().build();
		}
		@Bean
		StandardMongoClientSettingsBuilderCustomizer standardMongoSettingsCustomizer(MongoProperties properties,
				MongoConnectionDetails connectionDetails, ObjectProvider<SslBundles> sslBundles) {
			return new StandardMongoClientSettingsBuilderCustomizer(connectionDetails.getConnectionString(),
					properties.getUuidRepresentation(), properties.getSsl(), sslBundles.getIfAvailable());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
public class StandardMongoClientSettingsBuilderCustomizer implements MongoClientSettingsBuilderCustomizer, Ordered {
	private final ConnectionString connectionString;
	private final UuidRepresentation uuidRepresentation;
	private final MongoProperties.Ssl ssl;
	private final SslBundles sslBundles;
	private int order = 0;
	public StandardMongoClientSettingsBuilderCustomizer(ConnectionString connectionString,
			UuidRepresentation uuidRepresentation, MongoProperties.Ssl ssl, SslBundles sslBundles) {
		this.connectionString = connectionString;
		this.uuidRepresentation = uuidRepresentation;
		this.ssl = ssl;
		this.sslBundles = sslBundles;
	}
	@Override
	public void customize(MongoClientSettings.Builder settingsBuilder) {
		settingsBuilder.uuidRepresentation(this.uuidRepresentation);
		settingsBuilder.applyConnectionString(this.connectionString);
		if (this.ssl.isEnabled()) {
			settingsBuilder.applyToSslSettings(this::configureSsl);
		}
	}
	private void configureSsl(SslSettings.Builder settings) {
		settings.enabled(true);
		if (this.ssl.getBundle() != null) {
			SslBundle sslBundle = this.sslBundles.getBundle(this.ssl.getBundle());
			Assert.state(!sslBundle.getOptions().isSpecified(), 'SSL options cannot be specified with MongoDB');
			settings.context(sslBundle.createSslContext());
		}
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	/**
	 * Set the order value of this object.
	 * @param order the new order value
	 * @see #getOrder()
	 */
	public void setOrder(int order) {
		this.order = order;
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
public abstract class MongoClientFactorySupport<T> {
	private final List<MongoClientSettingsBuilderCustomizer> builderCustomizers;
	private final BiFunction<MongoClientSettings, MongoDriverInformation, T> clientCreator;
	protected MongoClientFactorySupport(List<MongoClientSettingsBuilderCustomizer> builderCustomizers,
			BiFunction<MongoClientSettings, MongoDriverInformation, T> clientCreator) {
		this.builderCustomizers = (builderCustomizers != null) ? builderCustomizers : Collections.emptyList();
		this.clientCreator = clientCreator;
	}
	public T createMongoClient(MongoClientSettings settings) {
		Builder targetSettings = MongoClientSettings.builder(settings);
		customize(targetSettings);
		return this.clientCreator.apply(targetSettings.build(), driverInformation());
	}
	private void customize(Builder builder) {
		for (MongoClientSettingsBuilderCustomizer customizer : this.builderCustomizers) {
			customizer.customize(builder);
		}
	}
	private MongoDriverInformation driverInformation() {
		return MongoDriverInformation.builder(MongoDriverInformation.builder().build())
			.driverName('spring-boot')
			.build();
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
public interface MongoConnectionDetails extends ConnectionDetails {
	/**
	 * The {@link ConnectionString} for MongoDB.
	 * @return the connection string
	 */
	ConnectionString getConnectionString();
	/**
	 * GridFS configuration.
	 * @return the GridFS configuration or {@code null}
	 */
	default GridFs getGridFs() {
		return null;
	}
	/**
	 * GridFS configuration.
	 */
	interface GridFs {
		/**
		 * GridFS database name.
		 * @return the GridFS database name or {@code null}
		 */
		String getDatabase();
		/**
		 * GridFS bucket name.
		 * @return the GridFS bucket name or {@code null}
		 */
		String getBucket();
		/**
		 * Factory method to create a new {@link GridFs} instance.
		 * @param database the database
		 * @param bucket the bucket name
		 * @return a new {@link GridFs} instance
		 */
		static GridFs of(String database, String bucket) {
			return new GridFs() {
				@Override
				public String getDatabase() {
					return database;
				}
				@Override
				public String getBucket() {
					return bucket;
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
@ConfigurationProperties(prefix = 'spring.data.mongodb')
public class MongoProperties {
	/**
	 * Default port used when the configured port is {@code null}.
	 */
	public static final int DEFAULT_PORT = 27017;
	/**
	 * Default URI used when the configured URI is {@code null}.
	 */
	public static final String DEFAULT_URI = 'mongodb://localhost/test';
	/**
	 * Mongo server host. Cannot be set with URI.
	 */
	private String host;
	/**
	 * Mongo server port. Cannot be set with URI.
	 */
	private Integer port = null;
	/**
	 * Additional server hosts. Cannot be set with URI or if "host" is not specified.
	 * Additional hosts will use the default mongo port of 27017. If you want to use a
	 * different port you can use the 'host:port' syntax.
	 */
	private List<String> additionalHosts;
	/**
	 * Mongo database URI. Overrides host, port, username, and password.
	 */
	private String uri;
	/**
	 * Database name. Overrides database in URI.
	 */
	private String database;
	/**
	 * Authentication database name.
	 */
	private String authenticationDatabase;
	private final Gridfs gridfs = new Gridfs();
	/**
	 * Login user of the mongo server. Cannot be set with URI.
	 */
	private String username;
	/**
	 * Login password of the mongo server. Cannot be set with URI.
	 */
	private char[] password;
	/**
	 * Required replica set name for the cluster. Cannot be set with URI.
	 */
	private String replicaSetName;
	/**
	 * Fully qualified name of the FieldNamingStrategy to use.
	 */
	private Class<?> fieldNamingStrategy;
	/**
	 * Representation to use when converting a UUID to a BSON binary value.
	 */
	private UuidRepresentation uuidRepresentation = UuidRepresentation.JAVA_LEGACY;
	private final Ssl ssl = new Ssl();
	/**
	 * Whether to enable auto-index creation.
	 */
	private Boolean autoIndexCreation;
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public String getDatabase() {
		return this.database;
	}
	public void setDatabase(String database) {
		this.database = database;
	}
	public String getAuthenticationDatabase() {
		return this.authenticationDatabase;
	}
	public void setAuthenticationDatabase(String authenticationDatabase) {
		this.authenticationDatabase = authenticationDatabase;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public char[] getPassword() {
		return this.password;
	}
	public void setPassword(char[] password) {
		this.password = password;
	}
	public String getReplicaSetName() {
		return this.replicaSetName;
	}
	public void setReplicaSetName(String replicaSetName) {
		this.replicaSetName = replicaSetName;
	}
	public Class<?> getFieldNamingStrategy() {
		return this.fieldNamingStrategy;
	}
	public void setFieldNamingStrategy(Class<?> fieldNamingStrategy) {
		this.fieldNamingStrategy = fieldNamingStrategy;
	}
	public UuidRepresentation getUuidRepresentation() {
		return this.uuidRepresentation;
	}
	public void setUuidRepresentation(UuidRepresentation uuidRepresentation) {
		this.uuidRepresentation = uuidRepresentation;
	}
	public String getUri() {
		return this.uri;
	}
	public String determineUri() {
		return (this.uri != null) ? this.uri : DEFAULT_URI;
	}
	public void setUri(String uri) {
		this.uri = uri;
	}
	public Integer getPort() {
		return this.port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
	public Gridfs getGridfs() {
		return this.gridfs;
	}
	public String getMongoClientDatabase() {
		if (this.database != null) {
			return this.database;
		}
		return new ConnectionString(determineUri()).getDatabase();
	}
	public Boolean isAutoIndexCreation() {
		return this.autoIndexCreation;
	}
	public void setAutoIndexCreation(Boolean autoIndexCreation) {
		this.autoIndexCreation = autoIndexCreation;
	}
	public List<String> getAdditionalHosts() {
		return this.additionalHosts;
	}
	public void setAdditionalHosts(List<String> additionalHosts) {
		this.additionalHosts = additionalHosts;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public static class Gridfs {
		/**
		 * GridFS database name.
		 */
		private String database;
		/**
		 * GridFS bucket name.
		 */
		private String bucket;
		public String getDatabase() {
			return this.database;
		}
		public void setDatabase(String database) {
			this.database = database;
		}
		public String getBucket() {
			return this.bucket;
		}
		public void setBucket(String bucket) {
			this.bucket = bucket;
		}
	}
	public static class Ssl {
		/**
		 * Whether to enable SSL support. Enabled automatically if 'bundle' is provided
		 * unless specified otherwise.
		 */
		private Boolean enabled;
		/**
		 * SSL bundle name.
		 */
		private String bundle;
		public boolean isEnabled() {
			return (this.enabled != null) ? this.enabled : this.bundle != null;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
public class ReactiveMongoClientFactory extends MongoClientFactorySupport<MongoClient> {
	/**
	 * Construct a factory for creating a {@link MongoClient}.
	 * @param builderCustomizers a list of configuration settings customizers
	 */
	public ReactiveMongoClientFactory(List<MongoClientSettingsBuilderCustomizer> builderCustomizers) {
		super(builderCustomizers, MongoClients::create);
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
@AutoConfiguration
@ConditionalOnClass({ MongoClient.class, Flux.class })
@EnableConfigurationProperties(MongoProperties.class)
public class MongoReactiveAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(MongoConnectionDetails.class)
	PropertiesMongoConnectionDetails mongoConnectionDetails(MongoProperties properties) {
		return new PropertiesMongoConnectionDetails(properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public MongoClient reactiveStreamsMongoClient(
			ObjectProvider<MongoClientSettingsBuilderCustomizer> builderCustomizers, MongoClientSettings settings) {
		ReactiveMongoClientFactory factory = new ReactiveMongoClientFactory(
				builderCustomizers.orderedStream().toList());
		return factory.createMongoClient(settings);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(MongoClientSettings.class)
	static class MongoClientSettingsConfiguration {
		@Bean
		MongoClientSettings mongoClientSettings() {
			return MongoClientSettings.builder().build();
		}
		@Bean
		StandardMongoClientSettingsBuilderCustomizer standardMongoSettingsCustomizer(MongoProperties properties,
				MongoConnectionDetails connectionDetails, ObjectProvider<SslBundles> sslBundles) {
			return new StandardMongoClientSettingsBuilderCustomizer(connectionDetails.getConnectionString(),
					properties.getUuidRepresentation(), properties.getSsl(), sslBundles.getIfAvailable());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ SocketChannel.class, NioEventLoopGroup.class })
	static class NettyDriverConfiguration {
		@Bean
		@Order(Ordered.HIGHEST_PRECEDENCE)
		NettyDriverMongoClientSettingsBuilderCustomizer nettyDriverCustomizer(
				ObjectProvider<MongoClientSettings> settings) {
			return new NettyDriverMongoClientSettingsBuilderCustomizer(settings);
		}
	}
	/**
	 * {@link MongoClientSettingsBuilderCustomizer} to apply Mongo client settings.
	 */
	static final class NettyDriverMongoClientSettingsBuilderCustomizer
			implements MongoClientSettingsBuilderCustomizer, DisposableBean {
		private final ObjectProvider<MongoClientSettings> settings;
		private volatile EventLoopGroup eventLoopGroup;
		NettyDriverMongoClientSettingsBuilderCustomizer(ObjectProvider<MongoClientSettings> settings) {
			this.settings = settings;
		}
		@Override
		public void customize(Builder builder) {
			if (!isCustomTransportConfiguration(this.settings.getIfAvailable())) {
				NioEventLoopGroup eventLoopGroup = new NioEventLoopGroup();
				this.eventLoopGroup = eventLoopGroup;
				builder.transportSettings(TransportSettings.nettyBuilder().eventLoopGroup(eventLoopGroup).build());
			}
		}
		@Override
		public void destroy() {
			EventLoopGroup eventLoopGroup = this.eventLoopGroup;
			if (eventLoopGroup != null) {
				eventLoopGroup.shutdownGracefully().awaitUninterruptibly();
				this.eventLoopGroup = null;
			}
		}
		private boolean isCustomTransportConfiguration(MongoClientSettings settings) {
			return settings != null && settings.getTransportSettings() != null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
@FunctionalInterface
public interface MongoClientSettingsBuilderCustomizer {
	/**
	 * Customize the {@link Builder}.
	 * @param clientSettingsBuilder the builder to customize
	 */
	void customize(Builder clientSettingsBuilder);
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
public class MongoClientFactory extends MongoClientFactorySupport<MongoClient> {
	/**
	 * Construct a factory for creating a blocking {@link MongoClient}.
	 * @param builderCustomizers a list of configuration settings customizers
	 */
	public MongoClientFactory(List<MongoClientSettingsBuilderCustomizer> builderCustomizers) {
		super(builderCustomizers, MongoClients::create);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.mongo;
/*
package org.springframework.boot.autoconfigure.mongo;
/**
public class PropertiesMongoConnectionDetails implements MongoConnectionDetails {
	private final MongoProperties properties;
	public PropertiesMongoConnectionDetails(MongoProperties properties) {
		this.properties = properties;
	}
	@Override
	public ConnectionString getConnectionString() {
		// mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database.collection][?options]]
		if (this.properties.getUri() != null) {
			return new ConnectionString(this.properties.getUri());
		}
		StringBuilder builder = new StringBuilder('mongodb://');
		if (this.properties.getUsername() != null) {
			builder.append(encode(this.properties.getUsername()));
			builder.append(':');
			if (this.properties.getPassword() != null) {
				builder.append(encode(this.properties.getPassword()));
			}
			builder.append('@');
		}
		builder.append((this.properties.getHost() != null) ? this.properties.getHost() : 'localhost');
		if (this.properties.getPort() != null) {
			builder.append(':');
			builder.append(this.properties.getPort());
		}
		if (this.properties.getAdditionalHosts() != null) {
			builder.append(',');
			builder.append(String.join(',', this.properties.getAdditionalHosts()));
		}
		builder.append('/');
		builder.append(this.properties.getMongoClientDatabase());
		List<String> options = getOptions();
		if (!options.isEmpty()) {
			builder.append('?');
			builder.append(String.join('&', options));
		}
		return new ConnectionString(builder.toString());
	}
	private String encode(String input) {
		return URLEncoder.encode(input, StandardCharsets.UTF_8);
	}
	private char[] encode(char[] input) {
		return URLEncoder.encode(new String(input), StandardCharsets.UTF_8).toCharArray();
	}
	@Override
	public GridFs getGridFs() {
		return GridFs.of(PropertiesMongoConnectionDetails.this.properties.getGridfs().getDatabase(),
				PropertiesMongoConnectionDetails.this.properties.getGridfs().getBucket());
	}
	private List<String> getOptions() {
		List<String> options = new ArrayList<>();
		if (StringUtils.hasText(this.properties.getReplicaSetName())) {
			options.add('replicaSet=' + this.properties.getReplicaSetName());
		}
		if (this.properties.getUsername() != null && this.properties.getAuthenticationDatabase() != null) {
			options.add('authSource=' + this.properties.getAuthenticationDatabase());
		}
		return options;
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(DefaultGraphQlSchemaCondition.class)
public @interface ConditionalOnGraphQlSchema {
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
@AutoConfiguration
@ConditionalOnClass({ GraphQL.class, GraphQlSource.class })
@ConditionalOnGraphQlSchema
@EnableConfigurationProperties(GraphQlProperties.class)
@ImportRuntimeHints(GraphQlAutoConfiguration.GraphQlResourcesRuntimeHints.class)
public class GraphQlAutoConfiguration {
	private static final Log logger = LogFactory.getLog(GraphQlAutoConfiguration.class);
	private final ListableBeanFactory beanFactory;
	public GraphQlAutoConfiguration(ListableBeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}
	@Bean
	@ConditionalOnMissingBean
	public GraphQlSource graphQlSource(ResourcePatternResolver resourcePatternResolver, GraphQlProperties properties,
			ObjectProvider<DataFetcherExceptionResolver> exceptionResolvers,
			ObjectProvider<SubscriptionExceptionResolver> subscriptionExceptionResolvers,
			ObjectProvider<Instrumentation> instrumentations, ObjectProvider<RuntimeWiringConfigurer> wiringConfigurers,
			ObjectProvider<GraphQlSourceBuilderCustomizer> sourceCustomizers) {
		String[] schemaLocations = properties.getSchema().getLocations();
		Resource[] schemaResources = resolveSchemaResources(resourcePatternResolver, schemaLocations,
				properties.getSchema().getFileExtensions());
		GraphQlSource.SchemaResourceBuilder builder = GraphQlSource.schemaResourceBuilder()
			.schemaResources(schemaResources)
			.exceptionResolvers(exceptionResolvers.orderedStream().toList())
			.subscriptionExceptionResolvers(subscriptionExceptionResolvers.orderedStream().toList())
			.instrumentation(instrumentations.orderedStream().toList());
		if (properties.getSchema().getInspection().isEnabled()) {
			builder.inspectSchemaMappings(logger::info);
		}
		if (!properties.getSchema().getIntrospection().isEnabled()) {
			Introspection.enabledJvmWide(false);
		}
		builder.configureTypeDefinitions(new ConnectionTypeDefinitionConfigurer());
		wiringConfigurers.orderedStream().forEach(builder::configureRuntimeWiring);
		sourceCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	private Resource[] resolveSchemaResources(ResourcePatternResolver resolver, String[] locations,
			String[] extensions) {
		List<Resource> resources = new ArrayList<>();
		for (String location : locations) {
			for (String extension : extensions) {
				resources.addAll(resolveSchemaResources(resolver, location + '*' + extension));
			}
		}
		return resources.toArray(new Resource[0]);
	}
	private List<Resource> resolveSchemaResources(ResourcePatternResolver resolver, String pattern) {
		try {
			return Arrays.asList(resolver.getResources(pattern));
		}
		catch (IOException ex) {
			logger.debug(LogMessage.format('Could not resolve schema location: "%s"', pattern), ex);
			return Collections.emptyList();
		}
	}
	@Bean
	@ConditionalOnMissingBean
	public BatchLoaderRegistry batchLoaderRegistry() {
		return new DefaultBatchLoaderRegistry();
	}
	@Bean
	@ConditionalOnMissingBean
	public ExecutionGraphQlService executionGraphQlService(GraphQlSource graphQlSource,
			BatchLoaderRegistry batchLoaderRegistry) {
		DefaultExecutionGraphQlService service = new DefaultExecutionGraphQlService(graphQlSource);
		service.addDataLoaderRegistrar(batchLoaderRegistry);
		return service;
	}
	@Bean
	@ConditionalOnMissingBean
	public AnnotatedControllerConfigurer annotatedControllerConfigurer(
			@Qualifier(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME) ObjectProvider<Executor> executorProvider,
			ObjectProvider<HandlerMethodArgumentResolver> argumentResolvers) {
		AnnotatedControllerConfigurer controllerConfigurer = new AnnotatedControllerConfigurer();
		controllerConfigurer
			.addFormatterRegistrar((registry) -> ApplicationConversionService.addBeans(registry, this.beanFactory));
		executorProvider.ifAvailable(controllerConfigurer::setExecutor);
		argumentResolvers.orderedStream().forEach(controllerConfigurer::addCustomArgumentResolver);
		return controllerConfigurer;
	}
	@Bean
	DataFetcherExceptionResolver annotatedControllerConfigurerDataFetcherExceptionResolver(
			AnnotatedControllerConfigurer annotatedControllerConfigurer) {
		return annotatedControllerConfigurer.getExceptionResolver();
	}
	@ConditionalOnClass(ScrollPosition.class)
	@Configuration(proxyBeanMethods = false)
	static class GraphQlDataAutoConfiguration {
		@Bean
		@ConditionalOnMissingBean
		EncodingCursorStrategy<ScrollPosition> cursorStrategy() {
			return CursorStrategy.withEncoder(new ScrollPositionCursorStrategy(), CursorEncoder.base64());
		}
		@Bean
		@SuppressWarnings('unchecked')
		GraphQlSourceBuilderCustomizer cursorStrategyCustomizer(CursorStrategy<?> cursorStrategy) {
			if (cursorStrategy.supports(ScrollPosition.class)) {
				CursorStrategy<ScrollPosition> scrollCursorStrategy = (CursorStrategy<ScrollPosition>) cursorStrategy;
				ConnectionFieldTypeVisitor connectionFieldTypeVisitor = ConnectionFieldTypeVisitor
					.create(List.of(new WindowConnectionAdapter(scrollCursorStrategy),
							new SliceConnectionAdapter(scrollCursorStrategy)));
				return (builder) -> builder.typeVisitors(List.of(connectionFieldTypeVisitor));
			}
			return (builder) -> {
			};
		}
	}
	static class GraphQlResourcesRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('graphql/*.graphqls').registerPattern('graphql/*.gqls');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.security;
/**
@AutoConfiguration(after = GraphQlWebMvcAutoConfiguration.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass({ GraphQL.class, GraphQlHttpHandler.class, EnableWebSecurity.class })
@ConditionalOnBean(GraphQlHttpHandler.class)
public class GraphQlWebMvcSecurityAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public SecurityDataFetcherExceptionResolver securityDataFetcherExceptionResolver() {
		return new SecurityDataFetcherExceptionResolver();
	}
}
/*
/**
package org.springframework.boot.autoconfigure.graphql.security;
/*
package org.springframework.boot.autoconfigure.graphql.security;
/**
@AutoConfiguration(after = GraphQlWebFluxAutoConfiguration.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@ConditionalOnClass({ GraphQL.class, GraphQlHttpHandler.class, EnableWebFluxSecurity.class })
@ConditionalOnBean(GraphQlHttpHandler.class)
public class GraphQlWebFluxSecurityAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ReactiveSecurityDataFetcherExceptionResolver reactiveSecurityDataFetcherExceptionResolver() {
		return new ReactiveSecurityDataFetcherExceptionResolver();
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
@AutoConfiguration(after = GraphQlAutoConfiguration.class)
@ConditionalOnClass({ GraphQL.class, QueryByExampleDataFetcher.class, QueryByExampleExecutor.class })
@ConditionalOnBean(GraphQlSource.class)
public class GraphQlQueryByExampleAutoConfiguration {
	@Bean
	public GraphQlSourceBuilderCustomizer queryByExampleRegistrar(ObjectProvider<QueryByExampleExecutor<?>> executors) {
		RuntimeWiringConfigurer configurer = QueryByExampleDataFetcher
			.autoRegistrationConfigurer(executors.orderedStream().toList(), Collections.emptyList());
		return (builder) -> builder.configureRuntimeWiring(configurer);
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
@AutoConfiguration(after = GraphQlAutoConfiguration.class)
@ConditionalOnClass({ GraphQL.class, QueryByExampleDataFetcher.class, ReactiveQueryByExampleExecutor.class })
@ConditionalOnBean(GraphQlSource.class)
public class GraphQlReactiveQueryByExampleAutoConfiguration {
	@Bean
	public GraphQlSourceBuilderCustomizer reactiveQueryByExampleRegistrar(
			ObjectProvider<ReactiveQueryByExampleExecutor<?>> reactiveExecutors) {
		RuntimeWiringConfigurer configurer = QueryByExampleDataFetcher
			.autoRegistrationConfigurer(Collections.emptyList(), reactiveExecutors.orderedStream().toList());
		return (builder) -> builder.configureRuntimeWiring(configurer);
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
@AutoConfiguration(after = GraphQlAutoConfiguration.class)
@ConditionalOnClass({ GraphQL.class, Query.class, QuerydslDataFetcher.class, ReactiveQuerydslPredicateExecutor.class })
@ConditionalOnBean(GraphQlSource.class)
public class GraphQlReactiveQuerydslAutoConfiguration {
	@Bean
	public GraphQlSourceBuilderCustomizer reactiveQuerydslRegistrar(
			ObjectProvider<ReactiveQuerydslPredicateExecutor<?>> reactiveExecutors) {
		RuntimeWiringConfigurer configurer = QuerydslDataFetcher.autoRegistrationConfigurer(Collections.emptyList(),
				reactiveExecutors.orderedStream().toList());
		return (builder) -> builder.configureRuntimeWiring(configurer);
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
@AutoConfiguration(after = GraphQlAutoConfiguration.class)
@ConditionalOnClass({ GraphQL.class, Query.class, QuerydslDataFetcher.class, QuerydslPredicateExecutor.class })
@ConditionalOnBean(GraphQlSource.class)
public class GraphQlQuerydslAutoConfiguration {
	@Bean
	public GraphQlSourceBuilderCustomizer querydslRegistrar(ObjectProvider<QuerydslPredicateExecutor<?>> executors) {
		RuntimeWiringConfigurer configurer = QuerydslDataFetcher
			.autoRegistrationConfigurer(executors.orderedStream().toList(), Collections.emptyList());
		return (builder) -> builder.configureRuntimeWiring(configurer);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.graphql.data;
/*
/**
package org.springframework.boot.autoconfigure.graphql.servlet;
/*
package org.springframework.boot.autoconfigure.graphql.servlet;
/**
@AutoConfiguration(after = GraphQlAutoConfiguration.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass({ GraphQL.class, GraphQlHttpHandler.class })
@ConditionalOnBean(ExecutionGraphQlService.class)
@EnableConfigurationProperties(GraphQlCorsProperties.class)
@ImportRuntimeHints(GraphQlWebMvcAutoConfiguration.GraphiQlResourceHints.class)
public class GraphQlWebMvcAutoConfiguration {
	private static final Log logger = LogFactory.getLog(GraphQlWebMvcAutoConfiguration.class);
	@Bean
	@ConditionalOnMissingBean
	public GraphQlHttpHandler graphQlHttpHandler(WebGraphQlHandler webGraphQlHandler) {
		return new GraphQlHttpHandler(webGraphQlHandler);
	}
	@Bean
	@ConditionalOnMissingBean
	public GraphQlSseHandler graphQlSseHandler(WebGraphQlHandler webGraphQlHandler) {
		return new GraphQlSseHandler(webGraphQlHandler);
	}
	@Bean
	@ConditionalOnMissingBean
	public WebGraphQlHandler webGraphQlHandler(ExecutionGraphQlService service,
			ObjectProvider<WebGraphQlInterceptor> interceptors) {
		return WebGraphQlHandler.builder(service).interceptors(interceptors.orderedStream().toList()).build();
	}
	@Bean
	@Order(0)
	public RouterFunction<ServerResponse> graphQlRouterFunction(GraphQlHttpHandler httpHandler,
			GraphQlSseHandler sseHandler, GraphQlSource graphQlSource, GraphQlProperties properties) {
		String path = properties.getPath();
		logger.info(LogMessage.format('GraphQL endpoint HTTP POST %s', path));
		RouterFunctions.Builder builder = RouterFunctions.route();
		builder.route(GraphQlRequestPredicates.graphQlHttp(path), httpHandler::handleRequest);
		builder.route(GraphQlRequestPredicates.graphQlSse(path), sseHandler::handleRequest);
		builder.POST(path, this::unsupportedMediaType);
		builder.GET(path, this::onlyAllowPost);
		if (properties.getGraphiql().isEnabled()) {
			GraphiQlHandler graphiQLHandler = new GraphiQlHandler(path, properties.getWebsocket().getPath());
			builder.GET(properties.getGraphiql().getPath(), graphiQLHandler::handleRequest);
		}
		if (properties.getSchema().getPrinter().isEnabled()) {
			SchemaHandler schemaHandler = new SchemaHandler(graphQlSource);
			builder.GET(path + '/schema', schemaHandler::handleRequest);
		}
		return builder.build();
	}
	private ServerResponse unsupportedMediaType(ServerRequest request) {
		return ServerResponse.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE).headers(this::acceptJson).build();
	}
	private void acceptJson(HttpHeaders headers) {
		headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
	}
	private ServerResponse onlyAllowPost(ServerRequest request) {
		return ServerResponse.status(HttpStatus.METHOD_NOT_ALLOWED).headers(this::onlyAllowPost).build();
	}
	private void onlyAllowPost(HttpHeaders headers) {
		headers.setAllow(Collections.singleton(HttpMethod.POST));
	}
	@Configuration(proxyBeanMethods = false)
	public static class GraphQlEndpointCorsConfiguration implements WebMvcConfigurer {
		final GraphQlProperties graphQlProperties;
		final GraphQlCorsProperties corsProperties;
		public GraphQlEndpointCorsConfiguration(GraphQlProperties graphQlProps, GraphQlCorsProperties corsProps) {
			this.graphQlProperties = graphQlProps;
			this.corsProperties = corsProps;
		}
		@Override
		public void addCorsMappings(CorsRegistry registry) {
			CorsConfiguration configuration = this.corsProperties.toCorsConfiguration();
			if (configuration != null) {
				registry.addMapping(this.graphQlProperties.getPath()).combine(configuration);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ ServerContainer.class, WebSocketHandler.class })
	@ConditionalOnProperty(prefix = 'spring.graphql.websocket', name = 'path')
	public static class WebSocketConfiguration {
		@Bean
		@ConditionalOnMissingBean
		public GraphQlWebSocketHandler graphQlWebSocketHandler(WebGraphQlHandler webGraphQlHandler,
				GraphQlProperties properties, HttpMessageConverters converters) {
			return new GraphQlWebSocketHandler(webGraphQlHandler, getJsonConverter(converters),
					properties.getWebsocket().getConnectionInitTimeout(), properties.getWebsocket().getKeepAlive());
		}
		private GenericHttpMessageConverter<Object> getJsonConverter(HttpMessageConverters converters) {
			return converters.getConverters()
				.stream()
				.filter(this::canReadJsonMap)
				.findFirst()
				.map(this::asGenericHttpMessageConverter)
				.orElseThrow(() -> new IllegalStateException('No JSON converter'));
		}
		private boolean canReadJsonMap(HttpMessageConverter<?> candidate) {
			return candidate.canRead(Map.class, MediaType.APPLICATION_JSON);
		}
		@SuppressWarnings('unchecked')
		private GenericHttpMessageConverter<Object> asGenericHttpMessageConverter(HttpMessageConverter<?> converter) {
			return (GenericHttpMessageConverter<Object>) converter;
		}
		@Bean
		public HandlerMapping graphQlWebSocketMapping(GraphQlWebSocketHandler handler, GraphQlProperties properties) {
			String path = properties.getWebsocket().getPath();
			logger.info(LogMessage.format('GraphQL endpoint WebSocket %s', path));
			WebSocketHandlerMapping mapping = new WebSocketHandlerMapping();
			mapping.setWebSocketUpgradeMatch(true);
			mapping.setUrlMap(Collections.singletonMap(path,
					handler.initWebSocketHttpRequestHandler(new DefaultHandshakeHandler())));
			mapping.setOrder(-2); // Ahead of HTTP endpoint ('routerFunctionMapping' bean)
			return mapping;
		}
	}
	static class GraphiQlResourceHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('graphiql/index.html');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
@ConfigurationProperties(prefix = 'spring.graphql')
public class GraphQlProperties {
	/**
	 * Path at which to expose a GraphQL request HTTP endpoint.
	 */
	private String path = '/graphql';
	private final Graphiql graphiql = new Graphiql();
	private final Schema schema = new Schema();
	private final Websocket websocket = new Websocket();
	private final Rsocket rsocket = new Rsocket();
	public Graphiql getGraphiql() {
		return this.graphiql;
	}
	public String getPath() {
		return this.path;
	}
	public void setPath(String path) {
		this.path = path;
	}
	public Schema getSchema() {
		return this.schema;
	}
	public Websocket getWebsocket() {
		return this.websocket;
	}
	public Rsocket getRsocket() {
		return this.rsocket;
	}
	public static class Schema {
		/**
		 * Locations of GraphQL schema files.
		 */
		private String[] locations = new String[] { 'classpath:graphql/**/' };
		/**
		 * File extensions for GraphQL schema files.
		 */
		private String[] fileExtensions = new String[] { '.graphqls', '.gqls' };
		private final Inspection inspection = new Inspection();
		private final Introspection introspection = new Introspection();
		private final Printer printer = new Printer();
		public String[] getLocations() {
			return this.locations;
		}
		public void setLocations(String[] locations) {
			this.locations = appendSlashIfNecessary(locations);
		}
		public String[] getFileExtensions() {
			return this.fileExtensions;
		}
		public void setFileExtensions(String[] fileExtensions) {
			this.fileExtensions = fileExtensions;
		}
		private String[] appendSlashIfNecessary(String[] locations) {
			return Arrays.stream(locations)
				.map((location) -> location.endsWith('/') ? location : location + '/')
				.toArray(String[]::new);
		}
		public Inspection getInspection() {
			return this.inspection;
		}
		public Introspection getIntrospection() {
			return this.introspection;
		}
		public Printer getPrinter() {
			return this.printer;
		}
		public static class Inspection {
			/**
			 * Whether schema should be compared to the application to detect missing
			 * mappings.
			 */
			private boolean enabled = true;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
		}
		public static class Introspection {
			/**
			 * Whether field introspection should be enabled at the schema level.
			 */
			private boolean enabled = true;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
		}
		public static class Printer {
			/**
			 * Whether the endpoint that prints the schema is enabled. Schema is available
			 * under spring.graphql.path + '/schema'.
			 */
			private boolean enabled = false;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
		}
	}
	public static class Graphiql {
		/**
		 * Path to the GraphiQL UI endpoint.
		 */
		private String path = '/graphiql';
		/**
		 * Whether the default GraphiQL UI is enabled.
		 */
		private boolean enabled = false;
		public String getPath() {
			return this.path;
		}
		public void setPath(String path) {
			this.path = path;
		}
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
	public static class Websocket {
		/**
		 * Path of the GraphQL WebSocket subscription endpoint.
		 */
		private String path;
		/**
		 * Time within which the initial {@code CONNECTION_INIT} type message must be
		 * received.
		 */
		private Duration connectionInitTimeout = Duration.ofSeconds(60);
		/**
		 * Maximum idle period before a server keep-alive ping is sent to client.
		 */
		private Duration keepAlive;
		public String getPath() {
			return this.path;
		}
		public void setPath(String path) {
			this.path = path;
		}
		public Duration getConnectionInitTimeout() {
			return this.connectionInitTimeout;
		}
		public void setConnectionInitTimeout(Duration connectionInitTimeout) {
			this.connectionInitTimeout = connectionInitTimeout;
		}
		public Duration getKeepAlive() {
			return this.keepAlive;
		}
		public void setKeepAlive(Duration keepAlive) {
			this.keepAlive = keepAlive;
		}
	}
	public static class Rsocket {
		/**
		 * Mapping of the RSocket message handler.
		 */
		private String mapping;
		public String getMapping() {
			return this.mapping;
		}
		public void setMapping(String mapping) {
			this.mapping = mapping;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
@FunctionalInterface
public interface GraphQlSourceBuilderCustomizer {
	/**
	 * Customize the
	 * {@link org.springframework.graphql.execution.GraphQlSource.SchemaResourceBuilder
	 * Builder} instance.
	 * @param builder builder the builder to customize
	 */
	void customize(GraphQlSource.SchemaResourceBuilder builder);
}
/*
package org.springframework.boot.autoconfigure.graphql.rsocket;
@Controller
class GraphQlRSocketController {
	private final GraphQlRSocketHandler handler;
	GraphQlRSocketController(GraphQlRSocketHandler handler) {
		this.handler = handler;
	}
	@MessageMapping('${spring.graphql.rsocket.mapping}')
	Mono<Map<String, Object>> handle(Map<String, Object> payload) {
		return this.handler.handle(payload);
	}
	@MessageMapping('${spring.graphql.rsocket.mapping}')
	Flux<Map<String, Object>> handleSubscription(Map<String, Object> payload) {
		return this.handler.handleSubscription(payload);
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.rsocket;
/**
@AutoConfiguration(after = RSocketRequesterAutoConfiguration.class)
@ConditionalOnClass({ GraphQL.class, RSocketGraphQlClient.class, RSocketRequester.class, RSocket.class,
		TcpClientTransport.class })
public class RSocketGraphQlClientAutoConfiguration {
	@Bean
	@Scope('prototype')
	@ConditionalOnMissingBean
	public RSocketGraphQlClient.Builder<?> rsocketGraphQlClientBuilder(
			RSocketRequester.Builder rsocketRequesterBuilder) {
		return RSocketGraphQlClient.builder(rsocketRequesterBuilder.dataMimeType(MimeTypeUtils.APPLICATION_JSON));
	}
}
/*
/**
package org.springframework.boot.autoconfigure.graphql.rsocket;
/*
package org.springframework.boot.autoconfigure.graphql.rsocket;
/**
@AutoConfiguration(after = { GraphQlAutoConfiguration.class, RSocketMessagingAutoConfiguration.class })
@ConditionalOnClass({ GraphQL.class, GraphQlSource.class, RSocketServer.class, HttpServer.class })
@ConditionalOnBean({ RSocketMessageHandler.class, AnnotatedControllerConfigurer.class })
@ConditionalOnProperty(prefix = 'spring.graphql.rsocket', name = 'mapping')
public class GraphQlRSocketAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public GraphQlRSocketHandler graphQlRSocketHandler(ExecutionGraphQlService graphQlService,
			ObjectProvider<RSocketGraphQlInterceptor> interceptors, ObjectMapper objectMapper) {
		return new GraphQlRSocketHandler(graphQlService, interceptors.orderedStream().toList(),
				new Jackson2JsonEncoder(objectMapper));
	}
	@Bean
	@ConditionalOnMissingBean
	public GraphQlRSocketController graphQlRSocketController(GraphQlRSocketHandler handler) {
		return new GraphQlRSocketController(handler);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.graphql;
/*
package org.springframework.boot.autoconfigure.graphql;
/**
class DefaultGraphQlSchemaCondition extends SpringBootCondition implements ConfigurationCondition {
	@Override
	public ConfigurationCondition.ConfigurationPhase getConfigurationPhase() {
		return ConfigurationCondition.ConfigurationPhase.REGISTER_BEAN;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		boolean match = false;
		List<ConditionMessage> messages = new ArrayList<>(2);
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnGraphQlSchema.class);
		Binder binder = Binder.get(context.getEnvironment());
		GraphQlProperties.Schema schema = binder.bind('spring.graphql.schema', GraphQlProperties.Schema.class)
			.orElse(new GraphQlProperties.Schema());
		ResourcePatternResolver resourcePatternResolver = ResourcePatternUtils
			.getResourcePatternResolver(context.getResourceLoader());
		List<Resource> schemaResources = resolveSchemaResources(resourcePatternResolver, schema.getLocations(),
				schema.getFileExtensions());
		if (!schemaResources.isEmpty()) {
			match = true;
			messages.add(message.found('schema', 'schemas').items(ConditionMessage.Style.QUOTE, schemaResources));
		}
		else {
			messages.add(message.didNotFind('schema files in locations')
				.items(ConditionMessage.Style.QUOTE, Arrays.asList(schema.getLocations())));
		}
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		String[] customizerBeans = beanFactory.getBeanNamesForType(GraphQlSourceBuilderCustomizer.class, false, false);
		if (customizerBeans.length != 0) {
			match = true;
			messages.add(message.found('customizer', 'customizers').items(Arrays.asList(customizerBeans)));
		}
		else {
			messages.add((message.didNotFind('GraphQlSourceBuilderCustomizer').atAll()));
		}
		return new ConditionOutcome(match, ConditionMessage.of(messages));
	}
	private List<Resource> resolveSchemaResources(ResourcePatternResolver resolver, String[] locations,
			String[] extensions) {
		List<Resource> resources = new ArrayList<>();
		for (String location : locations) {
			for (String extension : extensions) {
				resources.addAll(resolveSchemaResources(resolver, location + '*' + extension));
			}
		}
		return resources;
	}
	private List<Resource> resolveSchemaResources(ResourcePatternResolver resolver, String pattern) {
		try {
			return Arrays.asList(resolver.getResources(pattern));
		}
		catch (IOException ex) {
			return Collections.emptyList();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
@ConfigurationProperties(prefix = 'spring.graphql.cors')
public class GraphQlCorsProperties {
	/**
	 * List of origins to allow with "*" allowing all origins. When allow-credentials is
	 * enabled, "*" cannot be used, and setting origin patterns should be considered
	 * instead. When neither allowed origins nor allowed origin patterns are set,
	 * cross-origin requests are effectively disabled.
	 */
	private List<String> allowedOrigins = new ArrayList<>();
	/**
	 * List of origin patterns to allow. Unlike allowed origins which only support "*",
	 * origin patterns are more flexible, e.g. "https://*.example.com", and can be used
	 * with allow-credentials. When neither allowed origins nor allowed origin patterns
	 * are set, cross-origin requests are effectively disabled.
	 */
	private List<String> allowedOriginPatterns = new ArrayList<>();
	/**
	 * List of HTTP methods to allow. "*" allows all methods. When not set, defaults to
	 * GET.
	 */
	private List<String> allowedMethods = new ArrayList<>();
	/**
	 * List of HTTP headers to allow in a request. "*" allows all headers.
	 */
	private List<String> allowedHeaders = new ArrayList<>();
	/**
	 * List of headers to include in a response.
	 */
	private List<String> exposedHeaders = new ArrayList<>();
	/**
	 * Whether credentials are supported. When not set, credentials are not supported.
	 */
	private Boolean allowCredentials;
	/**
	 * How long the response from a pre-flight request can be cached by clients. If a
	 * duration suffix is not specified, seconds will be used.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration maxAge = Duration.ofSeconds(1800);
	public List<String> getAllowedOrigins() {
		return this.allowedOrigins;
	}
	public void setAllowedOrigins(List<String> allowedOrigins) {
		this.allowedOrigins = allowedOrigins;
	}
	public List<String> getAllowedOriginPatterns() {
		return this.allowedOriginPatterns;
	}
	public void setAllowedOriginPatterns(List<String> allowedOriginPatterns) {
		this.allowedOriginPatterns = allowedOriginPatterns;
	}
	public List<String> getAllowedMethods() {
		return this.allowedMethods;
	}
	public void setAllowedMethods(List<String> allowedMethods) {
		this.allowedMethods = allowedMethods;
	}
	public List<String> getAllowedHeaders() {
		return this.allowedHeaders;
	}
	public void setAllowedHeaders(List<String> allowedHeaders) {
		this.allowedHeaders = allowedHeaders;
	}
	public List<String> getExposedHeaders() {
		return this.exposedHeaders;
	}
	public void setExposedHeaders(List<String> exposedHeaders) {
		this.exposedHeaders = exposedHeaders;
	}
	public Boolean getAllowCredentials() {
		return this.allowCredentials;
	}
	public void setAllowCredentials(Boolean allowCredentials) {
		this.allowCredentials = allowCredentials;
	}
	public Duration getMaxAge() {
		return this.maxAge;
	}
	public void setMaxAge(Duration maxAge) {
		this.maxAge = maxAge;
	}
	public CorsConfiguration toCorsConfiguration() {
		if (CollectionUtils.isEmpty(this.allowedOrigins) && CollectionUtils.isEmpty(this.allowedOriginPatterns)) {
			return null;
		}
		PropertyMapper map = PropertyMapper.get();
		CorsConfiguration config = new CorsConfiguration();
		map.from(this::getAllowedOrigins).to(config::setAllowedOrigins);
		map.from(this::getAllowedOriginPatterns).to(config::setAllowedOriginPatterns);
		map.from(this::getAllowedHeaders).whenNot(CollectionUtils::isEmpty).to(config::setAllowedHeaders);
		map.from(this::getAllowedMethods).whenNot(CollectionUtils::isEmpty).to(config::setAllowedMethods);
		map.from(this::getExposedHeaders).whenNot(CollectionUtils::isEmpty).to(config::setExposedHeaders);
		map.from(this::getMaxAge).whenNonNull().as(Duration::getSeconds).to(config::setMaxAge);
		map.from(this::getAllowCredentials).whenNonNull().to(config::setAllowCredentials);
		return config;
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.reactive;
/**
@AutoConfiguration(after = GraphQlAutoConfiguration.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@ConditionalOnClass({ GraphQL.class, GraphQlHttpHandler.class })
@ConditionalOnBean(ExecutionGraphQlService.class)
@EnableConfigurationProperties(GraphQlCorsProperties.class)
@ImportRuntimeHints(GraphQlWebFluxAutoConfiguration.GraphiQlResourceHints.class)
public class GraphQlWebFluxAutoConfiguration {
	private static final Log logger = LogFactory.getLog(GraphQlWebFluxAutoConfiguration.class);
	@Bean
	@ConditionalOnMissingBean
	public WebGraphQlHandler webGraphQlHandler(ExecutionGraphQlService service,
			ObjectProvider<WebGraphQlInterceptor> interceptors) {
		return WebGraphQlHandler.builder(service).interceptors(interceptors.orderedStream().toList()).build();
	}
	@Bean
	@ConditionalOnMissingBean
	public GraphQlHttpHandler graphQlHttpHandler(WebGraphQlHandler webGraphQlHandler) {
		return new GraphQlHttpHandler(webGraphQlHandler);
	}
	@Bean
	@ConditionalOnMissingBean
	public GraphQlSseHandler graphQlSseHandler(WebGraphQlHandler webGraphQlHandler) {
		return new GraphQlSseHandler(webGraphQlHandler);
	}
	@Bean
	@Order(0)
	public RouterFunction<ServerResponse> graphQlRouterFunction(GraphQlHttpHandler httpHandler,
			GraphQlSseHandler sseHandler, GraphQlSource graphQlSource, GraphQlProperties properties) {
		String path = properties.getPath();
		logger.info(LogMessage.format('GraphQL endpoint HTTP POST %s', path));
		RouterFunctions.Builder builder = RouterFunctions.route();
		builder.route(GraphQlRequestPredicates.graphQlHttp(path), httpHandler::handleRequest);
		builder.route(GraphQlRequestPredicates.graphQlSse(path), sseHandler::handleRequest);
		builder.POST(path, this::unsupportedMediaType);
		builder.GET(path, this::onlyAllowPost);
		if (properties.getGraphiql().isEnabled()) {
			GraphiQlHandler graphQlHandler = new GraphiQlHandler(path, properties.getWebsocket().getPath());
			builder.GET(properties.getGraphiql().getPath(), graphQlHandler::handleRequest);
		}
		if (properties.getSchema().getPrinter().isEnabled()) {
			SchemaHandler schemaHandler = new SchemaHandler(graphQlSource);
			builder.GET(path + '/schema', schemaHandler::handleRequest);
		}
		return builder.build();
	}
	private Mono<ServerResponse> unsupportedMediaType(ServerRequest request) {
		return ServerResponse.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE).headers(this::acceptJson).build();
	}
	private void acceptJson(HttpHeaders headers) {
		headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
	}
	private Mono<ServerResponse> onlyAllowPost(ServerRequest request) {
		return ServerResponse.status(HttpStatus.METHOD_NOT_ALLOWED).headers(this::onlyAllowPost).build();
	}
	private void onlyAllowPost(HttpHeaders headers) {
		headers.setAllow(Collections.singleton(HttpMethod.POST));
	}
	@Configuration(proxyBeanMethods = false)
	public static class GraphQlEndpointCorsConfiguration implements WebFluxConfigurer {
		final GraphQlProperties graphQlProperties;
		final GraphQlCorsProperties corsProperties;
		public GraphQlEndpointCorsConfiguration(GraphQlProperties graphQlProps, GraphQlCorsProperties corsProps) {
			this.graphQlProperties = graphQlProps;
			this.corsProperties = corsProps;
		}
		@Override
		public void addCorsMappings(CorsRegistry registry) {
			CorsConfiguration configuration = this.corsProperties.toCorsConfiguration();
			if (configuration != null) {
				registry.addMapping(this.graphQlProperties.getPath()).combine(configuration);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.graphql.websocket', name = 'path')
	public static class WebSocketConfiguration {
		@Bean
		@ConditionalOnMissingBean
		public GraphQlWebSocketHandler graphQlWebSocketHandler(WebGraphQlHandler webGraphQlHandler,
				GraphQlProperties properties, ServerCodecConfigurer configurer) {
			return new GraphQlWebSocketHandler(webGraphQlHandler, configurer,
					properties.getWebsocket().getConnectionInitTimeout(), properties.getWebsocket().getKeepAlive());
		}
		@Bean
		public HandlerMapping graphQlWebSocketEndpoint(GraphQlWebSocketHandler graphQlWebSocketHandler,
				GraphQlProperties properties) {
			String path = properties.getWebsocket().getPath();
			logger.info(LogMessage.format('GraphQL endpoint WebSocket %s', path));
			SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();
			mapping.setHandlerPredicate(new WebSocketUpgradeHandlerPredicate());
			mapping.setUrlMap(Collections.singletonMap(path, graphQlWebSocketHandler));
			mapping.setOrder(-2); // Ahead of HTTP endpoint ('routerFunctionMapping' bean)
			return mapping;
		}
	}
	static class GraphiQlResourceHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('graphiql/index.html');
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.graphql.reactive;
/*
package org.springframework.boot.autoconfigure.jackson;
/**
@AutoConfiguration
@ConditionalOnClass(ObjectMapper.class)
public class JacksonAutoConfiguration {
	private static final Map<?, Boolean> FEATURE_DEFAULTS;
	static {
		Map<Object, Boolean> featureDefaults = new HashMap<>();
		featureDefaults.put(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
		featureDefaults.put(SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS, false);
		FEATURE_DEFAULTS = Collections.unmodifiableMap(featureDefaults);
	}
	@Bean
	public JsonComponentModule jsonComponentModule() {
		return new JsonComponentModule();
	}
	@Configuration(proxyBeanMethods = false)
	static class JacksonMixinConfiguration {
		@Bean
		static JsonMixinModuleEntries jsonMixinModuleEntries(ApplicationContext context) {
			List<String> packages = AutoConfigurationPackages.has(context) ? AutoConfigurationPackages.get(context)
					: Collections.emptyList();
			return JsonMixinModuleEntries.scan(context, packages);
		}
		@Bean
		JsonMixinModule jsonMixinModule(ApplicationContext context, JsonMixinModuleEntries entries) {
			JsonMixinModule jsonMixinModule = new JsonMixinModule();
			jsonMixinModule.registerEntries(entries, context.getClassLoader());
			return jsonMixinModule;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)
	static class JacksonObjectMapperConfiguration {
		@Bean
		@Primary
		@ConditionalOnMissingBean
		ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
			return builder.createXmlMapper(false).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ParameterNamesModule.class)
	static class ParameterNamesModuleConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ParameterNamesModule parameterNamesModule() {
			return new ParameterNamesModule(JsonCreator.Mode.DEFAULT);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)
	static class JacksonObjectMapperBuilderConfiguration {
		@Bean
		@Scope('prototype')
		@ConditionalOnMissingBean
		Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder(ApplicationContext applicationContext,
				List<Jackson2ObjectMapperBuilderCustomizer> customizers) {
			Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder();
			builder.applicationContext(applicationContext);
			customize(builder, customizers);
			return builder;
		}
		private void customize(Jackson2ObjectMapperBuilder builder,
				List<Jackson2ObjectMapperBuilderCustomizer> customizers) {
			for (Jackson2ObjectMapperBuilderCustomizer customizer : customizers) {
				customizer.customize(builder);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)
	@EnableConfigurationProperties(JacksonProperties.class)
	static class Jackson2ObjectMapperBuilderCustomizerConfiguration {
		@Bean
		StandardJackson2ObjectMapperBuilderCustomizer standardJacksonObjectMapperBuilderCustomizer(
				JacksonProperties jacksonProperties, ObjectProvider<Module> modules) {
			return new StandardJackson2ObjectMapperBuilderCustomizer(jacksonProperties, modules.stream().toList());
		}
		static final class StandardJackson2ObjectMapperBuilderCustomizer
				implements Jackson2ObjectMapperBuilderCustomizer, Ordered {
			private final JacksonProperties jacksonProperties;
			private final Collection<Module> modules;
			StandardJackson2ObjectMapperBuilderCustomizer(JacksonProperties jacksonProperties,
					Collection<Module> modules) {
				this.jacksonProperties = jacksonProperties;
				this.modules = modules;
			}
			@Override
			public int getOrder() {
				return 0;
			}
			@Override
			public void customize(Jackson2ObjectMapperBuilder builder) {
				if (this.jacksonProperties.getDefaultPropertyInclusion() != null) {
					builder.serializationInclusion(this.jacksonProperties.getDefaultPropertyInclusion());
				}
				if (this.jacksonProperties.getTimeZone() != null) {
					builder.timeZone(this.jacksonProperties.getTimeZone());
				}
				configureFeatures(builder, FEATURE_DEFAULTS);
				configureVisibility(builder, this.jacksonProperties.getVisibility());
				configureFeatures(builder, this.jacksonProperties.getDeserialization());
				configureFeatures(builder, this.jacksonProperties.getSerialization());
				configureFeatures(builder, this.jacksonProperties.getMapper());
				configureFeatures(builder, this.jacksonProperties.getParser());
				configureFeatures(builder, this.jacksonProperties.getGenerator());
				configureFeatures(builder, this.jacksonProperties.getDatatype().getEnum());
				configureFeatures(builder, this.jacksonProperties.getDatatype().getJsonNode());
				configureDateFormat(builder);
				configurePropertyNamingStrategy(builder);
				configureModules(builder);
				configureLocale(builder);
				configureDefaultLeniency(builder);
				configureConstructorDetector(builder);
			}
			private void configureFeatures(Jackson2ObjectMapperBuilder builder, Map<?, Boolean> features) {
				features.forEach((feature, value) -> {
					if (value != null) {
						if (value) {
							builder.featuresToEnable(feature);
						}
						else {
							builder.featuresToDisable(feature);
						}
					}
				});
			}
			private void configureVisibility(Jackson2ObjectMapperBuilder builder,
					Map<PropertyAccessor, JsonAutoDetect.Visibility> visibilities) {
				visibilities.forEach(builder::visibility);
			}
			private void configureDateFormat(Jackson2ObjectMapperBuilder builder) {
				// We support a fully qualified class name extending DateFormat or a date
				// pattern string value
				String dateFormat = this.jacksonProperties.getDateFormat();
				if (dateFormat != null) {
					try {
						Class<?> dateFormatClass = ClassUtils.forName(dateFormat, null);
						builder.dateFormat((DateFormat) BeanUtils.instantiateClass(dateFormatClass));
					}
					catch (ClassNotFoundException ex) {
						SimpleDateFormat simpleDateFormat = new SimpleDateFormat(dateFormat);
						// Since Jackson 2.6.3 we always need to set a TimeZone (see
						// gh-4170). If none in our properties fallback to the Jackson"s
						// default
						TimeZone timeZone = this.jacksonProperties.getTimeZone();
						if (timeZone == null) {
							timeZone = new ObjectMapper().getSerializationConfig().getTimeZone();
						}
						simpleDateFormat.setTimeZone(timeZone);
						builder.dateFormat(simpleDateFormat);
					}
				}
			}
			private void configurePropertyNamingStrategy(Jackson2ObjectMapperBuilder builder) {
				// We support a fully qualified class name extending Jackson"s
				// PropertyNamingStrategy or a string value corresponding to the constant
				// names in PropertyNamingStrategy which hold default provided
				// implementations
				String strategy = this.jacksonProperties.getPropertyNamingStrategy();
				if (strategy != null) {
					try {
						configurePropertyNamingStrategyClass(builder, ClassUtils.forName(strategy, null));
					}
					catch (ClassNotFoundException ex) {
						configurePropertyNamingStrategyField(builder, strategy);
					}
				}
			}
			private void configurePropertyNamingStrategyClass(Jackson2ObjectMapperBuilder builder,
					Class<?> propertyNamingStrategyClass) {
				builder.propertyNamingStrategy(
						(PropertyNamingStrategy) BeanUtils.instantiateClass(propertyNamingStrategyClass));
			}
			private void configurePropertyNamingStrategyField(Jackson2ObjectMapperBuilder builder, String fieldName) {
				// Find the field (this way we automatically support new constants
				// that may be added by Jackson in the future)
				Field field = findPropertyNamingStrategyField(fieldName);
				Assert.notNull(field, () -> 'Constant named "' + fieldName + '" not found');
				try {
					builder.propertyNamingStrategy((PropertyNamingStrategy) field.get(null));
				}
				catch (Exception ex) {
					throw new IllegalStateException(ex);
				}
			}
			private Field findPropertyNamingStrategyField(String fieldName) {
				return ReflectionUtils.findField(com.fasterxml.jackson.databind.PropertyNamingStrategies.class,
						fieldName, PropertyNamingStrategy.class);
			}
			private void configureModules(Jackson2ObjectMapperBuilder builder) {
				builder.modulesToInstall(this.modules.toArray(new Module[0]));
			}
			private void configureLocale(Jackson2ObjectMapperBuilder builder) {
				Locale locale = this.jacksonProperties.getLocale();
				if (locale != null) {
					builder.locale(locale);
				}
			}
			private void configureDefaultLeniency(Jackson2ObjectMapperBuilder builder) {
				Boolean defaultLeniency = this.jacksonProperties.getDefaultLeniency();
				if (defaultLeniency != null) {
					builder.postConfigurer((objectMapper) -> objectMapper.setDefaultLeniency(defaultLeniency));
				}
			}
			private void configureConstructorDetector(Jackson2ObjectMapperBuilder builder) {
				ConstructorDetectorStrategy strategy = this.jacksonProperties.getConstructorDetector();
				if (strategy != null) {
					builder.postConfigurer((objectMapper) -> {
						switch (strategy) {
							case USE_PROPERTIES_BASED ->
								objectMapper.setConstructorDetector(ConstructorDetector.USE_PROPERTIES_BASED);
							case USE_DELEGATING ->
								objectMapper.setConstructorDetector(ConstructorDetector.USE_DELEGATING);
							case EXPLICIT_ONLY ->
								objectMapper.setConstructorDetector(ConstructorDetector.EXPLICIT_ONLY);
							default -> objectMapper.setConstructorDetector(ConstructorDetector.DEFAULT);
						}
					});
				}
			}
		}
	}
	static class JacksonAutoConfigurationRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			if (ClassUtils.isPresent('com.fasterxml.jackson.databind.PropertyNamingStrategy', classLoader)) {
				registerPropertyNamingStrategyHints(hints.reflection());
			}
		}
		/**
		 * Register hints for the {@code configurePropertyNamingStrategyField} method to
		 * use.
		 * @param hints reflection hints
		 */
		private void registerPropertyNamingStrategyHints(ReflectionHints hints) {
			registerPropertyNamingStrategyHints(hints, PropertyNamingStrategies.class);
		}
		private void registerPropertyNamingStrategyHints(ReflectionHints hints, Class<?> type) {
			Stream.of(type.getDeclaredFields())
				.filter(this::isPropertyNamingStrategyField)
				.forEach(hints::registerField);
		}
		private boolean isPropertyNamingStrategyField(Field candidate) {
			return ReflectionUtils.isPublicStaticFinal(candidate)
					&& candidate.getType().isAssignableFrom(PropertyNamingStrategy.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jackson;
/**
@FunctionalInterface
public interface Jackson2ObjectMapperBuilderCustomizer {
	/**
	 * Customize the JacksonObjectMapperBuilder.
	 * @param jacksonObjectMapperBuilder the JacksonObjectMapperBuilder to customize
	 */
	void customize(Jackson2ObjectMapperBuilder jacksonObjectMapperBuilder);
}
/*
package org.springframework.boot.autoconfigure.jackson;
/**
@ConfigurationProperties(prefix = 'spring.jackson')
public class JacksonProperties {
	/**
	 * Date format string or a fully-qualified date format class name. For instance,
	 * "yyyy-MM-dd HH:mm:ss".
	 */
	private String dateFormat;
	/**
	 * One of the constants on Jackson"s PropertyNamingStrategies. Can also be a
	 * fully-qualified class name of a PropertyNamingStrategy implementation.
	 */
	private String propertyNamingStrategy;
	/**
	 * Jackson visibility thresholds that can be used to limit which methods (and fields)
	 * are auto-detected.
	 */
	private final Map<PropertyAccessor, JsonAutoDetect.Visibility> visibility = new EnumMap<>(PropertyAccessor.class);
	/**
	 * Jackson on/off features that affect the way Java objects are serialized.
	 */
	private final Map<SerializationFeature, Boolean> serialization = new EnumMap<>(SerializationFeature.class);
	/**
	 * Jackson on/off features that affect the way Java objects are deserialized.
	 */
	private final Map<DeserializationFeature, Boolean> deserialization = new EnumMap<>(DeserializationFeature.class);
	/**
	 * Jackson general purpose on/off features.
	 */
	private final Map<MapperFeature, Boolean> mapper = new EnumMap<>(MapperFeature.class);
	/**
	 * Jackson on/off features for parsers.
	 */
	private final Map<JsonParser.Feature, Boolean> parser = new EnumMap<>(JsonParser.Feature.class);
	/**
	 * Jackson on/off features for generators.
	 */
	private final Map<JsonGenerator.Feature, Boolean> generator = new EnumMap<>(JsonGenerator.Feature.class);
	/**
	 * Controls the inclusion of properties during serialization. Configured with one of
	 * the values in Jackson"s JsonInclude.Include enumeration.
	 */
	private JsonInclude.Include defaultPropertyInclusion;
	/**
	 * Global default setting (if any) for leniency.
	 */
	private Boolean defaultLeniency;
	/**
	 * Strategy to use to auto-detect constructor, and in particular behavior with
	 * single-argument constructors.
	 */
	private ConstructorDetectorStrategy constructorDetector;
	/**
	 * Time zone used when formatting dates. For instance, 'America/Los_Angeles' or
	 * 'GMT+10'.
	 */
	private TimeZone timeZone = null;
	/**
	 * Locale used for formatting.
	 */
	private Locale locale;
	private final Datatype datatype = new Datatype();
	public String getDateFormat() {
		return this.dateFormat;
	}
	public void setDateFormat(String dateFormat) {
		this.dateFormat = dateFormat;
	}
	public String getPropertyNamingStrategy() {
		return this.propertyNamingStrategy;
	}
	public void setPropertyNamingStrategy(String propertyNamingStrategy) {
		this.propertyNamingStrategy = propertyNamingStrategy;
	}
	public Map<PropertyAccessor, JsonAutoDetect.Visibility> getVisibility() {
		return this.visibility;
	}
	public Map<SerializationFeature, Boolean> getSerialization() {
		return this.serialization;
	}
	public Map<DeserializationFeature, Boolean> getDeserialization() {
		return this.deserialization;
	}
	public Map<MapperFeature, Boolean> getMapper() {
		return this.mapper;
	}
	public Map<JsonParser.Feature, Boolean> getParser() {
		return this.parser;
	}
	public Map<JsonGenerator.Feature, Boolean> getGenerator() {
		return this.generator;
	}
	public JsonInclude.Include getDefaultPropertyInclusion() {
		return this.defaultPropertyInclusion;
	}
	public void setDefaultPropertyInclusion(JsonInclude.Include defaultPropertyInclusion) {
		this.defaultPropertyInclusion = defaultPropertyInclusion;
	}
	public Boolean getDefaultLeniency() {
		return this.defaultLeniency;
	}
	public void setDefaultLeniency(Boolean defaultLeniency) {
		this.defaultLeniency = defaultLeniency;
	}
	public ConstructorDetectorStrategy getConstructorDetector() {
		return this.constructorDetector;
	}
	public void setConstructorDetector(ConstructorDetectorStrategy constructorDetector) {
		this.constructorDetector = constructorDetector;
	}
	public TimeZone getTimeZone() {
		return this.timeZone;
	}
	public void setTimeZone(TimeZone timeZone) {
		this.timeZone = timeZone;
	}
	public Locale getLocale() {
		return this.locale;
	}
	public void setLocale(Locale locale) {
		this.locale = locale;
	}
	public Datatype getDatatype() {
		return this.datatype;
	}
	public enum ConstructorDetectorStrategy {
		/**
		 * Use heuristics to see if 'properties' mode is to be used.
		 */
		DEFAULT,
		/**
		 * Assume 'properties' mode if not explicitly annotated otherwise.
		 */
		USE_PROPERTIES_BASED,
		/**
		 * Assume 'delegating' mode if not explicitly annotated otherwise.
		 */
		USE_DELEGATING,
		/**
		 * Refuse to decide implicit mode and instead throw an InvalidDefinitionException
		 * for ambiguous cases.
		 */
		EXPLICIT_ONLY
	}
	public static class Datatype {
		/**
		 * Jackson on/off features for enums.
		 */
		private final Map<EnumFeature, Boolean> enumFeatures = new EnumMap<>(EnumFeature.class);
		/**
		 * Jackson on/off features for JsonNodes.
		 */
		private final Map<JsonNodeFeature, Boolean> jsonNode = new EnumMap<>(JsonNodeFeature.class);
		public Map<EnumFeature, Boolean> getEnum() {
			return this.enumFeatures;
		}
		public Map<JsonNodeFeature, Boolean> getJsonNode() {
			return this.jsonNode;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jackson;
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@FunctionalInterface
public interface HibernatePropertiesCustomizer {
	/**
	 * Customize the specified JPA vendor properties.
	 * @param hibernateProperties the JPA vendor properties to customize
	 */
	void customize(Map<String, Object> hibernateProperties);
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@AutoConfiguration(
		after = { DataSourceAutoConfiguration.class, TransactionManagerCustomizationAutoConfiguration.class },
		before = { TransactionAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class })
@ConditionalOnClass({ LocalContainerEntityManagerFactoryBean.class, EntityManager.class, SessionImplementor.class })
@EnableConfigurationProperties(JpaProperties.class)
@Import(HibernateJpaConfiguration.class)
public class HibernateJpaAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@ConfigurationProperties('spring.jpa.hibernate')
public class HibernateProperties {
	private static final String DISABLED_SCANNER_CLASS = 'org.hibernate.boot.archive.scan.internal.DisabledScanner';
	private final Naming naming = new Naming();
	/**
	 * DDL mode. This is actually a shortcut for the 'hibernate.hbm2ddl.auto' property.
	 * Defaults to 'create-drop' when using an embedded database and no schema manager was
	 * detected. Otherwise, defaults to 'none'.
	 */
	private String ddlAuto;
	public String getDdlAuto() {
		return this.ddlAuto;
	}
	public void setDdlAuto(String ddlAuto) {
		this.ddlAuto = ddlAuto;
	}
	public Naming getNaming() {
		return this.naming;
	}
	/**
	 * Determine the configuration properties for the initialization of the main Hibernate
	 * EntityManagerFactory based on standard JPA properties and
	 * {@link HibernateSettings}.
	 * @param jpaProperties standard JPA properties
	 * @param settings the settings to apply when determining the configuration properties
	 * @return the Hibernate properties to use
	 */
	public Map<String, Object> determineHibernateProperties(Map<String, String> jpaProperties,
			HibernateSettings settings) {
		Assert.notNull(jpaProperties, 'JpaProperties must not be null');
		Assert.notNull(settings, 'Settings must not be null');
		return getAdditionalProperties(jpaProperties, settings);
	}
	private Map<String, Object> getAdditionalProperties(Map<String, String> existing, HibernateSettings settings) {
		Map<String, Object> result = new HashMap<>(existing);
		applyScanner(result);
		getNaming().applyNamingStrategies(result);
		String ddlAuto = determineDdlAuto(existing, settings::getDdlAuto);
		if (StringUtils.hasText(ddlAuto) && !'none'.equals(ddlAuto)) {
			result.put(AvailableSettings.HBM2DDL_AUTO, ddlAuto);
		}
		else {
			result.remove(AvailableSettings.HBM2DDL_AUTO);
		}
		Collection<HibernatePropertiesCustomizer> customizers = settings.getHibernatePropertiesCustomizers();
		if (!ObjectUtils.isEmpty(customizers)) {
			customizers.forEach((customizer) -> customizer.customize(result));
		}
		return result;
	}
	private void applyScanner(Map<String, Object> result) {
		if (!result.containsKey(AvailableSettings.SCANNER) && ClassUtils.isPresent(DISABLED_SCANNER_CLASS, null)) {
			result.put(AvailableSettings.SCANNER, DISABLED_SCANNER_CLASS);
		}
	}
	private String determineDdlAuto(Map<String, String> existing, Supplier<String> defaultDdlAuto) {
		String ddlAuto = existing.get(AvailableSettings.HBM2DDL_AUTO);
		if (ddlAuto != null) {
			return ddlAuto;
		}
		if (this.ddlAuto != null) {
			return this.ddlAuto;
		}
		if (existing.get(AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION) != null) {
			return null;
		}
		return defaultDdlAuto.get();
	}
	public static class Naming {
		/**
		 * Fully qualified name of the implicit naming strategy.
		 */
		private String implicitStrategy;
		/**
		 * Fully qualified name of the physical naming strategy.
		 */
		private String physicalStrategy;
		public String getImplicitStrategy() {
			return this.implicitStrategy;
		}
		public void setImplicitStrategy(String implicitStrategy) {
			this.implicitStrategy = implicitStrategy;
		}
		public String getPhysicalStrategy() {
			return this.physicalStrategy;
		}
		public void setPhysicalStrategy(String physicalStrategy) {
			this.physicalStrategy = physicalStrategy;
		}
		private void applyNamingStrategies(Map<String, Object> properties) {
			applyNamingStrategy(properties, AvailableSettings.IMPLICIT_NAMING_STRATEGY, this.implicitStrategy,
					SpringImplicitNamingStrategy.class::getName);
			applyNamingStrategy(properties, AvailableSettings.PHYSICAL_NAMING_STRATEGY, this.physicalStrategy,
					CamelCaseToUnderscoresNamingStrategy.class::getName);
		}
		private void applyNamingStrategy(Map<String, Object> properties, String key, Object strategy,
				Supplier<String> defaultStrategy) {
			if (strategy != null) {
				properties.put(key, strategy);
			}
			else {
				properties.computeIfAbsent(key, (k) -> defaultStrategy.get());
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
public class EntityManagerFactoryDependsOnPostProcessor extends AbstractDependsOnBeanFactoryPostProcessor {
	/**
	 * Creates a new {@code EntityManagerFactoryDependsOnPostProcessor} that will set up
	 * dependencies upon beans with the given names.
	 * @param dependsOn names of the beans to depend upon
	 */
	public EntityManagerFactoryDependsOnPostProcessor(String... dependsOn) {
		super(EntityManagerFactory.class, AbstractEntityManagerFactoryBean.class, dependsOn);
	}
	/**
	 * Creates a new {@code EntityManagerFactoryDependsOnPostProcessor} that will set up
	 * dependencies upon beans with the given types.
	 * @param dependsOn types of the beans to depend upon
	 */
	public EntityManagerFactoryDependsOnPostProcessor(Class<?>... dependsOn) {
		super(EntityManagerFactory.class, AbstractEntityManagerFactoryBean.class, dependsOn);
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@ConfigurationProperties(prefix = 'spring.jpa')
public class JpaProperties {
	/**
	 * Additional native properties to set on the JPA provider.
	 */
	private Map<String, String> properties = new HashMap<>();
	/**
	 * Mapping resources (equivalent to 'mapping-file' entries in persistence.xml).
	 */
	private final List<String> mappingResources = new ArrayList<>();
	/**
	 * Name of the target database to operate on, auto-detected by default. Can be
	 * alternatively set using the 'Database' enum.
	 */
	private String databasePlatform;
	/**
	 * Target database to operate on, auto-detected by default. Can be alternatively set
	 * using the 'databasePlatform' property.
	 */
	private Database database;
	/**
	 * Whether to initialize the schema on startup.
	 */
	private boolean generateDdl = false;
	/**
	 * Whether to enable logging of SQL statements.
	 */
	private boolean showSql = false;
	/**
	 * Register OpenEntityManagerInViewInterceptor. Binds a JPA EntityManager to the
	 * thread for the entire processing of the request.
	 */
	private Boolean openInView;
	public Map<String, String> getProperties() {
		return this.properties;
	}
	public void setProperties(Map<String, String> properties) {
		this.properties = properties;
	}
	public List<String> getMappingResources() {
		return this.mappingResources;
	}
	public String getDatabasePlatform() {
		return this.databasePlatform;
	}
	public void setDatabasePlatform(String databasePlatform) {
		this.databasePlatform = databasePlatform;
	}
	public Database getDatabase() {
		return this.database;
	}
	public void setDatabase(Database database) {
		this.database = database;
	}
	public boolean isGenerateDdl() {
		return this.generateDdl;
	}
	public void setGenerateDdl(boolean generateDdl) {
		this.generateDdl = generateDdl;
	}
	public boolean isShowSql() {
		return this.showSql;
	}
	public void setShowSql(boolean showSql) {
		this.showSql = showSql;
	}
	public Boolean getOpenInView() {
		return this.openInView;
	}
	public void setOpenInView(Boolean openInView) {
		this.openInView = openInView;
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
class HibernateDefaultDdlAutoProvider implements SchemaManagementProvider {
	private final Iterable<SchemaManagementProvider> providers;
	HibernateDefaultDdlAutoProvider(Iterable<SchemaManagementProvider> providers) {
		this.providers = providers;
	}
	String getDefaultDdlAuto(DataSource dataSource) {
		if (!EmbeddedDatabaseConnection.isEmbedded(dataSource)) {
			return 'none';
		}
		SchemaManagement schemaManagement = getSchemaManagement(dataSource);
		if (SchemaManagement.MANAGED.equals(schemaManagement)) {
			return 'none';
		}
		return 'create-drop';
	}
	@Override
	public SchemaManagement getSchemaManagement(DataSource dataSource) {
		return StreamSupport.stream(this.providers.spliterator(), false)
			.map((provider) -> provider.getSchemaManagement(dataSource))
			.filter(SchemaManagement.MANAGED::equals)
			.findFirst()
			.orElse(SchemaManagement.UNMANAGED);
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(JpaProperties.class)
public abstract class JpaBaseConfiguration {
	private final DataSource dataSource;
	private final JpaProperties properties;
	private final JtaTransactionManager jtaTransactionManager;
	protected JpaBaseConfiguration(DataSource dataSource, JpaProperties properties,
			ObjectProvider<JtaTransactionManager> jtaTransactionManager) {
		this.dataSource = dataSource;
		this.properties = properties;
		this.jtaTransactionManager = jtaTransactionManager.getIfAvailable();
	}
	@Bean
	@ConditionalOnMissingBean(TransactionManager.class)
	public PlatformTransactionManager transactionManager(
			ObjectProvider<TransactionManagerCustomizers> transactionManagerCustomizers) {
		JpaTransactionManager transactionManager = new JpaTransactionManager();
		transactionManagerCustomizers.ifAvailable((customizers) -> customizers.customize(transactionManager));
		return transactionManager;
	}
	@Bean
	@ConditionalOnMissingBean
	public JpaVendorAdapter jpaVendorAdapter() {
		AbstractJpaVendorAdapter adapter = createJpaVendorAdapter();
		adapter.setShowSql(this.properties.isShowSql());
		if (this.properties.getDatabase() != null) {
			adapter.setDatabase(this.properties.getDatabase());
		}
		if (this.properties.getDatabasePlatform() != null) {
			adapter.setDatabasePlatform(this.properties.getDatabasePlatform());
		}
		adapter.setGenerateDdl(this.properties.isGenerateDdl());
		return adapter;
	}
	@Bean
	@ConditionalOnMissingBean
	public EntityManagerFactoryBuilder entityManagerFactoryBuilder(JpaVendorAdapter jpaVendorAdapter,
			ObjectProvider<PersistenceUnitManager> persistenceUnitManager,
			ObjectProvider<EntityManagerFactoryBuilderCustomizer> customizers) {
		EntityManagerFactoryBuilder builder = new EntityManagerFactoryBuilder(jpaVendorAdapter, buildJpaProperties(),
				persistenceUnitManager.getIfAvailable());
		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder;
	}
	private Map<String, ?> buildJpaProperties() {
		Map<String, Object> properties = new HashMap<>(this.properties.getProperties());
		Map<String, Object> vendorProperties = getVendorProperties();
		customizeVendorProperties(vendorProperties);
		properties.putAll(vendorProperties);
		return properties;
	}
	@Bean
	@Primary
	@ConditionalOnMissingBean({ LocalContainerEntityManagerFactoryBean.class, EntityManagerFactory.class })
	public LocalContainerEntityManagerFactoryBean entityManagerFactory(EntityManagerFactoryBuilder factoryBuilder,
			PersistenceManagedTypes persistenceManagedTypes) {
		return factoryBuilder.dataSource(this.dataSource)
			.managedTypes(persistenceManagedTypes)
			.mappingResources(getMappingResources())
			.jta(isJta())
			.build();
	}
	protected abstract AbstractJpaVendorAdapter createJpaVendorAdapter();
	protected abstract Map<String, Object> getVendorProperties();
	/**
	 * Customize vendor properties before they are used. Allows for post-processing (for
	 * example to configure JTA specific settings).
	 * @param vendorProperties the vendor properties to customize
	 */
	protected void customizeVendorProperties(Map<String, Object> vendorProperties) {
	}
	private String[] getMappingResources() {
		List<String> mappingResources = this.properties.getMappingResources();
		return (!ObjectUtils.isEmpty(mappingResources) ? StringUtils.toStringArray(mappingResources) : null);
	}
	/**
	 * Return the JTA transaction manager.
	 * @return the transaction manager or {@code null}
	 */
	protected JtaTransactionManager getJtaTransactionManager() {
		return this.jtaTransactionManager;
	}
	/**
	 * Returns if a JTA {@link PlatformTransactionManager} is being used.
	 * @return if a JTA transaction manager is being used
	 */
	protected final boolean isJta() {
		return (this.jtaTransactionManager != null);
	}
	/**
	 * Return the {@link JpaProperties}.
	 * @return the properties
	 */
	protected final JpaProperties getProperties() {
		return this.properties;
	}
	/**
	 * Return the {@link DataSource}.
	 * @return the data source
	 */
	protected final DataSource getDataSource() {
		return this.dataSource;
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean({ LocalContainerEntityManagerFactoryBean.class, EntityManagerFactory.class })
	static class PersistenceManagedTypesConfiguration {
		@Bean
		@Primary
		@ConditionalOnMissingBean
		static PersistenceManagedTypes persistenceManagedTypes(BeanFactory beanFactory, ResourceLoader resourceLoader,
				ObjectProvider<ManagedClassNameFilter> managedClassNameFilter) {
			String[] packagesToScan = getPackagesToScan(beanFactory);
			return new PersistenceManagedTypesScanner(resourceLoader, managedClassNameFilter.getIfAvailable())
				.scan(packagesToScan);
		}
		private static String[] getPackagesToScan(BeanFactory beanFactory) {
			List<String> packages = EntityScanPackages.get(beanFactory).getPackageNames();
			if (packages.isEmpty() && AutoConfigurationPackages.has(beanFactory)) {
				packages = AutoConfigurationPackages.get(beanFactory);
			}
			return StringUtils.toStringArray(packages);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	@ConditionalOnClass(WebMvcConfigurer.class)
	@ConditionalOnMissingBean({ OpenEntityManagerInViewInterceptor.class, OpenEntityManagerInViewFilter.class })
	@ConditionalOnMissingFilterBean(OpenEntityManagerInViewFilter.class)
	@ConditionalOnProperty(prefix = 'spring.jpa', name = 'open-in-view', havingValue = 'true', matchIfMissing = true)
	protected static class JpaWebConfiguration {
		private static final Log logger = LogFactory.getLog(JpaWebConfiguration.class);
		private final JpaProperties jpaProperties;
		protected JpaWebConfiguration(JpaProperties jpaProperties) {
			this.jpaProperties = jpaProperties;
		}
		@Bean
		public OpenEntityManagerInViewInterceptor openEntityManagerInViewInterceptor() {
			if (this.jpaProperties.getOpenInView() == null) {
				logger.warn('spring.jpa.open-in-view is enabled by default. '
						+ 'Therefore, database queries may be performed during view '
						+ 'rendering. Explicitly configure spring.jpa.open-in-view to disable this warning');
			}
			return new OpenEntityManagerInViewInterceptor();
		}
		@Bean
		public WebMvcConfigurer openEntityManagerInViewInterceptorConfigurer(
				OpenEntityManagerInViewInterceptor interceptor) {
			return new WebMvcConfigurer() {
				@Override
				public void addInterceptors(InterceptorRegistry registry) {
					registry.addWebRequestInterceptor(interceptor);
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@FunctionalInterface
public interface EntityManagerFactoryBuilderCustomizer {
	/**
	 * Customize the given {@code builder}.
	 * @param builder the builder to customize
	 */
	void customize(EntityManagerFactoryBuilder builder);
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(HibernateProperties.class)
@ConditionalOnSingleCandidate(DataSource.class)
@ImportRuntimeHints(HibernateRuntimeHints.class)
class HibernateJpaConfiguration extends JpaBaseConfiguration {
	private static final Log logger = LogFactory.getLog(HibernateJpaConfiguration.class);
	private static final String JTA_PLATFORM = 'hibernate.transaction.jta.platform';
	private static final String PROVIDER_DISABLES_AUTOCOMMIT = 'hibernate.connection.provider_disables_autocommit';
	/**
	 * {@code NoJtaPlatform} implementations for various Hibernate versions.
	 */
	private static final String[] NO_JTA_PLATFORM_CLASSES = {
			'org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform',
			'org.hibernate.service.jta.platform.internal.NoJtaPlatform' };
	private final HibernateProperties hibernateProperties;
	private final HibernateDefaultDdlAutoProvider defaultDdlAutoProvider;
	private final DataSourcePoolMetadataProvider poolMetadataProvider;
	private final List<HibernatePropertiesCustomizer> hibernatePropertiesCustomizers;
	HibernateJpaConfiguration(DataSource dataSource, JpaProperties jpaProperties,
			ConfigurableListableBeanFactory beanFactory, ObjectProvider<JtaTransactionManager> jtaTransactionManager,
			HibernateProperties hibernateProperties,
			ObjectProvider<Collection<DataSourcePoolMetadataProvider>> metadataProviders,
			ObjectProvider<SchemaManagementProvider> providers,
			ObjectProvider<PhysicalNamingStrategy> physicalNamingStrategy,
			ObjectProvider<ImplicitNamingStrategy> implicitNamingStrategy,
			ObjectProvider<HibernatePropertiesCustomizer> hibernatePropertiesCustomizers) {
		super(dataSource, jpaProperties, jtaTransactionManager);
		this.hibernateProperties = hibernateProperties;
		this.defaultDdlAutoProvider = new HibernateDefaultDdlAutoProvider(providers);
		this.poolMetadataProvider = new CompositeDataSourcePoolMetadataProvider(metadataProviders.getIfAvailable());
		this.hibernatePropertiesCustomizers = determineHibernatePropertiesCustomizers(
				physicalNamingStrategy.getIfAvailable(), implicitNamingStrategy.getIfAvailable(), beanFactory,
				hibernatePropertiesCustomizers.orderedStream().toList());
	}
	private List<HibernatePropertiesCustomizer> determineHibernatePropertiesCustomizers(
			PhysicalNamingStrategy physicalNamingStrategy, ImplicitNamingStrategy implicitNamingStrategy,
			ConfigurableListableBeanFactory beanFactory,
			List<HibernatePropertiesCustomizer> hibernatePropertiesCustomizers) {
		List<HibernatePropertiesCustomizer> customizers = new ArrayList<>();
		if (ClassUtils.isPresent('org.hibernate.resource.beans.container.spi.BeanContainer',
				getClass().getClassLoader())) {
			customizers.add((properties) -> properties.put(AvailableSettings.BEAN_CONTAINER,
					new SpringBeanContainer(beanFactory)));
		}
		if (physicalNamingStrategy != null || implicitNamingStrategy != null) {
			customizers
				.add(new NamingStrategiesHibernatePropertiesCustomizer(physicalNamingStrategy, implicitNamingStrategy));
		}
		customizers.addAll(hibernatePropertiesCustomizers);
		return customizers;
	}
	@Override
	protected AbstractJpaVendorAdapter createJpaVendorAdapter() {
		return new HibernateJpaVendorAdapter();
	}
	@Override
	protected Map<String, Object> getVendorProperties() {
		Supplier<String> defaultDdlMode = () -> this.defaultDdlAutoProvider.getDefaultDdlAuto(getDataSource());
		return new LinkedHashMap<>(this.hibernateProperties.determineHibernateProperties(
				getProperties().getProperties(), new HibernateSettings().ddlAuto(defaultDdlMode)
					.hibernatePropertiesCustomizers(this.hibernatePropertiesCustomizers)));
	}
	@Override
	protected void customizeVendorProperties(Map<String, Object> vendorProperties) {
		super.customizeVendorProperties(vendorProperties);
		if (!vendorProperties.containsKey(JTA_PLATFORM)) {
			configureJtaPlatform(vendorProperties);
		}
		if (!vendorProperties.containsKey(PROVIDER_DISABLES_AUTOCOMMIT)) {
			configureProviderDisablesAutocommit(vendorProperties);
		}
	}
	private void configureJtaPlatform(Map<String, Object> vendorProperties) throws LinkageError {
		JtaTransactionManager jtaTransactionManager = getJtaTransactionManager();
		// Make sure Hibernate doesn"t attempt to auto-detect a JTA platform
		if (jtaTransactionManager == null) {
			vendorProperties.put(JTA_PLATFORM, getNoJtaPlatformManager());
		}
		// As of Hibernate 5.2, Hibernate can fully integrate with the WebSphere
		// transaction manager on its own.
		else if (!runningOnWebSphere()) {
			configureSpringJtaPlatform(vendorProperties, jtaTransactionManager);
		}
	}
	private void configureProviderDisablesAutocommit(Map<String, Object> vendorProperties) {
		if (isDataSourceAutoCommitDisabled() && !isJta()) {
			vendorProperties.put(PROVIDER_DISABLES_AUTOCOMMIT, 'true');
		}
	}
	private boolean isDataSourceAutoCommitDisabled() {
		DataSourcePoolMetadata poolMetadata = this.poolMetadataProvider.getDataSourcePoolMetadata(getDataSource());
		return poolMetadata != null && Boolean.FALSE.equals(poolMetadata.getDefaultAutoCommit());
	}
	private boolean runningOnWebSphere() {
		return ClassUtils.isPresent('com.ibm.websphere.jtaextensions.ExtendedJTATransaction',
				getClass().getClassLoader());
	}
	private void configureSpringJtaPlatform(Map<String, Object> vendorProperties,
			JtaTransactionManager jtaTransactionManager) {
		try {
			vendorProperties.put(JTA_PLATFORM, new SpringJtaPlatform(jtaTransactionManager));
		}
		catch (LinkageError ex) {
			// NoClassDefFoundError can happen if Hibernate 4.2 is used and some
			// containers (e.g. JBoss EAP 6) wrap it in the superclass LinkageError
			if (!isUsingJndi()) {
				throw new IllegalStateException(
						'Unable to set Hibernate JTA platform, are you using the correct version of Hibernate?', ex);
			}
			// Assume that Hibernate will use JNDI
			if (logger.isDebugEnabled()) {
				logger.debug('Unable to set Hibernate JTA platform : ' + ex.getMessage());
			}
		}
	}
	private boolean isUsingJndi() {
		try {
			return JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable();
		}
		catch (Error ex) {
			return false;
		}
	}
	private Object getNoJtaPlatformManager() {
		for (String candidate : NO_JTA_PLATFORM_CLASSES) {
			try {
				return Class.forName(candidate).getDeclaredConstructor().newInstance();
			}
			catch (Exception ex) {
				// Continue searching
			}
		}
		throw new IllegalStateException(
				'No available JtaPlatform candidates amongst ' + Arrays.toString(NO_JTA_PLATFORM_CLASSES));
	}
	private static class NamingStrategiesHibernatePropertiesCustomizer implements HibernatePropertiesCustomizer {
		private final PhysicalNamingStrategy physicalNamingStrategy;
		private final ImplicitNamingStrategy implicitNamingStrategy;
		NamingStrategiesHibernatePropertiesCustomizer(PhysicalNamingStrategy physicalNamingStrategy,
				ImplicitNamingStrategy implicitNamingStrategy) {
			this.physicalNamingStrategy = physicalNamingStrategy;
			this.implicitNamingStrategy = implicitNamingStrategy;
		}
		@Override
		public void customize(Map<String, Object> hibernateProperties) {
			if (this.physicalNamingStrategy != null) {
				hibernateProperties.put('hibernate.physical_naming_strategy', this.physicalNamingStrategy);
			}
			if (this.implicitNamingStrategy != null) {
				hibernateProperties.put('hibernate.implicit_naming_strategy', this.implicitNamingStrategy);
			}
		}
	}
	static class HibernateRuntimeHints implements RuntimeHintsRegistrar {
		private static final Consumer<Builder> INVOKE_DECLARED_CONSTRUCTORS = TypeHint
			.builtWith(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			for (String noJtaPlatformClass : NO_JTA_PLATFORM_CLASSES) {
				hints.reflection().registerType(TypeReference.of(noJtaPlatformClass), INVOKE_DECLARED_CONSTRUCTORS);
			}
			hints.reflection().registerType(SpringImplicitNamingStrategy.class, INVOKE_DECLARED_CONSTRUCTORS);
			hints.reflection().registerType(CamelCaseToUnderscoresNamingStrategy.class, INVOKE_DECLARED_CONSTRUCTORS);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
public class HibernateSettings {
	private Supplier<String> ddlAuto;
	private Collection<HibernatePropertiesCustomizer> hibernatePropertiesCustomizers;
	public HibernateSettings ddlAuto(Supplier<String> ddlAuto) {
		this.ddlAuto = ddlAuto;
		return this;
	}
	public String getDdlAuto() {
		return (this.ddlAuto != null) ? this.ddlAuto.get() : null;
	}
	public HibernateSettings hibernatePropertiesCustomizers(
			Collection<HibernatePropertiesCustomizer> hibernatePropertiesCustomizers) {
		this.hibernatePropertiesCustomizers = new ArrayList<>(hibernatePropertiesCustomizers);
		return this;
	}
	public Collection<HibernatePropertiesCustomizer> getHibernatePropertiesCustomizers() {
		return this.hibernatePropertiesCustomizers;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.orm.jpa;
/*
package org.springframework.boot.autoconfigure.http;
/**
public class HttpMessageConverters implements Iterable<HttpMessageConverter<?>> {
	private static final List<Class<?>> NON_REPLACING_CONVERTERS;
	static {
		List<Class<?>> nonReplacingConverters = new ArrayList<>();
		addClassIfExists(nonReplacingConverters,
				'org.springframework.hateoas.server.mvc.TypeConstrainedMappingJackson2HttpMessageConverter');
		NON_REPLACING_CONVERTERS = Collections.unmodifiableList(nonReplacingConverters);
	}
	private static final Map<Class<?>, Class<?>> EQUIVALENT_CONVERTERS;
	static {
		Map<Class<?>, Class<?>> equivalentConverters = new HashMap<>();
		putIfExists(equivalentConverters, 'org.springframework.http.converter.json.MappingJackson2HttpMessageConverter',
				'org.springframework.http.converter.json.GsonHttpMessageConverter');
		EQUIVALENT_CONVERTERS = Collections.unmodifiableMap(equivalentConverters);
	}
	private final List<HttpMessageConverter<?>> converters;
	/**
	 * Create a new {@link HttpMessageConverters} instance with the specified additional
	 * converters.
	 * @param additionalConverters additional converters to be added. Items are added just
	 * before any default converter of the same type (or at the front of the list if no
	 * default converter is found). The {@link #postProcessConverters(List)} method can be
	 * used for further converter manipulation.
	 */
	public HttpMessageConverters(HttpMessageConverter<?>... additionalConverters) {
		this(Arrays.asList(additionalConverters));
	}
	/**
	 * Create a new {@link HttpMessageConverters} instance with the specified additional
	 * converters.
	 * @param additionalConverters additional converters to be added. Items are added just
	 * before any default converter of the same type (or at the front of the list if no
	 * default converter is found). The {@link #postProcessConverters(List)} method can be
	 * used for further converter manipulation.
	 */
	public HttpMessageConverters(Collection<HttpMessageConverter<?>> additionalConverters) {
		this(true, additionalConverters);
	}
	/**
	 * Create a new {@link HttpMessageConverters} instance with the specified converters.
	 * @param addDefaultConverters if default converters should be added
	 * @param converters converters to be added. Items are added just before any default
	 * converter of the same type (or at the front of the list if no default converter is
	 * found). The {@link #postProcessConverters(List)} method can be used for further
	 * converter manipulation.
	 */
	public HttpMessageConverters(boolean addDefaultConverters, Collection<HttpMessageConverter<?>> converters) {
		List<HttpMessageConverter<?>> combined = getCombinedConverters(converters,
				addDefaultConverters ? getDefaultConverters() : Collections.emptyList());
		combined = postProcessConverters(combined);
		this.converters = Collections.unmodifiableList(combined);
	}
	private List<HttpMessageConverter<?>> getCombinedConverters(Collection<HttpMessageConverter<?>> converters,
			List<HttpMessageConverter<?>> defaultConverters) {
		List<HttpMessageConverter<?>> combined = new ArrayList<>();
		List<HttpMessageConverter<?>> processing = new ArrayList<>(converters);
		for (HttpMessageConverter<?> defaultConverter : defaultConverters) {
			Iterator<HttpMessageConverter<?>> iterator = processing.iterator();
			while (iterator.hasNext()) {
				HttpMessageConverter<?> candidate = iterator.next();
				if (isReplacement(defaultConverter, candidate)) {
					combined.add(candidate);
					iterator.remove();
				}
			}
			combined.add(defaultConverter);
			if (defaultConverter instanceof AllEncompassingFormHttpMessageConverter allEncompassingConverter) {
				configurePartConverters(allEncompassingConverter, converters);
			}
		}
		combined.addAll(0, processing);
		return combined;
	}
	private boolean isReplacement(HttpMessageConverter<?> defaultConverter, HttpMessageConverter<?> candidate) {
		for (Class<?> nonReplacingConverter : NON_REPLACING_CONVERTERS) {
			if (nonReplacingConverter.isInstance(candidate)) {
				return false;
			}
		}
		Class<?> converterClass = defaultConverter.getClass();
		if (ClassUtils.isAssignableValue(converterClass, candidate)) {
			return true;
		}
		Class<?> equivalentClass = EQUIVALENT_CONVERTERS.get(converterClass);
		return equivalentClass != null && ClassUtils.isAssignableValue(equivalentClass, candidate);
	}
	private void configurePartConverters(AllEncompassingFormHttpMessageConverter formConverter,
			Collection<HttpMessageConverter<?>> converters) {
		List<HttpMessageConverter<?>> partConverters = formConverter.getPartConverters();
		List<HttpMessageConverter<?>> combinedConverters = getCombinedConverters(converters, partConverters);
		combinedConverters = postProcessPartConverters(combinedConverters);
		formConverter.setPartConverters(combinedConverters);
	}
	/**
	 * Method that can be used to post-process the {@link HttpMessageConverter} list
	 * before it is used.
	 * @param converters a mutable list of the converters that will be used.
	 * @return the final converts list to use
	 */
	protected List<HttpMessageConverter<?>> postProcessConverters(List<HttpMessageConverter<?>> converters) {
		return converters;
	}
	/**
	 * Method that can be used to post-process the {@link HttpMessageConverter} list
	 * before it is used to configure the part converters of
	 * {@link AllEncompassingFormHttpMessageConverter}.
	 * @param converters a mutable list of the converters that will be used.
	 * @return the final converts list to use
	 * @since 1.3.0
	 */
	protected List<HttpMessageConverter<?>> postProcessPartConverters(List<HttpMessageConverter<?>> converters) {
		return converters;
	}
	private List<HttpMessageConverter<?>> getDefaultConverters() {
		List<HttpMessageConverter<?>> converters = new ArrayList<>();
		if (ClassUtils.isPresent('org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport',
				null)) {
			converters.addAll(new WebMvcConfigurationSupport() {
				public List<HttpMessageConverter<?>> defaultMessageConverters() {
					return super.getMessageConverters();
				}
			}.defaultMessageConverters());
		}
		else {
			converters.addAll(new RestTemplate().getMessageConverters());
		}
		reorderXmlConvertersToEnd(converters);
		return converters;
	}
	private void reorderXmlConvertersToEnd(List<HttpMessageConverter<?>> converters) {
		List<HttpMessageConverter<?>> xml = new ArrayList<>();
		for (Iterator<HttpMessageConverter<?>> iterator = converters.iterator(); iterator.hasNext();) {
			HttpMessageConverter<?> converter = iterator.next();
			if ((converter instanceof AbstractXmlHttpMessageConverter)
					|| (converter instanceof MappingJackson2XmlHttpMessageConverter)) {
				xml.add(converter);
				iterator.remove();
			}
		}
		converters.addAll(xml);
	}
	@Override
	public Iterator<HttpMessageConverter<?>> iterator() {
		return getConverters().iterator();
	}
	/**
	 * Return an immutable list of the converters in the order that they will be
	 * registered.
	 * @return the converters
	 */
	public List<HttpMessageConverter<?>> getConverters() {
		return this.converters;
	}
	private static void addClassIfExists(List<Class<?>> list, String className) {
		try {
			list.add(Class.forName(className));
		}
		catch (ClassNotFoundException | NoClassDefFoundError ex) {
			// Ignore
		}
	}
	private static void putIfExists(Map<Class<?>, Class<?>> map, String keyClassName, String valueClassName) {
		try {
			map.put(Class.forName(keyClassName), Class.forName(valueClassName));
		}
		catch (ClassNotFoundException | NoClassDefFoundError ex) {
			// Ignore
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http.codec;
/**
@AutoConfiguration(after = JacksonAutoConfiguration.class)
@ConditionalOnClass({ CodecConfigurer.class, WebClient.class })
@EnableConfigurationProperties(CodecProperties.class)
public class CodecsAutoConfiguration {
	private static final MimeType[] EMPTY_MIME_TYPES = {};
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ObjectMapper.class)
	static class JacksonCodecConfiguration {
		@Bean
		@Order(0)
		@ConditionalOnBean(ObjectMapper.class)
		CodecCustomizer jacksonCodecCustomizer(ObjectMapper objectMapper) {
			return (configurer) -> {
				CodecConfigurer.DefaultCodecs defaults = configurer.defaultCodecs();
				defaults.jackson2JsonDecoder(new Jackson2JsonDecoder(objectMapper, EMPTY_MIME_TYPES));
				defaults.jackson2JsonEncoder(new Jackson2JsonEncoder(objectMapper, EMPTY_MIME_TYPES));
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DefaultCodecsConfiguration {
		@Bean
		@Order(0)
		CodecCustomizer defaultCodecCustomizer(CodecProperties codecProperties) {
			return (configurer) -> {
				PropertyMapper map = PropertyMapper.get();
				CodecConfigurer.DefaultCodecs defaultCodecs = configurer.defaultCodecs();
				defaultCodecs.enableLoggingRequestDetails(codecProperties.isLogRequestDetails());
				map.from(codecProperties.getMaxInMemorySize())
					.whenNonNull()
					.asInt(DataSize::toBytes)
					.to(defaultCodecs::maxInMemorySize);
			};
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.http.codec;
/*
package org.springframework.boot.autoconfigure.http;
/**
@Configuration(proxyBeanMethods = false)
class JacksonHttpMessageConvertersConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ObjectMapper.class)
	@ConditionalOnBean(ObjectMapper.class)
	@ConditionalOnProperty(name = HttpMessageConvertersAutoConfiguration.PREFERRED_MAPPER_PROPERTY,
			havingValue = 'jackson', matchIfMissing = true)
	static class MappingJackson2HttpMessageConverterConfiguration {
		@Bean
		@ConditionalOnMissingBean(value = MappingJackson2HttpMessageConverter.class,
				ignoredType = {
						'org.springframework.hateoas.server.mvc.TypeConstrainedMappingJackson2HttpMessageConverter',
						'org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter' })
		MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) {
			return new MappingJackson2HttpMessageConverter(objectMapper);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(XmlMapper.class)
	@ConditionalOnBean(Jackson2ObjectMapperBuilder.class)
	protected static class MappingJackson2XmlHttpMessageConverterConfiguration {
		@Bean
		@ConditionalOnMissingBean
		public MappingJackson2XmlHttpMessageConverter mappingJackson2XmlHttpMessageConverter(
				Jackson2ObjectMapperBuilder builder) {
			return new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(Gson.class)
class GsonHttpMessageConvertersConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(Gson.class)
	@Conditional(PreferGsonOrJacksonAndJsonbUnavailableCondition.class)
	static class GsonHttpMessageConverterConfiguration {
		@Bean
		@ConditionalOnMissingBean
		GsonHttpMessageConverter gsonHttpMessageConverter(Gson gson) {
			GsonHttpMessageConverter converter = new GsonHttpMessageConverter();
			converter.setGson(gson);
			return converter;
		}
	}
	private static class PreferGsonOrJacksonAndJsonbUnavailableCondition extends AnyNestedCondition {
		PreferGsonOrJacksonAndJsonbUnavailableCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnProperty(name = HttpMessageConvertersAutoConfiguration.PREFERRED_MAPPER_PROPERTY,
				havingValue = 'gson')
		static class GsonPreferred {
		}
		@Conditional(JacksonAndJsonbUnavailableCondition.class)
		static class JacksonJsonbUnavailable {
		}
	}
	private static class JacksonAndJsonbUnavailableCondition extends NoneNestedConditions {
		JacksonAndJsonbUnavailableCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnBean(MappingJackson2HttpMessageConverter.class)
		static class JacksonAvailable {
		}
		@ConditionalOnProperty(name = HttpMessageConvertersAutoConfiguration.PREFERRED_MAPPER_PROPERTY,
				havingValue = 'jsonb')
		static class JsonbPreferred {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http.client;
/**
@ConfigurationProperties('spring.http.client')
public class HttpClientProperties {
	/**
	 * Default factory used for a client HTTP request.
	 */
	private Factory factory;
	/**
	 * Handling for HTTP redirects.
	 */
	private Redirects redirects = Redirects.FOLLOW_WHEN_POSSIBLE;
	/**
	 * Default connect timeout for a client HTTP request.
	 */
	private Duration connectTimeout;
	/**
	 * Default read timeout for a client HTTP request.
	 */
	private Duration readTimeout;
	/**
	 * Default SSL configuration for a client HTTP request.
	 */
	private final Ssl ssl = new Ssl();
	public Factory getFactory() {
		return this.factory;
	}
	public void setFactory(Factory factory) {
		this.factory = factory;
	}
	public Redirects getRedirects() {
		return this.redirects;
	}
	public void setRedirects(Redirects redirects) {
		this.redirects = redirects;
	}
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public Duration getReadTimeout() {
		return this.readTimeout;
	}
	public void setReadTimeout(Duration readTimeout) {
		this.readTimeout = readTimeout;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	/**
	 * Supported factory types.
	 */
	public enum Factory {
		/**
		 * Apache HttpComponents HttpClient.
		 */
		HTTP_COMPONENTS(ClientHttpRequestFactoryBuilder::httpComponents),
		/**
		 * Jetty"s HttpClient.
		 */
		JETTY(ClientHttpRequestFactoryBuilder::jetty),
		/**
		 * Reactor-Netty.
		 */
		REACTOR(ClientHttpRequestFactoryBuilder::reactor),
		/**
		 * Java"s HttpClient.
		 */
		JDK(ClientHttpRequestFactoryBuilder::jdk),
		/**
		 * Standard JDK facilities.
		 */
		SIMPLE(ClientHttpRequestFactoryBuilder::simple);
		private final Supplier<ClientHttpRequestFactoryBuilder<?>> builderSupplier;
		Factory(Supplier<ClientHttpRequestFactoryBuilder<?>> builderSupplier) {
			this.builderSupplier = builderSupplier;
		}
		ClientHttpRequestFactoryBuilder<?> builder() {
			return this.builderSupplier.get();
		}
	}
	/**
	 * SSL configuration.
	 */
	public static class Ssl {
		/**
		 * SSL bundle to use.
		 */
		private String bundle;
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http.client;
/**
class NotReactiveWebApplicationCondition extends NoneNestedConditions {
	NotReactiveWebApplicationCondition() {
		super(ConfigurationPhase.PARSE_CONFIGURATION);
	}
	@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
	private static final class ReactiveWebApplication {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.http.client;
/*
package org.springframework.boot.autoconfigure.http.client;
/**
@AutoConfiguration(after = SslAutoConfiguration.class)
@ConditionalOnClass(ClientHttpRequestFactory.class)
@Conditional(NotReactiveWebApplicationCondition.class)
@EnableConfigurationProperties(HttpClientProperties.class)
public class HttpClientAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	ClientHttpRequestFactoryBuilder<?> clientHttpRequestFactoryBuilder(HttpClientProperties httpClientProperties) {
		Factory factory = httpClientProperties.getFactory();
		return (factory != null) ? factory.builder() : ClientHttpRequestFactoryBuilder.detect();
	}
	@Bean
	@ConditionalOnMissingBean
	ClientHttpRequestFactorySettings clientHttpRequestFactorySettings(HttpClientProperties httpClientProperties,
			ObjectProvider<SslBundles> sslBundles) {
		SslBundle sslBundle = getSslBundle(httpClientProperties.getSsl(), sslBundles);
		return new ClientHttpRequestFactorySettings(httpClientProperties.getRedirects(),
				httpClientProperties.getConnectTimeout(), httpClientProperties.getReadTimeout(), sslBundle);
	}
	private SslBundle getSslBundle(HttpClientProperties.Ssl properties, ObjectProvider<SslBundles> sslBundles) {
		String name = properties.getBundle();
		return (StringUtils.hasLength(name)) ? sslBundles.getObject().getBundle(name) : null;
	}
}
/*
package org.springframework.boot.autoconfigure.http;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(Jsonb.class)
class JsonbHttpMessageConvertersConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(Jsonb.class)
	@Conditional(PreferJsonbOrMissingJacksonAndGsonCondition.class)
	static class JsonbHttpMessageConverterConfiguration {
		@Bean
		@ConditionalOnMissingBean
		JsonbHttpMessageConverter jsonbHttpMessageConverter(Jsonb jsonb) {
			JsonbHttpMessageConverter converter = new JsonbHttpMessageConverter();
			converter.setJsonb(jsonb);
			return converter;
		}
	}
	private static class PreferJsonbOrMissingJacksonAndGsonCondition extends AnyNestedCondition {
		PreferJsonbOrMissingJacksonAndGsonCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnProperty(name = HttpMessageConvertersAutoConfiguration.PREFERRED_MAPPER_PROPERTY,
				havingValue = 'jsonb')
		static class JsonbPreferred {
		}
		@ConditionalOnMissingBean({ MappingJackson2HttpMessageConverter.class, GsonHttpMessageConverter.class })
		static class JacksonAndGsonMissing {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http;
/**
@AutoConfiguration(
		after = { GsonAutoConfiguration.class, JacksonAutoConfiguration.class, JsonbAutoConfiguration.class })
@ConditionalOnClass(HttpMessageConverter.class)
@Conditional(NotReactiveWebApplicationCondition.class)
@Import({ JacksonHttpMessageConvertersConfiguration.class, GsonHttpMessageConvertersConfiguration.class,
		JsonbHttpMessageConvertersConfiguration.class })
@ImportRuntimeHints(HttpMessageConvertersAutoConfigurationRuntimeHints.class)
public class HttpMessageConvertersAutoConfiguration {
	static final String PREFERRED_MAPPER_PROPERTY = 'spring.mvc.converters.preferred-json-mapper';
	@Bean
	@ConditionalOnMissingBean
	public HttpMessageConverters messageConverters(ObjectProvider<HttpMessageConverter<?>> converters) {
		return new HttpMessageConverters(converters.orderedStream().toList());
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(StringHttpMessageConverter.class)
	protected static class StringHttpMessageConverterConfiguration {
		@Bean
		@ConditionalOnMissingBean
		public StringHttpMessageConverter stringHttpMessageConverter(Environment environment) {
			Encoding encoding = Binder.get(environment).bindOrCreate('server.servlet.encoding', Encoding.class);
			StringHttpMessageConverter converter = new StringHttpMessageConverter(encoding.getCharset());
			converter.setWriteAcceptCharset(false);
			return converter;
		}
	}
	static class NotReactiveWebApplicationCondition extends NoneNestedConditions {
		NotReactiveWebApplicationCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnWebApplication(type = Type.REACTIVE)
		private static final class ReactiveWebApplication {
		}
	}
	static class HttpMessageConvertersAutoConfigurationRuntimeHints extends BindableRuntimeHintsRegistrar {
		HttpMessageConvertersAutoConfigurationRuntimeHints() {
			super(Encoding.class);
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.http;
/*
package org.springframework.boot.autoconfigure;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(ImportAutoConfigurationImportSelector.class)
public @interface ImportAutoConfiguration {
	/**
	 * The auto-configuration classes that should be imported. This is an alias for
	 * {@link #classes()}.
	 * @return the classes to import
	 */
	@AliasFor('classes')
	Class<?>[] value() default {};
	/**
	 * The auto-configuration classes that should be imported. When empty, the classes are
	 * specified using a file in {@code META-INF/spring} where the file name is the
	 * fully-qualified name of the annotated class, suffixed with {@code .imports}. An
	 * entry in the file may be prefixed with {@code optional:} to indicate that the
	 * imported class should be ignored if it is not on the classpath.
	 * @return the classes to import
	 */
	@AliasFor('value')
	Class<?>[] classes() default {};
	/**
	 * Exclude specific auto-configuration classes such that they will never be applied.
	 * @return the classes to exclude
	 */
	Class<?>[] exclude() default {};
}
/*
package sample.app;
@RestController
public class SampleController {
	@GetMapping('/')
	public String hello() {
		return 'Hello World';
	}
}
/*
package sample.app;
@SpringBootApplication
public class DeploymentTestApplication extends SpringBootServletInitializer {
}
/*
package sample.autoconfig;
@ConditionalOnWarDeployment
@AutoConfiguration
public class ExampleAutoConfiguration {
	@Bean
	public TestEndpoint testEndpoint() {
		return new TestEndpoint();
	}
	@Endpoint(id = 'war')
	static class TestEndpoint {
		@ReadOperation
		String hello() {
			return '{\'hello\':\'world\'}';
		}
	}
}
/*
package org.springframework.boot.deployment;
/**
@Testcontainers(disabledWithoutDocker = true)
class TomEEDeploymentTests extends AbstractDeploymentTests {
	@Container
	static WarDeploymentContainer container = new WarDeploymentContainer('tomee:9.1.1-jre17-webprofile',
			'/usr/local/tomee/webapps', DEFAULT_PORT);
	@Override
	WarDeploymentContainer getContainer() {
		return container;
	}
}
/*
package org.springframework.boot.deployment;
/**
@Testcontainers(disabledWithoutDocker = true)
class WildflyDeploymentTests extends AbstractDeploymentTests {
	@Container
	static WarDeploymentContainer container = new WarDeploymentContainer('quay.io/wildfly/wildfly:27.0.0.Final-jdk17',
			'/opt/jboss/wildfly/standalone/deployments', DEFAULT_PORT);
	@Override
	WarDeploymentContainer getContainer() {
		return container;
	}
}
/*
package org.springframework.boot.deployment;
/**
@Testcontainers(disabledWithoutDocker = true)
class OpenLibertyDeploymentTests extends AbstractDeploymentTests {
	private static final int PORT = 9080;
	@Container
	static WarDeploymentContainer container = new WarDeploymentContainer(
			'icr.io/appcafe/open-liberty:full-java17-openj9-ubi', '/config/dropins', PORT,
			(builder) -> builder.run('sed -i "s/javaee-8.0/jakartaee-10.0/g" /config/server.xml'));
	@Override
	WarDeploymentContainer getContainer() {
		return container;
	}
	@Override
	protected int getPort() {
		return PORT;
	}
}
/*
package org.springframework.boot.deployment;
/**
@Testcontainers(disabledWithoutDocker = true)
class TomcatDeploymentTests extends AbstractDeploymentTests {
	@Container
	static WarDeploymentContainer container = new WarDeploymentContainer('tomcat:10.1.15-jdk17',
			'/usr/local/tomcat/webapps', DEFAULT_PORT);
	@Override
	WarDeploymentContainer getContainer() {
		return container;
	}
}
/*
package org.springframework.boot.deployment;
/**
abstract class AbstractDeploymentTests {
	protected static final int DEFAULT_PORT = 8080;
	@Test
	void home() {
		getDeployedApplication().test((rest) -> {
			ResponseEntity<String> response = rest.getForEntity('/', String.class);
			assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
			assertThat(response.getBody()).isEqualTo('Hello World');
		});
	}
	@Test
	void health() {
		getDeployedApplication().test((rest) -> {
			ResponseEntity<String> response = rest.getForEntity('/actuator/health', String.class);
			assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
			assertThat(response.getBody()).isEqualTo('{\'status\':\'UP\'}');
		});
	}
	@Test
	void conditionalOnWarShouldBeTrue() {
		getDeployedApplication().test((rest) -> {
			ResponseEntity<String> response = rest.getForEntity('/actuator/war', String.class);
			assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
			assertThat(response.getBody()).isEqualTo('{\'hello\':\'world\'}');
		});
	}
	private DeployedApplication getDeployedApplication() {
		return new DeployedApplication(getContainer(), getPort());
	}
	protected int getPort() {
		return DEFAULT_PORT;
	}
	abstract WarDeploymentContainer getContainer();
	static final class DeployedApplication {
		private final WarDeploymentContainer container;
		private final int port;
		DeployedApplication(WarDeploymentContainer container, int port) {
			this.container = container;
			this.port = port;
		}
		private void test(Consumer<TestRestTemplate> consumer) {
			TestRestTemplate rest = new TestRestTemplate(new RestTemplateBuilder()
				.rootUri('http://' + this.container.getHost() + ':' + this.container.getMappedPort(this.port)
						+ '/spring-boot')
				.requestFactory(() -> new HttpComponentsClientHttpRequestFactory(HttpClients.custom()
					.setRetryStrategy(new DefaultHttpRequestRetryStrategy(10, TimeValue.of(1, TimeUnit.SECONDS)))
					.build())));
			try {
				Awaitility.await().atMost(Duration.ofMinutes(10)).until(() -> {
					try {
						consumer.accept(rest);
						return true;
					}
					catch (Throwable ex) {
						return false;
					}
				});
			}
			catch (ConditionTimeoutException ex) {
				System.out.println(this.container.getLogs());
				throw ex;
			}
		}
	}
	static final class WarDeploymentContainer extends GenericContainer<WarDeploymentContainer> {
		WarDeploymentContainer(String baseImage, String deploymentLocation, int port) {
			this(baseImage, deploymentLocation, port, null);
		}
		WarDeploymentContainer(String baseImage, String deploymentLocation, int port,
				Consumer<DockerfileBuilder> dockerfileCustomizer) {
			super(new ImageFromDockerfile().withFileFromFile('spring-boot.war', findWarToDeploy())
				.withDockerfileFromBuilder((builder) -> {
					builder.from(baseImage).add('spring-boot.war', deploymentLocation + '/spring-boot.war');
					if (dockerfileCustomizer != null) {
						dockerfileCustomizer.accept(builder);
					}
				}));
			withExposedPorts(port).withStartupTimeout(Duration.ofMinutes(5)).withStartupAttempts(3);
		}
		private static File findWarToDeploy() {
			File[] candidates = new File('build/libs').listFiles();
			assertThat(candidates).hasSize(1);
			return candidates[0];
		}
	}
}
/*
package org.springframework.boot.image.assertions;
/**
public class ImageAssert extends AbstractAssert<ImageAssert, ImageReference> {
	private final HashMap<String, Layer> layers = new HashMap<>();
	ImageAssert(ImageReference imageReference) throws IOException {
		super(imageReference, ImageAssert.class);
		getLayers();
	}
	public void layer(String layerDigest, Consumer<LayerContentAssert> assertConsumer) {
		if (!this.layers.containsKey(layerDigest)) {
			failWithMessage('Layer with digest "%s" not found in image', layerDigest);
		}
		assertConsumer.accept(new LayerContentAssert(this.layers.get(layerDigest)));
	}
	private void getLayers() throws IOException {
		new DockerApi().image().exportLayers(this.actual, (id, tarArchive) -> {
			Layer layer = Layer.fromTarArchive(tarArchive);
			this.layers.put(layer.getId().toString(), layer);
		});
	}
	/**
	 * Asserts for image layers.
	 */
	public static class LayerContentAssert extends AbstractAssert<LayerContentAssert, Layer> {
		public LayerContentAssert(Layer layer) {
			super(layer, LayerContentAssert.class);
		}
		public ListAssert<String> entries() {
			List<String> entryNames = new ArrayList<>();
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				this.actual.writeTo(out);
				try (TarArchiveInputStream in = new TarArchiveInputStream(
						new ByteArrayInputStream(out.toByteArray()))) {
					TarArchiveEntry entry = in.getNextEntry();
					while (entry != null) {
						if (!entry.isDirectory()) {
							entryNames.add(entry.getName().replaceFirst('^/workspace/', ''));
						}
						entry = in.getNextEntry();
					}
				}
			}
			catch (IOException ex) {
				failWithMessage('IOException while reading image layer archive: "%s"', ex.getMessage());
			}
			return Assertions.assertThat(entryNames);
		}
		public void jsonEntry(String name, Consumer<JsonContentAssert> assertConsumer) {
			try {
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				this.actual.writeTo(out);
				try (TarArchiveInputStream in = new TarArchiveInputStream(
						new ByteArrayInputStream(out.toByteArray()))) {
					TarArchiveEntry entry = in.getNextEntry();
					while (entry != null) {
						if (entry.getName().equals(name)) {
							ByteArrayOutputStream entryOut = new ByteArrayOutputStream();
							IOUtils.copy(in, entryOut);
							assertConsumer.accept(new JsonContentAssert(LayerContentAssert.class, entryOut.toString()));
							return;
						}
						entry = in.getNextEntry();
					}
				}
				failWithMessage('Expected JSON entry "%s" in layer with digest "%s"', name, this.actual.getId());
			}
			catch (IOException ex) {
				failWithMessage('IOException while reading image layer archive: "%s"', ex.getMessage());
			}
		}
	}
}
/*
package org.springframework.boot.image.assertions;
/**
public final class ImageAssertions {
	private ImageAssertions() {
	}
	public static ContainerConfigAssert assertThat(ContainerConfig containerConfig) {
		return new ContainerConfigAssert(containerConfig);
	}
	public static ImageAssert assertThat(ImageReference imageReference) throws IOException {
		return new ImageAssert(imageReference);
	}
}
/*
package org.springframework.boot.image.assertions;
/**
public class ContainerConfigAssert extends AbstractAssert<ContainerConfigAssert, ContainerConfig> {
	private static final String BUILD_METADATA_LABEL = 'io.buildpacks.build.metadata';
	private static final String LIFECYCLE_METADATA_LABEL = 'io.buildpacks.lifecycle.metadata';
	ContainerConfigAssert(ContainerConfig containerConfig) {
		super(containerConfig, ContainerConfigAssert.class);
	}
	public void buildMetadata(Consumer<BuildMetadataAssert> assertConsumer) {
		assertConsumer.accept(new BuildMetadataAssert(jsonLabel(BUILD_METADATA_LABEL)));
	}
	public void lifecycleMetadata(Consumer<LifecycleMetadataAssert> assertConsumer) {
		assertConsumer.accept(new LifecycleMetadataAssert(jsonLabel(LIFECYCLE_METADATA_LABEL)));
	}
	public void labels(Consumer<LabelsAssert> assertConsumer) {
		assertConsumer.accept(new LabelsAssert(this.actual.getLabels()));
	}
	private JsonContentAssert jsonLabel(String label) {
		return new JsonContentAssert(ContainerConfigAssert.class, getLabel(label));
	}
	private String getLabel(String label) {
		Map<String, String> labels = this.actual.getLabels();
		if (labels == null) {
			failWithMessage('Container config contains no labels');
		}
		if (!labels.containsKey(label)) {
			failWithActualExpectedAndMessage(labels, label, 'Expected label not found in container config');
		}
		return labels.get(label);
	}
	/**
	 * Asserts for labels on an image.
	 */
	public static class LabelsAssert extends AbstractMapAssert<LabelsAssert, Map<String, String>, String, String> {
		protected LabelsAssert(Map<String, String> labels) {
			super(labels, LabelsAssert.class);
		}
	}
	/**
	 * Asserts for the JSON content in the {@code io.buildpacks.build.metadata} label.
	 *
	 * See <a href=
	 * 'https://github.com/buildpacks/spec/blob/main/platform.md#iobuildpacksbuildmetadata-json'>the
	 * spec</a>
	 */
	public static class BuildMetadataAssert extends AbstractAssert<BuildMetadataAssert, JsonContentAssert> {
		BuildMetadataAssert(JsonContentAssert jsonContentAssert) {
			super(jsonContentAssert, BuildMetadataAssert.class);
		}
		public ListAssert<Object> buildpacks() {
			return this.actual.extractingJsonPathArrayValue('$.buildpacks[*].id');
		}
		public AbstractListAssert<?, List<? extends String>, String, ObjectAssert<String>> processOfType(String type) {
			return this.actual.extractingJsonPathArrayValue('$.processes[?(@.type=="%s")]', type)
				.singleElement()
				.extracting('command', 'args')
				.flatMap(this::getArgs);
		}
		private Collection<String> getArgs(Object obj) {
			if (obj instanceof List<?> list) {
				return list.stream().map(Objects::toString).toList();
			}
			return Collections.emptyList();
		}
	}
	/**
	 * Asserts for the JSON content in the {@code io.buildpacks.lifecycle.metadata} label.
	 *
	 * See <a href=
	 * 'https://github.com/buildpacks/spec/blob/main/platform.md#iobuildpackslifecyclemetadata-json'>the
	 * spec</a>
	 */
	public static class LifecycleMetadataAssert extends AbstractAssert<LifecycleMetadataAssert, JsonContentAssert> {
		LifecycleMetadataAssert(JsonContentAssert jsonContentAssert) {
			super(jsonContentAssert, LifecycleMetadataAssert.class);
		}
		public ListAssert<Object> buildpackLayers(String buildpackId) {
			return this.actual.extractingJsonPathArrayValue('$.buildpacks[?(@.key=="%s")].layers', buildpackId);
		}
		public AbstractListAssert<?, List<?>, Object, ObjectAssert<Object>> appLayerShas() {
			return this.actual.extractingJsonPathArrayValue('$.app').extracting('sha');
		}
		public AbstractObjectAssert<?, Object> sbomLayerSha() {
			return this.actual.extractingJsonPathValue('$.sbom.sha');
		}
	}
}
/*
package org.springframework.boot.image.paketo;
/**
@ExtendWith({ GradleBuildInjectionExtension.class, GradleBuildExtension.class })
@EnabledForJreRange(max = JRE.JAVA_21)
class PaketoBuilderTests {
	GradleBuild gradleBuild;
	@BeforeEach
	void configureGradleBuild() {
		this.gradleBuild.scriptProperty('systemTestMavenRepository',
				new File('build/system-test-maven-repository').getAbsoluteFile().toURI().toASCIIString());
		this.gradleBuild.scriptPropertyFrom(new File('../../gradle.properties'), 'nativeBuildToolsVersion');
		this.gradleBuild.expectDeprecationMessages('BPL_SPRING_CLOUD_BINDINGS_ENABLED.*true.*Deprecated');
		this.gradleBuild.expectDeprecationMessages('Command \'packages\' is deprecated, use `syft scan` instead');
		this.gradleBuild.expectDeprecationMessages('BP_ENABLE_RUNTIME_CERT_BINDING.*true.*Deprecated');
		this.gradleBuild.gradleVersion(GradleVersions.maximumCompatible());
	}
	@Test
	void executableJarApp() throws Exception {
		writeMainClass();
		String imageName = 'paketo-integration/' + this.gradleBuild.getProjectDir().getName();
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			ContainerConfig config = container.getContainerInfo().getConfig();
			assertLabelsMatchManifestAttributes(config);
			ImageAssertions.assertThat(config).buildMetadata((metadata) -> {
				metadata.buildpacks()
					.contains('paketo-buildpacks/ca-certificates', 'paketo-buildpacks/bellsoft-liberica',
							'paketo-buildpacks/executable-jar', 'paketo-buildpacks/dist-zip',
							'paketo-buildpacks/spring-boot');
				metadata.processOfType('web')
					.containsExactly('java', 'org.springframework.boot.loader.launch.JarLauncher');
				metadata.processOfType('executable-jar')
					.containsExactly('java', 'org.springframework.boot.loader.launch.JarLauncher');
			});
			assertImageHasJvmSbomLayer(imageReference, config);
			assertImageHasDependenciesSbomLayer(imageReference, config, 'executable-jar');
			assertImageLayersMatchLayersIndex(imageReference, config);
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	void executableJarAppWithAdditionalArgs() throws Exception {
		writeMainClass();
		String imageName = 'paketo-integration/' + this.gradleBuild.getProjectDir().getName();
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withCommand('--server.port=9090');
			container.withExposedPorts(9090);
			container.waitingFor(Wait.forHttp('/test')).start();
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	void executableJarAppBuiltTwiceWithCaching() throws Exception {
		writeMainClass();
		String imageName = 'paketo-integration/' + this.gradleBuild.getProjectDir().getName();
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			container.stop();
		}
		this.gradleBuild.expectDeprecationMessages('BOM table is deprecated');
		result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	@Disabled('0.4.292 of the builder launches an unpacked jar rather than the script in bin')
	void bootDistZipJarApp() throws Exception {
		writeMainClass();
		String projectName = this.gradleBuild.getProjectDir().getName();
		String imageName = 'paketo-integration/' + projectName;
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName, 'assemble', 'bootDistZip');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			ContainerConfig config = container.getContainerInfo().getConfig();
			ImageAssertions.assertThat(config).buildMetadata((metadata) -> {
				metadata.buildpacks()
					.contains('paketo-buildpacks/ca-certificates', 'paketo-buildpacks/bellsoft-liberica',
							'paketo-buildpacks/dist-zip', 'paketo-buildpacks/spring-boot');
				String launcher = '/workspace/' + projectName + '-boot/bin/' + projectName;
				metadata.processOfType('web').containsExactly(launcher);
				metadata.processOfType('dist-zip').containsExactly(launcher);
			});
			assertImageHasJvmSbomLayer(imageReference, config);
			assertImageHasDependenciesSbomLayer(imageReference, config, 'dist-zip');
			DigestCapturingCondition digest = new DigestCapturingCondition();
			ImageAssertions.assertThat(config)
				.lifecycleMetadata((metadata) -> metadata.appLayerShas().haveExactly(1, digest));
			ImageAssertions.assertThat(imageReference)
				.layer(digest.getDigest(),
						(layer) -> layer.entries()
							.contains(projectName + '-boot/bin/' + projectName,
									projectName + '-boot/lib/' + projectName + '.jar'));
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	void plainDistZipJarApp() throws Exception {
		writeMainClass();
		String projectName = this.gradleBuild.getProjectDir().getName();
		String imageName = 'paketo-integration/' + projectName;
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName, 'assemble', 'bootDistZip');
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			ContainerConfig config = container.getContainerInfo().getConfig();
			ImageAssertions.assertThat(config).buildMetadata((metadata) -> {
				metadata.buildpacks()
					.contains('paketo-buildpacks/ca-certificates', 'paketo-buildpacks/bellsoft-liberica',
							'paketo-buildpacks/dist-zip', 'paketo-buildpacks/spring-boot');
				String launcher = '/workspace/' + projectName + '/bin/' + projectName;
				metadata.processOfType('web').containsExactly(launcher);
				metadata.processOfType('dist-zip').containsExactly(launcher);
			});
			assertImageHasJvmSbomLayer(imageReference, config);
			assertImageHasDependenciesSbomLayer(imageReference, config, 'dist-zip');
			DigestCapturingCondition digest = new DigestCapturingCondition();
			ImageAssertions.assertThat(config)
				.lifecycleMetadata((metadata) -> metadata.appLayerShas().haveExactly(1, digest));
			ImageAssertions.assertThat(imageReference)
				.layer(digest.getDigest(), (layer) -> layer.entries()
					.contains(projectName + '/bin/' + projectName, projectName + '/lib/' + projectName + '-plain.jar')
					.anyMatch((s) -> s.startsWith(projectName + '/lib/spring-boot-'))
					.anyMatch((s) -> s.startsWith(projectName + '/lib/spring-core-'))
					.anyMatch((s) -> s.startsWith(projectName + '/lib/spring-web-')));
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	void executableWarApp() throws Exception {
		writeMainClass();
		writeServletInitializerClass();
		String imageName = 'paketo-integration/' + this.gradleBuild.getProjectDir().getName();
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			ContainerConfig config = container.getContainerInfo().getConfig();
			assertLabelsMatchManifestAttributes(config);
			ImageAssertions.assertThat(config).buildMetadata((metadata) -> {
				metadata.buildpacks()
					.contains('paketo-buildpacks/ca-certificates', 'paketo-buildpacks/bellsoft-liberica',
							'paketo-buildpacks/executable-jar', 'paketo-buildpacks/dist-zip',
							'paketo-buildpacks/spring-boot');
				metadata.processOfType('web')
					.containsExactly('java', 'org.springframework.boot.loader.launch.WarLauncher');
				metadata.processOfType('executable-jar')
					.containsExactly('java', 'org.springframework.boot.loader.launch.WarLauncher');
			});
			assertImageHasJvmSbomLayer(imageReference, config);
			assertImageHasDependenciesSbomLayer(imageReference, config, 'executable-jar');
			assertImageLayersMatchLayersIndex(imageReference, config);
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	void plainWarApp() throws Exception {
		writeMainClass();
		writeServletInitializerClass();
		String imageName = 'paketo-integration/' + this.gradleBuild.getProjectDir().getName();
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			ContainerConfig config = container.getContainerInfo().getConfig();
			ImageAssertions.assertThat(config).buildMetadata((metadata) -> {
				metadata.buildpacks()
					.contains('paketo-buildpacks/ca-certificates', 'paketo-buildpacks/bellsoft-liberica',
							'paketo-buildpacks/apache-tomcat', 'paketo-buildpacks/dist-zip',
							'paketo-buildpacks/spring-boot');
				metadata.processOfType('web')
					.containsSubsequence('java', 'org.apache.catalina.startup.Bootstrap', 'start');
				metadata.processOfType('tomcat')
					.containsSubsequence('java', 'org.apache.catalina.startup.Bootstrap', 'start');
			});
			assertImageHasJvmSbomLayer(imageReference, config);
			assertImageHasDependenciesSbomLayer(imageReference, config, 'apache-tomcat');
			DigestCapturingCondition digest = new DigestCapturingCondition();
			ImageAssertions.assertThat(config)
				.lifecycleMetadata((metadata) -> metadata.appLayerShas().haveExactly(1, digest));
			ImageAssertions.assertThat(imageReference)
				.layer(digest.getDigest(),
						(layer) -> layer.entries()
							.contains('WEB-INF/classes/example/ExampleApplication.class',
									'WEB-INF/classes/example/HelloController.class', 'META-INF/MANIFEST.MF')
							.anyMatch((s) -> s.startsWith('WEB-INF/lib/spring-boot-'))
							.anyMatch((s) -> s.startsWith('WEB-INF/lib/spring-core-'))
							.anyMatch((s) -> s.startsWith('WEB-INF/lib/spring-web-')));
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	void nativeApp() throws Exception {
		this.gradleBuild.expectDeprecationMessages('uses or overrides a deprecated API');
		this.gradleBuild.expectDeprecationMessages('has been deprecated and marked for removal');
		// these deprecations are transitive from the Native Build Tools Gradle plugin
		this.gradleBuild
			.expectDeprecationMessages('has been deprecated. This is scheduled to be removed in Gradle 9.0');
		this.gradleBuild.expectDeprecationMessages('upgrading_version_8.html#deprecated_access_to_convention');
		writeMainClass();
		String imageName = 'paketo-integration/' + this.gradleBuild.getProjectDir().getName();
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			ContainerConfig config = container.getContainerInfo().getConfig();
			assertLabelsMatchManifestAttributes(config);
			ImageAssertions.assertThat(config).buildMetadata((metadata) -> {
				metadata.buildpacks()
					.contains('paketo-buildpacks/ca-certificates', 'paketo-buildpacks/bellsoft-liberica',
							'paketo-buildpacks/executable-jar', 'paketo-buildpacks/spring-boot',
							'paketo-buildpacks/native-image');
				metadata.processOfType('web')
					.satisfiesExactly((command) -> assertThat(command).endsWith('/example.ExampleApplication'));
				metadata.processOfType('native-image')
					.satisfiesExactly((command) -> assertThat(command).endsWith('/example.ExampleApplication'));
			});
			assertImageHasDependenciesSbomLayer(imageReference, config, 'native-image');
		}
		finally {
			removeImage(imageReference);
		}
	}
	@Test
	void classDataSharingApp() throws Exception {
		writeMainClass();
		String imageName = 'paketo-integration/' + this.gradleBuild.getProjectDir().getName();
		ImageReference imageReference = ImageReference.of(ImageName.of(imageName));
		BuildResult result = buildImage(imageName);
		assertThat(result.task(':bootBuildImage').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('Running creator');
		try (GenericContainer<?> container = new GenericContainer<>(imageName)) {
			container.withExposedPorts(8080);
			container.waitingFor(Wait.forHttp('/test')).start();
			ContainerConfig config = container.getContainerInfo().getConfig();
			assertLabelsMatchManifestAttributes(config);
			ImageAssertions.assertThat(config).buildMetadata((metadata) -> {
				metadata.buildpacks()
					.contains('paketo-buildpacks/ca-certificates', 'paketo-buildpacks/bellsoft-liberica',
							'paketo-buildpacks/executable-jar', 'paketo-buildpacks/dist-zip',
							'paketo-buildpacks/spring-boot');
				metadata.processOfType('web')
					.satisfiesExactly((command) -> assertThat(command).isEqualTo('java'),
							(arg) -> assertThat(arg).isEqualTo('-cp'),
							(arg) -> assertThat(arg).startsWith('runner.jar'),
							(arg) -> assertThat(arg).isEqualTo('example.ExampleApplication'));
				metadata.processOfType('spring-boot-app')
					.satisfiesExactly((command) -> assertThat(command).isEqualTo('java'),
							(arg) -> assertThat(arg).isEqualTo('-cp'),
							(arg) -> assertThat(arg).startsWith('runner.jar'),
							(arg) -> assertThat(arg).isEqualTo('example.ExampleApplication'));
				metadata.processOfType('executable-jar')
					.containsExactly('java', 'org.springframework.boot.loader.launch.JarLauncher');
			});
			assertImageHasJvmSbomLayer(imageReference, config);
			assertImageHasDependenciesSbomLayer(imageReference, config, 'executable-jar');
		}
		finally {
			removeImage(imageReference);
		}
	}
	private BuildResult buildImage(String imageName, String... arguments) {
		List<String> args = new ArrayList<>(List.of(arguments));
		args.add('bootBuildImage');
		args.add('--imageName=' + imageName);
		args.add('--pullPolicy=IF_NOT_PRESENT');
		return this.gradleBuild.build(args.toArray(new String[0]));
	}
	private void writeMainClass() throws IOException {
		writeProjectFile('ExampleApplication.java', (writer) -> {
			writer.println('package example;');
			writer.println();
			writer.println('import org.springframework.boot.SpringApplication;');
			writer.println('import org.springframework.boot.autoconfigure.SpringBootApplication;');
			writer.println('import org.springframework.stereotype.Controller;');
			writer.println('import org.springframework.web.bind.annotation.RequestMapping;');
			writer.println('import org.springframework.web.bind.annotation.ResponseBody;');
			writer.println();
			writer.println('@SpringBootApplication');
			writer.println('public class ExampleApplication {');
			writer.println();
			writer.println('    public static void main(String[] args) {');
			writer.println('        SpringApplication.run(ExampleApplication.class, args);');
			writer.println('    }');
			writer.println();
			writer.println('}');
			writer.println();
			writer.println('@Controller');
			writer.println('class HelloController {');
			writer.println();
			writer.println('    @RequestMapping(\'/test\')');
			writer.println('    @ResponseBody');
			writer.println('    String home() {');
			writer.println('        return \'Hello, world!\';');
			writer.println('    }');
			writer.println();
			writer.println('}');
		});
	}
	private void writeServletInitializerClass() throws IOException {
		writeProjectFile('ServletInitializer.java', (writer) -> {
			writer.println('package example;');
			writer.println();
			writer.println('import org.springframework.boot.builder.SpringApplicationBuilder;');
			writer.println('import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;');
			writer.println();
			writer.println('public class ServletInitializer extends SpringBootServletInitializer {');
			writer.println();
			writer.println('    @Override');
			writer.println('    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {');
			writer.println('        return application.sources(ExampleApplication.class);');
			writer.println('    }');
			writer.println();
			writer.println('}');
		});
	}
	private void writeProjectFile(String fileName, Consumer<PrintWriter> consumer) throws IOException {
		File examplePackage = new File(this.gradleBuild.getProjectDir(), 'src/main/java/example');
		examplePackage.mkdirs();
		File main = new File(examplePackage, fileName);
		try (PrintWriter writer = new PrintWriter(new FileWriter(main))) {
			consumer.accept(writer);
		}
	}
	private void assertLabelsMatchManifestAttributes(ContainerConfig config) throws IOException {
		try (JarFile jarFile = new JarFile(projectArchiveFile())) {
			Attributes attributes = jarFile.getManifest().getMainAttributes();
			ImageAssertions.assertThat(config).labels((labels) -> {
				labels.contains(entry('org.springframework.boot.version', attributes.getValue('Spring-Boot-Version')));
				labels.contains(entry('org.opencontainers.image.title',
						attributes.getValue(Attributes.Name.IMPLEMENTATION_TITLE)));
				labels.contains(entry('org.opencontainers.image.version',
						attributes.getValue(Attributes.Name.IMPLEMENTATION_VERSION)));
			});
		}
	}
	private void assertImageHasJvmSbomLayer(ImageReference imageReference, ContainerConfig config) throws IOException {
		DigestCapturingCondition digest = new DigestCapturingCondition();
		ImageAssertions.assertThat(config).lifecycleMetadata((metadata) -> metadata.sbomLayerSha().has(digest));
		ImageAssertions.assertThat(imageReference).layer(digest.getDigest(), (layer) -> {
			layer.entries().contains('/layers/sbom/launch/paketo-buildpacks_bellsoft-liberica/jre/sbom.syft.json');
			layer.jsonEntry('/layers/sbom/launch/paketo-buildpacks_bellsoft-liberica/jre/sbom.syft.json', (json) -> {
				json.extractingJsonPathStringValue('$.Artifacts[0].Name').isEqualTo('BellSoft Liberica JRE');
				json.extractingJsonPathStringValue('$.Artifacts[0].Version').startsWith(javaMajorVersion());
			});
		});
	}
	private void assertImageHasDependenciesSbomLayer(ImageReference imageReference, ContainerConfig config,
			String buildpack) throws IOException {
		DigestCapturingCondition digest = new DigestCapturingCondition();
		ImageAssertions.assertThat(config).lifecycleMetadata((metadata) -> metadata.sbomLayerSha().has(digest));
		ImageAssertions.assertThat(imageReference).layer(digest.getDigest(), (layer) -> {
			layer.entries()
				.contains('/layers/sbom/launch/paketo-buildpacks_' + buildpack + '/sbom.syft.json',
						'/layers/sbom/launch/paketo-buildpacks_' + buildpack + '/sbom.cdx.json');
			layer.jsonEntry('/layers/sbom/launch/paketo-buildpacks_' + buildpack + '/sbom.syft.json',
					(json) -> json.extractingJsonPathArrayValue('$.artifacts.[*].name')
						.contains('spring-beans', 'spring-boot', 'spring-boot-autoconfigure', 'spring-context',
								'spring-core', 'spring-expression', 'spring-jcl', 'spring-web', 'spring-webmvc'));
			layer.jsonEntry('/layers/sbom/launch/paketo-buildpacks_' + buildpack + '/sbom.cdx.json',
					(json) -> json.extractingJsonPathArrayValue('$.components.[*].name')
						.contains('spring-beans', 'spring-boot', 'spring-boot-autoconfigure', 'spring-context',
								'spring-core', 'spring-expression', 'spring-jcl', 'spring-web', 'spring-webmvc'));
		});
	}
	private void assertImageLayersMatchLayersIndex(ImageReference imageReference, ContainerConfig config)
			throws IOException {
		DigestsCapturingCondition digests = new DigestsCapturingCondition();
		ImageAssertions.assertThat(config)
			.lifecycleMetadata((metadata) -> metadata.appLayerShas().haveExactly(5, digests));
		LayersIndex layersIndex = LayersIndex.fromArchiveFile(projectArchiveFile());
		ImageAssertions.assertThat(imageReference)
			.layer(digests.getDigest(0), (layer) -> layer.entries()
				.allMatch((entry) -> startsWithOneOf(entry, layersIndex.getLayer('dependencies'))));
		ImageAssertions.assertThat(imageReference)
			.layer(digests.getDigest(1), (layer) -> layer.entries()
				.allMatch((entry) -> startsWithOneOf(entry, layersIndex.getLayer('spring-boot-loader'))));
		ImageAssertions.assertThat(imageReference)
			.layer(digests.getDigest(2), (layer) -> layer.entries()
				.allMatch((entry) -> startsWithOneOf(entry, layersIndex.getLayer('snapshot-dependencies'))));
		ImageAssertions.assertThat(imageReference)
			.layer(digests.getDigest(3), (layer) -> layer.entries()
				.allMatch((entry) -> startsWithOneOf(entry, layersIndex.getLayer('application'))));
		ImageAssertions.assertThat(imageReference)
			.layer(digests.getDigest(4),
					(layer) -> layer.entries().allMatch((entry) -> entry.contains('lib/spring-cloud-bindings-')));
	}
	private File projectArchiveFile() {
		return new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0];
	}
	private String javaMajorVersion() {
		String javaVersion = System.getProperty('java.version');
		if (javaVersion.startsWith('1.')) {
			return javaVersion.substring(2, 3);
		}
		int firstDotIndex = javaVersion.indexOf('.');
		if (firstDotIndex != -1) {
			return javaVersion.substring(0, firstDotIndex);
		}
		return javaVersion;
	}
	private boolean startsWithOneOf(String actual, List<String> expectedPrefixes) {
		for (String prefix : expectedPrefixes) {
			if (actual.startsWith(prefix)) {
				return true;
			}
		}
		return false;
	}
	private void removeImage(ImageReference image) throws IOException {
		new DockerApi().image().remove(image, false);
	}
	private static class DigestCapturingCondition extends Condition<Object> {
		private static String digest = null;
		DigestCapturingCondition() {
			super(predicate(), 'a value starting with "sha256:"');
		}
		private static Predicate<Object> predicate() {
			return (sha) -> {
				digest = sha.toString();
				return sha.toString().startsWith('sha256:');
			};
		}
		String getDigest() {
			return digest;
		}
	}
	private static class DigestsCapturingCondition extends Condition<Object> {
		private static List<String> digests;
		DigestsCapturingCondition() {
			super(predicate(), 'a value starting with "sha256:"');
		}
		private static Predicate<Object> predicate() {
			digests = new ArrayList<>();
			return (sha) -> {
				digests.add(sha.toString());
				return sha.toString().startsWith('sha256:');
			};
		}
		String getDigest(int index) {
			return digests.get(index);
		}
	}
}
/*
package org.springframework.boot.image.paketo;
/**
class LayersIndex extends ArrayList<Map<String, List<String>>> {
	List<String> getLayer(String layerName) {
		return stream().filter((entry) -> entry.containsKey(layerName))
			.findFirst()
			.map((entry) -> entry.get(layerName))
			.orElse(Collections.emptyList());
	}
	static LayersIndex fromArchiveFile(File archiveFile) throws IOException {
		String indexPath = (archiveFile.getName().endsWith('.war') ? 'WEB-INF/layers.idx' : 'BOOT-INF/layers.idx');
		try (JarFile jarFile = new JarFile(archiveFile)) {
			ZipEntry indexEntry = jarFile.getEntry(indexPath);
			Yaml yaml = new Yaml(new Constructor(LayersIndex.class, getLoaderOptions()));
			return yaml.load(jarFile.getInputStream(indexEntry));
		}
	}
	private static LoaderOptions getLoaderOptions() {
		LoaderOptions loaderOptions = new LoaderOptions();
		loaderOptions.setAllowDuplicateKeys(false);
		loaderOptions.setMaxAliasesForCollections(Integer.MAX_VALUE);
		loaderOptions.setAllowRecursiveKeys(true);
		return loaderOptions;
	}
}
/*
package org.springframework.boot.image.junit;
/**
public class GradleBuildInjectionExtension implements BeforeEachCallback {
	private final GradleBuild gradleBuild;
	GradleBuildInjectionExtension() {
		this.gradleBuild = new GradleBuild();
		this.gradleBuild.gradleVersion(GradleVersions.minimumCompatible());
		String bootVersion = System.getProperty('springBootVersion');
		Assert.notNull(bootVersion, 'Property "springBootVersion" must be set in build environment');
		this.gradleBuild.bootVersion(bootVersion);
	}
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		Field field = ReflectionUtils.findField(context.getRequiredTestClass(), 'gradleBuild');
		field.setAccessible(true);
		field.set(context.getRequiredTestInstance(), this.gradleBuild);
	}
}
/*
package smoketest.session;
/**
@SpringBootTest(properties = 'spring.session.timeout:10', webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers(disabledWithoutDocker = true)
class SampleSessionWebFluxMongoApplicationTests {
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	@LocalServerPort
	private int port;
	@Autowired
	private WebClient.Builder webClientBuilder;
	@Test
	void userDefinedMappingsSecureByDefault() {
		WebClient client = this.webClientBuilder.baseUrl('http://localhost:' + this.port + '/').build();
		client.get().header('Authorization', getBasicAuth()).exchangeToMono((response) -> {
			assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
			return response.bodyToMono(String.class)
				.map((sessionId) -> Tuples.of(response.cookies().getFirst('SESSION').getValue(), sessionId));
		}).flatMap((tuple) -> {
			String sessionCookie = tuple.getT1();
			return client.get().cookie('SESSION', sessionCookie).exchangeToMono((response) -> {
				assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
				return response.bodyToMono(String.class)
					.doOnNext((sessionId) -> assertThat(sessionId).isEqualTo(tuple.getT2()))
					.thenReturn(sessionCookie);
			});
		})
			.delayElement(Duration.ofSeconds(10))
			.flatMap((sessionCookie) -> client.get().cookie('SESSION', sessionCookie).exchangeToMono((response) -> {
				assertThat(response.statusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
				return response.releaseBody();
			}))
			.block(Duration.ofSeconds(30));
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
}
/*
package smoketest.session;
@RestController
public class HelloRestController {
	@GetMapping('/')
	String sessionId(WebSession session) {
		return session.getId();
	}
}
/*
package smoketest.session;
@SpringBootApplication
public class SampleSessionWebFluxMongoApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSessionWebFluxMongoApplication.class);
	}
	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http.authorizeExchange((exchange) -> exchange.anyExchange().authenticated());
		http.httpBasic((basic) -> basic.securityContextRepository(new WebSessionServerSecurityContextRepository()));
		http.formLogin(withDefaults());
		return http.build();
	}
}
/*
package smoketest.data.r2dbc;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.r2dbc.generate-unique-name=true')
class SampleR2dbcApplicationTests {
	@Autowired
	private WebTestClient webClient;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void citiesEndpointReturnInitialState() {
		this.webClient.get()
			.uri('/cities')
			.exchange()
			.expectBody()
			.jsonPath('$[*].id')
			.isEqualTo(new JSONArray().appendElement(2000).appendElement(2001));
	}
	@Test
	void citiesEndpointByIdWithExistingIdReturnCity() {
		this.webClient.get().uri('/cities/2001').exchange().expectBody().jsonPath('$.name').isEqualTo('San Francisco');
	}
	@Test
	void healthEndpointHasR2dbcEntry() {
		this.webClient.get()
			.uri('/actuator/health')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.jsonPath('components.r2dbc.status')
			.isEqualTo('UP')
			.jsonPath('components.r2dbc.details.database')
			.isEqualTo('H2');
	}
	@Test
	void dataSourceIsNotAutoConfigured() {
		assertThat(this.applicationContext.getBeansOfType(DataSource.class)).isEmpty();
	}
}
/*
package smoketest.data.r2dbc;
public class City {
	@Id
	private Long id;
	private String name;
	private String state;
	private String country;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public Long getId() {
		return this.id;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package smoketest.data.r2dbc;
@SpringBootApplication
public class SampleR2dbcApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleR2dbcApplication.class, args);
	}
}
/*
package smoketest.data.r2dbc;
public interface CityRepository extends ReactiveCrudRepository<City, Long> {
}
/*
package smoketest.data.r2dbc;
@RestController
public class CityController {
	private final CityRepository repository;
	public CityController(CityRepository repository) {
		this.repository = repository;
	}
	@GetMapping('/cities')
	public Flux<City> findCities() {
		return this.repository.findAll();
	}
	@GetMapping('/cities/{id}')
	public Mono<City> findCityById(@PathVariable long id) {
		return this.repository.findById(id);
	}
}
/*
package smoketest.profile;
/**
@SpringBootTest(webEnvironment = WebEnvironment.NONE, properties = { 'enableEnvironmentPostProcessor=true' }) // gh-28530
@ActiveProfiles('hello')
class ActiveProfilesTests {
	@Autowired
	private Environment environment;
	@Test
	void activeProfileShouldTakePrecedenceOverProgrammaticallySetProfile() {
		assertThat(this.environment.getActiveProfiles()).containsExactly('dev', 'hello');
	}
}
/*
package smoketest.profile;
@ExtendWith(OutputCaptureExtension.class)
class SampleProfileApplicationTests {
	private String profiles;
	@BeforeEach
	void before() {
		this.profiles = System.getProperty('spring.profiles.active');
	}
	@AfterEach
	void after() {
		if (this.profiles != null) {
			System.setProperty('spring.profiles.active', this.profiles);
		}
		else {
			System.clearProperty('spring.profiles.active');
		}
	}
	@Test
	void testDefaultProfile(CapturedOutput output) {
		SampleProfileApplication.main();
		assertThat(output).contains('Hello Phil');
	}
	@Test
	void testGoodbyeProfile(CapturedOutput output) {
		System.setProperty('spring.profiles.active', 'goodbye');
		SampleProfileApplication.main();
		assertThat(output).contains('Goodbye Everyone');
	}
	@Test
	void testGenericProfile(CapturedOutput output) {
		/*
		 * This is a profile that requires a new environment property, and one which is
		 * only overridden in the current working directory. That file also only contains
		 * partial overrides, and the default application.yml should still supply the
		 * 'test.name' property.
		 */
		System.setProperty('spring.profiles.active', 'generic');
		SampleProfileApplication.main();
		assertThat(output).contains('Bonjour Phil');
	}
	@Test
	void testGoodbyeProfileFromCommandline(CapturedOutput output) {
		SampleProfileApplication.main('--spring.profiles.active=goodbye');
		assertThat(output).contains('Goodbye Everyone');
	}
}
/*
package smoketest.profile;
// gh-29169
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class AttributeInjectionTests {
	@Autowired(required = false)
	private org.springframework.boot.web.servlet.error.ErrorAttributes errorAttributesServlet;
	@Autowired(required = false)
	private org.springframework.boot.web.reactive.error.ErrorAttributes errorAttributesReactive;
	@Test
	void contextLoads() {
		assertThat(this.errorAttributesServlet).isNull();
		assertThat(this.errorAttributesReactive).isNotNull();
	}
}
/*
package smoketest.profile.service;
public interface MessageService {
	String getMessage();
}
/*
package smoketest.profile.service;
@Component
@Profile({ 'hello', 'default' })
public class HelloWorldService implements MessageService {
	@Value('${test.name:World}')
	private String name;
	@Override
	public String getMessage() {
		return 'Hello ' + this.name;
	}
}
/*
package smoketest.profile.service;
@Component
@Profile({ 'generic' })
public class GenericService implements MessageService {
	@Value('${test.hello:Hello}')
	private String hello;
	@Value('${test.name:World}')
	private String name;
	@Override
	public String getMessage() {
		return this.hello + ' ' + this.name;
	}
}
/*
package smoketest.profile.service;
@Component
@Profile('goodbye')
public class GoodbyeWorldService implements MessageService {
	@Value('${test.name:World}')
	private String name;
	@Override
	public String getMessage() {
		return 'Goodbye ' + this.name;
	}
}
/*
package smoketest.profile;
/**
@Order(Ordered.HIGHEST_PRECEDENCE)
class ActiveProfilesEnvironmentPostProcessor implements EnvironmentPostProcessor {
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		if (environment.getProperty('enableEnvironmentPostProcessor') != null) {
			environment.addActiveProfile('dev');
		}
	}
}
/*
package smoketest.profile;
@SpringBootApplication
public class SampleProfileApplication implements CommandLineRunner {
	// Simple example shows how a command line spring application can execute an
	// injected bean service. Also demonstrates how you can use @Value to inject
	// command line args ("--test.name=whatever") or application properties
	@Autowired
	private MessageService helloWorldService;
	@Override
	public void run(String... args) {
		System.out.println(this.helloWorldService.getMessage());
	}
	public static void main(String... args) {
		SpringApplication application = new SpringApplication(SampleProfileApplication.class) {
			@Override
			protected void bindToSpringApplication(ConfigurableEnvironment environment) {
			}
		};
		application.setWebApplicationType(WebApplicationType.NONE);
		application.run(args);
	}
}
/*
package smoketest.tomcat;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@ExtendWith(OutputCaptureExtension.class)
class SampleTomcatApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private ApplicationContext applicationContext;
	@Value('${server.max-http-request-header-size}')
	private int maxHttpRequestHeaderSize;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
	@Test
	void testCompression() throws Exception {
		HttpHeaders requestHeaders = new HttpHeaders();
		requestHeaders.set('Accept-Encoding', 'gzip');
		HttpEntity<?> requestEntity = new HttpEntity<>(requestHeaders);
		ResponseEntity<byte[]> entity = this.restTemplate.exchange('/', HttpMethod.GET, requestEntity, byte[].class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		try (GZIPInputStream inflater = new GZIPInputStream(new ByteArrayInputStream(entity.getBody()))) {
			assertThat(StreamUtils.copyToString(inflater, StandardCharsets.UTF_8)).isEqualTo('Hello World');
		}
	}
	@Test
	void testTimeout() {
		ServletWebServerApplicationContext context = (ServletWebServerApplicationContext) this.applicationContext;
		TomcatWebServer embeddedServletContainer = (TomcatWebServer) context.getWebServer();
		ProtocolHandler protocolHandler = embeddedServletContainer.getTomcat().getConnector().getProtocolHandler();
		int timeout = ((AbstractProtocol<?>) protocolHandler).getConnectionTimeout();
		assertThat(timeout).isEqualTo(5000);
	}
	@Test
	void testMaxHttpResponseHeaderSize(CapturedOutput output) {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/max-http-response-header', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(output).contains(
				'threw exception [Request processing failed: org.apache.coyote.http11.HeadersTooLargeException: An attempt was made to write more data to the response headers than there was room available in the buffer. Increase maxHttpHeaderSize on the connector or write less data into the response headers.]');
	}
	@Test
	void testMaxHttpRequestHeaderSize(CapturedOutput output) {
		String headerValue = RandomStringUtil.getRandomBase64EncodedString(this.maxHttpRequestHeaderSize + 1);
		HttpHeaders headers = new HttpHeaders();
		headers.add('x-max-request-header', headerValue);
		HttpEntity<?> httpEntity = new HttpEntity<>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, httpEntity, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
		assertThat(output).contains('java.lang.IllegalArgumentException: Request header is too large');
	}
}
/*
package smoketest.tomcat;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class NonAutoConfigurationSampleTomcatApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	@ComponentScan(basePackageClasses = { SampleController.class, HelloWorldService.class })
	public static class NonAutoConfigurationSampleTomcatApplication {
		public static void main(String[] args) {
			SpringApplication.run(SampleTomcatApplication.class, args);
		}
	}
}
/*
package smoketest.tomcat.web;
@Controller
public class SampleController {
	private final HelloWorldService helloWorldService;
	private final HttpHeaderService httpHeaderService;
	public SampleController(HelloWorldService helloWorldService, HttpHeaderService httpHeaderService) {
		this.helloWorldService = helloWorldService;
		this.httpHeaderService = httpHeaderService;
	}
	@GetMapping('/')
	@ResponseBody
	public String helloWorld() {
		return this.helloWorldService.getHelloMessage();
	}
	@GetMapping('/max-http-response-header')
	@ResponseBody
	public String maxHttpResponseHeader(HttpServletResponse response) {
		String headerValue = this.httpHeaderService.getHeaderValue();
		response.addHeader('x-max-header', headerValue);
		return this.helloWorldService.getHelloMessage();
	}
}
/*
package smoketest.tomcat.service;
@Component
public class HelloWorldService {
	@Value('${test.name:World}')
	private String name;
	public String getHelloMessage() {
		return 'Hello ' + this.name;
	}
}
/*
package smoketest.tomcat.service;
@Component
public class HttpHeaderService {
	@Value('${server.tomcat.max-http-response-header-size}')
	private int maxHttpResponseHeaderSize;
	/**
	 * Generates random data. The data is:
	 * <ol>
	 * <li>is longer than configured
	 * <code>server.tomcat.max-http-response-header-size</code></li>
	 * <li>is url encoded by base 64 encode the random value</li>
	 * </ol>
	 * @return a base64 encoded string of random bytes
	 */
	public String getHeaderValue() {
		return RandomStringUtil.getRandomBase64EncodedString(this.maxHttpResponseHeaderSize + 1);
	}
}
/*
package smoketest.tomcat.util;
public final class RandomStringUtil {
	private RandomStringUtil() {
	}
	public static String getRandomBase64EncodedString(int length) {
		byte[] responseHeader = new byte[length];
		new Random().nextBytes(responseHeader);
		return Base64.getEncoder().encodeToString(responseHeader);
	}
}
/*
package smoketest.tomcat;
@SpringBootApplication
public class SampleTomcatApplication {
	private static final Log logger = LogFactory.getLog(SampleTomcatApplication.class);
	@Bean
	protected ServletContextListener listener() {
		return new ServletContextListener() {
			@Override
			public void contextInitialized(ServletContextEvent sce) {
				logger.info('ServletContext initialized');
			}
			@Override
			public void contextDestroyed(ServletContextEvent sce) {
				logger.info('ServletContext destroyed');
			}
		};
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleTomcatApplication.class, args);
	}
}
/*
package smoketest.quartz;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleQuartzApplicationWebTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void quartzGroupNames() {
		Map<String, Object> content = getContent('/actuator/quartz');
		assertThat(content).containsOnlyKeys('jobs', 'triggers');
	}
	@Test
	void quartzJobGroups() {
		Map<String, Object> content = getContent('/actuator/quartz/jobs');
		assertThat(content).containsOnlyKeys('groups');
		assertThat(content).extractingByKey('groups', nestedMap()).containsOnlyKeys('samples');
	}
	@Test
	void quartzTriggerGroups() {
		Map<String, Object> content = getContent('/actuator/quartz/triggers');
		assertThat(content).containsOnlyKeys('groups');
		assertThat(content).extractingByKey('groups', nestedMap()).containsOnlyKeys('DEFAULT', 'samples');
	}
	@Test
	void quartzJobDetail() {
		Map<String, Object> content = getContent('/actuator/quartz/jobs/samples/helloJob');
		assertThat(content).containsEntry('name', 'helloJob').containsEntry('group', 'samples');
	}
	@Test
	void quartzJobDetailWhenNameDoesNotExistReturns404() {
		ResponseEntity<String> response = this.restTemplate.getForEntity('/actuator/quartz/jobs/samples/does-not-exist',
				String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@Test
	void quartzTriggerDetail() {
		Map<String, Object> content = getContent('/actuator/quartz/triggers/samples/3am-weekdays');
		assertThat(content).contains(entry('group', 'samples'), entry('name', '3am-weekdays'), entry('state', 'NORMAL'),
				entry('type', 'cron'));
	}
	@Test
	void quartzTriggerDetailWhenNameDoesNotExistReturns404() {
		ResponseEntity<String> response = this.restTemplate
			.getForEntity('/actuator/quartz/triggers/samples/does-not-exist', String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	private Map<String, Object> getContent(String path) {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(this.restTemplate.getForEntity(path, Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		return entity.getBody();
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
	@SuppressWarnings('rawtypes')
	private static InstanceOfAssertFactory<Map, MapAssert<String, Object>> nestedMap() {
		return InstanceOfAssertFactories.map(String.class, Object.class);
	}
}
/*
package smoketest.quartz;
/**
@ExtendWith(OutputCaptureExtension.class)
class SampleQuartzApplicationTests {
	@Test
	void quartzJobIsTriggered(CapturedOutput output) {
		try (ConfigurableApplicationContext context = SpringApplication.run(SampleQuartzApplication.class,
				'--server.port=0')) {
			Awaitility.waitAtMost(Duration.ofSeconds(5)).until(output::toString, containsString('Hello World!'));
		}
	}
}
/*
package smoketest.quartz;
@SpringBootApplication
public class SampleQuartzApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleQuartzApplication.class, args);
	}
	@Bean
	public JobDetail helloJobDetail() {
		return JobBuilder.newJob(SampleJob.class)
			.withIdentity('helloJob', 'samples')
			.usingJobData('name', 'World')
			.storeDurably()
			.build();
	}
	@Bean
	public JobDetail anotherJobDetail() {
		return JobBuilder.newJob(SampleJob.class)
			.withIdentity('anotherJob', 'samples')
			.usingJobData('name', 'Everyone')
			.storeDurably()
			.build();
	}
	@Bean
	public Trigger everyTwoSecTrigger() {
		return TriggerBuilder.newTrigger()
			.forJob('helloJob', 'samples')
			.withIdentity('sampleTrigger')
			.withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever())
			.build();
	}
	@Bean
	public Trigger everyDayTrigger() {
		return TriggerBuilder.newTrigger()
			.forJob('helloJob', 'samples')
			.withIdentity('every-day', 'samples')
			.withSchedule(SimpleScheduleBuilder.repeatHourlyForever(24))
			.build();
	}
	@Bean
	public Trigger threeAmWeekdaysTrigger() {
		return TriggerBuilder.newTrigger()
			.forJob('anotherJob', 'samples')
			.withIdentity('3am-weekdays', 'samples')
			.withSchedule(CronScheduleBuilder.atHourAndMinuteOnGivenDaysOfWeek(3, 0, 1, 2, 3, 4, 5))
			.build();
	}
	@Bean
	public Trigger onceAWeekTrigger() {
		return TriggerBuilder.newTrigger()
			.forJob('anotherJob', 'samples')
			.withIdentity('once-a-week', 'samples')
			.withSchedule(CalendarIntervalScheduleBuilder.calendarIntervalSchedule().withIntervalInWeeks(1))
			.build();
	}
	@Bean
	public Trigger everyHourWorkingHourTuesdayAndThursdayTrigger() {
		return TriggerBuilder.newTrigger()
			.forJob('helloJob', 'samples')
			.withIdentity('every-hour-tue-thu', 'samples')
			.withSchedule(DailyTimeIntervalScheduleBuilder.dailyTimeIntervalSchedule()
				.onDaysOfTheWeek(Calendar.TUESDAY, Calendar.THURSDAY)
				.startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0))
				.endingDailyAt(TimeOfDay.hourAndMinuteOfDay(18, 0))
				.withInterval(1, IntervalUnit.HOUR))
			.build();
	}
}
/*
package smoketest.quartz;
public class SampleJob extends QuartzJobBean {
	private String name;
	// Invoked if a Job data map entry with that name
	public void setName(String name) {
		this.name = name;
	}
	@Override
	protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
		System.out.println(String.format('Hello %s!', this.name));
	}
}
/*
package smoketest.data.rest;
/**
@SpringBootTest
@AutoConfigureMockMvc
// Separate profile for web tests to avoid clashing databases
class SampleDataRestApplicationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void testHome() {
		assertThat(this.mvc.get().uri('/api')).hasStatusOk().bodyText().contains('hotels');
	}
	@Test
	void findByNameAndCountry() {
		assertThat(this.mvc.get()
			.uri('/api/cities/search/findByNameAndCountryAllIgnoringCase?name=Melbourne&country=Australia'))
			.hasStatusOk()
			.bodyJson()
			.extractingPath('$')
			.convertTo(City.class)
			.satisfies((city) -> {
				assertThat(city.getName()).isEqualTo('Melbourne');
				assertThat(city.getState()).isEqualTo('Victoria');
			});
	}
	@Test
	void findByContaining() {
		assertThat(this.mvc.get()
			.uri('/api/cities/search/findByNameContainingAndCountryContainingAllIgnoringCase?name=&country=UK'))
			.hasStatusOk()
			.bodyJson()
			.extractingPath('_embedded.cities')
			.asArray()
			.hasSize(3);
	}
}
/*
package smoketest.data.rest.service;
/**
@SpringBootTest
class CityRepositoryIntegrationTests {
	@Autowired
	CityRepository repository;
	@Test
	void findsFirstPageOfCities() {
		Page<City> cities = this.repository.findAll(PageRequest.of(0, 10));
		assertThat(cities.getTotalElements()).isGreaterThan(20L);
	}
	@Test
	void findByNameAndCountry() {
		City city = this.repository.findByNameAndCountryAllIgnoringCase('Melbourne', 'Australia');
		assertThat(city).isNotNull();
		assertThat(city.getName()).isEqualTo('Melbourne');
	}
	@Test
	void findContaining() {
		Page<City> cities = this.repository.findByNameContainingAndCountryContainingAllIgnoringCase('', 'UK',
				PageRequest.of(0, 10));
		assertThat(cities.getTotalElements()).isEqualTo(3L);
	}
}
/*
package smoketest.data.rest.domain;
@Entity
public class Hotel implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@SequenceGenerator(name = 'hotel_generator', sequenceName = 'hotel_sequence', initialValue = 28)
	@GeneratedValue(generator = 'hotel_generator')
	private Long id;
	@ManyToOne(optional = false)
	@NaturalId
	private City city;
	@Column(nullable = false)
	@NaturalId
	private String name;
	@Column(nullable = false)
	private String address;
	@Column(nullable = false)
	private String zip;
	protected Hotel() {
	}
	public Hotel(City city, String name) {
		this.city = city;
		this.name = name;
	}
	public City getCity() {
		return this.city;
	}
	public String getName() {
		return this.name;
	}
	public String getAddress() {
		return this.address;
	}
	public String getZip() {
		return this.zip;
	}
}
/*
package smoketest.data.rest.domain;
@Entity
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@SequenceGenerator(name = 'city_generator', sequenceName = 'city_sequence', initialValue = 23)
	@GeneratedValue(generator = 'city_generator')
	private Long id;
	@Column(nullable = false)
	private String name;
	@Column(nullable = false)
	private String state;
	@Column(nullable = false)
	private String country;
	@Column(nullable = false)
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package smoketest.data.rest.service;
public class CitySearchCriteria implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	public CitySearchCriteria() {
	}
	public CitySearchCriteria(String name) {
		Assert.notNull(name, 'Name must not be null');
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package smoketest.data.rest.service;
@RepositoryRestResource(collectionResourceRel = 'hotels', path = 'hotels')
interface HotelRepository extends PagingAndSortingRepository<Hotel, Long> {
	Hotel findByCityAndName(City city, String name);
}
/*
package smoketest.data.rest.service;
@RepositoryRestResource(collectionResourceRel = 'cities', path = 'cities')
interface CityRepository extends PagingAndSortingRepository<City, Long> {
	Page<City> findByNameContainingAndCountryContainingAllIgnoringCase(@Param('name') String name,
			@Param('country') String country, Pageable pageable);
	City findByNameAndCountryAllIgnoringCase(@Param('name') String name, @Param('country') String country);
}
/*
package smoketest.data.rest;
@SpringBootApplication
public class SampleDataRestApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleDataRestApplication.class, args);
	}
}
/*
package smoketest.structuredlogging.log4j2;
/**
@ExtendWith(OutputCaptureExtension.class)
class SampleLog4j2StructuredLoggingApplicationTests {
	@AfterEach
	void reset() {
		LoggingSystem.get(getClass().getClassLoader()).cleanUp();
		for (LoggingSystemProperty property : LoggingSystemProperty.values()) {
			System.getProperties().remove(property.getEnvironmentVariableName());
		}
	}
	@Test
	void shouldNotLogBanner(CapturedOutput output) {
		SampleLog4j2StructuredLoggingApplication.main(new String[0]);
		assertThat(output).doesNotContain(' :: Spring Boot :: ');
	}
	@Test
	void json(CapturedOutput output) {
		SampleLog4j2StructuredLoggingApplication.main(new String[0]);
		assertThat(output).contains('{\'@timestamp\'')
			.contains('\'message\':\'Starting SampleLog4j2StructuredLoggingApplication');
	}
	@Test
	void custom(CapturedOutput output) {
		SampleLog4j2StructuredLoggingApplication.main(new String[] { '--spring.profiles.active=custom' });
		assertThat(output).contains('epoch=').contains('msg=\'Starting SampleLog4j2StructuredLoggingApplication');
	}
}
/*
package smoketest.structuredlogging.log4j2;
public class CustomStructuredLogFormatter implements StructuredLogFormatter<LogEvent> {
	private final Long pid;
	public CustomStructuredLogFormatter(Environment environment) {
		this.pid = environment.getProperty('spring.application.pid', Long.class);
	}
	@Override
	public String format(LogEvent event) {
		StringBuilder result = new StringBuilder();
		result.append('epoch=').append(event.getInstant().getEpochMillisecond());
		if (this.pid != null) {
			result.append(' pid=').append(this.pid);
		}
		result.append(' msg=\'').append(event.getMessage().getFormattedMessage()).append("'");
		ThrowableProxy throwable = event.getThrownProxy();
		if (throwable != null) {
			result.append(' error=\'').append(throwable.getExtendedStackTraceAsString()).append("'");
		}
		result.append("\n");
		return result.toString();
	}
}
/*
package smoketest.structuredlogging.log4j2;
@SpringBootApplication
public class SampleLog4j2StructuredLoggingApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleLog4j2StructuredLoggingApplication.class, args);
	}
}
/*
package smoketest.prometheus;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureObservability
class SamplePrometheusApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void shouldExportExemplars() {
		for (int i = 0; i < 10; i++) {
			ResponseEntity<String> response = this.restTemplate.getForEntity('/actuator', String.class);
			assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		}
		HttpHeaders headers = new HttpHeaders();
		headers.add(HttpHeaders.ACCEPT, 'application/openmetrics-text; version=1.0.0; charset=utf-8');
		ResponseEntity<String> metrics = this.restTemplate.exchange('/actuator/prometheus', HttpMethod.GET,
				new HttpEntity<>(headers), String.class);
		assertThat(metrics.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(metrics.getBody()).containsSubsequence('http_client_requests_seconds_count', 'span_id', 'trace_id');
	}
}
/*
package smoketest.prometheus;
@SpringBootApplication
public class SamplePrometheusApplication {
	public static void main(String[] args) {
		SpringApplication.run(SamplePrometheusApplication.class, args);
	}
}
/*
package smoketest.xml;
/**
@SpringBootTest(
		classes = { SampleSpringXmlApplication.class, SampleSpringXmlPlaceholderBeanDefinitionTests.TestConfig.class })
@ExtendWith(OutputCaptureExtension.class)
class SampleSpringXmlPlaceholderBeanDefinitionTests {
	@Test
	void beanWithPlaceholderShouldNotFail(CapturedOutput output) {
		assertThat(output).contains('Hello Other World');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportResource({ 'classpath:/META-INF/context.xml' })
	static class TestConfig {
		@Bean
		CommandLineRunner testCommandLineRunner(OtherService service) {
			return (args) -> System.out.println(service.getMessage());
		}
	}
}
/*
package smoketest.xml;
@ExtendWith(OutputCaptureExtension.class)
class SampleSpringXmlApplicationTests {
	@Test
	void testDefaultSettings(CapturedOutput output) {
		SampleSpringXmlApplication.main(new String[0]);
		assertThat(output).contains('Hello World');
	}
}
/*
package smoketest.xml.service;
@Component
public class HelloWorldService {
	@Value('${test.name:World}')
	private String name;
	public String getHelloMessage() {
		return 'Hello ' + this.name;
	}
}
/*
package smoketest.xml.service;
public class OtherService {
	public String getMessage() {
		return 'Hello Other World';
	}
}
/*
package smoketest.xml;
@SpringBootApplication
public class SampleSpringXmlApplication implements CommandLineRunner {
	private static final String CONTEXT_XML = 'classpath:/META-INF/application-context.xml';
	@Autowired
	private HelloWorldService helloWorldService;
	@Override
	public void run(String... args) {
		System.out.println(this.helloWorldService.getHelloMessage());
	}
	public static void main(String[] args) {
		SpringApplication application = new SpringApplication();
		application.setSources(Collections.singleton(CONTEXT_XML));
		application.run(args);
	}
}
/*
package smoketest.tomcat.ssl;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleTomcatSslApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private AbstractConfigurableWebServerFactory webServerFactory;
	@Test
	void testSsl() {
		assertThat(this.webServerFactory.getSsl().isEnabled()).isTrue();
	}
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello, world');
	}
	@Test
	void testSslInfo() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/actuator/info', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		JsonContent body = new JsonContent(entity.getBody());
		assertThat(body).extractingPath('ssl.bundles[0].name').isEqualTo('ssldemo');
		assertThat(body).extractingPath('ssl.bundles[0].certificateChains[0].alias')
			.isEqualTo('spring-boot-ssl-sample');
		assertThat(body).extractingPath('ssl.bundles[0].certificateChains[0].certificates[0].issuer')
			.isEqualTo('CN=localhost,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown');
		assertThat(body).extractingPath('ssl.bundles[0].certificateChains[0].certificates[0].subject')
			.isEqualTo('CN=localhost,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown');
		assertThat(body).extractingPath('ssl.bundles[0].certificateChains[0].certificates[0].validity.status')
			.isEqualTo('EXPIRED');
		assertThat(body).extractingPath('ssl.bundles[0].certificateChains[0].certificates[0].validity.message')
			.asString()
			.startsWith('Not valid after ');
	}
	@Test
	void testSslHealth() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.SERVICE_UNAVAILABLE);
		JsonContent body = new JsonContent(entity.getBody());
		assertThat(body).extractingPath('status').isEqualTo('OUT_OF_SERVICE');
		assertThat(body).extractingPath('components.ssl.status').isEqualTo('OUT_OF_SERVICE');
		assertThat(body).extractingPath('components.ssl.details.invalidChains[0].alias')
			.isEqualTo('spring-boot-ssl-sample');
		assertThat(body).extractingPath('components.ssl.details.invalidChains[0].certificates[0].issuer')
			.isEqualTo('CN=localhost,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown');
		assertThat(body).extractingPath('components.ssl.details.invalidChains[0].certificates[0].subject')
			.isEqualTo('CN=localhost,OU=Unknown,O=Unknown,L=Unknown,ST=Unknown,C=Unknown');
		assertThat(body).extractingPath('components.ssl.details.invalidChains[0].certificates[0].validity.status')
			.isEqualTo('EXPIRED');
		assertThat(body).extractingPath('components.ssl.details.invalidChains[0].certificates[0].validity.message')
			.asString()
			.startsWith('Not valid after ');
	}
}
/*
package smoketest.tomcat.ssl.web;
@RestController
public class SampleController {
	@GetMapping('/')
	public String helloWorld() {
		return 'Hello, world';
	}
}
/*
package smoketest.tomcat.ssl;
@SpringBootApplication
public class SampleTomcatSslApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleTomcatSslApplication.class, args);
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		classes = { AbstractErrorPageTests.TestConfiguration.class,
				UnauthenticatedErrorPageTests.SecurityConfiguration.class, SampleWebSecureApplication.class },
		properties = { 'server.error.include-message=always', 'spring.security.user.name=username',
				'spring.security.user.password=password', 'server.servlet.context-path=/example' })
class CustomContextPathUnauthenticatedErrorPageTests extends AbstractUnauthenticatedErrorPageTests {
	CustomContextPathUnauthenticatedErrorPageTests() {
		super('');
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		classes = { AbstractErrorPageTests.TestConfiguration.class, NoSessionErrorPageTests.SecurityConfiguration.class,
				SampleWebSecureApplication.class },
		properties = { 'server.error.include-message=always', 'spring.security.user.name=username',
				'spring.security.user.password=password' })
class NoSessionErrorPageTests extends AbstractErrorPageTests {
	NoSessionErrorPageTests() {
		super('');
	}
	@org.springframework.boot.test.context.TestConfiguration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
			http.sessionManagement((session) -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
				.authorizeHttpRequests((requests) -> {
					requests.requestMatchers('/public/**').permitAll();
					requests.anyRequest().authenticated();
				});
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
}
/*
package smoketest.web.secure;
/**
abstract class AbstractErrorPageTests {
	@Autowired
	private TestRestTemplate testRestTemplate;
	private final String pathPrefix;
	protected AbstractErrorPageTests(String pathPrefix) {
		this.pathPrefix = pathPrefix;
	}
	@Test
	void testBadCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'wrongpassword')
			.exchange(this.pathPrefix + '/test', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse).isNull();
	}
	@Test
	void testNoCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.exchange(this.pathPrefix + '/test',
				HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse).isNull();
	}
	@Test
	void testPublicNotFoundPageWithCorrectCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'password')
			.exchange(this.pathPrefix + '/public/notfound', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Not Found');
	}
	@Test
	void testPublicNotFoundPageWithBadCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'wrong')
			.exchange(this.pathPrefix + '/public/notfound', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse).isNull();
	}
	@Test
	void testCorrectCredentialsWithControllerException() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'password')
			.exchange(this.pathPrefix + '/fail', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Internal Server Error');
	}
	@Test
	void testCorrectCredentials() {
		final ResponseEntity<String> response = this.testRestTemplate.withBasicAuth('username', 'password')
			.exchange(this.pathPrefix + '/test', HttpMethod.GET, null, String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		response.getBody();
		assertThat(response.getBody()).isEqualTo('test');
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@RestController
		static class TestController {
			@GetMapping('/test')
			String test() {
				return 'test';
			}
			@GetMapping('/fail')
			String fail() {
				throw new RuntimeException();
			}
		}
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		classes = { AbstractErrorPageTests.TestConfiguration.class,
				CustomServletPathUnauthenticatedErrorPageTests.SecurityConfiguration.class,
				SampleWebSecureApplication.class },
		properties = { 'server.error.include-message=always', 'spring.security.user.name=username',
				'spring.security.user.password=password', 'spring.mvc.servlet.path=/custom/servlet/path' })
class CustomServletPathUnauthenticatedErrorPageTests extends AbstractUnauthenticatedErrorPageTests {
	CustomServletPathUnauthenticatedErrorPageTests() {
		super('/custom/servlet/path');
	}
	@org.springframework.boot.test.context.TestConfiguration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> {
				requests.requestMatchers('/error').permitAll();
				requests.requestMatchers('/public/**').permitAll();
				requests.anyRequest().authenticated();
			});
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		classes = { AbstractErrorPageTests.TestConfiguration.class,
				UnauthenticatedErrorPageTests.SecurityConfiguration.class, SampleWebSecureApplication.class },
		properties = { 'server.error.include-message=always', 'spring.security.user.name=username',
				'spring.security.user.password=password' })
class UnauthenticatedErrorPageTests extends AbstractUnauthenticatedErrorPageTests {
	UnauthenticatedErrorPageTests() {
		super('');
	}
	@org.springframework.boot.test.context.TestConfiguration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> {
				requests.requestMatchers('/error').permitAll();
				requests.requestMatchers('/public/**').permitAll();
				requests.anyRequest().authenticated();
			});
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
}
/*
package smoketest.web.secure;
/**
abstract class AbstractUnauthenticatedErrorPageTests {
	@Autowired
	private TestRestTemplate testRestTemplate;
	private final String pathPrefix;
	protected AbstractUnauthenticatedErrorPageTests(String pathPrefix) {
		this.pathPrefix = pathPrefix;
	}
	@Test
	void testBadCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'wrongpassword')
			.exchange(this.pathPrefix + '/test', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Unauthorized');
	}
	@Test
	void testNoCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.exchange(this.pathPrefix + '/test',
				HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Unauthorized');
	}
	@Test
	void testPublicNotFoundPage() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.exchange(this.pathPrefix + '/public/notfound',
				HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Not Found');
	}
	@Test
	void testPublicNotFoundPageWithCorrectCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'password')
			.exchange(this.pathPrefix + '/public/notfound', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Not Found');
	}
	@Test
	void testPublicNotFoundPageWithBadCredentials() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'wrong')
			.exchange(this.pathPrefix + '/public/notfound', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Unauthorized');
	}
	@Test
	void testCorrectCredentialsWithControllerException() {
		final ResponseEntity<JsonNode> response = this.testRestTemplate.withBasicAuth('username', 'password')
			.exchange(this.pathPrefix + '/fail', HttpMethod.GET, null, JsonNode.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		JsonNode jsonResponse = response.getBody();
		assertThat(jsonResponse.get('error').asText()).isEqualTo('Internal Server Error');
	}
	@Test
	void testCorrectCredentials() {
		final ResponseEntity<String> response = this.testRestTemplate.withBasicAuth('username', 'password')
			.exchange(this.pathPrefix + '/test', HttpMethod.GET, null, String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(response.getBody()).isEqualTo('test');
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		classes = { AbstractErrorPageTests.TestConfiguration.class,
				CustomServletPathErrorPageTests.SecurityConfiguration.class, SampleWebSecureApplication.class },
		properties = { 'server.error.include-message=always', 'spring.security.user.name=username',
				'spring.security.user.password=password', 'spring.mvc.servlet.path=/custom/servlet/path' })
class CustomServletPathErrorPageTests extends AbstractErrorPageTests {
	CustomServletPathErrorPageTests() {
		super('/custom/servlet/path');
	}
	@org.springframework.boot.test.context.TestConfiguration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityFilterChain configure(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> {
				requests.requestMatchers('/public/**').permitAll();
				requests.anyRequest().fullyAuthenticated();
			});
			http.httpBasic(withDefaults());
			http.formLogin((form) -> form.loginPage('/custom/servlet/path/login').permitAll());
			return http.build();
		}
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		classes = { AbstractErrorPageTests.TestConfiguration.class, ErrorPageTests.SecurityConfiguration.class,
				SampleWebSecureApplication.class },
		properties = { 'server.error.include-message=always', 'spring.security.user.name=username',
				'spring.security.user.password=password' })
class ErrorPageTests extends AbstractErrorPageTests {
	ErrorPageTests() {
		super('');
	}
	@org.springframework.boot.test.context.TestConfiguration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityFilterChain configure(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> {
				requests.requestMatchers('/public/**').permitAll();
				requests.anyRequest().fullyAuthenticated();
			});
			http.httpBasic(withDefaults());
			http.formLogin((form) -> form.loginPage('/login').permitAll());
			return http.build();
		}
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		classes = { AbstractErrorPageTests.TestConfiguration.class, ErrorPageTests.SecurityConfiguration.class,
				SampleWebSecureApplication.class },
		properties = { 'server.error.include-message=always', 'spring.security.user.name=username',
				'spring.security.user.password=password', 'server.servlet.context-path=/example' })
class CustomContextPathErrorPageTests extends AbstractErrorPageTests {
	CustomContextPathErrorPageTests() {
		super('');
	}
}
/*
package smoketest.web.secure;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		classes = { SampleWebSecureApplicationTests.SecurityConfiguration.class, SampleWebSecureApplication.class })
class SampleWebSecureApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@LocalServerPort
	private int port;
	@Test
	void testHome() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.exchange('/home', HttpMethod.GET,
				new HttpEntity<Void>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation().toString()).endsWith(this.port + '/login');
	}
	@Test
	void testLoginPage() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.GET,
				new HttpEntity<Void>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('<title>Login</title>');
	}
	@Test
	void testLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'password');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation().toString()).endsWith(this.port + '/');
	}
	@org.springframework.boot.test.context.TestConfiguration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityFilterChain configure(HttpSecurity http) throws Exception {
			http.csrf(CsrfConfigurer::disable);
			http.authorizeHttpRequests((requests) -> {
				requests.requestMatchers('/public/**').permitAll();
				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll();
				requests.anyRequest().fullyAuthenticated();
			});
			http.httpBasic(withDefaults());
			http.formLogin((form) -> form.loginPage('/login').permitAll());
			return http.build();
		}
	}
}
/*
package smoketest.web.secure;
@SpringBootApplication
public class SampleWebSecureApplication implements WebMvcConfigurer {
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController('/').setViewName('home');
		registry.addViewController('/login').setViewName('login');
	}
	public static void main(String[] args) {
		new SpringApplicationBuilder(SampleWebSecureApplication.class).run(args);
	}
}
/*
package smoketest.aop;
/**
@ExtendWith(OutputCaptureExtension.class)
class SampleAopApplicationTests {
	private String profiles;
	@BeforeEach
	void init() {
		this.profiles = System.getProperty('spring.profiles.active');
	}
	@AfterEach
	void after() {
		if (this.profiles != null) {
			System.setProperty('spring.profiles.active', this.profiles);
		}
		else {
			System.clearProperty('spring.profiles.active');
		}
	}
	@Test
	void testDefaultSettings(CapturedOutput output) {
		SampleAopApplication.main(new String[0]);
		assertThat(output).contains('Hello Phil');
	}
	@Test
	void testCommandLineOverrides(CapturedOutput output) {
		SampleAopApplication.main(new String[] { '--test.name=Gordon' });
		assertThat(output).contains('Hello Gordon');
	}
}
/*
package smoketest.aop.service;
@Component
public class HelloWorldService {
	@Value('${test.name:World}')
	private String name;
	public String getHelloMessage() {
		return 'Hello ' + this.name;
	}
}
/*
package smoketest.aop;
@SpringBootApplication
public class SampleAopApplication implements CommandLineRunner {
	// Simple example shows how an application can spy on itself with AOP
	@Autowired
	private HelloWorldService helloWorldService;
	@Override
	public void run(String... args) {
		System.out.println(this.helloWorldService.getHelloMessage());
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleAopApplication.class, args);
	}
}
/*
package smoketest.aop.monitor;
@Aspect
@Component
public class ServiceMonitor {
	@AfterReturning('execution(* smoketest..*Service.*(..))')
	public void logServiceAccess(JoinPoint joinPoint) {
		System.out.println('Completed: ' + joinPoint);
	}
}
/*
package smoketest.data.mongo;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataMongoTest(properties = { 'spring.data.mongodb.ssl.bundle=client',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
class SampleMongoApplicationSslTests {
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(SecureMongoContainer.class);
	@Autowired
	private MongoTemplate mongoTemplate;
	@Autowired
	private SampleRepository exampleRepository;
	@Test
	void testRepository() {
		SampleDocument exampleDocument = new SampleDocument();
		exampleDocument.setText('Look, new @DataMongoTest!');
		exampleDocument = this.exampleRepository.save(exampleDocument);
		assertThat(exampleDocument.getId()).isNotNull();
		assertThat(this.mongoTemplate.collectionExists('exampleDocuments')).isTrue();
	}
}
/*
package smoketest.data.mongo;
/**
@Testcontainers(disabledWithoutDocker = true)
@SpringBootTest(properties = { 'spring.data.mongodb.ssl.bundle=client',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
class SampleMongoApplicationReactiveSslTests {
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(SecureMongoContainer.class);
	@Autowired
	private ReactiveMongoTemplate mongoTemplate;
	@Autowired
	private SampleReactiveRepository exampleRepository;
	@Test
	void testRepository() {
		SampleDocument exampleDocument = new SampleDocument();
		exampleDocument.setText('Look, new @DataMongoTest!');
		exampleDocument = this.exampleRepository.save(exampleDocument).block(Duration.ofSeconds(30));
		assertThat(exampleDocument.getId()).isNotNull();
		assertThat(this.mongoTemplate.collectionExists('exampleDocuments').block(Duration.ofSeconds(30))).isTrue();
	}
}
/*
package smoketest.data.mongo;
/**
class SecureMongoContainer extends MongoDBContainer {
	SecureMongoContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
	}
	@Override
	public void configure() {
		// test-server.pem is a single PEM file containing server certificate and key
		// content combined
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.pem'), '/ssl/server.pem');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-ca.crt'), '/ssl/ca.crt');
		withCommand('mongod --tlsMode requireTLS --tlsCertificateKeyFile /ssl/server.pem --tlsCAFile /ssl/ca.crt');
	}
	@Override
	protected void containerIsStarted(InspectContainerResponse containerInfo, boolean reused) {
	}
}
/*
package smoketest.data.mongo;
@Document(collection = 'exampleDocuments')
public class SampleDocument {
	private String id;
	private String text;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getText() {
		return this.text;
	}
	public void setText(String text) {
		this.text = text;
	}
}
/*
package smoketest.data.mongo;
@SpringBootApplication
public class SampleMongoApplication {
}
/*
package smoketest.data.mongo;
@Service
public class SampleService {
	private final MongoTemplate mongoTemplate;
	public SampleService(MongoTemplate mongoTemplate) {
		this.mongoTemplate = mongoTemplate;
	}
	public boolean hasCollection(String collectionName) {
		return this.mongoTemplate.collectionExists(collectionName);
	}
}
/*
package smoketest.data.mongo;
interface SampleReactiveRepository extends ReactiveMongoRepository<SampleDocument, String> {
}
/*
package smoketest.data.mongo;
interface SampleRepository extends MongoRepository<SampleDocument, String> {
}
/*
package smoketest.propertyvalidation;
/**
class SamplePropertyValidationApplicationTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@AfterEach
	void closeContext() {
		this.context.close();
	}
	@Test
	void bindValidProperties() {
		this.context.register(SamplePropertyValidationApplication.class);
		TestPropertyValues.of('sample.host:192.168.0.1', 'sample.port:9090').applyTo(this.context);
		this.context.refresh();
		SampleProperties properties = this.context.getBean(SampleProperties.class);
		assertThat(properties.getHost()).isEqualTo('192.168.0.1');
		assertThat(properties.getPort()).isEqualTo(Integer.valueOf(9090));
	}
	@Test
	void bindInvalidHost() {
		this.context.register(SamplePropertyValidationApplication.class);
		TestPropertyValues.of('sample.host:xxxxxx', 'sample.port:9090').applyTo(this.context);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.isInstanceOf(BindValidationException.class);
	}
	@Test
	void bindNullHost() {
		this.context.register(SamplePropertyValidationApplication.class);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(this.context::refresh)
			.havingRootCause()
			.isInstanceOf(BindValidationException.class);
	}
	@Test
	void validatorOnlyCalledOnSupportedClass() {
		this.context.register(SamplePropertyValidationApplication.class);
		this.context.register(ServerProperties.class); // our validator will not apply
		TestPropertyValues.of('sample.host:192.168.0.1', 'sample.port:9090').applyTo(this.context);
		this.context.refresh();
		SampleProperties properties = this.context.getBean(SampleProperties.class);
		assertThat(properties.getHost()).isEqualTo('192.168.0.1');
		assertThat(properties.getPort()).isEqualTo(Integer.valueOf(9090));
	}
}
/*
package smoketest.propertyvalidation;
public class SamplePropertiesValidator implements Validator {
	final Pattern pattern = Pattern.compile('^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$');
	@Override
	public boolean supports(Class<?> type) {
		return type == SampleProperties.class;
	}
	@Override
	public void validate(Object o, Errors errors) {
		ValidationUtils.rejectIfEmpty(errors, 'host', 'host.empty');
		ValidationUtils.rejectIfEmpty(errors, 'port', 'port.empty');
		SampleProperties properties = (SampleProperties) o;
		if (properties.getHost() != null && !this.pattern.matcher(properties.getHost()).matches()) {
			errors.rejectValue('host', 'Invalid host');
		}
	}
}
/*
package smoketest.propertyvalidation;
@SpringBootApplication
@ConfigurationPropertiesScan
public class SamplePropertyValidationApplication implements CommandLineRunner {
	private final SampleProperties properties;
	public SamplePropertyValidationApplication(SampleProperties properties) {
		this.properties = properties;
	}
	@Bean
	public static Validator configurationPropertiesValidator() {
		return new SamplePropertiesValidator();
	}
	@Override
	public void run(String... args) {
		System.out.println('=========================================');
		System.out.println('Sample host: ' + this.properties.getHost());
		System.out.println('Sample port: ' + this.properties.getPort());
		System.out.println('=========================================');
	}
	public static void main(String[] args) {
		new SpringApplicationBuilder(SamplePropertyValidationApplication.class).run(args);
	}
}
/*
package smoketest.propertyvalidation;
@ConfigurationProperties(prefix = 'sample')
@Validated
public class SampleProperties {
	/**
	 * Sample host.
	 */
	private String host;
	/**
	 * Sample port.
	 */
	private Integer port = 8080;
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public Integer getPort() {
		return this.port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
}
/*
package smoketest.jersey;
/**
class JerseyServletManagementPortTests extends AbstractJerseyManagementPortTests {
}
/*
package smoketest.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = 'management.endpoints.jackson.isolated-object-mapper=false')
@ContextConfiguration(loader = ApplicationStartupSpringBootContextLoader.class)
class JerseyActuatorIsolatedObjectMapperFalseTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void resourceShouldBeAvailableOnMainPort() {
		ResponseEntity<String> entity = this.testRestTemplate
			.getForEntity('http://localhost:' + this.port + '/actuator/startup', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
		assertThat(entity.getBody())
			.contains('Java 8 date/time type `java.time.Clock$SystemClock` not supported by default');
	}
}
/*
package smoketest.jersey;
/**
@TestPropertySource(properties = { 'spring.jersey.type=filter', 'server.servlet.register-default-servlet=true' })
class JerseyFilterManagementPortTests extends AbstractJerseyManagementPortTests {
}
/*
package smoketest.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = 'management.endpoints.jackson.isolated-object-mapper=true')
@ContextConfiguration(loader = ApplicationStartupSpringBootContextLoader.class)
class JerseyActuatorIsolatedObjectMapperTrueTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void resourceShouldBeAvailableOnMainPort() {
		ResponseEntity<String> entity = this.testRestTemplate
			.getForEntity('http://localhost:' + this.port + '/actuator/startup', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'timeline\':');
	}
}
/*
package smoketest.jersey;
/**
class JerseyServletApplicationTests extends AbstractJerseyApplicationTests {
}
/*
package smoketest.jersey;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, properties = 'management.server.port=0')
@Import(ResourceConfigConfiguration.class)
class AbstractJerseyManagementPortTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void resourceShouldBeAvailableOnMainPort() {
		ResponseEntity<String> entity = this.testRestTemplate.getForEntity('http://localhost:' + this.port + '/test',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('test');
	}
	@Test
	void resourceShouldNotBeAvailableOnManagementPort() {
		ResponseEntity<String> entity = this.testRestTemplate
			.getForEntity('http://localhost:' + this.managementPort + '/test', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@Test
	void actuatorShouldBeAvailableOnManagementPort() {
		ResponseEntity<String> entity = this.testRestTemplate
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void actuatorShouldNotBeAvailableOnMainPort() {
		ResponseEntity<String> entity = this.testRestTemplate
			.getForEntity('http://localhost:' + this.port + '/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@TestConfiguration
	static class ResourceConfigConfiguration {
		@Bean
		ResourceConfigCustomizer customizer() {
			return (config) -> config.register(TestEndpoint.class);
		}
		@Path('/test')
		public static class TestEndpoint {
			@GET
			public String test() {
				return 'test';
			}
		}
	}
}
/*
package smoketest.jersey;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'management.endpoints.web.base-path=/' })
class JerseyDifferentPortSampleActuatorApplicationTests {
	@LocalManagementPort
	private int managementPort;
	@Test
	void linksEndpointShouldBeAvailable() {
		ResponseEntity<String> entity = new TestRestTemplate('user', getPassword())
			.getForEntity('http://localhost:' + this.managementPort + '/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'_links\'');
	}
	private String getPassword() {
		return 'password';
	}
}
/*
package smoketest.jersey;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'spring.jersey.application-path=/app' })
class JerseyApplicationPathAndManagementPortTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void applicationPathShouldNotAffectActuators() {
		ResponseEntity<String> entity = this.testRestTemplate
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
}
/*
package smoketest.jersey;
/**
@TestPropertySource(properties = { 'spring.jersey.type=filter', 'server.servlet.register-default-servlet=true' })
class JerseyFilterApplicationTests extends AbstractJerseyApplicationTests {
}
/*
package smoketest.jersey;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'logging.level.root=debug')
abstract class AbstractJerseyApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void reverse() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/reverse?input=olleh', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('hello');
	}
	@Test
	void validation() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/reverse', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
	}
	@Test
	void actuatorStatus() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('{\'status\':\'UP\'}');
	}
}
/*
package smoketest.jersey;
class ApplicationStartupSpringBootContextLoader extends SpringBootContextLoader {
	@Override
	protected SpringApplication getSpringApplication() {
		SpringApplication application = new SpringApplication();
		application.setApplicationStartup(new BufferingApplicationStartup(1024));
		return application;
	}
}
/*
package smoketest.jersey;
@SpringBootApplication
public class SampleJerseyApplication extends SpringBootServletInitializer {
	public static void main(String[] args) {
		new SampleJerseyApplication()
			.configure(new SpringApplicationBuilder(SampleJerseyApplication.class)
				.applicationStartup(new BufferingApplicationStartup(2048)))
			.run(args);
	}
}
/*
package smoketest.jersey;
@Component
public class JerseyConfig extends ResourceConfig {
	public JerseyConfig() {
		register(Endpoint.class);
		register(ReverseEndpoint.class);
	}
}
/*
package smoketest.jersey;
@Component
@Path('/hello')
public class Endpoint {
	private final Service service;
	public Endpoint(Service service) {
		this.service = service;
	}
	@GET
	public String message() {
		return 'Hello ' + this.service.message();
	}
}
/*
package smoketest.jersey;
@Component
public class Service {
	@Value('${message:World}')
	private String msg;
	public String message() {
		return this.msg;
	}
}
/*
package smoketest.jersey;
@Component
@Path('/reverse')
public class ReverseEndpoint {
	@GET
	public String reverse(@QueryParam('input') @NotNull String input) {
		return new StringBuilder(input).reverse().toString();
	}
}
/*
package smoketest.flyway;
@SpringBootTest
class SampleFlywayApplicationTests {
	@Autowired
	private JdbcTemplate template;
	@Test
	void testDefaultSettings() {
		assertThat(this.template.queryForObject('SELECT COUNT(*) from PERSON', Integer.class)).isEqualTo(2);
	}
}
/*
package smoketest.flyway;
@Entity
public class Person {
	@Id
	@SequenceGenerator(name = 'person_generator', sequenceName = 'person_sequence', allocationSize = 1)
	@GeneratedValue(generator = 'person_generator')
	private Long id;
	private String firstName;
	private String lastName;
	public String getFirstName() {
		return this.firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public String getLastName() {
		return this.lastName;
	}
	public void setLastName(String lastname) {
		this.lastName = lastname;
	}
	@Override
	public String toString() {
		return 'Person [firstName=' + this.firstName + ', lastName=' + this.lastName + ']';
	}
}
/*
package smoketest.flyway;
@Repository
public interface PersonRepository extends CrudRepository<Person, Long> {
}
/*
package smoketest.flyway;
@SpringBootApplication
public class SampleFlywayApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleFlywayApplication.class, args);
	}
	@Bean
	public CommandLineRunner runner(PersonRepository repository) {
		return (args) -> System.err.println(repository.findAll());
	}
}
/*
package smoketest.bootstrapregistry.app;
/**
@ExtendWith(OutputCaptureExtension.class)
class SampleBootstrapRegistryApplicationTests {
	@Test
	void testBootstrapper(CapturedOutput output) {
		SampleBootstrapRegistryApplication.main(new String[0]);
		assertThat(output).contains('svn my-data from svn / example.com[secret]')
			.contains('client smoketest.bootstrapregistry.app.MySubversionClient');
	}
}
/*
package smoketest.bootstrapregistry.app;
@SpringBootApplication
public class SampleBootstrapRegistryApplication {
	public static void main(String[] args) {
		// This example shows how a Bootstrapper can be used to register a custom
		// SubversionClient that still has access to data provided in the
		// application.properties file
		SpringApplication application = new SpringApplication(SampleBootstrapRegistryApplication.class);
		application.addBootstrapRegistryInitializer(SubversionBootstrap.withCustomClient(MySubversionClient::new));
		application.run(args);
	}
}
/*
package smoketest.bootstrapregistry.app;
@Component
public class Printer {
	Printer(@Value('${svn}') String svn, SubversionClient subversionClient) {
		System.out.println('--- svn ' + svn);
		System.out.println('--- client ' + subversionClient.getClass().getName());
	}
}
/*
package smoketest.bootstrapregistry.app;
public class MySubversionClient extends SubversionClient {
	public MySubversionClient(SubversionServerCertificate serverCertificate) {
		super(serverCertificate);
	}
	@Override
	public String load(String location) {
		return 'my-' + super.load(location);
	}
}
/*
package smoketest.bootstrapregistry.external.svn;
/**
class SubversionConfigDataLoader implements ConfigDataLoader<SubversionConfigDataResource> {
	private static final ApplicationListener<BootstrapContextClosedEvent> closeListener = SubversionConfigDataLoader::onBootstrapContextClosed;
	SubversionConfigDataLoader(BootstrapRegistry bootstrapRegistry) {
		bootstrapRegistry.registerIfAbsent(SubversionClient.class, this::createSubversionClient);
		bootstrapRegistry.addCloseListener(closeListener);
	}
	private SubversionClient createSubversionClient(BootstrapContext bootstrapContext) {
		return new SubversionClient(bootstrapContext.get(SubversionServerCertificate.class));
	}
	@Override
	public ConfigData load(ConfigDataLoaderContext context, SubversionConfigDataResource resource)
			throws IOException, ConfigDataLocationNotFoundException {
		context.getBootstrapContext()
			.registerIfAbsent(SubversionServerCertificate.class, InstanceSupplier.of(resource.getServerCertificate()));
		SubversionClient client = context.getBootstrapContext().get(SubversionClient.class);
		String loaded = client.load(resource.getLocation());
		PropertySource<?> propertySource = new MapPropertySource('svn', Collections.singletonMap('svn', loaded));
		return new ConfigData(Collections.singleton(propertySource));
	}
	private static void onBootstrapContextClosed(BootstrapContextClosedEvent event) {
		event.getApplicationContext()
			.getBeanFactory()
			.registerSingleton('subversionClient', event.getBootstrapContext().get(SubversionClient.class));
	}
}
/*
package smoketest.bootstrapregistry.external.svn;
/**
public final class SubversionBootstrap {
	private SubversionBootstrap() {
	}
	/**
	 * Return a {@link BootstrapRegistryInitializer} for the given client factory.
	 * @param clientFactory the client factory
	 * @return a {@link BootstrapRegistryInitializer} instance
	 */
	public static BootstrapRegistryInitializer withCustomClient(
			Function<SubversionServerCertificate, SubversionClient> clientFactory) {
		return (registry) -> registry.register(SubversionClient.class,
				(bootstrapContext) -> createSubversionClient(bootstrapContext, clientFactory));
	}
	private static SubversionClient createSubversionClient(BootstrapContext bootstrapContext,
			Function<SubversionServerCertificate, SubversionClient> clientFactory) {
		return clientFactory.apply(bootstrapContext.get(SubversionServerCertificate.class));
	}
}
/*
package smoketest.bootstrapregistry.external.svn;
/**
public class SubversionClient {
	private final SubversionServerCertificate serverCertificate;
	public SubversionClient(SubversionServerCertificate serverCertificate) {
		this.serverCertificate = serverCertificate;
	}
	public String load(String location) {
		return 'data from svn / ' + location + '[' + this.serverCertificate + ']';
	}
}
/*
package smoketest.bootstrapregistry.external.svn;
/**
public class SubversionServerCertificate {
	private final String data;
	SubversionServerCertificate(String data) {
		this.data = data;
	}
	@Override
	public String toString() {
		return this.data;
	}
	public static SubversionServerCertificate of(String data) {
		return StringUtils.hasText(data) ? new SubversionServerCertificate(data) : null;
	}
}
/*
package smoketest.bootstrapregistry.external.svn;
/**
class SubversionConfigDataLocationResolver implements ConfigDataLocationResolver<SubversionConfigDataResource> {
	private static final String PREFIX = 'svn:';
	@Override
	public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
		return location.hasPrefix(PREFIX);
	}
	@Override
	public List<SubversionConfigDataResource> resolve(ConfigDataLocationResolverContext context,
			ConfigDataLocation location)
			throws ConfigDataLocationNotFoundException, ConfigDataResourceNotFoundException {
		String serverCertificate = context.getBinder().bind('spring.svn.server.certificate', String.class).orElse(null);
		return Collections
			.singletonList(new SubversionConfigDataResource(location.getNonPrefixedValue(PREFIX), serverCertificate));
	}
}
/*
package smoketest.bootstrapregistry.external.svn;
/**
class SubversionConfigDataResource extends ConfigDataResource {
	private final String location;
	private final SubversionServerCertificate serverCertificate;
	SubversionConfigDataResource(String location, String serverCertificate) {
		this.location = location;
		this.serverCertificate = SubversionServerCertificate.of(serverCertificate);
	}
	String getLocation() {
		return this.location;
	}
	SubversionServerCertificate getServerCertificate() {
		return this.serverCertificate;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		SubversionConfigDataResource other = (SubversionConfigDataResource) obj;
		return this.location.equals(other.location);
	}
	@Override
	public int hashCode() {
		return this.location.hashCode();
	}
	@Override
	public String toString() {
		return this.location;
	}
}
/*
/**
package smoketest.bootstrapregistry.external.svn;
/*
package smoketest.tomcat.jsp;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebJspApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testJspWithEl() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('/resources/text.txt');
	}
}
/*
package smoketest.tomcat.jsp;
@SpringBootApplication
public class SampleTomcatJspApplication extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleTomcatJspApplication.class);
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleTomcatJspApplication.class, args);
	}
}
/*
package smoketest.tomcat.jsp;
public class MyException extends RuntimeException {
	public MyException(String message) {
		super(message);
	}
}
/*
package smoketest.tomcat.jsp;
@Controller
public class WelcomeController {
	@Value('${application.message:Hello World}')
	private String message = 'Hello World';
	@GetMapping('/')
	public String welcome(Map<String, Object> model) {
		model.put('time', new Date());
		model.put('message', this.message);
		return 'welcome';
	}
	@RequestMapping('/fail')
	public String fail() {
		throw new MyException('Oh dear!');
	}
	@RequestMapping('/fail2')
	public String fail2() {
		throw new IllegalStateException();
	}
	@ExceptionHandler(MyException.class)
	@ResponseStatus(HttpStatus.BAD_REQUEST)
	public @ResponseBody MyRestResponse handleMyRuntimeException(MyException exception) {
		return new MyRestResponse('Some data I want to send back to the client.');
	}
}
/*
package smoketest.tomcat.jsp;
public class MyRestResponse {
	private final String message;
	public MyRestResponse(String message) {
		this.message = message;
	}
	public String getMessage() {
		return this.message;
	}
}
/*
package smoketest.session.mongodb;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers(disabledWithoutDocker = true)
class SampleSessionMongoApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@LocalServerPort
	private int port;
	@Container
	@ServiceConnection
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	@Test
	@SuppressWarnings('unchecked')
	void sessionsEndpointShouldReturnUserSessions() {
		performLogin();
		ResponseEntity<Map<String, Object>> response = getSessions();
		assertThat(response).isNotNull();
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		List<Map<String, Object>> sessions = (List<Map<String, Object>>) response.getBody().get('sessions');
		assertThat(sessions).hasSize(1);
	}
	private String performLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'password');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		return entity.getHeaders().getFirst('Set-Cookie');
	}
	private RequestEntity<Object> getRequestEntity(URI uri) {
		HttpHeaders headers = new HttpHeaders();
		headers.setBasicAuth('user', 'password');
		return new RequestEntity<>(headers, HttpMethod.GET, uri);
	}
	private ResponseEntity<Map<String, Object>> getSessions() {
		RequestEntity<Object> request = getRequestEntity(URI.create('/actuator/sessions?username=user'));
		ParameterizedTypeReference<Map<String, Object>> stringObjectMap = new ParameterizedTypeReference<>() {
		};
		return this.restTemplate.exchange(request, stringObjectMap);
	}
}
/*
package smoketest.session.mongodb;
/**
@Configuration(proxyBeanMethods = false)
class SecurityConfiguration {
	@Bean
	SecurityFilterChain managementSecurityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> {
			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class)).permitAll();
			requests.anyRequest().authenticated();
		});
		http.formLogin(withDefaults());
		http.httpBasic(withDefaults());
		http.csrf(CsrfConfigurer::disable);
		return http.build();
	}
}
/*
package smoketest.session.mongodb;
@SpringBootApplication
@EnableMongoHttpSession
public class SampleSessionMongoApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSessionMongoApplication.class);
	}
}
/*
package smoketest.mustache;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebMustacheApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testMustacheTemplate() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('Hello, Andy');
	}
	@Test
	void testMustacheErrorTemplate() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		HttpEntity<String> requestEntity = new HttpEntity<>(headers);
		ResponseEntity<String> responseEntity = this.restTemplate.exchange('/does-not-exist', HttpMethod.GET,
				requestEntity, String.class);
		assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		assertThat(responseEntity.getBody()).contains('Something went wrong: 404 Not Found');
	}
	@Test
	void test503HtmlResource() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		HttpEntity<String> requestEntity = new HttpEntity<>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/serviceUnavailable', HttpMethod.GET, requestEntity,
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.SERVICE_UNAVAILABLE);
		assertThat(entity.getBody()).contains('I"m a 503');
	}
	@Test
	void test5xxHtmlResource() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		HttpEntity<String> requestEntity = new HttpEntity<>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/bang', HttpMethod.GET, requestEntity,
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(entity.getBody()).contains('I"m a 5xx');
	}
	@Test
	void test507Template() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		HttpEntity<String> requestEntity = new HttpEntity<>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/insufficientStorage', HttpMethod.GET,
				requestEntity, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INSUFFICIENT_STORAGE);
		assertThat(entity.getBody()).contains('I"m a 507');
	}
}
/*
package smoketest.mustache;
@SpringBootApplication
public class SampleWebMustacheApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleWebMustacheApplication.class, args);
	}
}
/*
package smoketest.mustache;
@Controller
public class WelcomeController {
	@Value('${application.message:Hello World}')
	private String message = 'Hello World';
	@GetMapping('/')
	public String welcome(Map<String, Object> model) {
		model.put('time', new Date());
		model.put('message', this.message);
		return 'welcome';
	}
	@RequestMapping('/serviceUnavailable')
	public String ServiceUnavailable() {
		throw new ServiceUnavailableException();
	}
	@RequestMapping('/bang')
	public String bang() {
		throw new RuntimeException('Boom');
	}
	@RequestMapping('/insufficientStorage')
	public String insufficientStorage() {
		throw new InsufficientStorageException();
	}
	@ResponseStatus(HttpStatus.SERVICE_UNAVAILABLE)
	private static final class ServiceUnavailableException extends RuntimeException {
	}
	@ResponseStatus(HttpStatus.INSUFFICIENT_STORAGE)
	private static final class InsufficientStorageException extends RuntimeException {
	}
}
/*
package smoketest.session;
/**
@SpringBootTest(properties = 'spring.session.timeout:10', webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers(disabledWithoutDocker = true)
class SampleSessionWebFluxRedisApplicationTests {
	@Container
	@ServiceConnection
	private static final RedisContainer redis = TestImage.container(RedisContainer.class);
	@LocalServerPort
	private int port;
	@Autowired
	private WebClient.Builder webClientBuilder;
	@Test
	void userDefinedMappingsSecureByDefault() {
		WebClient client = this.webClientBuilder.baseUrl('http://localhost:' + this.port + '/').build();
		client.get().header('Authorization', getBasicAuth()).exchangeToMono((response) -> {
			assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
			return response.bodyToMono(String.class)
				.map((sessionId) -> Tuples.of(response.cookies().getFirst('SESSION').getValue(), sessionId));
		}).flatMap((tuple) -> {
			String sessionCookie = tuple.getT1();
			return client.get().cookie('SESSION', sessionCookie).exchangeToMono((response) -> {
				assertThat(response.statusCode()).isEqualTo(HttpStatus.OK);
				return response.bodyToMono(String.class)
					.doOnNext((sessionId) -> assertThat(sessionId).isEqualTo(tuple.getT2()))
					.thenReturn(sessionCookie);
			});
		})
			.delayElement(Duration.ofSeconds(10))
			.flatMap((sessionCookie) -> client.get().cookie('SESSION', sessionCookie).exchangeToMono((response) -> {
				assertThat(response.statusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
				return response.releaseBody();
			}))
			.block(Duration.ofSeconds(30));
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
}
/*
package smoketest.session;
@RestController
public class HelloRestController {
	@GetMapping('/')
	String sessionId(WebSession session) {
		return session.getId();
	}
}
/*
package smoketest.session;
@SpringBootApplication
public class SampleSessionWebFluxRedisApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSessionWebFluxRedisApplication.class);
	}
	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
		http.authorizeExchange((exchange) -> exchange.anyExchange().authenticated());
		http.httpBasic((basic) -> basic.securityContextRepository(new WebSessionServerSecurityContextRepository()));
		http.formLogin(withDefaults());
		return http.build();
	}
}
/*
package smoketest.activemq;
/**
@SpringBootTest
@Testcontainers(disabledWithoutDocker = true)
@ExtendWith(OutputCaptureExtension.class)
class SampleActiveMqTests {
	@Container
	@ServiceConnection
	private static final ActiveMQContainer container = TestImage.container(ActiveMQContainer.class);
	@Autowired
	private Producer producer;
	@Test
	void sendSimpleMessage(CapturedOutput output) {
		this.producer.send('Test message');
		Awaitility.waitAtMost(Duration.ofMinutes(1)).untilAsserted(() -> assertThat(output).contains('Test message'));
	}
}
/*
package smoketest.activemq;
@Component
public class Producer implements CommandLineRunner {
	@Autowired
	private JmsMessagingTemplate jmsMessagingTemplate;
	@Autowired
	private Queue queue;
	@Override
	public void run(String... args) throws Exception {
		send('Sample message');
		System.out.println('Message was sent to the Queue');
	}
	public void send(String msg) {
		this.jmsMessagingTemplate.convertAndSend(this.queue, msg);
	}
}
/*
package smoketest.activemq;
@SpringBootApplication
@EnableJms
public class SampleActiveMQApplication {
	@Bean
	public Queue queue() {
		return new ActiveMQQueue('sample.queue');
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleActiveMQApplication.class, args);
	}
}
/*
package smoketest.activemq;
@Component
public class Consumer {
	@JmsListener(destination = 'sample.queue')
	public void receiveQueue(String text) {
		System.out.println(text);
	}
}
/*
package smoketest.session.redis;
public class TestPropertiesSampleSessionRedisApplication {
	public static void main(String[] args) {
		SpringApplication.from(SampleSessionRedisApplication::main).with(ContainerConfiguration.class).run(args);
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class ContainerConfiguration {
		@Bean
		RedisContainer redisContainer(DynamicPropertyRegistry properties) {
			RedisContainer container = TestImage.container(RedisContainer.class);
			properties.add('spring.data.redis.host', container::getHost);
			properties.add('spring.data.redis.port', container::getFirstMappedPort);
			return container;
		}
	}
}
/*
package smoketest.session.redis;
public class TestServiceConnectionSampleSessionRedisApplication {
	public static void main(String[] args) {
		SpringApplication.from(SampleSessionRedisApplication::main).with(ContainerConfiguration.class).run(args);
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class ContainerConfiguration {
		@Bean
		@ServiceConnection
		RedisContainer redisContainer() {
			return TestImage.container(RedisContainer.class);
		}
	}
}
/*
package smoketest.session.redis;
public class TestPropertiesImportSampleSessionRedisApplication {
	public static void main(String[] args) {
		SpringApplication.from(SampleSessionRedisApplication::main).with(ContainerConfiguration.class).run(args);
	}
	@ImportTestcontainers
	static class ContainerConfiguration {
		static RedisContainer container = TestImage.container(RedisContainer.class);
		@DynamicPropertySource
		static void containerProperties(DynamicPropertyRegistry properties) {
			properties.add('spring.data.redis.host', container::getHost);
			properties.add('spring.data.redis.port', container::getFirstMappedPort);
		}
	}
}
/*
package smoketest.session.redis;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@Testcontainers(disabledWithoutDocker = true)
class SampleSessionRedisApplicationTests {
	@Container
	@ServiceConnection
	static RedisContainer redis = TestImage.container(RedisContainer.class);
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	@SuppressWarnings('unchecked')
	void sessionsEndpointShouldReturnUserSessions() {
		performLogin();
		ResponseEntity<Map<String, Object>> response = getSessions();
		assertThat(response).isNotNull();
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		List<Map<String, Object>> sessions = (List<Map<String, Object>>) response.getBody().get('sessions');
		assertThat(sessions).hasSize(1);
	}
	private String performLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'password');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		return entity.getHeaders().getFirst('Set-Cookie');
	}
	private RequestEntity<Object> getRequestEntity(URI uri) {
		HttpHeaders headers = new HttpHeaders();
		headers.setBasicAuth('user', 'password');
		return new RequestEntity<>(headers, HttpMethod.GET, uri);
	}
	private ResponseEntity<Map<String, Object>> getSessions() {
		RequestEntity<Object> request = getRequestEntity(URI.create('/actuator/sessions?username=user'));
		ParameterizedTypeReference<Map<String, Object>> stringObjectMap = new ParameterizedTypeReference<>() {
		};
		return this.restTemplate.exchange(request, stringObjectMap);
	}
}
/*
package smoketest.session.redis;
public class TestServiceConnectionImportSampleSessionRedisApplication {
	public static void main(String[] args) {
		SpringApplication.from(SampleSessionRedisApplication::main).with(ContainerConfiguration.class).run(args);
	}
	@ImportTestcontainers
	static class ContainerConfiguration {
		@ServiceConnection // We don"t need a name here because we have the container
		static RedisContainer redisContainer = TestImage.container(RedisContainer.class);
	}
}
/*
package smoketest.session.redis;
@SpringBootApplication
public class SampleSessionRedisApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSessionRedisApplication.class);
	}
}
/*
package smoketest.session.redis;
/**
@Configuration(proxyBeanMethods = false)
class SecurityConfiguration {
	@Bean
	SecurityFilterChain managementSecurityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> {
			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class)).permitAll();
			requests.anyRequest().authenticated();
		});
		http.formLogin(withDefaults());
		http.httpBasic(withDefaults());
		http.csrf(CsrfConfigurer::disable);
		return http.build();
	}
}
/*
package smoketest.undertow;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleUndertowApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		assertOkResponse('/', 'Hello World');
	}
	@Test
	void testAsync() {
		assertOkResponse('/async', 'async: Hello World');
	}
	@Test
	void testCompression() throws Exception {
		HttpHeaders requestHeaders = new HttpHeaders();
		requestHeaders.set('Accept-Encoding', 'gzip');
		HttpEntity<?> requestEntity = new HttpEntity<>(requestHeaders);
		ResponseEntity<byte[]> entity = this.restTemplate.exchange('/', HttpMethod.GET, requestEntity, byte[].class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		try (GZIPInputStream inflater = new GZIPInputStream(new ByteArrayInputStream(entity.getBody()))) {
			assertThat(StreamUtils.copyToString(inflater, StandardCharsets.UTF_8)).isEqualTo('Hello World');
		}
	}
	private void assertOkResponse(String path, String body) {
		ResponseEntity<String> entity = this.restTemplate.getForEntity(path, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo(body);
	}
}
/*
package smoketest.undertow.web;
@RestController
public class SampleController {
	@GetMapping('/')
	public String helloWorld() {
		return 'Hello World';
	}
	@GetMapping('/async')
	public Callable<String> helloWorldAsync() {
		return () -> 'async: Hello World';
	}
}
/*
package smoketest.undertow;
@SpringBootApplication
public class SampleUndertowApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleUndertowApplication.class, args);
	}
}
/*
package smoketest.oauth2.client;
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'APP-CLIENT-ID=my-client-id', 'APP-CLIENT-SECRET=my-client-secret',
				'YAHOO-CLIENT-ID=my-google-client-id', 'YAHOO-CLIENT-SECRET=my-google-client-secret' })
class SampleReactiveOAuth2ClientApplicationTests {
	@Autowired
	private WebTestClient webTestClient;
	@Test
	void everythingShouldRedirectToLogin() {
		this.webTestClient.get()
			.uri('/')
			.exchange()
			.expectStatus()
			.isFound()
			.expectHeader()
			.valueEquals('Location', '/login');
	}
	@Test
	void loginShouldHaveBothOAuthClientsToChooseFrom() {
		byte[] body = this.webTestClient.get()
			.uri('/login')
			.exchange()
			.expectStatus()
			.isOk()
			.returnResult(String.class)
			.getResponseBodyContent();
		String bodyString = new String(body);
		assertThat(bodyString).contains('/oauth2/authorization/yahoo');
		assertThat(bodyString).contains('/oauth2/authorization/github-client-1');
		assertThat(bodyString).contains('/oauth2/authorization/github-client-2');
	}
	@Test
	void actuatorShouldBeSecuredByOAuth() {
		this.webTestClient.get()
			.uri('/actuator/health')
			.exchange()
			.expectStatus()
			.isFound()
			.expectHeader()
			.valueEquals('Location', '/login');
	}
}
/*
package smoketest.oauth2.client;
@RestController
public class ExampleController {
	@RequestMapping('/')
	public String email(Principal principal) {
		return 'Hello ' + principal.getName();
	}
}
/*
package smoketest.oauth2.client;
@SpringBootApplication
public class SampleReactiveOAuth2ClientApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleReactiveOAuth2ClientApplication.class);
	}
}
/*
package smoketest.kafka.ssl;
/**
@Testcontainers(disabledWithoutDocker = true)
@SpringBootTest(classes = { SampleKafkaSslApplication.class, Producer.class, Consumer.class },
		properties = { 'spring.kafka.security.protocol=SSL',
				'spring.kafka.properties.ssl.endpoint.identification.algorithm=', 'spring.kafka.ssl.bundle=client',
				'spring.ssl.bundle.jks.client.keystore.location=classpath:ssl/test-client.p12',
				'spring.ssl.bundle.jks.client.keystore.password=password',
				'spring.ssl.bundle.jks.client.truststore.location=classpath:ssl/test-ca.p12',
				'spring.ssl.bundle.jks.client.truststore.password=password' })
class SampleKafkaSslApplicationTests {
	@Container
	public static ConfluentKafkaContainer kafka = TestImage.container(ConfluentKafkaContainer.class)
		.withEnv('KAFKA_LISTENER_SECURITY_PROTOCOL_MAP', 'PLAINTEXT:SSL,BROKER:PLAINTEXT,CONTROLLER:PLAINTEXT')
		.withEnv('KAFKA_AUTO_CREATE_TOPICS_ENABLE', 'true')
		.withEnv('KAFKA_SSL_CLIENT_AUTH', 'required')
		.withEnv('KAFKA_SSL_KEYSTORE_LOCATION', '/etc/kafka/secrets/certs/test-server.p12')
		.withEnv('KAFKA_SSL_KEYSTORE_PASSWORD', 'password')
		.withEnv('KAFKA_SSL_KEY_PASSWORD', 'password')
		.withEnv('KAFKA_SSL_TRUSTSTORE_LOCATION', '/etc/kafka/secrets/certs/test-ca.p12')
		.withEnv('KAFKA_SSL_TRUSTSTORE_PASSWORD', 'password')
		.withEnv('KAFKA_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM', '')
		.withCopyFileToContainer(MountableFile.forClasspathResource('ssl/test-server.p12'),
				'/etc/kafka/secrets/certs/test-server.p12')
		.withCopyFileToContainer(MountableFile.forClasspathResource('ssl/credentials'),
				'/etc/kafka/secrets/certs/credentials')
		.withCopyFileToContainer(MountableFile.forClasspathResource('ssl/test-ca.p12'),
				'/etc/kafka/secrets/certs/test-ca.p12');
	@DynamicPropertySource
	static void kafkaProperties(DynamicPropertyRegistry registry) {
		registry.add('spring.kafka.bootstrap-servers',
				() -> String.format('%s:%s', kafka.getHost(), kafka.getMappedPort(9092)));
	}
	@Autowired
	private Producer producer;
	@Autowired
	private Consumer consumer;
	@Test
	void testVanillaExchange() {
		this.producer.send(new SampleMessage(1, 'A simple test message'));
		Awaitility.waitAtMost(Duration.ofSeconds(30)).until(this.consumer::getMessages, not(empty()));
		assertThat(this.consumer.getMessages()).extracting('message').containsOnly('A simple test message');
	}
}
/*
package smoketest.kafka;
/**
@DisabledOnOs(OS.WINDOWS)
@SpringBootTest(properties = 'spring.kafka.bootstrap-servers=${spring.embedded.kafka.brokers}')
@EmbeddedKafka(topics = 'testTopic')
class SampleKafkaApplicationTests {
	@Autowired
	private Consumer consumer;
	@Test
	void testVanillaExchange() {
		Awaitility.waitAtMost(Duration.ofSeconds(30)).until(this.consumer::getMessages, not(empty()));
		assertThat(this.consumer.getMessages()).extracting('message').containsOnly('A simple test message');
	}
}
/*
package smoketest.kafka.ssl;
@SpringBootApplication
public class SampleKafkaSslApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleKafkaSslApplication.class, args);
	}
}
/*
package smoketest.kafka;
@SpringBootApplication
public class SampleKafkaApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleKafkaApplication.class, args);
	}
	@Bean
	public NewTopic kafkaTestTopic() {
		return new NewTopic('testTopic', 10, (short) 2);
	}
	@Bean
	public ApplicationRunner runner(Producer producer) {
		return (args) -> producer.send(new SampleMessage(1, 'A simple test message'));
	}
}
/*
package smoketest.kafka;
@Component
public class Producer {
	private final KafkaTemplate<Object, SampleMessage> kafkaTemplate;
	Producer(KafkaTemplate<Object, SampleMessage> kafkaTemplate) {
		this.kafkaTemplate = kafkaTemplate;
	}
	public void send(SampleMessage message) {
		this.kafkaTemplate.send('testTopic', message);
		System.out.println('Sent sample message [' + message + ']');
	}
}
/*
package smoketest.kafka;
public class SampleMessage {
	private final Integer id;
	private final String message;
	@JsonCreator
	public SampleMessage(@JsonProperty('id') Integer id, @JsonProperty('message') String message) {
		this.id = id;
		this.message = message;
	}
	public Integer getId() {
		return this.id;
	}
	public String getMessage() {
		return this.message;
	}
	@Override
	public String toString() {
		return 'SampleMessage{id=' + this.id + ', message="' + this.message + '"}';
	}
}
/*
package smoketest.kafka;
@Component
public class Consumer {
	private final List<SampleMessage> messages = new CopyOnWriteArrayList<>();
	@KafkaListener(topics = 'testTopic')
	void processMessage(SampleMessage message) {
		this.messages.add(message);
		System.out.println('Received sample message [' + message + ']');
	}
	public List<SampleMessage> getMessages() {
		return this.messages;
	}
}
/*
package smoketest.jetty.ssl;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleJettySslApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private AbstractConfigurableWebServerFactory webServerFactory;
	@Test
	void testSsl() {
		assertThat(this.webServerFactory.getSsl().isEnabled()).isTrue();
	}
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
}
/*
package smoketest.jetty.ssl.web;
@RestController
public class SampleController {
	@GetMapping('/')
	public String helloWorld() {
		return 'Hello World';
	}
}
/*
package smoketest.jetty.ssl;
@SpringBootApplication
public class SampleJettySslApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleJettySslApplication.class, args);
	}
}
/*
package smoketest.web.secure.jdbc;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebSecureJdbcApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@LocalServerPort
	private int port;
	@Test
	void testHome() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, new HttpEntity<Void>(headers),
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation().toString()).endsWith(this.port + '/login');
	}
	@Test
	void testLoginPage() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.GET,
				new HttpEntity<Void>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('<title>Login</title>');
	}
	@Test
	void testLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'user');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation().toString()).endsWith(this.port + '/');
	}
}
/*
package smoketest.web.secure.jdbc;
@SpringBootApplication
public class SampleWebSecureJdbcApplication implements WebMvcConfigurer {
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController('/').setViewName('home');
		registry.addViewController('/login').setViewName('login');
	}
	public static void main(String[] args) {
		new SpringApplicationBuilder(SampleWebSecureJdbcApplication.class).run(args);
	}
	@Configuration(proxyBeanMethods = false)
	protected static class ApplicationSecurity {
		@Bean
		SecurityFilterChain configure(HttpSecurity http) throws Exception {
			http.csrf(CsrfConfigurer::disable);
			http.authorizeHttpRequests((requests) -> {
				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll();
				requests.anyRequest().fullyAuthenticated();
			});
			http.formLogin((form) -> form.loginPage('/login').permitAll());
			return http.build();
		}
		@Bean
		public JdbcUserDetailsManager jdbcUserDetailsManager(DataSource dataSource) {
			JdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager();
			jdbcUserDetailsManager.setDataSource(dataSource);
			return jdbcUserDetailsManager;
		}
	}
}
/*
package smoketest;
@RunWith(SpringRunner.class)
@WebMvcTest
public class SampleJUnitVintageApplicationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	public void testMessage() {
		assertThat(this.mvc.get().uri('/hi')).hasBodyTextEqualTo('Hello World');
	}
}
/*
package smoketest;
@RestController
public class MessageController {
	@GetMapping('/hi')
	public String hello() {
		return 'Hello World';
	}
}
/*
package smoketest;
@SpringBootApplication
public class SampleJUnitVintageApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleJUnitVintageApplication.class, args);
	}
}
/*
package smoketest.websocket.jetty.echo;
@SpringBootTest(classes = { SampleJettyWebSocketsApplication.class, CustomContainerConfiguration.class },
		webEnvironment = WebEnvironment.RANDOM_PORT)
class CustomContainerWebSocketsApplicationTests {
	private static final Log logger = LogFactory.getLog(CustomContainerWebSocketsApplicationTests.class);
	@LocalServerPort
	private int port;
	@Test
	void echoEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/ws/echo/websocket')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Did you say \'Hello world!\'?');
	}
	@Test
	void reverseEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/ws/reverse')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Reversed: !dlrow olleH');
	}
	@Configuration(proxyBeanMethods = false)
	protected static class CustomContainerConfiguration {
		@Bean
		public ServletWebServerFactory webServerFactory() {
			return new JettyServletWebServerFactory('/ws', 0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClientConfiguration implements CommandLineRunner {
		@Value('${websocket.uri}')
		private String webSocketUri;
		private final CountDownLatch latch = new CountDownLatch(1);
		private final AtomicReference<String> messagePayload = new AtomicReference<>();
		@Override
		public void run(String... args) throws Exception {
			logger.info('Waiting for response: latch=' + this.latch.getCount());
			if (this.latch.await(10, TimeUnit.SECONDS)) {
				logger.info('Got response: ' + this.messagePayload.get());
			}
			else {
				logger.info('Response not received: latch=' + this.latch.getCount());
			}
		}
		@Bean
		WebSocketConnectionManager wsConnectionManager() {
			WebSocketConnectionManager manager = new WebSocketConnectionManager(client(), handler(), this.webSocketUri);
			manager.setAutoStartup(true);
			return manager;
		}
		@Bean
		StandardWebSocketClient client() {
			return new StandardWebSocketClient();
		}
		@Bean
		SimpleClientWebSocketHandler handler() {
			return new SimpleClientWebSocketHandler(greetingService(), this.latch, this.messagePayload);
		}
		@Bean
		GreetingService greetingService() {
			return new SimpleGreetingService();
		}
	}
}
/*
package smoketest.websocket.jetty;
@SpringBootTest(classes = SampleJettyWebSocketsApplication.class, webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebSocketsApplicationTests {
	private static final Log logger = LogFactory.getLog(SampleWebSocketsApplicationTests.class);
	@LocalServerPort
	private int port = 1234;
	@Test
	void echoEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/echo/websocket')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Did you say \'Hello world!\'?');
	}
	@Test
	void reverseEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/reverse')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Reversed: !dlrow olleH');
	}
	@Configuration(proxyBeanMethods = false)
	static class ClientConfiguration implements CommandLineRunner {
		@Value('${websocket.uri}')
		private String webSocketUri;
		private final CountDownLatch latch = new CountDownLatch(1);
		private final AtomicReference<String> messagePayload = new AtomicReference<>();
		@Override
		public void run(String... args) throws Exception {
			logger.info('Waiting for response: latch=' + this.latch.getCount());
			if (this.latch.await(10, TimeUnit.SECONDS)) {
				logger.info('Got response: ' + this.messagePayload.get());
			}
			else {
				logger.info('Response not received: latch=' + this.latch.getCount());
			}
		}
		@Bean
		WebSocketConnectionManager wsConnectionManager() {
			WebSocketConnectionManager manager = new WebSocketConnectionManager(client(), handler(), this.webSocketUri);
			manager.setAutoStartup(true);
			return manager;
		}
		@Bean
		StandardWebSocketClient client() {
			return new StandardWebSocketClient();
		}
		@Bean
		SimpleClientWebSocketHandler handler() {
			return new SimpleClientWebSocketHandler(greetingService(), this.latch, this.messagePayload);
		}
		@Bean
		GreetingService greetingService() {
			return new SimpleGreetingService();
		}
	}
}
/*
package smoketest.websocket.jetty.snake;
class SnakeTimerTests {
	@Test
	void removeDysfunctionalSnakes() throws Exception {
		Snake snake = mock(Snake.class);
		willThrow(new IOException()).given(snake).sendMessage(anyString());
		SnakeTimer.addSnake(snake);
		SnakeTimer.broadcast('');
		assertThat(SnakeTimer.getSnakes()).isEmpty();
	}
}
/*
package smoketest.websocket.jetty.reverse;
@ServerEndpoint('/reverse')
public class ReverseWebSocketEndpoint {
	@OnMessage
	public void handleMessage(Session session, String message) throws IOException {
		session.getBasicRemote().sendText('Reversed: ' + new StringBuilder(message).reverse());
	}
}
/*
package smoketest.websocket.jetty.echo;
public interface EchoService {
	String getMessage(String message);
}
/*
package smoketest.websocket.jetty.echo;
/**
public class EchoWebSocketHandler extends TextWebSocketHandler {
	private static final Log logger = LogFactory.getLog(EchoWebSocketHandler.class);
	private final EchoService echoService;
	public EchoWebSocketHandler(EchoService echoService) {
		this.echoService = echoService;
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) {
		logger.debug('Opened new session in instance ' + this);
	}
	@Override
	public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		String echoMessage = this.echoService.getMessage(message.getPayload());
		logger.debug(echoMessage);
		session.sendMessage(new TextMessage(echoMessage));
	}
	@Override
	public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
		session.close(CloseStatus.SERVER_ERROR);
	}
}
/*
package smoketest.websocket.jetty.echo;
public class DefaultEchoService implements EchoService {
	private final String echoFormat;
	public DefaultEchoService(String echoFormat) {
		this.echoFormat = (echoFormat != null) ? echoFormat : '%s';
	}
	@Override
	public String getMessage(String message) {
		return String.format(this.echoFormat, message);
	}
}
/*
package smoketest.websocket.jetty;
@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@EnableWebSocket
public class SampleJettyWebSocketsApplication extends SpringBootServletInitializer implements WebSocketConfigurer {
	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(echoWebSocketHandler(), '/echo').withSockJS();
		registry.addHandler(snakeWebSocketHandler(), '/snake').withSockJS();
	}
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleJettyWebSocketsApplication.class);
	}
	@Bean
	public EchoService echoService() {
		return new DefaultEchoService('Did you say \'%s\'?');
	}
	@Bean
	public GreetingService greetingService() {
		return new SimpleGreetingService();
	}
	@Bean
	public WebSocketHandler echoWebSocketHandler() {
		return new EchoWebSocketHandler(echoService());
	}
	@Bean
	public WebSocketHandler snakeWebSocketHandler() {
		return new PerConnectionWebSocketHandler(SnakeWebSocketHandler.class);
	}
	@Bean
	public ReverseWebSocketEndpoint reverseWebSocketEndpoint() {
		return new ReverseWebSocketEndpoint();
	}
	@Bean
	public ServerEndpointExporter serverEndpointExporter() {
		return new ServerEndpointExporter();
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleJettyWebSocketsApplication.class, args);
	}
}
/*
package smoketest.websocket.jetty.client;
public class SimpleGreetingService implements GreetingService {
	@Override
	public String getGreeting() {
		return 'Hello world!';
	}
}
/*
package smoketest.websocket.jetty.client;
public interface GreetingService {
	String getGreeting();
}
/*
package smoketest.websocket.jetty.client;
public class SimpleClientWebSocketHandler extends TextWebSocketHandler {
	protected Log logger = LogFactory.getLog(SimpleClientWebSocketHandler.class);
	private final GreetingService greetingService;
	private final CountDownLatch latch;
	private final AtomicReference<String> messagePayload;
	public SimpleClientWebSocketHandler(GreetingService greetingService, CountDownLatch latch,
			AtomicReference<String> message) {
		this.greetingService = greetingService;
		this.latch = latch;
		this.messagePayload = message;
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		TextMessage message = new TextMessage(this.greetingService.getGreeting());
		session.sendMessage(message);
	}
	@Override
	public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		this.logger.info('Received: ' + message + ' (' + this.latch.getCount() + ')');
		session.close();
		this.messagePayload.set(message.getPayload());
		this.latch.countDown();
	}
}
/*
package smoketest.websocket.jetty.snake;
public class Snake {
	private static final int DEFAULT_LENGTH = 5;
	private final Deque<Location> tail = new ArrayDeque<>();
	private final Object monitor = new Object();
	private final int id;
	private final WebSocketSession session;
	private final String hexColor;
	private Direction direction;
	private int length = DEFAULT_LENGTH;
	private Location head;
	public Snake(int id, WebSocketSession session) {
		this.id = id;
		this.session = session;
		this.hexColor = SnakeUtils.getRandomHexColor();
		resetState();
	}
	private void resetState() {
		this.direction = Direction.NONE;
		this.head = SnakeUtils.getRandomLocation();
		this.tail.clear();
		this.length = DEFAULT_LENGTH;
	}
	private void kill() throws Exception {
		synchronized (this.monitor) {
			resetState();
			sendMessage('{"type": "dead"}');
		}
	}
	private void reward() throws Exception {
		synchronized (this.monitor) {
			this.length++;
			sendMessage('{"type": "kill"}');
		}
	}
	protected void sendMessage(String msg) throws Exception {
		this.session.sendMessage(new TextMessage(msg));
	}
	public void update(Collection<Snake> snakes) throws Exception {
		synchronized (this.monitor) {
			Location nextLocation = this.head.getAdjacentLocation(this.direction);
			if (nextLocation.x >= SnakeUtils.PLAYFIELD_WIDTH) {
				nextLocation.x = 0;
			}
			if (nextLocation.y >= SnakeUtils.PLAYFIELD_HEIGHT) {
				nextLocation.y = 0;
			}
			if (nextLocation.x < 0) {
				nextLocation.x = SnakeUtils.PLAYFIELD_WIDTH;
			}
			if (nextLocation.y < 0) {
				nextLocation.y = SnakeUtils.PLAYFIELD_HEIGHT;
			}
			if (this.direction != Direction.NONE) {
				this.tail.addFirst(this.head);
				if (this.tail.size() > this.length) {
					this.tail.removeLast();
				}
				this.head = nextLocation;
			}
			handleCollisions(snakes);
		}
	}
	private void handleCollisions(Collection<Snake> snakes) throws Exception {
		for (Snake snake : snakes) {
			boolean headCollision = this.id != snake.id && snake.getHead().equals(this.head);
			boolean tailCollision = snake.getTail().contains(this.head);
			if (headCollision || tailCollision) {
				kill();
				if (this.id != snake.id) {
					snake.reward();
				}
			}
		}
	}
	public Location getHead() {
		synchronized (this.monitor) {
			return this.head;
		}
	}
	public Collection<Location> getTail() {
		synchronized (this.monitor) {
			return this.tail;
		}
	}
	public void setDirection(Direction direction) {
		synchronized (this.monitor) {
			this.direction = direction;
		}
	}
	public String getLocationsJson() {
		synchronized (this.monitor) {
			StringBuilder sb = new StringBuilder();
			sb.append(String.format('{x: %d, y: %d}', this.head.x, this.head.y));
			for (Location location : this.tail) {
				sb.append(",");
				sb.append(String.format('{x: %d, y: %d}', location.x, location.y));
			}
			return String.format('{"id":%d,"body":[%s]}', this.id, sb);
		}
	}
	public int getId() {
		return this.id;
	}
	public String getHexColor() {
		return this.hexColor;
	}
}
/*
package smoketest.websocket.jetty.snake;
public class Location {
	/**
	 * The X location.
	 */
	public int x;
	/**
	 * The Y location.
	 */
	public int y;
	public Location(int x, int y) {
		this.x = x;
		this.y = y;
	}
	public Location getAdjacentLocation(Direction direction) {
		return switch (direction) {
			case NORTH -> new Location(this.x, this.y - SnakeUtils.GRID_SIZE);
			case SOUTH -> new Location(this.x, this.y + SnakeUtils.GRID_SIZE);
			case EAST -> new Location(this.x + SnakeUtils.GRID_SIZE, this.y);
			case WEST -> new Location(this.x - SnakeUtils.GRID_SIZE, this.y);
			case NONE -> this;
		};
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Location location = (Location) o;
		if (this.x != location.x) {
			return false;
		}
		return this.y == location.y;
	}
	@Override
	public int hashCode() {
		int result = this.x;
		result = 31 * result + this.y;
		return result;
	}
}
/*
package smoketest.websocket.jetty.snake;
/**
public final class SnakeTimer {
	private static final long TICK_DELAY = 100;
	private static final Object MONITOR = new Object();
	private static final Log logger = LogFactory.getLog(SnakeTimer.class);
	private static final ConcurrentHashMap<Integer, Snake> snakes = new ConcurrentHashMap<>();
	private static Timer gameTimer = null;
	private SnakeTimer() {
	}
	public static void addSnake(Snake snake) {
		synchronized (MONITOR) {
			if (snakes.isEmpty()) {
				startTimer();
			}
			snakes.put(snake.getId(), snake);
		}
	}
	public static Collection<Snake> getSnakes() {
		return Collections.unmodifiableCollection(snakes.values());
	}
	public static void removeSnake(Snake snake) {
		synchronized (MONITOR) {
			snakes.remove(snake.getId());
			if (snakes.isEmpty()) {
				stopTimer();
			}
		}
	}
	public static void tick() throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Iterator<Snake> iterator = SnakeTimer.getSnakes().iterator(); iterator.hasNext();) {
			Snake snake = iterator.next();
			snake.update(SnakeTimer.getSnakes());
			sb.append(snake.getLocationsJson());
			if (iterator.hasNext()) {
				sb.append(",");
			}
		}
		broadcast(String.format('{"type": "update", "data" : [%s]}', sb));
	}
	public static void broadcast(String message) {
		Collection<Snake> snakes = new CopyOnWriteArrayList<>(SnakeTimer.getSnakes());
		for (Snake snake : snakes) {
			try {
				snake.sendMessage(message);
			}
			catch (Throwable ex) {
				// if Snake#sendMessage fails the client is removed
				removeSnake(snake);
			}
		}
	}
	public static void startTimer() {
		gameTimer = new Timer(SnakeTimer.class.getSimpleName() + ' Timer');
		gameTimer.scheduleAtFixedRate(new TimerTask() {
			@Override
			public void run() {
				try {
					tick();
				}
				catch (Throwable ex) {
					logger.error('Caught to prevent timer from shutting down', ex);
				}
			}
		}, TICK_DELAY, TICK_DELAY);
	}
	public static void stopTimer() {
		if (gameTimer != null) {
			gameTimer.cancel();
		}
	}
}
/*
package smoketest.websocket.jetty.snake;
public enum Direction {
	NONE, NORTH, SOUTH, EAST, WEST
}
/*
package smoketest.websocket.jetty.snake;
public final class SnakeUtils {
	/**
	 * The width of the playfield.
	 */
	public static final int PLAYFIELD_WIDTH = 640;
	/**
	 * The height of the playfield.
	 */
	public static final int PLAYFIELD_HEIGHT = 480;
	/**
	 * The grid size.
	 */
	public static final int GRID_SIZE = 10;
	private static final Random random = new Random();
	private SnakeUtils() {
	}
	public static String getRandomHexColor() {
		float hue = random.nextFloat();
		// sat between 0.1 and 0.3
		float saturation = (random.nextInt(2000) + 1000) / 10000f;
		float luminance = 0.9f;
		Color color = Color.getHSBColor(hue, saturation, luminance);
		return "#" + Integer.toHexString((color.getRGB() & 0xffffff) | 0x1000000).substring(1);
	}
	public static Location getRandomLocation() {
		int x = roundByGridSize(random.nextInt(PLAYFIELD_WIDTH));
		int y = roundByGridSize(random.nextInt(PLAYFIELD_HEIGHT));
		return new Location(x, y);
	}
	private static int roundByGridSize(int value) {
		value = value + (GRID_SIZE / 2);
		value = value / GRID_SIZE;
		value = value * GRID_SIZE;
		return value;
	}
}
/*
package smoketest.websocket.jetty.snake;
public class SnakeWebSocketHandler extends TextWebSocketHandler {
	private static final AtomicInteger snakeIds = new AtomicInteger();
	private static final Random random = new Random();
	private final int id;
	private Snake snake;
	public static String getRandomHexColor() {
		float hue = random.nextFloat();
		// sat between 0.1 and 0.3
		float saturation = (random.nextInt(2000) + 1000) / 10000f;
		float luminance = 0.9f;
		Color color = Color.getHSBColor(hue, saturation, luminance);
		return "#" + Integer.toHexString((color.getRGB() & 0xffffff) | 0x1000000).substring(1);
	}
	public static Location getRandomLocation() {
		int x = roundByGridSize(random.nextInt(SnakeUtils.PLAYFIELD_WIDTH));
		int y = roundByGridSize(random.nextInt(SnakeUtils.PLAYFIELD_HEIGHT));
		return new Location(x, y);
	}
	private static int roundByGridSize(int value) {
		value = value + (SnakeUtils.GRID_SIZE / 2);
		value = value / SnakeUtils.GRID_SIZE;
		value = value * SnakeUtils.GRID_SIZE;
		return value;
	}
	public SnakeWebSocketHandler() {
		this.id = snakeIds.getAndIncrement();
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		this.snake = new Snake(this.id, session);
		SnakeTimer.addSnake(this.snake);
		StringBuilder sb = new StringBuilder();
		for (Iterator<Snake> iterator = SnakeTimer.getSnakes().iterator(); iterator.hasNext();) {
			Snake snake = iterator.next();
			sb.append(String.format('{id: %d, color: "%s"}', snake.getId(), snake.getHexColor()));
			if (iterator.hasNext()) {
				sb.append(",");
			}
		}
		SnakeTimer.broadcast(String.format('{"type": "join","data":[%s]}', sb));
	}
	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		String payload = message.getPayload();
		switch (payload) {
			case 'west' -> this.snake.setDirection(Direction.WEST);
			case 'north' -> this.snake.setDirection(Direction.NORTH);
			case 'east' -> this.snake.setDirection(Direction.EAST);
			case 'south' -> this.snake.setDirection(Direction.SOUTH);
		}
	}
	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
		SnakeTimer.removeSnake(this.snake);
		SnakeTimer.broadcast(String.format('{"type": "leave", "id": %d}', this.id));
	}
}
/*
package smoketest.war;
@SpringBootTest
class WarApplicationResourceTests {
	// gh-6371
	@Value('${demo.string.value}')
	private String demoStringValue;
	@Test
	void contextLoads() {
		assertThat(this.demoStringValue).isEqualTo('demo');
	}
}
/*
package smoketest.war;
@RestController
public class MyController {
	@GetMapping('/')
	public String hello() {
		return 'Hello World!';
	}
}
/*
package smoketest.war;
@SpringBootApplication
@PropertySource('WEB-INF/custom.properties')
public class SampleWarApplication extends SpringBootServletInitializer {
	public static void main(String[] args) {
		SpringApplication.run(SampleWarApplication.class, args);
	}
}
/*
package smoketest.secure.jersey;
/**
abstract class AbstractJerseySecureTests {
	abstract String getPath();
	abstract String getManagementPath();
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void helloEndpointIsSecure() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getPath() + '/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void actuatorInsecureEndpoint() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getManagementPath() + '/actuator/health',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
		entity = restTemplate().getForEntity(getManagementPath() + '/actuator/health/diskSpace', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
	@Test
	void actuatorLinksWithAnonymous() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getManagementPath() + '/actuator', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = restTemplate().getForEntity(getManagementPath() + '/actuator/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void actuatorLinksWithUnauthorizedUser() {
		ResponseEntity<String> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
		entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void actuatorLinksWithAuthorizedUser() {
		ResponseEntity<String> entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		adminRestTemplate().getForEntity(getManagementPath() + '/actuator/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void actuatorSecureEndpointWithAnonymous() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getManagementPath() + '/actuator/env',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = restTemplate().getForEntity(
				getManagementPath() + '/actuator/env/management.endpoints.web.exposure.include', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void actuatorSecureEndpointWithUnauthorizedUser() {
		ResponseEntity<String> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/env',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
		entity = userRestTemplate().getForEntity(
				getManagementPath() + '/actuator/env/management.endpoints.web.exposure.include', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void actuatorSecureEndpointWithAuthorizedUser() {
		ResponseEntity<String> entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator/env',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		entity = adminRestTemplate().getForEntity(
				getManagementPath() + '/actuator/env/management.endpoints.web.exposure.include', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void secureServletEndpointWithAnonymous() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getManagementPath() + '/actuator/se1',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = restTemplate().getForEntity(getManagementPath() + '/actuator/se1/list', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void secureServletEndpointWithUnauthorizedUser() {
		ResponseEntity<String> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/se1',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
		entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/se1/list', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void secureServletEndpointWithAuthorizedUser() {
		ResponseEntity<String> entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator/se1',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator/se1/list', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void actuatorExcludedFromEndpointRequestMatcher() {
		ResponseEntity<String> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/mappings',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	TestRestTemplate restTemplate() {
		return this.testRestTemplate;
	}
	TestRestTemplate adminRestTemplate() {
		return this.testRestTemplate.withBasicAuth('admin', 'admin');
	}
	TestRestTemplate userRestTemplate() {
		return this.testRestTemplate.withBasicAuth('user', 'password');
	}
}
/*
package smoketest.secure.jersey;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class JerseySecureApplicationTests extends AbstractJerseySecureTests {
	@LocalServerPort
	private int port;
	@Override
	String getPath() {
		return 'http://localhost:' + this.port;
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.port;
	}
}
/*
package smoketest.secure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'management.server.base-path=/management' })
class ManagementPortAndPathJerseyApplicationTests extends AbstractJerseySecureTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Test
	void testMissing() {
		ResponseEntity<String> entity = new TestRestTemplate('admin', 'admin')
			.getForEntity('http://localhost:' + this.managementPort + '/management/actuator/missing', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@Override
	String getPath() {
		return 'http://localhost:' + this.port;
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.managementPort + '/management';
	}
}
/*
package smoketest.secure.jersey;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'spring.jersey.application-path=/example' })
class ManagementPortCustomApplicationPathJerseyTests extends AbstractJerseySecureTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Test
	void actuatorPathOnMainPortShouldNotMatch() {
		ResponseEntity<String> entity = new TestRestTemplate()
			.getForEntity('http://localhost:' + this.port + '/example/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Override
	String getPath() {
		return 'http://localhost:' + this.port + '/example';
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.managementPort;
	}
}
/*
package smoketest.secure.jersey;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = 'spring.jersey.application-path=/example')
class CustomApplicationPathActuatorTests extends AbstractJerseySecureTests {
	@LocalServerPort
	private int port;
	@Override
	String getPath() {
		return 'http://localhost:' + this.port + '/example';
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.port + '/example';
	}
}
/*
package smoketest.secure.jersey;
@SpringBootApplication
@SuppressWarnings('removal')
public class SampleSecureJerseyApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSecureJerseyApplication.class, args);
	}
	@Bean
	TestServletEndpoint servletEndpoint() {
		return new TestServletEndpoint();
	}
	@ServletEndpoint(id = 'se1')
	@SuppressWarnings('removal')
	static class TestServletEndpoint implements Supplier<EndpointServlet> {
		@Override
		public EndpointServlet get() {
			return new EndpointServlet(ExampleServlet.class);
		}
	}
	static class ExampleServlet extends HttpServlet {
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		}
	}
}
/*
package smoketest.secure.jersey;
@Component
public class JerseyConfig extends ResourceConfig {
	public JerseyConfig() {
		register(Endpoint.class);
		register(ReverseEndpoint.class);
	}
}
/*
package smoketest.secure.jersey;
@Component
@Path('/hello')
public class Endpoint {
	private final Service service;
	public Endpoint(Service service) {
		this.service = service;
	}
	@GET
	public String message() {
		return 'Hello ' + this.service.message();
	}
}
/*
package smoketest.secure.jersey;
@Configuration
public class SecurityConfiguration {
	@Bean
	@SuppressWarnings('deprecation')
	public InMemoryUserDetailsManager inMemoryUserDetailsManager() {
		return new InMemoryUserDetailsManager(
				User.withDefaultPasswordEncoder()
					.username('user')
					.password('password')
					.authorities('ROLE_USER')
					.build(),
				User.withDefaultPasswordEncoder()
					.username('admin')
					.password('admin')
					.authorities('ROLE_ACTUATOR', 'ROLE_USER')
					.build());
	}
	@Bean
	SecurityFilterChain configure(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> {
			requests.requestMatchers(EndpointRequest.to('health')).permitAll();
			requests.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class))
				.hasRole('ACTUATOR');
			requests.requestMatchers('/**').hasRole('USER');
		});
		http.httpBasic(Customizer.withDefaults());
		return http.build();
	}
}
/*
package smoketest.secure.jersey;
@Component
public class Service {
	@Value('${message:World}')
	private String msg;
	public String message() {
		return this.msg;
	}
}
/*
package smoketest.secure.jersey;
@Component
@Path('/reverse')
public class ReverseEndpoint {
	@GET
	public String reverse(@QueryParam('input') @NotNull String input) {
		return new StringBuilder(input).reverse().toString();
	}
}
/*
package smoketest.data.jdbc;
/**
@SpringBootTest
@AutoConfigureTestDatabase
class CustomerRepositoryIntegrationTests {
	@Autowired
	private CustomerRepository repository;
	@Test
	void findAllCustomers() {
		assertThat(this.repository.findAll()).hasSize(2);
	}
	@Test
	void findByNameWithMatch() {
		assertThat(this.repository.findByName('joan')).hasSize(1);
	}
	@Test
	void findByNameWithNoMatch() {
		assertThat(this.repository.findByName('hugh')).isEmpty();
	}
}
/*
package smoketest.data.jdbc;
/**
@SpringBootTest
@AutoConfigureMockMvc
class SampleDataJdbcApplicationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void testCustomers() {
		assertThat(this.mvc.get().uri('/').param('name', 'merEDith')).hasStatusOk().bodyText().contains('Meredith');
	}
}
/*
package smoketest.data.jdbc;
public interface CustomerRepository extends CrudRepository<Customer, Long> {
	@Query('select id, first_name, date_of_birth from customer where upper(first_name) like "%" || upper(:name) || "%" ')
	List<Customer> findByName(@Param('name') String name);
}
/*
package smoketest.data.jdbc;
public class Customer {
	@Id
	private Long id;
	private String firstName;
	private LocalDate dateOfBirth;
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getFirstName() {
		return this.firstName;
	}
	public void setFirstName(String firstName) {
		this.firstName = firstName;
	}
	public LocalDate getDateOfBirth() {
		return this.dateOfBirth;
	}
	public void setDateOfBirth(LocalDate dateOfBirth) {
		this.dateOfBirth = dateOfBirth;
	}
}
/*
package smoketest.data.jdbc;
@Controller
public class SampleController {
	private final CustomerRepository customerRepository;
	public SampleController(CustomerRepository customerRepository) {
		this.customerRepository = customerRepository;
	}
	@GetMapping('/')
	@ResponseBody
	@Transactional(readOnly = true)
	public List<Customer> customers(@RequestParam String name) {
		return this.customerRepository.findByName(name);
	}
}
/*
package smoketest.data.jdbc;
@SpringBootApplication
public class SampleDataJdbcApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleDataJdbcApplication.class);
	}
}
/*
package smoketest.data.r2dbc;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataR2dbcTest
class CityRepositoryTests {
	@Container
	@ServiceConnection
	static PostgreSQLContainer<?> postgresql = TestImage.container(PostgreSQLContainer.class)
		.withDatabaseName('test_flyway');
	@Autowired
	private CityRepository repository;
	@Test
	void databaseHasBeenInitialized() {
		StepVerifier.create(this.repository.findByState('DC').filter((city) -> city.getName().equals('Washington')))
			.consumeNextWith((city) -> assertThat(city.getId()).isNotNull())
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
}
/*
package smoketest.data.r2dbc;
public class City {
	@Id
	private Long id;
	private String name;
	private String state;
	private String country;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public Long getId() {
		return this.id;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package smoketest.data.r2dbc;
@SpringBootApplication
public class SampleR2dbcFlywayApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleR2dbcFlywayApplication.class, args);
	}
}
/*
package smoketest.data.r2dbc;
public interface CityRepository extends ReactiveCrudRepository<City, Long> {
	Flux<City> findByState(String state);
}
/*
package smoketest.oauth2.resource;
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SampleReactiveOAuth2ResourceServerApplicationTests {
	@Autowired
	private WebTestClient webTestClient;
	private static final MockWebServer server = new MockWebServer();
	private static final String VALID_TOKEN = 'eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJzdWJqZWN0Iiwic2NvcGUiOiJtZXNzYWdlOnJlYWQi'
			+ 'LCJleHAiOjQ2ODM4MDUxNDF9.h-j6FKRFdnTdmAueTZCdep45e6DPwqM68ZQ8doIJ1exi9YxAlbWzOwId6Bd0L5YmCmp63gGQgsBUBLzwnZQ8kLUgU'
			+ 'OBEC3UzSWGRqMskCY9_k9pX0iomX6IfF3N0PaYs0WPC4hO1s8wfZQ-6hKQ4KigFi13G9LMLdH58PRMK0pKEvs3gCbHJuEPw-K5ORlpdnleUTQIwIN'
			+ 'afU57cmK3KocTeknPAM_L716sCuSYGvDl6xUTXO7oPdrXhS_EhxLP6KxrpI1uD4Ea_5OWTh7S0Wx5LLDfU6wBG1DowN20d374zepOIEkR-Jnmr_Ql'
			+ 'R44vmRqS5ncrF-1R0EGcPX49U6A';
	@BeforeAll
	static void setup() throws Exception {
		server.start();
		String url = server.url('/.well-known/jwks.json').toString();
		server.enqueue(mockResponse());
		System.setProperty('spring.security.oauth2.resourceserver.jwt.jwk-set-uri', url);
	}
	@AfterAll
	static void shutdown() throws Exception {
		server.shutdown();
		System.clearProperty('spring.security.oauth2.resourceserver.jwt.jwk-set-uri');
	}
	@Test
	void getWhenValidTokenShouldBeOk() {
		this.webTestClient.get()
			.uri('/')
			.headers((headers) -> headers.setBearerAuth(VALID_TOKEN))
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('Hello, subject!');
	}
	@Test
	void getWhenNoTokenShouldBeUnauthorized() {
		this.webTestClient.get()
			.uri('/')
			.exchange()
			.expectStatus()
			.isUnauthorized()
			.expectHeader()
			.valueEquals(HttpHeaders.WWW_AUTHENTICATE, 'Bearer');
	}
	private static MockResponse mockResponse() {
		String body = '{\'keys\':[{\'p\':\'2p-ViY7DE9ZrdWQb544m0Jp7Cv03YCSljqfim9pD4ALhObX0OrAznOiowTjwBky9JGffMw'
				+ 'DBVSfJSD9TSU7aH2sbbfi0bZLMdekKAuimudXwUqPDxrrg0BCyvCYgLmKjbVT3zcdylWSog93CNTxGDPzauu-oc0XPNKCXnaDpNvE\''
				+ ',\'kty\':\'RSA\',\'q\':\'sP_QYavrpBvSJ86uoKVGj2AGl78CSsAtpf1ybSY5TwUlorXSdqapRbY69Y271b0aMLzlleUn9ZTBO'
				+ '1dlKV2_dw_lPADHVia8z3pxL-8sUhIXLsgj4acchMk4c9YX-sFh07xENnyZ-_TXm3llPLuL67HUfBC2eKe800TmCYVWc9U\',\'d\''
				+ ':\'bn1nFxCQT4KLTHqo8mo9HvHD0cRNRNdWcKNnnEQkCF6tKbt-ILRyQGP8O40axLd7CoNVG9c9p_-g4-2kwCtLJNv_STLtwfpCY7'
				+ 'VN5o6-ZIpfTjiW6duoPrLWq64Hm_4LOBQTiZfUPcLhsuJRHbWqakj-kV_YbUyC2Ocf_dd8IAQcSrAU2SCcDebhDCWwRUFvaa9V5eq0'
				+ '851S9goaA-AJz-JXyePH6ZFr8JxmWkWxYZ5kdcMD-sm9ZbxE0CaEk32l4fE4hR-L8x2dDtjWA-ahKCZ091z-gV3HWtR2JOjvxoNRjxUo'
				+ '3UxaGiFJHWNIl0EYUJZu1Cb-5wIlEI7wPx5mwQ\',\'e\':\'AQAB\',\'use\':\'sig\',\'kid\':\'one\',\'qi\':\'qS0OK4'
				+ '8M2CIAA6_4Wdw4EbCaAfcTLf5Oy9t5BOF_PFUKqoSpZ6JsT5H0a_4zkjt-oI969v78OTlvBKbmEyKO-KeytzHBAA5CsLmVcz0THrMSg6o'
				+ 'XZqu66MPnvWoZN9FEN5TklPOvBFm8Bg1QZ3k-YMVaM--DLvhaYR95_mqaz50\',\'dp\':\'Too2NozLGD1XrXyhabZvy1E0EuaVFj0UHQ'
				+ 'PDLSpkZ_2g3BK6Art6T0xmE8RYtmqrKIEIdlI3IliAvyvAx_1D7zWTTRaj-xlZyqJFrnXWL7zj8UxT8PkB-r2E-ILZ3NAi1gxIWezlBTZ8'
				+ 'M6NfObDFmbTc_3tJkN_raISo8z_ziIE\',\'dq\':\'U0yhSkY5yOsa9YcMoigGVBWSJLpNHtbg5NypjHrPv8OhWbkOSq7WvSstBkF'
				+ 'k5AtyFvvfZLMLIkWWxxGzV0t6f1MoxBtttLrYYyCxwihiiGFhLbAdSuZ1wnxcqA9bC7UVECvrQmVTpsMs8UupfHKbQBpZ8OWAqrn'
				+ 'uYNNtG4_4Bt0\',\'n\':\'lygtuZj0lJjqOqIWocF8Bb583QDdq-aaFg8PesOp2-EDda6GqCpL-_NZVOflNGX7XIgjsWHcPsQHs'
				+ 'V9gWuOzSJ0iEuWvtQ6eGBP5M6m7pccLNZfwUse8Cb4Ngx3XiTlyuqM7pv0LPyppZusfEHVEdeelou7Dy9k0OQ_nJTI3b2E1WBoHC5'
				+ '8CJ453lo4gcBm1efURN3LIVc1V9NQY_ESBKVdwqYyoJPEanURLVGRd6cQKn6YrCbbIRHjqAyqOE-z3KmgDJnPriljfR5XhSGyM9eq'
				+ 'D9Xpy6zu_MAeMJJfSArp857zLPk-Wf5VP9STAcjyfdBIybMKnwBYr2qHMT675hQ\'}]}';
		return new MockResponse().setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
			.setResponseCode(200)
			.setBody(body);
	}
}
/*
package smoketest.oauth2.resource;
@RestController
public class ExampleController {
	@GetMapping('/')
	public String index(@AuthenticationPrincipal Jwt jwt) {
		return String.format('Hello, %s!', jwt.getSubject());
	}
}
/*
package smoketest.oauth2.resource;
@SpringBootApplication
public class SampleReactiveOAuth2ResourceServerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleReactiveOAuth2ResourceServerApplication.class);
	}
}
/*
package smoketest.actuator.noweb;
/**
@SpringBootTest
class SampleActuatorNoWebApplicationTests {
	@Test
	void contextLoads() {
	}
}
/*
package smoketest.actuator.noweb;
@ConfigurationProperties(prefix = 'service', ignoreUnknownFields = false)
public class ServiceProperties {
	/**
	 * Name of the service.
	 */
	private String name = 'World';
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package smoketest.actuator.noweb;
@Component
public class HelloWorldService {
	private final ServiceProperties configuration;
	public HelloWorldService(ServiceProperties configuration) {
		this.configuration = configuration;
	}
	public String getHelloMessage() {
		return 'Hello ' + this.configuration.getName();
	}
}
/*
package smoketest.actuator.noweb;
@SpringBootApplication
@ConfigurationPropertiesScan
public class SampleActuatorNoWebApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleActuatorNoWebApplication.class, args);
	}
}
/*
package smoketest.session.hazelcast;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SampleSessionHazelcastApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	@SuppressWarnings('unchecked')
	void sessionsEndpointShouldReturnUserSession() {
		performLogin();
		ResponseEntity<Map<String, Object>> entity = getSessions();
		assertThat(entity).isNotNull();
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		List<Map<String, Object>> sessions = (List<Map<String, Object>>) entity.getBody().get('sessions');
		assertThat(sessions).hasSize(1);
	}
	private String performLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'password');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		return entity.getHeaders().getFirst('Set-Cookie');
	}
	private ResponseEntity<Map<String, Object>> getSessions() {
		HttpHeaders headers = new HttpHeaders();
		headers.set('Authorization', getBasicAuth());
		RequestEntity<Object> request = new RequestEntity<>(headers, HttpMethod.GET,
				URI.create('/actuator/sessions?username=user'));
		ParameterizedTypeReference<Map<String, Object>> stringObjectMap = new ParameterizedTypeReference<>() {
		};
		return this.restTemplate.exchange(request, stringObjectMap);
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
}
/*
package smoketest.session.hazelcast;
@SpringBootApplication
public class SampleSessionHazelcastApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSessionHazelcastApplication.class);
	}
}
/*
package smoketest.session.hazelcast;
/**
@Configuration(proxyBeanMethods = false)
class SecurityConfiguration {
	@Bean
	SecurityFilterChain managementSecurityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> {
			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class)).permitAll();
			requests.anyRequest().authenticated();
		});
		http.formLogin(withDefaults());
		http.httpBasic(withDefaults());
		http.csrf(CsrfConfigurer::disable);
		return http.build();
	}
}
/*
package smoketest.secure;
/**
@SpringBootTest(classes = { SampleSecureApplication.class })
class SampleSecureApplicationTests {
	@Autowired
	private SampleService service;
	private Authentication authentication;
	@BeforeEach
	void init() {
		this.authentication = new UsernamePasswordAuthenticationToken('user', 'password');
	}
	@AfterEach
	void close() {
		SecurityContextHolder.clearContext();
	}
	@Test
	void secure() {
		assertThatExceptionOfType(AuthenticationException.class)
			.isThrownBy(() -> SampleSecureApplicationTests.this.service.secure());
	}
	@Test
	void authenticated() {
		SecurityContextHolder.getContext()
			.setAuthentication(new UsernamePasswordAuthenticationToken('user', 'N/A',
					AuthorityUtils.commaSeparatedStringToAuthorityList('ROLE_USER')));
		assertThat(this.service.secure()).isEqualTo('Hello Security');
	}
	@Test
	void preauth() {
		SecurityContextHolder.getContext().setAuthentication(this.authentication);
		assertThat(this.service.authorized()).isEqualTo('Hello World');
	}
	@Test
	void denied() {
		SecurityContextHolder.getContext().setAuthentication(this.authentication);
		assertThatExceptionOfType(AccessDeniedException.class)
			.isThrownBy(() -> SampleSecureApplicationTests.this.service.denied());
	}
}
/*
package smoketest.secure;
@EnableAutoConfiguration
@ComponentScan
@EnableMethodSecurity(securedEnabled = true, prePostEnabled = true)
public class SampleSecureApplication implements CommandLineRunner {
	@Autowired
	private SampleService service;
	@Override
	public void run(String... args) throws Exception {
		SecurityContextHolder.getContext()
			.setAuthentication(new UsernamePasswordAuthenticationToken('user', 'N/A',
					AuthorityUtils.commaSeparatedStringToAuthorityList('ROLE_USER')));
		try {
			System.out.println(this.service.secure());
		}
		finally {
			SecurityContextHolder.clearContext();
		}
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleSecureApplication.class, '--debug');
	}
}
/*
package smoketest.secure;
@Service
public class SampleService {
	@Secured('ROLE_USER')
	public String secure() {
		return 'Hello Security';
	}
	@PreAuthorize('true')
	public String authorized() {
		return 'Hello World';
	}
	@PreAuthorize('false')
	public String denied() {
		return 'Goodbye World';
	}
}
/*
package smoketest.saml2.serviceprovider;
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SampleSaml2RelyingPartyApplicationTests {
	@LocalServerPort
	private int port;
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void everythingShouldRedirectToLogin() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation()).isEqualTo(URI.create('http://localhost:' + this.port + '/login'));
	}
	@Test
	void loginShouldHaveAllAssertingPartiesToChooseFrom() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/login', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('/saml2/authenticate?registrationId=simplesamlphp');
		assertThat(entity.getBody()).contains('/saml2/authenticate?registrationId=okta');
	}
}
/*
package smoketest.saml2.serviceprovider;
@SpringBootApplication
public class SampleSaml2RelyingPartyApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSaml2RelyingPartyApplication.class);
	}
}
/*
package smoketest.saml2.serviceprovider;
@RestController
public class ExampleController {
	@RequestMapping('/')
	public String email(Principal principal) {
		return 'Hello ' + principal.getName();
	}
}
/*
package smoketest.actuator.customsecurity;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'server.error.include-message=always' })
class SampleActuatorCustomSecurityApplicationTests extends AbstractSampleActuatorCustomSecurityTests {
	@LocalServerPort
	private int port;
	@Autowired
	private Environment environment;
	@Override
	String getPath() {
		return 'http://localhost:' + this.port;
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.port;
	}
	@Override
	Environment getEnvironment() {
		return this.environment;
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void testInsecureApplicationPath() {
		ResponseEntity<Map> entity = restTemplate().getForEntity(getPath() + '/foo', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		Map<String, Object> body = entity.getBody();
		assertThat((String) body.get('message')).contains('Expected exception in controller');
	}
	@Test
	void mvcMatchersCanBeUsedToSecureActuators() {
		ResponseEntity<Object> entity = beansRestTemplate().getForEntity(getManagementPath() + '/actuator/beans',
				Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		entity = beansRestTemplate().getForEntity(getManagementPath() + '/actuator/beans/', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
}
/*
package smoketest.actuator.customsecurity;
/**
abstract class AbstractSampleActuatorCustomSecurityTests {
	abstract String getPath();
	abstract String getManagementPath();
	abstract Environment getEnvironment();
	@Test
	void homeIsSecure() {
		@SuppressWarnings('rawtypes')
		ResponseEntity<Map> entity = restTemplate().getForEntity(getPath() + '/', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		assertThat(entity.getHeaders()).doesNotContainKey('Set-Cookie');
	}
	@Test
	void testInsecureStaticResources() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getPath() + '/css/bootstrap.min.css', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('body');
	}
	@Test
	void actuatorInsecureEndpoint() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getManagementPath() + '/actuator/health',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
		entity = restTemplate().getForEntity(getManagementPath() + '/actuator/health/diskSpace', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
	@Test
	void actuatorLinksWithAnonymous() {
		ResponseEntity<Object> entity = restTemplate().getForEntity(getManagementPath() + '/actuator', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = restTemplate().getForEntity(getManagementPath() + '/actuator/', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void actuatorLinksWithUnauthorizedUser() {
		ResponseEntity<Object> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator',
				Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
		entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void actuatorLinksWithAuthorizedUser() {
		ResponseEntity<Object> entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator',
				Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		adminRestTemplate().getForEntity(getManagementPath() + '/actuator/', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void actuatorSecureEndpointWithAnonymous() {
		ResponseEntity<Object> entity = restTemplate().getForEntity(getManagementPath() + '/actuator/env',
				Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = restTemplate().getForEntity(
				getManagementPath() + '/actuator/env/management.endpoints.web.exposure.include', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void actuatorSecureEndpointWithUnauthorizedUser() {
		ResponseEntity<Object> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/env',
				Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
		entity = userRestTemplate().getForEntity(
				getManagementPath() + '/actuator/env/management.endpoints.web.exposure.include', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void actuatorSecureEndpointWithAuthorizedUser() {
		ResponseEntity<Object> entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator/env',
				Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator/env/', Object.class);
		// EndpointRequest matches the trailing slash but MVC doesn"t
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		entity = adminRestTemplate().getForEntity(
				getManagementPath() + '/actuator/env/management.endpoints.web.exposure.include', Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void secureServletEndpointWithAnonymous() {
		ResponseEntity<String> entity = restTemplate().getForEntity(getManagementPath() + '/actuator/se1',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = restTemplate().getForEntity(getManagementPath() + '/actuator/se1/list', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void secureServletEndpointWithUnauthorizedUser() {
		ResponseEntity<String> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/se1',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
		entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/se1/list', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void secureServletEndpointWithAuthorizedUser() {
		ResponseEntity<String> entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator/se1',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		entity = adminRestTemplate().getForEntity(getManagementPath() + '/actuator/se1/list', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void actuatorCustomMvcSecureEndpointWithAnonymous() {
		ResponseEntity<String> entity = restTemplate()
			.getForEntity(getManagementPath() + '/actuator/example/echo?text={t}', String.class, 'test');
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void actuatorCustomMvcSecureEndpointWithUnauthorizedUser() {
		ResponseEntity<String> entity = userRestTemplate()
			.getForEntity(getManagementPath() + '/actuator/example/echo?text={t}', String.class, 'test');
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
	@Test
	void actuatorCustomMvcSecureEndpointWithAuthorizedUser() {
		ResponseEntity<String> entity = adminRestTemplate()
			.getForEntity(getManagementPath() + '/actuator/example/echo?text={t}', String.class, 'test');
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('test');
		assertThat(entity.getHeaders().getFirst('echo')).isEqualTo('test');
	}
	@Test
	void actuatorExcludedFromEndpointRequestMatcher() {
		ResponseEntity<Object> entity = userRestTemplate().getForEntity(getManagementPath() + '/actuator/mappings',
				Object.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	TestRestTemplate restTemplate() {
		return configure(new TestRestTemplate());
	}
	TestRestTemplate adminRestTemplate() {
		return configure(new TestRestTemplate('admin', 'admin'));
	}
	TestRestTemplate userRestTemplate() {
		return configure(new TestRestTemplate('user', 'password'));
	}
	TestRestTemplate beansRestTemplate() {
		return configure(new TestRestTemplate('beans', 'beans'));
	}
	private TestRestTemplate configure(TestRestTemplate restTemplate) {
		restTemplate.setUriTemplateHandler(new LocalHostUriTemplateHandler(getEnvironment()));
		return restTemplate;
	}
}
/*
package smoketest.actuator.customsecurity;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'spring.mvc.servlet.path=/example' })
class ManagementPortCustomServletPathSampleActuatorTests extends AbstractSampleActuatorCustomSecurityTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private Environment environment;
	@Test
	void actuatorPathOnMainPortShouldNotMatch() {
		ResponseEntity<String> entity = new TestRestTemplate()
			.getForEntity('http://localhost:' + this.port + '/example/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Override
	String getPath() {
		return 'http://localhost:' + this.port + '/example';
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.managementPort;
	}
	@Override
	Environment getEnvironment() {
		return this.environment;
	}
}
/*
package smoketest.actuator.customsecurity;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'management.server.base-path=/management' })
class ManagementPortAndPathSampleActuatorApplicationTests extends AbstractSampleActuatorCustomSecurityTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private Environment environment;
	@Test
	void testMissing() {
		ResponseEntity<String> entity = new TestRestTemplate('admin', 'admin')
			.getForEntity('http://localhost:' + this.managementPort + '/management/actuator/missing', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		assertThat(entity.getBody()).contains('\'status\':404');
	}
	@Override
	String getPath() {
		return 'http://localhost:' + this.port;
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.managementPort + '/management';
	}
	@Override
	Environment getEnvironment() {
		return this.environment;
	}
}
/*
package smoketest.actuator.customsecurity;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles('cors')
class CorsSampleActuatorApplicationTests {
	private TestRestTemplate testRestTemplate;
	@Autowired
	private ApplicationContext applicationContext;
	@BeforeEach
	void setUp() {
		RestTemplateBuilder builder = new RestTemplateBuilder();
		LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(this.applicationContext.getEnvironment(),
				'http');
		builder = builder.uriTemplateHandler(handler);
		this.testRestTemplate = new TestRestTemplate(builder);
	}
	@Test
	void endpointShouldReturnUnauthorized() {
		ResponseEntity<?> entity = this.testRestTemplate.getForEntity('/actuator/env', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void preflightRequestToEndpointShouldReturnOk() throws Exception {
		RequestEntity<?> envRequest = RequestEntity.options(new URI('/actuator/env'))
			.header('Origin', 'http://localhost:8080')
			.header('Access-Control-Request-Method', 'GET')
			.build();
		ResponseEntity<?> exchange = this.testRestTemplate.exchange(envRequest, Map.class);
		assertThat(exchange.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void preflightRequestWhenCorsConfigInvalidShouldReturnForbidden() throws Exception {
		RequestEntity<?> entity = RequestEntity.options(new URI('/actuator/env'))
			.header('Origin', 'http://localhost:9095')
			.header('Access-Control-Request-Method', 'GET')
			.build();
		ResponseEntity<byte[]> exchange = this.testRestTemplate.exchange(entity, byte[].class);
		assertThat(exchange.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
}
/*
package smoketest.actuator.customsecurity;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = 'spring.mvc.servlet.path=/example')
class CustomServletPathSampleActuatorTests extends AbstractSampleActuatorCustomSecurityTests {
	@LocalServerPort
	private int port;
	@Autowired
	private Environment environment;
	@Override
	String getPath() {
		return 'http://localhost:' + this.port + '/example';
	}
	@Override
	String getManagementPath() {
		return 'http://localhost:' + this.port + '/example';
	}
	@Override
	Environment getEnvironment() {
		return this.environment;
	}
}
/*
package smoketest.actuator.customsecurity;
@Controller
public class ExampleController {
	@GetMapping('/')
	public String home(Map<String, Object> model) {
		model.put('message', 'Hello World');
		model.put('title', 'Hello Home');
		model.put('date', new Date());
		return 'home';
	}
	@RequestMapping('/foo')
	public String foo() {
		throw new RuntimeException('Expected exception in controller');
	}
}
/*
package smoketest.actuator.customsecurity;
@Configuration(proxyBeanMethods = false)
public class SecurityConfiguration {
	@Bean
	public InMemoryUserDetailsManager inMemoryUserDetailsManager() {
		List<UserDetails> userDetails = new ArrayList<>();
		userDetails.add(createUserDetails('user', 'password', 'ROLE_USER'));
		userDetails.add(createUserDetails('beans', 'beans', 'ROLE_BEANS'));
		userDetails.add(createUserDetails('admin', 'admin', 'ROLE_ACTUATOR', 'ROLE_USER'));
		return new InMemoryUserDetailsManager(userDetails);
	}
	@SuppressWarnings('deprecation')
	private UserDetails createUserDetails(String username, String password, String... authorities) {
		UserBuilder builder = User.withDefaultPasswordEncoder();
		builder.username(username);
		builder.password(password);
		builder.authorities(authorities);
		return builder.build();
	}
	@Bean
	SecurityFilterChain configure(HttpSecurity http, HandlerMappingIntrospector handlerMappingIntrospector)
			throws Exception {
		http.authorizeHttpRequests((requests) -> {
			requests.requestMatchers(new MvcRequestMatcher(handlerMappingIntrospector, '/actuator/beans'))
				.hasRole('BEANS');
			requests.requestMatchers(EndpointRequest.to('health')).permitAll();
			requests.requestMatchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class))
				.hasRole('ACTUATOR');
			requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();
			requests.requestMatchers(new AntPathRequestMatcher('/foo')).permitAll();
			requests.requestMatchers(new MvcRequestMatcher(handlerMappingIntrospector, '/error')).permitAll();
			requests.requestMatchers(new AntPathRequestMatcher('/**')).hasRole('USER');
		});
		http.cors(withDefaults());
		http.httpBasic(withDefaults());
		return http.build();
	}
}
/*
package smoketest.actuator.customsecurity;
@SpringBootApplication
@SuppressWarnings('removal')
public class SampleActuatorCustomSecurityApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleActuatorCustomSecurityApplication.class, args);
	}
	@Bean
	TestServletEndpoint servletEndpoint() {
		return new TestServletEndpoint();
	}
	@ServletEndpoint(id = 'se1')
	static class TestServletEndpoint implements Supplier<EndpointServlet> {
		@Override
		public EndpointServlet get() {
			return new EndpointServlet(ExampleServlet.class);
		}
	}
	static class ExampleServlet extends HttpServlet {
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
		}
	}
}
/*
package smoketest.actuator.customsecurity;
@Component
@RestControllerEndpoint(id = 'example')
@SuppressWarnings('removal')
public class ExampleRestControllerEndpoint {
	@GetMapping('/echo')
	public ResponseEntity<String> echo(@RequestParam('text') String text) {
		return ResponseEntity.ok().header('echo', text).body(text);
	}
}
/*
package smoketest.rsocket;
@SpringBootTest(properties = 'spring.rsocket.server.port=0')
class SampleRSocketApplicationTests {
	@LocalRSocketServerPort
	private int port;
	@Autowired
	private RSocketRequester.Builder builder;
	@Test
	void unauthenticatedAccessToRSocketEndpoint() {
		RSocketRequester requester = this.builder.tcp('localhost', this.port);
		Mono<Project> result = requester.route('find.project.spring-boot').retrieveMono(Project.class);
		StepVerifier.create(result).expectErrorMessage('Access Denied').verify();
	}
	@Test
	void rSocketEndpoint() {
		RSocketRequester requester = this.builder
			.rsocketStrategies((builder) -> builder.encoder(new SimpleAuthenticationEncoder()))
			.setupMetadata(new UsernamePasswordMetadata('user', 'password'),
					MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString()))
			.tcp('localhost', this.port);
		Mono<Project> result = requester.route('find.project.spring-boot').retrieveMono(Project.class);
		StepVerifier.create(result)
			.assertNext((project) -> assertThat(project.getName()).isEqualTo('spring-boot'))
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
}
/*
package smoketest.rsocket;
public class Project {
	private String name;
	public Project() {
	}
	public Project(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package smoketest.rsocket;
@Controller
public class ProjectController {
	@MessageMapping('find.project.{name}')
	public Mono<Project> findProject(@DestinationVariable String name) {
		return Mono.just(new Project(name));
	}
}
/*
package smoketest.rsocket;
@SpringBootApplication
public class SampleRSocketApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleRSocketApplication.class, args);
	}
}
/*
package smoketest.actuator.ui;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'management.server.port:0' })
class SampleActuatorUiApplicationPortTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.testRestTemplate.getForEntity('http://localhost:' + this.port,
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void testMetrics() {
		@SuppressWarnings('rawtypes')
		ResponseEntity<Map> entity = this.testRestTemplate
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/metrics', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testHealth() {
		ResponseEntity<String> entity = this.testRestTemplate.withBasicAuth('user', getPassword())
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
	private String getPassword() {
		return 'password';
	}
}
/*
package smoketest.actuator.ui;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'server.error.include-message=always' })
class SampleActuatorUiApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', getPassword())
			.exchange('/', HttpMethod.GET, new HttpEntity<Void>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('<title>Hello');
	}
	@Test
	void testCss() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/css/bootstrap.min.css', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('body');
	}
	@Test
	void testMetrics() {
		@SuppressWarnings('rawtypes')
		ResponseEntity<Map> entity = this.restTemplate.getForEntity('/actuator/metrics', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testError() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', getPassword())
			.exchange('/error', HttpMethod.GET, new HttpEntity<Void>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(entity.getBody()).contains('<html>')
			.contains('<body>')
			.contains('Please contact the operator with the above information');
	}
	private String getPassword() {
		return 'password';
	}
}
/*
package smoketest.actuator.ui;
@SpringBootApplication
@Controller
public class SampleActuatorUiApplication {
	@GetMapping('/')
	public String home(Map<String, Object> model) {
		model.put('message', 'Hello World');
		model.put('title', 'Hello Home');
		model.put('date', new Date());
		return 'home';
	}
	@RequestMapping('/foo')
	public String foo() {
		throw new RuntimeException('Expected exception in controller');
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleActuatorUiApplication.class, args);
	}
}
/*
package smoketest.tomcat;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@ExtendWith(OutputCaptureExtension.class)
class SampleTomcat11ApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private ApplicationContext applicationContext;
	@Value('${server.max-http-request-header-size}')
	private int maxHttpRequestHeaderSize;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
	@Test
	void testCompression() throws Exception {
		HttpHeaders requestHeaders = new HttpHeaders();
		requestHeaders.set('Accept-Encoding', 'gzip');
		HttpEntity<?> requestEntity = new HttpEntity<>(requestHeaders);
		ResponseEntity<byte[]> entity = this.restTemplate.exchange('/', HttpMethod.GET, requestEntity, byte[].class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		try (GZIPInputStream inflater = new GZIPInputStream(new ByteArrayInputStream(entity.getBody()))) {
			assertThat(StreamUtils.copyToString(inflater, StandardCharsets.UTF_8)).isEqualTo('Hello World');
		}
	}
	@Test
	void testTimeout() {
		ServletWebServerApplicationContext context = (ServletWebServerApplicationContext) this.applicationContext;
		TomcatWebServer embeddedServletContainer = (TomcatWebServer) context.getWebServer();
		ProtocolHandler protocolHandler = embeddedServletContainer.getTomcat().getConnector().getProtocolHandler();
		int timeout = ((AbstractProtocol<?>) protocolHandler).getConnectionTimeout();
		assertThat(timeout).isEqualTo(5000);
	}
	@Test
	void testMaxHttpResponseHeaderSize(CapturedOutput output) {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/max-http-response-header', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(output).contains(
				'threw exception [Request processing failed: org.apache.coyote.http11.HeadersTooLargeException: An attempt was made to write more data to the response headers than there was room available in the buffer. Increase maxHttpHeaderSize on the connector or write less data into the response headers.]');
	}
	@Test
	void testMaxHttpRequestHeaderSize(CapturedOutput output) {
		String headerValue = RandomStringUtil.getRandomBase64EncodedString(this.maxHttpRequestHeaderSize + 1);
		HttpHeaders headers = new HttpHeaders();
		headers.add('x-max-request-header', headerValue);
		HttpEntity<?> httpEntity = new HttpEntity<>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, httpEntity, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
		assertThat(output).contains('java.lang.IllegalArgumentException: Request header is too large');
	}
}
/*
package smoketest.tomcat;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class NonAutoConfigurationSampleTomcatApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	@ComponentScan(basePackageClasses = { SampleController.class, HelloWorldService.class })
	public static class NonAutoConfigurationSampleTomcatApplication {
		public static void main(String[] args) {
			SpringApplication.run(SampleTomcat11Application.class, args);
		}
	}
}
/*
package smoketest.tomcat.web;
@Controller
public class SampleController {
	private final HelloWorldService helloWorldService;
	private final HttpHeaderService httpHeaderService;
	public SampleController(HelloWorldService helloWorldService, HttpHeaderService httpHeaderService) {
		this.helloWorldService = helloWorldService;
		this.httpHeaderService = httpHeaderService;
	}
	@GetMapping('/')
	@ResponseBody
	public String helloWorld() {
		return this.helloWorldService.getHelloMessage();
	}
	@GetMapping('/max-http-response-header')
	@ResponseBody
	public String maxHttpResponseHeader(HttpServletResponse response) {
		String headerValue = this.httpHeaderService.getHeaderValue();
		response.addHeader('x-max-header', headerValue);
		return this.helloWorldService.getHelloMessage();
	}
}
/*
package smoketest.tomcat;
@SpringBootApplication
public class SampleTomcat11Application {
	private static final Log logger = LogFactory.getLog(SampleTomcat11Application.class);
	@Bean
	protected ServletContextListener listener() {
		return new ServletContextListener() {
			@Override
			public void contextInitialized(ServletContextEvent sce) {
				logger.info('ServletContext initialized');
			}
			@Override
			public void contextDestroyed(ServletContextEvent sce) {
				logger.info('ServletContext destroyed');
			}
		};
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleTomcat11Application.class, args);
	}
}
/*
package smoketest.tomcat.service;
@Component
public class HelloWorldService {
	@Value('${test.name:World}')
	private String name;
	public String getHelloMessage() {
		return 'Hello ' + this.name;
	}
}
/*
package smoketest.tomcat.service;
@Component
public class HttpHeaderService {
	@Value('${server.tomcat.max-http-response-header-size}')
	private int maxHttpResponseHeaderSize;
	/**
	 * Generates random data. The data is:
	 * <ol>
	 * <li>is longer than configured
	 * <code>server.tomcat.max-http-response-header-size</code></li>
	 * <li>is url encoded by base 64 encode the random value</li>
	 * </ol>
	 * @return a base64 encoded string of random bytes
	 */
	public String getHeaderValue() {
		return RandomStringUtil.getRandomBase64EncodedString(this.maxHttpResponseHeaderSize + 1);
	}
}
/*
package smoketest.tomcat.util;
public final class RandomStringUtil {
	private RandomStringUtil() {
	}
	public static String getRandomBase64EncodedString(int length) {
		byte[] responseHeader = new byte[length];
		new Random().nextBytes(responseHeader);
		return Base64.getEncoder().encodeToString(responseHeader);
	}
}
/*
package smoketest.pulsar;
@Testcontainers(disabledWithoutDocker = true)
@ExtendWith(OutputCaptureExtension.class)
class SamplePulsarApplicationTests {
	@Container
	@ServiceConnection
	static final PulsarContainer pulsar = TestImage.container(PulsarContainer.class);
	abstract class PulsarApplication {
		private final String type;
		PulsarApplication(String type) {
			this.type = type;
		}
		@Test
		void appProducesAndConsumesMessages(CapturedOutput output) {
			List<String> expectedOutput = new ArrayList<>();
			IntStream.range(0, 10).forEachOrdered((i) -> {
				expectedOutput.add('++++++PRODUCE %s:(%s)------'.formatted(this.type, i));
				expectedOutput.add('++++++CONSUME %s:(%s)------'.formatted(this.type, i));
			});
			Awaitility.waitAtMost(Duration.ofSeconds(30))
				.untilAsserted(() -> assertThat(output).contains(expectedOutput));
		}
	}
	@Nested
	@SpringBootTest
	@ActiveProfiles('smoketest.pulsar.imperative')
	class ImperativePulsarApplication extends PulsarApplication {
		ImperativePulsarApplication() {
			super('IMPERATIVE');
		}
	}
	@Nested
	@SpringBootTest
	@ActiveProfiles('smoketest.pulsar.reactive')
	class ReactivePulsarApplication extends PulsarApplication {
		ReactivePulsarApplication() {
			super('REACTIVE');
		}
	}
}
/*
package smoketest.pulsar;
@Configuration(proxyBeanMethods = false)
@Profile('smoketest.pulsar.reactive')
class ReactiveAppConfig {
	private static final Log logger = LogFactory.getLog(ReactiveAppConfig.class);
	private static final String TOPIC = 'pulsar-reactive-smoke-test-topic';
	@Bean
	PulsarTopic pulsarTestTopic() {
		return new PulsarTopicBuilder().name(TOPIC).numberOfPartitions(1).build();
	}
	@Bean
	ApplicationRunner sendMessagesToPulsarTopic(ReactivePulsarTemplate<SampleMessage> template) {
		return (args) -> Flux.range(0, 10)
			.map((i) -> new SampleMessage(i, 'message:' + i))
			.map(MessageSpec::of)
			.as((msgs) -> template.send(TOPIC, msgs))
			.doOnNext((sendResult) -> logger
				.info('++++++PRODUCE REACTIVE:(' + sendResult.getMessageSpec().getValue().id() + ')------'))
			.subscribe();
	}
	@ReactivePulsarListener(topics = TOPIC)
	Mono<Void> consumeMessagesFromPulsarTopic(SampleMessage msg) {
		logger.info('++++++CONSUME REACTIVE:(' + msg.id() + ')------');
		return Mono.empty();
	}
}
/*
package smoketest.pulsar;
@Configuration(proxyBeanMethods = false)
@Profile('smoketest.pulsar.imperative')
class ImperativeAppConfig {
	private static final Log logger = LogFactory.getLog(ImperativeAppConfig.class);
	private static final String TOPIC = 'pulsar-smoke-test-topic';
	@Bean
	PulsarTopic pulsarTestTopic() {
		return new PulsarTopicBuilder().name(TOPIC).numberOfPartitions(1).build();
	}
	@Bean
	ApplicationRunner sendMessagesToPulsarTopic(PulsarTemplate<SampleMessage> template) {
		return (args) -> {
			for (int i = 0; i < 10; i++) {
				template.send(TOPIC, new SampleMessage(i, 'message:' + i));
				logger.info('++++++PRODUCE IMPERATIVE:(' + i + ')------');
			}
		};
	}
	@PulsarListener(topics = TOPIC)
	void consumeMessagesFromPulsarTopic(SampleMessage msg) {
		logger.info('++++++CONSUME IMPERATIVE:(' + msg.id() + ')------');
	}
}
/*
package smoketest.pulsar;
@SpringBootApplication
public class SamplePulsarApplication {
	public static void main(String[] args) {
		SpringApplication.run(SamplePulsarApplication.class, args);
	}
}
/*
package smoketest.pulsar;
record SampleMessage(Integer id, String content) {
}
/*
package smoketest.oauth2.resource;
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SampleOauth2ResourceServerApplicationTests {
	private static final MockWebServer server = new MockWebServer();
	private static final String VALID_TOKEN = 'eyJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJzdWJqZWN0Iiwic2NvcGUiOiJtZXNzYWdlOnJlYWQi'
			+ 'LCJleHAiOjQ2ODM4MDUxNDF9.h-j6FKRFdnTdmAueTZCdep45e6DPwqM68ZQ8doIJ1exi9YxAlbWzOwId6Bd0L5YmCmp63gGQgsBUBLzwnZQ8kLUgU'
			+ 'OBEC3UzSWGRqMskCY9_k9pX0iomX6IfF3N0PaYs0WPC4hO1s8wfZQ-6hKQ4KigFi13G9LMLdH58PRMK0pKEvs3gCbHJuEPw-K5ORlpdnleUTQIwIN'
			+ 'afU57cmK3KocTeknPAM_L716sCuSYGvDl6xUTXO7oPdrXhS_EhxLP6KxrpI1uD4Ea_5OWTh7S0Wx5LLDfU6wBG1DowN20d374zepOIEkR-Jnmr_Ql'
			+ 'R44vmRqS5ncrF-1R0EGcPX49U6A';
	@Autowired
	private TestRestTemplate restTemplate;
	@BeforeAll
	static void setup() throws Exception {
		server.start();
		String url = server.url('/.well-known/jwks.json').toString();
		server.enqueue(mockResponse());
		System.setProperty('spring.security.oauth2.resourceserver.jwt.jwk-set-uri', url);
	}
	@AfterAll
	static void shutdown() throws IOException {
		server.shutdown();
		System.clearProperty('spring.security.oauth2.resourceserver.jwt.jwk-set-uri');
	}
	@Test
	void withValidBearerTokenShouldAllowAccess() {
		HttpHeaders headers = new HttpHeaders();
		headers.setBearerAuth(VALID_TOKEN);
		HttpEntity<?> request = new HttpEntity<Void>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, request, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void withNoBearerTokenShouldNotAllowAccess() {
		HttpHeaders headers = new HttpHeaders();
		HttpEntity<?> request = new HttpEntity<Void>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, request, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	private static MockResponse mockResponse() {
		String body = '{\'keys\':[{\'p\':\'2p-ViY7DE9ZrdWQb544m0Jp7Cv03YCSljqfim9pD4ALhObX0OrAznOiowTjwBky9JGffMw'
				+ 'DBVSfJSD9TSU7aH2sbbfi0bZLMdekKAuimudXwUqPDxrrg0BCyvCYgLmKjbVT3zcdylWSog93CNTxGDPzauu-oc0XPNKCXnaDpNvE\''
				+ ',\'kty\':\'RSA\',\'q\':\'sP_QYavrpBvSJ86uoKVGj2AGl78CSsAtpf1ybSY5TwUlorXSdqapRbY69Y271b0aMLzlleUn9ZTBO'
				+ '1dlKV2_dw_lPADHVia8z3pxL-8sUhIXLsgj4acchMk4c9YX-sFh07xENnyZ-_TXm3llPLuL67HUfBC2eKe800TmCYVWc9U\',\'d\''
				+ ':\'bn1nFxCQT4KLTHqo8mo9HvHD0cRNRNdWcKNnnEQkCF6tKbt-ILRyQGP8O40axLd7CoNVG9c9p_-g4-2kwCtLJNv_STLtwfpCY7'
				+ 'VN5o6-ZIpfTjiW6duoPrLWq64Hm_4LOBQTiZfUPcLhsuJRHbWqakj-kV_YbUyC2Ocf_dd8IAQcSrAU2SCcDebhDCWwRUFvaa9V5eq0'
				+ '851S9goaA-AJz-JXyePH6ZFr8JxmWkWxYZ5kdcMD-sm9ZbxE0CaEk32l4fE4hR-L8x2dDtjWA-ahKCZ091z-gV3HWtR2JOjvxoNRjxUo'
				+ '3UxaGiFJHWNIl0EYUJZu1Cb-5wIlEI7wPx5mwQ\',\'e\':\'AQAB\',\'use\':\'sig\',\'kid\':\'one\',\'qi\':\'qS0OK4'
				+ '8M2CIAA6_4Wdw4EbCaAfcTLf5Oy9t5BOF_PFUKqoSpZ6JsT5H0a_4zkjt-oI969v78OTlvBKbmEyKO-KeytzHBAA5CsLmVcz0THrMSg6o'
				+ 'XZqu66MPnvWoZN9FEN5TklPOvBFm8Bg1QZ3k-YMVaM--DLvhaYR95_mqaz50\',\'dp\':\'Too2NozLGD1XrXyhabZvy1E0EuaVFj0UHQ'
				+ 'PDLSpkZ_2g3BK6Art6T0xmE8RYtmqrKIEIdlI3IliAvyvAx_1D7zWTTRaj-xlZyqJFrnXWL7zj8UxT8PkB-r2E-ILZ3NAi1gxIWezlBTZ8'
				+ 'M6NfObDFmbTc_3tJkN_raISo8z_ziIE\',\'dq\':\'U0yhSkY5yOsa9YcMoigGVBWSJLpNHtbg5NypjHrPv8OhWbkOSq7WvSstBkF'
				+ 'k5AtyFvvfZLMLIkWWxxGzV0t6f1MoxBtttLrYYyCxwihiiGFhLbAdSuZ1wnxcqA9bC7UVECvrQmVTpsMs8UupfHKbQBpZ8OWAqrn'
				+ 'uYNNtG4_4Bt0\',\'n\':\'lygtuZj0lJjqOqIWocF8Bb583QDdq-aaFg8PesOp2-EDda6GqCpL-_NZVOflNGX7XIgjsWHcPsQHs'
				+ 'V9gWuOzSJ0iEuWvtQ6eGBP5M6m7pccLNZfwUse8Cb4Ngx3XiTlyuqM7pv0LPyppZusfEHVEdeelou7Dy9k0OQ_nJTI3b2E1WBoHC5'
				+ '8CJ453lo4gcBm1efURN3LIVc1V9NQY_ESBKVdwqYyoJPEanURLVGRd6cQKn6YrCbbIRHjqAyqOE-z3KmgDJnPriljfR5XhSGyM9eq'
				+ 'D9Xpy6zu_MAeMJJfSArp857zLPk-Wf5VP9STAcjyfdBIybMKnwBYr2qHMT675hQ\'}]}';
		return new MockResponse().setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
			.setResponseCode(200)
			.setBody(body);
	}
}
/*
package smoketest.oauth2.resource;
@SpringBootApplication
public class SampleOauth2ResourceServerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleOauth2ResourceServerApplication.class);
	}
}
/*
package smoketest.oauth2.resource;
@RestController
public class ExampleController {
	@GetMapping('/')
	public String index(@AuthenticationPrincipal Jwt jwt) {
		return String.format('Hello, %s!', jwt.getSubject());
	}
}
/*
package smoketest.ant;
/**
class SampleAntApplicationIT {
	@Test
	void runJar() throws Exception {
		File libs = new File('build/ant/libs');
		Process process = new JavaExecutable().processBuilder('-jar', 'spring-boot-smoke-test-ant.jar')
			.directory(libs)
			.start();
		process.waitFor(5, TimeUnit.MINUTES);
		assertThat(process.exitValue()).isZero();
		String output = FileCopyUtils.copyToString(new InputStreamReader(process.getInputStream()));
		assertThat(output).contains('Spring Boot Ant Example');
	}
}
/*
package smoketest.ant;
@SpringBootApplication
public class SampleAntApplication implements CommandLineRunner {
	@Override
	public void run(String... args) {
		System.out.println('Spring Boot Ant Example');
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleAntApplication.class, args);
	}
}
/*
package smoketest.activemq.embedded;
/**
@SpringBootTest
@ExtendWith(OutputCaptureExtension.class)
class SampleActiveMQApplicationTests {
	@Autowired
	private Producer producer;
	@Test
	void sendSimpleMessage(CapturedOutput output) throws InterruptedException {
		this.producer.send('Test message');
		Thread.sleep(1000L);
		assertThat(output).contains('Test message');
	}
}
/*
package smoketest.activemq.embedded;
@Component
public class Producer implements CommandLineRunner {
	@Autowired
	private JmsMessagingTemplate jmsMessagingTemplate;
	@Autowired
	private Queue queue;
	@Override
	public void run(String... args) throws Exception {
		send('Sample message');
		System.out.println('Message was sent to the Queue');
	}
	public void send(String msg) {
		this.jmsMessagingTemplate.convertAndSend(this.queue, msg);
	}
}
/*
package smoketest.activemq.embedded;
@SpringBootApplication
@EnableJms
public class SampleActiveMQApplication {
	@Bean
	public Queue queue() {
		return new ActiveMQQueue('sample.queue');
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleActiveMQApplication.class, args);
	}
}
/*
package smoketest.activemq.embedded;
@Component
public class Consumer {
	@JmsListener(destination = 'sample.queue')
	public void receiveQueue(String text) {
		System.out.println(text);
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'spring.mvc.servlet.path=/spring' })
class ServletPathSampleActuatorApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testErrorPath() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/spring/error', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(entity.getBody()).containsEntry('error', 'None');
		assertThat(entity.getBody()).containsEntry('status', 999);
	}
	@Test
	void testHealth() {
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', 'password')
			.getForEntity('/spring/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
	@Test
	void testHomeIsSecure() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(this.restTemplate.getForEntity('/spring/', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		assertThat(entity.getHeaders()).doesNotContainKey('Set-Cookie');
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'management.endpoints.web.base-path=/admin' })
class ManagementPathSampleActuatorApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHealth() {
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', 'password')
			.getForEntity('/admin/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
	@Test
	void testHomeIsSecure() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(this.restTemplate.getForEntity('/', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		assertThat(entity.getHeaders()).doesNotContainKey('Set-Cookie');
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleActuatorApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private ApplicationContext applicationContext;
	@Test
	void testHomeIsSecure() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(this.restTemplate.getForEntity('/', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		assertThat(entity.getHeaders()).doesNotContainKey('Set-Cookie');
	}
	@Test
	void testMetricsIsSecure() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.getForEntity('/actuator/metrics', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = asMapEntity(this.restTemplate.getForEntity('/actuator/metrics/', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = asMapEntity(this.restTemplate.getForEntity('/actuator/metrics/foo', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		entity = asMapEntity(this.restTemplate.getForEntity('/actuator/metrics.json', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testHome() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsEntry('message', 'Hello Phil');
	}
	@Test
	@SuppressWarnings('unchecked')
	void testMetrics() {
		testHome(); // makes sure some requests have been made
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/actuator/metrics', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsKey('names');
		List<String> names = (List<String>) entity.getBody().get('names');
		assertThat(names).contains('jvm.buffer.count');
	}
	@Test
	void testEnv() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/actuator/env', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsKey('propertySources');
	}
	@Test
	void healthInsecureByDefault() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
		assertThat(entity.getBody()).doesNotContain('\'hello\':\'1\'');
	}
	@Test
	void testErrorPage() {
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', 'password')
			.getForEntity('/foo', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		String body = entity.getBody();
		assertThat(body).contains('\'error\':');
	}
	@Test
	void testHtmlErrorPage() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		HttpEntity<?> request = new HttpEntity<Void>(headers);
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', 'password')
			.exchange('/foo', HttpMethod.GET, request, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		String body = entity.getBody();
		assertThat(body).as('Body was null').isNotNull();
		assertThat(body).contains('This application has no explicit mapping for /error');
	}
	@Test
	void testErrorPageDirectAccess() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/error', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(entity.getBody()).containsEntry('error', 'None');
		assertThat(entity.getBody()).containsEntry('status', 999);
	}
	@Test
	void testBeans() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/actuator/beans', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsOnlyKeys('contexts');
	}
	@Test
	@SuppressWarnings('unchecked')
	void testConfigProps() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/actuator/configprops', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		Map<String, Object> body = entity.getBody();
		Map<String, Object> contexts = (Map<String, Object>) body.get('contexts');
		Map<String, Object> context = (Map<String, Object>) contexts.get(this.applicationContext.getId());
		Map<String, Object> beans = (Map<String, Object>) context.get('beans');
		assertThat(beans).containsKey('spring.datasource-' + DataSourceProperties.class.getName());
	}
	@Test
	void testLegacyDot() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/actuator/legacy', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains(entry('legacy', 'legacy'));
	}
	@Test
	void testLegacyHyphen() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/actuator/anotherlegacy', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains(entry('legacy', 'legacy'));
	}
	@Test
	@SuppressWarnings('unchecked')
	void testInfo() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/actuator/info', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsKey('build');
		Map<String, Object> body = entity.getBody();
		Map<String, Object> example = (Map<String, Object>) body.get('example');
		assertThat(example).containsEntry('someKey', 'someValue');
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'spring.mvc.pathmatch.matching-strategy=path-pattern-parser', 'management.server.port=0',
				'management.endpoints.web.base-path=/admin', 'management.endpoint.health.show-details=never' })
class ManagementPortAndPathWithPathMatcherSampleActuatorApplicationTests
		extends AbstractManagementPortAndPathSampleActuatorApplicationTests {
}
/*
package smoketest.actuator;
/**
abstract class AbstractManagementPortAndPathSampleActuatorApplicationTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private Environment environment;
	@Test
	void testHome() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				new TestRestTemplate('user', 'password').getForEntity('http://localhost:' + this.port, Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsEntry('message', 'Hello Phil');
	}
	@Test
	void testMetrics() {
		testHome(); // makes sure some requests have been made
		ResponseEntity<Map<String, Object>> entity = asMapEntity(new TestRestTemplate()
			.getForEntity('http://localhost:' + this.managementPort + '/admin/metrics', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testHealth() {
		ResponseEntity<String> entity = new TestRestTemplate().withBasicAuth('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/admin/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('{\'status\':\'UP\',\'groups\':[\'comp\',\'live\',\'ready\']}');
	}
	@Test
	void testGroupWithComposite() {
		ResponseEntity<String> entity = new TestRestTemplate().withBasicAuth('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/admin/health/comp', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains(
				'components\':{\'a\':{\'status\':\'UP\',\'details\':{\'hello\':\'spring-a\'}},\'c\':{\'status\':\'UP\',\'details\':{\'hello\':\'spring-c\'}}');
	}
	@Test
	void testEnvNotFound() {
		String unknownProperty = 'test-does-not-exist';
		assertThat(this.environment.containsProperty(unknownProperty)).isFalse();
		ResponseEntity<String> entity = new TestRestTemplate().withBasicAuth('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/admin/env/' + unknownProperty, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@Test
	void testMissing() {
		ResponseEntity<String> entity = new TestRestTemplate('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/admin/missing', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		assertThat(entity.getBody()).contains('\'status\':404');
	}
	@Test
	void testErrorPage() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(new TestRestTemplate('user', 'password')
			.getForEntity('http://localhost:' + this.port + '/error', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(entity.getBody()).containsEntry('status', 999);
	}
	@Test
	void testManagementErrorPage() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(new TestRestTemplate('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/error', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsEntry('status', 999);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(classes = { ShutdownSampleActuatorApplicationTests.SecurityConfiguration.class,
		SampleActuatorApplication.class }, webEnvironment = WebEnvironment.RANDOM_PORT)
class ShutdownSampleActuatorApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		Map<String, Object> body = entity.getBody();
		assertThat(body).containsEntry('message', 'Hello Phil');
	}
	@Test
	@DirtiesContext
	void testShutdown() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(this.restTemplate.withBasicAuth('user', 'password')
			.postForEntity('/actuator/shutdown', null, Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(((String) entity.getBody().get('message'))).contains('Shutting down');
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
	@Configuration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityFilterChain configure(HttpSecurity http) throws Exception {
			http.csrf(CsrfConfigurer::disable);
			return http.build();
		}
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = 'management.endpoints.jackson.isolated-object-mapper=false')
@ContextConfiguration(loader = ApplicationStartupSpringBootContextLoader.class)
class SampleActuatorApplicationIsolatedObjectMapperFalseTests {
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void resourceShouldBeAvailableOnMainPort() {
		ResponseEntity<String> entity = this.testRestTemplate.withBasicAuth('user', 'password')
			.getForEntity('/actuator/startup', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'management.server.port=0',
		'management.server.address=127.0.0.1', 'management.server.base-path:/admin' })
class ManagementAddressActuatorApplicationTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Test
	void testHome() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				new TestRestTemplate().getForEntity('http://localhost:' + this.port, Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testHealth() {
		ResponseEntity<String> entity = new TestRestTemplate().withBasicAuth('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/admin/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'management.server.port=-1' })
class NoManagementSampleActuatorApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsEntry('message', 'Hello Phil');
	}
	@Test
	void testMetricsNotAvailable() {
		testHome(); // makes sure some requests have been made
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/metrics', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'spring.main.lazy-initialization=true' })
class ManagementPortWithLazyInitializationTests {
	@LocalManagementPort
	private int managementPort;
	@Test
	void testHealth() {
		ResponseEntity<String> entity = new TestRestTemplate().withBasicAuth('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles('cors')
class CorsSampleActuatorApplicationTests {
	private TestRestTemplate testRestTemplate;
	@Autowired
	private ApplicationContext applicationContext;
	@BeforeEach
	void setUp() {
		RestTemplateBuilder builder = new RestTemplateBuilder();
		LocalHostUriTemplateHandler handler = new LocalHostUriTemplateHandler(this.applicationContext.getEnvironment(),
				'http');
		builder = builder.uriTemplateHandler(handler);
		this.testRestTemplate = new TestRestTemplate(builder);
	}
	@Test
	void endpointShouldReturnUnauthorized() {
		ResponseEntity<?> entity = this.testRestTemplate.getForEntity('/actuator/env', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void preflightRequestToEndpointShouldReturnOk() throws Exception {
		RequestEntity<?> healthRequest = RequestEntity.options(new URI('/actuator/env'))
			.header('Origin', 'http://localhost:8080')
			.header('Access-Control-Request-Method', 'GET')
			.build();
		ResponseEntity<?> exchange = this.testRestTemplate.exchange(healthRequest, Map.class);
		assertThat(exchange.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void preflightRequestWhenCorsConfigInvalidShouldReturnForbidden() throws Exception {
		RequestEntity<?> entity = RequestEntity.options(new URI('/actuator/env'))
			.header('Origin', 'http://localhost:9095')
			.header('Access-Control-Request-Method', 'GET')
			.build();
		ResponseEntity<byte[]> exchange = this.testRestTemplate.exchange(entity, byte[].class);
		assertThat(exchange.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'management.endpoint.health.show-details=always' })
@Import(CustomErrorAttributes.class)
class ManagementPortSampleActuatorApplicationTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private CustomErrorAttributes errorAttributes;
	@Test
	void testHome() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				new TestRestTemplate('user', 'password').getForEntity('http://localhost:' + this.port, Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsEntry('message', 'Hello Phil');
	}
	@Test
	void testMetrics() {
		testHome(); // makes sure some requests have been made
		ResponseEntity<Map<String, Object>> entity = asMapEntity(new TestRestTemplate()
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/metrics', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testHealth() {
		ResponseEntity<String> entity = new TestRestTemplate().withBasicAuth('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
		assertThat(entity.getBody()).contains('\'example\'');
		assertThat(entity.getBody()).contains('\'counter\':42');
	}
	@Test
	void testErrorPage() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(new TestRestTemplate('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/error', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).containsEntry('status', 999);
	}
	@Test
	void securityContextIsAvailableToErrorHandling() {
		this.errorAttributes.securityContext = null;
		ResponseEntity<Map<String, Object>> entity = asMapEntity(new TestRestTemplate('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/404', Map.class));
		assertThat(this.errorAttributes.securityContext.getAuthentication()).isNotNull();
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		assertThat(entity.getBody()).containsEntry('status', 404);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
	static class CustomErrorAttributes extends DefaultErrorAttributes {
		private volatile SecurityContext securityContext;
		@Override
		public Map<String, Object> getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) {
			this.securityContext = SecurityContextHolder.getContext();
			return super.getErrorAttributes(webRequest, options);
		}
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@ActiveProfiles('endpoints')
class EndpointsPropertiesSampleActuatorApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testCustomErrorPath() {
		ResponseEntity<Map<String, Object>> entity = asMapEntity(
				this.restTemplate.withBasicAuth('user', 'password').getForEntity('/oops', Map.class));
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		Map<String, Object> body = entity.getBody();
		assertThat(body).containsEntry('error', 'None');
		assertThat(body).containsEntry('status', 999);
	}
	@Test
	void testCustomContextPath() {
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', 'password')
			.getForEntity('/admin/health', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'status\':\'UP\'');
		assertThat(entity.getBody()).contains('\'hello\':\'world\'');
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	static <K, V> ResponseEntity<Map<K, V>> asMapEntity(ResponseEntity<Map> entity) {
		return (ResponseEntity) entity;
	}
}
/*
package smoketest.actuator;
class ApplicationStartupSpringBootContextLoader extends SpringBootContextLoader {
	@Override
	protected SpringApplication getSpringApplication() {
		SpringApplication application = new SpringApplication();
		application.setApplicationStartup(new BufferingApplicationStartup(1024));
		return application;
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = 'management.endpoints.jackson.isolated-object-mapper=true')
@ContextConfiguration(loader = ApplicationStartupSpringBootContextLoader.class)
class SampleActuatorApplicationIsolatedObjectMapperTrueTests {
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void resourceShouldBeAvailableOnMainPort() {
		ResponseEntity<String> entity = this.testRestTemplate.withBasicAuth('user', 'password')
			.getForEntity('/actuator/startup', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'timeline\':');
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.endpoints.web.base-path=/', 'management.server.port=0' })
class ManagementDifferentPortSampleActuatorApplicationTests {
	@LocalManagementPort
	private int managementPort;
	@Test
	void linksEndpointShouldBeAvailable() {
		ResponseEntity<String> entity = new TestRestTemplate('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'_links\'');
	}
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'management.server.port=0',
		'management.endpoints.web.base-path=/admin', 'management.endpoint.health.show-details=never' })
class ManagementPortAndPathWithAntPatcherSampleActuatorApplicationTests
		extends AbstractManagementPortAndPathSampleActuatorApplicationTests {
}
/*
package smoketest.actuator;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.endpoints.web.exposure.include=*', 'management.server.port=0' })
class ManagementDifferentPortAndEndpointWithExceptionHandlerSampleActuatorApplicationTests {
	@LocalManagementPort
	private int managementPort;
	@Test
	void testExceptionHandlerRestControllerEndpoint() {
		ResponseEntity<String> entity = new TestRestTemplate('user', 'password')
			.getForEntity('http://localhost:' + this.managementPort + '/actuator/exception', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.I_AM_A_TEAPOT);
		assertThat(entity.getBody()).isEqualTo('this is a custom exception body');
	}
}
/*
package smoketest.actuator;
@ConfigurationProperties(prefix = 'service', ignoreUnknownFields = false)
public class ServiceProperties {
	/**
	 * Name of the service.
	 */
	private String name = 'World';
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package smoketest.actuator;
@Controller
@Description('A controller for handling requests for hello messages')
public class SampleController {
	private final HelloWorldService helloWorldService;
	public SampleController(HelloWorldService helloWorldService) {
		this.helloWorldService = helloWorldService;
	}
	@GetMapping(value = '/', produces = MediaType.APPLICATION_JSON_VALUE)
	@ResponseBody
	public Map<String, String> hello() {
		return Collections.singletonMap('message', this.helloWorldService.getHelloMessage());
	}
	@PostMapping(value = '/', produces = MediaType.APPLICATION_JSON_VALUE)
	@ResponseBody
	public Map<String, Object> olleh(@Validated Message message) {
		Map<String, Object> model = new LinkedHashMap<>();
		model.put('message', message.getValue());
		model.put('title', 'Hello Home');
		model.put('date', new Date());
		return model;
	}
	@RequestMapping('/foo')
	@ResponseBody
	public String foo() {
		throw new IllegalArgumentException('Server error');
	}
	protected static class Message {
		@NotBlank(message = 'Message value cannot be empty')
		private String value;
		public String getValue() {
			return this.value;
		}
		public void setValue(String value) {
			this.value = value;
		}
	}
}
/*
package smoketest.actuator;
@Component
public class HelloWorldService {
	private final ServiceProperties configuration;
	public HelloWorldService(ServiceProperties configuration) {
		this.configuration = configuration;
	}
	public String getHelloMessage() {
		return 'Hello ' + this.configuration.getName();
	}
}
/*
package smoketest.actuator;
/**
@Component
@RestControllerEndpoint(id = 'exception')
@SuppressWarnings('removal')
public class SampleRestControllerEndpointWithException {
	@GetMapping('/')
	public String exception() {
		throw new CustomException();
	}
	@RestControllerAdvice
	static class CustomExceptionHandler {
		@ExceptionHandler(CustomException.class)
		ResponseEntity<String> handleCustomException(CustomException e) {
			return new ResponseEntity<>('this is a custom exception body', HttpStatus.I_AM_A_TEAPOT);
		}
	}
	static class CustomException extends RuntimeException {
	}
}
/*
package smoketest.actuator;
@Component
@Endpoint(id = 'another-legacy')
public class SampleLegacyEndpointWithHyphen {
	@ReadOperation
	public Map<String, String> example() {
		return Collections.singletonMap('legacy', 'legacy');
	}
}
/*
package smoketest.actuator;
@Component
public class ExampleHealthIndicator implements HealthIndicator {
	@Override
	public Health health() {
		return Health.up().withDetail('counter', 42).build();
	}
}
/*
package smoketest.actuator;
@Component
public class ExampleInfoContributor implements InfoContributor {
	@Override
	public void contribute(Info.Builder builder) {
		builder.withDetail('example', Collections.singletonMap('someKey', 'someValue'));
	}
}
/*
package smoketest.actuator;
@SpringBootApplication
@ConfigurationPropertiesScan
public class SampleActuatorApplication {
	@Bean
	public HealthIndicator helloHealthIndicator() {
		return createHealthIndicator('world');
	}
	@Bean
	public HealthContributor compositeHelloHealthContributor() {
		Map<String, HealthContributor> map = new LinkedHashMap<>();
		map.put('spring', createNestedHealthContributor('spring'));
		map.put('boot', createNestedHealthContributor('boot'));
		return CompositeHealthContributor.fromMap(map);
	}
	private HealthContributor createNestedHealthContributor(String name) {
		Map<String, HealthContributor> map = new LinkedHashMap<>();
		map.put('a', createHealthIndicator(name + '-a'));
		map.put('b', createHealthIndicator(name + '-b'));
		map.put('c', createHealthIndicator(name + '-c'));
		return CompositeHealthContributor.fromMap(map);
	}
	private HealthIndicator createHealthIndicator(String value) {
		return () -> Health.up().withDetail('hello', value).build();
	}
	public static void main(String[] args) {
		SpringApplication application = new SpringApplication(SampleActuatorApplication.class);
		application.setApplicationStartup(new BufferingApplicationStartup(1024));
		application.run(args);
	}
}
/*
package smoketest.actuator;
@Component
@Endpoint(id = 'lega.cy')
public class SampleLegacyEndpointWithDot {
	@ReadOperation
	public Map<String, String> example() {
		return Collections.singletonMap('legacy', 'legacy');
	}
}
/*
package smoketest.jsp;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebJspApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testJspWithEl() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('/resources/text.txt');
	}
	@Test
	void customErrorPage() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		RequestEntity<Void> request = new RequestEntity<>(headers, HttpMethod.GET, URI.create('/foo'));
		ResponseEntity<String> entity = this.restTemplate.exchange(request, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
		assertThat(entity.getBody()).contains('Something went wrong: 500 Internal Server Error');
	}
}
/*
package smoketest.jsp;
@SpringBootApplication
public class SampleWebJspApplication extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleWebJspApplication.class);
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleWebJspApplication.class, args);
	}
}
/*
package smoketest.jsp;
@Controller
public class WelcomeController {
	@Value('${application.message:Hello World}')
	private String message = 'Hello World';
	@GetMapping('/')
	public String welcome(Map<String, Object> model) {
		model.put('time', new Date());
		model.put('message', this.message);
		return 'welcome';
	}
	@RequestMapping('/foo')
	public String foo(Map<String, Object> model) {
		throw new RuntimeException('Foo');
	}
}
/*
package smoketest.graphql;
@SpringBootTest
@AutoConfigureHttpGraphQlTester
class GreetingControllerTests {
	@Autowired
	private HttpGraphQlTester graphQlTester;
	@Test
	void shouldUnauthorizeAnonymousUsers() {
		this.graphQlTester.documentName('greeting').variable('name', 'Brian').execute().errors().satisfy((errors) -> {
			assertThat(errors).hasSize(1);
			assertThat(errors.get(0).getErrorType()).isEqualTo(ErrorType.UNAUTHORIZED);
		});
	}
	@Test
	void shouldGreetWithSpecificName() {
		HttpGraphQlTester authenticated = withAdminCredentials(this.graphQlTester);
		authenticated.documentName('greeting')
			.variable('name', 'Brian')
			.execute()
			.path('greeting')
			.entity(String.class)
			.isEqualTo('Hello, Brian!');
	}
	@Test
	void shouldGreetWithDefaultName() {
		HttpGraphQlTester authenticated = withAdminCredentials(this.graphQlTester);
		authenticated.document('{ greeting }')
			.execute()
			.path('greeting')
			.entity(String.class)
			.isEqualTo('Hello, Spring!');
	}
	private HttpGraphQlTester withAdminCredentials(HttpGraphQlTester graphQlTester) {
		return graphQlTester.mutate()
			.webTestClient(
					(httpClient) -> httpClient.defaultHeaders((headers) -> headers.setBasicAuth('admin', 'admin')))
			.build();
	}
}
/*
package smoketest.graphql;
@GraphQlTest(ProjectController.class)
class ProjectControllerTests {
	@Autowired
	private GraphQlTester graphQlTester;
	@Test
	void shouldFindSpringGraphQl() {
		this.graphQlTester.document('{ project(slug: \'spring-graphql\') { name } }')
			.execute()
			.path('project.name')
			.entity(String.class)
			.isEqualTo('Spring GraphQL');
	}
	@Test
	void shouldNotFindUnknownProject() {
		this.graphQlTester.document('{ project(slug: \'spring-unknown\') { name } }')
			.execute()
			.path('project.name')
			.pathDoesNotExist();
	}
}
/*
package smoketest.graphql;
@Component
public class GreetingService {
	@PreAuthorize('hasRole("ADMIN")')
	public String greet(String name) {
		return 'Hello, ' + name + '!';
	}
}
/*
package smoketest.graphql;
@Controller
public class GreetingController {
	private final GreetingService greetingService;
	public GreetingController(GreetingService greetingService) {
		this.greetingService = greetingService;
	}
	@QueryMapping
	public String greeting(@Argument String name) {
		return this.greetingService.greet(name);
	}
}
/*
package smoketest.graphql;
@SpringBootApplication
public class SampleGraphQlApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleGraphQlApplication.class, args);
	}
}
/*
package smoketest.graphql;
public class Project {
	private String slug;
	private String name;
	public Project(String slug, String name) {
		this.slug = slug;
		this.name = name;
	}
	public String getSlug() {
		return this.slug;
	}
	public void setSlug(String slug) {
		this.slug = slug;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Project project = (Project) o;
		return this.slug.equals(project.slug);
	}
	@Override
	public int hashCode() {
		return Objects.hash(this.slug);
	}
}
/*
package smoketest.graphql;
@Controller
public class ProjectController {
	private final List<Project> projects;
	public ProjectController() {
		this.projects = Arrays.asList(new Project('spring-boot', 'Spring Boot'),
				new Project('spring-graphql', 'Spring GraphQL'), new Project('spring-framework', 'Spring Framework'));
	}
	@QueryMapping
	public Optional<Project> project(@Argument String slug) {
		return this.projects.stream().filter((project) -> project.getSlug().equals(slug)).findFirst();
	}
}
/*
package smoketest.graphql;
@Configuration(proxyBeanMethods = false)
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
	@Bean
	public DefaultSecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception {
		return http.csrf(CsrfConfigurer::disable)
			// Demonstrate that method security works
			// Best practice to use both for defense in depth
			.authorizeHttpRequests((requests) -> requests.anyRequest().permitAll())
			.httpBasic(withDefaults())
			.build();
	}
	@Bean
	@SuppressWarnings('deprecation')
	public InMemoryUserDetailsManager userDetailsService() {
		User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
		UserDetails rob = userBuilder.username('rob').password('rob').roles('USER').build();
		UserDetails admin = userBuilder.username('admin').password('admin').roles('USER', 'ADMIN').build();
		return new InMemoryUserDetailsManager(rob, admin);
	}
}
/*
package smoketest.integration.consumer;
/**
class SampleIntegrationApplicationTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void stop() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void testVanillaExchange(@TempDir Path temp) {
		File inputDir = new File(temp.toFile(), 'input');
		File outputDir = new File(temp.toFile(), 'output');
		this.context = SpringApplication.run(SampleIntegrationApplication.class, '--service.input-dir=' + inputDir,
				'--service.output-dir=' + outputDir);
		SpringApplication.run(ProducerApplication.class, 'World', '--service.input-dir=' + inputDir,
				'--service.output-dir=' + outputDir);
		awaitOutputContaining(outputDir, 'Hello World');
	}
	@Test
	void testMessageGateway(@TempDir Path temp) {
		File inputDir = new File(temp.toFile(), 'input');
		File outputDir = new File(temp.toFile(), 'output');
		this.context = SpringApplication.run(SampleIntegrationApplication.class, 'testviamg',
				'--service.input-dir=' + inputDir, '--service.output-dir=' + outputDir);
		awaitOutputContaining(this.context.getBean(ServiceProperties.class).getOutputDir(), 'testviamg');
	}
	private void awaitOutputContaining(File outputDir, String requiredContents) {
		Awaitility.waitAtMost(Duration.ofSeconds(30))
			.until(() -> outputIn(outputDir), containsString(requiredContents));
	}
	private String outputIn(File outputDir) throws IOException {
		Resource[] resources = findResources(outputDir);
		if (resources.length == 0) {
			return null;
		}
		return readResources(resources);
	}
	private Resource[] findResources(File outputDir) throws IOException {
		return ResourcePatternUtils.getResourcePatternResolver(new DefaultResourceLoader())
			.getResources('file:' + outputDir.getAbsolutePath() + '/*.txt');
	}
	private String readResources(Resource[] resources) throws IOException {
		StringBuilder builder = new StringBuilder();
		for (Resource resource : resources) {
			try (InputStream input = resource.getInputStream()) {
				builder.append(new String(StreamUtils.copyToByteArray(input)));
			}
		}
		return builder.toString();
	}
}
/*
package smoketest.integration.producer;
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(ServiceProperties.class)
public class ProducerApplication implements ApplicationRunner {
	private final ServiceProperties serviceProperties;
	public ProducerApplication(ServiceProperties serviceProperties) {
		this.serviceProperties = serviceProperties;
	}
	@Override
	public void run(ApplicationArguments args) throws Exception {
		this.serviceProperties.getInputDir().mkdirs();
		if (!args.getNonOptionArgs().isEmpty()) {
			FileOutputStream stream = new FileOutputStream(
					new File(this.serviceProperties.getInputDir(), 'data' + System.currentTimeMillis() + '.txt'));
			for (String arg : args.getNonOptionArgs()) {
				stream.write(arg.getBytes());
			}
			stream.flush();
			stream.close();
		}
	}
	public static void main(String[] args) {
		SpringApplication.run(ProducerApplication.class, args);
	}
}
/*
package smoketest.integration;
@ConfigurationProperties(prefix = 'service', ignoreUnknownFields = false)
@ManagedResource
public class ServiceProperties {
	private String greeting = 'Hello';
	private File inputDir;
	private File outputDir;
	@ManagedAttribute
	public String getGreeting() {
		return this.greeting;
	}
	public void setGreeting(String greeting) {
		this.greeting = greeting;
	}
	public File getInputDir() {
		return this.inputDir;
	}
	public void setInputDir(File inputDir) {
		this.inputDir = inputDir;
	}
	public File getOutputDir() {
		return this.outputDir;
	}
	public void setOutputDir(File outputDir) {
		this.outputDir = outputDir;
	}
}
/*
package smoketest.integration;
@SpringBootApplication
public class SampleIntegrationApplication {
	private final ServiceProperties serviceProperties;
	public SampleIntegrationApplication(ServiceProperties serviceProperties) {
		this.serviceProperties = serviceProperties;
	}
	@Bean
	public FileReadingMessageSource fileReader() {
		FileReadingMessageSource reader = new FileReadingMessageSource();
		reader.setDirectory(this.serviceProperties.getInputDir());
		return reader;
	}
	@Bean
	public DirectChannel inputChannel() {
		return new DirectChannel();
	}
	@Bean
	public DirectChannel outputChannel() {
		return new DirectChannel();
	}
	@Bean
	public FileWritingMessageHandler fileWriter() {
		FileWritingMessageHandler writer = new FileWritingMessageHandler(this.serviceProperties.getOutputDir());
		writer.setExpectReply(false);
		return writer;
	}
	@Bean
	public IntegrationFlow integrationFlow(SampleEndpoint endpoint) {
		return IntegrationFlow.from(fileReader(), new FixedRatePoller())
			.channel(inputChannel())
			.handle(endpoint)
			.channel(outputChannel())
			.handle(fileWriter())
			.get();
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleIntegrationApplication.class, args);
	}
	private static final class FixedRatePoller implements Consumer<SourcePollingChannelAdapterSpec> {
		@Override
		public void accept(SourcePollingChannelAdapterSpec spec) {
			spec.poller(Pollers.fixedRate(500));
		}
	}
}
/*
package smoketest.integration;
@MessagingGateway(defaultRequestChannel = 'outputChannel')
public interface SampleMessageGateway {
	void echo(String message);
}
/*
package smoketest.integration;
@Service
public class HelloWorldService {
	private final ServiceProperties configuration;
	public HelloWorldService(ServiceProperties configuration) {
		this.configuration = configuration;
	}
	public String getHelloMessage(String name) {
		return this.configuration.getGreeting() + ' ' + name;
	}
}
/*
package smoketest.integration;
@Component
public class SampleApplicationRunner implements ApplicationRunner {
	private final SampleMessageGateway gateway;
	public SampleApplicationRunner(SampleMessageGateway gateway) {
		this.gateway = gateway;
	}
	@Override
	public void run(ApplicationArguments args) throws Exception {
		for (String arg : args.getNonOptionArgs()) {
			this.gateway.echo(arg);
		}
	}
}
/*
package smoketest.integration;
@MessageEndpoint
public class SampleEndpoint {
	private final HelloWorldService helloWorldService;
	public SampleEndpoint(HelloWorldService helloWorldService) {
		this.helloWorldService = helloWorldService;
	}
	@ServiceActivator
	public String hello(File input) throws Exception {
		FileInputStream in = new FileInputStream(input);
		String name = new String(StreamUtils.copyToByteArray(in));
		in.close();
		return this.helloWorldService.getHelloMessage(name);
	}
}
/*
package smoketest.jetty;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleJettyApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Value('${server.max-http-request-header-size}')
	private int maxHttpRequestHeaderSize;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
	@Test
	void testCompression() {
		// Jetty HttpClient sends Accept-Encoding: gzip by default
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
		// Jetty HttpClient decodes gzip responses automatically and removes the
		// Content-Encoding header. We have to assume that the response was gzipped.
	}
	@Test
	void testMaxHttpResponseHeaderSize() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/max-http-response-header', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);
	}
	@Test
	void testMaxHttpRequestHeaderSize() {
		String headerValue = StringUtil.repeat("A", this.maxHttpRequestHeaderSize + 1);
		HttpHeaders headers = new HttpHeaders();
		headers.add('x-max-request-header', headerValue);
		HttpEntity<?> httpEntity = new HttpEntity<>(headers);
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, httpEntity, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.REQUEST_HEADER_FIELDS_TOO_LARGE);
	}
}
/*
package smoketest.jetty.web;
@Controller
public class SampleController {
	private final HelloWorldService helloWorldService;
	private final HttpHeaderService httpHeaderService;
	public SampleController(HelloWorldService helloWorldService, HttpHeaderService httpHeaderService) {
		this.helloWorldService = helloWorldService;
		this.httpHeaderService = httpHeaderService;
	}
	@GetMapping('/')
	@ResponseBody
	public String helloWorld() {
		return this.helloWorldService.getHelloMessage();
	}
	@GetMapping('/max-http-response-header')
	@ResponseBody
	public String maxHttpResponseHeader(HttpServletResponse response) {
		String headerValue = this.httpHeaderService.getHeaderValue();
		response.addHeader('x-max-header', headerValue);
		return this.helloWorldService.getHelloMessage();
	}
}
/*
package smoketest.jetty.service;
@Component
public class HelloWorldService {
	@Value('${test.name:World}')
	private String name;
	public String getHelloMessage() {
		return 'Hello ' + this.name;
	}
}
/*
package smoketest.jetty.service;
@Component
public class HttpHeaderService {
	@Value('${server.jetty.max-http-response-header-size}')
	private int maxHttpResponseHeaderSize;
	/**
	 * Generates a header value, which is longer than
	 * "server.jetty.max-http-response-header-size".
	 * @return the header value
	 */
	public String getHeaderValue() {
		return StringUtil.repeat("A", this.maxHttpResponseHeaderSize + 1);
	}
}
/*
package smoketest.jetty;
/**
@Component
public class ExampleServletContextListener implements ServletContextListener {
	@Override
	public void contextInitialized(ServletContextEvent sce) {
		System.out.println('*** contextInitialized');
	}
	@Override
	public void contextDestroyed(ServletContextEvent sce) {
		System.out.println('*** contextDestroyed');
	}
}
/*
package smoketest.jetty.util;
public final class StringUtil {
	private StringUtil() {
	}
	public static String repeat(char c, int length) {
		char[] chars = new char[length];
		Arrays.fill(chars, c);
		return new String(chars);
	}
}
/*
package smoketest.jetty;
@SpringBootApplication
public class SampleJettyApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleJettyApplication.class, args);
	}
}
/*
package smoketest.parent.consumer;
/**
class SampleIntegrationParentApplicationTests {
	@Test
	void testVanillaExchange(@TempDir Path temp) {
		File inputDir = new File(temp.toFile(), 'input');
		File outputDir = new File(temp.toFile(), 'output');
		try (ConfigurableApplicationContext app = SpringApplication.run(SampleParentContextApplication.class,
				'--service.input-dir=' + inputDir, '--service.output-dir=' + outputDir)) {
			try (ConfigurableApplicationContext producer = SpringApplication.run(ProducerApplication.class,
					'--service.input-dir=' + inputDir, '--service.output-dir=' + outputDir, 'World')) {
				awaitOutputContaining(outputDir, 'Hello World');
			}
		}
	}
	private void awaitOutputContaining(File outputDir, String requiredContents) {
		Awaitility.waitAtMost(Duration.ofSeconds(30))
			.until(() -> outputIn(outputDir), containsString(requiredContents));
	}
	private String outputIn(File outputDir) throws IOException {
		Resource[] resources = findResources(outputDir);
		if (resources.length == 0) {
			return null;
		}
		return readResources(resources);
	}
	private Resource[] findResources(File outputDir) throws IOException {
		return ResourcePatternUtils.getResourcePatternResolver(new DefaultResourceLoader())
			.getResources('file:' + outputDir.getAbsolutePath() + '/*.txt');
	}
	private String readResources(Resource[] resources) throws IOException {
		StringBuilder builder = new StringBuilder();
		for (Resource resource : resources) {
			try (InputStream input = resource.getInputStream()) {
				builder.append(new String(StreamUtils.copyToByteArray(input)));
			}
		}
		return builder.toString();
	}
}
/*
package smoketest.parent.producer;
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(ServiceProperties.class)
public class ProducerApplication implements ApplicationRunner {
	private final ServiceProperties serviceProperties;
	public ProducerApplication(ServiceProperties serviceProperties) {
		this.serviceProperties = serviceProperties;
	}
	@Override
	public void run(ApplicationArguments args) throws Exception {
		this.serviceProperties.getInputDir().mkdirs();
		if (!args.getNonOptionArgs().isEmpty()) {
			FileOutputStream stream = new FileOutputStream(
					new File(this.serviceProperties.getInputDir(), 'data' + System.currentTimeMillis() + '.txt'));
			for (String arg : args.getNonOptionArgs()) {
				stream.write(arg.getBytes());
			}
			stream.flush();
			stream.close();
		}
	}
	public static void main(String[] args) {
		SpringApplication.run(ProducerApplication.class, args);
	}
}
/*
package smoketest.parent;
@ConfigurationProperties(prefix = 'service', ignoreUnknownFields = false)
@ManagedResource
public class ServiceProperties {
	private String greeting = 'Hello';
	private File inputDir;
	private File outputDir;
	@ManagedAttribute
	public String getGreeting() {
		return this.greeting;
	}
	public void setGreeting(String greeting) {
		this.greeting = greeting;
	}
	public File getInputDir() {
		return this.inputDir;
	}
	public void setInputDir(File inputDir) {
		this.inputDir = inputDir;
	}
	public File getOutputDir() {
		return this.outputDir;
	}
	public void setOutputDir(File outputDir) {
		this.outputDir = outputDir;
	}
}
/*
package smoketest.parent;
@Component
public class HelloWorldService {
	private final ServiceProperties configuration;
	public HelloWorldService(ServiceProperties configuration) {
		this.configuration = configuration;
	}
	public String getHelloMessage(String name) {
		return this.configuration.getGreeting() + ' ' + name;
	}
}
/*
package smoketest.parent;
@SpringBootApplication
public class SampleParentContextApplication {
	public static void main(String[] args) {
		new SpringApplicationBuilder(Parent.class).child(SampleParentContextApplication.class).run(args);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAutoConfiguration
	protected static class Parent {
		private final ServiceProperties serviceProperties;
		public Parent(ServiceProperties serviceProperties) {
			this.serviceProperties = serviceProperties;
		}
		@Bean
		public FileReadingMessageSource fileReader() {
			FileReadingMessageSource reader = new FileReadingMessageSource();
			reader.setDirectory(this.serviceProperties.getInputDir());
			return reader;
		}
		@Bean
		public DirectChannel inputChannel() {
			return new DirectChannel();
		}
		@Bean
		public DirectChannel outputChannel() {
			return new DirectChannel();
		}
		@Bean
		public FileWritingMessageHandler fileWriter() {
			FileWritingMessageHandler writer = new FileWritingMessageHandler(this.serviceProperties.getOutputDir());
			writer.setExpectReply(false);
			return writer;
		}
		@Bean
		public IntegrationFlow integrationFlow(SampleEndpoint endpoint) {
			return IntegrationFlow.from(fileReader(), new FixedRatePoller())
				.channel(inputChannel())
				.handle(endpoint)
				.channel(outputChannel())
				.handle(fileWriter())
				.get();
		}
		private static final class FixedRatePoller implements Consumer<SourcePollingChannelAdapterSpec> {
			@Override
			public void accept(SourcePollingChannelAdapterSpec spec) {
				spec.poller(Pollers.fixedRate(500));
			}
		}
	}
}
/*
package smoketest.parent;
@MessageEndpoint
public class SampleEndpoint {
	private final HelloWorldService helloWorldService;
	public SampleEndpoint(HelloWorldService helloWorldService) {
		this.helloWorldService = helloWorldService;
	}
	@ServiceActivator
	public String hello(File input) throws Exception {
		FileInputStream in = new FileInputStream(input);
		String name = new String(StreamUtils.copyToByteArray(in));
		in.close();
		return this.helloWorldService.getHelloMessage(name);
	}
}
/*
package smoketest.session;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'server.servlet.session.timeout:2' })
class SampleSessionJdbcApplicationTests {
	private static final ClientHttpRequestFactorySettings DONT_FOLLOW_REDIRECTS = ClientHttpRequestFactorySettings
		.defaults()
		.withRedirects(Redirects.DONT_FOLLOW);
	@Autowired
	private RestTemplateBuilder restTemplateBuilder;
	@Autowired
	private TestRestTemplate restTemplate;
	@LocalServerPort
	private String port;
	private static final URI ROOT_URI = URI.create('/');
	@Test
	void sessionExpiry() throws Exception {
		String cookie = performLogin();
		String sessionId1 = performRequest(ROOT_URI, cookie).getBody();
		String sessionId2 = performRequest(ROOT_URI, cookie).getBody();
		assertThat(sessionId1).isEqualTo(sessionId2);
		Thread.sleep(2100);
		String loginPage = performRequest(ROOT_URI, cookie).getBody();
		assertThat(loginPage).containsIgnoringCase('login');
	}
	private String performLogin() {
		RestTemplate restTemplate = this.restTemplateBuilder.requestFactorySettings(DONT_FOLLOW_REDIRECTS).build();
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'password');
		ResponseEntity<String> entity = restTemplate.exchange('http://localhost:' + this.port + '/login',
				HttpMethod.POST, new HttpEntity<>(form, headers), String.class);
		return entity.getHeaders().getFirst('Set-Cookie');
	}
	@Test
	@SuppressWarnings('unchecked')
	void sessionsEndpointShouldReturnUserSession() {
		performLogin();
		ResponseEntity<Map<String, Object>> response = getSessions();
		assertThat(response).isNotNull();
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		List<Map<String, Object>> sessions = (List<Map<String, Object>>) response.getBody().get('sessions');
		assertThat(sessions).hasSize(1);
	}
	private ResponseEntity<String> performRequest(URI uri, String cookie) {
		HttpHeaders headers = getHeaders(cookie);
		RequestEntity<Object> request = new RequestEntity<>(headers, HttpMethod.GET, uri);
		return this.restTemplate.exchange(request, String.class);
	}
	private HttpHeaders getHeaders(String cookie) {
		HttpHeaders headers = new HttpHeaders();
		if (cookie != null) {
			headers.set('Cookie', cookie);
		}
		else {
			headers.set('Authorization', getBasicAuth());
		}
		return headers;
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
	private ResponseEntity<Map<String, Object>> getSessions() {
		HttpHeaders headers = getHeaders(null);
		RequestEntity<Object> request = new RequestEntity<>(headers, HttpMethod.GET,
				URI.create('/actuator/sessions?username=user'));
		ParameterizedTypeReference<Map<String, Object>> stringObjectMap = new ParameterizedTypeReference<>() {
		};
		return this.restTemplate.exchange(request, stringObjectMap);
	}
}
/*
package smoketest.session;
@RestController
public class HelloRestController {
	@GetMapping('/')
	String uid(HttpSession session) {
		return session.getId();
	}
}
/*
package smoketest.session;
@SpringBootApplication
public class SampleSessionJdbcApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSessionJdbcApplication.class);
	}
}
/*
package smoketest.session;
/**
@Configuration(proxyBeanMethods = false)
class SecurityConfiguration {
	@Bean
	SecurityFilterChain managementSecurityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> {
			requests.requestMatchers(EndpointRequest.to(HealthEndpoint.class)).permitAll();
			requests.anyRequest().authenticated();
		});
		http.formLogin(withDefaults());
		http.httpBasic(withDefaults());
		http.csrf(CsrfConfigurer::disable);
		return http.build();
	}
}
/*
package smoketest.webflux;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebFluxApplicationTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void testWelcome() {
		this.webClient.get()
			.uri('/')
			.accept(MediaType.TEXT_PLAIN)
			.exchange()
			.expectBody(String.class)
			.isEqualTo('Hello World');
	}
	@Test
	void testEcho() {
		this.webClient.post()
			.uri('/echo')
			.contentType(MediaType.TEXT_PLAIN)
			.accept(MediaType.TEXT_PLAIN)
			.body(Mono.just('Hello WebFlux!'), String.class)
			.exchange()
			.expectBody(String.class)
			.isEqualTo('Hello WebFlux!');
	}
	@Test
	void testActuatorStatus() {
		this.webClient.get()
			.uri('/actuator/health')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.json('{\'status\':\'UP\'}');
	}
}
/*
package smoketest.webflux;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'management.server.port=0', 'management.endpoints.web.base-path=/' })
class SampleWebFluxApplicationActuatorDifferentPortTests {
	@LocalManagementPort
	private int managementPort;
	@Test
	void linksEndpointShouldBeAvailable() {
		ResponseEntity<String> entity = new TestRestTemplate('user', getPassword())
			.getForEntity('http://localhost:' + this.managementPort + '/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('\'_links\'');
	}
	private String getPassword() {
		return 'password';
	}
}
/*
package smoketest.webflux;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = 'management.endpoints.jackson.isolated-object-mapper=false')
@ContextConfiguration(loader = ApplicationStartupSpringBootContextLoader.class)
class SampleWebFluxApplicationActuatorIsolatedObjectMapperFalseTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void linksEndpointShouldBeAvailable() {
		this.webClient.get()
			.uri('/actuator/startup')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.is5xxServerError();
	}
}
/*
package smoketest.webflux;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = 'management.endpoints.jackson.isolated-object-mapper=true')
@ContextConfiguration(loader = ApplicationStartupSpringBootContextLoader.class)
class SampleWebFluxApplicationActuatorIsolatedObjectMapperTrueTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void linksEndpointShouldBeAvailable() {
		this.webClient.get()
			.uri('/actuator/startup')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody()
			.consumeWith(this::assertExpectedJson);
	}
	private void assertExpectedJson(EntityExchangeResult<byte[]> result) {
		String body = new String(result.getResponseBody(), StandardCharsets.UTF_8);
		assertThat(body).contains('\'timeline\':');
	}
}
/*
package smoketest.webflux;
class ApplicationStartupSpringBootContextLoader extends SpringBootContextLoader {
	@Override
	protected SpringApplication getSpringApplication() {
		SpringApplication application = new SpringApplication();
		application.setApplicationStartup(new BufferingApplicationStartup(1024));
		return application;
	}
}
/*
package smoketest.webflux;
@RestController
public class ExampleController {
	@PostMapping(path = '/', consumes = { MediaType.APPLICATION_JSON_VALUE, '!application/xml' },
			produces = MediaType.TEXT_PLAIN_VALUE, headers = 'X-Custom=Foo', params = 'a!=alpha')
	public String example() {
		return 'Hello World';
	}
}
/*
package smoketest.webflux;
@RestController
public class WelcomeController {
	@GetMapping('/')
	public String welcome() {
		return 'Hello World';
	}
}
/*
package smoketest.webflux;
@SpringBootApplication
public class SampleWebFluxApplication {
	public static void main(String[] args) {
		SpringApplication application = new SpringApplication(SampleWebFluxApplication.class);
		application.setApplicationStartup(new BufferingApplicationStartup(1024));
		application.run(args);
	}
	@Bean
	public RouterFunction<ServerResponse> monoRouterFunction(EchoHandler echoHandler) {
		return route(POST('/echo'), echoHandler::echo);
	}
}
/*
package smoketest.webflux;
@Component
public class EchoHandler {
	public Mono<ServerResponse> echo(ServerRequest request) {
		return ServerResponse.ok().body(request.bodyToMono(String.class), String.class);
	}
}
/*
package smoketest.undertow.ssl;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleUndertowSslApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private AbstractConfigurableWebServerFactory webServerFactory;
	@Test
	void testSsl() {
		assertThat(this.webServerFactory.getSsl().isEnabled()).isTrue();
	}
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
}
/*
package smoketest.undertow.ssl.web;
@RestController
public class SampleController {
	@GetMapping('/')
	public String helloWorld() {
		return 'Hello World';
	}
}
/*
package smoketest.undertow.ssl;
@SpringBootApplication
public class SampleUndertowSslApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleUndertowSslApplication.class, args);
	}
}
/*
package smoketest.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
@SpringBootTest(properties = { 'spring.data.redis.ssl.bundle=client',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
class SampleRedisApplicationSslTests {
	private static final Charset CHARSET = StandardCharsets.UTF_8;
	@Container
	@ServiceConnection
	static RedisContainer redis = TestImage.container(SecureRedisContainer.class);
	@Autowired
	private RedisOperations<Object, Object> operations;
	@Autowired
	private SampleRepository exampleRepository;
	@Test
	void testRepository() {
		PersonHash personHash = new PersonHash();
		personHash.setDescription('Look, new @DataRedisTest!');
		assertThat(personHash.getId()).isNull();
		PersonHash savedEntity = this.exampleRepository.save(personHash);
		assertThat(savedEntity.getId()).isNotNull();
		assertThat(this.operations
			.execute((org.springframework.data.redis.connection.RedisConnection connection) -> connection.keyCommands()
				.exists(('persons:' + savedEntity.getId()).getBytes(CHARSET))))
			.isTrue();
		this.exampleRepository.deleteAll();
	}
}
/*
package smoketest.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
@SpringBootTest(properties = { 'spring.data.redis.ssl.bundle=client',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
class SampleRedisApplicationReactiveSslTests {
	@Container
	@ServiceConnection
	static RedisContainer redis = TestImage.container(SecureRedisContainer.class);
	@Autowired
	private ReactiveRedisOperations<Object, Object> operations;
	@Test
	void testRepository() {
		String id = UUID.randomUUID().toString();
		StepVerifier.create(this.operations.opsForValue().set(id, 'Hello World'))
			.expectNext(Boolean.TRUE)
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		StepVerifier.create(this.operations.opsForValue().get(id))
			.expectNext('Hello World')
			.expectComplete()
			.verify(Duration.ofSeconds(30));
		StepVerifier.create(this.operations.execute((action) -> action.serverCommands().flushDb()))
			.expectNext('OK')
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
}
/*
package smoketest.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
@ClassPathExclusions('lettuce-core-*.jar')
@DataRedisTest(properties = { 'spring.data.redis.ssl.bundle=client',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
class SampleRedisApplicationJedisSslTests {
	private static final Charset CHARSET = StandardCharsets.UTF_8;
	@Container
	@ServiceConnection
	static RedisContainer redis = TestImage.container(SecureRedisContainer.class);
	@Autowired
	private RedisOperations<Object, Object> operations;
	@Autowired
	private SampleRepository exampleRepository;
	@Test
	void testRepository() {
		PersonHash personHash = new PersonHash();
		personHash.setDescription('Look, new @DataRedisTest!');
		assertThat(personHash.getId()).isNull();
		PersonHash savedEntity = this.exampleRepository.save(personHash);
		assertThat(savedEntity.getId()).isNotNull();
		assertThat(this.operations
			.execute((org.springframework.data.redis.connection.RedisConnection connection) -> connection.keyCommands()
				.exists(('persons:' + savedEntity.getId()).getBytes(CHARSET))))
			.isTrue();
		this.exampleRepository.deleteAll();
	}
}
/*
package smoketest.data.redis;
/**
class SecureRedisContainer extends RedisContainer {
	SecureRedisContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.crt'), '/ssl/server.crt');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.key'), '/ssl/server.key');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-ca.crt'), '/ssl/ca.crt');
		withCommand('redis-server --tls-port 6379 --port 0 '
				+ '--tls-cert-file /ssl/server.crt --tls-key-file /ssl/server.key --tls-ca-cert-file /ssl/ca.crt');
	}
}
/*
package smoketest.data.redis;
@Service
public class SampleService {
	private static final Charset CHARSET = StandardCharsets.UTF_8;
	private final RedisOperations<Object, Object> operations;
	public SampleService(RedisOperations<Object, Object> operations) {
		this.operations = operations;
	}
	public boolean hasRecord(PersonHash personHash) {
		return this.operations.execute((RedisConnection connection) -> connection.keyCommands()
			.exists(('persons:' + personHash.getId()).getBytes(CHARSET)));
	}
}
/*
package smoketest.data.redis;
@RedisHash('persons')
public class PersonHash {
	@Id
	private String id;
	private String description;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
}
/*
package smoketest.data.redis;
interface SampleRepository extends CrudRepository<PersonHash, String> {
}
/*
package smoketest.data.redis;
@SpringBootApplication
public class SampleRedisApplication {
}
/*
package smoketest.test;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@AutoConfigureTestDatabase
class SampleTestApplicationWebIntegrationTests {
	private static final VehicleIdentificationNumber VIN = new VehicleIdentificationNumber('01234567890123456');
	@Autowired
	private TestRestTemplate restTemplate;
	@MockitoBean
	private VehicleDetailsService vehicleDetailsService;
	@BeforeEach
	void setup() {
		given(this.vehicleDetailsService.getVehicleDetails(VIN)).willReturn(new VehicleDetails('Honda', 'Civic'));
	}
	@Test
	void test() {
		assertThat(this.restTemplate.getForEntity('/{username}/vehicle', String.class, 'sframework').getStatusCode())
			.isEqualTo(HttpStatus.OK);
	}
}
/*
package smoketest.test.web;
/**
@WebMvcTest(UserVehicleController.class)
class UserVehicleControllerTests {
	private static final VehicleIdentificationNumber VIN = new VehicleIdentificationNumber('00000000000000000');
	@Autowired
	private MockMvcTester mvc;
	@Autowired
	private ApplicationContext applicationContext;
	@MockitoBean
	private UserVehicleService userVehicleService;
	@Test
	void getVehicleWhenRequestingTextShouldReturnMakeAndModel() {
		given(this.userVehicleService.getVehicleDetails('sboot')).willReturn(new VehicleDetails('Honda', 'Civic'));
		assertThat(this.mvc.get().uri('/sboot/vehicle').accept(MediaType.TEXT_PLAIN)).hasStatusOk()
			.hasBodyTextEqualTo('Honda Civic');
	}
	@Test
	void getVehicleWhenRequestingJsonShouldReturnMakeAndModel() {
		given(this.userVehicleService.getVehicleDetails('sboot')).willReturn(new VehicleDetails('Honda', 'Civic'));
		assertThat(this.mvc.get().uri('/sboot/vehicle').accept(MediaType.APPLICATION_JSON)).hasStatusOk()
			.bodyJson()
			.isLenientlyEqualTo('{"make":"Honda","model":"Civic"}');
	}
	@Test
	void getVehicleWhenRequestingHtmlShouldReturnMakeAndModel() {
		given(this.userVehicleService.getVehicleDetails('sboot')).willReturn(new VehicleDetails('Honda', 'Civic'));
		assertThat(this.mvc.get().uri('/sboot/vehicle.html').accept(MediaType.TEXT_HTML)).hasStatusOk()
			.bodyText()
			.contains('<h1>Honda Civic</h1>');
	}
	@Test
	void getVehicleWhenUserNotFoundShouldReturnNotFound() {
		given(this.userVehicleService.getVehicleDetails('sboot')).willThrow(new UserNameNotFoundException('sboot'));
		assertThat(this.mvc.get().uri('/sboot/vehicle')).hasStatus(HttpStatus.NOT_FOUND);
	}
	@Test
	void getVehicleWhenVinNotFoundShouldReturnNotFound() {
		given(this.userVehicleService.getVehicleDetails('sboot'))
			.willThrow(new VehicleIdentificationNumberNotFoundException(VIN));
		assertThat(this.mvc.get().uri('/sboot/vehicle')).hasStatus(HttpStatus.NOT_FOUND);
	}
	@Test
	void welcomeCommandLineRunnerShouldNotBeAvailable() {
		// Since we"re a @WebMvcTest WelcomeCommandLineRunner should not be available.
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.applicationContext.getBean(WelcomeCommandLineRunner.class));
	}
}
/*
package smoketest.test.web;
/**
@ExtendWith(MockitoExtension.class)
class UserVehicleServiceTests {
	private static final VehicleIdentificationNumber VIN = new VehicleIdentificationNumber('00000000000000000');
	@Mock
	private VehicleDetailsService vehicleDetailsService;
	@Mock
	private UserRepository userRepository;
	private UserVehicleService service;
	@BeforeEach
	void setup() {
		this.service = new UserVehicleService(this.userRepository, this.vehicleDetailsService);
	}
	@Test
	void getVehicleDetailsWhenUsernameIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.service.getVehicleDetails(null))
			.withMessage('Username must not be null');
	}
	@Test
	void getVehicleDetailsWhenUsernameNotFoundShouldThrowException() {
		given(this.userRepository.findByUsername(anyString())).willReturn(null);
		assertThatExceptionOfType(UserNameNotFoundException.class)
			.isThrownBy(() -> this.service.getVehicleDetails('sboot'));
	}
	@Test
	void getVehicleDetailsShouldReturnMakeAndModel() {
		given(this.userRepository.findByUsername(anyString())).willReturn(new User('sboot', VIN));
		VehicleDetails details = new VehicleDetails('Honda', 'Civic');
		given(this.vehicleDetailsService.getVehicleDetails(VIN)).willReturn(details);
		VehicleDetails actual = this.service.getVehicleDetails('sboot');
		assertThat(actual).isEqualTo(details);
	}
}
/*
package smoketest.test.web;
/**
@WebMvcTest(UserVehicleController.class)
class UserVehicleControllerSeleniumTests {
	@Autowired
	private WebDriver webDriver;
	@MockitoBean
	private UserVehicleService userVehicleService;
	@Test
	void getVehicleWhenRequestingTextShouldReturnMakeAndModel() {
		given(this.userVehicleService.getVehicleDetails('sboot')).willReturn(new VehicleDetails('Honda', 'Civic'));
		this.webDriver.get('/sboot/vehicle.html');
		WebElement element = this.webDriver.findElement(By.tagName('h1'));
		assertThat(element.getText()).isEqualTo('Honda Civic');
	}
}
/*
package smoketest.test.web;
/**
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureTestDatabase
class UserVehicleControllerApplicationTests {
	@Autowired
	private MockMvcTester mvc;
	@Autowired
	private ApplicationContext applicationContext;
	@MockitoBean
	private UserVehicleService userVehicleService;
	@Test
	void getVehicleWhenRequestingTextShouldReturnMakeAndModel() {
		given(this.userVehicleService.getVehicleDetails('sboot')).willReturn(new VehicleDetails('Honda', 'Civic'));
		assertThat(this.mvc.get().uri('/sboot/vehicle').accept(MediaType.TEXT_PLAIN)).hasStatusOk()
			.hasBodyTextEqualTo('Honda Civic');
	}
	@Test
	void welcomeCommandLineRunnerShouldBeAvailable() {
		// Since we"re a @SpringBootTest all beans should be available.
		assertThat(this.applicationContext.getBean(WelcomeCommandLineRunner.class)).isNotNull();
	}
}
/*
package smoketest.test.web;
/**
@WebMvcTest(UserVehicleController.class)
class UserVehicleControllerHtmlUnitTests {
	@Autowired
	private WebClient webClient;
	@MockitoBean
	private UserVehicleService userVehicleService;
	@Test
	void getVehicleWhenRequestingTextShouldReturnMakeAndModel() throws Exception {
		given(this.userVehicleService.getVehicleDetails('sboot')).willReturn(new VehicleDetails('Honda', 'Civic'));
		HtmlPage page = this.webClient.getPage('/sboot/vehicle.html');
		assertThat(page.getBody().getTextContent()).isEqualTo('Honda Civic');
	}
}
/*
package smoketest.test.domain;
/**
class VehicleIdentificationNumberTests {
	private static final String SAMPLE_VIN = '41549485710496749';
	@Test
	void createWhenVinIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new VehicleIdentificationNumber(null))
			.withMessage('VIN must not be null');
	}
	@Test
	void createWhenVinIsMoreThan17CharsShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new VehicleIdentificationNumber('012345678901234567'))
			.withMessage('VIN must be exactly 17 characters');
	}
	@Test
	void createWhenVinIsLessThan17CharsShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new VehicleIdentificationNumber('0123456789012345'))
			.withMessage('VIN must be exactly 17 characters');
	}
	@Test
	void toStringShouldReturnVin() {
		VehicleIdentificationNumber vin = new VehicleIdentificationNumber(SAMPLE_VIN);
		assertThat(vin).hasToString(SAMPLE_VIN);
	}
	@Test
	void equalsAndHashCodeShouldBeBasedOnVin() {
		VehicleIdentificationNumber vin1 = new VehicleIdentificationNumber(SAMPLE_VIN);
		VehicleIdentificationNumber vin2 = new VehicleIdentificationNumber(SAMPLE_VIN);
		VehicleIdentificationNumber vin3 = new VehicleIdentificationNumber('00000000000000000');
		assertThat(vin1).hasSameHashCodeAs(vin2);
		assertThat(vin1).isEqualTo(vin1).isEqualTo(vin2).isNotEqualTo(vin3);
	}
}
/*
package smoketest.test.domain;
/**
@DataJpaTest
class UserRepositoryTests {
	private static final VehicleIdentificationNumber VIN = new VehicleIdentificationNumber('00000000000000000');
	@Autowired
	private TestEntityManager entityManager;
	@Autowired
	private UserRepository repository;
	@Test
	void findByUsernameShouldReturnUser() {
		this.entityManager.persist(new User('sboot', VIN));
		User user = this.repository.findByUsername('sboot');
		assertThat(user.getUsername()).isEqualTo('sboot');
		assertThat(user.getVin()).isEqualTo(VIN);
	}
	@Test
	void findByUsernameWhenNoUserShouldReturnNull() {
		this.entityManager.persist(new User('sboot', VIN));
		User user = this.repository.findByUsername('mmouse');
		assertThat(user).isNull();
	}
}
/*
package smoketest.test.domain;
/**
@DataJpaTest
class UserEntityTests {
	private static final VehicleIdentificationNumber VIN = new VehicleIdentificationNumber('00000000000000000');
	@Autowired
	private TestEntityManager entityManager;
	@Test
	void createWhenUsernameIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new User(null, VIN))
			.withMessage('Username must not be empty');
	}
	@Test
	void createWhenUsernameIsEmptyShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new User('', VIN))
			.withMessage('Username must not be empty');
	}
	@Test
	void createWhenVinIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new User('sboot', null))
			.withMessage('VIN must not be null');
	}
	@Test
	void saveShouldPersistData() {
		User user = this.entityManager.persistFlushFind(new User('sboot', VIN));
		assertThat(user.getUsername()).isEqualTo('sboot');
		assertThat(user.getVin()).isEqualTo(VIN);
	}
}
/*
package smoketest.test.service;
/**
@RestClientTest({ RemoteVehicleDetailsService.class, ServiceProperties.class })
class RemoteVehicleDetailsServiceTests {
	private static final String VIN = '00000000000000000';
	@Autowired
	private RemoteVehicleDetailsService service;
	@Autowired
	private MockRestServiceServer server;
	@Test
	void getVehicleDetailsWhenVinIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.service.getVehicleDetails(null))
			.withMessage('VIN must not be null');
	}
	@Test
	void getVehicleDetailsWhenResultIsSuccessShouldReturnDetails() {
		this.server.expect(requestTo('/vehicle/' + VIN + '/details'))
			.andRespond(withSuccess(getClassPathResource('vehicledetails.json'), MediaType.APPLICATION_JSON));
		VehicleDetails details = this.service.getVehicleDetails(new VehicleIdentificationNumber(VIN));
		assertThat(details.getMake()).isEqualTo('Honda');
		assertThat(details.getModel()).isEqualTo('Civic');
	}
	@Test
	void getVehicleDetailsWhenResultIsNotFoundShouldThrowException() {
		this.server.expect(requestTo('/vehicle/' + VIN + '/details')).andRespond(withStatus(HttpStatus.NOT_FOUND));
		assertThatExceptionOfType(VehicleIdentificationNumberNotFoundException.class)
			.isThrownBy(() -> this.service.getVehicleDetails(new VehicleIdentificationNumber(VIN)));
	}
	@Test
	void getVehicleDetailsWhenResultIServerErrorShouldThrowException() {
		this.server.expect(requestTo('/vehicle/' + VIN + '/details')).andRespond(withServerError());
		assertThatExceptionOfType(HttpServerErrorException.class)
			.isThrownBy(() -> this.service.getVehicleDetails(new VehicleIdentificationNumber(VIN)));
	}
	private ClassPathResource getClassPathResource(String path) {
		return new ClassPathResource(path, getClass());
	}
}
/*
package smoketest.test.service;
/**
@JsonTest
class VehicleDetailsJsonTests {
	@Autowired
	private JacksonTester<VehicleDetails> json;
	@Test
	void serializeJson() throws Exception {
		VehicleDetails details = new VehicleDetails('Honda', 'Civic');
		assertThat(this.json.write(details)).isEqualTo('vehicledetails.json');
		assertThat(this.json.write(details)).isEqualToJson('vehicledetails.json');
		assertThat(this.json.write(details)).hasJsonPathStringValue('@.make');
		assertThat(this.json.write(details)).extractingJsonPathStringValue('@.make').isEqualTo('Honda');
	}
	@Test
	void deserializeJson() throws Exception {
		String content = '{\'make\':\'Ford\',\'model\':\'Focus\'}';
		assertThat(this.json.parse(content)).isEqualTo(new VehicleDetails('Ford', 'Focus'));
		assertThat(this.json.parseObject(content).getMake()).isEqualTo('Ford');
	}
}
/*
package smoketest.test.web;
/**
@RestController
public class UserVehicleController {
	private final UserVehicleService userVehicleService;
	public UserVehicleController(UserVehicleService userVehicleService) {
		this.userVehicleService = userVehicleService;
	}
	@GetMapping(path = '/{username}/vehicle', produces = MediaType.TEXT_PLAIN_VALUE)
	public String getVehicleDetailsText(@PathVariable String username) {
		VehicleDetails details = this.userVehicleService.getVehicleDetails(username);
		return details.getMake() + ' ' + details.getModel();
	}
	@GetMapping(path = '/{username}/vehicle', produces = MediaType.APPLICATION_JSON_VALUE)
	public VehicleDetails VehicleDetailsJson(@PathVariable String username) {
		return this.userVehicleService.getVehicleDetails(username);
	}
	@GetMapping(path = '/{username}/vehicle.html', produces = MediaType.TEXT_HTML_VALUE)
	public String VehicleDetailsHtml(@PathVariable String username) {
		VehicleDetails details = this.userVehicleService.getVehicleDetails(username);
		String makeAndModel = details.getMake() + ' ' + details.getModel();
		return '<html><body><h1>' + makeAndModel + '</h1></body></html>';
	}
	@ExceptionHandler
	@ResponseStatus(HttpStatus.NOT_FOUND)
	private void handleVinNotFound(VehicleIdentificationNumberNotFoundException ex) {
	}
}
/*
package smoketest.test.web;
@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNameNotFoundException extends RuntimeException {
	private final String username;
	public UserNameNotFoundException(String username) {
		this.username = username;
	}
	public String getUsername() {
		return this.username;
	}
}
/*
package smoketest.test.web;
/**
@Component
public class UserVehicleService {
	private final UserRepository userRepository;
	private final VehicleDetailsService vehicleDetailsService;
	public UserVehicleService(UserRepository userRepository, VehicleDetailsService vehicleDetailsService) {
		this.userRepository = userRepository;
		this.vehicleDetailsService = vehicleDetailsService;
	}
	public VehicleDetails getVehicleDetails(String username)
			throws UserNameNotFoundException, VehicleIdentificationNumberNotFoundException {
		Assert.notNull(username, 'Username must not be null');
		User user = this.userRepository.findByUsername(username);
		if (user == null) {
			throw new UserNameNotFoundException(username);
		}
		return this.vehicleDetailsService.getVehicleDetails(user.getVin());
	}
}
/*
package smoketest.test.domain;
/**
public final class VehicleIdentificationNumber {
	private final String vin;
	public VehicleIdentificationNumber(String vin) {
		Assert.notNull(vin, 'VIN must not be null');
		Assert.isTrue(vin.length() == 17, 'VIN must be exactly 17 characters');
		this.vin = vin;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		return this.vin.equals(((VehicleIdentificationNumber) obj).vin);
	}
	@Override
	public int hashCode() {
		return this.vin.hashCode();
	}
	@Override
	public String toString() {
		return this.vin;
	}
}
/*
package smoketest.test.domain;
/**
@Entity
@Table(name = 'DRIVER')
public class User {
	@Id
	@GeneratedValue
	private Long id;
	@Column(unique = true)
	private String username;
	private VehicleIdentificationNumber vin;
	protected User() {
	}
	public User(String username, VehicleIdentificationNumber vin) {
		Assert.hasLength(username, 'Username must not be empty');
		Assert.notNull(vin, 'VIN must not be null');
		this.username = username;
		this.vin = vin;
	}
	public Long getId() {
		return this.id;
	}
	public String getUsername() {
		return this.username;
	}
	public VehicleIdentificationNumber getVin() {
		return this.vin;
	}
}
/*
package smoketest.test.domain;
/**
@Converter(autoApply = true)
public class VehicleIdentificationNumberAttributeConverter
		implements AttributeConverter<VehicleIdentificationNumber, String> {
	@Override
	public String convertToDatabaseColumn(VehicleIdentificationNumber attribute) {
		return attribute.toString();
	}
	@Override
	public VehicleIdentificationNumber convertToEntityAttribute(String dbData) {
		return new VehicleIdentificationNumber(dbData);
	}
}
/*
package smoketest.test.domain;
/**
public interface UserRepository extends Repository<User, Long> {
	User findByUsername(String username);
}
/*
package smoketest.test.service;
/**
@ConfigurationProperties
public class ServiceProperties {
	private String vehicleServiceRootUrl = 'http://localhost:8080/vs';
	public String getVehicleServiceRootUrl() {
		return this.vehicleServiceRootUrl;
	}
	public void setVehicleServiceRootUrl(String vehicleServiceRootUrl) {
		this.vehicleServiceRootUrl = vehicleServiceRootUrl;
	}
}
/*
package smoketest.test.service;
/**
public interface VehicleDetailsService {
	/**
	 * Get vehicle details for a given {@link VehicleIdentificationNumber}.
	 * @param vin the vehicle identification number
	 * @return vehicle details
	 * @throws VehicleIdentificationNumberNotFoundException if the VIN is not known
	 */
	VehicleDetails getVehicleDetails(VehicleIdentificationNumber vin)
			throws VehicleIdentificationNumberNotFoundException;
}
/*
package smoketest.test.service;
/**
public class VehicleDetails {
	private final String make;
	private final String model;
	@JsonCreator
	public VehicleDetails(@JsonProperty('make') String make, @JsonProperty('model') String model) {
		Assert.notNull(make, 'Make must not be null');
		Assert.notNull(model, 'Model must not be null');
		this.make = make;
		this.model = model;
	}
	public String getMake() {
		return this.make;
	}
	public String getModel() {
		return this.model;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;
		}
		if (obj == null || obj.getClass() != getClass()) {
			return false;
		}
		VehicleDetails other = (VehicleDetails) obj;
		return this.make.equals(other.make) && this.model.equals(other.model);
	}
	@Override
	public int hashCode() {
		return this.make.hashCode() * 31 + this.model.hashCode();
	}
}
/*
package smoketest.test.service;
/**
@Service
public class RemoteVehicleDetailsService implements VehicleDetailsService {
	private static final Log logger = LogFactory.getLog(RemoteVehicleDetailsService.class);
	private final RestTemplate restTemplate;
	public RemoteVehicleDetailsService(ServiceProperties properties, RestTemplateBuilder restTemplateBuilder) {
		this.restTemplate = restTemplateBuilder.rootUri(properties.getVehicleServiceRootUrl()).build();
	}
	@Override
	public VehicleDetails getVehicleDetails(VehicleIdentificationNumber vin)
			throws VehicleIdentificationNumberNotFoundException {
		Assert.notNull(vin, 'VIN must not be null');
		logger.debug('Retrieving vehicle data for: ' + vin);
		try {
			return this.restTemplate.getForObject('/vehicle/{vin}/details', VehicleDetails.class, vin);
		}
		catch (HttpStatusCodeException ex) {
			if (HttpStatus.NOT_FOUND.equals(ex.getStatusCode())) {
				throw new VehicleIdentificationNumberNotFoundException(vin, ex);
			}
			throw ex;
		}
	}
}
/*
package smoketest.test.service;
/**
public class VehicleIdentificationNumberNotFoundException extends RuntimeException {
	private final VehicleIdentificationNumber vehicleIdentificationNumber;
	public VehicleIdentificationNumberNotFoundException(VehicleIdentificationNumber vin) {
		this(vin, null);
	}
	public VehicleIdentificationNumberNotFoundException(VehicleIdentificationNumber vin, Throwable cause) {
		super('Unable to find VehicleIdentificationNumber ' + vin, cause);
		this.vehicleIdentificationNumber = vin;
	}
	public VehicleIdentificationNumber getVehicleIdentificationNumber() {
		return this.vehicleIdentificationNumber;
	}
}
/*
package smoketest.test;
/**
@SpringBootApplication
@ConfigurationPropertiesScan
public class SampleTestApplication {
	// NOTE: this application will intentionally not start without MySQL, the test will
	// still run.
	public static void main(String[] args) {
		SpringApplication.run(SampleTestApplication.class, args);
	}
}
/*
package smoketest.test;
/**
@Component
public class WelcomeCommandLineRunner implements CommandLineRunner {
	@Override
	public void run(String... args) throws Exception {
		System.out.println('***** WELCOME TO THE DEMO *****');
	}
}
/*
package smoketest.cache;
@SpringBootTest
@Testcontainers(disabledWithoutDocker = true)
class SampleCacheApplicationRedisTests {
	@Container
	@ServiceConnection
	private static final RedisContainer redis = TestImage.container(RedisContainer.class);
	@Autowired
	private CacheManager cacheManager;
	@Autowired
	private CountryRepository countryRepository;
	@Test
	void validateCache() {
		Cache countries = this.cacheManager.getCache('countries');
		assertThat(countries).isNotNull();
		countries.clear(); // Simple test assuming the cache is empty
		assertThat(countries.get('BE')).isNull();
		Country be = this.countryRepository.findByCode('BE');
		assertThat((Country) countries.get('BE').get()).isEqualTo(be);
	}
}
/*
package smoketest.cache;
@SpringBootTest
class SampleCacheApplicationTests {
	@Autowired
	private CacheManager cacheManager;
	@Autowired
	private CountryRepository countryRepository;
	@Test
	void validateCache() {
		Cache countries = this.cacheManager.getCache('countries');
		assertThat(countries).isNotNull();
		countries.clear(); // Simple test assuming the cache is empty
		assertThat(countries.get('BE')).isNull();
		Country be = this.countryRepository.findByCode('BE');
		assertThat((Country) countries.get('BE').get()).isEqualTo(be);
	}
}
/*
package smoketest.cache;
@Component
@Profile('app')
class SampleClient {
	private static final List<String> SAMPLE_COUNTRY_CODES = Arrays.asList('AF', 'AX', 'AL', 'DZ', 'AS', 'AD', 'AO',
			'AI', 'AQ', 'AG', 'AR', 'AM', 'AW', 'AU', 'AT', 'AZ', 'BS', 'BH', 'BD', 'BB', 'BY', 'BE', 'BZ', 'BJ', 'BM',
			'BT', 'BO', 'BQ', 'BA', 'BW', 'BV', 'BR', 'IO', 'BN', 'BG', 'BF', 'BI', 'KH', 'CM', 'CA', 'CV', 'KY', 'CF',
			'TD', 'CL', 'CN', 'CX', 'CC', 'CO', 'KM', 'CG', 'CD', 'CK', 'CR', 'CI', 'HR', 'CU', 'CW', 'CY', 'CZ', 'DK',
			'DJ', 'DM', 'DO', 'EC', 'EG', 'SV', 'GQ', 'ER', 'EE', 'ET', 'FK', 'FO', 'FJ', 'FI', 'FR', 'GF', 'PF', 'TF',
			'GA', 'GM', 'GE', 'DE', 'GH', 'GI', 'GR', 'GL', 'GD', 'GP', 'GU', 'GT', 'GG', 'GN', 'GW', 'GY', 'HT', 'HM',
			'VA', 'HN', 'HK', 'HU', 'IS', 'IN', 'ID', 'IR', 'IQ', 'IE', 'IM', 'IL', 'IT', 'JM', 'JP', 'JE', 'JO', 'KZ',
			'KE', 'KI', 'KP', 'KR', 'KW', 'KG', 'LA', 'LV', 'LB', 'LS', 'LR', 'LY', 'LI', 'LT', 'LU', 'MO', 'MK', 'MG',
			'MW', 'MY', 'MV', 'ML', 'MT', 'MH', 'MQ', 'MR', 'MU', 'YT', 'MX', 'FM', 'MD', 'MC', 'MN', 'ME', 'MS', 'MA',
			'MZ', 'MM', 'NA', 'NR', 'NP', 'NL', 'NC', 'NZ', 'NI', 'NE', 'NG', 'NU', 'NF', 'MP', 'NO', 'OM', 'PK', 'PW',
			'PS', 'PA', 'PG', 'PY', 'PE', 'PH', 'PN', 'PL', 'PT', 'PR', 'QA', 'RE', 'RO', 'RU', 'RW', 'BL', 'SH', 'KN',
			'LC', 'MF', 'PM', 'VC', 'WS', 'SM', 'ST', 'SA', 'SN', 'RS', 'SC', 'SL', 'SG', 'SX', 'SK', 'SI', 'SB', 'SO',
			'ZA', 'GS', 'SS', 'ES', 'LK', 'SD', 'SR', 'SJ', 'SZ', 'SE', 'CH', 'SY', 'TW', 'TJ', 'TZ', 'TH', 'TL', 'TG',
			'TK', 'TO', 'TT', 'TN', 'TR', 'TM', 'TC', 'TV', 'UG', 'UA', 'AE', 'GB', 'US', 'UM', 'UY', 'UZ', 'VU', 'VE',
			'VN', 'VG', 'VI', 'WF', 'EH', 'YE', 'ZM', 'ZW');
	private final CountryRepository countryService;
	private final Random random;
	SampleClient(CountryRepository countryService) {
		this.countryService = countryService;
		this.random = new Random();
	}
	@Scheduled(fixedDelay = 500)
	void retrieveCountry() {
		String randomCode = SAMPLE_COUNTRY_CODES.get(this.random.nextInt(SAMPLE_COUNTRY_CODES.size()));
		System.out.println('Looking for country with code "' + randomCode + '"');
		this.countryService.findByCode(randomCode);
	}
}
/*
package smoketest.cache;
@Component
public class CacheManagerCheck implements CommandLineRunner {
	private static final Log logger = LogFactory.getLog(CacheManagerCheck.class);
	private final CacheManager cacheManager;
	public CacheManagerCheck(CacheManager cacheManager) {
		this.cacheManager = cacheManager;
	}
	@Override
	public void run(String... strings) throws Exception {
		logger.info('\n\n=========================================================\nUsing cache manager: '
				+ this.cacheManager.getClass().getName() + '\n'
				+ '=========================================================\n\n');
	}
}
/*
package smoketest.cache;
@Component
@CacheConfig(cacheNames = 'countries')
public class CountryRepository {
	@Cacheable
	public Country findByCode(String code) {
		System.out.println('---> Loading country with code "' + code + '"');
		return new Country(code);
	}
}
/*
package smoketest.cache;
@EnableCaching
@EnableScheduling
@SpringBootApplication
public class SampleCacheApplication {
	public static void main(String[] args) {
		new SpringApplicationBuilder().sources(SampleCacheApplication.class).profiles('app').run(args);
	}
}
/*
package smoketest.cache;
@SuppressWarnings('serial')
public class Country implements Serializable {
	private final String code;
	public Country(String code) {
		this.code = code;
	}
	public String getCode() {
		return this.code;
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Country country = (Country) o;
		return this.code.equals(country.code);
	}
	@Override
	public int hashCode() {
		return this.code.hashCode();
	}
}
/*
package smoketest.data.r2dbc;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataR2dbcTest
class CityRepositoryTests {
	@Container
	@ServiceConnection
	static PostgreSQLContainer<?> postgresql = TestImage.container(PostgreSQLContainer.class)
		.withDatabaseName('test_liquibase');
	@Autowired
	private CityRepository repository;
	@Test
	void databaseHasBeenInitialized() {
		StepVerifier.create(this.repository.findByState('DC').filter((city) -> city.getName().equals('Washington')))
			.consumeNextWith((city) -> assertThat(city.getId()).isNotNull())
			.expectComplete()
			.verify(Duration.ofSeconds(30));
	}
}
/*
package smoketest.data.r2dbc;
public class City {
	@Id
	private Long id;
	private String name;
	private String state;
	private String country;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public Long getId() {
		return this.id;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package smoketest.data.r2dbc;
@SpringBootApplication
public class SampleR2dbcLiquibaseApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleR2dbcLiquibaseApplication.class, args);
	}
}
/*
package smoketest.data.r2dbc;
public interface CityRepository extends ReactiveCrudRepository<City, Long> {
	Flux<City> findByState(String state);
}
/*
package smoketest.actuator.log4j2;
/**
@SpringBootTest
@AutoConfigureMockMvc
@ExtendWith(OutputCaptureExtension.class)
class SampleActuatorLog4J2ApplicationTests {
	private static final Logger logger = LogManager.getLogger(SampleActuatorLog4J2ApplicationTests.class);
	@Autowired
	private MockMvcTester mvc;
	@Test
	void testLogger(CapturedOutput output) {
		logger.info('Hello World');
		assertThat(output).contains('Hello World');
	}
	@Test
	void validateLoggersEndpoint() {
		assertThat(this.mvc.get()
			.uri('/actuator/loggers/org.apache.coyote.http11.Http11NioProtocol')
			.header('Authorization', getBasicAuth())).hasStatusOk()
			.hasBodyTextEqualTo('{\'configuredLevel\':\'WARN\',\'effectiveLevel\':\'WARN\'}');
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
}
/*
package smoketest.actuator.log4j2;
@SpringBootApplication
public class SampleActuatorLog4J2Application {
	public static void main(String[] args) {
		SpringApplication.run(SampleActuatorLog4J2Application.class, args);
	}
}
/*
package smoketest.traditional;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleTraditionalApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHomeJsp() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		String body = entity.getBody();
		assertThat(body).contains('<html>').contains('<h1>Home</h1>');
	}
	@Test
	void testStaticPage() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/index.html', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		String body = entity.getBody();
		assertThat(body).contains('<html>').contains('<h1>Hello</h1>');
	}
}
/*
package smoketest.traditional.config;
@EnableWebMvc
@ComponentScan
@Configuration(proxyBeanMethods = false)
public class WebConfig implements WebMvcConfigurer {
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController('/').setViewName('home');
	}
	@Bean
	public InternalResourceViewResolver viewResolver() {
		InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
		viewResolver.setPrefix('/WEB-INF/views/');
		viewResolver.setSuffix('.jsp');
		return viewResolver;
	}
	@Bean
	// Only used when running in embedded servlet
	public DispatcherServlet dispatcherServlet() {
		return new DispatcherServlet();
	}
	@Override
	public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
		configurer.enable();
	}
}
/*
package smoketest.traditional;
@SpringBootApplication
public class SampleTraditionalApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleTraditionalApplication.class, args);
	}
}
/*
package smoketest.servlet;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleServletApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHomeIsSecure() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, new HttpEntity<Void>(headers),
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.withBasicAuth('user', getPassword())
			.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
	private String getPassword() {
		return 'password';
	}
}
/*
package smoketest.servlet;
@SpringBootConfiguration
@EnableAutoConfiguration
public class SampleServletApplication extends SpringBootServletInitializer {
	@SuppressWarnings('serial')
	@Bean
	public Servlet dispatcherServlet() {
		return new GenericServlet() {
			@Override
			public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
				res.setContentType('text/plain');
				res.getWriter().append('Hello World');
			}
		};
	}
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleServletApplication.class);
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleServletApplication.class, args);
	}
}
/*
package smoketest.data.ldap;
/**
@ExtendWith(OutputCaptureExtension.class)
@SpringBootTest
class SampleLdapApplicationTests {
	@Test
	void testDefaultSettings(CapturedOutput output) {
		assertThat(output).contains('cn=Alice Smith');
	}
}
/*
package smoketest.data.ldap;
@Entry(objectClasses = { 'person', 'top' })
public class Person {
	@Id
	private Name dn;
	@Attribute(name = 'telephoneNumber')
	private String phone;
	@Override
	public String toString() {
		return String.format('Customer[dn=%s, phone="%s"]', this.dn, this.phone);
	}
}
/*
package smoketest.data.ldap;
public interface PersonRepository extends LdapRepository<Person> {
	Person findByPhone(String phone);
}
/*
package smoketest.data.ldap;
@SpringBootApplication
public class SampleLdapApplication implements CommandLineRunner {
	private final PersonRepository repository;
	public SampleLdapApplication(PersonRepository repository) {
		this.repository = repository;
	}
	@Override
	public void run(String... args) throws Exception {
		// fetch all people
		System.out.println('People found with findAll():');
		System.out.println('-------------------------------');
		for (Person person : this.repository.findAll()) {
			System.out.println(person);
		}
		System.out.println();
		// fetch an individual person
		System.out.println('Person found with findByPhone("+46 555-123456"):');
		System.out.println('--------------------------------');
		System.out.println(this.repository.findByPhone('+46 555-123456'));
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleLdapApplication.class, args).close();
	}
}
/*
package smoketest.web.thymeleaf;
/**
@SpringBootTest
@AutoConfigureMockMvc
class MessageControllerWebTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void testHome() {
		assertThat(this.mvc.get().uri('/')).hasStatusOk().bodyText().contains('<title>Messages');
	}
	@Test
	void testCreate() {
		assertThat(this.mvc.post().uri('/').param('text', 'FOO text').param('summary', 'FOO'))
			.hasStatus(HttpStatus.FOUND)
			.headers()
			.hasEntrySatisfying('Location',
					(values) -> assertThat(values).hasSize(1)
						.element(0)
						.satisfies(HamcrestCondition.matching(RegexMatcher.matches('/[0-9]+'))));
	}
	@Test
	void testCreateValidation() {
		assertThat(this.mvc.post().uri('/').param('text', '').param('summary', '')).hasStatusOk()
			.bodyText()
			.contains('is required');
	}
	private static class RegexMatcher extends TypeSafeMatcher<String> {
		private final String regex;
		RegexMatcher(String regex) {
			this.regex = regex;
		}
		@Override
		public boolean matchesSafely(String item) {
			return Pattern.compile(this.regex).matcher(item).find();
		}
		@Override
		public void describeMismatchSafely(String item, Description mismatchDescription) {
			mismatchDescription.appendText('was \'').appendText(item).appendText('\'');
		}
		@Override
		public void describeTo(Description description) {
			description.appendText('a string that matches regex: ').appendText(this.regex);
		}
		static org.hamcrest.Matcher<java.lang.String> matches(String regex) {
			return new RegexMatcher(regex);
		}
	}
}
/*
package smoketest.web.thymeleaf;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.http.client.redirects=dont-follow')
class SampleWebUiApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@LocalServerPort
	private int port;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('<title>Messages');
		assertThat(entity.getBody()).doesNotContain('layout:fragment');
	}
	@Test
	void testCreate() {
		MultiValueMap<String, String> map = new LinkedMultiValueMap<>();
		map.set('text', 'FOO text');
		map.set('summary', 'FOO');
		URI location = this.restTemplate.postForLocation('/', map);
		assertThat(location.toString()).contains('localhost:' + this.port);
	}
}
/*
package smoketest.web.thymeleaf;
@SpringBootApplication
public class SampleWebUiApplication {
	@Bean
	public MessageRepository messageRepository() {
		return new InMemoryMessageRepository();
	}
	@Bean
	public Converter<String, Message> messageConverter() {
		return new Converter<>() {
			@Override
			public Message convert(String id) {
				return messageRepository().findMessage(Long.valueOf(id));
			}
		};
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleWebUiApplication.class, args);
	}
}
/*
package smoketest.web.thymeleaf;
public class InMemoryMessageRepository implements MessageRepository {
	private static final AtomicLong counter = new AtomicLong();
	private final ConcurrentMap<Long, Message> messages = new ConcurrentHashMap<>();
	@Override
	public Iterable<Message> findAll() {
		return this.messages.values();
	}
	@Override
	public Message save(Message message) {
		Long id = message.getId();
		if (id == null) {
			id = counter.incrementAndGet();
			message.setId(id);
		}
		this.messages.put(id, message);
		return message;
	}
	@Override
	public Message findMessage(Long id) {
		return this.messages.get(id);
	}
	@Override
	public void deleteMessage(Long id) {
		this.messages.remove(id);
	}
}
/*
package smoketest.web.thymeleaf;
public class Message {
	private Long id;
	@NotEmpty(message = 'Text is required.')
	private String text;
	@NotEmpty(message = 'Summary is required.')
	private String summary;
	private Calendar created = Calendar.getInstance();
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public Calendar getCreated() {
		return this.created;
	}
	public void setCreated(Calendar created) {
		this.created = created;
	}
	public String getText() {
		return this.text;
	}
	public void setText(String text) {
		this.text = text;
	}
	public String getSummary() {
		return this.summary;
	}
	public void setSummary(String summary) {
		this.summary = summary;
	}
}
/*
package smoketest.web.thymeleaf;
public interface MessageRepository {
	Iterable<Message> findAll();
	Message save(Message message);
	Message findMessage(Long id);
	void deleteMessage(Long id);
}
/*
package smoketest.web.thymeleaf.mvc;
@Controller
@RequestMapping('/')
public class MessageController {
	private final MessageRepository messageRepository;
	public MessageController(MessageRepository messageRepository) {
		this.messageRepository = messageRepository;
	}
	@GetMapping
	public ModelAndView list() {
		Iterable<Message> messages = this.messageRepository.findAll();
		return new ModelAndView('messages/list', 'messages', messages);
	}
	@GetMapping('{id}')
	public ModelAndView view(@PathVariable('id') Message message) {
		return new ModelAndView('messages/view', 'message', message);
	}
	@GetMapping(params = 'form')
	public String createForm(@ModelAttribute Message message) {
		return 'messages/form';
	}
	@PostMapping
	public ModelAndView create(@Valid Message message, BindingResult result, RedirectAttributes redirect) {
		if (result.hasErrors()) {
			return new ModelAndView('messages/form', 'formErrors', result.getAllErrors());
		}
		message = this.messageRepository.save(message);
		redirect.addFlashAttribute('globalMessage', 'view.success');
		return new ModelAndView('redirect:/{message.id}', 'message.id', message.getId());
	}
	@RequestMapping('foo')
	public String foo() {
		throw new RuntimeException('Expected exception in controller');
	}
	@GetMapping('delete/{id}')
	public ModelAndView delete(@PathVariable('id') Long id) {
		this.messageRepository.deleteMessage(id);
		Iterable<Message> messages = this.messageRepository.findAll();
		return new ModelAndView('messages/list', 'messages', messages);
	}
	@GetMapping('modify/{id}')
	public ModelAndView modifyForm(@PathVariable('id') Message message) {
		return new ModelAndView('messages/form', 'message', message);
	}
}
/*
package smoketest.webservices;
/**
@WebServiceServerTest
@ExtendWith(OutputCaptureExtension.class)
class WebServiceServerTestSampleWsApplicationTests {
	@MockitoBean
	HumanResourceService service;
	@Autowired
	private MockWebServiceClient client;
	@Test
	void testSendingHolidayRequest(CapturedOutput output) throws ParseException {
		String request = '<hr:HolidayRequest xmlns:hr=\'https://company.example.com/hr/schemas\'>'
				+ '   <hr:Holiday>      <hr:StartDate>2013-10-20</hr:StartDate>'
				+ '      <hr:EndDate>2013-11-22</hr:EndDate>   </hr:Holiday>   <hr:Employee>'
				+ '      <hr:Number>1</hr:Number>      <hr:FirstName>John</hr:FirstName>'
				+ '      <hr:LastName>Doe</hr:LastName>   </hr:Employee></hr:HolidayRequest>';
		StreamSource source = new StreamSource(new StringReader(request));
		this.client.sendRequest(RequestCreators.withPayload(source)).andExpect(ResponseMatchers.noFault());
		DateFormat dateFormat = new SimpleDateFormat('yyyy-MM-dd');
		then(this.service).should()
			.bookHoliday(dateFormat.parse('2013-10-20'), dateFormat.parse('2013-11-22'), 'John Doe');
	}
}
/*
package smoketest.webservices;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@ExtendWith(OutputCaptureExtension.class)
class SampleWsApplicationTests {
	private final WebServiceTemplate webServiceTemplate = new WebServiceTemplate();
	@LocalServerPort
	private int serverPort;
	@BeforeEach
	void setUp() {
		this.webServiceTemplate.setDefaultUri('http://localhost:' + this.serverPort + '/services/');
	}
	@Test
	void testSendingHolidayRequest(CapturedOutput output) {
		final String request = '<hr:HolidayRequest xmlns:hr=\'https://company.example.com/hr/schemas\'>'
				+ '   <hr:Holiday>      <hr:StartDate>2013-10-20</hr:StartDate>'
				+ '      <hr:EndDate>2013-11-22</hr:EndDate>   </hr:Holiday>   <hr:Employee>'
				+ '      <hr:Number>1</hr:Number>      <hr:FirstName>John</hr:FirstName>'
				+ '      <hr:LastName>Doe</hr:LastName>   </hr:Employee></hr:HolidayRequest>';
		StreamSource source = new StreamSource(new StringReader(request));
		StreamResult result = new StreamResult(System.out);
		this.webServiceTemplate.sendSourceAndReceiveToResult(source, result);
		assertThat(output).contains('Booking holiday for');
	}
}
/*
package smoketest.webservices;
@SpringBootApplication
public class SampleWebServicesApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleWebServicesApplication.class, args);
	}
}
/*
package smoketest.webservices.service;
public interface HumanResourceService {
	void bookHoliday(Date startDate, Date endDate, String name);
}
/*
package smoketest.webservices.service;
@Service
public class StubHumanResourceService implements HumanResourceService {
	private final Log logger = LogFactory.getLog(StubHumanResourceService.class);
	@Override
	public void bookHoliday(Date startDate, Date endDate, String name) {
		this.logger.info('Booking holiday for [' + startDate + ' - ' + endDate + '] for [' + name + ']');
	}
}
/*
package smoketest.webservices.endpoint;
@Endpoint
public class HolidayEndpoint {
	private static final String NAMESPACE_URI = 'https://company.example.com/hr/schemas';
	private final XPathExpression<Element> startDateExpression;
	private final XPathExpression<Element> endDateExpression;
	private final XPathExpression<String> nameExpression;
	private final HumanResourceService humanResourceService;
	public HolidayEndpoint(HumanResourceService humanResourceService) {
		this.humanResourceService = humanResourceService;
		Namespace namespace = Namespace.getNamespace('hr', NAMESPACE_URI);
		XPathFactory xPathFactory = XPathFactory.instance();
		this.startDateExpression = xPathFactory.compile('//hr:StartDate', Filters.element(), null, namespace);
		this.endDateExpression = xPathFactory.compile('//hr:EndDate', Filters.element(), null, namespace);
		this.nameExpression = xPathFactory.compile('concat(//hr:FirstName," ",//hr:LastName)', Filters.fstring(), null,
				namespace);
	}
	@PayloadRoot(namespace = NAMESPACE_URI, localPart = 'HolidayRequest')
	public void handleHolidayRequest(@RequestPayload Element holidayRequest) throws Exception {
		SimpleDateFormat dateFormat = new SimpleDateFormat('yyyy-MM-dd');
		Date startDate = dateFormat.parse(this.startDateExpression.evaluateFirst(holidayRequest).getText());
		Date endDate = dateFormat.parse(this.endDateExpression.evaluateFirst(holidayRequest).getText());
		String name = this.nameExpression.evaluateFirst(holidayRequest);
		this.humanResourceService.bookHoliday(startDate, endDate, name);
	}
}
/*
package smoketest.webservices;
@Configuration(proxyBeanMethods = false)
public class WebServiceConfig extends WsConfigurerAdapter {
	@Bean(name = 'holiday')
	public DefaultWsdl11Definition defaultWsdl11Definition(XsdSchema countriesSchema) {
		DefaultWsdl11Definition wsdl = new DefaultWsdl11Definition();
		wsdl.setPortTypeName('HumanResource');
		wsdl.setLocationUri('/holidayService/');
		wsdl.setTargetNamespace('https://company.example.com/hr/definitions');
		wsdl.setSchema(countriesSchema);
		return wsdl;
	}
}
/*
package smoketest.actuator.extension;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'server.error.include-message=always' })
class SampleActuatorExtensionApplicationTests {
	@Autowired
	private Environment environment;
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private RestTemplateBuilder restTemplateBuilder;
	@Test
	@SuppressWarnings('rawtypes')
	void healthActuatorIsNotExposed() {
		ResponseEntity<Map> entity = this.restTemplate.getForEntity('/actuator/health', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@Test
	@SuppressWarnings('rawtypes')
	void healthExtensionWithAuthHeaderIsDenied() {
		ResponseEntity<Map> entity = this.restTemplate.getForEntity('/myextension/health', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	@SuppressWarnings('rawtypes')
	void healthExtensionWithAuthHeader() {
		TestRestTemplate restTemplate = new TestRestTemplate(
				this.restTemplateBuilder.defaultHeader('Authorization', 'Bearer secret'));
		restTemplate.setUriTemplateHandler(new LocalHostUriTemplateHandler(this.environment));
		ResponseEntity<Map> entity = restTemplate.getForEntity('/myextension/health', Map.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
}
/*
package smoketest.actuator.extension;
@SpringBootApplication(proxyBeanMethods = false)
public class SampleActuatorExtensionApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleActuatorExtensionApplication.class, args);
	}
}
/*
package smoketest.actuator.extension;
class MyExtensionSecurityInterceptor implements HandlerInterceptor {
	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		String auth = request.getHeader('Authorization');
		if (!'Bearer secret'.equals(auth)) {
			response.sendError(HttpStatus.UNAUTHORIZED.value());
			return false;
		}
		return true;
	}
}
/*
package smoketest.actuator.extension;
class MyExtensionWebMvcEndpointHandlerMapping extends AbstractWebMvcEndpointHandlerMapping {
	private static final String PATH = '/myextension';
	private final EndpointLinksResolver linksResolver;
	MyExtensionWebMvcEndpointHandlerMapping(Collection<ExposableWebEndpoint> endpoints,
			EndpointMediaTypes endpointMediaTypes, CorsConfiguration corsConfiguration) {
		super(new EndpointMapping(PATH), endpoints, endpointMediaTypes, corsConfiguration, true);
		this.linksResolver = new EndpointLinksResolver(endpoints, PATH);
		setOrder(-100);
	}
	@Override
	protected LinksHandler getLinksHandler() {
		return new WebMvcLinksHandler();
	}
	@Override
	protected void extendInterceptors(List<Object> interceptors) {
		super.extendInterceptors(interceptors);
		interceptors.add(0, new MyExtensionSecurityInterceptor());
	}
	class WebMvcLinksHandler implements LinksHandler {
		@Override
		@ResponseBody
		public Map<String, Map<String, Link>> links(HttpServletRequest request, HttpServletResponse response) {
			return Collections.singletonMap('_links', MyExtensionWebMvcEndpointHandlerMapping.this.linksResolver
				.resolveLinks(request.getRequestURL().toString()));
		}
		@Override
		public String toString() {
			return 'Actuator extension root web endpoint';
		}
	}
}
/*
package smoketest.actuator.extension;
class MyExtensionEndpointExposureOutcomeContributor implements EndpointExposureOutcomeContributor {
	private final MyExtensionEndpointFilter filter;
	MyExtensionEndpointExposureOutcomeContributor(Environment environment) {
		this.filter = new MyExtensionEndpointFilter(environment);
	}
	@Override
	public ConditionOutcome getExposureOutcome(EndpointId endpointId, Set<EndpointExposure> exposures,
			Builder message) {
		if (exposures.contains(EndpointExposure.WEB) && this.filter.match(endpointId)) {
			return ConditionOutcome.match(message.because('marked as exposed by a my extension "'
					+ MyExtensionEndpointFilter.PROPERTY_PREFIX + '" property'));
		}
		return null;
	}
}
/*
package smoketest.actuator.extension;
@Configuration(proxyBeanMethods = false)
public class MyExtensionConfiguration {
	@Bean
	public MyExtensionWebMvcEndpointHandlerMapping myWebMvcEndpointHandlerMapping(
			WebEndpointsSupplier webEndpointsSupplier, EndpointMediaTypes endpointMediaTypes,
			ObjectProvider<CorsEndpointProperties> corsPropertiesProvider, WebEndpointProperties webEndpointProperties,
			Environment environment, ApplicationContext applicationContext, ParameterValueMapper parameterMapper) {
		CorsEndpointProperties corsProperties = corsPropertiesProvider.getIfAvailable();
		CorsConfiguration corsConfiguration = (corsProperties != null) ? corsProperties.toCorsConfiguration() : null;
		List<OperationInvokerAdvisor> invokerAdvisors = Collections.emptyList();
		List<EndpointFilter<ExposableWebEndpoint>> filters = Collections
			.singletonList(new MyExtensionEndpointFilter(environment));
		WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(applicationContext, parameterMapper,
				endpointMediaTypes, null, null, invokerAdvisors, filters, Collections.emptyList());
		Collection<ExposableWebEndpoint> endpoints = discoverer.getEndpoints();
		return new MyExtensionWebMvcEndpointHandlerMapping(endpoints, endpointMediaTypes, corsConfiguration);
	}
}
/*
package smoketest.actuator.extension;
class MyExtensionEndpointFilter extends IncludeExcludeEndpointFilter<ExposableWebEndpoint> {
	static final String PROPERTY_PREFIX = 'management.endpoints.myextension.exposure';
	MyExtensionEndpointFilter(Environment environment) {
		super(ExposableWebEndpoint.class, environment, PROPERTY_PREFIX, '*');
	}
}
/*
package smoketest.secure.webflux;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles('cors')
class CorsSampleActuatorApplicationTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void endpointShouldReturnUnauthorized() {
		this.webClient.get().uri('/actuator/env').exchange().expectStatus().isUnauthorized();
	}
	@Test
	void preflightRequestToEndpointShouldReturnOk() {
		this.webClient.options()
			.uri('/actuator/env')
			.header('Origin', 'http://localhost:8080')
			.header('Access-Control-Request-Method', 'GET')
			.exchange()
			.expectStatus()
			.isOk();
	}
	@Test
	void preflightRequestWhenCorsConfigInvalidShouldReturnForbidden() {
		this.webClient.options()
			.uri('/actuator/env')
			.header('Origin', 'http://localhost:9095')
			.header('Access-Control-Request-Method', 'GET')
			.exchange()
			.expectStatus()
			.isForbidden();
	}
}
/*
package smoketest.secure.webflux;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = { 'management.server.port=0' }, classes = {
		ManagementPortSampleSecureWebFluxTests.SecurityConfiguration.class, SampleSecureWebFluxApplication.class })
class ManagementPortSampleSecureWebFluxTests {
	@LocalServerPort
	private int port;
	@LocalManagementPort
	private int managementPort;
	@Autowired
	private WebTestClient webClient;
	@Test
	void testHome() {
		this.webClient.get()
			.uri('http://localhost:' + this.port, String.class)
			.header('Authorization', getBasicAuth())
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('Hello user');
	}
	@Test
	void actuatorPathOnMainPortShouldNotMatch() {
		this.webClient.get()
			.uri('http://localhost:' + this.port + '/actuator', String.class)
			.exchange()
			.expectStatus()
			.isUnauthorized();
		this.webClient.get()
			.uri('http://localhost:' + this.port + '/actuator/health', String.class)
			.exchange()
			.expectStatus()
			.isUnauthorized();
	}
	@Test
	void testSecureActuator() {
		this.webClient.get()
			.uri('http://localhost:' + this.managementPort + '/actuator/env', String.class)
			.exchange()
			.expectStatus()
			.isUnauthorized();
	}
	@Test
	void testInsecureActuator() {
		String responseBody = this.webClient.get()
			.uri('http://localhost:' + this.managementPort + '/actuator/health', String.class)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.returnResult()
			.getResponseBody();
		assertThat(responseBody).contains('\'status\':\'UP\'');
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
	@Configuration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@Bean
		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
			http.authorizeExchange((exchanges) -> {
				exchanges.matchers(EndpointRequest.to('health')).permitAll();
				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class))
					.hasRole('ACTUATOR');
				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();
				exchanges.pathMatchers('/login').permitAll();
				exchanges.anyExchange().authenticated();
			});
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
}
/*
package smoketest.secure.webflux;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = 'management.endpoint.health.show-details=never')
class SampleSecureWebFluxApplicationTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void userDefinedMappingsSecureByDefault() {
		this.webClient.get()
			.uri('/')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void healthInsecureByDefault() {
		this.webClient.get()
			.uri('/actuator/health')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk();
	}
	@Test
	void otherActuatorsSecureByDefault() {
		this.webClient.get()
			.uri('/actuator/env')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isUnauthorized();
	}
	@Test
	void userDefinedMappingsAccessibleOnLogin() {
		this.webClient.get()
			.uri('/')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', getBasicAuth())
			.exchange()
			.expectBody(String.class)
			.isEqualTo('Hello user');
	}
	@Test
	void actuatorsAccessibleOnLogin() {
		this.webClient.get()
			.uri('/actuator/health')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', getBasicAuth())
			.exchange()
			.expectBody(String.class)
			.isEqualTo('{\'status\':\'UP\'}');
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
}
/*
package smoketest.secure.webflux;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT, classes = {
		SampleSecureWebFluxCustomSecurityTests.SecurityConfiguration.class, SampleSecureWebFluxApplication.class })
class SampleSecureWebFluxCustomSecurityTests {
	@Autowired
	private WebTestClient webClient;
	@Test
	void userDefinedMappingsSecure() {
		this.webClient.get()
			.uri('/')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void healthDoesNotRequireAuthentication() {
		this.webClient.get()
			.uri('/actuator/health')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk();
	}
	@Test
	void actuatorsSecuredByRole() {
		this.webClient.get()
			.uri('/actuator/env')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', getBasicAuth())
			.exchange()
			.expectStatus()
			.isForbidden();
	}
	@Test
	void actuatorsAccessibleOnCorrectLogin() {
		this.webClient.get()
			.uri('/actuator/env')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', getBasicAuthForAdmin())
			.exchange()
			.expectStatus()
			.isOk();
	}
	@Test
	void actuatorExcludedFromEndpointRequestMatcher() {
		this.webClient.get()
			.uri('/actuator/mappings')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', getBasicAuth())
			.exchange()
			.expectStatus()
			.isOk();
	}
	@Test
	void staticResourceShouldBeAccessible() {
		this.webClient.get()
			.uri('/css/bootstrap.min.css')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isOk();
	}
	@Test
	void actuatorLinksIsSecure() {
		this.webClient.get()
			.uri('/actuator')
			.accept(MediaType.APPLICATION_JSON)
			.exchange()
			.expectStatus()
			.isUnauthorized();
		this.webClient.get()
			.uri('/actuator')
			.accept(MediaType.APPLICATION_JSON)
			.header('Authorization', getBasicAuthForAdmin())
			.exchange()
			.expectStatus()
			.isOk();
	}
	private String getBasicAuth() {
		return 'Basic ' + Base64.getEncoder().encodeToString('user:password'.getBytes());
	}
	private String getBasicAuthForAdmin() {
		return 'Basic ' + Base64.getEncoder().encodeToString('admin:admin'.getBytes());
	}
	@Configuration(proxyBeanMethods = false)
	static class SecurityConfiguration {
		@SuppressWarnings('deprecation')
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			return new MapReactiveUserDetailsService(
					User.withDefaultPasswordEncoder()
						.username('user')
						.password('password')
						.authorities('ROLE_USER')
						.build(),
					User.withDefaultPasswordEncoder()
						.username('admin')
						.password('admin')
						.authorities('ROLE_ACTUATOR', 'ROLE_USER')
						.build());
		}
		@Bean
		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
			http.authorizeExchange((exchanges) -> {
				exchanges.matchers(EndpointRequest.to('health')).permitAll();
				exchanges.matchers(EndpointRequest.toAnyEndpoint().excluding(MappingsEndpoint.class))
					.hasRole('ACTUATOR');
				exchanges.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();
				exchanges.pathMatchers('/login').permitAll();
				exchanges.anyExchange().authenticated();
			});
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
}
/*
package smoketest.secure.webflux;
@RestController
public class WelcomeController {
	@GetMapping('/')
	public String welcome(Principal principal) {
		return 'Hello ' + principal.getName();
	}
}
/*
package smoketest.secure.webflux;
@SpringBootApplication
public class SampleSecureWebFluxApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleSecureWebFluxApplication.class);
	}
	@Bean
	public RouterFunction<ServerResponse> monoRouterFunction(EchoHandler echoHandler) {
		return route(POST('/echo'), echoHandler::echo);
	}
}
/*
package smoketest.secure.webflux;
@Component
public class EchoHandler {
	public Mono<ServerResponse> echo(ServerRequest request) {
		return ServerResponse.ok().body(request.bodyToMono(String.class), String.class);
	}
}
/*
package smoketest.oauth2.server;
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
class SampleOAuth2AuthorizationServerApplicationTests {
	private static final ParameterizedTypeReference<Map<String, Object>> MAP_TYPE_REFERENCE = new ParameterizedTypeReference<>() {
	};
	@LocalServerPort
	private int port;
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void openidConfigurationShouldAllowAccess() {
		ResponseEntity<Map<String, Object>> entity = this.restTemplate.exchange('/.well-known/openid-configuration',
				HttpMethod.GET, null, MAP_TYPE_REFERENCE);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		OidcProviderConfiguration config = OidcProviderConfiguration.withClaims(entity.getBody()).build();
		assertThat(config.getIssuer()).hasToString('https://provider.com');
		assertThat(config.getAuthorizationEndpoint()).hasToString('https://provider.com/authorize');
		assertThat(config.getTokenEndpoint()).hasToString('https://provider.com/token');
		assertThat(config.getJwkSetUrl()).hasToString('https://provider.com/jwks');
		assertThat(config.getTokenRevocationEndpoint()).hasToString('https://provider.com/revoke');
		assertThat(config.getEndSessionEndpoint()).hasToString('https://provider.com/logout');
		assertThat(config.getTokenIntrospectionEndpoint()).hasToString('https://provider.com/introspect');
		assertThat(config.getUserInfoEndpoint()).hasToString('https://provider.com/user');
		// OIDC Client Registration is disabled by default
		assertThat(config.getClientRegistrationEndpoint()).isNull();
	}
	@Test
	void authServerMetadataShouldAllowAccess() {
		ResponseEntity<Map<String, Object>> entity = this.restTemplate
			.exchange('/.well-known/oauth-authorization-server', HttpMethod.GET, null, MAP_TYPE_REFERENCE);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		OAuth2AuthorizationServerMetadata config = OAuth2AuthorizationServerMetadata.withClaims(entity.getBody())
			.build();
		assertThat(config.getIssuer()).hasToString('https://provider.com');
		assertThat(config.getAuthorizationEndpoint()).hasToString('https://provider.com/authorize');
		assertThat(config.getTokenEndpoint()).hasToString('https://provider.com/token');
		assertThat(config.getJwkSetUrl()).hasToString('https://provider.com/jwks');
		assertThat(config.getTokenRevocationEndpoint()).hasToString('https://provider.com/revoke');
		assertThat(config.getTokenIntrospectionEndpoint()).hasToString('https://provider.com/introspect');
		// OIDC Client Registration is disabled by default
		assertThat(config.getClientRegistrationEndpoint()).isNull();
	}
	@Test
	void anonymousShouldRedirectToLogin() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation()).isEqualTo(URI.create('http://localhost:' + this.port + '/login'));
	}
	@Test
	void validTokenRequestShouldReturnTokenResponse() {
		HttpHeaders headers = new HttpHeaders();
		headers.setBasicAuth('messaging-client', 'secret');
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
		body.add(OAuth2ParameterNames.CLIENT_ID, 'messaging-client');
		body.add(OAuth2ParameterNames.GRANT_TYPE, AuthorizationGrantType.CLIENT_CREDENTIALS.getValue());
		body.add(OAuth2ParameterNames.SCOPE, 'message.read message.write');
		HttpEntity<Object> request = new HttpEntity<>(body, headers);
		ResponseEntity<Map<String, Object>> entity = this.restTemplate.exchange('/token', HttpMethod.POST, request,
				MAP_TYPE_REFERENCE);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		Map<String, Object> tokenResponse = Objects.requireNonNull(entity.getBody());
		assertThat(tokenResponse.get(OAuth2ParameterNames.ACCESS_TOKEN)).isNotNull();
		assertThat(tokenResponse.get(OAuth2ParameterNames.EXPIRES_IN)).isNotNull();
		assertThat(tokenResponse.get(OAuth2ParameterNames.SCOPE)).isEqualTo('message.read message.write');
		assertThat(tokenResponse.get(OAuth2ParameterNames.TOKEN_TYPE))
			.isEqualTo(OAuth2AccessToken.TokenType.BEARER.getValue());
	}
	@Test
	void anonymousTokenRequestShouldReturnUnauthorized() {
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
		body.add(OAuth2ParameterNames.CLIENT_ID, 'messaging-client');
		body.add(OAuth2ParameterNames.GRANT_TYPE, AuthorizationGrantType.CLIENT_CREDENTIALS.getValue());
		body.add(OAuth2ParameterNames.SCOPE, 'message.read message.write');
		HttpEntity<Object> request = new HttpEntity<>(body, headers);
		ResponseEntity<Map<String, Object>> entity = this.restTemplate.exchange('/token', HttpMethod.POST, request,
				MAP_TYPE_REFERENCE);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void anonymousTokenRequestWithAcceptHeaderAllShouldReturnUnauthorized() {
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		headers.setAccept(List.of(MediaType.ALL));
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
		body.add(OAuth2ParameterNames.CLIENT_ID, 'messaging-client');
		body.add(OAuth2ParameterNames.GRANT_TYPE, AuthorizationGrantType.CLIENT_CREDENTIALS.getValue());
		body.add(OAuth2ParameterNames.SCOPE, 'message.read message.write');
		HttpEntity<Object> request = new HttpEntity<>(body, headers);
		ResponseEntity<Map<String, Object>> entity = this.restTemplate.exchange('/token', HttpMethod.POST, request,
				MAP_TYPE_REFERENCE);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void anonymousTokenRequestWithAcceptHeaderTextHtmlShouldRedirectToLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		headers.setAccept(List.of(MediaType.TEXT_HTML));
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
		body.add(OAuth2ParameterNames.CLIENT_ID, 'messaging-client');
		body.add(OAuth2ParameterNames.GRANT_TYPE, AuthorizationGrantType.CLIENT_CREDENTIALS.getValue());
		body.add(OAuth2ParameterNames.SCOPE, 'message.read message.write');
		HttpEntity<Object> request = new HttpEntity<>(body, headers);
		ResponseEntity<Map<String, Object>> entity = this.restTemplate.exchange('/token', HttpMethod.POST, request,
				MAP_TYPE_REFERENCE);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation()).isEqualTo(URI.create('http://localhost:' + this.port + '/login'));
	}
}
/*
package smoketest.oauth2.server;
@SpringBootApplication
public class SampleOAuth2AuthorizationServerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleOAuth2AuthorizationServerApplication.class);
	}
}
/*
package smoketest.jetty.jsp;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebJspApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testJspWithEl() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('/resources/text.txt');
	}
}
/*
package smoketest.jetty.jsp;
public class MyException extends RuntimeException {
	public MyException(String message) {
		super(message);
	}
}
/*
package smoketest.jetty.jsp;
@SpringBootApplication
public class SampleJettyJspApplication extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleJettyJspApplication.class);
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleJettyJspApplication.class, args);
	}
}
/*
package smoketest.jetty.jsp;
@Controller
public class WelcomeController {
	@Value('${application.message:Hello World}')
	private String message = 'Hello World';
	@RequestMapping('/')
	public String welcome(Map<String, Object> model) {
		model.put('time', new Date());
		model.put('message', this.message);
		return 'welcome';
	}
	@RequestMapping('/fail')
	public String fail() {
		throw new MyException('Oh dear!');
	}
	@RequestMapping('/fail2')
	public String fail2() {
		throw new IllegalStateException();
	}
	@ExceptionHandler(MyException.class)
	@ResponseStatus(HttpStatus.BAD_REQUEST)
	public @ResponseBody MyRestResponse handleMyRuntimeException(MyException exception) {
		return new MyRestResponse('Some data I want to send back to the client.');
	}
}
/*
package smoketest.jetty.jsp;
public class MyRestResponse {
	private final String message;
	public MyRestResponse(String message) {
		this.message = message;
	}
	public String getMessage() {
		return this.message;
	}
}
/*
package smoketest.data.couchbase;
/**
@Testcontainers(disabledWithoutDocker = true)
@SpringBootTest(properties = { 'spring.couchbase.env.ssl.bundle=client', 'spring.data.couchbase.bucket-name=cbbucket',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
class SampleCouchbaseApplicationReactiveSslTests {
	private static final String BUCKET_NAME = 'cbbucket';
	@Container
	@ServiceConnection
	static final CouchbaseContainer couchbase = TestImage.container(SecureCouchbaseContainer.class)
		.withBucket(new BucketDefinition(BUCKET_NAME));
	@Autowired
	private ReactiveCouchbaseTemplate couchbaseTemplate;
	@Autowired
	private SampleReactiveRepository repository;
	@Test
	void testRepository() {
		SampleDocument document = new SampleDocument();
		document.setText('Look, new @DataCouchbaseTest!');
		document = this.repository.save(document).block(Duration.ofSeconds(30));
		assertThat(document.getId()).isNotNull();
		assertThat(this.couchbaseTemplate.getBucketName()).isEqualTo(BUCKET_NAME);
		this.repository.deleteAll();
	}
}
/*
package smoketest.data.couchbase;
/**
public class SecureCouchbaseContainer extends CouchbaseContainer {
	private static final int MANAGEMENT_PORT = 8091;
	private static final int KV_SSL_PORT = 11207;
	private static final String ADMIN_USER = 'Administrator';
	private static final String ADMIN_PASSWORD = 'password';
	public SecureCouchbaseContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.crt'),
				'/opt/couchbase/var/lib/couchbase/inbox/chain.pem');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.key'),
				'/opt/couchbase/var/lib/couchbase/inbox/pkey.key');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-ca.crt'),
				'/opt/couchbase/var/lib/couchbase/inbox/CA/ca.pem');
	}
	@Override
	public String getConnectionString() {
		return 'couchbase://%s:%d'.formatted(getHost(), getMappedPort(KV_SSL_PORT));
	}
	@Override
	protected void containerIsStarting(InspectContainerResponse containerInfo) {
		super.containerIsStarting(containerInfo);
		doHttpRequest('node/controller/loadTrustedCAs');
		doHttpRequest('node/controller/reloadCertificate');
	}
	private void doHttpRequest(String path) {
		HttpResponse response = post(path);
		if (response.getCode() != 200) {
			throw new IllegalStateException('Error calling Couchbase HTTP endpoint: ' + response);
		}
	}
	private HttpResponse post(String path) {
		try (CloseableHttpClient httpclient = HttpClients.createDefault()) {
			String basicAuth = 'Basic '
					+ Base64.getEncoder().encodeToString('%s:%s'.formatted(ADMIN_USER, ADMIN_PASSWORD).getBytes());
			String url = 'http://%s:%d/%s'.formatted(getHost(), getMappedPort(MANAGEMENT_PORT), path);
			ClassicHttpRequest httpPost = ClassicRequestBuilder.post(url)
				.addHeader('Authorization', basicAuth)
				.setEntity('')
				.build();
			return httpclient.execute(httpPost, (response) -> response);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Error calling Couchbase HTTP endpoint', ex);
		}
	}
}
/*
package smoketest.data.couchbase;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataCouchbaseTest(properties = { 'spring.couchbase.env.ssl.bundle=client', 'spring.couchbase.env.timeouts.connect=2m',
		'spring.data.couchbase.bucket-name=cbbucket',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
class SampleCouchbaseApplicationSslTests {
	private static final String BUCKET_NAME = 'cbbucket';
	@Container
	@ServiceConnection
	static final CouchbaseContainer couchbase = TestImage.container(SecureCouchbaseContainer.class)
		.withBucket(new BucketDefinition(BUCKET_NAME));
	@Autowired
	private CouchbaseTemplate couchbaseTemplate;
	@Autowired
	private SampleRepository repository;
	@Test
	void testRepository() {
		SampleDocument document = new SampleDocument();
		document.setText('Look, new @DataCouchbaseTest!');
		document = this.repository.save(document);
		assertThat(document.getId()).isNotNull();
		assertThat(this.couchbaseTemplate.getBucketName()).isEqualTo(BUCKET_NAME);
		this.repository.deleteAll();
	}
}
/*
package smoketest.data.couchbase;
@Document
public class SampleDocument {
	@Id
	@GeneratedValue(strategy = GenerationStrategy.UNIQUE)
	private String id;
	private String text;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getText() {
		return this.text;
	}
	public void setText(String text) {
		this.text = text;
	}
}
/*
package smoketest.data.couchbase;
@SpringBootApplication
public class SampleCouchbaseApplication {
}
/*
package smoketest.data.couchbase;
@Service
public class SampleService {
	private final CouchbaseTemplate couchbaseTemplate;
	public SampleService(CouchbaseTemplate couchbaseTemplate) {
		this.couchbaseTemplate = couchbaseTemplate;
	}
	public SampleDocument findById(String id) {
		return this.couchbaseTemplate.findById(SampleDocument.class).one(id);
	}
}
/*
package smoketest.data.couchbase;
interface SampleReactiveRepository extends ReactiveCouchbaseRepository<SampleDocument, String> {
}
/*
package smoketest.data.couchbase;
interface SampleRepository extends CouchbaseRepository<SampleDocument, String> {
}
/*
package smoketest.structuredlogging;
/**
@ExtendWith(OutputCaptureExtension.class)
class SampleStructuredLoggingApplicationTests {
	@AfterEach
	void reset() {
		LoggingSystem.get(getClass().getClassLoader()).cleanUp();
		for (LoggingSystemProperty property : LoggingSystemProperty.values()) {
			System.getProperties().remove(property.getEnvironmentVariableName());
		}
	}
	@Test
	void shouldNotLogBanner(CapturedOutput output) {
		SampleStructuredLoggingApplication.main(new String[0]);
		assertThat(output).doesNotContain(' :: Spring Boot :: ');
	}
	@Test
	void json(CapturedOutput output) {
		SampleStructuredLoggingApplication.main(new String[0]);
		assertThat(output).doesNotContain('{\'@timestamp\'')
			.contains('\'process.thread.name\':\'!!')
			.contains('\'process.procid\'')
			.contains('\'message\':\'Starting SampleStructuredLoggingApplication')
			.contains('\'foo\':\'hello');
	}
	@Test
	void custom(CapturedOutput output) {
		SampleStructuredLoggingApplication.main(new String[] { '--spring.profiles.active=custom' });
		assertThat(output).contains('epoch=').contains('msg=\'Starting SampleStructuredLoggingApplication');
	}
}
/*
package smoketest.structuredlogging;
@SpringBootApplication
public class SampleStructuredLoggingApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleStructuredLoggingApplication.class, args);
	}
}
/*
package smoketest.structuredlogging;
public class CustomStructuredLogFormatter implements StructuredLogFormatter<ILoggingEvent> {
	private final Long pid;
	private final ThrowableProxyConverter throwableProxyConverter;
	public CustomStructuredLogFormatter(Environment environment, ThrowableProxyConverter throwableProxyConverter) {
		this.pid = environment.getProperty('spring.application.pid', Long.class);
		this.throwableProxyConverter = throwableProxyConverter;
	}
	@Override
	public String format(ILoggingEvent event) {
		StringBuilder result = new StringBuilder();
		result.append('epoch=').append(event.getInstant().toEpochMilli());
		if (this.pid != null) {
			result.append(' pid=').append(this.pid);
		}
		result.append(' msg=\'').append(event.getFormattedMessage()).append("'");
		IThrowableProxy throwable = event.getThrowableProxy();
		if (throwable != null) {
			result.append(' error=\'').append(this.throwableProxyConverter.convert(event)).append("'");
		}
		result.append("\n");
		return result.toString();
	}
}
/*
package smoketest.structuredlogging;
public class SampleJsonMembersCustomizer implements StructureLoggingJsonMembersCustomizer<Object> {
	@Override
	public void customize(Members<Object> members) {
		members.applyingValueProcessor(
				ValueProcessor.of(String.class, '!!%s!!'::formatted).whenHasUnescapedPath('process.thread.name'));
	}
}
/*
package smoketest.devtools;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleDevToolsApplicationIntegrationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testStaticResource() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/css/application.css', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('color: green;');
	}
	@Test
	void testPublicResource() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/public.txt', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('public file');
	}
	@Test
	void testClassResource() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/application.properties', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
}
/*
package smoketest.devtools;
@Controller
public class MyController {
	@PostConstruct
	public void slowRestart() throws InterruptedException {
		Thread.sleep(5000);
	}
}
/*
package smoketest.devtools;
@SpringBootApplication
public class SampleDevToolsApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleDevToolsApplication.class, args);
	}
}
/*
package smoketest.devtools;
public final class Message {
	/**
	 * Sample message.
	 */
	public static String MESSAGE = 'Message';
	private Message() {
	}
}
/*
package smoketest.security.method;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.http.client.factory=simple')
class SampleMethodSecurityApplicationTests {
	@LocalServerPort
	private int port;
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, new HttpEntity<>(headers),
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void testLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'admin');
		form.set('password', 'admin');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation().toString()).endsWith(this.port + '/');
	}
	@Test
	void testDenied() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'user');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		String cookie = entity.getHeaders().getFirst('Set-Cookie');
		headers.set('Cookie', cookie);
		ResponseEntity<String> page = this.restTemplate.exchange(entity.getHeaders().getLocation(), HttpMethod.GET,
				new HttpEntity<>(headers), String.class);
		assertThat(page.getStatusCode()).isEqualTo(HttpStatus.FORBIDDEN);
		assertThat(page.getBody()).contains('Access denied');
	}
	@Test
	void testManagementProtected() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
		ResponseEntity<String> entity = this.restTemplate.exchange('/actuator/beans', HttpMethod.GET,
				new HttpEntity<>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
	}
	@Test
	void testManagementAuthorizedAccess() {
		BasicAuthenticationInterceptor basicAuthInterceptor = new BasicAuthenticationInterceptor('admin', 'admin');
		this.restTemplate.getRestTemplate().getInterceptors().add(basicAuthInterceptor);
		try {
			ResponseEntity<String> entity = this.restTemplate.getForEntity('/actuator/beans', String.class);
			assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		}
		finally {
			this.restTemplate.getRestTemplate().getInterceptors().remove(basicAuthInterceptor);
		}
	}
}
/*
package smoketest.security.method;
@SpringBootApplication
@EnableMethodSecurity(securedEnabled = true)
public class SampleMethodSecurityApplication implements WebMvcConfigurer {
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController('/login').setViewName('login');
		registry.addViewController('/access').setViewName('access');
	}
	public static void main(String[] args) {
		new SpringApplicationBuilder(SampleMethodSecurityApplication.class).run(args);
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	@Configuration(proxyBeanMethods = false)
	protected static class AuthenticationSecurity {
		@SuppressWarnings('deprecation')
		@Bean
		public InMemoryUserDetailsManager inMemoryUserDetailsManager() {
			return new InMemoryUserDetailsManager(
					User.withDefaultPasswordEncoder()
						.username('admin')
						.password('admin')
						.roles('ADMIN', 'USER', 'ACTUATOR')
						.build(),
					User.withDefaultPasswordEncoder().username('user').password('user').roles('USER').build());
		}
	}
	@Configuration(proxyBeanMethods = false)
	protected static class ApplicationSecurity {
		@Bean
		SecurityFilterChain configure(HttpSecurity http) throws Exception {
			http.csrf(CsrfConfigurer::disable);
			http.authorizeHttpRequests((requests) -> {
				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll();
				requests.anyRequest().fullyAuthenticated();
			});
			http.httpBasic(withDefaults());
			http.formLogin((form) -> form.loginPage('/login').permitAll());
			http.exceptionHandling((exceptions) -> exceptions.accessDeniedPage('/access'));
			return http.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Order(1)
	protected static class ActuatorSecurity {
		@Bean
		SecurityFilterChain actuatorSecurity(HttpSecurity http) throws Exception {
			http.csrf(CsrfConfigurer::disable);
			http.securityMatcher(EndpointRequest.toAnyEndpoint());
			http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
	@Controller
	protected static class HomeController {
		@GetMapping('/')
		@Secured('ROLE_ADMIN')
		public String home() {
			return 'home';
		}
	}
}
/*
package smoketest.amqp;
@SpringBootTest
@Testcontainers(disabledWithoutDocker = true)
@ExtendWith(OutputCaptureExtension.class)
class SampleAmqpSimpleApplicationTests {
	@Container
	@ServiceConnection
	static final RabbitMQContainer rabbit = TestImage.container(RabbitMQContainer.class);
	@Autowired
	private Sender sender;
	@Test
	void sendSimpleMessage(CapturedOutput output) {
		this.sender.send('Test message');
		Awaitility.waitAtMost(Duration.ofMinutes(1)).untilAsserted(() -> assertThat(output).contains('Test message'));
	}
}
/*
package smoketest.amqp;
/**
class SecureRabbitMqContainer extends RabbitMQContainer {
	SecureRabbitMqContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
	}
	@Override
	public void configure() {
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/rabbitmq.conf'),
				'/etc/rabbitmq/rabbitmq.conf');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.crt'),
				'/etc/rabbitmq/server_cert.pem');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.key'),
				'/etc/rabbitmq/server_key.pem');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-ca.crt'), '/etc/rabbitmq/ca_cert.pem');
	}
}
/*
package smoketest.amqp;
/**
@SpringBootTest(properties = { 'spring.rabbitmq.ssl.bundle=client',
		'spring.ssl.bundle.pem.client.keystore.certificate=classpath:ssl/test-client.crt',
		'spring.ssl.bundle.pem.client.keystore.private-key=classpath:ssl/test-client.key',
		'spring.ssl.bundle.pem.client.truststore.certificate=classpath:ssl/test-ca.crt' })
@Testcontainers(disabledWithoutDocker = true)
@ExtendWith(OutputCaptureExtension.class)
class SampleAmqpSimpleApplicationSslTests {
	@Container
	static final SecureRabbitMqContainer rabbit = TestImage.container(SecureRabbitMqContainer.class);
	@DynamicPropertySource
	static void secureRabbitMqProperties(DynamicPropertyRegistry registry) {
		registry.add('spring.rabbitmq.host', rabbit::getHost);
		registry.add('spring.rabbitmq.port', rabbit::getAmqpsPort);
		registry.add('spring.rabbitmq.username', rabbit::getAdminUsername);
		registry.add('spring.rabbitmq.password', rabbit::getAdminPassword);
	}
	@Autowired
	private Sender sender;
	@Test
	void sendSimpleMessage(CapturedOutput output) {
		this.sender.send('Test message');
		Awaitility.waitAtMost(Duration.ofMinutes(1)).untilAsserted(() -> assertThat(output).contains('Test message'));
	}
}
/*
package smoketest.amqp;
@SpringBootApplication
@RabbitListener(queues = 'foo')
public class SampleAmqpSimpleApplication {
	private static final Log logger = LogFactory.getLog(SampleAmqpSimpleApplication.class);
	@Bean
	public Sender mySender() {
		return new Sender();
	}
	@Bean
	public Queue fooQueue() {
		return new Queue('foo');
	}
	@RabbitHandler
	public void process(@Payload String foo) {
		logger.info(foo);
	}
	@Bean
	public ApplicationRunner runner(Sender sender) {
		return (args) -> sender.send('Hello');
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleAmqpSimpleApplication.class, args);
	}
}
/*
package smoketest.amqp;
public class Sender {
	@Autowired
	private RabbitTemplate rabbitTemplate;
	public void send(String message) {
		this.rabbitTemplate.convertAndSend('foo', message);
	}
}
/*
package smoketest.data.cassandra;
/**
@Testcontainers(disabledWithoutDocker = true)
@SpringBootTest(properties = { 'spring.cassandra.schema-action=create-if-not-exists',
		'spring.cassandra.connection.connect-timeout=60s', 'spring.cassandra.connection.init-query-timeout=60s',
		'spring.cassandra.request.timeout=60s', 'spring.cassandra.ssl.bundle=client',
		'spring.ssl.bundle.jks.client.keystore.location=classpath:ssl/test-client.p12',
		'spring.ssl.bundle.jks.client.keystore.password=password',
		'spring.ssl.bundle.jks.client.truststore.location=classpath:ssl/test-ca.p12',
		'spring.ssl.bundle.jks.client.truststore.password=password' })
class SampleCassandraApplicationReactiveSslTests {
	@Container
	@ServiceConnection
	static final SecureCassandraContainer cassandra = TestImage.container(SecureCassandraContainer.class);
	@Autowired
	private ReactiveCassandraTemplate cassandraTemplate;
	@Autowired
	private SampleRepository repository;
	@Test
	void testRepository() {
		SampleEntity entity = new SampleEntity();
		entity.setDescription('Look, new @DataCassandraTest!');
		String id = UUID.randomUUID().toString();
		entity.setId(id);
		SampleEntity savedEntity = this.repository.save(entity);
		SampleEntity getEntity = this.cassandraTemplate.selectOneById(id, SampleEntity.class)
			.block(Duration.ofSeconds(30));
		assertThat(getEntity).isNotNull();
		assertThat(getEntity.getId()).isNotNull();
		assertThat(getEntity.getId()).isEqualTo(savedEntity.getId());
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class KeyspaceTestConfiguration {
		@Bean
		CqlSession cqlSession(CqlSessionBuilder cqlSessionBuilder) {
			try (CqlSession session = cqlSessionBuilder.build()) {
				session.execute('CREATE KEYSPACE IF NOT EXISTS boot_test'
						+ ' WITH REPLICATION = { "class" : "SimpleStrategy", "replication_factor" : 1 };');
			}
			return cqlSessionBuilder.withKeyspace('boot_test').build();
		}
	}
}
/*
package smoketest.data.cassandra;
/**
class SecureCassandraContainer extends CassandraContainer {
	SecureCassandraContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		setWaitStrategy(Wait.defaultWaitStrategy()); // default strategy uses plain text
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/cassandra.yaml'),
				'/etc/cassandra/cassandra.yaml');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-server.p12'),
				'/etc/cassandra/server.p12');
		withCopyFileToContainer(MountableFile.forClasspathResource('/ssl/test-ca.p12'),
				'/etc/cassandra/truststore.p12');
	}
}
/*
package smoketest.data.cassandra;
/**
@Testcontainers(disabledWithoutDocker = true)
@DataCassandraTest(properties = { 'spring.cassandra.schema-action=create-if-not-exists',
		'spring.cassandra.connection.connect-timeout=60s', 'spring.cassandra.connection.init-query-timeout=60s',
		'spring.cassandra.request.timeout=60s', 'spring.cassandra.ssl.bundle=client',
		'spring.ssl.bundle.jks.client.keystore.location=classpath:ssl/test-client.p12',
		'spring.ssl.bundle.jks.client.keystore.password=password',
		'spring.ssl.bundle.jks.client.truststore.location=classpath:ssl/test-ca.p12',
		'spring.ssl.bundle.jks.client.truststore.password=password' })
class SampleCassandraApplicationSslTests {
	@Container
	@ServiceConnection
	static final SecureCassandraContainer cassandra = TestImage.container(SecureCassandraContainer.class);
	@Autowired
	private CassandraTemplate cassandraTemplate;
	@Autowired
	private SampleRepository repository;
	@Test
	void testRepository() {
		SampleEntity entity = new SampleEntity();
		entity.setDescription('Look, new @DataCassandraTest!');
		String id = UUID.randomUUID().toString();
		entity.setId(id);
		SampleEntity savedEntity = this.repository.save(entity);
		SampleEntity getEntity = this.cassandraTemplate.selectOneById(id, SampleEntity.class);
		assertThat(getEntity).isNotNull();
		assertThat(getEntity.getId()).isNotNull();
		assertThat(getEntity.getId()).isEqualTo(savedEntity.getId());
		this.repository.deleteAll();
	}
	@TestConfiguration(proxyBeanMethods = false)
	static class KeyspaceTestConfiguration {
		@Bean
		CqlSession cqlSession(CqlSessionBuilder cqlSessionBuilder) {
			try (CqlSession session = cqlSessionBuilder.build()) {
				session.execute('CREATE KEYSPACE IF NOT EXISTS boot_test'
						+ ' WITH REPLICATION = { "class" : "SimpleStrategy", "replication_factor" : 1 };');
			}
			return cqlSessionBuilder.withKeyspace('boot_test').build();
		}
	}
}
/*
package smoketest.data.cassandra;
@Service
public class SampleService {
	private final CassandraTemplate cassandraTemplate;
	public SampleService(CassandraTemplate cassandraTemplate) {
		this.cassandraTemplate = cassandraTemplate;
	}
	public boolean hasRecord(SampleEntity entity) {
		return this.cassandraTemplate.exists(entity.getId(), SampleEntity.class);
	}
}
/*
package smoketest.data.cassandra;
@Table
public class SampleEntity {
	@PrimaryKey
	private String id;
	private String description;
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
}
/*
package smoketest.data.cassandra;
@SpringBootApplication
public class SampleCassandraApplication {
}
/*
package smoketest.data.cassandra;
interface SampleRepository extends CassandraRepository<SampleEntity, String> {
}
/*
package smoketest.groovytemplates;
/**
@SpringBootTest
@AutoConfigureMockMvc
class MessageControllerWebTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void testHome() {
		assertThat(this.mvc.get().uri('/')).hasStatusOk().bodyText().contains('<title>Messages');
	}
	@Test
	void testCreate() {
		assertThat(this.mvc.post().uri('/').param('text', 'FOO text').param('summary', 'FOO'))
			.hasStatus(HttpStatus.FOUND)
			.headers()
			.hasEntrySatisfying('Location',
					(values) -> assertThat(values).hasSize(1)
						.element(0)
						.satisfies(HamcrestCondition.matching(RegexMatcher.matches('/[0-9]+'))));
	}
	@Test
	void testCreateValidation() {
		assertThat(this.mvc.post().uri('/').param('text', '').param('summary', '')).hasStatusOk()
			.bodyText()
			.contains('is required');
	}
	private static class RegexMatcher extends TypeSafeMatcher<String> {
		private final String regex;
		RegexMatcher(String regex) {
			this.regex = regex;
		}
		@Override
		public boolean matchesSafely(String item) {
			return Pattern.compile(this.regex).matcher(item).find();
		}
		@Override
		public void describeMismatchSafely(String item, Description mismatchDescription) {
			mismatchDescription.appendText('was \'').appendText(item).appendText('\'');
		}
		@Override
		public void describeTo(Description description) {
			description.appendText('a string that matches regex: ').appendText(this.regex);
		}
		static org.hamcrest.Matcher<java.lang.String> matches(String regex) {
			return new RegexMatcher(regex);
		}
	}
}
/*
package smoketest.groovytemplates;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.http.client.redirects=dont-follow')
class SampleGroovyTemplateApplicationTests {
	@LocalServerPort
	private int port;
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('<title>Messages');
		assertThat(entity.getBody()).doesNotContain('layout:fragment');
	}
	@Test
	void testCreate() {
		MultiValueMap<String, String> map = new LinkedMultiValueMap<>();
		map.set('text', 'FOO text');
		map.set('summary', 'FOO');
		URI location = this.restTemplate.postForLocation('/', map);
		assertThat(location.toString()).contains('localhost:' + this.port);
	}
	@Test
	void testCss() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/css/bootstrap.min.css', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('body');
	}
}
/*
package smoketest.groovytemplates;
public class InMemoryMessageRepository implements MessageRepository {
	private static final AtomicLong counter = new AtomicLong();
	private final ConcurrentMap<Long, Message> messages = new ConcurrentHashMap<>();
	@Override
	public Iterable<Message> findAll() {
		return this.messages.values();
	}
	@Override
	public Message save(Message message) {
		Long id = message.getId();
		if (id == null) {
			id = counter.incrementAndGet();
			message.setId(id);
		}
		this.messages.put(id, message);
		return message;
	}
	@Override
	public Message findMessage(Long id) {
		return this.messages.get(id);
	}
}
/*
package smoketest.groovytemplates;
public class Message {
	private Long id;
	@NotEmpty(message = 'Text is required.')
	private String text;
	@NotEmpty(message = 'Summary is required.')
	private String summary;
	private Date created = new Date();
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public Date getCreated() {
		return this.created;
	}
	public void setCreated(Date created) {
		this.created = created;
	}
	public String getText() {
		return this.text;
	}
	public void setText(String text) {
		this.text = text;
	}
	public String getSummary() {
		return this.summary;
	}
	public void setSummary(String summary) {
		this.summary = summary;
	}
}
/*
package smoketest.groovytemplates;
public interface MessageRepository {
	Iterable<Message> findAll();
	Message save(Message message);
	Message findMessage(Long id);
}
/*
package smoketest.groovytemplates.mvc;
@Controller
@RequestMapping('/')
public class MessageController {
	private final MessageRepository messageRepository;
	public MessageController(MessageRepository messageRepository) {
		this.messageRepository = messageRepository;
	}
	@GetMapping
	public ModelAndView list() {
		Iterable<Message> messages = this.messageRepository.findAll();
		return new ModelAndView('messages/list', 'messages', messages);
	}
	@GetMapping('{id}')
	public ModelAndView view(@PathVariable('id') Message message) {
		return new ModelAndView('messages/view', 'message', message);
	}
	@GetMapping(params = 'form')
	public String createForm(@ModelAttribute Message message) {
		return 'messages/form';
	}
	@PostMapping
	public ModelAndView create(@Valid Message message, BindingResult result, RedirectAttributes redirect) {
		if (result.hasErrors()) {
			ModelAndView mav = new ModelAndView('messages/form');
			mav.addObject('formErrors', result.getAllErrors());
			mav.addObject('fieldErrors', getFieldErrors(result));
			return mav;
		}
		message = this.messageRepository.save(message);
		redirect.addFlashAttribute('globalMessage', 'Successfully created a new message');
		return new ModelAndView('redirect:/{message.id}', 'message.id', message.getId());
	}
	private Map<String, ObjectError> getFieldErrors(BindingResult result) {
		Map<String, ObjectError> map = new HashMap<>();
		for (FieldError error : result.getFieldErrors()) {
			map.put(error.getField(), error);
		}
		return map;
	}
	@RequestMapping('foo')
	public String foo() {
		throw new RuntimeException('Expected exception in controller');
	}
}
/*
package smoketest.groovytemplates;
@SpringBootApplication
public class SampleGroovyTemplateApplication {
	@Bean
	public MessageRepository messageRepository() {
		return new InMemoryMessageRepository();
	}
	@Bean
	public Converter<String, Message> messageConverter() {
		return new Converter<>() {
			@Override
			public Message convert(String id) {
				return messageRepository().findMessage(Long.valueOf(id));
			}
		};
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleGroovyTemplateApplication.class, args);
	}
}
/*
package smoketest.hateoas;
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleHateoasApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void hasHalLinksWhenAnythingIsAcceptable() {
		HttpHeaders headers = new HttpHeaders();
		ResponseEntity<String> entity = this.restTemplate.exchange('/customers/1', HttpMethod.GET,
				new HttpEntity<>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).startsWith('{\'id\':1,\'firstName\':\'Oliver\',\'lastName\':\'Gierke\'');
		assertThat(entity.getBody()).contains('_links\':{\'self\':{\'href\'');
	}
	@Test
	void hasHalLinksWhenJsonIsAcceptable() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
		ResponseEntity<String> entity = this.restTemplate.exchange('/customers/1', HttpMethod.GET,
				new HttpEntity<>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).startsWith('{\'id\':1,\'firstName\':\'Oliver\',\'lastName\':\'Gierke\'');
		assertThat(entity.getBody()).contains('_links\':{\'self\':{\'href\'');
	}
	@Test
	void producesJsonWhenXmlIsPreferred() {
		HttpHeaders headers = new HttpHeaders();
		headers.set(HttpHeaders.ACCEPT, 'application/xml;q=0.9,application/json;q=0.8');
		HttpEntity<?> request = new HttpEntity<>(headers);
		ResponseEntity<String> response = this.restTemplate.exchange('/customers/1', HttpMethod.GET, request,
				String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(response.getHeaders().getContentType()).isEqualTo(MediaType.parseMediaType('application/json'));
	}
}
/*
package smoketest.hateoas.web;
@Controller
@RequestMapping('/customers')
@ExposesResourceFor(Customer.class)
public class CustomerController {
	private final CustomerRepository repository;
	private final EntityLinks entityLinks;
	public CustomerController(CustomerRepository repository, EntityLinks entityLinks) {
		this.repository = repository;
		this.entityLinks = entityLinks;
	}
	@GetMapping(produces = MediaType.APPLICATION_JSON_VALUE)
	HttpEntity<CollectionModel<Customer>> showCustomers() {
		CollectionModel<Customer> resources = CollectionModel.of(this.repository.findAll());
		resources.add(this.entityLinks.linkToCollectionResource(Customer.class));
		return new ResponseEntity<>(resources, HttpStatus.OK);
	}
	@GetMapping(path = '/{id}', produces = MediaType.APPLICATION_JSON_VALUE)
	HttpEntity<EntityModel<Customer>> showCustomer(@PathVariable Long id) {
		EntityModel<Customer> resource = EntityModel.of(this.repository.findOne(id));
		resource.add(this.entityLinks.linkToItemResource(Customer.class, id));
		return new ResponseEntity<>(resource, HttpStatus.OK);
	}
}
/*
package smoketest.hateoas.domain;
public interface CustomerRepository {
	List<Customer> findAll();
	Customer findOne(Long id);
}
/*
package smoketest.hateoas.domain;
@Repository
public class InMemoryCustomerRepository implements CustomerRepository {
	private final List<Customer> customers = new ArrayList<>();
	public InMemoryCustomerRepository() {
		this.customers.add(new Customer(1L, 'Oliver', 'Gierke'));
		this.customers.add(new Customer(2L, 'Andy', 'Wilkinson'));
		this.customers.add(new Customer(2L, 'Dave', 'Syer'));
	}
	@Override
	public List<Customer> findAll() {
		return this.customers;
	}
	@Override
	public Customer findOne(Long id) {
		for (Customer customer : this.customers) {
			if (ObjectUtils.nullSafeEquals(customer.getId(), id)) {
				return customer;
			}
		}
		return null;
	}
}
/*
package smoketest.hateoas.domain;
public class Customer {
	private final Long id;
	private final String firstName;
	private final String lastName;
	public Customer(Long id, String firstName, String lastName) {
		this.id = id;
		this.firstName = firstName;
		this.lastName = lastName;
	}
	public Long getId() {
		return this.id;
	}
	public String getFirstName() {
		return this.firstName;
	}
	public String getLastName() {
		return this.lastName;
	}
}
/*
package smoketest.hateoas;
@SpringBootApplication
public class SampleHateoasApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleHateoasApplication.class, args);
	}
}
/*
package smoketest.simple;
/**
@SpringBootTest
class SpringTestSampleSimpleApplicationTests {
	@Autowired
	ApplicationContext ctx;
	@Test
	void testContextLoads() {
		assertThat(this.ctx).isNotNull();
		assertThat(this.ctx.containsBean('helloWorldService')).isTrue();
		assertThat(this.ctx.containsBean('sampleSimpleApplication')).isTrue();
	}
}
/*
package smoketest.simple;
/**
@ExtendWith(OutputCaptureExtension.class)
class SampleSimpleApplicationTests {
	private String profiles;
	@BeforeEach
	void init() {
		this.profiles = System.getProperty('spring.profiles.active');
	}
	@AfterEach
	void after() {
		if (this.profiles != null) {
			System.setProperty('spring.profiles.active', this.profiles);
		}
		else {
			System.clearProperty('spring.profiles.active');
		}
	}
	@Test
	void testDefaultSettings(CapturedOutput output) {
		SampleSimpleApplication.main(new String[0]);
		assertThat(output).contains('Hello Phil');
	}
	@Test
	void testCommandLineOverrides(CapturedOutput output) {
		SampleSimpleApplication.main(new String[] { '--test.name=Gordon', '--test.duration=1m' });
		assertThat(output).contains('Hello Gordon for 60 seconds');
	}
}
/*
package smoketest.simple.service;
@Component
public class HelloWorldService {
	@Value('${test.name:World}')
	private String name;
	@Value('${test.duration:10s}')
	private Duration duration;
	public String getHelloMessage() {
		return 'Hello ' + this.name + ' for ' + this.duration.getSeconds() + ' seconds';
	}
}
/*
package smoketest.simple;
public class ExitException extends RuntimeException implements ExitCodeGenerator {
	@Override
	public int getExitCode() {
		return 10;
	}
}
/*
package smoketest.simple;
@Validated
@ConfigurationProperties(prefix = 'sample')
public final class SampleConfigurationProperties {
	@NotNull
	private String name;
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package smoketest.simple;
@SpringBootApplication
@EnableConfigurationProperties(SampleConfigurationProperties.class)
public class SampleSimpleApplication implements CommandLineRunner {
	// Simple example shows how a command line spring application can execute an
	// injected bean service. Also demonstrates how you can use @Value to inject
	// command line args ("--test.name=whatever") or application properties
	@Autowired
	private HelloWorldService helloWorldService;
	@Override
	public void run(String... args) {
		System.out.println(this.helloWorldService.getHelloMessage());
		if (args.length > 0 && args[0].equals('exitcode')) {
			throw new ExitException();
		}
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleSimpleApplication.class, args);
	}
}
/*
package smoketest.oauth2.client;
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'APP-CLIENT-ID=my-client-id', 'APP-CLIENT-SECRET=my-client-secret',
				'YAHOO-CLIENT-ID=my-yahoo-client-id', 'YAHOO-CLIENT-SECRET=my-yahoo-client-secret' })
class SampleOAuth2ClientApplicationTests {
	@LocalServerPort
	private int port;
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void everythingShouldRedirectToLogin() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation()).isEqualTo(URI.create('http://localhost:' + this.port + '/login'));
	}
	@Test
	void loginShouldHaveAllOAuth2ClientsToChooseFrom() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/login', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('/oauth2/authorization/yahoo');
		assertThat(entity.getBody()).contains('/oauth2/authorization/github-client-1');
		assertThat(entity.getBody()).contains('/oauth2/authorization/github-client-2');
		assertThat(entity.getBody()).contains('/oauth2/authorization/github-repos');
	}
}
/*
package smoketest.oauth2.client;
@RestController
public class ExampleController {
	@RequestMapping('/')
	public String email(Principal principal) {
		return 'Hello ' + principal.getName();
	}
}
/*
package smoketest.oauth2.client;
@SpringBootApplication
public class SampleOAuth2ClientApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleOAuth2ClientApplication.class);
	}
}
/*
package smoketest.data.jpa;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
@SpringBootTest
@AutoConfigureMockMvc
@AutoConfigureTestDatabase
class SpyBeanSampleDataJpaApplicationTests {
	@Autowired
	private MockMvcTester mvc;
	@SpyBean
	private CityRepository repository;
	@Test
	void testHome() {
		assertThat(this.mvc.get().uri('/')).hasStatusOk().hasBodyTextEqualTo('Bath');
		then(this.repository).should().findByNameAndCountryAllIgnoringCase('Bath', 'UK');
	}
}
/*
package smoketest.data.jpa.service;
/**
@SpringBootTest
class CityRepositoryIntegrationTests {
	@Autowired
	CityRepository repository;
	@Test
	void findsFirstPageOfCities() {
		Page<City> cities = this.repository.findAll(PageRequest.of(0, 10));
		assertThat(cities.getTotalElements()).isGreaterThan(20L);
	}
}
/*
package smoketest.data.jpa.service;
/**
@SpringBootTest
class HotelRepositoryIntegrationTests {
	@Autowired
	CityRepository cityRepository;
	@Autowired
	HotelRepository repository;
	@Test
	void executesQueryMethodsCorrectly() {
		City city = this.cityRepository.findAll(PageRequest.of(0, 1, Direction.ASC, 'name')).getContent().get(0);
		assertThat(city.getName()).isEqualTo('Atlanta');
		Page<HotelSummary> hotels = this.repository.findByCity(city, PageRequest.of(0, 10, Direction.ASC, 'name'));
		Hotel hotel = this.repository.findByCityAndName(city, hotels.getContent().get(0).getName());
		assertThat(hotel.getName()).isEqualTo('Doubletree');
		List<RatingCount> counts = this.repository.findRatingCounts(hotel);
		assertThat(counts).hasSize(1);
		assertThat(counts.get(0).getRating()).isEqualTo(Rating.AVERAGE);
		assertThat(counts.get(0).getCount()).isGreaterThan(1L);
	}
}
/*
package smoketest.data.jpa;
/**
// Enable JMX so we can test the MBeans (you can"t do this in a properties file)
@SpringBootTest(properties = 'spring.jmx.enabled:true')
@AutoConfigureMockMvc
@ActiveProfiles('scratch')
// Separate profile for web tests to avoid clashing databases
class SampleDataJpaApplicationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void testHome() {
		assertThat(this.mvc.get().uri('/')).hasStatusOk().hasBodyTextEqualTo('Bath');
	}
	@Test
	void testJmx() throws Exception {
		assertThat(ManagementFactory.getPlatformMBeanServer()
			.queryMBeans(new ObjectName('jpa.sample:type=HikariDataSource,*'), null)).hasSize(1);
	}
}
/*
package smoketest.data.jpa.web;
@Controller
public class SampleController {
	@Autowired
	private CityService cityService;
	@GetMapping('/')
	@ResponseBody
	@Transactional(readOnly = true)
	public String helloWorld() {
		return this.cityService.getCity('Bath', 'UK').getName();
	}
}
/*
package smoketest.data.jpa.domain;
@Entity
public class Hotel implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@SequenceGenerator(name = 'hotel_generator', sequenceName = 'hotel_sequence', initialValue = 28)
	@GeneratedValue(generator = 'hotel_generator')
	private Long id;
	@ManyToOne(optional = false)
	@NaturalId
	private City city;
	@Column(nullable = false)
	@NaturalId
	private String name;
	@Column(nullable = false)
	private String address;
	@Column(nullable = false)
	private String zip;
	@OneToMany(fetch = FetchType.LAZY, mappedBy = 'hotel')
	private Set<Review> reviews;
	protected Hotel() {
	}
	public Hotel(City city, String name) {
		this.city = city;
		this.name = name;
	}
	public City getCity() {
		return this.city;
	}
	public String getName() {
		return this.name;
	}
	public String getAddress() {
		return this.address;
	}
	public String getZip() {
		return this.zip;
	}
}
/*
package smoketest.data.jpa.domain;
public enum TripType {
	BUSINESS, COUPLES, FAMILY, FRIENDS, SOLO
}
/*
package smoketest.data.jpa.domain;
@Entity
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@SequenceGenerator(name = 'city_generator', sequenceName = 'city_sequence', initialValue = 23)
	@GeneratedValue(generator = 'city_generator')
	private Long id;
	@Column(nullable = false)
	private String name;
	@Column(nullable = false)
	private String state;
	@Column(nullable = false)
	private String country;
	@Column(nullable = false)
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package smoketest.data.jpa.domain;
public interface RatingCount {
	Rating getRating();
	long getCount();
}
/*
package smoketest.data.jpa.domain;
public enum Rating {
	TERRIBLE, POOR, AVERAGE, GOOD, EXCELLENT
}
/*
package smoketest.data.jpa.domain;
public interface HotelSummary {
	City getCity();
	String getName();
}
/*
package smoketest.data.jpa.domain;
public class ReviewDetails implements Serializable {
	private static final long serialVersionUID = 1L;
	private Rating rating;
	private Date checkInDate;
	private TripType tripType;
	private String title;
	private String details;
	public ReviewDetails() {
	}
	public Rating getRating() {
		return this.rating;
	}
	public void setRating(Rating rating) {
		this.rating = rating;
	}
	public Date getCheckInDate() {
		return this.checkInDate;
	}
	public void setCheckInDate(Date checkInDate) {
		this.checkInDate = checkInDate;
	}
	public TripType getTripType() {
		return this.tripType;
	}
	public void setTripType(TripType tripType) {
		this.tripType = tripType;
	}
	public String getTitle() {
		return this.title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getDetails() {
		return this.details;
	}
	public void setDetails(String details) {
		this.details = details;
	}
}
/*
package smoketest.data.jpa.domain;
@Entity
public class Review implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@SequenceGenerator(name = 'review_generator', sequenceName = 'review_sequence', initialValue = 64)
	@GeneratedValue(generator = 'review_generator')
	private Long id;
	@ManyToOne(optional = false)
	private Hotel hotel;
	@Column(nullable = false, name = 'idx')
	private int index;
	@Column(nullable = false)
	@Enumerated(EnumType.ORDINAL)
	private Rating rating;
	@Column(nullable = false)
	@Temporal(TemporalType.DATE)
	private Date checkInDate;
	@Column(nullable = false)
	@Enumerated(EnumType.ORDINAL)
	private TripType tripType;
	@Column(nullable = false)
	private String title;
	@Column(nullable = false, length = 5000)
	private String details;
	protected Review() {
	}
	public Review(Hotel hotel, int index, ReviewDetails details) {
		Assert.notNull(hotel, 'Hotel must not be null');
		Assert.notNull(details, 'Details must not be null');
		this.hotel = hotel;
		this.index = index;
		this.rating = details.getRating();
		this.checkInDate = details.getCheckInDate();
		this.tripType = details.getTripType();
		this.title = details.getTitle();
		this.details = details.getDetails();
	}
	public Hotel getHotel() {
		return this.hotel;
	}
	public int getIndex() {
		return this.index;
	}
	public Rating getRating() {
		return this.rating;
	}
	public void setRating(Rating rating) {
		this.rating = rating;
	}
	public Date getCheckInDate() {
		return this.checkInDate;
	}
	public void setCheckInDate(Date checkInDate) {
		this.checkInDate = checkInDate;
	}
	public TripType getTripType() {
		return this.tripType;
	}
	public void setTripType(TripType tripType) {
		this.tripType = tripType;
	}
	public String getTitle() {
		return this.title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getDetails() {
		return this.details;
	}
	public void setDetails(String details) {
		this.details = details;
	}
}
/*
package smoketest.data.jpa;
@SpringBootApplication
public class SampleDataJpaApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleDataJpaApplication.class, args);
	}
}
/*
package smoketest.data.jpa.service;
@Component('cityService')
@Transactional
class CityServiceImpl implements CityService {
	private final CityRepository cityRepository;
	private final HotelRepository hotelRepository;
	CityServiceImpl(CityRepository cityRepository, HotelRepository hotelRepository) {
		this.cityRepository = cityRepository;
		this.hotelRepository = hotelRepository;
	}
	@Override
	public Page<City> findCities(CitySearchCriteria criteria, Pageable pageable) {
		Assert.notNull(criteria, 'Criteria must not be null');
		String name = criteria.getName();
		if (!StringUtils.hasLength(name)) {
			return this.cityRepository.findAll(null);
		}
		String country = '';
		int splitPos = name.lastIndexOf(",");
		if (splitPos >= 0) {
			country = name.substring(splitPos + 1);
			name = name.substring(0, splitPos);
		}
		return this.cityRepository.findByNameContainingAndCountryContainingAllIgnoringCase(name.trim(), country.trim(),
				pageable);
	}
	@Override
	public City getCity(String name, String country) {
		Assert.notNull(name, 'Name must not be null');
		Assert.notNull(country, 'Country must not be null');
		return this.cityRepository.findByNameAndCountryAllIgnoringCase(name, country);
	}
	@Override
	public Page<HotelSummary> getHotels(City city, Pageable pageable) {
		Assert.notNull(city, 'City must not be null');
		return this.hotelRepository.findByCity(city, pageable);
	}
}
/*
package smoketest.data.jpa.service;
public class CitySearchCriteria implements Serializable {
	private static final long serialVersionUID = 1L;
	private String name;
	public CitySearchCriteria() {
	}
	public CitySearchCriteria(String name) {
		Assert.notNull(name, 'Name must not be null');
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package smoketest.data.jpa.service;
public interface CityService {
	Page<City> findCities(CitySearchCriteria criteria, Pageable pageable);
	City getCity(String name, String country);
	Page<HotelSummary> getHotels(City city, Pageable pageable);
}
/*
package smoketest.data.jpa.service;
public interface HotelService {
	Hotel getHotel(City city, String name);
	Page<Review> getReviews(Hotel hotel, Pageable pageable);
	Review getReview(Hotel hotel, int index);
	Review addReview(Hotel hotel, ReviewDetails details);
	ReviewsSummary getReviewSummary(Hotel hotel);
}
/*
package smoketest.data.jpa.service;
interface HotelRepository extends Repository<Hotel, Long> {
	Hotel findByCityAndName(City city, String name);
	@Query('select h.city as city, h.name as name, avg(cast(r.rating as Integer)) as averageRating '
			+ 'from Hotel h left outer join h.reviews r where h.city = ?1 group by h')
	Page<HotelSummary> findByCity(City city, Pageable pageable);
	@Query('select r.rating as rating, count(r) as count '
			+ 'from Review r where r.hotel = ?1 group by r.rating order by r.rating DESC')
	List<RatingCount> findRatingCounts(Hotel hotel);
}
/*
package smoketest.data.jpa.service;
interface ReviewRepository extends Repository<Review, Long> {
	Page<Review> findByHotel(Hotel hotel, Pageable pageable);
	Review findByHotelAndIndex(Hotel hotel, int index);
	Review save(Review review);
}
/*
package smoketest.data.jpa.service;
@Component('hotelService')
@Transactional
class HotelServiceImpl implements HotelService {
	private final HotelRepository hotelRepository;
	private final ReviewRepository reviewRepository;
	HotelServiceImpl(HotelRepository hotelRepository, ReviewRepository reviewRepository) {
		this.hotelRepository = hotelRepository;
		this.reviewRepository = reviewRepository;
	}
	@Override
	public Hotel getHotel(City city, String name) {
		Assert.notNull(city, 'City must not be null');
		Assert.hasLength(name, 'Name must not be empty');
		return this.hotelRepository.findByCityAndName(city, name);
	}
	@Override
	public Page<Review> getReviews(Hotel hotel, Pageable pageable) {
		Assert.notNull(hotel, 'Hotel must not be null');
		return this.reviewRepository.findByHotel(hotel, pageable);
	}
	@Override
	public Review getReview(Hotel hotel, int reviewNumber) {
		Assert.notNull(hotel, 'Hotel must not be null');
		return this.reviewRepository.findByHotelAndIndex(hotel, reviewNumber);
	}
	@Override
	public Review addReview(Hotel hotel, ReviewDetails details) {
		Review review = new Review(hotel, 1, details);
		return this.reviewRepository.save(review);
	}
	@Override
	public ReviewsSummary getReviewSummary(Hotel hotel) {
		List<RatingCount> ratingCounts = this.hotelRepository.findRatingCounts(hotel);
		return new ReviewsSummaryImpl(ratingCounts);
	}
	private static class ReviewsSummaryImpl implements ReviewsSummary {
		private final Map<Rating, Long> ratingCount;
		ReviewsSummaryImpl(List<RatingCount> ratingCounts) {
			this.ratingCount = new HashMap<>();
			for (RatingCount ratingCount : ratingCounts) {
				this.ratingCount.put(ratingCount.getRating(), ratingCount.getCount());
			}
		}
		@Override
		public long getNumberOfReviewsWithRating(Rating rating) {
			Long count = this.ratingCount.get(rating);
			return (count != null) ? count : 0;
		}
	}
}
/*
package smoketest.data.jpa.service;
public interface ReviewsSummary {
	long getNumberOfReviewsWithRating(Rating rating);
}
/*
package smoketest.data.jpa.service;
public interface CityRepository extends Repository<City, Long> {
	Page<City> findAll(Pageable pageable);
	Page<City> findByNameContainingAndCountryContainingAllIgnoringCase(String name, String country, Pageable pageable);
	City findByNameAndCountryAllIgnoringCase(String name, String country);
}
/*
package smoketest.tomcat.multiconnector;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@Import(Ports.class)
class SampleTomcatTwoConnectorsApplicationTests {
	@LocalServerPort
	private int port;
	@Autowired
	private Ports ports;
	@Autowired
	private TestRestTemplate restTemplate;
	@Autowired
	private AbstractConfigurableWebServerFactory webServerFactory;
	@Test
	void testSsl() {
		assertThat(this.webServerFactory.getSsl().isEnabled()).isTrue();
	}
	@Test
	void testHello() {
		assertThat(this.ports.getHttpsPort()).isEqualTo(this.port);
		assertThat(this.ports.getHttpPort()).isNotEqualTo(this.port);
		ResponseEntity<String> entity = this.restTemplate
			.getForEntity('http://localhost:' + this.ports.getHttpPort() + '/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('hello');
		ResponseEntity<String> httpsEntity = this.restTemplate.getForEntity('https://localhost:' + this.port + '/hello',
				String.class);
		assertThat(httpsEntity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(httpsEntity.getBody()).isEqualTo('hello');
	}
	@TestConfiguration
	static class Ports implements ApplicationListener<WebServerInitializedEvent> {
		private int httpPort;
		private int httpsPort;
		@Override
		public void onApplicationEvent(WebServerInitializedEvent event) {
			Service service = ((TomcatWebServer) event.getWebServer()).getTomcat().getService();
			for (Connector connector : service.findConnectors()) {
				if (connector.getSecure()) {
					this.httpsPort = connector.getLocalPort();
				}
				else {
					this.httpPort = connector.getLocalPort();
				}
			}
		}
		int getHttpPort() {
			return this.httpPort;
		}
		int getHttpsPort() {
			return this.httpsPort;
		}
	}
}
/*
package smoketest.tomcat.multiconnector.web;
@RestController
public class SampleController {
	@GetMapping('/hello')
	public String helloWorld() {
		return 'hello';
	}
}
/*
package smoketest.tomcat.multiconnector;
/**
@SpringBootApplication
public class SampleTomcatTwoConnectorsApplication {
	@Bean
	public ServletWebServerFactory servletContainer() {
		TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
		tomcat.addAdditionalTomcatConnectors(createStandardConnector());
		return tomcat;
	}
	private Connector createStandardConnector() {
		Connector connector = new Connector('org.apache.coyote.http11.Http11NioProtocol');
		connector.setPort(0);
		return connector;
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleTomcatTwoConnectorsApplication.class, args);
	}
}
/*
package smoketest.websocket.undertow.echo;
@SpringBootTest(classes = { SampleUndertowWebSocketsApplication.class, CustomContainerConfiguration.class },
		webEnvironment = WebEnvironment.RANDOM_PORT)
class CustomContainerWebSocketsApplicationTests {
	private static final Log logger = LogFactory.getLog(CustomContainerWebSocketsApplicationTests.class);
	@LocalServerPort
	private int port;
	@Test
	void echoEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/ws/echo/websocket')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Did you say \'Hello world!\'?');
	}
	@Test
	void reverseEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/ws/reverse')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Reversed: !dlrow olleH');
	}
	@Configuration(proxyBeanMethods = false)
	protected static class CustomContainerConfiguration {
		@Bean
		public ServletWebServerFactory webServerFactory() {
			return new UndertowServletWebServerFactory('/ws', 0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClientConfiguration implements CommandLineRunner {
		@Value('${websocket.uri}')
		private String webSocketUri;
		private final CountDownLatch latch = new CountDownLatch(1);
		private final AtomicReference<String> messagePayload = new AtomicReference<>();
		@Override
		public void run(String... args) throws Exception {
			logger.info('Waiting for response: latch=' + this.latch.getCount());
			if (this.latch.await(10, TimeUnit.SECONDS)) {
				logger.info('Got response: ' + this.messagePayload.get());
			}
			else {
				logger.info('Response not received: latch=' + this.latch.getCount());
			}
		}
		@Bean
		WebSocketConnectionManager wsConnectionManager() {
			WebSocketConnectionManager manager = new WebSocketConnectionManager(client(), handler(), this.webSocketUri);
			manager.setAutoStartup(true);
			return manager;
		}
		@Bean
		StandardWebSocketClient client() {
			return new StandardWebSocketClient();
		}
		@Bean
		SimpleClientWebSocketHandler handler() {
			return new SimpleClientWebSocketHandler(greetingService(), this.latch, this.messagePayload);
		}
		@Bean
		GreetingService greetingService() {
			return new SimpleGreetingService();
		}
	}
}
/*
package smoketest.websocket.undertow;
@SpringBootTest(classes = SampleUndertowWebSocketsApplication.class, webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebSocketsApplicationTests {
	private static final Log logger = LogFactory.getLog(SampleWebSocketsApplicationTests.class);
	@LocalServerPort
	private int port = 1234;
	@Test
	void echoEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/echo/websocket')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Did you say \'Hello world!\'?');
	}
	@Test
	void reverseEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/reverse')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Reversed: !dlrow olleH');
	}
	@Configuration(proxyBeanMethods = false)
	static class ClientConfiguration implements CommandLineRunner {
		@Value('${websocket.uri}')
		private String webSocketUri;
		private final CountDownLatch latch = new CountDownLatch(1);
		private final AtomicReference<String> messagePayload = new AtomicReference<>();
		@Override
		public void run(String... args) throws Exception {
			logger.info('Waiting for response: latch=' + this.latch.getCount());
			if (this.latch.await(10, TimeUnit.SECONDS)) {
				logger.info('Got response: ' + this.messagePayload.get());
			}
			else {
				logger.info('Response not received: latch=' + this.latch.getCount());
			}
		}
		@Bean
		WebSocketConnectionManager wsConnectionManager() {
			WebSocketConnectionManager manager = new WebSocketConnectionManager(client(), handler(), this.webSocketUri);
			manager.setAutoStartup(true);
			return manager;
		}
		@Bean
		StandardWebSocketClient client() {
			return new StandardWebSocketClient();
		}
		@Bean
		SimpleClientWebSocketHandler handler() {
			return new SimpleClientWebSocketHandler(greetingService(), this.latch, this.messagePayload);
		}
		@Bean
		GreetingService greetingService() {
			return new SimpleGreetingService();
		}
	}
}
/*
package smoketest.websocket.undertow.snake;
class SnakeTimerTests {
	@Test
	void removeDysfunctionalSnakes() throws Exception {
		Snake snake = mock(Snake.class);
		willThrow(new IOException()).given(snake).sendMessage(anyString());
		SnakeTimer.addSnake(snake);
		SnakeTimer.broadcast('');
		assertThat(SnakeTimer.getSnakes()).isEmpty();
	}
}
/*
package smoketest.websocket.undertow.reverse;
@ServerEndpoint('/reverse')
public class ReverseWebSocketEndpoint {
	@OnMessage
	public void handleMessage(Session session, String message) throws IOException {
		session.getBasicRemote().sendText('Reversed: ' + new StringBuilder(message).reverse());
	}
}
/*
package smoketest.websocket.undertow;
@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@EnableWebSocket
public class SampleUndertowWebSocketsApplication extends SpringBootServletInitializer implements WebSocketConfigurer {
	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(echoWebSocketHandler(), '/echo').setAllowedOrigins('*').withSockJS();
		registry.addHandler(snakeWebSocketHandler(), '/snake').setAllowedOrigins('*').withSockJS();
	}
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleUndertowWebSocketsApplication.class);
	}
	@Bean
	public EchoService echoService() {
		return new DefaultEchoService('Did you say \'%s\'?');
	}
	@Bean
	public GreetingService greetingService() {
		return new SimpleGreetingService();
	}
	@Bean
	public WebSocketHandler echoWebSocketHandler() {
		return new EchoWebSocketHandler(echoService());
	}
	@Bean
	public WebSocketHandler snakeWebSocketHandler() {
		return new PerConnectionWebSocketHandler(SnakeWebSocketHandler.class);
	}
	@Bean
	public ReverseWebSocketEndpoint reverseWebSocketEndpoint() {
		return new ReverseWebSocketEndpoint();
	}
	@Bean
	public ServerEndpointExporter serverEndpointExporter() {
		return new ServerEndpointExporter();
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleUndertowWebSocketsApplication.class, args);
	}
}
/*
package smoketest.websocket.undertow.echo;
public interface EchoService {
	String getMessage(String message);
}
/*
package smoketest.websocket.undertow.echo;
/**
public class EchoWebSocketHandler extends TextWebSocketHandler {
	private static final Log logger = LogFactory.getLog(EchoWebSocketHandler.class);
	private final EchoService echoService;
	public EchoWebSocketHandler(EchoService echoService) {
		this.echoService = echoService;
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) {
		logger.debug('Opened new session in instance ' + this);
	}
	@Override
	public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		String echoMessage = this.echoService.getMessage(message.getPayload());
		logger.debug(echoMessage);
		session.sendMessage(new TextMessage(echoMessage));
	}
	@Override
	public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
		session.close(CloseStatus.SERVER_ERROR);
	}
}
/*
package smoketest.websocket.undertow.echo;
public class DefaultEchoService implements EchoService {
	private final String echoFormat;
	public DefaultEchoService(String echoFormat) {
		this.echoFormat = (echoFormat != null) ? echoFormat : '%s';
	}
	@Override
	public String getMessage(String message) {
		return String.format(this.echoFormat, message);
	}
}
/*
package smoketest.websocket.undertow.client;
public class SimpleGreetingService implements GreetingService {
	@Override
	public String getGreeting() {
		return 'Hello world!';
	}
}
/*
package smoketest.websocket.undertow.client;
public interface GreetingService {
	String getGreeting();
}
/*
package smoketest.websocket.undertow.client;
public class SimpleClientWebSocketHandler extends TextWebSocketHandler {
	protected Log logger = LogFactory.getLog(SimpleClientWebSocketHandler.class);
	private final GreetingService greetingService;
	private final CountDownLatch latch;
	private final AtomicReference<String> messagePayload;
	public SimpleClientWebSocketHandler(GreetingService greetingService, CountDownLatch latch,
			AtomicReference<String> message) {
		this.greetingService = greetingService;
		this.latch = latch;
		this.messagePayload = message;
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		TextMessage message = new TextMessage(this.greetingService.getGreeting());
		session.sendMessage(message);
	}
	@Override
	public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		this.logger.info('Received: ' + message + ' (' + this.latch.getCount() + ')');
		session.close();
		this.messagePayload.set(message.getPayload());
		this.latch.countDown();
	}
}
/*
package smoketest.websocket.undertow.snake;
public class Snake {
	private static final int DEFAULT_LENGTH = 5;
	private final Deque<Location> tail = new ArrayDeque<>();
	private final Object monitor = new Object();
	private final int id;
	private final WebSocketSession session;
	private final String hexColor;
	private Direction direction;
	private int length = DEFAULT_LENGTH;
	private Location head;
	public Snake(int id, WebSocketSession session) {
		this.id = id;
		this.session = session;
		this.hexColor = SnakeUtils.getRandomHexColor();
		resetState();
	}
	private void resetState() {
		this.direction = Direction.NONE;
		this.head = SnakeUtils.getRandomLocation();
		this.tail.clear();
		this.length = DEFAULT_LENGTH;
	}
	private void kill() throws Exception {
		synchronized (this.monitor) {
			resetState();
			sendMessage('{"type": "dead"}');
		}
	}
	private void reward() throws Exception {
		synchronized (this.monitor) {
			this.length++;
			sendMessage('{"type": "kill"}');
		}
	}
	protected void sendMessage(String msg) throws Exception {
		this.session.sendMessage(new TextMessage(msg));
	}
	public void update(Collection<Snake> snakes) throws Exception {
		synchronized (this.monitor) {
			Location nextLocation = this.head.getAdjacentLocation(this.direction);
			if (nextLocation.x >= SnakeUtils.PLAYFIELD_WIDTH) {
				nextLocation.x = 0;
			}
			if (nextLocation.y >= SnakeUtils.PLAYFIELD_HEIGHT) {
				nextLocation.y = 0;
			}
			if (nextLocation.x < 0) {
				nextLocation.x = SnakeUtils.PLAYFIELD_WIDTH;
			}
			if (nextLocation.y < 0) {
				nextLocation.y = SnakeUtils.PLAYFIELD_HEIGHT;
			}
			if (this.direction != Direction.NONE) {
				this.tail.addFirst(this.head);
				if (this.tail.size() > this.length) {
					this.tail.removeLast();
				}
				this.head = nextLocation;
			}
			handleCollisions(snakes);
		}
	}
	private void handleCollisions(Collection<Snake> snakes) throws Exception {
		for (Snake snake : snakes) {
			boolean headCollision = this.id != snake.id && snake.getHead().equals(this.head);
			boolean tailCollision = snake.getTail().contains(this.head);
			if (headCollision || tailCollision) {
				kill();
				if (this.id != snake.id) {
					snake.reward();
				}
			}
		}
	}
	public Location getHead() {
		synchronized (this.monitor) {
			return this.head;
		}
	}
	public Collection<Location> getTail() {
		synchronized (this.monitor) {
			return this.tail;
		}
	}
	public void setDirection(Direction direction) {
		synchronized (this.monitor) {
			this.direction = direction;
		}
	}
	public String getLocationsJson() {
		synchronized (this.monitor) {
			StringBuilder sb = new StringBuilder();
			sb.append(String.format('{x: %d, y: %d}', this.head.x, this.head.y));
			for (Location location : this.tail) {
				sb.append(",");
				sb.append(String.format('{x: %d, y: %d}', location.x, location.y));
			}
			return String.format('{"id":%d,"body":[%s]}', this.id, sb);
		}
	}
	public int getId() {
		return this.id;
	}
	public String getHexColor() {
		return this.hexColor;
	}
}
/*
package smoketest.websocket.undertow.snake;
public class Location {
	/**
	 * The X location.
	 */
	public int x;
	/**
	 * The Y location.
	 */
	public int y;
	public Location(int x, int y) {
		this.x = x;
		this.y = y;
	}
	public Location getAdjacentLocation(Direction direction) {
		return switch (direction) {
			case NORTH -> new Location(this.x, this.y - SnakeUtils.GRID_SIZE);
			case SOUTH -> new Location(this.x, this.y + SnakeUtils.GRID_SIZE);
			case EAST -> new Location(this.x + SnakeUtils.GRID_SIZE, this.y);
			case WEST -> new Location(this.x - SnakeUtils.GRID_SIZE, this.y);
			case NONE -> this;
		};
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Location location = (Location) o;
		if (this.x != location.x) {
			return false;
		}
		return this.y == location.y;
	}
	@Override
	public int hashCode() {
		int result = this.x;
		result = 31 * result + this.y;
		return result;
	}
}
/*
package smoketest.websocket.undertow.snake;
/**
public final class SnakeTimer {
	private static final long TICK_DELAY = 100;
	private static final Object MONITOR = new Object();
	private static final Log logger = LogFactory.getLog(SnakeTimer.class);
	private static final ConcurrentHashMap<Integer, Snake> snakes = new ConcurrentHashMap<>();
	private static Timer gameTimer = null;
	private SnakeTimer() {
	}
	public static void addSnake(Snake snake) {
		synchronized (MONITOR) {
			if (snakes.isEmpty()) {
				startTimer();
			}
			snakes.put(snake.getId(), snake);
		}
	}
	public static Collection<Snake> getSnakes() {
		return Collections.unmodifiableCollection(snakes.values());
	}
	public static void removeSnake(Snake snake) {
		synchronized (MONITOR) {
			snakes.remove(snake.getId());
			if (snakes.isEmpty()) {
				stopTimer();
			}
		}
	}
	public static void tick() throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Iterator<Snake> iterator = SnakeTimer.getSnakes().iterator(); iterator.hasNext();) {
			Snake snake = iterator.next();
			snake.update(SnakeTimer.getSnakes());
			sb.append(snake.getLocationsJson());
			if (iterator.hasNext()) {
				sb.append(",");
			}
		}
		broadcast(String.format('{"type": "update", "data" : [%s]}', sb));
	}
	public static void broadcast(String message) {
		Collection<Snake> snakes = new CopyOnWriteArrayList<>(SnakeTimer.getSnakes());
		for (Snake snake : snakes) {
			try {
				snake.sendMessage(message);
			}
			catch (Throwable ex) {
				// if Snake#sendMessage fails the client is removed
				removeSnake(snake);
			}
		}
	}
	public static void startTimer() {
		gameTimer = new Timer(SnakeTimer.class.getSimpleName() + ' Timer');
		gameTimer.scheduleAtFixedRate(new TimerTask() {
			@Override
			public void run() {
				try {
					tick();
				}
				catch (Throwable ex) {
					logger.error('Caught to prevent timer from shutting down', ex);
				}
			}
		}, TICK_DELAY, TICK_DELAY);
	}
	public static void stopTimer() {
		if (gameTimer != null) {
			gameTimer.cancel();
		}
	}
}
/*
package smoketest.websocket.undertow.snake;
public enum Direction {
	NONE, NORTH, SOUTH, EAST, WEST
}
/*
package smoketest.websocket.undertow.snake;
public final class SnakeUtils {
	/**
	 * The width of the playfield.
	 */
	public static final int PLAYFIELD_WIDTH = 640;
	/**
	 * The height of the playfield.
	 */
	public static final int PLAYFIELD_HEIGHT = 480;
	/**
	 * The grid size.
	 */
	public static final int GRID_SIZE = 10;
	private static final Random random = new Random();
	private SnakeUtils() {
	}
	public static String getRandomHexColor() {
		float hue = random.nextFloat();
		// sat between 0.1 and 0.3
		float saturation = (random.nextInt(2000) + 1000) / 10000f;
		float luminance = 0.9f;
		Color color = Color.getHSBColor(hue, saturation, luminance);
		return "#" + Integer.toHexString((color.getRGB() & 0xffffff) | 0x1000000).substring(1);
	}
	public static Location getRandomLocation() {
		int x = roundByGridSize(random.nextInt(PLAYFIELD_WIDTH));
		int y = roundByGridSize(random.nextInt(PLAYFIELD_HEIGHT));
		return new Location(x, y);
	}
	private static int roundByGridSize(int value) {
		value = value + (GRID_SIZE / 2);
		value = value / GRID_SIZE;
		value = value * GRID_SIZE;
		return value;
	}
}
/*
package smoketest.websocket.undertow.snake;
public class SnakeWebSocketHandler extends TextWebSocketHandler {
	private static final AtomicInteger snakeIds = new AtomicInteger();
	private static final Random random = new Random();
	private final int id;
	private Snake snake;
	public static String getRandomHexColor() {
		float hue = random.nextFloat();
		// sat between 0.1 and 0.3
		float saturation = (random.nextInt(2000) + 1000) / 10000f;
		float luminance = 0.9f;
		Color color = Color.getHSBColor(hue, saturation, luminance);
		return "#" + Integer.toHexString((color.getRGB() & 0xffffff) | 0x1000000).substring(1);
	}
	public static Location getRandomLocation() {
		int x = roundByGridSize(random.nextInt(SnakeUtils.PLAYFIELD_WIDTH));
		int y = roundByGridSize(random.nextInt(SnakeUtils.PLAYFIELD_HEIGHT));
		return new Location(x, y);
	}
	private static int roundByGridSize(int value) {
		value = value + (SnakeUtils.GRID_SIZE / 2);
		value = value / SnakeUtils.GRID_SIZE;
		value = value * SnakeUtils.GRID_SIZE;
		return value;
	}
	public SnakeWebSocketHandler() {
		this.id = snakeIds.getAndIncrement();
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		this.snake = new Snake(this.id, session);
		SnakeTimer.addSnake(this.snake);
		StringBuilder sb = new StringBuilder();
		for (Iterator<Snake> iterator = SnakeTimer.getSnakes().iterator(); iterator.hasNext();) {
			Snake snake = iterator.next();
			sb.append(String.format('{id: %d, color: "%s"}', snake.getId(), snake.getHexColor()));
			if (iterator.hasNext()) {
				sb.append(",");
			}
		}
		SnakeTimer.broadcast(String.format('{"type": "join","data":[%s]}', sb));
	}
	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		String payload = message.getPayload();
		switch (payload) {
			case 'west' -> this.snake.setDirection(Direction.WEST);
			case 'north' -> this.snake.setDirection(Direction.NORTH);
			case 'east' -> this.snake.setDirection(Direction.EAST);
			case 'south' -> this.snake.setDirection(Direction.SOUTH);
		}
	}
	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
		SnakeTimer.removeSnake(this.snake);
		SnakeTimer.broadcast(String.format('{"type": "leave", "id": %d}', this.id));
	}
}
/*
package smoketest.liquibase;
@ExtendWith(OutputCaptureExtension.class)
class SampleLiquibaseApplicationTests {
	private Locale defaultLocale;
	@BeforeEach
	void init() throws SecurityException {
		this.defaultLocale = Locale.getDefault();
		Locale.setDefault(Locale.ENGLISH);
	}
	@AfterEach
	void restoreLocale() {
		Locale.setDefault(this.defaultLocale);
	}
	@Test
	void testDefaultSettings(CapturedOutput output) {
		try {
			SampleLiquibaseApplication.main(new String[] { '--server.port=0' });
		}
		catch (IllegalStateException ex) {
			assumeThat(serverNotRunning(ex)).isFalse();
		}
		assertThat(output).contains('Successfully acquired change log lock')
			.contains('Creating database history table with name: PUBLIC.DATABASECHANGELOG')
			.contains('Table person created')
			.contains('ChangeSet db/changelog/db.changelog-master.yaml::1::' + 'marceloverdijk ran successfully')
			.contains('New row inserted into person')
			.contains('ChangeSet db/changelog/' + 'db.changelog-master.yaml::2::marceloverdijk ran successfully')
			.contains('Successfully released change log lock');
	}
	private boolean serverNotRunning(IllegalStateException ex) {
		NestedCheckedException nested = new NestedCheckedException('failed', ex) {
		};
		if (nested.contains(ConnectException.class)) {
			Throwable root = nested.getRootCause();
			return root.getMessage().contains('Connection refused');
		}
		return false;
	}
}
/*
package smoketest.liquibase;
@SpringBootApplication
public class SampleLiquibaseApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleLiquibaseApplication.class, args);
	}
}
/*
package smoketest.websocket.tomcat.echo;
@SpringBootTest(classes = { SampleTomcatWebSocketApplication.class, CustomContainerConfiguration.class },
		webEnvironment = WebEnvironment.RANDOM_PORT)
class CustomContainerWebSocketsApplicationTests {
	private static final Log logger = LogFactory.getLog(CustomContainerWebSocketsApplicationTests.class);
	@LocalServerPort
	private int port;
	@Test
	void echoEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/ws/echo/websocket')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Did you say \'Hello world!\'?');
	}
	@Test
	void reverseEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/ws/reverse')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Reversed: !dlrow olleH');
	}
	@Configuration(proxyBeanMethods = false)
	protected static class CustomContainerConfiguration {
		@Bean
		public ServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory('/ws', 0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ClientConfiguration implements CommandLineRunner {
		@Value('${websocket.uri}')
		private String webSocketUri;
		private final CountDownLatch latch = new CountDownLatch(1);
		private final AtomicReference<String> messagePayload = new AtomicReference<>();
		@Override
		public void run(String... args) throws Exception {
			logger.info('Waiting for response: latch=' + this.latch.getCount());
			if (this.latch.await(10, TimeUnit.SECONDS)) {
				logger.info('Got response: ' + this.messagePayload.get());
			}
			else {
				logger.info('Response not received: latch=' + this.latch.getCount());
			}
		}
		@Bean
		WebSocketConnectionManager wsConnectionManager() {
			WebSocketConnectionManager manager = new WebSocketConnectionManager(client(), handler(), this.webSocketUri);
			manager.setAutoStartup(true);
			return manager;
		}
		@Bean
		StandardWebSocketClient client() {
			return new StandardWebSocketClient();
		}
		@Bean
		SimpleClientWebSocketHandler handler() {
			return new SimpleClientWebSocketHandler(greetingService(), this.latch, this.messagePayload);
		}
		@Bean
		GreetingService greetingService() {
			return new SimpleGreetingService();
		}
	}
}
/*
package smoketest.websocket.tomcat;
@SpringBootTest(classes = SampleTomcatWebSocketApplication.class, webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebSocketsApplicationTests {
	private static final Log logger = LogFactory.getLog(SampleWebSocketsApplicationTests.class);
	@LocalServerPort
	private int port = 1234;
	@Test
	void echoEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/echo/websocket')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Did you say \'Hello world!\'?');
	}
	@Test
	void reverseEndpoint() {
		ConfigurableApplicationContext context = new SpringApplicationBuilder(ClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class)
			.properties('websocket.uri:ws://localhost:' + this.port + '/reverse')
			.run('--spring.main.web-application-type=none');
		long count = context.getBean(ClientConfiguration.class).latch.getCount();
		AtomicReference<String> messagePayloadReference = context.getBean(ClientConfiguration.class).messagePayload;
		context.close();
		assertThat(count).isZero();
		assertThat(messagePayloadReference.get()).isEqualTo('Reversed: !dlrow olleH');
	}
	@Configuration(proxyBeanMethods = false)
	static class ClientConfiguration implements CommandLineRunner {
		@Value('${websocket.uri}')
		private String webSocketUri;
		private final CountDownLatch latch = new CountDownLatch(1);
		private final AtomicReference<String> messagePayload = new AtomicReference<>();
		@Override
		public void run(String... args) throws Exception {
			logger.info('Waiting for response: latch=' + this.latch.getCount());
			if (this.latch.await(10, TimeUnit.SECONDS)) {
				logger.info('Got response: ' + this.messagePayload.get());
			}
			else {
				logger.info('Response not received: latch=' + this.latch.getCount());
			}
		}
		@Bean
		WebSocketConnectionManager wsConnectionManager() {
			WebSocketConnectionManager manager = new WebSocketConnectionManager(client(), handler(), this.webSocketUri);
			manager.setAutoStartup(true);
			return manager;
		}
		@Bean
		StandardWebSocketClient client() {
			return new StandardWebSocketClient();
		}
		@Bean
		SimpleClientWebSocketHandler handler() {
			return new SimpleClientWebSocketHandler(greetingService(), this.latch, this.messagePayload);
		}
		@Bean
		GreetingService greetingService() {
			return new SimpleGreetingService();
		}
	}
}
/*
package smoketest.websocket.tomcat.snake;
class SnakeTimerTests {
	@Test
	void removeDysfunctionalSnakes() throws Exception {
		Snake snake = mock(Snake.class);
		willThrow(new IOException()).given(snake).sendMessage(anyString());
		SnakeTimer.addSnake(snake);
		SnakeTimer.broadcast('');
		assertThat(SnakeTimer.getSnakes()).isEmpty();
	}
}
/*
package smoketest.websocket.tomcat.reverse;
@ServerEndpoint('/reverse')
public class ReverseWebSocketEndpoint {
	@OnMessage
	public void handleMessage(Session session, String message) throws IOException {
		session.getBasicRemote().sendText('Reversed: ' + new StringBuilder(message).reverse());
	}
}
/*
package smoketest.websocket.tomcat.echo;
public interface EchoService {
	String getMessage(String message);
}
/*
package smoketest.websocket.tomcat.echo;
/**
public class EchoWebSocketHandler extends TextWebSocketHandler {
	private static final Log logger = LogFactory.getLog(EchoWebSocketHandler.class);
	private final EchoService echoService;
	public EchoWebSocketHandler(EchoService echoService) {
		this.echoService = echoService;
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) {
		logger.debug('Opened new session in instance ' + this);
	}
	@Override
	public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		String echoMessage = this.echoService.getMessage(message.getPayload());
		logger.debug(echoMessage);
		session.sendMessage(new TextMessage(echoMessage));
	}
	@Override
	public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
		session.close(CloseStatus.SERVER_ERROR);
	}
}
/*
package smoketest.websocket.tomcat.echo;
public class DefaultEchoService implements EchoService {
	private final String echoFormat;
	public DefaultEchoService(String echoFormat) {
		this.echoFormat = (echoFormat != null) ? echoFormat : '%s';
	}
	@Override
	public String getMessage(String message) {
		return String.format(this.echoFormat, message);
	}
}
/*
package smoketest.websocket.tomcat.client;
public class SimpleGreetingService implements GreetingService {
	@Override
	public String getGreeting() {
		return 'Hello world!';
	}
}
/*
package smoketest.websocket.tomcat.client;
public interface GreetingService {
	String getGreeting();
}
/*
package smoketest.websocket.tomcat.client;
public class SimpleClientWebSocketHandler extends TextWebSocketHandler {
	protected Log logger = LogFactory.getLog(SimpleClientWebSocketHandler.class);
	private final GreetingService greetingService;
	private final CountDownLatch latch;
	private final AtomicReference<String> messagePayload;
	public SimpleClientWebSocketHandler(GreetingService greetingService, CountDownLatch latch,
			AtomicReference<String> message) {
		this.greetingService = greetingService;
		this.latch = latch;
		this.messagePayload = message;
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		TextMessage message = new TextMessage(this.greetingService.getGreeting());
		session.sendMessage(message);
	}
	@Override
	public void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		this.logger.info('Received: ' + message + ' (' + this.latch.getCount() + ')');
		session.close();
		this.messagePayload.set(message.getPayload());
		this.latch.countDown();
	}
}
/*
package smoketest.websocket.tomcat.snake;
public class Snake {
	private static final int DEFAULT_LENGTH = 5;
	private final Deque<Location> tail = new ArrayDeque<>();
	private final Object monitor = new Object();
	private final int id;
	private final WebSocketSession session;
	private final String hexColor;
	private Direction direction;
	private int length = DEFAULT_LENGTH;
	private Location head;
	public Snake(int id, WebSocketSession session) {
		this.id = id;
		this.session = session;
		this.hexColor = SnakeUtils.getRandomHexColor();
		resetState();
	}
	private void resetState() {
		this.direction = Direction.NONE;
		this.head = SnakeUtils.getRandomLocation();
		this.tail.clear();
		this.length = DEFAULT_LENGTH;
	}
	private void kill() throws Exception {
		synchronized (this.monitor) {
			resetState();
			sendMessage('{"type": "dead"}');
		}
	}
	private void reward() throws Exception {
		synchronized (this.monitor) {
			this.length++;
			sendMessage('{"type": "kill"}');
		}
	}
	protected void sendMessage(String msg) throws Exception {
		this.session.sendMessage(new TextMessage(msg));
	}
	public void update(Collection<Snake> snakes) throws Exception {
		synchronized (this.monitor) {
			Location nextLocation = this.head.getAdjacentLocation(this.direction);
			if (nextLocation.x >= SnakeUtils.PLAYFIELD_WIDTH) {
				nextLocation.x = 0;
			}
			if (nextLocation.y >= SnakeUtils.PLAYFIELD_HEIGHT) {
				nextLocation.y = 0;
			}
			if (nextLocation.x < 0) {
				nextLocation.x = SnakeUtils.PLAYFIELD_WIDTH;
			}
			if (nextLocation.y < 0) {
				nextLocation.y = SnakeUtils.PLAYFIELD_HEIGHT;
			}
			if (this.direction != Direction.NONE) {
				this.tail.addFirst(this.head);
				if (this.tail.size() > this.length) {
					this.tail.removeLast();
				}
				this.head = nextLocation;
			}
			handleCollisions(snakes);
		}
	}
	private void handleCollisions(Collection<Snake> snakes) throws Exception {
		for (Snake snake : snakes) {
			boolean headCollision = this.id != snake.id && snake.getHead().equals(this.head);
			boolean tailCollision = snake.getTail().contains(this.head);
			if (headCollision || tailCollision) {
				kill();
				if (this.id != snake.id) {
					snake.reward();
				}
			}
		}
	}
	public Location getHead() {
		synchronized (this.monitor) {
			return this.head;
		}
	}
	public Collection<Location> getTail() {
		synchronized (this.monitor) {
			return this.tail;
		}
	}
	public void setDirection(Direction direction) {
		synchronized (this.monitor) {
			this.direction = direction;
		}
	}
	public String getLocationsJson() {
		synchronized (this.monitor) {
			StringBuilder sb = new StringBuilder();
			sb.append(String.format('{x: %d, y: %d}', this.head.x, this.head.y));
			for (Location location : this.tail) {
				sb.append(",");
				sb.append(String.format('{x: %d, y: %d}', location.x, location.y));
			}
			return String.format('{"id":%d,"body":[%s]}', this.id, sb);
		}
	}
	public int getId() {
		return this.id;
	}
	public String getHexColor() {
		return this.hexColor;
	}
}
/*
package smoketest.websocket.tomcat.snake;
public class Location {
	/**
	 * The X location.
	 */
	public int x;
	/**
	 * The Y location.
	 */
	public int y;
	public Location(int x, int y) {
		this.x = x;
		this.y = y;
	}
	public Location getAdjacentLocation(Direction direction) {
		return switch (direction) {
			case NORTH -> new Location(this.x, this.y - SnakeUtils.GRID_SIZE);
			case SOUTH -> new Location(this.x, this.y + SnakeUtils.GRID_SIZE);
			case EAST -> new Location(this.x + SnakeUtils.GRID_SIZE, this.y);
			case WEST -> new Location(this.x - SnakeUtils.GRID_SIZE, this.y);
			case NONE -> this;
		};
	}
	@Override
	public boolean equals(Object o) {
		if (this == o) {
			return true;
		}
		if (o == null || getClass() != o.getClass()) {
			return false;
		}
		Location location = (Location) o;
		if (this.x != location.x) {
			return false;
		}
		return this.y == location.y;
	}
	@Override
	public int hashCode() {
		int result = this.x;
		result = 31 * result + this.y;
		return result;
	}
}
/*
package smoketest.websocket.tomcat.snake;
/**
public final class SnakeTimer {
	private static final long TICK_DELAY = 100;
	private static final Object MONITOR = new Object();
	private static final Log logger = LogFactory.getLog(SnakeTimer.class);
	private static final ConcurrentHashMap<Integer, Snake> snakes = new ConcurrentHashMap<>();
	private static Timer gameTimer = null;
	private SnakeTimer() {
	}
	public static void addSnake(Snake snake) {
		synchronized (MONITOR) {
			if (snakes.isEmpty()) {
				startTimer();
			}
			snakes.put(snake.getId(), snake);
		}
	}
	public static Collection<Snake> getSnakes() {
		return Collections.unmodifiableCollection(snakes.values());
	}
	public static void removeSnake(Snake snake) {
		synchronized (MONITOR) {
			snakes.remove(snake.getId());
			if (snakes.isEmpty()) {
				stopTimer();
			}
		}
	}
	public static void tick() throws Exception {
		StringBuilder sb = new StringBuilder();
		for (Iterator<Snake> iterator = SnakeTimer.getSnakes().iterator(); iterator.hasNext();) {
			Snake snake = iterator.next();
			snake.update(SnakeTimer.getSnakes());
			sb.append(snake.getLocationsJson());
			if (iterator.hasNext()) {
				sb.append(",");
			}
		}
		broadcast(String.format('{"type": "update", "data" : [%s]}', sb));
	}
	public static void broadcast(String message) {
		Collection<Snake> snakes = new CopyOnWriteArrayList<>(SnakeTimer.getSnakes());
		for (Snake snake : snakes) {
			try {
				snake.sendMessage(message);
			}
			catch (Throwable ex) {
				// if Snake#sendMessage fails the client is removed
				removeSnake(snake);
			}
		}
	}
	public static void startTimer() {
		gameTimer = new Timer(SnakeTimer.class.getSimpleName() + ' Timer');
		gameTimer.scheduleAtFixedRate(new TimerTask() {
			@Override
			public void run() {
				try {
					tick();
				}
				catch (Throwable ex) {
					logger.error('Caught to prevent timer from shutting down', ex);
				}
			}
		}, TICK_DELAY, TICK_DELAY);
	}
	public static void stopTimer() {
		if (gameTimer != null) {
			gameTimer.cancel();
		}
	}
}
/*
package smoketest.websocket.tomcat.snake;
public enum Direction {
	NONE, NORTH, SOUTH, EAST, WEST
}
/*
package smoketest.websocket.tomcat.snake;
public final class SnakeUtils {
	/**
	 * The width of the playfield.
	 */
	public static final int PLAYFIELD_WIDTH = 640;
	/**
	 * The height of the playfield.
	 */
	public static final int PLAYFIELD_HEIGHT = 480;
	/**
	 * The grid size.
	 */
	public static final int GRID_SIZE = 10;
	private static final Random random = new Random();
	private SnakeUtils() {
	}
	public static String getRandomHexColor() {
		float hue = random.nextFloat();
		// sat between 0.1 and 0.3
		float saturation = (random.nextInt(2000) + 1000) / 10000f;
		float luminance = 0.9f;
		Color color = Color.getHSBColor(hue, saturation, luminance);
		return "#" + Integer.toHexString((color.getRGB() & 0xffffff) | 0x1000000).substring(1);
	}
	public static Location getRandomLocation() {
		int x = roundByGridSize(random.nextInt(PLAYFIELD_WIDTH));
		int y = roundByGridSize(random.nextInt(PLAYFIELD_HEIGHT));
		return new Location(x, y);
	}
	private static int roundByGridSize(int value) {
		value = value + (GRID_SIZE / 2);
		value = value / GRID_SIZE;
		value = value * GRID_SIZE;
		return value;
	}
}
/*
package smoketest.websocket.tomcat.snake;
public class SnakeWebSocketHandler extends TextWebSocketHandler {
	private static final AtomicInteger snakeIds = new AtomicInteger();
	private static final Random random = new Random();
	private final int id;
	private Snake snake;
	public static String getRandomHexColor() {
		float hue = random.nextFloat();
		// sat between 0.1 and 0.3
		float saturation = (random.nextInt(2000) + 1000) / 10000f;
		float luminance = 0.9f;
		Color color = Color.getHSBColor(hue, saturation, luminance);
		return "#" + Integer.toHexString((color.getRGB() & 0xffffff) | 0x1000000).substring(1);
	}
	public static Location getRandomLocation() {
		int x = roundByGridSize(random.nextInt(SnakeUtils.PLAYFIELD_WIDTH));
		int y = roundByGridSize(random.nextInt(SnakeUtils.PLAYFIELD_HEIGHT));
		return new Location(x, y);
	}
	private static int roundByGridSize(int value) {
		value = value + (SnakeUtils.GRID_SIZE / 2);
		value = value / SnakeUtils.GRID_SIZE;
		value = value * SnakeUtils.GRID_SIZE;
		return value;
	}
	public SnakeWebSocketHandler() {
		this.id = snakeIds.getAndIncrement();
	}
	@Override
	public void afterConnectionEstablished(WebSocketSession session) throws Exception {
		this.snake = new Snake(this.id, session);
		SnakeTimer.addSnake(this.snake);
		StringBuilder sb = new StringBuilder();
		for (Iterator<Snake> iterator = SnakeTimer.getSnakes().iterator(); iterator.hasNext();) {
			Snake snake = iterator.next();
			sb.append(String.format('{id: %d, color: "%s"}', snake.getId(), snake.getHexColor()));
			if (iterator.hasNext()) {
				sb.append(",");
			}
		}
		SnakeTimer.broadcast(String.format('{"type": "join","data":[%s]}', sb));
	}
	@Override
	protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {
		String payload = message.getPayload();
		switch (payload) {
			case 'west' -> this.snake.setDirection(Direction.WEST);
			case 'north' -> this.snake.setDirection(Direction.NORTH);
			case 'east' -> this.snake.setDirection(Direction.EAST);
			case 'south' -> this.snake.setDirection(Direction.SOUTH);
		}
	}
	@Override
	public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
		SnakeTimer.removeSnake(this.snake);
		SnakeTimer.broadcast(String.format('{"type": "leave", "id": %d}', this.id));
	}
}
/*
package smoketest.websocket.tomcat;
@Configuration(proxyBeanMethods = false)
@EnableAutoConfiguration
@EnableWebSocket
public class SampleTomcatWebSocketApplication extends SpringBootServletInitializer implements WebSocketConfigurer {
	@Override
	public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
		registry.addHandler(echoWebSocketHandler(), '/echo').withSockJS();
		registry.addHandler(snakeWebSocketHandler(), '/snake').withSockJS();
	}
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleTomcatWebSocketApplication.class);
	}
	@Bean
	public EchoService echoService() {
		return new DefaultEchoService('Did you say \'%s\'?');
	}
	@Bean
	public GreetingService greetingService() {
		return new SimpleGreetingService();
	}
	@Bean
	public WebSocketHandler echoWebSocketHandler() {
		return new EchoWebSocketHandler(echoService());
	}
	@Bean
	public WebSocketHandler snakeWebSocketHandler() {
		return new PerConnectionWebSocketHandler(SnakeWebSocketHandler.class);
	}
	@Bean
	public ReverseWebSocketEndpoint reverseWebSocketEndpoint() {
		return new ReverseWebSocketEndpoint();
	}
	@Bean
	public ServerEndpointExporter serverEndpointExporter() {
		return new ServerEndpointExporter();
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleTomcatWebSocketApplication.class, args);
	}
}
/*
package smoketest.logback;
@ExtendWith(OutputCaptureExtension.class)
class SampleLogbackApplicationTests {
	@Test
	void testLoadedCustomLogbackConfig(CapturedOutput output) {
		SampleLogbackApplication.main(new String[0]);
		assertThat(output).contains('Sample Debug Message').doesNotContain('Sample Trace Message');
	}
	@Test
	void testProfile(CapturedOutput output) {
		SampleLogbackApplication.main(new String[] { '--spring.profiles.active=staging' });
		assertThat(output).contains('Sample Debug Message').contains('Sample Trace Message');
	}
}
/*
package smoketest.logback;
@SpringBootApplication
public class SampleLogbackApplication {
	private static final Logger logger = LoggerFactory.getLogger(SampleLogbackApplication.class);
	@PostConstruct
	public void logSomething() {
		logger.debug('Sample Debug Message');
		logger.trace('Sample Trace Message');
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleLogbackApplication.class, args).close();
	}
}
/*
package smoketest.jpa;
/**
@SpringBootTest
@AutoConfigureMockMvc
class SampleJpaApplicationTests {
	@Autowired
	private MockMvcTester mvc;
	@Test
	void testHome() throws Exception {
		assertThat(this.mvc.get().uri('/')).hasStatusOk().matches(xpath('//tbody/tr').nodeCount(4));
	}
}
/*
package smoketest.jpa.repository;
/**
@SpringBootTest
@Transactional
class JpaTagRepositoryIntegrationTests {
	@Autowired
	JpaTagRepository repository;
	@Test
	void findsAllTags() {
		List<Tag> tags = this.repository.findAll();
		assertThat(tags).hasSize(3);
		for (Tag tag : tags) {
			assertThat(tag.getNotes()).isNotEmpty();
		}
	}
}
/*
package smoketest.jpa.repository;
/**
@SpringBootTest
@Transactional
class JpaNoteRepositoryIntegrationTests {
	@Autowired
	JpaNoteRepository repository;
	@Test
	void findsAllNotes() {
		List<Note> notes = this.repository.findAll();
		assertThat(notes).hasSize(4);
		for (Note note : notes) {
			assertThat(note.getTags()).isNotEmpty();
		}
	}
}
/*
package smoketest.jpa.web;
@Controller
public class IndexController {
	@Autowired
	private NoteRepository noteRepository;
	@GetMapping('/')
	@Transactional(readOnly = true)
	public ModelAndView index() {
		List<Note> notes = this.noteRepository.findAll();
		ModelAndView modelAndView = new ModelAndView('index');
		modelAndView.addObject('notes', notes);
		return modelAndView;
	}
}
/*
package smoketest.jpa.domain;
@Entity
public class Tag {
	@Id
	@SequenceGenerator(name = 'tag_generator', sequenceName = 'tag_sequence', initialValue = 4)
	@GeneratedValue(generator = 'tag_generator')
	private long id;
	private String name;
	@ManyToMany(mappedBy = 'tags')
	private List<Note> notes;
	public long getId() {
		return this.id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public List<Note> getNotes() {
		return this.notes;
	}
	public void setNotes(List<Note> notes) {
		this.notes = notes;
	}
}
/*
package smoketest.jpa.domain;
@Entity
public class Note {
	@Id
	@SequenceGenerator(name = 'note_generator', sequenceName = 'note_sequence', initialValue = 5)
	@GeneratedValue(generator = 'note_generator')
	private long id;
	private String title;
	private String body;
	@ManyToMany
	private List<Tag> tags;
	public long getId() {
		return this.id;
	}
	public void setId(long id) {
		this.id = id;
	}
	public String getTitle() {
		return this.title;
	}
	public void setTitle(String title) {
		this.title = title;
	}
	public String getBody() {
		return this.body;
	}
	public void setBody(String body) {
		this.body = body;
	}
	public List<Tag> getTags() {
		return this.tags;
	}
	public void setTags(List<Tag> tags) {
		this.tags = tags;
	}
}
/*
package smoketest.jpa.repository;
@Repository
class JpaTagRepository implements TagRepository {
	@PersistenceContext
	private EntityManager entityManager;
	@Override
	public List<Tag> findAll() {
		return this.entityManager.createQuery('SELECT t FROM Tag t', Tag.class).getResultList();
	}
}
/*
package smoketest.jpa.repository;
@Repository
class JpaNoteRepository implements NoteRepository {
	@PersistenceContext
	private EntityManager entityManager;
	@Override
	public List<Note> findAll() {
		return this.entityManager.createQuery('SELECT n FROM Note n', Note.class).getResultList();
	}
}
/*
package smoketest.jpa.repository;
public interface NoteRepository {
	List<Note> findAll();
}
/*
package smoketest.jpa.repository;
public interface TagRepository {
	List<Tag> findAll();
}
/*
package smoketest.jpa;
@SpringBootApplication
public class SampleJpaApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleJpaApplication.class, args);
	}
}
/*
package smoketest.web.secure.custom;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebSecureCustomApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@LocalServerPort
	private int port;
	@Test
	void testHome() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.exchange('/', HttpMethod.GET, new HttpEntity<Void>(headers),
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation().toString()).endsWith(this.port + '/login');
	}
	@Test
	void testLoginPage() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.GET,
				new HttpEntity<Void>(headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('<title>Login</title>');
	}
	@Test
	void testLogin() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Collections.singletonList(MediaType.TEXT_HTML));
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
		MultiValueMap<String, String> form = new LinkedMultiValueMap<>();
		form.set('username', 'user');
		form.set('password', 'password');
		ResponseEntity<String> entity = this.restTemplate.exchange('/login', HttpMethod.POST,
				new HttpEntity<>(form, headers), String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.FOUND);
		assertThat(entity.getHeaders().getLocation().toString()).endsWith(this.port + '/');
	}
}
/*
package smoketest.web.secure.custom;
@SpringBootApplication
public class SampleWebSecureCustomApplication implements WebMvcConfigurer {
	@Override
	public void addViewControllers(ViewControllerRegistry registry) {
		registry.addViewController('/').setViewName('home');
		registry.addViewController('/login').setViewName('login');
	}
	public static void main(String[] args) {
		new SpringApplicationBuilder(SampleWebSecureCustomApplication.class).run(args);
	}
	@Configuration(proxyBeanMethods = false)
	protected static class ApplicationSecurity {
		@Bean
		SecurityFilterChain configure(HttpSecurity http) throws Exception {
			http.csrf(CsrfConfigurer::disable);
			http.authorizeHttpRequests((requests) -> {
				requests.dispatcherTypeMatchers(DispatcherType.FORWARD).permitAll();
				requests.anyRequest().fullyAuthenticated();
			});
			http.formLogin((form) -> form.loginPage('/login').permitAll());
			return http.build();
		}
	}
}
/*
package smoketest.web.staticcontent;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebStaticApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('<title>Static');
	}
	@Test
	void testCss() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/webjars/bootstrap/3.0.3/css/bootstrap.min.css',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('body');
		assertThat(entity.getHeaders().getContentType()).isEqualTo(MediaType.valueOf('text/css'));
	}
}
/*
package smoketest.web.staticcontent;
@SpringBootApplication
public class SampleWebStaticApplication extends SpringBootServletInitializer {
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(SampleWebStaticApplication.class);
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleWebStaticApplication.class, args);
	}
}
/*
package smoketest.freemarker;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class SampleWebFreeMarkerApplicationTests {
	@Autowired
	private TestRestTemplate testRestTemplate;
	@Test
	void testFreeMarkerTemplate() {
		ResponseEntity<String> entity = this.testRestTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).contains('Hello, Andy');
	}
	@Test
	void testFreeMarkerErrorTemplate() {
		HttpHeaders headers = new HttpHeaders();
		headers.setAccept(Arrays.asList(MediaType.TEXT_HTML));
		HttpEntity<String> requestEntity = new HttpEntity<>(headers);
		ResponseEntity<String> responseEntity = this.testRestTemplate.exchange('/does-not-exist', HttpMethod.GET,
				requestEntity, String.class);
		assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		assertThat(responseEntity.getBody()).contains('Something went wrong: 404 Not Found');
	}
}
/*
package smoketest.freemarker;
@SpringBootApplication
public class SampleWebFreeMarkerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleWebFreeMarkerApplication.class, args);
	}
}
/*
package smoketest.freemarker;
@Controller
public class WelcomeController {
	@Value('${application.message:Hello World}')
	private String message = 'Hello World';
	@GetMapping('/')
	public String welcome(Map<String, Object> model) {
		model.put('time', new Date());
		model.put('message', this.message);
		return 'welcome';
	}
}
/*
package smoketest.testng;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class SampleTestNGApplicationTests extends AbstractTestNGSpringContextTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	public void testHome() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('Hello World');
	}
}
/*
package smoketest.testng.web;
@Controller
public class SampleController {
	@Autowired
	private HelloWorldService helloWorldService;
	@GetMapping('/')
	@ResponseBody
	public String helloWorld() {
		return this.helloWorldService.getHelloMessage();
	}
}
/*
package smoketest.testng.service;
@Component
public class HelloWorldService {
	@Value('${test.name:World}')
	private String name;
	public String getHelloMessage() {
		return 'Hello ' + this.name;
	}
}
/*
package smoketest.testng;
@SpringBootApplication
public class SampleTestNGApplication {
	private static final Log logger = LogFactory.getLog(SampleTestNGApplication.class);
	@Bean
	protected ServletContextListener listener() {
		return new ServletContextListener() {
			@Override
			public void contextInitialized(ServletContextEvent sce) {
				logger.info('ServletContext initialized');
			}
			@Override
			public void contextDestroyed(ServletContextEvent sce) {
				logger.info('ServletContext destroyed');
			}
		};
	}
	public static void main(String[] args) {
		SpringApplication.run(SampleTestNGApplication.class, args);
	}
}
/*
package smoketest.testnomockito;
/**
@ExtendWith(SpringExtension.class)
class SampleTestNoMockitoApplicationTests {
	// gh-7065
	@Autowired
	private ApplicationContext context;
	@Test
	void contextLoads() {
		assertThat(this.context).isNotNull();
	}
}
/*
package smoketest.testnomockito;
@SpringBootApplication
public class SampleTestNoMockitoApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleTestNoMockitoApplication.class);
	}
}
/*
package smoketest.batch;
@ExtendWith(OutputCaptureExtension.class)
class SampleBatchApplicationTests {
	@Test
	void testDefaultSettings(CapturedOutput output) {
		assertThat(SpringApplication.exit(SpringApplication.run(SampleBatchApplication.class))).isZero();
		assertThat(output).contains('completed with the following parameters');
	}
}
/*
package smoketest.batch;
@SpringBootApplication
public class SampleBatchApplication {
	@Bean
	Tasklet tasklet() {
		return (contribution, context) -> RepeatStatus.FINISHED;
	}
	@Bean
	Job job(JobRepository jobRepository, Step step) {
		return new JobBuilder('job', jobRepository).start(step).build();
	}
	@Bean
	Step step1(JobRepository jobRepository, Tasklet tasklet, PlatformTransactionManager transactionManager) {
		return new StepBuilder('step1', jobRepository).tasklet(tasklet, transactionManager).build();
	}
	public static void main(String[] args) {
		// System.exit is common for Batch applications since the exit code can be used to
		// drive a workflow
		System.exit(SpringApplication.exit(SpringApplication.run(SampleBatchApplication.class, args)));
	}
}
/*
package smoketest.webapplicationtype;
/**
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
class WebEnvironmentNoneOverridesWebApplicationTypeTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void contextIsPlain() {
		assertThat(this.context).isNotInstanceOf(ReactiveWebApplicationContext.class);
		assertThat(this.context).isNotInstanceOf(WebApplicationContext.class);
	}
}
/*
package smoketest.webapplicationtype;
/**
@SpringBootTest
class SampleWebApplicationTypeApplicationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void contextIsReactive() {
		assertThat(this.context).isInstanceOf(ReactiveWebApplicationContext.class);
	}
}
/*
package smoketest.webapplicationtype;
/**
@SpringBootTest(properties = 'spring.main.web-application-type=servlet')
class OverriddenWebApplicationTypeApplicationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void contextIsServlet() {
		assertThat(this.context).isInstanceOf(WebApplicationContext.class);
	}
}
/*
package smoketest.webapplicationtype;
@SpringBootApplication
public class SampleWebApplicationTypeApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleWebApplicationTypeApplication.class, args);
	}
}
/*
package org.springframework.boot.configurationprocessor.tests;
/**
class ConfigurationProcessorIntegrationTests {
	private static ConfigurationMetadataRepository repository;
	@BeforeAll
	static void readMetadata() throws IOException {
		repository = ConfigurationMetadataRepositoryJsonBuilder.create(getResource().openStream()).build();
	}
	private static URL getResource() throws IOException {
		ClassLoader classLoader = ConfigurationProcessorIntegrationTests.class.getClassLoader();
		List<URL> urls = new ArrayList<>();
		CollectionUtils.toIterator(classLoader.getResources('META-INF/spring-configuration-metadata.json'))
			.forEachRemaining(urls::add);
		for (URL url : urls) {
			if (url.toString().contains('spring-boot-configuration-processor-tests')) {
				return url;
			}
		}
		throw new IllegalStateException('Unable to find correct configuration-metadata resource from ' + urls);
	}
	@Test
	void extractTypeFromAnnotatedGetter() {
		ConfigurationMetadataProperty property = repository.getAllProperties().get('annotated.name');
		assertThat(property).isNotNull();
		assertThat(property.getType()).isEqualTo('java.lang.String');
	}
}
/*
package sample;
/**
@ConfigurationProperties('annotated')
public class AnnotatedSample {
	/**
	 * A valid name.
	 */
	private String name;
	@Valid
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
/**
package sample;
/*
package org.springframework.boot.loaderapp;
@SpringBootApplication
public class LoaderSignedJarTestApplication {
	public static void main(String[] args) throws Exception {
		Security.addProvider(new BouncyCastleProvider());
		Cipher.getInstance('AES/CBC/PKCS5Padding','BC');
		System.out.println('Legion of the Bouncy Castle');
		SpringApplication.run(LoaderSignedJarTestApplication.class, args);
	}
}
/*
package org.springframework.boot.loader;
/**
@DisabledIfDockerUnavailable
class LoaderIntegrationTests {
	private final ToStringConsumer output = new ToStringConsumer();
	@ParameterizedTest
	@MethodSource('javaRuntimes')
	void runJar(JavaRuntime javaRuntime) {
		try (GenericContainer<?> container = createContainer(javaRuntime, 'spring-boot-loader-tests-app', null)) {
			container.start();
			System.out.println(this.output.toUtf8String());
			assertThat(this.output.toUtf8String()).contains('>>>>> 287649 BYTES from')
				.contains('>>>>> gh-7161 [/gh-7161/example.txt]')
				.doesNotContain('WARNING:')
				.doesNotContain('illegal')
				.doesNotContain('jar written to temp');
		}
	}
	@ParameterizedTest
	@MethodSource('javaRuntimes')
	void runSignedJar(JavaRuntime javaRuntime) {
		try (GenericContainer<?> container = createContainer(javaRuntime, 'spring-boot-loader-tests-signed-jar',
				null)) {
			container.start();
			System.out.println(this.output.toUtf8String());
			assertThat(this.output.toUtf8String()).contains('Legion of the Bouncy Castle');
		}
	}
	@ParameterizedTest
	@MethodSource('javaRuntimes')
	void runSignedJarWhenUnpack(JavaRuntime javaRuntime) {
		try (GenericContainer<?> container = createContainer(javaRuntime, 'spring-boot-loader-tests-signed-jar',
				'unpack')) {
			container.start();
			System.out.println(this.output.toUtf8String());
			assertThat(this.output.toUtf8String()).contains('Legion of the Bouncy Castle');
		}
	}
	private GenericContainer<?> createContainer(JavaRuntime javaRuntime, String name, String classifier) {
		return javaRuntime.getContainer()
			.withLogConsumer(this.output)
			.withCopyFileToContainer(findApplication(name, classifier), '/app.jar')
			.withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofMinutes(5)))
			.withCommand('java', '-jar', 'app.jar');
	}
	private MountableFile findApplication(String name, String classifier) {
		return MountableFile.forHostPath(findJarFile(name, classifier).toPath());
	}
	private File findJarFile(String name, String classifier) {
		classifier = (classifier != null) ? '-' + classifier : '';
		String path = String.format('build/%1$s/build/libs/%1$s%2$s.jar', name, classifier);
		File jar = new File(path);
		Assert.state(jar.isFile(), () -> 'Could not find ' + path + '. Have you built it?');
		return jar;
	}
	static Stream<JavaRuntime> javaRuntimes() {
		List<JavaRuntime> javaRuntimes = new ArrayList<>();
		javaRuntimes.add(JavaRuntime.openJdk(JavaVersion.SEVENTEEN));
		javaRuntimes.add(JavaRuntime.openJdk(JavaVersion.TWENTY_ONE));
		javaRuntimes.add(JavaRuntime.oracleJdk17());
		javaRuntimes.add(JavaRuntime.openJdk(JavaVersion.TWENTY_TWO));
		javaRuntimes.add(JavaRuntime.openJdkEarlyAccess(JavaVersion.TWENTY_THREE));
		return javaRuntimes.stream().filter(JavaRuntime::isCompatible);
	}
	static final class JavaRuntime {
		private final String name;
		private final JavaVersion version;
		private final Supplier<GenericContainer<?>> container;
		private JavaRuntime(String name, JavaVersion version, Supplier<GenericContainer<?>> container) {
			this.name = name;
			this.version = version;
			this.container = container;
		}
		private boolean isCompatible() {
			return this.version.isEqualOrNewerThan(JavaVersion.getJavaVersion());
		}
		GenericContainer<?> getContainer() {
			return this.container.get();
		}
		@Override
		public String toString() {
			return this.name;
		}
		static JavaRuntime openJdkEarlyAccess(JavaVersion version) {
			String imageVersion = version.toString();
			DockerImageName image = DockerImageName.parse('openjdk:%s-ea-jdk'.formatted(imageVersion));
			return new JavaRuntime('OpenJDK Early Access ' + imageVersion, version,
					() -> new GenericContainer<>(image));
		}
		static JavaRuntime openJdk(JavaVersion version) {
			String imageVersion = version.toString();
			DockerImageName image = DockerImageName.parse('bellsoft/liberica-openjdk-debian:' + imageVersion);
			return new JavaRuntime('OpenJDK ' + imageVersion, version, () -> new GenericContainer<>(image));
		}
		static JavaRuntime oracleJdk17() {
			ImageFromDockerfile image = new ImageFromDockerfile('spring-boot-loader/oracle-jdk');
			image.withFileFromFile('Dockerfile', new File('src/dockerTest/resources/conf/oracle-jdk-17/Dockerfile'));
			for (File file : new File('build/downloads/jdk/oracle').listFiles()) {
				image.withFileFromFile('downloads/' + file.getName(), file);
			}
			return new JavaRuntime('Oracle JDK 17', JavaVersion.SEVENTEEN, () -> new GenericContainer<>(image));
		}
	}
}
/*
package org.springframework.boot.loaderapp;
@SpringBootApplication
public class LoaderTestApplication {
	@Bean
	public CommandLineRunner commandLineRunner(ServletContext servletContext) {
		return (args) -> {
			File temp = new File(System.getProperty('java.io.tmpdir'));
			URL resourceUrl = servletContext.getResource('webjars/jquery/3.5.0/jquery.js');
			JarURLConnection connection = (JarURLConnection) resourceUrl.openConnection();
			String jarName = connection.getJarFile().getName();
			System.out.println('>>>>> jar file ' + jarName);
			if(jarName.contains(temp.getAbsolutePath())) {
				System.out.println('>>>>> jar written to temp');
			}
			byte[] resourceContent = FileCopyUtils.copyToByteArray(resourceUrl.openStream());
			URL directUrl = new URL(resourceUrl.toExternalForm());
			byte[] directContent = FileCopyUtils.copyToByteArray(directUrl.openStream());
			String message = (!Arrays.equals(resourceContent, directContent)) ? 'NO MATCH'
					: directContent.length + ' BYTES';
			System.out.println('>>>>> ' + message + ' from ' + resourceUrl);
			testGh7161();
		};
	}
	private void testGh7161() {
		try {
			Resource resource = new ClassPathResource('gh-7161');
			Path path = Paths.get(resource.getURI());
			System.out.println('>>>>> gh-7161 ' + Files.list(path).toList());
		} catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	public static void main(String[] args) {
		SpringApplication.run(LoaderTestApplication.class, args).close();
	}
}
/*
package org.springframework.boot.sni.server;
@SpringBootApplication
public class SniClientApplication {
	public static void main(String[] args) {
		new SpringApplicationBuilder(SniClientApplication.class)
				.web(WebApplicationType.NONE).run(args);
	}
	@Bean
	public RestClient restClient(RestClient.Builder restClientBuilder, RestClientSsl ssl) {
		return restClientBuilder.apply(ssl.fromBundle('server')).build();
	}
	@Bean
	public CommandLineRunner commandLineRunner(RestClient client) {
		return ((args) -> {
			for (String hostname : args) {
				callServer(client, hostname);
				callActuator(client, hostname);
			}
		});
	}
	private static void callServer(RestClient client, String hostname) {
		String url = 'https://' + hostname + ':8443/';
		System.out.println('>>>>>> Calling server at "' + url + '"');
		try {
			ResponseEntity<String> response = client.get().uri(url).retrieve().toEntity(String.class);
			System.out.println('>>>>>> Server response status code is "' + response.getStatusCode() + '"');
			System.out.println('>>>>>> Server response body is "' + response + '"');
		} catch (Exception ex) {
			System.out.println('>>>>>> Exception thrown calling server at "' + url + '": ' + ex.getMessage());
			ex.printStackTrace();
		}
	}
	private static void callActuator(RestClient client, String hostname) {
		String url = 'https://' + hostname + ':8444/actuator/health';
		System.out.println('>>>>>> Calling server actuator at "' + url + '"');
		try {
			ResponseEntity<String> response = client.get().uri(url).retrieve().toEntity(String.class);
			System.out.println('>>>>>> Server actuator response status code is "' + response.getStatusCode() + '"');
			System.out.println('>>>>>> Server actuator response body is "' + response + '"');
		} catch (Exception ex) {
			System.out.println('>>>>>> Exception thrown calling server actuator at "' + url + '": ' + ex.getMessage());
			ex.printStackTrace();
		}
	}
}
/*
package org.springframework.boot.sni.server;
@SpringBootApplication
public class SniServerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SniServerApplication.class, args);
	}
}
/*
package org.springframework.boot.sni.server;
@RestController
public class HelloController {
	@GetMapping
	public String hello(HttpServletRequest request) {
		return 'Hello from ' + request.getRequestURL();
	}
}/*
package org.springframework.boot.sni;
/**
@Testcontainers(disabledWithoutDocker = true)
class SniIntegrationTests {
	private static final Map<String, String> SERVER_START_MESSAGES = Map.ofEntries(Map.entry('netty', 'Netty started'),
			Map.entry('tomcat', 'Tomcat initialized'), Map.entry('undertow', 'starting server: Undertow'));
	public static final String PRIMARY_SERVER_NAME = 'hello.example.com';
	public static final String ALT_SERVER_NAME = 'hello-alt.example.com';
	private static final Integer SERVER_PORT = 8443;
	private static final Network SHARED_NETWORK = Network.newNetwork();
	@ParameterizedTest
	@CsvSource({ 'reactive,netty', 'reactive,tomcat', 'servlet,tomcat', 'reactive,undertow', 'servlet,undertow' })
	void home(String webStack, String server) {
		try (ApplicationContainer serverContainer = new ServerApplicationContainer(webStack, server)) {
			serverContainer.start();
			try {
				Awaitility.await().atMost(Duration.ofSeconds(60)).until(serverContainer::isRunning);
			}
			catch (ConditionTimeoutException ex) {
				System.out.println(serverContainer.getLogs());
				throw ex;
			}
			String serverLogs = serverContainer.getLogs();
			assertThat(serverLogs).contains(SERVER_START_MESSAGES.get(server));
			try (ApplicationContainer clientContainer = new ClientApplicationContainer()) {
				clientContainer.start();
				Awaitility.await().atMost(Duration.ofSeconds(60)).until(() -> !clientContainer.isRunning());
				String clientLogs = clientContainer.getLogs();
				assertServerCalledWithName(clientLogs, PRIMARY_SERVER_NAME);
				assertServerCalledWithName(clientLogs, ALT_SERVER_NAME);
				clientContainer.stop();
			}
			serverContainer.stop();
		}
	}
	private void assertServerCalledWithName(String clientLogs, String serverName) {
		assertThat(clientLogs).contains('Calling server at "https://' + serverName + ':8443/"')
			.contains('Hello from https://' + serverName + ':8443/');
		assertThat(clientLogs).contains('Calling server actuator at "https://' + serverName + ':8444/actuator/health"')
			.contains('{\'status\':\'UP\'}');
	}
	static final class ClientApplicationContainer extends ApplicationContainer {
		ClientApplicationContainer() {
			super('spring-boot-sni-client-app', '', PRIMARY_SERVER_NAME, ALT_SERVER_NAME);
		}
	}
	static final class ServerApplicationContainer extends ApplicationContainer {
		ServerApplicationContainer(String webStack, String server) {
			super('spring-boot-sni-' + webStack + '-app', '-' + server);
			withNetworkAliases(PRIMARY_SERVER_NAME, ALT_SERVER_NAME);
		}
	}
	static class ApplicationContainer extends GenericContainer<ApplicationContainer> {
		protected ApplicationContainer(String appName, String fileSuffix, String... entryPointArgs) {
			super(new ImageFromDockerfile().withFileFromFile('spring-boot.jar', findJarFile(appName, fileSuffix))
				.withDockerfileFromBuilder((builder) -> builder.from('eclipse-temurin:17-jre-jammy')
					.add('spring-boot.jar', '/spring-boot.jar')
					.entryPoint(buildEntryPoint(entryPointArgs))));
			withExposedPorts(SERVER_PORT);
			withStartupTimeout(Duration.ofMinutes(2));
			withStartupAttempts(3);
			withNetwork(SHARED_NETWORK);
			withNetworkMode(SHARED_NETWORK.getId());
		}
		private static File findJarFile(String appName, String fileSuffix) {
			String path = String.format('build/%1$s/build/libs/%1$s%2$s.jar', appName, fileSuffix);
			File jar = new File(path);
			Assert.state(jar.isFile(), () -> 'Could not find ' + path);
			return jar;
		}
		private static String buildEntryPoint(String... args) {
			StringBuilder builder = new StringBuilder().append('java').append(' -jar').append(' /spring-boot.jar');
			for (String arg : args) {
				builder.append(' ').append(arg);
			}
			return builder.toString();
		}
	}
}
/*
package org.springframework.boot.sni.server;
@SpringBootApplication
public class SniServerApplication {
	public static void main(String[] args) {
		SpringApplication.run(SniServerApplication.class, args);
	}
}
/*
package org.springframework.boot.sni.server;
@RestController
public class HelloController {
	@GetMapping
	public String hello(ServerHttpRequest request) {
		return 'Hello from ' + request.getURI();
	}
}/*
package org.springframework.boot.launchscript;
public class LaunchScriptTestApplication {
	public static void main(String[] args) throws LifecycleException {
		System.out.println('Starting ' + LaunchScriptTestApplication.class.getSimpleName() + ' (' + findSource() + ')');
		Tomcat tomcat = new Tomcat();
		tomcat.getConnector().setPort(getPort(args));
		Context context = tomcat.addContext(getContextPath(args), null);
		tomcat.addServlet(context.getPath(), 'test', new HttpServlet() {
			@Override
			protected void doGet(HttpServletRequest req, HttpServletResponse resp)
					throws ServletException, IOException {
				resp.getWriter().println('Launched');
			}
		});
		context.addServletMappingDecoded('/', 'test');
		tomcat.start();
	}
	private static URL findSource() {
		try {
			ProtectionDomain domain = LaunchScriptTestApplication.class.getProtectionDomain();
			CodeSource codeSource = (domain != null) ? domain.getCodeSource() : null;
			return (codeSource != null) ? codeSource.getLocation() : null;
		}
		catch (Exception ex) {
		}
		return null;
	}
	private static int getPort(String[] args) {
		String port = getProperty(args, 'server.port');
		return (port != null) ? Integer.parseInt(port) : 8080;
	}
	private static String getContextPath(String[] args) {
		String contextPath = getProperty(args, 'server.servlet.context-path');
		return (contextPath != null) ? contextPath : '';
	}
	private static String getProperty(String[] args, String property) {
		String value = System.getProperty(property);
		if (value != null) {
			return value;
		}
		String prefix = '--' + property + '=';
		for (String arg : args) {
			if (arg.startsWith(prefix)) {
				return arg.substring(prefix.length());
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.launchscript;
/**
@DisabledIfDockerUnavailable
class SysVinitLaunchScriptIntegrationTests extends AbstractLaunchScriptIntegrationTests {
	SysVinitLaunchScriptIntegrationTests() {
		super('init.d/');
	}
	static List<Object[]> parameters() {
		return filterParameters((file) -> !file.getName().contains('RedHat'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void statusWhenStopped(String os, String version) throws Exception {
		String output = doTest(os, version, 'status-when-stopped.sh');
		assertThat(output).contains('Status: 3');
		assertThat(output).has(coloredString(AnsiColor.RED, 'Not running'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void statusWhenStarted(String os, String version) throws Exception {
		String output = doTest(os, version, 'status-when-started.sh');
		assertThat(output).contains('Status: 0');
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Started [' + extractPid(output) + ']'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void statusWhenKilled(String os, String version) throws Exception {
		String output = doTest(os, version, 'status-when-killed.sh');
		assertThat(output).contains('Status: 1');
		assertThat(output)
			.has(coloredString(AnsiColor.RED, 'Not running (process ' + extractPid(output) + ' not found)'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void stopWhenStopped(String os, String version) throws Exception {
		String output = doTest(os, version, 'stop-when-stopped.sh');
		assertThat(output).contains('Status: 0');
		assertThat(output).has(coloredString(AnsiColor.YELLOW, 'Not running (pidfile not found)'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void forceStopWhenStopped(String os, String version) throws Exception {
		String output = doTest(os, version, 'force-stop-when-stopped.sh');
		assertThat(output).contains('Status: 0');
		assertThat(output).has(coloredString(AnsiColor.YELLOW, 'Not running (pidfile not found)'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void startWhenStarted(String os, String version) throws Exception {
		String output = doTest(os, version, 'start-when-started.sh');
		assertThat(output).contains('Status: 0');
		assertThat(output).has(coloredString(AnsiColor.YELLOW, 'Already running [' + extractPid(output) + ']'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void restartWhenStopped(String os, String version) throws Exception {
		String output = doTest(os, version, 'restart-when-stopped.sh');
		assertThat(output).contains('Status: 0');
		assertThat(output).has(coloredString(AnsiColor.YELLOW, 'Not running (pidfile not found)'));
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Started [' + extractPid(output) + ']'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void restartWhenStarted(String os, String version) throws Exception {
		String output = doTest(os, version, 'restart-when-started.sh');
		assertThat(output).contains('Status: 0');
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Started [' + extract('PID1', output) + ']'));
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Stopped [' + extract('PID1', output) + ']'));
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Started [' + extract('PID2', output) + ']'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void startWhenStopped(String os, String version) throws Exception {
		String output = doTest(os, version, 'start-when-stopped.sh');
		assertThat(output).contains('Status: 0');
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Started [' + extractPid(output) + ']'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void basicLaunch(String os, String version) throws Exception {
		String output = doTest(os, version, 'basic-launch.sh');
		assertThat(output).doesNotContain('PID_FOLDER');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMissingLogFolderGeneratesAWarning(String os, String version) throws Exception {
		String output = doTest(os, version, 'launch-with-missing-log-folder.sh');
		assertThat(output)
			.has(coloredString(AnsiColor.YELLOW, 'LOG_FOLDER /does/not/exist does not exist. Falling back to /tmp'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMissingPidFolderGeneratesAWarning(String os, String version) throws Exception {
		String output = doTest(os, version, 'launch-with-missing-pid-folder.sh');
		assertThat(output)
			.has(coloredString(AnsiColor.YELLOW, 'PID_FOLDER /does/not/exist does not exist. Falling back to /tmp'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithSingleCommandLineArgument(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-single-command-line-argument.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMultipleCommandLineArguments(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-multiple-command-line-arguments.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithSingleRunArg(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-single-run-arg.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMultipleRunArgs(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-multiple-run-args.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithSingleJavaOpt(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-single-java-opt.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithDoubleLinkSingleJavaOpt(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-double-link-single-java-opt.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMultipleJavaOpts(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-multiple-java-opts.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithUseOfStartStopDaemonDisabled(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-use-of-start-stop-daemon-disabled.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithRelativePidFolder(String os, String version) throws Exception {
		String output = doTest(os, version, 'launch-with-relative-pid-folder.sh');
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Started [' + extractPid(output) + ']'));
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Running [' + extractPid(output) + ']'));
		assertThat(output).has(coloredString(AnsiColor.GREEN, 'Stopped [' + extractPid(output) + ']'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void pidFolderOwnership(String os, String version) throws Exception {
		String output = doTest(os, version, 'pid-folder-ownership.sh');
		assertThat(output).contains('phil root');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void pidFileOwnership(String os, String version) throws Exception {
		String output = doTest(os, version, 'pid-file-ownership.sh');
		assertThat(output).contains('phil root');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void logFileOwnership(String os, String version) throws Exception {
		String output = doTest(os, version, 'log-file-ownership.sh');
		assertThat(output).contains('phil root');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void logFileOwnershipIsChangedWhenCreated(String os, String version) throws Exception {
		String output = doTest(os, version, 'log-file-ownership-is-changed-when-created.sh');
		assertThat(output).contains('andy root');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void logFileOwnershipIsUnchangedWhenExists(String os, String version) throws Exception {
		String output = doTest(os, version, 'log-file-ownership-is-unchanged-when-exists.sh');
		assertThat(output).contains('root root');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithRelativeLogFolder(String os, String version) throws Exception {
		String output = doTest(os, version, 'launch-with-relative-log-folder.sh');
		assertThat(output).contains('Log written');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithRunAsUser(String os, String version) throws Exception {
		String output = doTest(os, version, 'launch-with-run-as-user.sh');
		assertThat(output).contains('wagner root');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void whenRunAsUserDoesNotExistLaunchFailsWithInvalidArgument(String os, String version) throws Exception {
		String output = doTest(os, version, 'launch-with-run-as-invalid-user.sh');
		assertThat(output).contains('Status: 2');
		assertThat(output).has(coloredString(AnsiColor.RED, 'Cannot run as "johndoe": no such user'));
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void whenJarOwnerAndRunAsUserAreBothSpecifiedRunAsUserTakesPrecedence(String os, String version) throws Exception {
		String output = doTest(os, version, 'launch-with-run-as-user-preferred-to-jar-owner.sh');
		assertThat(output).contains('wagner root');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void whenLaunchedUsingNonRootUserWithRunAsUserSpecifiedLaunchFailsWithInsufficientPrivilege(String os,
			String version) throws Exception {
		String output = doTest(os, version, 'launch-with-run-as-user-root-required.sh');
		assertThat(output).contains('Status: 4');
		assertThat(output).has(coloredString(AnsiColor.RED, 'Cannot run as "wagner": current user is not root'));
	}
	private String extractPid(String output) {
		return extract('PID', output);
	}
	private String extract(String label, String output) {
		Pattern pattern = Pattern.compile('.*' + label + ': ([0-9]+).*', Pattern.DOTALL);
		java.util.regex.Matcher matcher = pattern.matcher(output);
		if (matcher.matches()) {
			return matcher.group(1);
		}
		throw new IllegalArgumentException('Failed to extract ' + label + ' from output: ' + output);
	}
}
/*
package org.springframework.boot.launchscript;
/**
@DisabledIfDockerUnavailable
class JarLaunchScriptIntegrationTests extends AbstractLaunchScriptIntegrationTests {
	JarLaunchScriptIntegrationTests() {
		super('jar/');
	}
	static List<Object[]> parameters() {
		return filterParameters((file) -> true);
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void basicLaunch(String os, String version) throws Exception {
		doLaunch(os, version, 'basic-launch.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithDebugEnv(String os, String version) throws Exception {
		final String output = doTest(os, version, 'launch-with-debug.sh');
		assertThat(output).contains('++ pwd');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithDifferentJarFileEnv(String os, String version) throws Exception {
		final String output = doTest(os, version, 'launch-with-jarfile.sh');
		assertThat(output).contains('app-another.jar');
		assertThat(output).doesNotContain('spring-boot-launch-script-tests.jar');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithSingleCommandLineArgument(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-single-command-line-argument.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMultipleCommandLineArguments(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-multiple-command-line-arguments.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithSingleRunArg(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-single-run-arg.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMultipleRunArgs(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-multiple-run-args.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithSingleJavaOpt(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-single-java-opt.sh');
	}
	@ParameterizedTest(name = '{0} {1}')
	@MethodSource('parameters')
	void launchWithMultipleJavaOpts(String os, String version) throws Exception {
		doLaunch(os, version, 'launch-with-multiple-java-opts.sh');
	}
}
/*
package org.springframework.boot.launchscript;
/**
abstract class AbstractLaunchScriptIntegrationTests {
	protected static final char ESC = 27;
	private final String scriptsDir;
	protected AbstractLaunchScriptIntegrationTests(String scriptsDir) {
		this.scriptsDir = scriptsDir;
	}
	static List<Object[]> filterParameters(Predicate<File> osFilter) {
		List<Object[]> parameters = new ArrayList<>();
		for (File os : new File('src/dockerTest/resources/conf').listFiles()) {
			if (osFilter.test(os)) {
				for (File version : os.listFiles()) {
					parameters.add(new Object[] { os.getName(), version.getName() });
				}
			}
		}
		return parameters;
	}
	protected Condition<String> coloredString(AnsiColor color, String string) {
		String colorString = ESC + '[0;' + color + 'm' + string + ESC + '[0m';
		return new Condition<>() {
			@Override
			public boolean matches(String value) {
				return containsString(colorString).matches(value);
			}
		};
	}
	protected void doLaunch(String os, String version, String script) throws Exception {
		assertThat(doTest(os, version, script)).contains('Launched');
	}
	protected String doTest(String os, String version, String script) throws Exception {
		ToStringConsumer consumer = new ToStringConsumer().withRemoveAnsiCodes(false);
		try (LaunchScriptTestContainer container = new LaunchScriptTestContainer(os, version, this.scriptsDir,
				script)) {
			container.withLogConsumer(consumer);
			container.withLogConsumer(new Slf4jLogConsumer(LoggerFactory.getLogger('docker')));
			container.start();
			while (container.isRunning()) {
				Thread.sleep(100);
			}
		}
		return consumer.toUtf8String();
	}
	private static final class LaunchScriptTestContainer extends GenericContainer<LaunchScriptTestContainer> {
		private LaunchScriptTestContainer(String os, String version, String scriptsDir, String testScript) {
			super(createImage(os, version));
			withCopyFileToContainer(MountableFile.forHostPath(findApplication().getAbsolutePath()), '/app.jar');
			withCopyFileToContainer(
					MountableFile.forHostPath('src/dockerTest/resources/scripts/' + scriptsDir + 'test-functions.sh'),
					'/test-functions.sh');
			withCopyFileToContainer(
					MountableFile.forHostPath('src/dockerTest/resources/scripts/' + scriptsDir + testScript),
					'/' + testScript);
			withCommand('/bin/bash', '-c',
					'chown root:root *.sh && chown root:root *.jar && chmod +x ' + testScript + ' && ./' + testScript);
			withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofMinutes(5)));
		}
		private static ImageFromDockerfile createImage(String os, String version) {
			ImageFromDockerfile image = new ImageFromDockerfile(
					'spring-boot-launch-script/' + os.toLowerCase(Locale.ROOT) + '-' + version);
			image.withFileFromFile('Dockerfile',
					new File('src/dockerTest/resources/conf/' + os + '/' + version + '/Dockerfile'));
			for (File file : new File('build/downloads/jdk/bellsoft').listFiles()) {
				image.withFileFromFile('downloads/' + file.getName(), file);
			}
			return image;
		}
		private static File findApplication() {
			String name = String.format('build/%1$s/build/libs/%1$s.jar', 'spring-boot-launch-script-tests-app');
			File jar = new File(name);
			Assert.state(jar.isFile(), () -> 'Could not find ' + name + '. Have you built it?');
			return jar;
		}
	}
}
/*
package com.example;
/**
@ConditionalOnClass(name = {'org.eclipse.jetty.server.handler.ContextHandler'})
@Configuration(proxyBeanMethods = false)
public class JettyServerCustomizerConfig {
	@Bean
	public JettyServerCustomizer jettyServerCustomizer() {
		return (server) -> {
			ContextHandler handler = (ContextHandler) server.getHandler();
			handler.addAliasCheck((path, resource) -> true);
			for (Connector connector : server.getConnectors()) {
				connector.getConnectionFactory(HttpConnectionFactory.class).getHttpConfiguration()
						.setUriCompliance(UriCompliance.LEGACY);
			}
		};
	}
}
/*
package com.example;
/**
@SpringBootApplication
public class ResourceHandlingApplication {
	@Bean
	public ServletRegistrationBean<?> resourceServletRegistration() {
		ServletRegistrationBean<?> registration = new ServletRegistrationBean<HttpServlet>(new GetResourceServlet());
		registration.addUrlMappings('/servletContext');
		return registration;
	}
	@Bean
	public ServletRegistrationBean<?> resourcePathsServletRegistration() {
		ServletRegistrationBean<?> registration = new ServletRegistrationBean<HttpServlet>(
				new GetResourcePathsServlet());
		registration.addUrlMappings('/resourcePaths');
		return registration;
	}
	public static void main(String[] args) {
		try {
			Class.forName('org.springframework.web.servlet.DispatcherServlet');
			System.err.println('Spring MVC must not be present, otherwise its static resource handling '
					+ 'will be used rather than the embedded containers"');
			System.exit(1);
		}
		catch (Throwable ex) {
			new SpringApplicationBuilder(ResourceHandlingApplication.class).properties('server.port:0')
					.listeners(new WebServerPortFileWriter(args[0])).run(args);
		}
	}
	private static final class GetResourcePathsServlet extends HttpServlet {
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			collectResourcePaths('/').forEach(resp.getWriter()::println);
			resp.getWriter().flush();
		}
		private Set<String> collectResourcePaths(String path) {
			Set<String> allResourcePaths = new LinkedHashSet<>();
			Set<String> pathsForPath = getServletContext().getResourcePaths(path);
			if (pathsForPath != null) {
				for (String resourcePath : pathsForPath) {
					allResourcePaths.add(resourcePath);
					allResourcePaths.addAll(collectResourcePaths(resourcePath));
				}
			}
			return allResourcePaths;
		}
	}
	private static final class GetResourceServlet extends HttpServlet {
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			URL resource = getServletContext().getResource(req.getQueryString());
			if (resource == null) {
				resp.sendError(404);
			}
			else {
				resp.getWriter().println(resource);
				resp.getWriter().flush();
			}
		}
	}
}
/*
package com.autoconfig;
@AutoConfiguration
public class ExampleAutoConfiguration {
	@Bean
	@ConditionalOnWarDeployment
	public ServletRegistrationBean<TestServlet> onWarTestServlet() {
		ServletRegistrationBean<TestServlet> registration = new ServletRegistrationBean<>(new TestServlet());
		registration.addUrlMappings('/conditionalOnWar');
		return registration;
	}
	@Bean
	public ServletRegistrationBean<TestServlet> testServlet() {
		ServletRegistrationBean<TestServlet> registration = new ServletRegistrationBean<>(new TestServlet());
		registration.addUrlMappings('/always');
		return registration;
	}
	static class TestServlet extends HttpServlet {
		@Override
		protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
			resp.setContentType(MediaType.APPLICATION_JSON_VALUE);
			resp.getWriter().println('{\'hello\':\'world\'}');
			resp.flushBuffer();
		}
	}
}
/*
package org.springframework.boot.context.embedded;
/**
@EmbeddedServletContainerTest(packaging = 'war',
		launchers = { PackagedApplicationLauncher.class, ExplodedApplicationLauncher.class })
class EmbeddedServletContainerWarPackagingIntegrationTests {
	@TestTemplate
	void nestedMetaInfResourceIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/nested-meta-inf-resource.txt', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	@DisabledOnOs(OS.WINDOWS)
	void nestedMetaInfResourceWithNameThatContainsReservedCharactersIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity(
				'/nested-reserved-%21%23%24%25%26%28%29%2A%2B%2C%3A%3D%3F%40%5B%5D-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('encoded-name');
	}
	@TestTemplate
	void nestedMetaInfResourceIsAvailableViaServletContext(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/servletContext?/nested-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	void nestedJarIsNotAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/WEB-INF/lib/resources-1.0.jar', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@TestTemplate
	void applicationClassesAreNotAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest
			.getForEntity('/WEB-INF/classes/com/example/ResourceHandlingApplication.class', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@TestTemplate
	void webappResourcesAreAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/webapp-resource.txt', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	void loaderClassesAreNotAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/org/springframework/boot/loader/Launcher.class',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		entity = rest.getForEntity('/org/springframework/../springframework/boot/loader/Launcher.class', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@TestTemplate
	void loaderClassesAreNotAvailableViaResourcePaths(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/resourcePaths', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(readLines(entity.getBody()))
			.noneMatch((resourcePath) -> resourcePath.startsWith('/org/springframework/boot/loader'));
	}
	@TestTemplate
	void conditionalOnWarDeploymentBeanIsNotAvailableForEmbeddedServer(RestTemplate rest) {
		assertThat(rest.getForEntity('/always', String.class).getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(rest.getForEntity('/conditionalOnWar', String.class).getStatusCode())
			.isEqualTo(HttpStatus.NOT_FOUND);
	}
	private List<String> readLines(String input) {
		if (input == null) {
			return Collections.emptyList();
		}
		try (BufferedReader reader = new BufferedReader(new StringReader(input))) {
			return reader.lines().toList();
		}
		catch (IOException ex) {
			throw new RuntimeException('Failed to read lines from input "' + input + '"');
		}
	}
}
/*
package org.springframework.boot.context.embedded;
/**
@EmbeddedServletContainerTest(packaging = 'war',
		launchers = { BootRunApplicationLauncher.class, IdeApplicationLauncher.class })
class EmbeddedServletContainerWarDevelopmentIntegrationTests {
	@TestTemplate
	void metaInfResourceFromDependencyIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/nested-meta-inf-resource.txt', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	@DisabledOnOs(OS.WINDOWS)
	void metaInfResourceFromDependencyWithNameThatContainsReservedCharactersIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity(
				'/nested-reserved-%21%23%24%25%26%28%29%2A%2B%2C%3A%3D%3F%40%5B%5D-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('encoded-name');
	}
	@TestTemplate
	void metaInfResourceFromDependencyIsAvailableViaServletContext(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/servletContext?/nested-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	void webappResourcesAreAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/webapp-resource.txt', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	void loaderClassesAreNotAvailableViaResourcePaths(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/resourcePaths', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(readLines(entity.getBody()))
			.noneMatch((resourcePath) -> resourcePath.startsWith('/org/springframework/boot/loader'));
	}
	private List<String> readLines(String input) {
		if (input == null) {
			return Collections.emptyList();
		}
		try (BufferedReader reader = new BufferedReader(new StringReader(input))) {
			return reader.lines().toList();
		}
		catch (IOException ex) {
			throw new RuntimeException('Failed to read lines from input "' + input + '"');
		}
	}
}
/*
package org.springframework.boot.context.embedded;
/**
@EmbeddedServletContainerTest(packaging = 'jar',
		launchers = { PackagedApplicationLauncher.class, ExplodedApplicationLauncher.class })
class EmbeddedServletContainerJarPackagingIntegrationTests {
	@TestTemplate
	void nestedMetaInfResourceIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/nested-meta-inf-resource.txt', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	@DisabledOnOs(OS.WINDOWS)
	void nestedMetaInfResourceWithNameThatContainsReservedCharactersIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity(
				'/nested-reserved-%21%23%24%25%26%28%29%2A%2B%2C%3A%3D%3F%40%5B%5D-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('encoded-name');
	}
	@TestTemplate
	void nestedMetaInfResourceIsAvailableViaServletContext(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/servletContext?/nested-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	void nestedJarIsNotAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/BOOT-INF/lib/resources-1.0.jar', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@TestTemplate
	void applicationClassesAreNotAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest
			.getForEntity('/BOOT-INF/classes/com/example/ResourceHandlingApplication.class', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@TestTemplate
	void launcherIsNotAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/org/springframework/boot/loader/Launcher.class',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
	@TestTemplate
	void conditionalOnWarDeploymentBeanIsNotAvailableForEmbeddedServer(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/war', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
	}
}
/*
package org.springframework.boot.context.embedded;
/**
@EmbeddedServletContainerTest(packaging = 'jar',
		launchers = { BootRunApplicationLauncher.class, IdeApplicationLauncher.class })
class EmbeddedServletContainerJarDevelopmentIntegrationTests {
	@TestTemplate
	void metaInfResourceFromDependencyIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/nested-meta-inf-resource.txt', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@TestTemplate
	@DisabledOnOs(OS.WINDOWS)
	void metaInfResourceFromDependencyWithNameThatContainsReservedCharactersIsAvailableViaHttp(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity(
				'/nested-reserved-%21%23%24%25%26%28%29%2A%2B%2C%3A%3D%3F%40%5B%5D-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(entity.getBody()).isEqualTo('encoded-name');
	}
	@TestTemplate
	void metaInfResourceFromDependencyIsAvailableViaServletContext(RestTemplate rest) {
		ResponseEntity<String> entity = rest.getForEntity('/servletContext?/nested-meta-inf-resource.txt',
				String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
}
/*
package org.springframework.boot.context.embedded;
/**
class IdeApplicationLauncher extends AbstractApplicationLauncher {
	private final File exploded;
	IdeApplicationLauncher(Application application, File outputLocation) {
		super(application, outputLocation);
		this.exploded = new File(outputLocation, 'the+ide application');
	}
	@Override
	protected File getWorkingDirectory() {
		return this.exploded;
	}
	@Override
	protected String getDescription(String packaging) {
		return 'IDE run ' + packaging + ' project';
	}
	@Override
	protected List<String> getArguments(File archive, File serverPortFile) {
		try {
			explodeArchive(archive, this.exploded);
			deleteLauncherClasses();
			File builtClasses = populateBuiltClasses(archive);
			File dependencies = populateDependencies(archive);
			File resourcesProject = explodedResourcesProject(dependencies);
			if (archive.getName().endsWith('.war')) {
				populateSrcMainWebapp();
			}
			List<String> classpath = new ArrayList<>();
			classpath.add(builtClasses.getAbsolutePath());
			for (File dependency : dependencies.listFiles()) {
				classpath.add(dependency.getAbsolutePath());
			}
			classpath.add(resourcesProject.getAbsolutePath());
			return Arrays.asList('-cp', StringUtils.collectionToDelimitedString(classpath, File.pathSeparator),
					'com.example.ResourceHandlingApplication', serverPortFile.getAbsolutePath());
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private File populateBuiltClasses(File archive) throws IOException {
		File builtClasses = new File(this.exploded, 'built/classes');
		builtClasses.mkdirs();
		File source = new File(this.exploded, getClassesPath(archive));
		FileSystemUtils.copyRecursively(source, builtClasses);
		FileSystemUtils.deleteRecursively(source);
		return builtClasses;
	}
	private File populateDependencies(File archive) throws IOException {
		File dependencies = new File(this.exploded, 'dependencies');
		dependencies.mkdirs();
		List<String> libPaths = getLibPaths(archive);
		for (String libPath : libPaths) {
			File libDirectory = new File(this.exploded, libPath);
			for (File jar : libDirectory.listFiles()) {
				FileCopyUtils.copy(jar, new File(dependencies, jar.getName()));
			}
			FileSystemUtils.deleteRecursively(libDirectory);
		}
		return dependencies;
	}
	private File explodedResourcesProject(File dependencies) throws IOException {
		File resourcesProject = new File(this.exploded, 'resources-project/built/classes');
		File resourcesJar = new File(dependencies, 'spring-boot-server-tests-app-resources.jar');
		explodeArchive(resourcesJar, resourcesProject);
		resourcesJar.delete();
		return resourcesProject;
	}
	private void populateSrcMainWebapp() throws IOException {
		File srcMainWebapp = new File(this.exploded, 'src/main/webapp');
		srcMainWebapp.mkdirs();
		File source = new File(this.exploded, 'webapp-resource.txt');
		FileCopyUtils.copy(source, new File(srcMainWebapp, 'webapp-resource.txt'));
		source.delete();
	}
	private void deleteLauncherClasses() {
		FileSystemUtils.deleteRecursively(new File(this.exploded, 'org'));
	}
	private String getClassesPath(File archive) {
		return (archive.getName().endsWith('.jar') ? 'BOOT-INF/classes' : 'WEB-INF/classes');
	}
	private List<String> getLibPaths(File archive) {
		return (archive.getName().endsWith('.jar') ? Collections.singletonList('BOOT-INF/lib')
				: Arrays.asList('WEB-INF/lib'));
	}
	private void explodeArchive(File archive, File destination) throws IOException {
		FileSystemUtils.deleteRecursively(destination);
		JarFile jarFile = new JarFile(archive);
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			JarEntry jarEntry = entries.nextElement();
			File extracted = new File(destination, jarEntry.getName());
			if (jarEntry.isDirectory()) {
				extracted.mkdirs();
			}
			else {
				FileOutputStream extractedOutputStream = new FileOutputStream(extracted);
				StreamUtils.copy(jarFile.getInputStream(jarEntry), extractedOutputStream);
				extractedOutputStream.close();
			}
		}
		jarFile.close();
	}
}
/*
package org.springframework.boot.context.embedded;
/**
class PackagedApplicationLauncher extends AbstractApplicationLauncher {
	PackagedApplicationLauncher(Application application, File outputLocation) {
		super(application, outputLocation);
	}
	@Override
	protected File getWorkingDirectory() {
		return null;
	}
	@Override
	protected String getDescription(String packaging) {
		return 'packaged ' + packaging;
	}
	@Override
	protected List<String> getArguments(File archive, File serverPortFile) {
		return Arrays.asList('-jar', archive.getAbsolutePath(), serverPortFile.getAbsolutePath());
	}
}
/*
package org.springframework.boot.context.embedded;
/**
class Application {
	private final String packaging;
	private final String container;
	Application(String packaging, String container) {
		this.packaging = packaging;
		this.container = container;
	}
	String getPackaging() {
		return this.packaging;
	}
	String getContainer() {
		return this.container;
	}
	File getArchive() {
		return new File('build/spring-boot-server-tests-app/build/libs/spring-boot-server-tests-app-' + this.container
				+ '.' + this.packaging);
	}
}
/*
package org.springframework.boot.context.embedded;
/**
abstract class AbstractApplicationLauncher implements BeforeEachCallback {
	private final Application application;
	private final File outputLocation;
	private Process process;
	private int httpPort;
	protected AbstractApplicationLauncher(Application application, File outputLocation) {
		this.application = application;
		this.outputLocation = outputLocation;
	}
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		if (this.process == null) {
			this.process = startApplication();
		}
	}
	void destroyProcess() {
		if (this.process != null) {
			this.process.destroy();
			try {
				this.process.waitFor();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
		FileSystemUtils.deleteRecursively(this.outputLocation);
	}
	final int getHttpPort() {
		return this.httpPort;
	}
	protected abstract List<String> getArguments(File archive, File serverPortFile);
	protected abstract File getWorkingDirectory();
	protected abstract String getDescription(String packaging);
	private Process startApplication() throws Exception {
		File workingDirectory = getWorkingDirectory();
		File serverPortFile = new File(this.outputLocation, 'server.port');
		serverPortFile.delete();
		File archive = new File('build/spring-boot-server-tests-app/build/libs/spring-boot-server-tests-app-'
				+ this.application.getContainer() + '.' + this.application.getPackaging());
		List<String> arguments = new ArrayList<>();
		arguments.add(System.getProperty('java.home') + '/bin/java');
		arguments.addAll(getArguments(archive, serverPortFile));
		arguments.add('--server.servlet.register-default-servlet=true');
		ProcessBuilder processBuilder = new ProcessBuilder(StringUtils.toStringArray(arguments));
		if (workingDirectory != null) {
			processBuilder.directory(workingDirectory);
		}
		Process process = processBuilder.start();
		new ConsoleCopy(process.getInputStream(), System.out).start();
		new ConsoleCopy(process.getErrorStream(), System.err).start();
		this.httpPort = awaitServerPort(process, serverPortFile);
		return process;
	}
	private int awaitServerPort(Process process, File serverPortFile) throws Exception {
		Awaitility.waitAtMost(Duration.ofSeconds(180)).until(serverPortFile::length, (length) -> {
			if (!process.isAlive()) {
				throw new IllegalStateException('Application failed to start');
			}
			return length > 0;
		});
		return Integer.parseInt(FileCopyUtils.copyToString(new FileReader(serverPortFile)));
	}
	private static class ConsoleCopy extends Thread {
		private final InputStream input;
		private final PrintStream output;
		ConsoleCopy(InputStream input, PrintStream output) {
			this.input = input;
			this.output = output;
		}
		@Override
		public void run() {
			try {
				StreamUtils.copy(this.input, this.output);
			}
			catch (IOException ex) {
				// Ignore
			}
		}
	}
}
/*
package org.springframework.boot.context.embedded;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@ExtendWith(EmbeddedServerContainerInvocationContextProvider.class)
public @interface EmbeddedServletContainerTest {
	String packaging();
	Class<? extends AbstractApplicationLauncher>[] launchers();
}
/*
package org.springframework.boot.context.embedded;
/**
class EmbeddedServerContainerInvocationContextProvider
		implements TestTemplateInvocationContextProvider, AfterAllCallback {
	private static final Set<String> CONTAINERS = new HashSet<>(Arrays.asList('jetty', 'tomcat', 'undertow'));
	private static final BuildOutput buildOutput = new BuildOutput(
			EmbeddedServerContainerInvocationContextProvider.class);
	private final Map<String, AbstractApplicationLauncher> launcherCache = new HashMap<>();
	private final Path tempDir;
	EmbeddedServerContainerInvocationContextProvider() throws IOException {
		this.tempDir = Files.createTempDirectory('embedded-servlet-container-tests');
	}
	@Override
	public boolean supportsTestTemplate(ExtensionContext context) {
		return true;
	}
	@Override
	public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {
		EmbeddedServletContainerTest annotation = context.getRequiredTestClass()
			.getAnnotation(EmbeddedServletContainerTest.class);
		return CONTAINERS.stream()
			.map((container) -> getApplication(annotation, container))
			.flatMap((builder) -> provideTestTemplateInvocationContexts(annotation, builder));
	}
	private Stream<EmbeddedServletContainerInvocationContext> provideTestTemplateInvocationContexts(
			EmbeddedServletContainerTest annotation, Application application) {
		return Stream.of(annotation.launchers())
			.map((launcherClass) -> getAbstractApplicationLauncher(application, launcherClass))
			.map((launcher) -> provideTestTemplateInvocationContext(application, launcher));
	}
	private EmbeddedServletContainerInvocationContext provideTestTemplateInvocationContext(Application application,
			AbstractApplicationLauncher launcher) {
		String name = StringUtils.capitalize(application.getContainer()) + ': '
				+ launcher.getDescription(application.getPackaging());
		return new EmbeddedServletContainerInvocationContext(name, launcher);
	}
	@Override
	public void afterAll(ExtensionContext context) throws Exception {
		cleanupCaches();
		FileSystemUtils.deleteRecursively(this.tempDir);
	}
	private void cleanupCaches() {
		this.launcherCache.values().forEach(AbstractApplicationLauncher::destroyProcess);
		this.launcherCache.clear();
	}
	private AbstractApplicationLauncher getAbstractApplicationLauncher(Application application,
			Class<? extends AbstractApplicationLauncher> launcherClass) {
		String cacheKey = application.getContainer() + ':' + application.getPackaging() + ':' + launcherClass.getName();
		if (this.launcherCache.containsKey(cacheKey)) {
			return this.launcherCache.get(cacheKey);
		}
		AbstractApplicationLauncher launcher = ReflectionUtils.newInstance(launcherClass, application,
				new File(buildOutput.getRootLocation(), 'app-launcher-' + UUID.randomUUID()));
		this.launcherCache.put(cacheKey, launcher);
		return launcher;
	}
	private Application getApplication(EmbeddedServletContainerTest annotation, String container) {
		return new Application(annotation.packaging(), container);
	}
	static class EmbeddedServletContainerInvocationContext implements TestTemplateInvocationContext, ParameterResolver {
		private final String name;
		private final AbstractApplicationLauncher launcher;
		EmbeddedServletContainerInvocationContext(String name, AbstractApplicationLauncher launcher) {
			this.name = name;
			this.launcher = launcher;
		}
		@Override
		public List<Extension> getAdditionalExtensions() {
			return Arrays.asList(this.launcher, new RestTemplateParameterResolver(this.launcher));
		}
		@Override
		public String getDisplayName(int invocationIndex) {
			return this.name;
		}
		@Override
		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			if (parameterContext.getParameter().getType().equals(AbstractApplicationLauncher.class)) {
				return true;
			}
			return parameterContext.getParameter().getType().equals(RestTemplate.class);
		}
		@Override
		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			if (parameterContext.getParameter().getType().equals(AbstractApplicationLauncher.class)) {
				return this.launcher;
			}
			return null;
		}
	}
	private static final class RestTemplateParameterResolver implements ParameterResolver {
		private final AbstractApplicationLauncher launcher;
		private RestTemplateParameterResolver(AbstractApplicationLauncher launcher) {
			this.launcher = launcher;
		}
		@Override
		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			return parameterContext.getParameter().getType().equals(RestTemplate.class);
		}
		@Override
		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			RestTemplate rest = new RestTemplate(new HttpComponentsClientHttpRequestFactory(HttpClients.custom()
				.setRetryStrategy(new DefaultHttpRequestRetryStrategy(10, TimeValue.of(1, TimeUnit.SECONDS)))
				.build()));
			rest.setErrorHandler(new ResponseErrorHandler() {
				@Override
				public boolean hasError(ClientHttpResponse response) throws IOException {
					return false;
				}
				@Override
				public void handleError(ClientHttpResponse response) throws IOException {
				}
			});
			rest.setUriTemplateHandler(new UriTemplateHandler() {
				@Override
				public URI expand(String uriTemplate, Object... uriVariables) {
					return URI.create('http://localhost:' + RestTemplateParameterResolver.this.launcher.getHttpPort()
							+ uriTemplate);
				}
				@Override
				public URI expand(String uriTemplate, Map<String, ?> uriVariables) {
					return URI.create('http://localhost:' + RestTemplateParameterResolver.this.launcher.getHttpPort()
							+ uriTemplate);
				}
			});
			return rest;
		}
	}
}
/*
package org.springframework.boot.context.embedded;
/**
class ExplodedApplicationLauncher extends AbstractApplicationLauncher {
	private final File exploded;
	ExplodedApplicationLauncher(Application application, File outputLocation) {
		super(application, outputLocation);
		this.exploded = new File(outputLocation, 'exploded');
	}
	@Override
	protected File getWorkingDirectory() {
		return this.exploded;
	}
	@Override
	protected String getDescription(String packaging) {
		return 'exploded ' + packaging;
	}
	@Override
	protected List<String> getArguments(File archive, File serverPortFile) {
		String mainClass = (archive.getName().endsWith('.war') ? 'org.springframework.boot.loader.launch.WarLauncher'
				: 'org.springframework.boot.loader.launch.JarLauncher');
		try {
			explodeArchive(archive);
			return Arrays.asList('-cp', this.exploded.getAbsolutePath(), mainClass, serverPortFile.getAbsolutePath());
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void explodeArchive(File archive) throws IOException {
		FileSystemUtils.deleteRecursively(this.exploded);
		JarFile jarFile = new JarFile(archive);
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			JarEntry jarEntry = entries.nextElement();
			File extracted = new File(this.exploded, jarEntry.getName());
			if (jarEntry.isDirectory()) {
				extracted.mkdirs();
			}
			else {
				extracted.getParentFile().mkdirs();
				FileOutputStream extractedOutputStream = new FileOutputStream(extracted);
				StreamUtils.copy(jarFile.getInputStream(jarEntry), extractedOutputStream);
				extractedOutputStream.close();
			}
		}
		jarFile.close();
	}
}
/*
package org.springframework.boot.context.embedded;
/**
class BootRunApplicationLauncher extends AbstractApplicationLauncher {
	private final File exploded;
	BootRunApplicationLauncher(Application application, File outputLocation) {
		super(application, outputLocation);
		this.exploded = new File(outputLocation, 'run');
	}
	@Override
	protected List<String> getArguments(File archive, File serverPortFile) {
		try {
			explodeArchive(archive);
			deleteLauncherClasses();
			File targetClasses = populateTargetClasses(archive);
			File dependencies = populateDependencies(archive);
			if (archive.getName().endsWith('.war')) {
				populateSrcMainWebapp();
			}
			List<String> classpath = new ArrayList<>();
			classpath.add(targetClasses.getAbsolutePath());
			for (File dependency : dependencies.listFiles()) {
				classpath.add(dependency.getAbsolutePath());
			}
			return Arrays.asList('-cp', StringUtils.collectionToDelimitedString(classpath, File.pathSeparator),
					'com.example.ResourceHandlingApplication', serverPortFile.getAbsolutePath());
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void deleteLauncherClasses() {
		FileSystemUtils.deleteRecursively(new File(this.exploded, 'org'));
	}
	private File populateTargetClasses(File archive) throws IOException {
		File builtClasses = new File(this.exploded, 'built/classes');
		builtClasses.mkdirs();
		File source = new File(this.exploded, getClassesPath(archive));
		FileSystemUtils.copyRecursively(source, builtClasses);
		FileSystemUtils.deleteRecursively(source);
		return builtClasses;
	}
	private File populateDependencies(File archive) throws IOException {
		File dependencies = new File(this.exploded, 'dependencies');
		dependencies.mkdirs();
		List<String> libPaths = getLibPaths(archive);
		for (String libPath : libPaths) {
			File libDirectory = new File(this.exploded, libPath);
			for (File jar : libDirectory.listFiles()) {
				FileCopyUtils.copy(jar, new File(dependencies, jar.getName()));
			}
			FileSystemUtils.deleteRecursively(libDirectory);
		}
		return dependencies;
	}
	private void populateSrcMainWebapp() throws IOException {
		File srcMainWebapp = new File(this.exploded, 'src/main/webapp');
		srcMainWebapp.mkdirs();
		File source = new File(this.exploded, 'webapp-resource.txt');
		FileCopyUtils.copy(source, new File(srcMainWebapp, 'webapp-resource.txt'));
		source.delete();
	}
	private String getClassesPath(File archive) {
		return (archive.getName().endsWith('.jar') ? 'BOOT-INF/classes' : 'WEB-INF/classes');
	}
	private List<String> getLibPaths(File archive) {
		return (archive.getName().endsWith('.jar') ? Collections.singletonList('BOOT-INF/lib')
				: Arrays.asList('WEB-INF/lib'));
	}
	private void explodeArchive(File archive) throws IOException {
		FileSystemUtils.deleteRecursively(this.exploded);
		JarFile jarFile = new JarFile(archive);
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			JarEntry jarEntry = entries.nextElement();
			File extracted = new File(this.exploded, jarEntry.getName());
			if (jarEntry.isDirectory()) {
				extracted.mkdirs();
			}
			else {
				FileOutputStream extractedOutputStream = new FileOutputStream(extracted);
				StreamUtils.copy(jarFile.getInputStream(jarEntry), extractedOutputStream);
				extractedOutputStream.close();
			}
		}
		jarFile.close();
	}
	@Override
	protected File getWorkingDirectory() {
		return this.exploded;
	}
	@Override
	protected String getDescription(String packaging) {
		return 'build system run ' + packaging + ' project';
	}
}
/*
package org.springframework.boot.loader;
/**
@DisabledIfDockerUnavailable
class LoaderIntegrationTests {
	private final ToStringConsumer output = new ToStringConsumer();
	@ParameterizedTest
	@MethodSource('javaRuntimes')
	void readUrlsWithoutWarning(JavaRuntime javaRuntime) {
		try (GenericContainer<?> container = createContainer(javaRuntime)) {
			container.start();
			System.out.println(this.output.toUtf8String());
			assertThat(this.output.toUtf8String()).contains('>>>>> 287649 BYTES from')
				.doesNotContain('WARNING:')
				.doesNotContain('illegal')
				.doesNotContain('jar written to temp');
		}
	}
	private GenericContainer<?> createContainer(JavaRuntime javaRuntime) {
		return javaRuntime.getContainer()
			.withLogConsumer(this.output)
			.withCopyFileToContainer(MountableFile.forHostPath(findApplication().toPath()), '/app.jar')
			.withStartupCheckStrategy(new OneShotStartupCheckStrategy().withTimeout(Duration.ofMinutes(5)))
			.withCommand('java', '-jar', 'app.jar');
	}
	private File findApplication() {
		String name = String.format('build/%1$s/build/libs/%1$s.jar', 'spring-boot-loader-classic-tests-app');
		File jar = new File(name);
		Assert.state(jar.isFile(), () -> 'Could not find ' + name + '. Have you built it?');
		return jar;
	}
	static Stream<JavaRuntime> javaRuntimes() {
		List<JavaRuntime> javaRuntimes = new ArrayList<>();
		javaRuntimes.add(JavaRuntime.openJdk(JavaVersion.SEVENTEEN));
		javaRuntimes.add(JavaRuntime.openJdk(JavaVersion.TWENTY_ONE));
		javaRuntimes.add(JavaRuntime.oracleJdk17());
		javaRuntimes.add(JavaRuntime.openJdk(JavaVersion.TWENTY_TWO));
		javaRuntimes.add(JavaRuntime.openJdkEarlyAccess(JavaVersion.TWENTY_THREE));
		return javaRuntimes.stream().filter(JavaRuntime::isCompatible);
	}
	static final class JavaRuntime {
		private final String name;
		private final JavaVersion version;
		private final Supplier<GenericContainer<?>> container;
		private JavaRuntime(String name, JavaVersion version, Supplier<GenericContainer<?>> container) {
			this.name = name;
			this.version = version;
			this.container = container;
		}
		private boolean isCompatible() {
			return this.version.isEqualOrNewerThan(JavaVersion.getJavaVersion());
		}
		GenericContainer<?> getContainer() {
			return this.container.get();
		}
		@Override
		public String toString() {
			return this.name;
		}
		static JavaRuntime openJdkEarlyAccess(JavaVersion version) {
			String imageVersion = version.toString();
			DockerImageName image = DockerImageName.parse('openjdk:%s-ea-jdk'.formatted(imageVersion));
			return new JavaRuntime('OpenJDK Early Access ' + imageVersion, version,
					() -> new GenericContainer<>(image));
		}
		static JavaRuntime openJdk(JavaVersion version) {
			String imageVersion = version.toString();
			DockerImageName image = DockerImageName.parse('bellsoft/liberica-openjdk-debian:' + imageVersion);
			return new JavaRuntime('OpenJDK ' + imageVersion, version, () -> new GenericContainer<>(image));
		}
		static JavaRuntime oracleJdk17() {
			String arch = System.getProperty('os.arch');
			String dockerFile = ('aarch64'.equals(arch)) ? 'Dockerfile-aarch64' : 'Dockerfile';
			ImageFromDockerfile image = new ImageFromDockerfile('spring-boot-loader/oracle-jdk-17')
				.withFileFromFile('Dockerfile', new File('src/dockerTest/resources/conf/oracle-jdk-17/' + dockerFile));
			return new JavaRuntime('Oracle JDK 17', JavaVersion.SEVENTEEN, () -> new GenericContainer<>(image));
		}
	}
}
/*
package org.springframework.boot.loaderapp;
@SpringBootApplication
public class LoaderTestApplication {
	@Bean
	public CommandLineRunner commandLineRunner(ServletContext servletContext) {
		return (args) -> {
			File temp = new File(System.getProperty('java.io.tmpdir'));
			URL resourceUrl = servletContext.getResource('webjars/jquery/3.5.0/jquery.js');
			JarURLConnection connection = (JarURLConnection) resourceUrl.openConnection();
			String jarName = connection.getJarFile().getName();
			System.out.println('>>>>> jar file ' + jarName);
			if(jarName.contains(temp.getAbsolutePath())) {
				System.out.println('>>>>> jar written to temp');
			}
			byte[] resourceContent = FileCopyUtils.copyToByteArray(resourceUrl.openStream());
			URL directUrl = new URL(resourceUrl.toExternalForm());
			byte[] directContent = FileCopyUtils.copyToByteArray(directUrl.openStream());
			String message = (!Arrays.equals(resourceContent, directContent)) ? 'NO MATCH'
					: directContent.length + ' BYTES';
			System.out.println('>>>>> ' + message + ' from ' + resourceUrl);
		};
	}
	public static void main(String[] args) {
		SpringApplication.run(LoaderTestApplication.class, args).close();
	}
}
/*
package org.springframework.boot.build.assertj;
/**
public class NodeAssert extends AbstractAssert<NodeAssert, Node> implements AssertProvider<NodeAssert> {
	private static final DocumentBuilderFactory FACTORY = DocumentBuilderFactory.newInstance();
	private final XPathFactory xpathFactory = XPathFactory.newInstance();
	private final XPath xpath = this.xpathFactory.newXPath();
	public NodeAssert(File xmlFile) {
		this(read(xmlFile));
	}
	public NodeAssert(Node actual) {
		super(actual, NodeAssert.class);
	}
	private static Document read(File xmlFile) {
		try {
			return FACTORY.newDocumentBuilder().parse(xmlFile);
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	public NodeAssert nodeAtPath(String xpath) {
		try {
			return new NodeAssert((Node) this.xpath.evaluate(xpath, this.actual, XPathConstants.NODE));
		}
		catch (XPathExpressionException ex) {
			throw new RuntimeException(ex);
		}
	}
	public StringAssert textAtPath(String xpath) {
		try {
			return new StringAssert(
					(String) this.xpath.evaluate(xpath + '/text()', this.actual, XPathConstants.STRING));
		}
		catch (XPathExpressionException ex) {
			throw new RuntimeException(ex);
		}
	}
	@Override
	public NodeAssert assertThat() {
		return this;
	}
}
/*
package org.springframework.boot.build.optional;
/**
class OptionalDependenciesPluginIntegrationTests {
	private File projectDir;
	private File buildFile;
	@BeforeEach
	void setup(@TempDir File projectDir) {
		this.projectDir = projectDir;
		this.buildFile = new File(this.projectDir, 'build.gradle');
	}
	@Test
	void optionalConfigurationIsCreated() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins { id "org.springframework.boot.optional-dependencies" }');
			out.println('task printConfigurations {');
			out.println('    doLast {');
			out.println('        configurations.all { println it.name }');
			out.println('    }');
			out.println('}');
		}
		BuildResult buildResult = runGradle('printConfigurations');
		assertThat(buildResult.getOutput()).contains(OptionalDependenciesPlugin.OPTIONAL_CONFIGURATION_NAME);
	}
	@Test
	void optionalDependenciesAreAddedToMainSourceSetsCompileClasspath() throws IOException {
		optionalDependenciesAreAddedToSourceSetClasspath('main', 'compileClasspath');
	}
	@Test
	void optionalDependenciesAreAddedToMainSourceSetsRuntimeClasspath() throws IOException {
		optionalDependenciesAreAddedToSourceSetClasspath('main', 'runtimeClasspath');
	}
	@Test
	void optionalDependenciesAreAddedToTestSourceSetsCompileClasspath() throws IOException {
		optionalDependenciesAreAddedToSourceSetClasspath('test', 'compileClasspath');
	}
	@Test
	void optionalDependenciesAreAddedToTestSourceSetsRuntimeClasspath() throws IOException {
		optionalDependenciesAreAddedToSourceSetClasspath('test', 'runtimeClasspath');
	}
	private void optionalDependenciesAreAddedToSourceSetClasspath(String sourceSet, String classpath)
			throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.optional-dependencies"');
			out.println('    id "java"');
			out.println('}');
			out.println('repositories {');
			out.println('    mavenCentral()');
			out.println('}');
			out.println('dependencies {');
			out.println('    optional "org.springframework:spring-jcl:5.1.2.RELEASE"');
			out.println('}');
			out.println('task printClasspath {');
			out.println('    doLast {');
			out.println('        println sourceSets.' + sourceSet + '.' + classpath + '.files');
			out.println('    }');
			out.println('}');
		}
		BuildResult buildResult = runGradle('printClasspath');
		assertThat(buildResult.getOutput()).contains('spring-jcl');
	}
	private BuildResult runGradle(String... args) {
		return GradleRunner.create().withProjectDir(this.projectDir).withArguments(args).withPluginClasspath().build();
	}
}
/*
package org.springframework.boot.build.testing;
/**
class TestFailuresPluginIntegrationTests {
	private File projectDir;
	@BeforeEach
	void setup(@TempDir File projectDir) {
		this.projectDir = projectDir;
	}
	@Test
	void singleProject() {
		createProject(this.projectDir);
		BuildResult result = GradleRunner.create()
			.withDebug(true)
			.withProjectDir(this.projectDir)
			.withArguments('build')
			.withPluginClasspath()
			.buildAndFail();
		assertThat(readLines(result.getOutput())).containsSequence('Found test failures in 1 test task:', '', ':test',
				'    example.ExampleTests > bad()', '    example.ExampleTests > fail()',
				'    example.MoreTests > bad()', '    example.MoreTests > fail()', '');
	}
	@Test
	void multiProject() {
		createMultiProjectBuild();
		BuildResult result = GradleRunner.create()
			.withDebug(true)
			.withProjectDir(this.projectDir)
			.withArguments('build')
			.withPluginClasspath()
			.buildAndFail();
		assertThat(readLines(result.getOutput())).containsSequence('Found test failures in 1 test task:', '',
				':project-one:test', '    example.ExampleTests > bad()', '    example.ExampleTests > fail()',
				'    example.MoreTests > bad()', '    example.MoreTests > fail()', '');
	}
	@Test
	void multiProjectContinue() {
		createMultiProjectBuild();
		BuildResult result = GradleRunner.create()
			.withDebug(true)
			.withProjectDir(this.projectDir)
			.withArguments('build', '--continue')
			.withPluginClasspath()
			.buildAndFail();
		assertThat(readLines(result.getOutput())).containsSequence('Found test failures in 2 test tasks:', '',
				':project-one:test', '    example.ExampleTests > bad()', '    example.ExampleTests > fail()',
				'    example.MoreTests > bad()', '    example.MoreTests > fail()', '', ':project-two:test',
				'    example.ExampleTests > bad()', '    example.ExampleTests > fail()',
				'    example.MoreTests > bad()', '    example.MoreTests > fail()', '');
	}
	@Test
	void multiProjectParallel() {
		createMultiProjectBuild();
		BuildResult result = GradleRunner.create()
			.withDebug(true)
			.withProjectDir(this.projectDir)
			.withArguments('build', '--parallel', '--stacktrace')
			.withPluginClasspath()
			.buildAndFail();
		assertThat(readLines(result.getOutput())).containsSequence('Found test failures in 2 test tasks:', '',
				':project-one:test', '    example.ExampleTests > bad()', '    example.ExampleTests > fail()',
				'    example.MoreTests > bad()', '    example.MoreTests > fail()', '', ':project-two:test',
				'    example.ExampleTests > bad()', '    example.ExampleTests > fail()',
				'    example.MoreTests > bad()', '    example.MoreTests > fail()', '');
	}
	private void createProject(File dir) {
		File examplePackage = new File(dir, 'src/test/java/example');
		examplePackage.mkdirs();
		createTestSource('ExampleTests', examplePackage);
		createTestSource('MoreTests', examplePackage);
		createBuildScript(dir);
	}
	private void createMultiProjectBuild() {
		createProject(new File(this.projectDir, 'project-one'));
		createProject(new File(this.projectDir, 'project-two'));
		withPrintWriter(new File(this.projectDir, 'settings.gradle'), (writer) -> {
			writer.println('include "project-one"');
			writer.println('include "project-two"');
		});
	}
	private void createTestSource(String name, File dir) {
		withPrintWriter(new File(dir, name + '.java'), (writer) -> {
			writer.println('package example;');
			writer.println();
			writer.println('import org.junit.jupiter.api.Test;');
			writer.println();
			writer.println('import static org.assertj.core.api.Assertions.assertThat;');
			writer.println();
			writer.println('class ' + name + '{');
			writer.println();
			writer.println('	@Test');
			writer.println('	void fail() {');
			writer.println('		assertThat(true).isFalse();');
			writer.println('	}');
			writer.println();
			writer.println('	@Test');
			writer.println('	void bad() {');
			writer.println('		assertThat(5).isLessThan(4);');
			writer.println('	}');
			writer.println();
			writer.println('	@Test');
			writer.println('	void ok() {');
			writer.println('	}');
			writer.println();
			writer.println('}');
		});
	}
	private void createBuildScript(File dir) {
		withPrintWriter(new File(dir, 'build.gradle'), (writer) -> {
			writer.println('plugins {');
			writer.println('	id "java"');
			writer.println('	id "org.springframework.boot.test-failures"');
			writer.println('}');
			writer.println();
			writer.println('repositories {');
			writer.println('	mavenCentral()');
			writer.println('}');
			writer.println();
			writer.println('dependencies {');
			writer.println('	testImplementation "org.junit.jupiter:junit-jupiter:5.6.0"');
			writer.println('	testImplementation "org.assertj:assertj-core:3.11.1"');
			writer.println('}');
			writer.println();
			writer.println('test {');
			writer.println('	useJUnitPlatform()');
			writer.println('}');
		});
	}
	private void withPrintWriter(File file, Consumer<PrintWriter> consumer) {
		try (PrintWriter writer = new PrintWriter(new FileWriter(file))) {
			consumer.accept(writer);
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private List<String> readLines(String output) {
		try (BufferedReader reader = new BufferedReader(new StringReader(output))) {
			return reader.lines().toList();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.build.mavenplugin;
/**
class PluginXmlParserTests {
	private final PluginXmlParser parser = new PluginXmlParser();
	@Test
	void parseExistingDescriptorReturnPluginDescriptor() {
		Plugin plugin = this.parser.parse(new File('src/test/resources/plugin.xml'));
		assertThat(plugin.getGroupId()).isEqualTo('org.springframework.boot');
		assertThat(plugin.getArtifactId()).isEqualTo('spring-boot-maven-plugin');
		assertThat(plugin.getVersion()).isEqualTo('2.2.0.GRADLE-SNAPSHOT');
		assertThat(plugin.getGoalPrefix()).isEqualTo('spring-boot');
		assertThat(plugin.getMojos().stream().map(PluginXmlParser.Mojo::getGoal)).containsExactly('build-info', 'help',
				'repackage', 'run', 'start', 'stop');
	}
	@Test
	void parseNonExistingFileThrowException() {
		assertThatExceptionOfType(RuntimeException.class)
			.isThrownBy(() -> this.parser.parse(new File('src/test/resources/nonexistent.xml')))
			.withCauseInstanceOf(FileNotFoundException.class);
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class CompoundRowTests {
	private static final String NEWLINE = System.lineSeparator();
	private static final Snippet SNIPPET = new Snippet('my', 'title', null);
	@Test
	void simpleProperty() {
		CompoundRow row = new CompoundRow(SNIPPET, 'spring.test', 'This is a description.');
		row.addProperty(new ConfigurationProperty('spring.test.first', 'java.lang.String'));
		row.addProperty(new ConfigurationProperty('spring.test.second', 'java.lang.String'));
		row.addProperty(new ConfigurationProperty('spring.test.third', 'java.lang.String'));
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test]]xref:#my.spring.test[`+spring.test.first+` +' + NEWLINE
				+ '`+spring.test.second+` +' + NEWLINE + '`+spring.test.third+` +' + NEWLINE + ']' + NEWLINE
				+ '|+++This is a description.+++' + NEWLINE + '|' + NEWLINE);
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class ConfigurationPropertiesTests {
	@Test
	void whenJsonHasAnIntegerDefaultValueThenItRemainsAnIntegerWhenRead() {
		ConfigurationProperties properties = ConfigurationProperties
			.fromFiles(Arrays.asList(new File('src/test/resources/spring-configuration-metadata.json')));
		assertThat(properties.get('example.counter').getDefaultValue()).isEqualTo(0);
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class SingleRowTests {
	private static final String NEWLINE = System.lineSeparator();
	private static final Snippet SNIPPET = new Snippet('my', 'title', null);
	@Test
	void simpleProperty() {
		ConfigurationProperty property = new ConfigurationProperty('spring.test.prop', 'java.lang.String', 'something',
				'This is a description.', false);
		SingleRow row = new SingleRow(SNIPPET, property);
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop+`]'
				+ NEWLINE + '|+++This is a description.+++' + NEWLINE + '|`+something+`' + NEWLINE);
	}
	@Test
	void noDefaultValue() {
		ConfigurationProperty property = new ConfigurationProperty('spring.test.prop', 'java.lang.String', null,
				'This is a description.', false);
		SingleRow row = new SingleRow(SNIPPET, property);
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop+`]'
				+ NEWLINE + '|+++This is a description.+++' + NEWLINE + '|' + NEWLINE);
	}
	@Test
	void defaultValueWithPipes() {
		ConfigurationProperty property = new ConfigurationProperty('spring.test.prop', 'java.lang.String',
				'first|second', 'This is a description.', false);
		SingleRow row = new SingleRow(SNIPPET, property);
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop+`]'
				+ NEWLINE + '|+++This is a description.+++' + NEWLINE + '|`+first\\|second+`' + NEWLINE);
	}
	@Test
	void defaultValueWithBackslash() {
		ConfigurationProperty property = new ConfigurationProperty('spring.test.prop', 'java.lang.String',
				'first\\second', 'This is a description.', false);
		SingleRow row = new SingleRow(SNIPPET, property);
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop+`]'
				+ NEWLINE + '|+++This is a description.+++' + NEWLINE + '|`+first\\\\second+`' + NEWLINE);
	}
	@Test
	void descriptionWithPipe() {
		ConfigurationProperty property = new ConfigurationProperty('spring.test.prop', 'java.lang.String', null,
				'This is a description with a | pipe.', false);
		SingleRow row = new SingleRow(SNIPPET, property);
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop+`]'
				+ NEWLINE + '|+++This is a description with a \\| pipe.+++' + NEWLINE + '|' + NEWLINE);
	}
	@Test
	void mapProperty() {
		ConfigurationProperty property = new ConfigurationProperty('spring.test.prop',
				'java.util.Map<java.lang.String,java.lang.String>', null, 'This is a description.', false);
		SingleRow row = new SingleRow(SNIPPET, property);
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop.*+`]'
				+ NEWLINE + '|+++This is a description.+++' + NEWLINE + '|' + NEWLINE);
	}
	@Test
	void listProperty() {
		String[] defaultValue = new String[] { 'first', 'second', 'third' };
		ConfigurationProperty property = new ConfigurationProperty('spring.test.prop',
				'java.util.List<java.lang.String>', defaultValue, 'This is a description.', false);
		SingleRow row = new SingleRow(SNIPPET, property);
		Asciidoc asciidoc = new Asciidoc();
		row.write(asciidoc);
		assertThat(asciidoc).hasToString('|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop+`]'
				+ NEWLINE + '|+++This is a description.+++' + NEWLINE + '|`+first,' + NEWLINE + 'second,' + NEWLINE
				+ 'third+`' + NEWLINE);
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class TableTests {
	private static final String NEWLINE = System.lineSeparator();
	private static final Snippet SNIPPET = new Snippet('my', 'title', null);
	@Test
	void simpleTable() {
		Table table = new Table();
		table.addRow(new SingleRow(SNIPPET, new ConfigurationProperty('spring.test.prop', 'java.lang.String',
				'something', 'This is a description.', false)));
		table.addRow(new SingleRow(SNIPPET, new ConfigurationProperty('spring.test.other', 'java.lang.String',
				'other value', 'This is another description.', false)));
		Asciidoc asciidoc = new Asciidoc();
		table.write(asciidoc);
		// @formatter:off
		assertThat(asciidoc).hasToString('[cols=\'4,3,3\', options=\'header\']' + NEWLINE +
		'|===' + NEWLINE +
		'|Name|Description|Default Value' + NEWLINE + NEWLINE +
		'|[[my.spring.test.other]]xref:#my.spring.test.other[`+spring.test.other+`]' + NEWLINE +
		'|+++This is another description.+++' + NEWLINE +
		'|`+other value+`' + NEWLINE + NEWLINE +
		'|[[my.spring.test.prop]]xref:#my.spring.test.prop[`+spring.test.prop+`]' + NEWLINE +
		'|+++This is a description.+++' + NEWLINE +
		'|`+something+`' + NEWLINE + NEWLINE +
		'|===' + NEWLINE);
		// @formatter:on
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
class ReleaseScheduleTests {
	private final RestTemplate rest = new RestTemplate();
	private final ReleaseSchedule releaseSchedule = new ReleaseSchedule(this.rest);
	private final MockRestServiceServer server = MockRestServiceServer.bindTo(this.rest).build();
	@Test
	void releasesBetween() {
		this.server
			.expect(requestTo('https://calendar.spring.io/releases?start=2023-09-01T00:00Z&end=2023-09-21T23:59Z'))
			.andRespond(withSuccess(new ClassPathResource('releases.json'), MediaType.APPLICATION_JSON));
		Map<String, List<Release>> releases = this.releaseSchedule
			.releasesBetween(OffsetDateTime.parse('2023-09-01T00:00Z'), OffsetDateTime.parse('2023-09-21T23:59Z'));
		assertThat(releases).hasSize(23);
		assertThat(releases.get('Spring Framework')).hasSize(3);
		assertThat(releases.get('Spring Boot')).hasSize(4);
		assertThat(releases.get('Spring Modulith')).hasSize(1);
		assertThat(releases.get('spring graphql')).hasSize(3);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class ArtifactVersionDependencyVersionTests {
	@Test
	void parseWhenVersionIsNotAMavenVersionShouldReturnNull() {
		assertThat(version('1.2.3.1')).isNull();
	}
	@Test
	void parseWhenVersionIsAMavenVersionShouldReturnAVersion() {
		assertThat(version('1.2.3')).isNotNull();
	}
	@Test
	void isSameMajorWhenSameMajorAndMinorShouldReturnTrue() {
		assertThat(version('1.10.2').isSameMajor(version('1.10.0'))).isTrue();
	}
	@Test
	void isSameMajorWhenSameMajorShouldReturnTrue() {
		assertThat(version('1.10.2').isSameMajor(version('1.9.0'))).isTrue();
	}
	@Test
	void isSameMajorWhenDifferentMajorShouldReturnFalse() {
		assertThat(version('2.0.2').isSameMajor(version('1.9.0'))).isFalse();
	}
	@Test
	void isSameMinorWhenSameMinorShouldReturnTrue() {
		assertThat(version('1.10.2').isSameMinor(version('1.10.1'))).isTrue();
	}
	@Test
	void isSameMinorWhenDifferentMinorShouldReturnFalse() {
		assertThat(version('1.10.2').isSameMinor(version('1.9.1'))).isFalse();
	}
	@Test
	void isSnapshotForWhenSnapshotForReleaseShouldReturnTrue() {
		assertThat(version('1.10.2-SNAPSHOT').isSnapshotFor(version('1.10.2'))).isTrue();
	}
	@Test
	void isSnapshotForWhenBuildSnapshotForReleaseShouldReturnTrue() {
		assertThat(version('1.10.2.BUILD-SNAPSHOT').isSnapshotFor(version('1.10.2.RELEASE'))).isTrue();
	}
	@Test
	void isSnapshotForWhenSnapshotForReleaseCandidateShouldReturnTrue() {
		assertThat(version('1.10.2-SNAPSHOT').isSnapshotFor(version('1.10.2-RC2'))).isTrue();
	}
	@Test
	void isSnapshotForWhenBuildSnapshotForReleaseCandidateShouldReturnTrue() {
		assertThat(version('1.10.2.BUILD-SNAPSHOT').isSnapshotFor(version('1.10.2.RC2'))).isTrue();
	}
	@Test
	void isSnapshotForWhenSnapshotForMilestoneShouldReturnTrue() {
		assertThat(version('1.10.2-SNAPSHOT').isSnapshotFor(version('1.10.2-M1'))).isTrue();
	}
	@Test
	void isSnapshotForWhenBuildSnapshotForMilestoneShouldReturnTrue() {
		assertThat(version('1.10.2.BUILD-SNAPSHOT').isSnapshotFor(version('1.10.2.M1'))).isTrue();
	}
	@Test
	void isSnapshotForWhenSnapshotForDifferentReleaseShouldReturnFalse() {
		assertThat(version('1.10.1-SNAPSHOT').isSnapshotFor(version('1.10.2'))).isFalse();
	}
	@Test
	void isSnapshotForWhenBuildSnapshotForDifferentReleaseShouldReturnTrue() {
		assertThat(version('1.10.1.BUILD-SNAPSHOT').isSnapshotFor(version('1.10.2.RELEASE'))).isFalse();
	}
	@Test
	void isSnapshotForWhenSnapshotForDifferentReleaseCandidateShouldReturnTrue() {
		assertThat(version('1.10.1-SNAPSHOT').isSnapshotFor(version('1.10.2-RC2'))).isFalse();
	}
	@Test
	void isSnapshotForWhenBuildSnapshotForDifferentReleaseCandidateShouldReturnTrue() {
		assertThat(version('1.10.1.BUILD-SNAPSHOT').isSnapshotFor(version('1.10.2.RC2'))).isFalse();
	}
	@Test
	void isSnapshotForWhenSnapshotForDifferentMilestoneShouldReturnTrue() {
		assertThat(version('1.10.1-SNAPSHOT').isSnapshotFor(version('1.10.2-M1'))).isFalse();
	}
	@Test
	void isSnapshotForWhenBuildSnapshotForDifferentMilestoneShouldReturnTrue() {
		assertThat(version('1.10.1.BUILD-SNAPSHOT').isSnapshotFor(version('1.10.2.M1'))).isFalse();
	}
	@Test
	void isSnapshotForWhenNotSnapshotShouldReturnFalse() {
		assertThat(version('1.10.1-M1').isSnapshotFor(version('1.10.1'))).isFalse();
	}
	private ArtifactVersionDependencyVersion version(String version) {
		return ArtifactVersionDependencyVersion.parse(version);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class CalendarVersionDependencyVersionTests {
	@Test
	void parseWhenVersionIsNotACalendarVersionShouldReturnNull() {
		assertThat(version('1.2.3')).isNull();
	}
	@Test
	void parseWhenVersionIsACalendarVersionShouldReturnAVersion() {
		assertThat(version('2020.0.0')).isNotNull();
	}
	@Test
	void isSameMajorWhenSameMajorAndMinorShouldReturnTrue() {
		assertThat(version('2020.0.0').isSameMajor(version('2020.0.1'))).isTrue();
	}
	@Test
	void isSameMajorWhenSameMajorShouldReturnTrue() {
		assertThat(version('2020.0.0').isSameMajor(version('2020.1.0'))).isTrue();
	}
	@Test
	void isSameMajorWhenDifferentMajorShouldReturnFalse() {
		assertThat(version('2020.0.0').isSameMajor(version('2021.0.0'))).isFalse();
	}
	@Test
	void isSameMinorWhenSameMinorShouldReturnTrue() {
		assertThat(version('2020.0.0').isSameMinor(version('2020.0.1'))).isTrue();
	}
	@Test
	void isSameMinorWhenDifferentMinorShouldReturnFalse() {
		assertThat(version('2020.0.0').isSameMinor(version('2020.1.0'))).isFalse();
	}
	@Test
	void calendarVersionIsNotSameMajorAsReleaseTrainVersion() {
		assertThat(version('2020.0.0').isSameMajor(releaseTrainVersion('Aluminium-RELEASE'))).isFalse();
	}
	@Test
	void calendarVersionIsNotSameMinorAsReleaseTrainVersion() {
		assertThat(version('2020.0.0').isSameMinor(releaseTrainVersion('Aluminium-RELEASE'))).isFalse();
	}
	private ReleaseTrainDependencyVersion releaseTrainVersion(String version) {
		return ReleaseTrainDependencyVersion.parse(version);
	}
	private CalendarVersionDependencyVersion version(String version) {
		return CalendarVersionDependencyVersion.parse(version);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class DependencyVersionTests {
	@Test
	void parseWhenValidMavenVersionShouldReturnArtifactVersionDependencyVersion() {
		assertThat(DependencyVersion.parse('1.2.3.Final')).isExactlyInstanceOf(ArtifactVersionDependencyVersion.class);
	}
	@Test
	void parseWhenReleaseTrainShouldReturnReleaseTrainDependencyVersion() {
		assertThat(DependencyVersion.parse('Ingalls-SR5')).isInstanceOf(ReleaseTrainDependencyVersion.class);
	}
	@Test
	void parseWhenMavenLikeVersionWithNumericQualifierShouldReturnNumericQualifierDependencyVersion() {
		assertThat(DependencyVersion.parse('1.2.3.4')).isInstanceOf(MultipleComponentsDependencyVersion.class);
	}
	@Test
	void parseWhen5ComponentsShouldReturnNumericQualifierDependencyVersion() {
		assertThat(DependencyVersion.parse('1.2.3.4.5')).isInstanceOf(MultipleComponentsDependencyVersion.class);
	}
	@Test
	void parseWhenVersionWithLeadingZeroesShouldReturnLeadingZeroesDependencyVersion() {
		assertThat(DependencyVersion.parse('1.4.01')).isInstanceOf(LeadingZeroesDependencyVersion.class);
	}
	@Test
	void parseWhenVersionWithCombinedPatchAndQualifierShouldReturnCombinedPatchAndQualifierDependencyVersion() {
		assertThat(DependencyVersion.parse('4.0.0M4')).isInstanceOf(CombinedPatchAndQualifierDependencyVersion.class);
	}
	@Test
	void parseWhenCalendarVersionShouldReturnArtifactVersionDependencyVersion() {
		assertThat(DependencyVersion.parse('2020.0.0')).isInstanceOf(CalendarVersionDependencyVersion.class);
	}
	@Test
	void parseWhenCalendarVersionWithModifierShouldReturnArtifactVersionDependencyVersion() {
		assertThat(DependencyVersion.parse('2020.0.0-M1')).isInstanceOf(CalendarVersionDependencyVersion.class);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class ReleaseTrainDependencyVersionTests {
	@Test
	void parsingOfANonReleaseTrainVersionReturnsNull() {
		assertThat(version('5.1.4.RELEASE')).isNull();
	}
	@Test
	void parsingOfAReleaseTrainVersionReturnsVersion() {
		assertThat(version('Lovelace-SR3')).isNotNull();
	}
	@Test
	void isSameMajorWhenReleaseTrainIsDifferentShouldReturnFalse() {
		assertThat(version('Lovelace-RELEASE').isSameMajor(version('Kay-SR5'))).isFalse();
	}
	@Test
	void isSameMajorWhenReleaseTrainIsTheSameShouldReturnTrue() {
		assertThat(version('Lovelace-RELEASE').isSameMajor(version('Lovelace-SR5'))).isTrue();
	}
	@Test
	void isSameMinorWhenReleaseTrainIsDifferentShouldReturnFalse() {
		assertThat(version('Lovelace-RELEASE').isSameMajor(version('Kay-SR5'))).isFalse();
	}
	@Test
	void isSameMinorWhenReleaseTrainIsTheSameShouldReturnTrue() {
		assertThat(version('Lovelace-RELEASE').isSameMajor(version('Lovelace-SR5'))).isTrue();
	}
	@Test
	void releaseTrainVersionIsNotSameMajorAsCalendarTrainVersion() {
		assertThat(version('Kay-SR6').isSameMajor(calendarVersion('2020.0.0'))).isFalse();
	}
	@Test
	void releaseTrainVersionIsNotSameMinorAsCalendarVersion() {
		assertThat(version('Kay-SR6').isSameMinor(calendarVersion('2020.0.0'))).isFalse();
	}
	@Test
	void isSnapshotForWhenSnapshotForServiceReleaseShouldReturnTrue() {
		assertThat(version('Kay-BUILD-SNAPSHOT').isSnapshotFor(version('Kay-SR2'))).isTrue();
	}
	@Test
	void isSnapshotForWhenSnapshotForReleaseShouldReturnTrue() {
		assertThat(version('Kay-BUILD-SNAPSHOT').isSnapshotFor(version('Kay-RELEASE'))).isTrue();
	}
	@Test
	void isSnapshotForWhenSnapshotForReleaseCandidateShouldReturnTrue() {
		assertThat(version('Kay-BUILD-SNAPSHOT').isSnapshotFor(version('Kay-RC1'))).isTrue();
	}
	@Test
	void isSnapshotForWhenSnapshotForMilestoneShouldReturnTrue() {
		assertThat(version('Kay-BUILD-SNAPSHOT').isSnapshotFor(version('Kay-M2'))).isTrue();
	}
	@Test
	void isSnapshotForWhenSnapshotForDifferentReleaseShouldReturnFalse() {
		assertThat(version('Kay-BUILD-SNAPSHOT').isSnapshotFor(version('Lovelace-RELEASE'))).isFalse();
	}
	@Test
	void isSnapshotForWhenSnapshotForDifferentReleaseCandidateShouldReturnTrue() {
		assertThat(version('Kay-BUILD-SNAPSHOT').isSnapshotFor(version('Lovelace-RC2'))).isFalse();
	}
	@Test
	void isSnapshotForWhenSnapshotForDifferentMilestoneShouldReturnTrue() {
		assertThat(version('Kay-BUILD-SNAPSHOT').isSnapshotFor(version('Lovelace-M1'))).isFalse();
	}
	@Test
	void isSnapshotForWhenNotSnapshotShouldReturnFalse() {
		assertThat(version('Kay-M1').isSnapshotFor(version('Kay-RELEASE'))).isFalse();
	}
	private static ReleaseTrainDependencyVersion version(String input) {
		return ReleaseTrainDependencyVersion.parse(input);
	}
	private CalendarVersionDependencyVersion calendarVersion(String version) {
		return CalendarVersionDependencyVersion.parse(version);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class MultipleComponentsDependencyVersionTests {
	@Test
	void isSameMajorOfFiveComponentVersionWithSameMajorShouldReturnTrue() {
		assertThat(version('21.4.0.0.1').isSameMajor(version('21.1.0.0'))).isTrue();
	}
	@Test
	void isSameMajorOfFiveComponentVersionWithDifferentMajorShouldReturnFalse() {
		assertThat(version('21.4.0.0.1').isSameMajor(version('22.1.0.0'))).isFalse();
	}
	@Test
	void isSameMinorOfFiveComponentVersionWithSameMinorShouldReturnTrue() {
		assertThat(version('21.4.0.0.1').isSameMinor(version('21.4.0.0'))).isTrue();
	}
	@Test
	void isSameMinorOfFiveComponentVersionWithDifferentMinorShouldReturnFalse() {
		assertThat(version('21.4.0.0.1').isSameMinor(version('21.5.0.0'))).isFalse();
	}
	private MultipleComponentsDependencyVersion version(String version) {
		return MultipleComponentsDependencyVersion.parse(version);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class DependencyVersionUpgradeTests {
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3', candidate = '1.2.3')
	@ArtifactVersion(current = '1.2.3.RELEASE', candidate = '1.2.3.RELEASE')
	@CalendarVersion(current = '2023.0.0', candidate = '2023.0.0')
	@ReleaseTrain(current = 'Kay-RELEASE', candidate = 'Kay-RELEASE')
	void isUpgradeWhenSameVersionShouldReturnFalse(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isFalse();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-SNAPSHOT', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.BUILD-SNAPSHOT', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0-SNAPSHOT', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-BUILD-SNAPSHOT', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenSameSnapshotVersionShouldReturnFalse(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isFalse();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-SNAPSHOT', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.BUILD-SNAPSHOT', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0-SNAPSHOT', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-BUILD-SNAPSHOT', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenSameSnapshotVersionAndMovingToSnapshotsShouldReturnFalse(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, true)).isFalse();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3', candidate = '1.2.4')
	@ArtifactVersion(current = '1.2.3.RELEASE', candidate = '1.2.4.RELEASE')
	@CalendarVersion(current = '2023.0.0', candidate = '2023.0.1')
	@ReleaseTrain(current = 'Kay-RELEASE', candidate = 'Kay-SR1')
	void isUpgradeWhenLaterPatchReleaseShouldReturnTrue(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3', candidate = '1.2.4-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.RELEASE', candidate = '1.2.4.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0', candidate = '2023.0.1-SNAPSHOT')
	void isUpgradeWhenSnapshotOfLaterPatchReleaseShouldReturnTrue(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3', candidate = '1.2.4-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.RELEASE', candidate = '1.2.4.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0', candidate = '2023.0.1-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-RELEASE', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenSnapshotOfLaterPatchReleaseAndMovingToSnapshotsShouldReturnTrue(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, true)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.RELEASE', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-RELEASE', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenSnapshotOfSameVersionShouldReturnFalse(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isFalse();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-SNAPSHOT', candidate = '1.2.3-M2')
	@ArtifactVersion(current = '1.2.3.BUILD-SNAPSHOT', candidate = '1.2.3.M2')
	@CalendarVersion(current = '2023.0.0-SNAPSHOT', candidate = '2023.0.0-M2')
	@ReleaseTrain(current = 'Kay-BUILD-SNAPSHOT', candidate = 'Kay-M2')
	void isUpgradeWhenSnapshotToMilestoneShouldReturnTrue(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-SNAPSHOT', candidate = '1.2.3-RC1')
	@ArtifactVersion(current = '1.2.3.BUILD-SNAPSHOT', candidate = '1.2.3.RC1')
	@CalendarVersion(current = '2023.0.0-SNAPSHOT', candidate = '2023.0.0-RC1')
	@ReleaseTrain(current = 'Kay-BUILD-SNAPSHOT', candidate = 'Kay-RC1')
	void isUpgradeWhenSnapshotToReleaseCandidateShouldReturnTrue(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-SNAPSHOT', candidate = '1.2.3')
	@ArtifactVersion(current = '1.2.3.BUILD-SNAPSHOT', candidate = '1.2.3.RELEASE')
	@CalendarVersion(current = '2023.0.0-SNAPSHOT', candidate = '2023.0.0')
	@ReleaseTrain(current = 'Kay-BUILD-SNAPSHOT', candidate = 'Kay-RELEASE')
	void isUpgradeWhenSnapshotToReleaseShouldReturnTrue(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-M1', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.M1', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0-M1', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-M1', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenMilestoneToSnapshotShouldReturnFalse(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isFalse();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-RC1', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.RC1', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0-RC1', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-RC1', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenReleaseCandidateToSnapshotShouldReturnFalse(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isFalse();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.RELEASE', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-RELEASE', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenReleaseToSnapshotShouldReturnFalse(DependencyVersion current, DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, false)).isFalse();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-M1', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.M1', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0-M1', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-M1', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenMilestoneToSnapshotAndMovingToSnapshotsShouldReturnTrue(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, true)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3-RC1', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.RC1', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0-RC1', candidate = '2023.0.0-SNAPSHOT')
	@ReleaseTrain(current = 'Kay-RC1', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenReleaseCandidateToSnapshotAndMovingToSnapshotsShouldReturnTrue(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, true)).isTrue();
	}
	@ParameterizedTest
	@ArtifactVersion(current = '1.2.3', candidate = '1.2.3-SNAPSHOT')
	@ArtifactVersion(current = '1.2.3.RELEASE', candidate = '1.2.3.BUILD-SNAPSHOT')
	@CalendarVersion(current = '2023.0.0', candidate = '2023.0.0-SNAPSHOT')
	void isUpgradeWhenReleaseToSnapshotAndMovingToSnapshotsShouldReturnFalse(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, true)).isFalse();
	}
	@ParameterizedTest
	@ReleaseTrain(current = 'Kay-RELEASE', candidate = 'Kay-BUILD-SNAPSHOT')
	void isUpgradeWhenReleaseTrainToSnapshotAndMovingToSnapshotsShouldReturnTrue(DependencyVersion current,
			DependencyVersion candidate) {
		assertThat(current.isUpgrade(candidate, true)).isTrue();
	}
	@Repeatable(ArtifactVersions.class)
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.RUNTIME)
	@ArgumentsSource(InputProvider.class)
	@interface ArtifactVersion {
		String current();
		String candidate();
	}
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.RUNTIME)
	@interface ArtifactVersions {
		ArtifactVersion[] value();
	}
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.RUNTIME)
	@ArgumentsSource(InputProvider.class)
	@interface ReleaseTrain {
		String current();
		String candidate();
	}
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.RUNTIME)
	@ArgumentsSource(InputProvider.class)
	@interface CalendarVersion {
		String current();
		String candidate();
	}
	static class InputProvider implements ArgumentsProvider {
		@Override
		public Stream<? extends Arguments> provideArguments(ExtensionContext context) {
			Method testMethod = context.getRequiredTestMethod();
			Stream<Arguments> artifactVersions = artifactVersions(testMethod)
				.map((artifactVersion) -> Arguments.of(VersionType.ARTIFACT_VERSION.parse(artifactVersion.current()),
						VersionType.ARTIFACT_VERSION.parse(artifactVersion.candidate())));
			Stream<Arguments> releaseTrains = releaseTrains(testMethod)
				.map((releaseTrain) -> Arguments.of(VersionType.RELEASE_TRAIN.parse(releaseTrain.current()),
						VersionType.RELEASE_TRAIN.parse(releaseTrain.candidate())));
			Stream<Arguments> calendarVersions = calendarVersions(testMethod)
				.map((calendarVersion) -> Arguments.of(VersionType.CALENDAR_VERSION.parse(calendarVersion.current()),
						VersionType.CALENDAR_VERSION.parse(calendarVersion.candidate())));
			return Stream.concat(Stream.concat(artifactVersions, releaseTrains), calendarVersions);
		}
		private Stream<ArtifactVersion> artifactVersions(Method testMethod) {
			ArtifactVersions artifactVersions = testMethod.getAnnotation(ArtifactVersions.class);
			if (artifactVersions != null) {
				return Stream.of(artifactVersions.value());
			}
			return versions(testMethod, ArtifactVersion.class);
		}
		private Stream<ReleaseTrain> releaseTrains(Method testMethod) {
			return versions(testMethod, ReleaseTrain.class);
		}
		private Stream<CalendarVersion> calendarVersions(Method testMethod) {
			return versions(testMethod, CalendarVersion.class);
		}
		private <T extends Annotation> Stream<T> versions(Method testMethod, Class<T> type) {
			T annotation = testMethod.getAnnotation(type);
			return (annotation != null) ? Stream.of(annotation) : Stream.empty();
		}
	}
	enum VersionType {
		ARTIFACT_VERSION(ArtifactVersionDependencyVersion::parse),
		CALENDAR_VERSION(CalendarVersionDependencyVersion::parse),
		RELEASE_TRAIN(ReleaseTrainDependencyVersion::parse);
		private final Function<String, DependencyVersion> parser;
		VersionType(Function<String, DependencyVersion> parser) {
			this.parser = parser;
		}
		DependencyVersion parse(String version) {
			return this.parser.apply(version);
		}
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
class UpgradeApplicatorTests {
	@TempDir
	File temp;
	@Test
	void whenUpgradeIsAppliedToLibraryWithVersionThenBomIsUpdated() throws IOException {
		File bom = new File(this.temp, 'bom.gradle');
		FileCopyUtils.copy(new File('src/test/resources/bom.gradle'), bom);
		String originalContents = Files.readString(bom.toPath());
		File gradleProperties = new File(this.temp, 'gradle.properties');
		FileCopyUtils.copy(new File('src/test/resources/gradle.properties'), gradleProperties);
		new UpgradeApplicator(bom.toPath(), gradleProperties.toPath()).apply(
				new Upgrade(
						new Library('ActiveMQ', null, new LibraryVersion(DependencyVersion.parse('5.15.11')), null,
								null, false, null, null, null, Collections.emptyMap()),
						DependencyVersion.parse('5.16')));
		String bomContents = Files.readString(bom.toPath());
		assertThat(bomContents).hasSize(originalContents.length() - 3);
	}
	@Test
	void whenUpgradeIsAppliedToLibraryWithVersionPropertyThenGradlePropertiesIsUpdated() throws IOException {
		File bom = new File(this.temp, 'bom.gradle');
		FileCopyUtils.copy(new File('src/test/resources/bom.gradle'), bom);
		File gradleProperties = new File(this.temp, 'gradle.properties');
		FileCopyUtils.copy(new File('src/test/resources/gradle.properties'), gradleProperties);
		new UpgradeApplicator(bom.toPath(), gradleProperties.toPath())
			.apply(new Upgrade(new Library('Kotlin', null, new LibraryVersion(DependencyVersion.parse('1.3.70')), null,
					null, false, null, null, null, Collections.emptyMap()), DependencyVersion.parse('1.4')));
		Properties properties = new Properties();
		try (InputStream in = new FileInputStream(gradleProperties)) {
			properties.load(in);
		}
		assertThat(properties).containsOnly(entry('a', 'alpha'), entry('b', 'bravo'), entry('kotlinVersion', '1.4'),
				entry('t', 'tango'));
	}
}
/*
package org.springframework.boot.build.bom;
/**
class BomPluginIntegrationTests {
	private File projectDir;
	private File buildFile;
	@BeforeEach
	void setup(@TempDir File projectDir) {
		this.projectDir = projectDir;
		this.buildFile = new File(this.projectDir, 'build.gradle');
	}
	@Test
	void libraryModulesAreIncludedInDependencyManagementOfGeneratedPom() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.bom"');
			out.println('}');
			out.println('bom {');
			out.println('    library("ActiveMQ", "5.15.10") {');
			out.println('        group("org.apache.activemq") {');
			out.println('            modules = [');
			out.println('                "activemq-amqp",');
			out.println('                "activemq-blueprint"');
			out.println('            ]');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		generatePom((pom) -> {
			assertThat(pom).textAtPath('//properties/activemq.version').isEqualTo('5.15.10');
			NodeAssert dependency = pom.nodeAtPath('//dependencyManagement/dependencies/dependency[1]');
			assertThat(dependency).textAtPath('groupId').isEqualTo('org.apache.activemq');
			assertThat(dependency).textAtPath('artifactId').isEqualTo('activemq-amqp');
			assertThat(dependency).textAtPath('version').isEqualTo('${activemq.version}');
			assertThat(dependency).textAtPath('scope').isNullOrEmpty();
			assertThat(dependency).textAtPath('type').isNullOrEmpty();
			assertThat(dependency).textAtPath('classifier').isNullOrEmpty();
			dependency = pom.nodeAtPath('//dependencyManagement/dependencies/dependency[2]');
			assertThat(dependency).textAtPath('groupId').isEqualTo('org.apache.activemq');
			assertThat(dependency).textAtPath('artifactId').isEqualTo('activemq-blueprint');
			assertThat(dependency).textAtPath('version').isEqualTo('${activemq.version}');
			assertThat(dependency).textAtPath('scope').isNullOrEmpty();
			assertThat(dependency).textAtPath('type').isNullOrEmpty();
			assertThat(dependency).textAtPath('classifier').isNullOrEmpty();
		});
	}
	@Test
	void libraryPluginsAreIncludedInPluginManagementOfGeneratedPom() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.bom"');
			out.println('}');
			out.println('bom {');
			out.println('    library("Flyway", "6.0.8") {');
			out.println('        group("org.flywaydb") {');
			out.println('            plugins = [');
			out.println('                "flyway-maven-plugin"');
			out.println('            ]');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		generatePom((pom) -> {
			assertThat(pom).textAtPath('//properties/flyway.version').isEqualTo('6.0.8');
			NodeAssert plugin = pom.nodeAtPath('//pluginManagement/plugins/plugin');
			assertThat(plugin).textAtPath('groupId').isEqualTo('org.flywaydb');
			assertThat(plugin).textAtPath('artifactId').isEqualTo('flyway-maven-plugin');
			assertThat(plugin).textAtPath('version').isEqualTo('${flyway.version}');
			assertThat(plugin).textAtPath('scope').isNullOrEmpty();
			assertThat(plugin).textAtPath('type').isNullOrEmpty();
		});
	}
	@Test
	void libraryImportsAreIncludedInDependencyManagementOfGeneratedPom() throws Exception {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.bom"');
			out.println('}');
			out.println('bom {');
			out.println('    library("Jackson Bom", "2.10.0") {');
			out.println('        group("com.fasterxml.jackson") {');
			out.println('            imports = [');
			out.println('                "jackson-bom"');
			out.println('            ]');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		generatePom((pom) -> {
			assertThat(pom).textAtPath('//properties/jackson-bom.version').isEqualTo('2.10.0');
			NodeAssert dependency = pom.nodeAtPath('//dependencyManagement/dependencies/dependency');
			assertThat(dependency).textAtPath('groupId').isEqualTo('com.fasterxml.jackson');
			assertThat(dependency).textAtPath('artifactId').isEqualTo('jackson-bom');
			assertThat(dependency).textAtPath('version').isEqualTo('${jackson-bom.version}');
			assertThat(dependency).textAtPath('scope').isEqualTo('import');
			assertThat(dependency).textAtPath('type').isEqualTo('pom');
			assertThat(dependency).textAtPath('classifier').isNullOrEmpty();
		});
	}
	@Test
	void moduleExclusionsAreIncludedInDependencyManagementOfGeneratedPom() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.bom"');
			out.println('}');
			out.println('bom {');
			out.println('    library("MySQL", "8.0.18") {');
			out.println('        group("mysql") {');
			out.println('            modules = [');
			out.println('                "mysql-connector-java" {');
			out.println('                    exclude group: "com.google.protobuf", module: "protobuf-java"');
			out.println('                }');
			out.println('            ]');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		generatePom((pom) -> {
			assertThat(pom).textAtPath('//properties/mysql.version').isEqualTo('8.0.18');
			NodeAssert dependency = pom.nodeAtPath('//dependencyManagement/dependencies/dependency');
			assertThat(dependency).textAtPath('groupId').isEqualTo('mysql');
			assertThat(dependency).textAtPath('artifactId').isEqualTo('mysql-connector-java');
			assertThat(dependency).textAtPath('version').isEqualTo('${mysql.version}');
			assertThat(dependency).textAtPath('scope').isNullOrEmpty();
			assertThat(dependency).textAtPath('type').isNullOrEmpty();
			assertThat(dependency).textAtPath('classifier').isNullOrEmpty();
			NodeAssert exclusion = dependency.nodeAtPath('exclusions/exclusion');
			assertThat(exclusion).textAtPath('groupId').isEqualTo('com.google.protobuf');
			assertThat(exclusion).textAtPath('artifactId').isEqualTo('protobuf-java');
		});
	}
	@Test
	void moduleTypesAreIncludedInDependencyManagementOfGeneratedPom() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.bom"');
			out.println('}');
			out.println('bom {');
			out.println('    library("Elasticsearch", "7.15.2") {');
			out.println('        group("org.elasticsearch.distribution.integ-test-zip") {');
			out.println('            modules = [');
			out.println('                "elasticsearch" {');
			out.println('                    type = "zip"');
			out.println('                }');
			out.println('            ]');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		generatePom((pom) -> {
			assertThat(pom).textAtPath('//properties/elasticsearch.version').isEqualTo('7.15.2');
			NodeAssert dependency = pom.nodeAtPath('//dependencyManagement/dependencies/dependency');
			assertThat(dependency).textAtPath('groupId').isEqualTo('org.elasticsearch.distribution.integ-test-zip');
			assertThat(dependency).textAtPath('artifactId').isEqualTo('elasticsearch');
			assertThat(dependency).textAtPath('version').isEqualTo('${elasticsearch.version}');
			assertThat(dependency).textAtPath('scope').isNullOrEmpty();
			assertThat(dependency).textAtPath('type').isEqualTo('zip');
			assertThat(dependency).textAtPath('classifier').isNullOrEmpty();
			assertThat(dependency).nodeAtPath('exclusions').isNull();
		});
	}
	@Test
	void moduleClassifiersAreIncludedInDependencyManagementOfGeneratedPom() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.bom"');
			out.println('}');
			out.println('bom {');
			out.println('    library("Kafka", "2.7.2") {');
			out.println('        group("org.apache.kafka") {');
			out.println('            modules = [');
			out.println('                "connect-api",');
			out.println('                "generator",');
			out.println('                "generator" {');
			out.println('                    classifier = "test"');
			out.println('                },');
			out.println('                "kafka-tools",');
			out.println('            ]');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		generatePom((pom) -> {
			assertThat(pom).textAtPath('//properties/kafka.version').isEqualTo('2.7.2');
			NodeAssert connectApi = pom.nodeAtPath('//dependencyManagement/dependencies/dependency[1]');
			assertThat(connectApi).textAtPath('groupId').isEqualTo('org.apache.kafka');
			assertThat(connectApi).textAtPath('artifactId').isEqualTo('connect-api');
			assertThat(connectApi).textAtPath('version').isEqualTo('${kafka.version}');
			assertThat(connectApi).textAtPath('scope').isNullOrEmpty();
			assertThat(connectApi).textAtPath('type').isNullOrEmpty();
			assertThat(connectApi).textAtPath('classifier').isNullOrEmpty();
			assertThat(connectApi).nodeAtPath('exclusions').isNull();
			NodeAssert generator = pom.nodeAtPath('//dependencyManagement/dependencies/dependency[2]');
			assertThat(generator).textAtPath('groupId').isEqualTo('org.apache.kafka');
			assertThat(generator).textAtPath('artifactId').isEqualTo('generator');
			assertThat(generator).textAtPath('version').isEqualTo('${kafka.version}');
			assertThat(generator).textAtPath('scope').isNullOrEmpty();
			assertThat(generator).textAtPath('type').isNullOrEmpty();
			assertThat(generator).textAtPath('classifier').isNullOrEmpty();
			assertThat(generator).nodeAtPath('exclusions').isNull();
			NodeAssert generatorTest = pom.nodeAtPath('//dependencyManagement/dependencies/dependency[3]');
			assertThat(generatorTest).textAtPath('groupId').isEqualTo('org.apache.kafka');
			assertThat(generatorTest).textAtPath('artifactId').isEqualTo('generator');
			assertThat(generatorTest).textAtPath('version').isEqualTo('${kafka.version}');
			assertThat(generatorTest).textAtPath('scope').isNullOrEmpty();
			assertThat(generatorTest).textAtPath('type').isNullOrEmpty();
			assertThat(generatorTest).textAtPath('classifier').isEqualTo('test');
			assertThat(generatorTest).nodeAtPath('exclusions').isNull();
			NodeAssert kafkaTools = pom.nodeAtPath('//dependencyManagement/dependencies/dependency[4]');
			assertThat(kafkaTools).textAtPath('groupId').isEqualTo('org.apache.kafka');
			assertThat(kafkaTools).textAtPath('artifactId').isEqualTo('kafka-tools');
			assertThat(kafkaTools).textAtPath('version').isEqualTo('${kafka.version}');
			assertThat(kafkaTools).textAtPath('scope').isNullOrEmpty();
			assertThat(kafkaTools).textAtPath('type').isNullOrEmpty();
			assertThat(kafkaTools).textAtPath('classifier').isNullOrEmpty();
			assertThat(kafkaTools).nodeAtPath('exclusions').isNull();
		});
	}
	@Test
	void libraryNamedSpringBootHasNoVersionProperty() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "org.springframework.boot.bom"');
			out.println('}');
			out.println('bom {');
			out.println('    library("Spring Boot", "1.2.3") {');
			out.println('        group("org.springframework.boot") {');
			out.println('            modules = [');
			out.println('                "spring-boot"');
			out.println('            ]');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		generatePom((pom) -> {
			assertThat(pom).textAtPath('//properties/spring-boot.version').isEmpty();
			NodeAssert dependency = pom.nodeAtPath('//dependencyManagement/dependencies/dependency[1]');
			assertThat(dependency).textAtPath('groupId').isEqualTo('org.springframework.boot');
			assertThat(dependency).textAtPath('artifactId').isEqualTo('spring-boot');
			assertThat(dependency).textAtPath('version').isEqualTo('1.2.3');
			assertThat(dependency).textAtPath('scope').isNullOrEmpty();
			assertThat(dependency).textAtPath('type').isNullOrEmpty();
		});
	}
	// @Test
	// void versionAlignmentIsVerified() throws IOException {
	// try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
	// out.println('plugins {');
	// out.println(' id "org.springframework.boot.bom"');
	// out.println('}');
	// out.println('bom {');
	// out.println(' library("OAuth2 OIDC SDK", "8.36.1") {');
	// out.println(' alignedWith("Spring Security") {');
	// out.println(
	// '
	// source("https://github.com/spring-projects/spring-security/blob/${libraryVersion}/config/gradle/dependency-locks/optional.lockfile")');
	// out.println(' pattern("com.nimbusds:oauth2-oidc-sdk:(.+)")');
	// out.println(' }');
	// out.println(' group("com.nimbusds") {');
	// out.println(' modules = [');
	// out.println(' "oauth2-oidc-sdk"');
	// out.println(' ]');
	// out.println(' }');
	// out.println(' }');
	// out.println(' library("Spring Security", "5.4.7") {');
	// out.println(' }');
	// out.println('}');
	// }
	// System.out.println(runGradle(DeployedPlugin.GENERATE_POM_TASK_NAME,
	// '-s').getOutput());
	// }
	private BuildResult runGradle(String... args) {
		return GradleRunner.create()
			.withDebug(true)
			.withProjectDir(this.projectDir)
			.withArguments(args)
			.withPluginClasspath()
			.build();
	}
	private void generatePom(Consumer<NodeAssert> consumer) {
		runGradle(DeployedPlugin.GENERATE_POM_TASK_NAME, '-s');
		File generatedPomXml = new File(this.projectDir, 'build/publications/maven/pom-default.xml');
		assertThat(generatedPomXml).isFile();
		consumer.accept(new NodeAssert(generatedPomXml));
	}
}
/*
package org.springframework.boot.build.bom;
/**
class LibraryTests {
	@Test
	void getLinkRootNameWhenNoneSpecified() {
		String name = 'Spring Framework';
		String calendarName = null;
		LibraryVersion version = new LibraryVersion(DependencyVersion.parse('1.2.3'));
		List<Group> groups = Collections.emptyList();
		List<ProhibitedVersion> prohibitedVersion = Collections.emptyList();
		boolean considerSnapshots = false;
		VersionAlignment versionAlignment = null;
		String alignsWithBom = null;
		String linkRootName = null;
		Map<String, Function<LibraryVersion, String>> links = Collections.emptyMap();
		Library library = new Library(name, calendarName, version, groups, prohibitedVersion, considerSnapshots,
				versionAlignment, alignsWithBom, linkRootName, links);
		assertThat(library.getLinkRootName()).isEqualTo('spring-framework');
	}
	@Test
	void getLinkRootNameWhenSpecified() {
		String name = 'Spring Data BOM';
		String calendarName = null;
		LibraryVersion version = new LibraryVersion(DependencyVersion.parse('1.2.3'));
		List<Group> groups = Collections.emptyList();
		List<ProhibitedVersion> prohibitedVersion = Collections.emptyList();
		boolean considerSnapshots = false;
		VersionAlignment versionAlignment = null;
		String alignsWithBom = null;
		String linkRootName = 'spring-data';
		Map<String, Function<LibraryVersion, String>> links = Collections.emptyMap();
		Library library = new Library(name, calendarName, version, groups, prohibitedVersion, considerSnapshots,
				versionAlignment, alignsWithBom, linkRootName, links);
		assertThat(library.getLinkRootName()).isEqualTo('spring-data');
	}
	@Test
	void toMajorMinorGenerationWithRelease() {
		LibraryVersion version = new LibraryVersion(DependencyVersion.parse('1.2.3'));
		assertThat(version.forMajorMinorGeneration()).isEqualTo('1.2.x');
	}
	@Test
	void toMajorMinorGenerationWithSnapshot() {
		LibraryVersion version = new LibraryVersion(DependencyVersion.parse('2.0.0-SNAPSHOT'));
		assertThat(version.forMajorMinorGeneration()).isEqualTo('2.0.x-SNAPSHOT');
	}
}
/*
package org.springframework.boot.build.antora;
/**
class AntoraAsciidocAttributesTests {
	@Test
	void buildTypeWhenOpenSource() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.OPEN_SOURCE, null,
				mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('build-type', 'opensource');
	}
	@Test
	void buildTypeWhenCommercial() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.COMMERCIAL, null,
				mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('build-type', 'commercial');
	}
	@Test
	void githubRefWhenReleasedVersionIsTag() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.OPEN_SOURCE, null,
				mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('github-ref', 'v1.2.3');
	}
	@Test
	void githubRefWhenLatestSnapshotVersionIsMainBranch() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-SNAPSHOT', true,
				BuildType.OPEN_SOURCE, null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('github-ref', 'main');
	}
	@Test
	void githubRefWhenOlderSnapshotVersionIsBranch() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-SNAPSHOT', false,
				BuildType.OPEN_SOURCE, null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('github-ref', '1.2.x');
	}
	@Test
	void githubRefWhenOlderSnapshotHotFixVersionIsBranch() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3.1-SNAPSHOT', false,
				BuildType.OPEN_SOURCE, null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('github-ref', '1.2.3.x');
	}
	@Test
	void versionReferenceFromLibrary() {
		Library library = mockLibrary(Collections.emptyMap());
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3.1-SNAPSHOT', false,
				BuildType.OPEN_SOURCE, List.of(library), mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('version-spring-framework', '1.2.3');
	}
	@Test
	void versionReferenceFromSpringDataDependencyReleaseVersion() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.OPEN_SOURCE, null,
				mockDependencyVersions('3.2.5'), null);
		assertThat(attributes.get()).containsEntry('version-spring-data-mongodb-docs', '3.2');
		assertThat(attributes.get()).containsEntry('version-spring-data-mongodb-javadoc', '3.2.x');
	}
	@Test
	void versionReferenceFromSpringDataDependencySnapshotVersion() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.OPEN_SOURCE, null,
				mockDependencyVersions('3.2.0-SNAPSHOT'), null);
		assertThat(attributes.get()).containsEntry('version-spring-data-mongodb-docs', '3.2-SNAPSHOT');
		assertThat(attributes.get()).containsEntry('version-spring-data-mongodb-javadoc', '3.2.x');
	}
	@Test
	void versionNativeBuildTools() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.OPEN_SOURCE, null,
				mockDependencyVersions(), Map.of('nativeBuildToolsVersion', '3.4.5'));
		assertThat(attributes.get()).containsEntry('version-native-build-tools', '3.4.5');
	}
	@Test
	void urlArtifactRepositoryWhenRelease() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.OPEN_SOURCE, null,
				mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('url-artifact-repository', 'https://repo.maven.apache.org/maven2');
	}
	@Test
	void urlArtifactRepositoryWhenMilestone() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-M1', true, BuildType.OPEN_SOURCE,
				null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('url-artifact-repository', 'https://repo.spring.io/milestone');
	}
	@Test
	void urlArtifactRepositoryWhenSnapshot() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-SNAPSHOT', true,
				BuildType.OPEN_SOURCE, null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('url-artifact-repository', 'https://repo.spring.io/snapshot');
	}
	@Test
	void artifactReleaseTypeWhenOpenSourceRelease() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.OPEN_SOURCE, null,
				mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('artifact-release-type', 'release');
		assertThat(attributes.get()).containsEntry('build-and-artifact-release-type', 'opensource-release');
	}
	@Test
	void artifactReleaseTypeWhenOpenSourceMilestone() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-M1', true, BuildType.OPEN_SOURCE,
				null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('artifact-release-type', 'milestone');
		assertThat(attributes.get()).containsEntry('build-and-artifact-release-type', 'opensource-milestone');
	}
	@Test
	void artifactReleaseTypeWhenOpenSourceSnapshot() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-SNAPSHOT', true,
				BuildType.OPEN_SOURCE, null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('artifact-release-type', 'snapshot');
		assertThat(attributes.get()).containsEntry('build-and-artifact-release-type', 'opensource-snapshot');
	}
	@Test
	void artifactReleaseTypeWhenCommercialRelease() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3', true, BuildType.COMMERCIAL, null,
				mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('artifact-release-type', 'release');
		assertThat(attributes.get()).containsEntry('build-and-artifact-release-type', 'commercial-release');
	}
	@Test
	void artifactReleaseTypeWhenCommercialMilestone() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-M1', true, BuildType.COMMERCIAL, null,
				mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('artifact-release-type', 'milestone');
		assertThat(attributes.get()).containsEntry('build-and-artifact-release-type', 'commercial-milestone');
	}
	@Test
	void artifactReleaseTypeWhenCommercialSnapshot() {
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3-SNAPSHOT', true, BuildType.COMMERCIAL,
				null, mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('artifact-release-type', 'snapshot');
		assertThat(attributes.get()).containsEntry('build-and-artifact-release-type', 'commercial-snapshot');
	}
	@Test
	void urlLinksFromLibrary() {
		Map<String, Function<LibraryVersion, String>> links = new LinkedHashMap<>();
		links.put('site', (version) -> 'https://example.com/site/' + version);
		links.put('docs', (version) -> 'https://example.com/docs/' + version);
		Library library = mockLibrary(links);
		AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes('1.2.3.1-SNAPSHOT', false,
				BuildType.OPEN_SOURCE, List.of(library), mockDependencyVersions(), null);
		assertThat(attributes.get()).containsEntry('url-spring-framework-site', 'https://example.com/site/1.2.3')
			.containsEntry('url-spring-framework-docs', 'https://example.com/docs/1.2.3');
	}
	@Test
	void linksFromProperties() {
		Map<String, String> attributes = new AntoraAsciidocAttributes('1.2.3-SNAPSHOT', true, BuildType.OPEN_SOURCE,
				null, mockDependencyVersions(), null)
			.get();
		assertThat(attributes).containsEntry('include-java', 'ROOT:example$java/org/springframework/boot/docs');
		assertThat(attributes).containsEntry('url-spring-data-cassandra-site',
				'https://spring.io/projects/spring-data-cassandra');
		List<String> keys = new ArrayList<>(attributes.keySet());
		assertThat(keys.indexOf('include-java')).isLessThan(keys.indexOf('code-spring-boot-latest'));
	}
	private Library mockLibrary(Map<String, Function<LibraryVersion, String>> links) {
		String name = 'Spring Framework';
		String calendarName = null;
		LibraryVersion version = new LibraryVersion(DependencyVersion.parse('1.2.3'));
		List<Group> groups = Collections.emptyList();
		List<ProhibitedVersion> prohibitedVersion = Collections.emptyList();
		boolean considerSnapshots = false;
		VersionAlignment versionAlignment = null;
		String alignsWithBom = null;
		String linkRootName = null;
		Library library = new Library(name, calendarName, version, groups, prohibitedVersion, considerSnapshots,
				versionAlignment, alignsWithBom, linkRootName, links);
		return library;
	}
	private Map<String, String> mockDependencyVersions() {
		return mockDependencyVersions('1.2.3');
	}
	private Map<String, String> mockDependencyVersions(String version) {
		Map<String, String> versions = new LinkedHashMap<>();
		addMockSpringDataVersion(versions, 'spring-data-commons', version);
		addMockSpringDataVersion(versions, 'spring-data-cassandra', version);
		addMockSpringDataVersion(versions, 'spring-data-couchbase', version);
		addMockSpringDataVersion(versions, 'spring-data-elasticsearch', version);
		addMockSpringDataVersion(versions, 'spring-data-jdbc', version);
		addMockSpringDataVersion(versions, 'spring-data-jpa', version);
		addMockSpringDataVersion(versions, 'spring-data-mongodb', version);
		addMockSpringDataVersion(versions, 'spring-data-neo4j', version);
		addMockSpringDataVersion(versions, 'spring-data-r2dbc', version);
		addMockSpringDataVersion(versions, 'spring-data-rest-core', version);
		addMockSpringDataVersion(versions, 'spring-data-ldap', version);
		addMockJacksonVersion(versions, 'jackson-annotations', version);
		addMockJacksonVersion(versions, 'jackson-core', version);
		addMockJacksonVersion(versions, 'jackson-databind', version);
		return versions;
	}
	private void addMockSpringDataVersion(Map<String, String> versions, String artifactId, String version) {
		versions.put('org.springframework.data:' + artifactId, version);
	}
	private void addMockJacksonVersion(Map<String, String> versions, String artifactId, String version) {
		versions.put('com.fasterxml.jackson.core:' + artifactId, version);
	}
}
/*
package org.springframework.boot.build.antora;
/**
class GenerateAntoraPlaybookTests {
	@TempDir
	File temp;
	@Test
	void writePlaybookGeneratesExpectedContent() throws Exception {
		writePlaybookYml((task) -> {
			task.getXrefStubs().addAll('appendix:.*', 'api:.*', 'reference:.*');
			task.getAlwaysInclude().set(Map.of('name', 'test', 'classifier', 'local-aggregate-content'));
		});
		String actual = Files.readString(this.temp.toPath()
			.resolve('rootproject/project/build/generated/docs/antora-playbook/antora-playbook.yml'));
		String expected = Files
			.readString(Path.of('src/test/resources/org/springframework/boot/build/antora/expected-playbook.yml'));
		System.out.println(actual);
		assertThat(actual.replace("\\", "/")).isEqualToNormalizingNewlines(expected.replace("\\", "/"));
	}
	@Test
	void writePlaybookWhenHasJavadocExcludeGeneratesExpectedContent() throws Exception {
		writePlaybookYml((task) -> {
			task.getXrefStubs().addAll('appendix:.*', 'api:.*', 'reference:.*');
			task.getAlwaysInclude().set(Map.of('name', 'test', 'classifier', 'local-aggregate-content'));
			task.getExcludeJavadocExtension().set(true);
		});
		String actual = Files.readString(this.temp.toPath()
			.resolve('rootproject/project/build/generated/docs/antora-playbook/antora-playbook.yml'));
		assertThat(actual).doesNotContain('javadoc-extension');
	}
	private void writePlaybookYml(ThrowingConsumer<GenerateAntoraPlaybook> customizer) throws Exception {
		File rootProjectDir = new File(this.temp, 'rootproject').getCanonicalFile();
		rootProjectDir.mkdirs();
		Project rootProject = ProjectBuilder.builder().withProjectDir(rootProjectDir).build();
		File projectDir = new File(rootProjectDir, 'project');
		projectDir.mkdirs();
		Project project = ProjectBuilder.builder().withProjectDir(projectDir).withParent(rootProject).build();
		GenerateAntoraPlaybook task = project.getTasks().create('generateAntoraPlaybook', GenerateAntoraPlaybook.class);
		customizer.accept(task);
		task.writePlaybookYml();
	}
}
/*
package org.springframework.boot.build;
/**
class ConventionsPluginTests {
	private File projectDir;
	private File buildFile;
	@BeforeEach
	void setup(@TempDir File projectDir) throws IOException {
		this.projectDir = projectDir;
		this.buildFile = new File(this.projectDir, 'build.gradle');
		File settingsFile = new File(this.projectDir, 'settings.gradle');
		try (PrintWriter out = new PrintWriter(new FileWriter(settingsFile))) {
			out.println('plugins {');
			out.println('    id "com.gradle.develocity"');
			out.println('}');
			out.println('include ":spring-boot-project:spring-boot-parent"');
		}
		File springBootParent = new File(this.projectDir, 'spring-boot-project/spring-boot-parent/build.gradle');
		springBootParent.getParentFile().mkdirs();
		try (PrintWriter out = new PrintWriter(new FileWriter(springBootParent))) {
			out.println('plugins {');
			out.println('    id "java-platform"');
			out.println('}');
		}
	}
	@Test
	void jarIncludesLegalFiles() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "java"');
			out.println('    id "org.springframework.boot.conventions"');
			out.println('}');
			out.println('version = "1.2.3"');
			out.println('sourceCompatibility = "17"');
			out.println('description "Test project for manifest customization"');
			out.println('jar.archiveFileName = "test.jar"');
		}
		runGradle('jar');
		File file = new File(this.projectDir, '/build/libs/test.jar');
		assertThat(file).exists();
		try (JarFile jar = new JarFile(file)) {
			assertThatLicenseIsPresent(jar);
			assertThatNoticeIsPresent(jar);
			Attributes mainAttributes = jar.getManifest().getMainAttributes();
			assertThat(mainAttributes.getValue('Implementation-Title'))
				.isEqualTo('Test project for manifest customization');
			assertThat(mainAttributes.getValue('Automatic-Module-Name'))
				.isEqualTo(this.projectDir.getName().replace('-', '.'));
			assertThat(mainAttributes.getValue('Implementation-Version')).isEqualTo('1.2.3');
			assertThat(mainAttributes.getValue('Built-By')).isEqualTo('Spring');
			assertThat(mainAttributes.getValue('Build-Jdk-Spec')).isEqualTo('17');
		}
	}
	@Test
	void sourceJarIsBuilt() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "java"');
			out.println('    id "maven-publish"');
			out.println('    id "org.springframework.boot.conventions"');
			out.println('}');
			out.println('version = "1.2.3"');
			out.println('sourceCompatibility = "17"');
			out.println('description "Test"');
		}
		runGradle('assemble');
		File file = new File(this.projectDir, '/build/libs/' + this.projectDir.getName() + '-1.2.3-sources.jar');
		assertThat(file).exists();
		try (JarFile jar = new JarFile(file)) {
			assertThatLicenseIsPresent(jar);
			assertThatNoticeIsPresent(jar);
			Attributes mainAttributes = jar.getManifest().getMainAttributes();
			assertThat(mainAttributes.getValue('Implementation-Title'))
				.isEqualTo('Source for ' + this.projectDir.getName());
			assertThat(mainAttributes.getValue('Automatic-Module-Name'))
				.isEqualTo(this.projectDir.getName().replace('-', '.'));
			assertThat(mainAttributes.getValue('Implementation-Version')).isEqualTo('1.2.3');
			assertThat(mainAttributes.getValue('Built-By')).isEqualTo('Spring');
			assertThat(mainAttributes.getValue('Build-Jdk-Spec')).isEqualTo('17');
		}
	}
	@Test
	void javadocJarIsBuilt() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "java"');
			out.println('    id "maven-publish"');
			out.println('    id "org.springframework.boot.conventions"');
			out.println('}');
			out.println('version = "1.2.3"');
			out.println('sourceCompatibility = "17"');
			out.println('description "Test"');
		}
		runGradle('assemble');
		File file = new File(this.projectDir, '/build/libs/' + this.projectDir.getName() + '-1.2.3-javadoc.jar');
		assertThat(file).exists();
		try (JarFile jar = new JarFile(file)) {
			assertThatLicenseIsPresent(jar);
			assertThatNoticeIsPresent(jar);
			Attributes mainAttributes = jar.getManifest().getMainAttributes();
			assertThat(mainAttributes.getValue('Implementation-Title'))
				.isEqualTo('Javadoc for ' + this.projectDir.getName());
			assertThat(mainAttributes.getValue('Automatic-Module-Name'))
				.isEqualTo(this.projectDir.getName().replace('-', '.'));
			assertThat(mainAttributes.getValue('Implementation-Version')).isEqualTo('1.2.3');
			assertThat(mainAttributes.getValue('Built-By')).isEqualTo('Spring');
			assertThat(mainAttributes.getValue('Build-Jdk-Spec')).isEqualTo('17');
		}
	}
	private void assertThatLicenseIsPresent(JarFile jar) {
		JarEntry license = jar.getJarEntry('META-INF/LICENSE.txt');
		assertThat(license).isNotNull();
	}
	private void assertThatNoticeIsPresent(JarFile jar) throws IOException {
		JarEntry notice = jar.getJarEntry('META-INF/NOTICE.txt');
		assertThat(notice).isNotNull();
		String noticeContent = FileCopyUtils.copyToString(new InputStreamReader(jar.getInputStream(notice)));
		// Test that variables were replaced
		assertThat(noticeContent).doesNotContain('${');
	}
	@Test
	void testRetryIsConfiguredWithThreeRetriesOnCI() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "java"');
			out.println('    id "org.springframework.boot.conventions"');
			out.println('}');
			out.println('description "Test"');
			out.println('task retryConfig {');
			out.println('    doLast {');
			out.println('        test.retry {');
			out.println('            println \'maxRetries: ${maxRetries.get()}\'');
			out.println('            println \'failOnPassedAfterRetry: ${failOnPassedAfterRetry.get()}\'');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		assertThat(runGradle(Collections.singletonMap('CI', 'true'), 'retryConfig', '--stacktrace').getOutput())
			.contains('maxRetries: 3')
			.contains('failOnPassedAfterRetry: false');
	}
	@Test
	void testRetryIsConfiguredWithZeroRetriesLocally() throws IOException {
		try (PrintWriter out = new PrintWriter(new FileWriter(this.buildFile))) {
			out.println('plugins {');
			out.println('    id "java"');
			out.println('    id "org.springframework.boot.conventions"');
			out.println('}');
			out.println('description "Test"');
			out.println('task retryConfig {');
			out.println('    doLast {');
			out.println('        test.retry {');
			out.println('            println \'maxRetries: ${maxRetries.get()}\'');
			out.println('            println \'failOnPassedAfterRetry: ${failOnPassedAfterRetry.get()}\'');
			out.println('        }');
			out.println('    }');
			out.println('}');
		}
		assertThat(runGradle(Collections.singletonMap('CI', 'local'), 'retryConfig', '--stacktrace').getOutput())
			.contains('maxRetries: 0')
			.contains('failOnPassedAfterRetry: false');
	}
	private BuildResult runGradle(String... args) {
		return runGradle(Collections.emptyMap(), args);
	}
	private BuildResult runGradle(Map<String, String> environment, String... args) {
		return GradleRunner.create()
			.withProjectDir(this.projectDir)
			.withEnvironment(environment)
			.withArguments(args)
			.withPluginClasspath()
			.build();
	}
}
/*
package org.springframework.boot.build.artifacts;
/**
class ArtifactReleaseTests {
	@Test
	void whenProjectVersionIsSnapshotThenTypeIsSnapshot() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3-SNAPSHOT');
		assertThat(ArtifactRelease.forProject(project).getType()).isEqualTo('snapshot');
	}
	@Test
	void whenProjectVersionIsMilestoneThenTypeIsMilestone() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3-M1');
		assertThat(ArtifactRelease.forProject(project).getType()).isEqualTo('milestone');
	}
	@Test
	void whenProjectVersionIsReleaseCandidateThenTypeIsMilestone() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3-RC1');
		assertThat(ArtifactRelease.forProject(project).getType()).isEqualTo('milestone');
	}
	@Test
	void whenProjectVersionIsReleaseThenTypeIsRelease() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3');
		assertThat(ArtifactRelease.forProject(project).getType()).isEqualTo('release');
	}
	@Test
	void whenProjectVersionIsSnapshotThenRepositoryIsArtifactorySnapshot() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3-SNAPSHOT');
		assertThat(ArtifactRelease.forProject(project).getDownloadRepo()).contains('repo.spring.io/snapshot');
	}
	@Test
	void whenProjectVersionIsMilestoneThenRepositoryIsArtifactoryMilestone() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3-M1');
		assertThat(ArtifactRelease.forProject(project).getDownloadRepo()).contains('repo.spring.io/milestone');
	}
	@Test
	void whenProjectVersionIsReleaseCandidateThenRepositoryIsArtifactoryMilestone() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3-RC1');
		assertThat(ArtifactRelease.forProject(project).getDownloadRepo()).contains('repo.spring.io/milestone');
	}
	@Test
	void whenProjectVersionIsReleaseThenRepositoryIsMavenCentral() {
		Project project = ProjectBuilder.builder().build();
		project.setVersion('1.2.3');
		assertThat(ArtifactRelease.forProject(project).getDownloadRepo())
			.contains('https://repo.maven.apache.org/maven2');
	}
}
/*
package org.springframework.boot.build.groovyscripts;
/**
class SpringRepositoriesExtensionTests {
	private static GroovyClassLoader groovyClassLoader;
	private static Class<?> supportClass;
	@BeforeAll
	static void loadGroovyClass() throws Exception {
		groovyClassLoader = new GroovyClassLoader(SpringRepositoriesExtensionTests.class.getClassLoader());
		supportClass = groovyClassLoader.parseClass(new File('SpringRepositorySupport.groovy'));
	}
	@AfterAll
	static void cleanup() throws Exception {
		groovyClassLoader.close();
	}
	private final List<MavenArtifactRepository> repositories = new ArrayList<>();
	private final List<RepositoryContentDescriptor> contents = new ArrayList<>();
	private final List<PasswordCredentials> credentials = new ArrayList<>();
	@Test
	void mavenRepositoriesWhenNotCommercialSnapshot() {
		SpringRepositoriesExtension extension = createExtension('0.0.0-SNAPSHOT', 'oss');
		extension.mavenRepositories();
		assertThat(this.repositories).hasSize(2);
		verify(this.repositories.get(0)).setName('spring-oss-milestone');
		verify(this.repositories.get(0)).setUrl('https://repo.spring.io/milestone');
		verify(this.repositories.get(1)).setName('spring-oss-snapshot');
		verify(this.repositories.get(1)).setUrl('https://repo.spring.io/snapshot');
	}
	@Test
	void mavenRepositoriesWhenCommercialSnapshot() {
		SpringRepositoriesExtension extension = createExtension('0.0.0-SNAPSHOT', 'commercial');
		extension.mavenRepositories();
		assertThat(this.repositories).hasSize(4);
		verify(this.repositories.get(0)).setName('spring-commercial-release');
		verify(this.repositories.get(0))
			.setUrl('https://usw1.packages.broadcom.com/spring-enterprise-maven-prod-local');
		verify(this.repositories.get(1)).setName('spring-oss-milestone');
		verify(this.repositories.get(1)).setUrl('https://repo.spring.io/milestone');
		verify(this.repositories.get(2)).setName('spring-commercial-snapshot');
		verify(this.repositories.get(2)).setUrl('https://usw1.packages.broadcom.com/spring-enterprise-maven-dev-local');
		verify(this.repositories.get(3)).setName('spring-oss-snapshot');
		verify(this.repositories.get(3)).setUrl('https://repo.spring.io/snapshot');
	}
	@Test
	void mavenRepositoriesWhenNotCommercialMilestone() {
		SpringRepositoriesExtension extension = createExtension('0.0.0-M1', 'oss');
		extension.mavenRepositories();
		assertThat(this.repositories).hasSize(1);
		verify(this.repositories.get(0)).setName('spring-oss-milestone');
		verify(this.repositories.get(0)).setUrl('https://repo.spring.io/milestone');
	}
	@Test
	void mavenRepositoriesWhenCommercialMilestone() {
		SpringRepositoriesExtension extension = createExtension('0.0.0-M1', 'commercial');
		extension.mavenRepositories();
		assertThat(this.repositories).hasSize(2);
		verify(this.repositories.get(0)).setName('spring-commercial-release');
		verify(this.repositories.get(0))
			.setUrl('https://usw1.packages.broadcom.com/spring-enterprise-maven-prod-local');
		verify(this.repositories.get(1)).setName('spring-oss-milestone');
		verify(this.repositories.get(1)).setUrl('https://repo.spring.io/milestone');
	}
	@Test
	void mavenRepositoriesWhenNotCommercialRelease() {
		SpringRepositoriesExtension extension = createExtension('0.0.1', 'oss');
		extension.mavenRepositories();
		assertThat(this.repositories).isEmpty();
	}
	@Test
	void mavenRepositoriesWhenCommercialRelease() {
		SpringRepositoriesExtension extension = createExtension('0.0.1', 'commercial');
		extension.mavenRepositories();
		assertThat(this.repositories).hasSize(1);
		verify(this.repositories.get(0)).setName('spring-commercial-release');
		verify(this.repositories.get(0))
			.setUrl('https://usw1.packages.broadcom.com/spring-enterprise-maven-prod-local');
	}
	@Test
	void mavenRepositoriesWhenConditionMatches() {
		SpringRepositoriesExtension extension = createExtension('0.0.0-SNAPSHOT', 'oss');
		extension.mavenRepositories(true);
		assertThat(this.repositories).hasSize(2);
	}
	@Test
	void mavenRepositoriesWhenConditionDoesNotMatch() {
		SpringRepositoriesExtension extension = createExtension('0.0.0-SNAPSHOT', 'oss');
		extension.mavenRepositories(false);
		assertThat(this.repositories).isEmpty();
	}
	@Test
	void mavenRepositoriesExcludingBootGroup() {
		SpringRepositoriesExtension extension = createExtension('0.0.0-SNAPSHOT', 'oss');
		extension.mavenRepositoriesExcludingBootGroup();
		assertThat(this.contents).hasSize(2);
		verify(this.contents.get(0)).excludeGroup('org.springframework.boot');
		verify(this.contents.get(1)).excludeGroup('org.springframework.boot');
	}
	@Test
	void mavenRepositoriesWithRepositorySpecificEnvironmentVariables() {
		Map<String, String> environment = new HashMap<>();
		environment.put('COMMERCIAL_RELEASE_REPO_URL', 'curl');
		environment.put('COMMERCIAL_RELEASE_REPO_USERNAME', 'cuser');
		environment.put('COMMERCIAL_RELEASE_REPO_PASSWORD', 'cpass');
		environment.put('COMMERCIAL_SNAPSHOT_REPO_URL', 'surl');
		environment.put('COMMERCIAL_SNAPSHOT_REPO_USERNAME', 'suser');
		environment.put('COMMERCIAL_SNAPSHOT_REPO_PASSWORD', 'spass');
		SpringRepositoriesExtension extension = createExtension('0.0.0-SNAPSHOT', 'commercial', environment::get);
		extension.mavenRepositories();
		assertThat(this.repositories).hasSize(4);
		verify(this.repositories.get(0)).setUrl('curl');
		verify(this.repositories.get(2)).setUrl('surl');
		assertThat(this.credentials).hasSize(2);
		verify(this.credentials.get(0)).setUsername('cuser');
		verify(this.credentials.get(0)).setPassword('cpass');
		verify(this.credentials.get(1)).setUsername('suser');
		verify(this.credentials.get(1)).setPassword('spass');
	}
	@Test
	void mavenRepositoriesWhenRepositoryEnvironmentVariables() {
		Map<String, String> environment = new HashMap<>();
		environment.put('COMMERCIAL_REPO_URL', 'url');
		environment.put('COMMERCIAL_REPO_USERNAME', 'user');
		environment.put('COMMERCIAL_REPO_PASSWORD', 'pass');
		SpringRepositoriesExtension extension = createExtension('0.0.0-SNAPSHOT', 'commercial', environment::get);
		extension.mavenRepositories();
		assertThat(this.repositories).hasSize(4);
		verify(this.repositories.get(0)).setUrl('url');
		verify(this.repositories.get(2)).setUrl('url');
		assertThat(this.credentials).hasSize(2);
		verify(this.credentials.get(0)).setUsername('user');
		verify(this.credentials.get(0)).setPassword('pass');
		verify(this.credentials.get(1)).setUsername('user');
		verify(this.credentials.get(1)).setPassword('pass');
	}
	private SpringRepositoriesExtension createExtension(String version, String buildType) {
		return createExtension(version, buildType, (name) -> null);
	}
	@SuppressWarnings({ 'unchecked', 'unchecked' })
	private SpringRepositoriesExtension createExtension(String version, String buildType,
			UnaryOperator<String> environment) {
		RepositoryHandler repositoryHandler = mock(RepositoryHandler.class);
		given(repositoryHandler.maven(any(Closure.class))).willAnswer(this::mavenClosure);
		return SpringRepositoriesExtension.get(repositoryHandler, version, buildType, environment);
	}
	@SuppressWarnings({ 'unchecked', 'unchecked' })
	private Object mavenClosure(InvocationOnMock invocation) {
		MavenArtifactRepository repository = mock(MavenArtifactRepository.class);
		willAnswer(this::contentAction).given(repository).content(any(Action.class));
		willAnswer(this::credentialsAction).given(repository).credentials(any(Action.class));
		Closure<MavenArtifactRepository> closure = invocation.getArgument(0);
		closure.call(repository);
		this.repositories.add(repository);
		return null;
	}
	private Object contentAction(InvocationOnMock invocation) {
		RepositoryContentDescriptor content = mock(RepositoryContentDescriptor.class);
		Action<RepositoryContentDescriptor> action = invocation.getArgument(0);
		action.execute(content);
		this.contents.add(content);
		return null;
	}
	private Object credentialsAction(InvocationOnMock invocation) {
		PasswordCredentials credentials = mock(PasswordCredentials.class);
		Action<PasswordCredentials> action = invocation.getArgument(0);
		action.execute(credentials);
		this.credentials.add(credentials);
		return null;
	}
	interface SpringRepositoriesExtension {
		void mavenRepositories();
		void mavenRepositories(boolean condition);
		void mavenRepositoriesExcludingBootGroup();
		static SpringRepositoriesExtension get(RepositoryHandler repositoryHandler, String version, String buildType,
				UnaryOperator<String> environment) {
			try {
				Class<?> extensionClass = supportClass.getClassLoader().loadClass('SpringRepositoriesExtension');
				Object extension = extensionClass
					.getDeclaredConstructor(Object.class, Object.class, Object.class, Object.class)
					.newInstance(repositoryHandler, version, buildType, environment);
				return (SpringRepositoriesExtension) Proxy.newProxyInstance(
						SpringRepositoriesExtensionTests.class.getClassLoader(),
						new Class<?>[] { SpringRepositoriesExtension.class }, (instance, method, args) -> {
							Class<?>[] params = new Class<?>[(args != null) ? args.length : 0];
							Arrays.fill(params, Object.class);
							Method groovyMethod = extension.getClass().getDeclaredMethod(method.getName(), params);
							return groovyMethod.invoke(extension, args);
						});
			}
			catch (Exception ex) {
				throw new RuntimeException(ex);
			}
		}
	}
}
/*
package org.springframework.boot.build.architecture.bpp.nonstatic;
class NonStaticBeanPostProcessorConfiguration {
	@Bean
	BeanPostProcessor nonStaticBeanPostProcessor() {
		return new BeanPostProcessor() {
		};
	}
}
/*
package org.springframework.boot.build.architecture.bpp.noparameters;
class NoParametersBeanPostProcessorConfiguration {
	@Bean
	static BeanPostProcessor noParametersBeanPostProcessor() {
		return new BeanPostProcessor() {
		};
	}
	@Bean
	Integer beanOne() {
		return 1;
	}
	@Bean
	String beanTwo() {
		return 'test';
	}
}
/*
package org.springframework.boot.build.architecture.bpp.safeparameters;
class SafeParametersBeanPostProcessorConfiguration {
	@Bean
	static BeanPostProcessor safeParametersBeanPostProcessor(ApplicationContext context, ObjectProvider<String> beanOne,
			ObjectProvider<String> beanTwo, Environment environment, @Lazy String beanThree) {
		return new BeanPostProcessor() {
		};
	}
	@Bean
	Integer beanOne() {
		return 1;
	}
	@Bean
	String beanTwo() {
		return 'test';
	}
}
/*
package org.springframework.boot.build.architecture.bpp.unsafeparameters;
class UnsafeParametersBeanPostProcessorConfiguration {
	@Bean
	static BeanPostProcessor unsafeParametersBeanPostProcessor(ApplicationContext context, Integer beanOne,
			String beanTwo) {
		return new BeanPostProcessor() {
		};
	}
	@Bean
	Integer beanOne() {
		return 1;
	}
	@Bean
	String beanTwo() {
		return 'test';
	}
}
/*
package org.springframework.boot.build.architecture.tangled.sub;
public final class TangledTwo {
	public static final String ID = TangledOne.ID + '-Two';
	private TangledTwo() {
	}
}
/*
package org.springframework.boot.build.architecture.tangled;
public final class TangledOne {
	public static final String ID = TangledTwo.class.getName() + 'One';
	private TangledOne() {
	}
}
/*
package org.springframework.boot.build.architecture.bfpp.nonstatic;
class NonStaticBeanFactoryPostProcessorConfiguration {
	@Bean
	BeanFactoryPostProcessor nonStaticBeanFactoryPostProcessor() {
		return (beanFactory) -> {
		};
	}
}
/*
package org.springframework.boot.build.architecture.bfpp.noparameters;
class NoParametersBeanFactoryPostProcessorConfiguration {
	@Bean
	static BeanFactoryPostProcessor noParametersBeanFactoryPostProcessor() {
		return (beanFactory) -> {
		};
	}
	@Bean
	Integer beanOne() {
		return 1;
	}
	@Bean
	String beanTwo() {
		return 'test';
	}
}
/*
package org.springframework.boot.build.architecture.bfpp.parameters;
class ParametersBeanFactoryPostProcessorConfiguration {
	@Bean
	static BeanFactoryPostProcessor parametersBeanFactoryPostProcessor(Integer param) {
		return (beanFactory) -> {
		};
	}
	@Bean
	Integer beanOne() {
		return 1;
	}
	@Bean
	String beanTwo() {
		return 'test';
	}
}
/*
package org.springframework.boot.build.architecture;
/**
class ArchitectureCheckTests {
	@TempDir
	File temp;
	@Test
	void whenPackagesAreTangledTaskFailsAndWritesAReport() throws Exception {
		prepareTask('tangled', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenPackagesAreNotTangledTaskSucceedsAndWritesAnEmptyReport() throws Exception {
		prepareTask('untangled', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	File failureReport(ArchitectureCheck architectureCheck) {
		return architectureCheck.getProject()
			.getLayout()
			.getBuildDirectory()
			.file('checkArchitecture/failure-report.txt')
			.get()
			.getAsFile();
	}
	@Test
	void whenBeanPostProcessorBeanMethodIsNotStaticTaskFailsAndWritesAReport() throws Exception {
		prepareTask('bpp/nonstatic', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenBeanPostProcessorBeanMethodIsStaticAndHasUnsafeParametersTaskFailsAndWritesAReport() throws Exception {
		prepareTask('bpp/unsafeparameters', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenBeanPostProcessorBeanMethodIsStaticAndHasSafeParametersTaskSucceedsAndWritesAnEmptyReport()
			throws Exception {
		prepareTask('bpp/safeparameters', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	@Test
	void whenBeanPostProcessorBeanMethodIsStaticAndHasNoParametersTaskSucceedsAndWritesAnEmptyReport()
			throws Exception {
		prepareTask('bpp/noparameters', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	@Test
	void whenBeanFactoryPostProcessorBeanMethodIsNotStaticTaskFailsAndWritesAReport() throws Exception {
		prepareTask('bfpp/nonstatic', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenBeanFactoryPostProcessorBeanMethodIsStaticAndHasParametersTaskFailsAndWritesAReport() throws Exception {
		prepareTask('bfpp/parameters', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenBeanFactoryPostProcessorBeanMethodIsStaticAndHasNoParametersTaskSucceedsAndWritesAnEmptyReport()
			throws Exception {
		prepareTask('bfpp/noparameters', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	@Test
	void whenClassLoadsResourceUsingResourceUtilsTaskFailsAndWritesReport() throws Exception {
		prepareTask('resources/loads', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenClassUsesResourceUtilsWithoutLoadingResourcesTaskSucceedsAndWritesAnEmptyReport() throws Exception {
		prepareTask('resources/noloads', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	@Test
	void whenClassDoesNotCallObjectsRequireNonNullTaskSucceedsAndWritesAnEmptyReport() throws Exception {
		prepareTask('objects/noRequireNonNull', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	@Test
	void whenClassCallsObjectsRequireNonNullWithMessageTaskFailsAndWritesReport() throws Exception {
		prepareTask('objects/requireNonNullWithString', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenClassCallsObjectsRequireNonNullWithSupplierTaskFailsAndWritesReport() throws Exception {
		prepareTask('objects/requireNonNullWithSupplier', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty();
		});
	}
	@Test
	void whenClassCallsStringToUpperCaseWithoutLocaleFailsAndWritesReport() throws Exception {
		prepareTask('string/toUpperCase', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty()
				.content()
				.contains('because String.toUpperCase(Locale.ROOT) should be used instead');
		});
	}
	@Test
	void whenClassCallsStringToLowerCaseWithoutLocaleFailsAndWritesReport() throws Exception {
		prepareTask('string/toLowerCase', (architectureCheck) -> {
			assertThatExceptionOfType(GradleException.class).isThrownBy(architectureCheck::checkArchitecture);
			assertThat(failureReport(architectureCheck)).isNotEmpty()
				.content()
				.contains('because String.toLowerCase(Locale.ROOT) should be used instead');
		});
	}
	@Test
	void whenClassCallsStringToLowerCaseWithLocaleShouldNotFail() throws Exception {
		prepareTask('string/toLowerCaseWithLocale', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	@Test
	void whenClassCallsStringToUpperCaseWithLocaleShouldNotFail() throws Exception {
		prepareTask('string/toUpperCaseWithLocale', (architectureCheck) -> {
			architectureCheck.checkArchitecture();
			assertThat(failureReport(architectureCheck)).isEmpty();
		});
	}
	private void prepareTask(String classes, Callback<ArchitectureCheck> callback) throws Exception {
		File projectDir = new File(this.temp, 'project');
		projectDir.mkdirs();
		copyClasses(classes, projectDir);
		Project project = ProjectBuilder.builder().withProjectDir(projectDir).build();
		ArchitectureCheck architectureCheck = project.getTasks()
			.create('checkArchitecture', ArchitectureCheck.class, (task) -> task.setClasses(project.files('classes')));
		callback.accept(architectureCheck);
	}
	private void copyClasses(String name, File projectDir) throws IOException {
		PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
		Resource root = resolver.getResource('classpath:org/springframework/boot/build/architecture/' + name);
		FileSystemUtils.copyRecursively(root.getFile(),
				new File(projectDir, 'classes/org/springframework/boot/build/architecture/' + name));
	}
	private interface Callback<T> {
		void accept(T item) throws Exception;
	}
}
/*
package org.springframework.boot.build.architecture.objects.requireNonNullWithSupplier;
class RequireNonNullWithSupplier {
	void exampleMethod() {
		Objects.requireNonNull(new Object(), () -> 'Object cannot be null');
	}
}
/*
package org.springframework.boot.build.architecture.objects.requireNonNullWithString;
class RequireNonNullWithString {
	void exampleMethod() {
		Objects.requireNonNull(new Object(), 'Object cannot be null');
	}
}
/*
package org.springframework.boot.build.architecture.objects.noRequireNonNull;
class NoRequireNonNull {
	void exampleMethod() {
		Assert.notNull(new Object(), 'Object must not be null');
		// Compilation of a method reference generates code that uses
		// Objects.requireNonNull(Object). Check that it doesn"t cause a failure.
		Collections.emptyList().forEach(System.out::println);
	}
}
/*
package org.springframework.boot.build.architecture.untangled;
public final class UntangledOne {
	public static final String ID = UntangledTwo.class.getName() + 'One';
	private UntangledOne() {
	}
}
/*
package org.springframework.boot.build.architecture.untangled.sub;
public final class UntangledTwo {
	public static final String ID = 'Two';
	private UntangledTwo() {
	}
}
/*
package org.springframework.boot.build.architecture.resources.loads;
public class ResourceUtilsResourceLoader {
	void getResource() throws FileNotFoundException {
		ResourceUtils.getURL('gradle.properties');
	}
}
/*
package org.springframework.boot.build.architecture.resources.noloads;
public class ResourceUtilsWithoutLoading {
	void inspectResourceLocation() throws MalformedURLException {
		ResourceUtils.isUrl('gradle.properties');
		ResourceUtils.isFileURL(new URL('gradle.properties'));
		'test'.startsWith(ResourceUtils.FILE_URL_PREFIX);
	}
}
/*
package org.springframework.boot.build.architecture.string.toLowerCase;
class ToLowerCase {
	void exampleMethod() {
		String test = 'Object must not be null';
		System.out.println(test.toLowerCase());
	}
}
/*
package org.springframework.boot.build.architecture.string.toLowerCaseWithLocale;
class ToLowerCaseWithLocale {
	void exampleMethod() {
		String test = 'Object must not be null';
		System.out.println(test.toLowerCase(Locale.ENGLISH));
	}
}
/*
package org.springframework.boot.build.architecture.string.toUpperCaseWithLocale;
class ToUpperCaseWithLocale {
	void exampleMethod() {
		String test = 'Object must not be null';
		System.out.println(test.toUpperCase(Locale.ROOT));
	}
}
/*
package org.springframework.boot.build.architecture.string.toUpperCase;
class ToUpperCase {
	void exampleMethod() {
		String test = 'Object must not be null';
		System.out.println(test.toUpperCase());
	}
}
/*
package org.springframework.boot.build;
/**
public class MavenRepositoryPlugin implements Plugin<Project> {
	/**
	 * Name of the {@code mavenRepository} configuration.
	 */
	public static final String MAVEN_REPOSITORY_CONFIGURATION_NAME = 'mavenRepository';
	/**
	 * Name of the task that publishes to the project repository.
	 */
	public static final String PUBLISH_TO_PROJECT_REPOSITORY_TASK_NAME = 'publishMavenPublicationToProjectRepository';
	@Override
	public void apply(Project project) {
		project.getPlugins().apply(MavenPublishPlugin.class);
		PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
		File repositoryLocation = project.getLayout().getBuildDirectory().dir('maven-repository').get().getAsFile();
		publishing.getRepositories().maven((mavenRepository) -> {
			mavenRepository.setName('project');
			mavenRepository.setUrl(repositoryLocation.toURI());
		});
		project.getTasks()
			.matching((task) -> task.getName().equals(PUBLISH_TO_PROJECT_REPOSITORY_TASK_NAME))
			.all((task) -> setUpProjectRepository(project, task, repositoryLocation));
		project.getTasks()
			.matching((task) -> task.getName().equals('publishPluginMavenPublicationToProjectRepository'))
			.all((task) -> setUpProjectRepository(project, task, repositoryLocation));
	}
	private void setUpProjectRepository(Project project, Task publishTask, File repositoryLocation) {
		publishTask.doFirst(new CleanAction(repositoryLocation));
		Configuration projectRepository = project.getConfigurations().create(MAVEN_REPOSITORY_CONFIGURATION_NAME);
		project.getArtifacts()
			.add(projectRepository.getName(), repositoryLocation, (artifact) -> artifact.builtBy(publishTask));
		DependencySet target = projectRepository.getDependencies();
		project.getPlugins()
			.withType(JavaPlugin.class)
			.all((javaPlugin) -> addMavenRepositoryDependencies(project, JavaPlugin.IMPLEMENTATION_CONFIGURATION_NAME,
					target));
		project.getPlugins()
			.withType(JavaLibraryPlugin.class)
			.all((javaLibraryPlugin) -> addMavenRepositoryDependencies(project, JavaPlugin.API_CONFIGURATION_NAME,
					target));
		project.getPlugins()
			.withType(JavaPlatformPlugin.class)
			.all((javaPlugin) -> addMavenRepositoryDependencies(project, JavaPlatformPlugin.API_CONFIGURATION_NAME,
					target));
	}
	private void addMavenRepositoryDependencies(Project project, String sourceConfigurationName, DependencySet target) {
		project.getConfigurations()
			.getByName(sourceConfigurationName)
			.getDependencies()
			.withType(ProjectDependency.class)
			.all((dependency) -> {
				Map<String, String> dependencyDescriptor = new HashMap<>();
				dependencyDescriptor.put('path', dependency.getDependencyProject().getPath());
				dependencyDescriptor.put('configuration', MAVEN_REPOSITORY_CONFIGURATION_NAME);
				target.add(project.getDependencies().project(dependencyDescriptor));
			});
	}
	private static final class CleanAction implements Action<Task> {
		private final File location;
		private CleanAction(File location) {
			this.location = location;
		}
		@Override
		public void execute(Task task) {
			FileSystemUtils.deleteRecursively(this.location);
		}
	}
}
/*
package org.springframework.boot.build.autoconfigure;
/**
public abstract class AutoConfigurationMetadata extends DefaultTask {
	private static final String COMMENT_START = '#';
	private final String moduleName;
	private FileCollection classesDirectories;
	public AutoConfigurationMetadata() {
		getProject().getConfigurations()
			.maybeCreate(AutoConfigurationPlugin.AUTO_CONFIGURATION_METADATA_CONFIGURATION_NAME);
		this.moduleName = getProject().getName();
	}
	public void setSourceSet(SourceSet sourceSet) {
		getAutoConfigurationImports().set(new File(sourceSet.getOutput().getResourcesDir(),
				'META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports'));
		this.classesDirectories = sourceSet.getOutput().getClassesDirs();
		dependsOn(sourceSet.getOutput());
	}
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	abstract RegularFileProperty getAutoConfigurationImports();
	@OutputFile
	public abstract RegularFileProperty getOutputFile();
	@Classpath
	FileCollection getClassesDirectories() {
		return this.classesDirectories;
	}
	@TaskAction
	void documentAutoConfiguration() throws IOException {
		Properties autoConfiguration = readAutoConfiguration();
		File outputFile = getOutputFile().get().getAsFile();
		outputFile.getParentFile().mkdirs();
		try (FileWriter writer = new FileWriter(outputFile)) {
			autoConfiguration.store(writer, null);
		}
	}
	private Properties readAutoConfiguration() throws IOException {
		Properties autoConfiguration = CollectionFactory.createSortedProperties(true);
		List<String> classNames = readAutoConfigurationsFile();
		Set<String> publicClassNames = new LinkedHashSet<>();
		for (String className : classNames) {
			File classFile = findClassFile(className);
			if (classFile == null) {
				throw new IllegalStateException('Auto-configuration class "' + className + '" not found.');
			}
			try (InputStream in = new FileInputStream(classFile)) {
				int access = new ClassReader(in).getAccess();
				if ((access & Opcodes.ACC_PUBLIC) == Opcodes.ACC_PUBLIC) {
					publicClassNames.add(className);
				}
			}
		}
		autoConfiguration.setProperty('autoConfigurationClassNames', String.join(',', publicClassNames));
		autoConfiguration.setProperty('module', this.moduleName);
		return autoConfiguration;
	}
	/**
	 * Reads auto-configurations from
	 * META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports.
	 * @return auto-configurations
	 */
	private List<String> readAutoConfigurationsFile() throws IOException {
		File file = getAutoConfigurationImports().getAsFile().get();
		if (!file.exists()) {
			return Collections.emptyList();
		}
		try (BufferedReader reader = new BufferedReader(new FileReader(file))) {
			return reader.lines().map(this::stripComment).filter((line) -> !line.isEmpty()).toList();
		}
	}
	private String stripComment(String line) {
		int commentStart = line.indexOf(COMMENT_START);
		if (commentStart == -1) {
			return line.trim();
		}
		return line.substring(0, commentStart).trim();
	}
	private File findClassFile(String className) {
		String classFileName = className.replace('.', '/') + '.class';
		for (File classesDir : this.classesDirectories) {
			File classFile = new File(classesDir, classFileName);
			if (classFile.isFile()) {
				return classFile;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.build.autoconfigure;
/**
public abstract class DocumentAutoConfigurationClasses extends DefaultTask {
	private FileCollection autoConfiguration;
	@InputFiles
	public FileCollection getAutoConfiguration() {
		return this.autoConfiguration;
	}
	public void setAutoConfiguration(FileCollection autoConfiguration) {
		this.autoConfiguration = autoConfiguration;
	}
	@OutputDirectory
	public abstract DirectoryProperty getOutputDir();
	@TaskAction
	void documentAutoConfigurationClasses() throws IOException {
		for (File metadataFile : this.autoConfiguration) {
			Properties metadata = new Properties();
			try (Reader reader = new FileReader(metadataFile)) {
				metadata.load(reader);
			}
			AutoConfiguration autoConfiguration = new AutoConfiguration(metadata.getProperty('module'), new TreeSet<>(
					StringUtils.commaDelimitedListToSet(metadata.getProperty('autoConfigurationClassNames'))));
			writeTable(autoConfiguration);
		}
	}
	private void writeTable(AutoConfiguration autoConfigurationClasses) throws IOException {
		File outputDir = getOutputDir().getAsFile().get();
		outputDir.mkdirs();
		try (PrintWriter writer = new PrintWriter(
				new FileWriter(new File(outputDir, autoConfigurationClasses.module + '.adoc')))) {
			writer.println('[cols=\'4,1\']');
			writer.println('|===');
			writer.println('| Configuration Class | Links');
			for (AutoConfigurationClass autoConfigurationClass : autoConfigurationClasses.classes) {
				writer.println();
				writer.printf('| {code-spring-boot}/spring-boot-project/%s/src/main/java/%s.java[`%s`]%n',
						autoConfigurationClasses.module, autoConfigurationClass.path, autoConfigurationClass.name);
				writer.printf('| xref:api:java/%s.html[javadoc]%n', autoConfigurationClass.path);
			}
			writer.println('|===');
		}
	}
	private static final class AutoConfiguration {
		private final String module;
		private final SortedSet<AutoConfigurationClass> classes;
		private AutoConfiguration(String module, Set<String> classNames) {
			this.module = module;
			this.classes = classNames.stream().map((className) -> {
				String path = className.replace(".", "/");
				String name = className.substring(className.lastIndexOf(".") + 1);
				return new AutoConfigurationClass(name, path);
			}).collect(Collectors.toCollection(TreeSet::new));
		}
	}
	private static final class AutoConfigurationClass implements Comparable<AutoConfigurationClass> {
		private final String name;
		private final String path;
		private AutoConfigurationClass(String name, String path) {
			this.name = name;
			this.path = path;
		}
		@Override
		public int compareTo(AutoConfigurationClass other) {
			return this.name.compareTo(other.name);
		}
	}
}
/*
package org.springframework.boot.build.autoconfigure;
/**
public class AutoConfigurationPlugin implements Plugin<Project> {
	/**
	 * Name of the {@link Configuration} that holds the auto-configuration metadata
	 * artifact.
	 */
	public static final String AUTO_CONFIGURATION_METADATA_CONFIGURATION_NAME = 'autoConfigurationMetadata';
	private static final String AUTO_CONFIGURATION_IMPORTS_PATH = 'META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports';
	@Override
	public void apply(Project project) {
		project.getPlugins().apply(DeployedPlugin.class);
		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> {
			Configuration annotationProcessors = project.getConfigurations()
				.getByName(JavaPlugin.ANNOTATION_PROCESSOR_CONFIGURATION_NAME);
			annotationProcessors.getDependencies()
				.add(project.getDependencies()
					.project(Collections.singletonMap('path',
							':spring-boot-project:spring-boot-tools:spring-boot-autoconfigure-processor')));
			annotationProcessors.getDependencies()
				.add(project.getDependencies()
					.project(Collections.singletonMap('path',
							':spring-boot-project:spring-boot-tools:spring-boot-configuration-processor')));
			project.getTasks().create('autoConfigurationMetadata', AutoConfigurationMetadata.class, (task) -> {
				SourceSet main = project.getExtensions()
					.getByType(JavaPluginExtension.class)
					.getSourceSets()
					.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
				task.setSourceSet(main);
				task.dependsOn(main.getClassesTaskName());
				task.getOutputFile()
					.set(project.getLayout().getBuildDirectory().file('auto-configuration-metadata.properties'));
				project.getArtifacts()
					.add(AutoConfigurationPlugin.AUTO_CONFIGURATION_METADATA_CONFIGURATION_NAME, task.getOutputFile(),
							(artifact) -> artifact.builtBy(task));
			});
			project.getPlugins()
				.withType(ArchitecturePlugin.class, (plugin) -> configureArchitecturePluginTasks(project));
		});
	}
	private void configureArchitecturePluginTasks(Project project) {
		project.getTasks().configureEach((task) -> {
			if ('checkArchitectureMain'.equals(task.getName()) && task instanceof ArchitectureCheck architectureCheck) {
				configureCheckArchitectureMain(project, architectureCheck);
			}
		});
	}
	private void configureCheckArchitectureMain(Project project, ArchitectureCheck architectureCheck) {
		SourceSet main = project.getExtensions()
			.getByType(JavaPluginExtension.class)
			.getSourceSets()
			.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		File resourcesDirectory = main.getOutput().getResourcesDir();
		architectureCheck.dependsOn(main.getProcessResourcesTaskName());
		architectureCheck.getInputs()
			.files(resourcesDirectory)
			.optional()
			.withPathSensitivity(PathSensitivity.RELATIVE);
		architectureCheck.getRules()
			.add(allClassesAnnotatedWithAutoConfigurationShouldBeListedInAutoConfigurationImports(
					autoConfigurationImports(project, resourcesDirectory)));
	}
	private ArchRule allClassesAnnotatedWithAutoConfigurationShouldBeListedInAutoConfigurationImports(
			Provider<AutoConfigurationImports> imports) {
		return ArchRuleDefinition.classes()
			.that()
			.areAnnotatedWith('org.springframework.boot.autoconfigure.AutoConfiguration')
			.should(beListedInAutoConfigurationImports(imports))
			.allowEmptyShould(true);
	}
	private ArchCondition<JavaClass> beListedInAutoConfigurationImports(Provider<AutoConfigurationImports> imports) {
		return new ArchCondition<>('be listed in ' + AUTO_CONFIGURATION_IMPORTS_PATH) {
			@Override
			public void check(JavaClass item, ConditionEvents events) {
				AutoConfigurationImports autoConfigurationImports = imports.get();
				if (!autoConfigurationImports.imports.contains(item.getName())) {
					events.add(SimpleConditionEvent.violated(item,
							item.getName() + ' was not listed in ' + autoConfigurationImports.importsFile));
				}
			}
		};
	}
	private Provider<AutoConfigurationImports> autoConfigurationImports(Project project, File resourcesDirectory) {
		Path importsFile = new File(resourcesDirectory, AUTO_CONFIGURATION_IMPORTS_PATH).toPath();
		return project.provider(() -> {
			try {
				return new AutoConfigurationImports(project.getProjectDir().toPath().relativize(importsFile),
						Files.readAllLines(importsFile));
			}
			catch (IOException ex) {
				throw new RuntimeException('Failed to read AutoConfiguration.imports', ex);
			}
		});
	}
	private record AutoConfigurationImports(Path importsFile, List<String> imports) {
	}
}
/*
package org.springframework.boot.build.cli;
/**
public abstract class HomebrewFormula extends DefaultTask {
	private static final Logger logger = LoggerFactory.getLogger(HomebrewFormula.class);
	private final FileSystemOperations fileSystemOperations;
	@Inject
	public HomebrewFormula(FileSystemOperations fileSystemOperations) {
		this.fileSystemOperations = fileSystemOperations;
		Project project = getProject();
		MapProperty<String, Object> properties = getProperties();
		properties.put('hash', getArchive().map((archive) -> sha256(archive.getAsFile())));
		getProperties().put('repo', ArtifactRelease.forProject(project).getDownloadRepo());
		getProperties().put('version', project.getVersion().toString());
	}
	private String sha256(File file) {
		try {
			MessageDigest digest = MessageDigest.getInstance('SHA-256');
			return new DigestUtils(digest).digestAsHex(file);
		}
		catch (Exception ex) {
			throw new TaskExecutionException(this, ex);
		}
	}
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	public abstract RegularFileProperty getArchive();
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	public abstract RegularFileProperty getTemplate();
	@OutputDirectory
	public abstract DirectoryProperty getOutputDir();
	@Input
	abstract MapProperty<String, Object> getProperties();
	@TaskAction
	void createFormula() {
		BuildType buildType = BuildProperties.get(getProject()).buildType();
		if (buildType != BuildType.OPEN_SOURCE) {
			logger.debug('Skipping Homebrew formula for non open source build type');
			return;
		}
		this.fileSystemOperations.copy((copy) -> {
			copy.from(getTemplate());
			copy.into(getOutputDir());
			copy.expand(getProperties().get());
		});
	}
}
/*
package org.springframework.boot.build.optional;
/**
public class OptionalDependenciesPlugin implements Plugin<Project> {
	/**
	 * Name of the {@code optional} configuration.
	 */
	public static final String OPTIONAL_CONFIGURATION_NAME = 'optional';
	@Override
	public void apply(Project project) {
		Configuration optional = project.getConfigurations().create('optional');
		optional.setCanBeConsumed(false);
		optional.setCanBeResolved(false);
		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> {
			SourceSetContainer sourceSets = project.getExtensions()
				.getByType(JavaPluginExtension.class)
				.getSourceSets();
			sourceSets.all((sourceSet) -> {
				project.getConfigurations()
					.getByName(sourceSet.getCompileClasspathConfigurationName())
					.extendsFrom(optional);
				project.getConfigurations()
					.getByName(sourceSet.getRuntimeClasspathConfigurationName())
					.extendsFrom(optional);
			});
		});
	}
}
/*
package org.springframework.boot.build;
/**
class MavenPublishingConventions {
	private static final Logger logger = LoggerFactory.getLogger(MavenPublishingConventions.class);
	void apply(Project project) {
		project.getPlugins().withType(MavenPublishPlugin.class).all((mavenPublish) -> {
			PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
			if (project.hasProperty('deploymentRepository')) {
				publishing.getRepositories().maven((mavenRepository) -> {
					mavenRepository.setUrl(project.property('deploymentRepository'));
					mavenRepository.setName('deployment');
				});
			}
			publishing.getPublications()
				.withType(MavenPublication.class)
				.all((mavenPublication) -> customizeMavenPublication(mavenPublication, project));
			project.getPlugins().withType(JavaPlugin.class).all((javaPlugin) -> {
				JavaPluginExtension extension = project.getExtensions().getByType(JavaPluginExtension.class);
				extension.withJavadocJar();
				extension.withSourcesJar();
			});
		});
	}
	private void customizeMavenPublication(MavenPublication publication, Project project) {
		customizePom(publication.getPom(), project);
		project.getPlugins()
			.withType(JavaPlugin.class)
			.all((javaPlugin) -> customizeJavaMavenPublication(publication, project));
	}
	private void customizePom(MavenPom pom, Project project) {
		pom.getUrl().set('https://spring.io/projects/spring-boot');
		pom.getName().set(project.provider(project::getName));
		pom.getDescription().set(project.provider(project::getDescription));
		if (!isUserInherited(project)) {
			pom.organization(this::customizeOrganization);
		}
		pom.licenses(this::customizeLicences);
		pom.developers(this::customizeDevelopers);
		pom.scm((scm) -> customizeScm(scm, project));
		pom.issueManagement((issueManagement) -> customizeIssueManagement(issueManagement, project));
	}
	private void customizeJavaMavenPublication(MavenPublication publication, Project project) {
		publication.versionMapping((strategy) -> strategy.usage(Usage.JAVA_API, (mappingStrategy) -> mappingStrategy
			.fromResolutionOf(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME)));
		publication.versionMapping(
				(strategy) -> strategy.usage(Usage.JAVA_RUNTIME, VariantVersionMappingStrategy::fromResolutionResult));
	}
	private void customizeOrganization(MavenPomOrganization organization) {
		organization.getName().set('VMware, Inc.');
		organization.getUrl().set('https://spring.io');
	}
	private void customizeLicences(MavenPomLicenseSpec licences) {
		licences.license((licence) -> {
			licence.getName().set('Apache License, Version 2.0');
			licence.getUrl().set('https://www.apache.org/licenses/LICENSE-2.0');
		});
	}
	private void customizeDevelopers(MavenPomDeveloperSpec developers) {
		developers.developer((developer) -> {
			developer.getName().set('Spring');
			developer.getEmail().set('ask@spring.io');
			developer.getOrganization().set('VMware, Inc.');
			developer.getOrganizationUrl().set('https://www.spring.io');
		});
	}
	private void customizeScm(MavenPomScm scm, Project project) {
		if (BuildProperties.get(project).buildType() != BuildType.OPEN_SOURCE) {
			logger.debug('Skipping Maven POM SCM for non open source build type');
			return;
		}
		scm.getUrl().set('https://github.com/spring-projects/spring-boot');
		if (!isUserInherited(project)) {
			scm.getConnection().set('scm:git:git://github.com/spring-projects/spring-boot.git');
			scm.getDeveloperConnection().set('scm:git:ssh://git@github.com/spring-projects/spring-boot.git');
		}
	}
	private void customizeIssueManagement(MavenPomIssueManagement issueManagement, Project project) {
		if (BuildProperties.get(project).buildType() != BuildType.OPEN_SOURCE) {
			logger.debug('Skipping Maven POM SCM for non open source build type');
			return;
		}
		if (!isUserInherited(project)) {
			issueManagement.getSystem().set('GitHub');
			issueManagement.getUrl().set('https://github.com/spring-projects/spring-boot/issues');
		}
	}
	private boolean isUserInherited(Project project) {
		return 'spring-boot-starter-parent'.equals(project.getName())
				|| 'spring-boot-dependencies'.equals(project.getName());
	}
}
/*
package org.springframework.boot.build;
/**
public class NoHttpConventions {
	void apply(Project project) {
		project.getPluginManager().apply(NoHttpCheckstylePlugin.class);
		configureNoHttpExtension(project, project.getExtensions().getByType(NoHttpExtension.class));
		project.getTasks()
			.named(NoHttpCheckstylePlugin.CHECKSTYLE_NOHTTP_TASK_NAME, Checkstyle.class)
			.configure((task) -> task.getConfigDirectory().set(project.getRootProject().file('src/nohttp')));
	}
	private void configureNoHttpExtension(Project project, NoHttpExtension extension) {
		extension.setAllowlistFile(project.getRootProject().file('src/nohttp/allowlist.lines'));
		ConfigurableFileTree source = extension.getSource();
		source.exclude('bin/**');
		source.exclude('build/**');
		source.exclude('out/**');
		source.exclude('target/**');
		source.exclude('.settings/**');
		source.exclude('.classpath');
		source.exclude('.project');
		source.exclude('.gradle');
		source.exclude('**/docker/export.tar');
	}
}
/*
package org.springframework.boot.build.testing;
/**
public abstract class TestResultsOverview
		implements BuildService<BuildServiceParameters.None>, OperationCompletionListener, AutoCloseable {
	private final Map<Test, List<TestFailure>> testFailures = new TreeMap<>(Comparator.comparing(DefaultTask::getPath));
	private final Object monitor = new Object();
	void addFailures(Test test, List<TestDescriptor> failureDescriptors) {
		List<TestFailure> testFailures = failureDescriptors.stream().map(TestFailure::new).sorted().toList();
		synchronized (this.monitor) {
			this.testFailures.put(test, testFailures);
		}
	}
	@Override
	public void onFinish(FinishEvent event) {
		// OperationCompletionListener is implemented to defer close until the build ends
	}
	@Override
	public void close() {
		synchronized (this.monitor) {
			if (this.testFailures.isEmpty()) {
				return;
			}
			System.err.println();
			System.err.println('Found test failures in ' + this.testFailures.size() + ' test task'
					+ ((this.testFailures.size() == 1) ? ':' : 's:'));
			this.testFailures.forEach((task, failures) -> {
				System.err.println();
				System.err.println(task.getPath());
				failures.forEach((failure) -> System.err
					.println('    ' + failure.descriptor.getClassName() + ' > ' + failure.descriptor.getName()));
			});
		}
	}
	private static final class TestFailure implements Comparable<TestFailure> {
		private final TestDescriptor descriptor;
		private TestFailure(TestDescriptor descriptor) {
			this.descriptor = descriptor;
		}
		@Override
		public int compareTo(TestFailure other) {
			int comparison = this.descriptor.getClassName().compareTo(other.descriptor.getClassName());
			if (comparison == 0) {
				comparison = this.descriptor.getName().compareTo(other.descriptor.getName());
			}
			return comparison;
		}
	}
}
/*
package org.springframework.boot.build.testing;
/**
public class TestFailuresPlugin implements Plugin<Project> {
	@Override
	public void apply(Project project) {
		Provider<TestResultsOverview> testResultsOverview = project.getGradle()
			.getSharedServices()
			.registerIfAbsent('testResultsOverview', TestResultsOverview.class, (spec) -> {
			});
		project.getTasks().withType(Test.class, (test) -> {
			test.usesService(testResultsOverview);
			test.addTestListener(new FailureRecordingTestListener(testResultsOverview, test));
		});
	}
	private final class FailureRecordingTestListener implements TestListener {
		private final List<TestDescriptor> failures = new ArrayList<>();
		private final Provider<TestResultsOverview> testResultsOverview;
		private final Test test;
		private FailureRecordingTestListener(Provider<TestResultsOverview> testResultOverview, Test test) {
			this.testResultsOverview = testResultOverview;
			this.test = test;
		}
		@Override
		public void afterSuite(TestDescriptor descriptor, TestResult result) {
			if (!this.failures.isEmpty()) {
				this.testResultsOverview.get().addFailures(this.test, this.failures);
			}
		}
		@Override
		public void afterTest(TestDescriptor descriptor, TestResult result) {
			if (result.getFailedTestCount() > 0) {
				this.failures.add(descriptor);
			}
		}
		@Override
		public void beforeSuite(TestDescriptor descriptor) {
		}
		@Override
		public void beforeTest(TestDescriptor descriptor) {
		}
	}
}
/*
package org.springframework.boot.build.mavenplugin;
/**
public abstract class MavenExec extends JavaExec {
	private final Logger logger = LoggerFactory.getLogger(MavenExec.class);
	public MavenExec() {
		setClasspath(mavenConfiguration(getProject()));
		args('--batch-mode');
		getMainClass().set('org.apache.maven.cli.MavenCli');
		getPom().set(getProjectDir().file('pom.xml'));
	}
	@Internal
	public abstract DirectoryProperty getProjectDir();
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	abstract RegularFileProperty getPom();
	@Override
	public void exec() {
		File workingDir = getProjectDir().getAsFile().get();
		workingDir(workingDir);
		systemProperty('maven.multiModuleProjectDirectory', workingDir.getAbsolutePath());
		try {
			Path logFile = Files.createTempFile(getName(), '.log');
			try {
				args('--log-file', logFile.toFile().getAbsolutePath());
				super.exec();
				if (this.logger.isInfoEnabled()) {
					Files.readAllLines(logFile).forEach(this.logger::info);
				}
			}
			catch (ExecException ex) {
				System.out.println('Exec exception! Dumping log');
				Files.readAllLines(logFile).forEach(System.out::println);
				throw ex;
			}
		}
		catch (IOException ex) {
			throw new TaskExecutionException(this, ex);
		}
	}
	private Configuration mavenConfiguration(Project project) {
		Configuration existing = project.getConfigurations().findByName('maven');
		if (existing != null) {
			return existing;
		}
		return project.getConfigurations().create('maven', (maven) -> {
			maven.getDependencies().add(project.getDependencies().create('org.apache.maven:maven-embedder:3.6.3'));
			maven.getDependencies().add(project.getDependencies().create('org.apache.maven:maven-compat:3.6.3'));
			maven.getDependencies().add(project.getDependencies().create('org.slf4j:slf4j-simple:1.7.5'));
			maven.getDependencies()
				.add(project.getDependencies()
					.create('org.apache.maven.resolver:maven-resolver-connector-basic:1.4.1'));
			maven.getDependencies()
				.add(project.getDependencies().create('org.apache.maven.resolver:maven-resolver-transport-http:1.4.1'));
		});
	}
}
/*
package org.springframework.boot.build.mavenplugin;
/**
class PluginXmlParser {
	private final XPath xpath;
	PluginXmlParser() {
		this.xpath = XPathFactory.newInstance().newXPath();
	}
	Plugin parse(File pluginXml) {
		try {
			Node root = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(pluginXml);
			List<Mojo> mojos = parseMojos(root);
			return new Plugin(textAt('//plugin/groupId', root), textAt('//plugin/artifactId', root),
					textAt('//plugin/version', root), textAt('//plugin/goalPrefix', root), mojos);
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	private String textAt(String path, Node source) throws XPathExpressionException {
		String text = this.xpath.evaluate(path + '/text()', source);
		return text.isEmpty() ? null : text;
	}
	private List<Mojo> parseMojos(Node plugin) throws XPathExpressionException {
		List<Mojo> mojos = new ArrayList<>();
		for (Node mojoNode : nodesAt('//plugin/mojos/mojo', plugin)) {
			mojos.add(new Mojo(textAt('goal', mojoNode), format(textAt('description', mojoNode)),
					parseParameters(mojoNode)));
		}
		return mojos;
	}
	private Iterable<Node> nodesAt(String path, Node source) throws XPathExpressionException {
		return IterableNodeList.of((NodeList) this.xpath.evaluate(path, source, XPathConstants.NODESET));
	}
	private List<Parameter> parseParameters(Node mojoNode) throws XPathExpressionException {
		Map<String, String> defaultValues = new HashMap<>();
		Map<String, String> userProperties = new HashMap<>();
		for (Node parameterConfigurationNode : nodesAt('configuration/*', mojoNode)) {
			String userProperty = parameterConfigurationNode.getTextContent();
			if (userProperty != null && !userProperty.isEmpty()) {
				userProperties.put(parameterConfigurationNode.getNodeName(),
						userProperty.replace('${', '`').replace('}', '`'));
			}
			Node defaultValueAttribute = parameterConfigurationNode.getAttributes().getNamedItem('default-value');
			if (defaultValueAttribute != null && !defaultValueAttribute.getTextContent().isEmpty()) {
				defaultValues.put(parameterConfigurationNode.getNodeName(), defaultValueAttribute.getTextContent());
			}
		}
		List<Parameter> parameters = new ArrayList<>();
		for (Node parameterNode : nodesAt('parameters/parameter', mojoNode)) {
			parameters.add(parseParameter(parameterNode, defaultValues, userProperties));
		}
		return parameters;
	}
	private Parameter parseParameter(Node parameterNode, Map<String, String> defaultValues,
			Map<String, String> userProperties) throws XPathExpressionException {
		String description = textAt('description', parameterNode);
		return new Parameter(textAt('name', parameterNode), textAt('type', parameterNode),
				booleanAt('required', parameterNode), booleanAt('editable', parameterNode),
				(description != null) ? format(description) : '', defaultValues.get(textAt('name', parameterNode)),
				userProperties.get(textAt('name', parameterNode)), textAt('since', parameterNode));
	}
	private boolean booleanAt(String path, Node node) throws XPathExpressionException {
		return Boolean.parseBoolean(textAt(path, node));
	}
	private String format(String input) {
		return input.replace('<code>', '`')
			.replace('</code>', '`')
			.replace('&lt;', '<')
			.replace('&gt;', '>')
			.replace('<br>', ' ')
			.replace('\n', ' ')
			.replace('&quot;', '\'')
			.replaceAll('\\{@code (.*?)}', '`$1`')
			.replaceAll('\\{@link (.*?)}', '`$1`')
			.replaceAll('\\{@literal (.*?)}', '`$1`')
			.replaceAll('<a href=.\'(.*?)\'.>(.*?)</a>', '$1[$2]');
	}
	private static final class IterableNodeList implements Iterable<Node> {
		private final NodeList nodeList;
		private IterableNodeList(NodeList nodeList) {
			this.nodeList = nodeList;
		}
		private static Iterable<Node> of(NodeList nodeList) {
			return new IterableNodeList(nodeList);
		}
		@Override
		public Iterator<Node> iterator() {
			return new Iterator<>() {
				private int index = 0;
				@Override
				public boolean hasNext() {
					return this.index < IterableNodeList.this.nodeList.getLength();
				}
				@Override
				public Node next() {
					return IterableNodeList.this.nodeList.item(this.index++);
				}
			};
		}
	}
	static final class Plugin {
		private final String groupId;
		private final String artifactId;
		private final String version;
		private final String goalPrefix;
		private final List<Mojo> mojos;
		private Plugin(String groupId, String artifactId, String version, String goalPrefix, List<Mojo> mojos) {
			this.groupId = groupId;
			this.artifactId = artifactId;
			this.version = version;
			this.goalPrefix = goalPrefix;
			this.mojos = mojos;
		}
		String getGroupId() {
			return this.groupId;
		}
		String getArtifactId() {
			return this.artifactId;
		}
		String getVersion() {
			return this.version;
		}
		String getGoalPrefix() {
			return this.goalPrefix;
		}
		List<Mojo> getMojos() {
			return this.mojos;
		}
	}
	static final class Mojo {
		private final String goal;
		private final String description;
		private final List<Parameter> parameters;
		private Mojo(String goal, String description, List<Parameter> parameters) {
			this.goal = goal;
			this.description = description;
			this.parameters = parameters;
		}
		String getGoal() {
			return this.goal;
		}
		String getDescription() {
			return this.description;
		}
		List<Parameter> getParameters() {
			return this.parameters;
		}
	}
	static final class Parameter {
		private final String name;
		private final String type;
		private final boolean required;
		private final boolean editable;
		private final String description;
		private final String defaultValue;
		private final String userProperty;
		private final String since;
		private Parameter(String name, String type, boolean required, boolean editable, String description,
				String defaultValue, String userProperty, String since) {
			this.name = name;
			this.type = type;
			this.required = required;
			this.editable = editable;
			this.description = description;
			this.defaultValue = defaultValue;
			this.userProperty = userProperty;
			this.since = since;
		}
		String getName() {
			return this.name;
		}
		String getType() {
			return this.type;
		}
		boolean isRequired() {
			return this.required;
		}
		boolean isEditable() {
			return this.editable;
		}
		String getDescription() {
			return this.description;
		}
		String getDefaultValue() {
			return this.defaultValue;
		}
		String getUserProperty() {
			return this.userProperty;
		}
		String getSince() {
			return this.since;
		}
	}
}
/*
package org.springframework.boot.build.mavenplugin;
/**
public abstract class DocumentPluginGoals extends DefaultTask {
	private final PluginXmlParser parser = new PluginXmlParser();
	@OutputDirectory
	public abstract DirectoryProperty getOutputDir();
	@Input
	public abstract MapProperty<String, String> getGoalSections();
	@InputFile
	public abstract RegularFileProperty getPluginXml();
	@TaskAction
	public void documentPluginGoals() throws IOException {
		Plugin plugin = this.parser.parse(getPluginXml().getAsFile().get());
		writeOverview(plugin);
		for (Mojo mojo : plugin.getMojos()) {
			documentMojo(plugin, mojo);
		}
	}
	private void writeOverview(Plugin plugin) throws IOException {
		try (PrintWriter writer = new PrintWriter(
				new FileWriter(new File(getOutputDir().getAsFile().get(), 'overview.adoc')))) {
			writer.println('[cols=\'1,3\']');
			writer.println('|===');
			writer.println('| Goal | Description');
			writer.println();
			for (Mojo mojo : plugin.getMojos()) {
				writer.printf('| xref:%s[%s:%s]%n', goalSectionId(mojo, false), plugin.getGoalPrefix(), mojo.getGoal());
				writer.printf('| %s%n', mojo.getDescription());
				writer.println();
			}
			writer.println('|===');
		}
	}
	private void documentMojo(Plugin plugin, Mojo mojo) throws IOException {
		try (PrintWriter writer = new PrintWriter(
				new FileWriter(new File(getOutputDir().getAsFile().get(), mojo.getGoal() + '.adoc')))) {
			String sectionId = goalSectionId(mojo, true);
			writer.printf('[[%s]]%n', sectionId);
			writer.printf('= `%s:%s`%n%n', plugin.getGoalPrefix(), mojo.getGoal());
			writer.printf('`%s:%s:%s`%n', plugin.getGroupId(), plugin.getArtifactId(), plugin.getVersion());
			writer.println();
			writer.println(mojo.getDescription());
			List<Parameter> parameters = mojo.getParameters().stream().filter(Parameter::isEditable).toList();
			List<Parameter> requiredParameters = parameters.stream().filter(Parameter::isRequired).toList();
			String detailsSectionId = sectionId + '.parameter-details';
			if (!requiredParameters.isEmpty()) {
				writer.println();
				writer.println();
				writer.println();
				writer.printf('[[%s.required-parameters]]%n', sectionId);
				writer.println('== Required parameters');
				writer.println();
				writeParametersTable(writer, detailsSectionId, requiredParameters);
			}
			List<Parameter> optionalParameters = parameters.stream()
				.filter((parameter) -> !parameter.isRequired())
				.toList();
			if (!optionalParameters.isEmpty()) {
				writer.println();
				writer.println();
				writer.println();
				writer.printf('[[%s.optional-parameters]]%n', sectionId);
				writer.println('== Optional parameters');
				writer.println();
				writeParametersTable(writer, detailsSectionId, optionalParameters);
			}
			writer.println();
			writer.println();
			writer.println();
			writer.printf('[[%s]]%n', detailsSectionId);
			writer.println('== Parameter details');
			writer.println();
			writeParameterDetails(writer, parameters, detailsSectionId);
		}
	}
	private String goalSectionId(Mojo mojo, boolean innerReference) {
		String goalSection = getGoalSections().getting(mojo.getGoal()).get();
		if (goalSection == null) {
			throw new IllegalStateException('Goal "' + mojo.getGoal() + '" has not be assigned to a section');
		}
		String sectionId = goalSection + '.' + mojo.getGoal() + '-goal';
		return (!innerReference) ? goalSection + '#' + sectionId : sectionId;
	}
	private void writeParametersTable(PrintWriter writer, String detailsSectionId, List<Parameter> parameters) {
		writer.println('[cols=\'3,2,3\']');
		writer.println('|===');
		writer.println('| Name | Type | Default');
		writer.println();
		for (Parameter parameter : parameters) {
			String name = parameter.getName();
			writer.printf('| xref:#%s.%s[%s]%n', detailsSectionId, parameterId(name), name);
			writer.printf('| `%s`%n', typeNameToJavadocLink(shortTypeName(parameter.getType()), parameter.getType()));
			String defaultValue = parameter.getDefaultValue();
			if (defaultValue != null) {
				writer.printf('| `%s`%n', defaultValue);
			}
			else {
				writer.println('|');
			}
			writer.println();
		}
		writer.println('|===');
	}
	private void writeParameterDetails(PrintWriter writer, List<Parameter> parameters, String sectionId) {
		for (Parameter parameter : parameters) {
			String name = parameter.getName();
			writer.println();
			writer.println();
			writer.printf('[[%s.%s]]%n', sectionId, parameterId(name));
			writer.printf('=== `%s`%n', name);
			writer.println(parameter.getDescription());
			writer.println();
			writer.println('[cols=\'10h,90\']');
			writer.println('|===');
			writer.println();
			writeDetail(writer, 'Name', name);
			writeDetail(writer, 'Type', typeNameToJavadocLink(parameter.getType()));
			writeOptionalDetail(writer, 'Default value', parameter.getDefaultValue());
			writeOptionalDetail(writer, 'User property', parameter.getUserProperty());
			writeOptionalDetail(writer, 'Since', parameter.getSince());
			writer.println('|===');
		}
	}
	private String parameterId(String name) {
		StringBuilder id = new StringBuilder(name.length() + 4);
		for (char c : name.toCharArray()) {
			if (Character.isLowerCase(c)) {
				id.append(c);
			}
			else {
				id.append('-');
				id.append(Character.toLowerCase(c));
			}
		}
		return id.toString();
	}
	private void writeDetail(PrintWriter writer, String name, String value) {
		writer.printf('| %s%n', name);
		writer.printf('| `%s`%n', value);
		writer.println();
	}
	private void writeOptionalDetail(PrintWriter writer, String name, String value) {
		writer.printf('| %s%n', name);
		if (value != null) {
			writer.printf('| `%s`%n', value);
		}
		else {
			writer.println('|');
		}
		writer.println();
	}
	private String shortTypeName(String name) {
		if (name.lastIndexOf(".") >= 0) {
			name = name.substring(name.lastIndexOf(".") + 1);
		}
		if (name.lastIndexOf("$") >= 0) {
			name = name.substring(name.lastIndexOf("$") + 1);
		}
		return name;
	}
	private String typeNameToJavadocLink(String name) {
		return typeNameToJavadocLink(name, name);
	}
	private String typeNameToJavadocLink(String shortName, String name) {
		if (name.startsWith('org.springframework.boot.maven')) {
			return 'xref:maven-plugin:api/java/' + typeNameToJavadocPath(name) + '.html[' + shortName + ']';
		}
		if (name.startsWith('org.springframework.boot')) {
			return 'xref:api:java/' + typeNameToJavadocPath(name) + '.html[' + shortName + ']';
		}
		return shortName;
	}
	private String typeNameToJavadocPath(String name) {
		return name.replace('.', '/').replace('$', '.');
	}
}
/*
package org.springframework.boot.build.mavenplugin;
/**
public class MavenPluginPlugin implements Plugin<Project> {
	@Override
	public void apply(Project project) {
		project.getPlugins().apply(JavaLibraryPlugin.class);
		project.getPlugins().apply(MavenPublishPlugin.class);
		project.getPlugins().apply(DeployedPlugin.class);
		project.getPlugins().apply(MavenRepositoryPlugin.class);
		project.getPlugins().apply(IntegrationTestPlugin.class);
		Jar jarTask = (Jar) project.getTasks().getByName(JavaPlugin.JAR_TASK_NAME);
		configurePomPackaging(project);
		addPopulateIntTestMavenRepositoryTask(project);
		MavenExec generateHelpMojoTask = addGenerateHelpMojoTask(project, jarTask);
		MavenExec generatePluginDescriptorTask = addGeneratePluginDescriptorTask(project, jarTask,
				generateHelpMojoTask);
		addDocumentPluginGoalsTask(project, generatePluginDescriptorTask);
		addPrepareMavenBinariesTask(project);
		addExtractVersionPropertiesTask(project);
		publishOptionalDependenciesInPom(project);
		project.getTasks().withType(GenerateModuleMetadata.class).configureEach((task) -> task.setEnabled(false));
	}
	private void publishOptionalDependenciesInPom(Project project) {
		project.getPlugins().withType(OptionalDependenciesPlugin.class, (optionalDependencies) -> {
			SoftwareComponent component = project.getComponents().findByName('java');
			if (component instanceof AdhocComponentWithVariants componentWithVariants) {
				componentWithVariants.addVariantsFromConfiguration(
						project.getConfigurations().getByName(OptionalDependenciesPlugin.OPTIONAL_CONFIGURATION_NAME),
						ConfigurationVariantDetails::mapToOptional);
			}
		});
		MavenPublication publication = (MavenPublication) project.getExtensions()
			.getByType(PublishingExtension.class)
			.getPublications()
			.getByName('maven');
		publication.getPom().withXml((xml) -> {
			Element root = xml.asElement();
			NodeList children = root.getChildNodes();
			for (int i = 0; i < children.getLength(); i++) {
				Node child = children.item(i);
				if ('dependencyManagement'.equals(child.getNodeName())) {
					root.removeChild(child);
				}
			}
		});
	}
	private void configurePomPackaging(Project project) {
		PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
		publishing.getPublications().withType(MavenPublication.class, this::setPackaging);
	}
	private void setPackaging(MavenPublication mavenPublication) {
		mavenPublication.pom((pom) -> pom.setPackaging('maven-plugin'));
	}
	private void addPopulateIntTestMavenRepositoryTask(Project project) {
		Configuration runtimeClasspathWithMetadata = project.getConfigurations().create('runtimeClasspathWithMetadata');
		runtimeClasspathWithMetadata
			.extendsFrom(project.getConfigurations().getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME));
		runtimeClasspathWithMetadata.attributes((attributes) -> attributes.attribute(DocsType.DOCS_TYPE_ATTRIBUTE,
				project.getObjects().named(DocsType.class, 'maven-repository')));
		RuntimeClasspathMavenRepository runtimeClasspathMavenRepository = project.getTasks()
			.create('runtimeClasspathMavenRepository', RuntimeClasspathMavenRepository.class);
		runtimeClasspathMavenRepository.getOutputDir()
			.set(project.getLayout().getBuildDirectory().dir('runtime-classpath-repository'));
		project.getDependencies()
			.components((components) -> components.all(MavenRepositoryComponentMetadataRule.class));
		Sync task = project.getTasks().create('populateTestMavenRepository', Sync.class);
		task.setDestinationDir(project.getLayout().getBuildDirectory().dir('test-maven-repository').get().getAsFile());
		task.with(copyIntTestMavenRepositoryFiles(project, runtimeClasspathMavenRepository));
		task.dependsOn(project.getTasks().getByName(MavenRepositoryPlugin.PUBLISH_TO_PROJECT_REPOSITORY_TASK_NAME));
		project.getTasks().getByName(IntegrationTestPlugin.INT_TEST_TASK_NAME).dependsOn(task);
		project.getPlugins()
			.withType(DockerTestPlugin.class)
			.all((dockerTestPlugin) -> project.getTasks()
				.named(DockerTestPlugin.DOCKER_TEST_TASK_NAME, (dockerTest) -> dockerTest.dependsOn(task)));
	}
	private CopySpec copyIntTestMavenRepositoryFiles(Project project,
			RuntimeClasspathMavenRepository runtimeClasspathMavenRepository) {
		CopySpec copySpec = project.copySpec();
		copySpec.from(project.getConfigurations().getByName(MavenRepositoryPlugin.MAVEN_REPOSITORY_CONFIGURATION_NAME));
		copySpec.from(project.getLayout().getBuildDirectory().dir('maven-repository'));
		copySpec.from(runtimeClasspathMavenRepository);
		return copySpec;
	}
	private void addDocumentPluginGoalsTask(Project project, MavenExec generatePluginDescriptorTask) {
		DocumentPluginGoals task = project.getTasks().create('documentPluginGoals', DocumentPluginGoals.class);
		File pluginXml = new File(generatePluginDescriptorTask.getOutputs().getFiles().getSingleFile(), 'plugin.xml');
		task.getPluginXml().set(pluginXml);
		task.getOutputDir().set(project.getLayout().getBuildDirectory().dir('docs/generated/goals/'));
		task.dependsOn(generatePluginDescriptorTask);
	}
	private MavenExec addGenerateHelpMojoTask(Project project, Jar jarTask) {
		Provider<Directory> helpMojoDir = project.getLayout().getBuildDirectory().dir('help-mojo');
		MavenExec task = createGenerateHelpMojoTask(project, helpMojoDir);
		task.dependsOn(createSyncHelpMojoInputsTask(project, helpMojoDir));
		includeHelpMojoInJar(jarTask, task);
		return task;
	}
	private MavenExec createGenerateHelpMojoTask(Project project, Provider<Directory> helpMojoDir) {
		MavenExec task = project.getTasks().create('generateHelpMojo', MavenExec.class);
		task.getProjectDir().set(helpMojoDir);
		task.args('org.apache.maven.plugins:maven-plugin-plugin:3.6.1:helpmojo');
		task.getOutputs().dir(helpMojoDir.map((directory) -> directory.dir('target/generated-sources/plugin')));
		return task;
	}
	private Sync createSyncHelpMojoInputsTask(Project project, Provider<Directory> helpMojoDir) {
		Sync task = project.getTasks().create('syncHelpMojoInputs', Sync.class);
		task.setDestinationDir(helpMojoDir.get().getAsFile());
		File pomFile = new File(project.getProjectDir(), 'src/maven/resources/pom.xml');
		task.from(pomFile, (copy) -> replaceVersionPlaceholder(copy, project));
		return task;
	}
	private void includeHelpMojoInJar(Jar jarTask, JavaExec generateHelpMojoTask) {
		jarTask.from(generateHelpMojoTask).exclude('**/*.java');
		jarTask.dependsOn(generateHelpMojoTask);
	}
	private MavenExec addGeneratePluginDescriptorTask(Project project, Jar jarTask, MavenExec generateHelpMojoTask) {
		Provider<Directory> pluginDescriptorDir = project.getLayout().getBuildDirectory().dir('plugin-descriptor');
		Provider<Directory> generatedHelpMojoDir = project.getLayout()
			.getBuildDirectory()
			.dir('generated/sources/helpMojo');
		SourceSet mainSourceSet = getMainSourceSet(project);
		project.getTasks().withType(Javadoc.class, this::setJavadocOptions);
		FormatHelpMojoSource formattedHelpMojoSource = createFormatHelpMojoSource(project, generateHelpMojoTask,
				generatedHelpMojoDir);
		project.getTasks().getByName(mainSourceSet.getCompileJavaTaskName()).dependsOn(formattedHelpMojoSource);
		mainSourceSet.java((javaSources) -> javaSources.srcDir(formattedHelpMojoSource));
		Sync pluginDescriptorInputs = createSyncPluginDescriptorInputs(project, pluginDescriptorDir, mainSourceSet);
		pluginDescriptorInputs.dependsOn(mainSourceSet.getClassesTaskName());
		MavenExec task = createGeneratePluginDescriptorTask(project, pluginDescriptorDir);
		task.dependsOn(pluginDescriptorInputs);
		includeDescriptorInJar(jarTask, task);
		return task;
	}
	private SourceSet getMainSourceSet(Project project) {
		SourceSetContainer sourceSets = project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets();
		return sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
	}
	private void setJavadocOptions(Javadoc javadoc) {
		StandardJavadocDocletOptions options = (StandardJavadocDocletOptions) javadoc.getOptions();
		options.addMultilineStringsOption('tag').setValue(Arrays.asList('goal:X', 'requiresProject:X', 'threadSafe:X'));
	}
	private FormatHelpMojoSource createFormatHelpMojoSource(Project project, MavenExec generateHelpMojoTask,
			Provider<Directory> generatedHelpMojoDir) {
		FormatHelpMojoSource formatHelpMojoSource = project.getTasks()
			.create('formatHelpMojoSource', FormatHelpMojoSource.class);
		formatHelpMojoSource.setGenerator(generateHelpMojoTask);
		formatHelpMojoSource.getOutputDir().set(generatedHelpMojoDir);
		return formatHelpMojoSource;
	}
	private Sync createSyncPluginDescriptorInputs(Project project, Provider<Directory> destination,
			SourceSet sourceSet) {
		Sync pluginDescriptorInputs = project.getTasks().create('syncPluginDescriptorInputs', Sync.class);
		pluginDescriptorInputs.setDestinationDir(destination.get().getAsFile());
		File pomFile = new File(project.getProjectDir(), 'src/maven/resources/pom.xml');
		pluginDescriptorInputs.from(pomFile, (copy) -> replaceVersionPlaceholder(copy, project));
		pluginDescriptorInputs.from(sourceSet.getOutput().getClassesDirs(), (sync) -> sync.into('target/classes'));
		pluginDescriptorInputs.from(sourceSet.getAllJava().getSrcDirs(), (sync) -> sync.into('src/main/java'));
		pluginDescriptorInputs.getInputs().property('version', project.getVersion());
		return pluginDescriptorInputs;
	}
	private MavenExec createGeneratePluginDescriptorTask(Project project, Provider<Directory> mavenDir) {
		MavenExec generatePluginDescriptor = project.getTasks().create('generatePluginDescriptor', MavenExec.class);
		generatePluginDescriptor.args('org.apache.maven.plugins:maven-plugin-plugin:3.6.1:descriptor');
		generatePluginDescriptor.getOutputs()
			.dir(mavenDir.map((directory) -> directory.dir('target/classes/META-INF/maven')));
		generatePluginDescriptor.getInputs()
			.dir(mavenDir.map((directory) -> directory.dir('target/classes/org')))
			.withPathSensitivity(PathSensitivity.RELATIVE)
			.withPropertyName('plugin classes');
		generatePluginDescriptor.getProjectDir().set(mavenDir);
		return generatePluginDescriptor;
	}
	private void includeDescriptorInJar(Jar jar, JavaExec generatePluginDescriptorTask) {
		jar.from(generatePluginDescriptorTask, (copy) -> copy.into('META-INF/maven/'));
		jar.dependsOn(generatePluginDescriptorTask);
	}
	private void addPrepareMavenBinariesTask(Project project) {
		TaskProvider<PrepareMavenBinaries> task = project.getTasks()
			.register('prepareMavenBinaries', PrepareMavenBinaries.class,
					(prepareMavenBinaries) -> prepareMavenBinaries.getOutputDir()
						.set(project.getLayout().getBuildDirectory().dir('maven-binaries')));
		project.getTasks()
			.getByName(IntegrationTestPlugin.INT_TEST_TASK_NAME)
			.getInputs()
			.dir(task.map(PrepareMavenBinaries::getOutputDir))
			.withPathSensitivity(PathSensitivity.RELATIVE)
			.withPropertyName('mavenBinaries');
	}
	private void replaceVersionPlaceholder(CopySpec copy, Project project) {
		copy.filter((input) -> replaceVersionPlaceholder(project, input));
	}
	private String replaceVersionPlaceholder(Project project, String input) {
		return input.replace('{{version}}', project.getVersion().toString());
	}
	private void addExtractVersionPropertiesTask(Project project) {
		ExtractVersionProperties extractVersionProperties = project.getTasks()
			.create('extractVersionProperties', ExtractVersionProperties.class);
		extractVersionProperties.setEffectiveBoms(project.getConfigurations().create('versionProperties'));
		extractVersionProperties.getDestination()
			.set(project.getLayout()
				.getBuildDirectory()
				.dir('generated-resources')
				.map((dir) -> dir.file('extracted-versions.properties')));
	}
	public abstract static class FormatHelpMojoSource extends DefaultTask {
		private Task generator;
		void setGenerator(Task generator) {
			this.generator = generator;
			getInputs().files(this.generator)
				.withPathSensitivity(PathSensitivity.RELATIVE)
				.withPropertyName('generated source');
		}
		@OutputDirectory
		public abstract DirectoryProperty getOutputDir();
		@TaskAction
		void syncAndFormat() {
			FileFormatter formatter = new FileFormatter();
			for (File output : this.generator.getOutputs().getFiles()) {
				formatter.formatFiles(getProject().fileTree(output), StandardCharsets.UTF_8)
					.forEach((edit) -> save(output, edit));
			}
		}
		private void save(File output, FileEdit edit) {
			Path relativePath = output.toPath().relativize(edit.getFile().toPath());
			Path outputLocation = getOutputDir().getAsFile().get().toPath().resolve(relativePath);
			try {
				Files.createDirectories(outputLocation.getParent());
				Files.writeString(outputLocation, edit.getFormattedContent());
			}
			catch (Exception ex) {
				throw new TaskExecutionException(this, ex);
			}
		}
	}
	public static class MavenRepositoryComponentMetadataRule implements ComponentMetadataRule {
		private final ObjectFactory objects;
		@javax.inject.Inject
		public MavenRepositoryComponentMetadataRule(ObjectFactory objects) {
			this.objects = objects;
		}
		@Override
		public void execute(ComponentMetadataContext context) {
			context.getDetails()
				.maybeAddVariant('compileWithMetadata', 'compile', (variant) -> configureVariant(context, variant));
			context.getDetails()
				.maybeAddVariant('apiElementsWithMetadata', 'apiElements',
						(variant) -> configureVariant(context, variant));
		}
		private void configureVariant(ComponentMetadataContext context, VariantMetadata variant) {
			variant.attributes((attributes) -> {
				attributes.attribute(DocsType.DOCS_TYPE_ATTRIBUTE,
						this.objects.named(DocsType.class, 'maven-repository'));
				attributes.attribute(Usage.USAGE_ATTRIBUTE, this.objects.named(Usage.class, 'maven-repository'));
			});
			variant.withFiles((files) -> {
				ModuleVersionIdentifier id = context.getDetails().getId();
				files.addFile(id.getName() + '-' + id.getVersion() + '.pom');
			});
		}
	}
	public abstract static class RuntimeClasspathMavenRepository extends DefaultTask {
		private final Configuration runtimeClasspath;
		public RuntimeClasspathMavenRepository() {
			this.runtimeClasspath = getProject().getConfigurations().getByName('runtimeClasspathWithMetadata');
		}
		@OutputDirectory
		public abstract DirectoryProperty getOutputDir();
		@Classpath
		public Configuration getRuntimeClasspath() {
			return this.runtimeClasspath;
		}
		@TaskAction
		public void createRepository() {
			for (ResolvedArtifactResult result : this.runtimeClasspath.getIncoming().getArtifacts()) {
				if (result.getId().getComponentIdentifier() instanceof ModuleComponentIdentifier identifier) {
					String fileName = result.getFile()
						.getName()
						.replace(identifier.getVersion() + '-' + identifier.getVersion(), identifier.getVersion());
					File repositoryLocation = getOutputDir()
						.dir(identifier.getGroup().replace(".", "/") + '/' + identifier.getModule() + '/'
								+ identifier.getVersion() + '/' + fileName)
						.get()
						.getAsFile();
					repositoryLocation.getParentFile().mkdirs();
					try {
						Files.copy(result.getFile().toPath(), repositoryLocation.toPath(),
								StandardCopyOption.REPLACE_EXISTING);
					}
					catch (IOException ex) {
						throw new RuntimeException('Failed to copy artifact "' + result + '"', ex);
					}
				}
			}
		}
	}
	public abstract static class ExtractVersionProperties extends DefaultTask {
		private FileCollection effectiveBoms;
		@InputFiles
		@PathSensitive(PathSensitivity.RELATIVE)
		public FileCollection getEffectiveBoms() {
			return this.effectiveBoms;
		}
		public void setEffectiveBoms(FileCollection effectiveBoms) {
			this.effectiveBoms = effectiveBoms;
		}
		@OutputFile
		public abstract RegularFileProperty getDestination();
		@TaskAction
		public void extractVersionProperties() {
			EffectiveBom effectiveBom = new EffectiveBom(this.effectiveBoms.getSingleFile());
			Properties versions = extractVersionProperties(effectiveBom);
			writeProperties(versions);
		}
		private void writeProperties(Properties versions) {
			File outputFile = getDestination().getAsFile().get();
			outputFile.getParentFile().mkdirs();
			try (Writer writer = new FileWriter(outputFile)) {
				versions.store(writer, null);
			}
			catch (IOException ex) {
				throw new GradleException('Failed to write extracted version properties', ex);
			}
		}
		private Properties extractVersionProperties(EffectiveBom effectiveBom) {
			Properties versions = CollectionFactory.createSortedProperties(true);
			versions.setProperty('project.version', effectiveBom.version());
			effectiveBom.property('log4j2.version', versions::setProperty);
			effectiveBom.property('maven-jar-plugin.version', versions::setProperty);
			effectiveBom.property('maven-war-plugin.version', versions::setProperty);
			effectiveBom.property('build-helper-maven-plugin.version', versions::setProperty);
			effectiveBom.property('spring-framework.version', versions::setProperty);
			effectiveBom.property('jakarta-servlet.version', versions::setProperty);
			effectiveBom.property('kotlin.version', versions::setProperty);
			effectiveBom.property('assertj.version', versions::setProperty);
			effectiveBom.property('junit-jupiter.version', versions::setProperty);
			return versions;
		}
	}
	private static final class EffectiveBom {
		private final Document document;
		private final XPath xpath;
		private EffectiveBom(File bomFile) {
			this.document = loadDocument(bomFile);
			this.xpath = XPathFactory.newInstance().newXPath();
		}
		private Document loadDocument(File bomFile) {
			try {
				try (InputStream inputStream = new FileInputStream(bomFile)) {
					DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
					DocumentBuilder builder = builderFactory.newDocumentBuilder();
					return builder.parse(inputStream);
				}
			}
			catch (ParserConfigurationException | SAXException | IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
		private String version() {
			return get('version');
		}
		private void property(String name, BiConsumer<String, String> handler) {
			handler.accept(name, get('properties/' + name));
		}
		private String get(String expression) {
			try {
				Node node = (Node) this.xpath.compile('/project/' + expression)
					.evaluate(this.document, XPathConstants.NODE);
				String text = (node != null) ? node.getTextContent() : null;
				Assert.hasLength(text, () -> 'No result for expression ' + expression);
				return text;
			}
			catch (XPathExpressionException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
}
/*
package org.springframework.boot.build.mavenplugin;
/**
public abstract class PrepareMavenBinaries extends DefaultTask {
	private final FileSystemOperations fileSystemOperations;
	private final ArchiveOperations archiveOperations;
	@Inject
	public PrepareMavenBinaries(FileSystemOperations fileSystemOperations, ArchiveOperations archiveOperations) {
		this.fileSystemOperations = fileSystemOperations;
		this.archiveOperations = archiveOperations;
	}
	@OutputDirectory
	public abstract DirectoryProperty getOutputDir();
	@Input
	public abstract SetProperty<String> getVersions();
	@TaskAction
	public void prepareBinaries() {
		this.fileSystemOperations.sync((sync) -> {
			sync.into(getOutputDir());
			for (String version : getVersions().get()) {
				Configuration configuration = getProject().getConfigurations()
					.detachedConfiguration(getProject().getDependencies()
						.create('org.apache.maven:apache-maven:' + version + ':bin@zip'));
				sync.from(this.archiveOperations.zipTree(configuration.getSingleFile()));
			}
		});
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class Snippet {
	private final String anchor;
	private final String title;
	private final Set<String> prefixes;
	private final Map<String, String> overrides;
	Snippet(String anchor, String title, Consumer<Config> config) {
		Set<String> prefixes = new LinkedHashSet<>();
		Map<String, String> overrides = new LinkedHashMap<>();
		if (config != null) {
			config.accept(new Config() {
				@Override
				public void accept(String prefix) {
					prefixes.add(prefix);
				}
				@Override
				public void accept(String prefix, String description) {
					overrides.put(prefix, description);
				}
			});
		}
		this.anchor = anchor;
		this.title = title;
		this.prefixes = prefixes;
		this.overrides = overrides;
	}
	String getAnchor() {
		return this.anchor;
	}
	String getTitle() {
		return this.title;
	}
	void forEachPrefix(Consumer<String> action) {
		this.prefixes.forEach(action);
	}
	void forEachOverride(BiConsumer<String, String> action) {
		this.overrides.forEach(action);
	}
	/**
	 * Callback to configure the snippet.
	 */
	interface Config {
		/**
		 * Accept the given prefix using the meta-data description.
		 * @param prefix the prefix to accept
		 */
		void accept(String prefix);
		/**
		 * Accept the given prefix with a defined description.
		 * @param prefix the prefix to accept
		 * @param description the description to use
		 */
		void accept(String prefix, String description);
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class ConfigurationProperty {
	private final String name;
	private final String type;
	private final Object defaultValue;
	private final String description;
	private final boolean deprecated;
	ConfigurationProperty(String name, String type) {
		this(name, type, null, null, false);
	}
	ConfigurationProperty(String name, String type, Object defaultValue, String description, boolean deprecated) {
		this.name = name;
		this.type = type;
		this.defaultValue = defaultValue;
		this.description = description;
		this.deprecated = deprecated;
	}
	String getName() {
		return this.name;
	}
	String getDisplayName() {
		return (getType() != null && getType().startsWith('java.util.Map')) ? getName() + '.*' : getName();
	}
	String getType() {
		return this.type;
	}
	Object getDefaultValue() {
		return this.defaultValue;
	}
	String getDescription() {
		return this.description;
	}
	boolean isDeprecated() {
		return this.deprecated;
	}
	@Override
	public String toString() {
		return 'ConfigurationProperty [name=' + this.name + ', type=' + this.type + ']';
	}
	static ConfigurationProperty fromJsonProperties(Map<String, Object> property) {
		String name = (String) property.get('name');
		String type = (String) property.get('type');
		Object defaultValue = property.get('defaultValue');
		String description = (String) property.get('description');
		boolean deprecated = property.containsKey('deprecated');
		return new ConfigurationProperty(name, type, defaultValue, description, deprecated);
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class Asciidoc {
	private final StringBuilder content;
	Asciidoc() {
		this.content = new StringBuilder();
	}
	Asciidoc appendWithHardLineBreaks(Object... items) {
		for (Object item : items) {
			appendln('`+', item, '+` +');
		}
		return this;
	}
	Asciidoc appendln(Object... items) {
		return append(items).newLine();
	}
	Asciidoc append(Object... items) {
		for (Object item : items) {
			this.content.append(item);
		}
		return this;
	}
	Asciidoc newLine() {
		return append(System.lineSeparator());
	}
	@Override
	public String toString() {
		return this.content.toString();
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
final class ConfigurationProperties {
	private final Map<String, ConfigurationProperty> byName;
	private ConfigurationProperties(List<ConfigurationProperty> properties) {
		Map<String, ConfigurationProperty> byName = new LinkedHashMap<>();
		for (ConfigurationProperty property : properties) {
			byName.put(property.getName(), property);
		}
		this.byName = Collections.unmodifiableMap(byName);
	}
	ConfigurationProperty get(String propertyName) {
		return this.byName.get(propertyName);
	}
	Stream<ConfigurationProperty> stream() {
		return this.byName.values().stream();
	}
	@SuppressWarnings('unchecked')
	static ConfigurationProperties fromFiles(Iterable<File> files) {
		try {
			ObjectMapper objectMapper = new ObjectMapper();
			List<ConfigurationProperty> properties = new ArrayList<>();
			for (File file : files) {
				Map<String, Object> json = objectMapper.readValue(file, Map.class);
				for (Map<String, Object> property : (List<Map<String, Object>>) json.get('properties')) {
					properties.add(ConfigurationProperty.fromJsonProperties(property));
				}
			}
			return new ConfigurationProperties(properties);
		}
		catch (IOException ex) {
			throw new RuntimeException('Failed to load configuration metadata', ex);
		}
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class SingleRow extends Row {
	private final String displayName;
	private final String description;
	private final String defaultValue;
	SingleRow(Snippet snippet, ConfigurationProperty property) {
		super(snippet, property.getName());
		this.displayName = property.getDisplayName();
		this.description = property.getDescription();
		this.defaultValue = getDefaultValue(property.getDefaultValue());
	}
	private String getDefaultValue(Object defaultValue) {
		if (defaultValue == null) {
			return null;
		}
		if (defaultValue.getClass().isArray()) {
			return Arrays.stream((Object[]) defaultValue)
				.map(Object::toString)
				.collect(Collectors.joining(',' + System.lineSeparator()));
		}
		return defaultValue.toString();
	}
	@Override
	void write(Asciidoc asciidoc) {
		asciidoc.append('|');
		asciidoc.append('[[' + getAnchor() + ']]');
		asciidoc.appendln('xref:#' + getAnchor() + '[`+', this.displayName, '+`]');
		writeDescription(asciidoc);
		writeDefaultValue(asciidoc);
	}
	private void writeDescription(Asciidoc builder) {
		if (this.description == null || this.description.isEmpty()) {
			builder.appendln('|');
		}
		else {
			String cleanedDescription = this.description.replace('|', '\\|').replace('<', '&lt;').replace('>', '&gt;');
			builder.appendln('|+++', cleanedDescription, '+++');
		}
	}
	private void writeDefaultValue(Asciidoc builder) {
		String defaultValue = (this.defaultValue != null) ? this.defaultValue : '';
		if (defaultValue.isEmpty()) {
			builder.appendln('|');
		}
		else {
			defaultValue = defaultValue.replace('\\', '\\\\').replace('|', '\\|');
			builder.appendln('|`+', defaultValue, '+`');
		}
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
public abstract class CheckSpringConfigurationMetadata extends DefaultTask {
	private final Path projectRoot;
	public CheckSpringConfigurationMetadata() {
		this.projectRoot = getProject().getProjectDir().toPath();
	}
	@OutputFile
	public abstract RegularFileProperty getReportLocation();
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	public abstract RegularFileProperty getMetadataLocation();
	@Input
	public abstract ListProperty<String> getExclusions();
	@TaskAction
	void check() throws JsonParseException, IOException {
		Report report = createReport();
		File reportFile = getReportLocation().get().getAsFile();
		Files.write(reportFile.toPath(), report, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
		if (report.hasProblems()) {
			throw new GradleException(
					'Problems found in Spring configuration metadata. See ' + reportFile + ' for details.');
		}
	}
	@SuppressWarnings('unchecked')
	private Report createReport() throws IOException, JsonParseException, JsonMappingException {
		ObjectMapper objectMapper = new ObjectMapper();
		File file = getMetadataLocation().get().getAsFile();
		Report report = new Report(this.projectRoot.relativize(file.toPath()));
		Map<String, Object> json = objectMapper.readValue(file, Map.class);
		List<Map<String, Object>> properties = (List<Map<String, Object>>) json.get('properties');
		for (Map<String, Object> property : properties) {
			String name = (String) property.get('name');
			if (!isDeprecated(property) && !isDescribed(property) && !isExcluded(name)) {
				report.propertiesWithNoDescription.add(name);
			}
		}
		return report;
	}
	private boolean isExcluded(String propertyName) {
		for (String exclusion : getExclusions().get()) {
			if (propertyName.equals(exclusion)) {
				return true;
			}
			if (exclusion.endsWith('.*')) {
				if (propertyName.startsWith(exclusion.substring(0, exclusion.length() - 2))) {
					return true;
				}
			}
		}
		return false;
	}
	@SuppressWarnings('unchecked')
	private boolean isDeprecated(Map<String, Object> property) {
		return (Map<String, Object>) property.get('deprecation') != null;
	}
	private boolean isDescribed(Map<String, Object> property) {
		return property.get('description') != null;
	}
	private static final class Report implements Iterable<String> {
		private final List<String> propertiesWithNoDescription = new ArrayList<>();
		private final Path source;
		private Report(Path source) {
			this.source = source;
		}
		private boolean hasProblems() {
			return !this.propertiesWithNoDescription.isEmpty();
		}
		@Override
		public Iterator<String> iterator() {
			List<String> lines = new ArrayList<>();
			lines.add(this.source.toString());
			lines.add('');
			if (this.propertiesWithNoDescription.isEmpty()) {
				lines.add('No problems found.');
			}
			else {
				lines.add('The following properties have no description:');
				lines.add('');
				lines.addAll(this.propertiesWithNoDescription.stream().map((line) -> '\t' + line).toList());
			}
			lines.add('');
			return lines.iterator();
		}
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
abstract class Row implements Comparable<Row> {
	private final Snippet snippet;
	private final String id;
	protected Row(Snippet snippet, String id) {
		this.snippet = snippet;
		this.id = id;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		Row other = (Row) obj;
		return this.id.equals(other.id);
	}
	@Override
	public int hashCode() {
		return this.id.hashCode();
	}
	@Override
	public int compareTo(Row other) {
		return this.id.compareTo(other.id);
	}
	String getAnchor() {
		return this.snippet.getAnchor() + '.' + this.id;
	}
	abstract void write(Asciidoc asciidoc);
}
/*
package org.springframework.boot.build.context.properties;
/**
public abstract class DocumentConfigurationProperties extends DefaultTask {
	private FileCollection configurationPropertyMetadata;
	@InputFiles
	@PathSensitive(PathSensitivity.RELATIVE)
	public FileCollection getConfigurationPropertyMetadata() {
		return this.configurationPropertyMetadata;
	}
	public void setConfigurationPropertyMetadata(FileCollection configurationPropertyMetadata) {
		this.configurationPropertyMetadata = configurationPropertyMetadata;
	}
	@OutputDirectory
	public abstract DirectoryProperty getOutputDir();
	@TaskAction
	void documentConfigurationProperties() throws IOException {
		Snippets snippets = new Snippets(this.configurationPropertyMetadata);
		snippets.add('application-properties.core', 'Core Properties', this::corePrefixes);
		snippets.add('application-properties.cache', 'Cache Properties', this::cachePrefixes);
		snippets.add('application-properties.mail', 'Mail Properties', this::mailPrefixes);
		snippets.add('application-properties.json', 'JSON Properties', this::jsonPrefixes);
		snippets.add('application-properties.data', 'Data Properties', this::dataPrefixes);
		snippets.add('application-properties.transaction', 'Transaction Properties', this::transactionPrefixes);
		snippets.add('application-properties.data-migration', 'Data Migration Properties', this::dataMigrationPrefixes);
		snippets.add('application-properties.integration', 'Integration Properties', this::integrationPrefixes);
		snippets.add('application-properties.web', 'Web Properties', this::webPrefixes);
		snippets.add('application-properties.templating', 'Templating Properties', this::templatePrefixes);
		snippets.add('application-properties.server', 'Server Properties', this::serverPrefixes);
		snippets.add('application-properties.security', 'Security Properties', this::securityPrefixes);
		snippets.add('application-properties.rsocket', 'RSocket Properties', this::rsocketPrefixes);
		snippets.add('application-properties.actuator', 'Actuator Properties', this::actuatorPrefixes);
		snippets.add('application-properties.devtools', 'Devtools Properties', this::devtoolsPrefixes);
		snippets.add('application-properties.docker-compose', 'Docker Compose Properties', this::dockerComposePrefixes);
		snippets.add('application-properties.testcontainers', 'Testcontainers Properties',
				this::testcontainersPrefixes);
		snippets.add('application-properties.testing', 'Testing Properties', this::testingPrefixes);
		snippets.writeTo(getOutputDir().getAsFile().get().toPath());
	}
	private void corePrefixes(Config config) {
		config.accept('debug');
		config.accept('trace');
		config.accept('logging');
		config.accept('spring.aop');
		config.accept('spring.application');
		config.accept('spring.autoconfigure');
		config.accept('spring.banner');
		config.accept('spring.beaninfo');
		config.accept('spring.codec');
		config.accept('spring.config');
		config.accept('spring.info');
		config.accept('spring.jmx');
		config.accept('spring.lifecycle');
		config.accept('spring.main');
		config.accept('spring.messages');
		config.accept('spring.pid');
		config.accept('spring.profiles');
		config.accept('spring.quartz');
		config.accept('spring.reactor');
		config.accept('spring.ssl');
		config.accept('spring.task');
		config.accept('spring.threads');
		config.accept('spring.mandatory-file-encoding');
		config.accept('info');
		config.accept('spring.output.ansi.enabled');
	}
	private void cachePrefixes(Config config) {
		config.accept('spring.cache');
	}
	private void mailPrefixes(Config config) {
		config.accept('spring.mail');
		config.accept('spring.sendgrid');
	}
	private void jsonPrefixes(Config config) {
		config.accept('spring.jackson');
		config.accept('spring.gson');
	}
	private void dataPrefixes(Config config) {
		config.accept('spring.couchbase');
		config.accept('spring.cassandra');
		config.accept('spring.elasticsearch');
		config.accept('spring.h2');
		config.accept('spring.influx');
		config.accept('spring.ldap');
		config.accept('spring.mongodb');
		config.accept('spring.neo4j');
		config.accept('spring.dao');
		config.accept('spring.data');
		config.accept('spring.datasource');
		config.accept('spring.jooq');
		config.accept('spring.jdbc');
		config.accept('spring.jpa');
		config.accept('spring.r2dbc');
		config.accept('spring.datasource.oracleucp',
				'Oracle UCP specific settings bound to an instance of Oracle UCP"s PoolDataSource');
		config.accept('spring.datasource.dbcp2',
				'Commons DBCP2 specific settings bound to an instance of DBCP2"s BasicDataSource');
		config.accept('spring.datasource.tomcat',
				'Tomcat datasource specific settings bound to an instance of Tomcat JDBC"s DataSource');
		config.accept('spring.datasource.hikari',
				'Hikari specific settings bound to an instance of Hikari"s HikariDataSource');
	}
	private void transactionPrefixes(Config prefix) {
		prefix.accept('spring.jta');
		prefix.accept('spring.transaction');
	}
	private void dataMigrationPrefixes(Config prefix) {
		prefix.accept('spring.flyway');
		prefix.accept('spring.liquibase');
		prefix.accept('spring.sql.init');
	}
	private void integrationPrefixes(Config prefix) {
		prefix.accept('spring.activemq');
		prefix.accept('spring.artemis');
		prefix.accept('spring.batch');
		prefix.accept('spring.integration');
		prefix.accept('spring.jms');
		prefix.accept('spring.kafka');
		prefix.accept('spring.pulsar');
		prefix.accept('spring.rabbitmq');
		prefix.accept('spring.hazelcast');
		prefix.accept('spring.webservices');
	}
	private void webPrefixes(Config prefix) {
		prefix.accept('spring.graphql');
		prefix.accept('spring.hateoas');
		prefix.accept('spring.http');
		prefix.accept('spring.jersey');
		prefix.accept('spring.mvc');
		prefix.accept('spring.netty');
		prefix.accept('spring.resources');
		prefix.accept('spring.servlet');
		prefix.accept('spring.session');
		prefix.accept('spring.web');
		prefix.accept('spring.webflux');
	}
	private void templatePrefixes(Config prefix) {
		prefix.accept('spring.freemarker');
		prefix.accept('spring.groovy');
		prefix.accept('spring.mustache');
		prefix.accept('spring.thymeleaf');
		prefix.accept('spring.groovy.template.configuration', 'See GroovyMarkupConfigurer');
	}
	private void serverPrefixes(Config prefix) {
		prefix.accept('server');
	}
	private void securityPrefixes(Config prefix) {
		prefix.accept('spring.security');
	}
	private void rsocketPrefixes(Config prefix) {
		prefix.accept('spring.rsocket');
	}
	private void actuatorPrefixes(Config prefix) {
		prefix.accept('management');
		prefix.accept('micrometer');
	}
	private void dockerComposePrefixes(Config prefix) {
		prefix.accept('spring.docker.compose');
	}
	private void devtoolsPrefixes(Config prefix) {
		prefix.accept('spring.devtools');
	}
	private void testingPrefixes(Config prefix) {
		prefix.accept('spring.test.');
	}
	private void testcontainersPrefixes(Config prefix) {
		prefix.accept('spring.testcontainers.');
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class Table {
	private final Set<Row> rows = new TreeSet<>();
	void addRow(Row row) {
		this.rows.add(row);
	}
	void write(Asciidoc asciidoc) {
		asciidoc.appendln('[cols=\'4,3,3\', options=\'header\']');
		asciidoc.appendln('|===');
		asciidoc.appendln('|Name|Description|Default Value');
		asciidoc.appendln();
		this.rows.forEach((entry) -> {
			entry.write(asciidoc);
			asciidoc.appendln();
		});
		asciidoc.appendln('|===');
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
public abstract class CheckAdditionalSpringConfigurationMetadata extends SourceTask {
	private final File projectDir;
	public CheckAdditionalSpringConfigurationMetadata() {
		this.projectDir = getProject().getProjectDir();
	}
	@OutputFile
	public abstract RegularFileProperty getReportLocation();
	@Override
	@InputFiles
	@PathSensitive(PathSensitivity.RELATIVE)
	public FileTree getSource() {
		return super.getSource();
	}
	@TaskAction
	void check() throws JsonParseException, IOException {
		Report report = createReport();
		File reportFile = getReportLocation().get().getAsFile();
		Files.write(reportFile.toPath(), report, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
		if (report.hasProblems()) {
			throw new GradleException(
					'Problems found in additional Spring configuration metadata. See ' + reportFile + ' for details.');
		}
	}
	@SuppressWarnings('unchecked')
	private Report createReport() throws IOException, JsonParseException, JsonMappingException {
		ObjectMapper objectMapper = new ObjectMapper();
		Report report = new Report();
		for (File file : getSource().getFiles()) {
			Analysis analysis = report.analysis(this.projectDir.toPath().relativize(file.toPath()));
			Map<String, Object> json = objectMapper.readValue(file, Map.class);
			check('groups', json, analysis);
			check('properties', json, analysis);
			check('hints', json, analysis);
		}
		return report;
	}
	@SuppressWarnings('unchecked')
	private void check(String key, Map<String, Object> json, Analysis analysis) {
		List<Map<String, Object>> groups = (List<Map<String, Object>>) json.getOrDefault(key, Collections.emptyList());
		List<String> names = groups.stream().map((group) -> (String) group.get('name')).toList();
		List<String> sortedNames = sortedCopy(names);
		for (int i = 0; i < names.size(); i++) {
			String actual = names.get(i);
			String expected = sortedNames.get(i);
			if (!actual.equals(expected)) {
				analysis.problems.add('Wrong order at $.' + key + '[' + i + '].name - expected "' + expected
						+ '" but found "' + actual + '"');
			}
		}
	}
	private List<String> sortedCopy(Collection<String> original) {
		List<String> copy = new ArrayList<>(original);
		Collections.sort(copy);
		return copy;
	}
	private static final class Report implements Iterable<String> {
		private final List<Analysis> analyses = new ArrayList<>();
		private Analysis analysis(Path path) {
			Analysis analysis = new Analysis(path);
			this.analyses.add(analysis);
			return analysis;
		}
		private boolean hasProblems() {
			for (Analysis analysis : this.analyses) {
				if (!analysis.problems.isEmpty()) {
					return true;
				}
			}
			return false;
		}
		@Override
		public Iterator<String> iterator() {
			List<String> lines = new ArrayList<>();
			for (Analysis analysis : this.analyses) {
				lines.add(analysis.source.toString());
				lines.add('');
				if (analysis.problems.isEmpty()) {
					lines.add('No problems found.');
				}
				else {
					lines.addAll(analysis.problems);
				}
				lines.add('');
			}
			return lines.iterator();
		}
	}
	private static final class Analysis {
		private final List<String> problems = new ArrayList<>();
		private final Path source;
		private Analysis(Path source) {
			this.source = source;
		}
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class CompoundRow extends Row {
	private final Set<String> propertyNames;
	private final String description;
	CompoundRow(Snippet snippet, String prefix, String description) {
		super(snippet, prefix);
		this.description = description;
		this.propertyNames = new TreeSet<>();
	}
	void addProperty(ConfigurationProperty property) {
		this.propertyNames.add(property.getDisplayName());
	}
	@Override
	void write(Asciidoc asciidoc) {
		asciidoc.append('|');
		asciidoc.append('[[' + getAnchor() + ']]');
		asciidoc.append('xref:#' + getAnchor() + '[');
		this.propertyNames.forEach(asciidoc::appendWithHardLineBreaks);
		asciidoc.appendln(']');
		asciidoc.appendln('|+++', this.description, '+++');
		asciidoc.appendln('|');
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
public class ConfigurationPropertiesPlugin implements Plugin<Project> {
	/**
	 * Name of the {@link Configuration} that holds the configuration property metadata
	 * artifact.
	 */
	public static final String CONFIGURATION_PROPERTIES_METADATA_CONFIGURATION_NAME = 'configurationPropertiesMetadata';
	/**
	 * Name of the {@link CheckAdditionalSpringConfigurationMetadata} task.
	 */
	public static final String CHECK_ADDITIONAL_SPRING_CONFIGURATION_METADATA_TASK_NAME = 'checkAdditionalSpringConfigurationMetadata';
	/**
	 * Name of the {@link CheckAdditionalSpringConfigurationMetadata} task.
	 */
	public static final String CHECK_SPRING_CONFIGURATION_METADATA_TASK_NAME = 'checkSpringConfigurationMetadata';
	@Override
	public void apply(Project project) {
		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> {
			configureConfigurationPropertiesAnnotationProcessor(project);
			disableIncrementalCompilation(project);
			configureAdditionalMetadataLocationsCompilerArgument(project);
			registerCheckAdditionalMetadataTask(project);
			registerCheckMetadataTask(project);
			addMetadataArtifact(project);
		});
	}
	private void configureConfigurationPropertiesAnnotationProcessor(Project project) {
		Configuration annotationProcessors = project.getConfigurations()
			.getByName(JavaPlugin.ANNOTATION_PROCESSOR_CONFIGURATION_NAME);
		annotationProcessors.getDependencies()
			.add(project.getDependencies()
				.project(Collections.singletonMap('path',
						':spring-boot-project:spring-boot-tools:spring-boot-configuration-processor')));
	}
	private void disableIncrementalCompilation(Project project) {
		SourceSet mainSourceSet = project.getExtensions()
			.getByType(JavaPluginExtension.class)
			.getSourceSets()
			.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		project.getTasks()
			.named(mainSourceSet.getCompileJavaTaskName(), JavaCompile.class)
			.configure((compileJava) -> compileJava.getOptions().setIncremental(false));
	}
	private void addMetadataArtifact(Project project) {
		SourceSet mainSourceSet = project.getExtensions()
			.getByType(JavaPluginExtension.class)
			.getSourceSets()
			.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		project.getConfigurations().maybeCreate(CONFIGURATION_PROPERTIES_METADATA_CONFIGURATION_NAME);
		project.afterEvaluate((evaluatedProject) -> evaluatedProject.getArtifacts()
			.add(CONFIGURATION_PROPERTIES_METADATA_CONFIGURATION_NAME,
					mainSourceSet.getJava()
						.getDestinationDirectory()
						.dir('META-INF/spring-configuration-metadata.json'),
					(artifact) -> artifact
						.builtBy(evaluatedProject.getTasks().getByName(mainSourceSet.getClassesTaskName()))));
	}
	private void configureAdditionalMetadataLocationsCompilerArgument(Project project) {
		JavaCompile compileJava = project.getTasks()
			.withType(JavaCompile.class)
			.getByName(JavaPlugin.COMPILE_JAVA_TASK_NAME);
		((Task) compileJava).getInputs()
			.files(project.getTasks().getByName(JavaPlugin.PROCESS_RESOURCES_TASK_NAME))
			.withPathSensitivity(PathSensitivity.RELATIVE)
			.withPropertyName('processed resources');
		SourceSet mainSourceSet = project.getExtensions()
			.getByType(JavaPluginExtension.class)
			.getSourceSets()
			.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		compileJava.getOptions()
			.getCompilerArgs()
			.add('-Aorg.springframework.boot.configurationprocessor.additionalMetadataLocations='
					+ StringUtils.collectionToCommaDelimitedString(mainSourceSet.getResources()
						.getSourceDirectories()
						.getFiles()
						.stream()
						.map(project.getRootProject()::relativePath)
						.collect(Collectors.toSet())));
	}
	private void registerCheckAdditionalMetadataTask(Project project) {
		TaskProvider<CheckAdditionalSpringConfigurationMetadata> checkConfigurationMetadata = project.getTasks()
			.register(CHECK_ADDITIONAL_SPRING_CONFIGURATION_METADATA_TASK_NAME,
					CheckAdditionalSpringConfigurationMetadata.class);
		checkConfigurationMetadata.configure((check) -> {
			SourceSet mainSourceSet = project.getExtensions()
				.getByType(JavaPluginExtension.class)
				.getSourceSets()
				.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
			check.setSource(mainSourceSet.getResources());
			check.include('META-INF/additional-spring-configuration-metadata.json');
			check.getReportLocation()
				.set(project.getLayout()
					.getBuildDirectory()
					.file('reports/additional-spring-configuration-metadata/check.txt'));
		});
		project.getTasks()
			.named(LifecycleBasePlugin.CHECK_TASK_NAME)
			.configure((check) -> check.dependsOn(checkConfigurationMetadata));
	}
	private void registerCheckMetadataTask(Project project) {
		TaskProvider<CheckSpringConfigurationMetadata> checkConfigurationMetadata = project.getTasks()
			.register(CHECK_SPRING_CONFIGURATION_METADATA_TASK_NAME, CheckSpringConfigurationMetadata.class);
		checkConfigurationMetadata.configure((check) -> {
			SourceSet mainSourceSet = project.getExtensions()
				.getByType(JavaPluginExtension.class)
				.getSourceSets()
				.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
			Provider<RegularFile> metadataLocation = project.getTasks()
				.named(mainSourceSet.getCompileJavaTaskName(), JavaCompile.class)
				.flatMap((javaCompile) -> javaCompile.getDestinationDirectory()
					.file('META-INF/spring-configuration-metadata.json'));
			check.getMetadataLocation().set(metadataLocation);
			check.getReportLocation()
				.set(project.getLayout().getBuildDirectory().file('reports/spring-configuration-metadata/check.txt'));
		});
		project.getTasks()
			.named(LifecycleBasePlugin.CHECK_TASK_NAME)
			.configure((check) -> check.dependsOn(checkConfigurationMetadata));
	}
}
/*
package org.springframework.boot.build.context.properties;
/**
class Snippets {
	private final ConfigurationProperties properties;
	private final List<Snippet> snippets = new ArrayList<>();
	Snippets(FileCollection configurationPropertyMetadata) {
		this.properties = ConfigurationProperties.fromFiles(configurationPropertyMetadata);
	}
	void add(String anchor, String title, Consumer<Snippet.Config> config) {
		this.snippets.add(new Snippet(anchor, title, config));
	}
	void writeTo(Path outputDirectory) throws IOException {
		createDirectory(outputDirectory);
		Set<String> remaining = this.properties.stream()
			.filter((property) -> !property.isDeprecated())
			.map(ConfigurationProperty::getName)
			.collect(Collectors.toSet());
		for (Snippet snippet : this.snippets) {
			Set<String> written = writeSnippet(outputDirectory, snippet, remaining);
			remaining.removeAll(written);
		}
		if (!remaining.isEmpty()) {
			throw new IllegalStateException(
					'The following keys were not written to the documentation: ' + String.join(', ', remaining));
		}
	}
	private Set<String> writeSnippet(Path outputDirectory, Snippet snippet, Set<String> remaining) throws IOException {
		Table table = new Table();
		Set<String> added = new HashSet<>();
		snippet.forEachOverride((prefix, description) -> {
			CompoundRow row = new CompoundRow(snippet, prefix, description);
			remaining.stream().filter((candidate) -> candidate.startsWith(prefix)).forEach((name) -> {
				if (added.add(name)) {
					row.addProperty(this.properties.get(name));
				}
			});
			table.addRow(row);
		});
		snippet.forEachPrefix((prefix) -> {
			remaining.stream().filter((candidate) -> candidate.startsWith(prefix)).forEach((name) -> {
				if (added.add(name)) {
					table.addRow(new SingleRow(snippet, this.properties.get(name)));
				}
			});
		});
		Asciidoc asciidoc = getAsciidoc(snippet, table);
		writeAsciidoc(outputDirectory, snippet, asciidoc);
		return added;
	}
	private Asciidoc getAsciidoc(Snippet snippet, Table table) {
		Asciidoc asciidoc = new Asciidoc();
		// We have to prepend "appendix." as a section id here, otherwise the
		// spring-asciidoctor-extensions:section-id asciidoctor extension complains
		asciidoc.appendln('[[appendix.' + snippet.getAnchor() + ']]');
		asciidoc.appendln('== ', snippet.getTitle());
		table.write(asciidoc);
		return asciidoc;
	}
	private void writeAsciidoc(Path outputDirectory, Snippet snippet, Asciidoc asciidoc) throws IOException {
		String[] parts = (snippet.getAnchor()).split('\\.');
		Path path = outputDirectory.resolve(parts[parts.length - 1] + '.adoc');
		createDirectory(path.getParent());
		Files.deleteIfExists(path);
		try (OutputStream outputStream = Files.newOutputStream(path)) {
			outputStream.write(asciidoc.toString().getBytes(StandardCharsets.UTF_8));
		}
	}
	private void createDirectory(Path path) throws IOException {
		assertValidOutputDirectory(path);
		if (!Files.exists(path)) {
			Files.createDirectory(path);
		}
	}
	private void assertValidOutputDirectory(Path path) {
		if (path == null) {
			throw new IllegalArgumentException('Directory path should not be null');
		}
		if (Files.exists(path) && !Files.isDirectory(path)) {
			throw new IllegalArgumentException('Path already exists and is not a directory');
		}
	}
}
/*
package org.springframework.boot.build;
/**
public class AntoraConventions {
	private static final String DEPENDENCIES_PATH = ':spring-boot-project:spring-boot-dependencies';
	private static final String ANTORA_SOURCE_DIR = 'src/docs/antora';
	private static final List<String> NAV_FILES = List.of('nav.adoc', 'local-nav.adoc');
	void apply(Project project) {
		project.getPlugins().withType(AntoraPlugin.class, (antoraPlugin) -> apply(project, antoraPlugin));
	}
	private void apply(Project project, AntoraPlugin antoraPlugin) {
		ExtractVersionConstraints dependencyVersionsTask = addDependencyVersionsTask(project);
		project.getPlugins().apply(GenerateAntoraYmlPlugin.class);
		TaskContainer tasks = project.getTasks();
		GenerateAntoraPlaybook generateAntoraPlaybookTask = tasks.create('generateAntoraPlaybook',
				GenerateAntoraPlaybook.class);
		configureGenerateAntoraPlaybookTask(project, generateAntoraPlaybookTask);
		Copy copyAntoraPackageJsonTask = tasks.create('copyAntoraPackageJson', Copy.class);
		configureCopyAntoraPackageJsonTask(project, copyAntoraPackageJsonTask);
		NpmInstallTask npmInstallTask = tasks.create('antoraNpmInstall', NpmInstallTask.class);
		configureNpmInstallTask(project, npmInstallTask, copyAntoraPackageJsonTask);
		tasks.withType(GenerateAntoraYmlTask.class, (generateAntoraYmlTask) -> configureGenerateAntoraYmlTask(project,
				generateAntoraYmlTask, dependencyVersionsTask));
		tasks.withType(AntoraTask.class,
				(antoraTask) -> configureAntoraTask(project, antoraTask, npmInstallTask, generateAntoraPlaybookTask));
		project.getExtensions()
			.configure(NodeExtension.class, (nodeExtension) -> configureNodeExtension(project, nodeExtension));
	}
	private void configureGenerateAntoraPlaybookTask(Project project,
			GenerateAntoraPlaybook generateAntoraPlaybookTask) {
		Provider<Directory> nodeProjectDir = getNodeProjectDir(project);
		generateAntoraPlaybookTask.getOutputFile()
			.set(nodeProjectDir.map((directory) -> directory.file('antora-playbook.yml')));
	}
	private void configureCopyAntoraPackageJsonTask(Project project, Copy copyAntoraPackageJsonTask) {
		copyAntoraPackageJsonTask
			.from(project.getRootProject().file('antora'),
					(spec) -> spec.include('package.json', 'package-lock.json', 'patches/**'))
			.into(getNodeProjectDir(project));
	}
	private void configureNpmInstallTask(Project project, NpmInstallTask npmInstallTask, Copy copyAntoraPackageJson) {
		npmInstallTask.dependsOn(copyAntoraPackageJson);
		Map<String, String> environment = new HashMap<>();
		environment.put('npm_config_omit', 'optional');
		environment.put('npm_config_update_notifier', 'false');
		npmInstallTask.getEnvironment().set(environment);
		npmInstallTask.getNpmCommand().set(List.of('ci', '--silent', '--no-progress'));
	}
	private ExtractVersionConstraints addDependencyVersionsTask(Project project) {
		return project.getTasks()
			.create('dependencyVersions', ExtractVersionConstraints.class,
					(task) -> task.enforcedPlatform(DEPENDENCIES_PATH));
	}
	private void configureGenerateAntoraYmlTask(Project project, GenerateAntoraYmlTask generateAntoraYmlTask,
			ExtractVersionConstraints dependencyVersionsTask) {
		generateAntoraYmlTask.getOutputs().doNotCacheIf('getAsciidocAttributes() changes output', (task) -> true);
		generateAntoraYmlTask.dependsOn(dependencyVersionsTask);
		generateAntoraYmlTask.setProperty('componentName', 'boot');
		generateAntoraYmlTask.setProperty('outputFile',
				project.getLayout().getBuildDirectory().file('generated/docs/antora-yml/antora.yml'));
		generateAntoraYmlTask.setProperty('yml', getDefaultYml(project));
		generateAntoraYmlTask.getAsciidocAttributes().putAll(getAsciidocAttributes(project, dependencyVersionsTask));
	}
	private Map<String, ?> getDefaultYml(Project project) {
		String navFile = null;
		for (String candidate : NAV_FILES) {
			if (project.file(ANTORA_SOURCE_DIR + '/' + candidate).exists()) {
				Assert.state(navFile == null, 'Multiple nav files found');
				navFile = candidate;
			}
		}
		Map<String, Object> defaultYml = new LinkedHashMap<>();
		defaultYml.put('title', 'Spring Boot');
		if (navFile != null) {
			defaultYml.put('nav', List.of(navFile));
		}
		return defaultYml;
	}
	private Provider<Map<String, String>> getAsciidocAttributes(Project project,
			ExtractVersionConstraints dependencyVersionsTask) {
		return project.provider(() -> {
			BomExtension bom = (BomExtension) project.project(DEPENDENCIES_PATH).getExtensions().getByName('bom');
			Map<String, String> dependencyVersions = dependencyVersionsTask.getVersionConstraints();
			AntoraAsciidocAttributes attributes = new AntoraAsciidocAttributes(project, bom, dependencyVersions);
			return attributes.get();
		});
	}
	private void configureAntoraTask(Project project, AntoraTask antoraTask, NpmInstallTask npmInstallTask,
			GenerateAntoraPlaybook generateAntoraPlaybookTask) {
		antoraTask.setGroup('Documentation');
		antoraTask.dependsOn(npmInstallTask, generateAntoraPlaybookTask);
		antoraTask.setPlaybook('antora-playbook.yml');
		antoraTask.setUiBundleUrl(getUiBundleUrl(project));
		antoraTask.getArgs().set(project.provider(() -> getAntoraNpxArs(project, antoraTask)));
		project.getPlugins()
			.withType(JavaBasePlugin.class,
					(javaBasePlugin) -> project.getTasks()
						.getByName(JavaBasePlugin.CHECK_TASK_NAME)
						.dependsOn(antoraTask));
	}
	private List<String> getAntoraNpxArs(Project project, AntoraTask antoraTask) {
		logWarningIfNodeModulesInUserHome(project);
		StartParameter startParameter = project.getGradle().getStartParameter();
		boolean showStacktrace = startParameter.getShowStacktrace().name().startsWith('ALWAYS');
		boolean debugLogging = project.getGradle().getStartParameter().getLogLevel() == LogLevel.DEBUG;
		String playbookPath = antoraTask.getPlaybook();
		List<String> arguments = new ArrayList<>();
		arguments.addAll(List.of('--package', '@antora/cli'));
		arguments.add('antora');
		arguments.addAll((!showStacktrace) ? Collections.emptyList() : List.of('--stacktrace'));
		arguments.addAll((!debugLogging) ? List.of('--quiet') : List.of('--log-level', 'all'));
		arguments.addAll(List.of('--ui-bundle-url', antoraTask.getUiBundleUrl()));
		arguments.add(playbookPath);
		return arguments;
	}
	private void logWarningIfNodeModulesInUserHome(Project project) {
		if (new File(System.getProperty('user.home'), 'node_modules').exists()) {
			project.getLogger()
				.warn('Detected the existence of $HOME/node_modules. This directory is '
						+ 'not compatible with this plugin. Please remove it.');
		}
	}
	private String getUiBundleUrl(Project project) {
		try {
			File packageJson = project.getRootProject().file('antora/package.json');
			ObjectMapper objectMapper = new ObjectMapper();
			Map<?, ?> json = objectMapper.readerFor(Map.class).readValue(packageJson);
			Map<?, ?> config = (json != null) ? (Map<?, ?>) json.get('config') : null;
			String url = (config != null) ? (String) config.get('ui-bundle-url') : null;
			Assert.state(StringUtils.hasText(url.toString()), 'package.json has not ui-bundle-url config');
			return url;
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private void configureNodeExtension(Project project, NodeExtension nodeExtension) {
		nodeExtension.getWorkDir().set(project.getLayout().getBuildDirectory().dir('.gradle/nodejs'));
		nodeExtension.getNpmWorkDir().set(project.getLayout().getBuildDirectory().dir('.gradle/npm'));
		nodeExtension.getNodeProjectDir().set(getNodeProjectDir(project));
	}
	private Provider<Directory> getNodeProjectDir(Project project) {
		return project.getLayout().getBuildDirectory().dir('.gradle/nodeproject');
	}
}
/*
package org.springframework.boot.build.processors;
/**
public class AnnotationProcessorPlugin implements Plugin<Project> {
	private static final String JAR_TYPE = 'annotation-processor';
	@Override
	public void apply(Project project) {
		project.getTasks().withType(Jar.class, (jar) -> project.afterEvaluate((evaluated) -> {
			jar.manifest((manifest) -> {
				Map<String, Object> attributes = new TreeMap<>();
				attributes.put('Spring-Boot-Jar-Type', JAR_TYPE);
				manifest.attributes(attributes);
			});
		}));
	}
}
/*
package org.springframework.boot.build.classpath;
/**
public abstract class CheckClasspathForConflicts extends DefaultTask {
	private final List<Predicate<String>> ignores = new ArrayList<>();
	private FileCollection classpath;
	public void setClasspath(FileCollection classpath) {
		this.classpath = classpath;
	}
	@Classpath
	public FileCollection getClasspath() {
		return this.classpath;
	}
	@TaskAction
	public void checkForConflicts() throws IOException {
		ClasspathContents classpathContents = new ClasspathContents();
		for (File file : this.classpath) {
			if (file.isDirectory()) {
				Path root = file.toPath();
				try (Stream<Path> pathStream = Files.walk(root)) {
					pathStream.filter(Files::isRegularFile)
						.forEach((entry) -> classpathContents.add(root.relativize(entry).toString(), root.toString()));
				}
			}
			else {
				try (JarFile jar = new JarFile(file)) {
					for (JarEntry entry : Collections.list(jar.entries())) {
						if (!entry.isDirectory()) {
							classpathContents.add(entry.getName(), file.getAbsolutePath());
						}
					}
				}
			}
		}
		Map<String, List<String>> conflicts = classpathContents.getConflicts(this.ignores);
		if (!conflicts.isEmpty()) {
			StringBuilder message = new StringBuilder(String.format('Found classpath conflicts:%n'));
			conflicts.forEach((entry, locations) -> {
				message.append(String.format('    %s%n', entry));
				locations.forEach((location) -> message.append(String.format('        %s%n', location)));
			});
			throw new GradleException(message.toString());
		}
	}
	public void ignore(Predicate<String> predicate) {
		this.ignores.add(predicate);
	}
	private static final class ClasspathContents {
		private static final Set<String> IGNORED_NAMES = new HashSet<>(Arrays.asList('about.html', 'changelog.txt',
				'LICENSE', 'license.txt', 'module-info.class', 'notice.txt', 'readme.txt'));
		private final Map<String, List<String>> classpathContents = new HashMap<>();
		private void add(String name, String source) {
			this.classpathContents.computeIfAbsent(name, (key) -> new ArrayList<>()).add(source);
		}
		private Map<String, List<String>> getConflicts(List<Predicate<String>> ignores) {
			return this.classpathContents.entrySet()
				.stream()
				.filter((entry) -> entry.getValue().size() > 1)
				.filter((entry) -> canConflict(entry.getKey(), ignores))
				.collect(Collectors.toMap(Entry::getKey, Entry::getValue, (v1, v2) -> v1, TreeMap::new));
		}
		private boolean canConflict(String name, List<Predicate<String>> ignores) {
			if (name.startsWith('META-INF/')) {
				return false;
			}
			for (String ignoredName : IGNORED_NAMES) {
				if (name.equals(ignoredName)) {
					return false;
				}
			}
			for (Predicate<String> ignore : ignores) {
				if (ignore.test(name)) {
					return false;
				}
			}
			return true;
		}
	}
}
/*
package org.springframework.boot.build.classpath;
/**
public abstract class CheckClasspathForUnnecessaryExclusions extends DefaultTask {
	private static final Map<String, String> SPRING_BOOT_DEPENDENCIES_PROJECT = Collections.singletonMap('path',
			':spring-boot-project:spring-boot-dependencies');
	private final Map<String, Set<String>> exclusionsByDependencyId = new TreeMap<>();
	private final Map<String, Dependency> dependencyById = new HashMap<>();
	private final Dependency platform;
	private final DependencyHandler dependencyHandler;
	private final ConfigurationContainer configurations;
	private Configuration classpath;
	@Inject
	public CheckClasspathForUnnecessaryExclusions(DependencyHandler dependencyHandler,
			ConfigurationContainer configurations) {
		this.dependencyHandler = getProject().getDependencies();
		this.configurations = getProject().getConfigurations();
		this.platform = this.dependencyHandler
			.create(this.dependencyHandler.platform(this.dependencyHandler.project(SPRING_BOOT_DEPENDENCIES_PROJECT)));
		getOutputs().upToDateWhen((task) -> true);
	}
	public void setClasspath(Configuration classpath) {
		this.classpath = classpath;
		this.exclusionsByDependencyId.clear();
		this.dependencyById.clear();
		classpath.getAllDependencies().all(this::processDependency);
	}
	@Classpath
	public FileCollection getClasspath() {
		return this.classpath;
	}
	private void processDependency(Dependency dependency) {
		if (dependency instanceof ModuleDependency moduleDependency) {
			processDependency(moduleDependency);
		}
	}
	private void processDependency(ModuleDependency dependency) {
		String dependencyId = getId(dependency);
		TreeSet<String> exclusions = dependency.getExcludeRules()
			.stream()
			.map(this::getId)
			.collect(Collectors.toCollection(TreeSet::new));
		this.exclusionsByDependencyId.put(dependencyId, exclusions);
		if (!exclusions.isEmpty()) {
			this.dependencyById.put(dependencyId, getProject().getDependencies().create(dependencyId));
		}
	}
	@Input
	Map<String, Set<String>> getExclusionsByDependencyId() {
		return this.exclusionsByDependencyId;
	}
	@TaskAction
	public void checkForUnnecessaryExclusions() {
		Map<String, Set<String>> unnecessaryExclusions = new HashMap<>();
		this.exclusionsByDependencyId.forEach((dependencyId, exclusions) -> {
			if (!exclusions.isEmpty()) {
				Dependency toCheck = this.dependencyById.get(dependencyId);
				this.configurations.detachedConfiguration(toCheck, this.platform)
					.getIncoming()
					.getArtifacts()
					.getArtifacts()
					.stream()
					.map(this::getId)
					.forEach(exclusions::remove);
				removeProfileExclusions(dependencyId, exclusions);
				if (!exclusions.isEmpty()) {
					unnecessaryExclusions.put(dependencyId, exclusions);
				}
			}
		});
		if (!unnecessaryExclusions.isEmpty()) {
			throw new GradleException(getExceptionMessage(unnecessaryExclusions));
		}
	}
	private void removeProfileExclusions(String dependencyId, Set<String> exclusions) {
		if ('org.xmlunit:xmlunit-core'.equals(dependencyId)) {
			exclusions.remove('javax.xml.bind:jaxb-api');
		}
	}
	private String getExceptionMessage(Map<String, Set<String>> unnecessaryExclusions) {
		StringBuilder message = new StringBuilder('Unnecessary exclusions detected:');
		for (Entry<String, Set<String>> entry : unnecessaryExclusions.entrySet()) {
			message.append(String.format('%n    %s', entry.getKey()));
			for (String exclusion : entry.getValue()) {
				message.append(String.format('%n       %s', exclusion));
			}
		}
		return message.toString();
	}
	private String getId(ResolvedArtifactResult artifact) {
		return getId((ModuleComponentIdentifier) artifact.getId().getComponentIdentifier());
	}
	private String getId(ModuleDependency dependency) {
		return dependency.getGroup() + ':' + dependency.getName();
	}
	private String getId(ExcludeRule rule) {
		return rule.getGroup() + ':' + rule.getModule();
	}
	private String getId(ModuleComponentIdentifier identifier) {
		return identifier.getGroup() + ':' + identifier.getModule();
	}
}
/*
package org.springframework.boot.build.classpath;
/**
public abstract class CheckClasspathForUnconstrainedDirectDependencies extends DefaultTask {
	private Configuration classpath;
	public CheckClasspathForUnconstrainedDirectDependencies() {
		getOutputs().upToDateWhen((task) -> true);
	}
	@Classpath
	public FileCollection getClasspath() {
		return this.classpath;
	}
	public void setClasspath(Configuration classpath) {
		this.classpath = classpath;
	}
	@TaskAction
	void checkForUnconstrainedDirectDependencies() {
		ResolutionResult resolutionResult = this.classpath.getIncoming().getResolutionResult();
		Set<? extends DependencyResult> dependencies = resolutionResult.getRoot().getDependencies();
		Set<String> unconstrainedDependencies = dependencies.stream()
			.map(DependencyResult::getRequested)
			.filter(ModuleComponentSelector.class::isInstance)
			.map(ModuleComponentSelector.class::cast)
			.map((selector) -> selector.getGroup() + ':' + selector.getModule())
			.collect(Collectors.toSet());
		Set<String> constraints = resolutionResult.getAllDependencies()
			.stream()
			.filter(DependencyResult::isConstraint)
			.map(DependencyResult::getRequested)
			.filter(ModuleComponentSelector.class::isInstance)
			.map(ModuleComponentSelector.class::cast)
			.map((selector) -> selector.getGroup() + ':' + selector.getModule())
			.collect(Collectors.toSet());
		unconstrainedDependencies.removeAll(constraints);
		if (!unconstrainedDependencies.isEmpty()) {
			throw new GradleException('Found unconstrained direct dependencies: ' + unconstrainedDependencies);
		}
	}
}
/*
package org.springframework.boot.build.classpath;
/**
public abstract class CheckClasspathForProhibitedDependencies extends DefaultTask {
	private static final Set<String> PROHIBITED_GROUPS = Set.of('org.codehaus.groovy', 'org.eclipse.jetty.toolchain',
			'commons-logging', 'org.apache.geronimo.specs', 'com.sun.activation');
	private static final Set<String> PERMITTED_JAVAX_GROUPS = Set.of('javax.batch', 'javax.cache', 'javax.money');
	private Configuration classpath;
	public CheckClasspathForProhibitedDependencies() {
		getOutputs().upToDateWhen((task) -> true);
	}
	public void setClasspath(Configuration classpath) {
		this.classpath = classpath;
	}
	@Classpath
	public FileCollection getClasspath() {
		return this.classpath;
	}
	@TaskAction
	public void checkForProhibitedDependencies() {
		TreeSet<String> prohibited = this.classpath.getResolvedConfiguration()
			.getResolvedArtifacts()
			.stream()
			.map((artifact) -> artifact.getModuleVersion().getId())
			.filter(this::prohibited)
			.map((id) -> id.getGroup() + ':' + id.getName())
			.collect(Collectors.toCollection(TreeSet::new));
		if (!prohibited.isEmpty()) {
			StringBuilder message = new StringBuilder(String.format('Found prohibited dependencies:%n'));
			for (String dependency : prohibited) {
				message.append(String.format('    %s%n', dependency));
			}
			throw new GradleException(message.toString());
		}
	}
	private boolean prohibited(ModuleVersionIdentifier id) {
		return PROHIBITED_GROUPS.contains(id.getGroup()) || prohibitedJavax(id) || prohibitedSlf4j(id)
				|| prohibitedJbossSpec(id);
	}
	private boolean prohibitedSlf4j(ModuleVersionIdentifier id) {
		return id.getGroup().equals('org.slf4j') && id.getName().equals('jcl-over-slf4j');
	}
	private boolean prohibitedJbossSpec(ModuleVersionIdentifier id) {
		return id.getGroup().startsWith('org.jboss.spec');
	}
	private boolean prohibitedJavax(ModuleVersionIdentifier id) {
		return id.getGroup().startsWith('javax.') && !PERMITTED_JAVAX_GROUPS.contains(id.getGroup());
	}
}
/*
package org.springframework.boot.build.constraints;
/**
public abstract class DocumentConstrainedVersions extends DefaultTask {
	@Input
	public abstract SetProperty<ConstrainedVersion> getConstrainedVersions();
	@OutputFile
	public abstract RegularFileProperty getOutputFile();
	@TaskAction
	public void documentConstrainedVersions() throws IOException {
		File outputFile = getOutputFile().get().getAsFile();
		outputFile.getParentFile().mkdirs();
		try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
			writer.println('|===');
			writer.println('| Group ID | Artifact ID | Version');
			for (ConstrainedVersion constrainedVersion : getConstrainedVersions().get()) {
				writer.println();
				writer.printf('| `%s`%n', constrainedVersion.getGroup());
				writer.printf('| `%s`%n', constrainedVersion.getArtifact());
				writer.printf('| `%s`%n', constrainedVersion.getVersion());
			}
			writer.println('|===');
		}
	}
}
/*
package org.springframework.boot.build.constraints;
/**
public abstract class DocumentVersionProperties extends DefaultTask {
	@Input
	public abstract SetProperty<VersionProperty> getVersionProperties();
	@OutputFile
	public abstract RegularFileProperty getOutputFile();
	@TaskAction
	public void documentVersionProperties() throws IOException {
		File outputFile = getOutputFile().getAsFile().get();
		outputFile.getParentFile().mkdirs();
		try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
			writer.println('|===');
			writer.println('| Library | Version Property');
			for (VersionProperty versionProperty : getVersionProperties().get()) {
				writer.println();
				writer.printf('| `%s`%n', versionProperty.getLibraryName());
				writer.printf('| `%s`%n', versionProperty.getVersionProperty());
			}
			writer.println('|===');
		}
	}
}
/*
package org.springframework.boot.build.constraints;
/**
public abstract class ExtractVersionConstraints extends DefaultTask {
	private final Configuration configuration;
	private final Map<String, String> versionConstraints = new TreeMap<>();
	private final Set<ConstrainedVersion> constrainedVersions = new TreeSet<>();
	private final Set<VersionProperty> versionProperties = new TreeSet<>();
	private final List<DependencyConstraintSet> dependencyConstraintSets = new ArrayList<>();
	private final List<BomExtension> boms = new ArrayList<>();
	public ExtractVersionConstraints() {
		DependencyHandler dependencies = getProject().getDependencies();
		this.configuration = getProject().getConfigurations().create(getName());
		dependencies.getComponents().all(this::processMetadataDetails);
	}
	public void enforcedPlatform(String projectPath) {
		this.configuration.getDependencies()
			.add(getProject().getDependencies()
				.enforcedPlatform(
						getProject().getDependencies().project(Collections.singletonMap('path', projectPath))));
		Project project = getProject().project(projectPath);
		project.getPlugins().withType(BomPlugin.class).all((plugin) -> {
			this.boms.add(project.getExtensions().getByType(BomExtension.class));
			this.dependencyConstraintSets
				.add(project.getConfigurations().getByName('apiElements').getAllDependencyConstraints());
		});
	}
	@Internal
	public Map<String, String> getVersionConstraints() {
		return Collections.unmodifiableMap(this.versionConstraints);
	}
	@Internal
	public Set<ConstrainedVersion> getConstrainedVersions() {
		return this.constrainedVersions;
	}
	@Internal
	public Set<VersionProperty> getVersionProperties() {
		return this.versionProperties;
	}
	@TaskAction
	void extractVersionConstraints() {
		this.configuration.resolve();
		this.boms.forEach(this::extractVersionProperties);
		for (DependencyConstraintSet constraints : this.dependencyConstraintSets) {
			for (DependencyConstraint constraint : constraints) {
				this.versionConstraints.put(constraint.getGroup() + ':' + constraint.getName(),
						constraint.getVersionConstraint().toString());
				this.constrainedVersions.add(new ConstrainedVersion(constraint.getGroup(), constraint.getName(),
						constraint.getVersionConstraint().toString()));
			}
		}
	}
	private void extractVersionProperties(BomExtension bomExtension) {
		for (Library lib : bomExtension.getLibraries()) {
			String versionProperty = lib.getVersionProperty();
			if (versionProperty != null) {
				this.versionProperties.add(new VersionProperty(lib.getName(), versionProperty));
			}
		}
	}
	private void processMetadataDetails(ComponentMetadataDetails details) {
		details.allVariants((variantMetadata) -> variantMetadata.withDependencyConstraints((dependencyConstraints) -> {
			for (DependencyConstraintMetadata constraint : dependencyConstraints) {
				this.versionConstraints.put(constraint.getGroup() + ':' + constraint.getName(),
						constraint.getVersionConstraint().toString());
				this.constrainedVersions.add(new ConstrainedVersion(constraint.getGroup(), constraint.getName(),
						constraint.getVersionConstraint().toString()));
			}
		}));
	}
	public static final class ConstrainedVersion implements Comparable<ConstrainedVersion>, Serializable {
		private final String group;
		private final String artifact;
		private final String version;
		private ConstrainedVersion(String group, String artifact, String version) {
			this.group = group;
			this.artifact = artifact;
			this.version = version;
		}
		public String getGroup() {
			return this.group;
		}
		public String getArtifact() {
			return this.artifact;
		}
		public String getVersion() {
			return this.version;
		}
		@Override
		public int compareTo(ConstrainedVersion other) {
			int groupComparison = this.group.compareTo(other.group);
			if (groupComparison != 0) {
				return groupComparison;
			}
			return this.artifact.compareTo(other.artifact);
		}
	}
	public static final class VersionProperty implements Comparable<VersionProperty>, Serializable {
		private final String libraryName;
		private final String versionProperty;
		public VersionProperty(String libraryName, String versionProperty) {
			this.libraryName = libraryName;
			this.versionProperty = versionProperty;
		}
		public String getLibraryName() {
			return this.libraryName;
		}
		public String getVersionProperty() {
			return this.versionProperty;
		}
		@Override
		public int compareTo(VersionProperty other) {
			int groupComparison = this.libraryName.compareToIgnoreCase(other.libraryName);
			if (groupComparison != 0) {
				return groupComparison;
			}
			return this.versionProperty.compareTo(other.versionProperty);
		}
	}
}
/*
package org.springframework.boot.build;
/**
public class RepositoryTransformersExtension {
	private static final String MARKER = '{spring.mavenRepositories}';
	private static final String MARKER_PLUGIN = '{spring.mavenPluginRepositories}';
	private final Project project;
	@Inject
	public RepositoryTransformersExtension(Project project) {
		this.project = project;
	}
	public Transformer<String, String> ant() {
		return this::transformAnt;
	}
	private String transformAnt(String line) {
		if (line.contains(MARKER)) {
			StringBuilder result = new StringBuilder();
			String indent = getIndent(line);
			this.project.getRepositories().withType(MavenArtifactRepository.class, (repository) -> {
				String name = repository.getName();
				if (name.startsWith('spring-')) {
					result.append(!result.isEmpty() ? '\n' : '');
					result.append('%s<ibiblio name=\'%s\' m2compatible=\'true\' root=\'%s\' />'.formatted(indent, name,
							repository.getUrl()));
				}
			});
			return result.toString();
		}
		return line;
	}
	public Transformer<String, String> mavenSettings() {
		return this::transformMavenSettings;
	}
	private String transformMavenSettings(String line) {
		if (line.contains(MARKER)) {
			return transformMarker(line, false);
		}
		if (line.contains(MARKER_PLUGIN)) {
			return transformMarker(line, true);
		}
		return line;
	}
	private String transformMarker(String line, boolean pluginRepository) {
		StringBuilder result = new StringBuilder();
		String indent = getIndent(line);
		this.project.getRepositories().withType(MavenArtifactRepository.class, (repository) -> {
			String name = repository.getName();
			if (name.startsWith('spring-')) {
				result.append(!result.isEmpty() ? '\n' : '');
				result.append(mavenRepositoryXml(indent, repository, pluginRepository));
			}
		});
		return result.toString();
	}
	private String mavenRepositoryXml(String indent, MavenArtifactRepository repository, boolean pluginRepository) {
		String rootTag = pluginRepository ? 'pluginRepository' : 'repository';
		boolean snapshots = repository.getName().endsWith('-snapshot');
		StringBuilder xml = new StringBuilder();
		xml.append('%s<%s>%n'.formatted(indent, rootTag));
		xml.append('%s\t<id>%s</id>%n'.formatted(indent, repository.getName()));
		xml.append('%s\t<url>%s</url>%n'.formatted(indent, repository.getUrl()));
		xml.append('%s\t<releases>%n'.formatted(indent));
		xml.append('%s\t\t<enabled>%s</enabled>%n'.formatted(indent, !snapshots));
		xml.append('%s\t</releases>%n'.formatted(indent));
		xml.append('%s\t<snapshots>%n'.formatted(indent));
		xml.append('%s\t\t<enabled>%s</enabled>%n'.formatted(indent, snapshots));
		xml.append('%s\t</snapshots>%n'.formatted(indent));
		xml.append('%s</%s>'.formatted(indent, rootTag));
		return xml.toString();
	}
	private String getIndent(String line) {
		return line.substring(0, line.length() - line.stripLeading().length());
	}
	static void apply(Project project) {
		project.getExtensions().create('springRepositoryTransformers', RepositoryTransformersExtension.class, project);
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
final class MavenMetadataVersionResolver implements VersionResolver {
	private final RestTemplate rest;
	private final Collection<MavenArtifactRepository> repositories;
	MavenMetadataVersionResolver(Collection<MavenArtifactRepository> repositories) {
		this(new RestTemplate(Collections.singletonList(new StringHttpMessageConverter())), repositories);
	}
	MavenMetadataVersionResolver(RestTemplate restTemplate, Collection<MavenArtifactRepository> repositories) {
		this.rest = restTemplate;
		this.repositories = repositories;
	}
	@Override
	public SortedSet<DependencyVersion> resolveVersions(String groupId, String artifactId) {
		Set<String> versions = new HashSet<>();
		for (MavenArtifactRepository repository : this.repositories) {
			versions.addAll(resolveVersions(groupId, artifactId, repository));
		}
		return versions.stream().map(DependencyVersion::parse).collect(Collectors.toCollection(TreeSet::new));
	}
	private Set<String> resolveVersions(String groupId, String artifactId, MavenArtifactRepository repository) {
		Set<String> versions = new HashSet<>();
		URI url = UriComponentsBuilder.fromUri(repository.getUrl())
			.pathSegment(groupId.replace(".", "/"), artifactId, 'maven-metadata.xml')
			.build()
			.toUri();
		try {
			HttpHeaders headers = new HttpHeaders();
			String username = repository.getCredentials().getUsername();
			if (username != null) {
				headers.setBasicAuth(username, repository.getCredentials().getPassword());
			}
			HttpEntity<Void> request = new HttpEntity<>(headers);
			String metadata = this.rest.exchange(url, HttpMethod.GET, request, String.class).getBody();
			Document metadataDocument = DocumentBuilderFactory.newInstance()
				.newDocumentBuilder()
				.parse(new InputSource(new StringReader(metadata)));
			NodeList versionNodes = (NodeList) XPathFactory.newInstance()
				.newXPath()
				.evaluate('/metadata/versioning/versions/version', metadataDocument, XPathConstants.NODESET);
			for (int i = 0; i < versionNodes.getLength(); i++) {
				versions.add(versionNodes.item(i).getTextContent());
			}
		}
		catch (HttpClientErrorException ex) {
			if (ex.getStatusCode() != HttpStatus.NOT_FOUND) {
				System.err.println('Failed to download maven-metadata.xml for ' + groupId + ':' + artifactId + ' from '
						+ url + ': ' + ex.getMessage());
			}
		}
		catch (Exception ex) {
			System.err.println('Failed to resolve versions for module ' + groupId + ':' + artifactId + ' in repository '
					+ repository + ': ' + ex.getMessage());
		}
		return versions;
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
class UpgradeApplicator {
	private final Path buildFile;
	private final Path gradleProperties;
	UpgradeApplicator(Path buildFile, Path gradleProperties) {
		this.buildFile = buildFile;
		this.gradleProperties = gradleProperties;
	}
	Path apply(Upgrade upgrade) throws IOException {
		String buildFileContents = Files.readString(this.buildFile);
		Matcher matcher = Pattern.compile('library\\(\'' + upgrade.getLibrary().getName() + '\', \'(.+)\'\\)')
			.matcher(buildFileContents);
		if (!matcher.find()) {
			matcher = Pattern
				.compile('library\\(\'' + upgrade.getLibrary().getName() + '\'\\) \\{\\s+version\\(\'(.+)\'\\)',
						Pattern.MULTILINE)
				.matcher(buildFileContents);
			if (!matcher.find()) {
				throw new IllegalStateException('Failed to find definition for library "'
						+ upgrade.getLibrary().getName() + '" in bom "' + this.buildFile + '"');
			}
		}
		String version = matcher.group(1);
		if (version.startsWith('${') && version.endsWith('}')) {
			updateGradleProperties(upgrade, version);
			return this.gradleProperties;
		}
		else {
			updateBuildFile(upgrade, buildFileContents, matcher.start(1), matcher.end(1));
			return this.buildFile;
		}
	}
	private void updateGradleProperties(Upgrade upgrade, String version) throws IOException {
		String property = version.substring(2, version.length() - 1);
		String gradlePropertiesContents = Files.readString(this.gradleProperties);
		String modified = gradlePropertiesContents.replace(
				property + '=' + upgrade.getLibrary().getVersion().getVersion(), property + '=' + upgrade.getVersion());
		overwrite(this.gradleProperties, modified);
	}
	private void updateBuildFile(Upgrade upgrade, String buildFileContents, int versionStart, int versionEnd)
			throws IOException {
		String modified = buildFileContents.substring(0, versionStart) + upgrade.getVersion()
				+ buildFileContents.substring(versionEnd);
		overwrite(this.buildFile, modified);
	}
	private void overwrite(Path target, String content) throws IOException {
		Files.writeString(target, content, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
final class MultipleComponentsDependencyVersion extends ArtifactVersionDependencyVersion {
	private final String original;
	private MultipleComponentsDependencyVersion(ArtifactVersion artifactVersion, String original) {
		super(artifactVersion, new ComparableVersion(original));
		this.original = original;
	}
	@Override
	public String toString() {
		return this.original;
	}
	static MultipleComponentsDependencyVersion parse(String input) {
		String[] components = input.split('\\.');
		if (components.length == 4 || components.length == 5) {
			ArtifactVersion artifactVersion = new DefaultArtifactVersion(
					components[0] + '.' + components[1] + '.' + components[2]);
			if (artifactVersion.getQualifier() != null && artifactVersion.getQualifier().equals(input)) {
				return null;
			}
			return new MultipleComponentsDependencyVersion(artifactVersion, input);
		}
		return null;
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
final class LeadingZeroesDependencyVersion extends ArtifactVersionDependencyVersion {
	private static final Pattern PATTERN = Pattern.compile('0*([0-9]+)\\.0*([0-9]+)\\.0*([0-9]+)');
	private final String original;
	private LeadingZeroesDependencyVersion(ArtifactVersion artifactVersion, String original) {
		super(artifactVersion);
		this.original = original;
	}
	@Override
	public String toString() {
		return this.original;
	}
	static LeadingZeroesDependencyVersion parse(String input) {
		Matcher matcher = PATTERN.matcher(input);
		if (!matcher.matches()) {
			return null;
		}
		ArtifactVersion artifactVersion = new DefaultArtifactVersion(
				matcher.group(1) + matcher.group(2) + matcher.group(3));
		return new LeadingZeroesDependencyVersion(artifactVersion, input);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
final class UnstructuredDependencyVersion extends AbstractDependencyVersion implements DependencyVersion {
	private final String version;
	private UnstructuredDependencyVersion(String version) {
		super(new ComparableVersion(version));
		this.version = version;
	}
	@Override
	public boolean isSameMajor(DependencyVersion other) {
		return true;
	}
	@Override
	public boolean isSameMinor(DependencyVersion other) {
		return true;
	}
	@Override
	public String toString() {
		return this.version;
	}
	@Override
	public boolean isSnapshotFor(DependencyVersion candidate) {
		return false;
	}
	static UnstructuredDependencyVersion parse(String version) {
		return new UnstructuredDependencyVersion(version);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
public interface DependencyVersion extends Comparable<DependencyVersion> {
	/**
	 * Returns whether this version has the same major and minor versions as the
	 * {@code other} version.
	 * @param other the version to test
	 * @return {@code true} if this version has the same major and minor, otherwise
	 * {@code false}
	 */
	boolean isSameMinor(DependencyVersion other);
	/**
	 * Returns whether this version has the same major version as the {@code other}
	 * version.
	 * @param other the version to test
	 * @return {@code true} if this version has the same major, otherwise {@code false}
	 */
	boolean isSameMajor(DependencyVersion other);
	/**
	 * Returns whether the given {@code candidate} is an upgrade of this version.
	 * @param candidate the version to consider
	 * @param movingToSnapshots whether the upgrade is to be considered as part of moving
	 * to snapshots
	 * @return {@code true} if the candidate is an upgrade, otherwise false
	 */
	boolean isUpgrade(DependencyVersion candidate, boolean movingToSnapshots);
	/**
	 * Returns whether this version is a snapshot for the given {@code candidate}.
	 * @param candidate the version to consider
	 * @return {@code true} if this version is a snapshot for the candidate, otherwise
	 * false
	 */
	boolean isSnapshotFor(DependencyVersion candidate);
	static DependencyVersion parse(String version) {
		List<Function<String, DependencyVersion>> parsers = Arrays.asList(CalendarVersionDependencyVersion::parse,
				ArtifactVersionDependencyVersion::parse, ReleaseTrainDependencyVersion::parse,
				MultipleComponentsDependencyVersion::parse, CombinedPatchAndQualifierDependencyVersion::parse,
				LeadingZeroesDependencyVersion::parse, UnstructuredDependencyVersion::parse);
		for (Function<String, DependencyVersion> parser : parsers) {
			DependencyVersion result = parser.apply(version);
			if (result != null) {
				return result;
			}
		}
		throw new IllegalArgumentException('Version "' + version + '" could not be parsed');
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
final class ReleaseTrainDependencyVersion implements DependencyVersion {
	private static final Pattern VERSION_PATTERN = Pattern
		.compile('([A-Z][a-z]+)-((BUILD-SNAPSHOT)|([A-Z-]+)([0-9]*))');
	private final String releaseTrain;
	private final String type;
	private final int version;
	private final String original;
	private ReleaseTrainDependencyVersion(String releaseTrain, String type, int version, String original) {
		this.releaseTrain = releaseTrain;
		this.type = type;
		this.version = version;
		this.original = original;
	}
	@Override
	public int compareTo(DependencyVersion other) {
		if (!(other instanceof ReleaseTrainDependencyVersion otherReleaseTrain)) {
			return -1;
		}
		int comparison = this.releaseTrain.compareTo(otherReleaseTrain.releaseTrain);
		if (comparison != 0) {
			return comparison;
		}
		comparison = this.type.compareTo(otherReleaseTrain.type);
		if (comparison != 0) {
			return comparison;
		}
		return Integer.compare(this.version, otherReleaseTrain.version);
	}
	@Override
	public boolean isUpgrade(DependencyVersion candidate, boolean movingToSnapshots) {
		if (candidate instanceof ReleaseTrainDependencyVersion candidateReleaseTrain) {
			return isUpgrade(candidateReleaseTrain, movingToSnapshots);
		}
		return true;
	}
	private boolean isUpgrade(ReleaseTrainDependencyVersion candidate, boolean movingToSnapshots) {
		int comparison = this.releaseTrain.compareTo(candidate.releaseTrain);
		if (comparison != 0) {
			return comparison < 0;
		}
		if (movingToSnapshots && !isSnapshot() && candidate.isSnapshot()) {
			return true;
		}
		comparison = this.type.compareTo(candidate.type);
		if (comparison != 0) {
			return comparison < 0;
		}
		return Integer.compare(this.version, candidate.version) < 0;
	}
	private boolean isSnapshot() {
		return 'BUILD-SNAPSHOT'.equals(this.type);
	}
	@Override
	public boolean isSnapshotFor(DependencyVersion candidate) {
		if (!isSnapshot() || !(candidate instanceof ReleaseTrainDependencyVersion candidateReleaseTrain)) {
			return false;
		}
		return this.releaseTrain.equals(candidateReleaseTrain.releaseTrain);
	}
	@Override
	public boolean isSameMajor(DependencyVersion other) {
		return isSameReleaseTrain(other);
	}
	@Override
	public boolean isSameMinor(DependencyVersion other) {
		return isSameReleaseTrain(other);
	}
	private boolean isSameReleaseTrain(DependencyVersion other) {
		if (other instanceof CalendarVersionDependencyVersion) {
			return false;
		}
		if (other instanceof ReleaseTrainDependencyVersion otherReleaseTrain) {
			return otherReleaseTrain.releaseTrain.equals(this.releaseTrain);
		}
		return true;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		ReleaseTrainDependencyVersion other = (ReleaseTrainDependencyVersion) obj;
		return this.original.equals(other.original);
	}
	@Override
	public int hashCode() {
		return this.original.hashCode();
	}
	@Override
	public String toString() {
		return this.original;
	}
	static ReleaseTrainDependencyVersion parse(String input) {
		Matcher matcher = VERSION_PATTERN.matcher(input);
		if (!matcher.matches()) {
			return null;
		}
		return new ReleaseTrainDependencyVersion(matcher.group(1),
				StringUtils.hasLength(matcher.group(3)) ? matcher.group(3) : matcher.group(4),
				(StringUtils.hasLength(matcher.group(5))) ? Integer.parseInt(matcher.group(5)) : 0, input);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
abstract class AbstractDependencyVersion implements DependencyVersion {
	private final ComparableVersion comparableVersion;
	protected AbstractDependencyVersion(ComparableVersion comparableVersion) {
		this.comparableVersion = comparableVersion;
	}
	@Override
	public int compareTo(DependencyVersion other) {
		ComparableVersion otherComparable = (other instanceof AbstractDependencyVersion otherVersion)
				? otherVersion.comparableVersion : new ComparableVersion(other.toString());
		return this.comparableVersion.compareTo(otherComparable);
	}
	@Override
	public boolean isUpgrade(DependencyVersion candidate, boolean movingToSnapshots) {
		ComparableVersion comparableCandidate = (candidate instanceof AbstractDependencyVersion abstractDependencyVersion)
				? abstractDependencyVersion.comparableVersion : new ComparableVersion(candidate.toString());
		return comparableCandidate.compareTo(this.comparableVersion) > 0;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null) {
			return false;
		}
		if (getClass() != obj.getClass()) {
			return false;
		}
		AbstractDependencyVersion other = (AbstractDependencyVersion) obj;
		return this.comparableVersion.equals(other.comparableVersion);
	}
	@Override
	public int hashCode() {
		return this.comparableVersion.hashCode();
	}
	@Override
	public String toString() {
		return this.comparableVersion.toString();
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
final class CombinedPatchAndQualifierDependencyVersion extends ArtifactVersionDependencyVersion {
	private static final Pattern PATTERN = Pattern.compile('([0-9]+\\.[0-9]+\\.[0-9]+)([A-Za-z][A-Za-z0-9]+)');
	private final String original;
	private CombinedPatchAndQualifierDependencyVersion(ArtifactVersion artifactVersion, String original) {
		super(artifactVersion);
		this.original = original;
	}
	@Override
	public String toString() {
		return this.original;
	}
	static CombinedPatchAndQualifierDependencyVersion parse(String version) {
		Matcher matcher = PATTERN.matcher(version);
		if (!matcher.matches()) {
			return null;
		}
		ArtifactVersion artifactVersion = new DefaultArtifactVersion(matcher.group(1) + '.' + matcher.group(2));
		if (artifactVersion.getQualifier() != null && artifactVersion.getQualifier().equals(version)) {
			return null;
		}
		return new CombinedPatchAndQualifierDependencyVersion(artifactVersion, version);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class CalendarVersionDependencyVersion extends ArtifactVersionDependencyVersion {
	private static final Pattern CALENDAR_VERSION_PATTERN = Pattern.compile('\\d{4}\\.\\d+\\.\\d+(-.+)?');
	protected CalendarVersionDependencyVersion(ArtifactVersion artifactVersion) {
		super(artifactVersion);
	}
	protected CalendarVersionDependencyVersion(ArtifactVersion artifactVersion, ComparableVersion comparableVersion) {
		super(artifactVersion, comparableVersion);
	}
	static CalendarVersionDependencyVersion parse(String version) {
		if (!CALENDAR_VERSION_PATTERN.matcher(version).matches()) {
			return null;
		}
		ArtifactVersion artifactVersion = new DefaultArtifactVersion(version);
		if (artifactVersion.getQualifier() != null && artifactVersion.getQualifier().equals(version)) {
			return null;
		}
		return new CalendarVersionDependencyVersion(artifactVersion);
	}
}
/*
package org.springframework.boot.build.bom.bomr.version;
/**
class ArtifactVersionDependencyVersion extends AbstractDependencyVersion {
	private final ArtifactVersion artifactVersion;
	protected ArtifactVersionDependencyVersion(ArtifactVersion artifactVersion) {
		super(new ComparableVersion(toNormalizedString(artifactVersion)));
		this.artifactVersion = artifactVersion;
	}
	private static String toNormalizedString(ArtifactVersion artifactVersion) {
		String versionString = artifactVersion.toString();
		if (versionString.endsWith('.RELEASE')) {
			return versionString.substring(0, versionString.length() - 8);
		}
		if (versionString.endsWith('.BUILD-SNAPSHOT')) {
			return versionString.substring(0, versionString.length() - 15) + '-SNAPSHOT';
		}
		return versionString;
	}
	protected ArtifactVersionDependencyVersion(ArtifactVersion artifactVersion, ComparableVersion comparableVersion) {
		super(comparableVersion);
		this.artifactVersion = artifactVersion;
	}
	@Override
	public boolean isSameMajor(DependencyVersion other) {
		if (other instanceof ReleaseTrainDependencyVersion) {
			return false;
		}
		return extractArtifactVersionDependencyVersion(other).map(this::isSameMajor).orElse(true);
	}
	private boolean isSameMajor(ArtifactVersionDependencyVersion other) {
		return this.artifactVersion.getMajorVersion() == other.artifactVersion.getMajorVersion();
	}
	@Override
	public boolean isSameMinor(DependencyVersion other) {
		if (other instanceof ReleaseTrainDependencyVersion) {
			return false;
		}
		return extractArtifactVersionDependencyVersion(other).map(this::isSameMinor).orElse(true);
	}
	private boolean isSameMinor(ArtifactVersionDependencyVersion other) {
		return isSameMajor(other) && this.artifactVersion.getMinorVersion() == other.artifactVersion.getMinorVersion();
	}
	@Override
	public boolean isUpgrade(DependencyVersion candidate, boolean movingToSnapshots) {
		if (candidate instanceof MultipleComponentsDependencyVersion) {
			return super.isUpgrade(candidate, movingToSnapshots);
		}
		if (!(candidate instanceof ArtifactVersionDependencyVersion)) {
			return false;
		}
		ArtifactVersion other = ((ArtifactVersionDependencyVersion) candidate).artifactVersion;
		if (this.artifactVersion.equals(other)) {
			return false;
		}
		if (sameMajorMinorIncremental(other)) {
			if (!StringUtils.hasLength(this.artifactVersion.getQualifier())
					|| 'RELEASE'.equals(this.artifactVersion.getQualifier())) {
				return false;
			}
			if (isSnapshot()) {
				return true;
			}
			else if (((ArtifactVersionDependencyVersion) candidate).isSnapshot()) {
				return movingToSnapshots;
			}
		}
		return super.isUpgrade(candidate, movingToSnapshots);
	}
	private boolean sameMajorMinorIncremental(ArtifactVersion other) {
		return this.artifactVersion.getMajorVersion() == other.getMajorVersion()
				&& this.artifactVersion.getMinorVersion() == other.getMinorVersion()
				&& this.artifactVersion.getIncrementalVersion() == other.getIncrementalVersion();
	}
	private boolean isSnapshot() {
		return 'SNAPSHOT'.equals(this.artifactVersion.getQualifier())
				|| 'BUILD'.equals(this.artifactVersion.getQualifier());
	}
	@Override
	public boolean isSnapshotFor(DependencyVersion candidate) {
		if (!isSnapshot() || !(candidate instanceof ArtifactVersionDependencyVersion)) {
			return false;
		}
		return sameMajorMinorIncremental(((ArtifactVersionDependencyVersion) candidate).artifactVersion);
	}
	@Override
	public int compareTo(DependencyVersion other) {
		if (other instanceof ArtifactVersionDependencyVersion otherArtifactDependencyVersion) {
			ArtifactVersion otherArtifactVersion = otherArtifactDependencyVersion.artifactVersion;
			if ((!Objects.equals(this.artifactVersion.getQualifier(), otherArtifactVersion.getQualifier()))
					&& 'snapshot'.equalsIgnoreCase(otherArtifactVersion.getQualifier())
					&& otherArtifactVersion.getMajorVersion() == this.artifactVersion.getMajorVersion()
					&& otherArtifactVersion.getMinorVersion() == this.artifactVersion.getMinorVersion()
					&& otherArtifactVersion.getIncrementalVersion() == this.artifactVersion.getIncrementalVersion()) {
				return 1;
			}
		}
		return super.compareTo(other);
	}
	@Override
	public String toString() {
		return this.artifactVersion.toString();
	}
	protected Optional<ArtifactVersionDependencyVersion> extractArtifactVersionDependencyVersion(
			DependencyVersion other) {
		ArtifactVersionDependencyVersion artifactVersion = null;
		if (other instanceof ArtifactVersionDependencyVersion otherVersion) {
			artifactVersion = otherVersion;
		}
		return Optional.ofNullable(artifactVersion);
	}
	static ArtifactVersionDependencyVersion parse(String version) {
		ArtifactVersion artifactVersion = new DefaultArtifactVersion(version);
		if (artifactVersion.getQualifier() != null && artifactVersion.getQualifier().equals(version)) {
			return null;
		}
		return new ArtifactVersionDependencyVersion(artifactVersion);
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
public interface LibraryUpdateResolver {
	/**
	 * Finds library updates.
	 * @param librariesToUpgrade libraries to update
	 * @param librariesByName libraries indexed by name
	 * @return library which have updates
	 */
	List<LibraryWithVersionOptions> findLibraryUpdates(Collection<Library> librariesToUpgrade,
			Map<String, Library> librariesByName);
}
/*
package org.springframework.boot.build.bom.bomr.github;
/**
public interface GitHub {
	/**
	 * Returns a {@link GitHubRepository} with the given {@code name} in the given
	 * {@code organization}.
	 * @param organization the organization
	 * @param name the name of the repository
	 * @return the repository
	 */
	GitHubRepository getRepository(String organization, String name);
	/**
	 * Creates a new {@code GitHub} that will authenticate with given {@code username} and
	 * {@code password}.
	 * @param username username for authentication
	 * @param password password for authentication
	 * @return the new {@code GitHub} instance
	 */
	static GitHub withCredentials(String username, String password) {
		return new StandardGitHub(username, password);
	}
}
/*
package org.springframework.boot.build.bom.bomr.github;
/**
public class Issue {
	private final RestTemplate rest;
	private final int number;
	private final String title;
	private final State state;
	Issue(RestTemplate rest, int number, String title, State state) {
		this.rest = rest;
		this.number = number;
		this.title = title;
		this.state = state;
	}
	public int getNumber() {
		return this.number;
	}
	public String getTitle() {
		return this.title;
	}
	public State getState() {
		return this.state;
	}
	/**
	 * Labels the issue with the given {@code labels}. Any existing labels are removed.
	 * @param labels the labels to apply to the issue
	 */
	public void label(List<String> labels) {
		Map<String, List<String>> body = Collections.singletonMap('labels', labels);
		this.rest.put('issues/' + this.number + '/labels', body);
	}
	public enum State {
		/**
		 * The issue is open.
		 */
		OPEN,
		/**
		 * The issue is closed.
		 */
		CLOSED;
		static State of(String state) {
			if ('open'.equals(state)) {
				return OPEN;
			}
			if ('closed'.equals(state)) {
				return CLOSED;
			}
			else {
				throw new IllegalArgumentException('Unknown state "' + state + '"');
			}
		}
	}
}
/*
package org.springframework.boot.build.bom.bomr.github;
/**
final class StandardGitHub implements GitHub {
	private final String username;
	private final String password;
	StandardGitHub(String username, String password) {
		this.username = username;
		this.password = password;
	}
	@Override
	public GitHubRepository getRepository(String organization, String name) {
		RestTemplate restTemplate = new RestTemplate(
				Collections.singletonList(new MappingJackson2HttpMessageConverter(new ObjectMapper())));
		restTemplate.getInterceptors().add((request, body, execution) -> {
			request.getHeaders().add('User-Agent', StandardGitHub.this.username);
			request.getHeaders()
				.add('Authorization', 'Basic ' + Base64.getEncoder()
					.encodeToString((StandardGitHub.this.username + ':' + StandardGitHub.this.password).getBytes()));
			request.getHeaders().add('Accept', MediaType.APPLICATION_JSON_VALUE);
			return execution.execute(request, body);
		});
		UriTemplateHandler uriTemplateHandler = new DefaultUriBuilderFactory(
				'https://api.github.com/repos/' + organization + '/' + name + '/');
		restTemplate.setUriTemplateHandler(uriTemplateHandler);
		return new StandardGitHubRepository(restTemplate);
	}
}
/*
package org.springframework.boot.build.bom.bomr.github;
/**
public interface GitHubRepository {
	/**
	 * Opens a new issue with the given title. The given {@code labels} will be applied to
	 * the issue and it will be assigned to the given {@code milestone}.
	 * @param title the title of the issue
	 * @param body the body of the issue
	 * @param labels the labels to apply to the issue
	 * @param milestone the milestone to assign the issue to
	 * @return the number of the new issue
	 */
	int openIssue(String title, String body, List<String> labels, Milestone milestone);
	/**
	 * Returns the labels in the repository.
	 * @return the labels
	 */
	Set<String> getLabels();
	/**
	 * Returns the milestones in the repository.
	 * @return the milestones
	 */
	List<Milestone> getMilestones();
	/**
	 * Finds issues that have the given {@code labels} and are assigned to the given
	 * {@code milestone}.
	 * @param labels issue labels
	 * @param milestone assigned milestone
	 * @return the matching issues
	 */
	List<Issue> findIssues(List<String> labels, Milestone milestone);
}
/*
package org.springframework.boot.build.bom.bomr.github;
/**
public class Milestone {
	private final String name;
	private final int number;
	private final OffsetDateTime dueOn;
	Milestone(String name, int number, OffsetDateTime dueOn) {
		this.name = name;
		this.number = number;
		this.dueOn = dueOn;
	}
	/**
	 * Returns the name of the milestone.
	 * @return the name
	 */
	public String getName() {
		return this.name;
	}
	/**
	 * Returns the number of the milestone.
	 * @return the number
	 */
	public int getNumber() {
		return this.number;
	}
	public OffsetDateTime getDueOn() {
		return this.dueOn;
	}
	@Override
	public String toString() {
		return this.name + ' (' + this.number + ')';
	}
}
/*
package org.springframework.boot.build.bom.bomr.github;
/**
final class StandardGitHubRepository implements GitHubRepository {
	private final RestTemplate rest;
	StandardGitHubRepository(RestTemplate restTemplate) {
		this.rest = restTemplate;
	}
	@Override
	@SuppressWarnings('rawtypes')
	public int openIssue(String title, String body, List<String> labels, Milestone milestone) {
		Map<String, Object> requestBody = new HashMap<>();
		requestBody.put('title', title);
		if (milestone != null) {
			requestBody.put('milestone', milestone.getNumber());
		}
		if (!labels.isEmpty()) {
			requestBody.put('labels', labels);
		}
		requestBody.put('body', body);
		try {
			ResponseEntity<Map> response = this.rest.postForEntity('issues', requestBody, Map.class);
			// See gh-30304
			sleep(Duration.ofSeconds(3));
			return (Integer) response.getBody().get('number');
		}
		catch (RestClientException ex) {
			if (ex instanceof Forbidden forbidden) {
				System.out.println('Received 403 response with headers ' + forbidden.getResponseHeaders());
			}
			throw ex;
		}
	}
	@Override
	public Set<String> getLabels() {
		return new HashSet<>(get('labels?per_page=100', (label) -> (String) label.get('name')));
	}
	@Override
	public List<Milestone> getMilestones() {
		return get('milestones?per_page=100', (milestone) -> new Milestone((String) milestone.get('title'),
				(Integer) milestone.get('number'),
				(milestone.get('due_on') != null) ? OffsetDateTime.parse((String) milestone.get('due_on')) : null));
	}
	@Override
	public List<Issue> findIssues(List<String> labels, Milestone milestone) {
		return get(
				'issues?per_page=100&state=all&labels=' + String.join(',', labels) + '&milestone='
						+ milestone.getNumber(),
				(issue) -> new Issue(this.rest, (Integer) issue.get('number'), (String) issue.get('title'),
						Issue.State.of((String) issue.get('state'))));
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private <T> List<T> get(String name, Function<Map<String, Object>, T> mapper) {
		ResponseEntity<List> response = this.rest.getForEntity(name, List.class);
		return ((List<Map<String, Object>>) response.getBody()).stream().map(mapper).toList();
	}
	private static void sleep(Duration duration) {
		try {
			Thread.sleep(duration.toMillis());
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
class ReleaseSchedule {
	private static final Pattern LIBRARY_AND_VERSION = Pattern.compile('([A-Za-z0-9 ]+) ([0-9A-Za-z.-]+)');
	private final RestOperations rest;
	ReleaseSchedule() {
		this(new RestTemplate());
	}
	ReleaseSchedule(RestOperations rest) {
		this.rest = rest;
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	Map<String, List<Release>> releasesBetween(OffsetDateTime start, OffsetDateTime end) {
		ResponseEntity<List> response = this.rest
			.getForEntity('https://calendar.spring.io/releases?start=' + start + '&end=' + end, List.class);
		List<Map<String, String>> body = response.getBody();
		Map<String, List<Release>> releasesByLibrary = new LinkedCaseInsensitiveMap<>();
		body.stream()
			.map(this::asRelease)
			.filter(Objects::nonNull)
			.forEach((release) -> releasesByLibrary.computeIfAbsent(release.getLibraryName(), (l) -> new ArrayList<>())
				.add(release));
		return releasesByLibrary;
	}
	private Release asRelease(Map<String, String> entry) {
		LocalDate due = LocalDate.parse(entry.get('start'));
		String title = entry.get('title');
		Matcher matcher = LIBRARY_AND_VERSION.matcher(title);
		if (!matcher.matches()) {
			return null;
		}
		String library = matcher.group(1);
		String version = matcher.group(2);
		return new Release(library, DependencyVersion.parse(version), due);
	}
	static class Release {
		private final String libraryName;
		private final DependencyVersion version;
		private final LocalDate dueOn;
		Release(String libraryName, DependencyVersion version, LocalDate dueOn) {
			this.libraryName = libraryName;
			this.version = version;
			this.dueOn = dueOn;
		}
		String getLibraryName() {
			return this.libraryName;
		}
		DependencyVersion getVersion() {
			return this.version;
		}
		LocalDate getDueOn() {
			return this.dueOn;
		}
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
interface UpgradeResolver {
	/**
	 * Resolves the upgrades to be applied to the given {@code libraries}.
	 * @param librariesToUpgrade the libraries to upgrade
	 * @param libraries all libraries
	 * @return the upgrades
	 */
	List<Upgrade> resolveUpgrades(Collection<Library> librariesToUpgrade, Collection<Library> libraries);
}
/*
package org.springframework.boot.build.bom.bomr;
/**
interface VersionResolver {
	/**
	 * Resolves the available versions for the module identified by the given
	 * {@code groupId} and {@code artifactId}.
	 * @param groupId module"s group ID
	 * @param artifactId module"s artifact ID
	 * @return the available versions
	 */
	SortedSet<DependencyVersion> resolveVersions(String groupId, String artifactId);
}
/*
package org.springframework.boot.build.bom.bomr;
/**
class StandardLibraryUpdateResolver implements LibraryUpdateResolver {
	private static final Logger logger = LoggerFactory.getLogger(StandardLibraryUpdateResolver.class);
	private final VersionResolver versionResolver;
	private final BiPredicate<Library, DependencyVersion> predicate;
	StandardLibraryUpdateResolver(VersionResolver versionResolver,
			List<BiPredicate<Library, DependencyVersion>> predicates) {
		this.versionResolver = versionResolver;
		this.predicate = (library, dependencyVersion) -> predicates.stream()
			.allMatch((predicate) -> predicate.test(library, dependencyVersion));
	}
	@Override
	public List<LibraryWithVersionOptions> findLibraryUpdates(Collection<Library> librariesToUpgrade,
			Map<String, Library> librariesByName) {
		List<LibraryWithVersionOptions> result = new ArrayList<>();
		for (Library library : librariesToUpgrade) {
			if (isLibraryExcluded(library)) {
				continue;
			}
			logger.info('Looking for updates for {}', library.getName());
			long start = System.nanoTime();
			List<VersionOption> versionOptions = getVersionOptions(library);
			result.add(new LibraryWithVersionOptions(library, versionOptions));
			logger.info('Found {} updates for {}, took {}', versionOptions.size(), library.getName(),
					Duration.ofNanos(System.nanoTime() - start));
		}
		return result;
	}
	protected boolean isLibraryExcluded(Library library) {
		return library.getName().equals('Spring Boot');
	}
	protected List<VersionOption> getVersionOptions(Library library) {
		VersionOption option = determineAlignedVersionOption(library);
		return (option != null) ? List.of(option) : determineResolvedVersionOptions(library);
	}
	private VersionOption determineAlignedVersionOption(Library library) {
		VersionAlignment versionAlignment = library.getVersionAlignment();
		if (versionAlignment != null) {
			Set<String> alignedVersions = versionAlignment.resolve();
			if (alignedVersions != null && alignedVersions.size() == 1) {
				DependencyVersion alignedVersion = DependencyVersion.parse(alignedVersions.iterator().next());
				if (!alignedVersion.equals(library.getVersion().getVersion())) {
					return new VersionOption.AlignedVersionOption(alignedVersion, versionAlignment);
				}
			}
		}
		return null;
	}
	private List<VersionOption> determineResolvedVersionOptions(Library library) {
		Map<String, SortedSet<DependencyVersion>> moduleVersions = new LinkedHashMap<>();
		for (Group group : library.getGroups()) {
			for (Module module : group.getModules()) {
				moduleVersions.put(group.getId() + ':' + module.getName(),
						getLaterVersionsForModule(group.getId(), module.getName(), library));
			}
			for (String bom : group.getBoms()) {
				moduleVersions.put(group.getId() + ':' + bom, getLaterVersionsForModule(group.getId(), bom, library));
			}
			for (String plugin : group.getPlugins()) {
				moduleVersions.put(group.getId() + ':' + plugin,
						getLaterVersionsForModule(group.getId(), plugin, library));
			}
		}
		return moduleVersions.values()
			.stream()
			.flatMap(SortedSet::stream)
			.distinct()
			.filter((dependencyVersion) -> this.predicate.test(library, dependencyVersion))
			.map((version) -> (VersionOption) new VersionOption.ResolvedVersionOption(version,
					getMissingModules(moduleVersions, version)))
			.toList();
	}
	private List<String> getMissingModules(Map<String, SortedSet<DependencyVersion>> moduleVersions,
			DependencyVersion version) {
		List<String> missingModules = new ArrayList<>();
		moduleVersions.forEach((name, versions) -> {
			if (!versions.contains(version)) {
				missingModules.add(name);
			}
		});
		return missingModules;
	}
	private SortedSet<DependencyVersion> getLaterVersionsForModule(String groupId, String artifactId, Library library) {
		return this.versionResolver.resolveVersions(groupId, artifactId);
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
class VersionOption {
	private final DependencyVersion version;
	VersionOption(DependencyVersion version) {
		this.version = version;
	}
	DependencyVersion getVersion() {
		return this.version;
	}
	@Override
	public String toString() {
		return this.version.toString();
	}
	static final class AlignedVersionOption extends VersionOption {
		private final VersionAlignment alignedWith;
		AlignedVersionOption(DependencyVersion version, VersionAlignment alignedWith) {
			super(version);
			this.alignedWith = alignedWith;
		}
		@Override
		public String toString() {
			return super.toString() + ' (aligned with ' + this.alignedWith + ')';
		}
	}
	static final class ResolvedVersionOption extends VersionOption {
		private final List<String> missingModules;
		ResolvedVersionOption(DependencyVersion version, List<String> missingModules) {
			super(version);
			this.missingModules = missingModules;
		}
		@Override
		public String toString() {
			if (this.missingModules.isEmpty()) {
				return super.toString();
			}
			return super.toString() + ' (some modules are missing: '
					+ StringUtils.collectionToDelimitedString(this.missingModules, ', ') + ')';
		}
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
public abstract class UpgradeBom extends UpgradeDependencies {
	@Inject
	public UpgradeBom(BomExtension bom) {
		super(bom);
		switch (BuildProperties.get(getProject()).buildType()) {
			case OPEN_SOURCE -> addOpenSourceRepositories();
			case COMMERCIAL -> addCommercialRepositories();
		}
	}
	private void addOpenSourceRepositories() {
		getRepositoryNames().add(ArtifactRepositoryContainer.DEFAULT_MAVEN_CENTRAL_REPO_NAME);
		getProject().getRepositories().withType(MavenArtifactRepository.class, (repository) -> {
			String name = repository.getName();
			if (name.startsWith('spring-') && !name.endsWith('-snapshot')) {
				getRepositoryNames().add(name);
			}
		});
	}
	private void addCommercialRepositories() {
		getRepositoryNames().addAll(ArtifactRepositoryContainer.DEFAULT_MAVEN_CENTRAL_REPO_NAME,
				'spring-commercial-release');
	}
	@Override
	protected String issueTitle(Upgrade upgrade) {
		return 'Upgrade to ' + upgrade.getLibrary().getName() + ' ' + upgrade.getVersion();
	}
	@Override
	protected String commitMessage(Upgrade upgrade, int issueNumber) {
		return issueTitle(upgrade) + '\n\nCloses gh-' + issueNumber;
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
class MultithreadedLibraryUpdateResolver implements LibraryUpdateResolver {
	private static final Logger logger = LoggerFactory.getLogger(MultithreadedLibraryUpdateResolver.class);
	private final int threads;
	private final LibraryUpdateResolver delegate;
	MultithreadedLibraryUpdateResolver(int threads, LibraryUpdateResolver delegate) {
		this.threads = threads;
		this.delegate = delegate;
	}
	@Override
	public List<LibraryWithVersionOptions> findLibraryUpdates(Collection<Library> librariesToUpgrade,
			Map<String, Library> librariesByName) {
		logger.info('Looking for updates using {} threads', this.threads);
		ExecutorService executorService = Executors.newFixedThreadPool(this.threads);
		try {
			return librariesToUpgrade.stream().map((library) -> {
				if (library.getVersionAlignment() == null) {
					return executorService.submit(() -> this.delegate
						.findLibraryUpdates(Collections.singletonList(library), librariesByName));
				}
				else {
					return CompletableFuture.completedFuture(
							this.delegate.findLibraryUpdates(Collections.singletonList(library), librariesByName));
				}
			}).flatMap(this::getResult).toList();
		}
		finally {
			executorService.shutdownNow();
		}
	}
	private Stream<LibraryWithVersionOptions> getResult(Future<List<LibraryWithVersionOptions>> job) {
		try {
			return job.get().stream();
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
			throw new RuntimeException(ex);
		}
		catch (ExecutionException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
public final class InteractiveUpgradeResolver implements UpgradeResolver {
	private final UserInputHandler userInputHandler;
	private final LibraryUpdateResolver libraryUpdateResolver;
	InteractiveUpgradeResolver(UserInputHandler userInputHandler, LibraryUpdateResolver libraryUpdateResolver) {
		this.userInputHandler = userInputHandler;
		this.libraryUpdateResolver = libraryUpdateResolver;
	}
	@Override
	public List<Upgrade> resolveUpgrades(Collection<Library> librariesToUpgrade, Collection<Library> libraries) {
		Map<String, Library> librariesByName = new HashMap<>();
		for (Library library : libraries) {
			librariesByName.put(library.getName(), library);
		}
		List<LibraryWithVersionOptions> libraryUpdates = this.libraryUpdateResolver
			.findLibraryUpdates(librariesToUpgrade, librariesByName);
		try {
			return libraryUpdates.stream().map(this::resolveUpgrade).filter(Objects::nonNull).toList();
		}
		catch (UpgradesInterruptedException ex) {
			return Collections.emptyList();
		}
	}
	private Upgrade resolveUpgrade(LibraryWithVersionOptions libraryWithVersionOptions) {
		if (libraryWithVersionOptions.getVersionOptions().isEmpty()) {
			return null;
		}
		VersionOption defaultOption = new VersionOption(
				libraryWithVersionOptions.getLibrary().getVersion().getVersion());
		VersionOption selected = this.userInputHandler.askUser((questions) -> {
			String question = libraryWithVersionOptions.getLibrary().getName() + ' '
					+ libraryWithVersionOptions.getLibrary().getVersion().getVersion();
			List<VersionOption> options = new ArrayList<>();
			options.add(defaultOption);
			options.addAll(libraryWithVersionOptions.getVersionOptions());
			return questions.selectOption(question, options, defaultOption);
		}).get();
		if (this.userInputHandler.interrupted()) {
			throw new UpgradesInterruptedException();
		}
		return (selected.equals(defaultOption)) ? null
				: new Upgrade(libraryWithVersionOptions.getLibrary(), selected.getVersion());
	}
	static class UpgradesInterruptedException extends RuntimeException {
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
public abstract class UpgradeDependencies extends DefaultTask {
	private final BomExtension bom;
	private final boolean movingToSnapshots;
	@Inject
	public UpgradeDependencies(BomExtension bom) {
		this(bom, false);
	}
	protected UpgradeDependencies(BomExtension bom, boolean movingToSnapshots) {
		this.bom = bom;
		getThreads().convention(2);
		this.movingToSnapshots = movingToSnapshots;
	}
	@Input
	@Option(option = 'milestone', description = 'Milestone to which dependency upgrade issues should be assigned')
	public abstract Property<String> getMilestone();
	@Input
	@Optional
	@Option(option = 'threads', description = 'Number of Threads to use for update resolution')
	public abstract Property<Integer> getThreads();
	@Input
	@Optional
	@Option(option = 'libraries', description = 'Regular expression that identifies the libraries to upgrade')
	public abstract Property<String> getLibraries();
	@Input
	abstract ListProperty<String> getRepositoryNames();
	@TaskAction
	void upgradeDependencies() {
		GitHubRepository repository = createGitHub().getRepository(this.bom.getUpgrade().getGitHub().getOrganization(),
				this.bom.getUpgrade().getGitHub().getRepository());
		List<String> issueLabels = verifyLabels(repository);
		Milestone milestone = determineMilestone(repository);
		List<Upgrade> upgrades = resolveUpgrades(milestone);
		applyUpgrades(repository, issueLabels, milestone, upgrades);
	}
	private void applyUpgrades(GitHubRepository repository, List<String> issueLabels, Milestone milestone,
			List<Upgrade> upgrades) {
		Path buildFile = getProject().getBuildFile().toPath();
		Path gradleProperties = new File(getProject().getRootProject().getProjectDir(), 'gradle.properties').toPath();
		UpgradeApplicator upgradeApplicator = new UpgradeApplicator(buildFile, gradleProperties);
		List<Issue> existingUpgradeIssues = repository.findIssues(issueLabels, milestone);
		System.out.println('Applying upgrades...');
		System.out.println('');
		for (Upgrade upgrade : upgrades) {
			System.out.println(upgrade.getLibrary().getName() + ' ' + upgrade.getVersion());
			String title = issueTitle(upgrade);
			Issue existingUpgradeIssue = findExistingUpgradeIssue(existingUpgradeIssues, upgrade);
			try {
				Path modified = upgradeApplicator.apply(upgrade);
				int issueNumber = getOrOpenUpgradeIssue(repository, issueLabels, milestone, title,
						existingUpgradeIssue);
				if (existingUpgradeIssue != null && existingUpgradeIssue.getState() == Issue.State.CLOSED) {
					existingUpgradeIssue.label(Arrays.asList('type: task', 'status: superseded'));
				}
				System.out.println('   Issue: ' + issueNumber + ' - ' + title
						+ getExistingUpgradeIssueMessageDetails(existingUpgradeIssue));
				if (new ProcessBuilder().command('git', 'add', modified.toFile().getAbsolutePath())
					.start()
					.waitFor() != 0) {
					throw new IllegalStateException('git add failed');
				}
				String commitMessage = commitMessage(upgrade, issueNumber);
				if (new ProcessBuilder().command('git', 'commit', '-m', commitMessage).start().waitFor() != 0) {
					throw new IllegalStateException('git commit failed');
				}
				System.out.println('  Commit: ' + commitMessage.substring(0, commitMessage.indexOf("\n")));
			}
			catch (IOException ex) {
				throw new TaskExecutionException(this, ex);
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
	}
	private int getOrOpenUpgradeIssue(GitHubRepository repository, List<String> issueLabels, Milestone milestone,
			String title, Issue existingUpgradeIssue) {
		if (existingUpgradeIssue != null && existingUpgradeIssue.getState() == Issue.State.OPEN) {
			return existingUpgradeIssue.getNumber();
		}
		String body = (existingUpgradeIssue != null) ? 'Supersedes #' + existingUpgradeIssue.getNumber() : '';
		return repository.openIssue(title, body, issueLabels, milestone);
	}
	private String getExistingUpgradeIssueMessageDetails(Issue existingUpgradeIssue) {
		if (existingUpgradeIssue == null) {
			return '';
		}
		if (existingUpgradeIssue.getState() != Issue.State.CLOSED) {
			return ' (completes existing upgrade)';
		}
		return ' (supersedes #' + existingUpgradeIssue.getNumber() + ' ' + existingUpgradeIssue.getTitle() + ')';
	}
	private List<String> verifyLabels(GitHubRepository repository) {
		Set<String> availableLabels = repository.getLabels();
		List<String> issueLabels = this.bom.getUpgrade().getGitHub().getIssueLabels();
		if (!availableLabels.containsAll(issueLabels)) {
			List<String> unknownLabels = new ArrayList<>(issueLabels);
			unknownLabels.removeAll(availableLabels);
			String suffix = (unknownLabels.size() == 1) ? '' : 's';
			throw new InvalidUserDataException(
					'Unknown label' + suffix + ': ' + StringUtils.collectionToCommaDelimitedString(unknownLabels));
		}
		return issueLabels;
	}
	private GitHub createGitHub() {
		Properties bomrProperties = new Properties();
		try (Reader reader = new FileReader(new File(System.getProperty('user.home'), '.bomr.properties'))) {
			bomrProperties.load(reader);
			String username = bomrProperties.getProperty('bomr.github.username');
			String password = bomrProperties.getProperty('bomr.github.password');
			return GitHub.withCredentials(username, password);
		}
		catch (IOException ex) {
			throw new InvalidUserDataException('Failed to load .bomr.properties from user home', ex);
		}
	}
	private Milestone determineMilestone(GitHubRepository repository) {
		List<Milestone> milestones = repository.getMilestones();
		java.util.Optional<Milestone> matchingMilestone = milestones.stream()
			.filter((milestone) -> milestone.getName().equals(getMilestone().get()))
			.findFirst();
		if (matchingMilestone.isEmpty()) {
			throw new InvalidUserDataException('Unknown milestone: ' + getMilestone().get());
		}
		return matchingMilestone.get();
	}
	private Issue findExistingUpgradeIssue(List<Issue> existingUpgradeIssues, Upgrade upgrade) {
		String toMatch = 'Upgrade to ' + upgrade.getLibrary().getName();
		for (Issue existingUpgradeIssue : existingUpgradeIssues) {
			String title = existingUpgradeIssue.getTitle();
			int lastSpaceIndex = title.lastIndexOf(" ");
			if (lastSpaceIndex > -1) {
				title = title.substring(0, lastSpaceIndex);
			}
			if (title.equals(toMatch)) {
				return existingUpgradeIssue;
			}
		}
		return null;
	}
	@SuppressWarnings('deprecation')
	private List<Upgrade> resolveUpgrades(Milestone milestone) {
		InteractiveUpgradeResolver upgradeResolver = new InteractiveUpgradeResolver(
				getServices().get(UserInputHandler.class), getLibraryUpdateResolver(milestone));
		return upgradeResolver.resolveUpgrades(matchingLibraries(), this.bom.getLibraries());
	}
	private LibraryUpdateResolver getLibraryUpdateResolver(Milestone milestone) {
		VersionResolver versionResolver = new MavenMetadataVersionResolver(getRepositories());
		LibraryUpdateResolver libraryResolver = new StandardLibraryUpdateResolver(versionResolver,
				determineUpdatePredicates(milestone));
		return new MultithreadedLibraryUpdateResolver(getThreads().get(), libraryResolver);
	}
	private Collection<MavenArtifactRepository> getRepositories() {
		return getRepositoryNames().map(this::asRepositories).get();
	}
	private List<MavenArtifactRepository> asRepositories(List<String> repositoryNames) {
		return repositoryNames.stream()
			.map(getProject().getRepositories()::getByName)
			.map(MavenArtifactRepository.class::cast)
			.toList();
	}
	protected List<BiPredicate<Library, DependencyVersion>> determineUpdatePredicates(Milestone milestone) {
		List<BiPredicate<Library, DependencyVersion>> updatePredicates = new ArrayList<>();
		updatePredicates.add(this::compliesWithUpgradePolicy);
		updatePredicates.add(this::isAnUpgrade);
		updatePredicates.add(this::isNotProhibited);
		return updatePredicates;
	}
	private boolean compliesWithUpgradePolicy(Library library, DependencyVersion candidate) {
		return this.bom.getUpgrade().getPolicy().test(candidate, library.getVersion().getVersion());
	}
	private boolean isAnUpgrade(Library library, DependencyVersion candidate) {
		return library.getVersion().getVersion().isUpgrade(candidate, this.movingToSnapshots);
	}
	private boolean isNotProhibited(Library library, DependencyVersion candidate) {
		return library.getProhibitedVersions()
			.stream()
			.noneMatch((prohibited) -> prohibited.isProhibited(candidate.toString()));
	}
	private List<Library> matchingLibraries() {
		List<Library> matchingLibraries = this.bom.getLibraries().stream().filter(this::eligible).toList();
		if (matchingLibraries.isEmpty()) {
			throw new InvalidUserDataException('No libraries to upgrade');
		}
		return matchingLibraries;
	}
	protected boolean eligible(Library library) {
		String pattern = getLibraries().getOrNull();
		if (pattern == null) {
			return true;
		}
		Predicate<String> libraryPredicate = Pattern.compile(pattern).asPredicate();
		return libraryPredicate.test(library.getName());
	}
	protected abstract String issueTitle(Upgrade upgrade);
	protected abstract String commitMessage(Upgrade upgrade, int issueNumber);
}
/*
package org.springframework.boot.build.bom.bomr;
class LibraryWithVersionOptions {
	private final Library library;
	private final List<VersionOption> versionOptions;
	LibraryWithVersionOptions(Library library, List<VersionOption> versionOptions) {
		this.library = library;
		this.versionOptions = versionOptions;
	}
	Library getLibrary() {
		return this.library;
	}
	List<VersionOption> getVersionOptions() {
		return this.versionOptions;
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
public abstract class MoveToSnapshots extends UpgradeDependencies {
	private static final Logger logger = LoggerFactory.getLogger(MoveToSnapshots.class);
	@Inject
	public MoveToSnapshots(BomExtension bom) {
		super(bom, true);
		getProject().getRepositories().withType(MavenArtifactRepository.class, (repository) -> {
			String name = repository.getName();
			if (name.startsWith('spring-') && name.endsWith('-snapshot')) {
				getRepositoryNames().add(name);
			}
		});
	}
	@Override
	@TaskAction
	void upgradeDependencies() {
		super.upgradeDependencies();
	}
	@Override
	protected String issueTitle(Upgrade upgrade) {
		String snapshotVersion = upgrade.getVersion().toString();
		String releaseVersion = snapshotVersion.substring(0, snapshotVersion.length() - '-SNAPSHOT'.length());
		return 'Upgrade to ' + upgrade.getLibrary().getName() + ' ' + releaseVersion;
	}
	@Override
	protected String commitMessage(Upgrade upgrade, int issueNumber) {
		return 'Start building against ' + upgrade.getLibrary().getName() + ' ' + releaseVersion(upgrade) + ' snapshots'
				+ '\n\nSee gh-' + issueNumber;
	}
	private String releaseVersion(Upgrade upgrade) {
		String snapshotVersion = upgrade.getVersion().toString();
		return snapshotVersion.substring(0, snapshotVersion.length() - '-SNAPSHOT'.length());
	}
	@Override
	protected boolean eligible(Library library) {
		return library.isConsiderSnapshots() && super.eligible(library);
	}
	@Override
	protected List<BiPredicate<Library, DependencyVersion>> determineUpdatePredicates(Milestone milestone) {
		return switch (BuildProperties.get(getProject()).buildType()) {
			case OPEN_SOURCE -> determineOpenSourceUpdatePredicates(milestone);
			case COMMERCIAL -> super.determineUpdatePredicates(milestone);
		};
	}
	private List<BiPredicate<Library, DependencyVersion>> determineOpenSourceUpdatePredicates(Milestone milestone) {
		Map<String, List<Release>> scheduledReleases = getScheduledOpenSourceReleases(milestone);
		List<BiPredicate<Library, DependencyVersion>> predicates = super.determineUpdatePredicates(milestone);
		predicates.add((library, candidate) -> {
			List<Release> releases = scheduledReleases.get(library.getCalendarName());
			boolean match = (releases != null)
					&& releases.stream().anyMatch((release) -> candidate.isSnapshotFor(release.getVersion()));
			if (logger.isInfoEnabled() && !match) {
				logger.info('Ignoring {}. No release of {} scheduled before {}', candidate, library.getName(),
						milestone.getDueOn());
			}
			return match;
		});
		return predicates;
	}
	private Map<String, List<Release>> getScheduledOpenSourceReleases(Milestone milestone) {
		ReleaseSchedule releaseSchedule = new ReleaseSchedule();
		return releaseSchedule.releasesBetween(OffsetDateTime.now(), milestone.getDueOn());
	}
}
/*
package org.springframework.boot.build.bom.bomr;
/**
final class Upgrade {
	private final Library library;
	private final DependencyVersion version;
	Upgrade(Library library, DependencyVersion version) {
		this.library = library;
		this.version = version;
	}
	Library getLibrary() {
		return this.library;
	}
	DependencyVersion getVersion() {
		return this.version;
	}
}
/*
package org.springframework.boot.build.bom;
/**
public class BomExtension {
	private final Project project;
	private final UpgradeHandler upgradeHandler;
	private final Map<String, DependencyVersion> properties = new LinkedHashMap<>();
	private final Map<String, String> artifactVersionProperties = new HashMap<>();
	private final List<Library> libraries = new ArrayList<>();
	public BomExtension(Project project) {
		this.project = project;
		this.upgradeHandler = project.getObjects().newInstance(UpgradeHandler.class, project);
	}
	public List<Library> getLibraries() {
		return this.libraries;
	}
	public void upgrade(Action<UpgradeHandler> action) {
		action.execute(this.upgradeHandler);
	}
	public Upgrade getUpgrade() {
		GitHubHandler gitHub = this.upgradeHandler.gitHub;
		return new Upgrade(this.upgradeHandler.upgradePolicy,
				new GitHub(gitHub.organization, gitHub.repository, gitHub.issueLabels));
	}
	public void library(String name, Action<LibraryHandler> action) {
		library(name, null, action);
	}
	public void library(String name, String version, Action<LibraryHandler> action) {
		ObjectFactory objects = this.project.getObjects();
		LibraryHandler libraryHandler = objects.newInstance(LibraryHandler.class, this.project,
				(version != null) ? version : '');
		action.execute(libraryHandler);
		LibraryVersion libraryVersion = new LibraryVersion(DependencyVersion.parse(libraryHandler.version));
		VersionAlignment versionAlignment = (libraryHandler.alignWith.version != null)
				? new VersionAlignment(libraryHandler.alignWith.version.from,
						libraryHandler.alignWith.version.managedBy, this.project, this.libraries, libraryHandler.groups)
				: null;
		addLibrary(new Library(name, libraryHandler.calendarName, libraryVersion, libraryHandler.groups,
				libraryHandler.prohibitedVersions, libraryHandler.considerSnapshots, versionAlignment,
				libraryHandler.alignWith.dependencyManagementDeclaredIn, libraryHandler.linkRootName,
				libraryHandler.links));
	}
	public void effectiveBomArtifact() {
		Configuration effectiveBomConfiguration = this.project.getConfigurations().create('effectiveBom');
		this.project.getTasks()
			.matching((task) -> task.getName().equals(DeployedPlugin.GENERATE_POM_TASK_NAME))
			.all((task) -> {
				Sync syncBom = this.project.getTasks().create('syncBom', Sync.class);
				syncBom.dependsOn(task);
				File generatedBomDir = this.project.getLayout()
					.getBuildDirectory()
					.dir('generated/bom')
					.get()
					.getAsFile();
				syncBom.setDestinationDir(generatedBomDir);
				syncBom.from(((GenerateMavenPom) task).getDestination(), (pom) -> pom.rename((name) -> 'pom.xml'));
				try {
					String settingsXmlContent = FileCopyUtils
						.copyToString(new InputStreamReader(
								getClass().getClassLoader().getResourceAsStream('effective-bom-settings.xml'),
								StandardCharsets.UTF_8))
						.replace('localRepositoryPath',
								this.project.getLayout()
									.getBuildDirectory()
									.dir('local-m2-repository')
									.get()
									.getAsFile()
									.getAbsolutePath());
					syncBom.from(this.project.getResources().getText().fromString(settingsXmlContent),
							(settingsXml) -> settingsXml.rename((name) -> 'settings.xml'));
				}
				catch (IOException ex) {
					throw new GradleException('Failed to prepare settings.xml', ex);
				}
				MavenExec generateEffectiveBom = this.project.getTasks()
					.create('generateEffectiveBom', MavenExec.class);
				generateEffectiveBom.getProjectDir().set(generatedBomDir);
				File effectiveBom = this.project.getLayout()
					.getBuildDirectory()
					.file('generated/effective-bom/' + this.project.getName() + '-effective-bom.xml')
					.get()
					.getAsFile();
				generateEffectiveBom.args('--settings', 'settings.xml', 'help:effective-pom',
						'-Doutput=' + effectiveBom);
				generateEffectiveBom.dependsOn(syncBom);
				generateEffectiveBom.getOutputs().file(effectiveBom);
				generateEffectiveBom.doLast(new StripUnrepeatableOutputAction(effectiveBom));
				this.project.getArtifacts()
					.add(effectiveBomConfiguration.getName(), effectiveBom,
							(artifact) -> artifact.builtBy(generateEffectiveBom));
			});
	}
	private String createDependencyNotation(String groupId, String artifactId, DependencyVersion version) {
		return groupId + ':' + artifactId + ':' + version;
	}
	Map<String, DependencyVersion> getProperties() {
		return this.properties;
	}
	String getArtifactVersionProperty(String groupId, String artifactId, String classifier) {
		String coordinates = groupId + ':' + artifactId + ':' + classifier;
		return this.artifactVersionProperties.get(coordinates);
	}
	private void putArtifactVersionProperty(String groupId, String artifactId, String versionProperty) {
		putArtifactVersionProperty(groupId, artifactId, null, versionProperty);
	}
	private void putArtifactVersionProperty(String groupId, String artifactId, String classifier,
			String versionProperty) {
		String coordinates = groupId + ':' + artifactId + ':' + ((classifier != null) ? classifier : '');
		String existing = this.artifactVersionProperties.putIfAbsent(coordinates, versionProperty);
		if (existing != null) {
			throw new InvalidUserDataException('Cannot put version property for "' + coordinates
					+ '". Version property "' + existing + '" has already been stored.');
		}
	}
	private void addLibrary(Library library) {
		DependencyHandler dependencies = this.project.getDependencies();
		this.libraries.add(library);
		String versionProperty = library.getVersionProperty();
		if (versionProperty != null) {
			this.properties.put(versionProperty, library.getVersion().getVersion());
		}
		for (Group group : library.getGroups()) {
			for (Module module : group.getModules()) {
				addModule(library, dependencies, versionProperty, group, module);
			}
			for (String bomImport : group.getBoms()) {
				addBomImport(library, dependencies, versionProperty, group, bomImport);
			}
		}
	}
	private void addModule(Library library, DependencyHandler dependencies, String versionProperty, Group group,
			Module module) {
		putArtifactVersionProperty(group.getId(), module.getName(), module.getClassifier(), versionProperty);
		String constraint = createDependencyNotation(group.getId(), module.getName(),
				library.getVersion().getVersion());
		dependencies.getConstraints().add(JavaPlatformPlugin.API_CONFIGURATION_NAME, constraint);
	}
	private void addBomImport(Library library, DependencyHandler dependencies, String versionProperty, Group group,
			String bomImport) {
		putArtifactVersionProperty(group.getId(), bomImport, versionProperty);
		String bomDependency = createDependencyNotation(group.getId(), bomImport, library.getVersion().getVersion());
		dependencies.add(JavaPlatformPlugin.API_CONFIGURATION_NAME, dependencies.platform(bomDependency));
		dependencies.add(BomPlugin.API_ENFORCED_CONFIGURATION_NAME, dependencies.enforcedPlatform(bomDependency));
	}
	public static class LibraryHandler {
		private final List<Group> groups = new ArrayList<>();
		private final List<ProhibitedVersion> prohibitedVersions = new ArrayList<>();
		private final AlignWithHandler alignWith;
		private boolean considerSnapshots = false;
		private String version;
		private String calendarName;
		private String linkRootName;
		private final Map<String, Function<LibraryVersion, String>> links = new HashMap<>();
		@Inject
		public LibraryHandler(Project project, String version) {
			this.version = version;
			this.alignWith = project.getObjects().newInstance(AlignWithHandler.class);
		}
		public void version(String version) {
			this.version = version;
		}
		public void considerSnapshots() {
			this.considerSnapshots = true;
		}
		public void setCalendarName(String calendarName) {
			this.calendarName = calendarName;
		}
		public void group(String id, Action<GroupHandler> action) {
			GroupHandler groupHandler = new GroupHandler(id);
			action.execute(groupHandler);
			this.groups
				.add(new Group(groupHandler.id, groupHandler.modules, groupHandler.plugins, groupHandler.imports));
		}
		public void prohibit(Action<ProhibitedHandler> action) {
			ProhibitedHandler handler = new ProhibitedHandler();
			action.execute(handler);
			this.prohibitedVersions.add(new ProhibitedVersion(handler.versionRange, handler.startsWith,
					handler.endsWith, handler.contains, handler.reason));
		}
		public void alignWith(Action<AlignWithHandler> action) {
			action.execute(this.alignWith);
		}
		public void links(Action<LinksHandler> action) {
			links(null, action);
		}
		public void links(String linkRootName, Action<LinksHandler> action) {
			LinksHandler handler = new LinksHandler();
			action.execute(handler);
			this.linkRootName = linkRootName;
			this.links.putAll(handler.links);
		}
		public static class ProhibitedHandler {
			private String reason;
			private final List<String> startsWith = new ArrayList<>();
			private final List<String> endsWith = new ArrayList<>();
			private final List<String> contains = new ArrayList<>();
			private VersionRange versionRange;
			public void versionRange(String versionRange) {
				try {
					this.versionRange = VersionRange.createFromVersionSpec(versionRange);
				}
				catch (InvalidVersionSpecificationException ex) {
					throw new InvalidUserCodeException('Invalid version range', ex);
				}
			}
			public void startsWith(String startsWith) {
				this.startsWith.add(startsWith);
			}
			public void startsWith(Collection<String> startsWith) {
				this.startsWith.addAll(startsWith);
			}
			public void endsWith(String endsWith) {
				this.endsWith.add(endsWith);
			}
			public void endsWith(Collection<String> endsWith) {
				this.endsWith.addAll(endsWith);
			}
			public void contains(String contains) {
				this.contains.add(contains);
			}
			public void contains(List<String> contains) {
				this.contains.addAll(contains);
			}
			public void because(String because) {
				this.reason = because;
			}
		}
		public class GroupHandler extends GroovyObjectSupport {
			private final String id;
			private List<Module> modules = new ArrayList<>();
			private List<String> imports = new ArrayList<>();
			private List<String> plugins = new ArrayList<>();
			public GroupHandler(String id) {
				this.id = id;
			}
			public void setModules(List<Object> modules) {
				this.modules = modules.stream()
					.map((input) -> (input instanceof Module module) ? module : new Module((String) input))
					.toList();
			}
			public void setImports(List<String> imports) {
				this.imports = imports;
			}
			public void setPlugins(List<String> plugins) {
				this.plugins = plugins;
			}
			public Object methodMissing(String name, Object args) {
				if (args instanceof Object[] argsArray && argsArray.length == 1) {
					if (argsArray[0] instanceof Closure<?> closure) {
						ModuleHandler moduleHandler = new ModuleHandler();
						closure.setResolveStrategy(Closure.DELEGATE_FIRST);
						closure.setDelegate(moduleHandler);
						closure.call(moduleHandler);
						return new Module(name, moduleHandler.type, moduleHandler.classifier, moduleHandler.exclusions);
					}
				}
				throw new InvalidUserDataException('Invalid configuration for module "' + name + '"');
			}
			public class ModuleHandler {
				private final List<Exclusion> exclusions = new ArrayList<>();
				private String type;
				private String classifier;
				public void exclude(Map<String, String> exclusion) {
					this.exclusions.add(new Exclusion(exclusion.get('group'), exclusion.get('module')));
				}
				public void setType(String type) {
					this.type = type;
				}
				public void setClassifier(String classifier) {
					this.classifier = classifier;
				}
			}
		}
		public static class AlignWithHandler {
			private VersionHandler version;
			private String dependencyManagementDeclaredIn;
			public void version(Action<VersionHandler> action) {
				this.version = new VersionHandler();
				action.execute(this.version);
			}
			public void dependencyManagementDeclaredIn(String bomCoordinates) {
				this.dependencyManagementDeclaredIn = bomCoordinates;
			}
			public static class VersionHandler {
				private String from;
				private String managedBy;
				public void from(String from) {
					this.from = from;
				}
				public void managedBy(String managedBy) {
					this.managedBy = managedBy;
				}
			}
		}
	}
	public static class LinksHandler {
		private final Map<String, Function<LibraryVersion, String>> links = new HashMap<>();
		public void site(String linkTemplate) {
			site(asFactory(linkTemplate));
		}
		public void site(Function<LibraryVersion, String> linkFactory) {
			add('site', linkFactory);
		}
		public void github(String linkTemplate) {
			github(asFactory(linkTemplate));
		}
		public void github(Function<LibraryVersion, String> linkFactory) {
			add('github', linkFactory);
		}
		public void docs(String linkTemplate) {
			docs(asFactory(linkTemplate));
		}
		public void docs(Function<LibraryVersion, String> linkFactory) {
			add('docs', linkFactory);
		}
		public void javadoc(String linkTemplate) {
			javadoc(asFactory(linkTemplate));
		}
		public void javadoc(Function<LibraryVersion, String> linkFactory) {
			add('javadoc', linkFactory);
		}
		public void releaseNotes(String linkTemplate) {
			releaseNotes(asFactory(linkTemplate));
		}
		public void releaseNotes(Function<LibraryVersion, String> linkFactory) {
			add('releaseNotes', linkFactory);
		}
		public void add(String name, String linkTemplate) {
			add(name, asFactory(linkTemplate));
		}
		public void add(String name, Function<LibraryVersion, String> linkFactory) {
			this.links.put(name, linkFactory);
		}
		private Function<LibraryVersion, String> asFactory(String linkTemplate) {
			return (version) -> {
				PlaceholderResolver resolver = (name) -> 'version'.equals(name) ? version.toString() : null;
				return new PropertyPlaceholderHelper('{', '}').replacePlaceholders(linkTemplate, resolver);
			};
		}
	}
	public static class UpgradeHandler {
		private UpgradePolicy upgradePolicy;
		private final GitHubHandler gitHub;
		@Inject
		public UpgradeHandler(Project project) {
			this.gitHub = new GitHubHandler(project);
		}
		public void setPolicy(UpgradePolicy upgradePolicy) {
			this.upgradePolicy = upgradePolicy;
		}
		public void gitHub(Action<GitHubHandler> action) {
			action.execute(this.gitHub);
		}
	}
	public static final class Upgrade {
		private final UpgradePolicy upgradePolicy;
		private final GitHub gitHub;
		private Upgrade(UpgradePolicy upgradePolicy, GitHub gitHub) {
			this.upgradePolicy = upgradePolicy;
			this.gitHub = gitHub;
		}
		public UpgradePolicy getPolicy() {
			return this.upgradePolicy;
		}
		public GitHub getGitHub() {
			return this.gitHub;
		}
	}
	public static class GitHubHandler {
		private String organization;
		private String repository;
		private List<String> issueLabels;
		public GitHubHandler(Project project) {
			BuildProperties buildProperties = BuildProperties.get(project);
			this.organization = buildProperties.gitHub().organization();
			this.repository = buildProperties.gitHub().repository();
		}
		public void setOrganization(String organization) {
			this.organization = organization;
		}
		public void setRepository(String repository) {
			this.repository = repository;
		}
		public void setIssueLabels(List<String> issueLabels) {
			this.issueLabels = issueLabels;
		}
	}
	public static final class GitHub {
		private String organization;
		private String repository;
		private final List<String> issueLabels;
		private GitHub(String organization, String repository, List<String> issueLabels) {
			this.organization = organization;
			this.repository = repository;
			this.issueLabels = issueLabels;
		}
		public String getOrganization() {
			return this.organization;
		}
		public String getRepository() {
			return this.repository;
		}
		public List<String> getIssueLabels() {
			return this.issueLabels;
		}
	}
	private static final class StripUnrepeatableOutputAction implements Action<Task> {
		private final File effectiveBom;
		private StripUnrepeatableOutputAction(File xmlFile) {
			this.effectiveBom = xmlFile;
		}
		@Override
		public void execute(Task task) {
			try {
				Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(this.effectiveBom);
				XPath xpath = XPathFactory.newInstance().newXPath();
				NodeList comments = (NodeList) xpath.evaluate('//comment()', document, XPathConstants.NODESET);
				for (int i = 0; i < comments.getLength(); i++) {
					org.w3c.dom.Node comment = comments.item(i);
					comment.getParentNode().removeChild(comment);
				}
				org.w3c.dom.Node build = (org.w3c.dom.Node) xpath.evaluate('/project/build', document,
						XPathConstants.NODE);
				build.getParentNode().removeChild(build);
				org.w3c.dom.Node reporting = (org.w3c.dom.Node) xpath.evaluate('/project/reporting', document,
						XPathConstants.NODE);
				reporting.getParentNode().removeChild(reporting);
				TransformerFactory.newInstance()
					.newTransformer()
					.transform(new DOMSource(document), new StreamResult(this.effectiveBom));
			}
			catch (Exception ex) {
				throw new TaskExecutionException(task, ex);
			}
		}
	}
}
/*
package org.springframework.boot.build.bom;
/**
public abstract class CheckBom extends DefaultTask {
	private final BomExtension bom;
	@Inject
	public CheckBom(BomExtension bom) {
		this.bom = bom;
	}
	@TaskAction
	void checkBom() {
		List<String> errors = new ArrayList<>();
		for (Library library : this.bom.getLibraries()) {
			checkLibrary(library, errors);
		}
		if (!errors.isEmpty()) {
			System.out.println();
			errors.forEach(System.out::println);
			System.out.println();
			throw new GradleException('Bom check failed. See previous output for details.');
		}
	}
	private void checkLibrary(Library library, List<String> errors) {
		List<String> libraryErrors = new ArrayList<>();
		checkExclusions(library, libraryErrors);
		checkProhibitedVersions(library, libraryErrors);
		checkVersionAlignment(library, libraryErrors);
		checkDependencyManagementAlignment(library, libraryErrors);
		if (!libraryErrors.isEmpty()) {
			errors.add(library.getName());
			for (String libraryError : libraryErrors) {
				errors.add('    - ' + libraryError);
			}
		}
	}
	private void checkExclusions(Library library, List<String> errors) {
		for (Group group : library.getGroups()) {
			for (Module module : group.getModules()) {
				if (!module.getExclusions().isEmpty()) {
					checkExclusions(group.getId(), module, library.getVersion().getVersion(), errors);
				}
			}
		}
	}
	private void checkExclusions(String groupId, Module module, DependencyVersion version, List<String> errors) {
		Set<String> resolved = getProject().getConfigurations()
			.detachedConfiguration(
					getProject().getDependencies().create(groupId + ':' + module.getName() + ':' + version))
			.getResolvedConfiguration()
			.getResolvedArtifacts()
			.stream()
			.map((artifact) -> artifact.getModuleVersion().getId())
			.map((id) -> id.getGroup() + ':' + id.getModule().getName())
			.collect(Collectors.toSet());
		Set<String> exclusions = module.getExclusions()
			.stream()
			.map((exclusion) -> exclusion.getGroupId() + ':' + exclusion.getArtifactId())
			.collect(Collectors.toSet());
		Set<String> unused = new TreeSet<>();
		for (String exclusion : exclusions) {
			if (!resolved.contains(exclusion)) {
				if (exclusion.endsWith(':*')) {
					String group = exclusion.substring(0, exclusion.indexOf(":") + 1);
					if (resolved.stream().noneMatch((candidate) -> candidate.startsWith(group))) {
						unused.add(exclusion);
					}
				}
				else {
					unused.add(exclusion);
				}
			}
		}
		exclusions.removeAll(resolved);
		if (!unused.isEmpty()) {
			errors.add('Unnecessary exclusions on ' + groupId + ':' + module.getName() + ': ' + exclusions);
		}
	}
	private void checkProhibitedVersions(Library library, List<String> errors) {
		ArtifactVersion currentVersion = new DefaultArtifactVersion(library.getVersion().getVersion().toString());
		for (ProhibitedVersion prohibited : library.getProhibitedVersions()) {
			if (prohibited.isProhibited(library.getVersion().getVersion().toString())) {
				errors.add('Current version ' + currentVersion + ' is prohibited');
			}
			else {
				VersionRange versionRange = prohibited.getRange();
				if (versionRange != null) {
					for (Restriction restriction : versionRange.getRestrictions()) {
						ArtifactVersion upperBound = restriction.getUpperBound();
						if (upperBound == null) {
							return;
						}
						int comparison = currentVersion.compareTo(upperBound);
						if ((restriction.isUpperBoundInclusive() && comparison <= 0)
								|| ((!restriction.isUpperBoundInclusive()) && comparison < 0)) {
							return;
						}
					}
					errors.add('Version range ' + versionRange + ' is ineffective as the current version, '
							+ currentVersion + ', is greater than its upper bound');
				}
			}
		}
	}
	private void checkVersionAlignment(Library library, List<String> errors) {
		VersionAlignment versionAlignment = library.getVersionAlignment();
		if (versionAlignment == null) {
			return;
		}
		Set<String> alignedVersions = versionAlignment.resolve();
		if (alignedVersions.size() == 1) {
			String alignedVersion = alignedVersions.iterator().next();
			if (!alignedVersion.equals(library.getVersion().getVersion().toString())) {
				errors.add('Version ' + library.getVersion().getVersion() + ' is misaligned. It should be '
						+ alignedVersion + '.');
			}
		}
		else {
			if (alignedVersions.isEmpty()) {
				errors.add('Version alignment requires a single version but none were found.');
			}
			else {
				errors.add('Version alignment requires a single version but ' + alignedVersions.size() + ' were found: '
						+ alignedVersions + '.');
			}
		}
	}
	private void checkDependencyManagementAlignment(Library library, List<String> errors) {
		String alignsWithBom = library.getAlignsWithBom();
		if (alignsWithBom == null) {
			return;
		}
		File bom = resolveBom(library, alignsWithBom);
		ManagedDependencies managedByBom = ManagedDependencies.ofBom(bom);
		ManagedDependencies managedByLibrary = ManagedDependencies.ofLibrary(library);
		Difference diff = managedByBom.diff(managedByLibrary);
		if (!diff.isEmpty()) {
			String error = 'Dependency management does not align with ' + library.getAlignsWithBom() + ':';
			if (!diff.missing().isEmpty()) {
				error = error + '%n        - Missing:%n            %s'
					.formatted(String.join('\n            ', diff.missing()));
			}
			if (!diff.unexpected().isEmpty()) {
				error = error + '%n        - Unexpected:%n            %s'
					.formatted(String.join('\n            ', diff.unexpected()));
			}
			errors.add(error);
		}
	}
	private File resolveBom(Library library, String alignsWithBom) {
		String coordinates = alignsWithBom + ':' + library.getVersion().getVersion() + '@pom';
		Set<File> files = getProject().getConfigurations()
			.detachedConfiguration(getProject().getDependencies().create(coordinates))
			.getResolvedConfiguration()
			.getFiles();
		if (files.size() != 1) {
			throw new IllegalStateException(
					'Expected a single file but "' + coordinates + '" resolved to ' + files.size());
		}
		return files.iterator().next();
	}
}
/*
package org.springframework.boot.build.bom;
/**
public enum UpgradePolicy implements BiPredicate<DependencyVersion, DependencyVersion> {
	/**
	 * Any version.
	 */
	ANY((candidate, current) -> true),
	/**
	 * Minor versions of the current major version.
	 */
	SAME_MAJOR_VERSION(DependencyVersion::isSameMajor),
	/**
	 * Patch versions of the current minor version.
	 */
	SAME_MINOR_VERSION(DependencyVersion::isSameMinor);
	private final BiPredicate<DependencyVersion, DependencyVersion> delegate;
	UpgradePolicy(BiPredicate<DependencyVersion, DependencyVersion> delegate) {
		this.delegate = delegate;
	}
	@Override
	public boolean test(DependencyVersion candidate, DependencyVersion current) {
		return this.delegate.test(candidate, current);
	}
}
/*
package org.springframework.boot.build.bom;
/**
class ManagedDependencies {
	private final Set<String> ids;
	ManagedDependencies(Set<String> ids) {
		this.ids = ids;
	}
	Set<String> getIds() {
		return this.ids;
	}
	Difference diff(ManagedDependencies other) {
		Set<String> missing = new HashSet<>(this.ids);
		missing.removeAll(other.ids);
		Set<String> unexpected = new HashSet<>(other.ids);
		unexpected.removeAll(this.ids);
		return new Difference(missing, unexpected);
	}
	static ManagedDependencies ofBom(File bom) {
		try {
			Document bomDocument = DocumentBuilderFactory.newInstance()
				.newDocumentBuilder()
				.parse(new InputSource(new FileReader(bom)));
			XPath xpath = XPathFactory.newInstance().newXPath();
			NodeList dependencyNodes = (NodeList) xpath
				.evaluate('/project/dependencyManagement/dependencies/dependency', bomDocument, XPathConstants.NODESET);
			NodeList propertyNodes = (NodeList) xpath.evaluate('/project/properties/*', bomDocument,
					XPathConstants.NODESET);
			Map<String, String> properties = new HashMap<>();
			for (int i = 0; i < propertyNodes.getLength(); i++) {
				Node property = propertyNodes.item(i);
				String name = property.getNodeName();
				String value = property.getTextContent();
				properties.put('${%s}'.formatted(name), value);
			}
			Set<String> managedDependencies = new HashSet<>();
			for (int i = 0; i < dependencyNodes.getLength(); i++) {
				Node dependency = dependencyNodes.item(i);
				String groupId = (String) xpath.evaluate('groupId/text()', dependency, XPathConstants.STRING);
				String artifactId = (String) xpath.evaluate('artifactId/text()', dependency, XPathConstants.STRING);
				String version = (String) xpath.evaluate('version/text()', dependency, XPathConstants.STRING);
				String classifier = (String) xpath.evaluate('classifier/text()', dependency, XPathConstants.STRING);
				if (version.startsWith('${') && version.endsWith('}')) {
					version = properties.get(version);
				}
				managedDependencies.add(asId(groupId, artifactId, version, classifier));
			}
			return new ManagedDependencies(managedDependencies);
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	static String asId(String groupId, String artifactId, String version, String classifier) {
		String id = groupId + ':' + artifactId + ':' + version;
		if (classifier != null && !classifier.isEmpty()) {
			id = id + ':' + classifier;
		}
		return id;
	}
	static ManagedDependencies ofLibrary(Library library) {
		Set<String> managedByLibrary = new HashSet<>();
		for (Group group : library.getGroups()) {
			for (Module module : group.getModules()) {
				managedByLibrary.add(asId(group.getId(), module.getName(), library.getVersion().getVersion().toString(),
						module.getClassifier()));
			}
		}
		return new ManagedDependencies(managedByLibrary);
	}
	record Difference(Set<String> missing, Set<String> unexpected) {
		boolean isEmpty() {
			return this.missing.isEmpty() && this.unexpected.isEmpty();
		}
	}
}
/*
package org.springframework.boot.build.bom;
/**
public class BomPlugin implements Plugin<Project> {
	static final String API_ENFORCED_CONFIGURATION_NAME = 'apiEnforced';
	@Override
	public void apply(Project project) {
		PluginContainer plugins = project.getPlugins();
		plugins.apply(DeployedPlugin.class);
		plugins.apply(MavenRepositoryPlugin.class);
		plugins.apply(JavaPlatformPlugin.class);
		JavaPlatformExtension javaPlatform = project.getExtensions().getByType(JavaPlatformExtension.class);
		javaPlatform.allowDependencies();
		createApiEnforcedConfiguration(project);
		BomExtension bom = project.getExtensions().create('bom', BomExtension.class, project);
		CheckBom checkBom = project.getTasks().create('bomrCheck', CheckBom.class, bom);
		project.getTasks().named('check').configure((check) -> check.dependsOn(checkBom));
		project.getTasks().create('bomrUpgrade', UpgradeBom.class, bom);
		project.getTasks().create('moveToSnapshots', MoveToSnapshots.class, bom);
		project.getTasks().register('checkLinks', CheckLinks.class, bom);
		new PublishingCustomizer(project, bom).customize();
	}
	private void createApiEnforcedConfiguration(Project project) {
		Configuration apiEnforced = project.getConfigurations()
			.create(API_ENFORCED_CONFIGURATION_NAME, (configuration) -> {
				configuration.setCanBeConsumed(false);
				configuration.setCanBeResolved(false);
				configuration.setVisible(false);
			});
		project.getConfigurations()
			.getByName(JavaPlatformPlugin.ENFORCED_API_ELEMENTS_CONFIGURATION_NAME)
			.extendsFrom(apiEnforced);
		project.getConfigurations()
			.getByName(JavaPlatformPlugin.ENFORCED_RUNTIME_ELEMENTS_CONFIGURATION_NAME)
			.extendsFrom(apiEnforced);
	}
	private static final class PublishingCustomizer {
		private final Project project;
		private final BomExtension bom;
		private PublishingCustomizer(Project project, BomExtension bom) {
			this.project = project;
			this.bom = bom;
		}
		private void customize() {
			PublishingExtension publishing = this.project.getExtensions().getByType(PublishingExtension.class);
			publishing.getPublications().withType(MavenPublication.class).all(this::configurePublication);
		}
		private void configurePublication(MavenPublication publication) {
			publication.pom(this::customizePom);
		}
		@SuppressWarnings('unchecked')
		private void customizePom(MavenPom pom) {
			pom.withXml((xml) -> {
				Node projectNode = xml.asNode();
				Node properties = new Node(null, 'properties');
				this.bom.getProperties().forEach(properties::appendNode);
				Node dependencyManagement = findChild(projectNode, 'dependencyManagement');
				if (dependencyManagement != null) {
					addPropertiesBeforeDependencyManagement(projectNode, properties);
					addClassifiedManagedDependencies(dependencyManagement);
					replaceVersionsWithVersionPropertyReferences(dependencyManagement);
					addExclusionsToManagedDependencies(dependencyManagement);
					addTypesToManagedDependencies(dependencyManagement);
				}
				else {
					projectNode.children().add(properties);
				}
				addPluginManagement(projectNode);
			});
		}
		@SuppressWarnings('unchecked')
		private void addPropertiesBeforeDependencyManagement(Node projectNode, Node properties) {
			for (int i = 0; i < projectNode.children().size(); i++) {
				if (isNodeWithName(projectNode.children().get(i), 'dependencyManagement')) {
					projectNode.children().add(i, properties);
					break;
				}
			}
		}
		private void replaceVersionsWithVersionPropertyReferences(Node dependencyManagement) {
			Node dependencies = findChild(dependencyManagement, 'dependencies');
			if (dependencies != null) {
				for (Node dependency : findChildren(dependencies, 'dependency')) {
					String groupId = findChild(dependency, 'groupId').text();
					String artifactId = findChild(dependency, 'artifactId').text();
					Node classifierNode = findChild(dependency, 'classifier');
					String classifier = (classifierNode != null) ? classifierNode.text() : '';
					String versionProperty = this.bom.getArtifactVersionProperty(groupId, artifactId, classifier);
					if (versionProperty != null) {
						findChild(dependency, 'version').setValue('${' + versionProperty + '}');
					}
				}
			}
		}
		private void addExclusionsToManagedDependencies(Node dependencyManagement) {
			Node dependencies = findChild(dependencyManagement, 'dependencies');
			if (dependencies != null) {
				for (Node dependency : findChildren(dependencies, 'dependency')) {
					String groupId = findChild(dependency, 'groupId').text();
					String artifactId = findChild(dependency, 'artifactId').text();
					this.bom.getLibraries()
						.stream()
						.flatMap((library) -> library.getGroups().stream())
						.filter((group) -> group.getId().equals(groupId))
						.flatMap((group) -> group.getModules().stream())
						.filter((module) -> module.getName().equals(artifactId))
						.flatMap((module) -> module.getExclusions().stream())
						.forEach((exclusion) -> {
							Node exclusions = findOrCreateNode(dependency, 'exclusions');
							Node node = new Node(exclusions, 'exclusion');
							node.appendNode('groupId', exclusion.getGroupId());
							node.appendNode('artifactId', exclusion.getArtifactId());
						});
				}
			}
		}
		private void addTypesToManagedDependencies(Node dependencyManagement) {
			Node dependencies = findChild(dependencyManagement, 'dependencies');
			if (dependencies != null) {
				for (Node dependency : findChildren(dependencies, 'dependency')) {
					String groupId = findChild(dependency, 'groupId').text();
					String artifactId = findChild(dependency, 'artifactId').text();
					Set<String> types = this.bom.getLibraries()
						.stream()
						.flatMap((library) -> library.getGroups().stream())
						.filter((group) -> group.getId().equals(groupId))
						.flatMap((group) -> group.getModules().stream())
						.filter((module) -> module.getName().equals(artifactId))
						.map(Module::getType)
						.filter(Objects::nonNull)
						.collect(Collectors.toSet());
					if (types.size() > 1) {
						throw new IllegalStateException(
								'Multiple types for ' + groupId + ':' + artifactId + ': ' + types);
					}
					if (types.size() == 1) {
						String type = types.iterator().next();
						dependency.appendNode('type', type);
					}
				}
			}
		}
		@SuppressWarnings('unchecked')
		private void addClassifiedManagedDependencies(Node dependencyManagement) {
			Node dependencies = findChild(dependencyManagement, 'dependencies');
			if (dependencies != null) {
				for (Node dependency : findChildren(dependencies, 'dependency')) {
					String groupId = findChild(dependency, 'groupId').text();
					String artifactId = findChild(dependency, 'artifactId').text();
					String version = findChild(dependency, 'version').text();
					Set<String> classifiers = this.bom.getLibraries()
						.stream()
						.flatMap((library) -> library.getGroups().stream())
						.filter((group) -> group.getId().equals(groupId))
						.flatMap((group) -> group.getModules().stream())
						.filter((module) -> module.getName().equals(artifactId))
						.map(Module::getClassifier)
						.filter(Objects::nonNull)
						.collect(Collectors.toSet());
					Node target = dependency;
					for (String classifier : classifiers) {
						if (!classifier.isEmpty()) {
							if (target == null) {
								target = new Node(null, 'dependency');
								target.appendNode('groupId', groupId);
								target.appendNode('artifactId', artifactId);
								target.appendNode('version', version);
								int index = dependency.parent().children().indexOf(dependency);
								dependency.parent().children().add(index + 1, target);
							}
							target.appendNode('classifier', classifier);
						}
						target = null;
					}
				}
			}
		}
		private void addPluginManagement(Node projectNode) {
			for (Library library : this.bom.getLibraries()) {
				for (Group group : library.getGroups()) {
					Node plugins = findOrCreateNode(projectNode, 'build', 'pluginManagement', 'plugins');
					for (String pluginName : group.getPlugins()) {
						Node plugin = new Node(plugins, 'plugin');
						plugin.appendNode('groupId', group.getId());
						plugin.appendNode('artifactId', pluginName);
						String versionProperty = library.getVersionProperty();
						String value = (versionProperty != null) ? '${' + versionProperty + '}'
								: library.getVersion().getVersion().toString();
						plugin.appendNode('version', value);
					}
				}
			}
		}
		private Node findOrCreateNode(Node parent, String... path) {
			Node current = parent;
			for (String nodeName : path) {
				Node child = findChild(current, nodeName);
				if (child == null) {
					child = new Node(current, nodeName);
				}
				current = child;
			}
			return current;
		}
		private Node findChild(Node parent, String name) {
			for (Object child : parent.children()) {
				if (child instanceof Node node) {
					if ((node.name() instanceof QName qname) && name.equals(qname.getLocalPart())) {
						return node;
					}
					if (name.equals(node.name())) {
						return node;
					}
				}
			}
			return null;
		}
		@SuppressWarnings('unchecked')
		private List<Node> findChildren(Node parent, String name) {
			return parent.children().stream().filter((child) -> isNodeWithName(child, name)).toList();
		}
		private boolean isNodeWithName(Object candidate, String name) {
			if (candidate instanceof Node node) {
				if ((node.name() instanceof QName qname) && name.equals(qname.getLocalPart())) {
					return true;
				}
				return name.equals(node.name());
			}
			return false;
		}
	}
}
/*
package org.springframework.boot.build.bom;
/**
public abstract class CheckLinks extends DefaultTask {
	private final BomExtension bom;
	@Inject
	public CheckLinks(BomExtension bom) {
		this.bom = bom;
	}
	@TaskAction
	void releaseNotes() {
		RequestConfig config = RequestConfig.custom().setCookieSpec(CookieSpecs.IGNORE_COOKIES).build();
		CloseableHttpClient httpClient = HttpClients.custom().setDefaultRequestConfig(config).build();
		HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);
		RestTemplate restTemplate = new RestTemplate(requestFactory);
		restTemplate.setErrorHandler(new IgnoringErrorHandler());
		for (Library library : this.bom.getLibraries()) {
			library.getLinks().forEach((name, link) -> {
				URI uri;
				try {
					uri = new URI(link);
					ResponseEntity<String> response = restTemplate.exchange(uri, HttpMethod.HEAD, null, String.class);
					System.out.printf('[%3d] %s - %s (%s)%n', response.getStatusCode().value(), library.getName(), name,
							uri);
				}
				catch (URISyntaxException ex) {
					throw new RuntimeException(ex);
				}
			});
		}
	}
	static class IgnoringErrorHandler extends DefaultResponseErrorHandler {
		@Override
		public void handleError(ClientHttpResponse response) throws IOException {
		}
	}
}
/*
package org.springframework.boot.build.bom;
/**
public class Library {
	private final String name;
	private final String calendarName;
	private final LibraryVersion version;
	private final List<Group> groups;
	private final String versionProperty;
	private final List<ProhibitedVersion> prohibitedVersions;
	private final boolean considerSnapshots;
	private final VersionAlignment versionAlignment;
	private final String alignsWithBom;
	private final String linkRootName;
	private final Map<String, Function<LibraryVersion, String>> links;
	/**
	 * Create a new {@code Library} with the given {@code name}, {@code version}, and
	 * {@code groups}.
	 * @param name name of the library
	 * @param calendarName name of the library as it appears in the Spring Calendar. May
	 * be {@code null} in which case the {@code name} is used.
	 * @param version version of the library
	 * @param groups groups in the library
	 * @param prohibitedVersions version of the library that are prohibited
	 * @param considerSnapshots whether to consider snapshots
	 * @param versionAlignment version alignment, if any, for the library
	 * @param alignsWithBom the coordinates of the bom, if any, that this library should
	 * align with
	 * @param linkRootName the root name to use when generating link variable or
	 * {@code null} to generate one based on the library {@code name}
	 * @param links a list of HTTP links relevant to the library
	 */
	public Library(String name, String calendarName, LibraryVersion version, List<Group> groups,
			List<ProhibitedVersion> prohibitedVersions, boolean considerSnapshots, VersionAlignment versionAlignment,
			String alignsWithBom, String linkRootName, Map<String, Function<LibraryVersion, String>> links) {
		this.name = name;
		this.calendarName = (calendarName != null) ? calendarName : name;
		this.version = version;
		this.groups = groups;
		this.versionProperty = 'Spring Boot'.equals(name) ? null
				: name.toLowerCase(Locale.ENGLISH).replace(" ", "-") + '.version';
		this.prohibitedVersions = prohibitedVersions;
		this.considerSnapshots = considerSnapshots;
		this.versionAlignment = versionAlignment;
		this.alignsWithBom = alignsWithBom;
		this.linkRootName = (linkRootName != null) ? linkRootName : generateLinkRootName(name);
		this.links = Collections.unmodifiableMap(links);
	}
	private static String generateLinkRootName(String name) {
		return name.replace('-', '').replace(' ', '-').toLowerCase(Locale.ROOT);
	}
	public String getName() {
		return this.name;
	}
	public String getCalendarName() {
		return this.calendarName;
	}
	public LibraryVersion getVersion() {
		return this.version;
	}
	public List<Group> getGroups() {
		return this.groups;
	}
	public String getVersionProperty() {
		return this.versionProperty;
	}
	public List<ProhibitedVersion> getProhibitedVersions() {
		return this.prohibitedVersions;
	}
	public boolean isConsiderSnapshots() {
		return this.considerSnapshots;
	}
	public VersionAlignment getVersionAlignment() {
		return this.versionAlignment;
	}
	public String getLinkRootName() {
		return this.linkRootName;
	}
	public String getAlignsWithBom() {
		return this.alignsWithBom;
	}
	public Map<String, String> getLinks() {
		Map<String, String> links = new TreeMap<>();
		this.links.forEach((name, linkFactory) -> links.put(name, linkFactory.apply(this.version)));
		return Collections.unmodifiableMap(links);
	}
	/**
	 * A version or range of versions that are prohibited from being used in a bom.
	 */
	public static class ProhibitedVersion {
		private final VersionRange range;
		private final List<String> startsWith;
		private final List<String> endsWith;
		private final List<String> contains;
		private final String reason;
		public ProhibitedVersion(VersionRange range, List<String> startsWith, List<String> endsWith,
				List<String> contains, String reason) {
			this.range = range;
			this.startsWith = startsWith;
			this.endsWith = endsWith;
			this.contains = contains;
			this.reason = reason;
		}
		public VersionRange getRange() {
			return this.range;
		}
		public List<String> getStartsWith() {
			return this.startsWith;
		}
		public List<String> getEndsWith() {
			return this.endsWith;
		}
		public List<String> getContains() {
			return this.contains;
		}
		public String getReason() {
			return this.reason;
		}
		public boolean isProhibited(String candidate) {
			boolean result = false;
			result = result
					|| (this.range != null && this.range.containsVersion(new DefaultArtifactVersion(candidate)));
			result = result || this.startsWith.stream().anyMatch(candidate::startsWith);
			result = result || this.endsWith.stream().anyMatch(candidate::endsWith);
			result = result || this.contains.stream().anyMatch(candidate::contains);
			return result;
		}
	}
	public static class LibraryVersion {
		private final DependencyVersion version;
		public LibraryVersion(DependencyVersion version) {
			this.version = version;
		}
		public DependencyVersion getVersion() {
			return this.version;
		}
		public int[] componentInts() {
			return Arrays.stream(parts()).mapToInt(Integer::parseInt).toArray();
		}
		public String major() {
			return parts()[0];
		}
		public String minor() {
			return parts()[1];
		}
		public String patch() {
			return parts()[2];
		}
		@Override
		public String toString() {
			return this.version.toString();
		}
		public String toString(String separator) {
			return this.version.toString().replace('.', separator);
		}
		public String forAntora() {
			String[] parts = parts();
			String result = parts[0] + '.' + parts[1];
			if (toString().endsWith('SNAPSHOT')) {
				result += '-SNAPSHOT';
			}
			return result;
		}
		public String forMajorMinorGeneration() {
			String[] parts = parts();
			String result = parts[0] + '.' + parts[1] + '.x';
			if (toString().endsWith('SNAPSHOT')) {
				result += '-SNAPSHOT';
			}
			return result;
		}
		private String[] parts() {
			return toString().split('[.-]');
		}
	}
	/**
	 * A collection of modules, Maven plugins, and Maven boms with the same group ID.
	 */
	public static class Group {
		private final String id;
		private final List<Module> modules;
		private final List<String> plugins;
		private final List<String> boms;
		public Group(String id, List<Module> modules, List<String> plugins, List<String> boms) {
			this.id = id;
			this.modules = modules;
			this.plugins = plugins;
			this.boms = boms;
		}
		public String getId() {
			return this.id;
		}
		public List<Module> getModules() {
			return this.modules;
		}
		public List<String> getPlugins() {
			return this.plugins;
		}
		public List<String> getBoms() {
			return this.boms;
		}
	}
	/**
	 * A module in a group.
	 */
	public static class Module {
		private final String name;
		private final String type;
		private final String classifier;
		private final List<Exclusion> exclusions;
		public Module(String name) {
			this(name, Collections.emptyList());
		}
		public Module(String name, String type) {
			this(name, type, null, Collections.emptyList());
		}
		public Module(String name, List<Exclusion> exclusions) {
			this(name, null, null, exclusions);
		}
		public Module(String name, String type, String classifier, List<Exclusion> exclusions) {
			this.name = name;
			this.type = type;
			this.classifier = (classifier != null) ? classifier : '';
			this.exclusions = exclusions;
		}
		public String getName() {
			return this.name;
		}
		public String getClassifier() {
			return this.classifier;
		}
		public String getType() {
			return this.type;
		}
		public List<Exclusion> getExclusions() {
			return this.exclusions;
		}
	}
	/**
	 * An exclusion of a dependency identified by its group ID and artifact ID.
	 */
	public static class Exclusion {
		private final String groupId;
		private final String artifactId;
		public Exclusion(String groupId, String artifactId) {
			this.groupId = groupId;
			this.artifactId = artifactId;
		}
		public String getGroupId() {
			return this.groupId;
		}
		public String getArtifactId() {
			return this.artifactId;
		}
	}
	/**
	 * Version alignment for a library.
	 */
	public static class VersionAlignment {
		private final String from;
		private final String managedBy;
		private final Project project;
		private final List<Library> libraries;
		private final List<Group> groups;
		private Set<String> alignedVersions;
		VersionAlignment(String from, String managedBy, Project project, List<Library> libraries, List<Group> groups) {
			this.from = from;
			this.managedBy = managedBy;
			this.project = project;
			this.libraries = libraries;
			this.groups = groups;
		}
		public Set<String> resolve() {
			if (this.alignedVersions != null) {
				return this.alignedVersions;
			}
			Map<String, String> versions = resolveAligningDependencies();
			Set<String> versionsInLibrary = new HashSet<>();
			for (Group group : this.groups) {
				for (Module module : group.getModules()) {
					String version = versions.get(group.getId() + ':' + module.getName());
					if (version != null) {
						versionsInLibrary.add(version);
					}
				}
				for (String plugin : group.getPlugins()) {
					String version = versions.get(group.getId() + ':' + plugin);
					if (version != null) {
						versionsInLibrary.add(version);
					}
				}
			}
			this.alignedVersions = versionsInLibrary;
			return this.alignedVersions;
		}
		private Map<String, String> resolveAligningDependencies() {
			List<Dependency> dependencies = getAligningDependencies();
			Configuration alignmentConfiguration = this.project.getConfigurations()
				.detachedConfiguration(dependencies.toArray(new Dependency[0]));
			Map<String, String> versions = new HashMap<>();
			for (DependencyResult dependency : alignmentConfiguration.getIncoming()
				.getResolutionResult()
				.getAllDependencies()) {
				versions.put(dependency.getFrom().getModuleVersion().getModule().toString(),
						dependency.getFrom().getModuleVersion().getVersion());
			}
			return versions;
		}
		private List<Dependency> getAligningDependencies() {
			if (this.managedBy == null) {
				Library fromLibrary = findFromLibrary();
				return List
					.of(this.project.getDependencies().create(this.from + ':' + fromLibrary.getVersion().getVersion()));
			}
			else {
				Library managingLibrary = findManagingLibrary();
				List<Dependency> boms = getBomDependencies(managingLibrary);
				List<Dependency> dependencies = new ArrayList<>();
				dependencies.addAll(boms);
				dependencies.add(this.project.getDependencies().create(this.from));
				return dependencies;
			}
		}
		private Library findFromLibrary() {
			for (Library library : this.libraries) {
				for (Group group : library.getGroups()) {
					for (Module module : group.getModules()) {
						if (this.from.equals(group.getId() + ':' + module.getName())) {
							return library;
						}
					}
				}
			}
			return null;
		}
		private Library findManagingLibrary() {
			if (this.managedBy == null) {
				return null;
			}
			return this.libraries.stream()
				.filter((candidate) -> this.managedBy.equals(candidate.getName()))
				.findFirst()
				.orElseThrow(() -> new IllegalStateException('Managing library "' + this.managedBy + '" not found.'));
		}
		private List<Dependency> getBomDependencies(Library manager) {
			if (manager == null) {
				return Collections.emptyList();
			}
			return manager.getGroups()
				.stream()
				.flatMap((group) -> group.getBoms()
					.stream()
					.map((bom) -> this.project.getDependencies()
						.platform(group.getId() + ':' + bom + ':' + manager.getVersion().getVersion())))
				.toList();
		}
		String getFrom() {
			return this.from;
		}
		String getManagedBy() {
			return this.managedBy;
		}
		@Override
		public String toString() {
			String result = 'version from dependencies of ' + this.from;
			if (this.managedBy != null) {
				result += ' that is managed by ' + this.managedBy;
			}
			return result;
		}
	}
}
/*
package org.springframework.boot.build;
/**
class EclipseConventions {
	void apply(Project project) {
		project.getPlugins().withType(EclipsePlugin.class, (eclipse) -> {
			EclipseModel eclipseModel = project.getExtensions().getByType(EclipseModel.class);
			eclipseModel.classpath(this::configureClasspath);
		});
	}
	private void configureClasspath(EclipseClasspath classpath) {
		classpath.file(this::configureClasspathFile);
	}
	private void configureClasspathFile(XmlFileContentMerger merger) {
		merger.whenMerged((content) -> {
			if (content instanceof Classpath classpath) {
				classpath.getEntries().removeIf(this::isKotlinPluginContributedBuildDirectory);
			}
		});
	}
	private boolean isKotlinPluginContributedBuildDirectory(ClasspathEntry entry) {
		return (entry instanceof Library library) && isKotlinPluginContributedBuildDirectory(library.getPath())
				&& isTest(library);
	}
	private boolean isKotlinPluginContributedBuildDirectory(String path) {
		return path.contains('/main') && (path.contains('/build/classes/') || path.contains('/build/resources/'));
	}
	private boolean isTest(Library library) {
		Object value = library.getEntryAttributes().get('test');
		return (value instanceof String string && Boolean.parseBoolean(string));
	}
}
/*
package org.springframework.boot.build.test.autoconfigure;
/**
public abstract class TestSliceMetadata extends DefaultTask {
	private FileCollection classpath;
	private FileCollection importsFiles;
	private FileCollection classesDirs;
	public TestSliceMetadata() {
		Configuration testSliceMetadata = getProject().getConfigurations().maybeCreate('testSliceMetadata');
		getProject().afterEvaluate((evaluated) -> evaluated.getArtifacts()
			.add(testSliceMetadata.getName(), getOutputFile(), (artifact) -> artifact.builtBy(this)));
	}
	public void setSourceSet(SourceSet sourceSet) {
		this.classpath = sourceSet.getRuntimeClasspath();
		this.importsFiles = getProject().fileTree(new File(sourceSet.getOutput().getResourcesDir(), 'META-INF/spring'),
				(tree) -> tree.filter((file) -> file.getName().endsWith('.imports')));
		getSpringFactories().set(new File(sourceSet.getOutput().getResourcesDir(), 'META-INF/spring.factories'));
		this.classesDirs = sourceSet.getOutput().getClassesDirs();
	}
	@OutputFile
	public abstract RegularFileProperty getOutputFile();
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	abstract RegularFileProperty getSpringFactories();
	@Classpath
	FileCollection getClasspath() {
		return this.classpath;
	}
	@InputFiles
	@PathSensitive(PathSensitivity.RELATIVE)
	FileCollection getImportFiles() {
		return this.importsFiles;
	}
	@Classpath
	FileCollection getClassesDirs() {
		return this.classesDirs;
	}
	@TaskAction
	void documentTestSlices() throws IOException {
		Properties testSlices = readTestSlices();
		File outputFile = getOutputFile().getAsFile().get();
		outputFile.getParentFile().mkdirs();
		try (FileWriter writer = new FileWriter(outputFile)) {
			testSlices.store(writer, null);
		}
	}
	private Properties readTestSlices() throws IOException {
		Properties testSlices = CollectionFactory.createSortedProperties(true);
		try (URLClassLoader classLoader = new URLClassLoader(
				StreamSupport.stream(this.classpath.spliterator(), false).map(this::toURL).toArray(URL[]::new))) {
			MetadataReaderFactory metadataReaderFactory = new SimpleMetadataReaderFactory(classLoader);
			Properties springFactories = readSpringFactories(getSpringFactories().getAsFile().get());
			readImportsFiles(springFactories, this.importsFiles);
			for (File classesDir : this.classesDirs) {
				addTestSlices(testSlices, classesDir, metadataReaderFactory, springFactories);
			}
		}
		return testSlices;
	}
	/**
	 * Reads the given imports files and puts them in springFactories. The key is the file
	 * name, the value is the file contents, split by line, delimited with a comma. This
	 * is done to mimic the spring.factories structure.
	 * @param springFactories spring.factories parsed as properties
	 * @param importsFiles the imports files to read
	 */
	private void readImportsFiles(Properties springFactories, FileCollection importsFiles) {
		for (File file : importsFiles.getFiles()) {
			try {
				List<String> lines = removeComments(Files.readAllLines(file.toPath()));
				String fileNameWithoutExtension = file.getName()
					.substring(0, file.getName().length() - '.imports'.length());
				springFactories.setProperty(fileNameWithoutExtension,
						StringUtils.collectionToCommaDelimitedString(lines));
			}
			catch (IOException ex) {
				throw new UncheckedIOException('Failed to read file ' + file, ex);
			}
		}
	}
	private List<String> removeComments(List<String> lines) {
		List<String> result = new ArrayList<>();
		for (String line : lines) {
			int commentIndex = line.indexOf("#");
			if (commentIndex > -1) {
				line = line.substring(0, commentIndex);
			}
			line = line.trim();
			if (!line.isEmpty()) {
				result.add(line);
			}
		}
		return result;
	}
	private URL toURL(File file) {
		try {
			return file.toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new RuntimeException(ex);
		}
	}
	private Properties readSpringFactories(File file) throws IOException {
		Properties springFactories = new Properties();
		try (Reader in = new FileReader(file)) {
			springFactories.load(in);
		}
		return springFactories;
	}
	private void addTestSlices(Properties testSlices, File classesDir, MetadataReaderFactory metadataReaderFactory,
			Properties springFactories) throws IOException {
		try (Stream<Path> classes = Files.walk(classesDir.toPath())) {
			classes.filter((path) -> path.toString().endsWith('Test.class'))
				.map((path) -> getMetadataReader(path, metadataReaderFactory))
				.filter((metadataReader) -> metadataReader.getClassMetadata().isAnnotation())
				.forEach((metadataReader) -> addTestSlice(testSlices, springFactories, metadataReader));
		}
	}
	private MetadataReader getMetadataReader(Path path, MetadataReaderFactory metadataReaderFactory) {
		try {
			return metadataReaderFactory.getMetadataReader(new FileSystemResource(path));
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void addTestSlice(Properties testSlices, Properties springFactories, MetadataReader metadataReader) {
		testSlices.setProperty(metadataReader.getClassMetadata().getClassName(),
				StringUtils.collectionToCommaDelimitedString(
						getImportedAutoConfiguration(springFactories, metadataReader.getAnnotationMetadata())));
	}
	private SortedSet<String> getImportedAutoConfiguration(Properties springFactories,
			AnnotationMetadata annotationMetadata) {
		Stream<String> importers = findMetaImporters(annotationMetadata);
		if (annotationMetadata.isAnnotated('org.springframework.boot.autoconfigure.ImportAutoConfiguration')) {
			importers = Stream.concat(importers, Stream.of(annotationMetadata.getClassName()));
		}
		return importers
			.flatMap((importer) -> StringUtils.commaDelimitedListToSet(springFactories.getProperty(importer)).stream())
			.collect(Collectors.toCollection(TreeSet::new));
	}
	private Stream<String> findMetaImporters(AnnotationMetadata annotationMetadata) {
		return annotationMetadata.getAnnotationTypes()
			.stream()
			.filter((annotationType) -> isAutoConfigurationImporter(annotationType, annotationMetadata));
	}
	private boolean isAutoConfigurationImporter(String annotationType, AnnotationMetadata metadata) {
		return metadata.getMetaAnnotationTypes(annotationType)
			.contains('org.springframework.boot.autoconfigure.ImportAutoConfiguration');
	}
}
/*
package org.springframework.boot.build.test.autoconfigure;
/**
public abstract class DocumentTestSlices extends DefaultTask {
	private FileCollection testSlices;
	@InputFiles
	@PathSensitive(PathSensitivity.RELATIVE)
	public FileCollection getTestSlices() {
		return this.testSlices;
	}
	public void setTestSlices(FileCollection testSlices) {
		this.testSlices = testSlices;
	}
	@OutputFile
	public abstract RegularFileProperty getOutputFile();
	@TaskAction
	void documentTestSlices() throws IOException {
		Set<TestSlice> testSlices = readTestSlices();
		writeTable(testSlices);
	}
	@SuppressWarnings('unchecked')
	private Set<TestSlice> readTestSlices() throws IOException {
		Set<TestSlice> testSlices = new TreeSet<>();
		for (File metadataFile : this.testSlices) {
			Properties metadata = new Properties();
			try (Reader reader = new FileReader(metadataFile)) {
				metadata.load(reader);
			}
			for (String name : Collections.list((Enumeration<String>) metadata.propertyNames())) {
				testSlices.add(new TestSlice(name,
						new TreeSet<>(StringUtils.commaDelimitedListToSet(metadata.getProperty(name)))));
			}
		}
		return testSlices;
	}
	private void writeTable(Set<TestSlice> testSlices) throws IOException {
		File outputFile = getOutputFile().getAsFile().get();
		outputFile.getParentFile().mkdirs();
		try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
			writer.println('[cols=\'d,a\']');
			writer.println('|===');
			writer.println('| Test slice | Imported auto-configuration');
			for (TestSlice testSlice : testSlices) {
				writer.println();
				writer.printf('| `@%s`%n', testSlice.className);
				writer.println('| ');
				for (String importedAutoConfiguration : testSlice.importedAutoConfigurations) {
					writer.printf('`%s`%n', importedAutoConfiguration);
				}
			}
			writer.println('|===');
		}
	}
	private static final class TestSlice implements Comparable<TestSlice> {
		private final String className;
		private final SortedSet<String> importedAutoConfigurations;
		private TestSlice(String className, SortedSet<String> importedAutoConfigurations) {
			this.className = ClassUtils.getShortName(className);
			this.importedAutoConfigurations = importedAutoConfigurations;
		}
		@Override
		public int compareTo(TestSlice other) {
			return this.className.compareTo(other.className);
		}
	}
}
/*
package org.springframework.boot.build.test;
/**
public class DockerTestPlugin implements Plugin<Project> {
	/**
	 * Name of the {@code dockerTest} task.
	 */
	public static final String DOCKER_TEST_TASK_NAME = 'dockerTest';
	/**
	 * Name of the {@code dockerTest} source set.
	 */
	public static final String DOCKER_TEST_SOURCE_SET_NAME = 'dockerTest';
	/**
	 * Name of the {@code dockerTest} shared service.
	 */
	public static final String DOCKER_TEST_SERVICE_NAME = 'dockerTest';
	private static final String RECLAIM_DOCKER_SPACE_TASK_NAME = 'reclaimDockerSpace';
	@Override
	public void apply(Project project) {
		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> configureDockerTesting(project));
	}
	private void configureDockerTesting(Project project) {
		Provider<DockerTestBuildService> buildService = DockerTestBuildService.registerIfNecessary(project);
		SourceSet dockerTestSourceSet = createSourceSet(project);
		Provider<Test> dockerTest = createTestTask(project, dockerTestSourceSet, buildService);
		project.getTasks().getByName(LifecycleBasePlugin.CHECK_TASK_NAME).dependsOn(dockerTest);
		project.getPlugins().withType(EclipsePlugin.class, (eclipsePlugin) -> {
			EclipseModel eclipse = project.getExtensions().getByType(EclipseModel.class);
			eclipse.classpath((classpath) -> classpath.getPlusConfigurations()
				.add(project.getConfigurations()
					.getByName(dockerTestSourceSet.getRuntimeClasspathConfigurationName())));
		});
		project.getDependencies()
			.add(dockerTestSourceSet.getRuntimeOnlyConfigurationName(), 'org.junit.platform:junit-platform-launcher');
		Provider<Exec> reclaimDockerSpace = createReclaimDockerSpaceTask(project, buildService);
		project.getTasks().getByName(LifecycleBasePlugin.CHECK_TASK_NAME).dependsOn(reclaimDockerSpace);
	}
	private SourceSet createSourceSet(Project project) {
		SourceSetContainer sourceSets = project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets();
		SourceSet dockerTestSourceSet = sourceSets.create(DOCKER_TEST_SOURCE_SET_NAME);
		SourceSet main = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		SourceSet test = sourceSets.getByName(SourceSet.TEST_SOURCE_SET_NAME);
		dockerTestSourceSet.setCompileClasspath(dockerTestSourceSet.getCompileClasspath()
			.plus(main.getOutput())
			.plus(main.getCompileClasspath())
			.plus(test.getOutput()));
		dockerTestSourceSet.setRuntimeClasspath(dockerTestSourceSet.getRuntimeClasspath()
			.plus(main.getOutput())
			.plus(main.getRuntimeClasspath())
			.plus(test.getOutput()));
		project.getPlugins().withType(IntegrationTestPlugin.class, (integrationTestPlugin) -> {
			SourceSet intTest = sourceSets.getByName(IntegrationTestPlugin.INT_TEST_SOURCE_SET_NAME);
			dockerTestSourceSet
				.setCompileClasspath(dockerTestSourceSet.getCompileClasspath().plus(intTest.getOutput()));
			dockerTestSourceSet
				.setRuntimeClasspath(dockerTestSourceSet.getRuntimeClasspath().plus(intTest.getOutput()));
		});
		return dockerTestSourceSet;
	}
	private Provider<Test> createTestTask(Project project, SourceSet dockerTestSourceSet,
			Provider<DockerTestBuildService> buildService) {
		return project.getTasks().register(DOCKER_TEST_TASK_NAME, Test.class, (task) -> {
			task.usesService(buildService);
			task.setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
			task.setDescription('Runs Docker-based tests.');
			task.setTestClassesDirs(dockerTestSourceSet.getOutput().getClassesDirs());
			task.setClasspath(dockerTestSourceSet.getRuntimeClasspath());
			task.shouldRunAfter(JavaPlugin.TEST_TASK_NAME);
		});
	}
	private Provider<Exec> createReclaimDockerSpaceTask(Project project,
			Provider<DockerTestBuildService> buildService) {
		return project.getTasks().register(RECLAIM_DOCKER_SPACE_TASK_NAME, Exec.class, (task) -> {
			task.usesService(buildService);
			task.setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
			task.setDescription('Reclaims Docker space on CI.');
			task.shouldRunAfter(DOCKER_TEST_TASK_NAME);
			task.onlyIf(this::shouldReclaimDockerSpace);
			task.executable('bash');
			task.args('-c',
					project.getRootDir()
						.toPath()
						.resolve('.github/scripts/reclaim-docker-diskspace.sh')
						.toAbsolutePath());
		});
	}
	private boolean shouldReclaimDockerSpace(Task task) {
		if (System.getProperty('os.name').startsWith('Windows')) {
			return false;
		}
		return System.getenv('GITHUB_ACTIONS') != null || System.getenv('RECLAIM_DOCKER_SPACE') != null;
	}
}
/*
package org.springframework.boot.build.test;
/**
public class IntegrationTestPlugin implements Plugin<Project> {
	/**
	 * Name of the {@code intTest} task.
	 */
	public static String INT_TEST_TASK_NAME = 'intTest';
	/**
	 * Name of the {@code intTest} source set.
	 */
	public static String INT_TEST_SOURCE_SET_NAME = 'intTest';
	@Override
	public void apply(Project project) {
		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> configureIntegrationTesting(project));
	}
	private void configureIntegrationTesting(Project project) {
		SourceSet intTestSourceSet = createSourceSet(project);
		Test intTest = createTestTask(project, intTestSourceSet);
		project.getTasks().getByName(LifecycleBasePlugin.CHECK_TASK_NAME).dependsOn(intTest);
		project.getPlugins().withType(EclipsePlugin.class, (eclipsePlugin) -> {
			EclipseModel eclipse = project.getExtensions().getByType(EclipseModel.class);
			eclipse.classpath((classpath) -> classpath.getPlusConfigurations()
				.add(project.getConfigurations().getByName(intTestSourceSet.getRuntimeClasspathConfigurationName())));
		});
		project.getDependencies()
			.add(intTestSourceSet.getRuntimeOnlyConfigurationName(), 'org.junit.platform:junit-platform-launcher');
	}
	private SourceSet createSourceSet(Project project) {
		SourceSetContainer sourceSets = project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets();
		SourceSet intTestSourceSet = sourceSets.create(INT_TEST_SOURCE_SET_NAME);
		SourceSet main = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		intTestSourceSet.setCompileClasspath(intTestSourceSet.getCompileClasspath().plus(main.getOutput()));
		intTestSourceSet.setRuntimeClasspath(intTestSourceSet.getRuntimeClasspath().plus(main.getOutput()));
		return intTestSourceSet;
	}
	private Test createTestTask(Project project, SourceSet intTestSourceSet) {
		Test intTest = project.getTasks().create(INT_TEST_TASK_NAME, Test.class);
		intTest.setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
		intTest.setDescription('Runs integration tests.');
		intTest.setTestClassesDirs(intTestSourceSet.getOutput().getClassesDirs());
		intTest.setClasspath(intTestSourceSet.getRuntimeClasspath());
		intTest.shouldRunAfter(JavaPlugin.TEST_TASK_NAME);
		return intTest;
	}
}
/*
package org.springframework.boot.build.test;
/**
abstract class DockerTestBuildService implements BuildService<BuildServiceParameters.None> {
	static Provider<DockerTestBuildService> registerIfNecessary(Project project) {
		return project.getGradle()
			.getSharedServices()
			.registerIfAbsent('dockerTest', DockerTestBuildService.class, (spec) -> spec.getMaxParallelUsages().set(1));
	}
}
/*
package org.springframework.boot.build.test;
/**
public class SystemTestPlugin implements Plugin<Project> {
	private static final Spec<Task> NEVER = (task) -> false;
	/**
	 * Name of the {@code systemTest} task.
	 */
	public static String SYSTEM_TEST_TASK_NAME = 'systemTest';
	/**
	 * Name of the {@code systemTest} source set.
	 */
	public static String SYSTEM_TEST_SOURCE_SET_NAME = 'systemTest';
	@Override
	public void apply(Project project) {
		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> configureSystemTesting(project));
	}
	private void configureSystemTesting(Project project) {
		SourceSet systemTestSourceSet = createSourceSet(project);
		createTestTask(project, systemTestSourceSet);
		project.getPlugins().withType(EclipsePlugin.class, (eclipsePlugin) -> {
			EclipseModel eclipse = project.getExtensions().getByType(EclipseModel.class);
			eclipse.classpath((classpath) -> classpath.getPlusConfigurations()
				.add(project.getConfigurations()
					.getByName(systemTestSourceSet.getRuntimeClasspathConfigurationName())));
		});
	}
	private SourceSet createSourceSet(Project project) {
		SourceSetContainer sourceSets = project.getExtensions().getByType(JavaPluginExtension.class).getSourceSets();
		SourceSet systemTestSourceSet = sourceSets.create(SYSTEM_TEST_SOURCE_SET_NAME);
		SourceSet mainSourceSet = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		systemTestSourceSet
			.setCompileClasspath(systemTestSourceSet.getCompileClasspath().plus(mainSourceSet.getOutput()));
		systemTestSourceSet
			.setRuntimeClasspath(systemTestSourceSet.getRuntimeClasspath().plus(mainSourceSet.getOutput()));
		return systemTestSourceSet;
	}
	private void createTestTask(Project project, SourceSet systemTestSourceSet) {
		Test systemTest = project.getTasks().create(SYSTEM_TEST_TASK_NAME, Test.class);
		systemTest.setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
		systemTest.setDescription('Runs system tests.');
		systemTest.setTestClassesDirs(systemTestSourceSet.getOutput().getClassesDirs());
		systemTest.setClasspath(systemTestSourceSet.getRuntimeClasspath());
		systemTest.shouldRunAfter(JavaPlugin.TEST_TASK_NAME);
		if (isCi()) {
			systemTest.getOutputs().upToDateWhen(NEVER);
			systemTest.getOutputs().doNotCacheIf('System tests are always rerun on CI', (task) -> true);
		}
	}
	private boolean isCi() {
		return Boolean.parseBoolean(System.getenv('CI'));
	}
}
/*
package org.springframework.boot.build.properties;
/**
public enum BuildType {
	/**
	 * An open source build.
	 */
	OPEN_SOURCE,
	/**
	 * A commercial build.
	 */
	COMMERCIAL;
	public String toIdentifier() {
		return toString().replace('_', '').toLowerCase(Locale.ROOT);
	}
}
/*
package org.springframework.boot.build.properties;
/**
public record BuildProperties(BuildType buildType, GitHub gitHub) {
	private static final String PROPERTY_NAME = BuildProperties.class.getName();
	/**
	 * Get the {@link BuildProperties} for the given {@link Project}.
	 * @param project the source project
	 * @return the build properties
	 */
	public static BuildProperties get(Project project) {
		BuildProperties buildProperties = (BuildProperties) project.findProperty(PROPERTY_NAME);
		if (buildProperties == null) {
			buildProperties = load(project);
			project.getExtensions().getExtraProperties().set(PROPERTY_NAME, buildProperties);
		}
		return buildProperties;
	}
	private static BuildProperties load(Project project) {
		BuildType buildType = buildType(project.findProperty('spring.build-type'));
		return switch (buildType) {
			case OPEN_SOURCE -> new BuildProperties(buildType, GitHub.OPEN_SOURCE);
			case COMMERCIAL -> new BuildProperties(buildType, GitHub.COMMERCIAL);
		};
	}
	private static BuildType buildType(Object value) {
		if (value == null || 'oss'.equals(value.toString())) {
			return BuildType.OPEN_SOURCE;
		}
		if ('commercial'.equals(value.toString())) {
			return BuildType.COMMERCIAL;
		}
		throw new IllegalStateException('Unknown build type property "' + value + '"');
	}
	/**
	 * GitHub properties.
	 *
	 * @param organization the GitHub organization
	 * @param repository the GitHub repository
	 */
	public record GitHub(String organization, String repository) {
		static final GitHub OPEN_SOURCE = new GitHub('spring-projects', 'spring-boot');
		static final GitHub COMMERCIAL = new GitHub('spring-projects', 'spring-boot-commercial');
	}
}
/*
package org.springframework.boot.build;
/**
public class WarConventions {
	void apply(Project project) {
		project.getPlugins().withType(EclipseWtpPlugin.class, (wtp) -> {
			project.getTasks().getByName(EclipseWtpPlugin.ECLIPSE_WTP_FACET_TASK_NAME).doFirst((task) -> {
				EclipseModel eclipseModel = project.getExtensions().getByType(EclipseModel.class);
				((IConventionAware) eclipseModel.getWtp().getFacet()).getConventionMapping()
					.map('facets', () -> getFacets(project));
			});
		});
	}
	private List<Facet> getFacets(Project project) {
		JavaVersion javaVersion = project.getExtensions().getByType(JavaPluginExtension.class).getSourceCompatibility();
		List<Facet> facets = new ArrayList<>();
		facets.add(new Facet(Facet.FacetType.fixed, 'jst.web', null));
		facets.add(new Facet(Facet.FacetType.installed, 'jst.web', '5.0'));
		facets.add(new Facet(Facet.FacetType.installed, 'jst.java', javaVersion.toString()));
		return facets;
	}
}
/*
package org.springframework.boot.build;
/**
class JavaConventions {
	private static final String SOURCE_AND_TARGET_COMPATIBILITY = '17';
	void apply(Project project) {
		project.getPlugins().withType(JavaBasePlugin.class, (java) -> {
			project.getPlugins().apply(TestFailuresPlugin.class);
			project.getPlugins().apply(ArchitecturePlugin.class);
			configureSpringJavaFormat(project);
			configureJavaConventions(project);
			configureJavadocConventions(project);
			configureTestConventions(project);
			configureJarManifestConventions(project);
			configureDependencyManagement(project);
			configureToolchain(project);
			configureProhibitedDependencyChecks(project);
		});
	}
	private void configureJarManifestConventions(Project project) {
		ExtractResources extractLegalResources = project.getTasks()
			.create('extractLegalResources', ExtractResources.class);
		extractLegalResources.getDestinationDirectory().set(project.getLayout().getBuildDirectory().dir('legal'));
		extractLegalResources.getResourceNames().set(Arrays.asList('LICENSE.txt', 'NOTICE.txt'));
		extractLegalResources.getProperties().put('version', project.getVersion().toString());
		SourceSetContainer sourceSets = project.getExtensions().getByType(SourceSetContainer.class);
		Set<String> sourceJarTaskNames = sourceSets.stream()
			.map(SourceSet::getSourcesJarTaskName)
			.collect(Collectors.toSet());
		Set<String> javadocJarTaskNames = sourceSets.stream()
			.map(SourceSet::getJavadocJarTaskName)
			.collect(Collectors.toSet());
		project.getTasks().withType(Jar.class, (jar) -> project.afterEvaluate((evaluated) -> {
			jar.metaInf((metaInf) -> metaInf.from(extractLegalResources));
			jar.manifest((manifest) -> {
				Map<String, Object> attributes = new TreeMap<>();
				attributes.put('Automatic-Module-Name', project.getName().replace('-', '.'));
				attributes.put('Build-Jdk-Spec', SOURCE_AND_TARGET_COMPATIBILITY);
				attributes.put('Built-By', 'Spring');
				attributes.put('Implementation-Title',
						determineImplementationTitle(project, sourceJarTaskNames, javadocJarTaskNames, jar));
				attributes.put('Implementation-Version', project.getVersion());
				manifest.attributes(attributes);
			});
		}));
	}
	private String determineImplementationTitle(Project project, Set<String> sourceJarTaskNames,
			Set<String> javadocJarTaskNames, Jar jar) {
		if (sourceJarTaskNames.contains(jar.getName())) {
			return 'Source for ' + project.getName();
		}
		if (javadocJarTaskNames.contains(jar.getName())) {
			return 'Javadoc for ' + project.getName();
		}
		return project.getDescription();
	}
	private void configureTestConventions(Project project) {
		project.getTasks().withType(Test.class, (test) -> {
			test.useJUnitPlatform();
			test.setMaxHeapSize('1024M');
			project.getTasks().withType(Checkstyle.class, test::mustRunAfter);
			project.getTasks().withType(CheckFormat.class, test::mustRunAfter);
			configureTestRetries(test);
			configurePredictiveTestSelection(test);
		});
		project.getPlugins()
			.withType(JavaPlugin.class, (javaPlugin) -> project.getDependencies()
				.add(JavaPlugin.TEST_RUNTIME_ONLY_CONFIGURATION_NAME, 'org.junit.platform:junit-platform-launcher'));
	}
	private void configureTestRetries(Test test) {
		TestRetryConfiguration testRetry = test.getExtensions()
			.getByType(DevelocityTestConfiguration.class)
			.getTestRetry();
		testRetry.getFailOnPassedAfterRetry().set(false);
		testRetry.getMaxRetries().set(isCi() ? 3 : 0);
	}
	private boolean isCi() {
		return Boolean.parseBoolean(System.getenv('CI'));
	}
	private void configurePredictiveTestSelection(Test test) {
		if (isPredictiveTestSelectionEnabled()) {
			PredictiveTestSelectionConfiguration predictiveTestSelection = test.getExtensions()
				.getByType(DevelocityTestConfiguration.class)
				.getPredictiveTestSelection();
			predictiveTestSelection.getEnabled().convention(true);
		}
	}
	private boolean isPredictiveTestSelectionEnabled() {
		return Boolean.parseBoolean(System.getenv('ENABLE_PREDICTIVE_TEST_SELECTION'));
	}
	private void configureJavadocConventions(Project project) {
		project.getTasks().withType(Javadoc.class, (javadoc) -> {
			CoreJavadocOptions options = (CoreJavadocOptions) javadoc.getOptions();
			options.source('17');
			options.encoding('UTF-8');
			options.addStringOption('Xdoclint:none', '-quiet');
		});
	}
	private void configureJavaConventions(Project project) {
		if (!project.hasProperty('toolchainVersion')) {
			JavaPluginExtension javaPluginExtension = project.getExtensions().getByType(JavaPluginExtension.class);
			javaPluginExtension.setSourceCompatibility(JavaVersion.toVersion(SOURCE_AND_TARGET_COMPATIBILITY));
		}
		project.getTasks().withType(JavaCompile.class, (compile) -> {
			compile.getOptions().setEncoding('UTF-8');
			List<String> args = compile.getOptions().getCompilerArgs();
			if (!args.contains('-parameters')) {
				args.add('-parameters');
			}
			if (project.hasProperty('toolchainVersion')) {
				compile.setSourceCompatibility(SOURCE_AND_TARGET_COMPATIBILITY);
				compile.setTargetCompatibility(SOURCE_AND_TARGET_COMPATIBILITY);
			}
			else if (buildingWithJava17(project)) {
				args.addAll(Arrays.asList('-Werror', '-Xlint:unchecked', '-Xlint:deprecation', '-Xlint:rawtypes',
						'-Xlint:varargs'));
			}
		});
	}
	private boolean buildingWithJava17(Project project) {
		return !project.hasProperty('toolchainVersion') && JavaVersion.current() == JavaVersion.VERSION_17;
	}
	private void configureSpringJavaFormat(Project project) {
		project.getPlugins().apply(SpringJavaFormatPlugin.class);
		project.getTasks().withType(Format.class, (Format) -> Format.setEncoding('UTF-8'));
		project.getPlugins().apply(CheckstylePlugin.class);
		CheckstyleExtension checkstyle = project.getExtensions().getByType(CheckstyleExtension.class);
		checkstyle.setToolVersion('10.12.4');
		checkstyle.getConfigDirectory().set(project.getRootProject().file('src/checkstyle'));
		String version = SpringJavaFormatPlugin.class.getPackage().getImplementationVersion();
		DependencySet checkstyleDependencies = project.getConfigurations().getByName('checkstyle').getDependencies();
		checkstyleDependencies
			.add(project.getDependencies().create('com.puppycrawl.tools:checkstyle:' + checkstyle.getToolVersion()));
		checkstyleDependencies
			.add(project.getDependencies().create('io.spring.javaformat:spring-javaformat-checkstyle:' + version));
	}
	private void configureDependencyManagement(Project project) {
		ConfigurationContainer configurations = project.getConfigurations();
		Configuration dependencyManagement = configurations.create('dependencyManagement', (configuration) -> {
			configuration.setVisible(false);
			configuration.setCanBeConsumed(false);
			configuration.setCanBeResolved(false);
		});
		configurations
			.matching((configuration) -> (configuration.getName().endsWith('Classpath')
					|| JavaPlugin.ANNOTATION_PROCESSOR_CONFIGURATION_NAME.equals(configuration.getName()))
					&& (!configuration.getName().contains('dokkatoo')))
			.all((configuration) -> configuration.extendsFrom(dependencyManagement));
		Dependency springBootParent = project.getDependencies()
			.enforcedPlatform(project.getDependencies()
				.project(Collections.singletonMap('path', ':spring-boot-project:spring-boot-parent')));
		dependencyManagement.getDependencies().add(springBootParent);
		project.getPlugins()
			.withType(OptionalDependenciesPlugin.class,
					(optionalDependencies) -> configurations
						.getByName(OptionalDependenciesPlugin.OPTIONAL_CONFIGURATION_NAME)
						.extendsFrom(dependencyManagement));
	}
	private void configureToolchain(Project project) {
		project.getPlugins().apply(ToolchainPlugin.class);
	}
	private void configureProhibitedDependencyChecks(Project project) {
		SourceSetContainer sourceSets = project.getExtensions().getByType(SourceSetContainer.class);
		sourceSets.all((sourceSet) -> createProhibitedDependenciesChecks(project,
				sourceSet.getCompileClasspathConfigurationName(), sourceSet.getRuntimeClasspathConfigurationName()));
	}
	private void createProhibitedDependenciesChecks(Project project, String... configurationNames) {
		ConfigurationContainer configurations = project.getConfigurations();
		for (String configurationName : configurationNames) {
			Configuration configuration = configurations.getByName(configurationName);
			createProhibitedDependenciesCheck(configuration, project);
		}
	}
	private void createProhibitedDependenciesCheck(Configuration classpath, Project project) {
		CheckClasspathForProhibitedDependencies checkClasspathForProhibitedDependencies = project.getTasks()
			.create('check' + StringUtils.capitalize(classpath.getName() + 'ForProhibitedDependencies'),
					CheckClasspathForProhibitedDependencies.class);
		checkClasspathForProhibitedDependencies.setClasspath(classpath);
		project.getTasks().getByName(JavaBasePlugin.CHECK_TASK_NAME).dependsOn(checkClasspathForProhibitedDependencies);
	}
}
/*
package org.springframework.boot.build.antora;
/**
public final class Extensions {
	private static final String ROOT_COMPONENT_EXTENSION = '@springio/antora-extensions/root-component-extension';
	private static final List<Extension> antora;
	static {
		List<Extension> extensions = new ArrayList<>();
		extensions.add(new Extension('@springio/antora-extensions', ROOT_COMPONENT_EXTENSION,
				'@springio/antora-extensions/static-page-extension',
				'@springio/antora-extensions/override-navigation-builder-extension'));
		extensions.add(new Extension('@springio/antora-xref-extension'));
		extensions.add(new Extension('@springio/antora-zip-contents-collector-extension'));
		antora = List.copyOf(extensions);
	}
	private static final List<Extension> asciidoc;
	static {
		List<Extension> extensions = new ArrayList<>();
		extensions.add(new Extension('@asciidoctor/tabs'));
		extensions.add(new Extension('@springio/asciidoctor-extensions', '@springio/asciidoctor-extensions',
				'@springio/asciidoctor-extensions/javadoc-extension',
				'@springio/asciidoctor-extensions/configuration-properties-extension',
				'@springio/asciidoctor-extensions/section-ids-extension'));
		asciidoc = List.copyOf(extensions);
	}
	private static final Map<String, String> localOverrides = Collections.emptyMap();
	private Extensions() {
	}
	static List<Map<String, Object>> antora(Consumer<AntoraExtensionsConfiguration> extensions) {
		AntoraExtensionsConfiguration result = new AntoraExtensionsConfiguration(
				antora.stream().flatMap(Extension::names).sorted().toList());
		extensions.accept(result);
		return result.config();
	}
	static List<String> asciidoc() {
		return asciidoc.stream().flatMap(Extension::names).sorted().toList();
	}
	private record Extension(String name, String... includeNames) {
		Stream<String> names() {
			return (this.includeNames.length != 0) ? Arrays.stream(this.includeNames) : Stream.of(this.name);
		}
	}
	static final class AntoraExtensionsConfiguration {
		private Map<String, Map<String, Object>> extensions = new TreeMap<>();
		private AntoraExtensionsConfiguration(List<String> names) {
			names.forEach((name) -> this.extensions.put(name, null));
		}
		void xref(Consumer<Xref> xref) {
			xref.accept(new Xref());
		}
		void zipContentsCollector(Consumer<ZipContentsCollector> zipContentsCollector) {
			zipContentsCollector.accept(new ZipContentsCollector());
		}
		void rootComponent(Consumer<RootComponent> rootComponent) {
			rootComponent.accept(new RootComponent());
		}
		List<Map<String, Object>> config() {
			List<Map<String, Object>> config = new ArrayList<>();
			Map<String, Map<String, Object>> orderedExtensions = new LinkedHashMap<>(this.extensions);
			// The root component extension must be last
			Map<String, Object> rootComponentConfig = orderedExtensions.remove(ROOT_COMPONENT_EXTENSION);
			orderedExtensions.put(ROOT_COMPONENT_EXTENSION, rootComponentConfig);
			orderedExtensions.forEach((name, customizations) -> {
				Map<String, Object> extensionConfig = new LinkedHashMap<>();
				extensionConfig.put('require', localOverrides.getOrDefault(name, name));
				if (customizations != null) {
					extensionConfig.putAll(customizations);
				}
				config.add(extensionConfig);
			});
			return List.copyOf(config);
		}
		abstract class Customizer {
			private final String name;
			Customizer(String name) {
				this.name = name;
			}
			protected void customize(String key, Object value) {
				AntoraExtensionsConfiguration.this.extensions.computeIfAbsent(this.name, (name) -> new TreeMap<>())
					.put(key, value);
			}
		}
		class Xref extends Customizer {
			Xref() {
				super('@springio/antora-xref-extension');
			}
			void stub(List<String> stub) {
				if (stub != null && !stub.isEmpty()) {
					customize('stub', stub);
				}
			}
		}
		class ZipContentsCollector extends Customizer {
			ZipContentsCollector() {
				super('@springio/antora-zip-contents-collector-extension');
			}
			void versionFile(String versionFile) {
				customize('version_file', versionFile);
			}
			void locations(Path... locations) {
				locations(Arrays.stream(locations).map(Path::toString).toList());
			}
			private void locations(List<String> locations) {
				customize('locations', locations);
			}
			void alwaysInclude(Map<String, String> alwaysInclude) {
				if (alwaysInclude != null && !alwaysInclude.isEmpty()) {
					customize('always_include', List.of(new TreeMap<>(alwaysInclude)));
				}
			}
		}
		class RootComponent extends Customizer {
			RootComponent() {
				super(ROOT_COMPONENT_EXTENSION);
			}
			void name(String name) {
				customize('root_component_name', name);
			}
		}
	}
}
/*
package org.springframework.boot.build.antora;
/**
public abstract class GenerateAntoraPlaybook extends DefaultTask {
	private static final String ANTORA_SOURCE_DIR = 'src/docs/antora';
	private static final String GENERATED_DOCS = 'build/generated/docs/';
	@OutputFile
	public abstract RegularFileProperty getOutputFile();
	@Input
	public abstract Property<String> getContentSourceConfiguration();
	@Input
	@Optional
	public abstract ListProperty<String> getXrefStubs();
	@Input
	@Optional
	public abstract MapProperty<String, String> getAlwaysInclude();
	@Input
	@Optional
	public abstract Property<Boolean> getExcludeJavadocExtension();
	public GenerateAntoraPlaybook() {
		setGroup('Documentation');
		setDescription('Generates an Antora playbook.yml file for local use');
		getOutputFile().convention(getProject().getLayout()
			.getBuildDirectory()
			.file('generated/docs/antora-playbook/antora-playbook.yml'));
		getContentSourceConfiguration().convention('antoraContent');
	}
	@TaskAction
	public void writePlaybookYml() throws IOException {
		File file = getOutputFile().get().getAsFile();
		file.getParentFile().mkdirs();
		try (FileWriter out = new FileWriter(file)) {
			createYaml().dump(getData(), out);
		}
	}
	@Input
	final Map<String, Object> getData() throws IOException {
		Map<String, Object> data = loadPlaybookTemplate();
		addExtensions(data);
		addSources(data);
		addDir(data);
		filterJavadocExtension(data);
		return data;
	}
	@SuppressWarnings('unchecked')
	private void filterJavadocExtension(Map<String, Object> data) {
		if (getExcludeJavadocExtension().getOrElse(Boolean.FALSE)) {
			Map<String, Object> asciidoc = (Map<String, Object>) data.get('asciidoc');
			List<String> extensions = new ArrayList<>((List<String>) asciidoc.get('extensions'));
			extensions.remove('@springio/asciidoctor-extensions/javadoc-extension');
			asciidoc.put('extensions', extensions);
		}
	}
	@SuppressWarnings('unchecked')
	private Map<String, Object> loadPlaybookTemplate() throws IOException {
		try (InputStream resource = getClass().getResourceAsStream('antora-playbook-template.yml')) {
			return createYaml().loadAs(resource, LinkedHashMap.class);
		}
	}
	@SuppressWarnings('unchecked')
	private void addExtensions(Map<String, Object> data) {
		Map<String, Object> antora = (Map<String, Object>) data.get('antora');
		antora.put('extensions', Extensions.antora((extensions) -> {
			extensions.xref((xref) -> xref.stub(getXrefStubs().getOrElse(Collections.emptyList())));
			extensions.zipContentsCollector((zipContentsCollector) -> {
				zipContentsCollector.versionFile('gradle.properties');
				String locationName = getProject().getName() + '-${version}-${name}-${classifier}.zip';
				Path antoraContent = getRelativeProjectPath()
					.resolve(GENERATED_DOCS + 'antora-content/' + locationName);
				Path antoraDependencies = getRelativeProjectPath()
					.resolve(GENERATED_DOCS + 'antora-dependencies-content/' + locationName);
				zipContentsCollector.locations(antoraContent, antoraDependencies);
				zipContentsCollector.alwaysInclude(getAlwaysInclude().getOrNull());
			});
			extensions.rootComponent((rootComponent) -> rootComponent.name('boot'));
		}));
		Map<String, Object> asciidoc = (Map<String, Object>) data.get('asciidoc');
		asciidoc.put('extensions', Extensions.asciidoc());
	}
	private void addSources(Map<String, Object> data) {
		List<Map<String, Object>> contentSources = getList(data, 'content.sources');
		contentSources.add(createContentSource());
	}
	private Map<String, Object> createContentSource() {
		Map<String, Object> source = new LinkedHashMap<>();
		Path playbookPath = getOutputFile().get().getAsFile().toPath().getParent();
		Path antoraSrc = getProjectPath(getProject()).resolve(ANTORA_SOURCE_DIR);
		StringBuilder url = new StringBuilder('.');
		relativizeFromRootProject(playbookPath).normalize().forEach((path) -> url.append(File.separator).append('..'));
		source.put('url', url.toString());
		source.put('branches', 'HEAD');
		source.put('version', getProject().getVersion().toString());
		Set<String> startPaths = new LinkedHashSet<>();
		addAntoraContentStartPaths(startPaths);
		startPaths.add(relativizeFromRootProject(antoraSrc).toString());
		source.put('start_paths', startPaths.stream().toList());
		return source;
	}
	private void addAntoraContentStartPaths(Set<String> startPaths) {
		Configuration configuration = getProject().getConfigurations().findByName('antoraContent');
		if (configuration != null) {
			for (ProjectDependency dependency : configuration.getAllDependencies().withType(ProjectDependency.class)) {
				Path path = dependency.getDependencyProject().getProjectDir().toPath();
				startPaths.add(relativizeFromRootProject(path).resolve(ANTORA_SOURCE_DIR).toString());
			}
		}
	}
	private void addDir(Map<String, Object> data) {
		Path playbookDir = toRealPath(getOutputFile().get().getAsFile().toPath()).getParent();
		Path outputDir = toRealPath(
				getProject().getLayout().getBuildDirectory().dir('site').get().getAsFile().toPath());
		data.put('output', Map.of('dir', '.' + File.separator + playbookDir.relativize(outputDir)));
	}
	@SuppressWarnings('unchecked')
	private <T> List<T> getList(Map<String, Object> data, String location) {
		return (List<T>) get(data, location);
	}
	@SuppressWarnings('unchecked')
	private Object get(Map<String, Object> data, String location) {
		Object result = data;
		String[] keys = location.split('\\.');
		for (String key : keys) {
			result = ((Map<String, Object>) result).get(key);
		}
		return result;
	}
	private Yaml createYaml() {
		DumperOptions options = new DumperOptions();
		options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
		options.setPrettyFlow(true);
		return new Yaml(options);
	}
	private Path getRelativeProjectPath() {
		return relativizeFromRootProject(getProjectPath(getProject()));
	}
	private Path relativizeFromRootProject(Path subPath) {
		Path rootProjectPath = getProjectPath(getProject().getRootProject());
		return rootProjectPath.relativize(subPath).normalize();
	}
	private Path getProjectPath(Project project) {
		return toRealPath(project.getProjectDir().toPath());
	}
	private Path toRealPath(Path path) {
		try {
			return Files.exists(path) ? path.toRealPath() : path;
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
}
/*
package org.springframework.boot.build.antora;
/**
public class AntoraAsciidocAttributes {
	private static final String DASH_SNAPSHOT = '-SNAPSHOT';
	private final String version;
	private final boolean latestVersion;
	private final BuildType buildType;
	private final ArtifactRelease artifactRelease;
	private final List<Library> libraries;
	private final Map<String, String> dependencyVersions;
	private final Map<String, ?> projectProperties;
	public AntoraAsciidocAttributes(Project project, BomExtension dependencyBom,
			Map<String, String> dependencyVersions) {
		this.version = String.valueOf(project.getVersion());
		this.latestVersion = Boolean.parseBoolean(String.valueOf(project.findProperty('latestVersion')));
		this.buildType = BuildProperties.get(project).buildType();
		this.artifactRelease = ArtifactRelease.forProject(project);
		this.libraries = dependencyBom.getLibraries();
		this.dependencyVersions = dependencyVersions;
		this.projectProperties = project.getProperties();
	}
	AntoraAsciidocAttributes(String version, boolean latestVersion, BuildType buildType, List<Library> libraries,
			Map<String, String> dependencyVersions, Map<String, ?> projectProperties) {
		this.version = version;
		this.latestVersion = latestVersion;
		this.buildType = buildType;
		this.artifactRelease = ArtifactRelease.forVersion(version);
		this.libraries = (libraries != null) ? libraries : Collections.emptyList();
		this.dependencyVersions = (dependencyVersions != null) ? dependencyVersions : Collections.emptyMap();
		this.projectProperties = (projectProperties != null) ? projectProperties : Collections.emptyMap();
	}
	public Map<String, String> get() {
		Map<String, String> attributes = new LinkedHashMap<>();
		addBuildTypeAttribute(attributes);
		addGitHubAttributes(attributes);
		addVersionAttributes(attributes);
		addArtifactAttributes(attributes);
		addUrlJava(attributes);
		addUrlLibraryLinkAttributes(attributes);
		addPropertyAttributes(attributes);
		return attributes;
	}
	private void addBuildTypeAttribute(Map<String, String> attributes) {
		attributes.put('build-type', this.buildType.toIdentifier());
	}
	private void addGitHubAttributes(Map<String, String> attributes) {
		attributes.put('github-repo', 'spring-projects/spring-boot');
		attributes.put('github-ref', determineGitHubRef());
	}
	private String determineGitHubRef() {
		int snapshotIndex = this.version.lastIndexOf(DASH_SNAPSHOT);
		if (snapshotIndex == -1) {
			return 'v' + this.version;
		}
		if (this.latestVersion) {
			return 'main';
		}
		String versionRoot = this.version.substring(0, snapshotIndex);
		int lastDot = versionRoot.lastIndexOf(".");
		return versionRoot.substring(0, lastDot) + '.x';
	}
	private void addVersionAttributes(Map<String, String> attributes) {
		this.libraries.forEach((library) -> {
			String name = 'version-' + library.getLinkRootName();
			String value = library.getVersion().toString();
			attributes.put(name, value);
		});
		attributes.put('version-native-build-tools', (String) this.projectProperties.get('nativeBuildToolsVersion'));
		attributes.put('version-graal', (String) this.projectProperties.get('graalVersion'));
		addDependencyVersion(attributes, 'jackson-annotations', 'com.fasterxml.jackson.core:jackson-annotations');
		addDependencyVersion(attributes, 'jackson-core', 'com.fasterxml.jackson.core:jackson-core');
		addDependencyVersion(attributes, 'jackson-databind', 'com.fasterxml.jackson.core:jackson-databind');
		addSpringDataDependencyVersion(attributes, 'spring-data-commons');
		addSpringDataDependencyVersion(attributes, 'spring-data-couchbase');
		addSpringDataDependencyVersion(attributes, 'spring-data-cassandra');
		addSpringDataDependencyVersion(attributes, 'spring-data-elasticsearch');
		addSpringDataDependencyVersion(attributes, 'spring-data-jdbc');
		addSpringDataDependencyVersion(attributes, 'spring-data-jpa');
		addSpringDataDependencyVersion(attributes, 'spring-data-mongodb');
		addSpringDataDependencyVersion(attributes, 'spring-data-neo4j');
		addSpringDataDependencyVersion(attributes, 'spring-data-r2dbc');
		addSpringDataDependencyVersion(attributes, 'spring-data-rest', 'spring-data-rest-core');
		addSpringDataDependencyVersion(attributes, 'spring-data-ldap');
	}
	private void addSpringDataDependencyVersion(Map<String, String> attributes, String artifactId) {
		addSpringDataDependencyVersion(attributes, artifactId, artifactId);
	}
	private void addSpringDataDependencyVersion(Map<String, String> attributes, String name, String artifactId) {
		String version = getVersion('org.springframework.data:' + artifactId);
		String majorMinor = Arrays.stream(version.split('\\.')).limit(2).collect(Collectors.joining('.'));
		String antoraVersion = version.endsWith(DASH_SNAPSHOT) ? majorMinor + DASH_SNAPSHOT : majorMinor;
		attributes.put('version-' + name + '-docs', antoraVersion);
		attributes.put('version-' + name + '-javadoc', majorMinor + '.x');
	}
	private void addDependencyVersion(Map<String, String> attributes, String name, String groupAndArtifactId) {
		attributes.put('version-' + name, getVersion(groupAndArtifactId));
	}
	private String getVersion(String groupAndArtifactId) {
		String version = this.dependencyVersions.get(groupAndArtifactId);
		Assert.notNull(version, () -> 'No version found for ' + groupAndArtifactId);
		return version;
	}
	private void addArtifactAttributes(Map<String, String> attributes) {
		attributes.put('url-artifact-repository', this.artifactRelease.getDownloadRepo());
		attributes.put('artifact-release-type', this.artifactRelease.getType());
		attributes.put('build-and-artifact-release-type',
				this.buildType.toIdentifier() + '-' + this.artifactRelease.getType());
	}
	private void addUrlJava(Map<String, String> attributes) {
		attributes.put('url-javase-javadoc', 'https://docs.oracle.com/en/java/javase/17/docs/api/');
	}
	private void addUrlLibraryLinkAttributes(Map<String, String> attributes) {
		this.libraries.forEach((library) -> {
			String prefix = 'url-' + library.getLinkRootName() + '-';
			library.getLinks().forEach((name, link) -> attributes.put(prefix + name, link));
		});
	}
	private void addPropertyAttributes(Map<String, String> attributes) {
		Properties properties = new Properties() {
			@Override
			public synchronized Object put(Object key, Object value) {
				// Put directly because order is important for us
				return attributes.put(key.toString(), value.toString());
			}
		};
		try (InputStream in = getClass().getResourceAsStream('antora-asciidoc-attributes.properties')) {
			properties.load(in);
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
}
/*
package org.springframework.boot.build.starters;
/**
public abstract class StarterMetadata extends DefaultTask {
	private Configuration dependencies;
	public StarterMetadata() {
		Project project = getProject();
		getStarterName().convention(project.provider(project::getName));
		getStarterDescription().convention(project.provider(project::getDescription));
	}
	@Input
	public abstract Property<String> getStarterName();
	@Input
	public abstract Property<String> getStarterDescription();
	@Classpath
	public FileCollection getDependencies() {
		return this.dependencies;
	}
	public void setDependencies(Configuration dependencies) {
		this.dependencies = dependencies;
	}
	@OutputFile
	public abstract RegularFileProperty getDestination();
	@TaskAction
	void generateMetadata() throws IOException {
		Properties properties = CollectionFactory.createSortedProperties(true);
		properties.setProperty('name', getStarterName().get());
		properties.setProperty('description', getStarterDescription().get());
		properties.setProperty('dependencies',
				String.join(',',
						this.dependencies.getResolvedConfiguration()
							.getResolvedArtifacts()
							.stream()
							.map(ResolvedArtifact::getName)
							.collect(Collectors.toSet())));
		File destination = getDestination().getAsFile().get();
		destination.getParentFile().mkdirs();
		try (FileWriter writer = new FileWriter(destination)) {
			properties.store(writer, null);
		}
	}
}
/*
package org.springframework.boot.build.starters;
/**
public abstract class DocumentStarters extends DefaultTask {
	private final Configuration starters;
	public DocumentStarters() {
		this.starters = getProject().getConfigurations().create('starters');
		getProject().getGradle().projectsEvaluated((gradle) -> {
			gradle.allprojects((project) -> {
				if (project.getPlugins().hasPlugin(StarterPlugin.class)) {
					Map<String, String> dependency = new HashMap<>();
					dependency.put('path', project.getPath());
					dependency.put('configuration', 'starterMetadata');
					this.starters.getDependencies().add(project.getDependencies().project(dependency));
				}
			});
		});
	}
	@OutputDirectory
	public abstract DirectoryProperty getOutputDir();
	@InputFiles
	@PathSensitive(PathSensitivity.RELATIVE)
	public FileCollection getStarters() {
		return this.starters;
	}
	@TaskAction
	void documentStarters() {
		Set<Starter> starters = this.starters.getFiles()
			.stream()
			.map(this::loadStarter)
			.collect(Collectors.toCollection(TreeSet::new));
		writeTable('application-starters', starters.stream().filter(Starter::isApplication));
		writeTable('production-starters', starters.stream().filter(Starter::isProduction));
		writeTable('technical-starters', starters.stream().filter(Starter::isTechnical));
	}
	private Starter loadStarter(File metadata) {
		Properties properties = new Properties();
		try (FileReader reader = new FileReader(metadata)) {
			properties.load(reader);
			return new Starter(properties.getProperty('name'), properties.getProperty('description'),
					StringUtils.commaDelimitedListToSet(properties.getProperty('dependencies')));
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void writeTable(String name, Stream<Starter> starters) {
		File output = new File(getOutputDir().getAsFile().get(), name + '.adoc');
		output.getParentFile().mkdirs();
		try (PrintWriter writer = new PrintWriter(new FileWriter(output))) {
			writer.println('|===');
			writer.println('| Name | Description');
			starters.forEach((starter) -> {
				writer.println();
				writer.printf('| [[%s]]`%s`%n', starter.name, starter.name);
				writer.printf('| %s%n', postProcessDescription(starter.description));
			});
			writer.println('|===');
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private String postProcessDescription(String description) {
		return addStarterCrossLinks(description);
	}
	private String addStarterCrossLinks(String input) {
		return input.replaceAll('(spring-boot-starter[A-Za-z-]*)', 'xref:#$1[`$1`]');
	}
	private static final class Starter implements Comparable<Starter> {
		private final String name;
		private final String description;
		private final Set<String> dependencies;
		private Starter(String name, String description, Set<String> dependencies) {
			this.name = name;
			this.description = description;
			this.dependencies = dependencies;
		}
		private boolean isProduction() {
			return this.name.equals('spring-boot-starter-actuator');
		}
		private boolean isTechnical() {
			return !Arrays.asList('spring-boot-starter', 'spring-boot-starter-test').contains(this.name)
					&& !isProduction() && !this.dependencies.contains('spring-boot-starter');
		}
		private boolean isApplication() {
			return !isProduction() && !isTechnical();
		}
		@Override
		public int compareTo(Starter other) {
			return this.name.compareTo(other.name);
		}
	}
}
/*
package org.springframework.boot.build.starters;
/**
public class StarterPlugin implements Plugin<Project> {
	private static final String JAR_TYPE = 'dependencies-starter';
	@Override
	public void apply(Project project) {
		PluginContainer plugins = project.getPlugins();
		plugins.apply(DeployedPlugin.class);
		plugins.apply(JavaLibraryPlugin.class);
		plugins.apply(ConventionsPlugin.class);
		StarterMetadata starterMetadata = project.getTasks().create('starterMetadata', StarterMetadata.class);
		ConfigurationContainer configurations = project.getConfigurations();
		Configuration runtimeClasspath = configurations.getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);
		starterMetadata.setDependencies(runtimeClasspath);
		Provider<RegularFile> destination = project.getLayout().getBuildDirectory().file('starter-metadata.properties');
		starterMetadata.getDestination().set(destination);
		configurations.create('starterMetadata');
		project.getArtifacts()
			.add('starterMetadata', project.provider(starterMetadata::getDestination),
					(artifact) -> artifact.builtBy(starterMetadata));
		createClasspathConflictsCheck(runtimeClasspath, project);
		createUnnecessaryExclusionsCheck(runtimeClasspath, project);
		createUnconstrainedDirectDependenciesCheck(runtimeClasspath, project);
		configureJarManifest(project);
	}
	private void createClasspathConflictsCheck(Configuration classpath, Project project) {
		CheckClasspathForConflicts checkClasspathForConflicts = project.getTasks()
			.create('check' + StringUtils.capitalize(classpath.getName() + 'ForConflicts'),
					CheckClasspathForConflicts.class);
		checkClasspathForConflicts.setClasspath(classpath);
		project.getTasks().getByName(JavaBasePlugin.CHECK_TASK_NAME).dependsOn(checkClasspathForConflicts);
	}
	private void createUnnecessaryExclusionsCheck(Configuration classpath, Project project) {
		CheckClasspathForUnnecessaryExclusions checkClasspathForUnnecessaryExclusions = project.getTasks()
			.create('check' + StringUtils.capitalize(classpath.getName() + 'ForUnnecessaryExclusions'),
					CheckClasspathForUnnecessaryExclusions.class);
		checkClasspathForUnnecessaryExclusions.setClasspath(classpath);
		project.getTasks().getByName(JavaBasePlugin.CHECK_TASK_NAME).dependsOn(checkClasspathForUnnecessaryExclusions);
	}
	private void createUnconstrainedDirectDependenciesCheck(Configuration classpath, Project project) {
		CheckClasspathForUnconstrainedDirectDependencies checkClasspathForUnconstrainedDirectDependencies = project
			.getTasks()
			.create('check' + StringUtils.capitalize(classpath.getName() + 'ForUnconstrainedDirectDependencies'),
					CheckClasspathForUnconstrainedDirectDependencies.class);
		checkClasspathForUnconstrainedDirectDependencies.setClasspath(classpath);
		project.getTasks()
			.getByName(JavaBasePlugin.CHECK_TASK_NAME)
			.dependsOn(checkClasspathForUnconstrainedDirectDependencies);
	}
	private void configureJarManifest(Project project) {
		project.getTasks().withType(Jar.class, (jar) -> project.afterEvaluate((evaluated) -> {
			jar.manifest((manifest) -> {
				Map<String, Object> attributes = new TreeMap<>();
				attributes.put('Spring-Boot-Jar-Type', JAR_TYPE);
				manifest.attributes(attributes);
			});
		}));
	}
}
/*
package org.springframework.boot.build.devtools;
/**
public abstract class DocumentDevtoolsPropertyDefaults extends DefaultTask {
	private final Configuration devtools;
	public DocumentDevtoolsPropertyDefaults() {
		this.devtools = getProject().getConfigurations().create('devtools');
		getOutputFile().convention(getProject().getLayout()
			.getBuildDirectory()
			.file('generated/docs/using/devtools-property-defaults.adoc'));
		Map<String, String> dependency = new HashMap<>();
		dependency.put('path', ':spring-boot-project:spring-boot-devtools');
		dependency.put('configuration', 'propertyDefaults');
		this.devtools.getDependencies().add(getProject().getDependencies().project(dependency));
	}
	@InputFiles
	public FileCollection getDevtools() {
		return this.devtools;
	}
	@OutputFile
	public abstract RegularFileProperty getOutputFile();
	@TaskAction
	void documentPropertyDefaults() throws IOException {
		Map<String, String> properties = loadProperties();
		documentProperties(properties);
	}
	private Map<String, String> loadProperties() throws IOException, FileNotFoundException {
		Properties properties = new Properties();
		Map<String, String> sortedProperties = new TreeMap<>();
		try (FileInputStream stream = new FileInputStream(this.devtools.getSingleFile())) {
			properties.load(stream);
			for (String name : properties.stringPropertyNames()) {
				sortedProperties.put(name, properties.getProperty(name));
			}
		}
		return sortedProperties;
	}
	private void documentProperties(Map<String, String> properties) throws IOException {
		try (PrintWriter writer = new PrintWriter(new FileWriter(getOutputFile().getAsFile().get()))) {
			writer.println('[cols=\'3,1\']');
			writer.println('|===');
			writer.println('| Name | Default Value');
			properties.forEach((name, value) -> {
				writer.println();
				writer.printf('| `%s`%n', name);
				writer.printf('| `%s`%n', value);
			});
			writer.println('|===');
		}
	}
}
/*
package org.springframework.boot.build.docs;
/**
public abstract class ApplicationRunner extends DefaultTask {
	private FileCollection classpath;
	public ApplicationRunner() {
		getApplicationJar().convention('/opt/apps/myapp.jar');
	}
	@OutputFile
	public abstract RegularFileProperty getOutput();
	@Classpath
	public FileCollection getClasspath() {
		return this.classpath;
	}
	public void setClasspath(FileCollection classpath) {
		this.classpath = classpath;
	}
	@Input
	public abstract ListProperty<String> getArgs();
	@Input
	public abstract Property<String> getMainClass();
	@Input
	public abstract Property<String> getExpectedLogging();
	@Input
	abstract MapProperty<String, String> getNormalizations();
	@Input
	abstract Property<String> getApplicationJar();
	public void normalizeTomcatPort() {
		getNormalizations().put('(Tomcat started on port )[\\d]+( \\(http\\))', '$18080$2');
		getNormalizations().put('(Tomcat initialized with port )[\\d]+( \\(http\\))', '$18080$2');
	}
	public void normalizeLiveReloadPort() {
		getNormalizations().put('(LiveReload server is running on port )[\\d]+', '$135729');
	}
	@TaskAction
	void runApplication() throws IOException {
		List<String> command = new ArrayList<>();
		File executable = Jvm.current().getExecutable('java');
		command.add(executable.getAbsolutePath());
		command.add('-cp');
		command.add(this.classpath.getFiles()
			.stream()
			.map(File::getAbsolutePath)
			.collect(Collectors.joining(File.pathSeparator)));
		command.add(getMainClass().get());
		command.addAll(getArgs().get());
		File outputFile = getOutput().getAsFile().get();
		Process process = new ProcessBuilder().redirectOutput(outputFile)
			.redirectError(outputFile)
			.command(command)
			.start();
		awaitLogging(process);
		process.destroy();
		normalizeLogging();
	}
	private void awaitLogging(Process process) {
		long end = System.currentTimeMillis() + 60000;
		String expectedLogging = getExpectedLogging().get();
		while (System.currentTimeMillis() < end) {
			for (String line : outputLines()) {
				if (line.contains(expectedLogging)) {
					return;
				}
			}
			if (!process.isAlive()) {
				throw new IllegalStateException('Process exited before "' + expectedLogging + '" was logged');
			}
		}
		throw new IllegalStateException('"' + expectedLogging + '" was not logged within 60 seconds');
	}
	private List<String> outputLines() {
		Path outputPath = getOutput().get().getAsFile().toPath();
		try {
			return Files.readAllLines(outputPath);
		}
		catch (IOException ex) {
			throw new RuntimeException('Failed to read lines of output from "' + outputPath + '"', ex);
		}
	}
	private void normalizeLogging() {
		List<String> outputLines = outputLines();
		List<String> normalizedLines = normalize(outputLines);
		Path outputPath = getOutput().get().getAsFile().toPath();
		try {
			Files.write(outputPath, normalizedLines);
		}
		catch (IOException ex) {
			throw new RuntimeException('Failed to write normalized lines of output to "' + outputPath + '"', ex);
		}
	}
	private List<String> normalize(List<String> lines) {
		List<String> normalizedLines = lines;
		Map<String, String> normalizations = new HashMap<>(getNormalizations().get());
		normalizations.put('(Starting .* using Java .* with PID [\\d]+ \\().*( started by ).*( in ).*(\\))',
				'$1' + getApplicationJar().get() + '$2myuser$3/opt/apps/$4');
		for (Entry<String, String> normalization : normalizations.entrySet()) {
			Pattern pattern = Pattern.compile(normalization.getKey());
			normalizedLines = normalize(normalizedLines, pattern, normalization.getValue());
		}
		return normalizedLines;
	}
	private List<String> normalize(List<String> lines, Pattern pattern, String replacement) {
		boolean matched = false;
		List<String> normalizedLines = new ArrayList<>();
		for (String line : lines) {
			Matcher matcher = pattern.matcher(line);
			StringBuilder transformed = new StringBuilder();
			while (matcher.find()) {
				matched = true;
				matcher.appendReplacement(transformed, replacement);
			}
			matcher.appendTail(transformed);
			normalizedLines.add(transformed.toString());
		}
		if (!matched) {
			reportUnmatchedNormalization(lines, pattern);
		}
		return normalizedLines;
	}
	private void reportUnmatchedNormalization(List<String> lines, Pattern pattern) {
		StringBuilder message = new StringBuilder(
				'"' + pattern + '" did not match any of the following lines of output:');
		message.append(String.format('%n'));
		for (String line : lines) {
			message.append(String.format('%s%n', line));
		}
		throw new IllegalStateException(message.toString());
	}
}
/*
package org.springframework.boot.build;
/**
public class DeployedPlugin implements Plugin<Project> {
	/**
	 * Name of the task that generates the deployed pom file.
	 */
	public static final String GENERATE_POM_TASK_NAME = 'generatePomFileForMavenPublication';
	@Override
	@SuppressWarnings('deprecation')
	public void apply(Project project) {
		project.getPlugins().apply(MavenPublishPlugin.class);
		project.getPlugins().apply(MavenRepositoryPlugin.class);
		PublishingExtension publishing = project.getExtensions().getByType(PublishingExtension.class);
		MavenPublication mavenPublication = publishing.getPublications().create('maven', MavenPublication.class);
		project.afterEvaluate((evaluated) -> project.getPlugins().withType(JavaPlugin.class).all((javaPlugin) -> {
			if (((Jar) project.getTasks().getByName(JavaPlugin.JAR_TASK_NAME)).isEnabled()) {
				project.getComponents()
					.matching((component) -> component.getName().equals('java'))
					.all(mavenPublication::from);
			}
		}));
		project.getPlugins()
			.withType(JavaPlatformPlugin.class)
			.all((javaPlugin) -> project.getComponents()
				.matching((component) -> component.getName().equals('javaPlatform'))
				.all(mavenPublication::from));
	}
}
/*
package org.springframework.boot.build.toolchain;
/**
public class ToolchainExtension {
	private final Property<JavaLanguageVersion> maximumCompatibleJavaVersion;
	private final ListProperty<String> testJvmArgs;
	private final JavaLanguageVersion javaVersion;
	public ToolchainExtension(Project project) {
		this.maximumCompatibleJavaVersion = project.getObjects().property(JavaLanguageVersion.class);
		this.testJvmArgs = project.getObjects().listProperty(String.class);
		String toolchainVersion = (String) project.findProperty('toolchainVersion');
		this.javaVersion = (toolchainVersion != null) ? JavaLanguageVersion.of(toolchainVersion) : null;
	}
	public Property<JavaLanguageVersion> getMaximumCompatibleJavaVersion() {
		return this.maximumCompatibleJavaVersion;
	}
	public ListProperty<String> getTestJvmArgs() {
		return this.testJvmArgs;
	}
	JavaLanguageVersion getJavaVersion() {
		return this.javaVersion;
	}
}
/*
package org.springframework.boot.build.toolchain;
/**
public class ToolchainPlugin implements Plugin<Project> {
	@Override
	public void apply(Project project) {
		configureToolchain(project);
	}
	private void configureToolchain(Project project) {
		ToolchainExtension toolchain = project.getExtensions().create('toolchain', ToolchainExtension.class, project);
		JavaLanguageVersion toolchainVersion = toolchain.getJavaVersion();
		if (toolchainVersion != null) {
			project.afterEvaluate((evaluated) -> configure(evaluated, toolchain));
		}
	}
	private void configure(Project project, ToolchainExtension toolchain) {
		if (!isJavaVersionSupported(toolchain, toolchain.getJavaVersion())) {
			disableToolchainTasks(project);
		}
		else {
			JavaToolchainSpec toolchainSpec = project.getExtensions()
				.getByType(JavaPluginExtension.class)
				.getToolchain();
			toolchainSpec.getLanguageVersion().set(toolchain.getJavaVersion());
			configureTestToolchain(project, toolchain);
		}
	}
	private boolean isJavaVersionSupported(ToolchainExtension toolchain, JavaLanguageVersion toolchainVersion) {
		return toolchain.getMaximumCompatibleJavaVersion()
			.map((version) -> version.canCompileOrRun(toolchainVersion))
			.getOrElse(true);
	}
	private void disableToolchainTasks(Project project) {
		project.getTasks().withType(Test.class, (task) -> task.setEnabled(false));
	}
	private void configureTestToolchain(Project project, ToolchainExtension toolchain) {
		List<String> jvmArgs = new ArrayList<>(toolchain.getTestJvmArgs().getOrElse(Collections.emptyList()));
		project.getTasks().withType(Test.class, (test) -> test.jvmArgs(jvmArgs));
	}
}
/*
package org.springframework.boot.build;
/**
class KotlinConventions {
	void apply(Project project) {
		project.getPlugins().withId('org.jetbrains.kotlin.jvm', (plugin) -> {
			project.getTasks().withType(KotlinCompile.class, this::configure);
			project.getPlugins().withType(DokkatooHtmlPlugin.class, (dokkatooPlugin) -> configureDokkatoo(project));
		});
	}
	private void configure(KotlinCompile compile) {
		KotlinJvmOptions kotlinOptions = compile.getKotlinOptions();
		kotlinOptions.setApiVersion('1.7');
		kotlinOptions.setLanguageVersion('1.7');
		kotlinOptions.setJvmTarget('17');
		kotlinOptions.setAllWarningsAsErrors(true);
		List<String> freeCompilerArgs = new ArrayList<>(kotlinOptions.getFreeCompilerArgs());
		freeCompilerArgs.add('-Xsuppress-version-warnings');
		kotlinOptions.setFreeCompilerArgs(freeCompilerArgs);
	}
	private void configureDokkatoo(Project project) {
		DokkatooExtension dokkatoo = project.getExtensions().getByType(DokkatooExtension.class);
		dokkatoo.getDokkatooSourceSets().configureEach((sourceSet) -> {
			if (SourceSet.MAIN_SOURCE_SET_NAME.equals(sourceSet.getName())) {
				sourceSet.getSourceRoots().setFrom(project.file('src/main/kotlin'));
				sourceSet.getClasspath()
					.from(project.getExtensions()
						.getByType(SourceSetContainer.class)
						.getByName(SourceSet.MAIN_SOURCE_SET_NAME)
						.getOutput());
				sourceSet.getExternalDocumentationLinks().create('spring-boot-javadoc', (link) -> {
					link.getUrl().set(URI.create('https://docs.spring.io/spring-boot/api/java/'));
					link.getPackageListUrl()
						.set(URI.create('https://docs.spring.io/spring-boot/api/java/element-list'));
				});
				sourceSet.getExternalDocumentationLinks().create('spring-framework-javadoc', (link) -> {
					String url = 'https://docs.spring.io/spring-framework/docs/%s/javadoc-api/'
						.formatted(project.property('springFrameworkVersion'));
					link.getUrl().set(URI.create(url));
					link.getPackageListUrl().set(URI.create(url + '/element-list'));
				});
			}
		});
	}
}
/*
package org.springframework.boot.build;
/**
public class ConventionsPlugin implements Plugin<Project> {
	@Override
	public void apply(Project project) {
		new NoHttpConventions().apply(project);
		new JavaConventions().apply(project);
		new MavenPublishingConventions().apply(project);
		new AntoraConventions().apply(project);
		new KotlinConventions().apply(project);
		new WarConventions().apply(project);
		new EclipseConventions().apply(project);
		RepositoryTransformersExtension.apply(project);
	}
}
/*
package org.springframework.boot.build;
/**
public abstract class SyncAppSource extends DefaultTask {
	private final FileSystemOperations fileSystemOperations;
	@Inject
	public SyncAppSource(FileSystemOperations fileSystemOperations) {
		getPluginVersion().convention(getProject().provider(() -> getProject().getVersion().toString()));
		this.fileSystemOperations = fileSystemOperations;
	}
	@InputDirectory
	public abstract DirectoryProperty getSourceDirectory();
	@OutputDirectory
	public abstract DirectoryProperty getDestinationDirectory();
	@Input
	public abstract Property<String> getPluginVersion();
	@TaskAction
	void syncAppSources() {
		this.fileSystemOperations.sync((copySpec) -> {
			copySpec.from(getSourceDirectory());
			copySpec.into(getDestinationDirectory());
			copySpec.filter((line) -> line.replace('id \'org.springframework.boot\'',
					'id \'org.springframework.boot\' version \'' + getPluginVersion().get() + '\''));
		});
	}
}
/*
package org.springframework.boot.build;
/**
public abstract class ExtractResources extends DefaultTask {
	private final PropertyPlaceholderHelper propertyPlaceholderHelper = new PropertyPlaceholderHelper('${', '}');
	@Input
	public abstract ListProperty<String> getResourceNames();
	@OutputDirectory
	public abstract DirectoryProperty getDestinationDirectory();
	@Input
	public abstract MapProperty<String, String> getProperties();
	@TaskAction
	void extractResources() throws IOException {
		for (String resourceName : getResourceNames().get()) {
			InputStream resourceStream = getClass().getClassLoader().getResourceAsStream(resourceName);
			if (resourceStream == null) {
				throw new GradleException('Resource "' + resourceName + '" does not exist');
			}
			String resource = FileCopyUtils.copyToString(new InputStreamReader(resourceStream, StandardCharsets.UTF_8));
			resource = this.propertyPlaceholderHelper.replacePlaceholders(resource, getProperties().get()::get);
			FileCopyUtils.copy(resource,
					new FileWriter(getDestinationDirectory().file(resourceName).get().getAsFile()));
		}
	}
}
/*
package org.springframework.boot.build.artifacts;
/**
public final class ArtifactRelease {
	private static final String SPRING_REPO = 'https://repo.spring.io/%s';
	private static final String MAVEN_REPO = 'https://repo.maven.apache.org/maven2';
	private final Type type;
	private ArtifactRelease(Type type) {
		this.type = type;
	}
	public String getType() {
		return this.type.toString().toLowerCase(Locale.ROOT);
	}
	public String getDownloadRepo() {
		return (this.isRelease()) ? MAVEN_REPO : String.format(SPRING_REPO, this.getType());
	}
	public boolean isRelease() {
		return this.type == Type.RELEASE;
	}
	public static ArtifactRelease forProject(Project project) {
		return forVersion(project.getVersion().toString());
	}
	public static ArtifactRelease forVersion(String version) {
		return new ArtifactRelease(Type.forVersion(version));
	}
	enum Type {
		SNAPSHOT, MILESTONE, RELEASE;
		static Type forVersion(String version) {
			int modifierIndex = version.lastIndexOf("-");
			if (modifierIndex == -1) {
				return RELEASE;
			}
			String type = version.substring(modifierIndex + 1);
			if (type.startsWith('M') || type.startsWith('RC')) {
				return MILESTONE;
			}
			return SNAPSHOT;
		}
	}
}
/*
package org.springframework.boot.build.architecture;
/**
public abstract class ArchitectureCheck extends DefaultTask {
	private FileCollection classes;
	public ArchitectureCheck() {
		getOutputDirectory().convention(getProject().getLayout().getBuildDirectory().dir(getName()));
		getProhibitObjectsRequireNonNull().convention(true);
		getRules().addAll(allPackagesShouldBeFreeOfTangles(),
				allBeanPostProcessorBeanMethodsShouldBeStaticAndHaveParametersThatWillNotCausePrematureInitialization(),
				allBeanFactoryPostProcessorBeanMethodsShouldBeStaticAndHaveNoParameters(),
				noClassesShouldCallStepVerifierStepVerifyComplete(),
				noClassesShouldConfigureDefaultStepVerifierTimeout(), noClassesShouldCallCollectorsToList(),
				noClassesShouldCallURLEncoderWithStringEncoding(), noClassesShouldCallURLDecoderWithStringEncoding(),
				noClassesShouldLoadResourcesUsingResourceUtils(), noClassesShouldCallStringToUpperCaseWithoutLocale(),
				noClassesShouldCallStringToLowerCaseWithoutLocale());
		getRules().addAll(getProhibitObjectsRequireNonNull()
			.map((prohibit) -> prohibit ? noClassesShouldCallObjectsRequireNonNull() : Collections.emptyList()));
		getRuleDescriptions().set(getRules().map((rules) -> rules.stream().map(ArchRule::getDescription).toList()));
	}
	@TaskAction
	void checkArchitecture() throws IOException {
		JavaClasses javaClasses = new ClassFileImporter()
			.importPaths(this.classes.getFiles().stream().map(File::toPath).toList());
		List<EvaluationResult> violations = getRules().get()
			.stream()
			.map((rule) -> rule.evaluate(javaClasses))
			.filter(EvaluationResult::hasViolation)
			.toList();
		File outputFile = getOutputDirectory().file('failure-report.txt').get().getAsFile();
		outputFile.getParentFile().mkdirs();
		if (!violations.isEmpty()) {
			StringBuilder report = new StringBuilder();
			for (EvaluationResult violation : violations) {
				report.append(violation.getFailureReport());
				report.append(String.format('%n'));
			}
			Files.writeString(outputFile.toPath(), report.toString(), StandardOpenOption.CREATE,
					StandardOpenOption.TRUNCATE_EXISTING);
			throw new GradleException('Architecture check failed. See "' + outputFile + '" for details.');
		}
		else {
			outputFile.createNewFile();
		}
	}
	private ArchRule allPackagesShouldBeFreeOfTangles() {
		return SlicesRuleDefinition.slices().matching('(**)').should().beFreeOfCycles();
	}
	private ArchRule allBeanPostProcessorBeanMethodsShouldBeStaticAndHaveParametersThatWillNotCausePrematureInitialization() {
		return ArchRuleDefinition.methods()
			.that()
			.areAnnotatedWith('org.springframework.context.annotation.Bean')
			.and()
			.haveRawReturnType(Predicates.assignableTo('org.springframework.beans.factory.config.BeanPostProcessor'))
			.should(onlyHaveParametersThatWillNotCauseEagerInitialization())
			.andShould()
			.beStatic()
			.allowEmptyShould(true);
	}
	private ArchCondition<JavaMethod> onlyHaveParametersThatWillNotCauseEagerInitialization() {
		DescribedPredicate<CanBeAnnotated> notAnnotatedWithLazy = DescribedPredicate
			.not(CanBeAnnotated.Predicates.annotatedWith('org.springframework.context.annotation.Lazy'));
		DescribedPredicate<JavaClass> notOfASafeType = DescribedPredicate
			.not(Predicates.assignableTo('org.springframework.beans.factory.ObjectProvider')
				.or(Predicates.assignableTo('org.springframework.context.ApplicationContext'))
				.or(Predicates.assignableTo('org.springframework.core.env.Environment')));
		return new ArchCondition<>('not have parameters that will cause eager initialization') {
			@Override
			public void check(JavaMethod item, ConditionEvents events) {
				item.getParameters()
					.stream()
					.filter(notAnnotatedWithLazy)
					.filter((parameter) -> notOfASafeType.test(parameter.getRawType()))
					.forEach((parameter) -> events.add(SimpleConditionEvent.violated(parameter,
							parameter.getDescription() + ' will cause eager initialization as it is '
									+ notAnnotatedWithLazy.getDescription() + ' and is '
									+ notOfASafeType.getDescription())));
			}
		};
	}
	private ArchRule allBeanFactoryPostProcessorBeanMethodsShouldBeStaticAndHaveNoParameters() {
		return ArchRuleDefinition.methods()
			.that()
			.areAnnotatedWith('org.springframework.context.annotation.Bean')
			.and()
			.haveRawReturnType(
					Predicates.assignableTo('org.springframework.beans.factory.config.BeanFactoryPostProcessor'))
			.should(onlyInjectEnvironment())
			.andShould()
			.beStatic()
			.allowEmptyShould(true);
	}
	private ArchCondition<JavaMethod> onlyInjectEnvironment() {
		return new ArchCondition<>('only inject Environment') {
			@Override
			public void check(JavaMethod item, ConditionEvents events) {
				List<JavaParameter> parameters = item.getParameters();
				for (JavaParameter parameter : parameters) {
					if (!'org.springframework.core.env.Environment'.equals(parameter.getType().getName())) {
						events.add(SimpleConditionEvent.violated(item,
								item.getDescription() + ' should only inject Environment'));
					}
				}
			}
		};
	}
	private ArchRule noClassesShouldCallStringToLowerCaseWithoutLocale() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethod(String.class, 'toLowerCase')
			.because('String.toLowerCase(Locale.ROOT) should be used instead');
	}
	private ArchRule noClassesShouldCallStringToUpperCaseWithoutLocale() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethod(String.class, 'toUpperCase')
			.because('String.toUpperCase(Locale.ROOT) should be used instead');
	}
	private ArchRule noClassesShouldCallStepVerifierStepVerifyComplete() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethod('reactor.test.StepVerifier$Step', 'verifyComplete')
			.because('it can block indefinitely and expectComplete().verify(Duration) should be used instead');
	}
	private ArchRule noClassesShouldConfigureDefaultStepVerifierTimeout() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethod('reactor.test.StepVerifier', 'setDefaultTimeout', 'java.time.Duration')
			.because('expectComplete().verify(Duration) should be used instead');
	}
	private ArchRule noClassesShouldCallCollectorsToList() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethod(Collectors.class, 'toList')
			.because('java.util.stream.Stream.toList() should be used instead');
	}
	private ArchRule noClassesShouldCallURLEncoderWithStringEncoding() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethod(URLEncoder.class, 'encode', String.class, String.class)
			.because('java.net.URLEncoder.encode(String s, Charset charset) should be used instead');
	}
	private ArchRule noClassesShouldCallURLDecoderWithStringEncoding() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethod(URLDecoder.class, 'decode', String.class, String.class)
			.because('java.net.URLDecoder.decode(String s, Charset charset) should be used instead');
	}
	private ArchRule noClassesShouldLoadResourcesUsingResourceUtils() {
		return ArchRuleDefinition.noClasses()
			.should()
			.callMethodWhere(JavaCall.Predicates.target(With.owner(Predicates.type(ResourceUtils.class)))
				.and(JavaCall.Predicates.target(HasName.Predicates.name('getURL')))
				.and(JavaCall.Predicates.target(HasParameterTypes.Predicates.rawParameterTypes(String.class)))
				.or(JavaCall.Predicates.target(With.owner(Predicates.type(ResourceUtils.class)))
					.and(JavaCall.Predicates.target(HasName.Predicates.name('getFile')))
					.and(JavaCall.Predicates.target(HasParameterTypes.Predicates.rawParameterTypes(String.class)))))
			.because('org.springframework.boot.io.ApplicationResourceLoader should be used instead');
	}
	private List<ArchRule> noClassesShouldCallObjectsRequireNonNull() {
		return List.of(
				ArchRuleDefinition.noClasses()
					.should()
					.callMethod(Objects.class, 'requireNonNull', Object.class, String.class)
					.because('org.springframework.utils.Assert.notNull(Object, String) should be used instead'),
				ArchRuleDefinition.noClasses()
					.should()
					.callMethod(Objects.class, 'requireNonNull', Object.class, Supplier.class)
					.because('org.springframework.utils.Assert.notNull(Object, Supplier) should be used instead'));
	}
	public void setClasses(FileCollection classes) {
		this.classes = classes;
	}
	@Internal
	public FileCollection getClasses() {
		return this.classes;
	}
	@InputFiles
	@SkipWhenEmpty
	@IgnoreEmptyDirectories
	@PathSensitive(PathSensitivity.RELATIVE)
	final FileTree getInputClasses() {
		return this.classes.getAsFileTree();
	}
	@Optional
	@InputFiles
	@PathSensitive(PathSensitivity.RELATIVE)
	public abstract DirectoryProperty getResourcesDirectory();
	@OutputDirectory
	public abstract DirectoryProperty getOutputDirectory();
	@Internal
	public abstract ListProperty<ArchRule> getRules();
	@Internal
	public abstract Property<Boolean> getProhibitObjectsRequireNonNull();
	@Input
	// The rules themselves can"t be an input as they aren"t serializable so we use
	// their descriptions instead
	abstract ListProperty<String> getRuleDescriptions();
}
/*
package org.springframework.boot.build.architecture;
/**
public class ArchitecturePlugin implements Plugin<Project> {
	@Override
	public void apply(Project project) {
		project.getPlugins().withType(JavaPlugin.class, (javaPlugin) -> registerTasks(project));
	}
	private void registerTasks(Project project) {
		JavaPluginExtension javaPluginExtension = project.getExtensions().getByType(JavaPluginExtension.class);
		List<TaskProvider<ArchitectureCheck>> packageTangleChecks = new ArrayList<>();
		for (SourceSet sourceSet : javaPluginExtension.getSourceSets()) {
			TaskProvider<ArchitectureCheck> checkPackageTangles = project.getTasks()
				.register('checkArchitecture' + StringUtils.capitalize(sourceSet.getName()), ArchitectureCheck.class,
						(task) -> {
							task.setClasses(sourceSet.getOutput().getClassesDirs());
							task.getResourcesDirectory().set(sourceSet.getOutput().getResourcesDir());
							task.dependsOn(sourceSet.getProcessResourcesTaskName());
							task.setDescription('Checks the architecture of the classes of the ' + sourceSet.getName()
									+ ' source set.');
							task.setGroup(LifecycleBasePlugin.VERIFICATION_GROUP);
						});
			packageTangleChecks.add(checkPackageTangles);
		}
		if (!packageTangleChecks.isEmpty()) {
			TaskProvider<Task> checkTask = project.getTasks().named(LifecycleBasePlugin.CHECK_TASK_NAME);
			checkTask.configure((check) -> check.dependsOn(packageTangleChecks));
		}
	}
}
