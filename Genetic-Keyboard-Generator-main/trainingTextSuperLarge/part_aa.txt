/*
package org.springframework.boot.docker.compose.service.connection.clickhouse;
/**
class ClickHouseJdbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'clickhouse-compose.yaml', image = TestImage.CLICKHOUSE)
	void runCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) throws ClassNotFoundException {
		assertConnectionDetails(connectionDetails);
		checkDatabaseAccess(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'clickhouse-bitnami-compose.yaml', image = TestImage.BITNAMI_CLICKHOUSE)
	void runWithBitnamiImageCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
		// See https://github.com/bitnami/containers/issues/73550
		// checkDatabaseAccess(connectionDetails);
	}
	private void assertConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:clickhouse://').endsWith('/mydatabase');
	}
	@SuppressWarnings('unchecked')
	private void checkDatabaseAccess(JdbcConnectionDetails connectionDetails) throws ClassNotFoundException {
		SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
		dataSource.setUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClass((Class<? extends Driver>) ClassUtils.forName(connectionDetails.getDriverClassName(),
				getClass().getClassLoader()));
		JdbcTemplate template = new JdbcTemplate(dataSource);
		assertThat(template.queryForObject(DatabaseDriver.CLICKHOUSE.getValidationQuery(), Integer.class)).isEqualTo(1);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.clickhouse;
/**
class ClickHouseR2dbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'clickhouse-compose.yaml', image = TestImage.CLICKHOUSE)
	void runCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
		checkDatabaseAccess(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'clickhouse-bitnami-compose.yaml', image = TestImage.BITNAMI_CLICKHOUSE)
	void runWithBitnamiImageCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
		// See https://github.com/bitnami/containers/issues/73550
		// checkDatabaseAccess(connectionDetails);
	}
	private void assertConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.toString()).contains('database=mydatabase', 'driver=clickhouse',
				'password=REDACTED', 'user=myuser');
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('secret');
	}
	private void checkDatabaseAccess(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		ConnectionFactory connectionFactory = ConnectionFactories.get(connectionFactoryOptions);
		String sql = DatabaseDriver.CLICKHOUSE.getValidationQuery();
		Integer result = Mono.from(connectionFactory.create())
			.flatMapMany((connection) -> connection.createStatement(sql).execute())
			.flatMap((r) -> r.map((row, rowMetadata) -> row.get(0, Integer.class)))
			.blockFirst(Duration.ofSeconds(30));
		assertThat(result).isEqualTo(1);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.cassandra;
/**
class CassandraDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'cassandra-compose.yaml', image = TestImage.CASSANDRA)
	void runCreatesConnectionDetails(CassandraConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'cassandra-bitnami-compose.yaml', image = TestImage.BITNAMI_CASSANDRA)
	void runWithBitnamiImageCreatesConnectionDetails(CassandraConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(CassandraConnectionDetails connectionDetails) {
		List<Node> contactPoints = connectionDetails.getContactPoints();
		assertThat(contactPoints).hasSize(1);
		Node node = contactPoints.get(0);
		assertThat(node.host()).isNotNull();
		assertThat(node.port()).isGreaterThan(0);
		assertThat(connectionDetails.getUsername()).isNull();
		assertThat(connectionDetails.getPassword()).isNull();
		assertThat(connectionDetails.getLocalDatacenter()).isEqualTo('testdc1');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The Oracle image has no ARM support')
class OracleFreeR2dbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'oracle-compose.yaml', image = TestImage.ORACLE_FREE)
	void runCreatesConnectionDetailsThatCanBeUsedToAccessDatabase(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.toString()).contains('database=freepdb1', 'driver=oracle',
				'password=REDACTED', 'user=app_user');
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD))
			.isEqualTo('app_user_secret');
		Awaitility.await().atMost(Duration.ofMinutes(1)).ignoreExceptions().untilAsserted(() -> {
			Object result = DatabaseClient.create(ConnectionFactories.get(connectionFactoryOptions))
				.sql(DatabaseDriver.ORACLE.getValidationQuery())
				.map((row, metadata) -> row.get(0))
				.first()
				.block(Duration.ofSeconds(30));
			assertThat(result).isEqualTo('Hello');
		});
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The Oracle image has no ARM support')
class OracleXeJdbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@SuppressWarnings('unchecked')
	@DockerComposeTest(composeFile = 'oracle-compose.yaml', image = TestImage.ORACLE_XE)
	void runCreatesConnectionDetailsThatCanBeUsedToAccessDatabase(JdbcConnectionDetails connectionDetails)
			throws Exception {
		assertThat(connectionDetails.getUsername()).isEqualTo('app_user');
		assertThat(connectionDetails.getPassword()).isEqualTo('app_user_secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:oracle:thin:@').endsWith('/xepdb1');
		SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
		dataSource.setUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClass((Class<? extends Driver>) ClassUtils.forName(connectionDetails.getDriverClassName(),
				getClass().getClassLoader()));
		Awaitility.await().atMost(Duration.ofMinutes(1)).ignoreExceptions().untilAsserted(() -> {
			JdbcTemplate template = new JdbcTemplate(dataSource);
			assertThat(template.queryForObject(DatabaseDriver.ORACLE.getValidationQuery(), String.class))
				.isEqualTo('Hello');
		});
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The Oracle image has no ARM support')
class OracleXeR2dbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'oracle-compose.yaml', image = TestImage.ORACLE_XE)
	void runCreatesConnectionDetailsThatCanBeUsedToAccessDatabase(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.toString()).contains('database=xepdb1', 'driver=oracle',
				'password=REDACTED', 'user=app_user');
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD))
			.isEqualTo('app_user_secret');
		Awaitility.await().atMost(Duration.ofMinutes(1)).ignoreExceptions().untilAsserted(() -> {
			Object result = DatabaseClient.create(ConnectionFactories.get(connectionFactoryOptions))
				.sql(DatabaseDriver.ORACLE.getValidationQuery())
				.map((row, metadata) -> row.get(0))
				.first()
				.block(Duration.ofSeconds(30));
			assertThat(result).isEqualTo('Hello');
		});
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The Oracle image has no ARM support')
class OracleFreeJdbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@SuppressWarnings('unchecked')
	@DockerComposeTest(composeFile = 'oracle-compose.yaml', image = TestImage.ORACLE_FREE)
	void runCreatesConnectionDetailsThatCanBeUsedToAccessDatabase(JdbcConnectionDetails connectionDetails)
			throws Exception {
		assertThat(connectionDetails.getUsername()).isEqualTo('app_user');
		assertThat(connectionDetails.getPassword()).isEqualTo('app_user_secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:oracle:thin:@').endsWith('/freepdb1');
		SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
		dataSource.setUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClass((Class<? extends Driver>) ClassUtils.forName(connectionDetails.getDriverClassName(),
				getClass().getClassLoader()));
		Awaitility.await().atMost(Duration.ofMinutes(1)).ignoreExceptions().untilAsserted(() -> {
			JdbcTemplate template = new JdbcTemplate(dataSource);
			assertThat(template.queryForObject(DatabaseDriver.ORACLE.getValidationQuery(), String.class))
				.isEqualTo('Hello');
		});
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.test;
/**
class DockerComposeTestExtension implements BeforeTestExecutionCallback, AfterTestExecutionCallback, ParameterResolver {
	private static final Namespace NAMESPACE = Namespace.create(DockerComposeTestExtension.class);
	private static final String STORE_KEY_COMPOSE_FILE = 'compose-file';
	private static final String STORE_KEY_APPLICATION_CONTEXT = 'application-context';
	@Override
	public void beforeTestExecution(ExtensionContext context) throws Exception {
		Path transformedComposeFile = prepareComposeFile(context);
		Store store = context.getStore(NAMESPACE);
		store.put(STORE_KEY_COMPOSE_FILE, transformedComposeFile);
		try {
			SpringApplication application = prepareApplication(transformedComposeFile);
			store.put(STORE_KEY_APPLICATION_CONTEXT, application.run());
		}
		catch (Exception ex) {
			cleanUp(context);
			throw ex;
		}
	}
	private Path prepareComposeFile(ExtensionContext context) {
		DockerComposeTest dockerComposeTest = context.getRequiredTestMethod().getAnnotation(DockerComposeTest.class);
		TestImage image = dockerComposeTest.image();
		Resource composeResource = new ClassPathResource(dockerComposeTest.composeFile(),
				context.getRequiredTestClass());
		return transformedComposeFile(composeResource, image);
	}
	private Path transformedComposeFile(Resource composeFileResource, TestImage image) {
		try {
			Path composeFile = composeFileResource.getFile().toPath();
			Path transformedComposeFile = Files.createTempFile('', '-' + composeFile.getFileName().toString());
			String transformedContent = Files.readString(composeFile).replace('{imageName}', image.toString());
			Files.writeString(transformedComposeFile, transformedContent);
			return transformedComposeFile;
		}
		catch (IOException ex) {
			fail('Error transforming Docker compose file "' + composeFileResource + '": ' + ex.getMessage());
		}
		return null;
	}
	private SpringApplication prepareApplication(Path transformedComposeFile) {
		SpringApplication application = new SpringApplication(Config.class);
		Map<String, Object> properties = new LinkedHashMap<>();
		properties.put('spring.docker.compose.skip.in-tests', 'false');
		properties.put('spring.docker.compose.file', transformedComposeFile);
		properties.put('spring.docker.compose.stop.command', 'down');
		application.setDefaultProperties(properties);
		return application;
	}
	@Override
	public void afterTestExecution(ExtensionContext context) throws Exception {
		cleanUp(context);
	}
	private void cleanUp(ExtensionContext context) throws Exception {
		Store store = context.getStore(NAMESPACE);
		runShutdownHandlers();
		deleteComposeFile(store);
	}
	private void runShutdownHandlers() {
		SpringApplicationShutdownHandlers shutdownHandlers = SpringApplication.getShutdownHandlers();
		((Runnable) shutdownHandlers).run();
	}
	private void deleteComposeFile(Store store) throws IOException {
		Path composeFile = store.get(STORE_KEY_COMPOSE_FILE, Path.class);
		if (composeFile != null) {
			Files.delete(composeFile);
		}
	}
	@Override
	public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
			throws ParameterResolutionException {
		return true;
	}
	@Override
	public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
			throws ParameterResolutionException {
		ConfigurableApplicationContext applicationContext = extensionContext.getStore(NAMESPACE)
			.get(STORE_KEY_APPLICATION_CONTEXT, ConfigurableApplicationContext.class);
		return (applicationContext != null) ? applicationContext.getBean(parameterContext.getParameter().getType())
				: null;
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.test;
/**
@Test
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ExtendWith(DockerComposeTestExtension.class)
@DisabledIfDockerUnavailable
@DisabledIfProcessUnavailable({ 'docker', 'compose' })
public @interface DockerComposeTest {
	/**
	 * The name of the compose file to use. Loaded as a classpath resource relative to the
	 * test class. The image name in the compose file can be parameterized using
	 * <code>{image}</code> and it will be replaced using the specified {@link #image}
	 * reference.
	 * @return the compose file
	 */
	String composeFile();
	/**
	 * The Docker image reference.
	 * @return the Docker image reference
	 * @see TestImage
	 */
	TestImage image();
}
/*
package org.springframework.boot.docker.compose.service.connection.zipkin;
/**
class ZipkinDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'zipkin-compose.yaml', image = TestImage.ZIPKIN)
	void runCreatesConnectionDetails(ZipkinConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getSpanEndpoint()).startsWith('http://').endsWith('/api/v2/spans');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mariadb;
/**
class MariaDbR2dbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'mariadb-compose.yaml', image = TestImage.MARIADB)
	void runCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'mariadb-bitnami-compose.yaml', image = TestImage.BITNAMI_MARIADB)
	void runWithBitnamiImageCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.toString()).contains('database=mydatabase', 'driver=mariadb',
				'password=REDACTED', 'user=myuser');
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mariadb;
/**
class MariaDbJdbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'mariadb-compose.yaml', image = TestImage.MARIADB)
	void runCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'mariadb-bitnami-compose.yaml', image = TestImage.BITNAMI_MARIADB)
	void runWithBitnamiImageCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:mariadb://').endsWith('/mydatabase');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.pulsar;
/**
class PulsarDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'pulsar-compose.yaml', image = TestImage.PULSAR)
	void runCreatesConnectionDetails(PulsarConnectionDetails connectionDetails) {
		assertThat(connectionDetails).isNotNull();
		assertThat(connectionDetails.getBrokerUrl()).matches('^pulsar://\\S+:\\d+');
		assertThat(connectionDetails.getAdminUrl()).matches('^http://\\S+:\\d+');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.hazelcast;
/**
class HazelcastDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'hazelcast-compose.yaml', image = TestImage.HAZELCAST)
	void runCreatesConnectionDetails(HazelcastConnectionDetails connectionDetails) {
		ClientConfig config = connectionDetails.getClientConfig();
		assertThat(config.getClusterName()).isEqualTo(Config.DEFAULT_CLUSTER_NAME);
		verifyConnection(config);
	}
	@DockerComposeTest(composeFile = 'hazelcast-cluster-name-compose.yaml', image = TestImage.HAZELCAST)
	void runCreatesConnectionDetailsCustomClusterName(HazelcastConnectionDetails connectionDetails) {
		ClientConfig config = connectionDetails.getClientConfig();
		assertThat(config.getClusterName()).isEqualTo('spring-boot');
		verifyConnection(config);
	}
	private static void verifyConnection(ClientConfig config) {
		HazelcastInstance hazelcastInstance = HazelcastClient.newHazelcastClient(config);
		try {
			IMap<String, String> map = hazelcastInstance.getMap(UUID.randomUUID().toString());
			map.put('docker', 'compose');
			assertThat(map.get('docker')).isEqualTo('compose');
		}
		finally {
			hazelcastInstance.shutdown();
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.neo4j;
/**
class Neo4jDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'neo4j-compose.yaml', image = TestImage.NEO4J)
	void runCreatesConnectionDetailsThatCanAccessNeo4j(Neo4jConnectionDetails connectionDetails) {
		assertConnectionDetailsWithPassword(connectionDetails, 'secret');
	}
	@DockerComposeTest(composeFile = 'neo4j-bitnami-compose.yaml', image = TestImage.BITNAMI_NEO4J)
	void runWithBitnamiImageCreatesConnectionDetailsThatCanAccessNeo4j(Neo4jConnectionDetails connectionDetails) {
		assertConnectionDetailsWithPassword(connectionDetails, 'bitnami2');
	}
	private void assertConnectionDetailsWithPassword(Neo4jConnectionDetails connectionDetails, String password) {
		assertThat(connectionDetails.getAuthToken()).isEqualTo(AuthTokens.basic('neo4j', password));
		try (Driver driver = GraphDatabase.driver(connectionDetails.getUri(), connectionDetails.getAuthToken())) {
			assertThatNoException().isThrownBy(driver::verifyConnectivity);
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class GrafanaOpenTelemetryTracingDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'otlp-compose.yaml', image = TestImage.GRAFANA_OTEL_LGTM)
	void runCreatesConnectionDetails(OtlpTracingConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUrl(Transport.HTTP)).startsWith('http://').endsWith('/v1/traces');
		assertThat(connectionDetails.getUrl(Transport.GRPC)).startsWith('http://').endsWith('/v1/traces');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class GrafanaOpenTelemetryLoggingDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'otlp-compose.yaml', image = TestImage.GRAFANA_OTEL_LGTM)
	void runCreatesConnectionDetails(OtlpLoggingConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUrl(Transport.HTTP)).startsWith('http://').endsWith('/v1/logs');
		assertThat(connectionDetails.getUrl(Transport.GRPC)).startsWith('http://').endsWith('/v1/logs');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class OpenTelemetryMetricsDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'otlp-compose.yaml', image = TestImage.OPENTELEMETRY)
	void runCreatesConnectionDetails(OtlpMetricsConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUrl()).startsWith('http://').endsWith('/v1/metrics');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class OpenTelemetryTracingDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'otlp-compose.yaml', image = TestImage.OPENTELEMETRY)
	void runCreatesConnectionDetails(OtlpTracingConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUrl(Transport.HTTP)).startsWith('http://').endsWith('/v1/traces');
		assertThat(connectionDetails.getUrl(Transport.GRPC)).startsWith('http://').endsWith('/v1/traces');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class OpenTelemetryLoggingDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'otlp-compose.yaml', image = TestImage.OPENTELEMETRY)
	void runCreatesConnectionDetails(OtlpLoggingConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUrl(Transport.HTTP)).startsWith('http://').endsWith('/v1/logs');
		assertThat(connectionDetails.getUrl(Transport.GRPC)).startsWith('http://').endsWith('/v1/logs');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class GrafanaOpenTelemetryMetricsDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'otlp-compose.yaml', image = TestImage.GRAFANA_OTEL_LGTM)
	void runCreatesConnectionDetails(OtlpMetricsConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUrl()).startsWith('http://').endsWith('/v1/metrics');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.sqlserver;
/**
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The SQL server image has no ARM support')
class SqlServerJdbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'mssqlserver-compose.yaml', image = TestImage.SQL_SERVER)
	void runCreatesConnectionDetailsThatCanBeUsedToAccessDatabase(JdbcConnectionDetails connectionDetails)
			throws ClassNotFoundException, LinkageError {
		assertThat(connectionDetails.getUsername()).isEqualTo('SA');
		assertThat(connectionDetails.getPassword()).isEqualTo('verYs3cret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:sqlserver://');
		checkDatabaseAccess(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'mssqlserver-with-jdbc-parameters-compose.yaml', image = TestImage.SQL_SERVER)
	void runWithJdbcParametersCreatesConnectionDetailsThatCanBeUsedToAccessDatabase(
			JdbcConnectionDetails connectionDetails) throws ClassNotFoundException {
		assertThat(connectionDetails.getUsername()).isEqualTo('SA');
		assertThat(connectionDetails.getPassword()).isEqualTo('verYs3cret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:sqlserver://')
			.contains(';sendStringParametersAsUnicode=false;');
		checkDatabaseAccess(connectionDetails);
	}
	@SuppressWarnings('unchecked')
	private void checkDatabaseAccess(JdbcConnectionDetails connectionDetails) throws ClassNotFoundException {
		SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
		dataSource.setUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClass((Class<? extends Driver>) ClassUtils.forName(connectionDetails.getDriverClassName(),
				getClass().getClassLoader()));
		JdbcTemplate template = new JdbcTemplate(dataSource);
		assertThat(template.queryForObject(DatabaseDriver.SQLSERVER.getValidationQuery(), Integer.class)).isEqualTo(1);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.sqlserver;
/**
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The SQL server image has no ARM support')
class SqlServerR2dbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'mssqlserver-compose.yaml', image = TestImage.SQL_SERVER)
	void runCreatesConnectionDetailsThatCanBeUsedToAccessDatabase(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.toString()).contains('driver=mssql', 'password=REDACTED', 'user=SA');
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD))
			.isEqualTo('verYs3cret');
		Object result = DatabaseClient.create(ConnectionFactories.get(connectionFactoryOptions))
			.sql(DatabaseDriver.SQLSERVER.getValidationQuery())
			.map((row, metadata) -> row.get(0))
			.first()
			.block(Duration.ofSeconds(30));
		assertThat(result).isEqualTo(1);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mysql;
/**
class MySqlJdbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'mysql-compose.yaml', image = TestImage.MYSQL)
	void runCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'mysql-bitnami-compose.yaml', image = TestImage.BITNAMI_MYSQL)
	void runWithBitnamiImageCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:mysql://').endsWith('/mydatabase');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mysql;
/**
class MySqlR2dbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'mysql-compose.yaml', image = TestImage.MYSQL)
	void runCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'mysql-bitnami-compose.yaml', image = TestImage.BITNAMI_MYSQL)
	void runWithBitnamiImageCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.toString()).contains('database=mydatabase', 'driver=mysql',
				'password=REDACTED', 'user=myuser');
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.rabbit;
/**
class RabbitDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'rabbit-compose.yaml', image = TestImage.RABBITMQ)
	void runCreatesConnectionDetails(RabbitConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'rabbit-bitnami-compose.yaml', image = TestImage.BITNAMI_RABBITMQ)
	void runWithBitnamiImageCreatesConnectionDetails(RabbitConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(RabbitConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getVirtualHost()).isEqualTo('/');
		assertThat(connectionDetails.getAddresses()).hasSize(1);
		Address address = connectionDetails.getFirstAddress();
		assertThat(address.host()).isNotNull();
		assertThat(address.port()).isGreaterThan(0);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.elasticsearch;
/**
class ElasticsearchDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'elasticsearch-compose.yaml', image = TestImage.ELASTICSEARCH_8)
	void runCreatesConnectionDetails(ElasticsearchConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'elasticsearch-bitnami-compose.yaml', image = TestImage.BITNAMI_ELASTICSEARCH)
	void runWithBitnamiImageCreatesConnectionDetails(ElasticsearchConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(ElasticsearchConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('elastic');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getPathPrefix()).isNull();
		assertThat(connectionDetails.getNodes()).hasSize(1);
		Node node = connectionDetails.getNodes().get(0);
		assertThat(node.hostname()).isNotNull();
		assertThat(node.port()).isGreaterThan(0);
		assertThat(node.protocol()).isEqualTo(Protocol.HTTP);
		assertThat(node.username()).isEqualTo('elastic');
		assertThat(node.password()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.redis;
/**
class RedisDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'redis-compose.yaml', image = TestImage.REDIS)
	void runCreatesConnectionDetails(RedisConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'redis-bitnami-compose.yaml', image = TestImage.BITNAMI_REDIS)
	void runWithBitnamiImageCreatesConnectionDetails(RedisConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'redis-compose.yaml', image = TestImage.REDIS_STACK)
	void runWithRedisStackCreatesConnectionDetails(RedisConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'redis-compose.yaml', image = TestImage.REDIS_STACK_SERVER)
	void runWithRedisStackServerCreatesConnectionDetails(RedisConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(RedisConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isNull();
		assertThat(connectionDetails.getPassword()).isNull();
		assertThat(connectionDetails.getCluster()).isNull();
		assertThat(connectionDetails.getSentinel()).isNull();
		Standalone standalone = connectionDetails.getStandalone();
		assertThat(standalone).isNotNull();
		assertThat(standalone.getDatabase()).isZero();
		assertThat(standalone.getPort()).isGreaterThan(0);
		assertThat(standalone.getHost()).isNotNull();
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.postgres;
/**
class PostgresJdbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'postgres-compose.yaml', image = TestImage.POSTGRESQL)
	void runCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'postgres-with-trust-host-auth-method-compose.yaml', image = TestImage.POSTGRESQL)
	void runCreatesConnectionDetailsThatCanAccessDatabaseWhenHostAuthMethodIsTrust(
			JdbcConnectionDetails connectionDetails) throws ClassNotFoundException {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isNull();
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:postgresql://').endsWith('/mydatabase');
		checkDatabaseAccess(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'postgres-bitnami-compose.yaml', image = TestImage.BITNAMI_POSTGRESQL)
	void runWithBitnamiImageCreatesConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(JdbcConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:postgresql://').endsWith('/mydatabase');
	}
	@SuppressWarnings('unchecked')
	private void checkDatabaseAccess(JdbcConnectionDetails connectionDetails) throws ClassNotFoundException {
		SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
		dataSource.setUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClass((Class<? extends Driver>) ClassUtils.forName(connectionDetails.getDriverClassName(),
				getClass().getClassLoader()));
		JdbcTemplate template = new JdbcTemplate(dataSource);
		assertThat(template.queryForObject(DatabaseDriver.POSTGRESQL.getValidationQuery(), Integer.class)).isEqualTo(1);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.postgres;
/**
class PostgresR2dbcDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'postgres-compose.yaml', image = TestImage.POSTGRESQL)
	void runCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'postgres-with-trust-host-auth-method-compose.yaml', image = TestImage.POSTGRESQL)
	void runCreatesConnectionDetailsThatCanAccessDatabaseWhenHostAuthMethodIsTrust(
			R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.USER)).isEqualTo('myuser');
		assertThat(connectionFactoryOptions.getValue(ConnectionFactoryOptions.PASSWORD)).isNull();
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.DATABASE))
			.isEqualTo('mydatabase');
		checkDatabaseAccess(connectionDetails);
	}
	@DockerComposeTest(composeFile = 'postgres-bitnami-compose.yaml', image = TestImage.BITNAMI_POSTGRESQL)
	void runWithBitnamiImageCreatesConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		assertConnectionDetails(connectionDetails);
	}
	private void assertConnectionDetails(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		assertThat(connectionFactoryOptions.toString()).contains('database=mydatabase', 'driver=postgresql',
				'password=REDACTED', 'user=myuser');
		assertThat(connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('secret');
	}
	private void checkDatabaseAccess(R2dbcConnectionDetails connectionDetails) {
		ConnectionFactoryOptions connectionFactoryOptions = connectionDetails.getConnectionFactoryOptions();
		Object result = DatabaseClient.create(ConnectionFactories.get(connectionFactoryOptions))
			.sql(DatabaseDriver.POSTGRESQL.getValidationQuery())
			.map((row, metadata) -> row.get(0))
			.first()
			.block(Duration.ofSeconds(30));
		assertThat(result).isEqualTo(1);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.liquibase;
/**
class JdbcAdaptingLiquibaseConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'liquibase-compose.yaml', image = TestImage.POSTGRESQL)
	void runCreatesConnectionDetails(LiquibaseConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:postgresql://').endsWith('/mydatabase');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.flyway;
/**
class JdbcAdaptingFlywayConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'flyway-compose.yaml', image = TestImage.POSTGRESQL)
	void runCreatesConnectionDetails(FlywayConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('myuser');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
		assertThat(connectionDetails.getJdbcUrl()).startsWith('jdbc:postgresql://').endsWith('/mydatabase');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.ldap;
/**
class OpenLdapDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'ldap-compose.yaml', image = TestImage.OPEN_LDAP)
	void runCreatesConnectionDetails(LdapConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getUsername()).isEqualTo('cn=admin,dc=ldap,dc=example,dc=org');
		assertThat(connectionDetails.getPassword()).isEqualTo('somepassword');
		assertThat(connectionDetails.getBase()).isEqualTo('dc=ldap,dc=example,dc=org');
		assertThat(connectionDetails.getUrls()).hasSize(1);
		assertThat(connectionDetails.getUrls()[0]).startsWith('ldaps://');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mongo;
/**
class MongoDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'mongo-compose.yaml', image = TestImage.MONGODB)
	void runCreatesConnectionDetails(MongoConnectionDetails connectionDetails) {
		assertConnectionDetailsWithDatabase(connectionDetails, 'mydatabase');
	}
	@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64', disabledReason = 'The image has no ARM support')
	@DockerComposeTest(composeFile = 'mongo-bitnami-compose.yaml', image = TestImage.BITNAMI_MONGODB)
	void runWithBitnamiImageCreatesConnectionDetails(MongoConnectionDetails connectionDetails) {
		assertConnectionDetailsWithDatabase(connectionDetails, 'testdb');
	}
	private void assertConnectionDetailsWithDatabase(MongoConnectionDetails connectionDetails, String database) {
		ConnectionString connectionString = connectionDetails.getConnectionString();
		assertThat(connectionString.getCredential().getUserName()).isEqualTo('root');
		assertThat(connectionString.getCredential().getPassword()).isEqualTo('secret'.toCharArray());
		assertThat(connectionString.getCredential().getSource()).isEqualTo('admin');
		assertThat(connectionString.getDatabase()).isEqualTo(database);
		assertThat(connectionDetails.getGridFs()).isNull();
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQClassicDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'activemq-classic-compose.yaml', image = TestImage.ACTIVE_MQ_CLASSIC)
	void runCreatesConnectionDetails(ActiveMQConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getBrokerUrl()).isNotNull().startsWith('tcp://');
		assertThat(connectionDetails.getUser()).isEqualTo('root');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ArtemisDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'artemis-compose.yaml', image = TestImage.ARTEMIS)
	void runCreatesConnectionDetails(ArtemisConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getMode()).isEqualTo(ArtemisMode.NATIVE);
		assertThat(connectionDetails.getBrokerUrl()).isNotNull().startsWith('tcp://');
		assertThat(connectionDetails.getUser()).isEqualTo('root');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQDockerComposeConnectionDetailsFactoryIntegrationTests {
	@DockerComposeTest(composeFile = 'activemq-compose.yaml', image = TestImage.ACTIVE_MQ)
	void runCreatesConnectionDetails(ActiveMQConnectionDetails connectionDetails) {
		assertThat(connectionDetails.getBrokerUrl()).isNotNull().startsWith('tcp://');
		assertThat(connectionDetails.getUser()).isEqualTo('root');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
@DisabledIfDockerUnavailable
@DisabledIfProcessUnavailable({ 'docker', 'compose' })
class DockerCliIntegrationTests {
	@TempDir
	private static Path tempDir;
	@Test
	void runBasicCommand() {
		DockerCli cli = new DockerCli(null, null);
		List<DockerCliContextResponse> context = cli.run(new DockerCliCommand.Context());
		assertThat(context).isNotEmpty();
	}
	@Test
	void runLifecycle() throws IOException {
		File composeFile = createComposeFile('redis-compose.yaml');
		String projectName = UUID.randomUUID().toString();
		DockerCli cli = new DockerCli(null, new DockerComposeOptions(DockerComposeFile.of(composeFile),
				Collections.emptySet(), List.of('--project-name=' + projectName)));
		try {
			// Verify that no services are running (this is a fresh compose project)
			List<DockerCliComposePsResponse> ps = cli.run(new ComposePs());
			assertThat(ps).isEmpty();
			// List the config and verify that redis is there
			DockerCliComposeConfigResponse config = cli.run(new ComposeConfig());
			assertThat(config.services()).containsOnlyKeys('redis');
			assertThat(config.name()).isEqualTo(projectName);
			// Run up
			cli.run(new ComposeUp(LogLevel.INFO, Collections.emptyList()));
			// Run ps and use id to run inspect on the id
			ps = cli.run(new ComposePs());
			assertThat(ps).hasSize(1);
			String id = ps.get(0).id();
			List<DockerCliInspectResponse> inspect = cli.run(new Inspect(List.of(id)));
			assertThat(inspect).isNotEmpty();
			assertThat(inspect.get(0).id()).startsWith(id);
			// Run stop, then run ps and verify the services are stopped
			cli.run(new ComposeStop(Duration.ofSeconds(10), Collections.emptyList()));
			ps = cli.run(new ComposePs());
			assertThat(ps).isEmpty();
			// Run start, verify service is there, then run down and verify they are gone
			cli.run(new ComposeStart(LogLevel.INFO, Collections.emptyList()));
			ps = cli.run(new ComposePs());
			assertThat(ps).hasSize(1);
			cli.run(new ComposeDown(Duration.ofSeconds(10), Collections.emptyList()));
			ps = cli.run(new ComposePs());
			assertThat(ps).isEmpty();
		}
		finally {
			// Clean up in any case
			quietComposeDown(cli);
		}
	}
	@Test
	void shouldWorkWithMultipleComposeFiles() throws IOException {
		List<File> composeFiles = createComposeFiles();
		DockerCli cli = new DockerCli(null,
				new DockerComposeOptions(DockerComposeFile.of(composeFiles), Set.of('dev'), Collections.emptyList()));
		try {
			// List the config and verify that both redis are there
			DockerCliComposeConfigResponse config = cli.run(new ComposeConfig());
			assertThat(config.services()).containsOnlyKeys('redis1', 'redis2');
			// Run up
			cli.run(new ComposeUp(LogLevel.INFO, Collections.emptyList()));
			// Run ps and use id to run inspect on the id
			List<DockerCliComposePsResponse> ps = cli.run(new ComposePs());
			assertThat(ps).hasSize(2);
		}
		finally {
			// Clean up in any case
			quietComposeDown(cli);
		}
	}
	private static void quietComposeDown(DockerCli cli) {
		try {
			cli.run(new ComposeDown(Duration.ZERO, Collections.emptyList()));
		}
		catch (RuntimeException ex) {
			// Ignore
		}
	}
	private static File createComposeFile(String resource) throws IOException {
		File source = new ClassPathResource(resource, DockerCliIntegrationTests.class).getFile();
		File target = Path.of(tempDir.toString(), source.getName()).toFile();
		String content = FileCopyUtils.copyToString(new FileReader(source));
		content = content.replace('{imageName}', TestImage.REDIS.toString());
		try (FileWriter writer = new FileWriter(target)) {
			FileCopyUtils.copy(content, writer);
		}
		return target;
	}
	private static List<File> createComposeFiles() throws IOException {
		File file1 = createComposeFile('1.yaml');
		File file2 = createComposeFile('2.yaml');
		File file3 = createComposeFile('3.yaml');
		return List.of(file1, file2, file3);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.clickhouse;
/**
class ClickHouseEnvironmentTests {
	@Test
	void createWhenNoPasswordThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new ClickHouseEnvironment(Collections.emptyMap()))
			.withMessage('No ClickHouse password found');
	}
	@Test
	void getPasswordWhenHasPassword() {
		ClickHouseEnvironment environment = new ClickHouseEnvironment(Map.of('CLICKHOUSE_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasNoPasswordAndAllowEmptyPassword() {
		ClickHouseEnvironment environment = new ClickHouseEnvironment(Map.of('ALLOW_EMPTY_PASSWORD', 'true'));
		assertThat(environment.getPassword()).isEmpty();
	}
	@Test
	void getPasswordWhenHasNoPasswordAndAllowEmptyPasswordIsFalse() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new ClickHouseEnvironment(Map.of('ALLOW_EMPTY_PASSWORD', 'false')))
			.withMessage('No ClickHouse password found');
	}
	@Test
	void getUsernameWhenNoUser() {
		ClickHouseEnvironment environment = new ClickHouseEnvironment(Map.of('CLICKHOUSE_PASSWORD', 'secret'));
		assertThat(environment.getUsername()).isEqualTo('default');
	}
	@Test
	void getUsernameWhenHasUser() {
		ClickHouseEnvironment environment = new ClickHouseEnvironment(
				Map.of('CLICKHOUSE_USER', 'me', 'CLICKHOUSE_PASSWORD', 'secret'));
		assertThat(environment.getUsername()).isEqualTo('me');
	}
	@Test
	void getDatabaseWhenNoDatabase() {
		ClickHouseEnvironment environment = new ClickHouseEnvironment(Map.of('CLICKHOUSE_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('default');
	}
	@Test
	void getDatabaseWhenHasDatabase() {
		ClickHouseEnvironment environment = new ClickHouseEnvironment(
				Map.of('CLICKHOUSE_DB', 'db', 'CLICKHOUSE_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.jdbc;
/**
class JdbcUrlBuilderTests {
	private JdbcUrlBuilder builder = new JdbcUrlBuilder('mydb', 1234);
	@Test
	void createWhenDriverProtocolIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new JdbcUrlBuilder(null, 123))
			.withMessage('DriverProtocol must not be null');
	}
	@Test
	void buildBuildsUrlForService() {
		RunningService service = mockService(456);
		String url = this.builder.build(service);
		assertThat(url).isEqualTo('jdbc:mydb://myhost:456');
	}
	@Test
	void buildBuildsUrlForServiceAndDatabase() {
		RunningService service = mockService(456);
		String url = this.builder.build(service, 'mydb');
		assertThat(url).isEqualTo('jdbc:mydb://myhost:456/mydb');
	}
	@Test
	void buildWhenHasParamsLabelBuildsUrl() {
		RunningService service = mockService(456, Map.of('org.springframework.boot.jdbc.parameters', 'foo=bar'));
		String url = this.builder.build(service, 'mydb');
		assertThat(url).isEqualTo('jdbc:mydb://myhost:456/mydb?foo=bar');
	}
	@Test
	void buildWithCustomAppendParametersWhenHasParamsLabelBuildsUrl() {
		RunningService service = mockService(456, Map.of('org.springframework.boot.jdbc.parameters', 'foo=bar'));
		String url = new JdbcUrlBuilder('mydb', 1234) {
			@Override
			protected void appendParameters(StringBuilder url, String parameters) {
				url.append(';').append(parameters);
			}
		}.build(service, 'mydb');
		assertThat(url).isEqualTo('jdbc:mydb://myhost:456/mydb;foo=bar');
	}
	@Test
	void buildWhenServiceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.builder.build(null, 'mydb'))
			.withMessage('Service must not be null');
	}
	private RunningService mockService(int mappedPort) {
		return mockService(mappedPort, Collections.emptyMap());
	}
	private RunningService mockService(int mappedPort, Map<String, String> labels) {
		RunningService service = mock(RunningService.class);
		ConnectionPorts ports = mock(ConnectionPorts.class);
		given(ports.get(1234)).willReturn(mappedPort);
		given(service.host()).willReturn('myhost');
		given(service.ports()).willReturn(ports);
		given(service.labels()).willReturn(labels);
		return service;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.cassandra;
/**
class CassandraEnvironmentTests {
	@Test
	void getDatacenterWhenDatacenterIsNotSet() {
		CassandraEnvironment environment = new CassandraEnvironment(Collections.emptyMap());
		assertThat(environment.getDatacenter()).isEqualTo('datacenter1');
	}
	@Test
	void getDatacenterWhenDcIsSet() {
		CassandraEnvironment environment = new CassandraEnvironment(Map.of('CASSANDRA_DC', 'testdc1'));
		assertThat(environment.getDatacenter()).isEqualTo('testdc1');
	}
	@Test
	void getDatacenterWhenDatacenterIsSet() {
		CassandraEnvironment environment = new CassandraEnvironment(Map.of('CASSANDRA_DATACENTER', 'testdc1'));
		assertThat(environment.getDatacenter()).isEqualTo('testdc1');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
class OracleEnvironmentTests {
	@Test
	void getUsernameWhenHasAppUser() {
		OracleEnvironment environment = new OracleEnvironment(
				Map.of('APP_USER', 'alice', 'APP_USER_PASSWORD', 'secret'), 'defaultDb');
		assertThat(environment.getUsername()).isEqualTo('alice');
	}
	@Test
	void getUsernameWhenHasNoAppUser() {
		OracleEnvironment environment = new OracleEnvironment(Map.of('ORACLE_PASSWORD', 'secret'), 'defaultDb');
		assertThat(environment.getUsername()).isEqualTo('system');
	}
	@Test
	void getPasswordWhenHasAppPassword() {
		OracleEnvironment environment = new OracleEnvironment(
				Map.of('APP_USER', 'alice', 'APP_USER_PASSWORD', 'secret'), 'defaultDb');
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasOraclePassword() {
		OracleEnvironment environment = new OracleEnvironment(Map.of('ORACLE_PASSWORD', 'secret'), 'defaultDb');
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void createWhenRandomPasswordAndAppPasswordDoesNotThrow() {
		assertThatNoException().isThrownBy(() -> new OracleEnvironment(
				Map.of('APP_USER', 'alice', 'APP_USER_PASSWORD', 'secret', 'ORACLE_RANDOM_PASSWORD', 'true'),
				'defaultDb'));
	}
	@Test
	void createWhenRandomPasswordThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new OracleEnvironment(Map.of('ORACLE_RANDOM_PASSWORD', 'true'), 'defaultDb'))
			.withMessage('ORACLE_RANDOM_PASSWORD is not supported without APP_USER and APP_USER_PASSWORD');
	}
	@Test
	void createWhenAppUserAndNoAppPasswordThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new OracleEnvironment(Map.of('APP_USER', 'alice'), 'defaultDb'))
			.withMessage('No Oracle app password found');
	}
	@Test
	void createWhenAppUserAndEmptyAppPasswordThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new OracleEnvironment(Map.of('APP_USER', 'alice', 'APP_USER_PASSWORD', ''), 'defaultDb'))
			.withMessage('No Oracle app password found');
	}
	@Test
	void createWhenHasNoPasswordThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new OracleEnvironment(Collections.emptyMap(), 'defaultDb'))
			.withMessage('No Oracle password found');
	}
	@Test
	void createWhenHasEmptyPasswordThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new OracleEnvironment(Map.of('ORACLE_PASSWORD', ''), 'defaultDb'))
			.withMessage('No Oracle password found');
	}
	@Test
	void getDatabaseWhenHasNoOracleDatabase() {
		OracleEnvironment environment = new OracleEnvironment(Map.of('ORACLE_PASSWORD', 'secret'), 'defaultDb');
		assertThat(environment.getDatabase()).isEqualTo('defaultDb');
	}
	@Test
	void getDatabaseWhenHasOracleDatabase() {
		OracleEnvironment environment = new OracleEnvironment(
				Map.of('ORACLE_PASSWORD', 'secret', 'ORACLE_DATABASE', 'db'), 'defaultDb');
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mariadb;
/**
class MariaDbEnvironmentTests {
	@Test
	void createWhenHasMariadbRandomRootPasswordThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new MariaDbEnvironment(Map.of('MARIADB_RANDOM_ROOT_PASSWORD', 'true')))
			.withMessage('MARIADB_RANDOM_ROOT_PASSWORD is not supported');
	}
	@Test
	void createWhenHasMysqlRandomRootPasswordThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new MariaDbEnvironment(Map.of('MYSQL_RANDOM_ROOT_PASSWORD', 'true')))
			.withMessage('MYSQL_RANDOM_ROOT_PASSWORD is not supported');
	}
	@Test
	void createWhenHasMariadbRootPasswordHashThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new MariaDbEnvironment(Map.of('MARIADB_ROOT_PASSWORD_HASH', '0FF')))
			.withMessage('MARIADB_ROOT_PASSWORD_HASH is not supported');
	}
	@Test
	void createWhenHasNoPasswordThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new MariaDbEnvironment(Collections.emptyMap()))
			.withMessage('No MariaDB password found');
	}
	@Test
	void createWhenHasNoDatabaseThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new MariaDbEnvironment(Map.of('MARIADB_PASSWORD', 'secret')))
			.withMessage('No MARIADB_DATABASE defined');
	}
	@Test
	void getUsernameWhenHasMariadbUser() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_USER', 'myself', 'MARIADB_PASSWORD', 'secret', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getUsername()).isEqualTo('myself');
	}
	@Test
	void getUsernameWhenHasMysqlUser() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MYSQL_USER', 'myself', 'MARIADB_PASSWORD', 'secret', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getUsername()).isEqualTo('myself');
	}
	@Test
	void getUsernameWhenHasMariadbUserAndMysqlUser() {
		MariaDbEnvironment environment = new MariaDbEnvironment(Map.of('MARIADB_USER', 'myself', 'MYSQL_USER', 'me',
				'MARIADB_PASSWORD', 'secret', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getUsername()).isEqualTo('myself');
	}
	@Test
	void getUsernameWhenHasNoMariadbUserOrMysqlUser() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_PASSWORD', 'secret', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getUsername()).isEqualTo('root');
	}
	@Test
	void getPasswordWhenHasMariadbPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_PASSWORD', 'secret', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasMysqlPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MYSQL_PASSWORD', 'secret', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasMysqlRootPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MYSQL_ROOT_PASSWORD', 'secret', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasMariadbPasswordAndMysqlPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_PASSWORD', 'secret', 'MYSQL_PASSWORD', 'donttell', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasMariadbPasswordAndMysqlRootPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_PASSWORD', 'secret', 'MYSQL_ROOT_PASSWORD', 'donttell', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasNoPasswordAndAllowEmptyPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('ALLOW_EMPTY_PASSWORD', 'true', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEmpty();
	}
	@Test
	void getPasswordWhenHasNoPasswordAndMariadbAllowEmptyPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_ALLOW_EMPTY_PASSWORD', 'true', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEmpty();
	}
	@Test
	void getPasswordWhenHasNoPasswordAndMysqlAllowEmptyPassword() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MYSQL_ALLOW_EMPTY_PASSWORD', 'true', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEmpty();
	}
	@Test
	void getDatabaseWhenHasMariadbDatabase() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_ALLOW_EMPTY_PASSWORD', 'true', 'MARIADB_DATABASE', 'db'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
	@Test
	void getDatabaseWhenHasMysqlDatabase() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_ALLOW_EMPTY_PASSWORD', 'true', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
	@Test
	void getDatabaseWhenHasMariadbAndMysqlDatabase() {
		MariaDbEnvironment environment = new MariaDbEnvironment(
				Map.of('MARIADB_ALLOW_EMPTY_PASSWORD', 'true', 'MARIADB_DATABASE', 'db', 'MYSQL_DATABASE', 'otherdb'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.hazelcast;
/**
class HazelcastEnvironmentTests {
	@Test
	void getClusterNameWhenHasNoHzClusterNameSet() {
		HazelcastEnvironment environment = new HazelcastEnvironment(Collections.emptyMap());
		assertThat(environment.getClusterName()).isNull();
	}
	@Test
	void getClusterNameWhenHzClusterNameSet() {
		HazelcastEnvironment environment = new HazelcastEnvironment(Map.of('HZ_CLUSTERNAME', 'spring-boot'));
		assertThat(environment.getClusterName()).isEqualTo('spring-boot');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.neo4j;
/**
class Neo4jEnvironmentTests {
	@Test
	void whenNeo4jAuthAndPasswordAreNullThenAuthTokenIsNull() {
		Neo4jEnvironment environment = new Neo4jEnvironment(Collections.emptyMap());
		assertThat(environment.getAuthToken()).isNull();
	}
	@Test
	void whenNeo4jAuthIsNoneThenAuthTokenIsNone() {
		Neo4jEnvironment environment = new Neo4jEnvironment(Map.of('NEO4J_AUTH', 'none'));
		assertThat(environment.getAuthToken()).isEqualTo(AuthTokens.none());
	}
	@Test
	void whenNeo4jAuthIsNeo4jSlashPasswordThenAuthTokenIsBasic() {
		Neo4jEnvironment environment = new Neo4jEnvironment(Map.of('NEO4J_AUTH', 'neo4j/custom-password'));
		assertThat(environment.getAuthToken()).isEqualTo(AuthTokens.basic('neo4j', 'custom-password'));
	}
	@Test
	void whenNeo4jAuthIsNeitherNoneNorNeo4jSlashPasswordEnvironmentCreationThrows() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new Neo4jEnvironment(Map.of('NEO4J_AUTH', 'graphdb/custom-password')));
	}
	@Test
	void whenNeo4jPasswordIsProvidedThenAuthTokenIsBasic() {
		Neo4jEnvironment environment = new Neo4jEnvironment(Map.of('NEO4J_PASSWORD', 'custom-password'));
		assertThat(environment.getAuthToken()).isEqualTo(AuthTokens.basic('neo4j', 'custom-password'));
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.sqlserver;
/**
class SqlServerEnvironmentTests {
	@Test
	void createWhenHasNoPasswordThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new SqlServerEnvironment(Collections.emptyMap()))
			.withMessage('No MSSQL password found');
	}
	@Test
	void getUsernameWhenHasNoMsSqlUser() {
		SqlServerEnvironment environment = new SqlServerEnvironment(Map.of('MSSQL_SA_PASSWORD', 'secret'));
		assertThat(environment.getUsername()).isEqualTo('SA');
	}
	@Test
	void getPasswordWhenHasMsSqlSaPassword() {
		SqlServerEnvironment environment = new SqlServerEnvironment(Map.of('MSSQL_SA_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasSaPassword() {
		SqlServerEnvironment environment = new SqlServerEnvironment(Map.of('SA_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasMsSqlSaPasswordAndSaPasswordPrefersMsSqlSaPassword() {
		SqlServerEnvironment environment = new SqlServerEnvironment(
				Map.of('MSSQL_SA_PASSWORD', 'secret', 'SA_PASSWORD', 'not used'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mysql;
/**
class MySqlEnvironmentTests {
	@Test
	void createWhenHasMysqlRandomRootPasswordThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new MySqlEnvironment(Map.of('MYSQL_RANDOM_ROOT_PASSWORD', 'true')))
			.withMessage('MYSQL_RANDOM_ROOT_PASSWORD is not supported');
	}
	@Test
	void createWhenHasNoPasswordThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new MySqlEnvironment(Collections.emptyMap()))
			.withMessage('No MySQL password found');
	}
	@Test
	void createWhenHasNoDatabaseThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new MySqlEnvironment(Map.of('MYSQL_PASSWORD', 'secret')))
			.withMessage('No MYSQL_DATABASE defined');
	}
	@Test
	void getUsernameWhenHasMysqlUser() {
		MySqlEnvironment environment = new MySqlEnvironment(
				Map.of('MYSQL_USER', 'myself', 'MYSQL_PASSWORD', 'secret', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getUsername()).isEqualTo('myself');
	}
	@Test
	void getUsernameWhenHasNoMysqlUser() {
		MySqlEnvironment environment = new MySqlEnvironment(Map.of('MYSQL_PASSWORD', 'secret', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getUsername()).isEqualTo('root');
	}
	@Test
	void getPasswordWhenHasMysqlPassword() {
		MySqlEnvironment environment = new MySqlEnvironment(Map.of('MYSQL_PASSWORD', 'secret', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasMysqlRootPassword() {
		MySqlEnvironment environment = new MySqlEnvironment(
				Map.of('MYSQL_ROOT_PASSWORD', 'secret', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasNoPasswordAndMysqlAllowEmptyPassword() {
		MySqlEnvironment environment = new MySqlEnvironment(
				Map.of('MYSQL_ALLOW_EMPTY_PASSWORD', 'true', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEmpty();
	}
	@Test
	void getPasswordWhenHasNoPasswordAndAllowEmptyPassword() {
		MySqlEnvironment environment = new MySqlEnvironment(
				Map.of('ALLOW_EMPTY_PASSWORD', 'true', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getPassword()).isEmpty();
	}
	@Test
	void getDatabaseWhenHasMysqlDatabase() {
		MySqlEnvironment environment = new MySqlEnvironment(
				Map.of('MYSQL_ALLOW_EMPTY_PASSWORD', 'true', 'MYSQL_DATABASE', 'db'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.rabbit;
/**
class RabbitEnvironmentTests {
	@Test
	void getUsernameWhenNoRabbitmqDefaultUser() {
		RabbitEnvironment environment = new RabbitEnvironment(Collections.emptyMap());
		assertThat(environment.getUsername()).isEqualTo('guest');
	}
	@Test
	void getUsernameWhenHasRabbitmqDefaultUser() {
		RabbitEnvironment environment = new RabbitEnvironment(Map.of('RABBITMQ_DEFAULT_USER', 'me'));
		assertThat(environment.getUsername()).isEqualTo('me');
	}
	@Test
	void getUsernameWhenHasRabbitmqUsername() {
		RabbitEnvironment environment = new RabbitEnvironment(Map.of('RABBITMQ_USERNAME', 'me'));
		assertThat(environment.getUsername()).isEqualTo('me');
	}
	@Test
	void getUsernameWhenNoRabbitmqDefaultPass() {
		RabbitEnvironment environment = new RabbitEnvironment(Collections.emptyMap());
		assertThat(environment.getPassword()).isEqualTo('guest');
	}
	@Test
	void getUsernameWhenHasRabbitmqDefaultPass() {
		RabbitEnvironment environment = new RabbitEnvironment(Map.of('RABBITMQ_DEFAULT_PASS', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getUsernameWhenHasRabbitmqPassword() {
		RabbitEnvironment environment = new RabbitEnvironment(Map.of('RABBITMQ_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.elasticsearch;
/**
class ElasticsearchEnvironmentTests {
	@Test
	void createWhenHasElasticPasswordFileThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new ElasticsearchEnvironment(Map.of('ELASTIC_PASSWORD_FILE', 'afile')))
			.withMessage('ELASTIC_PASSWORD_FILE is not supported');
	}
	@Test
	void getPasswordWhenNoPassword() {
		ElasticsearchEnvironment environment = new ElasticsearchEnvironment(Collections.emptyMap());
		assertThat(environment.getPassword()).isNull();
	}
	@Test
	void getPasswordWhenHasPassword() {
		ElasticsearchEnvironment environment = new ElasticsearchEnvironment(Map.of('ELASTIC_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.r2dbc;
/**
class ConnectionFactoryOptionsBuilderTests {
	private ConnectionFactoryOptionsBuilder builder = new ConnectionFactoryOptionsBuilder('mydb', 1234);
	@Test
	void createWhenDriverProtocolIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new JdbcUrlBuilder(null, 123))
			.withMessage('DriverProtocol must not be null');
	}
	@Test
	void buildBuildsOptions() {
		RunningService service = mockService(456);
		ConnectionFactoryOptions options = this.builder.build(service, 'mydb', 'user', 'pass');
		assertThat(options).isEqualTo(ConnectionFactoryOptions.builder()
			.option(ConnectionFactoryOptions.DATABASE, 'mydb')
			.option(ConnectionFactoryOptions.HOST, 'myhost')
			.option(ConnectionFactoryOptions.PORT, 456)
			.option(ConnectionFactoryOptions.DRIVER, 'mydb')
			.option(ConnectionFactoryOptions.PASSWORD, 'pass')
			.option(ConnectionFactoryOptions.USER, 'user')
			.build());
	}
	@Test
	void buildWhenHasParamsLabelBuildsOptions() {
		RunningService service = mockService(456, Map.of('org.springframework.boot.r2dbc.parameters', 'foo=bar'));
		ConnectionFactoryOptions options = this.builder.build(service, 'mydb', 'user', 'pass');
		assertThat(options).isEqualTo(ConnectionFactoryOptions.builder()
			.option(ConnectionFactoryOptions.DATABASE, 'mydb')
			.option(ConnectionFactoryOptions.HOST, 'myhost')
			.option(ConnectionFactoryOptions.PORT, 456)
			.option(ConnectionFactoryOptions.DRIVER, 'mydb')
			.option(ConnectionFactoryOptions.PASSWORD, 'pass')
			.option(ConnectionFactoryOptions.USER, 'user')
			.option(Option.valueOf('foo'), 'bar')
			.build());
	}
	@Test
	void buildWhenServiceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.builder.build(null, 'mydb', 'user', 'pass'))
			.withMessage('Service must not be null');
	}
	@Test
	void buildWhenDatabaseIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.build(mockService(456), null, 'user', 'pass'))
			.withMessage('Database must not be null');
	}
	private RunningService mockService(int mappedPort) {
		return mockService(mappedPort, Collections.emptyMap());
	}
	private RunningService mockService(int mappedPort, Map<String, String> labels) {
		RunningService service = mock(RunningService.class);
		ConnectionPorts ports = mock(ConnectionPorts.class);
		given(ports.get(1234)).willReturn(mappedPort);
		given(service.host()).willReturn('myhost');
		given(service.ports()).willReturn(ports);
		given(service.labels()).willReturn(labels);
		return service;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.postgres;
/**
class PostgresEnvironmentTests {
	@Test
	void createWhenNoPostgresPasswordThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> new PostgresEnvironment(Collections.emptyMap()))
			.withMessage('PostgreSQL password must be provided');
	}
	@Test
	void getUsernameWhenNoPostgresUser() {
		PostgresEnvironment environment = new PostgresEnvironment(Map.of('POSTGRES_PASSWORD', 'secret'));
		assertThat(environment.getUsername()).isEqualTo('postgres');
	}
	@Test
	void getUsernameWhenNoPostgresqlUser() {
		PostgresEnvironment environment = new PostgresEnvironment(Map.of('POSTGRESQL_PASSWORD', 'secret'));
		assertThat(environment.getUsername()).isEqualTo('postgres');
	}
	@Test
	void getUsernameWhenHasPostgresUser() {
		PostgresEnvironment environment = new PostgresEnvironment(
				Map.of('POSTGRES_USER', 'me', 'POSTGRES_PASSWORD', 'secret'));
		assertThat(environment.getUsername()).isEqualTo('me');
	}
	@Test
	void getUsernameWhenHasPostgresqlUser() {
		PostgresEnvironment environment = new PostgresEnvironment(
				Map.of('POSTGRESQL_USER', 'me', 'POSTGRESQL_PASSWORD', 'secret'));
		assertThat(environment.getUsername()).isEqualTo('me');
	}
	@Test
	void getPasswordWhenHasPostgresPassword() {
		PostgresEnvironment environment = new PostgresEnvironment(Map.of('POSTGRES_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasPostgresqlPassword() {
		PostgresEnvironment environment = new PostgresEnvironment(Map.of('POSTGRESQL_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getPasswordWhenHasTrustHostAuthMethod() {
		PostgresEnvironment environment = new PostgresEnvironment(Map.of('POSTGRES_HOST_AUTH_METHOD', 'trust'));
		assertThat(environment.getPassword()).isNull();
	}
	@Test
	void getDatabaseWhenNoPostgresDbOrPostgresUser() {
		PostgresEnvironment environment = new PostgresEnvironment(Map.of('POSTGRES_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('postgres');
	}
	@Test
	void getDatabaseWhenNoPostgresqlDbOrPostgresUser() {
		PostgresEnvironment environment = new PostgresEnvironment(Map.of('POSTGRESQL_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('postgres');
	}
	@Test
	void getDatabaseWhenNoPostgresDbAndPostgresUser() {
		PostgresEnvironment environment = new PostgresEnvironment(
				Map.of('POSTGRES_USER', 'me', 'POSTGRES_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('me');
	}
	@Test
	void getDatabaseWhenNoPostgresqlDbAndPostgresUser() {
		PostgresEnvironment environment = new PostgresEnvironment(
				Map.of('POSTGRESQL_USER', 'me', 'POSTGRESQL_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('me');
	}
	@Test
	void getDatabaseWhenHasPostgresDb() {
		PostgresEnvironment environment = new PostgresEnvironment(
				Map.of('POSTGRES_DB', 'db', 'POSTGRES_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
	@Test
	void getDatabaseWhenHasPostgresqlDb() {
		PostgresEnvironment environment = new PostgresEnvironment(
				Map.of('POSTGRESQL_DB', 'db', 'POSTGRESQL_PASSWORD', 'secret'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mongo;
/**
class MongoEnvironmentTests {
	@Test
	void createWhenMonoInitdbRootUsernameFileSetThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new MongoEnvironment(Map.of('MONGO_INITDB_ROOT_USERNAME_FILE', 'file')))
			.withMessage('MONGO_INITDB_ROOT_USERNAME_FILE is not supported');
	}
	@Test
	void createWhenMonoInitdbRootPasswordFileSetThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> new MongoEnvironment(Map.of('MONGO_INITDB_ROOT_PASSWORD_FILE', 'file')))
			.withMessage('MONGO_INITDB_ROOT_PASSWORD_FILE is not supported');
	}
	@Test
	void getUsernameWhenHasNoMongoInitdbRootUsernameSet() {
		MongoEnvironment environment = new MongoEnvironment(Collections.emptyMap());
		assertThat(environment.getUsername()).isNull();
	}
	@Test
	void getUsernameWhenHasMongoInitdbRootUsernameSet() {
		MongoEnvironment environment = new MongoEnvironment(Map.of('MONGO_INITDB_ROOT_USERNAME', 'user'));
		assertThat(environment.getUsername()).isEqualTo('user');
	}
	@Test
	void getPasswordWhenHasNoMongoInitdbRootPasswordSet() {
		MongoEnvironment environment = new MongoEnvironment(Collections.emptyMap());
		assertThat(environment.getPassword()).isNull();
	}
	@Test
	void getPasswordWhenHasMongoInitdbRootPasswordSet() {
		MongoEnvironment environment = new MongoEnvironment(Map.of('MONGO_INITDB_ROOT_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
	@Test
	void getDatabaseWhenHasNoMongoInitdbDatabaseSet() {
		MongoEnvironment environment = new MongoEnvironment(Collections.emptyMap());
		assertThat(environment.getDatabase()).isNull();
	}
	@Test
	void getDatabaseWhenHasMongoInitdbDatabaseSet() {
		MongoEnvironment environment = new MongoEnvironment(Map.of('MONGO_INITDB_DATABASE', 'db'));
		assertThat(environment.getDatabase()).isEqualTo('db');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ArtemisEnvironmentTests {
	@Test
	void getUserWhenHasNoActiveMqUser() {
		ArtemisEnvironment environment = new ArtemisEnvironment(Collections.emptyMap());
		assertThat(environment.getUser()).isNull();
	}
	@Test
	void getUserWhenHasActiveMqUser() {
		ArtemisEnvironment environment = new ArtemisEnvironment(Map.of('ARTEMIS_USER', 'me'));
		assertThat(environment.getUser()).isEqualTo('me');
	}
	@Test
	void getPasswordWhenHasNoActiveMqPassword() {
		ArtemisEnvironment environment = new ArtemisEnvironment(Collections.emptyMap());
		assertThat(environment.getPassword()).isNull();
	}
	@Test
	void getPasswordWhenHasActiveMqPassword() {
		ArtemisEnvironment environment = new ArtemisEnvironment(Map.of('ARTEMIS_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQEnvironmentTests {
	@Test
	void getUserWhenHasNoActiveMqUser() {
		ActiveMQEnvironment environment = new ActiveMQEnvironment(Collections.emptyMap());
		assertThat(environment.getUser()).isNull();
	}
	@Test
	void getUserWhenHasActiveMqUser() {
		ActiveMQEnvironment environment = new ActiveMQEnvironment(Map.of('ACTIVEMQ_USERNAME', 'me'));
		assertThat(environment.getUser()).isEqualTo('me');
	}
	@Test
	void getPasswordWhenHasNoActiveMqPassword() {
		ActiveMQEnvironment environment = new ActiveMQEnvironment(Collections.emptyMap());
		assertThat(environment.getPassword()).isNull();
	}
	@Test
	void getPasswordWhenHasActiveMqPassword() {
		ActiveMQEnvironment environment = new ActiveMQEnvironment(Map.of('ACTIVEMQ_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQClassicEnvironmentTests {
	@Test
	void getUserWhenHasNoActiveMqUser() {
		ActiveMQClassicEnvironment environment = new ActiveMQClassicEnvironment(Collections.emptyMap());
		assertThat(environment.getUser()).isNull();
	}
	@Test
	void getUserWhenHasActiveMqUser() {
		ActiveMQClassicEnvironment environment = new ActiveMQClassicEnvironment(
				Map.of('ACTIVEMQ_CONNECTION_USER', 'me'));
		assertThat(environment.getUser()).isEqualTo('me');
	}
	@Test
	void getPasswordWhenHasNoActiveMqPassword() {
		ActiveMQClassicEnvironment environment = new ActiveMQClassicEnvironment(Collections.emptyMap());
		assertThat(environment.getPassword()).isNull();
	}
	@Test
	void getPasswordWhenHasActiveMqPassword() {
		ActiveMQClassicEnvironment environment = new ActiveMQClassicEnvironment(
				Map.of('ACTIVEMQ_CONNECTION_PASSWORD', 'secret'));
		assertThat(environment.getPassword()).isEqualTo('secret');
	}
}
/*
package org.springframework.boot.docker.compose.service.connection;
/**
class ConnectionNamePredicateTests {
	@Test
	void offical() {
		assertThat(predicateOf('elasticsearch')).accepts(sourceOf('elasticsearch'));
		assertThat(predicateOf('elasticsearch')).accepts(sourceOf('library/elasticsearch'));
		assertThat(predicateOf('elasticsearch')).accepts(sourceOf('docker.io/library/elasticsearch'));
		assertThat(predicateOf('elasticsearch')).accepts(sourceOf('docker.io/elasticsearch'));
		assertThat(predicateOf('elasticsearch')).accepts(sourceOf('docker.io/elasticsearch:latest'));
		assertThat(predicateOf('elasticsearch')).rejects(sourceOf('redis'));
		assertThat(predicateOf('elasticsearch')).rejects(sourceOf('library/redis'));
		assertThat(predicateOf('elasticsearch')).rejects(sourceOf('docker.io/library/redis'));
		assertThat(predicateOf('elasticsearch')).rejects(sourceOf('docker.io/redis'));
		assertThat(predicateOf('elasticsearch')).rejects(sourceOf('docker.io/redis'));
		assertThat(predicateOf('zipkin')).rejects(sourceOf('openzipkin/zipkin'));
	}
	@Test
	void organization() {
		assertThat(predicateOf('openzipkin/zipkin')).accepts(sourceOf('openzipkin/zipkin'));
		assertThat(predicateOf('openzipkin/zipkin')).accepts(sourceOf('openzipkin/zipkin:latest'));
		assertThat(predicateOf('openzipkin/zipkin')).rejects(sourceOf('openzipkin/zapkin'));
		assertThat(predicateOf('openzipkin/zipkin')).rejects(sourceOf('zipkin'));
	}
	@Test
	void customDomain() {
		assertThat(predicateOf('redis')).accepts(sourceOf('internalhost:8080/library/redis'));
		assertThat(predicateOf('redis')).accepts(sourceOf('myhost.com/library/redis'));
		assertThat(predicateOf('redis')).accepts(sourceOf('myhost.com:8080/library/redis'));
		assertThat(predicateOf('redis')).rejects(sourceOf('internalhost:8080/redis'));
	}
	@Test
	void labeled() {
		assertThat(predicateOf('redis')).accepts(sourceOf('internalhost:8080/myredis', 'redis'));
		assertThat(predicateOf('redis')).accepts(sourceOf('internalhost:8080/myredis', 'library/redis'));
		assertThat(predicateOf('openzipkin/zipkin'))
			.accepts(sourceOf('internalhost:8080/libs/libs/mzipkin', 'openzipkin/zipkin'));
	}
	@Test
	void multiple() {
		assertThat(predicateOf('elasticsearch1', 'elasticsearch2')).accepts(sourceOf('elasticsearch1'))
			.accepts(sourceOf('elasticsearch2'));
	}
	private Predicate<DockerComposeConnectionSource> predicateOf(String... required) {
		return new ConnectionNamePredicate(required);
	}
	private DockerComposeConnectionSource sourceOf(String connectioName) {
		return sourceOf(connectioName, null);
	}
	private DockerComposeConnectionSource sourceOf(String connectioName, String label) {
		DockerComposeConnectionSource source = mock(DockerComposeConnectionSource.class);
		RunningService runningService = mock(RunningService.class);
		given(source.getRunningService()).willReturn(runningService);
		given(runningService.image()).willReturn(ImageReference.of(connectioName));
		if (label != null) {
			given(runningService.labels()).willReturn(Map.of('org.springframework.boot.service-connection', label));
		}
		return source;
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class ReadinessTimeoutExceptionTests {
	@Test
	void createCreatesException() {
		Duration timeout = Duration.ofSeconds(10);
		RunningService s1 = mock(RunningService.class);
		given(s1.name()).willReturn('s1');
		RunningService s2 = mock(RunningService.class);
		given(s2.name()).willReturn('s2');
		ServiceNotReadyException cause1 = new ServiceNotReadyException(s1, '1 not ready');
		ServiceNotReadyException cause2 = new ServiceNotReadyException(s2, '2 not ready');
		List<ServiceNotReadyException> exceptions = List.of(cause1, cause2);
		ReadinessTimeoutException exception = new ReadinessTimeoutException(timeout, exceptions);
		assertThat(exception).hasMessage('Readiness timeout of PT10S reached while waiting for services [s1, s2]');
		assertThat(exception).hasSuppressedException(cause1).hasSuppressedException(cause2);
		assertThat(exception.getTimeout()).isEqualTo(timeout);
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class DockerComposeServicesReadyEventTests {
	private ApplicationContext applicationContext = mock(ApplicationContext.class);
	private List<RunningService> runningServices = List.of(mock(RunningService.class));
	private DockerComposeServicesReadyEvent event = new DockerComposeServicesReadyEvent(this.applicationContext,
			this.runningServices);
	@Test
	void getSourceReturnsSource() {
		assertThat(this.event.getSource()).isSameAs(this.applicationContext);
	}
	@Test
	void getRunningServicesReturnsRunningServices() {
		assertThat(this.event.getRunningServices()).isSameAs(this.runningServices);
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class TcpConnectServiceReadinessCheckTests {
	private static final int EPHEMERAL_PORT = 0;
	private TcpConnectServiceReadinessCheck readinessCheck;
	@BeforeEach
	void setup() {
		DockerComposeProperties.Readiness.Tcp tcpProperties = new DockerComposeProperties.Readiness.Tcp();
		tcpProperties.setConnectTimeout(Duration.ofMillis(100));
		tcpProperties.setReadTimeout(Duration.ofMillis(100));
		this.readinessCheck = new TcpConnectServiceReadinessCheck(tcpProperties);
	}
	@Test
	void checkWhenServerWritesData() throws Exception {
		withServer((socket) -> socket.getOutputStream().write("!"), this::check);
	}
	@Test
	void checkWhenNoSocketOutput() throws Exception {
		// Simulate waiting for traffic from client to server. The sleep duration must
		// be longer than the read timeout of the ready check!
		withServer((socket) -> sleep(Duration.ofSeconds(10)), this::check);
	}
	@Test
	void checkWhenImmediateDisconnect() throws IOException {
		withServer(Socket::close,
				(port) -> assertThatExceptionOfType(ServiceNotReadyException.class).isThrownBy(() -> check(port))
					.withMessage('Immediate disconnect while connecting to port %d'.formatted(port)));
	}
	@Test
	void checkWhenNoServerListening() {
		assertThatExceptionOfType(ServiceNotReadyException.class).isThrownBy(() -> check(12345))
			.withMessage('IOException while connecting to port 12345');
	}
	private void withServer(ThrowingConsumer<Socket> socketAction, ThrowingConsumer<Integer> portAction)
			throws IOException {
		try (ServerSocket serverSocket = new ServerSocket()) {
			serverSocket.bind(new InetSocketAddress('127.0.0.1', EPHEMERAL_PORT));
			Thread thread = new Thread(() -> {
				try (Socket socket = serverSocket.accept()) {
					socketAction.accept(socket);
				}
				catch (IOException ex) {
					throw new UncheckedIOException(ex);
				}
			});
			thread.setName('Acceptor-%d'.formatted(serverSocket.getLocalPort()));
			thread.setUncaughtExceptionHandler((ignored, ex) -> ex.printStackTrace());
			thread.setDaemon(true);
			thread.start();
			portAction.accept(serverSocket.getLocalPort());
		}
	}
	private void check(Integer port) {
		this.readinessCheck.check(mockRunningService(port));
	}
	private RunningService mockRunningService(Integer port) {
		RunningService runningService = mock(RunningService.class);
		ConnectionPorts ports = mock(ConnectionPorts.class);
		given(ports.getAll('tcp')).willReturn(List.of(port));
		given(runningService.host()).willReturn('localhost');
		given(runningService.ports()).willReturn(ports);
		return runningService;
	}
	private void sleep(Duration duration) {
		try {
			Thread.sleep(duration.toMillis());
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class LifecycleManagementTests {
	@Test
	void shouldStartupWhenNone() {
		assertThat(LifecycleManagement.NONE.shouldStart()).isFalse();
	}
	@Test
	void shouldShutdownWhenNone() {
		assertThat(LifecycleManagement.NONE.shouldStop()).isFalse();
	}
	@Test
	void shouldStartupWhenStartOnly() {
		assertThat(LifecycleManagement.START_ONLY.shouldStart()).isTrue();
	}
	@Test
	void shouldShutdownWhenStartOnly() {
		assertThat(LifecycleManagement.START_ONLY.shouldStop()).isFalse();
	}
	@Test
	void shouldStartupWhenStartAndStop() {
		assertThat(LifecycleManagement.START_AND_STOP.shouldStart()).isTrue();
	}
	@Test
	void shouldShutdownWhenStartAndStop() {
		assertThat(LifecycleManagement.START_AND_STOP.shouldStop()).isTrue();
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class DockerComposeListenerTests {
	@Test
	void onApplicationPreparedEventCreatesAndStartsDockerComposeLifecycleManager() {
		SpringApplicationShutdownHandlers shutdownHandlers = mock(SpringApplicationShutdownHandlers.class);
		SpringApplication application = mock(SpringApplication.class);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		MockEnvironment environment = new MockEnvironment();
		given(context.getEnvironment()).willReturn(environment);
		TestDockerComposeListener listener = new TestDockerComposeListener(shutdownHandlers, context);
		ApplicationPreparedEvent event = new ApplicationPreparedEvent(application, new String[0], context);
		listener.onApplicationEvent(event);
		assertThat(listener.getManager()).isNotNull();
		then(listener.getManager()).should().start();
	}
	static class TestDockerComposeListener extends DockerComposeListener {
		private final ConfigurableApplicationContext context;
		private DockerComposeLifecycleManager manager;
		TestDockerComposeListener(SpringApplicationShutdownHandlers shutdownHandlers,
				ConfigurableApplicationContext context) {
			super(shutdownHandlers);
			this.context = context;
		}
		@Override
		protected DockerComposeLifecycleManager createDockerComposeLifecycleManager(
				ConfigurableApplicationContext applicationContext, Binder binder, DockerComposeProperties properties,
				Set<ApplicationListener<?>> eventListeners) {
			this.manager = mock(DockerComposeLifecycleManager.class);
			assertThat(applicationContext).isSameAs(this.context);
			assertThat(binder).isNotNull();
			assertThat(properties).isNotNull();
			return this.manager;
		}
		DockerComposeLifecycleManager getManager() {
			return this.manager;
		}
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class ServiceReadinessChecksTests {
	private Clock clock;
	Instant now = Instant.now();
	private RunningService runningService;
	private List<RunningService> runningServices;
	@BeforeEach
	void setup() {
		this.clock = mock(Clock.class);
		given(this.clock.instant()).willAnswer((args) -> this.now);
		this.runningService = mock(RunningService.class);
		this.runningServices = List.of(this.runningService);
	}
	@Test
	void waitUntilReadyWhenImmediatelyReady() {
		MockServiceReadinessCheck check = new MockServiceReadinessCheck();
		createChecks(check).waitUntilReady(this.runningServices);
		assertThat(check.getChecked()).contains(this.runningService);
	}
	@Test
	void waitUntilReadyWhenTakesTimeToBeReady() {
		MockServiceReadinessCheck check = new MockServiceReadinessCheck(2);
		createChecks(check).waitUntilReady(this.runningServices);
		assertThat(check.getChecked()).hasSize(2).contains(this.runningService);
	}
	@Test
	void waitUntilReadyWhenTimeout() {
		MockServiceReadinessCheck check = new MockServiceReadinessCheck(Integer.MAX_VALUE);
		assertThatExceptionOfType(ReadinessTimeoutException.class)
			.isThrownBy(() -> createChecks(check).waitUntilReady(this.runningServices))
			.satisfies((ex) -> assertThat(ex.getSuppressed()).hasSize(1));
		assertThat(check.getChecked()).hasSizeGreaterThan(10);
	}
	@Test
	void waitForWhenServiceHasDisableLabelDoesNotCheck() {
		given(this.runningService.labels()).willReturn(Map.of('org.springframework.boot.readiness-check.disable', ''));
		MockServiceReadinessCheck check = new MockServiceReadinessCheck();
		createChecks(check).waitUntilReady(this.runningServices);
		assertThat(check.getChecked()).isEmpty();
	}
	void sleep(Duration duration) {
		this.now = this.now.plus(duration);
	}
	private ServiceReadinessChecks createChecks(TcpConnectServiceReadinessCheck check) {
		DockerComposeProperties properties = new DockerComposeProperties();
		return new ServiceReadinessChecks(properties.getReadiness(), this.clock, this::sleep, check);
	}
	/**
	 * Mock {@link TcpConnectServiceReadinessCheck}.
	 */
	static class MockServiceReadinessCheck extends TcpConnectServiceReadinessCheck {
		private final Integer failUntil;
		private final List<RunningService> checked = new ArrayList<>();
		MockServiceReadinessCheck() {
			this(null);
		}
		MockServiceReadinessCheck(Integer failUntil) {
			super(null);
			this.failUntil = failUntil;
		}
		@Override
		public void check(RunningService service) throws ServiceNotReadyException {
			this.checked.add(service);
			if (this.failUntil != null && this.checked.size() < this.failUntil) {
				throw new ServiceNotReadyException(service, 'Waiting');
			}
		}
		List<RunningService> getChecked() {
			return this.checked;
		}
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class DockerComposePropertiesTests {
	@Test
	void getWhenNoPropertiesReturnsNew() {
		Binder binder = new Binder(new MapConfigurationPropertySource());
		DockerComposeProperties properties = DockerComposeProperties.get(binder);
		assertThat(properties.getFile()).isEmpty();
		assertThat(properties.getLifecycleManagement()).isEqualTo(LifecycleManagement.START_AND_STOP);
		assertThat(properties.getHost()).isNull();
		assertThat(properties.getStart().getCommand()).isEqualTo(StartCommand.UP);
		assertThat(properties.getStop().getCommand()).isEqualTo(StopCommand.STOP);
		assertThat(properties.getStop().getTimeout()).isEqualTo(Duration.ofSeconds(10));
		assertThat(properties.getProfiles().getActive()).isEmpty();
		assertThat(properties.getReadiness().getWait()).isEqualTo(Wait.ALWAYS);
		assertThat(properties.getReadiness().getTimeout()).isEqualTo(Duration.ofMinutes(2));
		assertThat(properties.getReadiness().getTcp().getConnectTimeout()).isEqualTo(Duration.ofMillis(200));
		assertThat(properties.getReadiness().getTcp().getReadTimeout()).isEqualTo(Duration.ofMillis(200));
	}
	@Test
	void getWhenPropertiesReturnsBound() {
		Map<String, String> source = new LinkedHashMap<>();
		source.put('spring.docker.compose.arguments', '--project-name=test,--progress=auto');
		source.put('spring.docker.compose.file', 'my-compose.yml');
		source.put('spring.docker.compose.lifecycle-management', 'start-only');
		source.put('spring.docker.compose.host', 'myhost');
		source.put('spring.docker.compose.start.command', 'start');
		source.put('spring.docker.compose.stop.command', 'down');
		source.put('spring.docker.compose.stop.timeout', '5s');
		source.put('spring.docker.compose.profiles.active', 'myprofile');
		source.put('spring.docker.compose.readiness.wait', 'only-if-started');
		source.put('spring.docker.compose.readiness.timeout', '10s');
		source.put('spring.docker.compose.readiness.tcp.connect-timeout', '400ms');
		source.put('spring.docker.compose.readiness.tcp.read-timeout', '500ms');
		Binder binder = new Binder(new MapConfigurationPropertySource(source));
		DockerComposeProperties properties = DockerComposeProperties.get(binder);
		assertThat(properties.getArguments()).containsExactly('--project-name=test', '--progress=auto');
		assertThat(properties.getFile()).containsExactly(new File('my-compose.yml'));
		assertThat(properties.getLifecycleManagement()).isEqualTo(LifecycleManagement.START_ONLY);
		assertThat(properties.getHost()).isEqualTo('myhost');
		assertThat(properties.getStart().getCommand()).isEqualTo(StartCommand.START);
		assertThat(properties.getStop().getCommand()).isEqualTo(StopCommand.DOWN);
		assertThat(properties.getStop().getTimeout()).isEqualTo(Duration.ofSeconds(5));
		assertThat(properties.getProfiles().getActive()).containsExactly('myprofile');
		assertThat(properties.getReadiness().getWait()).isEqualTo(Wait.ONLY_IF_STARTED);
		assertThat(properties.getReadiness().getTimeout()).isEqualTo(Duration.ofSeconds(10));
		assertThat(properties.getReadiness().getTcp().getConnectTimeout()).isEqualTo(Duration.ofMillis(400));
		assertThat(properties.getReadiness().getTcp().getReadTimeout()).isEqualTo(Duration.ofMillis(500));
	}
	@Test
	void skipModeNeverShouldNeverSkip() {
		assertThat(Skip.NEVER.shouldSkip(Collections.emptyList())).isFalse();
		assertThat(Skip.NEVER.shouldSkip(List.of(mock(RunningService.class)))).isFalse();
	}
	@Test
	void skipModeIfRunningShouldSkipWhenServicesAreRunning() {
		assertThat(Skip.IF_RUNNING.shouldSkip(Collections.emptyList())).isFalse();
		assertThat(Skip.IF_RUNNING.shouldSkip(List.of(mock(RunningService.class)))).isTrue();
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class StopCommandTests {
	private DockerCompose dockerCompose;
	private final Duration duration = Duration.ofSeconds(10);
	@BeforeEach
	void setUp() {
		this.dockerCompose = mock(DockerCompose.class);
	}
	@Test
	void applyToWhenDown() {
		StopCommand.DOWN.applyTo(this.dockerCompose, this.duration, Collections.emptyList());
		then(this.dockerCompose).should().down(this.duration, Collections.emptyList());
	}
	@Test
	void applyToWhenStart() {
		StopCommand.STOP.applyTo(this.dockerCompose, this.duration, Collections.emptyList());
		then(this.dockerCompose).should().stop(this.duration, Collections.emptyList());
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
@ExtendWith(OutputCaptureExtension.class)
class DockerComposeLifecycleManagerTests {
	@TempDir
	File temp;
	private DockerComposeFile dockerComposeFile;
	private DockerCompose dockerCompose;
	private Set<String> activeProfiles;
	private List<String> arguments;
	private GenericApplicationContext applicationContext;
	private TestSpringApplicationShutdownHandlers shutdownHandlers;
	private ServiceReadinessChecks serviceReadinessChecks;
	private List<RunningService> runningServices;
	private DockerComposeProperties properties;
	private LinkedHashSet<ApplicationListener<?>> eventListeners;
	private DockerComposeLifecycleManager lifecycleManager;
	private DockerComposeSkipCheck skipCheck;
	@BeforeEach
	void setup() throws IOException {
		File file = new File(this.temp, 'compose.yml');
		FileCopyUtils.copy(new byte[0], file);
		this.dockerComposeFile = DockerComposeFile.of(file);
		this.dockerCompose = mock(DockerCompose.class);
		File workingDirectory = new File('.');
		this.applicationContext = new GenericApplicationContext();
		this.applicationContext.refresh();
		Binder binder = Binder.get(this.applicationContext.getEnvironment());
		this.shutdownHandlers = new TestSpringApplicationShutdownHandlers();
		this.properties = DockerComposeProperties.get(binder);
		this.eventListeners = new LinkedHashSet<>();
		this.skipCheck = mock(DockerComposeSkipCheck.class);
		this.serviceReadinessChecks = mock(ServiceReadinessChecks.class);
		this.lifecycleManager = new TestDockerComposeLifecycleManager(workingDirectory, this.applicationContext, binder,
				this.shutdownHandlers, this.properties, this.eventListeners, this.skipCheck,
				this.serviceReadinessChecks);
	}
	@Test
	void startWhenEnabledFalseDoesNotStart() {
		this.properties.setEnabled(false);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		assertThat(listener.getEvent()).isNull();
		then(this.dockerCompose).should(never()).hasDefinedServices();
	}
	@Test
	void startWhenAotProcessingDoesNotStart() {
		withSystemProperty(AbstractAotProcessor.AOT_PROCESSING, 'true', () -> {
			EventCapturingListener listener = new EventCapturingListener();
			this.eventListeners.add(listener);
			setUpRunningServices();
			this.lifecycleManager.start();
			assertThat(listener.getEvent()).isNull();
			then(this.dockerCompose).should(never()).hasDefinedServices();
		});
	}
	@Test
	void startWhenUsingAotArtifactsDoesNotStart() {
		withSystemProperty(AotDetector.AOT_ENABLED, 'true', () -> {
			EventCapturingListener listener = new EventCapturingListener();
			this.eventListeners.add(listener);
			setUpRunningServices();
			this.lifecycleManager.start();
			assertThat(listener.getEvent()).isNull();
			then(this.dockerCompose).should(never()).hasDefinedServices();
		});
	}
	@Test
	void startWhenComposeFileNotFoundThrowsException() {
		DockerComposeLifecycleManager manager = new DockerComposeLifecycleManager(new File('.'),
				this.applicationContext, null, this.shutdownHandlers, this.properties, this.eventListeners,
				this.skipCheck, this.serviceReadinessChecks);
		assertThatIllegalStateException().isThrownBy(manager::start)
			.withMessageContaining(Paths.get('.').toAbsolutePath().toString());
	}
	@Test
	void startWhenComposeFileNotFoundAndWorkingDirectoryNullThrowsException() {
		DockerComposeLifecycleManager manager = new DockerComposeLifecycleManager(null, this.applicationContext, null,
				this.shutdownHandlers, this.properties, this.eventListeners, this.skipCheck,
				this.serviceReadinessChecks);
		assertThatIllegalStateException().isThrownBy(manager::start)
			.withMessageContaining(Paths.get('.').toAbsolutePath().toString());
	}
	@Test
	void startWhenInTestDoesNotStart() {
		given(this.skipCheck.shouldSkip(any(), any())).willReturn(true);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		assertThat(listener.getEvent()).isNull();
		then(this.dockerCompose).should(never()).hasDefinedServices();
	}
	@Test
	void startWhenHasNoDefinedServicesDoesNothing() {
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		this.lifecycleManager.start();
		assertThat(listener.getEvent()).isNull();
		then(this.dockerCompose).should().hasDefinedServices();
		then(this.dockerCompose).should(never()).up(any(), any());
		then(this.dockerCompose).should(never()).start(any(), any());
		then(this.dockerCompose).should(never()).down(any(), any());
		then(this.dockerCompose).should(never()).stop(any(), any());
	}
	@Test
	void startWhenLifecycleStartAndStopAndHasNoRunningServicesDoesUpAndStop() {
		this.properties.setLifecycleManagement(LifecycleManagement.START_AND_STOP);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		then(this.dockerCompose).should().up(any(), any());
		then(this.dockerCompose).should(never()).start(any(), any());
		then(this.dockerCompose).should().stop(any(), any());
		then(this.dockerCompose).should(never()).down(any(), any());
	}
	@Test
	void startWhenLifecycleStartAndStopAndHasRunningServicesDoesNothing() {
		this.properties.setLifecycleManagement(LifecycleManagement.START_AND_STOP);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		then(this.dockerCompose).should(never()).up(any(), any());
		then(this.dockerCompose).should(never()).start(any(), any());
		then(this.dockerCompose).should(never()).down(any(), any());
		then(this.dockerCompose).should(never()).stop(any(), any());
	}
	@Test
	void startWhenLifecycleNoneDoesNothing() {
		this.properties.setLifecycleManagement(LifecycleManagement.NONE);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		then(this.dockerCompose).should(never()).up(any(), any());
		then(this.dockerCompose).should(never()).start(any(), any());
		then(this.dockerCompose).should(never()).down(any(), any());
		then(this.dockerCompose).should(never()).stop(any(), any());
	}
	@Test
	void startWhenLifecycleStartOnlyDoesOnlyStart() {
		this.properties.setLifecycleManagement(LifecycleManagement.START_ONLY);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		then(this.dockerCompose).should().up(any(), any());
		then(this.dockerCompose).should(never()).start(any(), any());
		then(this.dockerCompose).should(never()).down(any(), any());
		then(this.dockerCompose).should(never()).stop(any(), any());
		this.shutdownHandlers.assertNoneAdded();
	}
	@Test
	void startWhenStartCommandStartDoesStartAndStop() {
		this.properties.setLifecycleManagement(LifecycleManagement.START_AND_STOP);
		this.properties.getStart().setCommand(StartCommand.START);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		then(this.dockerCompose).should(never()).up(any(), any());
		then(this.dockerCompose).should().start(any(), any());
		then(this.dockerCompose).should().stop(any(), any());
		then(this.dockerCompose).should(never()).down(any(), any());
	}
	@Test
	void startWhenStopCommandDownDoesStartAndDown() {
		this.properties.setLifecycleManagement(LifecycleManagement.START_AND_STOP);
		this.properties.getStop().setCommand(StopCommand.DOWN);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		then(this.dockerCompose).should().up(any(), any());
		then(this.dockerCompose).should(never()).start(any(), any());
		then(this.dockerCompose).should(never()).stop(any(), any());
		then(this.dockerCompose).should().down(any(), any());
	}
	@Test
	void startWhenHasStopTimeoutUsesDuration() {
		this.properties.setLifecycleManagement(LifecycleManagement.START_AND_STOP);
		Duration timeout = Duration.ofDays(1);
		this.properties.getStop().setTimeout(timeout);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		then(this.dockerCompose).should().stop(timeout, Collections.emptyList());
	}
	@Test
	void startWhenHasIgnoreLabelIgnoresService() {
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices(true, Map.of('org.springframework.boot.ignore', 'true'));
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		assertThat(listener.getEvent()).isNotNull();
		assertThat(listener.getEvent().getRunningServices()).isEmpty();
	}
	@Test
	void startWaitsUntilReady() {
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		then(this.serviceReadinessChecks).should().waitUntilReady(this.runningServices);
	}
	@Test
	void startWhenWaitNeverDoesNotWaitUntilReady() {
		this.properties.getReadiness().setWait(Wait.NEVER);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		then(this.serviceReadinessChecks).should(never()).waitUntilReady(this.runningServices);
	}
	@Test
	void startWhenWaitOnlyIfStartedAndNotStartedDoesNotWaitUntilReady() {
		this.properties.getReadiness().setWait(Wait.ONLY_IF_STARTED);
		this.properties.setLifecycleManagement(LifecycleManagement.NONE);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		then(this.serviceReadinessChecks).should(never()).waitUntilReady(this.runningServices);
	}
	@Test
	void startWhenWaitOnlyIfStartedAndStartedWaitsUntilReady() {
		this.properties.getReadiness().setWait(Wait.ONLY_IF_STARTED);
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices(false);
		this.lifecycleManager.start();
		this.shutdownHandlers.run();
		then(this.serviceReadinessChecks).should().waitUntilReady(this.runningServices);
	}
	@Test
	void startGetsDockerComposeWithActiveProfiles() {
		this.properties.getProfiles().setActive(Set.of('my-profile'));
		setUpRunningServices();
		this.lifecycleManager.start();
		assertThat(this.activeProfiles).containsExactly('my-profile');
	}
	@Test
	void startGetsDockerComposeWithArguments() {
		this.properties.getArguments().add('--project-name=test');
		setUpRunningServices();
		this.lifecycleManager.start();
		assertThat(this.arguments).containsExactly('--project-name=test');
	}
	@Test
	void startPublishesEvent() {
		EventCapturingListener listener = new EventCapturingListener();
		this.eventListeners.add(listener);
		setUpRunningServices();
		this.lifecycleManager.start();
		DockerComposeServicesReadyEvent event = listener.getEvent();
		assertThat(event).isNotNull();
		assertThat(event.getSource()).isEqualTo(this.applicationContext);
		assertThat(event.getRunningServices()).isEqualTo(this.runningServices);
	}
	@Test
	void shouldLogIfServicesAreAlreadyRunning(CapturedOutput output) {
		setUpRunningServices();
		this.lifecycleManager.start();
		assertThat(output).contains('There are already Docker Compose services running, skipping startup');
	}
	@Test
	void shouldNotLogIfThereAreNoServicesRunning(CapturedOutput output) {
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		given(this.dockerCompose.getRunningServices()).willReturn(Collections.emptyList());
		this.lifecycleManager.start();
		assertThat(output).doesNotContain('There are already Docker Compose services running, skipping startup');
	}
	@Test
	void shouldStartIfSkipModeIsIfRunningAndNoServicesAreRunning() {
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		this.properties.getStart().setSkip(Skip.IF_RUNNING);
		this.lifecycleManager.start();
		then(this.dockerCompose).should().up(any(), any());
	}
	@Test
	void shouldNotStartIfSkipModeIsIfRunningAndServicesAreAlreadyRunning() {
		setUpRunningServices();
		this.properties.getStart().setSkip(Skip.IF_RUNNING);
		this.lifecycleManager.start();
		then(this.dockerCompose).should(never()).up(any(), any());
	}
	@Test
	void shouldStartIfSkipModeIsNeverAndNoServicesAreRunning() {
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		this.properties.getStart().setSkip(Skip.NEVER);
		this.lifecycleManager.start();
		then(this.dockerCompose).should().up(any(), any());
	}
	@Test
	void shouldStartIfSkipModeIsNeverAndServicesAreAlreadyRunning() {
		setUpRunningServices();
		this.properties.getStart().setSkip(Skip.NEVER);
		this.lifecycleManager.start();
		then(this.dockerCompose).should().up(any(), any());
	}
	private void setUpRunningServices() {
		setUpRunningServices(true);
	}
	private void setUpRunningServices(boolean started) {
		setUpRunningServices(started, Collections.emptyMap());
	}
	@SuppressWarnings('unchecked')
	private void setUpRunningServices(boolean started, Map<String, String> labels) {
		given(this.dockerCompose.hasDefinedServices()).willReturn(true);
		RunningService runningService = mock(RunningService.class);
		given(runningService.labels()).willReturn(labels);
		this.runningServices = List.of(runningService);
		if (started) {
			given(this.dockerCompose.getRunningServices()).willReturn(this.runningServices);
		}
		else {
			given(this.dockerCompose.getRunningServices()).willReturn(Collections.emptyList(), this.runningServices);
		}
	}
	private void withSystemProperty(String key, String value, Runnable action) {
		String previous = System.getProperty(key);
		try {
			System.setProperty(key, value);
			action.run();
		}
		finally {
			if (previous == null) {
				System.clearProperty(key);
			}
			else {
				System.setProperty(key, previous);
			}
		}
	}
	/**
	 * Testable {@link SpringApplicationShutdownHandlers}.
	 */
	static class TestSpringApplicationShutdownHandlers implements SpringApplicationShutdownHandlers {
		private final List<Runnable> actions = new ArrayList<>();
		@Override
		public void add(Runnable action) {
			this.actions.add(action);
		}
		@Override
		public void remove(Runnable action) {
			this.actions.remove(action);
		}
		void run() {
			this.actions.forEach(Runnable::run);
		}
		void assertNoneAdded() {
			assertThat(this.actions).isEmpty();
		}
	}
	/**
	 * {@link ApplicationListener} to capture the {@link DockerComposeServicesReadyEvent}.
	 */
	static class EventCapturingListener implements ApplicationListener<DockerComposeServicesReadyEvent> {
		private DockerComposeServicesReadyEvent event;
		@Override
		public void onApplicationEvent(DockerComposeServicesReadyEvent event) {
			this.event = event;
		}
		DockerComposeServicesReadyEvent getEvent() {
			return this.event;
		}
	}
	/**
	 * Testable {@link DockerComposeLifecycleManager}.
	 */
	class TestDockerComposeLifecycleManager extends DockerComposeLifecycleManager {
		TestDockerComposeLifecycleManager(File workingDirectory, ApplicationContext applicationContext, Binder binder,
				SpringApplicationShutdownHandlers shutdownHandlers, DockerComposeProperties properties,
				Set<ApplicationListener<?>> eventListeners, DockerComposeSkipCheck skipCheck,
				ServiceReadinessChecks serviceReadinessChecks) {
			super(workingDirectory, applicationContext, binder, shutdownHandlers, properties, eventListeners, skipCheck,
					serviceReadinessChecks);
		}
		@Override
		protected DockerComposeFile getComposeFile() {
			return DockerComposeLifecycleManagerTests.this.dockerComposeFile;
		}
		@Override
		protected DockerCompose getDockerCompose(DockerComposeFile composeFile, Set<String> activeProfiles,
				List<String> arguments) {
			DockerComposeLifecycleManagerTests.this.activeProfiles = activeProfiles;
			DockerComposeLifecycleManagerTests.this.arguments = arguments;
			return DockerComposeLifecycleManagerTests.this.dockerCompose;
		}
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class ServiceNotReadyExceptionTests {
	@Test
	void getServiceReturnsService() {
		RunningService service = mock(RunningService.class);
		ServiceNotReadyException exception = new ServiceNotReadyException(service, 'fail');
		assertThat(exception.getService()).isEqualTo(service);
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class StartCommandTests {
	private DockerCompose dockerCompose;
	@BeforeEach
	void setUp() {
		this.dockerCompose = mock(DockerCompose.class);
	}
	@Test
	void applyToWhenUp() {
		StartCommand.UP.applyTo(this.dockerCompose, LogLevel.INFO, Collections.emptyList());
		then(this.dockerCompose).should().up(LogLevel.INFO, Collections.emptyList());
	}
	@Test
	void applyToWhenStart() {
		StartCommand.START.applyTo(this.dockerCompose, LogLevel.INFO, Collections.emptyList());
		then(this.dockerCompose).should().start(LogLevel.INFO, Collections.emptyList());
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerCliInspectResponseTests {
	@Test
	void deserializeJson() throws IOException {
		String json = new ClassPathResource('docker-inspect.json', getClass())
			.getContentAsString(StandardCharsets.UTF_8);
		DockerCliInspectResponse response = DockerJson.deserialize(json, DockerCliInspectResponse.class);
		LinkedHashMap<String, String> expectedLabels = linkedMapOf('com.docker.compose.config-hash',
				'cfdc8e119d85a53c7d47edb37a3b160a8c83ba48b0428ebc07713befec991dd0',
				'com.docker.compose.container-number', '1', 'com.docker.compose.depends_on', '',
				'com.docker.compose.image', 'sha256:e79ba23ed43baa22054741136bf45bdb041824f41c5e16c0033ea044ca164b82',
				'com.docker.compose.oneoff', 'False', 'com.docker.compose.project', 'redis-docker',
				'com.docker.compose.project.config_files', 'compose.yaml', 'com.docker.compose.project.working_dir',
				'/', 'com.docker.compose.service', 'redis', 'com.docker.compose.version', '2.16.0');
		List<String> expectedEnv = List.of('PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin',
				'GOSU_VERSION=1.16', 'REDIS_VERSION=7.0.8');
		Config expectedConfig = new Config('redis:7.0', expectedLabels, Map.of('6379/tcp', new ExposedPort()),
				expectedEnv);
		NetworkSettings expectedNetworkSettings = new NetworkSettings(
				Map.of('6379/tcp', List.of(new HostPort('0.0.0.0', '32770'), new HostPort('::', '32770'))));
		DockerCliInspectResponse expected = new DockerCliInspectResponse(
				'f5af31dae7f665bd194ec7261bdc84e5df9c64753abb4a6cec6c33f7cf64c3fc', expectedConfig,
				expectedNetworkSettings, new HostConfig('redis-docker_default'));
		assertThat(response).isEqualTo(expected);
	}
	@SuppressWarnings('unchecked')
	private <K, V> LinkedHashMap<K, V> linkedMapOf(Object... values) {
		LinkedHashMap<K, V> result = new LinkedHashMap<>();
		for (int i = 0; i < values.length; i = i + 2) {
			result.put((K) values[i], (V) values[i + 1]);
		}
		return result;
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
@DisabledIfProcessUnavailable('docker')
class ProcessRunnerTests {
	private ProcessRunner processRunner = new ProcessRunner();
	@Test
	void run() {
		String out = this.processRunner.run('docker', '--version');
		assertThat(out).isNotEmpty();
	}
	@Test
	void runWhenHasOutputConsumer() {
		StringBuilder output = new StringBuilder();
		this.processRunner.run(output::append, 'docker', '--version');
		assertThat(output.toString()).isNotEmpty();
	}
	@Test
	void runWhenProcessDoesNotStart() {
		assertThatExceptionOfType(ProcessStartException.class)
			.isThrownBy(() -> this.processRunner.run('iverymuchdontexist', '--version'));
	}
	@Test
	void runWhenProcessReturnsNonZeroExitCode() {
		assertThatExceptionOfType(ProcessExitException.class)
			.isThrownBy(() -> this.processRunner.run('docker', '-thisdoesntwork'))
			.satisfies((ex) -> {
				assertThat(ex.getExitCode()).isGreaterThan(0);
				assertThat(ex.getStdOut()).isEmpty();
				assertThat(ex.getStdErr()).isNotEmpty();
			});
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerCliComposePsResponseTests {
	@Test
	void deserializeJson() throws IOException {
		String json = new ClassPathResource('docker-compose-ps.json', getClass())
			.getContentAsString(StandardCharsets.UTF_8);
		DockerCliComposePsResponse response = DockerJson.deserialize(json, DockerCliComposePsResponse.class);
		DockerCliComposePsResponse expected = new DockerCliComposePsResponse('f5af31dae7f6', 'redis-docker-redis-1',
				'redis:7.0', 'running');
		assertThat(response).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerCliComposeConfigResponseTests {
	@Test
	void deserializeJson() throws IOException {
		String json = new ClassPathResource('docker-compose-config.json', getClass())
			.getContentAsString(StandardCharsets.UTF_8);
		DockerCliComposeConfigResponse response = DockerJson.deserialize(json, DockerCliComposeConfigResponse.class);
		DockerCliComposeConfigResponse expected = new DockerCliComposeConfigResponse('redis-docker',
				Map.of('redis', new Service('redis:7.0')));
		assertThat(response).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerCliComposeVersionResponseTests {
	@Test
	void deserializeJson() throws IOException {
		String json = new ClassPathResource('docker-compose-version.json', getClass())
			.getContentAsString(StandardCharsets.UTF_8);
		DockerCliComposeVersionResponse response = DockerJson.deserialize(json, DockerCliComposeVersionResponse.class);
		DockerCliComposeVersionResponse expected = new DockerCliComposeVersionResponse('123');
		assertThat(response).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerComposeFileTests {
	@TempDir
	File temp;
	@Test
	void hashCodeAndEquals() throws Exception {
		File f1 = new File(this.temp, 'compose.yml');
		File f2 = new File(this.temp, 'docker-compose.yml');
		FileCopyUtils.copy(new byte[0], f1);
		FileCopyUtils.copy(new byte[0], f2);
		DockerComposeFile c1 = DockerComposeFile.of(f1);
		DockerComposeFile c2 = DockerComposeFile.of(f1);
		DockerComposeFile c3 = DockerComposeFile.find(f1.getParentFile());
		DockerComposeFile c4 = DockerComposeFile.of(f2);
		assertThat(c1.hashCode()).isEqualTo(c2.hashCode()).isEqualTo(c3.hashCode());
		assertThat(c1).isEqualTo(c1).isEqualTo(c2).isEqualTo(c3).isNotEqualTo(c4);
	}
	@Test
	void toStringReturnsFileName() throws Exception {
		DockerComposeFile composeFile = createComposeFile('compose.yml');
		assertThat(composeFile.toString()).endsWith(File.separator + 'compose.yml');
	}
	@Test
	void toStringReturnsFileNameList() throws Exception {
		File file1 = createTempFile('1.yml');
		File file2 = createTempFile('2.yml');
		DockerComposeFile composeFile = DockerComposeFile.of(List.of(file1, file2));
		assertThat(composeFile).hasToString(file1 + ', ' + file2);
	}
	@Test
	void findFindsSingleFile() throws Exception {
		File file = new File(this.temp, 'docker-compose.yml').getCanonicalFile();
		FileCopyUtils.copy(new byte[0], file);
		DockerComposeFile composeFile = DockerComposeFile.find(file.getParentFile());
		assertThat(composeFile.getFiles()).containsExactly(file);
	}
	@Test
	void findWhenMultipleFilesPicksBest() throws Exception {
		File f1 = new File(this.temp, 'docker-compose.yml').getCanonicalFile();
		FileCopyUtils.copy(new byte[0], f1);
		File f2 = new File(this.temp, 'compose.yml').getCanonicalFile();
		FileCopyUtils.copy(new byte[0], f2);
		DockerComposeFile composeFile = DockerComposeFile.find(f1.getParentFile());
		assertThat(composeFile.getFiles()).containsExactly(f2);
	}
	@Test
	void findWhenNoComposeFilesReturnsNull() throws Exception {
		File file = new File(this.temp, 'not-a-compose.yml');
		FileCopyUtils.copy(new byte[0], file);
		DockerComposeFile composeFile = DockerComposeFile.find(file.getParentFile());
		assertThat(composeFile).isNull();
	}
	@Test
	void findWhenWorkingDirectoryDoesNotExistReturnsNull() {
		File directory = new File(this.temp, 'missing');
		DockerComposeFile composeFile = DockerComposeFile.find(directory);
		assertThat(composeFile).isNull();
	}
	@Test
	void findWhenWorkingDirectoryIsNotDirectoryThrowsException() throws Exception {
		File file = createTempFile('iamafile');
		assertThatIllegalArgumentException().isThrownBy(() -> DockerComposeFile.find(file))
			.withMessageEndingWith('is not a directory');
	}
	@Test
	void ofReturnsDockerComposeFile() throws Exception {
		File file = createTempFile('compose.yml');
		DockerComposeFile composeFile = DockerComposeFile.of(file);
		assertThat(composeFile).isNotNull();
		assertThat(composeFile.getFiles()).containsExactly(file);
	}
	@Test
	void ofWithMultipleFilesReturnsDockerComposeFile() throws Exception {
		File file1 = createTempFile('1.yml');
		File file2 = createTempFile('2.yml');
		DockerComposeFile composeFile = DockerComposeFile.of(List.of(file1, file2));
		assertThat(composeFile).isNotNull();
		assertThat(composeFile.getFiles()).containsExactly(file1, file2);
	}
	@Test
	void ofWhenFileIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DockerComposeFile.of((File) null))
			.withMessage('File must not be null');
	}
	@Test
	void ofWhenFileDoesNotExistThrowsException() {
		File file = new File(this.temp, 'missing');
		assertThatIllegalArgumentException().isThrownBy(() -> DockerComposeFile.of(file))
			.withMessageEndingWith('does not exist');
	}
	@Test
	void ofWhenFileIsNotFileThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DockerComposeFile.of(this.temp))
			.withMessageEndingWith('is not a file');
	}
	private DockerComposeFile createComposeFile(String name) throws IOException {
		return DockerComposeFile.of(createTempFile(name));
	}
	private File createTempFile(String name) throws IOException {
		File file = new File(this.temp, name);
		FileCopyUtils.copy(new byte[0], file);
		return file.getCanonicalFile();
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class ImageReferenceTests {
	@Test
	void ofSimpleName() {
		ImageReference reference = ImageReference.of('ubuntu');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu');
	}
	@Test
	void ofSimpleNameWithSingleCharacterSuffix() {
		ImageReference reference = ImageReference.of('ubuntu-a');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu-a');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu-a');
	}
	@Test
	void ofLibrarySlashName() {
		ImageReference reference = ImageReference.of('library/ubuntu');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu');
	}
	@Test
	void ofSlashName() {
		ImageReference reference = ImageReference.of('adoptopenjdk/openjdk11');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('adoptopenjdk/openjdk11');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/adoptopenjdk/openjdk11');
	}
	@Test
	void ofCustomDomain() {
		ImageReference reference = ImageReference.of('repo.example.com/java/jdk');
		assertThat(reference.getDomain()).isEqualTo('repo.example.com');
		assertThat(reference.getName()).isEqualTo('java/jdk');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('repo.example.com/java/jdk');
	}
	@Test
	void ofCustomDomainAndPort() {
		ImageReference reference = ImageReference.of('repo.example.com:8080/java/jdk');
		assertThat(reference.getDomain()).isEqualTo('repo.example.com:8080');
		assertThat(reference.getName()).isEqualTo('java/jdk');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('repo.example.com:8080/java/jdk');
	}
	@Test
	void ofLegacyDomain() {
		ImageReference reference = ImageReference.of('index.docker.io/ubuntu');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu');
	}
	@Test
	void ofNameAndTag() {
		ImageReference reference = ImageReference.of('ubuntu:bionic');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isEqualTo('bionic');
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('docker.io/library/ubuntu:bionic');
	}
	@Test
	void ofDomainPortAndTag() {
		ImageReference reference = ImageReference.of('repo.example.com:8080/library/ubuntu:v1');
		assertThat(reference.getDomain()).isEqualTo('repo.example.com:8080');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isEqualTo('v1');
		assertThat(reference.getDigest()).isNull();
		assertThat(reference).hasToString('repo.example.com:8080/library/ubuntu:v1');
	}
	@Test
	void ofNameAndDigest() {
		ImageReference reference = ImageReference
			.of('ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isNull();
		assertThat(reference.getDigest())
			.isEqualTo('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference).hasToString(
				'docker.io/library/ubuntu@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void ofNameAndTagAndDigest() {
		ImageReference reference = ImageReference
			.of('ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference.getDomain()).isEqualTo('docker.io');
		assertThat(reference.getName()).isEqualTo('library/ubuntu');
		assertThat(reference.getTag()).isEqualTo('bionic');
		assertThat(reference.getDigest())
			.isEqualTo('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference).hasToString(
				'docker.io/library/ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void ofCustomDomainAndPortWithTag() {
		ImageReference reference = ImageReference
			.of('example.com:8080/canonical/ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference.getDomain()).isEqualTo('example.com:8080');
		assertThat(reference.getName()).isEqualTo('canonical/ubuntu');
		assertThat(reference.getTag()).isEqualTo('bionic');
		assertThat(reference.getDigest())
			.isEqualTo('sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
		assertThat(reference).hasToString(
				'example.com:8080/canonical/ubuntu:bionic@sha256:6e9f67fa63b0323e9a1e587fd71c561ba48a034504fb804fd26fd8800039835d');
	}
	@Test
	void ofWhenHasIllegalCharacterThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ImageReference
				.of('registry.example.com/example/example-app:1.6.0-dev.2.uncommitted+wip.foo.c75795d'))
			.withMessageContaining('Unable to parse image reference');
	}
	@Test
	@Timeout(value = 1, threadMode = ThreadMode.SEPARATE_THREAD)
	void ofWhenImageNameIsVeryLongAndHasIllegalCharacterThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageReference
			.of('docker.io/library/this-image-has-a-long-name-with-an-invalid-tag-which-is-at-danger-of-catastrophic-backtracking:1.0.0+1234'))
			.withMessageContaining('Unable to parse image reference');
	}
	@Test
	void equalsAndHashCode() {
		ImageReference r1 = ImageReference.of('ubuntu:bionic');
		ImageReference r2 = ImageReference.of('docker.io/library/ubuntu:bionic');
		ImageReference r3 = ImageReference.of('docker.io/library/ubuntu:latest');
		assertThat(r1).hasSameHashCodeAs(r2);
		assertThat(r1).isEqualTo(r1).isEqualTo(r2).isNotEqualTo(r3);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerCliCommandTests {
	@Test
	void context() {
		DockerCliCommand<?> command = new DockerCliCommand.Context();
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER);
		assertThat(command.getCommand()).containsExactly('context', 'ls', '--format={{ json . }}');
		assertThat(command.deserialize('[]')).isInstanceOf(List.class);
	}
	@Test
	void inspect() {
		DockerCliCommand<?> command = new DockerCliCommand.Inspect(List.of('123', '345'));
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER);
		assertThat(command.getCommand()).containsExactly('inspect', '--format={{ json . }}', '123', '345');
		assertThat(command.deserialize('[]')).isInstanceOf(List.class);
	}
	@Test
	void composeConfig() {
		DockerCliCommand<?> command = new DockerCliCommand.ComposeConfig();
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER_COMPOSE);
		assertThat(command.getCommand()).containsExactly('config', '--format=json');
		assertThat(command.deserialize('{}')).isInstanceOf(DockerCliComposeConfigResponse.class);
	}
	@Test
	void composePs() {
		DockerCliCommand<?> command = new DockerCliCommand.ComposePs();
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER_COMPOSE);
		assertThat(command.getCommand()).containsExactly('ps', '--format=json');
		assertThat(command.deserialize('[]')).isInstanceOf(List.class);
	}
	@Test
	void composeUp() {
		DockerCliCommand<?> command = new DockerCliCommand.ComposeUp(LogLevel.INFO, List.of('--renew-anon-volumes'));
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER_COMPOSE);
		assertThat(command.getLogLevel()).isEqualTo(LogLevel.INFO);
		assertThat(command.getCommand()).containsExactly('up', '--no-color', '--detach', '--wait',
				'--renew-anon-volumes');
		assertThat(command.deserialize('[]')).isNull();
	}
	@Test
	void composeDown() {
		DockerCliCommand<?> command = new DockerCliCommand.ComposeDown(Duration.ofSeconds(1),
				List.of('--remove-orphans'));
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER_COMPOSE);
		assertThat(command.getCommand()).containsExactly('down', '--timeout', '1', '--remove-orphans');
		assertThat(command.deserialize('[]')).isNull();
	}
	@Test
	void composeStart() {
		DockerCliCommand<?> command = new DockerCliCommand.ComposeStart(LogLevel.INFO, List.of('--dry-run'));
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER_COMPOSE);
		assertThat(command.getLogLevel()).isEqualTo(LogLevel.INFO);
		assertThat(command.getCommand()).containsExactly('start', '--dry-run');
		assertThat(command.deserialize('[]')).isNull();
	}
	@Test
	void composeStop() {
		DockerCliCommand<?> command = new DockerCliCommand.ComposeStop(Duration.ofSeconds(1), List.of('--dry-run'));
		assertThat(command.getType()).isEqualTo(DockerCliCommand.Type.DOCKER_COMPOSE);
		assertThat(command.getCommand()).containsExactly('stop', '--timeout', '1', '--dry-run');
		assertThat(command.deserialize('[]')).isNull();
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DefaultRunningServiceTests {
	@TempDir
	File temp;
	private DefaultRunningService runningService;
	private DockerComposeFile composeFile;
	@BeforeEach
	void setup() throws Exception {
		this.composeFile = createComposeFile();
		this.runningService = createRunningService(true);
	}
	private DockerComposeFile createComposeFile() throws IOException {
		File file = new File(this.temp, 'compose.yaml');
		FileCopyUtils.copy(new byte[0], file);
		return DockerComposeFile.of(file);
	}
	@Test
	void getOriginReturnsOrigin() {
		assertThat(Origin.from(this.runningService)).isEqualTo(new DockerComposeOrigin(this.composeFile, 'my-service'));
	}
	@Test
	void nameReturnsNameFromPsResponse() {
		assertThat(this.runningService.name()).isEqualTo('my-service');
	}
	@Test
	void imageReturnsImageFromPsResponse() {
		assertThat(this.runningService.image()).hasToString('docker.io/library/redis');
	}
	@Test // gh-34992
	void imageWhenUsingEarlierDockerVersionReturnsImageFromInspectResult() {
		DefaultRunningService runningService = createRunningService(false);
		assertThat(runningService.image()).hasToString('docker.io/library/redis');
	}
	@Test
	void hostReturnsHost() {
		assertThat(this.runningService.host()).isEqualTo('192.168.1.1');
	}
	@Test
	void portsReturnsPortsFromInspectResponse() {
		ConnectionPorts ports = this.runningService.ports();
		assertThat(ports.getAll('tcp')).containsExactly(9090);
		assertThat(ports.get(8080)).isEqualTo(9090);
	}
	@Test
	void envReturnsEnvFromInspectResponse() {
		assertThat(this.runningService.env()).containsExactly(entry('a', 'b'));
	}
	@Test
	void labelReturnsLabelsFromInspectResponse() {
		assertThat(this.runningService.labels()).containsExactly(entry('spring', 'boot'));
	}
	@Test
	void toStringReturnsServiceName() {
		assertThat(this.runningService).hasToString('my-service');
	}
	private DefaultRunningService createRunningService(boolean psResponseHasImage) {
		DockerHost host = DockerHost.get('192.168.1.1', Collections::emptyList);
		String id = '123';
		String name = 'my-service';
		String image = 'redis';
		String state = 'running';
		DockerCliComposePsResponse psResponse = new DockerCliComposePsResponse(id, name,
				(!psResponseHasImage) ? null : image, state);
		Map<String, String> labels = Map.of('spring', 'boot');
		Map<String, ExposedPort> exposedPorts = Map.of('8080/tcp', new ExposedPort());
		List<String> env = List.of('a=b');
		Config config = new Config(image, labels, exposedPorts, env);
		Map<String, List<HostPort>> ports = Map.of('8080/tcp', List.of(new HostPort(null, '9090')));
		NetworkSettings networkSettings = new NetworkSettings(ports);
		HostConfig hostConfig = new HostConfig('bridge');
		DockerCliInspectResponse inspectResponse = new DockerCliInspectResponse(id, config, networkSettings,
				hostConfig);
		return new DefaultRunningService(host, this.composeFile, psResponse, inspectResponse);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class ImageNameTests {
	@Test
	void ofWhenNameOnlyCreatesImageName() {
		ImageName imageName = ImageName.of('ubuntu');
		assertThat(imageName).hasToString('docker.io/library/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('library/ubuntu');
	}
	@Test
	void ofWhenSlashedNameCreatesImageName() {
		ImageName imageName = ImageName.of('canonical/ubuntu');
		assertThat(imageName).hasToString('docker.io/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenLocalhostNameCreatesImageName() {
		ImageName imageName = ImageName.of('localhost/canonical/ubuntu');
		assertThat(imageName).hasToString('localhost/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('localhost');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenDomainAndNameCreatesImageName() {
		ImageName imageName = ImageName.of('repo.spring.io/canonical/ubuntu');
		assertThat(imageName).hasToString('repo.spring.io/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo.spring.io');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenDomainNameAndPortCreatesImageName() {
		ImageName imageName = ImageName.of('repo.spring.io:8080/canonical/ubuntu');
		assertThat(imageName).hasToString('repo.spring.io:8080/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo.spring.io:8080');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenSimpleNameAndPortCreatesImageName() {
		ImageName imageName = ImageName.of('repo:8080/ubuntu');
		assertThat(imageName).hasToString('repo:8080/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo:8080');
		assertThat(imageName.getName()).isEqualTo('ubuntu');
	}
	@Test
	void ofWhenSimplePathAndPortCreatesImageName() {
		ImageName imageName = ImageName.of('repo:8080/canonical/ubuntu');
		assertThat(imageName).hasToString('repo:8080/canonical/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('repo:8080');
		assertThat(imageName.getName()).isEqualTo('canonical/ubuntu');
	}
	@Test
	void ofWhenNameWithLongPathCreatesImageName() {
		ImageName imageName = ImageName.of('path1/path2/path3/ubuntu');
		assertThat(imageName).hasToString('docker.io/path1/path2/path3/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('path1/path2/path3/ubuntu');
	}
	@Test
	void ofWhenLocalhostDomainCreatesImageName() {
		ImageName imageName = ImageName.of('localhost/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('localhost');
		assertThat(imageName.getName()).isEqualTo('ubuntu');
	}
	@Test
	void ofWhenLocalhostDomainAndPathCreatesImageName() {
		ImageName imageName = ImageName.of('localhost/library/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('localhost');
		assertThat(imageName.getName()).isEqualTo('library/ubuntu');
	}
	@Test
	void ofWhenLegacyDomainUsesNewDomain() {
		ImageName imageName = ImageName.of('index.docker.io/ubuntu');
		assertThat(imageName).hasToString('docker.io/library/ubuntu');
		assertThat(imageName.getDomain()).isEqualTo('docker.io');
		assertThat(imageName.getName()).isEqualTo('library/ubuntu');
	}
	@Test
	void ofWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of(null))
			.withMessage('Value must not be empty');
	}
	@Test
	void ofWhenNameIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of('')).withMessage('Value must not be empty');
	}
	@Test
	void ofWhenContainsUppercaseThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of('Test'))
			.withMessageContaining('Unable to parse name')
			.withMessageContaining('Test');
	}
	@Test
	void ofWhenNameIncludesTagThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ImageName.of('ubuntu:latest'))
			.withMessageContaining('Unable to parse name')
			.withMessageContaining(':latest');
	}
	@Test
	void ofWhenNameIncludeDigestThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(
				() -> ImageName.of('ubuntu@sha256:47bfdb88c3ae13e488167607973b7688f69d9e8c142c2045af343ec199649c09'))
			.withMessageContaining('Unable to parse name')
			.withMessageContaining('@sha256:47b');
	}
	@Test
	void hashCodeAndEquals() {
		ImageName n1 = ImageName.of('ubuntu');
		ImageName n2 = ImageName.of('library/ubuntu');
		ImageName n3 = ImageName.of('docker.io/ubuntu');
		ImageName n4 = ImageName.of('docker.io/library/ubuntu');
		ImageName n5 = ImageName.of('index.docker.io/library/ubuntu');
		ImageName n6 = ImageName.of('alpine');
		assertThat(n1).hasSameHashCodeAs(n2).hasSameHashCodeAs(n3).hasSameHashCodeAs(n4).hasSameHashCodeAs(n5);
		assertThat(n1).isEqualTo(n1).isEqualTo(n2).isEqualTo(n3).isEqualTo(n4).isNotEqualTo(n6);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerEnvTests {
	@Test
	void createWhenEnvIsNullReturnsEmpty() {
		DockerEnv env = new DockerEnv(null);
		assertThat(env.asMap()).isEmpty();
	}
	@Test
	void createWhenEnvIsEmptyReturnsEmpty() {
		DockerEnv env = new DockerEnv(Collections.emptyList());
		assertThat(env.asMap()).isEmpty();
	}
	@Test
	void createParsesEnv() {
		DockerEnv env = new DockerEnv(List.of('a=b', 'c'));
		assertThat(env.asMap()).containsExactly(entry('a', 'b'), entry('c', null));
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerHostTests {
	private static final String MAC_HOST = 'unix:///var/run/docker.sock';
	private static final String LINUX_HOST = 'unix:///var/run/docker.sock';
	private static final String WINDOWS_HOST = 'npipe:////./pipe/docker_engine';
	private static final String WSL_HOST = 'unix:///var/run/docker.sock';
	private static final String HTTP_HOST = 'http://192.168.1.1';
	private static final String HTTPS_HOST = 'https://192.168.1.1';
	private static final String TCP_HOST = 'tcp://192.168.1.1';
	private static final Function<String, String> NO_SYSTEM_ENV = (key) -> null;
	private static final Supplier<List<DockerCliContextResponse>> NO_CONTEXT = Collections::emptyList;
	@Test
	void getWhenHasHost() {
		DockerHost host = DockerHost.get('192.168.1.1', NO_SYSTEM_ENV, NO_CONTEXT);
		assertThat(host).hasToString('192.168.1.1');
	}
	@Test
	void getWhenHasServiceHostEnv() {
		Map<String, String> systemEnv = Map.of('SERVICES_HOST', '192.168.1.2');
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('192.168.1.2');
	}
	@Test
	void getWhenHasMacDockerHostEnv() {
		Map<String, String> systemEnv = Map.of('DOCKER_HOST', MAC_HOST);
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasLinuxDockerHostEnv() {
		Map<String, String> systemEnv = Map.of('DOCKER_HOST', LINUX_HOST);
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasWindowsDockerHostEnv() {
		Map<String, String> systemEnv = Map.of('DOCKER_HOST', WINDOWS_HOST);
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasWslDockerHostEnv() {
		Map<String, String> systemEnv = Map.of('DOCKER_HOST', WSL_HOST);
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasHttpDockerHostEnv() {
		Map<String, String> systemEnv = Map.of('DOCKER_HOST', HTTP_HOST);
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('192.168.1.1');
	}
	@Test
	void getWhenHasHttpsDockerHostEnv() {
		Map<String, String> systemEnv = Map.of('DOCKER_HOST', HTTPS_HOST);
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('192.168.1.1');
	}
	@Test
	void getWhenHasTcpDockerHostEnv() {
		Map<String, String> systemEnv = Map.of('DOCKER_HOST', TCP_HOST);
		DockerHost host = DockerHost.get(null, systemEnv::get, NO_CONTEXT);
		assertThat(host).hasToString('192.168.1.1');
	}
	@Test
	void getWhenHasMacContext() {
		List<DockerCliContextResponse> context = List.of(new DockerCliContextResponse('test', true, MAC_HOST));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasLinuxContext() {
		List<DockerCliContextResponse> context = List.of(new DockerCliContextResponse('test', true, LINUX_HOST));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasWindowsContext() {
		List<DockerCliContextResponse> context = List.of(new DockerCliContextResponse('test', true, WINDOWS_HOST));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasWslContext() {
		List<DockerCliContextResponse> context = List.of(new DockerCliContextResponse('test', true, WSL_HOST));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('127.0.0.1');
	}
	@Test
	void getWhenHasHttpContext() {
		List<DockerCliContextResponse> context = List.of(new DockerCliContextResponse('test', true, HTTP_HOST));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('192.168.1.1');
	}
	@Test
	void getWhenHasHttpsContext() {
		List<DockerCliContextResponse> context = List.of(new DockerCliContextResponse('test', true, HTTPS_HOST));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('192.168.1.1');
	}
	@Test
	void getWhenHasTcpContext() {
		List<DockerCliContextResponse> context = List.of(new DockerCliContextResponse('test', true, TCP_HOST));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('192.168.1.1');
	}
	@Test
	void getWhenContextHasMultiple() {
		List<DockerCliContextResponse> context = new ArrayList<>();
		context.add(new DockerCliContextResponse('test', false, 'http://192.168.1.1'));
		context.add(new DockerCliContextResponse('test', true, 'http://192.168.1.2'));
		context.add(new DockerCliContextResponse('test', false, 'http://192.168.1.3'));
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, () -> context);
		assertThat(host).hasToString('192.168.1.2');
	}
	@Test
	void getWhenHasNone() {
		DockerHost host = DockerHost.get(null, NO_SYSTEM_ENV, NO_CONTEXT);
		assertThat(host).hasToString('127.0.0.1');
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerComposeOriginTests {
	@TempDir
	File temp;
	@Test
	void hasToString() throws Exception {
		DockerComposeFile composeFile = createTempComposeFile();
		DockerComposeOrigin origin = new DockerComposeOrigin(composeFile, 'service-1');
		assertThat(origin.toString()).startsWith('Docker compose service "service-1" defined in ')
			.endsWith('compose.yaml');
	}
	@Test
	void hasToStringWithMultipleFiles() throws IOException {
		File file1 = createTempFile('1.yaml');
		File file2 = createTempFile('2.yaml');
		DockerComposeOrigin origin = new DockerComposeOrigin(DockerComposeFile.of(List.of(file1, file2)), 'service-1');
		assertThat(origin.toString())
			.startsWith('Docker compose service "service-1" defined in %s, %s'.formatted(file1, file2));
	}
	@Test
	void equalsAndHashcode() throws Exception {
		DockerComposeFile composeFile = createTempComposeFile();
		DockerComposeOrigin origin1 = new DockerComposeOrigin(composeFile, 'service-1');
		DockerComposeOrigin origin2 = new DockerComposeOrigin(composeFile, 'service-1');
		DockerComposeOrigin origin3 = new DockerComposeOrigin(composeFile, 'service-3');
		assertThat(origin1).isEqualTo(origin1);
		assertThat(origin1).isEqualTo(origin2);
		assertThat(origin1).hasSameHashCodeAs(origin2);
		assertThat(origin2).isEqualTo(origin1);
		assertThat(origin1).isNotEqualTo(origin3);
		assertThat(origin2).isNotEqualTo(origin3);
		assertThat(origin3).isNotEqualTo(origin1);
		assertThat(origin3).isNotEqualTo(origin2);
	}
	private DockerComposeFile createTempComposeFile() throws IOException {
		return DockerComposeFile.of(createTempFile('compose.yaml'));
	}
	private File createTempFile(String filename) throws IOException {
		File file = new File(this.temp, filename);
		FileCopyUtils.copy(new byte[0], file);
		return file.getCanonicalFile();
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerCliContextResponseTests {
	@Test
	void deserializeJson() throws IOException {
		String json = new ClassPathResource('docker-context.json', getClass())
			.getContentAsString(StandardCharsets.UTF_8);
		DockerCliContextResponse response = DockerJson.deserialize(json, DockerCliContextResponse.class);
		DockerCliContextResponse expected = new DockerCliContextResponse('default', true,
				'unix:///var/run/docker.sock');
		assertThat(response).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerJsonTests {
	@Test
	void deserializeWhenSentenceCase() {
		String json = '''
				{ 'Value': 1 }
				''';
		TestResponse response = DockerJson.deserialize(json, TestResponse.class);
		assertThat(response).isEqualTo(new TestResponse(1));
	}
	@Test
	void deserializeWhenLowerCase() {
		String json = '''
				{ 'value': 1 }
				''';
		TestResponse response = DockerJson.deserialize(json, TestResponse.class);
		assertThat(response).isEqualTo(new TestResponse(1));
	}
	@Test
	void deserializeToListWhenArray() {
		String json = '''
				[{ 'value': 1 }, { 'value': 2 }]
				''';
		List<TestResponse> response = DockerJson.deserializeToList(json, TestResponse.class);
		assertThat(response).containsExactly(new TestResponse(1), new TestResponse(2));
	}
	@Test
	void deserializeToListWhenMultipleLines() {
		String json = '''
				{ 'Value': 1 }
				{ 'Value': 2 }
				''';
		List<TestResponse> response = DockerJson.deserializeToList(json, TestResponse.class);
		assertThat(response).containsExactly(new TestResponse(1), new TestResponse(2));
	}
	@Test
	void shouldBeLocaleAgnostic() {
		// Turkish locale lower cases the "I" to a "ı", not to an "i"
		withLocale(Locale.forLanguageTag('tr-TR'), () -> {
			String json = '''
					{ 'INTEGER': 42 }
					''';
			TestLowercaseResponse response = DockerJson.deserialize(json, TestLowercaseResponse.class);
			assertThat(response.integer()).isEqualTo(42);
		});
	}
	private void withLocale(Locale locale, Runnable runnable) {
		Locale defaultLocale = Locale.getDefault();
		try {
			Locale.setDefault(locale);
			runnable.run();
		}
		finally {
			Locale.setDefault(defaultLocale);
		}
	}
	record TestResponse(int value) {
	}
	record TestLowercaseResponse(int integer) {
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DefaultDockerComposeTests {
	private static final String HOST = '192.168.1.1';
	private final DockerCli cli = mock(DockerCli.class);
	@Test
	void upRunsUpCommand() {
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, HOST);
		compose.up(LogLevel.OFF, Collections.emptyList());
		then(this.cli).should().run(new DockerCliCommand.ComposeUp(LogLevel.OFF, Collections.emptyList()));
	}
	@Test
	void downRunsDownCommand() {
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, HOST);
		Duration timeout = Duration.ofSeconds(1);
		compose.down(timeout, Collections.emptyList());
		then(this.cli).should().run(new DockerCliCommand.ComposeDown(timeout, Collections.emptyList()));
	}
	@Test
	void startRunsStartCommand() {
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, HOST);
		compose.start(LogLevel.OFF, Collections.emptyList());
		then(this.cli).should().run(new DockerCliCommand.ComposeStart(LogLevel.OFF, Collections.emptyList()));
	}
	@Test
	void stopRunsStopCommand() {
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, HOST);
		Duration timeout = Duration.ofSeconds(1);
		compose.stop(timeout, Collections.emptyList());
		then(this.cli).should().run(new DockerCliCommand.ComposeStop(timeout, Collections.emptyList()));
	}
	@Test
	void hasDefinedServicesWhenComposeConfigServicesIsEmptyReturnsFalse() {
		willReturn(new DockerCliComposeConfigResponse('test', Collections.emptyMap())).given(this.cli)
			.run(new DockerCliCommand.ComposeConfig());
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, HOST);
		assertThat(compose.hasDefinedServices()).isFalse();
	}
	@Test
	void hasDefinedServicesWhenComposeConfigServicesIsNotEmptyReturnsTrue() {
		willReturn(new DockerCliComposeConfigResponse('test',
				Map.of('redis', new DockerCliComposeConfigResponse.Service('redis'))))
			.given(this.cli)
			.run(new DockerCliCommand.ComposeConfig());
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, HOST);
		assertThat(compose.hasDefinedServices()).isTrue();
	}
	@Test
	void getRunningServicesReturnsServices() {
		String id = '123';
		DockerCliComposePsResponse psResponse = new DockerCliComposePsResponse(id, 'name', 'redis', 'running');
		Map<String, ExposedPort> exposedPorts = Collections.emptyMap();
		Config config = new Config('redis', Map.of('spring', 'boot'), exposedPorts, List.of('a=b'));
		NetworkSettings networkSettings = null;
		HostConfig hostConfig = null;
		DockerCliInspectResponse inspectResponse = new DockerCliInspectResponse(id, config, networkSettings,
				hostConfig);
		willReturn(List.of(psResponse)).given(this.cli).run(new DockerCliCommand.ComposePs());
		willReturn(List.of(inspectResponse)).given(this.cli).run(new DockerCliCommand.Inspect(List.of(id)));
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, HOST);
		List<RunningService> runningServices = compose.getRunningServices();
		assertThat(runningServices).hasSize(1);
		RunningService runningService = runningServices.get(0);
		assertThat(runningService.name()).isEqualTo('name');
		assertThat(runningService.image()).hasToString('docker.io/library/redis');
		assertThat(runningService.host()).isEqualTo(HOST);
		assertThat(runningService.ports().getAll()).isEmpty();
		assertThat(runningService.env()).containsExactly(entry('a', 'b'));
		assertThat(runningService.labels()).containsExactly(entry('spring', 'boot'));
	}
	@Test
	void getRunningServicesWhenNoHostUsesHostFromContext() {
		String id = '123';
		DockerCliComposePsResponse psResponse = new DockerCliComposePsResponse(id, 'name', 'redis', 'running');
		Map<String, ExposedPort> exposedPorts = Collections.emptyMap();
		Config config = new Config('redis', Map.of('spring', 'boot'), exposedPorts, List.of('a=b'));
		NetworkSettings networkSettings = null;
		HostConfig hostConfig = null;
		DockerCliInspectResponse inspectResponse = new DockerCliInspectResponse(id, config, networkSettings,
				hostConfig);
		willReturn(List.of(new DockerCliContextResponse('test', true, 'https://192.168.1.1'))).given(this.cli)
			.run(new DockerCliCommand.Context());
		willReturn(List.of(psResponse)).given(this.cli).run(new DockerCliCommand.ComposePs());
		willReturn(List.of(inspectResponse)).given(this.cli).run(new DockerCliCommand.Inspect(List.of(id)));
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, null);
		List<RunningService> runningServices = compose.getRunningServices();
		assertThat(runningServices).hasSize(1);
		RunningService runningService = runningServices.get(0);
		assertThat(runningService.host()).isEqualTo('192.168.1.1');
	}
	@Test
	void worksWithTruncatedIds() {
		String shortId = '123';
		String longId = '123456';
		DockerCliComposePsResponse psResponse = new DockerCliComposePsResponse(shortId, 'name', 'redis', 'running');
		Config config = new Config('redis', Collections.emptyMap(), Collections.emptyMap(), Collections.emptyList());
		DockerCliInspectResponse inspectResponse = new DockerCliInspectResponse(longId, config, null, null);
		willReturn(List.of(new DockerCliContextResponse('test', true, 'https://192.168.1.1'))).given(this.cli)
			.run(new DockerCliCommand.Context());
		willReturn(List.of(psResponse)).given(this.cli).run(new DockerCliCommand.ComposePs());
		willReturn(List.of(inspectResponse)).given(this.cli).run(new DockerCliCommand.Inspect(List.of(shortId)));
		DefaultDockerCompose compose = new DefaultDockerCompose(this.cli, null);
		List<RunningService> runningServices = compose.getRunningServices();
		assertThat(runningServices).hasSize(1);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DefaultConnectionPortsTests {
	@Test
	void createWhenBridgeNetwork() throws IOException {
		DefaultConnectionPorts ports = createForJson('docker-inspect-bridge-network.json');
		assertThat(ports.getMappings()).containsExactly(entry(new ContainerPort(6379, 'tcp'), 32770));
	}
	@Test
	void createWhenHostNetwork() throws Exception {
		DefaultConnectionPorts ports = createForJson('docker-inspect-host-network.json');
		assertThat(ports.getMappings()).containsExactly(entry(new ContainerPort(6379, 'tcp'), 6379));
	}
	private DefaultConnectionPorts createForJson(String path) throws IOException {
		String json = new ClassPathResource(path, getClass()).getContentAsString(StandardCharsets.UTF_8);
		DockerCliInspectResponse inspectResponse = DockerJson.deserialize(json, DockerCliInspectResponse.class);
		return new DefaultConnectionPorts(inspectResponse);
	}
	@Nested
	class ContainerPortTests {
		@Test
		void parse() {
			ContainerPort port = ContainerPort.parse('123/tcp');
			assertThat(port).isEqualTo(new ContainerPort(123, 'tcp'));
		}
		@Test
		void parseWhenNoSlashThrowsException() {
			assertThatIllegalStateException().isThrownBy(() -> ContainerPort.parse('123'))
				.withMessage('Unable to parse container port "123"');
		}
		@Test
		void parseWhenMultipleSlashesThrowsException() {
			assertThatIllegalStateException().isThrownBy(() -> ContainerPort.parse('123/tcp/ip'))
				.withMessage('Unable to parse container port "123/tcp/ip"');
		}
		@Test
		void parseWhenNotNumberThrowsException() {
			assertThatIllegalStateException().isThrownBy(() -> ContainerPort.parse('tcp/123'))
				.withMessage('Unable to parse container port "tcp/123"');
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.clickhouse;
/**
class ClickHouseR2dbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<R2dbcConnectionDetails> {
	private static final String[] CLICKHOUSE_CONTAINER_NAMES = { 'clickhouse/clickhouse-server', 'bitnami/clickhouse' };
	ClickHouseR2dbcDockerComposeConnectionDetailsFactory() {
		super(CLICKHOUSE_CONTAINER_NAMES, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	protected R2dbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new ClickhouseDbR2dbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@code clickhouse}
	 * {@link RunningService}.
	 */
	static class ClickhouseDbR2dbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements R2dbcConnectionDetails {
		private static final ConnectionFactoryOptionsBuilder connectionFactoryOptionsBuilder = new ConnectionFactoryOptionsBuilder(
				'clickhouse', 8123);
		private final ConnectionFactoryOptions connectionFactoryOptions;
		ClickhouseDbR2dbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			ClickHouseEnvironment environment = new ClickHouseEnvironment(service.env());
			this.connectionFactoryOptions = connectionFactoryOptionsBuilder.build(service, environment.getDatabase(),
					environment.getUsername(), environment.getPassword());
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return this.connectionFactoryOptions;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.clickhouse;
/**
class ClickHouseJdbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<JdbcConnectionDetails> {
	private static final String[] CLICKHOUSE_CONTAINER_NAMES = { 'clickhouse/clickhouse-server', 'bitnami/clickhouse' };
	protected ClickHouseJdbcDockerComposeConnectionDetailsFactory() {
		super(CLICKHOUSE_CONTAINER_NAMES);
	}
	@Override
	protected JdbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new ClickhouseJdbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link JdbcConnectionDetails} backed by a {@code clickhouse}
	 * {@link RunningService}.
	 */
	static class ClickhouseJdbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements JdbcConnectionDetails {
		private static final JdbcUrlBuilder jdbcUrlBuilder = new JdbcUrlBuilder('clickhouse', 8123);
		private final ClickHouseEnvironment environment;
		private final String jdbcUrl;
		ClickhouseJdbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new ClickHouseEnvironment(service.env());
			this.jdbcUrl = jdbcUrlBuilder.build(service, this.environment.getDatabase());
		}
		@Override
		public String getUsername() {
			return this.environment.getUsername();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.jdbcUrl;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.clickhouse;
/**
class ClickHouseEnvironment {
	private final String username;
	private final String password;
	private final String database;
	ClickHouseEnvironment(Map<String, String> env) {
		this.username = env.getOrDefault('CLICKHOUSE_USER', 'default');
		this.password = extractPassword(env);
		this.database = env.getOrDefault('CLICKHOUSE_DB', 'default');
	}
	private String extractPassword(Map<String, String> env) {
		boolean allowEmpty = Boolean.parseBoolean(env.getOrDefault('ALLOW_EMPTY_PASSWORD', Boolean.FALSE.toString()));
		String password = env.get('CLICKHOUSE_PASSWORD');
		Assert.state(StringUtils.hasLength(password) || allowEmpty, 'No ClickHouse password found');
		return (password != null) ? password : '';
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
	String getDatabase() {
		return this.database;
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.clickhouse;
/*
package org.springframework.boot.docker.compose.service.connection;
/**
public abstract class DockerComposeConnectionDetailsFactory<D extends ConnectionDetails>
		implements ConnectionDetailsFactory<DockerComposeConnectionSource, D> {
	private final Predicate<DockerComposeConnectionSource> predicate;
	private final String[] requiredClassNames;
	/**
	 * Create a new {@link DockerComposeConnectionDetailsFactory} instance.
	 * @param connectionName the required connection name
	 * @param requiredClassNames the names of classes that must be present
	 */
	protected DockerComposeConnectionDetailsFactory(String connectionName, String... requiredClassNames) {
		this(new ConnectionNamePredicate(connectionName), requiredClassNames);
	}
	/**
	 * Create a new {@link DockerComposeConnectionDetailsFactory} instance.
	 * @param connectionNames the required connection name
	 * @param requiredClassNames the names of classes that must be present
	 * @since 3.2.0
	 */
	protected DockerComposeConnectionDetailsFactory(String[] connectionNames, String... requiredClassNames) {
		this(new ConnectionNamePredicate(connectionNames), requiredClassNames);
	}
	/**
	 * Create a new {@link DockerComposeConnectionDetailsFactory} instance.
	 * @param predicate a predicate used to check when a service is accepted
	 * @param requiredClassNames the names of classes that must be present
	 */
	protected DockerComposeConnectionDetailsFactory(Predicate<DockerComposeConnectionSource> predicate,
			String... requiredClassNames) {
		this.predicate = predicate;
		this.requiredClassNames = requiredClassNames;
	}
	@Override
	public final D getConnectionDetails(DockerComposeConnectionSource source) {
		return (!accept(source)) ? null : getDockerComposeConnectionDetails(source);
	}
	private boolean accept(DockerComposeConnectionSource source) {
		return hasRequiredClasses() && this.predicate.test(source);
	}
	private boolean hasRequiredClasses() {
		return ObjectUtils.isEmpty(this.requiredClassNames) || Arrays.stream(this.requiredClassNames)
			.allMatch((requiredClassName) -> ClassUtils.isPresent(requiredClassName, null));
	}
	/**
	 * Get the {@link ConnectionDetails} from the given {@link RunningService}
	 * {@code source}. May return {@code null} if no connection can be created. Result
	 * types should consider extending {@link DockerComposeConnectionDetails}.
	 * @param source the source
	 * @return the service connection or {@code null}.
	 */
	protected abstract D getDockerComposeConnectionDetails(DockerComposeConnectionSource source);
	/**
	 * Convenient base class for {@link ConnectionDetails} results that are backed by a
	 * {@link RunningService}.
	 */
	protected static class DockerComposeConnectionDetails implements ConnectionDetails, OriginProvider {
		private final Origin origin;
		/**
		 * Create a new {@link DockerComposeConnectionDetails} instance.
		 * @param runningService the source {@link RunningService}
		 */
		protected DockerComposeConnectionDetails(RunningService runningService) {
			Assert.notNull(runningService, 'RunningService must not be null');
			this.origin = Origin.from(runningService);
		}
		@Override
		public Origin getOrigin() {
			return this.origin;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.jdbc;
/**
public class JdbcUrlBuilder {
	private static final String PARAMETERS_LABEL = 'org.springframework.boot.jdbc.parameters';
	private final String driverProtocol;
	private final int containerPort;
	/**
	 * Create a new {@link JdbcUrlBuilder} instance.
	 * @param driverProtocol the driver protocol
	 * @param containerPort the source container port
	 */
	public JdbcUrlBuilder(String driverProtocol, int containerPort) {
		Assert.notNull(driverProtocol, 'DriverProtocol must not be null');
		this.driverProtocol = driverProtocol;
		this.containerPort = containerPort;
	}
	/**
	 * Build a JDBC URL for the given {@link RunningService}.
	 * @param service the running service
	 * @return a new JDBC URL
	 */
	public String build(RunningService service) {
		return build(service, null);
	}
	/**
	 * Build a JDBC URL for the given {@link RunningService} and database.
	 * @param service the running service
	 * @param database the database to connect to
	 * @return a new JDBC URL
	 */
	public String build(RunningService service, String database) {
		return urlFor(service, database);
	}
	private String urlFor(RunningService service, String database) {
		Assert.notNull(service, 'Service must not be null');
		StringBuilder url = new StringBuilder('jdbc:%s://%s:%d'.formatted(this.driverProtocol, service.host(),
				service.ports().get(this.containerPort)));
		if (StringUtils.hasLength(database)) {
			url.append('/');
			url.append(database);
		}
		String parameters = getParameters(service);
		if (StringUtils.hasLength(parameters)) {
			appendParameters(url, parameters);
		}
		return url.toString();
	}
	/**
	 * Appends to the given {@code url} the given {@code parameters}.
	 * <p>
	 * The default implementation appends a {@code ?} followed by the {@code parameters}.
	 * @param url the url
	 * @param parameters the parameters
	 * @since 3.2.7
	 */
	protected void appendParameters(StringBuilder url, String parameters) {
		url.append('?').append(parameters);
	}
	private String getParameters(RunningService service) {
		return service.labels().get(PARAMETERS_LABEL);
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.jdbc;
/*
package org.springframework.boot.docker.compose.service.connection.cassandra;
/**
class CassandraEnvironment {
	private final String datacenter;
	CassandraEnvironment(Map<String, String> env) {
		this.datacenter = env.getOrDefault('CASSANDRA_DC', env.getOrDefault('CASSANDRA_DATACENTER', 'datacenter1'));
	}
	String getDatacenter() {
		return this.datacenter;
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.cassandra;
/*
package org.springframework.boot.docker.compose.service.connection.cassandra;
/**
class CassandraDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<CassandraConnectionDetails> {
	private static final String[] CASSANDRA_CONTAINER_NAMES = { 'cassandra', 'bitnami/cassandra' };
	private static final int CASSANDRA_PORT = 9042;
	CassandraDockerComposeConnectionDetailsFactory() {
		super(CASSANDRA_CONTAINER_NAMES);
	}
	@Override
	protected CassandraConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new CassandraDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link CassandraConnectionDetails} backed by a {@code Cassandra}
	 * {@link RunningService}.
	 */
	static class CassandraDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements CassandraConnectionDetails {
		private final List<Node> contactPoints;
		private final String datacenter;
		CassandraDockerComposeConnectionDetails(RunningService service) {
			super(service);
			CassandraEnvironment cassandraEnvironment = new CassandraEnvironment(service.env());
			this.contactPoints = List.of(new Node(service.host(), service.ports().get(CASSANDRA_PORT)));
			this.datacenter = cassandraEnvironment.getDatacenter();
		}
		@Override
		public List<Node> getContactPoints() {
			return this.contactPoints;
		}
		@Override
		public String getLocalDatacenter() {
			return this.datacenter;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
abstract class OracleR2dbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<R2dbcConnectionDetails> {
	private final String defaultDatabase;
	OracleR2dbcDockerComposeConnectionDetailsFactory(OracleContainer container) {
		super(container.getImageName(), 'io.r2dbc.spi.ConnectionFactoryOptions');
		this.defaultDatabase = container.getDefaultDatabase();
	}
	@Override
	protected R2dbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new OracleDbR2dbcDockerComposeConnectionDetails(source.getRunningService(), this.defaultDatabase);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@code gvenzl/oracle-xe}
	 * {@link RunningService}.
	 */
	static class OracleDbR2dbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements R2dbcConnectionDetails {
		private static final ConnectionFactoryOptionsBuilder connectionFactoryOptionsBuilder = new ConnectionFactoryOptionsBuilder(
				'oracle', 1521);
		private final ConnectionFactoryOptions connectionFactoryOptions;
		OracleDbR2dbcDockerComposeConnectionDetails(RunningService service, String defaultDatabase) {
			super(service);
			OracleEnvironment environment = new OracleEnvironment(service.env(), defaultDatabase);
			this.connectionFactoryOptions = connectionFactoryOptionsBuilder.build(service, environment.getDatabase(),
					environment.getUsername(), environment.getPassword());
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return this.connectionFactoryOptions;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
abstract class OracleJdbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<JdbcConnectionDetails> {
	private final String defaultDatabase;
	protected OracleJdbcDockerComposeConnectionDetailsFactory(OracleContainer container) {
		super(container.getImageName());
		this.defaultDatabase = container.getDefaultDatabase();
	}
	@Override
	protected JdbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new OracleJdbcDockerComposeConnectionDetails(source.getRunningService(), this.defaultDatabase);
	}
	/**
	 * {@link JdbcConnectionDetails} backed by an {@code oracle-xe} or {@code oracle-free}
	 * {@link RunningService}.
	 */
	static class OracleJdbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements JdbcConnectionDetails {
		private static final String PARAMETERS_LABEL = 'org.springframework.boot.jdbc.parameters';
		private final OracleEnvironment environment;
		private final String jdbcUrl;
		OracleJdbcDockerComposeConnectionDetails(RunningService service, String defaultDatabase) {
			super(service);
			this.environment = new OracleEnvironment(service.env(), defaultDatabase);
			this.jdbcUrl = 'jdbc:oracle:thin:@' + service.host() + ':' + service.ports().get(1521) + '/'
					+ this.environment.getDatabase() + getParameters(service);
		}
		private String getParameters(RunningService service) {
			String parameters = service.labels().get(PARAMETERS_LABEL);
			return (StringUtils.hasLength(parameters)) ? '?' + parameters : '';
		}
		@Override
		public String getUsername() {
			return this.environment.getUsername();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.jdbcUrl;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
enum OracleContainer {
	FREE('gvenzl/oracle-free', 'freepdb1'),
	XE('gvenzl/oracle-xe', 'xepdb1');
	private final String imageName;
	private final String defaultDatabase;
	OracleContainer(String imageName, String defaultDatabase) {
		this.imageName = imageName;
		this.defaultDatabase = defaultDatabase;
	}
	String getImageName() {
		return this.imageName;
	}
	String getDefaultDatabase() {
		return this.defaultDatabase;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
class OracleXeR2dbcDockerComposeConnectionDetailsFactory extends OracleR2dbcDockerComposeConnectionDetailsFactory {
	protected OracleXeR2dbcDockerComposeConnectionDetailsFactory() {
		super(OracleContainer.XE);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
class OracleFreeJdbcDockerComposeConnectionDetailsFactory extends OracleJdbcDockerComposeConnectionDetailsFactory {
	protected OracleFreeJdbcDockerComposeConnectionDetailsFactory() {
		super(OracleContainer.FREE);
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.oracle;
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
class OracleEnvironment {
	private final String username;
	private final String password;
	private final String database;
	OracleEnvironment(Map<String, String> env, String defaultDatabase) {
		this.username = env.getOrDefault('APP_USER', 'system');
		this.password = extractPassword(env);
		this.database = env.getOrDefault('ORACLE_DATABASE', defaultDatabase);
	}
	private String extractPassword(Map<String, String> env) {
		if (env.containsKey('APP_USER')) {
			String password = env.get('APP_USER_PASSWORD');
			Assert.state(StringUtils.hasLength(password), 'No Oracle app password found');
			return password;
		}
		Assert.state(!env.containsKey('ORACLE_RANDOM_PASSWORD'),
				'ORACLE_RANDOM_PASSWORD is not supported without APP_USER and APP_USER_PASSWORD');
		String password = env.get('ORACLE_PASSWORD');
		Assert.state(StringUtils.hasLength(password), 'No Oracle password found');
		return password;
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
	String getDatabase() {
		return this.database;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
class OracleXeJdbcDockerComposeConnectionDetailsFactory extends OracleJdbcDockerComposeConnectionDetailsFactory {
	protected OracleXeJdbcDockerComposeConnectionDetailsFactory() {
		super(OracleContainer.XE);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.oracle;
/**
class OracleFreeR2dbcDockerComposeConnectionDetailsFactory extends OracleR2dbcDockerComposeConnectionDetailsFactory {
	protected OracleFreeR2dbcDockerComposeConnectionDetailsFactory() {
		super(OracleContainer.FREE);
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.zipkin;
/**
class ZipkinDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<ZipkinConnectionDetails> {
	private static final int ZIPKIN_PORT = 9411;
	ZipkinDockerComposeConnectionDetailsFactory() {
		super('openzipkin/zipkin',
				'org.springframework.boot.actuate.autoconfigure.tracing.zipkin.ZipkinAutoConfiguration');
	}
	@Override
	protected ZipkinConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new ZipkinDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link ZipkinConnectionDetails} backed by a {@code zipkin} {@link RunningService}.
	 */
	static class ZipkinDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements ZipkinConnectionDetails {
		private final String host;
		private final int port;
		ZipkinDockerComposeConnectionDetails(RunningService source) {
			super(source);
			this.host = source.host();
			this.port = source.ports().get(ZIPKIN_PORT);
		}
		@Override
		public String getSpanEndpoint() {
			return 'http://' + this.host + ':' + this.port + '/api/v2/spans';
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.zipkin;
/*
package org.springframework.boot.docker.compose.service.connection.mariadb;
/**
class MariaDbJdbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<JdbcConnectionDetails> {
	private static final String[] MARIADB_CONTAINER_NAMES = { 'mariadb', 'bitnami/mariadb' };
	protected MariaDbJdbcDockerComposeConnectionDetailsFactory() {
		super(MARIADB_CONTAINER_NAMES);
	}
	@Override
	protected JdbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new MariaDbJdbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link JdbcConnectionDetails} backed by a {@code mariadb} {@link RunningService}.
	 */
	static class MariaDbJdbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements JdbcConnectionDetails {
		private static final JdbcUrlBuilder jdbcUrlBuilder = new JdbcUrlBuilder('mariadb', 3306);
		private final MariaDbEnvironment environment;
		private final String jdbcUrl;
		MariaDbJdbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new MariaDbEnvironment(service.env());
			this.jdbcUrl = jdbcUrlBuilder.build(service, this.environment.getDatabase());
		}
		@Override
		public String getUsername() {
			return this.environment.getUsername();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.jdbcUrl;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mariadb;
/**
class MariaDbR2dbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<R2dbcConnectionDetails> {
	private static final String[] MARIADB_CONTAINER_NAMES = { 'mariadb', 'bitnami/mariadb' };
	MariaDbR2dbcDockerComposeConnectionDetailsFactory() {
		super(MARIADB_CONTAINER_NAMES, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	protected R2dbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new MariaDbR2dbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@code mariadb} {@link RunningService}.
	 */
	static class MariaDbR2dbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements R2dbcConnectionDetails {
		private static final ConnectionFactoryOptionsBuilder connectionFactoryOptionsBuilder = new ConnectionFactoryOptionsBuilder(
				'mariadb', 3306);
		private final ConnectionFactoryOptions connectionFactoryOptions;
		MariaDbR2dbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			MariaDbEnvironment environment = new MariaDbEnvironment(service.env());
			this.connectionFactoryOptions = connectionFactoryOptionsBuilder.build(service, environment.getDatabase(),
					environment.getUsername(), environment.getPassword());
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return this.connectionFactoryOptions;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mariadb;
/**
class MariaDbEnvironment {
	private final String username;
	private final String password;
	private final String database;
	MariaDbEnvironment(Map<String, String> env) {
		this.username = extractUsername(env);
		this.password = extractPassword(env);
		this.database = extractDatabase(env);
	}
	private String extractUsername(Map<String, String> env) {
		String user = env.get('MARIADB_USER');
		return (user != null) ? user : env.getOrDefault('MYSQL_USER', 'root');
	}
	private String extractPassword(Map<String, String> env) {
		Assert.state(!env.containsKey('MARIADB_RANDOM_ROOT_PASSWORD'), 'MARIADB_RANDOM_ROOT_PASSWORD is not supported');
		Assert.state(!env.containsKey('MYSQL_RANDOM_ROOT_PASSWORD'), 'MYSQL_RANDOM_ROOT_PASSWORD is not supported');
		Assert.state(!env.containsKey('MARIADB_ROOT_PASSWORD_HASH'), 'MARIADB_ROOT_PASSWORD_HASH is not supported');
		boolean allowEmpty = env.containsKey('MARIADB_ALLOW_EMPTY_PASSWORD')
				|| env.containsKey('MYSQL_ALLOW_EMPTY_PASSWORD') || env.containsKey('ALLOW_EMPTY_PASSWORD');
		String password = env.get('MARIADB_PASSWORD');
		password = (password != null) ? password : env.get('MYSQL_PASSWORD');
		password = (password != null) ? password : env.get('MARIADB_ROOT_PASSWORD');
		password = (password != null) ? password : env.get('MYSQL_ROOT_PASSWORD');
		Assert.state(StringUtils.hasLength(password) || allowEmpty, 'No MariaDB password found');
		return (password != null) ? password : '';
	}
	private String extractDatabase(Map<String, String> env) {
		String database = env.get('MARIADB_DATABASE');
		database = (database != null) ? database : env.get('MYSQL_DATABASE');
		Assert.state(database != null, 'No MARIADB_DATABASE defined');
		return database;
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
	String getDatabase() {
		return this.database;
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.mariadb;
/*
package org.springframework.boot.docker.compose.service.connection.pulsar;
/**
class PulsarDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<PulsarConnectionDetails> {
	private static final int BROKER_PORT = 6650;
	private static final int ADMIN_PORT = 8080;
	PulsarDockerComposeConnectionDetailsFactory() {
		super('apachepulsar/pulsar');
	}
	@Override
	protected PulsarConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new PulsarDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link PulsarConnectionDetails} backed by a {@code pulsar} {@link RunningService}.
	 */
	static class PulsarDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements PulsarConnectionDetails {
		private final String brokerUrl;
		private final String adminUrl;
		PulsarDockerComposeConnectionDetails(RunningService service) {
			super(service);
			ConnectionPorts ports = service.ports();
			this.brokerUrl = 'pulsar://%s:%s'.formatted(service.host(), ports.get(BROKER_PORT));
			this.adminUrl = 'http://%s:%s'.formatted(service.host(), ports.get(ADMIN_PORT));
		}
		@Override
		public String getBrokerUrl() {
			return this.brokerUrl;
		}
		@Override
		public String getAdminUrl() {
			return this.adminUrl;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.pulsar;
/*
package org.springframework.boot.docker.compose.service.connection.hazelcast;
/**
class HazelcastEnvironment {
	private final String clusterName;
	HazelcastEnvironment(Map<String, String> env) {
		this.clusterName = env.get('HZ_CLUSTERNAME');
	}
	String getClusterName() {
		return this.clusterName;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.hazelcast;
/**
class HazelcastDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<HazelcastConnectionDetails> {
	private static final int DEFAULT_PORT = 5701;
	protected HazelcastDockerComposeConnectionDetailsFactory() {
		super('hazelcast/hazelcast', 'com.hazelcast.client.config.ClientConfig');
	}
	@Override
	protected HazelcastConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new HazelcastDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link HazelcastConnectionDetails} backed by a {@code hazelcast}
	 * {@link RunningService}.
	 */
	static class HazelcastDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements HazelcastConnectionDetails {
		private final String host;
		private final int port;
		private final HazelcastEnvironment environment;
		HazelcastDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.host = service.host();
			this.port = service.ports().get(DEFAULT_PORT);
			this.environment = new HazelcastEnvironment(service.env());
		}
		@Override
		public ClientConfig getClientConfig() {
			ClientConfig config = new ClientConfig();
			if (this.environment.getClusterName() != null) {
				config.setClusterName(this.environment.getClusterName());
			}
			config.getNetworkConfig().addAddress(this.host + ':' + this.port);
			return config;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.hazelcast;
/*
package org.springframework.boot.docker.compose.service.connection;
/**
public final class DockerComposeConnectionSource {
	private final RunningService runningService;
	/**
	 * Create a new {@link DockerComposeConnectionSource} instance.
	 * @param runningService the running Docker Compose service
	 */
	DockerComposeConnectionSource(RunningService runningService) {
		this.runningService = runningService;
	}
	/**
	 * Return the running Docker Compose service.
	 * @return the running service
	 */
	public RunningService getRunningService() {
		return this.runningService;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.neo4j;
/**
class Neo4jEnvironment {
	private final AuthToken authToken;
	Neo4jEnvironment(Map<String, String> env) {
		AuthToken authToken = parse(env.get('NEO4J_AUTH'));
		if (authToken == null && env.containsKey('NEO4J_PASSWORD')) {
			authToken = parse('neo4j/' + env.get('NEO4J_PASSWORD'));
		}
		this.authToken = authToken;
	}
	private AuthToken parse(String neo4jAuth) {
		if (neo4jAuth == null) {
			return null;
		}
		if ('none'.equals(neo4jAuth)) {
			return AuthTokens.none();
		}
		if (neo4jAuth.startsWith('neo4j/')) {
			return AuthTokens.basic('neo4j', neo4jAuth.substring(6));
		}
		throw new IllegalStateException(
				'Cannot extract auth token from NEO4J_AUTH environment variable with value "' + neo4jAuth + '".'
						+ ' Value should be "none" to disable authentication or start with "neo4j/" to specify'
						+ ' the neo4j user"s password');
	}
	AuthToken getAuthToken() {
		return this.authToken;
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.neo4j;
/*
package org.springframework.boot.docker.compose.service.connection.neo4j;
/**
class Neo4jDockerComposeConnectionDetailsFactory extends DockerComposeConnectionDetailsFactory<Neo4jConnectionDetails> {
	private static final String[] NEO4J_CONTAINER_NAMES = { 'neo4j', 'bitnami/neo4j' };
	Neo4jDockerComposeConnectionDetailsFactory() {
		super(NEO4J_CONTAINER_NAMES);
	}
	@Override
	protected Neo4jConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new Neo4jDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link Neo4jConnectionDetails} backed by a {@code Neo4j} {@link RunningService}.
	 */
	static class Neo4jDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements Neo4jConnectionDetails {
		private static final int BOLT_PORT = 7687;
		private final AuthToken authToken;
		private final URI uri;
		Neo4jDockerComposeConnectionDetails(RunningService service) {
			super(service);
			Neo4jEnvironment neo4jEnvironment = new Neo4jEnvironment(service.env());
			this.authToken = neo4jEnvironment.getAuthToken();
			this.uri = URI.create('neo4j://%s:%d'.formatted(service.host(), service.ports().get(BOLT_PORT)));
		}
		@Override
		public URI getUri() {
			return this.uri;
		}
		@Override
		public AuthToken getAuthToken() {
			return this.authToken;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class OpenTelemetryMetricsDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<OtlpMetricsConnectionDetails> {
	private static final String[] OPENTELEMETRY_IMAGE_NAMES = { 'otel/opentelemetry-collector-contrib',
			'grafana/otel-lgtm' };
	private static final int OTLP_PORT = 4318;
	OpenTelemetryMetricsDockerComposeConnectionDetailsFactory() {
		super(OPENTELEMETRY_IMAGE_NAMES,
				'org.springframework.boot.actuate.autoconfigure.metrics.export.otlp.OtlpMetricsExportAutoConfiguration');
	}
	@Override
	protected OtlpMetricsConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new OpenTelemetryMetricsDockerComposeConnectionDetails(source.getRunningService());
	}
	private static final class OpenTelemetryMetricsDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements OtlpMetricsConnectionDetails {
		private final String host;
		private final int port;
		private OpenTelemetryMetricsDockerComposeConnectionDetails(RunningService source) {
			super(source);
			this.host = source.host();
			this.port = source.ports().get(OTLP_PORT);
		}
		@Override
		public String getUrl() {
			return 'http://%s:%d/v1/metrics'.formatted(this.host, this.port);
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class OpenTelemetryLoggingDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<OtlpLoggingConnectionDetails> {
	private static final String[] OPENTELEMETRY_IMAGE_NAMES = { 'otel/opentelemetry-collector-contrib',
			'grafana/otel-lgtm' };
	private static final int OTLP_GRPC_PORT = 4317;
	private static final int OTLP_HTTP_PORT = 4318;
	OpenTelemetryLoggingDockerComposeConnectionDetailsFactory() {
		super(OPENTELEMETRY_IMAGE_NAMES,
				'org.springframework.boot.actuate.autoconfigure.logging.otlp.OtlpLoggingAutoConfiguration');
	}
	@Override
	protected OtlpLoggingConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new OpenTelemetryLoggingDockerComposeConnectionDetails(source.getRunningService());
	}
	private static final class OpenTelemetryLoggingDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements OtlpLoggingConnectionDetails {
		private final String host;
		private final int grpcPort;
		private final int httPort;
		private OpenTelemetryLoggingDockerComposeConnectionDetails(RunningService source) {
			super(source);
			this.host = source.host();
			this.grpcPort = source.ports().get(OTLP_GRPC_PORT);
			this.httPort = source.ports().get(OTLP_HTTP_PORT);
		}
		@Override
		public String getUrl(Transport transport) {
			int port = switch (transport) {
				case HTTP -> this.httPort;
				case GRPC -> this.grpcPort;
			};
			return 'http://%s:%d/v1/logs'.formatted(this.host, port);
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.otlp;
/**
class OpenTelemetryTracingDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<OtlpTracingConnectionDetails> {
	private static final String[] OPENTELEMETRY_IMAGE_NAMES = { 'otel/opentelemetry-collector-contrib',
			'grafana/otel-lgtm' };
	private static final int OTLP_GRPC_PORT = 4317;
	private static final int OTLP_HTTP_PORT = 4318;
	OpenTelemetryTracingDockerComposeConnectionDetailsFactory() {
		super(OPENTELEMETRY_IMAGE_NAMES,
				'org.springframework.boot.actuate.autoconfigure.tracing.otlp.OtlpTracingAutoConfiguration');
	}
	@Override
	protected OtlpTracingConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new OpenTelemetryTracingDockerComposeConnectionDetails(source.getRunningService());
	}
	private static final class OpenTelemetryTracingDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements OtlpTracingConnectionDetails {
		private final String host;
		private final int grpcPort;
		private final int httPort;
		private OpenTelemetryTracingDockerComposeConnectionDetails(RunningService source) {
			super(source);
			this.host = source.host();
			this.grpcPort = source.ports().get(OTLP_GRPC_PORT);
			this.httPort = source.ports().get(OTLP_HTTP_PORT);
		}
		@Override
		public String getUrl(Transport transport) {
			int port = switch (transport) {
				case HTTP -> this.httPort;
				case GRPC -> this.grpcPort;
			};
			return 'http://%s:%d/v1/traces'.formatted(this.host, port);
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.otlp;
/*
package org.springframework.boot.docker.compose.service.connection.sqlserver;
/**
class SqlServerR2dbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<R2dbcConnectionDetails> {
	SqlServerR2dbcDockerComposeConnectionDetailsFactory() {
		super('mssql/server', 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	protected R2dbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new SqlServerR2dbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@code mssql} {@link RunningService}.
	 */
	static class SqlServerR2dbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements R2dbcConnectionDetails {
		private static final ConnectionFactoryOptionsBuilder connectionFactoryOptionsBuilder = new ConnectionFactoryOptionsBuilder(
				'mssql', 1433);
		private final ConnectionFactoryOptions connectionFactoryOptions;
		SqlServerR2dbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			SqlServerEnvironment environment = new SqlServerEnvironment(service.env());
			this.connectionFactoryOptions = connectionFactoryOptionsBuilder.build(service, '',
					environment.getUsername(), environment.getPassword());
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return this.connectionFactoryOptions;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.sqlserver;
/**
class SqlServerJdbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<JdbcConnectionDetails> {
	protected SqlServerJdbcDockerComposeConnectionDetailsFactory() {
		super('mssql/server');
	}
	@Override
	protected JdbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new SqlServerJdbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link JdbcConnectionDetails} backed by a {@code mssql/server}
	 * {@link RunningService}.
	 */
	static class SqlServerJdbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements JdbcConnectionDetails {
		private static final JdbcUrlBuilder jdbcUrlBuilder = new SqlServerJdbcUrlBuilder('sqlserver', 1433);
		private final SqlServerEnvironment environment;
		private final String jdbcUrl;
		SqlServerJdbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new SqlServerEnvironment(service.env());
			this.jdbcUrl = disableEncryptionIfNecessary(jdbcUrlBuilder.build(service));
		}
		private String disableEncryptionIfNecessary(String jdbcUrl) {
			if (jdbcUrl.contains(';encrypt=false;')) {
				return jdbcUrl;
			}
			StringBuilder jdbcUrlBuilder = new StringBuilder(jdbcUrl);
			if (!jdbcUrl.endsWith(';')) {
				jdbcUrlBuilder.append(';');
			}
			jdbcUrlBuilder.append('encrypt=false;');
			return jdbcUrlBuilder.toString();
		}
		@Override
		public String getUsername() {
			return this.environment.getUsername();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.jdbcUrl;
		}
		private static final class SqlServerJdbcUrlBuilder extends JdbcUrlBuilder {
			private SqlServerJdbcUrlBuilder(String driverProtocol, int containerPort) {
				super(driverProtocol, containerPort);
			}
			@Override
			protected void appendParameters(StringBuilder url, String parameters) {
				url.append(';').append(parameters);
			}
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.sqlserver;
/*
package org.springframework.boot.docker.compose.service.connection.sqlserver;
/**
class SqlServerEnvironment {
	private final String username = 'SA';
	private final String password;
	SqlServerEnvironment(Map<String, String> env) {
		this.password = extractPassword(env);
	}
	private String extractPassword(Map<String, String> env) {
		String password = env.get('MSSQL_SA_PASSWORD');
		password = (password != null) ? password : env.get('SA_PASSWORD');
		Assert.state(StringUtils.hasLength(password), 'No MSSQL password found');
		return password;
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mysql;
/**
class MySqlJdbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<JdbcConnectionDetails> {
	private static final String[] MYSQL_CONTAINER_NAMES = { 'mysql', 'bitnami/mysql' };
	protected MySqlJdbcDockerComposeConnectionDetailsFactory() {
		super(MYSQL_CONTAINER_NAMES);
	}
	@Override
	protected JdbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new MySqlJdbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link JdbcConnectionDetails} backed by a {@code mysql} {@link RunningService}.
	 */
	static class MySqlJdbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements JdbcConnectionDetails {
		private static final JdbcUrlBuilder jdbcUrlBuilder = new JdbcUrlBuilder('mysql', 3306);
		private final MySqlEnvironment environment;
		private final String jdbcUrl;
		MySqlJdbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new MySqlEnvironment(service.env());
			this.jdbcUrl = jdbcUrlBuilder.build(service, this.environment.getDatabase());
		}
		@Override
		public String getUsername() {
			return this.environment.getUsername();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.jdbcUrl;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mysql;
/**
class MySqlEnvironment {
	private final String username;
	private final String password;
	private final String database;
	MySqlEnvironment(Map<String, String> env) {
		this.username = env.getOrDefault('MYSQL_USER', 'root');
		this.password = extractPassword(env);
		this.database = extractDatabase(env);
	}
	private String extractPassword(Map<String, String> env) {
		Assert.state(!env.containsKey('MYSQL_RANDOM_ROOT_PASSWORD'), 'MYSQL_RANDOM_ROOT_PASSWORD is not supported');
		boolean allowEmpty = env.containsKey('MYSQL_ALLOW_EMPTY_PASSWORD') || env.containsKey('ALLOW_EMPTY_PASSWORD');
		String password = env.get('MYSQL_PASSWORD');
		password = (password != null) ? password : env.get('MYSQL_ROOT_PASSWORD');
		Assert.state(StringUtils.hasLength(password) || allowEmpty, 'No MySQL password found');
		return (password != null) ? password : '';
	}
	private String extractDatabase(Map<String, String> env) {
		String database = env.get('MYSQL_DATABASE');
		Assert.state(database != null, 'No MYSQL_DATABASE defined');
		return database;
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
	String getDatabase() {
		return this.database;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mysql;
/**
class MySqlR2dbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<R2dbcConnectionDetails> {
	private static final String[] MYSQL_CONTAINER_NAMES = { 'mysql', 'bitnami/mysql' };
	MySqlR2dbcDockerComposeConnectionDetailsFactory() {
		super(MYSQL_CONTAINER_NAMES, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	protected R2dbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new MySqlR2dbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@code mysql} {@link RunningService}.
	 */
	static class MySqlR2dbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements R2dbcConnectionDetails {
		private static final ConnectionFactoryOptionsBuilder connectionFactoryOptionsBuilder = new ConnectionFactoryOptionsBuilder(
				'mysql', 3306);
		private final ConnectionFactoryOptions connectionFactoryOptions;
		MySqlR2dbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			MySqlEnvironment environment = new MySqlEnvironment(service.env());
			this.connectionFactoryOptions = connectionFactoryOptionsBuilder.build(service, environment.getDatabase(),
					environment.getUsername(), environment.getPassword());
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return this.connectionFactoryOptions;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.mysql;
/*
package org.springframework.boot.docker.compose.service.connection.rabbit;
/**
class RabbitDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<RabbitConnectionDetails> {
	private static final String[] RABBITMQ_CONTAINER_NAMES = { 'rabbitmq', 'bitnami/rabbitmq' };
	private static final int RABBITMQ_PORT = 5672;
	protected RabbitDockerComposeConnectionDetailsFactory() {
		super(RABBITMQ_CONTAINER_NAMES);
	}
	@Override
	protected RabbitConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new RabbitDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link RabbitConnectionDetails} backed by a {@code rabbitmq}
	 * {@link RunningService}.
	 */
	static class RabbitDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements RabbitConnectionDetails {
		private final RabbitEnvironment environment;
		private final List<Address> addresses;
		protected RabbitDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new RabbitEnvironment(service.env());
			this.addresses = List.of(new Address(service.host(), service.ports().get(RABBITMQ_PORT)));
		}
		@Override
		public String getUsername() {
			return this.environment.getUsername();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public String getVirtualHost() {
			return '/';
		}
		@Override
		public List<Address> getAddresses() {
			return this.addresses;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.rabbit;
/*
package org.springframework.boot.docker.compose.service.connection.rabbit;
/**
class RabbitEnvironment {
	private final String username;
	private final String password;
	RabbitEnvironment(Map<String, String> env) {
		this.username = env.getOrDefault('RABBITMQ_DEFAULT_USER', env.getOrDefault('RABBITMQ_USERNAME', 'guest'));
		this.password = env.getOrDefault('RABBITMQ_DEFAULT_PASS', env.getOrDefault('RABBITMQ_PASSWORD', 'guest'));
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.elasticsearch;
/**
class ElasticsearchDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<ElasticsearchConnectionDetails> {
	private static final String[] ELASTICSEARCH_CONTAINER_NAMES = { 'elasticsearch', 'bitnami/elasticsearch' };
	private static final int ELASTICSEARCH_PORT = 9200;
	protected ElasticsearchDockerComposeConnectionDetailsFactory() {
		super(ELASTICSEARCH_CONTAINER_NAMES);
	}
	@Override
	protected ElasticsearchConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new ElasticsearchDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link ElasticsearchConnectionDetails} backed by an {@code elasticsearch}
	 * {@link RunningService}.
	 */
	static class ElasticsearchDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements ElasticsearchConnectionDetails {
		private final ElasticsearchEnvironment environment;
		private final List<Node> nodes;
		ElasticsearchDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new ElasticsearchEnvironment(service.env());
			this.nodes = List.of(new Node(service.host(), service.ports().get(ELASTICSEARCH_PORT), Protocol.HTTP,
					getUsername(), getPassword()));
		}
		@Override
		public String getUsername() {
			return 'elastic';
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public List<Node> getNodes() {
			return this.nodes;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.elasticsearch;
/**
class ElasticsearchEnvironment {
	private final String password;
	ElasticsearchEnvironment(Map<String, String> env) {
		Assert.state(!env.containsKey('ELASTIC_PASSWORD_FILE'), 'ELASTIC_PASSWORD_FILE is not supported');
		this.password = env.get('ELASTIC_PASSWORD');
	}
	String getPassword() {
		return this.password;
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.elasticsearch;
/*
package org.springframework.boot.docker.compose.service.connection.redis;
/**
class RedisDockerComposeConnectionDetailsFactory extends DockerComposeConnectionDetailsFactory<RedisConnectionDetails> {
	private static final String[] REDIS_CONTAINER_NAMES = { 'redis', 'bitnami/redis', 'redis/redis-stack',
			'redis/redis-stack-server' };
	private static final int REDIS_PORT = 6379;
	RedisDockerComposeConnectionDetailsFactory() {
		super(REDIS_CONTAINER_NAMES);
	}
	@Override
	protected RedisConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new RedisDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link RedisConnectionDetails} backed by a {@code redis} {@link RunningService}.
	 */
	static class RedisDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements RedisConnectionDetails {
		private final Standalone standalone;
		RedisDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.standalone = Standalone.of(service.host(), service.ports().get(REDIS_PORT));
		}
		@Override
		public Standalone getStandalone() {
			return this.standalone;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.redis;
/*
package org.springframework.boot.docker.compose.service.connection.r2dbc;
/**
public class ConnectionFactoryOptionsBuilder {
	private static final String PARAMETERS_LABEL = 'org.springframework.boot.r2dbc.parameters';
	private final String driver;
	private final int sourcePort;
	/**
	 * Create a new {@link JdbcUrlBuilder} instance.
	 * @param driver the driver protocol
	 * @param containerPort the source container port
	 */
	public ConnectionFactoryOptionsBuilder(String driver, int containerPort) {
		Assert.notNull(driver, 'Driver must not be null');
		this.driver = driver;
		this.sourcePort = containerPort;
	}
	public ConnectionFactoryOptions build(RunningService service, String database, String user, String password) {
		Assert.notNull(service, 'Service must not be null');
		Assert.notNull(database, 'Database must not be null');
		ConnectionFactoryOptions.Builder builder = ConnectionFactoryOptions.builder()
			.option(ConnectionFactoryOptions.DRIVER, this.driver)
			.option(ConnectionFactoryOptions.HOST, service.host())
			.option(ConnectionFactoryOptions.PORT, service.ports().get(this.sourcePort))
			.option(ConnectionFactoryOptions.DATABASE, database);
		if (StringUtils.hasLength(user)) {
			builder.option(ConnectionFactoryOptions.USER, user);
		}
		if (StringUtils.hasLength(password)) {
			builder.option(ConnectionFactoryOptions.PASSWORD, password);
		}
		applyParameters(service, builder);
		return builder.build();
	}
	private void applyParameters(RunningService service, ConnectionFactoryOptions.Builder builder) {
		String parameters = service.labels().get(PARAMETERS_LABEL);
		try {
			if (StringUtils.hasText(parameters)) {
				parseParameters(parameters).forEach((name, value) -> builder.option(Option.valueOf(name), value));
			}
		}
		catch (RuntimeException ex) {
			throw new IllegalStateException(
					'Unable to apply R2DBC label parameters "%s" defined on service %s'.formatted(parameters, service));
		}
	}
	private Map<String, String> parseParameters(String parameters) {
		Map<String, String> result = new LinkedHashMap<>();
		for (String parameter : StringUtils.commaDelimitedListToStringArray(parameters)) {
			String[] parts = parameter.split('=');
			Assert.state(parts.length == 2, () -> 'Unable to parse parameter "%s"'.formatted(parameter));
			result.put(parts[0], parts[1]);
		}
		return Collections.unmodifiableMap(result);
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.r2dbc;
/*
/**
package org.springframework.boot.docker.compose.service.connection;
/*
package org.springframework.boot.docker.compose.service.connection;
/**
class DockerComposeServiceConnectionsApplicationListener
		implements ApplicationListener<DockerComposeServicesReadyEvent> {
	private final ConnectionDetailsFactories factories;
	DockerComposeServiceConnectionsApplicationListener() {
		this(new ConnectionDetailsFactories());
	}
	DockerComposeServiceConnectionsApplicationListener(ConnectionDetailsFactories factories) {
		this.factories = factories;
	}
	@Override
	public void onApplicationEvent(DockerComposeServicesReadyEvent event) {
		ApplicationContext applicationContext = event.getSource();
		if (applicationContext instanceof BeanDefinitionRegistry registry) {
			registerConnectionDetails(registry, event.getRunningServices());
		}
	}
	private void registerConnectionDetails(BeanDefinitionRegistry registry, List<RunningService> runningServices) {
		for (RunningService runningService : runningServices) {
			DockerComposeConnectionSource source = new DockerComposeConnectionSource(runningService);
			this.factories.getConnectionDetails(source, false).forEach((connectionDetailsType, connectionDetails) -> {
				register(registry, runningService, connectionDetailsType, connectionDetails);
				this.factories.getConnectionDetails(connectionDetails, false)
					.forEach((adaptedType, adaptedDetails) -> register(registry, runningService, adaptedType,
							adaptedDetails));
			});
		}
	}
	@SuppressWarnings('unchecked')
	private <T> void register(BeanDefinitionRegistry registry, RunningService runningService,
			Class<?> connectionDetailsType, ConnectionDetails connectionDetails) {
		ContainerImageMetadata containerMetadata = new ContainerImageMetadata(runningService.image().toString());
		String beanName = getBeanName(runningService, connectionDetailsType);
		Class<T> beanType = (Class<T>) connectionDetails.getClass();
		Supplier<T> beanSupplier = () -> (T) connectionDetails;
		RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType, beanSupplier);
		containerMetadata.addTo(beanDefinition);
		registry.registerBeanDefinition(beanName, beanDefinition);
	}
	private String getBeanName(RunningService runningService, Class<?> connectionDetailsType) {
		List<String> parts = new ArrayList<>();
		parts.add(ClassUtils.getShortNameAsProperty(connectionDetailsType));
		parts.add('for');
		parts.addAll(Arrays.asList(runningService.name().split('-')));
		return StringUtils.uncapitalize(parts.stream().map(StringUtils::capitalize).collect(Collectors.joining()));
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.postgres;
/**
class PostgresJdbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<JdbcConnectionDetails> {
	private static final String[] POSTGRES_CONTAINER_NAMES = { 'postgres', 'bitnami/postgresql' };
	protected PostgresJdbcDockerComposeConnectionDetailsFactory() {
		super(POSTGRES_CONTAINER_NAMES);
	}
	@Override
	protected JdbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new PostgresJdbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link JdbcConnectionDetails} backed by a {@code postgres} {@link RunningService}.
	 */
	static class PostgresJdbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements JdbcConnectionDetails {
		private static final JdbcUrlBuilder jdbcUrlBuilder = new JdbcUrlBuilder('postgresql', 5432);
		private final PostgresEnvironment environment;
		private final String jdbcUrl;
		PostgresJdbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new PostgresEnvironment(service.env());
			this.jdbcUrl = jdbcUrlBuilder.build(service, this.environment.getDatabase());
		}
		@Override
		public String getUsername() {
			return this.environment.getUsername();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return this.jdbcUrl;
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.postgres;
/**
class PostgresR2dbcDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<R2dbcConnectionDetails> {
	private static final String[] POSTGRES_CONTAINER_NAMES = { 'postgres', 'bitnami/postgresql' };
	PostgresR2dbcDockerComposeConnectionDetailsFactory() {
		super(POSTGRES_CONTAINER_NAMES, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	protected R2dbcConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new PostgresDbR2dbcDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@code postgres} {@link RunningService}.
	 */
	static class PostgresDbR2dbcDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements R2dbcConnectionDetails {
		private static final ConnectionFactoryOptionsBuilder connectionFactoryOptionsBuilder = new ConnectionFactoryOptionsBuilder(
				'postgresql', 5432);
		private final ConnectionFactoryOptions connectionFactoryOptions;
		PostgresDbR2dbcDockerComposeConnectionDetails(RunningService service) {
			super(service);
			PostgresEnvironment environment = new PostgresEnvironment(service.env());
			this.connectionFactoryOptions = connectionFactoryOptionsBuilder.build(service, environment.getDatabase(),
					environment.getUsername(), environment.getPassword());
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return this.connectionFactoryOptions;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.postgres;
/*
package org.springframework.boot.docker.compose.service.connection.postgres;
/**
class PostgresEnvironment {
	private final String username;
	private final String password;
	private final String database;
	PostgresEnvironment(Map<String, String> env) {
		this.username = env.getOrDefault('POSTGRES_USER', env.getOrDefault('POSTGRESQL_USER', 'postgres'));
		this.password = extractPassword(env);
		this.database = env.getOrDefault('POSTGRES_DB', env.getOrDefault('POSTGRESQL_DB', this.username));
	}
	private String extractPassword(Map<String, String> env) {
		if (isUsingTrustHostAuthMethod(env)) {
			return null;
		}
		String password = env.getOrDefault('POSTGRES_PASSWORD', env.get('POSTGRESQL_PASSWORD'));
		Assert.state(StringUtils.hasLength(password), 'PostgreSQL password must be provided');
		return password;
	}
	private boolean isUsingTrustHostAuthMethod(Map<String, String> env) {
		String hostAuthMethod = env.get('POSTGRES_HOST_AUTH_METHOD');
		return 'trust'.equals(hostAuthMethod);
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
	String getDatabase() {
		return this.database;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.liquibase;
/**
class JdbcAdaptingLiquibaseConnectionDetailsFactory
		implements ConnectionDetailsFactory<JdbcConnectionDetails, LiquibaseConnectionDetails> {
	@Override
	public LiquibaseConnectionDetails getConnectionDetails(JdbcConnectionDetails input) {
		return new LiquibaseConnectionDetails() {
			@Override
			public String getUsername() {
				return input.getUsername();
			}
			@Override
			public String getPassword() {
				return input.getPassword();
			}
			@Override
			public String getJdbcUrl() {
				return input.getJdbcUrl();
			}
			@Override
			public String getDriverClassName() {
				return input.getDriverClassName();
			}
		};
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.liquibase;
/*
/**
package org.springframework.boot.docker.compose.service.connection.flyway;
/*
package org.springframework.boot.docker.compose.service.connection.flyway;
/**
class JdbcAdaptingFlywayConnectionDetailsFactory
		implements ConnectionDetailsFactory<JdbcConnectionDetails, FlywayConnectionDetails> {
	@Override
	public FlywayConnectionDetails getConnectionDetails(JdbcConnectionDetails input) {
		return new FlywayConnectionDetails() {
			@Override
			public String getUsername() {
				return input.getUsername();
			}
			@Override
			public String getPassword() {
				return input.getPassword();
			}
			@Override
			public String getJdbcUrl() {
				return input.getJdbcUrl();
			}
			@Override
			public String getDriverClassName() {
				return input.getDriverClassName();
			}
		};
	}
}
/*
package org.springframework.boot.docker.compose.service.connection;
/**
class ConnectionNamePredicate implements Predicate<DockerComposeConnectionSource> {
	private final Set<String> required;
	ConnectionNamePredicate(String... required) {
		Assert.notEmpty(required, 'Required must not be empty');
		this.required = Arrays.stream(required).map(this::asCanonicalName).collect(Collectors.toSet());
	}
	@Override
	public boolean test(DockerComposeConnectionSource source) {
		String actual = getActual(source.getRunningService());
		return this.required.contains(actual);
	}
	private String getActual(RunningService service) {
		String label = service.labels().get('org.springframework.boot.service-connection');
		return (label != null) ? asCanonicalName(label) : service.image().getName();
	}
	private String asCanonicalName(String name) {
		return ImageReference.of(name).getName();
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.ldap;
/**
class OpenLdapDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<LdapConnectionDetails> {
	protected OpenLdapDockerComposeConnectionDetailsFactory() {
		super('osixia/openldap');
	}
	@Override
	protected LdapConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new OpenLdapDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link LdapConnectionDetails} backed by an {@code openldap} {@link RunningService}.
	 */
	static class OpenLdapDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements LdapConnectionDetails {
		private final String[] urls;
		private final String base;
		private final String username;
		private final String password;
		OpenLdapDockerComposeConnectionDetails(RunningService service) {
			super(service);
			Map<String, String> env = service.env();
			boolean usesTls = Boolean.parseBoolean(env.getOrDefault('LDAP_TLS', 'true'));
			String ldapPort = usesTls ? env.getOrDefault('LDAPS_PORT', '636') : env.getOrDefault('LDAP_PORT', '389');
			this.urls = new String[] { '%s://%s:%d'.formatted(usesTls ? 'ldaps' : 'ldap', service.host(),
					service.ports().get(Integer.parseInt(ldapPort))) };
			if (env.containsKey('LDAP_BASE_DN')) {
				this.base = env.get('LDAP_BASE_DN');
			}
			else {
				this.base = Arrays.stream(env.getOrDefault('LDAP_DOMAIN', 'example.org').split('\\.'))
					.map('dc=%s'::formatted)
					.collect(Collectors.joining(','));
			}
			this.password = env.getOrDefault('LDAP_ADMIN_PASSWORD', 'admin');
			this.username = 'cn=admin,%s'.formatted(this.base);
		}
		@Override
		public String[] getUrls() {
			return this.urls;
		}
		@Override
		public String getBase() {
			return this.base;
		}
		@Override
		public String getUsername() {
			return this.username;
		}
		@Override
		public String getPassword() {
			return this.password;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.ldap;
/*
package org.springframework.boot.docker.compose.service.connection.mongo;
/**
class MongoEnvironment {
	private final String username;
	private final String password;
	private final String database;
	MongoEnvironment(Map<String, String> env) {
		Assert.state(!env.containsKey('MONGO_INITDB_ROOT_USERNAME_FILE'),
				'MONGO_INITDB_ROOT_USERNAME_FILE is not supported');
		Assert.state(!env.containsKey('MONGO_INITDB_ROOT_PASSWORD_FILE'),
				'MONGO_INITDB_ROOT_PASSWORD_FILE is not supported');
		this.username = env.getOrDefault('MONGO_INITDB_ROOT_USERNAME', env.get('MONGODB_ROOT_USERNAME'));
		this.password = env.getOrDefault('MONGO_INITDB_ROOT_PASSWORD', env.get('MONGODB_ROOT_PASSWORD'));
		this.database = env.getOrDefault('MONGO_INITDB_DATABASE', env.get('MONGODB_DATABASE'));
	}
	String getUsername() {
		return this.username;
	}
	String getPassword() {
		return this.password;
	}
	String getDatabase() {
		return this.database;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.mongo;
/**
class MongoDockerComposeConnectionDetailsFactory extends DockerComposeConnectionDetailsFactory<MongoConnectionDetails> {
	private static final String[] MONGODB_CONTAINER_NAMES = { 'mongo', 'bitnami/mongodb' };
	private static final int MONGODB_PORT = 27017;
	protected MongoDockerComposeConnectionDetailsFactory() {
		super(MONGODB_CONTAINER_NAMES, 'com.mongodb.ConnectionString');
	}
	@Override
	protected MongoDockerComposeConnectionDetails getDockerComposeConnectionDetails(
			DockerComposeConnectionSource source) {
		return new MongoDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link MongoConnectionDetails} backed by a {@code mongo} {@link RunningService}.
	 */
	static class MongoDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements MongoConnectionDetails {
		private final ConnectionString connectionString;
		MongoDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.connectionString = buildConnectionString(service);
		}
		private ConnectionString buildConnectionString(RunningService service) {
			MongoEnvironment environment = new MongoEnvironment(service.env());
			StringBuilder builder = new StringBuilder('mongodb://');
			if (environment.getUsername() != null) {
				builder.append(environment.getUsername());
				builder.append(':');
				builder.append((environment.getPassword() != null) ? environment.getPassword() : '');
				builder.append('@');
			}
			builder.append(service.host());
			builder.append(':');
			builder.append(service.ports().get(MONGODB_PORT));
			builder.append('/');
			builder.append((environment.getDatabase() != null) ? environment.getDatabase() : 'test');
			if (environment.getUsername() != null) {
				builder.append('?authSource=admin');
			}
			return new ConnectionString(builder.toString());
		}
		@Override
		public ConnectionString getConnectionString() {
			return this.connectionString;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.mongo;
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQClassicDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<ActiveMQConnectionDetails> {
	private static final int ACTIVEMQ_PORT = 61616;
	protected ActiveMQClassicDockerComposeConnectionDetailsFactory() {
		super('apache/activemq-classic');
	}
	@Override
	protected ActiveMQConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new ActiveMQDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link ActiveMQConnectionDetails} backed by an {@code activemq}
	 * {@link RunningService}.
	 */
	static class ActiveMQDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements ActiveMQConnectionDetails {
		private final ActiveMQClassicEnvironment environment;
		private final String brokerUrl;
		protected ActiveMQDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new ActiveMQClassicEnvironment(service.env());
			this.brokerUrl = 'tcp://' + service.host() + ':' + service.ports().get(ACTIVEMQ_PORT);
		}
		@Override
		public String getBrokerUrl() {
			return this.brokerUrl;
		}
		@Override
		public String getUser() {
			return this.environment.getUser();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQClassicEnvironment {
	private final String user;
	private final String password;
	ActiveMQClassicEnvironment(Map<String, String> env) {
		this.user = env.get('ACTIVEMQ_CONNECTION_USER');
		this.password = env.get('ACTIVEMQ_CONNECTION_PASSWORD');
	}
	String getUser() {
		return this.user;
	}
	String getPassword() {
		return this.password;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQEnvironment {
	private final String user;
	private final String password;
	ActiveMQEnvironment(Map<String, String> env) {
		this.user = env.get('ACTIVEMQ_USERNAME');
		this.password = env.get('ACTIVEMQ_PASSWORD');
	}
	String getUser() {
		return this.user;
	}
	String getPassword() {
		return this.password;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ArtemisEnvironment {
	private final String user;
	private final String password;
	ArtemisEnvironment(Map<String, String> env) {
		this.user = env.get('ARTEMIS_USER');
		this.password = env.get('ARTEMIS_PASSWORD');
	}
	String getUser() {
		return this.user;
	}
	String getPassword() {
		return this.password;
	}
}
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ArtemisDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<ArtemisConnectionDetails> {
	private static final int ACTIVEMQ_PORT = 61616;
	protected ArtemisDockerComposeConnectionDetailsFactory() {
		super('apache/activemq-artemis');
	}
	@Override
	protected ArtemisConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new ArtemisDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link ArtemisConnectionDetails} backed by a {@code artemis}
	 * {@link RunningService}.
	 */
	static class ArtemisDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements ArtemisConnectionDetails {
		private final ArtemisEnvironment environment;
		private final String brokerUrl;
		protected ArtemisDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new ArtemisEnvironment(service.env());
			this.brokerUrl = 'tcp://' + service.host() + ':' + service.ports().get(ACTIVEMQ_PORT);
		}
		@Override
		public ArtemisMode getMode() {
			return ArtemisMode.NATIVE;
		}
		@Override
		public String getBrokerUrl() {
			return this.brokerUrl;
		}
		@Override
		public String getUser() {
			return this.environment.getUser();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.service.connection.activemq;
/*
package org.springframework.boot.docker.compose.service.connection.activemq;
/**
class ActiveMQDockerComposeConnectionDetailsFactory
		extends DockerComposeConnectionDetailsFactory<ActiveMQConnectionDetails> {
	private static final int ACTIVEMQ_PORT = 61616;
	protected ActiveMQDockerComposeConnectionDetailsFactory() {
		super('symptoma/activemq');
	}
	@Override
	protected ActiveMQConnectionDetails getDockerComposeConnectionDetails(DockerComposeConnectionSource source) {
		return new ActiveMQDockerComposeConnectionDetails(source.getRunningService());
	}
	/**
	 * {@link ActiveMQConnectionDetails} backed by an {@code activemq}
	 * {@link RunningService}.
	 */
	static class ActiveMQDockerComposeConnectionDetails extends DockerComposeConnectionDetails
			implements ActiveMQConnectionDetails {
		private final ActiveMQEnvironment environment;
		private final String brokerUrl;
		protected ActiveMQDockerComposeConnectionDetails(RunningService service) {
			super(service);
			this.environment = new ActiveMQEnvironment(service.env());
			this.brokerUrl = 'tcp://' + service.host() + ':' + service.ports().get(ACTIVEMQ_PORT);
		}
		@Override
		public String getBrokerUrl() {
			return this.brokerUrl;
		}
		@Override
		public String getUser() {
			return this.environment.getUser();
		}
		@Override
		public String getPassword() {
			return this.environment.getPassword();
		}
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class DockerComposeListener implements ApplicationListener<ApplicationPreparedEvent> {
	private final SpringApplicationShutdownHandlers shutdownHandlers;
	DockerComposeListener() {
		this(SpringApplication.getShutdownHandlers());
	}
	DockerComposeListener(SpringApplicationShutdownHandlers shutdownHandlers) {
		this.shutdownHandlers = shutdownHandlers;
	}
	@Override
	public void onApplicationEvent(ApplicationPreparedEvent event) {
		ConfigurableApplicationContext applicationContext = event.getApplicationContext();
		Binder binder = Binder.get(applicationContext.getEnvironment());
		DockerComposeProperties properties = DockerComposeProperties.get(binder);
		Set<ApplicationListener<?>> eventListeners = event.getSpringApplication().getListeners();
		createDockerComposeLifecycleManager(applicationContext, binder, properties, eventListeners).start();
	}
	protected DockerComposeLifecycleManager createDockerComposeLifecycleManager(
			ConfigurableApplicationContext applicationContext, Binder binder, DockerComposeProperties properties,
			Set<ApplicationListener<?>> eventListeners) {
		return new DockerComposeLifecycleManager(applicationContext, binder, this.shutdownHandlers, properties,
				eventListeners);
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
@ConfigurationProperties(DockerComposeProperties.NAME)
public class DockerComposeProperties {
	static final String NAME = 'spring.docker.compose';
	/**
	 * Whether Docker Compose support is enabled.
	 */
	private boolean enabled = true;
	/**
	 * Arguments to pass to the Docker Compose command.
	 */
	private final List<String> arguments = new ArrayList<>();
	/**
	 * Paths to the Docker Compose configuration files.
	 */
	private final List<File> file = new ArrayList<>();
	/**
	 * Docker compose lifecycle management.
	 */
	private LifecycleManagement lifecycleManagement = LifecycleManagement.START_AND_STOP;
	/**
	 * Hostname or IP of the machine where the docker containers are started.
	 */
	private String host;
	/**
	 * Start configuration.
	 */
	private final Start start = new Start();
	/**
	 * Stop configuration.
	 */
	private final Stop stop = new Stop();
	/**
	 * Profiles configuration.
	 */
	private final Profiles profiles = new Profiles();
	private final Skip skip = new Skip();
	private final Readiness readiness = new Readiness();
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public List<String> getArguments() {
		return this.arguments;
	}
	public List<File> getFile() {
		return this.file;
	}
	public LifecycleManagement getLifecycleManagement() {
		return this.lifecycleManagement;
	}
	public void setLifecycleManagement(LifecycleManagement lifecycleManagement) {
		this.lifecycleManagement = lifecycleManagement;
	}
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public Start getStart() {
		return this.start;
	}
	public Stop getStop() {
		return this.stop;
	}
	public Profiles getProfiles() {
		return this.profiles;
	}
	public Skip getSkip() {
		return this.skip;
	}
	public Readiness getReadiness() {
		return this.readiness;
	}
	static DockerComposeProperties get(Binder binder) {
		return binder.bind(NAME, DockerComposeProperties.class).orElseGet(DockerComposeProperties::new);
	}
	/**
	 * Start properties.
	 */
	public static class Start {
		/**
		 * Command used to start Docker Compose.
		 */
		private StartCommand command = StartCommand.UP;
		/**
		 * Log level for output.
		 */
		private LogLevel logLevel = LogLevel.INFO;
		/**
		 * Whether to skip executing the start command.
		 */
		private Skip skip = Skip.IF_RUNNING;
		/**
		 * Arguments to pass to the start command.
		 */
		private final List<String> arguments = new ArrayList<>();
		public StartCommand getCommand() {
			return this.command;
		}
		public void setCommand(StartCommand command) {
			this.command = command;
		}
		public LogLevel getLogLevel() {
			return this.logLevel;
		}
		public void setLogLevel(LogLevel logLevel) {
			this.logLevel = logLevel;
		}
		public Skip getSkip() {
			return this.skip;
		}
		public void setSkip(Skip skip) {
			this.skip = skip;
		}
		public List<String> getArguments() {
			return this.arguments;
		}
		/**
		 * Start command skip mode.
		 */
		public enum Skip {
			/**
			 * Never skip start.
			 */
			NEVER {
				@Override
				boolean shouldSkip(List<RunningService> runningServices) {
					return false;
				}
			},
			/**
			 * Skip start if there are already services running.
			 */
			IF_RUNNING {
				@Override
				boolean shouldSkip(List<RunningService> runningServices) {
					return !runningServices.isEmpty();
				}
				@Override
				String getLogMessage() {
					return 'There are already Docker Compose services running, skipping startup';
				}
			};
			abstract boolean shouldSkip(List<RunningService> runningServices);
			String getLogMessage() {
				return '';
			}
		}
	}
	/**
	 * Stop properties.
	 */
	public static class Stop {
		/**
		 * Command used to stop Docker Compose.
		 */
		private StopCommand command = StopCommand.STOP;
		/**
		 * Timeout for stopping Docker Compose. Use "0" for forced stop.
		 */
		private Duration timeout = Duration.ofSeconds(10);
		/**
		 * Arguments to pass to the stop command.
		 */
		private final List<String> arguments = new ArrayList<>();
		public StopCommand getCommand() {
			return this.command;
		}
		public void setCommand(StopCommand command) {
			this.command = command;
		}
		public Duration getTimeout() {
			return this.timeout;
		}
		public void setTimeout(Duration timeout) {
			this.timeout = timeout;
		}
		public List<String> getArguments() {
			return this.arguments;
		}
	}
	/**
	 * Profiles properties.
	 */
	public static class Profiles {
		/**
		 * Docker compose profiles that should be active.
		 */
		private Set<String> active = new LinkedHashSet<>();
		public Set<String> getActive() {
			return this.active;
		}
		public void setActive(Set<String> active) {
			this.active = active;
		}
	}
	/**
	 * Skip options.
	 */
	public static class Skip {
		/**
		 * Whether to skip in tests.
		 */
		private boolean inTests = true;
		public boolean isInTests() {
			return this.inTests;
		}
		public void setInTests(boolean inTests) {
			this.inTests = inTests;
		}
	}
	/**
	 * Readiness properties.
	 */
	public static class Readiness {
		/**
		 * Wait strategy to use.
		 */
		private Wait wait = Wait.ALWAYS;
		/**
		 * Timeout of the readiness checks.
		 */
		private Duration timeout = Duration.ofMinutes(2);
		/**
		 * TCP properties.
		 */
		private final Tcp tcp = new Tcp();
		public Wait getWait() {
			return this.wait;
		}
		public void setWait(Wait wait) {
			this.wait = wait;
		}
		public Duration getTimeout() {
			return this.timeout;
		}
		public void setTimeout(Duration timeout) {
			this.timeout = timeout;
		}
		public Tcp getTcp() {
			return this.tcp;
		}
		/**
		 * Readiness wait strategies.
		 */
		public enum Wait {
			/**
			 * Always perform readiness checks.
			 */
			ALWAYS,
			/**
			 * Never perform readiness checks.
			 */
			NEVER,
			/**
			 * Only perform readiness checks if docker was started with lifecycle
			 * management.
			 */
			ONLY_IF_STARTED
		}
		/**
		 * TCP properties.
		 */
		public static class Tcp {
			/**
			 * Timeout for connections.
			 */
			private Duration connectTimeout = Duration.ofMillis(200);
			/**
			 * Timeout for reads.
			 */
			private Duration readTimeout = Duration.ofMillis(200);
			public Duration getConnectTimeout() {
				return this.connectTimeout;
			}
			public void setConnectTimeout(Duration connectTimeout) {
				this.connectTimeout = connectTimeout;
			}
			public Duration getReadTimeout() {
				return this.readTimeout;
			}
			public void setReadTimeout(Duration readTimeout) {
				this.readTimeout = readTimeout;
			}
		}
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
public final class ReadinessTimeoutException extends RuntimeException {
	private final Duration timeout;
	ReadinessTimeoutException(Duration timeout, List<ServiceNotReadyException> exceptions) {
		super(buildMessage(timeout, exceptions));
		this.timeout = timeout;
		exceptions.forEach(this::addSuppressed);
	}
	private static String buildMessage(Duration timeout, List<ServiceNotReadyException> exceptions) {
		List<String> serviceNames = exceptions.stream()
			.map(ServiceNotReadyException::getService)
			.filter(Objects::nonNull)
			.map(RunningService::name)
			.toList();
		return 'Readiness timeout of %s reached while waiting for services %s'.formatted(timeout, serviceNames);
	}
	/**
	 * Return the timeout that was reached.
	 * @return the timeout
	 */
	public Duration getTimeout() {
		return this.timeout;
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class ServiceNotReadyException extends RuntimeException {
	private final RunningService service;
	ServiceNotReadyException(RunningService service, String message) {
		this(service, message, null);
	}
	ServiceNotReadyException(RunningService service, String message, Throwable cause) {
		super(message, cause);
		this.service = service;
	}
	RunningService getService() {
		return this.service;
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
public enum StartCommand {
	/**
	 * Start using {@code docker compose up}.
	 */
	UP(DockerCompose::up),
	/**
	 * Start using {@code docker compose start}.
	 */
	START(DockerCompose::start);
	private final Command command;
	StartCommand(Command command) {
		this.command = command;
	}
	void applyTo(DockerCompose dockerCompose, LogLevel logLevel, List<String> arguments) {
		this.command.applyTo(dockerCompose, logLevel, arguments);
	}
	@FunctionalInterface
	private interface Command {
		void applyTo(DockerCompose dockerCompose, LogLevel logLevel, List<String> arguments);
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class ServiceReadinessChecks {
	private static final Log logger = LogFactory.getLog(ServiceReadinessChecks.class);
	private static final String DISABLE_LABEL = 'org.springframework.boot.readiness-check.disable';
	private static final Duration SLEEP_BETWEEN_READINESS_TRIES = Duration.ofSeconds(1);
	private final Clock clock;
	private final Consumer<Duration> sleep;
	private final DockerComposeProperties.Readiness properties;
	private final TcpConnectServiceReadinessCheck check;
	ServiceReadinessChecks(DockerComposeProperties.Readiness properties) {
		this(properties, Clock.systemUTC(), ServiceReadinessChecks::sleep,
				new TcpConnectServiceReadinessCheck(properties.getTcp()));
	}
	ServiceReadinessChecks(DockerComposeProperties.Readiness properties, Clock clock, Consumer<Duration> sleep,
			TcpConnectServiceReadinessCheck check) {
		this.clock = clock;
		this.sleep = sleep;
		this.properties = properties;
		this.check = check;
	}
	/**
	 * Wait for the given services to be ready.
	 * @param runningServices the services to wait for
	 */
	void waitUntilReady(List<RunningService> runningServices) {
		Duration timeout = this.properties.getTimeout();
		Instant start = this.clock.instant();
		while (true) {
			List<ServiceNotReadyException> exceptions = check(runningServices);
			if (exceptions.isEmpty()) {
				return;
			}
			Duration elapsed = Duration.between(start, this.clock.instant());
			if (elapsed.compareTo(timeout) > 0) {
				throw new ReadinessTimeoutException(timeout, exceptions);
			}
			this.sleep.accept(SLEEP_BETWEEN_READINESS_TRIES);
		}
	}
	private List<ServiceNotReadyException> check(List<RunningService> runningServices) {
		List<ServiceNotReadyException> exceptions = null;
		for (RunningService service : runningServices) {
			if (isDisabled(service)) {
				continue;
			}
			logger.trace(LogMessage.format('Checking readiness of service "%s"', service));
			try {
				this.check.check(service);
				logger.trace(LogMessage.format('Service "%s" is ready', service));
			}
			catch (ServiceNotReadyException ex) {
				logger.trace(LogMessage.format('Service "%s" is not ready', service), ex);
				exceptions = (exceptions != null) ? exceptions : new ArrayList<>();
				exceptions.add(ex);
			}
		}
		return (exceptions != null) ? exceptions : Collections.emptyList();
	}
	private boolean isDisabled(RunningService service) {
		return service.labels().containsKey(DISABLE_LABEL);
	}
	private static void sleep(Duration duration) {
		try {
			Thread.sleep(duration.toMillis());
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
public enum LifecycleManagement {
	/**
	 * Don"t start or stop Docker Compose.
	 */
	NONE(false, false),
	/**
	 * Start Docker Compose if it"s not running.
	 */
	START_ONLY(true, false),
	/**
	 * Start Docker Compose if it"s not running and stop it when the JVM exits.
	 */
	START_AND_STOP(true, true);
	private final boolean start;
	private final boolean stop;
	LifecycleManagement(boolean start, boolean stop) {
		this.start = start;
		this.stop = stop;
	}
	/**
	 * Return whether Docker Compose should be started.
	 * @return whether Docker Compose should be started
	 */
	boolean shouldStart() {
		return this.start;
	}
	/**
	 * Return whether Docker Compose should be stopped.
	 * @return whether Docker Compose should be stopped
	 */
	boolean shouldStop() {
		return this.stop;
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class DockerComposeSkipCheck {
	private static final Set<String> REQUIRED_CLASSES = Set.of('org.junit.jupiter.api.Test', 'org.junit.Test');
	private static final Set<String> SKIPPED_STACK_ELEMENTS;
	static {
		Set<String> skipped = new LinkedHashSet<>();
		skipped.add('org.junit.runners.');
		skipped.add('org.junit.platform.');
		skipped.add('org.springframework.boot.test.');
		skipped.add(SpringApplicationAotProcessor.class.getName());
		skipped.add('cucumber.runtime.');
		SKIPPED_STACK_ELEMENTS = Collections.unmodifiableSet(skipped);
	}
	boolean shouldSkip(ClassLoader classLoader, DockerComposeProperties.Skip properties) {
		if (properties.isInTests() && hasAtLeastOneRequiredClass(classLoader)) {
			Thread thread = Thread.currentThread();
			for (StackTraceElement element : thread.getStackTrace()) {
				if (isSkippedStackElement(element)) {
					return true;
				}
			}
		}
		return false;
	}
	private boolean hasAtLeastOneRequiredClass(ClassLoader classLoader) {
		for (String requiredClass : REQUIRED_CLASSES) {
			if (ClassUtils.isPresent(requiredClass, classLoader)) {
				return true;
			}
		}
		return false;
	}
	private static boolean isSkippedStackElement(StackTraceElement element) {
		for (String skipped : SKIPPED_STACK_ELEMENTS) {
			if (element.getClassName().startsWith(skipped)) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
public class DockerComposeServicesReadyEvent extends ApplicationEvent {
	private final List<RunningService> runningServices;
	DockerComposeServicesReadyEvent(ApplicationContext source, List<RunningService> runningServices) {
		super(source);
		this.runningServices = runningServices;
	}
	@Override
	public ApplicationContext getSource() {
		return (ApplicationContext) super.getSource();
	}
	/**
	 * Return the relevant Docker Compose services that are running.
	 * @return the running services
	 */
	public List<RunningService> getRunningServices() {
		return this.runningServices;
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
public enum StopCommand {
	/**
	 * Stop using {@code docker compose down}.
	 */
	DOWN(DockerCompose::down),
	/**
	 * Stop using {@code docker compose stop}.
	 */
	STOP(DockerCompose::stop);
	private final Command command;
	StopCommand(Command command) {
		this.command = command;
	}
	void applyTo(DockerCompose dockerCompose, Duration timeout, List<String> arguments) {
		this.command.applyTo(dockerCompose, timeout, arguments);
	}
	@FunctionalInterface
	private interface Command {
		void applyTo(DockerCompose dockerCompose, Duration timeout, List<String> arguments);
	}
}
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class TcpConnectServiceReadinessCheck {
	private static final String DISABLE_LABEL = 'org.springframework.boot.readiness-check.tcp.disable';
	private final DockerComposeProperties.Readiness.Tcp properties;
	TcpConnectServiceReadinessCheck(DockerComposeProperties.Readiness.Tcp properties) {
		this.properties = properties;
	}
	void check(RunningService service) {
		if (service.labels().containsKey(DISABLE_LABEL)) {
			return;
		}
		for (int port : service.ports().getAll('tcp')) {
			check(service, port);
		}
	}
	private void check(RunningService service, int port) {
		int connectTimeout = (int) this.properties.getConnectTimeout().toMillis();
		int readTimeout = (int) this.properties.getReadTimeout().toMillis();
		try (Socket socket = new Socket()) {
			socket.setSoTimeout(readTimeout);
			socket.connect(new InetSocketAddress(service.host(), port), connectTimeout);
			check(service, port, socket);
		}
		catch (IOException ex) {
			throw new ServiceNotReadyException(service, 'IOException while connecting to port %s'.formatted(port), ex);
		}
	}
	private void check(RunningService service, int port, Socket socket) throws IOException {
		try {
			// -1 indicates the socket has been closed immediately
			// Other responses or a timeout are considered as success
			if (socket.getInputStream().read() == -1) {
				throw new ServiceNotReadyException(service,
						'Immediate disconnect while connecting to port %s'.formatted(port));
			}
		}
		catch (SocketTimeoutException ex) {
			// Ignore
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.lifecycle;
/*
package org.springframework.boot.docker.compose.lifecycle;
/**
class DockerComposeLifecycleManager {
	private static final Log logger = LogFactory.getLog(DockerComposeLifecycleManager.class);
	private static final String IGNORE_LABEL = 'org.springframework.boot.ignore';
	private final File workingDirectory;
	private final ApplicationContext applicationContext;
	private final ClassLoader classLoader;
	private final SpringApplicationShutdownHandlers shutdownHandlers;
	private final DockerComposeProperties properties;
	private final Set<ApplicationListener<?>> eventListeners;
	private final DockerComposeSkipCheck skipCheck;
	private final ServiceReadinessChecks serviceReadinessChecks;
	DockerComposeLifecycleManager(ApplicationContext applicationContext, Binder binder,
			SpringApplicationShutdownHandlers shutdownHandlers, DockerComposeProperties properties,
			Set<ApplicationListener<?>> eventListeners) {
		this(null, applicationContext, binder, shutdownHandlers, properties, eventListeners,
				new DockerComposeSkipCheck(), null);
	}
	DockerComposeLifecycleManager(File workingDirectory, ApplicationContext applicationContext, Binder binder,
			SpringApplicationShutdownHandlers shutdownHandlers, DockerComposeProperties properties,
			Set<ApplicationListener<?>> eventListeners, DockerComposeSkipCheck skipCheck,
			ServiceReadinessChecks serviceReadinessChecks) {
		this.workingDirectory = workingDirectory;
		this.applicationContext = applicationContext;
		this.classLoader = applicationContext.getClassLoader();
		this.shutdownHandlers = shutdownHandlers;
		this.properties = properties;
		this.eventListeners = eventListeners;
		this.skipCheck = skipCheck;
		this.serviceReadinessChecks = (serviceReadinessChecks != null) ? serviceReadinessChecks
				: new ServiceReadinessChecks(properties.getReadiness());
	}
	void start() {
		if (Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING) || AotDetector.useGeneratedArtifacts()) {
			logger.trace('Docker Compose support disabled with AOT and native images');
			return;
		}
		if (!this.properties.isEnabled()) {
			logger.trace('Docker Compose support not enabled');
			return;
		}
		if (this.skipCheck.shouldSkip(this.classLoader, this.properties.getSkip())) {
			logger.trace('Docker Compose support skipped');
			return;
		}
		DockerComposeFile composeFile = getComposeFile();
		Set<String> activeProfiles = this.properties.getProfiles().getActive();
		List<String> arguments = this.properties.getArguments();
		DockerCompose dockerCompose = getDockerCompose(composeFile, activeProfiles, arguments);
		if (!dockerCompose.hasDefinedServices()) {
			logger.warn(LogMessage.format('No services defined in Docker Compose file %s with active profiles %s',
					composeFile, activeProfiles));
			return;
		}
		LifecycleManagement lifecycleManagement = this.properties.getLifecycleManagement();
		Start start = this.properties.getStart();
		Stop stop = this.properties.getStop();
		Wait wait = this.properties.getReadiness().getWait();
		List<RunningService> runningServices = dockerCompose.getRunningServices();
		if (lifecycleManagement.shouldStart()) {
			Skip skip = this.properties.getStart().getSkip();
			if (skip.shouldSkip(runningServices)) {
				logger.info(skip.getLogMessage());
			}
			else {
				start.getCommand().applyTo(dockerCompose, start.getLogLevel(), start.getArguments());
				runningServices = dockerCompose.getRunningServices();
				if (wait == Wait.ONLY_IF_STARTED) {
					wait = Wait.ALWAYS;
				}
				if (lifecycleManagement.shouldStop()) {
					this.shutdownHandlers
						.add(() -> stop.getCommand().applyTo(dockerCompose, stop.getTimeout(), stop.getArguments()));
				}
			}
		}
		List<RunningService> relevantServices = new ArrayList<>(runningServices);
		relevantServices.removeIf(this::isIgnored);
		if (wait == Wait.ALWAYS || wait == null) {
			this.serviceReadinessChecks.waitUntilReady(relevantServices);
		}
		publishEvent(new DockerComposeServicesReadyEvent(this.applicationContext, relevantServices));
	}
	protected DockerComposeFile getComposeFile() {
		DockerComposeFile composeFile = (CollectionUtils.isEmpty(this.properties.getFile()))
				? DockerComposeFile.find(this.workingDirectory) : DockerComposeFile.of(this.properties.getFile());
		Assert.state(composeFile != null, () -> 'No Docker Compose file found in directory "%s"'.formatted(
				((this.workingDirectory != null) ? this.workingDirectory : new File('.')).toPath().toAbsolutePath()));
		if (composeFile.getFiles().size() == 1) {
			logger.info(LogMessage.format('Using Docker Compose file %s', composeFile.getFiles().get(0)));
		}
		else {
			logger.info(LogMessage.format('Using Docker Compose files %s', composeFile.toString()));
		}
		return composeFile;
	}
	protected DockerCompose getDockerCompose(DockerComposeFile composeFile, Set<String> activeProfiles,
			List<String> arguments) {
		return DockerCompose.get(composeFile, this.properties.getHost(), activeProfiles, arguments);
	}
	private boolean isIgnored(RunningService service) {
		return service.labels().containsKey(IGNORE_LABEL);
	}
	/**
	 * Publish a {@link DockerComposeServicesReadyEvent} directly to the event listeners
	 * since we cannot call {@link ApplicationContext#publishEvent} this early.
	 * @param event the event to publish
	 */
	private void publishEvent(DockerComposeServicesReadyEvent event) {
		SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();
		this.eventListeners.forEach(multicaster::addApplicationListener);
		multicaster.multicastEvent(event);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerCli {
	private static final Map<File, DockerCommands> dockerCommandsCache = new HashMap<>();
	private static final Log logger = LogFactory.getLog(DockerCli.class);
	private final ProcessRunner processRunner;
	private final DockerCommands dockerCommands;
	private final DockerComposeOptions dockerComposeOptions;
	/**
	 * Create a new {@link DockerCli} instance.
	 * @param workingDirectory the working directory or {@code null}
	 * @param dockerComposeOptions the Docker Compose options to use or {@code null}.
	 */
	DockerCli(File workingDirectory, DockerComposeOptions dockerComposeOptions) {
		this.processRunner = new ProcessRunner(workingDirectory);
		this.dockerCommands = dockerCommandsCache.computeIfAbsent(workingDirectory,
				(key) -> new DockerCommands(this.processRunner));
		this.dockerComposeOptions = (dockerComposeOptions != null) ? dockerComposeOptions : DockerComposeOptions.none();
	}
	/**
	 * Run the given {@link DockerCli} command and return the response.
	 * @param <R> the response type
	 * @param dockerCommand the command to run
	 * @return the response
	 */
	<R> R run(DockerCliCommand<R> dockerCommand) {
		List<String> command = createCommand(dockerCommand.getType());
		command.addAll(dockerCommand.getCommand());
		Consumer<String> outputConsumer = createOutputConsumer(dockerCommand.getLogLevel());
		String json = this.processRunner.run(outputConsumer, command.toArray(new String[0]));
		return dockerCommand.deserialize(json);
	}
	private Consumer<String> createOutputConsumer(LogLevel logLevel) {
		if (logLevel == null || logLevel == LogLevel.OFF) {
			return null;
		}
		return (line) -> logLevel.log(logger, line);
	}
	private List<String> createCommand(Type type) {
		return switch (type) {
			case DOCKER -> new ArrayList<>(this.dockerCommands.get(type));
			case DOCKER_COMPOSE -> {
				List<String> result = new ArrayList<>(this.dockerCommands.get(type));
				DockerComposeFile composeFile = this.dockerComposeOptions.composeFile();
				if (composeFile != null) {
					for (File file : composeFile.getFiles()) {
						result.add('--file');
						result.add(file.getPath());
					}
				}
				result.add('--ansi');
				result.add('never');
				Set<String> activeProfiles = this.dockerComposeOptions.activeProfiles();
				if (!CollectionUtils.isEmpty(activeProfiles)) {
					for (String profile : activeProfiles) {
						result.add('--profile');
						result.add(profile);
					}
				}
				List<String> arguments = this.dockerComposeOptions.arguments();
				if (!CollectionUtils.isEmpty(arguments)) {
					result.addAll(arguments);
				}
				yield result;
			}
		};
	}
	/**
	 * Return the {@link DockerComposeFile} being used by this CLI instance.
	 * @return the Docker Compose file
	 */
	DockerComposeFile getDockerComposeFile() {
		return this.dockerComposeOptions.composeFile();
	}
	/**
	 * Holds details of the actual CLI commands to invoke.
	 */
	private static class DockerCommands {
		private final List<String> dockerCommand;
		private final List<String> dockerComposeCommand;
		DockerCommands(ProcessRunner processRunner) {
			this.dockerCommand = getDockerCommand(processRunner);
			this.dockerComposeCommand = getDockerComposeCommand(processRunner);
		}
		private List<String> getDockerCommand(ProcessRunner processRunner) {
			try {
				String version = processRunner.run('docker', 'version', '--format', '{{.Client.Version}}');
				logger.trace(LogMessage.format('Using docker %s', version));
				return List.of('docker');
			}
			catch (ProcessStartException ex) {
				throw new DockerProcessStartException('Unable to start docker process. Is docker correctly installed?',
						ex);
			}
			catch (ProcessExitException ex) {
				if (ex.getStdErr().contains('docker daemon is not running')
						|| ex.getStdErr().contains('Cannot connect to the Docker daemon')) {
					throw new DockerNotRunningException(ex.getStdErr(), ex);
				}
				throw ex;
			}
		}
		private List<String> getDockerComposeCommand(ProcessRunner processRunner) {
			try {
				DockerCliComposeVersionResponse response = DockerJson.deserialize(
						processRunner.run('docker', 'compose', 'version', '--format', 'json'),
						DockerCliComposeVersionResponse.class);
				logger.trace(LogMessage.format('Using Docker Compose %s', response.version()));
				return List.of('docker', 'compose');
			}
			catch (ProcessExitException ex) {
				// Ignore and try docker-compose
			}
			try {
				DockerCliComposeVersionResponse response = DockerJson.deserialize(
						processRunner.run('docker-compose', 'version', '--format', 'json'),
						DockerCliComposeVersionResponse.class);
				logger.trace(LogMessage.format('Using docker-compose %s', response.version()));
				return List.of('docker-compose');
			}
			catch (ProcessStartException ex) {
				throw new DockerProcessStartException(
						'Unable to start "docker-compose" process or use "docker compose". Is docker correctly installed?',
						ex);
			}
		}
		List<String> get(Type type) {
			return switch (type) {
				case DOCKER -> this.dockerCommand;
				case DOCKER_COMPOSE -> this.dockerComposeCommand;
			};
		}
	}
	/**
	 * Options for Docker Compose.
	 *
	 * @param composeFile the Docker Compose file to use
	 * @param activeProfiles the profiles to activate
	 * @param arguments the arguments to pass to Docker Compose
	 */
	record DockerComposeOptions(DockerComposeFile composeFile, Set<String> activeProfiles, List<String> arguments) {
		DockerComposeOptions {
			activeProfiles = (activeProfiles != null) ? activeProfiles : Collections.emptySet();
			arguments = (arguments != null) ? arguments : Collections.emptyList();
		}
		static DockerComposeOptions none() {
			return new DockerComposeOptions(null, null, null);
		}
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
record DockerCliComposeConfigResponse(String name, Map<String, DockerCliComposeConfigResponse.Service> services) {
	/**
	 * Docker compose service.
	 *
	 * @param image the image
	 */
	record Service(String image) {
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
abstract sealed class DockerCliCommand<R> {
	private final Type type;
	private final LogLevel logLevel;
	private final Class<?> responseType;
	private final boolean listResponse;
	private final List<String> command;
	private DockerCliCommand(Type type, Class<?> responseType, boolean listResponse, String... command) {
		this(type, LogLevel.OFF, responseType, listResponse, command);
	}
	private DockerCliCommand(Type type, LogLevel logLevel, Class<?> responseType, boolean listResponse,
			String... command) {
		this.type = type;
		this.logLevel = logLevel;
		this.responseType = responseType;
		this.listResponse = listResponse;
		this.command = List.of(command);
	}
	Type getType() {
		return this.type;
	}
	LogLevel getLogLevel() {
		return this.logLevel;
	}
	List<String> getCommand() {
		return this.command;
	}
	@SuppressWarnings('unchecked')
	R deserialize(String json) {
		if (this.responseType == Void.class) {
			return null;
		}
		return (R) ((!this.listResponse) ? DockerJson.deserialize(json, this.responseType)
				: DockerJson.deserializeToList(json, this.responseType));
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		DockerCliCommand<?> other = (DockerCliCommand<?>) obj;
		boolean result = this.type == other.type;
		result = result && this.responseType == other.responseType;
		result = result && this.listResponse == other.listResponse;
		result = result && this.command.equals(other.command);
		return result;
	}
	@Override
	public int hashCode() {
		return Objects.hash(this.type, this.responseType, this.listResponse, this.command);
	}
	@Override
	public String toString() {
		return 'DockerCliCommand [type=%s, responseType=%s, listResponse=%s, command=%s]'.formatted(this.type,
				this.responseType, this.listResponse, this.command);
	}
	protected static String[] join(Collection<String> command, Collection<String> args) {
		List<String> result = new ArrayList<>(command);
		result.addAll(args);
		return result.toArray(new String[0]);
	}
	/**
	 * The {@code docker context} command.
	 */
	static final class Context extends DockerCliCommand<List<DockerCliContextResponse>> {
		Context() {
			super(Type.DOCKER, DockerCliContextResponse.class, true, 'context', 'ls', '--format={{ json . }}');
		}
	}
	/**
	 * The {@code docker inspect} command.
	 */
	static final class Inspect extends DockerCliCommand<List<DockerCliInspectResponse>> {
		Inspect(Collection<String> ids) {
			super(Type.DOCKER, DockerCliInspectResponse.class, true,
					join(List.of('inspect', '--format={{ json . }}'), ids));
		}
	}
	/**
	 * The {@code docker compose config} command.
	 */
	static final class ComposeConfig extends DockerCliCommand<DockerCliComposeConfigResponse> {
		ComposeConfig() {
			super(Type.DOCKER_COMPOSE, DockerCliComposeConfigResponse.class, false, 'config', '--format=json');
		}
	}
	/**
	 * The {@code docker compose ps} command.
	 */
	static final class ComposePs extends DockerCliCommand<List<DockerCliComposePsResponse>> {
		ComposePs() {
			super(Type.DOCKER_COMPOSE, DockerCliComposePsResponse.class, true, 'ps', '--format=json');
		}
	}
	/**
	 * The {@code docker compose up} command.
	 */
	static final class ComposeUp extends DockerCliCommand<Void> {
		ComposeUp(LogLevel logLevel, List<String> arguments) {
			super(Type.DOCKER_COMPOSE, logLevel, Void.class, false, getCommand(arguments));
		}
		private static String[] getCommand(List<String> arguments) {
			List<String> result = new ArrayList<>();
			result.add('up');
			result.add('--no-color');
			result.add('--detach');
			result.add('--wait');
			result.addAll(arguments);
			return result.toArray(String[]::new);
		}
	}
	/**
	 * The {@code docker compose down} command.
	 */
	static final class ComposeDown extends DockerCliCommand<Void> {
		ComposeDown(Duration timeout, List<String> arguments) {
			super(Type.DOCKER_COMPOSE, Void.class, false, getCommand(timeout, arguments));
		}
		private static String[] getCommand(Duration timeout, List<String> arguments) {
			List<String> command = new ArrayList<>();
			command.add('down');
			command.add('--timeout');
			command.add(Long.toString(timeout.toSeconds()));
			command.addAll(arguments);
			return command.toArray(String[]::new);
		}
	}
	/**
	 * The {@code docker compose start} command.
	 */
	static final class ComposeStart extends DockerCliCommand<Void> {
		ComposeStart(LogLevel logLevel, List<String> arguments) {
			super(Type.DOCKER_COMPOSE, logLevel, Void.class, false, getCommand(arguments));
		}
		private static String[] getCommand(List<String> arguments) {
			List<String> command = new ArrayList<>();
			command.add('start');
			command.addAll(arguments);
			return command.toArray(String[]::new);
		}
	}
	/**
	 * The {@code docker compose stop} command.
	 */
	static final class ComposeStop extends DockerCliCommand<Void> {
		ComposeStop(Duration timeout, List<String> arguments) {
			super(Type.DOCKER_COMPOSE, Void.class, false, getCommand(timeout, arguments));
		}
		private static String[] getCommand(Duration timeout, List<String> arguments) {
			List<String> command = new ArrayList<>();
			command.add('stop');
			command.add('--timeout');
			command.add(Long.toString(timeout.toSeconds()));
			command.addAll(arguments);
			return command.toArray(String[]::new);
		}
	}
	/**
	 * Command Types.
	 */
	enum Type {
		/**
		 * A command executed using {@code docker}.
		 */
		DOCKER,
		/**
		 * A command executed using {@code docker compose} or {@code docker-compose}.
		 */
		DOCKER_COMPOSE
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public interface ConnectionPorts {
	/**
	 * Return the host port mapped to the given container port.
	 * @param containerPort the container port. This is usually the standard port for the
	 * service (e.g. port 80 for HTTP)
	 * @return the host port. This can be an ephemeral port that is different from the
	 * container port
	 * @throws IllegalStateException if the container port is not mapped
	 */
	int get(int containerPort);
	/**
	 * Return all host ports in use.
	 * @return a list of all host ports
	 * @see #getAll(String)
	 */
	List<Integer> getAll();
	/**
	 * Return all host ports in use that match the given protocol.
	 * @param protocol the protocol in use (for example "tcp") or {@code null} to return
	 * all host ports
	 * @return a list of all host ports using the given protocol
	 */
	List<Integer> getAll(String protocol);
}
/*
package org.springframework.boot.docker.compose.core;
/**
record DockerCliComposeVersionResponse(String version) {
}
/*
package org.springframework.boot.docker.compose.core;
/**
record DockerCliInspectResponse(String id, DockerCliInspectResponse.Config config,
		DockerCliInspectResponse.NetworkSettings networkSettings, DockerCliInspectResponse.HostConfig hostConfig) {
	/**
	 * Configuration for the container that is portable between hosts.
	 *
	 * @param image the name (or reference) of the image
	 * @param labels user-defined key/value metadata
	 * @param exposedPorts the mapping of exposed ports
	 * @param env a list of environment variables in the form {@code VAR=value}
	 */
	record Config(String image, Map<String, String> labels, Map<String, ExposedPort> exposedPorts, List<String> env) {
	}
	/**
	 * Empty object used with {@link Config#exposedPorts()}.
	 */
	record ExposedPort() {
	}
	/**
	 * A container"s resources (cgroups config, ulimits, etc).
	 *
	 * @param networkMode the network mode to use for this container
	 */
	record HostConfig(String networkMode) {
	}
	/**
	 * The network settings in the API.
	 *
	 * @param ports the mapping of container ports to host ports
	 */
	record NetworkSettings(Map<String, List<HostPort>> ports) {
	}
	/**
	 * Port mapping details.
	 *
	 * @param hostIp the host IP
	 * @param hostPort the host port
	 */
	record HostPort(String hostIp, String hostPort) {
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public interface RunningService {
	/**
	 * Return the name of the service.
	 * @return the service name
	 */
	String name();
	/**
	 * Return the image being used by the service.
	 * @return the service image
	 */
	ImageReference image();
	/**
	 * Return the host that can be used to connect to the service.
	 * @return the service host
	 */
	String host();
	/**
	 * Return the ports that can be used to connect to the service.
	 * @return the service ports
	 */
	ConnectionPorts ports();
	/**
	 * Return the environment defined for the service.
	 * @return the service env
	 */
	Map<String, String> env();
	/**
	 * Return the labels attached to the service.
	 * @return the service labels
	 */
	Map<String, String> labels();
}
/*
package org.springframework.boot.docker.compose.core;
/**
class ProcessStartException extends RuntimeException {
	ProcessStartException(String[] command, IOException ex) {
		super('Unable to start command %s'.formatted(String.join(' ', command)), ex);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DefaultRunningService implements RunningService, OriginProvider {
	private final Origin origin;
	private final String name;
	private final ImageReference image;
	private final DockerHost host;
	private final DefaultConnectionPorts ports;
	private final Map<String, String> labels;
	private final DockerEnv env;
	DefaultRunningService(DockerHost host, DockerComposeFile composeFile, DockerCliComposePsResponse composePsResponse,
			DockerCliInspectResponse inspectResponse) {
		this.origin = new DockerComposeOrigin(composeFile, composePsResponse.name());
		this.name = composePsResponse.name();
		this.image = ImageReference
			.of((composePsResponse.image() != null) ? composePsResponse.image() : inspectResponse.config().image());
		this.host = host;
		this.ports = new DefaultConnectionPorts(inspectResponse);
		this.env = new DockerEnv(inspectResponse.config().env());
		this.labels = Collections.unmodifiableMap(inspectResponse.config().labels());
	}
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	@Override
	public String name() {
		return this.name;
	}
	@Override
	public ImageReference image() {
		return this.image;
	}
	@Override
	public String host() {
		return this.host.toString();
	}
	@Override
	public ConnectionPorts ports() {
		return this.ports;
	}
	@Override
	public Map<String, String> env() {
		return this.env.asMap();
	}
	@Override
	public Map<String, String> labels() {
		return this.labels;
	}
	@Override
	public String toString() {
		return this.name;
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public interface DockerCompose {
	/**
	 * Timeout duration used to request a forced stop.
	 */
	Duration FORCE_STOP = Duration.ZERO;
	/**
	 * Run {@code docker compose up} to create and start services. Waits until all
	 * contains are started and healthy.
	 * @param logLevel the log level used to report progress
	 */
	void up(LogLevel logLevel);
	/**
	 * Run {@code docker compose up} to create and start services. Waits until all
	 * contains are started and healthy.
	 * @param logLevel the log level used to report progress
	 * @param arguments the arguments to pass to the up command
	 * @since 3.4.0
	 */
	void up(LogLevel logLevel, List<String> arguments);
	/**
	 * Run {@code docker compose down} to stop and remove any running services.
	 * @param timeout the amount of time to wait or {@link #FORCE_STOP} to stop without
	 * waiting.
	 */
	void down(Duration timeout);
	/**
	 * Run {@code docker compose down} to stop and remove any running services.
	 * @param timeout the amount of time to wait or {@link #FORCE_STOP} to stop without
	 * waiting.
	 * @param arguments the arguments to pass to the down command
	 * @since 3.4.0
	 */
	void down(Duration timeout, List<String> arguments);
	/**
	 * Run {@code docker compose start} to start services. Waits until all containers are
	 * started and healthy.
	 * @param logLevel the log level used to report progress
	 */
	void start(LogLevel logLevel);
	/**
	 * Run {@code docker compose start} to start services. Waits until all containers are
	 * started and healthy.
	 * @param logLevel the log level used to report progress
	 * @param arguments the arguments to pass to the start command
	 * @since 3.4.0
	 */
	void start(LogLevel logLevel, List<String> arguments);
	/**
	 * Run {@code docker compose stop} to stop any running services.
	 * @param timeout the amount of time to wait or {@link #FORCE_STOP} to stop without
	 * waiting.
	 */
	void stop(Duration timeout);
	/**
	 * Run {@code docker compose stop} to stop any running services.
	 * @param timeout the amount of time to wait or {@link #FORCE_STOP} to stop without
	 * waiting.
	 * @param arguments the arguments to pass to the stop command
	 * @since 3.4.0
	 */
	void stop(Duration timeout, List<String> arguments);
	/**
	 * Return if services have been defined in the {@link DockerComposeFile} for the
	 * active profiles.
	 * @return {@code true} if services have been defined
	 * @see #hasDefinedServices()
	 */
	boolean hasDefinedServices();
	/**
	 * Return the running services for the active profile, or an empty list if no services
	 * are running.
	 * @return the list of running services
	 */
	List<RunningService> getRunningServices();
	/**
	 * Factory method used to create a {@link DockerCompose} instance.
	 * @param file the Docker Compose file
	 * @param hostname the hostname used for services or {@code null} if the hostname
	 * should be deduced
	 * @param activeProfiles a set of the profiles that should be activated
	 * @return a {@link DockerCompose} instance
	 */
	static DockerCompose get(DockerComposeFile file, String hostname, Set<String> activeProfiles) {
		return get(file, hostname, activeProfiles, Collections.emptyList());
	}
	/**
	 * Factory method used to create a {@link DockerCompose} instance.
	 * @param file the Docker Compose file
	 * @param hostname the hostname used for services or {@code null} if the hostname
	 * should be deduced
	 * @param activeProfiles a set of the profiles that should be activated
	 * @param arguments the arguments to pass to Docker Compose
	 * @return a {@link DockerCompose} instance
	 * @since 3.4.0
	 */
	static DockerCompose get(DockerComposeFile file, String hostname, Set<String> activeProfiles,
			List<String> arguments) {
		DockerCli cli = new DockerCli(null, new DockerComposeOptions(file, activeProfiles, arguments));
		return new DefaultDockerCompose(cli, hostname);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public class DockerNotRunningException extends DockerException {
	private final String errorOutput;
	DockerNotRunningException(String errorOutput, Throwable cause) {
		super('Docker is not running', cause);
		this.errorOutput = errorOutput;
	}
	/**
	 * Return the error output returned from docker.
	 * @return the error output
	 */
	public String getErrorOutput() {
		return this.errorOutput;
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public class DockerProcessStartException extends DockerException {
	DockerProcessStartException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public class DockerOutputParseException extends DockerException {
	DockerOutputParseException(String json, Throwable cause) {
		super('Failed to parse docker JSON:\n\n' + json, cause);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
record DockerCliContextResponse(String name, boolean current, String dockerEndpoint) {
}
/*
package org.springframework.boot.docker.compose.core;
/**
final class DockerJson {
	private static final ObjectMapper objectMapper = JsonMapper.builder()
		.defaultLocale(Locale.ENGLISH)
		.enable(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES)
		.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
		.addModule(new ParameterNamesModule())
		.build();
	private DockerJson() {
	}
	/**
	 * Deserialize JSON to a list. Handles JSON arrays and multiple JSON objects in
	 * separate lines.
	 * @param <T> the item type
	 * @param json the source JSON
	 * @param itemType the item type
	 * @return a list of items
	 */
	static <T> List<T> deserializeToList(String json, Class<T> itemType) {
		if (json.startsWith('[')) {
			JavaType javaType = objectMapper.getTypeFactory().constructCollectionType(List.class, itemType);
			return deserialize(json, javaType);
		}
		return json.trim().lines().map((line) -> deserialize(line, itemType)).toList();
	}
	/**
	 * Deserialize JSON to an object instance.
	 * @param <T> the result type
	 * @param json the source JSON
	 * @param type the result type
	 * @return the deserialized result
	 */
	static <T> T deserialize(String json, Class<T> type) {
		return deserialize(json, objectMapper.getTypeFactory().constructType(type));
	}
	private static <T> T deserialize(String json, JavaType type) {
		try {
			return objectMapper.readValue(json.trim(), type);
		}
		catch (IOException ex) {
			throw new DockerOutputParseException(json, ex);
		}
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DockerEnv {
	private final Map<String, String> map;
	/**
	 * Create a new {@link DockerEnv} instance.
	 * @param env a list of env entries in the form {@code name=value} or {@code name}.
	 */
	DockerEnv(List<String> env) {
		this.map = parse(env);
	}
	private Map<String, String> parse(List<String> env) {
		if (CollectionUtils.isEmpty(env)) {
			return Collections.emptyMap();
		}
		Map<String, String> result = new LinkedHashMap<>();
		env.stream().map(this::parseEntry).forEach((entry) -> result.put(entry.key(), entry.value()));
		return Collections.unmodifiableMap(result);
	}
	private Entry parseEntry(String entry) {
		int index = entry.indexOf("=");
		if (index != -1) {
			String key = entry.substring(0, index);
			String value = entry.substring(index + 1);
			return new Entry(key, value);
		}
		return new Entry(entry, null);
	}
	/**
	 * Return the env as a {@link Map}.
	 * @return the env as a map
	 */
	Map<String, String> asMap() {
		return this.map;
	}
	private record Entry(String key, String value) {
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public record DockerComposeOrigin(DockerComposeFile composeFile, String serviceName) implements Origin {
	@Override
	public String toString() {
		return 'Docker compose service "%s" defined in %s'.formatted(this.serviceName,
				(this.composeFile != null) ? this.composeFile : 'default compose file');
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
public final class DockerComposeFile {
	private static final List<String> SEARCH_ORDER = List.of('compose.yaml', 'compose.yml', 'docker-compose.yaml',
			'docker-compose.yml');
	private final List<File> files;
	private DockerComposeFile(List<File> files) {
		Assert.state(!files.isEmpty(), 'Files must not be empty');
		this.files = files.stream().map(DockerComposeFile::toCanonicalFile).toList();
	}
	private static File toCanonicalFile(File file) {
		try {
			return file.getCanonicalFile();
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	/**
	 * Returns the source Docker Compose files.
	 * @return the source Docker Compose files
	 * @since 3.4.0
	 */
	public List<File> getFiles() {
		return this.files;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		DockerComposeFile other = (DockerComposeFile) obj;
		return this.files.equals(other.files);
	}
	@Override
	public int hashCode() {
		return this.files.hashCode();
	}
	@Override
	public String toString() {
		if (this.files.size() == 1) {
			return this.files.get(0).getPath();
		}
		return this.files.stream().map(File::toString).collect(Collectors.joining(', '));
	}
	/**
	 * Find the Docker Compose file by searching in the given working directory. Files are
	 * considered in the same order that {@code docker compose} uses, namely:
	 * <ul>
	 * <li>{@code compose.yaml}</li>
	 * <li>{@code compose.yml}</li>
	 * <li>{@code docker-compose.yaml}</li>
	 * <li>{@code docker-compose.yml}</li>
	 * </ul>
	 * @param workingDirectory the working directory to search or {@code null} to use the
	 * current directory
	 * @return the located file or {@code null} if no Docker Compose file can be found
	 */
	public static DockerComposeFile find(File workingDirectory) {
		File base = (workingDirectory != null) ? workingDirectory : new File('.');
		if (!base.exists()) {
			return null;
		}
		Assert.isTrue(base.isDirectory(), () -> '"%s" is not a directory'.formatted(base));
		Path basePath = base.toPath();
		for (String candidate : SEARCH_ORDER) {
			Path resolved = basePath.resolve(candidate);
			if (Files.exists(resolved)) {
				return of(resolved.toAbsolutePath().toFile());
			}
		}
		return null;
	}
	/**
	 * Create a new {@link DockerComposeFile} for the given {@link File}.
	 * @param file the source file
	 * @return the Docker Compose file
	 */
	public static DockerComposeFile of(File file) {
		Assert.notNull(file, 'File must not be null');
		Assert.isTrue(file.exists(), () -> 'Docker Compose file "%s" does not exist'.formatted(file));
		Assert.isTrue(file.isFile(), () -> 'Docker compose file "%s" is not a file'.formatted(file));
		return new DockerComposeFile(Collections.singletonList(file));
	}
	/**
	 * Creates a new {@link DockerComposeFile} for the given {@link File files}.
	 * @param files the source files
	 * @return the Docker Compose file
	 * @since 3.4.0
	 */
	public static DockerComposeFile of(Collection<? extends File> files) {
		Assert.notNull(files, 'Files must not be null');
		for (File file : files) {
			Assert.notNull(file, 'File must not be null');
			Assert.isTrue(file.exists(), () -> 'Docker Compose file "%s" does not exist'.formatted(file));
			Assert.isTrue(file.isFile(), () -> 'Docker compose file "%s" is not a file'.formatted(file));
		}
		return new DockerComposeFile(List.copyOf(files));
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DefaultConnectionPorts implements ConnectionPorts {
	private final Map<ContainerPort, Integer> mappings;
	private final Map<Integer, Integer> portMappings;
	DefaultConnectionPorts(DockerCliInspectResponse inspectResponse) {
		this.mappings = !isHostNetworkMode(inspectResponse)
				? buildMappingsForNetworkSettings(inspectResponse.networkSettings())
				: buildMappingsForHostNetworking(inspectResponse.config());
		Map<Integer, Integer> portMappings = new HashMap<>();
		this.mappings.forEach((containerPort, hostPort) -> portMappings.put(containerPort.number(), hostPort));
		this.portMappings = Collections.unmodifiableMap(portMappings);
	}
	private static boolean isHostNetworkMode(DockerCliInspectResponse inspectResponse) {
		HostConfig config = inspectResponse.hostConfig();
		return (config != null) && 'host'.equals(config.networkMode());
	}
	private Map<ContainerPort, Integer> buildMappingsForNetworkSettings(NetworkSettings networkSettings) {
		if (networkSettings == null || CollectionUtils.isEmpty(networkSettings.ports())) {
			return Collections.emptyMap();
		}
		Map<ContainerPort, Integer> mappings = new HashMap<>();
		networkSettings.ports().forEach((containerPortString, hostPorts) -> {
			if (!CollectionUtils.isEmpty(hostPorts)) {
				ContainerPort containerPort = ContainerPort.parse(containerPortString);
				hostPorts.stream()
					.filter(this::isIpV4)
					.forEach((hostPort) -> mappings.put(containerPort, getPortNumber(hostPort)));
			}
		});
		return Collections.unmodifiableMap(mappings);
	}
	private boolean isIpV4(HostPort hostPort) {
		String ip = (hostPort != null) ? hostPort.hostIp() : null;
		return !StringUtils.hasLength(ip) || ip.contains('.');
	}
	private static int getPortNumber(HostPort hostPort) {
		return Integer.parseInt(hostPort.hostPort());
	}
	private Map<ContainerPort, Integer> buildMappingsForHostNetworking(Config config) {
		if (CollectionUtils.isEmpty(config.exposedPorts())) {
			return Collections.emptyMap();
		}
		Map<ContainerPort, Integer> mappings = new HashMap<>();
		for (String entry : config.exposedPorts().keySet()) {
			ContainerPort containerPort = ContainerPort.parse(entry);
			mappings.put(containerPort, containerPort.number());
		}
		return Collections.unmodifiableMap(mappings);
	}
	@Override
	public int get(int containerPort) {
		Integer hostPort = this.portMappings.get(containerPort);
		Assert.state(hostPort != null, 'No host port mapping found for container port %s'.formatted(containerPort));
		return hostPort;
	}
	@Override
	public List<Integer> getAll() {
		return getAll(null);
	}
	@Override
	public List<Integer> getAll(String protocol) {
		List<Integer> hostPorts = new ArrayList<>();
		this.mappings.forEach((containerPort, hostPort) -> {
			if (protocol == null || protocol.equalsIgnoreCase(containerPort.protocol())) {
				hostPorts.add(hostPort);
			}
		});
		return Collections.unmodifiableList(hostPorts);
	}
	Map<ContainerPort, Integer> getMappings() {
		return this.mappings;
	}
	/**
	 * A container port consisting of a number and protocol.
	 *
	 * @param number the port number
	 * @param protocol the protocol (e.g. tcp)
	 */
	record ContainerPort(int number, String protocol) {
		@Override
		public String toString() {
			return '%d/%s'.formatted(this.number, this.protocol);
		}
		static ContainerPort parse(String value) {
			try {
				String[] parts = value.split('/');
				Assert.state(parts.length == 2, 'Unable to split string');
				return new ContainerPort(Integer.parseInt(parts[0]), parts[1]);
			}
			catch (RuntimeException ex) {
				throw new IllegalStateException('Unable to parse container port "%s"'.formatted(value), ex);
			}
		}
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class ProcessExitException extends RuntimeException {
	private final int exitCode;
	private final String[] command;
	private final String stdOut;
	private final String stdErr;
	ProcessExitException(int exitCode, String[] command, String stdOut, String stdErr) {
		this(exitCode, command, stdOut, stdErr, null);
	}
	ProcessExitException(int exitCode, String[] command, String stdOut, String stdErr, Throwable cause) {
		super(buildMessage(exitCode, command, stdOut, stdErr), cause);
		this.exitCode = exitCode;
		this.command = command;
		this.stdOut = stdOut;
		this.stdErr = stdErr;
	}
	private static String buildMessage(int exitCode, String[] command, String stdOut, String strErr) {
		return '"%s" failed with exit code %d.\n\nStdout:\n%s\n\nStderr:\n%s'.formatted(String.join(' ', command),
				exitCode, stdOut, strErr);
	}
	int getExitCode() {
		return this.exitCode;
	}
	String[] getCommand() {
		return this.command;
	}
	String getStdOut() {
		return this.stdOut;
	}
	String getStdErr() {
		return this.stdErr;
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class ImageName {
	private static final String DEFAULT_DOMAIN = 'docker.io';
	private static final String OFFICIAL_REPOSITORY_NAME = 'library';
	private static final String LEGACY_DOMAIN = 'index.docker.io';
	private final String domain;
	private final String name;
	private final String string;
	ImageName(String domain, String path) {
		Assert.hasText(path, 'Path must not be empty');
		this.domain = getDomainOrDefault(domain);
		this.name = getNameWithDefaultPath(this.domain, path);
		this.string = this.domain + '/' + this.name;
	}
	/**
	 * Return the domain for this image name.
	 * @return the domain
	 */
	String getDomain() {
		return this.domain;
	}
	/**
	 * Return the name of this image.
	 * @return the image name
	 */
	String getName() {
		return this.name;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ImageName other = (ImageName) obj;
		boolean result = true;
		result = result && this.domain.equals(other.domain);
		result = result && this.name.equals(other.name);
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.domain.hashCode();
		result = prime * result + this.name.hashCode();
		return result;
	}
	@Override
	public String toString() {
		return this.string;
	}
	private String getDomainOrDefault(String domain) {
		if (domain == null || LEGACY_DOMAIN.equals(domain)) {
			return DEFAULT_DOMAIN;
		}
		return domain;
	}
	private String getNameWithDefaultPath(String domain, String name) {
		if (DEFAULT_DOMAIN.equals(domain) && !name.contains('/')) {
			return OFFICIAL_REPOSITORY_NAME + '/' + name;
		}
		return name;
	}
	static String parseDomain(String value) {
		int firstSlash = value.indexOf("/");
		String candidate = (firstSlash != -1) ? value.substring(0, firstSlash) : null;
		if (candidate != null && Regex.DOMAIN.matcher(candidate).matches()) {
			return candidate;
		}
		return null;
	}
	static ImageName of(String value) {
		Assert.hasText(value, 'Value must not be empty');
		String domain = parseDomain(value);
		String path = (domain != null) ? value.substring(domain.length() + 1) : value;
		Assert.isTrue(Regex.PATH.matcher(path).matches(),
				() -> 'Unable to parse name \'' + value + '\'. '
						+ 'Image name must be in the form "[domainHost:port/][path/]name", '
						+ 'with "path" and "name" containing only [a-z0-9][.][_][-]');
		return new ImageName(domain, path);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
record DockerCliComposePsResponse(String id, String name, String image, String state) {
}
/*
package org.springframework.boot.docker.compose.core;
/**
public final class ImageReference {
	private final ImageName name;
	private final String tag;
	private final String digest;
	private final String string;
	private ImageReference(ImageName name, String tag, String digest) {
		Assert.notNull(name, 'Name must not be null');
		this.name = name;
		this.tag = tag;
		this.digest = digest;
		this.string = buildString(name.toString(), tag, digest);
	}
	/**
	 * Return the domain for this image name.
	 * @return the domain
	 * @see ImageName#getDomain()
	 */
	public String getDomain() {
		return this.name.getDomain();
	}
	/**
	 * Return the name of this image.
	 * @return the image name
	 * @see ImageName#getName()
	 */
	public String getName() {
		return this.name.getName();
	}
	/**
	 * Return the tag from the reference or {@code null}.
	 * @return the referenced tag
	 */
	public String getTag() {
		return this.tag;
	}
	/**
	 * Return the digest from the reference or {@code null}.
	 * @return the referenced digest
	 */
	public String getDigest() {
		return this.digest;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		ImageReference other = (ImageReference) obj;
		boolean result = true;
		result = result && this.name.equals(other.name);
		result = result && ObjectUtils.nullSafeEquals(this.tag, other.tag);
		result = result && ObjectUtils.nullSafeEquals(this.digest, other.digest);
		return result;
	}
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + this.name.hashCode();
		result = prime * result + ObjectUtils.nullSafeHashCode(this.tag);
		result = prime * result + ObjectUtils.nullSafeHashCode(this.digest);
		return result;
	}
	@Override
	public String toString() {
		return this.string;
	}
	private String buildString(String name, String tag, String digest) {
		StringBuilder string = new StringBuilder(name);
		if (tag != null) {
			string.append(':').append(tag);
		}
		if (digest != null) {
			string.append('@').append(digest);
		}
		return string.toString();
	}
	/**
	 * Create a new {@link ImageReference} from the given value. The following value forms
	 * can be used:
	 * <ul>
	 * <li>{@code name} (maps to {@code docker.io/library/name})</li>
	 * <li>{@code domain/name}</li>
	 * <li>{@code domain:port/name}</li>
	 * <li>{@code domain:port/name:tag}</li>
	 * <li>{@code domain:port/name@digest}</li>
	 * </ul>
	 * @param value the value to parse
	 * @return an {@link ImageReference} instance
	 */
	public static ImageReference of(String value) {
		Assert.hasText(value, 'Value must not be null');
		String domain = ImageName.parseDomain(value);
		String path = (domain != null) ? value.substring(domain.length() + 1) : value;
		String digest = null;
		int digestSplit = path.indexOf('@');
		if (digestSplit != -1) {
			String remainder = path.substring(digestSplit + 1);
			Matcher matcher = Regex.DIGEST.matcher(remainder);
			if (matcher.find()) {
				digest = remainder.substring(0, matcher.end());
				remainder = remainder.substring(matcher.end());
				path = path.substring(0, digestSplit) + remainder;
			}
		}
		String tag = null;
		int tagSplit = path.lastIndexOf(':');
		if (tagSplit != -1) {
			String remainder = path.substring(tagSplit + 1);
			Matcher matcher = Regex.TAG.matcher(remainder);
			if (matcher.find()) {
				tag = remainder.substring(0, matcher.end());
				remainder = remainder.substring(matcher.end());
				path = path.substring(0, tagSplit) + remainder;
			}
		}
		Assert.isTrue(Regex.PATH.matcher(path).matches(),
				() -> 'Unable to parse image reference \'' + value + '\'. '
						+ 'Image reference must be in the form "[domainHost:port/][path/]name[:tag][@digest]", '
						+ 'with "path" and "name" containing only [a-z0-9][.][_][-]');
		ImageName name = new ImageName(domain, path);
		return new ImageReference(name, tag, digest);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
final class Regex implements CharSequence {
	static final Pattern DOMAIN;
	static {
		Regex component = Regex.oneOf('[a-zA-Z0-9]', '[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]');
		Regex dotComponent = Regex.group('[.]', component);
		Regex colonPort = Regex.of('[:][0-9]+');
		Regex dottedDomain = Regex.group(component, dotComponent.oneOrMoreTimes());
		Regex dottedDomainAndPort = Regex.group(component, dotComponent.oneOrMoreTimes(), colonPort);
		Regex nameAndPort = Regex.group(component, colonPort);
		DOMAIN = Regex.oneOf(dottedDomain, nameAndPort, dottedDomainAndPort, 'localhost').compile();
	}
	private static final Regex PATH_COMPONENT;
	static {
		Regex segment = Regex.of('[a-z0-9]+');
		Regex separator = Regex.group('[._-]{1,2}');
		Regex separatedSegment = Regex.group(separator, segment).oneOrMoreTimes();
		PATH_COMPONENT = Regex.of(segment, Regex.group(separatedSegment).zeroOrOnce());
	}
	static final Pattern PATH;
	static {
		Regex component = PATH_COMPONENT;
		Regex slashComponent = Regex.group('[/]', component);
		Regex slashComponents = Regex.group(slashComponent.oneOrMoreTimes());
		PATH = Regex.of(component, slashComponents.zeroOrOnce()).compile();
	}
	static final Pattern TAG = Regex.of('^[\\w][\\w.-]{0,127}').compile();
	static final Pattern DIGEST = Regex.of('^[A-Za-z][A-Za-z0-9]*(?:[-_+.][A-Za-z][A-Za-z0-9]*)*[:][[A-Fa-f0-9]]{32,}')
		.compile();
	private final String value;
	private Regex(CharSequence value) {
		this.value = value.toString();
	}
	private Regex oneOrMoreTimes() {
		return new Regex(this.value + '+');
	}
	private Regex zeroOrOnce() {
		return new Regex(this.value + '?');
	}
	Pattern compile() {
		return Pattern.compile('^' + this.value + '$');
	}
	@Override
	public int length() {
		return this.value.length();
	}
	@Override
	public char charAt(int index) {
		return this.value.charAt(index);
	}
	@Override
	public CharSequence subSequence(int start, int end) {
		return this.value.subSequence(start, end);
	}
	@Override
	public String toString() {
		return this.value;
	}
	private static Regex of(CharSequence... expressions) {
		return new Regex(String.join('', expressions));
	}
	private static Regex oneOf(CharSequence... expressions) {
		return new Regex('(?:' + String.join('|', expressions) + ')');
	}
	private static Regex group(CharSequence... expressions) {
		return new Regex('(?:' + String.join('', expressions) + ')');
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
final class DockerHost {
	private static final String LOCALHOST = '127.0.0.1';
	private final String host;
	private DockerHost(String host) {
		this.host = host;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		DockerHost other = (DockerHost) obj;
		return this.host.equals(other.host);
	}
	@Override
	public int hashCode() {
		return this.host.hashCode();
	}
	@Override
	public String toString() {
		return this.host;
	}
	/**
	 * Get or deduce a new {@link DockerHost} instance.
	 * @param host the host to use or {@code null} to deduce
	 * @param contextsSupplier a supplier to provide a list of
	 * {@link DockerCliContextResponse}
	 * @return a new docker host instance
	 */
	static DockerHost get(String host, Supplier<List<DockerCliContextResponse>> contextsSupplier) {
		return get(host, System::getenv, contextsSupplier);
	}
	/**
	 * Get or deduce a new {@link DockerHost} instance.
	 * @param host the host to use or {@code null} to deduce
	 * @param systemEnv access to the system environment
	 * @param contextsSupplier a supplier to provide a list of
	 * {@link DockerCliContextResponse}
	 * @return a new docker host instance
	 */
	static DockerHost get(String host, Function<String, String> systemEnv,
			Supplier<List<DockerCliContextResponse>> contextsSupplier) {
		host = (StringUtils.hasText(host)) ? host : fromServicesHostEnv(systemEnv);
		host = (StringUtils.hasText(host)) ? host : fromDockerHostEnv(systemEnv);
		host = (StringUtils.hasText(host)) ? host : fromCurrentContext(contextsSupplier);
		host = (StringUtils.hasText(host)) ? host : LOCALHOST;
		return new DockerHost(host);
	}
	private static String fromServicesHostEnv(Function<String, String> systemEnv) {
		return systemEnv.apply('SERVICES_HOST');
	}
	private static String fromDockerHostEnv(Function<String, String> systemEnv) {
		return fromEndpoint(systemEnv.apply('DOCKER_HOST'));
	}
	private static String fromCurrentContext(Supplier<List<DockerCliContextResponse>> contextsSupplier) {
		DockerCliContextResponse current = getCurrentContext(contextsSupplier.get());
		return (current != null) ? fromEndpoint(current.dockerEndpoint()) : null;
	}
	private static DockerCliContextResponse getCurrentContext(List<DockerCliContextResponse> candidates) {
		return candidates.stream().filter(DockerCliContextResponse::current).findFirst().orElse(null);
	}
	private static String fromEndpoint(String endpoint) {
		return (StringUtils.hasLength(endpoint)) ? fromUri(URI.create(endpoint)) : null;
	}
	private static String fromUri(URI uri) {
		try {
			return switch (uri.getScheme()) {
				case 'http', 'https', 'tcp' -> uri.getHost();
				default -> null;
			};
		}
		catch (Exception ex) {
			return null;
		}
	}
}
/*
/**
package org.springframework.boot.docker.compose.core;
/*
package org.springframework.boot.docker.compose.core;
/**
public abstract class DockerException extends RuntimeException {
	public DockerException(String message) {
		super(message);
	}
	public DockerException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class DefaultDockerCompose implements DockerCompose {
	private final DockerCli cli;
	private final DockerHost hostname;
	DefaultDockerCompose(DockerCli cli, String host) {
		this.cli = cli;
		this.hostname = DockerHost.get(host, () -> cli.run(new DockerCliCommand.Context()));
	}
	@Override
	public void up(LogLevel logLevel) {
		up(logLevel, Collections.emptyList());
	}
	@Override
	public void up(LogLevel logLevel, List<String> arguments) {
		this.cli.run(new DockerCliCommand.ComposeUp(logLevel, arguments));
	}
	@Override
	public void down(Duration timeout) {
		down(timeout, Collections.emptyList());
	}
	@Override
	public void down(Duration timeout, List<String> arguments) {
		this.cli.run(new DockerCliCommand.ComposeDown(timeout, arguments));
	}
	@Override
	public void start(LogLevel logLevel) {
		start(logLevel, Collections.emptyList());
	}
	@Override
	public void start(LogLevel logLevel, List<String> arguments) {
		this.cli.run(new DockerCliCommand.ComposeStart(logLevel, arguments));
	}
	@Override
	public void stop(Duration timeout) {
		stop(timeout, Collections.emptyList());
	}
	@Override
	public void stop(Duration timeout, List<String> arguments) {
		this.cli.run(new DockerCliCommand.ComposeStop(timeout, arguments));
	}
	@Override
	public boolean hasDefinedServices() {
		return !this.cli.run(new DockerCliCommand.ComposeConfig()).services().isEmpty();
	}
	@Override
	public List<RunningService> getRunningServices() {
		List<DockerCliComposePsResponse> runningPsResponses = runComposePs().stream().filter(this::isRunning).toList();
		if (runningPsResponses.isEmpty()) {
			return Collections.emptyList();
		}
		DockerComposeFile dockerComposeFile = this.cli.getDockerComposeFile();
		List<RunningService> result = new ArrayList<>();
		Map<String, DockerCliInspectResponse> inspected = inspect(runningPsResponses);
		for (DockerCliComposePsResponse psResponse : runningPsResponses) {
			DockerCliInspectResponse inspectResponse = inspectContainer(psResponse.id(), inspected);
			Assert.notNull(inspectResponse, () -> 'Failed to inspect container "%s"'.formatted(psResponse.id()));
			result.add(new DefaultRunningService(this.hostname, dockerComposeFile, psResponse, inspectResponse));
		}
		return Collections.unmodifiableList(result);
	}
	private Map<String, DockerCliInspectResponse> inspect(List<DockerCliComposePsResponse> runningPsResponses) {
		List<String> ids = runningPsResponses.stream().map(DockerCliComposePsResponse::id).toList();
		List<DockerCliInspectResponse> inspectResponses = this.cli.run(new DockerCliCommand.Inspect(ids));
		return inspectResponses.stream().collect(Collectors.toMap(DockerCliInspectResponse::id, Function.identity()));
	}
	private DockerCliInspectResponse inspectContainer(String id, Map<String, DockerCliInspectResponse> inspected) {
		DockerCliInspectResponse inspect = inspected.get(id);
		if (inspect != null) {
			return inspect;
		}
		// Docker Compose v2.23.0 returns truncated ids, so we have to do a prefix match
		for (Entry<String, DockerCliInspectResponse> entry : inspected.entrySet()) {
			if (entry.getKey().startsWith(id)) {
				return entry.getValue();
			}
		}
		return null;
	}
	private List<DockerCliComposePsResponse> runComposePs() {
		return this.cli.run(new DockerCliCommand.ComposePs());
	}
	private boolean isRunning(DockerCliComposePsResponse psResponse) {
		return !'exited'.equals(psResponse.state());
	}
}
/*
package org.springframework.boot.docker.compose.core;
/**
class ProcessRunner {
	private static final String USR_LOCAL_BIN = '/usr/local/bin';
	private static final boolean MAC_OS = System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('mac');
	private static final Log logger = LogFactory.getLog(ProcessRunner.class);
	private final File workingDirectory;
	/**
	 * Create a new {@link ProcessRunner} instance.
	 */
	ProcessRunner() {
		this(null);
	}
	/**
	 * Create a new {@link ProcessRunner} instance.
	 * @param workingDirectory the working directory for the process
	 */
	ProcessRunner(File workingDirectory) {
		this.workingDirectory = workingDirectory;
	}
	/**
	 * Runs the given {@code command}. If the process exits with an error code other than
	 * zero, an {@link ProcessExitException} will be thrown.
	 * @param command the command to run
	 * @return the output of the command
	 * @throws ProcessExitException if execution failed
	 */
	String run(String... command) {
		return run(null, command);
	}
	/**
	 * Runs the given {@code command}. If the process exits with an error code other than
	 * zero, an {@link ProcessExitException} will be thrown.
	 * @param outputConsumer consumer used to accept output one line at a time
	 * @param command the command to run
	 * @return the output of the command
	 * @throws ProcessExitException if execution failed
	 */
	String run(Consumer<String> outputConsumer, String... command) {
		logger.trace(LogMessage.of(() -> 'Running "%s"'.formatted(String.join(' ', command))));
		Process process = startProcess(command);
		ReaderThread stdOutReader = new ReaderThread(process.getInputStream(), 'stdout', outputConsumer);
		ReaderThread stdErrReader = new ReaderThread(process.getErrorStream(), 'stderr', outputConsumer);
		logger.trace('Waiting for process exit');
		int exitCode = waitForProcess(process);
		logger.trace(LogMessage.format('Process exited with exit code %d', exitCode));
		String stdOut = stdOutReader.toString();
		String stdErr = stdErrReader.toString();
		if (exitCode != 0) {
			throw new ProcessExitException(exitCode, command, stdOut, stdErr);
		}
		return stdOut;
	}
	private Process startProcess(String[] command) {
		ProcessBuilder processBuilder = new ProcessBuilder(command);
		processBuilder.directory(this.workingDirectory);
		try {
			return processBuilder.start();
		}
		catch (IOException ex) {
			String path = processBuilder.environment().get('PATH');
			if (MAC_OS && path != null && !path.contains(USR_LOCAL_BIN)
					&& !command[0].startsWith(USR_LOCAL_BIN + '/')) {
				String[] localCommand = command.clone();
				localCommand[0] = USR_LOCAL_BIN + '/' + localCommand[0];
				return startProcess(localCommand);
			}
			throw new ProcessStartException(command, ex);
		}
	}
	private int waitForProcess(Process process) {
		try {
			return process.waitFor();
		}
		catch (InterruptedException ex) {
			throw new IllegalStateException('Interrupted waiting for %s'.formatted(process));
		}
	}
	/**
	 * Thread used to read stream input from the process.
	 */
	private static class ReaderThread extends Thread {
		private final InputStream source;
		private final Consumer<String> outputConsumer;
		private final StringBuilder output = new StringBuilder();
		private final CountDownLatch latch = new CountDownLatch(1);
		ReaderThread(InputStream source, String name, Consumer<String> outputConsumer) {
			this.source = source;
			this.outputConsumer = outputConsumer;
			setName('OutputReader-' + name);
			setDaemon(true);
			start();
		}
		@Override
		public void run() {
			try (BufferedReader reader = new BufferedReader(
					new InputStreamReader(this.source, StandardCharsets.UTF_8))) {
				String line = reader.readLine();
				while (line != null) {
					this.output.append(line);
					this.output.append('\n');
					if (this.outputConsumer != null) {
						this.outputConsumer.accept(line);
					}
					line = reader.readLine();
				}
				this.latch.countDown();
			}
			catch (IOException ex) {
				throw new UncheckedIOException('Failed to read process stream', ex);
			}
		}
		@Override
		public String toString() {
			try {
				this.latch.await();
				return this.output.toString();
			}
			catch (InterruptedException ex) {
				return null;
			}
		}
	}
}
/*
package org.springframework.boot.testcontainers.properties;
/**
@SpringBootTest(classes = TestConfig.class,
		properties = 'spring.testcontainers.dynamic-property-registry-injection=allow')
class TestcontainersPropertySourceAutoConfigurationWithSpringBootTestIntegrationTest {
	@Autowired
	private Environment environment;
	@Test
	void injectsRegistryIntoBeanMethod() {
		assertThat(this.environment.getProperty('from.bean.method')).isEqualTo('one');
	}
	@Test
	void callsRegistrars() {
		assertThat(this.environment.getProperty('from.registrar')).isEqualTo('two');
	}
	@TestConfiguration
	@ImportAutoConfiguration(TestcontainersPropertySourceAutoConfiguration.class)
	@SpringBootConfiguration
	static class TestConfig {
		@Bean
		String example(DynamicPropertyRegistry registry) {
			registry.add('from.bean.method', () -> 'one');
			return 'Hello';
		}
		@Bean
		DynamicPropertyRegistrar propertyRegistrar() {
			return (registry) -> registry.add('from.registrar', () -> 'two');
		}
	}
}
/*
package org.springframework.boot.testcontainers.properties;
/**
@DisabledIfDockerUnavailable
@ExtendWith(OutputCaptureExtension.class)
class TestcontainersPropertySourceAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withInitializer(new TestcontainersLifecycleApplicationContextInitializer())
		.withConfiguration(AutoConfigurations.of(TestcontainersPropertySourceAutoConfiguration.class));
	@Test
	@SuppressWarnings('removal')
	@Deprecated(since = '3.4.0', forRemoval = true)
	void registeringADynamicPropertyFailsByDefault() {
		this.contextRunner.withUserConfiguration(ContainerAndPropertiesConfiguration.class)
			.run((context) -> assertThat(context).getFailure()
				.rootCause()
				.isInstanceOf(
						org.springframework.boot.testcontainers.properties.TestcontainersPropertySource.DynamicPropertyRegistryInjectionException.class)
				.hasMessageStartingWith(
						'Support for injecting a DynamicPropertyRegistry into @Bean methods is deprecated'));
	}
	@Test
	@SuppressWarnings('removal')
	@Deprecated(since = '3.4.0', forRemoval = true)
	void registeringADynamicPropertyCanLogAWarningAndContributeProperty(CapturedOutput output) {
		List<ApplicationEvent> events = new ArrayList<>();
		this.contextRunner.withPropertyValues('spring.testcontainers.dynamic-property-registry-injection=warn')
			.withUserConfiguration(ContainerAndPropertiesConfiguration.class)
			.withInitializer((context) -> context.addApplicationListener(events::add))
			.run((context) -> {
				TestBean testBean = context.getBean(TestBean.class);
				RedisContainer redisContainer = context.getBean(RedisContainer.class);
				assertThat(testBean.getUsingPort()).isEqualTo(redisContainer.getFirstMappedPort());
				assertThat(events.stream()
					.filter(org.springframework.boot.testcontainers.lifecycle.BeforeTestcontainerUsedEvent.class::isInstance))
					.hasSize(1);
				assertThat(output)
					.contains('Support for injecting a DynamicPropertyRegistry into @Bean methods is deprecated');
			});
	}
	@Test
	@SuppressWarnings('removal')
	@Deprecated(since = '3.4.0', forRemoval = true)
	void registeringADynamicPropertyCanBePermittedAndContributeProperty(CapturedOutput output) {
		List<ApplicationEvent> events = new ArrayList<>();
		this.contextRunner.withPropertyValues('spring.testcontainers.dynamic-property-registry-injection=allow')
			.withUserConfiguration(ContainerAndPropertiesConfiguration.class)
			.withInitializer((context) -> context.addApplicationListener(events::add))
			.run((context) -> {
				TestBean testBean = context.getBean(TestBean.class);
				RedisContainer redisContainer = context.getBean(RedisContainer.class);
				assertThat(testBean.getUsingPort()).isEqualTo(redisContainer.getFirstMappedPort());
				assertThat(events.stream()
					.filter(org.springframework.boot.testcontainers.lifecycle.BeforeTestcontainerUsedEvent.class::isInstance))
					.hasSize(1);
				assertThat(output)
					.doesNotContain('Support for injecting a DynamicPropertyRegistry into @Bean methods is deprecated');
			});
	}
	@Test
	void dynamicPropertyRegistrarBeanContributesProperties(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(ContainerAndPropertyRegistrarConfiguration.class).run((context) -> {
			TestBean testBean = context.getBean(TestBean.class);
			RedisContainer redisContainer = context.getBean(RedisContainer.class);
			assertThat(testBean.getUsingPort()).isEqualTo(redisContainer.getFirstMappedPort());
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ContainerProperties.class)
	@Import(TestBean.class)
	static class ContainerAndPropertiesConfiguration {
		@Bean
		RedisContainer redisContainer(DynamicPropertyRegistry properties) {
			RedisContainer container = TestImage.container(RedisContainer.class);
			properties.add('container.port', container::getFirstMappedPort);
			return container;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ContainerProperties.class)
	@Import(TestBean.class)
	static class ContainerAndPropertyRegistrarConfiguration {
		@Bean
		RedisContainer redisContainer() {
			return TestImage.container(RedisContainer.class);
		}
		@Bean
		DynamicPropertyRegistrar redisProperties(RedisContainer container) {
			return (registry) -> registry.add('container.port', container::getFirstMappedPort);
		}
	}
	@ConfigurationProperties('container')
	record ContainerProperties(int port) {
	}
	static class TestBean {
		private int usingPort;
		TestBean(ContainerProperties containerProperties) {
			this.usingPort = containerProperties.port();
		}
		int getUsingPort() {
			return this.usingPort;
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.jdbc;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class JdbcContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final PostgreSQLContainer<?> postgres = TestImage.container(PostgreSQLContainer.class);
	@Autowired(required = false)
	private JdbcConnectionDetails connectionDetails;
	@Autowired
	private DataSource dataSource;
	@Test
	void connectionCanBeMadeToJdbcContainer() {
		assertThat(this.connectionDetails).isNotNull();
		JdbcTemplate jdbc = new JdbcTemplate(this.dataSource);
		assertThatNoException().isThrownBy(() -> jdbc.execute(DatabaseDriver.POSTGRESQL.getValidationQuery()));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.cassandra;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class CassandraContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final CassandraContainer cassandra = TestImage.container(CassandraContainer.class);
	@Autowired(required = false)
	private CassandraConnectionDetails connectionDetails;
	@Autowired
	private CqlSession cqlSession;
	@Test
	void connectionCanBeMadeToCassandraContainer() {
		assertThat(this.connectionDetails).isNotNull();
		assertThat(this.cqlSession.getMetadata().getNodes()).hasSize(1);
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(CassandraAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.cassandra;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@Deprecated(since = '3.4.0', forRemoval = true)
class DeprecatedCassandraContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final CassandraContainer<?> cassandra = TestImage.container(CassandraContainer.class);
	@Autowired(required = false)
	private CassandraConnectionDetails connectionDetails;
	@Autowired
	private CqlSession cqlSession;
	@Test
	void connectionCanBeMadeToCassandraContainer() {
		assertThat(this.connectionDetails).isNotNull();
		assertThat(this.cqlSession.getMetadata().getNodes()).hasSize(1);
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(CassandraAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.zipkin;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class ZipkinContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final GenericContainer<?> zipkin = TestImage.container(ZipkinContainer.class);
	@Autowired(required = false)
	private ZipkinConnectionDetails connectionDetails;
	@Test
	void connectionCanBeMadeToZipkinContainer() {
		assertThat(this.connectionDetails).isNotNull();
		assertThat(this.connectionDetails.getSpanEndpoint())
			.startsWith('http://' + zipkin.getHost() + ':' + zipkin.getMappedPort(9411));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(ZipkinAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.couchbase;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class CouchbaseContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final CouchbaseContainer couchbase = TestImage.container(CouchbaseContainer.class)
		.withEnabledServices(CouchbaseService.KV, CouchbaseService.INDEX, CouchbaseService.QUERY)
		.withBucket(new BucketDefinition('cbbucket'));
	@Autowired(required = false)
	private CouchbaseConnectionDetails connectionDetails;
	@Autowired
	private Cluster cluster;
	@Test
	void connectionCanBeMadeToCouchbaseContainer() {
		assertThat(this.connectionDetails).isNotNull();
		assertThat(this.cluster.diagnostics().endpoints()).hasSize(1);
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(CouchbaseAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.pulsar;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@TestPropertySource(properties = { 'spring.pulsar.consumer.subscription.initial-position=earliest' })
class PulsarContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	@SuppressWarnings('unused')
	static final PulsarContainer pulsar = TestImage.container(PulsarContainer.class);
	@Autowired
	private PulsarTemplate<String> pulsarTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToPulsarContainer() {
		this.pulsarTemplate.send('test-topic', 'test-data');
		Awaitility.waitAtMost(Duration.ofSeconds(30))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('test-data'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(PulsarAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@PulsarListener(topics = 'test-topic')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.hazelcast;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class CustomClusterNameHazelcastContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final HazelcastContainer hazelcast = TestImage.container(HazelcastContainer.class)
		.withClusterName('spring-boot');
	@Autowired(required = false)
	private HazelcastConnectionDetails connectionDetails;
	@Autowired
	private HazelcastInstance hazelcastInstance;
	@Test
	void connectionCanBeMadeToHazelcastContainer() {
		assertThat(this.connectionDetails).isNotNull();
		assertThat(this.hazelcastInstance).satisfies(clusterName('spring-boot'));
		IMap<String, String> map = this.hazelcastInstance.getMap(UUID.randomUUID().toString());
		map.put('test', 'containers');
		assertThat(map.get('test')).isEqualTo('containers');
	}
	private static Consumer<HazelcastInstance> clusterName(String name) {
		return (hazelcastInstance) -> {
			assertThat(hazelcastInstance).isInstanceOf(HazelcastClientProxy.class);
			HazelcastClientProxy proxy = (HazelcastClientProxy) hazelcastInstance;
			assertThat(proxy.getClientConfig()).extracting(ClientConfig::getClusterName).isEqualTo(name);
		};
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(HazelcastAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.hazelcast;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class HazelcastContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final HazelcastContainer hazelcast = TestImage.container(HazelcastContainer.class);
	@Autowired(required = false)
	private HazelcastConnectionDetails connectionDetails;
	@Autowired
	private HazelcastInstance hazelcastInstance;
	@Test
	void connectionCanBeMadeToHazelcastContainer() {
		assertThat(this.connectionDetails).isNotNull();
		IMap<String, String> map = this.hazelcastInstance.getMap(UUID.randomUUID().toString());
		map.put('test', 'containers');
		assertThat(map.get('test')).isEqualTo('containers');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(HazelcastAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
@SpringJUnitConfig
@TestPropertySource(properties = { 'management.otlp.metrics.export.resource-attributes.service.name=test',
		'management.otlp.metrics.export.step=1s' })
@Testcontainers(disabledWithoutDocker = true)
class OpenTelemetryMetricsContainerConnectionDetailsFactoryIntegrationTests {
	private static final String OPENMETRICS_001 = 'application/openmetrics-text; version=0.0.1; charset=utf-8';
	private static final String CONFIG_FILE_NAME = 'collector-config.yml';
	@Container
	@ServiceConnection
	static final GenericContainer<?> container = TestImage.OPENTELEMETRY.genericContainer()
		.withCommand('--config=/etc/' + CONFIG_FILE_NAME)
		.withCopyToContainer(MountableFile.forClasspathResource(CONFIG_FILE_NAME), '/etc/' + CONFIG_FILE_NAME)
		.withExposedPorts(4318, 9090);
	@Autowired
	private MeterRegistry meterRegistry;
	@Test
	void connectionCanBeMadeToOpenTelemetryCollectorContainer() {
		Counter.builder('test.counter').register(this.meterRegistry).increment(42);
		Gauge.builder('test.gauge', () -> 12).register(this.meterRegistry);
		Timer.builder('test.timer').register(this.meterRegistry).record(Duration.ofMillis(123));
		DistributionSummary.builder('test.distributionsummary').register(this.meterRegistry).record(24);
		Awaitility.await()
			.atMost(Duration.ofSeconds(30))
			.untilAsserted(() -> whenPrometheusScraped().then()
				.statusCode(200)
				.contentType(OPENMETRICS_001)
				.body(endsWith('# EOF\n'), containsString(
						'{job=\'test\',service_name=\'test\',telemetry_sdk_language=\'java\',telemetry_sdk_name=\'io.micrometer\''),
						matchesPattern('(?s)^.*test_counter\\{.+} 42\\.0\\n.*$'),
						matchesPattern('(?s)^.*test_gauge\\{.+} 12\\.0\\n.*$'),
						matchesPattern('(?s)^.*test_timer_count\\{.+} 1\\n.*$'),
						matchesPattern('(?s)^.*test_timer_sum\\{.+} 123\\.0\\n.*$'),
						matchesPattern('(?s)^.*test_timer_bucket\\{.+,le=\'\\+Inf\'} 1\\n.*$'),
						matchesPattern('(?s)^.*test_distributionsummary_count\\{.+} 1\\n.*$'),
						matchesPattern('(?s)^.*test_distributionsummary_sum\\{.+} 24\\.0\\n.*$'),
						matchesPattern('(?s)^.*test_distributionsummary_bucket\\{.+,le=\'\\+Inf\'} 1\\n.*$')));
	}
	private Response whenPrometheusScraped() {
		return RestAssured.given().port(container.getMappedPort(9090)).accept(OPENMETRICS_001).when().get('/metrics');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(OtlpMetricsExportAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		Clock customClock() {
			return Clock.SYSTEM;
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class OpenTelemetryTracingContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final GenericContainer<?> container = TestImage.OPENTELEMETRY.genericContainer()
		.withExposedPorts(4317, 4318);
	@Autowired
	private OtlpTracingConnectionDetails connectionDetails;
	@Test
	void connectionCanBeMadeToOpenTelemetryContainer() {
		assertThat(this.connectionDetails.getUrl(Transport.HTTP))
			.isEqualTo('http://' + container.getHost() + ':' + container.getMappedPort(4318) + '/v1/traces');
		assertThat(this.connectionDetails.getUrl(Transport.GRPC))
			.isEqualTo('http://' + container.getHost() + ':' + container.getMappedPort(4317) + '/v1/traces');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(OtlpTracingAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class GrafanaOpenTelemetryTracingContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final LgtmStackContainer container = TestImage.container(LgtmStackContainer.class);
	@Autowired
	private OtlpTracingConnectionDetails connectionDetails;
	@Test
	void connectionCanBeMadeToOpenTelemetryContainer() {
		assertThat(this.connectionDetails.getUrl(Transport.HTTP))
			.isEqualTo('%s/v1/traces'.formatted(container.getOtlpHttpUrl()));
		assertThat(this.connectionDetails.getUrl(Transport.GRPC))
			.isEqualTo('%s/v1/traces'.formatted(container.getOtlpGrpcUrl()));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(OtlpTracingAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
@SpringJUnitConfig
@TestPropertySource(properties = { 'management.otlp.metrics.export.resource-attributes.service.name=test',
		'management.otlp.metrics.export.step=1s' })
@Testcontainers(disabledWithoutDocker = true)
class GrafanaOpenTelemetryMetricsContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final LgtmStackContainer container = TestImage.container(LgtmStackContainer.class);
	@Autowired
	private MeterRegistry meterRegistry;
	@Test
	void connectionCanBeMadeToOpenTelemetryCollectorContainer() {
		Counter.builder('test.counter').register(this.meterRegistry).increment(42);
		Gauge.builder('test.gauge', () -> 12).register(this.meterRegistry);
		Timer.builder('test.timer').register(this.meterRegistry).record(Duration.ofMillis(123));
		DistributionSummary.builder('test.distributionsummary').register(this.meterRegistry).record(24);
		Awaitility.given()
			.pollInterval(Duration.ofSeconds(2))
			.atMost(Duration.ofSeconds(10))
			.ignoreExceptions()
			.untilAsserted(() -> {
				Response response = RestAssured.given()
					.queryParam('query', '{job=\'test\'}')
					.get('%s/api/v1/query'.formatted(container.getPromehteusHttpUrl()))
					.prettyPeek()
					.thenReturn();
				assertThat(response.getStatusCode()).isEqualTo(200);
				assertThat(response.body()
					.jsonPath()
					.getList('data.result.find { it.metric.__name__ == "test_counter_total" }.value')).contains('42');
				assertThat(response.body()
					.jsonPath()
					.getList('data.result.find { it.metric.__name__ == "test_gauge" }.value')).contains('12');
				assertThat(response.body()
					.jsonPath()
					.getList('data.result.find { it.metric.__name__ == "test_timer_milliseconds_count" }.value'))
					.contains('1');
				assertThat(response.body()
					.jsonPath()
					.getList('data.result.find { it.metric.__name__ == "test_timer_milliseconds_sum" }.value'))
					.contains('123');
				assertThat(response.body()
					.jsonPath()
					.getList(
							'data.result.find { it.metric.__name__ == "test_timer_milliseconds_bucket" & it.metric.le == "+Inf" }.value'))
					.contains('1');
				assertThat(response.body()
					.jsonPath()
					.getList('data.result.find { it.metric.__name__ == "test_distributionsummary_count" }.value'))
					.contains('1');
				assertThat(response.body()
					.jsonPath()
					.getList('data.result.find { it.metric.__name__ == "test_distributionsummary_sum" }.value'))
					.contains('24');
				assertThat(response.body()
					.jsonPath()
					.getList(
							'data.result.find { it.metric.__name__ == "test_distributionsummary_bucket" & it.metric.le == "+Inf" }.value'))
					.contains('1');
			});
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(OtlpMetricsExportAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		Clock customClock() {
			return Clock.SYSTEM;
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class GrafanaOpenTelemetryLoggingContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final LgtmStackContainer container = TestImage.container(LgtmStackContainer.class);
	@Autowired
	private OtlpLoggingConnectionDetails connectionDetails;
	@Test
	void connectionCanBeMadeToOpenTelemetryContainer() {
		assertThat(this.connectionDetails.getUrl(Transport.GRPC))
			.isEqualTo('%s/v1/logs'.formatted(container.getOtlpGrpcUrl()));
		assertThat(this.connectionDetails.getUrl(Transport.HTTP))
			.isEqualTo('%s/v1/logs'.formatted(container.getOtlpHttpUrl()));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(OtlpLoggingAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class OpenTelemetryLoggingContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final GenericContainer<?> container = TestImage.OPENTELEMETRY.genericContainer()
		.withExposedPorts(4317, 4318);
	@Autowired
	private OtlpLoggingConnectionDetails connectionDetails;
	@Test
	void connectionCanBeMadeToOpenTelemetryContainer() {
		assertThat(this.connectionDetails.getUrl(Transport.HTTP))
			.isEqualTo('http://' + container.getHost() + ':' + container.getMappedPort(4318) + '/v1/logs');
		assertThat(this.connectionDetails.getUrl(Transport.GRPC))
			.isEqualTo('http://' + container.getHost() + ':' + container.getMappedPort(4317) + '/v1/logs');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(OtlpTracingAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.amqp;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class RabbitContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final RabbitMQContainer rabbit = TestImage.container(RabbitMQContainer.class);
	@Autowired(required = false)
	private RabbitConnectionDetails connectionDetails;
	@Autowired
	private RabbitTemplate rabbitTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToRabbitContainer() {
		assertThat(this.connectionDetails).isNotNull();
		this.rabbitTemplate.convertAndSend('test', 'message');
		Awaitility.waitAtMost(Duration.ofMinutes(4))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('message'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(RabbitAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@RabbitListener(queuesToDeclare = @Queue('test'))
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
@DisabledIfDockerUnavailable
class ServiceConnectionAutoConfigurationTests {
	private static final String REDIS_CONTAINER_CONNECTION_DETAILS = 'org.springframework.boot.testcontainers.service.connection.redis.'
			+ 'RedisContainerConnectionDetailsFactory$RedisContainerConnectionDetails';
	@Test
	void whenNoExistingBeansRegistersServiceConnection() {
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext()) {
			applicationContext.register(WithNoExtraAutoConfiguration.class, ContainerConfiguration.class);
			new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
			applicationContext.refresh();
			RedisConnectionDetails connectionDetails = applicationContext.getBean(RedisConnectionDetails.class);
			assertThat(connectionDetails.getClass().getName()).isEqualTo(REDIS_CONTAINER_CONNECTION_DETAILS);
		}
	}
	@Test
	void whenHasExistingAutoConfigurationRegistersReplacement() {
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext()) {
			applicationContext.register(WithRedisAutoConfiguration.class, ContainerConfiguration.class);
			new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
			applicationContext.refresh();
			RedisConnectionDetails connectionDetails = applicationContext.getBean(RedisConnectionDetails.class);
			assertThat(connectionDetails.getClass().getName()).isEqualTo(REDIS_CONTAINER_CONNECTION_DETAILS);
		}
	}
	@Test
	@ClassPathExclusions('lettuce-core-*.jar')
	void whenHasUserConfigurationDoesNotRegisterReplacement() {
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext()) {
			applicationContext.register(UserConfiguration.class, WithRedisAutoConfiguration.class,
					ContainerConfiguration.class);
			new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
			applicationContext.refresh();
			RedisConnectionDetails connectionDetails = applicationContext.getBean(RedisConnectionDetails.class);
			assertThat(Mockito.mockingDetails(connectionDetails).isMock()).isTrue();
		}
	}
	@Test
	void whenHasTestcontainersBeanDefinition() {
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext()) {
			applicationContext.register(WithNoExtraAutoConfiguration.class,
					TestcontainerBeanDefinitionConfiguration.class);
			new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
			applicationContext.refresh();
			RedisConnectionDetails connectionDetails = applicationContext.getBean(RedisConnectionDetails.class);
			assertThat(connectionDetails.getClass().getName()).isEqualTo(REDIS_CONTAINER_CONNECTION_DETAILS);
		}
	}
	@Test
	void serviceConnectionBeansDoNotCauseAotProcessingToFail() {
		try (AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext()) {
			applicationContext.register(WithNoExtraAutoConfiguration.class, ContainerConfiguration.class);
			new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
			TestGenerationContext generationContext = new TestGenerationContext();
			assertThatNoException().isThrownBy(() -> new ApplicationContextAotGenerator()
				.processAheadOfTime(applicationContext, generationContext));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(ServiceConnectionAutoConfiguration.class)
	static class WithNoExtraAutoConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ ServiceConnectionAutoConfiguration.class, RedisAutoConfiguration.class })
	static class WithRedisAutoConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class ContainerConfiguration {
		@Bean
		@ServiceConnection
		RedisContainer redisContainer() {
			return TestImage.container(RedisContainer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserConfiguration {
		@Bean
		RedisConnectionDetails redisConnectionDetails() {
			return mock(RedisConnectionDetails.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestcontainerBeanDefinitionRegistrar.class)
	static class TestcontainerBeanDefinitionConfiguration {
	}
	static class TestcontainerBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar {
		@Override
		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,
				BeanNameGenerator importBeanNameGenerator) {
			registry.registerBeanDefinition('redisContainer', new TestcontainersRootBeanDefinition());
		}
	}
	static class TestcontainersRootBeanDefinition extends RootBeanDefinition implements TestcontainerBeanDefinition {
		private final RedisContainer container = TestImage.container(RedisContainer.class);
		TestcontainersRootBeanDefinition() {
			setBeanClass(RedisContainer.class);
			setInstanceSupplier(() -> this.container);
		}
		@Override
		public String getContainerImageName() {
			return this.container.getDockerImageName();
		}
		@Override
		public MergedAnnotations getAnnotations() {
			MergedAnnotation<ServiceConnection> annotation = MergedAnnotation.of(ServiceConnection.class);
			return MergedAnnotations.of(Set.of(annotation));
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.kafka;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@TestPropertySource(properties = { 'spring.kafka.consumer.group-id=test-group',
		'spring.kafka.consumer.auto-offset-reset=earliest' })
class ApacheKafkaContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final KafkaContainer kafka = TestImage.container(KafkaContainer.class);
	@Autowired
	private KafkaTemplate<String, String> kafkaTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToKafkaContainer() {
		this.kafkaTemplate.send('test-topic', 'test-data');
		Awaitility.waitAtMost(Duration.ofMinutes(4))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('test-data'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(KafkaAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@KafkaListener(topics = 'test-topic')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.kafka;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@TestPropertySource(properties = { 'spring.kafka.consumer.group-id=test-group',
		'spring.kafka.consumer.auto-offset-reset=earliest' })
class ConfluentKafkaContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final ConfluentKafkaContainer kafka = TestImage.container(ConfluentKafkaContainer.class);
	@Autowired
	private KafkaTemplate<String, String> kafkaTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToKafkaContainer() {
		this.kafkaTemplate.send('test-topic', 'test-data');
		Awaitility.waitAtMost(Duration.ofMinutes(4))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('test-data'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(KafkaAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@KafkaListener(topics = 'test-topic')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.kafka;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@TestPropertySource(properties = { 'spring.kafka.consumer.group-id=test-group',
		'spring.kafka.consumer.auto-offset-reset=earliest' })
@Deprecated(since = '3.4.0', forRemoval = true)
class DeprecatedConfluentKafkaContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final KafkaContainer kafka = TestImage.container(KafkaContainer.class);
	@Autowired
	private KafkaTemplate<String, String> kafkaTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToKafkaContainer() {
		this.kafkaTemplate.send('test-topic', 'test-data');
		Awaitility.waitAtMost(Duration.ofMinutes(4))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('test-data'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(KafkaAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@KafkaListener(topics = 'test-topic')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.elasticsearch;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class ElasticsearchContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	@Autowired(required = false)
	private ElasticsearchConnectionDetails connectionDetails;
	@Autowired
	private ElasticsearchClient client;
	@Test
	void connectionCanBeMadeToElasticsearchContainer() throws IOException {
		assertThat(this.connectionDetails).isNotNull();
		assertThat(this.client.cluster().health().numberOfNodes()).isEqualTo(1);
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ ElasticsearchClientAutoConfiguration.class,
			ElasticsearchRestClientAutoConfiguration.class })
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.redis;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class RedisContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final RedisContainer redis = TestImage.container(RedisContainer.class);
	@Autowired(required = false)
	private RedisConnectionDetails connectionDetails;
	@Autowired
	private RedisConnectionFactory connectionFactory;
	@Test
	void connectionCanBeMadeToRedisContainer() {
		assertThat(this.connectionDetails).isNotNull();
		try (RedisConnection connection = this.connectionFactory.getConnection()) {
			assertThat(connection.commands().echo('Hello, World'.getBytes())).isEqualTo('Hello, World'.getBytes());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(RedisAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.redis;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class RedisStackContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final RedisStackContainer redis = TestImage.container(RedisStackContainer.class);
	@Autowired(required = false)
	private RedisConnectionDetails connectionDetails;
	@Autowired
	private RedisConnectionFactory connectionFactory;
	@Test
	void connectionCanBeMadeToRedisContainer() {
		assertThat(this.connectionDetails).isNotNull();
		try (RedisConnection connection = this.connectionFactory.getConnection()) {
			assertThat(connection.commands().echo('Hello, World'.getBytes())).isEqualTo('Hello, World'.getBytes());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(RedisAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.redis;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class RedisStackServerContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final RedisStackServerContainer redis = TestImage.container(RedisStackServerContainer.class);
	@Autowired(required = false)
	private RedisConnectionDetails connectionDetails;
	@Autowired
	private RedisConnectionFactory connectionFactory;
	@Test
	void connectionCanBeMadeToRedisContainer() {
		assertThat(this.connectionDetails).isNotNull();
		try (RedisConnection connection = this.connectionFactory.getConnection()) {
			assertThat(connection.commands().echo('Hello, World'.getBytes())).isEqualTo('Hello, World'.getBytes());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(RedisAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.redis;
/**
class CustomRedisContainerConnectionDetailsFactoryTests {
	@Test
	void getConnectionDetailsWhenRedisContainerWithCustomName() {
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories();
		MergedAnnotation<ServiceConnection> annotation = MergedAnnotation.of(ServiceConnection.class,
				Map.of('value', ''));
		ContainerConnectionSource<RedisContainer> source = TestContainerConnectionSource.create('test', null,
				RedisContainer.class, 'mycustomimage', annotation, null);
		Map<Class<?>, ConnectionDetails> connectionDetails = factories.getConnectionDetails(source, true);
		assertThat(connectionDetails.get(RedisConnectionDetails.class)).isNotNull();
	}
	@Test
	void getConnectionDetailsWhenRedisStackContainerWithCustomName() {
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories();
		MergedAnnotation<ServiceConnection> annotation = MergedAnnotation.of(ServiceConnection.class,
				Map.of('value', ''));
		ContainerConnectionSource<RedisStackContainer> source = TestContainerConnectionSource.create('test', null,
				RedisStackContainer.class, 'mycustomimage', annotation, null);
		Map<Class<?>, ConnectionDetails> connectionDetails = factories.getConnectionDetails(source, true);
		assertThat(connectionDetails.get(RedisConnectionDetails.class)).isNotNull();
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The Oracle image has no ARM support')
class OracleXeR2dbcContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final OracleContainer oracle = TestImage.container(OracleContainer.class);
	@Autowired
	ConnectionFactory connectionFactory;
	@Test
	void connectionCanBeMadeToOracleContainer() {
		Object result = DatabaseClient.create(this.connectionFactory)
			.sql(DatabaseDriver.ORACLE.getValidationQuery())
			.map((row, metadata) -> row.get(0))
			.first()
			.block(Duration.ofSeconds(30));
		assertThat(result).isEqualTo('Hello');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(R2dbcAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
		disabledReason = 'The Oracle image has no ARM support')
class OracleFreeR2dbcContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final OracleContainer oracle = TestImage.container(OracleContainer.class);
	@Autowired
	ConnectionFactory connectionFactory;
	@Test
	void connectionCanBeMadeToOracleContainer() {
		Object result = DatabaseClient.create(this.connectionFactory)
			.sql(DatabaseDriver.ORACLE.getValidationQuery())
			.map((row, metadata) -> row.get(0))
			.first()
			.block(Duration.ofSeconds(30));
		assertThat(result).isEqualTo('Hello');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(R2dbcAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.liquibase;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class LiquibaseContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final PostgreSQLContainer<?> postgres = TestImage.container(PostgreSQLContainer.class);
	@Autowired(required = false)
	private JdbcConnectionDetails connectionDetails;
	@Autowired
	private SpringLiquibase liquibase;
	@Test
	void connectionCanBeMadeToJdbcContainer() {
		assertThat(this.connectionDetails).isNotNull();
		JdbcTemplate jdbc = new JdbcTemplate(this.liquibase.getDataSource());
		assertThatNoException().isThrownBy(() -> jdbc.execute('SELECT * from example'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(LiquibaseAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.flyway;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class FlywayContainerConnectionDetailsFactoryTests {
	@Container
	@ServiceConnection
	static final PostgreSQLContainer<?> postgres = TestImage.container(PostgreSQLContainer.class);
	@Autowired(required = false)
	private JdbcConnectionDetails connectionDetails;
	@Autowired
	private Flyway flyway;
	@Test
	void connectionCanBeMadeToJdbcContainer() {
		assertThat(this.connectionDetails).isNotNull();
		JdbcTemplate jdbc = new JdbcTemplate(this.flyway.getConfiguration().getDataSource());
		assertThatNoException().isThrownBy(() -> jdbc.execute('SELECT * from public.flyway_schema_history'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(FlywayAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.ldap;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class OpenLdapContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final OpenLdapContainer openLdap = TestImage.container(OpenLdapContainer.class).withEnv('LDAP_TLS', 'false');
	@Autowired
	private LdapTemplate ldapTemplate;
	@Test
	void connectionCanBeMadeToLdapContainer() {
		List<String> cn = this.ldapTemplate.search(LdapQueryBuilder.query().where('objectclass').is('dcObject'),
				(AttributesMapper<String>) (attributes) -> attributes.get('dc').get().toString());
		assertThat(cn).singleElement().isEqualTo('example');
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ LdapAutoConfiguration.class })
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.activemq;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class ActiveMQClassicContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final ActiveMQContainer activemq = TestImage.container(ActiveMQContainer.class);
	@Autowired
	private JmsMessagingTemplate jmsTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToActiveMQContainer() {
		this.jmsTemplate.convertAndSend('sample.queue', 'message');
		Awaitility.waitAtMost(Duration.ofMinutes(1))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('message'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ ActiveMQAutoConfiguration.class, JmsAutoConfiguration.class })
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@JmsListener(destination = 'sample.queue')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.activemq;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class ActiveMQContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final SymptomaActiveMQContainer activemq = TestImage.container(SymptomaActiveMQContainer.class);
	@Autowired
	private JmsMessagingTemplate jmsTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToActiveMQContainer() {
		this.jmsTemplate.convertAndSend('sample.queue', 'message');
		Awaitility.waitAtMost(Duration.ofMinutes(1))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('message'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ ActiveMQAutoConfiguration.class, JmsAutoConfiguration.class })
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@JmsListener(destination = 'sample.queue')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.activemq;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
class ArtemisContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final ArtemisContainer artemis = TestImage.container(ArtemisContainer.class);
	@Autowired
	private JmsMessagingTemplate jmsTemplate;
	@Autowired
	private TestListener listener;
	@Test
	void connectionCanBeMadeToActiveMQContainer() {
		this.jmsTemplate.convertAndSend('sample.queue', 'message');
		Awaitility.waitAtMost(Duration.ofMinutes(1))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('message'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ ArtemisAutoConfiguration.class, JmsAutoConfiguration.class })
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@JmsListener(destination = 'sample.queue')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.redpanda;
/**
@SpringJUnitConfig
@Testcontainers(disabledWithoutDocker = true)
@TestPropertySource(properties = { 'spring.kafka.consumer.group-id=test-group',
		'spring.kafka.consumer.auto-offset-reset=earliest' })
class RedpandaContainerConnectionDetailsFactoryIntegrationTests {
	@Container
	@ServiceConnection
	static final RedpandaContainer redpanda = TestImage.container(RedpandaContainer.class);
	@Autowired
	KafkaTemplate<String, String> kafkaTemplate;
	@Autowired
	TestListener listener;
	@Test
	void connectionCanBeMadeToRedpandaContainer() {
		this.kafkaTemplate.send('test-topic', 'test-data');
		Awaitility.waitAtMost(Duration.ofSeconds(30))
			.untilAsserted(() -> assertThat(this.listener.messages).containsExactly('test-data'));
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(KafkaAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		TestListener testListener() {
			return new TestListener();
		}
	}
	static class TestListener {
		private final List<String> messages = new ArrayList<>();
		@KafkaListener(topics = 'test-topic')
		void processMessage(String message) {
			this.messages.add(message);
		}
	}
}
/*
package org.springframework.boot.testcontainers;
/**
@DisabledIfDockerUnavailable
class ImportTestcontainersTests {
	private AnnotationConfigApplicationContext applicationContext;
	@AfterEach
	void teardown() {
		if (this.applicationContext != null) {
			this.applicationContext.close();
		}
	}
	@Test
	void importWithoutValueRegistersBeans() {
		this.applicationContext = new AnnotationConfigApplicationContext(ImportWithoutValue.class);
		String[] beanNames = this.applicationContext.getBeanNamesForType(PostgreSQLContainer.class);
		assertThat(beanNames).hasSize(1);
		assertThat(this.applicationContext.getBean(beanNames[0])).isSameAs(ImportWithoutValue.container);
		TestcontainerBeanDefinition beanDefinition = (TestcontainerBeanDefinition) this.applicationContext
			.getBeanDefinition(beanNames[0]);
		assertThat(beanDefinition.getContainerImageName()).isEqualTo(ImportWithoutValue.container.getDockerImageName());
		assertThat(beanDefinition.getAnnotations().isPresent(ContainerAnnotation.class)).isTrue();
	}
	@Test
	void importWithValueRegistersBeans() {
		this.applicationContext = new AnnotationConfigApplicationContext(ImportWithValue.class);
		String[] beanNames = this.applicationContext.getBeanNamesForType(PostgreSQLContainer.class);
		assertThat(beanNames).hasSize(1);
		assertThat(this.applicationContext.getBean(beanNames[0])).isSameAs(ContainerDefinitions.container);
		TestcontainerBeanDefinition beanDefinition = (TestcontainerBeanDefinition) this.applicationContext
			.getBeanDefinition(beanNames[0]);
		assertThat(beanDefinition.getContainerImageName())
			.isEqualTo(ContainerDefinitions.container.getDockerImageName());
		assertThat(beanDefinition.getAnnotations().isPresent(ContainerAnnotation.class)).isTrue();
	}
	@Test
	void importWhenHasNoContainerFieldsDoesNothing() {
		this.applicationContext = new AnnotationConfigApplicationContext(NoContainers.class);
		String[] beanNames = this.applicationContext.getBeanNamesForType(Container.class);
		assertThat(beanNames).isEmpty();
	}
	@Test
	void importWhenHasNullContainerFieldThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.applicationContext = new AnnotationConfigApplicationContext(NullContainer.class))
			.withMessage('Container field "container" must not have a null value');
	}
	@Test
	void importWhenHasNonStaticContainerFieldThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(
					() -> this.applicationContext = new AnnotationConfigApplicationContext(NonStaticContainer.class))
			.withMessage('Container field "container" must be static');
	}
	@Test
	void importWhenHasContainerDefinitionsWithDynamicPropertySource() {
		this.applicationContext = new AnnotationConfigApplicationContext(
				ContainerDefinitionsWithDynamicPropertySource.class);
		assertThat(this.applicationContext.getEnvironment().getProperty('container.port')).isNotNull();
	}
	@Test
	void importWhenHasNonStaticDynamicPropertySourceMethod() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.applicationContext = new AnnotationConfigApplicationContext(
					NonStaticDynamicPropertySourceMethod.class))
			.withMessage('@DynamicPropertySource method "containerProperties" must be static');
	}
	@Test
	void importWhenHasBadArgsDynamicPropertySourceMethod() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.applicationContext = new AnnotationConfigApplicationContext(
					BadArgsDynamicPropertySourceMethod.class))
			.withMessage('@DynamicPropertySource method "containerProperties" must be static');
	}
	@ImportTestcontainers
	static class ImportWithoutValue {
		@ContainerAnnotation
		static PostgreSQLContainer<?> container = TestImage.container(PostgreSQLContainer.class);
	}
	@ImportTestcontainers(ContainerDefinitions.class)
	static class ImportWithValue {
	}
	@ImportTestcontainers
	static class NoContainers {
	}
	@ImportTestcontainers
	static class NullContainer {
		static PostgreSQLContainer<?> container = null;
	}
	@ImportTestcontainers
	static class NonStaticContainer {
		PostgreSQLContainer<?> container = TestImage.container(PostgreSQLContainer.class);
	}
	interface ContainerDefinitions {
		@ContainerAnnotation
		PostgreSQLContainer<?> container = TestImage.container(PostgreSQLContainer.class);
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface ContainerAnnotation {
	}
	@ImportTestcontainers
	static class ContainerDefinitionsWithDynamicPropertySource {
		static PostgreSQLContainer<?> container = TestImage.container(PostgreSQLContainer.class);
		@DynamicPropertySource
		static void containerProperties(DynamicPropertyRegistry registry) {
			registry.add('container.port', container::getFirstMappedPort);
		}
	}
	@ImportTestcontainers
	static class NonStaticDynamicPropertySourceMethod {
		@DynamicPropertySource
		void containerProperties(DynamicPropertyRegistry registry) {
		}
	}
	@ImportTestcontainers
	static class BadArgsDynamicPropertySourceMethod {
		@DynamicPropertySource
		void containerProperties() {
		}
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@ExtendWith(SpringExtension.class)
@DisabledIfDockerUnavailable
@ImportTestcontainers(Containers.class)
class TestcontainersImportWithPropertiesInjectedIntoLoadTimeWeaverAwareBeanIntegrationTests {
	// gh-38913
	@Test
	void starts() {
	}
	@TestConfiguration
	@EnableConfigurationProperties(MockDataSourceProperties.class)
	static class Config {
		@Bean
		MockEntityManager mockEntityManager(MockDataSourceProperties properties) {
			return new MockEntityManager();
		}
	}
	static class MockEntityManager implements LoadTimeWeaverAware {
		@Override
		public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {
		}
	}
	@ConfigurationProperties('spring.datasource')
	public static class MockDataSourceProperties {
		private String url;
		public String getUrl() {
			return this.url;
		}
		public void setUrl(String url) {
			this.url = url;
		}
	}
	static class Containers {
		@Container
		static PostgreSQLContainer<?> container = TestImage.container(PostgreSQLContainer.class);
		@DynamicPropertySource
		static void setConnectionProperties(DynamicPropertyRegistry registry) {
			registry.add('spring.datasource.url', container::getJdbcUrl);
			registry.add('spring.datasource.password', container::getPassword);
			registry.add('spring.datasource.username', container::getUsername);
		}
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@ExtendWith(SpringExtension.class)
@ContextConfiguration(classes = ContainerConfig.class)
@TestPropertySource(properties = 'spring.testcontainers.beans.startup=parallel')
@DisabledIfDockerUnavailable
@ExtendWith(OutputCaptureExtension.class)
class TestContainersParallelStartupIntegrationTests {
	@Test
	void startsInParallel(CapturedOutput out) {
		assertThat(out).contains('-lifecycle-0').contains('-lifecycle-1').contains('-lifecycle-2');
	}
	@Configuration(proxyBeanMethods = false)
	static class ContainerConfig {
		@Bean
		static PostgreSQLContainer<?> container1() {
			return TestImage.container(PostgreSQLContainer.class);
		}
		@Bean
		static PostgreSQLContainer<?> container2() {
			return TestImage.container(PostgreSQLContainer.class);
		}
		@Bean
		static PostgreSQLContainer<?> container3() {
			return TestImage.container(PostgreSQLContainer.class);
		}
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@ExtendWith(AssertingSpringExtension.class)
@ContextConfiguration(loader = ScopedContextLoader.class, classes = { TestConfig.class, ContainerConfig.class })
@DirtiesContext
@DisabledIfDockerUnavailable
class TestcontainersLifecycleOrderWithScopeIntegrationTests {
	static List<String> events = Collections.synchronizedList(new ArrayList<>());
	@Test
	void eventsAreOrderedCorrectlyAfterStartup() {
		assertThat(events).containsExactly('start-container', 'create-bean');
	}
	@Configuration(proxyBeanMethods = false)
	static class ContainerConfig {
		@Bean
		@Scope('custom')
		@ServiceConnection
		RedisContainer redisContainer() {
			return TestImage.container(EventRecordingRedisContainer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		TestBean testBean() {
			events.add('create-bean');
			return new TestBean();
		}
	}
	static class TestBean implements AutoCloseable {
		@Override
		public void close() throws Exception {
			events.add('destroy-bean');
		}
	}
	static class AssertingSpringExtension extends SpringExtension {
		@Override
		public void afterAll(ExtensionContext context) throws Exception {
			super.afterAll(context);
			assertThat(events).containsExactly('start-container', 'create-bean', 'destroy-bean', 'stop-container');
		}
	}
	static class EventRecordingRedisContainer extends RedisContainer {
		EventRecordingRedisContainer(DockerImageName dockerImageName) {
			super(dockerImageName);
		}
		@Override
		public void start() {
			events.add('start-container');
			super.start();
		}
		@Override
		public void stop() {
			events.add('stop-container');
			super.stop();
		}
	}
	static class ScopedContextLoader extends AnnotationConfigContextLoader {
		@Override
		protected GenericApplicationContext createContext() {
			CustomScope customScope = new CustomScope();
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext() {
				@Override
				protected void onClose() {
					customScope.destroy();
					super.onClose();
				}
			};
			context.getBeanFactory().registerScope('custom', customScope);
			return context;
		}
	}
	static class CustomScope implements org.springframework.beans.factory.config.Scope {
		private Map<String, Object> instances = new HashMap<>();
		private MultiValueMap<String, Runnable> destructors = new LinkedMultiValueMap<>();
		@Override
		public Object get(String name, ObjectFactory<?> objectFactory) {
			return this.instances.computeIfAbsent(name, (key) -> objectFactory.getObject());
		}
		@Override
		public Object remove(String name) {
			synchronized (this) {
				Object removed = this.instances.remove(name);
				this.destructors.get(name).forEach(Runnable::run);
				this.destructors.remove(name);
				return removed;
			}
		}
		@Override
		public void registerDestructionCallback(String name, Runnable callback) {
			this.destructors.add(name, callback);
		}
		@Override
		public Object resolveContextualObject(String key) {
			return null;
		}
		@Override
		public String getConversationId() {
			return null;
		}
		void destroy() {
			synchronized (this) {
				this.destructors.forEach((name, actions) -> actions.forEach(Runnable::run));
				this.destructors.clear();
				this.instances.clear();
			}
		}
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@ExtendWith(AssertingSpringExtension.class)
@ContextConfiguration(classes = { TestConfig.class, ContainerConfig.class })
@DirtiesContext
@DisabledIfDockerUnavailable
class TestcontainersLifecycleOrderIntegrationTests {
	static List<String> events = Collections.synchronizedList(new ArrayList<>());
	@Test
	void eventsAreOrderedCorrectlyAfterStartup() {
		assertThat(events).containsExactly('start-container', 'create-bean');
	}
	@Configuration(proxyBeanMethods = false)
	static class ContainerConfig {
		@Bean
		@ServiceConnection
		RedisContainer redisContainer() {
			return TestImage.container(EventRecordingRedisContainer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfig {
		@Bean
		TestBean testBean() {
			events.add('create-bean');
			return new TestBean();
		}
	}
	static class TestBean implements AutoCloseable {
		@Override
		public void close() throws Exception {
			events.add('destroy-bean');
		}
	}
	static class AssertingSpringExtension extends SpringExtension {
		@Override
		public void afterAll(ExtensionContext context) throws Exception {
			super.afterAll(context);
			assertThat(events).containsExactly('start-container', 'create-bean', 'destroy-bean', 'stop-container');
		}
	}
	static class EventRecordingRedisContainer extends RedisContainer {
		EventRecordingRedisContainer(DockerImageName dockerImageName) {
			super(dockerImageName);
		}
		@Override
		public void start() {
			events.add('start-container');
			super.start();
		}
		@Override
		public void stop() {
			events.add('stop-container');
			super.stop();
		}
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@ExtendWith(SpringExtension.class)
@TestPropertySource(properties = 'spring.testcontainers.beans.startup=parallel')
@DisabledIfDockerUnavailable
@ExtendWith(OutputCaptureExtension.class)
@ImportTestcontainers(Containers.class)
class TestContainersParallelStartupWithImportTestcontainersIntegrationTests {
	@Test
	void startsInParallel(CapturedOutput out) {
		assertThat(out).contains('-lifecycle-0').contains('-lifecycle-1').contains('-lifecycle-2');
	}
	static class Containers {
		@Container
		static PostgreSQLContainer<?> container1 = TestImage.container(PostgreSQLContainer.class);
		@Container
		static PostgreSQLContainer<?> container2 = TestImage.container(PostgreSQLContainer.class);
		@Container
		static PostgreSQLContainer<?> container3 = TestImage.container(PostgreSQLContainer.class);
	}
}
/*
package org.springframework.boot.testcontainers;
/**
interface LoadTimeWeaverAwareConsumerContainers {
	@Container
	@ServiceConnection
	PostgreSQLContainer<?> postgreSQLContainer = new PostgreSQLContainer<>('postgres:16.1');
}
/*
package org.springframework.boot.testcontainers;
@SpringBootTest
@DisabledIfDockerUnavailable
@ImportTestcontainers(LoadTimeWeaverAwareConsumerContainers.class)
class LoadTimeWeaverAwareConsumerImportTestcontainersTests implements LoadTimeWeaverAwareConsumerContainers {
	@Autowired
	private LoadTimeWeaverAwareConsumer consumer;
	@Test
	void loadTimeWeaverAwareBeanCanUseJdbcUrlFromContainerBasedConnectionDetails() {
		assertThat(this.consumer.jdbcUrl).isNotNull();
	}
	@Configuration
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class TestConfiguration {
		@Bean
		LoadTimeWeaverAwareConsumer loadTimeWeaverAwareConsumer(JdbcConnectionDetails connectionDetails) {
			return new LoadTimeWeaverAwareConsumer(connectionDetails);
		}
	}
	static class LoadTimeWeaverAwareConsumer implements LoadTimeWeaverAware {
		private final String jdbcUrl;
		LoadTimeWeaverAwareConsumer(JdbcConnectionDetails connectionDetails) {
			this.jdbcUrl = connectionDetails.getJdbcUrl();
		}
		@Override
		public void setLoadTimeWeaver(LoadTimeWeaver loadTimeWeaver) {
		}
	}
}
/*
package org.springframework.boot.testcontainers.properties;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
class TestcontainersPropertySourceTests {
	private MockEnvironment environment = new MockEnvironment()
		.withProperty('spring.testcontainers.dynamic-property-registry-injection', 'allow');
	private GenericApplicationContext context = new GenericApplicationContext();
	TestcontainersPropertySourceTests() {
		((DefaultListableBeanFactory) this.context.getBeanFactory()).setAllowBeanDefinitionOverriding(false);
		this.context.setEnvironment(this.environment);
	}
	@Test
	void getPropertyWhenHasValueSupplierReturnsSuppliedValue() {
		DynamicPropertyRegistry registry = TestcontainersPropertySource.attach(this.environment);
		registry.add('test', () -> 'spring');
		assertThat(this.environment.getProperty('test')).isEqualTo('spring');
	}
	@Test
	void getPropertyWhenHasNoValueSupplierReturnsNull() {
		DynamicPropertyRegistry registry = TestcontainersPropertySource.attach(this.environment);
		registry.add('test', () -> 'spring');
		assertThat(this.environment.getProperty('missing')).isNull();
	}
	@Test
	void containsPropertyWhenHasPropertyReturnsTrue() {
		DynamicPropertyRegistry registry = TestcontainersPropertySource.attach(this.environment);
		registry.add('test', () -> null);
		assertThat(this.environment.containsProperty('test')).isTrue();
	}
	@Test
	void containsPropertyWhenHasNoPropertyReturnsFalse() {
		DynamicPropertyRegistry registry = TestcontainersPropertySource.attach(this.environment);
		registry.add('test', () -> null);
		assertThat(this.environment.containsProperty('missing')).isFalse();
	}
	@Test
	void getPropertyNamesReturnsNames() {
		DynamicPropertyRegistry registry = TestcontainersPropertySource.attach(this.environment);
		registry.add('test', () -> null);
		registry.add('other', () -> null);
		EnumerablePropertySource<?> propertySource = (EnumerablePropertySource<?>) this.environment.getPropertySources()
			.get(TestcontainersPropertySource.NAME);
		assertThat(propertySource.getPropertyNames()).containsExactly('test', 'other');
	}
	@Test
	@SuppressWarnings('unchecked')
	void getSourceReturnsImmutableSource() {
		TestcontainersPropertySource.attach(this.environment);
		PropertySource<?> propertySource = this.environment.getPropertySources().get(TestcontainersPropertySource.NAME);
		Map<String, Object> map = (Map<String, Object>) propertySource.getSource();
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(map::clear);
	}
	@Test
	void attachToEnvironmentWhenNotAttachedAttaches() {
		TestcontainersPropertySource.attach(this.environment);
		PropertySource<?> propertySource = this.environment.getPropertySources().get(TestcontainersPropertySource.NAME);
		assertThat(propertySource).isNotNull();
	}
	@Test
	void attachToEnvironmentWhenAlreadyAttachedReturnsExisting() {
		DynamicPropertyRegistry r1 = TestcontainersPropertySource.attach(this.environment);
		PropertySource<?> p1 = this.environment.getPropertySources().get(TestcontainersPropertySource.NAME);
		DynamicPropertyRegistry r2 = TestcontainersPropertySource.attach(this.environment);
		PropertySource<?> p2 = this.environment.getPropertySources().get(TestcontainersPropertySource.NAME);
		assertThat(r1).isSameAs(r2);
		assertThat(p1).isSameAs(p2);
	}
	@Test
	void attachToEnvironmentAndContextWhenNotAttachedAttaches() {
		TestcontainersPropertySource.attach(this.environment, this.context);
		PropertySource<?> propertySource = this.environment.getPropertySources().get(TestcontainersPropertySource.NAME);
		assertThat(propertySource).isNotNull();
		assertThat(this.context.containsBean(
				org.springframework.boot.testcontainers.properties.TestcontainersPropertySource.EventPublisherRegistrar.NAME));
	}
	@Test
	void attachToEnvironmentAndContextWhenAlreadyAttachedReturnsExisting() {
		DynamicPropertyRegistry r1 = TestcontainersPropertySource.attach(this.environment, this.context);
		PropertySource<?> p1 = this.environment.getPropertySources().get(TestcontainersPropertySource.NAME);
		DynamicPropertyRegistry r2 = TestcontainersPropertySource.attach(this.environment, this.context);
		PropertySource<?> p2 = this.environment.getPropertySources().get(TestcontainersPropertySource.NAME);
		assertThat(r1).isSameAs(r2);
		assertThat(p1).isSameAs(p2);
	}
	@Test
	void getPropertyPublishesEvent() {
		try (GenericApplicationContext applicationContext = new GenericApplicationContext()) {
			ConfigurableEnvironment environment = applicationContext.getEnvironment();
			environment.getPropertySources()
				.addLast(new MapPropertySource('test',
						Map.of('spring.testcontainers.dynamic-property-registry-injection', 'allow')));
			List<ApplicationEvent> events = new ArrayList<>();
			applicationContext.addApplicationListener(events::add);
			DynamicPropertyRegistry registry = TestcontainersPropertySource.attach(environment,
					(BeanDefinitionRegistry) applicationContext.getBeanFactory());
			applicationContext.refresh();
			registry.add('test', () -> 'spring');
			assertThat(environment.containsProperty('test')).isTrue();
			assertThat(events.isEmpty());
			assertThat(environment.getProperty('test')).isEqualTo('spring');
			assertThat(events.stream().filter(BeforeTestcontainerUsedEvent.class::isInstance)).hasSize(1);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ServiceConnectionContextCustomizerFactoryTests {
	private final ServiceConnectionContextCustomizerFactory factory = new ServiceConnectionContextCustomizerFactory();
	@Test
	void createContextCustomizerWhenNoServiceConnectionsReturnsCustomizerToApplyInitializer() {
		ContextCustomizer customizer = this.factory.createContextCustomizer(NoServiceConnections.class, null);
		assertThat(customizer).isNotNull();
		GenericApplicationContext context = new GenericApplicationContext();
		int initialNumberOfPostProcessors = context.getBeanFactoryPostProcessors().size();
		MergedContextConfiguration mergedConfig = mock(MergedContextConfiguration.class);
		customizer.customizeContext(context, mergedConfig);
		assertThat(context.getBeanFactoryPostProcessors()).hasSize(initialNumberOfPostProcessors + 1);
	}
	@Test
	void createContextCustomizerWhenClassHasServiceConnectionsReturnsCustomizer() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(ServiceConnections.class, null);
		assertThat(customizer).isNotNull();
		assertThat(customizer.getSources()).hasSize(2);
	}
	@Test
	void createContextCustomizerWhenEnclosingClassHasServiceConnectionsReturnsCustomizer() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(ServiceConnections.NestedClass.class, null);
		assertThat(customizer).isNotNull();
		assertThat(customizer.getSources()).hasSize(3);
	}
	@Test
	void createContextCustomizerWhenInterfaceHasServiceConnectionsReturnsCustomizer() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(ServiceConnectionsInterface.class, null);
		assertThat(customizer).isNotNull();
		assertThat(customizer.getSources()).hasSize(2);
	}
	@Test
	void createContextCustomizerWhenSuperclassHasServiceConnectionsReturnsCustomizer() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(ServiceConnectionsSubclass.class, null);
		assertThat(customizer).isNotNull();
		assertThat(customizer.getSources()).hasSize(2);
	}
	@Test
	void createContextCustomizerWhenImplementedInterfaceHasServiceConnectionsReturnsCustomizer() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(ServiceConnectionsImpl.class, null);
		assertThat(customizer).isNotNull();
		assertThat(customizer.getSources()).hasSize(2);
	}
	@Test
	void createContextCustomizerWhenInheritedImplementedInterfaceHasServiceConnectionsReturnsCustomizer() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(ServiceConnectionsImplSubclass.class, null);
		assertThat(customizer).isNotNull();
		assertThat(customizer.getSources()).hasSize(2);
	}
	@Test
	void createContextCustomizerWhenClassHasNonStaticServiceConnectionFailsWithHelpfulException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.factory.createContextCustomizer(NonStaticServiceConnection.class, null))
			.withMessage('@ServiceConnection field "service" must be static');
	}
	@Test
	void createContextCustomizerWhenClassHasAnnotationOnNonConnectionFieldFailsWithHelpfulException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.factory.createContextCustomizer(ServiceConnectionOnWrongFieldType.class, null))
			.withMessage('Field "service2" in ' + ServiceConnectionOnWrongFieldType.class.getName()
					+ ' must be a org.testcontainers.containers.Container');
	}
	@Test
	void createContextCustomizerCreatesCustomizerSourceWithSensibleBeanNameSuffix() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(SingleServiceConnection.class, null);
		ContainerConnectionSource<?> source = customizer.getSources().get(0);
		assertThat(source.getBeanNameSuffix()).isEqualTo('test');
	}
	@Test
	void createContextCustomizerCreatesCustomizerSourceWithSensibleOrigin() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(SingleServiceConnection.class, null);
		ContainerConnectionSource<?> source = customizer.getSources().get(0);
		assertThat(source.getOrigin())
			.hasToString('ServiceConnectionContextCustomizerFactoryTests.SingleServiceConnection.service1');
	}
	@Test
	void createContextCustomizerCreatesCustomizerSourceWithSensibleToString() {
		ServiceConnectionContextCustomizer customizer = (ServiceConnectionContextCustomizer) this.factory
			.createContextCustomizer(SingleServiceConnection.class, null);
		ContainerConnectionSource<?> source = customizer.getSources().get(0);
		assertThat(source).hasToString(
				'@ServiceConnection source for ServiceConnectionContextCustomizerFactoryTests.SingleServiceConnection.service1');
	}
	static class NoServiceConnections {
	}
	static class SingleServiceConnection {
		@ServiceConnection
		private static GenericContainer<?> service1 = new MockContainer();
	}
	static class ServiceConnections {
		@ServiceConnection
		private static Container<?> service1 = new MockContainer();
		@ServiceConnection
		private static Container<?> service2 = new MockContainer();
		@Nested
		class NestedClass {
			@ServiceConnection
			private static Container<?> service3 = new MockContainer();
		}
	}
	interface ServiceConnectionsInterface {
		@ServiceConnection
		Container<?> service1 = new MockContainer();
		@ServiceConnection
		Container<?> service2 = new MockContainer();
		default void dummy() {
		}
	}
	static class ServiceConnectionsSubclass extends ServiceConnections {
	}
	static class ServiceConnectionsImpl implements ServiceConnectionsInterface {
	}
	static class ServiceConnectionsImplSubclass extends ServiceConnectionsImpl {
	}
	static class NonStaticServiceConnection {
		@ServiceConnection
		private Container<?> service = new MockContainer('example');
	}
	static class ServiceConnectionOnWrongFieldType {
		@ServiceConnection
		private static InputStream service2 = new ByteArrayInputStream(new byte[0]);
	}
	static class MockContainer extends GenericContainer<MockContainer> {
		private final String dockerImageName;
		MockContainer() {
			this('example');
		}
		MockContainer(String dockerImageName) {
			super(dockerImageName);
			this.dockerImageName = dockerImageName;
		}
		@Override
		public String getDockerImageName() {
			return this.dockerImageName;
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ServiceConnectionContextCustomizerTests {
	private Origin origin;
	private PostgreSQLContainer<?> container;
	private MergedAnnotation<ServiceConnection> annotation;
	private ContainerConnectionSource<?> source;
	private ConnectionDetailsFactories factories;
	@BeforeEach
	void setup() {
		this.origin = mock(Origin.class);
		this.container = mock(PostgreSQLContainer.class);
		this.annotation = MergedAnnotation.of(ServiceConnection.class,
				Map.of('name', 'myname', 'type', new Class<?>[0]));
		this.source = new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class,
				this.container.getDockerImageName(), this.annotation, () -> this.container);
		this.factories = mock(ConnectionDetailsFactories.class);
	}
	@Test
	void customizeContextRegistersServiceConnections() {
		ServiceConnectionContextCustomizer customizer = new ServiceConnectionContextCustomizer(List.of(this.source),
				this.factories);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		DefaultListableBeanFactory beanFactory = spy(new DefaultListableBeanFactory());
		given(context.getBeanFactory()).willReturn(beanFactory);
		MergedContextConfiguration mergedConfig = mock(MergedContextConfiguration.class);
		JdbcConnectionDetails connectionDetails = new TestJdbcConnectionDetails();
		given(this.factories.getConnectionDetails(this.source, true))
			.willReturn(Map.of(JdbcConnectionDetails.class, connectionDetails));
		customizer.customizeContext(context, mergedConfig);
		then(beanFactory).should()
			.registerBeanDefinition(eq('testJdbcConnectionDetailsForTest'),
					ArgumentMatchers.<RootBeanDefinition>assertArg((beanDefinition) -> {
						assertThat(beanDefinition.getInstanceSupplier().get()).isSameAs(connectionDetails);
						assertThat(beanDefinition.getBeanClass()).isEqualTo(TestJdbcConnectionDetails.class);
					}));
	}
	@Test
	void equalsAndHashCode() {
		PostgreSQLContainer<?> container1 = mock(PostgreSQLContainer.class);
		PostgreSQLContainer<?> container2 = mock(PostgreSQLContainer.class);
		MergedAnnotation<ServiceConnection> annotation1 = MergedAnnotation.of(ServiceConnection.class,
				Map.of('name', '', 'type', new Class<?>[0]));
		MergedAnnotation<ServiceConnection> annotation2 = MergedAnnotation.of(ServiceConnection.class,
				Map.of('name', '', 'type', new Class<?>[0]));
		MergedAnnotation<ServiceConnection> annotation3 = MergedAnnotation.of(ServiceConnection.class,
				Map.of('name', '', 'type', new Class<?>[] { JdbcConnectionDetails.class }));
		// Connection Names
		ServiceConnectionContextCustomizer n1 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation1, () -> container1)));
		ServiceConnectionContextCustomizer n2 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation1, () -> container1)));
		ServiceConnectionContextCustomizer n3 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'namex',
						annotation1, () -> container1)));
		assertThat(n1.hashCode()).isEqualTo(n2.hashCode()).isNotEqualTo(n3.hashCode());
		assertThat(n1).isEqualTo(n2).isNotEqualTo(n3);
		// Connection Details Types
		ServiceConnectionContextCustomizer t1 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation1, () -> container1)));
		ServiceConnectionContextCustomizer t2 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation2, () -> container1)));
		ServiceConnectionContextCustomizer t3 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation3, () -> container1)));
		assertThat(t1.hashCode()).isEqualTo(t2.hashCode()).isNotEqualTo(t3.hashCode());
		assertThat(t1).isEqualTo(t2).isNotEqualTo(t3);
		// Container
		ServiceConnectionContextCustomizer c1 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation1, () -> container1)));
		ServiceConnectionContextCustomizer c2 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation1, () -> container1)));
		ServiceConnectionContextCustomizer c3 = new ServiceConnectionContextCustomizer(
				List.of(new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, 'name',
						annotation1, () -> container2)));
		assertThat(c1.hashCode()).isEqualTo(c2.hashCode()).isNotEqualTo(c3.hashCode());
		assertThat(c1).isEqualTo(c2).isNotEqualTo(c3);
	}
	/**
	 * Test {@link JdbcConnectionDetails}.
	 */
	static class TestJdbcConnectionDetails implements JdbcConnectionDetails {
		@Override
		public String getUsername() {
			return null;
		}
		@Override
		public String getPassword() {
			return null;
		}
		@Override
		public String getJdbcUrl() {
			return null;
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class FieldOriginTests {
	@Test
	void createWhenFieldIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new FieldOrigin(null))
			.withMessage('Field must not be null');
	}
	@Test
	void equalsAndHashCode() {
		Origin o1 = new FieldOrigin(ReflectionUtils.findField(Fields.class, 'one'));
		Origin o2 = new FieldOrigin(ReflectionUtils.findField(Fields.class, 'one'));
		Origin o3 = new FieldOrigin(ReflectionUtils.findField(Fields.class, 'two'));
		assertThat(o1).isEqualTo(o1).isEqualTo(o2).isNotEqualTo(o3);
		assertThat(o1.hashCode()).isEqualTo(o2.hashCode());
	}
	@Test
	void toStringReturnsSensibleString() {
		Origin origin = new FieldOrigin(ReflectionUtils.findField(Fields.class, 'one'));
		assertThat(origin).hasToString('FieldOriginTests.Fields.one');
	}
	static class Fields {
		String one;
		String two;
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.zipkin;
/**
class ZipkinContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ZipkinAutoConfiguration.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.zipkin;
/**
@ClassPathExclusions('spring-boot-actuator-*')
class ZipkinContainerConnectionDetailsFactoryWithoutActuatorTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(hints).isNotNull();
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ContainerConnectionDetailsFactoryTests {
	private String beanNameSuffix;
	private Origin origin;
	private PostgreSQLContainer<?> container;
	private MergedAnnotation<ServiceConnection> annotation;
	private ContainerConnectionSource<?> source;
	@BeforeEach
	void setup() {
		this.beanNameSuffix = 'MyBean';
		this.origin = mock(Origin.class);
		this.container = mock(PostgreSQLContainer.class);
		this.annotation = MergedAnnotation.of(ServiceConnection.class,
				Map.of('name', 'myname', 'type', new Class<?>[0]));
		this.source = new ContainerConnectionSource<>(this.beanNameSuffix, this.origin, PostgreSQLContainer.class,
				this.container.getDockerImageName(), this.annotation, () -> this.container);
	}
	@Test
	void getConnectionDetailsWhenTypesMatchAndNoNameRestrictionReturnsDetails() {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory();
		ConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		assertThat(connectionDetails).isNotNull();
	}
	@Test
	void getConnectionDetailsWhenTypesMatchAndNameRestrictionMatchesReturnsDetails() {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory('myname');
		ConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		assertThat(connectionDetails).isNotNull();
	}
	@Test
	void getConnectionDetailsWhenTypesMatchAndNameRestrictionsMatchReturnsDetails() {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory(
				List.of('notmyname', 'myname'));
		ConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		assertThat(connectionDetails).isNotNull();
	}
	@Test
	void getConnectionDetailsWhenTypesMatchAndNameRestrictionDoesNotMatchReturnsNull() {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory('notmyname');
		ConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		assertThat(connectionDetails).isNull();
	}
	@Test
	void getConnectionDetailsWhenTypesMatchAndNameRestrictionsDoNotMatchReturnsNull() {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory(
				List.of('notmyname', 'alsonotmyname'));
		ConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		assertThat(connectionDetails).isNull();
	}
	@Test
	void getConnectionDetailsWhenContainerTypeDoesNotMatchReturnsNull() {
		ElasticsearchContainer container = mock(ElasticsearchContainer.class);
		ContainerConnectionSource<?> source = new ContainerConnectionSource<>(this.beanNameSuffix, this.origin,
				ElasticsearchContainer.class, container.getDockerImageName(), this.annotation, () -> container);
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory();
		ConnectionDetails connectionDetails = getConnectionDetails(factory, source);
		assertThat(connectionDetails).isNull();
	}
	@Test
	void getConnectionDetailsHasOrigin() {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory();
		ConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		assertThat(Origin.from(connectionDetails)).isSameAs(this.origin);
	}
	@Test
	void getContainerWhenNotInitializedThrowsException() {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory();
		TestContainerConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		assertThatIllegalStateException().isThrownBy(connectionDetails::callGetContainer)
			.withMessage('Container cannot be obtained before the connection details bean has been initialized');
	}
	@Test
	void getContainerWhenInitializedReturnsSuppliedContainer() throws Exception {
		TestContainerConnectionDetailsFactory factory = new TestContainerConnectionDetailsFactory();
		TestContainerConnectionDetails connectionDetails = getConnectionDetails(factory, this.source);
		connectionDetails.afterPropertiesSet();
		assertThat(connectionDetails.callGetContainer()).isSameAs(this.container);
	}
	@Test
	void creatingFactoryWithEmptyNamesThrows() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestContainerConnectionDetailsFactory(Collections.emptyList()));
	}
	@Test
	void creatingFactoryWithNullNamesThrows() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TestContainerConnectionDetailsFactory((List<String>) null));
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private TestContainerConnectionDetails getConnectionDetails(ConnectionDetailsFactory<?, ?> factory,
			ContainerConnectionSource<?> source) {
		return (TestContainerConnectionDetails) ((ConnectionDetailsFactory) factory).getConnectionDetails(source);
	}
	/**
	 * Test {@link ContainerConnectionDetailsFactory}.
	 */
	static class TestContainerConnectionDetailsFactory
			extends ContainerConnectionDetailsFactory<JdbcDatabaseContainer<?>, JdbcConnectionDetails> {
		TestContainerConnectionDetailsFactory() {
			this(ANY_CONNECTION_NAME);
		}
		TestContainerConnectionDetailsFactory(String connectionName) {
			super(connectionName);
		}
		TestContainerConnectionDetailsFactory(List<String> connectionNames) {
			super(connectionNames);
		}
		@Override
		protected JdbcConnectionDetails getContainerConnectionDetails(
				ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
			return new TestContainerConnectionDetails(source);
		}
		static final class TestContainerConnectionDetails extends ContainerConnectionDetails<JdbcDatabaseContainer<?>>
				implements JdbcConnectionDetails {
			private TestContainerConnectionDetails(ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
				super(source);
			}
			@Override
			public String getUsername() {
				return 'user';
			}
			@Override
			public String getPassword() {
				return 'secret';
			}
			@Override
			public String getJdbcUrl() {
				return 'jdbc:example';
			}
			JdbcDatabaseContainer<?> callGetContainer() {
				return super.getContainer();
			}
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.hazelcast;
/**
class HazelcastContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ClientConfig.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.neo4j;
/**
class Neo4jContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(AuthToken.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ContainerConnectionSourceTests {
	private String beanNameSuffix;
	private Origin origin;
	private PostgreSQLContainer<?> container;
	private MergedAnnotation<ServiceConnection> annotation;
	private ContainerConnectionSource<?> source;
	@BeforeEach
	void setup() {
		this.beanNameSuffix = 'MyBean';
		this.origin = mock(Origin.class);
		this.container = mock(PostgreSQLContainer.class);
		given(this.container.getDockerImageName()).willReturn('postgres');
		this.annotation = MergedAnnotation.of(ServiceConnection.class, Map.of('name', '', 'type', new Class<?>[0]));
		this.source = new ContainerConnectionSource<>(this.beanNameSuffix, this.origin, PostgreSQLContainer.class,
				this.container.getDockerImageName(), this.annotation, () -> this.container);
	}
	@Test
	void acceptsWhenContainerIsNotInstanceOfRequiredContainerTypeReturnsFalse() {
		String requiredConnectionName = null;
		Class<?> requiredContainerType = ElasticsearchContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isFalse();
	}
	@Test
	void acceptsWhenContainerIsInstanceOfRequiredContainerTypeReturnsTrue() {
		String requiredConnectionName = null;
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isTrue();
	}
	@Test
	void acceptsWhenRequiredConnectionNameDoesNotMatchNameTakenFromAnnotationReturnsFalse() {
		setupSourceAnnotatedWithName('myname');
		String requiredConnectionName = 'othername';
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isFalse();
	}
	@Test
	void acceptsWhenRequiredConnectionNameDoesNotMatchNameTakenFromContainerReturnsFalse() {
		String requiredConnectionName = 'othername';
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isFalse();
	}
	@Test
	void acceptsWhenRequiredConnectionNameIsUnrestrictedReturnsTrue() {
		String requiredConnectionName = null;
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isTrue();
	}
	@Test
	void acceptsWhenRequiredConnectionNameMatchesNameTakenFromAnnotationReturnsTrue() {
		setupSourceAnnotatedWithName('myname');
		String requiredConnectionName = 'myname';
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isTrue();
	}
	@Test
	void acceptsWhenRequiredConnectionNameMatchesNameTakenFromContainerReturnsTrue() {
		String requiredConnectionName = 'postgres';
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isTrue();
	}
	@Test
	void acceptsWhenRequiredConnectionDetailsTypeNotInAnnotationRestrictionReturnsFalse() {
		setupSourceAnnotatedWithType(ElasticsearchConnectionDetails.class);
		String requiredConnectionName = null;
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isFalse();
	}
	@Test
	void acceptsWhenRequiredConnectionDetailsTypeInAnnotationRestrictionReturnsTrue() {
		setupSourceAnnotatedWithType(JdbcConnectionDetails.class);
		String requiredConnectionName = null;
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isTrue();
	}
	@Test
	void acceptsWhenRequiredConnectionDetailsTypeIsNotRestrictedReturnsTrue() {
		String requiredConnectionName = null;
		Class<?> requiredContainerType = JdbcDatabaseContainer.class;
		Class<?> requiredConnectionDetailsType = JdbcConnectionDetails.class;
		assertThat(this.source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType))
			.isTrue();
	}
	@Test
	void getBeanNameSuffixReturnsBeanNameSuffix() {
		assertThat(this.source.getBeanNameSuffix()).isEqualTo(this.beanNameSuffix);
	}
	@Test
	void getOriginReturnsOrigin() {
		assertThat(this.source.getOrigin()).isEqualTo(this.origin);
	}
	@Test
	void getContainerSupplierReturnsSupplierSupplyingContainer() {
		assertThat(this.source.getContainerSupplier().get()).isSameAs(this.container);
	}
	@Test
	void toStringReturnsSensibleString() {
		assertThat(this.source.toString()).startsWith('@ServiceConnection source for Mock for Origin');
	}
	private void setupSourceAnnotatedWithName(String name) {
		this.annotation = MergedAnnotation.of(ServiceConnection.class, Map.of('name', name, 'type', new Class<?>[0]));
		this.source = new ContainerConnectionSource<>(this.beanNameSuffix, this.origin, PostgreSQLContainer.class,
				this.container.getDockerImageName(), this.annotation, () -> this.container);
	}
	private void setupSourceAnnotatedWithType(Class<?> type) {
		this.annotation = MergedAnnotation.of(ServiceConnection.class,
				Map.of('name', '', 'type', new Class<?>[] { type }));
		this.source = new ContainerConnectionSource<>(this.beanNameSuffix, this.origin, PostgreSQLContainer.class,
				this.container.getDockerImageName(), this.annotation, () -> this.container);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
public final class TestContainerConnectionSource {
	private TestContainerConnectionSource() {
	}
	public static <C extends Container<?>> ContainerConnectionSource<C> create(String beanNameSuffix, Origin origin,
			Class<C> containerType, String containerImageName, MergedAnnotation<ServiceConnection> annotation,
			Supplier<C> containerSupplier) {
		return new ContainerConnectionSource<>(beanNameSuffix, origin, containerType, containerImageName, annotation,
				containerSupplier);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class OracleXeR2dbcContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionFactoryOptions.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class MySqlR2dbcContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionFactoryOptions.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class MariaDbR2dbcContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionFactoryOptions.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class OracleFreeR2dbcContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionFactoryOptions.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class SqlServerR2dbcContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionFactoryOptions.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class PostgresR2dbcContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionFactoryOptions.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class ClickHouseR2dbcContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionFactoryOptions.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ConnectionDetailsRegistrarTests {
	private Origin origin;
	private PostgreSQLContainer<?> container;
	private MergedAnnotation<ServiceConnection> annotation;
	private ContainerConnectionSource<?> source;
	private ConnectionDetailsFactories factories;
	@BeforeEach
	void setup() {
		this.origin = mock(Origin.class);
		this.container = mock(PostgreSQLContainer.class);
		this.annotation = MergedAnnotation.of(ServiceConnection.class, Map.of('name', '', 'type', new Class<?>[0]));
		this.source = new ContainerConnectionSource<>('test', this.origin, PostgreSQLContainer.class, null,
				this.annotation, () -> this.container);
		this.factories = mock(ConnectionDetailsFactories.class);
	}
	@Test
	void registerBeanDefinitionsWhenConnectionDetailsFactoryNotFoundAndNoConnectionNameThrowsExceptionWithBetterMessage() {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		ConnectionDetailsRegistrar registrar = new ConnectionDetailsRegistrar(beanFactory, this.factories);
		given(this.factories.getConnectionDetails(this.source, true))
			.willThrow(new ConnectionDetailsFactoryNotFoundException('fail'));
		assertThatExceptionOfType(ConnectionDetailsFactoryNotFoundException.class)
			.isThrownBy(() -> registrar.registerBeanDefinitions(beanFactory, this.source))
			.withMessage('fail. You may need to add a "name" to your @ServiceConnection annotation');
	}
	@Test
	void registerBeanDefinitionsWhenConnectionDetailsNotFoundExceptionAndNoConnectionNameThrowsExceptionWithBetterMessage() {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		ConnectionDetailsRegistrar registrar = new ConnectionDetailsRegistrar(beanFactory, this.factories);
		given(this.factories.getConnectionDetails(this.source, true))
			.willThrow(new ConnectionDetailsNotFoundException('fail'));
		assertThatExceptionOfType(ConnectionDetailsNotFoundException.class)
			.isThrownBy(() -> registrar.registerBeanDefinitions(beanFactory, this.source))
			.withMessage('fail. You may need to add a "name" to your @ServiceConnection annotation');
	}
	@Test
	void registerBeanDefinitionsWhenExistingBeanSkipsRegistration() {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		beanFactory.registerBeanDefinition('testbean', new RootBeanDefinition(CustomTestConnectionDetails.class));
		ConnectionDetailsRegistrar registrar = new ConnectionDetailsRegistrar(beanFactory, this.factories);
		given(this.factories.getConnectionDetails(this.source, true))
			.willReturn(Map.of(TestConnectionDetails.class, new TestConnectionDetails()));
		registrar.registerBeanDefinitions(beanFactory, this.source);
		assertThat(beanFactory.getBean(TestConnectionDetails.class)).isInstanceOf(CustomTestConnectionDetails.class);
	}
	@Test
	void registerBeanDefinitionsRegistersDefinition() {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		ConnectionDetailsRegistrar registrar = new ConnectionDetailsRegistrar(beanFactory, this.factories);
		given(this.factories.getConnectionDetails(this.source, true))
			.willReturn(Map.of(TestConnectionDetails.class, new TestConnectionDetails()));
		registrar.registerBeanDefinitions(beanFactory, this.source);
		assertThat(beanFactory.getBean(TestConnectionDetails.class)).isNotNull();
	}
	static class TestConnectionDetails implements ConnectionDetails {
	}
	static class CustomTestConnectionDetails extends TestConnectionDetails {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.mongo;
/**
class MongoContainerConnectionDetailsFactoryTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = ContainerConnectionDetailsFactoryHints.getRegisteredHints(getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConnectionString.class)).accepts(hints);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
public final class ContainerConnectionDetailsFactoryHints {
	private ContainerConnectionDetailsFactoryHints() {
	}
	public static RuntimeHints getRegisteredHints(ClassLoader classLoader) {
		RuntimeHints hints = new RuntimeHints();
		new ContainerConnectionDetailsFactoriesRuntimeHints().registerHints(hints, classLoader);
		return hints;
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
class TestcontainersStartupTests {
	private static final String PROPERTY = TestcontainersStartup.PROPERTY;
	private final AtomicInteger counter = new AtomicInteger();
	@Test
	void startWhenSquentialStartsSequentially() {
		List<TestStartable> startables = createTestStartables(100);
		TestcontainersStartup.SEQUENTIAL.start(startables);
		for (int i = 0; i < startables.size(); i++) {
			assertThat(startables.get(i).getIndex()).isEqualTo(i);
			assertThat(startables.get(i).getThreadName()).isEqualTo(Thread.currentThread().getName());
		}
	}
	@Test
	void startWhenParallelStartsInParallel() {
		List<TestStartable> startables = createTestStartables(100);
		TestcontainersStartup.PARALLEL.start(startables);
		assertThat(startables.stream().map(TestStartable::getThreadName)).hasSizeGreaterThan(1);
	}
	@Test
	void getWhenNoPropertyReturnsDefault() {
		MockEnvironment environment = new MockEnvironment();
		assertThat(TestcontainersStartup.get(environment)).isEqualTo(TestcontainersStartup.SEQUENTIAL);
	}
	@Test
	void getWhenPropertyReturnsBasedOnValue() {
		MockEnvironment environment = new MockEnvironment();
		assertThat(TestcontainersStartup.get(environment.withProperty(PROPERTY, 'SEQUENTIAL')))
			.isEqualTo(TestcontainersStartup.SEQUENTIAL);
		assertThat(TestcontainersStartup.get(environment.withProperty(PROPERTY, 'sequential')))
			.isEqualTo(TestcontainersStartup.SEQUENTIAL);
		assertThat(TestcontainersStartup.get(environment.withProperty(PROPERTY, 'SEQuenTIaL')))
			.isEqualTo(TestcontainersStartup.SEQUENTIAL);
		assertThat(TestcontainersStartup.get(environment.withProperty(PROPERTY, 'S-E-Q-U-E-N-T-I-A-L')))
			.isEqualTo(TestcontainersStartup.SEQUENTIAL);
		assertThat(TestcontainersStartup.get(environment.withProperty(PROPERTY, 'parallel')))
			.isEqualTo(TestcontainersStartup.PARALLEL);
	}
	@Test
	void getWhenUnknownPropertyThrowsException() {
		MockEnvironment environment = new MockEnvironment();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> TestcontainersStartup.get(environment.withProperty(PROPERTY, 'bad')))
			.withMessage('Unknown "spring.testcontainers.beans.startup" property value "bad"');
	}
	private List<TestStartable> createTestStartables(int size) {
		List<TestStartable> testStartables = new ArrayList<>(size);
		for (int i = 0; i < size; i++) {
			testStartables.add(new TestStartable());
		}
		return testStartables;
	}
	private final class TestStartable implements Startable {
		private int index;
		private String threadName;
		@Override
		public void start() {
			this.index = TestcontainersStartupTests.this.counter.getAndIncrement();
			this.threadName = Thread.currentThread().getName();
		}
		@Override
		public void stop() {
		}
		int getIndex() {
			return this.index;
		}
		String getThreadName() {
			return this.threadName;
		}
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
class TestcontainersLifecycleApplicationContextInitializerTests {
	@BeforeEach
	void setUp() {
		TestcontainersConfiguration.getInstance().updateUserConfig('testcontainers.reuse.enable', 'false');
	}
	@Test
	void whenStartableBeanInvokesStartOnRefresh() {
		Startable container = mock(Startable.class);
		AnnotationConfigApplicationContext applicationContext = createApplicationContext(container);
		then(container).shouldHaveNoInteractions();
		applicationContext.refresh();
		then(container).should().start();
		applicationContext.close();
	}
	@Test
	void whenStartableBeanInvokesCloseOnShutdown() {
		Startable container = mock(Startable.class);
		AnnotationConfigApplicationContext applicationContext = createApplicationContext(container);
		applicationContext.refresh();
		then(container).should(never()).close();
		applicationContext.close();
		then(container).should(times(1)).close();
	}
	@Test
	void whenReusableContainerAndReuseEnabledBeanInvokesStartButNotClose() {
		TestcontainersConfiguration.getInstance().updateUserConfig('testcontainers.reuse.enable', 'true');
		GenericContainer<?> container = mock(GenericContainer.class);
		given(container.isShouldBeReused()).willReturn(true);
		AnnotationConfigApplicationContext applicationContext = createApplicationContext(container);
		then(container).shouldHaveNoInteractions();
		applicationContext.refresh();
		then(container).should().start();
		applicationContext.close();
		then(container).should(never()).close();
	}
	@Test
	void whenReusableContainerButReuseNotEnabledBeanInvokesStartAndClose() {
		GenericContainer<?> container = mock(GenericContainer.class);
		given(container.isShouldBeReused()).willReturn(true);
		AnnotationConfigApplicationContext applicationContext = createApplicationContext(container);
		then(container).shouldHaveNoInteractions();
		applicationContext.refresh();
		then(container).should().start();
		applicationContext.close();
		then(container).should(times(1)).close();
	}
	@Test
	void whenReusableContainerAndReuseEnabledBeanFromConfigurationInvokesStartButNotClose() {
		TestcontainersConfiguration.getInstance().updateUserConfig('testcontainers.reuse.enable', 'true');
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
		applicationContext.register(ReusableContainerConfiguration.class);
		applicationContext.refresh();
		GenericContainer<?> container = applicationContext.getBean(GenericContainer.class);
		then(container).should().start();
		applicationContext.close();
		then(container).should(never()).close();
	}
	@Test
	void whenReusableContainerButReuseNotEnabledBeanFromConfigurationInvokesStartAndClose() {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
		applicationContext.register(ReusableContainerConfiguration.class);
		applicationContext.refresh();
		GenericContainer<?> container = applicationContext.getBean(GenericContainer.class);
		then(container).should().start();
		applicationContext.close();
		then(container).should(times(1)).close();
	}
	@Test
	void doesNotInitializeSameContextMoreThanOnce() {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		int initialNumberOfPostProcessors = applicationContext.getBeanFactoryPostProcessors().size();
		for (int i = 0; i < 10; i++) {
			new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
		}
		assertThat(applicationContext.getBeanFactoryPostProcessors()).hasSize(initialNumberOfPostProcessors + 1);
	}
	@Test
	void dealsWithBeanCurrentlyInCreationException() {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
		applicationContext.register(BeanCurrentlyInCreationExceptionConfiguration2.class,
				BeanCurrentlyInCreationExceptionConfiguration1.class);
		applicationContext.refresh();
	}
	@Test
	void doesNotStartContainersWhenAotProcessingIsInProgress() {
		GenericContainer<?> container = mock(GenericContainer.class);
		AnnotationConfigApplicationContext applicationContext = createApplicationContext(container);
		then(container).shouldHaveNoInteractions();
		withSystemProperty(AbstractAotProcessor.AOT_PROCESSING, 'true',
				() -> applicationContext.refreshForAotProcessing(new RuntimeHints()));
		then(container).shouldHaveNoInteractions();
		applicationContext.close();
	}
	@Test
	void setupStartupBasedOnEnvironmentProperty() {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		applicationContext.getEnvironment()
			.getPropertySources()
			.addLast(new MapPropertySource('test', Map.of('spring.testcontainers.beans.startup', 'parallel')));
		new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
		AbstractBeanFactory beanFactory = (AbstractBeanFactory) applicationContext.getBeanFactory();
		BeanPostProcessor beanPostProcessor = beanFactory.getBeanPostProcessors()
			.stream()
			.filter(TestcontainersLifecycleBeanPostProcessor.class::isInstance)
			.findFirst()
			.get();
		assertThat(beanPostProcessor).extracting('startup').isEqualTo(TestcontainersStartup.PARALLEL);
	}
	private void withSystemProperty(String name, String value, Runnable action) {
		String previousValue = System.getProperty(name);
		System.setProperty(name, value);
		try {
			action.run();
		}
		finally {
			if (previousValue == null) {
				System.clearProperty(name);
			}
			else {
				System.setProperty(name, previousValue);
			}
		}
	}
	private AnnotationConfigApplicationContext createApplicationContext(Startable container) {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
		applicationContext.registerBean('container', Startable.class, () -> container);
		return applicationContext;
	}
	private AnnotationConfigApplicationContext createApplicationContext(GenericContainer<?> container) {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		new TestcontainersLifecycleApplicationContextInitializer().initialize(applicationContext);
		applicationContext.registerBean('container', GenericContainer.class, () -> container);
		return applicationContext;
	}
	@Configuration
	static class ReusableContainerConfiguration {
		@Bean
		GenericContainer<?> container() {
			GenericContainer<?> container = mock(GenericContainer.class);
			given(container.isShouldBeReused()).willReturn(true);
			return container;
		}
	}
	@Configuration
	static class BeanCurrentlyInCreationExceptionConfiguration1 {
		@Bean
		TestBean testBean() {
			return new TestBean();
		}
	}
	@Configuration
	static class BeanCurrentlyInCreationExceptionConfiguration2 {
		BeanCurrentlyInCreationExceptionConfiguration2(TestBean testBean) {
		}
		@Bean
		GenericContainer<?> container(TestBean testBean) {
			GenericContainer<?> container = mock(GenericContainer.class);
			given(container.isShouldBeReused()).willReturn(true);
			return container;
		}
	}
	static class TestBean {
	}
}
/*
package org.springframework.boot.testcontainers.context;
/**
class ContainerFieldsImporter {
	Set<Startable> registerBeanDefinitions(BeanDefinitionRegistry registry, Class<?> definitionClass) {
		Set<Startable> importedContainers = new HashSet<>();
		for (Field field : getContainerFields(definitionClass)) {
			assertValid(field);
			Container<?> container = getContainer(field);
			if (container instanceof Startable startable) {
				importedContainers.add(startable);
			}
			registerBeanDefinition(registry, field, container);
		}
		return importedContainers;
	}
	private List<Field> getContainerFields(Class<?> containersClass) {
		List<Field> containerFields = new ArrayList<>();
		ReflectionUtils.doWithFields(containersClass, containerFields::add, this::isContainerField);
		return List.copyOf(containerFields);
	}
	private boolean isContainerField(Field candidate) {
		return Container.class.isAssignableFrom(candidate.getType());
	}
	private void assertValid(Field field) {
		Assert.state(Modifier.isStatic(field.getModifiers()),
				() -> 'Container field "' + field.getName() + '" must be static');
	}
	private Container<?> getContainer(Field field) {
		ReflectionUtils.makeAccessible(field);
		Container<?> container = (Container<?>) ReflectionUtils.getField(field, null);
		Assert.state(container != null, () -> 'Container field "' + field.getName() + '" must not have a null value');
		return container;
	}
	private void registerBeanDefinition(BeanDefinitionRegistry registry, Field field, Container<?> container) {
		ContainerImageMetadata containerMetadata = new ContainerImageMetadata(container.getDockerImageName());
		TestcontainerFieldBeanDefinition beanDefinition = new TestcontainerFieldBeanDefinition(field, container);
		containerMetadata.addTo(beanDefinition);
		String beanName = generateBeanName(field);
		registry.registerBeanDefinition(beanName, beanDefinition);
	}
	private String generateBeanName(Field field) {
		return 'importTestContainer.%s.%s'.formatted(field.getDeclaringClass().getName(), field.getName());
	}
}
/*
package org.springframework.boot.testcontainers.context;
/**
class ImportTestcontainersRegistrar implements ImportBeanDefinitionRegistrar {
	private static final String DYNAMIC_PROPERTY_SOURCE_CLASS = 'org.springframework.test.context.DynamicPropertySource';
	private final ContainerFieldsImporter containerFieldsImporter;
	private final DynamicPropertySourceMethodsImporter dynamicPropertySourceMethodsImporter;
	ImportTestcontainersRegistrar(Environment environment) {
		this.containerFieldsImporter = new ContainerFieldsImporter();
		this.dynamicPropertySourceMethodsImporter = (!ClassUtils.isPresent(DYNAMIC_PROPERTY_SOURCE_CLASS, null)) ? null
				: new DynamicPropertySourceMethodsImporter();
	}
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		MergedAnnotation<ImportTestcontainers> annotation = importingClassMetadata.getAnnotations()
			.get(ImportTestcontainers.class);
		Class<?>[] definitionClasses = annotation.getClassArray(MergedAnnotation.VALUE);
		if (ObjectUtils.isEmpty(definitionClasses)) {
			Class<?> importingClass = ClassUtils.resolveClassName(importingClassMetadata.getClassName(), null);
			definitionClasses = new Class<?>[] { importingClass };
		}
		registerBeanDefinitions(registry, definitionClasses);
	}
	private void registerBeanDefinitions(BeanDefinitionRegistry registry, Class<?>[] definitionClasses) {
		for (Class<?> definitionClass : definitionClasses) {
			Set<Startable> importedContainers = this.containerFieldsImporter.registerBeanDefinitions(registry,
					definitionClass);
			if (this.dynamicPropertySourceMethodsImporter != null) {
				this.dynamicPropertySourceMethodsImporter.registerDynamicPropertySources(registry, definitionClass,
						importedContainers);
			}
		}
	}
}
/*
package org.springframework.boot.testcontainers.context;
/**
class TestcontainerFieldBeanDefinition extends RootBeanDefinition implements TestcontainerBeanDefinition {
	private final Container<?> container;
	private final MergedAnnotations annotations;
	TestcontainerFieldBeanDefinition(Field field, Container<?> container) {
		this.container = container;
		this.annotations = MergedAnnotations.from(field);
		this.setBeanClass(container.getClass());
		setInstanceSupplier(() -> container);
		setRole(ROLE_INFRASTRUCTURE);
	}
	@Override
	public String getContainerImageName() {
		return this.container.getDockerImageName();
	}
	@Override
	public MergedAnnotations getAnnotations() {
		return this.annotations;
	}
}
/*
package org.springframework.boot.testcontainers.context;
/**
class DynamicPropertySourceMethodsImporter {
	void registerDynamicPropertySources(BeanDefinitionRegistry beanDefinitionRegistry, Class<?> definitionClass,
			Set<Startable> importedContainers) {
		Set<Method> methods = MethodIntrospector.selectMethods(definitionClass, this::isAnnotated);
		if (methods.isEmpty()) {
			return;
		}
		methods.forEach((method) -> assertValid(method));
		RootBeanDefinition registrarDefinition = new RootBeanDefinition();
		registrarDefinition.setBeanClass(DynamicPropertySourcePropertyRegistrar.class);
		ConstructorArgumentValues arguments = new ConstructorArgumentValues();
		arguments.addGenericArgumentValue(methods);
		arguments.addGenericArgumentValue(importedContainers);
		registrarDefinition.setConstructorArgumentValues(arguments);
		beanDefinitionRegistry.registerBeanDefinition(definitionClass.getName() + '.dynamicPropertyRegistrar',
				registrarDefinition);
	}
	private boolean isAnnotated(Method method) {
		return MergedAnnotations.from(method).isPresent(DynamicPropertySource.class);
	}
	private void assertValid(Method method) {
		Assert.state(Modifier.isStatic(method.getModifiers()),
				() -> '@DynamicPropertySource method "' + method.getName() + '" must be static');
		Class<?>[] types = method.getParameterTypes();
		Assert.state(types.length == 1 && types[0] == DynamicPropertyRegistry.class,
				() -> '@DynamicPropertySource method "' + method.getName()
						+ '" must accept a single DynamicPropertyRegistry argument');
	}
	static class DynamicPropertySourcePropertyRegistrar implements DynamicPropertyRegistrar {
		private final Set<Method> methods;
		private final Set<Startable> containers;
		DynamicPropertySourcePropertyRegistrar(Set<Method> methods, Set<Startable> containers) {
			this.methods = methods;
			this.containers = containers;
		}
		@Override
		public void accept(DynamicPropertyRegistry registry) {
			DynamicPropertyRegistry containersBackedRegistry = new ContainersBackedDynamicPropertyRegistry(registry,
					this.containers);
			this.methods.forEach((method) -> {
				ReflectionUtils.makeAccessible(method);
				ReflectionUtils.invokeMethod(method, null, containersBackedRegistry);
			});
		}
	}
	static class ContainersBackedDynamicPropertyRegistry implements DynamicPropertyRegistry {
		private final DynamicPropertyRegistry delegate;
		private final Set<Startable> containers;
		ContainersBackedDynamicPropertyRegistry(DynamicPropertyRegistry delegate, Set<Startable> containers) {
			this.delegate = delegate;
			this.containers = containers;
		}
		@Override
		public void add(String name, Supplier<Object> valueSupplier) {
			this.delegate.add(name, () -> {
				startContainers();
				return valueSupplier.get();
			});
		}
		private void startContainers() {
			this.containers.forEach(Startable::start);
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.context;
/*
package org.springframework.boot.testcontainers.context;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(ImportTestcontainersRegistrar.class)
@ImportAutoConfiguration(TestcontainersPropertySourceAutoConfiguration.class)
public @interface ImportTestcontainers {
	/**
	 * The declaration classes to import. If no {@code value} is defined then the class
	 * that declares the {@link ImportTestcontainers @ImportTestcontainers} annotation
	 * will be searched.
	 * @return the definition classes to import
	 */
	Class<?>[] value() default {};
}
/*
package org.springframework.boot.testcontainers.properties;
/**
@SuppressWarnings('removal')
@Deprecated(since = '3.4.0', forRemoval = true)
public class TestcontainersPropertySource extends MapPropertySource {
	private static final Log logger = LogFactory.getLog(TestcontainersPropertySource.class);
	static final String NAME = 'testcontainersPropertySource';
	private final DynamicPropertyRegistry registry;
	private final Set<ApplicationEventPublisher> eventPublishers = new CopyOnWriteArraySet<>();
	TestcontainersPropertySource(DynamicPropertyRegistryInjection registryInjection) {
		this(Collections.synchronizedMap(new LinkedHashMap<>()), registryInjection);
	}
	private TestcontainersPropertySource(Map<String, Supplier<Object>> valueSuppliers,
			DynamicPropertyRegistryInjection registryInjection) {
		super(NAME, Collections.unmodifiableMap(valueSuppliers));
		this.registry = (name, valueSupplier) -> {
			Assert.hasText(name, '"name" must not be null or blank');
			DynamicPropertyRegistryInjectionException.throwIfNecessary(name, registryInjection);
			Assert.notNull(valueSupplier, '"valueSupplier" must not be null');
			valueSuppliers.put(name, valueSupplier);
		};
	}
	private void addEventPublisher(ApplicationEventPublisher eventPublisher) {
		this.eventPublishers.add(eventPublisher);
	}
	@Override
	public Object getProperty(String name) {
		Object valueSupplier = this.source.get(name);
		return (valueSupplier != null) ? getProperty(name, valueSupplier) : null;
	}
	private Object getProperty(String name, Object valueSupplier) {
		BeforeTestcontainerUsedEvent event = new BeforeTestcontainerUsedEvent(this);
		this.eventPublishers.forEach((eventPublisher) -> eventPublisher.publishEvent(event));
		return SupplierUtils.resolve(valueSupplier);
	}
	public static DynamicPropertyRegistry attach(Environment environment) {
		return attach(environment, null);
	}
	static DynamicPropertyRegistry attach(ConfigurableApplicationContext applicationContext) {
		return attach(applicationContext.getEnvironment(), applicationContext, null);
	}
	public static DynamicPropertyRegistry attach(Environment environment, BeanDefinitionRegistry registry) {
		return attach(environment, null, registry);
	}
	private static DynamicPropertyRegistry attach(Environment environment, ApplicationEventPublisher eventPublisher,
			BeanDefinitionRegistry registry) {
		Assert.state(environment instanceof ConfigurableEnvironment,
				'TestcontainersPropertySource can only be attached to a ConfigurableEnvironment');
		TestcontainersPropertySource propertySource = getOrAdd((ConfigurableEnvironment) environment);
		if (eventPublisher != null) {
			propertySource.addEventPublisher(eventPublisher);
		}
		else if (registry != null && !registry.containsBeanDefinition(EventPublisherRegistrar.NAME)) {
			registry.registerBeanDefinition(EventPublisherRegistrar.NAME, new RootBeanDefinition(
					EventPublisherRegistrar.class, () -> new EventPublisherRegistrar(environment)));
		}
		return propertySource.registry;
	}
	static TestcontainersPropertySource getOrAdd(ConfigurableEnvironment environment) {
		PropertySource<?> propertySource = environment.getPropertySources().get(NAME);
		if (propertySource == null) {
			BindResult<DynamicPropertyRegistryInjection> bindingResult = Binder.get(environment)
				.bind('spring.testcontainers.dynamic-property-registry-injection',
						DynamicPropertyRegistryInjection.class);
			environment.getPropertySources()
				.addFirst(
						new TestcontainersPropertySource(bindingResult.orElse(DynamicPropertyRegistryInjection.FAIL)));
			return getOrAdd(environment);
		}
		Assert.state(propertySource instanceof TestcontainersPropertySource,
				'Incorrect TestcontainersPropertySource type registered');
		return ((TestcontainersPropertySource) propertySource);
	}
	/**
	 * {@link BeanFactoryPostProcessor} to register the {@link ApplicationEventPublisher}
	 * to the {@link TestcontainersPropertySource}. This class is a
	 * {@link BeanFactoryPostProcessor} so that it is initialized as early as possible.
	 */
	static class EventPublisherRegistrar implements BeanFactoryPostProcessor, ApplicationEventPublisherAware {
		static final String NAME = EventPublisherRegistrar.class.getName();
		private final Environment environment;
		private ApplicationEventPublisher eventPublisher;
		EventPublisherRegistrar(Environment environment) {
			this.environment = environment;
		}
		@Override
		public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {
			this.eventPublisher = eventPublisher;
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
			if (this.eventPublisher != null) {
				TestcontainersPropertySource.getOrAdd((ConfigurableEnvironment) this.environment)
					.addEventPublisher(this.eventPublisher);
			}
		}
	}
	private enum DynamicPropertyRegistryInjection {
		ALLOW,
		FAIL,
		WARN
	}
	static final class DynamicPropertyRegistryInjectionException extends RuntimeException {
		private DynamicPropertyRegistryInjectionException(String propertyName) {
			super('Support for injecting a DynamicPropertyRegistry into @Bean methods is deprecated. Register "'
					+ propertyName + '" using a DynamicPropertyRegistrar bean instead. Alternatively, set '
					+ 'spring.testcontainers.dynamic-property-registry-injection to "warn" to replace this '
					+ 'failure with a warning or to "allow" to permit injection of the registry.');
		}
		private static void throwIfNecessary(String propertyName, DynamicPropertyRegistryInjection registryInjection) {
			switch (registryInjection) {
				case FAIL -> throw new DynamicPropertyRegistryInjectionException(propertyName);
				case WARN -> logger
					.warn('Support for injecting a DynamicPropertyRegistry into @Bean methods is deprecated. Register "'
							+ propertyName + '" using a DynamicPropertyRegistrar bean instead.');
			}
		}
	}
}
/*
package org.springframework.boot.testcontainers.properties;
/**
@AutoConfiguration
@Order(Ordered.HIGHEST_PRECEDENCE)
@ConditionalOnClass(DynamicPropertyRegistry.class)
public class TestcontainersPropertySourceAutoConfiguration {
	@Bean
	@SuppressWarnings('removal')
	@Deprecated(since = '3.4.0', forRemoval = true)
	static DynamicPropertyRegistry dynamicPropertyRegistry(ConfigurableApplicationContext applicationContext) {
		return TestcontainersPropertySource.attach(applicationContext);
	}
	@Bean
	@ConditionalOnMissingBean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	static DynamicPropertyRegistrarBeanInitializer dynamicPropertyRegistrarBeanInitializer() {
		return new DynamicPropertyRegistrarBeanInitializer();
	}
}
/*
/**
package org.springframework.boot.testcontainers.properties;
/*
package org.springframework.boot.testcontainers.service.connection;
/**
public final class ContainerConnectionSource<C extends Container<?>> implements OriginProvider {
	private static final Log logger = LogFactory.getLog(ContainerConnectionSource.class);
	private final String beanNameSuffix;
	private final Origin origin;
	private final Class<C> containerType;
	private final String containerImageName;
	private final String connectionName;
	private final Set<Class<?>> connectionDetailsTypes;
	private final Supplier<C> containerSupplier;
	ContainerConnectionSource(String beanNameSuffix, Origin origin, Class<C> containerType, String containerImageName,
			MergedAnnotation<ServiceConnection> annotation, Supplier<C> containerSupplier) {
		this.beanNameSuffix = beanNameSuffix;
		this.origin = origin;
		this.containerType = containerType;
		this.containerImageName = containerImageName;
		this.connectionName = getOrDeduceConnectionName(annotation.getString('name'), containerImageName);
		this.connectionDetailsTypes = Set.of(annotation.getClassArray('type'));
		this.containerSupplier = containerSupplier;
	}
	ContainerConnectionSource(String beanNameSuffix, Origin origin, Class<C> containerType, String containerImageName,
			ServiceConnection annotation, Supplier<C> containerSupplier) {
		this.beanNameSuffix = beanNameSuffix;
		this.origin = origin;
		this.containerType = containerType;
		this.containerImageName = containerImageName;
		this.connectionName = getOrDeduceConnectionName(annotation.name(), containerImageName);
		this.connectionDetailsTypes = Set.of(annotation.type());
		this.containerSupplier = containerSupplier;
	}
	private static String getOrDeduceConnectionName(String connectionName, String containerImageName) {
		if (StringUtils.hasText(connectionName)) {
			return connectionName;
		}
		if (StringUtils.hasText(containerImageName)) {
			DockerImageName imageName = DockerImageName.parse(containerImageName);
			imageName.assertValid();
			return imageName.getRepository();
		}
		return null;
	}
	/**
	 * Return if this source accepts the given connection.
	 * @param requiredConnectionName the required connection name or {@code null}
	 * @param requiredContainerType the required container type
	 * @param requiredConnectionDetailsType the required connection details type
	 * @return if the connection is accepted by this source
	 * @since 3.4.0
	 */
	public boolean accepts(String requiredConnectionName, Class<?> requiredContainerType,
			Class<?> requiredConnectionDetailsType) {
		if (StringUtils.hasText(requiredConnectionName)
				&& !requiredConnectionName.equalsIgnoreCase(this.connectionName)) {
			logger.trace(LogMessage
				.of(() -> '%s not accepted as source connection name "%s" does not match required connection name "%s"'
					.formatted(this, this.connectionName, requiredConnectionName)));
			return false;
		}
		if (!requiredContainerType.isAssignableFrom(this.containerType)) {
			logger.trace(LogMessage.of(() -> '%s not accepted as source container type %s is not assignable from %s'
				.formatted(this, this.containerType.getName(), requiredContainerType.getName())));
			return false;
		}
		if (!this.connectionDetailsTypes.isEmpty() && this.connectionDetailsTypes.stream()
			.noneMatch((candidate) -> candidate.isAssignableFrom(requiredConnectionDetailsType))) {
			logger.trace(LogMessage
				.of(() -> '%s not accepted as source connection details types %s has no element assignable from %s'
					.formatted(this, this.connectionDetailsTypes.stream().map(Class::getName).toList(),
							requiredConnectionDetailsType.getName())));
			return false;
		}
		logger.trace(
				LogMessage.of(() -> '%s accepted for connection name "%s" container type %s, connection details type %s'
					.formatted(this, requiredConnectionName, requiredContainerType.getName(),
							requiredConnectionDetailsType.getName())));
		return true;
	}
	String getBeanNameSuffix() {
		return this.beanNameSuffix;
	}
	@Override
	public Origin getOrigin() {
		return this.origin;
	}
	String getContainerImageName() {
		return this.containerImageName;
	}
	String getConnectionName() {
		return this.connectionName;
	}
	Supplier<C> getContainerSupplier() {
		return this.containerSupplier;
	}
	Set<Class<?>> getConnectionDetailsTypes() {
		return this.connectionDetailsTypes;
	}
	@Override
	public String toString() {
		return '@ServiceConnection source for %s'.formatted(this.origin);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ConnectionDetailsRegistrar {
	private static final Log logger = LogFactory.getLog(ConnectionDetailsRegistrar.class);
	private final ListableBeanFactory beanFactory;
	private final ConnectionDetailsFactories connectionDetailsFactories;
	ConnectionDetailsRegistrar(ListableBeanFactory beanFactory, ConnectionDetailsFactories connectionDetailsFactories) {
		this.beanFactory = beanFactory;
		this.connectionDetailsFactories = connectionDetailsFactories;
	}
	void registerBeanDefinitions(BeanDefinitionRegistry registry, Collection<ContainerConnectionSource<?>> sources) {
		sources.forEach((source) -> registerBeanDefinitions(registry, source));
	}
	void registerBeanDefinitions(BeanDefinitionRegistry registry, ContainerConnectionSource<?> source) {
		try {
			this.connectionDetailsFactories.getConnectionDetails(source, true)
				.forEach((connectionDetailsType, connectionDetails) -> registerBeanDefinition(registry, source,
						connectionDetailsType, connectionDetails));
		}
		catch (ConnectionDetailsFactoryNotFoundException ex) {
			rethrowConnectionDetails(source, ex, ConnectionDetailsFactoryNotFoundException::new);
		}
		catch (ConnectionDetailsNotFoundException ex) {
			rethrowConnectionDetails(source, ex, ConnectionDetailsNotFoundException::new);
		}
	}
	private void rethrowConnectionDetails(ContainerConnectionSource<?> source, RuntimeException ex,
			BiFunction<String, Throwable, RuntimeException> exceptionFactory) {
		if (!StringUtils.hasText(source.getConnectionName())) {
			StringBuilder message = new StringBuilder(ex.getMessage());
			message.append((!message.toString().endsWith('.')) ? '.' : '');
			message.append(' You may need to add a "name" to your @ServiceConnection annotation');
			throw exceptionFactory.apply(message.toString(), ex.getCause());
		}
		throw ex;
	}
	@SuppressWarnings('unchecked')
	private <T> void registerBeanDefinition(BeanDefinitionRegistry registry, ContainerConnectionSource<?> source,
			Class<?> connectionDetailsType, ConnectionDetails connectionDetails) {
		String[] existingBeans = this.beanFactory.getBeanNamesForType(connectionDetailsType);
		if (!ObjectUtils.isEmpty(existingBeans)) {
			logger.debug(LogMessage.of(() -> 'Skipping registration of %s due to existing beans %s'.formatted(source,
					Arrays.asList(existingBeans))));
			return;
		}
		ContainerImageMetadata containerMetadata = new ContainerImageMetadata(source.getContainerImageName());
		String beanName = getBeanName(source, connectionDetails);
		Class<T> beanType = (Class<T>) connectionDetails.getClass();
		Supplier<T> beanSupplier = () -> (T) connectionDetails;
		logger.debug(LogMessage.of(() -> 'Registering "%s" for %s'.formatted(beanName, source)));
		RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType, beanSupplier);
		beanDefinition.setAttribute(ServiceConnection.class.getName(), true);
		containerMetadata.addTo(beanDefinition);
		registry.registerBeanDefinition(beanName, beanDefinition);
	}
	private String getBeanName(ContainerConnectionSource<?> source, ConnectionDetails connectionDetails) {
		List<String> parts = new ArrayList<>();
		parts.add(ClassUtils.getShortNameAsProperty(connectionDetails.getClass()));
		parts.add('for');
		parts.add(source.getBeanNameSuffix());
		return StringUtils.uncapitalize(parts.stream().map(StringUtils::capitalize).collect(Collectors.joining()));
	}
	class ServiceConnectionBeanRegistrationExcludeFilter implements BeanRegistrationExcludeFilter {
		@Override
		public boolean isExcludedFromAotProcessing(RegisteredBean registeredBean) {
			return registeredBean.getMergedBeanDefinition().getAttribute(ServiceConnection.class.getName()) != null;
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
@AutoConfiguration
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Import(ServiceConnectionAutoConfigurationRegistrar.class)
public class ServiceConnectionAutoConfiguration {
	ServiceConnectionAutoConfiguration() {
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ServiceConnectionAutoConfigurationRegistrar implements ImportBeanDefinitionRegistrar {
	private final BeanFactory beanFactory;
	ServiceConnectionAutoConfigurationRegistrar(BeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		if (this.beanFactory instanceof ConfigurableListableBeanFactory listableBeanFactory) {
			registerBeanDefinitions(listableBeanFactory, registry);
		}
	}
	private void registerBeanDefinitions(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry) {
		ConnectionDetailsRegistrar registrar = new ConnectionDetailsRegistrar(beanFactory,
				new ConnectionDetailsFactories());
		for (String beanName : beanFactory.getBeanNamesForType(Container.class)) {
			BeanDefinition beanDefinition = getBeanDefinition(beanFactory, beanName);
			for (ServiceConnection annotation : getAnnotations(beanFactory, beanName, beanDefinition)) {
				ContainerConnectionSource<?> source = createSource(beanFactory, beanName, beanDefinition, annotation);
				registrar.registerBeanDefinitions(registry, source);
			}
		}
	}
	private Set<ServiceConnection> getAnnotations(ConfigurableListableBeanFactory beanFactory, String beanName,
			BeanDefinition beanDefinition) {
		Set<ServiceConnection> annotations = new LinkedHashSet<>(
				beanFactory.findAllAnnotationsOnBean(beanName, ServiceConnection.class, false));
		if (beanDefinition instanceof TestcontainerBeanDefinition testcontainerBeanDefinition) {
			testcontainerBeanDefinition.getAnnotations()
				.stream(ServiceConnection.class)
				.map(MergedAnnotation::synthesize)
				.forEach(annotations::add);
		}
		return annotations;
	}
	private BeanDefinition getBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName) {
		try {
			return beanFactory.getBeanDefinition(beanName);
		}
		catch (NoSuchBeanDefinitionException ex) {
			return null;
		}
	}
	@SuppressWarnings('unchecked')
	private <C extends Container<?>> ContainerConnectionSource<C> createSource(
			ConfigurableListableBeanFactory beanFactory, String beanName, BeanDefinition beanDefinition,
			ServiceConnection annotation) {
		Origin origin = new BeanOrigin(beanName, beanDefinition);
		Class<C> containerType = (Class<C>) beanFactory.getType(beanName, false);
		String containerImageName = (beanDefinition instanceof TestcontainerBeanDefinition testcontainerBeanDefinition)
				? testcontainerBeanDefinition.getContainerImageName() : null;
		return new ContainerConnectionSource<>(beanName, origin, containerType, containerImageName, annotation,
				() -> beanFactory.getBean(beanName, containerType));
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.jdbc;
/**
class JdbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<JdbcDatabaseContainer<?>, JdbcConnectionDetails> {
	@Override
	protected JdbcConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
		return new JdbcContainerConnectionDetails(source);
	}
	/**
	 * {@link JdbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class JdbcContainerConnectionDetails
			extends ContainerConnectionDetails<JdbcDatabaseContainer<?>> implements JdbcConnectionDetails {
		private JdbcContainerConnectionDetails(ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
			super(source);
		}
		@Override
		public String getUsername() {
			return getContainer().getUsername();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return getContainer().getJdbcUrl();
		}
		@Override
		public String getDriverClassName() {
			return getContainer().getDriverClassName();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.jdbc;
/*
package org.springframework.boot.testcontainers.service.connection.cassandra;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
class DeprecatedCassandraContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<CassandraContainer<?>, CassandraConnectionDetails> {
	@Override
	protected CassandraConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<CassandraContainer<?>> source) {
		return new CassandraContainerConnectionDetails(source);
	}
	/**
	 * {@link CassandraConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class CassandraContainerConnectionDetails
			extends ContainerConnectionDetails<CassandraContainer<?>> implements CassandraConnectionDetails {
		private CassandraContainerConnectionDetails(ContainerConnectionSource<CassandraContainer<?>> source) {
			super(source);
		}
		@Override
		public List<Node> getContactPoints() {
			InetSocketAddress contactPoint = getContainer().getContactPoint();
			return List.of(new Node(contactPoint.getHostString(), contactPoint.getPort()));
		}
		@Override
		public String getUsername() {
			return getContainer().getUsername();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
		@Override
		public String getLocalDatacenter() {
			return getContainer().getLocalDatacenter();
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.cassandra;
/**
class CassandraContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<CassandraContainer, CassandraConnectionDetails> {
	@Override
	protected CassandraConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<CassandraContainer> source) {
		return new CassandraContainerConnectionDetails(source);
	}
	/**
	 * {@link CassandraConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class CassandraContainerConnectionDetails
			extends ContainerConnectionDetails<CassandraContainer> implements CassandraConnectionDetails {
		private CassandraContainerConnectionDetails(ContainerConnectionSource<CassandraContainer> source) {
			super(source);
		}
		@Override
		public List<Node> getContactPoints() {
			InetSocketAddress contactPoint = getContainer().getContactPoint();
			return List.of(new Node(contactPoint.getHostString(), contactPoint.getPort()));
		}
		@Override
		public String getUsername() {
			return getContainer().getUsername();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
		@Override
		public String getLocalDatacenter() {
			return getContainer().getLocalDatacenter();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.cassandra;
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class BeanOrigin implements Origin {
	private final String beanName;
	private final String resourceDescription;
	BeanOrigin(String beanName, BeanDefinition beanDefinition) {
		this.beanName = beanName;
		this.resourceDescription = (beanDefinition != null) ? beanDefinition.getResourceDescription() : null;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		BeanOrigin other = (BeanOrigin) obj;
		return Objects.equals(this.beanName, other.beanName);
	}
	@Override
	public int hashCode() {
		return this.beanName.hashCode();
	}
	@Override
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append('Bean "');
		result.append(this.beanName);
		result.append('"');
		if (this.resourceDescription != null) {
			result.append(' defined in ');
			result.append(this.resourceDescription);
		}
		return result.toString();
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.zipkin;
/*
package org.springframework.boot.testcontainers.service.connection.zipkin;
/**
class ZipkinContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, ZipkinConnectionDetails> {
	private static final int ZIPKIN_PORT = 9411;
	ZipkinContainerConnectionDetailsFactory() {
		super('openzipkin/zipkin',
				'org.springframework.boot.actuate.autoconfigure.tracing.zipkin.ZipkinAutoConfiguration');
	}
	@Override
	protected ZipkinConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
		return new ZipkinContainerConnectionDetails(source);
	}
	/**
	 * {@link ZipkinConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static class ZipkinContainerConnectionDetails extends ContainerConnectionDetails<Container<?>>
			implements ZipkinConnectionDetails {
		ZipkinContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public String getSpanEndpoint() {
			return 'http://' + getContainer().getHost() + ':' + getContainer().getMappedPort(ZIPKIN_PORT)
					+ '/api/v2/spans';
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.couchbase;
/**
class CouchbaseContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<CouchbaseContainer, CouchbaseConnectionDetails> {
	@Override
	protected CouchbaseConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<CouchbaseContainer> source) {
		return new CouchbaseContainerConnectionDetails(source);
	}
	/**
	 * {@link CouchbaseConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class CouchbaseContainerConnectionDetails
			extends ContainerConnectionDetails<CouchbaseContainer> implements CouchbaseConnectionDetails {
		private CouchbaseContainerConnectionDetails(ContainerConnectionSource<CouchbaseContainer> source) {
			super(source);
		}
		@Override
		public String getUsername() {
			return getContainer().getUsername();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
		@Override
		public String getConnectionString() {
			return getContainer().getConnectionString();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.couchbase;
/*
package org.springframework.boot.testcontainers.service.connection.pulsar;
/**
class PulsarContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<PulsarContainer, PulsarConnectionDetails> {
	@Override
	protected PulsarConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<PulsarContainer> source) {
		return new PulsarContainerConnectionDetails(source);
	}
	/**
	 * {@link PulsarConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class PulsarContainerConnectionDetails extends ContainerConnectionDetails<PulsarContainer>
			implements PulsarConnectionDetails {
		private PulsarContainerConnectionDetails(ContainerConnectionSource<PulsarContainer> source) {
			super(source);
		}
		@Override
		public String getBrokerUrl() {
			return getContainer().getPulsarBrokerUrl();
		}
		@Override
		public String getAdminUrl() {
			return getContainer().getHttpServiceUrl();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.pulsar;
/*
package org.springframework.boot.testcontainers.service.connection.hazelcast;
/**
class HazelcastContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, HazelcastConnectionDetails> {
	private static final int DEFAULT_PORT = 5701;
	private static final String CLUSTER_NAME_ENV = 'HZ_CLUSTERNAME';
	HazelcastContainerConnectionDetailsFactory() {
		super('hazelcast/hazelcast', 'com.hazelcast.client.config.ClientConfig');
	}
	@Override
	protected HazelcastConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
		return new HazelcastContainerConnectionDetails(source);
	}
	/**
	 * {@link HazelcastConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class HazelcastContainerConnectionDetails extends ContainerConnectionDetails<Container<?>>
			implements HazelcastConnectionDetails {
		private HazelcastContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public ClientConfig getClientConfig() {
			ClientConfig config = new ClientConfig();
			Container<?> container = getContainer();
			Map<String, String> env = container.getEnvMap();
			String clusterName = env.get(CLUSTER_NAME_ENV);
			if (clusterName != null) {
				config.setClusterName(clusterName);
			}
			config.getNetworkConfig().addAddress(container.getHost() + ':' + container.getMappedPort(DEFAULT_PORT));
			return config;
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.hazelcast;
/*
package org.springframework.boot.testcontainers.service.connection;
/**
public abstract class ContainerConnectionDetailsFactory<C extends Container<?>, D extends ConnectionDetails>
		implements ConnectionDetailsFactory<ContainerConnectionSource<C>, D> {
	/**
	 * Constant passed to the constructor when any connection name is accepted.
	 */
	protected static final String ANY_CONNECTION_NAME = null;
	private final List<String> connectionNames;
	private final String[] requiredClassNames;
	/**
	 * Create a new {@link ContainerConnectionDetailsFactory} instance that accepts
	 * {@link #ANY_CONNECTION_NAME any connection name}.
	 */
	protected ContainerConnectionDetailsFactory() {
		this(ANY_CONNECTION_NAME);
	}
	/**
	 * Create a new {@link ContainerConnectionDetailsFactory} instance with the given
	 * connection name restriction.
	 * @param connectionName the required connection name or {@link #ANY_CONNECTION_NAME}
	 * @param requiredClassNames the names of classes that must be present
	 */
	protected ContainerConnectionDetailsFactory(String connectionName, String... requiredClassNames) {
		this(Arrays.asList(connectionName), requiredClassNames);
	}
	/**
	 * Create a new {@link ContainerConnectionDetailsFactory} instance with the given
	 * supported connection names.
	 * @param connectionNames the supported connection names
	 * @param requiredClassNames the names of classes that must be present
	 * @since 3.4.0
	 */
	protected ContainerConnectionDetailsFactory(List<String> connectionNames, String... requiredClassNames) {
		Assert.notEmpty(connectionNames, 'ConnectionNames must contain at least one name');
		this.connectionNames = connectionNames;
		this.requiredClassNames = requiredClassNames;
	}
	@Override
	public final D getConnectionDetails(ContainerConnectionSource<C> source) {
		if (!hasRequiredClasses()) {
			return null;
		}
		try {
			Class<?>[] generics = resolveGenerics();
			Class<?> requiredContainerType = generics[0];
			Class<?> requiredConnectionDetailsType = generics[1];
			if (sourceAccepts(source, requiredContainerType, requiredConnectionDetailsType)) {
				return getContainerConnectionDetails(source);
			}
		}
		catch (NoClassDefFoundError ex) {
			// Ignore
		}
		return null;
	}
	/**
	 * Return if the given source accepts the connection. By default this method checks
	 * each connection name.
	 * @param source the container connection source
	 * @param requiredContainerType the required container type
	 * @param requiredConnectionDetailsType the required connection details type
	 * @return if the source accepts the connection
	 * @since 3.4.0
	 */
	protected boolean sourceAccepts(ContainerConnectionSource<C> source, Class<?> requiredContainerType,
			Class<?> requiredConnectionDetailsType) {
		for (String requiredConnectionName : this.connectionNames) {
			if (source.accepts(requiredConnectionName, requiredContainerType, requiredConnectionDetailsType)) {
				return true;
			}
		}
		return false;
	}
	private boolean hasRequiredClasses() {
		return ObjectUtils.isEmpty(this.requiredClassNames) || Arrays.stream(this.requiredClassNames)
			.allMatch((requiredClassName) -> ClassUtils.isPresent(requiredClassName, null));
	}
	private Class<?>[] resolveGenerics() {
		return ResolvableType.forClass(ContainerConnectionDetailsFactory.class, getClass()).resolveGenerics();
	}
	/**
	 * Get the {@link ConnectionDetails} from the given {@link ContainerConnectionSource}
	 * {@code source}. May return {@code null} if no connection can be created. Result
	 * types should consider extending {@link ContainerConnectionDetails}.
	 * @param source the source
	 * @return the service connection or {@code null}.
	 */
	protected abstract D getContainerConnectionDetails(ContainerConnectionSource<C> source);
	/**
	 * Base class for {@link ConnectionDetails} results that are backed by a
	 * {@link ContainerConnectionSource}.
	 *
	 * @param <C> the container type
	 */
	protected static class ContainerConnectionDetails<C extends Container<?>>
			implements ConnectionDetails, OriginProvider, InitializingBean, ApplicationContextAware {
		private final ContainerConnectionSource<C> source;
		private volatile C container;
		/**
		 * Create a new {@link ContainerConnectionDetails} instance.
		 * @param source the source {@link ContainerConnectionSource}
		 */
		protected ContainerConnectionDetails(ContainerConnectionSource<C> source) {
			Assert.notNull(source, 'Source must not be null');
			this.source = source;
		}
		@Override
		public void afterPropertiesSet() throws Exception {
			this.container = this.source.getContainerSupplier().get();
		}
		/**
		 * Return the container that back this connection details instance. This method
		 * can only be called once the connection details bean has been initialized.
		 * @return the container instance
		 */
		protected final C getContainer() {
			Assert.state(this.container != null,
					'Container cannot be obtained before the connection details bean has been initialized');
			if (this.container instanceof Startable startable) {
				startable.start();
			}
			return this.container;
		}
		@Override
		public Origin getOrigin() {
			return this.source.getOrigin();
		}
		@Override
		@Deprecated(since = '3.4.0', forRemoval = true)
		public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		}
	}
	static class ContainerConnectionDetailsFactoriesRuntimeHints implements RuntimeHintsRegistrar {
		private static final Log logger = LogFactory.getLog(ContainerConnectionDetailsFactoriesRuntimeHints.class);
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			SpringFactoriesLoader.forDefaultResourceLocation(classLoader)
				.load(ConnectionDetailsFactory.class, FailureHandler.logging(logger))
				.stream()
				.flatMap(this::requiredClassNames)
				.forEach((requiredClassName) -> hints.reflection()
					.registerTypeIfPresent(classLoader, requiredClassName));
		}
		private Stream<String> requiredClassNames(ConnectionDetailsFactory<?, ?> connectionDetailsFactory) {
			return (connectionDetailsFactory instanceof ContainerConnectionDetailsFactory<?, ?> containerConnectionDetailsFactory)
					? Stream.of(containerConnectionDetailsFactory.requiredClassNames) : Stream.empty();
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class FieldOrigin implements Origin {
	private final Field field;
	FieldOrigin(Field field) {
		Assert.notNull(field, 'Field must not be null');
		this.field = field;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		FieldOrigin other = (FieldOrigin) obj;
		return this.field.equals(other.field);
	}
	@Override
	public int hashCode() {
		return this.field.hashCode();
	}
	@Override
	public String toString() {
		return ClassUtils.getShortName(this.field.getDeclaringClass()) + '.' + this.field.getName();
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.neo4j;
/**
class Neo4jContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Neo4jContainer<?>, Neo4jConnectionDetails> {
	Neo4jContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'org.neo4j.driver.AuthToken');
	}
	@Override
	protected Neo4jConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<Neo4jContainer<?>> source) {
		return new Neo4jContainerConnectionDetails(source);
	}
	/**
	 * {@link Neo4jConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class Neo4jContainerConnectionDetails extends ContainerConnectionDetails<Neo4jContainer<?>>
			implements Neo4jConnectionDetails {
		private Neo4jContainerConnectionDetails(ContainerConnectionSource<Neo4jContainer<?>> source) {
			super(source);
		}
		@Override
		public URI getUri() {
			return URI.create(getContainer().getBoltUrl());
		}
		@Override
		public AuthToken getAuthToken() {
			String password = getContainer().getAdminPassword();
			return (password != null) ? AuthTokens.basic('neo4j', password) : AuthTokens.none();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.neo4j;
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
class OpenTelemetryLoggingContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, OtlpLoggingConnectionDetails> {
	private static final int OTLP_GRPC_PORT = 4317;
	private static final int OTLP_HTTP_PORT = 4318;
	OpenTelemetryLoggingContainerConnectionDetailsFactory() {
		super('otel/opentelemetry-collector-contrib',
				'org.springframework.boot.actuate.autoconfigure.logging.otlp.OtlpLoggingAutoConfiguration');
	}
	@Override
	protected OtlpLoggingConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<Container<?>> source) {
		return new OpenTelemetryLoggingContainerConnectionDetails(source);
	}
	private static final class OpenTelemetryLoggingContainerConnectionDetails
			extends ContainerConnectionDetails<Container<?>> implements OtlpLoggingConnectionDetails {
		private OpenTelemetryLoggingContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public String getUrl(Transport transport) {
			int port = switch (transport) {
				case HTTP -> OTLP_HTTP_PORT;
				case GRPC -> OTLP_GRPC_PORT;
			};
			return 'http://%s:%d/v1/logs'.formatted(getContainer().getHost(), getContainer().getMappedPort(port));
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
class GrafanaOpenTelemetryLoggingContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<LgtmStackContainer, OtlpLoggingConnectionDetails> {
	GrafanaOpenTelemetryLoggingContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME,
				'org.springframework.boot.actuate.autoconfigure.logging.otlp.OtlpLoggingAutoConfiguration');
	}
	@Override
	protected OtlpLoggingConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<LgtmStackContainer> source) {
		return new OpenTelemetryLoggingContainerConnectionDetails(source);
	}
	private static final class OpenTelemetryLoggingContainerConnectionDetails
			extends ContainerConnectionDetails<LgtmStackContainer> implements OtlpLoggingConnectionDetails {
		private OpenTelemetryLoggingContainerConnectionDetails(ContainerConnectionSource<LgtmStackContainer> source) {
			super(source);
		}
		@Override
		public String getUrl(Transport transport) {
			String url = switch (transport) {
				case HTTP -> getContainer().getOtlpHttpUrl();
				case GRPC -> getContainer().getOtlpGrpcUrl();
			};
			return '%s/v1/logs'.formatted(url);
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
class GrafanaOpenTelemetryMetricsContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<LgtmStackContainer, OtlpMetricsConnectionDetails> {
	GrafanaOpenTelemetryMetricsContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME,
				'org.springframework.boot.actuate.autoconfigure.metrics.export.otlp.OtlpMetricsExportAutoConfiguration');
	}
	@Override
	protected OtlpMetricsConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<LgtmStackContainer> source) {
		return new OpenTelemetryMetricsContainerConnectionDetails(source);
	}
	private static final class OpenTelemetryMetricsContainerConnectionDetails
			extends ContainerConnectionDetails<LgtmStackContainer> implements OtlpMetricsConnectionDetails {
		private OpenTelemetryMetricsContainerConnectionDetails(ContainerConnectionSource<LgtmStackContainer> source) {
			super(source);
		}
		@Override
		public String getUrl() {
			return '%s/v1/metrics'.formatted(getContainer().getOtlpHttpUrl());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
class OpenTelemetryMetricsContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, OtlpMetricsConnectionDetails> {
	OpenTelemetryMetricsContainerConnectionDetailsFactory() {
		super('otel/opentelemetry-collector-contrib',
				'org.springframework.boot.actuate.autoconfigure.metrics.export.otlp.OtlpMetricsExportAutoConfiguration');
	}
	@Override
	protected OtlpMetricsConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<Container<?>> source) {
		return new OpenTelemetryMetricsContainerConnectionDetails(source);
	}
	private static final class OpenTelemetryMetricsContainerConnectionDetails
			extends ContainerConnectionDetails<Container<?>> implements OtlpMetricsConnectionDetails {
		private OpenTelemetryMetricsContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public String getUrl() {
			return 'http://%s:%d/v1/metrics'.formatted(getContainer().getHost(), getContainer().getMappedPort(4318));
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
class GrafanaOpenTelemetryTracingContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<LgtmStackContainer, OtlpTracingConnectionDetails> {
	GrafanaOpenTelemetryTracingContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME,
				'org.springframework.boot.actuate.autoconfigure.tracing.otlp.OtlpTracingAutoConfiguration');
	}
	@Override
	protected OtlpTracingConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<LgtmStackContainer> source) {
		return new OpenTelemetryTracingContainerConnectionDetails(source);
	}
	private static final class OpenTelemetryTracingContainerConnectionDetails
			extends ContainerConnectionDetails<LgtmStackContainer> implements OtlpTracingConnectionDetails {
		private OpenTelemetryTracingContainerConnectionDetails(ContainerConnectionSource<LgtmStackContainer> source) {
			super(source);
		}
		@Override
		public String getUrl(Transport transport) {
			String url = switch (transport) {
				case HTTP -> getContainer().getOtlpHttpUrl();
				case GRPC -> getContainer().getOtlpGrpcUrl();
			};
			return '%s/v1/traces'.formatted(url);
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.otlp;
/*
package org.springframework.boot.testcontainers.service.connection.otlp;
/**
class OpenTelemetryTracingContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, OtlpTracingConnectionDetails> {
	private static final int OTLP_GRPC_PORT = 4317;
	private static final int OTLP_HTTP_PORT = 4318;
	OpenTelemetryTracingContainerConnectionDetailsFactory() {
		super('otel/opentelemetry-collector-contrib',
				'org.springframework.boot.actuate.autoconfigure.tracing.otlp.OtlpTracingAutoConfiguration');
	}
	@Override
	protected OtlpTracingConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<Container<?>> source) {
		return new OpenTelemetryTracingContainerConnectionDetails(source);
	}
	private static final class OpenTelemetryTracingContainerConnectionDetails
			extends ContainerConnectionDetails<Container<?>> implements OtlpTracingConnectionDetails {
		private OpenTelemetryTracingContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public String getUrl(Transport transport) {
			int port = switch (transport) {
				case HTTP -> OTLP_HTTP_PORT;
				case GRPC -> OTLP_GRPC_PORT;
			};
			return 'http://%s:%d/v1/traces'.formatted(getContainer().getHost(), getContainer().getMappedPort(port));
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ServiceConnectionContextCustomizer implements ContextCustomizer {
	private final List<ContainerConnectionSource<?>> sources;
	private final Set<CacheKey> keys;
	private final ConnectionDetailsFactories connectionDetailsFactories;
	ServiceConnectionContextCustomizer(List<ContainerConnectionSource<?>> sources) {
		this(sources, new ConnectionDetailsFactories());
	}
	ServiceConnectionContextCustomizer(List<ContainerConnectionSource<?>> sources,
			ConnectionDetailsFactories connectionDetailsFactories) {
		this.sources = sources;
		this.keys = sources.stream().map(CacheKey::new).collect(Collectors.toUnmodifiableSet());
		this.connectionDetailsFactories = connectionDetailsFactories;
	}
	@Override
	public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedConfig) {
		new TestcontainersLifecycleApplicationContextInitializer().initialize(context);
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		if (beanFactory instanceof BeanDefinitionRegistry registry) {
			new ConnectionDetailsRegistrar(beanFactory, this.connectionDetailsFactories)
				.registerBeanDefinitions(registry, this.sources);
		}
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.keys.equals(((ServiceConnectionContextCustomizer) obj).keys);
	}
	@Override
	public int hashCode() {
		return this.keys.hashCode();
	}
	List<ContainerConnectionSource<?>> getSources() {
		return this.sources;
	}
	/**
	 * Relevant details from {@link ContainerConnectionSource} used as a
	 * MergedContextConfiguration cache key.
	 */
	private record CacheKey(String connectionName, Set<Class<?>> connectionDetailsTypes, Container<?> container) {
		CacheKey(ContainerConnectionSource<?> source) {
			this(source.getConnectionName(), source.getConnectionDetailsTypes(), source.getContainerSupplier().get());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.amqp;
/**
class RabbitContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<RabbitMQContainer, RabbitConnectionDetails> {
	@Override
	protected RabbitConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<RabbitMQContainer> source) {
		return new RabbitMqContainerConnectionDetails(source);
	}
	/**
	 * {@link RabbitConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class RabbitMqContainerConnectionDetails extends ContainerConnectionDetails<RabbitMQContainer>
			implements RabbitConnectionDetails {
		private RabbitMqContainerConnectionDetails(ContainerConnectionSource<RabbitMQContainer> source) {
			super(source);
		}
		@Override
		public String getUsername() {
			return getContainer().getAdminUsername();
		}
		@Override
		public String getPassword() {
			return getContainer().getAdminPassword();
		}
		@Override
		public List<Address> getAddresses() {
			URI uri = URI.create(getContainer().getAmqpUrl());
			return List.of(new Address(uri.getHost(), uri.getPort()));
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.amqp;
/*
package org.springframework.boot.testcontainers.service.connection.kafka;
/**
class ApacheKafkaContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<KafkaContainer, KafkaConnectionDetails> {
	@Override
	protected KafkaConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<KafkaContainer> source) {
		return new ApacheKafkaContainerConnectionDetails(source);
	}
	/**
	 * {@link KafkaConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class ApacheKafkaContainerConnectionDetails extends ContainerConnectionDetails<KafkaContainer>
			implements KafkaConnectionDetails {
		private ApacheKafkaContainerConnectionDetails(ContainerConnectionSource<KafkaContainer> source) {
			super(source);
		}
		@Override
		public List<String> getBootstrapServers() {
			return List.of(getContainer().getBootstrapServers());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.kafka;
/**
class ConfluentKafkaContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<ConfluentKafkaContainer, KafkaConnectionDetails> {
	@Override
	protected KafkaConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<ConfluentKafkaContainer> source) {
		return new ConfluentKafkaContainerConnectionDetails(source);
	}
	/**
	 * {@link KafkaConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class ConfluentKafkaContainerConnectionDetails
			extends ContainerConnectionDetails<ConfluentKafkaContainer> implements KafkaConnectionDetails {
		private ConfluentKafkaContainerConnectionDetails(ContainerConnectionSource<ConfluentKafkaContainer> source) {
			super(source);
		}
		@Override
		public List<String> getBootstrapServers() {
			return List.of(getContainer().getBootstrapServers());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.kafka;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
class DeprecatedConfluentKafkaContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<KafkaContainer, KafkaConnectionDetails> {
	@Override
	protected KafkaConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<KafkaContainer> source) {
		return new ConfluentKafkaContainerConnectionDetails(source);
	}
	/**
	 * {@link KafkaConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class ConfluentKafkaContainerConnectionDetails
			extends ContainerConnectionDetails<KafkaContainer> implements KafkaConnectionDetails {
		private ConfluentKafkaContainerConnectionDetails(ContainerConnectionSource<KafkaContainer> source) {
			super(source);
		}
		@Override
		public List<String> getBootstrapServers() {
			return List.of(getContainer().getBootstrapServers());
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.kafka;
/*
/**
package org.springframework.boot.testcontainers.service.connection.elasticsearch;
/*
package org.springframework.boot.testcontainers.service.connection.elasticsearch;
/**
class ElasticsearchContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<ElasticsearchContainer, ElasticsearchConnectionDetails> {
	private static final int DEFAULT_PORT = 9200;
	@Override
	protected ElasticsearchConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<ElasticsearchContainer> source) {
		return new ElasticsearchContainerConnectionDetails(source);
	}
	/**
	 * {@link ElasticsearchConnectionDetails} backed by a
	 * {@link ContainerConnectionSource}.
	 */
	private static final class ElasticsearchContainerConnectionDetails
			extends ContainerConnectionDetails<ElasticsearchContainer> implements ElasticsearchConnectionDetails {
		private ElasticsearchContainerConnectionDetails(ContainerConnectionSource<ElasticsearchContainer> source) {
			super(source);
		}
		@Override
		public List<Node> getNodes() {
			String host = getContainer().getHost();
			Integer port = getContainer().getMappedPort(DEFAULT_PORT);
			return List.of(new Node(host, port, Protocol.HTTP, null, null));
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.ANNOTATION_TYPE })
public @interface ServiceConnection {
	/**
	 * The name of the service being connected to. Container names are used to determine
	 * the connection details that should be created when a technology-specific
	 * {@link Container} subclass is not available.
	 * <p>
	 * If not specified, and if the {@link Container} instance is available, the
	 * {@link DockerImageName#getRepository() repository} part of the
	 * {@link Container#getDockerImageName() docker image name} will be used. Note that
	 * {@link Container} instances are <em>not</em> available early enough when the
	 * container is defined as a {@link Bean @Bean} method. All
	 * {@link ServiceConnection @ServiceConnection} {@link Bean @Bean} methods that need
	 * to match on the connection name <em>must</em> declare this attribute.
	 * <p>
	 * This attribute is an alias for {@link #name()}.
	 * @return the name of the service
	 * @see #name()
	 */
	@AliasFor('name')
	String value() default '';
	/**
	 * The name of the service being connected to. Container names are used to determine
	 * the connection details that should be created when a technology-specific
	 * {@link Container} subclass is not available.
	 * <p>
	 * If not specified, and if the {@link Container} instance is available, the
	 * {@link DockerImageName#getRepository() repository} part of the
	 * {@link Container#getDockerImageName() docker image name} will be used. Note that
	 * {@link Container} instances are <em>not</em> available early enough when the
	 * container is defined as a {@link Bean @Bean} method. All
	 * {@link ServiceConnection @ServiceConnection} {@link Bean @Bean} methods that need
	 * to match on the connection name <em>must</em> declare this attribute.
	 * <p>
	 * This attribute is an alias for {@link #value()}.
	 * @return the name of the service
	 * @see #value()
	 */
	@AliasFor('value')
	String name() default '';
	/**
	 * A restriction to types of {@link ConnectionDetails} that can be created from this
	 * connection. The default value does not restrict the types that can be created.
	 * @return the connection detail types that can be created to establish the connection
	 */
	Class<? extends ConnectionDetails>[] type() default {};
}
/*
package org.springframework.boot.testcontainers.service.connection.redis;
/**
class RedisContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, RedisConnectionDetails> {
	private static final List<String> REDIS_IMAGE_NAMES = List.of('redis', 'bitnami/redis', 'redis/redis-stack',
			'redis/redis-stack-server');
	private static final int REDIS_PORT = 6379;
	RedisContainerConnectionDetailsFactory() {
		super(REDIS_IMAGE_NAMES);
	}
	@Override
	protected boolean sourceAccepts(ContainerConnectionSource<Container<?>> source, Class<?> requiredContainerType,
			Class<?> requiredConnectionDetailsType) {
		return super.sourceAccepts(source, requiredContainerType, requiredConnectionDetailsType)
				|| source.accepts(ANY_CONNECTION_NAME, RedisContainer.class, requiredConnectionDetailsType)
				|| source.accepts(ANY_CONNECTION_NAME, RedisStackContainer.class, requiredConnectionDetailsType);
	}
	@Override
	protected RedisConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
		return new RedisContainerConnectionDetails(source);
	}
	/**
	 * {@link RedisConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class RedisContainerConnectionDetails extends ContainerConnectionDetails<Container<?>>
			implements RedisConnectionDetails {
		private RedisContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public Standalone getStandalone() {
			return Standalone.of(getContainer().getHost(), getContainer().getMappedPort(REDIS_PORT));
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.redis;
/*
package org.springframework.boot.testcontainers.service.connection;
/**
class ServiceConnectionContextCustomizerFactory implements ContextCustomizerFactory {
	@Override
	public ContextCustomizer createContextCustomizer(Class<?> testClass,
			List<ContextConfigurationAttributes> configAttributes) {
		List<ContainerConnectionSource<?>> sources = new ArrayList<>();
		collectSources(testClass, sources);
		return new ServiceConnectionContextCustomizer(sources);
	}
	private void collectSources(Class<?> candidate, List<ContainerConnectionSource<?>> sources) {
		if (candidate == Object.class || candidate == null) {
			return;
		}
		ReflectionUtils.doWithLocalFields(candidate, (field) -> {
			MergedAnnotations annotations = MergedAnnotations.from(field);
			annotations.stream(ServiceConnection.class)
				.forEach((annotation) -> sources.add(createSource(field, annotation)));
		});
		if (TestContextAnnotationUtils.searchEnclosingClass(candidate)) {
			collectSources(candidate.getEnclosingClass(), sources);
		}
		for (Class<?> implementedInterface : candidate.getInterfaces()) {
			collectSources(implementedInterface, sources);
		}
		collectSources(candidate.getSuperclass(), sources);
	}
	@SuppressWarnings('unchecked')
	private <C extends Container<?>> ContainerConnectionSource<?> createSource(Field field,
			MergedAnnotation<ServiceConnection> annotation) {
		Assert.state(Modifier.isStatic(field.getModifiers()),
				() -> '@ServiceConnection field "%s" must be static'.formatted(field.getName()));
		Origin origin = new FieldOrigin(field);
		Object fieldValue = getFieldValue(field);
		Assert.state(fieldValue instanceof Container, () -> 'Field "%s" in %s must be a %s'.formatted(field.getName(),
				field.getDeclaringClass().getName(), Container.class.getName()));
		Class<C> containerType = (Class<C>) fieldValue.getClass();
		C container = (C) fieldValue;
		// container.getDockerImageName() fails if there is no running docker environment
		// When running tests that doesn"t matter, but running AOT processing should be
		// possible without a Docker environment
		String dockerImageName = isAotProcessingInProgress() ? null : container.getDockerImageName();
		return new ContainerConnectionSource<>('test', origin, containerType, dockerImageName, annotation,
				() -> container);
	}
	private Object getFieldValue(Field field) {
		ReflectionUtils.makeAccessible(field);
		return ReflectionUtils.getField(field, null);
	}
	private boolean isAotProcessingInProgress() {
		return Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING);
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class ClickHouseR2dbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<ClickHouseContainer, R2dbcConnectionDetails> {
	ClickHouseR2dbcContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	public R2dbcConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<ClickHouseContainer> source) {
		return new ClickHouseR2dbcDatabaseContainerConnectionDetails(source);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class ClickHouseR2dbcDatabaseContainerConnectionDetails
			extends ContainerConnectionDetails<ClickHouseContainer> implements R2dbcConnectionDetails {
		private ClickHouseR2dbcDatabaseContainerConnectionDetails(
				ContainerConnectionSource<ClickHouseContainer> source) {
			super(source);
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return ClickHouseR2DBCDatabaseContainer.getOptions(getContainer());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class MySqlR2dbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<MySQLContainer<?>, R2dbcConnectionDetails> {
	MySqlR2dbcContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	public R2dbcConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<MySQLContainer<?>> source) {
		return new MySqlR2dbcDatabaseContainerConnectionDetails(source);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class MySqlR2dbcDatabaseContainerConnectionDetails
			extends ContainerConnectionDetails<MySQLContainer<?>> implements R2dbcConnectionDetails {
		private MySqlR2dbcDatabaseContainerConnectionDetails(ContainerConnectionSource<MySQLContainer<?>> source) {
			super(source);
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return MySQLR2DBCDatabaseContainer.getOptions(getContainer());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class MariaDbR2dbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<MariaDBContainer<?>, R2dbcConnectionDetails> {
	MariaDbR2dbcContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	public R2dbcConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<MariaDBContainer<?>> source) {
		return new MariaDbR2dbcDatabaseContainerConnectionDetails(source);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class MariaDbR2dbcDatabaseContainerConnectionDetails
			extends ContainerConnectionDetails<MariaDBContainer<?>> implements R2dbcConnectionDetails {
		private MariaDbR2dbcDatabaseContainerConnectionDetails(ContainerConnectionSource<MariaDBContainer<?>> source) {
			super(source);
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return MariaDBR2DBCDatabaseContainer.getOptions(getContainer());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class OracleFreeR2dbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<OracleContainer, R2dbcConnectionDetails> {
	OracleFreeR2dbcContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	public R2dbcConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<OracleContainer> source) {
		return new R2dbcDatabaseContainerConnectionDetails(source);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class R2dbcDatabaseContainerConnectionDetails
			extends ContainerConnectionDetails<OracleContainer> implements R2dbcConnectionDetails {
		private R2dbcDatabaseContainerConnectionDetails(ContainerConnectionSource<OracleContainer> source) {
			super(source);
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return OracleR2DBCDatabaseContainer.getOptions(getContainer());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class OracleXeR2dbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<OracleContainer, R2dbcConnectionDetails> {
	OracleXeR2dbcContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	public R2dbcConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<OracleContainer> source) {
		return new R2dbcDatabaseContainerConnectionDetails(source);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class R2dbcDatabaseContainerConnectionDetails
			extends ContainerConnectionDetails<OracleContainer> implements R2dbcConnectionDetails {
		private R2dbcDatabaseContainerConnectionDetails(ContainerConnectionSource<OracleContainer> source) {
			super(source);
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return OracleR2DBCDatabaseContainer.getOptions(getContainer());
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class PostgresR2dbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<PostgreSQLContainer<?>, R2dbcConnectionDetails> {
	PostgresR2dbcContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	public R2dbcConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<PostgreSQLContainer<?>> source) {
		return new PostgresR2dbcDatabaseContainerConnectionDetails(source);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class PostgresR2dbcDatabaseContainerConnectionDetails
			extends ContainerConnectionDetails<PostgreSQLContainer<?>> implements R2dbcConnectionDetails {
		PostgresR2dbcDatabaseContainerConnectionDetails(ContainerConnectionSource<PostgreSQLContainer<?>> source) {
			super(source);
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return PostgreSQLR2DBCDatabaseContainer.getOptions(getContainer());
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/*
package org.springframework.boot.testcontainers.service.connection.r2dbc;
/**
class SqlServerR2dbcContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<MSSQLServerContainer<?>, R2dbcConnectionDetails> {
	SqlServerR2dbcContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'io.r2dbc.spi.ConnectionFactoryOptions');
	}
	@Override
	public R2dbcConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<MSSQLServerContainer<?>> source) {
		return new MsSqlServerR2dbcDatabaseContainerConnectionDetails(source);
	}
	/**
	 * {@link R2dbcConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class MsSqlServerR2dbcDatabaseContainerConnectionDetails
			extends ContainerConnectionDetails<MSSQLServerContainer<?>> implements R2dbcConnectionDetails {
		private MsSqlServerR2dbcDatabaseContainerConnectionDetails(
				ContainerConnectionSource<MSSQLServerContainer<?>> source) {
			super(source);
		}
		@Override
		public ConnectionFactoryOptions getConnectionFactoryOptions() {
			return MSSQLR2DBCDatabaseContainer.getOptions(getContainer());
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection;
/*
package org.springframework.boot.testcontainers.service.connection.liquibase;
/**
class LiquibaseContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<JdbcDatabaseContainer<?>, LiquibaseConnectionDetails> {
	@Override
	protected LiquibaseConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
		return new LiquibaseContainerConnectionDetails(source);
	}
	/**
	 * {@link LiquibaseConnectionDetails} backed by a {@link JdbcDatabaseContainer}.
	 */
	private static final class LiquibaseContainerConnectionDetails
			extends ContainerConnectionDetails<JdbcDatabaseContainer<?>> implements LiquibaseConnectionDetails {
		private LiquibaseContainerConnectionDetails(ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
			super(source);
		}
		@Override
		public String getUsername() {
			return getContainer().getUsername();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return getContainer().getJdbcUrl();
		}
		@Override
		public String getDriverClassName() {
			return getContainer().getDriverClassName();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.liquibase;
/*
package org.springframework.boot.testcontainers.service.connection.flyway;
/**
class FlywayContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<JdbcDatabaseContainer<?>, FlywayConnectionDetails> {
	@Override
	protected FlywayConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
		return new FlywayContainerConnectionDetails(source);
	}
	/**
	 * {@link FlywayConnectionDetails} backed by a {@link JdbcDatabaseContainer}.
	 */
	private static final class FlywayContainerConnectionDetails
			extends ContainerConnectionDetails<JdbcDatabaseContainer<?>> implements FlywayConnectionDetails {
		private FlywayContainerConnectionDetails(ContainerConnectionSource<JdbcDatabaseContainer<?>> source) {
			super(source);
		}
		@Override
		public String getUsername() {
			return getContainer().getUsername();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
		@Override
		public String getJdbcUrl() {
			return getContainer().getJdbcUrl();
		}
		@Override
		public String getDriverClassName() {
			return getContainer().getDriverClassName();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.flyway;
/*
/**
package org.springframework.boot.testcontainers.service.connection.ldap;
/*
package org.springframework.boot.testcontainers.service.connection.ldap;
/**
class OpenLdapContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, LdapConnectionDetails> {
	OpenLdapContainerConnectionDetailsFactory() {
		super('osixia/openldap');
	}
	@Override
	protected LdapConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
		return new OpenLdapContainerConnectionDetails(source);
	}
	private static final class OpenLdapContainerConnectionDetails extends ContainerConnectionDetails<Container<?>>
			implements LdapConnectionDetails {
		private OpenLdapContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public String[] getUrls() {
			Map<String, String> env = getContainer().getEnvMap();
			boolean usesTls = Boolean.parseBoolean(env.getOrDefault('LDAP_TLS', 'true'));
			String ldapPort = usesTls ? env.getOrDefault('LDAPS_PORT', '636') : env.getOrDefault('LDAP_PORT', '389');
			return new String[] { '%s://%s:%d'.formatted(usesTls ? 'ldaps' : 'ldap', getContainer().getHost(),
					getContainer().getMappedPort(Integer.parseInt(ldapPort))) };
		}
		@Override
		public String getBase() {
			Map<String, String> env = getContainer().getEnvMap();
			if (env.containsKey('LDAP_BASE_DN')) {
				return env.get('LDAP_BASE_DN');
			}
			return Arrays.stream(env.getOrDefault('LDAP_DOMAIN', 'example.org').split('\\.'))
				.map('dc=%s'::formatted)
				.collect(Collectors.joining(','));
		}
		@Override
		public String getUsername() {
			return 'cn=admin,%s'.formatted(getBase());
		}
		@Override
		public String getPassword() {
			return getContainer().getEnvMap().getOrDefault('LDAP_ADMIN_PASSWORD', 'admin');
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.mongo;
/**
class MongoContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<MongoDBContainer, MongoConnectionDetails> {
	MongoContainerConnectionDetailsFactory() {
		super(ANY_CONNECTION_NAME, 'com.mongodb.ConnectionString');
	}
	@Override
	protected MongoConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<MongoDBContainer> source) {
		return new MongoContainerConnectionDetails(source);
	}
	/**
	 * {@link MongoConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class MongoContainerConnectionDetails extends ContainerConnectionDetails<MongoDBContainer>
			implements MongoConnectionDetails {
		private MongoContainerConnectionDetails(ContainerConnectionSource<MongoDBContainer> source) {
			super(source);
		}
		@Override
		public ConnectionString getConnectionString() {
			return new ConnectionString(getContainer().getReplicaSetUrl());
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.mongo;
/*
package org.springframework.boot.testcontainers.service.connection.activemq;
/**
class ActiveMQContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<Container<?>, ActiveMQConnectionDetails> {
	ActiveMQContainerConnectionDetailsFactory() {
		super('symptoma/activemq');
	}
	@Override
	protected ActiveMQConnectionDetails getContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
		return new ActiveMQContainerConnectionDetails(source);
	}
	private static final class ActiveMQContainerConnectionDetails extends ContainerConnectionDetails<Container<?>>
			implements ActiveMQConnectionDetails {
		private ActiveMQContainerConnectionDetails(ContainerConnectionSource<Container<?>> source) {
			super(source);
		}
		@Override
		public String getBrokerUrl() {
			return 'tcp://' + getContainer().getHost() + ':' + getContainer().getFirstMappedPort();
		}
		@Override
		public String getUser() {
			return getContainer().getEnvMap().get('ACTIVEMQ_USERNAME');
		}
		@Override
		public String getPassword() {
			return getContainer().getEnvMap().get('ACTIVEMQ_PASSWORD');
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.activemq;
/**
class ActiveMQClassicContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<ActiveMQContainer, ActiveMQConnectionDetails> {
	@Override
	protected ActiveMQConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<ActiveMQContainer> source) {
		return new ActiveMQContainerConnectionDetails(source);
	}
	private static final class ActiveMQContainerConnectionDetails extends ContainerConnectionDetails<ActiveMQContainer>
			implements ActiveMQConnectionDetails {
		private ActiveMQContainerConnectionDetails(ContainerConnectionSource<ActiveMQContainer> source) {
			super(source);
		}
		@Override
		public String getBrokerUrl() {
			return getContainer().getBrokerUrl();
		}
		@Override
		public String getUser() {
			return getContainer().getUser();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.activemq;
/*
package org.springframework.boot.testcontainers.service.connection.activemq;
/**
class ArtemisContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<ArtemisContainer, ArtemisConnectionDetails> {
	@Override
	protected ArtemisConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<ArtemisContainer> source) {
		return new ArtemisContainerConnectionDetails(source);
	}
	private static final class ArtemisContainerConnectionDetails extends ContainerConnectionDetails<ArtemisContainer>
			implements ArtemisConnectionDetails {
		private ArtemisContainerConnectionDetails(ContainerConnectionSource<ArtemisContainer> source) {
			super(source);
		}
		@Override
		public ArtemisMode getMode() {
			return ArtemisMode.NATIVE;
		}
		@Override
		public String getBrokerUrl() {
			return getContainer().getBrokerUrl();
		}
		@Override
		public String getUser() {
			return getContainer().getUser();
		}
		@Override
		public String getPassword() {
			return getContainer().getPassword();
		}
	}
}
/*
package org.springframework.boot.testcontainers.service.connection.redpanda;
/**
class RedpandaContainerConnectionDetailsFactory
		extends ContainerConnectionDetailsFactory<RedpandaContainer, KafkaConnectionDetails> {
	@Override
	protected KafkaConnectionDetails getContainerConnectionDetails(
			ContainerConnectionSource<RedpandaContainer> source) {
		return new RedpandaContainerConnectionDetails(source);
	}
	/**
	 * {@link KafkaConnectionDetails} backed by a {@link ContainerConnectionSource}.
	 */
	private static final class RedpandaContainerConnectionDetails extends ContainerConnectionDetails<RedpandaContainer>
			implements KafkaConnectionDetails {
		private RedpandaContainerConnectionDetails(ContainerConnectionSource<RedpandaContainer> source) {
			super(source);
		}
		@Override
		public List<String> getBootstrapServers() {
			return List.of(getContainer().getBootstrapServers());
		}
	}
}
/*
/**
package org.springframework.boot.testcontainers.service.connection.redpanda;
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@Deprecated(since = '3.4.0', forRemoval = true)
public class BeforeTestcontainerUsedEvent extends ApplicationEvent {
	public BeforeTestcontainerUsedEvent(Object source) {
		super(source);
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@SuppressWarnings({ 'removal', 'deprecation' })
@Order(Ordered.LOWEST_PRECEDENCE)
class TestcontainersLifecycleBeanPostProcessor
		implements DestructionAwareBeanPostProcessor, ApplicationListener<BeforeTestcontainerUsedEvent> {
	private static final Log logger = LogFactory.getLog(TestcontainersLifecycleBeanPostProcessor.class);
	private final ConfigurableListableBeanFactory beanFactory;
	private final TestcontainersStartup startup;
	private final AtomicReference<Startables> startables = new AtomicReference<>(Startables.UNSTARTED);
	private final AtomicBoolean containersInitialized = new AtomicBoolean();
	TestcontainersLifecycleBeanPostProcessor(ConfigurableListableBeanFactory beanFactory,
			TestcontainersStartup startup) {
		this.beanFactory = beanFactory;
		this.startup = startup;
	}
	@Override
	@Deprecated(since = '3.4.0', forRemoval = true)
	public void onApplicationEvent(BeforeTestcontainerUsedEvent event) {
		initializeContainers();
	}
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		if (this.beanFactory.isConfigurationFrozen() && !isAotProcessingInProgress()) {
			initializeContainers();
		}
		if (bean instanceof Startable startableBean) {
			if (this.startables.compareAndExchange(Startables.UNSTARTED, Startables.STARTING) == Startables.UNSTARTED) {
				initializeStartables(startableBean, beanName);
			}
			else if (this.startables.get() == Startables.STARTED) {
				logger.trace(LogMessage.format('Starting container %s', beanName));
				startableBean.start();
			}
		}
		return bean;
	}
	private boolean isAotProcessingInProgress() {
		return Boolean.getBoolean(AbstractAotProcessor.AOT_PROCESSING);
	}
	private void initializeStartables(Startable startableBean, String startableBeanName) {
		logger.trace(LogMessage.format('Initializing startables'));
		List<String> beanNames = new ArrayList<>(getBeanNames(Startable.class));
		beanNames.remove(startableBeanName);
		List<Object> beans = getBeans(beanNames);
		if (beans == null) {
			logger.trace(LogMessage.format('Failed to obtain startables %s', beanNames));
			this.startables.set(Startables.UNSTARTED);
			return;
		}
		beanNames.add(startableBeanName);
		beans.add(startableBean);
		logger.trace(LogMessage.format('Starting startables %s', beanNames));
		start(beans);
		this.startables.set(Startables.STARTED);
		if (!beanNames.isEmpty()) {
			logger.debug(LogMessage.format('Initialized and started startable beans "%s"', beanNames));
		}
	}
	private void start(List<Object> beans) {
		Set<Startable> startables = beans.stream()
			.filter(Startable.class::isInstance)
			.map(Startable.class::cast)
			.collect(Collectors.toCollection(LinkedHashSet::new));
		this.startup.start(startables);
	}
	private void initializeContainers() {
		if (this.containersInitialized.compareAndSet(false, true)) {
			logger.trace('Initializing containers');
			List<String> beanNames = getBeanNames(ContainerState.class);
			List<Object> beans = getBeans(beanNames);
			if (beans != null) {
				logger.trace(LogMessage.format('Initialized containers %s', beanNames));
			}
			else {
				logger.trace(LogMessage.format('Failed to initialize containers %s', beanNames));
				this.containersInitialized.set(false);
			}
		}
	}
	private List<String> getBeanNames(Class<?> type) {
		return List.of(this.beanFactory.getBeanNamesForType(type, true, false));
	}
	private List<Object> getBeans(List<String> beanNames) {
		List<Object> beans = new ArrayList<>(beanNames.size());
		for (String beanName : beanNames) {
			try {
				beans.add(this.beanFactory.getBean(beanName));
			}
			catch (BeanCreationException ex) {
				if (ex.contains(BeanCurrentlyInCreationException.class)) {
					return null;
				}
				throw ex;
			}
		}
		return beans;
	}
	@Override
	public boolean requiresDestruction(Object bean) {
		return bean instanceof Startable;
	}
	@Override
	public void postProcessBeforeDestruction(Object bean, String beanName) throws BeansException {
		if (bean instanceof Startable startable && !isDestroyedByFramework(beanName) && !isReusedContainer(bean)) {
			startable.close();
		}
	}
	private boolean isDestroyedByFramework(String beanName) {
		try {
			BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(beanName);
			String destroyMethodName = beanDefinition.getDestroyMethodName();
			return !''.equals(destroyMethodName);
		}
		catch (NoSuchBeanDefinitionException ex) {
			return false;
		}
	}
	private boolean isReusedContainer(Object bean) {
		return (bean instanceof GenericContainer<?> container) && container.isShouldBeReused()
				&& TestcontainersConfiguration.getInstance().environmentSupportsReuse();
	}
	enum Startables {
		UNSTARTED, STARTING, STARTED
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
public class TestcontainersLifecycleApplicationContextInitializer
		implements ApplicationContextInitializer<ConfigurableApplicationContext> {
	private static final Set<ConfigurableApplicationContext> applied = Collections.newSetFromMap(new WeakHashMap<>());
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		synchronized (applied) {
			if (!applied.add(applicationContext)) {
				return;
			}
		}
		ConfigurableListableBeanFactory beanFactory = applicationContext.getBeanFactory();
		applicationContext.addBeanFactoryPostProcessor(new TestcontainersLifecycleBeanFactoryPostProcessor());
		TestcontainersStartup startup = TestcontainersStartup.get(applicationContext.getEnvironment());
		TestcontainersLifecycleBeanPostProcessor beanPostProcessor = new TestcontainersLifecycleBeanPostProcessor(
				beanFactory, startup);
		beanFactory.addBeanPostProcessor(beanPostProcessor);
		applicationContext.addApplicationListener(beanPostProcessor);
	}
}
/*
/**
package org.springframework.boot.testcontainers.lifecycle;
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
@Order(Ordered.LOWEST_PRECEDENCE)
class TestcontainersLifecycleBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		for (String beanName : beanFactory.getBeanNamesForType(Startable.class, false, false)) {
			try {
				BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName);
				String destroyMethodName = beanDefinition.getDestroyMethodName();
				if (destroyMethodName == null || AbstractBeanDefinition.INFER_METHOD.equals(destroyMethodName)) {
					beanDefinition.setDestroyMethodName('');
				}
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Ignore
			}
		}
	}
}
/*
package org.springframework.boot.testcontainers.lifecycle;
/**
public enum TestcontainersStartup {
	/**
	 * Startup containers sequentially.
	 */
	SEQUENTIAL {
		@Override
		void start(Collection<? extends Startable> startables) {
			startables.forEach(Startable::start);
		}
	},
	/**
	 * Startup containers in parallel.
	 */
	PARALLEL {
		@Override
		void start(Collection<? extends Startable> startables) {
			Startables.deepStart(startables).join();
		}
	};
	/**
	 * The {@link Environment} property used to change the {@link TestcontainersStartup}
	 * strategy.
	 */
	public static final String PROPERTY = 'spring.testcontainers.beans.startup';
	abstract void start(Collection<? extends Startable> startables);
	static TestcontainersStartup get(ConfigurableEnvironment environment) {
		return get((environment != null) ? environment.getProperty(PROPERTY) : null);
	}
	private static TestcontainersStartup get(String value) {
		if (value == null) {
			return SEQUENTIAL;
		}
		String canonicalName = getCanonicalName(value);
		for (TestcontainersStartup candidate : values()) {
			if (candidate.name().equalsIgnoreCase(canonicalName)) {
				return candidate;
			}
		}
		throw new IllegalArgumentException('Unknown "%s" property value "%s"'.formatted(PROPERTY, value));
	}
	private static String getCanonicalName(String name) {
		StringBuilder canonicalName = new StringBuilder(name.length());
		name.chars()
			.filter(Character::isLetterOrDigit)
			.map(Character::toLowerCase)
			.forEach((c) -> canonicalName.append((char) c));
		return canonicalName.toString();
	}
}
/*
/**
package org.springframework.boot.testcontainers;
/*
package org.springframework.boot.testcontainers.beans;
/**
public interface TestcontainerBeanDefinition extends BeanDefinition {
	/**
	 * Return the container image name or {@code null} if the image name is not yet known.
	 * @return the container image name
	 */
	String getContainerImageName();
	/**
	 * Return any annotations declared alongside the container.
	 * @return annotations declared with the container
	 */
	MergedAnnotations getAnnotations();
}
/*
/**
package org.springframework.boot.testcontainers.beans;
/*
package org.springframework.boot.ssl;
/**
class SslOptionsTests {
	@Test
	void noneReturnsNull() {
		SslOptions options = SslOptions.NONE;
		assertThat(options.getCiphers()).isNull();
		assertThat(options.getEnabledProtocols()).isNull();
	}
	@Test
	void ofWithArrayCreatesSslOptions() {
		String[] ciphers = { 'a', 'b', 'c' };
		String[] enabledProtocols = { 'd', 'e', 'f' };
		SslOptions options = SslOptions.of(ciphers, enabledProtocols);
		assertThat(options.getCiphers()).containsExactly(ciphers);
		assertThat(options.getEnabledProtocols()).containsExactly(enabledProtocols);
	}
	@Test
	void ofWithNullArraysCreatesSslOptions() {
		String[] ciphers = null;
		String[] enabledProtocols = null;
		SslOptions options = SslOptions.of(ciphers, enabledProtocols);
		assertThat(options.getCiphers()).isNull();
		assertThat(options.getEnabledProtocols()).isNull();
	}
	@Test
	void ofWithSetCreatesSslOptions() {
		Set<String> ciphers = Set.of('a', 'b', 'c');
		Set<String> enabledProtocols = Set.of('d', 'e', 'f');
		SslOptions options = SslOptions.of(ciphers, enabledProtocols);
		assertThat(options.getCiphers()).contains('a', 'b', 'c');
		assertThat(options.getEnabledProtocols()).contains('d', 'e', 'f');
	}
	@Test
	void ofWithNullSetCreatesSslOptions() {
		Set<String> ciphers = null;
		Set<String> enabledProtocols = null;
		SslOptions options = SslOptions.of(ciphers, enabledProtocols);
		assertThat(options.getCiphers()).isNull();
		assertThat(options.getEnabledProtocols()).isNull();
	}
}
/*
package org.springframework.boot.ssl;
/**
class AliasKeyManagerFactoryTests {
	@Test
	void chooseEngineServerAliasReturnsAlias() throws Exception {
		KeyManagerFactory delegate = mock(KeyManagerFactory.class);
		given(delegate.getKeyManagers()).willReturn(new KeyManager[] { mock(X509ExtendedKeyManager.class) });
		AliasKeyManagerFactory factory = new AliasKeyManagerFactory(delegate, 'test-alias',
				KeyManagerFactory.getDefaultAlgorithm());
		factory.init(null, null);
		KeyManager[] keyManagers = factory.getKeyManagers();
		X509ExtendedKeyManager x509KeyManager = (X509ExtendedKeyManager) Arrays.stream(keyManagers)
			.filter(X509ExtendedKeyManager.class::isInstance)
			.findAny()
			.get();
		String chosenAlias = x509KeyManager.chooseEngineServerAlias(null, null, null);
		assertThat(chosenAlias).isEqualTo('test-alias');
	}
}
/*
package org.springframework.boot.ssl;
/**
class SslBundleTests {
	@Test
	void createSslContextDelegatesToManagers() {
		SslManagerBundle managers = mock(SslManagerBundle.class);
		SslBundle bundle = SslBundle.of(null, null, null, 'testprotocol', managers);
		bundle.createSslContext();
		then(managers).should().createSslContext('testprotocol');
	}
	@Test
	void ofCreatesSslBundle() {
		SslStoreBundle stores = mock(SslStoreBundle.class);
		SslBundleKey key = mock(SslBundleKey.class);
		SslOptions options = mock(SslOptions.class);
		String protocol = 'test';
		SslManagerBundle managers = mock(SslManagerBundle.class);
		SslBundle bundle = SslBundle.of(stores, key, options, protocol, managers);
		assertThat(bundle.getStores()).isSameAs(stores);
		assertThat(bundle.getKey()).isSameAs(key);
		assertThat(bundle.getOptions()).isSameAs(options);
		assertThat(bundle.getProtocol()).isSameAs(protocol);
		assertThat(bundle.getManagers()).isSameAs(managers);
	}
}
/*
package org.springframework.boot.ssl;
/**
class SslBundleKeyTests {
	@Test
	void noneHasNoValues() {
		SslBundleKey keyReference = SslBundleKey.NONE;
		assertThat(keyReference.getPassword()).isNull();
		assertThat(keyReference.getAlias()).isNull();
	}
	@Test
	void ofCreatesWithPasswordSslKeyReference() {
		SslBundleKey keyReference = SslBundleKey.of('password');
		assertThat(keyReference.getPassword()).isEqualTo('password');
		assertThat(keyReference.getAlias()).isNull();
	}
	@Test
	void ofCreatesWithPasswordAndAliasSslKeyReference() {
		SslBundleKey keyReference = SslBundleKey.of('password', 'alias');
		assertThat(keyReference.getPassword()).isEqualTo('password');
		assertThat(keyReference.getAlias()).isEqualTo('alias');
	}
	@Test
	void getKeyManagerFactoryWhenHasAliasNotInStoreThrowsException() throws Exception {
		KeyStore keyStore = mock(KeyStore.class);
		given(keyStore.containsAlias('alias')).willReturn(false);
		SslBundleKey key = SslBundleKey.of('secret', 'alias');
		assertThatIllegalStateException().isThrownBy(() -> key.assertContainsAlias(keyStore))
			.withMessage('Keystore does not contain alias "alias"');
	}
	@Test
	void getKeyManagerFactoryWhenHasAliasNotDeterminedInStoreThrowsException() throws Exception {
		KeyStore keyStore = mock(KeyStore.class);
		given(keyStore.containsAlias('alias')).willThrow(KeyStoreException.class);
		SslBundleKey key = SslBundleKey.of('secret', 'alias');
		assertThatIllegalStateException().isThrownBy(() -> key.assertContainsAlias(keyStore))
			.withMessage('Could not determine if keystore contains alias "alias"');
	}
}
/*
package org.springframework.boot.ssl;
/**
@ExtendWith(OutputCaptureExtension.class)
class DefaultSslBundleRegistryTests {
	private final SslBundle bundle1 = mock(SslBundle.class);
	private final SslBundle bundle2 = mock(SslBundle.class);
	private DefaultSslBundleRegistry registry;
	@BeforeEach
	void setUp() {
		this.registry = new DefaultSslBundleRegistry();
	}
	@Test
	void createWithNameAndBundleRegistersBundle() {
		DefaultSslBundleRegistry registry = new DefaultSslBundleRegistry('test', this.bundle1);
		assertThat(registry.getBundle('test')).isSameAs(this.bundle1);
	}
	@Test
	void registerBundleWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.registry.registerBundle(null, this.bundle1))
			.withMessage('Name must not be null');
	}
	@Test
	void registerBundleWhenBundleIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.registry.registerBundle('test', null))
			.withMessage('Bundle must not be null');
	}
	@Test
	void registerBundleWhenNameIsTakenThrowsException() {
		this.registry.registerBundle('test', this.bundle1);
		assertThatIllegalStateException().isThrownBy(() -> this.registry.registerBundle('test', this.bundle2))
			.withMessage('Cannot replace existing SSL bundle "test"');
	}
	@Test
	void registerBundleRegistersBundle() {
		this.registry.registerBundle('test', this.bundle1);
		assertThat(this.registry.getBundle('test')).isSameAs(this.bundle1);
	}
	@Test
	void getBundleWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.registry.getBundle(null))
			.withMessage('Name must not be null');
	}
	@Test
	void getBundleWhenNoSuchBundleThrowsException() {
		this.registry.registerBundle('test', this.bundle1);
		assertThatExceptionOfType(NoSuchSslBundleException.class).isThrownBy(() -> this.registry.getBundle('missing'))
			.satisfies((ex) -> assertThat(ex.getBundleName()).isEqualTo('missing'));
	}
	@Test
	void getBundleReturnsBundle() {
		this.registry.registerBundle('test1', this.bundle1);
		this.registry.registerBundle('test2', this.bundle2);
		assertThat(this.registry.getBundle('test1')).isSameAs(this.bundle1);
		assertThat(this.registry.getBundle('test2')).isSameAs(this.bundle2);
	}
	@Test
	void getBundleNamesReturnsNames() {
		this.registry.registerBundle('test1', this.bundle1);
		this.registry.registerBundle('test2', this.bundle2);
		assertThat(this.registry.getBundleNames()).containsExactly('test1', 'test2');
	}
	@Test
	void updateBundleShouldNotifyUpdateHandlers() {
		AtomicReference<SslBundle> updatedBundle = new AtomicReference<>();
		this.registry.registerBundle('test1', this.bundle1);
		this.registry.addBundleUpdateHandler('test1', updatedBundle::set);
		this.registry.updateBundle('test1', this.bundle2);
		Awaitility.await().untilAtomic(updatedBundle, Matchers.equalTo(this.bundle2));
	}
	@Test
	void shouldFailIfUpdatingNonRegisteredBundle() {
		assertThatExceptionOfType(NoSuchSslBundleException.class)
			.isThrownBy(() -> this.registry.updateBundle('dummy', this.bundle1))
			.withMessageContaining('"dummy"');
	}
	@Test
	void shouldLogIfUpdatingBundleWithoutListeners(CapturedOutput output) {
		this.registry.registerBundle('test1', this.bundle1);
		this.registry.getBundle('test1');
		this.registry.updateBundle('test1', this.bundle2);
		assertThat(output).contains(
				'SSL bundle "test1" has been updated but may be in use by a technology that doesn"t support SSL reloading');
	}
}
/*
package org.springframework.boot.ssl.jks;
/**
@MockPkcs11Security
class JksSslStoreBundleTests {
	@Test
	void whenNullStores() {
		JksSslStoreDetails keyStoreDetails = null;
		JksSslStoreDetails trustStoreDetails = null;
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).isNull();
		assertThat(bundle.getKeyStorePassword()).isNull();
		assertThat(bundle.getTrustStore()).isNull();
	}
	@Test
	void whenStoresHaveNoValues() {
		JksSslStoreDetails keyStoreDetails = JksSslStoreDetails.forLocation(null);
		JksSslStoreDetails trustStoreDetails = JksSslStoreDetails.forLocation(null);
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).isNull();
		assertThat(bundle.getKeyStorePassword()).isNull();
		assertThat(bundle.getTrustStore()).isNull();
	}
	@Test
	void whenTypePKCS11AndLocationGetKeyStoreThrowsException() {
		JksSslStoreDetails keyStoreDetails = new JksSslStoreDetails('PKCS11', null, 'test.jks', null);
		JksSslStoreBundle jksSslStoreBundle = new JksSslStoreBundle(keyStoreDetails, null);
		assertThatIllegalStateException().isThrownBy(jksSslStoreBundle::getKeyStore)
			.withMessageContaining(
					'Unable to create key store: Location is "test.jks", but must be empty or null for PKCS11 hardware key stores');
	}
	@Test
	void whenHasKeyStoreLocation() {
		JksSslStoreDetails keyStoreDetails = JksSslStoreDetails.forLocation('classpath:test.jks')
			.withPassword('secret');
		JksSslStoreDetails trustStoreDetails = null;
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('test-alias', 'password'));
	}
	@Test
	void getTrustStoreWithLocations() {
		JksSslStoreDetails keyStoreDetails = null;
		JksSslStoreDetails trustStoreDetails = JksSslStoreDetails.forLocation('classpath:test.jks')
			.withPassword('secret');
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('test-alias', 'password'));
	}
	@Test
	void whenHasKeyStoreType() {
		JksSslStoreDetails keyStoreDetails = new JksSslStoreDetails('jks', null, 'classpath:test.jks', 'secret');
		JksSslStoreDetails trustStoreDetails = null;
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('jks', 'test-alias', 'password'));
	}
	@Test
	void whenHasTrustStoreType() {
		JksSslStoreDetails keyStoreDetails = null;
		JksSslStoreDetails trustStoreDetails = new JksSslStoreDetails('jks', null, 'classpath:test.jks', 'secret');
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('jks', 'test-alias', 'password'));
	}
	@Test
	void whenHasKeyStoreProvider() {
		JksSslStoreDetails keyStoreDetails = new JksSslStoreDetails(null, 'com.example.KeyStoreProvider',
				'classpath:test.jks', 'secret');
		JksSslStoreBundle jksSslStoreBundle = new JksSslStoreBundle(keyStoreDetails, null);
		assertThatIllegalStateException().isThrownBy(jksSslStoreBundle::getKeyStore)
			.withMessageContaining('com.example.KeyStoreProvider');
	}
	@Test
	void whenHasTrustStoreProvider() {
		JksSslStoreDetails trustStoreDetails = new JksSslStoreDetails(null, 'com.example.KeyStoreProvider',
				'classpath:test.jks', 'secret');
		JksSslStoreBundle jksSslStoreBundle = new JksSslStoreBundle(null, trustStoreDetails);
		assertThatIllegalStateException().isThrownBy(jksSslStoreBundle::getTrustStore)
			.withMessageContaining('com.example.KeyStoreProvider');
	}
	@Test
	void storeCreationIsLazy() {
		JksSslStoreDetails details = new JksSslStoreDetails(null, null, 'does-not-exist', null);
		JksSslStoreBundle bundle = new JksSslStoreBundle(details, details);
		assertThatIllegalStateException().isThrownBy(bundle::getKeyStore);
		assertThatIllegalStateException().isThrownBy(bundle::getTrustStore);
	}
	@Test
	void whenLocationsAreBase64Encoded() throws IOException {
		JksSslStoreDetails keyStoreDetails = JksSslStoreDetails.forLocation(encodeFileContent('classpath:test.p12'))
			.withPassword('secret');
		JksSslStoreDetails trustStoreDetails = JksSslStoreDetails.forLocation(encodeFileContent('classpath:test.jks'))
			.withPassword('secret');
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('test-alias', 'secret'));
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('test-alias', 'password'));
	}
	@Test
	void invalidBase64EncodedLocationThrowsException() {
		JksSslStoreDetails keyStoreDetails = JksSslStoreDetails.forLocation('base64:not base 64');
		JksSslStoreBundle jksSslStoreBundle = new JksSslStoreBundle(keyStoreDetails, null);
		assertThatIllegalStateException().isThrownBy(jksSslStoreBundle::getKeyStore)
			.withMessageContaining('key store')
			.withMessageContaining('base64:not base 64')
			.havingRootCause()
			.isInstanceOf(IllegalArgumentException.class)
			.withMessageContaining('Illegal base64');
	}
	@Test
	void invalidLocationThrowsException() {
		JksSslStoreDetails trustStoreDetails = JksSslStoreDetails.forLocation('does-not-exist.p12');
		JksSslStoreBundle jksSslStoreBundle = new JksSslStoreBundle(null, trustStoreDetails);
		assertThatIllegalStateException().isThrownBy(jksSslStoreBundle::getTrustStore)
			.withMessageContaining('trust store')
			.withMessageContaining('does-not-exist.p12');
	}
	@Test
	void usesResourceLoader() {
		JksSslStoreDetails keyStoreDetails = null;
		JksSslStoreDetails trustStoreDetails = new JksSslStoreDetails('jks', null, 'classpath:test.jks', 'secret');
		ResourceLoader resourceLoader = spy(new DefaultResourceLoader());
		JksSslStoreBundle bundle = new JksSslStoreBundle(keyStoreDetails, trustStoreDetails, resourceLoader);
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('jks', 'test-alias', 'password'));
		then(resourceLoader).should(atLeastOnce()).getResource('classpath:test.jks');
	}
	private Consumer<KeyStore> storeContainingCertAndKey(String keyAlias, String keyPassword) {
		return storeContainingCertAndKey(KeyStore.getDefaultType(), keyAlias, keyPassword);
	}
	private Consumer<KeyStore> storeContainingCertAndKey(String keyStoreType, String keyAlias, String keyPassword) {
		return ThrowingConsumer.of((keyStore) -> {
			assertThat(keyStore).isNotNull();
			assertThat(keyStore.getType()).isEqualTo(keyStoreType);
			assertThat(keyStore.containsAlias(keyAlias)).isTrue();
			assertThat(keyStore.getCertificate(keyAlias)).isNotNull();
			assertThat(keyStore.getKey(keyAlias, keyPassword.toCharArray())).isNotNull();
		});
	}
	private String encodeFileContent(String location) throws IOException {
		Resource resource = ApplicationResourceLoader.get().getResource(location);
		byte[] bytes = Files.readAllBytes(resource.getFile().toPath());
		return 'base64:' + Base64.getEncoder().encodeToString(bytes);
	}
}
/*
package org.springframework.boot.ssl;
/**
class SslStoreBundleTests {
	@Test
	void noneReturnsEmptySslStoreBundle() {
		SslStoreBundle bundle = SslStoreBundle.NONE;
		assertThat(bundle.getKeyStore()).isNull();
		assertThat(bundle.getKeyStorePassword()).isNull();
		assertThat(bundle.getTrustStore()).isNull();
	}
	@Test
	void ofCreatesStoreBundle() {
		KeyStore keyStore = mock(KeyStore.class);
		String keyStorePassword = 'secret';
		KeyStore trustStore = mock(KeyStore.class);
		SslStoreBundle bundle = SslStoreBundle.of(keyStore, keyStorePassword, trustStore);
		assertThat(bundle.getKeyStore()).isSameAs(keyStore);
		assertThat(bundle.getKeyStorePassword()).isEqualTo(keyStorePassword);
		assertThat(bundle.getTrustStore()).isSameAs(trustStore);
	}
}
/*
package org.springframework.boot.ssl;
/**
class SslManagerBundleTests {
	private KeyManagerFactory keyManagerFactory = mock(KeyManagerFactory.class);
	private TrustManagerFactory trustManagerFactory = mock(TrustManagerFactory.class);
	@Test
	void getKeyManagersDelegatesToFactory() {
		SslManagerBundle bundle = SslManagerBundle.of(this.keyManagerFactory, this.trustManagerFactory);
		bundle.getKeyManagers();
		then(this.keyManagerFactory).should().getKeyManagers();
	}
	@Test
	void getTrustManagersDelegatesToFactory() {
		SslManagerBundle bundle = SslManagerBundle.of(this.keyManagerFactory, this.trustManagerFactory);
		bundle.getTrustManagers();
		then(this.trustManagerFactory).should().getTrustManagers();
	}
	@Test
	void createSslContextCreatesInitializedSslContext() {
		SslManagerBundle bundle = SslManagerBundle.of(this.keyManagerFactory, this.trustManagerFactory);
		SSLContext sslContext = bundle.createSslContext('TLS');
		assertThat(sslContext).isNotNull();
		assertThat(sslContext.getProtocol()).isEqualTo('TLS');
	}
	@Test
	void ofWhenKeyManagerFactoryIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> SslManagerBundle.of(null, this.trustManagerFactory))
			.withMessage('KeyManagerFactory must not be null');
	}
	@Test
	void ofWhenTrustManagerFactoryIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> SslManagerBundle.of(this.keyManagerFactory, null))
			.withMessage('TrustManagerFactory must not be null');
	}
	@Test
	void ofCreatesSslManagerBundle() {
		SslManagerBundle bundle = SslManagerBundle.of(this.keyManagerFactory, this.trustManagerFactory);
		assertThat(bundle.getKeyManagerFactory()).isSameAs(this.keyManagerFactory);
		assertThat(bundle.getTrustManagerFactory()).isSameAs(this.trustManagerFactory);
	}
	@Test
	void fromCreatesDefaultSslManagerBundle() {
		SslManagerBundle bundle = SslManagerBundle.from(SslStoreBundle.NONE, SslBundleKey.NONE);
		assertThat(bundle).isInstanceOf(DefaultSslManagerBundle.class);
	}
}
/*
package org.springframework.boot.ssl;
/**
class DefaultSslManagerBundleTests {
	private KeyManagerFactory keyManagerFactory = mock(KeyManagerFactory.class);
	private TrustManagerFactory trustManagerFactory = mock(TrustManagerFactory.class);
	@Test
	void getKeyManagerFactoryWhenStoreBundleIsNull() throws Exception {
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(null, SslBundleKey.NONE);
		KeyManagerFactory result = bundle.getKeyManagerFactory();
		assertThat(result).isNotNull();
		then(this.keyManagerFactory).should().init(null, null);
	}
	@Test
	void getKeyManagerFactoryWhenKeyIsNull() throws Exception {
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(SslStoreBundle.NONE, null);
		KeyManagerFactory result = bundle.getKeyManagerFactory();
		assertThat(result).isSameAs(this.keyManagerFactory);
		then(this.keyManagerFactory).should().init(null, null);
	}
	@Test
	void getKeyManagerFactoryWhenHasKeyAliasReturnsWrapped() {
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(null, SslBundleKey.of('secret', 'alias'));
		KeyManagerFactory result = bundle.getKeyManagerFactory();
		assertThat(result).isInstanceOf(AliasKeyManagerFactory.class);
	}
	@Test
	void getKeyManagerFactoryWhenHasKeyPassword() throws Exception {
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(null, SslBundleKey.of('secret'));
		KeyManagerFactory result = bundle.getKeyManagerFactory();
		assertThat(result).isSameAs(this.keyManagerFactory);
		then(this.keyManagerFactory).should().init(null, 'secret'.toCharArray());
	}
	@Test
	void getKeyManagerFactoryWhenHasKeyStorePassword() throws Exception {
		SslStoreBundle storeBundle = SslStoreBundle.of(null, 'secret', null);
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(storeBundle, null);
		KeyManagerFactory result = bundle.getKeyManagerFactory();
		assertThat(result).isSameAs(this.keyManagerFactory);
		then(this.keyManagerFactory).should().init(null, 'secret'.toCharArray());
	}
	@Test
	void getKeyManagerFactoryWhenHasAliasNotInStoreThrowsException() throws Exception {
		KeyStore keyStore = mock(KeyStore.class);
		given(keyStore.containsAlias('alias')).willReturn(false);
		SslStoreBundle storeBundle = SslStoreBundle.of(keyStore, null, null);
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(storeBundle,
				SslBundleKey.of('secret', 'alias'));
		assertThatIllegalStateException().isThrownBy(bundle::getKeyManagerFactory)
			.withMessage('Keystore does not contain alias "alias"');
	}
	@Test
	void getKeyManagerFactoryWhenHasAliasNotDeterminedInStoreThrowsException() throws Exception {
		KeyStore keyStore = mock(KeyStore.class);
		given(keyStore.containsAlias('alias')).willThrow(KeyStoreException.class);
		SslStoreBundle storeBundle = SslStoreBundle.of(keyStore, null, null);
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(storeBundle,
				SslBundleKey.of('secret', 'alias'));
		assertThatIllegalStateException().isThrownBy(bundle::getKeyManagerFactory)
			.withMessage('Could not determine if keystore contains alias "alias"');
	}
	@Test
	void getKeyManagerFactoryWhenHasStore() throws Exception {
		KeyStore keyStore = mock(KeyStore.class);
		SslStoreBundle storeBundle = SslStoreBundle.of(keyStore, null, null);
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(storeBundle, null);
		KeyManagerFactory result = bundle.getKeyManagerFactory();
		assertThat(result).isSameAs(this.keyManagerFactory);
		then(this.keyManagerFactory).should().init(keyStore, null);
	}
	@Test
	void getTrustManagerFactoryWhenStoreBundleIsNull() throws Exception {
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(null, null);
		TrustManagerFactory result = bundle.getTrustManagerFactory();
		assertThat(result).isSameAs(this.trustManagerFactory);
		then(this.trustManagerFactory).should().init((KeyStore) null);
	}
	@Test
	void getTrustManagerFactoryWhenHasStore() throws Exception {
		KeyStore trustStore = mock(KeyStore.class);
		SslStoreBundle storeBundle = SslStoreBundle.of(null, null, trustStore);
		DefaultSslManagerBundle bundle = new TestDefaultSslManagerBundle(storeBundle, null);
		TrustManagerFactory result = bundle.getTrustManagerFactory();
		assertThat(result).isSameAs(this.trustManagerFactory);
		then(this.trustManagerFactory).should().init(trustStore);
	}
	/**
	 * Test version of {@link DefaultSslManagerBundle}.
	 */
	class TestDefaultSslManagerBundle extends DefaultSslManagerBundle {
		TestDefaultSslManagerBundle(SslStoreBundle storeBundle, SslBundleKey key) {
			super(storeBundle, key);
		}
		@Override
		protected KeyManagerFactory getKeyManagerFactoryInstance(String algorithm) throws NoSuchAlgorithmException {
			return DefaultSslManagerBundleTests.this.keyManagerFactory;
		}
		@Override
		protected TrustManagerFactory getTrustManagerFactoryInstance(String algorithm) throws NoSuchAlgorithmException {
			return DefaultSslManagerBundleTests.this.trustManagerFactory;
		}
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
class LoadedPemSslStoreTests {
	@Test
	void certificatesAreLoadedLazily() {
		PemSslStoreDetails details = PemSslStoreDetails.forCertificate('classpath:missing-test-cert.pem')
			.withPrivateKey('classpath:test-key.pem');
		LoadedPemSslStore store = new LoadedPemSslStore(details, ApplicationResourceLoader.get());
		assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(store::certificates);
	}
	@Test
	void privateKeyIsLoadedLazily() {
		PemSslStoreDetails details = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:missing-test-key.pem');
		LoadedPemSslStore store = new LoadedPemSslStore(details, ApplicationResourceLoader.get());
		assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(store::privateKey);
	}
	@Test
	void withAliasIsLazy() {
		PemSslStoreDetails details = PemSslStoreDetails.forCertificate('classpath:missing-test-cert.pem')
			.withPrivateKey('classpath:test-key.pem');
		PemSslStore store = new LoadedPemSslStore(details, ApplicationResourceLoader.get()).withAlias('alias');
		assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(store::certificates);
	}
	@Test
	void withPasswordIsLazy() {
		PemSslStoreDetails details = PemSslStoreDetails.forCertificate('classpath:missing-test-cert.pem')
			.withPrivateKey('classpath:test-key.pem');
		PemSslStore store = new LoadedPemSslStore(details, ApplicationResourceLoader.get()).withPassword('password');
		assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(store::certificates);
	}
	@Test
	void usesResourceLoader() {
		PemSslStoreDetails details = PemSslStoreDetails.forCertificate('classpath:test-cert.pem');
		ResourceLoader resourceLoader = spy(new DefaultResourceLoader());
		LoadedPemSslStore store = new LoadedPemSslStore(details, resourceLoader);
		store.certificates();
		then(resourceLoader).should(atLeastOnce()).getResource('classpath:test-cert.pem');
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
class PemCertificateParserTests {
	@Test
	void parseCertificate() throws Exception {
		List<X509Certificate> certificates = PemCertificateParser.parse(read('test-cert.pem'));
		assertThat(certificates).isNotNull();
		assertThat(certificates).hasSize(1);
		assertThat(certificates.get(0).getType()).isEqualTo('X.509');
	}
	@Test
	void parseCertificateChain() throws Exception {
		List<X509Certificate> certificates = PemCertificateParser.parse(read('test-cert-chain.pem'));
		assertThat(certificates).isNotNull();
		assertThat(certificates).hasSize(2);
		assertThat(certificates.get(0).getType()).isEqualTo('X.509');
		assertThat(certificates.get(1).getType()).isEqualTo('X.509');
	}
	private String read(String path) throws IOException {
		return new ClassPathResource(path).getContentAsString(StandardCharsets.UTF_8);
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
class PemContentTests {
	@Test
	void getCertificateWhenNoCertificatesThrowsException() {
		PemContent content = PemContent.of('');
		assertThatIllegalStateException().isThrownBy(content::getCertificates)
			.withMessage('Missing certificates or unrecognized format');
	}
	@Test
	void getCertificateReturnsCertificates() throws Exception {
		PemContent content = PemContent.load(contentFromClasspath('/test-cert-chain.pem'),
				ApplicationResourceLoader.get());
		List<X509Certificate> certificates = content.getCertificates();
		assertThat(certificates).isNotNull();
		assertThat(certificates).hasSize(2);
		assertThat(certificates.get(0).getType()).isEqualTo('X.509');
		assertThat(certificates.get(1).getType()).isEqualTo('X.509');
	}
	@Test
	void getPrivateKeyWhenNoKeyThrowsException() {
		PemContent content = PemContent.of('');
		assertThatIllegalStateException().isThrownBy(content::getPrivateKey)
			.withMessage('Missing private key or unrecognized format');
	}
	@Test
	void getPrivateKeyReturnsPrivateKey() throws Exception {
		PemContent content = PemContent.load(contentFromClasspath('/org/springframework/boot/web/server/pkcs8/dsa.key'),
				ApplicationResourceLoader.get());
		PrivateKey privateKey = content.getPrivateKey();
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('DSA');
	}
	@Test
	void equalsAndHashCode() {
		PemContent c1 = PemContent.of('aaa');
		PemContent c2 = PemContent.of('aaa');
		PemContent c3 = PemContent.of('bbb');
		assertThat(c1.hashCode()).isEqualTo(c2.hashCode());
		assertThat(c1).isEqualTo(c1).isEqualTo(c2).isNotEqualTo(c3);
	}
	@Test
	void toStringReturnsString() {
		PemContent content = PemContent.of('test');
		assertThat(content).hasToString('test');
	}
	@Test
	void loadWithStringWhenContentIsNullReturnsNull() throws Exception {
		assertThat(PemContent.load((String) null, ApplicationResourceLoader.get())).isNull();
	}
	@Test
	void loadWithStringWhenContentIsPemContentReturnsContent() throws Exception {
		String content = '''
				-----BEGIN CERTIFICATE-----
				MIICpDCCAYwCCQCDOqHKPjAhCTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls
				b2NhbGhvc3QwHhcNMTQwOTEwMjE0MzA1WhcNMTQxMDEwMjE0MzA1WjAUMRIwEAYD
				VQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDR
				0KfxUw7MF/8RB5/YXOM7yLnoHYb/M/6dyoulMbtEdKKhQhU28o5FiDkHcEG9PJQL
				gqrRgAjl3VmCC9omtfZJQ2EpfkTttkJjnKOOroXhYE51/CYSckapBYCVh8GkjUEJ
				uEfnp07cTfYZFqViIgIWPZyjkzl3w4girS7kCuzNdDntVJVx5F/EsFwMA8n3C0Qa
				zHQoM5s00Fer6aTwd6AW0JD5QkADavpfzZ554e4HrVGwHlM28WKQQkFzzGu44FFX
				yVuEF3HeyVPug8GRHAc8UU7ijVgJB5TmbvRGYowIErD5i4VvGLuOv9mgR3aVyN0S
				dJ1N7aJnXpeSQjAgf03jAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAE4yvwhbPldg
				Bpl7sBw/m2B3bfiNeSqa4tII1PQ7ysgWVb9HbFNKkriScwDWlqo6ljZfJ+SDFCoj
				bQz4fOFdMAOzRnpTrG2NAKMoJLY0/g/p7XO00PiC8T3h3BOJ5SHuW3gUyfGXmAYs
				DnJxJOrwPzj57xvNXjNSbDOJ3DRfCbB0CWBexOeGDiUokoEq3Gnz04Q4ZfHyAcpZ
				3deMw8Od5p9WAoCh3oClpFyOSzXYKZd+3ppMMtfc4wnbfocnfSFxj0UCpOEJw4Ez
				+lGuHKdhNOVW9CmqPD1y76o6c8PQKuF7KZEoY2jvy3GeIfddBvqXgZ4PbWvFz1jO
				32C9XWHwRA4=
				-----END CERTIFICATE-----''';
		assertThat(PemContent.load(content, ApplicationResourceLoader.get())).hasToString(content);
	}
	@Test
	void loadWithStringWhenContentIsPemContentReturnsTrimmedContent() throws Exception {
		String content = '''
				-----BEGIN CERTIFICATE-----
					MIICpDCCAYwCCQCDOqHKPjAhCTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls
					b2NhbGhvc3QwHhcNMTQwOTEwMjE0MzA1WhcNMTQxMDEwMjE0MzA1WjAUMRIwEAYD
				VQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDR
					0KfxUw7MF/8RB5/YXOM7yLnoHYb/M/6dyoulMbtEdKKhQhU28o5FiDkHcEG9PJQL
				gqrRgAjl3VmCC9omtfZJQ2EpfkTttkJjnKOOroXhYE51/CYSckapBYCVh8GkjUEJ
					uEfnp07cTfYZFqViIgIWPZyjkzl3w4girS7kCuzNdDntVJVx5F/EsFwMA8n3C0Qa
				zHQoM5s00Fer6aTwd6AW0JD5QkADavpfzZ554e4HrVGwHlM28WKQQkFzzGu44FFX
					yVuEF3HeyVPug8GRHAc8UU7ijVgJB5TmbvRGYowIErD5i4VvGLuOv9mgR3aVyN0S
					dJ1N7aJnXpeSQjAgf03jAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAE4yvwhbPldg
					Bpl7sBw/m2B3bfiNeSqa4tII1PQ7ysgWVb9HbFNKkriScwDWlqo6ljZfJ+SDFCoj
				bQz4fOFdMAOzRnpTrG2NAKMoJLY0/g/p7XO00PiC8T3h3BOJ5SHuW3gUyfGXmAYs
					DnJxJOrwPzj57xvNXjNSbDOJ3DRfCbB0CWBexOeGDiUokoEq3Gnz04Q4ZfHyAcpZ
				3deMw8Od5p9WAoCh3oClpFyOSzXYKZd+3ppMMtfc4wnbfocnfSFxj0UCpOEJw4Ez
				+lGuHKdhNOVW9CmqPD1y76o6c8PQKuF7KZEoY2jvy3GeIfddBvqXgZ4PbWvFz1jO
					32C9XWHwRA4=
					-----END CERTIFICATE-----  ''';
		String trimmedContent = '''
				-----BEGIN CERTIFICATE-----
				MIICpDCCAYwCCQCDOqHKPjAhCTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls
				b2NhbGhvc3QwHhcNMTQwOTEwMjE0MzA1WhcNMTQxMDEwMjE0MzA1WjAUMRIwEAYD
				VQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDR
				0KfxUw7MF/8RB5/YXOM7yLnoHYb/M/6dyoulMbtEdKKhQhU28o5FiDkHcEG9PJQL
				gqrRgAjl3VmCC9omtfZJQ2EpfkTttkJjnKOOroXhYE51/CYSckapBYCVh8GkjUEJ
				uEfnp07cTfYZFqViIgIWPZyjkzl3w4girS7kCuzNdDntVJVx5F/EsFwMA8n3C0Qa
				zHQoM5s00Fer6aTwd6AW0JD5QkADavpfzZ554e4HrVGwHlM28WKQQkFzzGu44FFX
				yVuEF3HeyVPug8GRHAc8UU7ijVgJB5TmbvRGYowIErD5i4VvGLuOv9mgR3aVyN0S
				dJ1N7aJnXpeSQjAgf03jAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAE4yvwhbPldg
				Bpl7sBw/m2B3bfiNeSqa4tII1PQ7ysgWVb9HbFNKkriScwDWlqo6ljZfJ+SDFCoj
				bQz4fOFdMAOzRnpTrG2NAKMoJLY0/g/p7XO00PiC8T3h3BOJ5SHuW3gUyfGXmAYs
				DnJxJOrwPzj57xvNXjNSbDOJ3DRfCbB0CWBexOeGDiUokoEq3Gnz04Q4ZfHyAcpZ
				3deMw8Od5p9WAoCh3oClpFyOSzXYKZd+3ppMMtfc4wnbfocnfSFxj0UCpOEJw4Ez
				+lGuHKdhNOVW9CmqPD1y76o6c8PQKuF7KZEoY2jvy3GeIfddBvqXgZ4PbWvFz1jO
				32C9XWHwRA4=
				-----END CERTIFICATE-----''';
		assertThat(PemContent.load(content, ApplicationResourceLoader.get())).hasToString(trimmedContent);
	}
	@Test
	void isPresentInTextWithUntrimmedContent() {
		String content = '''
				-----BEGIN CERTIFICATE-----
					MIICpDCCAYwCCQCDOqHKPjAhCTANBgkqhkiG9w0BAQUFADAUMRIwEAYDVQQDDAls
					b2NhbGhvc3QwHhcNMTQwOTEwMjE0MzA1WhcNMTQxMDEwMjE0MzA1WjAUMRIwEAYD
				VQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDR
					0KfxUw7MF/8RB5/YXOM7yLnoHYb/M/6dyoulMbtEdKKhQhU28o5FiDkHcEG9PJQL
				gqrRgAjl3VmCC9omtfZJQ2EpfkTttkJjnKOOroXhYE51/CYSckapBYCVh8GkjUEJ
					uEfnp07cTfYZFqViIgIWPZyjkzl3w4girS7kCuzNdDntVJVx5F/EsFwMA8n3C0Qa
				zHQoM5s00Fer6aTwd6AW0JD5QkADavpfzZ554e4HrVGwHlM28WKQQkFzzGu44FFX
					yVuEF3HeyVPug8GRHAc8UU7ijVgJB5TmbvRGYowIErD5i4VvGLuOv9mgR3aVyN0S
					dJ1N7aJnXpeSQjAgf03jAgMBAAEwDQYJKoZIhvcNAQEFBQADggEBAE4yvwhbPldg
					Bpl7sBw/m2B3bfiNeSqa4tII1PQ7ysgWVb9HbFNKkriScwDWlqo6ljZfJ+SDFCoj
				bQz4fOFdMAOzRnpTrG2NAKMoJLY0/g/p7XO00PiC8T3h3BOJ5SHuW3gUyfGXmAYs
					DnJxJOrwPzj57xvNXjNSbDOJ3DRfCbB0CWBexOeGDiUokoEq3Gnz04Q4ZfHyAcpZ
				3deMw8Od5p9WAoCh3oClpFyOSzXYKZd+3ppMMtfc4wnbfocnfSFxj0UCpOEJw4Ez
				+lGuHKdhNOVW9CmqPD1y76o6c8PQKuF7KZEoY2jvy3GeIfddBvqXgZ4PbWvFz1jO
					32C9XWHwRA4=
					-----END CERTIFICATE-----  ''';
		assertThat(PemContent.isPresentInText(content)).isTrue();
	}
	@Test
	void loadWithStringWhenClasspathLocationReturnsContent() throws IOException {
		String actual = PemContent.load('classpath:test-cert.pem', ApplicationResourceLoader.get()).toString();
		String expected = contentFromClasspath('test-cert.pem');
		assertThat(actual).isEqualTo(expected);
	}
	@Test
	void loadWithStringWhenFileLocationReturnsContent() throws IOException {
		String actual = PemContent.load('src/test/resources/test-cert.pem', ApplicationResourceLoader.get()).toString();
		String expected = contentFromClasspath('test-cert.pem');
		assertThat(actual).isEqualTo(expected);
	}
	@Test
	void loadWithPathReturnsContent() throws IOException {
		Path path = Path.of('src/test/resources/test-cert.pem');
		String actual = PemContent.load(path).toString();
		String expected = contentFromClasspath('test-cert.pem');
		assertThat(actual).isEqualTo(expected);
	}
	@Test
	void loadWithResourceLoaderUsesResourceLoader() throws IOException {
		ResourceLoader resourceLoader = spy(new DefaultResourceLoader());
		PemContent.load('classpath:test-cert.pem', resourceLoader);
		then(resourceLoader).should(atLeastOnce()).getResource('classpath:test-cert.pem');
	}
	@Test
	void ofWhenNullReturnsNull() {
		assertThat(PemContent.of(null)).isNull();
	}
	@Test
	void ofReturnsContent() {
		assertThat(PemContent.of('test')).hasToString('test');
	}
	private static String contentFromClasspath(String path) throws IOException {
		return new ClassPathResource(path).getContentAsString(StandardCharsets.UTF_8).indent(0).stripTrailing();
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
class PemSslStoreTests {
	@Test
	void withAliasReturnsStoreWithNewAlias() {
		List<X509Certificate> certificates = List.of(mock(X509Certificate.class));
		PrivateKey privateKey = mock(PrivateKey.class);
		PemSslStore store = PemSslStore.of('type', 'alias', 'secret', certificates, privateKey);
		assertThat(store.withAlias('newalias').alias()).isEqualTo('newalias');
	}
	@Test
	void withPasswordReturnsStoreWithNewPassword() {
		List<X509Certificate> certificates = List.of(mock(X509Certificate.class));
		PrivateKey privateKey = mock(PrivateKey.class);
		PemSslStore store = PemSslStore.of('type', 'alias', 'secret', certificates, privateKey);
		assertThat(store.withPassword('newsecret').password()).isEqualTo('newsecret');
	}
	@Test
	void ofWhenNullCertificatesThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> PemSslStore.of(null, null, null, null, null))
			.withMessage('Certificates must not be empty');
	}
	@Test
	void ofWhenEmptyCertificatesThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> PemSslStore.of(null, null, null, Collections.emptyList(), null))
			.withMessage('Certificates must not be empty');
	}
	@Test
	void ofReturnsPemSslStore() {
		List<X509Certificate> certificates = List.of(mock(X509Certificate.class));
		PrivateKey privateKey = mock(PrivateKey.class);
		PemSslStore store = PemSslStore.of('type', 'alias', 'password', certificates, privateKey);
		assertThat(store.type()).isEqualTo('type');
		assertThat(store.alias()).isEqualTo('alias');
		assertThat(store.password()).isEqualTo('password');
		assertThat(store.certificates()).isEqualTo(certificates);
		assertThat(store.privateKey()).isEqualTo(privateKey);
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
class PemPrivateKeyParserTests {
	@ParameterizedTest
	// @formatter:off
	@CsvSource({
			'dsa.key,		DSA',
			'rsa.key,		RSA',
			'rsa-pss.key,	RSASSA-PSS'
	})
		// @formatter:on
	void shouldParseTraditionalPkcs8(String file, String algorithm) throws IOException {
		PrivateKey privateKey = PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs8/' + file));
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo(algorithm);
	}
	@ParameterizedTest
	// @formatter:off
	@CsvSource({
			'rsa.key,	RSA'
	})
		// @formatter:on
	void shouldParseTraditionalPkcs1(String file, String algorithm) throws IOException {
		PrivateKey privateKey = PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs1/' + file));
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo(algorithm);
	}
	@ParameterizedTest
	// @formatter:off
	@ValueSource(strings = {
			'dsa.key'
	})
		// @formatter:on
	void shouldNotParseUnsupportedTraditionalPkcs1(String file) {
		assertThatIllegalStateException()
			.isThrownBy(() -> PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs1/' + file)))
			.withMessageContaining('Missing private key or unrecognized format');
	}
	@ParameterizedTest
	// @formatter:off
	@CsvSource({
			'brainpoolP256r1.key,	brainpoolP256r1,	1.3.36.3.3.2.8.1.1.7',
			'brainpoolP320r1.key,	brainpoolP320r1,	1.3.36.3.3.2.8.1.1.9',
			'brainpoolP384r1.key,	brainpoolP384r1,	1.3.36.3.3.2.8.1.1.11',
			'brainpoolP512r1.key,	brainpoolP512r1,	1.3.36.3.3.2.8.1.1.13',
			'prime256v1.key,		secp256r1,			1.2.840.10045.3.1.7',
			'secp224r1.key,			secp224r1,			1.3.132.0.33',
			'secp256k1.key,			secp256k1,			1.3.132.0.10',
			'secp256r1.key,			secp256r1,			1.2.840.10045.3.1.7',
			'secp384r1.key,			secp384r1,			1.3.132.0.34',
			'secp521r1.key,			secp521r1,			1.3.132.0.35'
	})
		// @formatter:on
	void shouldParseEcPkcs8(String file, String curveName, String oid) throws IOException {
		PrivateKey privateKey = PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs8/' + file));
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('EC');
		assertThat(privateKey).isInstanceOf(ECPrivateKey.class);
		ECPrivateKey ecPrivateKey = (ECPrivateKey) privateKey;
		assertThat(ecPrivateKey.getParams().toString()).contains(curveName).contains(oid);
	}
	@ParameterizedTest
	// @formatter:off
	@ValueSource(strings = {
			'brainpoolP256t1.key',
			'brainpoolP320t1.key',
			'brainpoolP384t1.key',
			'brainpoolP512t1.key'
	})
		// @formatter:on
	void shouldNotParseUnsupportedEcPkcs8(String file) {
		assertThatIllegalStateException()
			.isThrownBy(() -> PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs8/' + file)))
			.withMessageContaining('Missing private key or unrecognized format');
	}
	@ParameterizedTest
	// @formatter:off
	@ValueSource(strings = {
			'ed448.key',
			'ed25519.key'
	})
		// @formatter:on
	void shouldParseEdDsaPkcs8(String file) throws IOException {
		PrivateKey privateKey = PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs8/' + file));
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('EdDSA');
	}
	@ParameterizedTest
	// @formatter:off
	@ValueSource(strings = {
			'x448.key',
			'x25519.key'
	})
		// @formatter:on
	void shouldParseXdhPkcs8(String file) throws IOException {
		PrivateKey privateKey = PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs8/' + file));
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('XDH');
	}
	@ParameterizedTest
	// @formatter:off
	@CsvSource({
			'brainpoolP256r1.key,	brainpoolP256r1,	1.3.36.3.3.2.8.1.1.7',
			'brainpoolP320r1.key,	brainpoolP320r1,	1.3.36.3.3.2.8.1.1.9',
			'brainpoolP384r1.key,	brainpoolP384r1,	1.3.36.3.3.2.8.1.1.11',
			'brainpoolP512r1.key,	brainpoolP512r1,	1.3.36.3.3.2.8.1.1.13',
			'prime256v1.key,		secp256r1,			1.2.840.10045.3.1.7',
			'secp224r1.key,			secp224r1,			1.3.132.0.33',
			'secp256k1.key,			secp256k1,			1.3.132.0.10',
			'secp256r1.key,			secp256r1,			1.2.840.10045.3.1.7',
			'secp384r1.key,			secp384r1,			1.3.132.0.34',
			'secp521r1.key,			secp521r1,			1.3.132.0.35'
	})
		// @formatter:on
	void shouldParseEcSec1(String file, String curveName, String oid) throws IOException {
		PrivateKey privateKey = PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/sec1/' + file));
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo('EC');
		assertThat(privateKey).isInstanceOf(ECPrivateKey.class);
		ECPrivateKey ecPrivateKey = (ECPrivateKey) privateKey;
		assertThat(ecPrivateKey.getParams().toString()).contains(curveName).contains(oid);
	}
	@ParameterizedTest
	// @formatter:off
	@ValueSource(strings = {
			'brainpoolP256t1.key',
			'brainpoolP320t1.key',
			'brainpoolP384t1.key',
			'brainpoolP512t1.key'
	})
		// @formatter:on
	void shouldNotParseUnsupportedEcSec1(String file) {
		assertThatIllegalStateException()
			.isThrownBy(() -> PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/sec1/' + file)))
			.withMessageContaining('Missing private key or unrecognized format');
	}
	@Test
	void parseWithNonKeyTextWillThrowException() {
		assertThatIllegalStateException().isThrownBy(() -> PemPrivateKeyParser.parse(read('test-banner.txt')));
	}
	@ParameterizedTest
	// @formatter:off
	@CsvSource({
			'dsa-aes-128-cbc.key,				DSA',
			'rsa-aes-256-cbc.key,				RSA',
			'prime256v1-aes-256-cbc.key,		EC',
			'ed25519-aes-256-cbc.key,			EdDSA',
			'x448-aes-256-cbc.key,				XDH'
	})
		// @formatter:on
	void shouldParseEncryptedPkcs8(String file, String algorithm) throws IOException {
		// Created with:
		// openssl pkcs8 -topk8 -in <input file> -out <output file> -v2 <algorithm>
		// -passout pass:test
		// where <algorithm> is aes128 or aes256
		PrivateKey privateKey = PemPrivateKeyParser.parse(read('org/springframework/boot/web/server/pkcs8/' + file),
				'test');
		assertThat(privateKey).isNotNull();
		assertThat(privateKey.getFormat()).isEqualTo('PKCS#8');
		assertThat(privateKey.getAlgorithm()).isEqualTo(algorithm);
	}
	@Test
	void shouldNotParseEncryptedPkcs8NotUsingAes() {
		// Created with:
		// openssl pkcs8 -topk8 -in rsa.key -out rsa-des-ede3-cbc.key -v2 des3 -passout
		// pass:test
		assertThatIllegalStateException()
			.isThrownBy(() -> PemPrivateKeyParser
				.parse(read('org/springframework/boot/web/server/pkcs8/rsa-des-ede3-cbc.key'), 'test'))
			.isInstanceOf(IllegalStateException.class)
			.withMessageContaining('Error decrypting private key');
	}
	@Test
	void shouldNotParseEncryptedPkcs8NotUsingPbkdf2() {
		// Created with:
		// openssl pkcs8 -topk8 -in rsa.key -out rsa-des-ede3-cbc.key -scrypt -passout
		// pass:test
		assertThatIllegalStateException()
			.isThrownBy(() -> PemPrivateKeyParser
				.parse(read('org/springframework/boot/web/server/pkcs8/rsa-scrypt.key'), 'test'))
			.withMessageContaining('Error decrypting private key');
	}
	@Test
	void shouldNotParseEncryptedSec1() {
		// created with:
		// openssl ecparam -genkey -name prime256v1 | openssl ec -aes-128-cbc -out
		// prime256v1-aes-128-cbc.key
		assertThatIllegalStateException()
			.isThrownBy(() -> PemPrivateKeyParser
				.parse(read('org/springframework/boot/web/server/sec1/prime256v1-aes-128-cbc.key'), 'test'))
			.withMessageContaining('Missing private key or unrecognized format');
	}
	@Test
	void shouldNotParseEncryptedPkcs1() {
		// created with:
		// openssl genrsa -aes-256-cbc -out rsa-aes-256-cbc.key
		assertThatIllegalStateException()
			.isThrownBy(() -> PemPrivateKeyParser
				.parse(read('org/springframework/boot/web/server/pkcs1/rsa-aes-256-cbc.key'), 'test'))
			.withMessageContaining('Missing private key or unrecognized format');
	}
	private String read(String path) throws IOException {
		return new ClassPathResource(path).getContentAsString(StandardCharsets.UTF_8);
	}
}
/*
package org.springframework.boot.ssl.pem;
/**
class PemSslStoreBundleTests {
	private static final String CERTIFICATE = '''
			-----BEGIN CERTIFICATE-----
			MIIDqzCCApOgAwIBAgIIFMqbpqvipw0wDQYJKoZIhvcNAQELBQAwbDELMAkGA1UE
			BhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQBgNVBAcTCVBhbG8gQWx0bzEP
			MA0GA1UEChMGVk13YXJlMQ8wDQYDVQQLEwZTcHJpbmcxEjAQBgNVBAMTCWxvY2Fs
			aG9zdDAgFw0yMzA1MDUxMTI2NThaGA8yMTIzMDQxMTExMjY1OFowbDELMAkGA1UE
			BhMCVVMxEzARBgNVBAgTCkNhbGlmb3JuaWExEjAQBgNVBAcTCVBhbG8gQWx0bzEP
			MA0GA1UEChMGVk13YXJlMQ8wDQYDVQQLEwZTcHJpbmcxEjAQBgNVBAMTCWxvY2Fs
			aG9zdDCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAPwHWxoE3xjRmNdD
			+m+e/aFlr5wEGQUdWSDD613OB1w7kqO/audEp3c6HxDB3GPcEL0amJwXgY6CQMYu
			sythuZX/EZSc2HdilTBu/5T+mbdWe5JkKThpiA0RYeucQfKuB7zv4ypioa4wiR4D
			nPsZXjg95OF8pCzYEssv8wT49v+M3ohWUgfF0FPlMFCSo0YVTuzB1mhDlWKq/jhQ
			11WpTmk/dQX+l6ts6bYIcJt4uItG+a68a4FutuSjZdTAE0f5SOYRBpGH96mjLwEP
			fW8ZjzvKb9g4R2kiuoPxvCDs1Y/8V2yvKqLyn5Tx9x/DjFmOi0DRK/TgELvNceCb
			UDJmhXMCAwEAAaNPME0wHQYDVR0OBBYEFMBIGU1nwix5RS3O5hGLLoMdR1+NMCwG
			A1UdEQQlMCOCCWxvY2FsaG9zdIcQAAAAAAAAAAAAAAAAAAAAAYcEfwAAATANBgkq
			hkiG9w0BAQsFAAOCAQEAhepfJgTFvqSccsT97XdAZfvB0noQx5NSynRV8NWmeOld
			hHP6Fzj6xCxHSYvlUfmX8fVP9EOAuChgcbbuTIVJBu60rnDT21oOOnp8FvNonCV6
			gJ89sCL7wZ77dw2RKIeUFjXXEV3QJhx2wCOVmLxnJspDoKFIEVjfLyiPXKxqe/6b
			dG8zzWDZ6z+M2JNCtVoOGpljpHqMPCmbDktncv6H3dDTZ83bmLj1nbpOU587gAJ8
			fl1PiUDyPRIl2cnOJd+wCHKsyym/FL7yzk0OSEZ81I92LpGd/0b2Ld3m/bpe+C4Z
			ILzLXTnC6AhrLcDc9QN/EO+BiCL52n7EplNLtSn1LQ==
			-----END CERTIFICATE-----
			'''.strip();
	private static final String PRIVATE_KEY = '''
			-----BEGIN PRIVATE KEY-----
			MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQD8B1saBN8Y0ZjX
			Q/pvnv2hZa+cBBkFHVkgw+tdzgdcO5Kjv2rnRKd3Oh8Qwdxj3BC9GpicF4GOgkDG
			LrMrYbmV/xGUnNh3YpUwbv+U/pm3VnuSZCk4aYgNEWHrnEHyrge87+MqYqGuMIke
			A5z7GV44PeThfKQs2BLLL/ME+Pb/jN6IVlIHxdBT5TBQkqNGFU7swdZoQ5Viqv44
			UNdVqU5pP3UF/perbOm2CHCbeLiLRvmuvGuBbrbko2XUwBNH+UjmEQaRh/epoy8B
			D31vGY87ym/YOEdpIrqD8bwg7NWP/Fdsryqi8p+U8fcfw4xZjotA0Sv04BC7zXHg
			m1AyZoVzAgMBAAECggEAfEqiZqANaF+BqXQIb4Dw42ZTJzWsIyYYnPySOGZRoe5t
			QJ03uwtULYv34xtANe1DQgd6SMyc46ugBzzjtprQ3ET5Jhn99U6kdcjf+dpf85dO
			hOEppP0CkDNI39nleinSfh6uIOqYgt/D143/nqQhn8oCdSOzkbwT9KnWh1bC9T7I
			vFjGfElvt1/xl88qYgrWgYLgXaencNGgiv/4/M0FNhiHEGsVC7SCu6kapC/WIQpE
			5IdV+HR+tiLoGZhXlhqorY7QC4xKC4wwafVSiFxqDOQAuK+SMD4TCEv0Aop+c+SE
			YBigVTmgVeJkjK7IkTEhKkAEFmRF5/5w+bZD9FhTNQKBgQD+4fNG1ChSU8RdizZT
			5dPlDyAxpETSCEXFFVGtPPh2j93HDWn7XugNyjn5FylTH507QlabC+5wZqltdIjK
			GRB5MIinQ9/nR2fuwGc9s+0BiSEwNOUB1MWm7wWL/JUIiKq6sTi6sJIfsYg79zco
			qxl5WE94aoINx9Utq1cdWhwJTQKBgQD9IjPksd4Jprz8zMrGLzR8k1gqHyhv24qY
			EJ7jiHKKAP6xllTUYwh1IBSL6w2j5lfZPpIkb4Jlk2KUoX6fN81pWkBC/fTBUSIB
			EHM9bL51+yKEYUbGIy/gANuRbHXsWg3sjUsFTNPN4hGTFk3w2xChCyl/f5us8Lo8
			Z633SNdpvwKBgQCGyDU9XzNzVZihXtx7wS0sE7OSjKtX5cf/UCbA1V0OVUWR3SYO
			J0HPCQFfF0BjFHSwwYPKuaR9C8zMdLNhK5/qdh/NU7czNi9fsZ7moh7SkRFbzJzN
			OxbKD9t/CzJEMQEXeF/nWTfsSpUgILqqZtAxuuFLbAcaAnJYlCKdAumQgQKBgQCK
			mqjJh68pn7gJwGUjoYNe1xtGbSsqHI9F9ovZ0MPO1v6e5M7sQJHH+Fnnxzv/y8e8
			d6tz8e73iX1IHymDKv35uuZHCGF1XOR+qrA/KQUc+vcKf21OXsP/JtkTRs1HLoRD
			S5aRf2DWcfvniyYARSNU2xTM8GWgi2ueWbMDHUp+ZwKBgA/swC+K+Jg5DEWm6Sau
			e6y+eC6S+SoXEKkI3wf7m9aKoZo0y+jh8Gas6gratlc181pSM8O3vZG0n19b493I
			apCFomMLE56zEzvyzfpsNhFhk5MBMCn0LPyzX6MiynRlGyWIj0c99fbHI3pOMufP
			WgmVLTZ8uDcSW1MbdUCwFSk5
			-----END PRIVATE KEY-----
			'''.strip();
	private static final char[] EMPTY_KEY_PASSWORD = new char[] {};
	@Test
	void createWithDetailsWhenNullStores() {
		PemSslStoreDetails keyStoreDetails = null;
		PemSslStoreDetails trustStoreDetails = null;
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).isNull();
		assertThat(bundle.getKeyStorePassword()).isNull();
		assertThat(bundle.getTrustStore()).isNull();
	}
	@Test
	void createWithDetailsWhenStoresHaveNoValues() {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate(null);
		PemSslStoreDetails trustStoreDetails = PemSslStoreDetails.forCertificate(null);
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).isNull();
		assertThat(bundle.getKeyStorePassword()).isNull();
		assertThat(bundle.getTrustStore()).isNull();
	}
	@Test
	void createWithDetailsWhenHasKeyStoreDetailsCertAndKey() {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:test-key.pem');
		PemSslStoreDetails trustStoreDetails = null;
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('ssl'));
		assertThat(bundle.getTrustStore()).isNull();
	}
	@Test
	void createWithDetailsWhenHasKeyStoreDetailsCertAndEncryptedKey() {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:ssl/pkcs8/key-rsa-encrypted.pem')
			.withPrivateKeyPassword('test');
		PemSslStoreDetails trustStoreDetails = null;
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('ssl'));
		assertThat(bundle.getTrustStore()).isNull();
	}
	@Test
	void createWithDetailsWhenHasKeyStoreDetailsAndTrustStoreDetailsWithoutKey() {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:test-key.pem');
		PemSslStoreDetails trustStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem');
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('ssl'));
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCert('ssl'));
	}
	@Test
	void createWithDetailsWhenHasKeyStoreDetailsAndTrustStoreDetails() {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:test-key.pem');
		PemSslStoreDetails trustStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:test-key.pem');
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('ssl'));
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('ssl'));
	}
	@Test
	void createWithDetailsWhenHasEmbeddedKeyStoreDetailsAndTrustStoreDetails() {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate(CERTIFICATE).withPrivateKey(PRIVATE_KEY);
		PemSslStoreDetails trustStoreDetails = PemSslStoreDetails.forCertificate(CERTIFICATE)
			.withPrivateKey(PRIVATE_KEY);
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('ssl'));
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('ssl'));
	}
	@Test
	void createWithDetailsWhenHasStoreType() {
		PemSslStoreDetails keyStoreDetails = new PemSslStoreDetails('PKCS12', 'classpath:test-cert.pem',
				'classpath:test-key.pem');
		PemSslStoreDetails trustStoreDetails = new PemSslStoreDetails('PKCS12', 'classpath:test-cert.pem',
				'classpath:test-key.pem');
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('PKCS12', 'ssl'));
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('PKCS12', 'ssl'));
	}
	@Test
	void createWithDetailsWhenHasKeyStoreDetailsAndTrustStoreDetailsAndKeyPassword() {
		PemSslStoreDetails keyStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:test-key.pem')
			.withAlias('ksa')
			.withPassword('kss');
		PemSslStoreDetails trustStoreDetails = PemSslStoreDetails.forCertificate('classpath:test-cert.pem')
			.withPrivateKey('classpath:test-key.pem')
			.withAlias('tsa')
			.withPassword('tss');
		PemSslStoreBundle bundle = new PemSslStoreBundle(keyStoreDetails, trustStoreDetails);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('ksa', 'kss'.toCharArray()));
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('tsa', 'tss'.toCharArray()));
	}
	@Test
	void createWithPemSslStoreCreatesInstance() {
		List<X509Certificate> certificates = PemContent.of(CERTIFICATE).getCertificates();
		PrivateKey privateKey = PemContent.of(PRIVATE_KEY).getPrivateKey();
		PemSslStore pemSslStore = PemSslStore.of(certificates, privateKey);
		PemSslStoreBundle bundle = new PemSslStoreBundle(pemSslStore, pemSslStore);
		assertThat(bundle.getKeyStore()).satisfies(storeContainingCertAndKey('ssl'));
		assertThat(bundle.getTrustStore()).satisfies(storeContainingCertAndKey('ssl'));
	}
	@Test
	void storeCreationIsLazy() {
		PemSslStore pemSslStore = mock(PemSslStore.class);
		PemSslStoreBundle bundle = new PemSslStoreBundle(pemSslStore, pemSslStore);
		given(pemSslStore.certificates()).willReturn(PemContent.of(CERTIFICATE).getCertificates());
		then(pemSslStore).shouldHaveNoInteractions();
		bundle.getKeyStore();
		then(pemSslStore).should().certificates();
		bundle.getTrustStore();
		then(pemSslStore).should(times(2)).certificates();
	}
	private Consumer<KeyStore> storeContainingCert(String keyAlias) {
		return storeContainingCert(KeyStore.getDefaultType(), keyAlias);
	}
	private Consumer<KeyStore> storeContainingCert(String keyStoreType, String keyAlias) {
		return ThrowingConsumer.of((keyStore) -> {
			assertThat(keyStore).isNotNull();
			assertThat(keyStore.getType()).isEqualTo(keyStoreType);
			assertThat(keyStore.containsAlias(keyAlias)).isTrue();
			assertThat(keyStore.getCertificate(keyAlias)).isNotNull();
			assertThat(keyStore.getKey(keyAlias, EMPTY_KEY_PASSWORD)).isNull();
		});
	}
	private Consumer<KeyStore> storeContainingCertAndKey(String keyAlias) {
		return storeContainingCertAndKey(KeyStore.getDefaultType(), keyAlias);
	}
	private Consumer<KeyStore> storeContainingCertAndKey(String keyStoreType, String keyAlias) {
		return storeContainingCertAndKey(keyStoreType, keyAlias, EMPTY_KEY_PASSWORD);
	}
	private Consumer<KeyStore> storeContainingCertAndKey(String keyAlias, char[] keyPassword) {
		return storeContainingCertAndKey(KeyStore.getDefaultType(), keyAlias, keyPassword);
	}
	private Consumer<KeyStore> storeContainingCertAndKey(String keyStoreType, String keyAlias, char[] keyPassword) {
		return ThrowingConsumer.of((keyStore) -> {
			assertThat(keyStore).isNotNull();
			assertThat(keyStore.getType()).isEqualTo(keyStoreType);
			assertThat(keyStore.containsAlias(keyAlias)).isTrue();
			assertThat(keyStore.getCertificate(keyAlias)).isNotNull();
			assertThat(keyStore.getKey(keyAlias, keyPassword)).isNotNull();
		});
	}
}
/*
package org.springframework.boot.ssl;
/**
class NoSuchSslBundleExceptionTests {
	@Test
	void createCreatesException() {
		Throwable cause = new RuntimeException();
		NoSuchSslBundleException exception = new NoSuchSslBundleException('name', 'badness', cause);
		assertThat(exception).hasMessage('badness').hasCause(cause);
		assertThat(exception.getBundleName()).isEqualTo('name');
	}
}
/*
package org.springframework.boot;
/**
class SpringApplicationShutdownHookTests {
	@Test
	void shutdownHookIsNotAddedUntilContextIsRegistered() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		shutdownHook.enableShutdownHookAddition();
		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isFalse();
		ConfigurableApplicationContext context = new GenericApplicationContext();
		shutdownHook.registerApplicationContext(context);
		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isTrue();
	}
	@Test
	void shutdownHookIsNotAddedUntilHandlerIsRegistered() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		shutdownHook.enableShutdownHookAddition();
		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isFalse();
		shutdownHook.getHandlers().add(() -> {
		});
		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isTrue();
	}
	@Test
	void shutdownHookIsNotAddedUntilAdditionIsEnabled() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		shutdownHook.getHandlers().add(() -> {
		});
		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isFalse();
		shutdownHook.enableShutdownHookAddition();
		shutdownHook.getHandlers().add(() -> {
		});
		assertThat(shutdownHook.isRuntimeShutdownHookAdded()).isTrue();
	}
	@Test
	void runClosesContextsBeforeRunningHandlerActions() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		List<Object> finished = new CopyOnWriteArrayList<>();
		ConfigurableApplicationContext context = new TestApplicationContext(finished);
		shutdownHook.registerApplicationContext(context);
		context.refresh();
		Runnable handlerAction = new TestHandlerAction(finished);
		shutdownHook.getHandlers().add(handlerAction);
		shutdownHook.run();
		assertThat(finished).containsExactly(context, handlerAction);
	}
	@Test
	void runWhenContextIsBeingClosedInAnotherThreadWaitsUntilContextIsInactive() throws InterruptedException {
		// This situation occurs in the Spring Tools IDE. It triggers a context close via
		// JMX and then stops the JVM. The two actions happen almost simultaneously
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		List<Object> finished = new CopyOnWriteArrayList<>();
		CountDownLatch closing = new CountDownLatch(1);
		CountDownLatch proceedWithClose = new CountDownLatch(1);
		ConfigurableApplicationContext context = new TestApplicationContext(finished, closing, proceedWithClose);
		shutdownHook.registerApplicationContext(context);
		context.refresh();
		Runnable handlerAction = new TestHandlerAction(finished);
		shutdownHook.getHandlers().add(handlerAction);
		Thread contextThread = new Thread(context::close);
		contextThread.start();
		// Wait for context thread to begin closing the context
		closing.await();
		Thread shutdownThread = new Thread(shutdownHook);
		shutdownThread.start();
		// Shutdown thread should start waiting for context to become inactive
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(shutdownThread::getState, State.WAITING::equals);
		// Allow context thread to proceed, unblocking shutdown thread
		proceedWithClose.countDown();
		contextThread.join();
		shutdownThread.join();
		// Context should have been closed before handler action was run
		assertThat(finished).containsExactly(context, handlerAction);
	}
	@Test
	void runDueToExitDuringRefreshWhenContextHasBeenClosedDoesNotDeadlock() {
		GenericApplicationContext context = new GenericApplicationContext();
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		shutdownHook.registerApplicationContext(context);
		context.registerBean(CloseContextAndExit.class, context, shutdownHook);
		context.refresh();
	}
	@Test
	void runWhenContextIsClosedDirectlyRunsHandlerActions() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		List<Object> finished = new CopyOnWriteArrayList<>();
		ConfigurableApplicationContext context = new TestApplicationContext(finished);
		shutdownHook.registerApplicationContext(context);
		context.refresh();
		context.close();
		Runnable handlerAction1 = new TestHandlerAction(finished);
		Runnable handlerAction2 = new TestHandlerAction(finished);
		shutdownHook.getHandlers().add(handlerAction1);
		shutdownHook.getHandlers().add(handlerAction2);
		shutdownHook.run();
		assertThat(finished).contains(handlerAction1, handlerAction2);
	}
	@Test
	void addHandlerActionWhenNullThrowsException() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		assertThatIllegalArgumentException().isThrownBy(() -> shutdownHook.getHandlers().add(null))
			.withMessage('Action must not be null');
	}
	@Test
	void addHandlerActionWhenShuttingDownThrowsException() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		shutdownHook.run();
		Runnable handlerAction = new TestHandlerAction(new ArrayList<>());
		assertThatIllegalStateException().isThrownBy(() -> shutdownHook.getHandlers().add(handlerAction))
			.withMessage('Shutdown in progress');
	}
	@Test
	void removeHandlerActionWhenNullThrowsException() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		assertThatIllegalArgumentException().isThrownBy(() -> shutdownHook.getHandlers().remove(null))
			.withMessage('Action must not be null');
	}
	@Test
	void removeHandlerActionWhenShuttingDownThrowsException() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		Runnable handlerAction = new TestHandlerAction(new ArrayList<>());
		shutdownHook.getHandlers().add(handlerAction);
		shutdownHook.run();
		assertThatIllegalStateException().isThrownBy(() -> shutdownHook.getHandlers().remove(handlerAction))
			.withMessage('Shutdown in progress');
	}
	@Test
	void failsWhenDeregisterActiveContext() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		ConfigurableApplicationContext context = new GenericApplicationContext();
		shutdownHook.registerApplicationContext(context);
		context.refresh();
		assertThatIllegalStateException().isThrownBy(() -> shutdownHook.deregisterFailedApplicationContext(context));
		assertThat(shutdownHook.isApplicationContextRegistered(context)).isTrue();
	}
	@Test
	void deregistersFailedContext() {
		TestSpringApplicationShutdownHook shutdownHook = new TestSpringApplicationShutdownHook();
		GenericApplicationContext context = new GenericApplicationContext();
		shutdownHook.registerApplicationContext(context);
		context.registerBean(FailingBean.class);
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(context::refresh);
		assertThat(shutdownHook.isApplicationContextRegistered(context)).isTrue();
		shutdownHook.deregisterFailedApplicationContext(context);
		assertThat(shutdownHook.isApplicationContextRegistered(context)).isFalse();
	}
	static class TestSpringApplicationShutdownHook extends SpringApplicationShutdownHook {
		private boolean runtimeShutdownHookAdded;
		@Override
		protected void addRuntimeShutdownHook() {
			this.runtimeShutdownHookAdded = true;
		}
		boolean isRuntimeShutdownHookAdded() {
			return this.runtimeShutdownHookAdded;
		}
	}
	static class TestApplicationContext extends AbstractApplicationContext {
		private final ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		private final List<Object> finished;
		private final CountDownLatch closing;
		private final CountDownLatch proceedWithClose;
		TestApplicationContext(List<Object> finished) {
			this(finished, null, null);
		}
		TestApplicationContext(List<Object> finished, CountDownLatch closing, CountDownLatch proceedWithClose) {
			this.finished = finished;
			this.closing = closing;
			this.proceedWithClose = proceedWithClose;
		}
		@Override
		protected void refreshBeanFactory() {
		}
		@Override
		protected void closeBeanFactory() {
		}
		@Override
		protected void onClose() {
			if (this.closing != null) {
				this.closing.countDown();
			}
			if (this.proceedWithClose != null) {
				try {
					this.proceedWithClose.await(1, TimeUnit.MINUTES);
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
			}
			this.finished.add(this);
		}
		@Override
		public ConfigurableListableBeanFactory getBeanFactory() {
			return this.beanFactory;
		}
	}
	static class TestHandlerAction implements Runnable {
		private final List<Object> finished;
		TestHandlerAction(List<Object> finished) {
			this.finished = finished;
		}
		@Override
		public void run() {
			this.finished.add(this);
		}
	}
	static class CloseContextAndExit implements InitializingBean {
		private final ConfigurableApplicationContext context;
		private final Runnable shutdownHook;
		CloseContextAndExit(ConfigurableApplicationContext context, SpringApplicationShutdownHook shutdownHook) {
			this.context = context;
			this.shutdownHook = shutdownHook;
		}
		@Override
		public void afterPropertiesSet() throws Exception {
			this.context.close();
			// Simulate System.exit by running the hook on a separate thread and waiting
			// for it to complete
			Thread thread = new Thread(this.shutdownHook);
			thread.start();
			thread.join(15000);
			assertThat(thread.isAlive()).isFalse();
		}
	}
	static class FailingBean implements InitializingBean {
		@Override
		public void afterPropertiesSet() throws Exception {
			throw new IllegalArgumentException('test failure');
		}
	}
}
/*
package org.springframework.boot.io;
/**
class ProtocolResolverApplicationContextInitializerTests {
	@Test
	void initializeAddsProtocolResolversToApplicationContext() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext()) {
			ProtocolResolverApplicationContextInitializer initializer = new ProtocolResolverApplicationContextInitializer();
			initializer.initialize(context);
			assertThat(context).isInstanceOf(DefaultResourceLoader.class);
			Collection<ProtocolResolver> protocolResolvers = ((DefaultResourceLoader) context).getProtocolResolvers();
			assertThat(protocolResolvers).hasExactlyElementsOfTypes(Base64ProtocolResolver.class);
		}
	}
}
/*
package org.springframework.boot.io;
/**
class ReverseStringProtocolResolver implements ProtocolResolver {
	private static final String PREFIX = 'reverse:';
	@Override
	public Resource resolve(String location, ResourceLoader resourceLoader) {
		if (!location.startsWith(PREFIX)) {
			return null;
		}
		return new ByteArrayResource(reverse(location.substring(PREFIX.length())));
	}
	private byte[] reverse(String substring) {
		return new StringBuilder(substring).reverse().toString().getBytes(StandardCharsets.UTF_8);
	}
}
/*
package org.springframework.boot.io;
/**
class ProtocolResolverApplicationContextInitializerIntegrationTests {
	@Test
	void base64ResourceResolves() throws IOException {
		SpringApplication application = new SpringApplication(TestConfiguration.class);
		application.setDefaultProperties(Map.of('test.resource', 'base64:dGVzdC12YWx1ZQ=='));
		application.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableApplicationContext context = application.run();
		TestProperties propertiesBean = context.getBean(TestProperties.class);
		Resource resource = propertiesBean.getResource();
		assertThat(resource).isNotNull();
		assertThat(resource.exists()).isTrue();
		assertThat(resource.getContentAsString(Charset.defaultCharset())).isEqualTo('test-value');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(TestProperties.class)
	static class TestConfiguration {
	}
	@ConfigurationProperties(prefix = 'test')
	static class TestProperties {
		Resource resource;
		Resource getResource() {
			return this.resource;
		}
		void setResource(Resource resource) {
			this.resource = resource;
		}
	}
}
/*
package org.springframework.boot.io;
/**
class Base64ProtocolResolverTests {
	@Test
	void base64LocationResolves() throws IOException {
		String location = Base64.getEncoder().encodeToString('test value'.getBytes());
		Resource resource = new Base64ProtocolResolver().resolve('base64:' + location, new DefaultResourceLoader());
		assertThat(resource).isNotNull();
		assertThat(resource.getContentAsString(StandardCharsets.UTF_8)).isEqualTo('test value');
	}
	@Test
	void base64LocationWithInvalidBase64ThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new Base64ProtocolResolver().resolve('base64:not valid base64', new DefaultResourceLoader()))
			.withMessageContaining('Illegal base64');
	}
	@Test
	void locationWithoutPrefixDoesNotResolve() {
		Resource resource = new Base64ProtocolResolver().resolve('file:notbase64.txt', new DefaultResourceLoader());
		assertThat(resource).isNull();
	}
}
/*
package org.springframework.boot.io;
/**
class ApplicationResourceLoaderTests {
	private static final String SPRING_FACTORIES = 'META-INF/spring.factories';
	private static final String TEST_PROTOCOL_RESOLVERS_FACTORIES = 'META-INF/spring-test-protocol-resolvers.factories';
	private static final String TEST_BASE_64_VALUE = Base64.getEncoder().encodeToString('test'.getBytes());
	@Test
	void getIncludesProtocolResolvers() throws IOException {
		ResourceLoader loader = ApplicationResourceLoader.get();
		Resource resource = loader.getResource('base64:' + TEST_BASE_64_VALUE);
		assertThat(contentAsString(resource)).isEqualTo('test');
	}
	@Test
	void getWithClassPathIncludesProtocolResolvers() throws IOException {
		ClassLoader classLoader = new TestClassLoader(this::useTestProtocolResolversFactories);
		ResourceLoader loader = ApplicationResourceLoader.get(classLoader);
		Resource resource = loader.getResource('reverse:test');
		assertThat(contentAsString(resource)).isEqualTo('tset');
	}
	@Test
	void getWithClassPathWhenClassPathIsNullIncludesProtocolResolvers() throws IOException {
		ResourceLoader loader = ApplicationResourceLoader.get((ClassLoader) null);
		Resource resource = loader.getResource('base64:' + TEST_BASE_64_VALUE);
		assertThat(contentAsString(resource)).isEqualTo('test');
	}
	@Test
	void getWithClassPathAndSpringFactoriesLoaderIncludesProtocolResolvers() throws IOException {
		SpringFactoriesLoader springFactoriesLoader = SpringFactoriesLoader
			.forResourceLocation(TEST_PROTOCOL_RESOLVERS_FACTORIES);
		ResourceLoader loader = ApplicationResourceLoader.get((ClassLoader) null, springFactoriesLoader);
		Resource resource = loader.getResource('reverse:test');
		assertThat(contentAsString(resource)).isEqualTo('tset');
	}
	@Test
	void getWithClassPathAndSpringFactoriesLoaderWhenSpringFactoriesLoaderIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ApplicationResourceLoader.get((ClassLoader) null, null))
			.withMessage('"springFactoriesLoader" must not be null');
	}
	@Test
	void getWithResourceLoaderIncludesProtocolResolvers() throws IOException {
		ResourceLoader loader = ApplicationResourceLoader.get(new DefaultResourceLoader());
		Resource resource = loader.getResource('base64:' + TEST_BASE_64_VALUE);
		assertThat(contentAsString(resource)).isEqualTo('test');
	}
	@Test
	void getWithResourceLoaderDelegatesLoading() throws IOException {
		DefaultResourceLoader delegate = new TestResourceLoader();
		ResourceLoader loader = ApplicationResourceLoader.get(delegate);
		assertThat(contentAsString(loader.getResource('spring'))).isEqualTo('boot');
	}
	@Test
	void getWithResourceLoaderWhenResourceLoaderIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ApplicationResourceLoader.get((ResourceLoader) null))
			.withMessage('"resourceLoader" must not be null');
	}
	@Test
	void getWithResourceLoaderAndSpringFactoriesLoaderIncludesProtocolResolvers() throws IOException {
		DefaultResourceLoader delegate = new TestResourceLoader();
		ResourceLoader loader = ApplicationResourceLoader.get(delegate);
		Resource resource = loader.getResource('base64:' + TEST_BASE_64_VALUE);
		assertThat(contentAsString(resource)).isEqualTo('test');
	}
	@Test
	void getWithResourceLoaderAndSpringFactoriesLoaderWhenResourceLoaderIsNullThrowsException() {
		SpringFactoriesLoader springFactoriesLoader = SpringFactoriesLoader
			.forResourceLocation(TEST_PROTOCOL_RESOLVERS_FACTORIES);
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ApplicationResourceLoader.get((ResourceLoader) null, springFactoriesLoader))
			.withMessage('"resourceLoader" must not be null');
	}
	@Test
	void getWithResourceLoaderAndSpringFactoriesLoaderWhenSpringFactoriesLoaderIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ApplicationResourceLoader.get(new TestResourceLoader(), null))
			.withMessage('"springFactoriesLoader" must not be null');
	}
	@Test
	void getResourceWhenPathIsRelative() throws IOException {
		ResourceLoader loader = ApplicationResourceLoader.get();
		String name = 'src/test/resources/' + TEST_PROTOCOL_RESOLVERS_FACTORIES;
		Resource resource = loader.getResource(name);
		assertThat(resource.getFile()).isEqualTo(new File(name));
	}
	@Test
	void getResourceWhenPathIsAbsolute() throws IOException {
		File file = new File('src/test/resources/' + TEST_PROTOCOL_RESOLVERS_FACTORIES);
		ResourceLoader loader = ApplicationResourceLoader.get();
		Resource resource = loader.getResource(file.getAbsolutePath());
		assertThat(resource.getFile()).hasSameBinaryContentAs(file);
	}
	@Test
	void getResourceWhenPathIsNull() {
		ResourceLoader loader = ApplicationResourceLoader.get();
		assertThatIllegalArgumentException().isThrownBy(() -> loader.getResource(null))
			.withMessage('Location must not be null');
	}
	@Test
	void getClassLoaderReturnsDelegateClassLoader() {
		ClassLoader classLoader = new TestClassLoader(this::useTestProtocolResolversFactories);
		ResourceLoader loader = ApplicationResourceLoader.get(new DefaultResourceLoader(classLoader));
		assertThat(loader.getClassLoader()).isSameAs(classLoader);
	}
	private String contentAsString(Resource resource) throws IOException {
		return resource.getContentAsString(StandardCharsets.UTF_8);
	}
	private String useTestProtocolResolversFactories(String name) {
		return (!SPRING_FACTORIES.equals(name)) ? name : TEST_PROTOCOL_RESOLVERS_FACTORIES;
	}
	static class TestClassLoader extends ClassLoader {
		private final UnaryOperator<String> mapper;
		TestClassLoader(UnaryOperator<String> mapper) {
			super(Thread.currentThread().getContextClassLoader());
			this.mapper = mapper;
		}
		@Override
		public URL getResource(String name) {
			return super.getResource(this.mapper.apply(name));
		}
		@Override
		public Enumeration<URL> getResources(String name) throws IOException {
			return super.getResources(this.mapper.apply(name));
		}
	}
	static class TestResourceLoader extends DefaultResourceLoader {
		@Override
		public Resource getResource(String location) {
			return (!'spring'.equals(location)) ? super.getResource(location)
					: new ByteArrayResource('boot'.getBytes(StandardCharsets.UTF_8));
		}
	}
}
/*
package org.springframework.boot.convert;
/**
class PeriodStyleTests {
	@Test
	void detectAndParseWhenValueIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> PeriodStyle.detectAndParse(null))
			.withMessageContaining('Value must not be null');
	}
	@Test
	void detectAndParseWhenIso8601ShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('p15m')).isEqualTo(Period.parse('p15m'));
		assertThat(PeriodStyle.detectAndParse('P15M')).isEqualTo(Period.parse('P15M'));
		assertThat(PeriodStyle.detectAndParse('-P15M')).isEqualTo(Period.parse('P-15M'));
		assertThat(PeriodStyle.detectAndParse('+P15M')).isEqualTo(Period.parse('P15M'));
		assertThat(PeriodStyle.detectAndParse('P2D')).isEqualTo(Period.parse('P2D'));
		assertThat(PeriodStyle.detectAndParse('-P20Y')).isEqualTo(Period.parse('P-20Y'));
	}
	@Test
	void detectAndParseWhenSimpleDaysShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('10d')).hasDays(10);
		assertThat(PeriodStyle.detectAndParse('10D')).hasDays(10);
		assertThat(PeriodStyle.detectAndParse('+10d')).hasDays(10);
		assertThat(PeriodStyle.detectAndParse('-10D')).hasDays(-10);
	}
	@Test
	void detectAndParseWhenSimpleWeeksShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('10w')).isEqualTo(Period.ofWeeks(10));
		assertThat(PeriodStyle.detectAndParse('10W')).isEqualTo(Period.ofWeeks(10));
		assertThat(PeriodStyle.detectAndParse('+10w')).isEqualTo(Period.ofWeeks(10));
		assertThat(PeriodStyle.detectAndParse('-10W')).isEqualTo(Period.ofWeeks(-10));
	}
	@Test
	void detectAndParseWhenSimpleMonthsShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('10m')).hasMonths(10);
		assertThat(PeriodStyle.detectAndParse('10M')).hasMonths(10);
		assertThat(PeriodStyle.detectAndParse('+10m')).hasMonths(10);
		assertThat(PeriodStyle.detectAndParse('-10M')).hasMonths(-10);
	}
	@Test
	void detectAndParseWhenSimpleYearsShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('10y')).hasYears(10);
		assertThat(PeriodStyle.detectAndParse('10Y')).hasYears(10);
		assertThat(PeriodStyle.detectAndParse('+10y')).hasYears(10);
		assertThat(PeriodStyle.detectAndParse('-10Y')).hasYears(-10);
	}
	@Test
	void detectAndParseWhenSimpleWithoutSuffixShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('10')).hasDays(10);
		assertThat(PeriodStyle.detectAndParse('+10')).hasDays(10);
		assertThat(PeriodStyle.detectAndParse('-10')).hasDays(-10);
	}
	@Test
	void detectAndParseWhenSimpleWithoutSuffixButWithChronoUnitShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('10', ChronoUnit.MONTHS)).hasMonths(10);
		assertThat(PeriodStyle.detectAndParse('+10', ChronoUnit.MONTHS)).hasMonths(10);
		assertThat(PeriodStyle.detectAndParse('-10', ChronoUnit.MONTHS)).hasMonths(-10);
	}
	@Test
	void detectAndParseWhenComplexShouldReturnPeriod() {
		assertThat(PeriodStyle.detectAndParse('1y2m')).isEqualTo(Period.of(1, 2, 0));
		assertThat(PeriodStyle.detectAndParse('1y2m3d')).isEqualTo(Period.of(1, 2, 3));
		assertThat(PeriodStyle.detectAndParse('2m3d')).isEqualTo(Period.of(0, 2, 3));
		assertThat(PeriodStyle.detectAndParse('1y3d')).isEqualTo(Period.of(1, 0, 3));
		assertThat(PeriodStyle.detectAndParse('-1y3d')).isEqualTo(Period.of(-1, 0, 3));
		assertThat(PeriodStyle.detectAndParse('-1y-3d')).isEqualTo(Period.of(-1, 0, -3));
	}
	@Test
	void detectAndParseWhenBadFormatShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> PeriodStyle.detectAndParse('10foo'))
			.withMessageContaining('"10foo" is not a valid period');
	}
	@Test
	void detectWhenSimpleShouldReturnSimple() {
		assertThat(PeriodStyle.detect('10')).isEqualTo(PeriodStyle.SIMPLE);
		assertThat(PeriodStyle.detect('+10')).isEqualTo(PeriodStyle.SIMPLE);
		assertThat(PeriodStyle.detect('-10')).isEqualTo(PeriodStyle.SIMPLE);
		assertThat(PeriodStyle.detect('10m')).isEqualTo(PeriodStyle.SIMPLE);
		assertThat(PeriodStyle.detect('10y')).isEqualTo(PeriodStyle.SIMPLE);
		assertThat(PeriodStyle.detect('10d')).isEqualTo(PeriodStyle.SIMPLE);
		assertThat(PeriodStyle.detect('10D')).isEqualTo(PeriodStyle.SIMPLE);
	}
	@Test
	void detectWhenIso8601ShouldReturnIso8601() {
		assertThat(PeriodStyle.detect('p20')).isEqualTo(PeriodStyle.ISO8601);
		assertThat(PeriodStyle.detect('P20')).isEqualTo(PeriodStyle.ISO8601);
		assertThat(PeriodStyle.detect('-P15M')).isEqualTo(PeriodStyle.ISO8601);
		assertThat(PeriodStyle.detect('+P15M')).isEqualTo(PeriodStyle.ISO8601);
		assertThat(PeriodStyle.detect('P10Y')).isEqualTo(PeriodStyle.ISO8601);
		assertThat(PeriodStyle.detect('P2D')).isEqualTo(PeriodStyle.ISO8601);
		assertThat(PeriodStyle.detect('-P6')).isEqualTo(PeriodStyle.ISO8601);
		assertThat(PeriodStyle.detect('-P-6M')).isEqualTo(PeriodStyle.ISO8601);
	}
	@Test
	void detectWhenUnknownShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> PeriodStyle.detect('bad'))
			.withMessageContaining('"bad" is not a valid period');
	}
	@Test
	void parseIso8601ShouldParse() {
		assertThat(PeriodStyle.ISO8601.parse('p20d')).isEqualTo(Period.parse('p20d'));
		assertThat(PeriodStyle.ISO8601.parse('P20D')).isEqualTo(Period.parse('P20D'));
		assertThat(PeriodStyle.ISO8601.parse('P15M')).isEqualTo(Period.parse('P15M'));
		assertThat(PeriodStyle.ISO8601.parse('+P15M')).isEqualTo(Period.parse('P15M'));
		assertThat(PeriodStyle.ISO8601.parse('P10Y')).isEqualTo(Period.parse('P10Y'));
		assertThat(PeriodStyle.ISO8601.parse('P2D')).isEqualTo(Period.parse('P2D'));
		assertThat(PeriodStyle.ISO8601.parse('-P6D')).isEqualTo(Period.parse('-P6D'));
		assertThat(PeriodStyle.ISO8601.parse('-P-6Y+3M')).isEqualTo(Period.parse('-P-6Y+3M'));
	}
	@Test
	void parseIso8601WithUnitShouldIgnoreUnit() {
		assertThat(PeriodStyle.ISO8601.parse('p20d', ChronoUnit.SECONDS)).isEqualTo(Period.parse('p20d'));
		assertThat(PeriodStyle.ISO8601.parse('P20D', ChronoUnit.SECONDS)).isEqualTo(Period.parse('P20D'));
		assertThat(PeriodStyle.ISO8601.parse('P15M', ChronoUnit.SECONDS)).isEqualTo(Period.parse('P15M'));
		assertThat(PeriodStyle.ISO8601.parse('+P15M', ChronoUnit.SECONDS)).isEqualTo(Period.parse('P15M'));
		assertThat(PeriodStyle.ISO8601.parse('P10Y', ChronoUnit.SECONDS)).isEqualTo(Period.parse('P10Y'));
		assertThat(PeriodStyle.ISO8601.parse('P2D', ChronoUnit.SECONDS)).isEqualTo(Period.parse('P2D'));
		assertThat(PeriodStyle.ISO8601.parse('-P6D', ChronoUnit.SECONDS)).isEqualTo(Period.parse('-P6D'));
		assertThat(PeriodStyle.ISO8601.parse('-P-6Y+3M', ChronoUnit.SECONDS)).isEqualTo(Period.parse('-P-6Y+3M'));
	}
	@Test
	void parseIso8601WhenSimpleShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> PeriodStyle.ISO8601.parse('10d'))
			.withMessageContaining('"10d" is not a valid ISO-8601 period');
	}
	@Test
	void parseSimpleShouldParse() {
		assertThat(PeriodStyle.SIMPLE.parse('10m')).hasMonths(10);
	}
	@Test
	void parseSimpleWithUnitShouldUseUnitAsFallback() {
		assertThat(PeriodStyle.SIMPLE.parse('10m', ChronoUnit.DAYS)).hasMonths(10);
		assertThat(PeriodStyle.SIMPLE.parse('10', ChronoUnit.MONTHS)).hasMonths(10);
	}
	@Test
	void parseSimpleWhenUnknownUnitShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> PeriodStyle.SIMPLE.parse('10x'))
			.satisfies(
					(ex) -> assertThat(ex.getCause().getMessage()).isEqualTo('Does not match simple period pattern'));
	}
	@Test
	void parseSimpleWhenIso8601ShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> PeriodStyle.SIMPLE.parse('PT10H'))
			.withMessageContaining('"PT10H" is not a valid simple period');
	}
	@Test
	void printIso8601ShouldPrint() {
		Period period = Period.parse('-P-6M+3D');
		assertThat(PeriodStyle.ISO8601.print(period)).isEqualTo('P6M-3D');
	}
	@Test
	void printIso8601ShouldIgnoreUnit() {
		Period period = Period.parse('-P3Y');
		assertThat(PeriodStyle.ISO8601.print(period, ChronoUnit.DAYS)).isEqualTo('P-3Y');
	}
	@Test
	void printSimpleWhenZeroWithoutUnitShouldPrintInDays() {
		Period period = Period.ofMonths(0);
		assertThat(PeriodStyle.SIMPLE.print(period)).isEqualTo('0d');
	}
	@Test
	void printSimpleWhenZeroWithUnitShouldPrintInUnit() {
		Period period = Period.ofYears(0);
		assertThat(PeriodStyle.SIMPLE.print(period, ChronoUnit.YEARS)).isEqualTo('0y');
	}
	@Test
	void printSimpleWhenNonZeroShouldIgnoreUnit() {
		Period period = Period.of(1, 2, 3);
		assertThat(PeriodStyle.SIMPLE.print(period, ChronoUnit.YEARS)).isEqualTo('1y2m3d');
	}
}
/*
package org.springframework.boot.convert;
/**
class CharSequenceToObjectConverterTests {
	@ConversionServiceTest
	void convertWhenCanConvertViaToString(ConversionService conversionService) {
		assertThat(conversionService.convert(new StringBuilder('1'), Integer.class)).isOne();
	}
	@ConversionServiceTest
	void convertWhenCanConvertDirectlySkipsStringConversion(ConversionService conversionService) {
		assertThat(conversionService.convert(new String('1'), Long.class)).isOne();
		if (!ConversionServiceArguments.isApplicationConversionService(conversionService)) {
			assertThat(conversionService.convert(new StringBuilder('1'), Long.class)).isEqualTo(2);
		}
	}
	@Test
	@SuppressWarnings('unchecked')
	void convertWhenTargetIsList() {
		ConversionService conversionService = new ApplicationConversionService();
		StringBuilder source = new StringBuilder('1,2,3');
		TypeDescriptor sourceType = TypeDescriptor.valueOf(StringBuilder.class);
		TypeDescriptor targetType = TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class));
		List<String> converted = (List<String>) conversionService.convert(source, sourceType, targetType);
		assertThat(converted).containsExactly('1', '2', '3');
	}
	@Test
	@SuppressWarnings('unchecked')
	void convertWhenTargetIsListAndNotUsingApplicationConversionService() {
		FormattingConversionService conversionService = new DefaultFormattingConversionService();
		conversionService.addConverter(new CharSequenceToObjectConverter(conversionService));
		StringBuilder source = new StringBuilder('1,2,3');
		TypeDescriptor sourceType = TypeDescriptor.valueOf(StringBuilder.class);
		TypeDescriptor targetType = TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class));
		List<String> converted = (List<String>) conversionService.convert(source, sourceType, targetType);
		assertThat(converted).containsExactly('1', '2', '3');
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with((conversionService) -> {
			conversionService.addConverter(new StringToIntegerConverter());
			conversionService.addConverter(new StringToLongConverter());
			conversionService.addConverter(new CharSequenceToLongConverter());
			conversionService.addConverter(new CharSequenceToObjectConverter(conversionService));
		});
	}
	static class StringToIntegerConverter implements Converter<String, Integer> {
		@Override
		public Integer convert(String source) {
			return Integer.valueOf(source);
		}
	}
	static class StringToLongConverter implements Converter<String, Long> {
		@Override
		public Long convert(String source) {
			return Long.valueOf(source);
		}
	}
	static class CharSequenceToLongConverter implements Converter<CharSequence, Long> {
		@Override
		public Long convert(CharSequence source) {
			return Long.parseLong(source.toString()) + 1;
		}
	}
}
/*
package org.springframework.boot.convert;
/**
class StringToDurationConverterTests {
	@ConversionServiceTest
	void convertWhenIso8601ShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, 'pt20.345s')).isEqualTo(Duration.parse('pt20.345s'));
		assertThat(convert(conversionService, 'PT20.345S')).isEqualTo(Duration.parse('PT20.345S'));
		assertThat(convert(conversionService, 'PT15M')).isEqualTo(Duration.parse('PT15M'));
		assertThat(convert(conversionService, '+PT15M')).isEqualTo(Duration.parse('PT15M'));
		assertThat(convert(conversionService, 'PT10H')).isEqualTo(Duration.parse('PT10H'));
		assertThat(convert(conversionService, 'P2D')).isEqualTo(Duration.parse('P2D'));
		assertThat(convert(conversionService, 'P2DT3H4M')).isEqualTo(Duration.parse('P2DT3H4M'));
		assertThat(convert(conversionService, '-PT6H3M')).isEqualTo(Duration.parse('-PT6H3M'));
		assertThat(convert(conversionService, '-PT-6H+3M')).isEqualTo(Duration.parse('-PT-6H+3M'));
	}
	@ConversionServiceTest
	void convertWhenSimpleNanosShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10ns')).hasNanos(10);
		assertThat(convert(conversionService, '10NS')).hasNanos(10);
		assertThat(convert(conversionService, '+10ns')).hasNanos(10);
		assertThat(convert(conversionService, '-10ns')).hasNanos(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleMicrosShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10us')).hasNanos(10000);
		assertThat(convert(conversionService, '10US')).hasNanos(10000);
		assertThat(convert(conversionService, '+10us')).hasNanos(10000);
		assertThat(convert(conversionService, '-10us')).hasNanos(-10000);
	}
	@ConversionServiceTest
	void convertWhenSimpleMillisShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10ms')).hasMillis(10);
		assertThat(convert(conversionService, '10MS')).hasMillis(10);
		assertThat(convert(conversionService, '+10ms')).hasMillis(10);
		assertThat(convert(conversionService, '-10ms')).hasMillis(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleSecondsShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10s')).hasSeconds(10);
		assertThat(convert(conversionService, '10S')).hasSeconds(10);
		assertThat(convert(conversionService, '+10s')).hasSeconds(10);
		assertThat(convert(conversionService, '-10s')).hasSeconds(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleMinutesShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10m')).hasMinutes(10);
		assertThat(convert(conversionService, '10M')).hasMinutes(10);
		assertThat(convert(conversionService, '+10m')).hasMinutes(10);
		assertThat(convert(conversionService, '-10m')).hasMinutes(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleHoursShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10h')).hasHours(10);
		assertThat(convert(conversionService, '10H')).hasHours(10);
		assertThat(convert(conversionService, '+10h')).hasHours(10);
		assertThat(convert(conversionService, '-10h')).hasHours(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleDaysShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10d')).hasDays(10);
		assertThat(convert(conversionService, '10D')).hasDays(10);
		assertThat(convert(conversionService, '+10d')).hasDays(10);
		assertThat(convert(conversionService, '-10d')).hasDays(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10')).hasMillis(10);
		assertThat(convert(conversionService, '+10')).hasMillis(10);
		assertThat(convert(conversionService, '-10')).hasMillis(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, '10', ChronoUnit.SECONDS, null)).hasSeconds(10);
		assertThat(convert(conversionService, '+10', ChronoUnit.SECONDS, null)).hasSeconds(10);
		assertThat(convert(conversionService, '-10', ChronoUnit.SECONDS, null)).hasSeconds(-10);
	}
	@ConversionServiceTest
	void convertWhenBadFormatShouldThrowException(ConversionService conversionService) {
		assertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() -> convert(conversionService, '10foo'))
			.havingRootCause()
			.withMessageContaining('"10foo" is not a valid duration');
	}
	@ConversionServiceTest
	void convertWhenStyleMismatchShouldThrowException(ConversionService conversionService) {
		assertThatExceptionOfType(ConversionFailedException.class)
			.isThrownBy(() -> convert(conversionService, '10s', null, DurationStyle.ISO8601));
	}
	@ConversionServiceTest
	void convertWhenEmptyShouldReturnNull(ConversionService conversionService) {
		assertThat(convert(conversionService, '')).isNull();
	}
	private Duration convert(ConversionService conversionService, String source) {
		return conversionService.convert(source, Duration.class);
	}
	private Duration convert(ConversionService conversionService, String source, ChronoUnit unit, DurationStyle style) {
		return (Duration) conversionService.convert(source, TypeDescriptor.forObject(source),
				MockDurationTypeDescriptor.get(unit, style));
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new StringToDurationConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
class ArrayToDelimitedStringConverterTests {
	@ConversionServiceTest
	void convertListToStringShouldConvert(ConversionService conversionService) {
		String[] list = { 'a', 'b', 'c' };
		String converted = conversionService.convert(list, String.class);
		assertThat(converted).isEqualTo('a,b,c');
	}
	@ConversionServiceTest
	void convertWhenHasDelimiterNoneShouldConvert(ConversionService conversionService) {
		Data data = new Data();
		data.none = new String[] { '1', '2', '3' };
		String converted = (String) conversionService.convert(data.none,
				TypeDescriptor.nested(ReflectionUtils.findField(Data.class, 'none'), 0),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('123');
	}
	@ConversionServiceTest
	void convertWhenHasDelimiterDashShouldConvert(ConversionService conversionService) {
		Data data = new Data();
		data.dash = new String[] { '1', '2', '3' };
		String converted = (String) conversionService.convert(data.dash,
				TypeDescriptor.nested(ReflectionUtils.findField(Data.class, 'dash'), 0),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1-2-3');
	}
	@ConversionServiceTest
	void convertShouldConvertNull(ConversionService conversionService) {
		String[] list = null;
		String converted = conversionService.convert(list, String.class);
		assertThat(converted).isNull();
	}
	@Test
	void convertShouldConvertElements() {
		Data data = new Data();
		data.type = new int[] { 1, 2, 3 };
		String converted = (String) new ApplicationConversionService().convert(data.type,
				TypeDescriptor.nested(ReflectionUtils.findField(Data.class, 'type'), 0),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1.2.3');
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((service) -> service.addConverter(new ArrayToDelimitedStringConverter(service)));
	}
	static class Data {
		@Delimiter(Delimiter.NONE)
		String[] none;
		@Delimiter('-')
		String[] dash;
		@Delimiter('.')
		int[] type;
	}
}
/*
package org.springframework.boot.convert;
/**
class InputStreamSourceToByteArrayConverterTests {
	@ConversionServiceTest
	void convertConvertsSource(ConversionService conversionService) {
		InputStreamSource source = () -> new ByteArrayInputStream(new byte[] { 0, 1, 2 });
		assertThat(conversionService.convert(source, byte[].class)).containsExactly(0, 1, 2);
	}
	@ConversionServiceTest
	void convertWhenFailsWithIOExceptionThrowsException(ConversionService conversionService) throws Exception {
		InputStreamSource source = mock(InputStreamSource.class);
		given(source.getInputStream()).willThrow(IOException.class);
		assertThatExceptionOfType(ConversionFailedException.class)
			.isThrownBy(() -> conversionService.convert(source, byte[].class))
			.havingCause()
			.isInstanceOf(IllegalStateException.class)
			.withMessageContaining('Unable to read from input stream source');
	}
	@ConversionServiceTest
	void convertWhenFailsWithIOExceptionFromOriginProviderThrowsException(ConversionService conversionService)
			throws Exception {
		Origin origin = new TestOrigin('mylocation');
		InputStreamSource source = mock(InputStreamSource.class, withSettings().extraInterfaces(OriginProvider.class));
		given(source.getInputStream()).willThrow(IOException.class);
		given(((OriginProvider) source).getOrigin()).willReturn(origin);
		assertThatExceptionOfType(ConversionFailedException.class)
			.isThrownBy(() -> conversionService.convert(source, byte[].class))
			.havingCause()
			.isInstanceOf(IllegalStateException.class)
			.withMessageContaining('Unable to read from mylocation');
	}
	@ConversionServiceTest
	void convertWhenFailsWithIOExceptionFromResourceThrowsException(ConversionService conversionService)
			throws Exception {
		Resource source = mock(Resource.class);
		given(source.getInputStream()).willThrow(IOException.class);
		given(source.getDescription()).willReturn('myresource');
		assertThatExceptionOfType(ConversionFailedException.class)
			.isThrownBy(() -> conversionService.convert(source, byte[].class))
			.havingCause()
			.isInstanceOf(IllegalStateException.class)
			.withMessageContaining('Unable to read from myresource');
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((service) -> service.addConverter(new InputStreamSourceToByteArrayConverter()));
	}
	private static class TestOrigin implements Origin {
		private final String string;
		TestOrigin(String string) {
			this.string = string;
		}
		@Override
		public String toString() {
			return this.string;
		}
	}
}
/*
package org.springframework.boot.convert;
/**
class LenientStringToEnumConverterFactoryTests {
	@ConversionServiceTest
	void canConvertFromStringToEnumShouldReturnTrue(ConversionService conversionService) {
		assertThat(conversionService.canConvert(String.class, TestEnum.class)).isTrue();
	}
	@ConversionServiceTest
	void canConvertFromStringToEnumSubclassShouldReturnTrue(ConversionService conversionService) {
		assertThat(conversionService.canConvert(String.class, TestSubclassEnum.ONE.getClass())).isTrue();
	}
	@ConversionServiceTest
	void convertFromStringToEnumWhenExactMatchShouldConvertValue(ConversionService conversionService) {
		assertThat(conversionService.convert('', TestEnum.class)).isNull();
		assertThat(conversionService.convert('ONE', TestEnum.class)).isEqualTo(TestEnum.ONE);
		assertThat(conversionService.convert('TWO', TestEnum.class)).isEqualTo(TestEnum.TWO);
		assertThat(conversionService.convert('THREE_AND_FOUR', TestEnum.class)).isEqualTo(TestEnum.THREE_AND_FOUR);
	}
	@ConversionServiceTest
	void convertFromStringToEnumWhenFuzzyMatchShouldConvertValue(ConversionService conversionService) {
		assertThat(conversionService.convert('', TestEnum.class)).isNull();
		assertThat(conversionService.convert('one', TestEnum.class)).isEqualTo(TestEnum.ONE);
		assertThat(conversionService.convert('tWo', TestEnum.class)).isEqualTo(TestEnum.TWO);
		assertThat(conversionService.convert('three_and_four', TestEnum.class)).isEqualTo(TestEnum.THREE_AND_FOUR);
		assertThat(conversionService.convert('threeandfour', TestEnum.class)).isEqualTo(TestEnum.THREE_AND_FOUR);
		assertThat(conversionService.convert('three-and-four', TestEnum.class)).isEqualTo(TestEnum.THREE_AND_FOUR);
		assertThat(conversionService.convert('threeAndFour', TestEnum.class)).isEqualTo(TestEnum.THREE_AND_FOUR);
	}
	@ConversionServiceTest
	void convertFromStringToEnumWhenUsingNonEnglishLocaleShouldConvertValue(ConversionService conversionService) {
		Locale defaultLocale = Locale.getDefault();
		try {
			Locale.setDefault(new Locale('tr'));
			LocaleSensitiveEnum result = conversionService.convert('accept-case-insensitive-properties',
					LocaleSensitiveEnum.class);
			assertThat(result).isEqualTo(LocaleSensitiveEnum.ACCEPT_CASE_INSENSITIVE_PROPERTIES);
		}
		finally {
			Locale.setDefault(defaultLocale);
		}
	}
	@ConversionServiceTest
	void convertFromStringToEnumWhenYamlBooleanShouldConvertValue(ConversionService conversionService) {
		assertThat(conversionService.convert('one', TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.ONE);
		assertThat(conversionService.convert('two', TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.TWO);
		assertThat(conversionService.convert('true', TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.ON);
		assertThat(conversionService.convert('false', TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.OFF);
		assertThat(conversionService.convert('TRUE', TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.ON);
		assertThat(conversionService.convert('FALSE', TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.OFF);
		assertThat(conversionService.convert('fA_lsE', TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.OFF);
		assertThat(conversionService.convert('one', TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.ONE);
		assertThat(conversionService.convert('two', TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.TWO);
		assertThat(conversionService.convert('true', TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.TRUE);
		assertThat(conversionService.convert('false', TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.FALSE);
		assertThat(conversionService.convert('TRUE', TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.TRUE);
		assertThat(conversionService.convert('FALSE', TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.FALSE);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((service) -> service.addConverterFactory(new LenientStringToEnumConverterFactory()));
	}
	enum TestEnum {
		ONE, TWO, THREE_AND_FOUR
	}
	enum TestOnOffEnum {
		ONE, TWO, ON, OFF
	}
	enum TestTrueFalseEnum {
		ONE, TWO, TRUE, FALSE, ON, OFF
	}
	enum LocaleSensitiveEnum {
		ACCEPT_CASE_INSENSITIVE_PROPERTIES
	}
	enum TestSubclassEnum {
		ONE {
			@Override
			public String toString() {
				return 'foo';
			}
		}
	}
}
/*
package org.springframework.boot.convert;
/**
class NumberToPeriodConverterTests {
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, 10)).hasDays(10);
		assertThat(convert(conversionService, +10)).hasDays(10);
		assertThat(convert(conversionService, -10)).hasDays(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, 10, ChronoUnit.DAYS)).hasDays(10);
		assertThat(convert(conversionService, -10, ChronoUnit.DAYS)).hasDays(-10);
		assertThat(convert(conversionService, 10, ChronoUnit.WEEKS)).isEqualTo(Period.ofWeeks(10));
		assertThat(convert(conversionService, -10, ChronoUnit.WEEKS)).isEqualTo(Period.ofWeeks(-10));
		assertThat(convert(conversionService, 10, ChronoUnit.MONTHS)).hasMonths(10);
		assertThat(convert(conversionService, -10, ChronoUnit.MONTHS)).hasMonths(-10);
		assertThat(convert(conversionService, 10, ChronoUnit.YEARS)).hasYears(10);
		assertThat(convert(conversionService, -10, ChronoUnit.YEARS)).hasYears(-10);
	}
	private Period convert(ConversionService conversionService, Integer source) {
		return conversionService.convert(source, Period.class);
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private Period convert(ConversionService conversionService, Integer source, ChronoUnit defaultUnit) {
		TypeDescriptor targetType = mock(TypeDescriptor.class);
		if (defaultUnit != null) {
			PeriodUnit unitAnnotation = AnnotationUtils
				.synthesizeAnnotation(Collections.singletonMap('value', defaultUnit), PeriodUnit.class, null);
			given(targetType.getAnnotation(PeriodUnit.class)).willReturn(unitAnnotation);
		}
		given(targetType.getType()).willReturn((Class) Period.class);
		return (Period) conversionService.convert(source, TypeDescriptor.forObject(source), targetType);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new NumberToPeriodConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
public final class MockDurationTypeDescriptor {
	private MockDurationTypeDescriptor() {
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	public static TypeDescriptor get(ChronoUnit unit, DurationStyle style) {
		TypeDescriptor descriptor = mock(TypeDescriptor.class);
		if (unit != null) {
			DurationUnit unitAnnotation = AnnotationUtils.synthesizeAnnotation(Collections.singletonMap('value', unit),
					DurationUnit.class, null);
			given(descriptor.getAnnotation(DurationUnit.class)).willReturn(unitAnnotation);
		}
		if (style != null) {
			DurationFormat formatAnnotation = AnnotationUtils
				.synthesizeAnnotation(Collections.singletonMap('value', style), DurationFormat.class, null);
			given(descriptor.getAnnotation(DurationFormat.class)).willReturn(formatAnnotation);
		}
		given(descriptor.getType()).willReturn((Class) Duration.class);
		given(descriptor.getObjectType()).willReturn((Class) Duration.class);
		return descriptor;
	}
}
/*
package org.springframework.boot.convert;
/**
class StringToFileConverterTests {
	@TempDir
	File temp;
	@ConversionServiceTest
	void convertWhenSimpleFileReturnsFile(ConversionService conversionService) {
		assertThat(convert(conversionService, this.temp.getAbsolutePath() + '/test'))
			.isEqualTo(new File(this.temp, 'test').getAbsoluteFile());
	}
	@ConversionServiceTest
	void convertWhenFilePrefixedReturnsFile(ConversionService conversionService) {
		assertThat(convert(conversionService, 'file:' + this.temp.getAbsolutePath() + '/test').getAbsoluteFile())
			.isEqualTo(new File(this.temp, 'test').getAbsoluteFile());
	}
	@ConversionServiceTest
	void convertWhenClasspathPrefixedReturnsFile(ConversionService conversionService) throws IOException {
		String resource = new ClassPathResource('test-banner.txt', this.getClass().getClassLoader()).getURL().getFile();
		assertThat(convert(conversionService, 'classpath:test-banner.txt').getAbsoluteFile())
			.isEqualTo(new File(resource).getAbsoluteFile());
	}
	private File convert(ConversionService conversionService, String source) {
		return conversionService.convert(source, File.class);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((conversionService) -> conversionService.addConverter(new StringToFileConverter()));
	}
}
/*
package org.springframework.boot.convert;
/**
public final class ConversionServiceArguments {
	private ConversionServiceArguments() {
	}
	public static Stream<? extends Arguments> with(Formatter<?> formatter) {
		return with((conversionService) -> conversionService.addFormatter(formatter));
	}
	public static Stream<? extends Arguments> with(GenericConverter converter) {
		return with((conversionService) -> conversionService.addConverter(converter));
	}
	public static Stream<? extends Arguments> with(Consumer<FormattingConversionService> initializer) {
		FormattingConversionService withoutDefaults = new FormattingConversionService();
		initializer.accept(withoutDefaults);
		return Stream.of(
				Arguments.of(new NamedConversionService(withoutDefaults, 'Without defaults conversion service')),
				Arguments.of(new NamedConversionService(new ApplicationConversionService(),
						'Application conversion service')));
	}
	public static boolean isApplicationConversionService(ConversionService conversionService) {
		if (conversionService instanceof NamedConversionService namedConversionService) {
			return isApplicationConversionService(namedConversionService.delegate);
		}
		return conversionService instanceof ApplicationConversionService;
	}
	static class NamedConversionService implements ConversionService {
		private final ConversionService delegate;
		private final String name;
		NamedConversionService(ConversionService delegate, String name) {
			this.delegate = delegate;
			this.name = name;
		}
		@Override
		public boolean canConvert(Class<?> sourceType, Class<?> targetType) {
			return this.delegate.canConvert(sourceType, targetType);
		}
		@Override
		public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {
			return this.delegate.canConvert(sourceType, targetType);
		}
		@Override
		public <T> T convert(Object source, Class<T> targetType) {
			return this.delegate.convert(source, targetType);
		}
		@Override
		public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
			return this.delegate.convert(source, sourceType, targetType);
		}
		@Override
		public String toString() {
			return this.name;
		}
	}
}
/*
package org.springframework.boot.convert;
/**
class IsoOffsetFormatterTests {
	@ConversionServiceTest
	void convertShouldConvertStringToIsoDate(ConversionService conversionService) {
		OffsetDateTime now = OffsetDateTime.now();
		OffsetDateTime converted = conversionService.convert(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(now),
				OffsetDateTime.class);
		assertThat(converted).isEqualTo(now);
	}
	@ConversionServiceTest
	void convertShouldConvertIsoDateToString(ConversionService conversionService) {
		OffsetDateTime now = OffsetDateTime.now();
		String converted = conversionService.convert(now, String.class);
		assertThat(converted).isNotNull().startsWith(now.format(DateTimeFormatter.ISO_OFFSET_DATE_TIME));
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new IsoOffsetFormatter());
	}
}
/*
package org.springframework.boot.convert;
/**
class DelimitedStringToArrayConverterTests {
	@ConversionServiceTest
	void canConvertFromStringToArrayShouldReturnTrue(ConversionService conversionService) {
		assertThat(conversionService.canConvert(String.class, String[].class)).isTrue();
	}
	@ConversionServiceTest
	void matchesWhenTargetIsNotAnnotatedShouldReturnTrue(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, 'noAnnotation'), 0);
		assertThat(new DelimitedStringToArrayConverter(conversionService).matches(sourceType, targetType)).isTrue();
	}
	@ConversionServiceTest
	void matchesWhenHasAnnotationAndNonConvertibleElementTypeShouldReturnFalse(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor
			.nested(ReflectionUtils.findField(Values.class, 'nonConvertibleElementType'), 0);
		assertThat(new DelimitedStringToArrayConverter(conversionService).matches(sourceType, targetType)).isFalse();
	}
	@ConversionServiceTest
	void convertWhenHasDelimiterOfNoneShouldReturnWholeString(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, 'delimiterNone'), 0);
		String[] converted = (String[]) conversionService.convert('a,b,c', sourceType, targetType);
		assertThat(converted).containsExactly('a,b,c');
	}
	@Test
	void matchesWhenHasAnnotationAndConvertibleElementTypeShouldReturnTrue() {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor
			.nested(ReflectionUtils.findField(Values.class, 'convertibleElementType'), 0);
		assertThat(
				new DelimitedStringToArrayConverter(new ApplicationConversionService()).matches(sourceType, targetType))
			.isTrue();
	}
	@Test
	void convertWhenHasConvertibleElementTypeShouldReturnConvertedType() {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor
			.nested(ReflectionUtils.findField(Values.class, 'convertibleElementType'), 0);
		Integer[] converted = (Integer[]) new ApplicationConversionService().convert(' 1 |  2| 3  ', sourceType,
				targetType);
		assertThat(converted).containsExactly(1, 2, 3);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((service) -> service.addConverter(new DelimitedStringToArrayConverter(service)));
	}
	static class Values {
		List<String> noAnnotation;
		@Delimiter('|')
		Integer[] convertibleElementType;
		@Delimiter('|')
		NonConvertible[] nonConvertibleElementType;
		@Delimiter(Delimiter.NONE)
		String[] delimiterNone;
	}
	static class NonConvertible {
	}
	static class MyCustomList<E> extends LinkedList<E> {
	}
}
/*
package org.springframework.boot.convert;
/**
public final class MockPeriodTypeDescriptor {
	private MockPeriodTypeDescriptor() {
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	public static TypeDescriptor get(ChronoUnit unit, PeriodStyle style) {
		TypeDescriptor descriptor = mock(TypeDescriptor.class);
		if (unit != null) {
			PeriodUnit unitAnnotation = AnnotationUtils.synthesizeAnnotation(Collections.singletonMap('value', unit),
					PeriodUnit.class, null);
			given(descriptor.getAnnotation(PeriodUnit.class)).willReturn(unitAnnotation);
		}
		if (style != null) {
			PeriodFormat formatAnnotation = AnnotationUtils
				.synthesizeAnnotation(Collections.singletonMap('value', style), PeriodFormat.class, null);
			given(descriptor.getAnnotation(PeriodFormat.class)).willReturn(formatAnnotation);
		}
		given(descriptor.getType()).willReturn((Class) Period.class);
		given(descriptor.getObjectType()).willReturn((Class) Period.class);
		return descriptor;
	}
}
/*
package org.springframework.boot.convert;
/**
class CharArrayFormatterTests {
	@ConversionServiceTest
	void convertFromCharArrayToStringShouldConvert(ConversionService conversionService) {
		char[] source = { "b", "o", "o", "t" };
		String converted = conversionService.convert(source, String.class);
		assertThat(converted).isEqualTo('boot');
	}
	@ConversionServiceTest
	void convertFromStringToCharArrayShouldConvert(ConversionService conversionService) {
		String source = 'boot';
		char[] converted = conversionService.convert(source, char[].class);
		assertThat(converted).containsExactly("b", "o", "o", "t");
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new CharArrayFormatter());
	}
}
/*
package org.springframework.boot.convert;
/**
class DurationToNumberConverterTests {
	@ConversionServiceTest
	void convertWithoutStyleShouldReturnMs(ConversionService conversionService) {
		Long converted = conversionService.convert(Duration.ofSeconds(1), Long.class);
		assertThat(converted).isEqualTo(1000);
	}
	@ConversionServiceTest
	void convertWithFormatShouldUseIgnoreFormat(ConversionService conversionService) {
		Integer converted = (Integer) conversionService.convert(Duration.ofSeconds(1),
				MockDurationTypeDescriptor.get(null, DurationStyle.ISO8601), TypeDescriptor.valueOf(Integer.class));
		assertThat(converted).isEqualTo(1000);
	}
	@ConversionServiceTest
	void convertWithFormatAndUnitShouldUseFormatAndUnit(ConversionService conversionService) {
		Byte converted = (Byte) conversionService.convert(Duration.ofSeconds(1),
				MockDurationTypeDescriptor.get(ChronoUnit.SECONDS, null), TypeDescriptor.valueOf(Byte.class));
		assertThat(converted).isEqualTo((byte) 1);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new DurationToNumberConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
class LenientBooleanToEnumConverterFactoryTests {
	@ConversionServiceTest
	void convertFromBooleanToEnumWhenShouldConvertValue(ConversionService conversionService) {
		assertThat(conversionService.convert(true, TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.ON);
		assertThat(conversionService.convert(false, TestOnOffEnum.class)).isEqualTo(TestOnOffEnum.OFF);
		assertThat(conversionService.convert(true, TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.TRUE);
		assertThat(conversionService.convert(false, TestTrueFalseEnum.class)).isEqualTo(TestTrueFalseEnum.FALSE);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((service) -> service.addConverterFactory(new LenientBooleanToEnumConverterFactory()));
	}
	enum TestOnOffEnum {
		ON, OFF
	}
	enum TestTrueFalseEnum {
		ONE, TWO, TRUE, FALSE, ON, OFF
	}
}
/*
package org.springframework.boot.convert;
/**
class InetAddressFormatterTests {
	@ConversionServiceTest
	void convertFromInetAddressToStringShouldConvert(ConversionService conversionService) {
		assumingThat(isResolvable('example.com'), () -> {
			InetAddress address = InetAddress.getByName('example.com');
			String converted = conversionService.convert(address, String.class);
			assertThat(converted).isEqualTo(address.getHostAddress());
		});
	}
	@ConversionServiceTest
	void convertFromStringToInetAddressShouldConvert(ConversionService conversionService) {
		assumingThat(isResolvable('example.com'), () -> {
			InetAddress converted = conversionService.convert('example.com', InetAddress.class);
			assertThat(converted.toString()).startsWith('example.com');
		});
	}
	@ConversionServiceTest
	void convertFromStringToInetAddressWhenHostDoesNotExistShouldThrowException(ConversionService conversionService) {
		String missingDomain = 'ireallydontexist.example.com';
		assumingThat(!isResolvable('ireallydontexist.example.com'),
				() -> assertThatExceptionOfType(ConversionFailedException.class)
					.isThrownBy(() -> conversionService.convert(missingDomain, InetAddress.class)));
	}
	private boolean isResolvable(String host) {
		try {
			InetAddress.getByName(host);
			return true;
		}
		catch (UnknownHostException ex) {
			return false;
		}
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new InetAddressFormatter());
	}
}
/*
package org.springframework.boot.convert;
/**
class PeriodToStringConverterTests {
	@ConversionServiceTest
	void convertWithoutStyleShouldReturnIso8601(ConversionService conversionService) {
		String converted = conversionService.convert(Period.ofDays(1), String.class);
		assertThat(converted).isEqualTo(Period.ofDays(1).toString());
	}
	@ConversionServiceTest
	void convertWithFormatWhenZeroShouldUseFormatAndDays(ConversionService conversionService) {
		String converted = (String) conversionService.convert(Period.ofMonths(0),
				MockPeriodTypeDescriptor.get(null, PeriodStyle.SIMPLE), TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('0d');
	}
	@ConversionServiceTest
	void convertWithFormatShouldUseFormat(ConversionService conversionService) {
		String converted = (String) conversionService.convert(Period.of(1, 2, 3),
				MockPeriodTypeDescriptor.get(null, PeriodStyle.SIMPLE), TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1y2m3d');
	}
	@ConversionServiceTest
	void convertWithFormatAndUnitWhenZeroShouldUseFormatAndUnit(ConversionService conversionService) {
		String converted = (String) conversionService.convert(Period.ofYears(0),
				MockPeriodTypeDescriptor.get(ChronoUnit.YEARS, PeriodStyle.SIMPLE),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('0y');
	}
	@ConversionServiceTest
	void convertWithFormatAndUnitWhenNonZeroShouldUseFormatAndIgnoreUnit(ConversionService conversionService) {
		String converted = (String) conversionService.convert(Period.of(1, 0, 3),
				MockPeriodTypeDescriptor.get(ChronoUnit.YEARS, PeriodStyle.SIMPLE),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1y3d');
	}
	@ConversionServiceTest
	void convertWithWeekUnitShouldConvertToStringInDays(ConversionService conversionService) {
		String converted = (String) conversionService.convert(Period.ofWeeks(53),
				MockPeriodTypeDescriptor.get(null, PeriodStyle.SIMPLE), TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('371d');
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new PeriodToStringConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
class DurationToStringConverterTests {
	@ConversionServiceTest
	void convertWithoutStyleShouldReturnIso8601(ConversionService conversionService) {
		String converted = conversionService.convert(Duration.ofSeconds(1), String.class);
		assertThat(converted).isEqualTo('PT1S');
	}
	@ConversionServiceTest
	void convertWithFormatShouldUseFormatAndMs(ConversionService conversionService) {
		String converted = (String) conversionService.convert(Duration.ofSeconds(1),
				MockDurationTypeDescriptor.get(null, DurationStyle.SIMPLE), TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1000ms');
	}
	@ConversionServiceTest
	void convertWithFormatAndUnitShouldUseFormatAndUnit(ConversionService conversionService) {
		String converted = (String) conversionService.convert(Duration.ofSeconds(1),
				MockDurationTypeDescriptor.get(ChronoUnit.SECONDS, DurationStyle.SIMPLE),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1s');
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new DurationToStringConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
class NumberToDataSizeConverterTests {
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, 10)).isEqualTo(DataSize.ofBytes(10));
		assertThat(convert(conversionService, +10)).isEqualTo(DataSize.ofBytes(10));
		assertThat(convert(conversionService, -10)).isEqualTo(DataSize.ofBytes(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, 10, DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(10));
		assertThat(convert(conversionService, +10, DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(10));
		assertThat(convert(conversionService, -10, DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(-10));
	}
	private DataSize convert(ConversionService conversionService, Integer source) {
		return conversionService.convert(source, DataSize.class);
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private DataSize convert(ConversionService conversionService, Integer source, DataUnit defaultUnit) {
		TypeDescriptor targetType = mock(TypeDescriptor.class);
		if (defaultUnit != null) {
			DataSizeUnit unitAnnotation = AnnotationUtils
				.synthesizeAnnotation(Collections.singletonMap('value', defaultUnit), DataSizeUnit.class, null);
			given(targetType.getAnnotation(DataSizeUnit.class)).willReturn(unitAnnotation);
		}
		given(targetType.getType()).willReturn((Class) DataSize.class);
		return (DataSize) conversionService.convert(source, TypeDescriptor.forObject(source), targetType);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new NumberToDataSizeConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
public final class MockDataSizeTypeDescriptor {
	private MockDataSizeTypeDescriptor() {
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	public static TypeDescriptor get(DataUnit unit) {
		TypeDescriptor descriptor = mock(TypeDescriptor.class);
		if (unit != null) {
			DataSizeUnit unitAnnotation = AnnotationUtils.synthesizeAnnotation(Collections.singletonMap('value', unit),
					DataSizeUnit.class, null);
			given(descriptor.getAnnotation(DataSizeUnit.class)).willReturn(unitAnnotation);
		}
		given(descriptor.getType()).willReturn((Class) DataSize.class);
		given(descriptor.getObjectType()).willReturn((Class) DataSize.class);
		return descriptor;
	}
}
/*
package org.springframework.boot.convert;
/**
class StringToPeriodConverterTests {
	@ConversionServiceTest
	void convertWhenIso8601ShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, 'p2y')).isEqualTo(Period.parse('p2y'));
		assertThat(convert(conversionService, 'P2Y')).isEqualTo(Period.parse('P2Y'));
		assertThat(convert(conversionService, 'P3M')).isEqualTo(Period.parse('P3M'));
		assertThat(convert(conversionService, 'P4W')).isEqualTo(Period.parse('P4W'));
		assertThat(convert(conversionService, 'P5D')).isEqualTo(Period.parse('P5D'));
		assertThat(convert(conversionService, 'P1Y2M3D')).isEqualTo(Period.parse('P1Y2M3D'));
		assertThat(convert(conversionService, 'P1Y2M3W4D')).isEqualTo(Period.parse('P1Y2M3W4D'));
		assertThat(convert(conversionService, 'P-1Y2M')).isEqualTo(Period.parse('P-1Y2M'));
		assertThat(convert(conversionService, '-P1Y2M')).isEqualTo(Period.parse('-P1Y2M'));
	}
	@ConversionServiceTest
	void convertWhenSimpleDaysShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, '10d')).isEqualTo(Period.ofDays(10));
		assertThat(convert(conversionService, '10D')).isEqualTo(Period.ofDays(10));
		assertThat(convert(conversionService, '+10d')).isEqualTo(Period.ofDays(10));
		assertThat(convert(conversionService, '-10D')).isEqualTo(Period.ofDays(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleWeeksShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, '10w')).isEqualTo(Period.ofWeeks(10));
		assertThat(convert(conversionService, '10W')).isEqualTo(Period.ofWeeks(10));
		assertThat(convert(conversionService, '+10w')).isEqualTo(Period.ofWeeks(10));
		assertThat(convert(conversionService, '-10W')).isEqualTo(Period.ofWeeks(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleMonthsShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, '10m')).isEqualTo(Period.ofMonths(10));
		assertThat(convert(conversionService, '10M')).isEqualTo(Period.ofMonths(10));
		assertThat(convert(conversionService, '+10m')).isEqualTo(Period.ofMonths(10));
		assertThat(convert(conversionService, '-10M')).isEqualTo(Period.ofMonths(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleYearsShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, '10y')).isEqualTo(Period.ofYears(10));
		assertThat(convert(conversionService, '10Y')).isEqualTo(Period.ofYears(10));
		assertThat(convert(conversionService, '+10y')).isEqualTo(Period.ofYears(10));
		assertThat(convert(conversionService, '-10Y')).isEqualTo(Period.ofYears(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, '10')).isEqualTo(Period.ofDays(10));
		assertThat(convert(conversionService, '+10')).isEqualTo(Period.ofDays(10));
		assertThat(convert(conversionService, '-10')).isEqualTo(Period.ofDays(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnPeriod(ConversionService conversionService) {
		assertThat(convert(conversionService, '10', ChronoUnit.DAYS, null)).isEqualTo(Period.ofDays(10));
		assertThat(convert(conversionService, '+10', ChronoUnit.DAYS, null)).isEqualTo(Period.ofDays(10));
		assertThat(convert(conversionService, '-10', ChronoUnit.DAYS, null)).isEqualTo(Period.ofDays(-10));
		assertThat(convert(conversionService, '10', ChronoUnit.WEEKS, null)).isEqualTo(Period.ofWeeks(10));
		assertThat(convert(conversionService, '+10', ChronoUnit.WEEKS, null)).isEqualTo(Period.ofWeeks(10));
		assertThat(convert(conversionService, '-10', ChronoUnit.WEEKS, null)).isEqualTo(Period.ofWeeks(-10));
		assertThat(convert(conversionService, '10', ChronoUnit.MONTHS, null)).isEqualTo(Period.ofMonths(10));
		assertThat(convert(conversionService, '+10', ChronoUnit.MONTHS, null)).isEqualTo(Period.ofMonths(10));
		assertThat(convert(conversionService, '-10', ChronoUnit.MONTHS, null)).isEqualTo(Period.ofMonths(-10));
		assertThat(convert(conversionService, '10', ChronoUnit.YEARS, null)).isEqualTo(Period.ofYears(10));
		assertThat(convert(conversionService, '+10', ChronoUnit.YEARS, null)).isEqualTo(Period.ofYears(10));
		assertThat(convert(conversionService, '-10', ChronoUnit.YEARS, null)).isEqualTo(Period.ofYears(-10));
	}
	private Period convert(ConversionService conversionService, String source) {
		return conversionService.convert(source, Period.class);
	}
	private Period convert(ConversionService conversionService, String source, ChronoUnit unit, PeriodStyle style) {
		return (Period) conversionService.convert(source, TypeDescriptor.forObject(source),
				MockPeriodTypeDescriptor.get(unit, style));
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new StringToPeriodConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
class NumberToDurationConverterTests {
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, 10)).hasMillis(10);
		assertThat(convert(conversionService, +10)).hasMillis(10);
		assertThat(convert(conversionService, -10)).hasMillis(-10);
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnDuration(ConversionService conversionService) {
		assertThat(convert(conversionService, 10, ChronoUnit.SECONDS)).hasSeconds(10);
		assertThat(convert(conversionService, +10, ChronoUnit.SECONDS)).hasSeconds(10);
		assertThat(convert(conversionService, -10, ChronoUnit.SECONDS)).hasSeconds(-10);
	}
	private Duration convert(ConversionService conversionService, Integer source) {
		return conversionService.convert(source, Duration.class);
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private Duration convert(ConversionService conversionService, Integer source, ChronoUnit defaultUnit) {
		TypeDescriptor targetType = mock(TypeDescriptor.class);
		if (defaultUnit != null) {
			DurationUnit unitAnnotation = AnnotationUtils
				.synthesizeAnnotation(Collections.singletonMap('value', defaultUnit), DurationUnit.class, null);
			given(targetType.getAnnotation(DurationUnit.class)).willReturn(unitAnnotation);
		}
		given(targetType.getType()).willReturn((Class) Duration.class);
		return (Duration) conversionService.convert(source, TypeDescriptor.forObject(source), targetType);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new NumberToDurationConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
class DelimitedStringToCollectionConverterTests {
	@ConversionServiceTest
	void canConvertFromStringToCollectionShouldReturnTrue(ConversionService conversionService) {
		assertThat(conversionService.canConvert(String.class, Collection.class)).isTrue();
	}
	@ConversionServiceTest
	void matchesWhenTargetIsNotAnnotatedShouldReturnTrue(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, 'noAnnotation'), 0);
		assertThat(new DelimitedStringToCollectionConverter(conversionService).matches(sourceType, targetType))
			.isTrue();
	}
	@ConversionServiceTest
	void matchesWhenHasAnnotationAndNoElementTypeShouldReturnTrue(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, 'noElementType'), 0);
		assertThat(new DelimitedStringToCollectionConverter(conversionService).matches(sourceType, targetType))
			.isTrue();
	}
	@ConversionServiceTest
	void matchesWhenHasAnnotationAndNonConvertibleElementTypeShouldReturnFalse(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor
			.nested(ReflectionUtils.findField(Values.class, 'nonConvertibleElementType'), 0);
		assertThat(new DelimitedStringToCollectionConverter(conversionService).matches(sourceType, targetType))
			.isFalse();
	}
	@ConversionServiceTest
	@SuppressWarnings('unchecked')
	void convertWhenHasNoElementTypeShouldReturnTrimmedString(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, 'noElementType'), 0);
		Collection<String> converted = (Collection<String>) conversionService.convert(' a |  b| c  ', sourceType,
				targetType);
		assertThat(converted).containsExactly('a', 'b', 'c');
	}
	@ConversionServiceTest
	@SuppressWarnings('unchecked')
	void convertWhenHasDelimiterOfNoneShouldReturnWholeString(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, 'delimiterNone'), 0);
		List<String> converted = (List<String>) conversionService.convert('a,b,c', sourceType, targetType);
		assertThat(converted).containsExactly('a,b,c');
	}
	@SuppressWarnings('unchecked')
	@ConversionServiceTest
	void convertWhenHasCollectionObjectTypeShouldUseCollectionObjectType(ConversionService conversionService) {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, 'specificType'), 0);
		MyCustomList<String> converted = (MyCustomList<String>) conversionService.convert('a*b', sourceType,
				targetType);
		assertThat(converted).containsExactly('a', 'b');
	}
	@Test
	void matchesWhenHasAnnotationAndConvertibleElementTypeShouldReturnTrue() {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor
			.nested(ReflectionUtils.findField(Values.class, 'convertibleElementType'), 0);
		assertThat(new DelimitedStringToCollectionConverter(new ApplicationConversionService()).matches(sourceType,
				targetType))
			.isTrue();
	}
	@Test
	@SuppressWarnings('unchecked')
	void convertWhenHasConvertibleElementTypeShouldReturnConvertedType() {
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor
			.nested(ReflectionUtils.findField(Values.class, 'convertibleElementType'), 0);
		List<Integer> converted = (List<Integer>) new ApplicationConversionService().convert(' 1 |  2| 3  ', sourceType,
				targetType);
		assertThat(converted).containsExactly(1, 2, 3);
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((service) -> service.addConverter(new DelimitedStringToCollectionConverter(service)));
	}
	static class Values {
		List<String> noAnnotation;
		@SuppressWarnings('rawtypes')
		@Delimiter('|')
		List noElementType;
		@Delimiter('|')
		List<Integer> convertibleElementType;
		@Delimiter('|')
		List<NonConvertible> nonConvertibleElementType;
		@Delimiter(Delimiter.NONE)
		List<String> delimiterNone;
		@Delimiter('*')
		MyCustomList<String> specificType;
	}
	static class NonConvertible {
	}
	static class MyCustomList<E> extends LinkedList<E> {
	}
}
/*
package org.springframework.boot.convert;
/**
class StringToDataSizeConverterTests {
	@ConversionServiceTest
	void convertWhenSimpleBytesShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, '10B')).isEqualTo(DataSize.ofBytes(10));
		assertThat(convert(conversionService, '+10B')).isEqualTo(DataSize.ofBytes(10));
		assertThat(convert(conversionService, '-10B')).isEqualTo(DataSize.ofBytes(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleKilobytesShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, '10KB')).isEqualTo(DataSize.ofKilobytes(10));
		assertThat(convert(conversionService, '+10KB')).isEqualTo(DataSize.ofKilobytes(10));
		assertThat(convert(conversionService, '-10KB')).isEqualTo(DataSize.ofKilobytes(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleMegabytesShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, '10MB')).isEqualTo(DataSize.ofMegabytes(10));
		assertThat(convert(conversionService, '+10MB')).isEqualTo(DataSize.ofMegabytes(10));
		assertThat(convert(conversionService, '-10MB')).isEqualTo(DataSize.ofMegabytes(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleGigabytesShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, '10GB')).isEqualTo(DataSize.ofGigabytes(10));
		assertThat(convert(conversionService, '+10GB')).isEqualTo(DataSize.ofGigabytes(10));
		assertThat(convert(conversionService, '-10GB')).isEqualTo(DataSize.ofGigabytes(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleTerabytesShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, '10TB')).isEqualTo(DataSize.ofTerabytes(10));
		assertThat(convert(conversionService, '+10TB')).isEqualTo(DataSize.ofTerabytes(10));
		assertThat(convert(conversionService, '-10TB')).isEqualTo(DataSize.ofTerabytes(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, '10')).isEqualTo(DataSize.ofBytes(10));
		assertThat(convert(conversionService, '+10')).isEqualTo(DataSize.ofBytes(10));
		assertThat(convert(conversionService, '-10')).isEqualTo(DataSize.ofBytes(-10));
	}
	@ConversionServiceTest
	void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnDataSize(ConversionService conversionService) {
		assertThat(convert(conversionService, '10', DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(10));
		assertThat(convert(conversionService, '+10', DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(10));
		assertThat(convert(conversionService, '-10', DataUnit.KILOBYTES)).isEqualTo(DataSize.ofKilobytes(-10));
	}
	@ConversionServiceTest
	void convertWhenBadFormatShouldThrowException(ConversionService conversionService) {
		assertThatExceptionOfType(ConversionFailedException.class).isThrownBy(() -> convert(conversionService, '10WB'))
			.havingCause()
			.isInstanceOf(IllegalArgumentException.class)
			.withMessageContaining('"10WB" is not a valid data size');
	}
	@ConversionServiceTest
	void convertWhenEmptyShouldReturnNull(ConversionService conversionService) {
		assertThat(convert(conversionService, '')).isNull();
	}
	private DataSize convert(ConversionService conversionService, String source) {
		return conversionService.convert(source, DataSize.class);
	}
	private DataSize convert(ConversionService conversionService, String source, DataUnit unit) {
		return (DataSize) conversionService.convert(source, TypeDescriptor.forObject(source),
				MockDataSizeTypeDescriptor.get(unit));
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with(new StringToDataSizeConverter());
	}
}
/*
package org.springframework.boot.convert;
/**
class DurationStyleTests {
	@Test
	void detectAndParseWhenValueIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DurationStyle.detectAndParse(null))
			.withMessageContaining('Value must not be null');
	}
	@Test
	void detectAndParseWhenIso8601ShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('pt20.345s')).isEqualTo(Duration.parse('pt20.345s'));
		assertThat(DurationStyle.detectAndParse('PT20.345S')).isEqualTo(Duration.parse('PT20.345S'));
		assertThat(DurationStyle.detectAndParse('PT15M')).isEqualTo(Duration.parse('PT15M'));
		assertThat(DurationStyle.detectAndParse('+PT15M')).isEqualTo(Duration.parse('PT15M'));
		assertThat(DurationStyle.detectAndParse('PT10H')).isEqualTo(Duration.parse('PT10H'));
		assertThat(DurationStyle.detectAndParse('P2D')).isEqualTo(Duration.parse('P2D'));
		assertThat(DurationStyle.detectAndParse('P2DT3H4M')).isEqualTo(Duration.parse('P2DT3H4M'));
		assertThat(DurationStyle.detectAndParse('-PT6H3M')).isEqualTo(Duration.parse('-PT6H3M'));
		assertThat(DurationStyle.detectAndParse('-PT-6H+3M')).isEqualTo(Duration.parse('-PT-6H+3M'));
	}
	@Test
	void detectAndParseWhenSimpleNanosShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10ns')).hasNanos(10);
		assertThat(DurationStyle.detectAndParse('10NS')).hasNanos(10);
		assertThat(DurationStyle.detectAndParse('+10ns')).hasNanos(10);
		assertThat(DurationStyle.detectAndParse('-10ns')).hasNanos(-10);
	}
	@Test
	void detectAndParseWhenSimpleMicrosShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10us')).hasNanos(10000);
		assertThat(DurationStyle.detectAndParse('10US')).hasNanos(10000);
		assertThat(DurationStyle.detectAndParse('+10us')).hasNanos(10000);
		assertThat(DurationStyle.detectAndParse('-10us')).hasNanos(-10000);
	}
	@Test
	void detectAndParseWhenSimpleMillisShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10ms')).hasMillis(10);
		assertThat(DurationStyle.detectAndParse('10MS')).hasMillis(10);
		assertThat(DurationStyle.detectAndParse('+10ms')).hasMillis(10);
		assertThat(DurationStyle.detectAndParse('-10ms')).hasMillis(-10);
	}
	@Test
	void detectAndParseWhenSimpleSecondsShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10s')).hasSeconds(10);
		assertThat(DurationStyle.detectAndParse('10S')).hasSeconds(10);
		assertThat(DurationStyle.detectAndParse('+10s')).hasSeconds(10);
		assertThat(DurationStyle.detectAndParse('-10s')).hasSeconds(-10);
	}
	@Test
	void detectAndParseWhenSimpleMinutesShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10m')).hasMinutes(10);
		assertThat(DurationStyle.detectAndParse('10M')).hasMinutes(10);
		assertThat(DurationStyle.detectAndParse('+10m')).hasMinutes(10);
		assertThat(DurationStyle.detectAndParse('-10m')).hasMinutes(-10);
	}
	@Test
	void detectAndParseWhenSimpleHoursShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10h')).hasHours(10);
		assertThat(DurationStyle.detectAndParse('10H')).hasHours(10);
		assertThat(DurationStyle.detectAndParse('+10h')).hasHours(10);
		assertThat(DurationStyle.detectAndParse('-10h')).hasHours(-10);
	}
	@Test
	void detectAndParseWhenSimpleDaysShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10d')).hasDays(10);
		assertThat(DurationStyle.detectAndParse('10D')).hasDays(10);
		assertThat(DurationStyle.detectAndParse('+10d')).hasDays(10);
		assertThat(DurationStyle.detectAndParse('-10d')).hasDays(-10);
	}
	@Test
	void detectAndParseWhenSimpleWithoutSuffixShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10')).hasMillis(10);
		assertThat(DurationStyle.detectAndParse('+10')).hasMillis(10);
		assertThat(DurationStyle.detectAndParse('-10')).hasMillis(-10);
	}
	@Test
	void detectAndParseWhenSimpleWithoutSuffixButWithChronoUnitShouldReturnDuration() {
		assertThat(DurationStyle.detectAndParse('10', ChronoUnit.SECONDS)).hasSeconds(10);
		assertThat(DurationStyle.detectAndParse('+10', ChronoUnit.SECONDS)).hasSeconds(10);
		assertThat(DurationStyle.detectAndParse('-10', ChronoUnit.SECONDS)).hasSeconds(-10);
	}
	@Test
	void detectAndParseWhenBadFormatShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DurationStyle.detectAndParse('10foo'))
			.withMessageContaining('"10foo" is not a valid duration');
	}
	@Test
	void detectWhenSimpleShouldReturnSimple() {
		assertThat(DurationStyle.detect('10')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('+10')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('-10')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('10ns')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('10ms')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('10s')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('10m')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('10h')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('10d')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('-10ms')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('-10ms')).isEqualTo(DurationStyle.SIMPLE);
		assertThat(DurationStyle.detect('10D')).isEqualTo(DurationStyle.SIMPLE);
	}
	@Test
	void detectWhenIso8601ShouldReturnIso8601() {
		assertThat(DurationStyle.detect('pt20.345s')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('PT20.345S')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('PT15M')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('+PT15M')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('PT10H')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('P2D')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('P2DT3H4M')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('-PT6H3M')).isEqualTo(DurationStyle.ISO8601);
		assertThat(DurationStyle.detect('-PT-6H+3M')).isEqualTo(DurationStyle.ISO8601);
	}
	@Test
	void detectWhenUnknownShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DurationStyle.detect('bad'))
			.withMessageContaining('"bad" is not a valid duration');
	}
	@Test
	void parseIso8601ShouldParse() {
		assertThat(DurationStyle.ISO8601.parse('pt20.345s')).isEqualTo(Duration.parse('pt20.345s'));
		assertThat(DurationStyle.ISO8601.parse('PT20.345S')).isEqualTo(Duration.parse('PT20.345S'));
		assertThat(DurationStyle.ISO8601.parse('PT15M')).isEqualTo(Duration.parse('PT15M'));
		assertThat(DurationStyle.ISO8601.parse('+PT15M')).isEqualTo(Duration.parse('PT15M'));
		assertThat(DurationStyle.ISO8601.parse('PT10H')).isEqualTo(Duration.parse('PT10H'));
		assertThat(DurationStyle.ISO8601.parse('P2D')).isEqualTo(Duration.parse('P2D'));
		assertThat(DurationStyle.ISO8601.parse('P2DT3H4M')).isEqualTo(Duration.parse('P2DT3H4M'));
		assertThat(DurationStyle.ISO8601.parse('-PT6H3M')).isEqualTo(Duration.parse('-PT6H3M'));
		assertThat(DurationStyle.ISO8601.parse('-PT-6H+3M')).isEqualTo(Duration.parse('-PT-6H+3M'));
	}
	@Test
	void parseIso8601WithUnitShouldIgnoreUnit() {
		assertThat(DurationStyle.ISO8601.parse('pt20.345s', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('pt20.345s'));
		assertThat(DurationStyle.ISO8601.parse('PT20.345S', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('PT20.345S'));
		assertThat(DurationStyle.ISO8601.parse('PT15M', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('PT15M'));
		assertThat(DurationStyle.ISO8601.parse('+PT15M', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('PT15M'));
		assertThat(DurationStyle.ISO8601.parse('PT10H', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('PT10H'));
		assertThat(DurationStyle.ISO8601.parse('P2D')).isEqualTo(Duration.parse('P2D'));
		assertThat(DurationStyle.ISO8601.parse('P2DT3H4M', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('P2DT3H4M'));
		assertThat(DurationStyle.ISO8601.parse('-PT6H3M', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('-PT6H3M'));
		assertThat(DurationStyle.ISO8601.parse('-PT-6H+3M', ChronoUnit.SECONDS)).isEqualTo(Duration.parse('-PT-6H+3M'));
	}
	@Test
	void parseIso8601WhenSimpleShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DurationStyle.ISO8601.parse('10d'))
			.withMessageContaining('"10d" is not a valid ISO-8601 duration');
	}
	@Test
	void parseSimpleShouldParse() {
		assertThat(DurationStyle.SIMPLE.parse('10m')).hasMinutes(10);
	}
	@Test
	void parseSimpleWithUnitShouldUseUnitAsFallback() {
		assertThat(DurationStyle.SIMPLE.parse('10m', ChronoUnit.SECONDS)).hasMinutes(10);
		assertThat(DurationStyle.SIMPLE.parse('10', ChronoUnit.MINUTES)).hasMinutes(10);
	}
	@Test
	void parseSimpleWhenUnknownUnitShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DurationStyle.SIMPLE.parse('10mb'))
			.satisfies((ex) -> assertThat(ex.getCause().getMessage()).isEqualTo('Unknown unit "mb"'));
	}
	@Test
	void parseSimpleWhenIso8601ShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> DurationStyle.SIMPLE.parse('PT10H'))
			.withMessageContaining('"PT10H" is not a valid simple duration');
	}
	@Test
	void printIso8601ShouldPrint() {
		Duration duration = Duration.parse('-PT-6H+3M');
		assertThat(DurationStyle.ISO8601.print(duration)).isEqualTo('PT5H57M');
	}
	@Test
	void printIso8601ShouldIgnoreUnit() {
		Duration duration = Duration.parse('-PT-6H+3M');
		assertThat(DurationStyle.ISO8601.print(duration, ChronoUnit.DAYS)).isEqualTo('PT5H57M');
	}
	@Test
	void printSimpleWithoutUnitShouldPrintInMs() {
		Duration duration = Duration.ofSeconds(1);
		assertThat(DurationStyle.SIMPLE.print(duration)).isEqualTo('1000ms');
	}
	@Test
	void printSimpleWithSecondsUnitShouldPrintInUnit() {
		Duration duration = Duration.ofMillis(1000);
		assertThat(DurationStyle.SIMPLE.print(duration, ChronoUnit.SECONDS)).isEqualTo('1s');
	}
	@Test
	void printSimpleWithMicrosUnitShouldPrintInUnit() {
		Duration duration = Duration.ofNanos(2000);
		assertThat(DurationStyle.SIMPLE.print(duration, ChronoUnit.MICROS)).isEqualTo('2us');
	}
}
/*
package org.springframework.boot.convert;
/**
@ParameterizedTest
@MethodSource('conversionServices')
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ConversionServiceTest {
}
/*
package org.springframework.boot.convert;
/**
class ApplicationConversionServiceTests {
	private final FormatterRegistry registry = mock(FormatterRegistry.class);
	@Test
	void addBeansWhenHasGenericConverterBeanAddConverter() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(
				ExampleGenericConverter.class)) {
			ApplicationConversionService.addBeans(this.registry, context);
			then(this.registry).should().addConverter(context.getBean(ExampleGenericConverter.class));
			then(this.registry).shouldHaveNoMoreInteractions();
		}
	}
	@Test
	void addBeansWhenHasConverterBeanAddConverter() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(ExampleConverter.class)) {
			ApplicationConversionService.addBeans(this.registry, context);
			then(this.registry).should().addConverter(context.getBean(ExampleConverter.class));
			then(this.registry).shouldHaveNoMoreInteractions();
		}
	}
	@Test
	void addBeansWhenHasFormatterBeanAddsOnlyFormatter() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(ExampleFormatter.class)) {
			ApplicationConversionService.addBeans(this.registry, context);
			then(this.registry).should().addFormatter(context.getBean(ExampleFormatter.class));
			then(this.registry).shouldHaveNoMoreInteractions();
		}
	}
	@Test
	void addBeansWhenHasPrinterBeanAddPrinter() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(ExamplePrinter.class)) {
			ApplicationConversionService.addBeans(this.registry, context);
			then(this.registry).should().addPrinter(context.getBean(ExamplePrinter.class));
			then(this.registry).shouldHaveNoMoreInteractions();
		}
	}
	@Test
	void addBeansWhenHasParserBeanAddParser() {
		try (ConfigurableApplicationContext context = new AnnotationConfigApplicationContext(ExampleParser.class)) {
			ApplicationConversionService.addBeans(this.registry, context);
			then(this.registry).should().addParser(context.getBean(ExampleParser.class));
			then(this.registry).shouldHaveNoMoreInteractions();
		}
	}
	@Test
	void isConvertViaObjectSourceTypeWhenObjectSourceReturnsTrue() {
		// Uses ObjectToCollectionConverter
		ApplicationConversionService conversionService = new ApplicationConversionService();
		TypeDescriptor sourceType = TypeDescriptor.valueOf(Long.class);
		TypeDescriptor targetType = TypeDescriptor.valueOf(List.class);
		assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();
		assertThat(conversionService.isConvertViaObjectSourceType(sourceType, targetType)).isTrue();
	}
	@Test
	void isConvertViaObjectSourceTypeWhenNotObjectSourceReturnsFalse() {
		// Uses StringToCollectionConverter
		ApplicationConversionService conversionService = new ApplicationConversionService();
		TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class);
		TypeDescriptor targetType = TypeDescriptor.valueOf(List.class);
		assertThat(conversionService.canConvert(sourceType, targetType)).isTrue();
		assertThat(conversionService.isConvertViaObjectSourceType(sourceType, targetType)).isFalse();
	}
	@Test
	void sharedInstanceCannotBeModified() {
		ApplicationConversionService instance = (ApplicationConversionService) ApplicationConversionService
			.getSharedInstance();
		assertUnmodifiableExceptionThrown(() -> instance.addPrinter(null));
		assertUnmodifiableExceptionThrown(() -> instance.addParser(null));
		assertUnmodifiableExceptionThrown(() -> instance.addFormatter(null));
		assertUnmodifiableExceptionThrown(() -> instance.addFormatterForFieldType(null, null));
		assertUnmodifiableExceptionThrown(() -> instance.addConverter((Converter<?, ?>) null));
		assertUnmodifiableExceptionThrown(() -> instance.addFormatterForFieldType(null, null, null));
		assertUnmodifiableExceptionThrown(() -> instance.addFormatterForFieldAnnotation(null));
		assertUnmodifiableExceptionThrown(() -> instance.addConverter(null, null, null));
		assertUnmodifiableExceptionThrown(() -> instance.addConverter((GenericConverter) null));
		assertUnmodifiableExceptionThrown(() -> instance.addConverterFactory(null));
		assertUnmodifiableExceptionThrown(() -> instance.removeConvertible(null, null));
	}
	private void assertUnmodifiableExceptionThrown(ThrowingCallable throwingCallable) {
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(throwingCallable)
			.withMessage('This ApplicationConversionService cannot be modified');
	}
	static class ExampleGenericConverter implements GenericConverter {
		@Override
		public Set<ConvertiblePair> getConvertibleTypes() {
			return null;
		}
		@Override
		public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
			return null;
		}
	}
	static class ExampleConverter implements Converter<String, Integer> {
		@Override
		public Integer convert(String source) {
			return null;
		}
	}
	static class ExampleFormatter implements Formatter<Integer> {
		@Override
		public String print(Integer object, Locale locale) {
			return null;
		}
		@Override
		public Integer parse(String text, Locale locale) throws ParseException {
			return null;
		}
	}
	static class ExampleParser implements Parser<Integer> {
		@Override
		public Integer parse(String text, Locale locale) throws ParseException {
			return null;
		}
	}
	static class ExamplePrinter implements Printer<Integer> {
		@Override
		public String print(Integer object, Locale locale) {
			return null;
		}
	}
}
/*
package org.springframework.boot.convert;
/**
class CollectionToDelimitedStringConverterTests {
	@ConversionServiceTest
	void convertListToStringShouldConvert(ConversionService conversionService) {
		List<String> list = Arrays.asList('a', 'b', 'c');
		String converted = conversionService.convert(list, String.class);
		assertThat(converted).isEqualTo('a,b,c');
	}
	@ConversionServiceTest
	void convertWhenHasDelimiterNoneShouldConvert(ConversionService conversionService) {
		Data data = new Data();
		data.none = Arrays.asList('1', '2', '3');
		String converted = (String) conversionService.convert(data.none,
				TypeDescriptor.nested(ReflectionUtils.findField(Data.class, 'none'), 0),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('123');
	}
	@ConversionServiceTest
	void convertWhenHasDelimiterDashShouldConvert(ConversionService conversionService) {
		Data data = new Data();
		data.dash = Arrays.asList('1', '2', '3');
		String converted = (String) conversionService.convert(data.dash,
				TypeDescriptor.nested(ReflectionUtils.findField(Data.class, 'dash'), 0),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1-2-3');
	}
	@ConversionServiceTest
	void convertShouldConvertNull(ConversionService conversionService) {
		List<String> list = null;
		String converted = conversionService.convert(list, String.class);
		assertThat(converted).isNull();
	}
	@Test
	void convertShouldConvertElements() {
		Data data = new Data();
		data.type = Arrays.asList(1, 2, 3);
		String converted = (String) new ApplicationConversionService().convert(data.type,
				TypeDescriptor.nested(ReflectionUtils.findField(Data.class, 'type'), 0),
				TypeDescriptor.valueOf(String.class));
		assertThat(converted).isEqualTo('1.2.3');
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments
			.with((service) -> service.addConverter(new CollectionToDelimitedStringConverter(service)));
	}
	static class Data {
		@Delimiter(Delimiter.NONE)
		List<String> none;
		@Delimiter('-')
		List<String> dash;
		@Delimiter('.')
		List<Integer> type;
	}
}
/*
package org.springframework.boot.cloud.cloudfoundry;
/**
class CloudFoundryVcapEnvironmentPostProcessorTests {
	private final CloudFoundryVcapEnvironmentPostProcessor initializer = new CloudFoundryVcapEnvironmentPostProcessor(
			Supplier::get);
	private final ConfigurableApplicationContext context = new AnnotationConfigApplicationContext();
	@Test
	void testApplicationProperties() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,
				'VCAP_APPLICATION={\'application_users\':[],\'instance_id\':\'bb7935245adf3e650dfb7c58a06e9ece\','
						+ '\'instance_index\':0,\'version\':\'3464e092-1c13-462e-a47c-807c30318a50\','
						+ '\'name\':\'foo\',\'uris\':[\'foo.cfapps.io\'],'
						+ '\'started_at\':\'2013-05-29 02:37:59 +0000\',\'started_at_timestamp\':1369795079,'
						+ '\'host\':\'0.0.0.0\',\'port\':61034,'
						+ '\'limits\':{\'mem\':128,\'disk\':1024,\'fds\':16384},'
						+ '\'version\':\'3464e092-1c13-462e-a47c-807c30318a50\','
						+ '\'name\':\'dsyerenv\',\'uris\':[\'dsyerenv.cfapps.io\'],'
						+ '\'users\':[],\'start\':\'2013-05-29 02:37:59 +0000\',\'state_timestamp\':1369795079}');
		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
		assertThat(getProperty('vcap.application.instance_id')).isEqualTo('bb7935245adf3e650dfb7c58a06e9ece');
	}
	@Test
	void testApplicationUris() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,
				'VCAP_APPLICATION={\'instance_id\':\'bb7935245adf3e650dfb7c58a06e9ece\',\'instance_index\':0,\'uris\':[\'foo.cfapps.io\']}');
		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
		assertThat(getProperty('vcap.application.uris[0]')).isEqualTo('foo.cfapps.io');
	}
	@Test
	void testUnparseableApplicationProperties() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, 'VCAP_APPLICATION:');
		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
		assertThat(getProperty('vcap')).isNull();
	}
	@Test
	void testNullApplicationProperties() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,
				'VCAP_APPLICATION={\'application_users\':null,'
						+ '\'instance_id\':\'bb7935245adf3e650dfb7c58a06e9ece\','
						+ '\'instance_index\':0,\'version\':\'3464e092-1c13-462e-a47c-807c30318a50\','
						+ '\'name\':\'foo\',\'uris\':[\'foo.cfapps.io\'],'
						+ '\'started_at\':\'2013-05-29 02:37:59 +0000\',\'started_at_timestamp\':1369795079,'
						+ '\'host\':\'0.0.0.0\',\'port\':61034,'
						+ '\'limits\':{\'mem\':128,\'disk\':1024,\'fds\':16384},'
						+ '\'version\':\'3464e092-1c13-462e-a47c-807c30318a50\','
						+ '\'name\':\'dsyerenv\',\'uris\':[\'dsyerenv.cfapps.io\'],'
						+ '\'users\':[],\'start\':\'2013-05-29 02:37:59 +0000\',\'state_timestamp\':1369795079}');
		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
		assertThat(getProperty('vcap')).isNull();
	}
	@Test
	void testServiceProperties() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,
				'VCAP_SERVICES={\'rds-mysql-n/a\':[{\'name\':\'mysql\',\'label\':\'rds-mysql-n/a\','
						+ '\'plan\':\'10mb\',\'credentials\':{\'name\':\'d04fb13d27d964c62b267bbba1cffb9da\','
						+ '\'hostname\':\'mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\','
						+ '\'ssl\':true,\'location\':null,'
						+ '\'host\':\'mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\','
						+ '\'port\':3306,\'user\':\'urpRuqTf8Cpe6\',\'username\':'
						+ '\'urpRuqTf8Cpe6\',\'password\':\'pxLsGVpsC9A5S\'}}]}');
		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
		assertThat(getProperty('vcap.services.mysql.name')).isEqualTo('mysql');
		assertThat(getProperty('vcap.services.mysql.credentials.port')).isEqualTo('3306');
		assertThat(getProperty('vcap.services.mysql.credentials.ssl')).isEqualTo('true');
		assertThat(getProperty('vcap.services.mysql.credentials.location')).isEmpty();
	}
	@Test
	void testServicePropertiesWithoutNA() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,
				'VCAP_SERVICES={\'rds-mysql\':[{\'name\':\'mysql\',\'label\':\'rds-mysql\',\'plan\':\'10mb\','
						+ '\'credentials\':{\'name\':\'d04fb13d27d964c62b267bbba1cffb9da\','
						+ '\'hostname\':\'mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\','
						+ '\'host\':\'mysql-service-public.clqg2e2w3ecf.us-east-1.rds.amazonaws.com\','
						+ '\'port\':3306,\'user\':\'urpRuqTf8Cpe6\',\'username\':\'urpRuqTf8Cpe6\','
						+ '\'password\':\'pxLsGVpsC9A5S\'}}]}');
		this.initializer.postProcessEnvironment(this.context.getEnvironment(), null);
		assertThat(getProperty('vcap.services.mysql.name')).isEqualTo('mysql');
		assertThat(getProperty('vcap.services.mysql.credentials.port')).isEqualTo('3306');
	}
	@Test
	void orderShouldBeBeforeConfigDataEnvironmentPostProcessorWithGap() {
		assertThat(this.initializer.getOrder()).isLessThan(ConfigDataEnvironmentPostProcessor.ORDER);
		assertThat(this.initializer.getOrder()).isLessThan(ConfigDataEnvironmentPostProcessor.ORDER - 1);
	}
	private String getProperty(String key) {
		return this.context.getEnvironment().getProperty(key);
	}
}
/*
package org.springframework.boot.cloud;
/**
class CloudPlatformTests {
	@Test
	void getActiveWhenEnvironmentIsNullShouldReturnNull() {
		CloudPlatform platform = CloudPlatform.getActive(null);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenNotInCloudShouldReturnNull() {
		Environment environment = new MockEnvironment();
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasVcapApplicationShouldReturnCloudFoundry() {
		Environment environment = new MockEnvironment().withProperty('VCAP_APPLICATION', '---');
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.CLOUD_FOUNDRY);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasVcapServicesShouldReturnCloudFoundry() {
		Environment environment = new MockEnvironment().withProperty('VCAP_SERVICES', '---');
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.CLOUD_FOUNDRY);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasDynoShouldReturnHeroku() {
		Environment environment = new MockEnvironment().withProperty('DYNO', '---');
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.HEROKU);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasHcLandscapeShouldReturnSap() {
		Environment environment = new MockEnvironment().withProperty('HC_LANDSCAPE', '---');
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.SAP);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasNomadAllocIdShouldReturnNomad() {
		Environment environment = new MockEnvironment().withProperty('NOMAD_ALLOC_ID', '---');
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.NOMAD);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasKubernetesServiceHostAndPortShouldReturnKubernetes() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('KUBERNETES_SERVICE_HOST', '---');
		envVars.put('KUBERNETES_SERVICE_PORT', '8080');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.KUBERNETES);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasKubernetesServiceHostAndNoKubernetesServicePortShouldNotReturnKubernetes() {
		Environment environment = getEnvironmentWithEnvVariables(
				Collections.singletonMap('KUBERNETES_SERVICE_HOST', '---'));
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasKubernetesServicePortAndNoKubernetesServiceHostShouldNotReturnKubernetes() {
		Environment environment = getEnvironmentWithEnvVariables(
				Collections.singletonMap('KUBERNETES_SERVICE_PORT', '8080'));
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasServiceHostAndServicePortShouldReturnKubernetes() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('EXAMPLE_SERVICE_HOST', '---');
		envVars.put('EXAMPLE_SERVICE_PORT', '8080');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.KUBERNETES);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasServiceHostAndNoServicePortShouldNotReturnKubernetes() {
		Environment environment = getEnvironmentWithEnvVariables(
				Collections.singletonMap('EXAMPLE_SERVICE_HOST', '---'));
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasAllAzureEnvVariablesShouldReturnAzureAppService() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('WEBSITE_SITE_NAME', '---');
		envVars.put('WEBSITE_INSTANCE_ID', '1234');
		envVars.put('WEBSITE_RESOURCE_GROUP', 'test');
		envVars.put('WEBSITE_SKU', '1234');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.AZURE_APP_SERVICE);
		assertThat(platform.isActive(environment)).isTrue();
	}
	@Test
	void getActiveWhenHasMissingWebsiteSiteNameShouldNotReturnAzureAppService() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('WEBSITE_INSTANCE_ID', '1234');
		envVars.put('WEBSITE_RESOURCE_GROUP', 'test');
		envVars.put('WEBSITE_SKU', '1234');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasMissingWebsiteInstanceIdShouldNotReturnAzureAppService() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('WEBSITE_SITE_NAME', '---');
		envVars.put('WEBSITE_RESOURCE_GROUP', 'test');
		envVars.put('WEBSITE_SKU', '1234');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasMissingWebsiteResourceGroupShouldNotReturnAzureAppService() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('WEBSITE_SITE_NAME', '---');
		envVars.put('WEBSITE_INSTANCE_ID', '1234');
		envVars.put('WEBSITE_SKU', '1234');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasMissingWebsiteSkuShouldNotReturnAzureAppService() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('WEBSITE_SITE_NAME', '---');
		envVars.put('WEBSITE_INSTANCE_ID', '1234');
		envVars.put('WEBSITE_RESOURCE_GROUP', 'test');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isNull();
	}
	@Test
	void getActiveWhenHasEnforcedCloudPlatform() {
		Environment environment = getEnvironmentWithEnvVariables(
				Collections.singletonMap('spring.main.cloud-platform', 'kubernetes'));
		CloudPlatform platform = CloudPlatform.getActive(environment);
		assertThat(platform).isEqualTo(CloudPlatform.KUBERNETES);
	}
	@Test
	void isEnforcedWhenEnvironmentPropertyMatchesReturnsTrue() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.main.cloud-platform', 'kubernetes');
		assertThat(CloudPlatform.KUBERNETES.isEnforced(environment)).isTrue();
	}
	@Test
	void isEnforcedWhenEnvironmentPropertyDoesNotMatchReturnsFalse() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.main.cloud-platform', 'heroku');
		assertThat(CloudPlatform.KUBERNETES.isEnforced(environment)).isFalse();
	}
	@Test
	void isEnforcedWhenEnvironmentPropertyIsMissingReturnsFalse() {
		MockEnvironment environment = new MockEnvironment();
		assertThat(CloudPlatform.KUBERNETES.isEnforced(environment)).isFalse();
	}
	@Test
	void isEnforcedWhenBinderPropertyMatchesReturnsTrue() {
		Binder binder = new Binder(new MockConfigurationPropertySource('spring.main.cloud-platform', 'kubernetes'));
		assertThat(CloudPlatform.KUBERNETES.isEnforced(binder)).isTrue();
	}
	@Test
	void isEnforcedWhenBinderPropertyDoesNotMatchReturnsFalse() {
		Binder binder = new Binder(new MockConfigurationPropertySource('spring.main.cloud-platform', 'heroku'));
		assertThat(CloudPlatform.KUBERNETES.isEnforced(binder)).isFalse();
	}
	@Test
	void isEnforcedWhenBinderPropertyIsMissingReturnsFalse() {
		Binder binder = new Binder(new MockConfigurationPropertySource());
		assertThat(CloudPlatform.KUBERNETES.isEnforced(binder)).isFalse();
	}
	void isActiveWhenNoCloudPlatformIsEnforcedAndHasKubernetesServiceHostAndKubernetesServicePort() {
		Map<String, Object> envVars = new HashMap<>();
		envVars.put('EXAMPLE_SERVICE_HOST', '---');
		envVars.put('EXAMPLE_SERVICE_PORT', '8080');
		Environment environment = getEnvironmentWithEnvVariables(envVars);
		((MockEnvironment) environment).setProperty('spring.main.cloud-platform', 'none');
		assertThat(Stream.of(CloudPlatform.values()).filter((platform) -> platform.isActive(environment)))
			.containsExactly(CloudPlatform.NONE);
	}
	private Environment getEnvironmentWithEnvVariables(Map<String, Object> environmentVariables) {
		MockEnvironment environment = new MockEnvironment();
		PropertySource<?> propertySource = new SystemEnvironmentPropertySource(
				StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, environmentVariables);
		environment.getPropertySources().addFirst(propertySource);
		return environment;
	}
}
/*
package org.springframework.boot;
/**
@Configuration(proxyBeanMethods = false)
@ExtendWith(OutputCaptureExtension.class)
class SimpleMainTests {
	private static final String SPRING_STARTUP = 'Started SpringApplication in';
	@Test
	void emptyApplicationContext() {
		assertThatIllegalArgumentException().isThrownBy(() -> SpringApplication.main(getArgs()));
	}
	@Test
	void basePackageScan(CapturedOutput output) throws Exception {
		SpringApplication.main(getArgs(ClassUtils.getPackageName(getClass()) + '.sampleconfig'));
		assertThat(output).contains(SPRING_STARTUP);
	}
	@Test
	void configClassContext(CapturedOutput output) throws Exception {
		SpringApplication.main(getArgs(getClass().getName()));
		assertThat(output).contains(SPRING_STARTUP);
	}
	@Test
	void xmlContext(CapturedOutput output) throws Exception {
		SpringApplication.main(getArgs('org/springframework/boot/sample-beans.xml'));
		assertThat(output).contains(SPRING_STARTUP);
	}
	@Test
	void mixedContext(CapturedOutput output) throws Exception {
		SpringApplication.main(getArgs(getClass().getName(), 'org/springframework/boot/sample-beans.xml'));
		assertThat(output).contains(SPRING_STARTUP);
	}
	private String[] getArgs(String... args) {
		List<String> list = new ArrayList<>(Arrays.asList('--spring.main.web-application-type=none',
				'--spring.main.show-banner=OFF', '--spring.main.register-shutdownHook=false'));
		if (args.length > 0) {
			list.add('--spring.main.sources=' + StringUtils.arrayToCommaDelimitedString(args));
		}
		return StringUtils.toStringArray(list);
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar', 'reactor-netty-http-*.jar' })
@SuppressWarnings('removal')
class HttpWebServiceMessageSenderBuilderSimpleIntegrationTests {
	private final HttpWebServiceMessageSenderBuilder builder = new HttpWebServiceMessageSenderBuilder();
	@Test
	void buildUseUseSimpleClientByDefault() {
		WebServiceMessageSender messageSender = this.builder.build();
		assertSimpleClientRequestFactory(messageSender);
	}
	@Test
	void buildWithCustomTimeouts() {
		WebServiceMessageSender messageSender = this.builder.setConnectTimeout(Duration.ofSeconds(5))
			.setReadTimeout(Duration.ofSeconds(2))
			.build();
		SimpleClientHttpRequestFactory requestFactory = assertSimpleClientRequestFactory(messageSender);
		assertThat(requestFactory).hasFieldOrPropertyWithValue('connectTimeout', 5000);
		assertThat(requestFactory).hasFieldOrPropertyWithValue('readTimeout', 2000);
	}
	private SimpleClientHttpRequestFactory assertSimpleClientRequestFactory(WebServiceMessageSender messageSender) {
		assertThat(messageSender).isInstanceOf(ClientHttpRequestMessageSender.class);
		ClientHttpRequestMessageSender sender = (ClientHttpRequestMessageSender) messageSender;
		ClientHttpRequestFactory requestFactory = sender.getRequestFactory();
		assertThat(requestFactory).isInstanceOf(SimpleClientHttpRequestFactory.class);
		return (SimpleClientHttpRequestFactory) requestFactory;
	}
}
/*
package org.springframework.boot.webservices.client;
/**
class WebServiceMessageSenderFactoryTests {
	@Test
	void httpWhenDetectedHttpComponents() {
		WebServiceMessageSender sender = WebServiceMessageSenderFactory.http().getWebServiceMessageSender();
		assertRequestFactoryInstanceOf(sender, HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	@ClassPathExclusions('httpclient5-*.jar')
	void httpWhenDetectedJetty() {
		WebServiceMessageSender sender = WebServiceMessageSenderFactory.http().getWebServiceMessageSender();
		assertRequestFactoryInstanceOf(sender, JettyClientHttpRequestFactory.class);
	}
	@Test
	@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar' })
	void httpWhenDetectedReactor() {
		WebServiceMessageSender sender = WebServiceMessageSenderFactory.http().getWebServiceMessageSender();
		assertRequestFactoryInstanceOf(sender, ReactorClientHttpRequestFactory.class);
	}
	@Test
	@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar', 'reactor-netty-http-*.jar' })
	void httpWhenDetectedJdk() {
		WebServiceMessageSender sender = WebServiceMessageSenderFactory.http().getWebServiceMessageSender();
		assertRequestFactoryInstanceOf(sender, JdkClientHttpRequestFactory.class);
	}
	@Test
	@ClassPathExclusions('httpclient5-*.jar')
	void httpWithSettingsUsesSettings() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(5))
			.withReadTimeout(Duration.ofSeconds(2));
		WebServiceMessageSender sender = WebServiceMessageSenderFactory.http(settings).getWebServiceMessageSender();
		assertTimeoutsOnJetty(sender);
	}
	@Test
	void httpWithFactoryAndSettingsUsesFactoryAndSettings() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(5))
			.withReadTimeout(Duration.ofSeconds(2));
		WebServiceMessageSender sender = WebServiceMessageSenderFactory
			.http(ClientHttpRequestFactoryBuilder.jetty(), settings)
			.getWebServiceMessageSender();
		assertTimeoutsOnJetty(sender);
	}
	@Test
	void httpWithFactoryAndSettingsWhenFactoryIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> WebServiceMessageSenderFactory.http(null, null))
			.withMessage('"requestFactoryBuilder" must not be null');
	}
	private void assertTimeoutsOnJetty(WebServiceMessageSender sender) {
		ClientHttpRequestFactory requestFactory = getRequestFactory(sender);
		HttpClient client = (HttpClient) ReflectionTestUtils.getField(requestFactory, 'httpClient');
		assertThat(client).isNotNull();
		assertThat(client.getConnectTimeout()).isEqualTo(5000);
		assertThat(requestFactory).hasFieldOrPropertyWithValue('readTimeout', 2000L);
	}
	private void assertRequestFactoryInstanceOf(WebServiceMessageSender sender, Class<?> expectedRequestFactoryType) {
		assertThat(getRequestFactory(sender)).isInstanceOf(expectedRequestFactoryType);
	}
	private ClientHttpRequestFactory getRequestFactory(WebServiceMessageSender sender) {
		assertThat(sender).isInstanceOf(ClientHttpRequestMessageSender.class);
		ClientHttpRequestFactory requestFactory = ((ClientHttpRequestMessageSender) sender).getRequestFactory();
		return requestFactory;
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@SuppressWarnings('removal')
class HttpWebServiceMessageSenderBuilderTests {
	@Test
	void buildWithRequestFactorySupplier() {
		ClientHttpRequestFactory requestFactory = mock(ClientHttpRequestFactory.class);
		ClientHttpRequestMessageSender messageSender = build(
				new HttpWebServiceMessageSenderBuilder().requestFactory(() -> requestFactory));
		assertThat(messageSender.getRequestFactory()).isSameAs(requestFactory);
	}
	@Test
	void buildWithReadAndConnectTimeout() {
		ClientHttpRequestMessageSender messageSender = build(
				new HttpWebServiceMessageSenderBuilder().requestFactory(SimpleClientHttpRequestFactory::new)
					.setConnectTimeout(Duration.ofSeconds(5))
					.setReadTimeout(Duration.ofSeconds(2)));
		SimpleClientHttpRequestFactory requestFactory = (SimpleClientHttpRequestFactory) messageSender
			.getRequestFactory();
		assertThat(requestFactory).hasFieldOrPropertyWithValue('connectTimeout', 5000);
		assertThat(requestFactory).hasFieldOrPropertyWithValue('readTimeout', 2000);
	}
	@Test
	void buildUsesHttpComponentsByDefault() {
		ClientHttpRequestMessageSender messageSender = build(
				new HttpWebServiceMessageSenderBuilder().setConnectTimeout(Duration.ofSeconds(5))
					.setReadTimeout(Duration.ofSeconds(5)));
		ClientHttpRequestFactory requestFactory = messageSender.getRequestFactory();
		assertThat(requestFactory).isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
	}
	private ClientHttpRequestMessageSender build(HttpWebServiceMessageSenderBuilder builder) {
		WebServiceMessageSender messageSender = builder.build();
		assertThat(messageSender).isInstanceOf(ClientHttpRequestMessageSender.class);
		return ((ClientHttpRequestMessageSender) messageSender);
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@ClassPathExclusions('httpclient5-*.jar')
@SuppressWarnings('removal')
class HttpWebServiceMessageSenderBuilderJettyClientIntegrationTests {
	private final HttpWebServiceMessageSenderBuilder builder = new HttpWebServiceMessageSenderBuilder();
	@Test
	void buildUseJettyClientIfHttpComponentsIsNotAvailable() {
		WebServiceMessageSender messageSender = this.builder.build();
		assertJettyClientHttpRequestFactory(messageSender);
	}
	@Test
	void buildWithCustomTimeouts() {
		WebServiceMessageSender messageSender = this.builder.setConnectTimeout(Duration.ofSeconds(5))
			.setReadTimeout(Duration.ofSeconds(2))
			.build();
		JettyClientHttpRequestFactory factory = assertJettyClientHttpRequestFactory(messageSender);
		HttpClient client = (HttpClient) ReflectionTestUtils.getField(factory, 'httpClient');
		assertThat(client).isNotNull();
		assertThat(client.getConnectTimeout()).isEqualTo(5000);
		assertThat(factory).hasFieldOrPropertyWithValue('readTimeout', 2000L);
	}
	private JettyClientHttpRequestFactory assertJettyClientHttpRequestFactory(WebServiceMessageSender messageSender) {
		assertThat(messageSender).isInstanceOf(ClientHttpRequestMessageSender.class);
		ClientHttpRequestMessageSender sender = (ClientHttpRequestMessageSender) messageSender;
		ClientHttpRequestFactory requestFactory = sender.getRequestFactory();
		assertThat(requestFactory).isInstanceOf(JettyClientHttpRequestFactory.class);
		return (JettyClientHttpRequestFactory) requestFactory;
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@ExtendWith(MockitoExtension.class)
class WebServiceTemplateBuilderTests {
	private final WebServiceTemplateBuilder builder = new WebServiceTemplateBuilder();
	@Mock
	private WebServiceMessageSender messageSender;
	@Mock
	private ClientInterceptor interceptor;
	@Test
	void createWithCustomizersShouldApplyCustomizers() {
		WebServiceTemplateCustomizer customizer = mock(WebServiceTemplateCustomizer.class);
		WebServiceTemplate template = new WebServiceTemplateBuilder(customizer).build();
		then(customizer).should().customize(template);
	}
	@Test
	void buildShouldDetectHttpMessageSender() {
		WebServiceTemplate webServiceTemplate = this.builder.build();
		assertThat(webServiceTemplate.getMessageSenders()).hasSize(1);
		WebServiceMessageSender messageSender = webServiceTemplate.getMessageSenders()[0];
		assertRequestFactoryInstanceOf(messageSender, HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	void detectHttpMessageSenderWhenFalseShouldDisableDetection() {
		WebServiceTemplate webServiceTemplate = this.builder.detectHttpMessageSender(false).build();
		assertThat(webServiceTemplate.getMessageSenders()).hasSize(1);
		assertThat(webServiceTemplate.getMessageSenders()[0]).isInstanceOf(HttpUrlConnectionMessageSender.class);
	}
	@Test
	void httpMessageSenderFactoryUsesFactory() {
		WebServiceTemplate webServiceTemplate = this.builder
			.httpMessageSenderFactory(() -> new ClientHttpRequestMessageSender(new JdkClientHttpRequestFactory()))
			.build();
		assertThat(webServiceTemplate.getMessageSenders()).hasSize(1);
		WebServiceMessageSender messageSender = webServiceTemplate.getMessageSenders()[0];
		assertRequestFactoryInstanceOf(messageSender, JdkClientHttpRequestFactory.class);
	}
	@Test
	void messageSendersWhenSendersAreAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.messageSenders((WebServiceMessageSender[]) null))
			.withMessageContaining('MessageSenders must not be null');
	}
	@Test
	void messageSendersCollectionWhenSendersAreAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.messageSenders((Collection<? extends WebServiceMessageSender>) null))
			.withMessageContaining('MessageSenders must not be null');
	}
	@Test
	void messageSendersShouldApply() {
		WebServiceTemplate template = this.builder.messageSenders(this.messageSender).build();
		assertThat(template.getMessageSenders()).containsOnly(this.messageSender);
	}
	@Test
	void messageSendersShouldReplaceExisting() {
		WebServiceTemplate template = this.builder.messageSenders(new ClientHttpRequestMessageSender())
			.messageSenders(this.messageSender)
			.build();
		assertThat(template.getMessageSenders()).containsOnly(this.messageSender);
	}
	@Test
	void additionalMessageSendersWhenSendersAreAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalMessageSenders((WebServiceMessageSender[]) null))
			.withMessageContaining('MessageSenders must not be null');
	}
	@Test
	void additionalMessageSendersCollectionWhenSendersAreAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> this.builder.additionalMessageSenders((Collection<? extends WebServiceMessageSender>) null))
			.withMessageContaining('MessageSenders must not be null');
	}
	@Test
	void additionalMessageSendersShouldAddToExisting() {
		ClientHttpRequestMessageSender httpMessageSender = new ClientHttpRequestMessageSender();
		WebServiceTemplate template = this.builder.messageSenders(httpMessageSender)
			.additionalMessageSenders(this.messageSender)
			.build();
		assertThat(template.getMessageSenders()).containsOnly(httpMessageSender, this.messageSender);
	}
	@Test
	void additionalMessageSendersShouldKeepDetectedHttpMessageSender() {
		WebServiceTemplate template = this.builder.additionalMessageSenders(this.messageSender).build();
		assertThat(template.getMessageSenders()).contains(this.messageSender);
		assertThat(template.getMessageSenders()).hasSize(2);
	}
	@Test
	void interceptorsWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.builder.interceptors((ClientInterceptor[]) null))
			.withMessageContaining('Interceptors must not be null');
	}
	@Test
	void interceptorsCollectionWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.interceptors((Collection<? extends ClientInterceptor>) null))
			.withMessageContaining('Interceptors must not be null');
	}
	@Test
	void interceptorsShouldApply() {
		WebServiceTemplate template = this.builder.interceptors(this.interceptor).build();
		assertThat(template.getInterceptors()).containsOnly(this.interceptor);
	}
	@Test
	void interceptorsShouldReplaceExisting() {
		WebServiceTemplate template = this.builder.interceptors(mock(ClientInterceptor.class))
			.interceptors(Collections.singleton(this.interceptor))
			.build();
		assertThat(template.getInterceptors()).containsOnly(this.interceptor);
	}
	@Test
	void additionalInterceptorsWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalInterceptors((ClientInterceptor[]) null))
			.withMessageContaining('Interceptors must not be null');
	}
	@Test
	void additionalInterceptorsCollectionWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalInterceptors((Set<ClientInterceptor>) null))
			.withMessageContaining('Interceptors must not be null');
	}
	@Test
	void additionalInterceptorsShouldAddToExisting() {
		ClientInterceptor interceptor = mock(ClientInterceptor.class);
		WebServiceTemplate template = this.builder.interceptors(interceptor)
			.additionalInterceptors(this.interceptor)
			.build();
		assertThat(template.getInterceptors()).containsOnly(interceptor, this.interceptor);
	}
	@Test
	void additionalInterceptorsShouldAddToExistingWebServiceTemplate() {
		ClientInterceptor f1 = mock(ClientInterceptor.class);
		ClientInterceptor f2 = mock(ClientInterceptor.class);
		WebServiceTemplate webServiceTemplate = new WebServiceTemplate();
		webServiceTemplate.setInterceptors(new ClientInterceptor[] { f1 });
		this.builder.additionalInterceptors(f2).configure(webServiceTemplate);
		assertThat(webServiceTemplate.getInterceptors()).containsExactlyInAnyOrder(f2, f1);
	}
	@Test
	void customizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((WebServiceTemplateCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((Collection<? extends WebServiceTemplateCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersShouldApply() {
		WebServiceTemplateCustomizer customizer = mock(WebServiceTemplateCustomizer.class);
		WebServiceTemplate template = this.builder.customizers(customizer).build();
		then(customizer).should().customize(template);
	}
	@Test
	void customizersShouldBeAppliedLast() {
		WebServiceTemplate template = spy(new WebServiceTemplate());
		this.builder.additionalCustomizers(
				((webServiceTemplate) -> then(webServiceTemplate).should().setMessageSenders(any())));
		this.builder.configure(template);
	}
	@Test
	void customizersShouldReplaceExisting() {
		WebServiceTemplateCustomizer customizer1 = mock(WebServiceTemplateCustomizer.class);
		WebServiceTemplateCustomizer customizer2 = mock(WebServiceTemplateCustomizer.class);
		WebServiceTemplate template = this.builder.customizers(customizer1)
			.customizers(Collections.singleton(customizer2))
			.build();
		then(customizer1).shouldHaveNoInteractions();
		then(customizer2).should().customize(template);
	}
	@Test
	void additionalCustomizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((WebServiceTemplateCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> this.builder.additionalCustomizers((Collection<? extends WebServiceTemplateCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersShouldAddToExisting() {
		WebServiceTemplateCustomizer customizer1 = mock(WebServiceTemplateCustomizer.class);
		WebServiceTemplateCustomizer customizer2 = mock(WebServiceTemplateCustomizer.class);
		WebServiceTemplate template = this.builder.customizers(customizer1).additionalCustomizers(customizer2).build();
		then(customizer1).should().customize(template);
		then(customizer2).should().customize(template);
	}
	@Test
	void setCheckConnectionForFault() {
		WebServiceTemplate template = mock(WebServiceTemplate.class);
		this.builder.setCheckConnectionForFault(false).configure(template);
		then(template).should().setCheckConnectionForFault(false);
	}
	@Test
	void setCheckConnectionForError() {
		WebServiceTemplate template = mock(WebServiceTemplate.class);
		this.builder.setCheckConnectionForError(false).configure(template);
		then(template).should().setCheckConnectionForError(false);
	}
	@Test
	void setTransformerFactoryClass() {
		WebServiceTemplate template = mock(WebServiceTemplate.class);
		this.builder.setTransformerFactoryClass(SAXTransformerFactory.class).configure(template);
		then(template).should().setTransformerFactoryClass(SAXTransformerFactory.class);
	}
	@Test
	void setWebServiceMessageFactory() {
		WebServiceMessageFactory messageFactory = mock(WebServiceMessageFactory.class);
		WebServiceTemplate template = this.builder.setWebServiceMessageFactory(messageFactory).build();
		assertThat(template.getMessageFactory()).isEqualTo(messageFactory);
	}
	@Test
	void setMarshaller() {
		Marshaller marshaller = mock(Marshaller.class);
		WebServiceTemplate template = this.builder.setMarshaller(marshaller).build();
		assertThat(template.getMarshaller()).isEqualTo(marshaller);
	}
	@Test
	void setUnmarshaller() {
		Unmarshaller unmarshaller = mock(Unmarshaller.class);
		WebServiceTemplate webServiceTemplate = this.builder.setUnmarshaller(unmarshaller).build();
		assertThat(webServiceTemplate.getUnmarshaller()).isEqualTo(unmarshaller);
	}
	@Test
	void setFaultMessageResolver() {
		FaultMessageResolver faultMessageResolver = mock(FaultMessageResolver.class);
		WebServiceTemplate webServiceTemplate = this.builder.setFaultMessageResolver(faultMessageResolver).build();
		assertThat(webServiceTemplate.getFaultMessageResolver()).isEqualTo(faultMessageResolver);
	}
	@Test
	void setDefaultUri() {
		URI uri = URI.create('http://localhost:8080');
		WebServiceTemplate webServiceTemplate = this.builder.setDefaultUri(uri.toString()).build();
		assertThat(webServiceTemplate.getDestinationProvider().getDestination()).isEqualTo(uri);
	}
	@Test
	void setDestinationProvider() {
		DestinationProvider destinationProvider = () -> URI.create('http://localhost:8080');
		WebServiceTemplate webServiceTemplate = this.builder.setDestinationProvider(destinationProvider).build();
		assertThat(webServiceTemplate.getDestinationProvider()).isEqualTo(destinationProvider);
	}
	private void assertRequestFactoryInstanceOf(WebServiceMessageSender messageSender, Class<?> type) {
		assertThat(messageSender).isInstanceOf(ClientHttpRequestMessageSender.class);
		ClientHttpRequestMessageSender sender = (ClientHttpRequestMessageSender) messageSender;
		ClientHttpRequestFactory requestFactory = sender.getRequestFactory();
		assertThat(requestFactory).isInstanceOf(type);
	}
}
/*
package org.springframework.boot.webservices.client;
/**
@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar' })
@SuppressWarnings('removal')
class HttpWebServiceMessageSenderBuilderReactorClientIntegrationTests {
	private final HttpWebServiceMessageSenderBuilder builder = new HttpWebServiceMessageSenderBuilder();
	@Test
	void buildUsesReactorClientIfHttpComponentsAndJettyAreNotAvailable() {
		WebServiceMessageSender messageSender = this.builder.build();
		assertReactorClientHttpRequestFactory(messageSender);
	}
	@Test
	void buildWithCustomTimeouts() {
		WebServiceMessageSender messageSender = this.builder.setConnectTimeout(Duration.ofSeconds(5))
			.setReadTimeout(Duration.ofSeconds(2))
			.build();
		ReactorClientHttpRequestFactory factory = assertReactorClientHttpRequestFactory(messageSender);
		assertThat(factory).extracting('httpClient', InstanceOfAssertFactories.type(HttpClient.class))
			.extracting((httpClient) -> httpClient.configuration().options(), InstanceOfAssertFactories.MAP)
			.containsEntry(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);
		assertThat(factory).hasFieldOrPropertyWithValue('readTimeout', Duration.ofSeconds(2));
	}
	private ReactorClientHttpRequestFactory assertReactorClientHttpRequestFactory(
			WebServiceMessageSender messageSender) {
		assertThat(messageSender).isInstanceOf(ClientHttpRequestMessageSender.class);
		ClientHttpRequestMessageSender sender = (ClientHttpRequestMessageSender) messageSender;
		ClientHttpRequestFactory requestFactory = sender.getRequestFactory();
		assertThat(requestFactory).isInstanceOf(ReactorClientHttpRequestFactory.class);
		return (ReactorClientHttpRequestFactory) requestFactory;
	}
}
/*
package org.springframework.boot.jdbc;
/**
class EmbeddedDatabaseConnectionTests {
	@Test
	void h2CustomDatabaseName() {
		assertThat(EmbeddedDatabaseConnection.H2.getUrl('mydb'))
			.isEqualTo('jdbc:h2:mem:mydb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE');
	}
	@Test
	void derbyCustomDatabaseName() {
		assertThat(EmbeddedDatabaseConnection.DERBY.getUrl('myderbydb'))
			.isEqualTo('jdbc:derby:memory:myderbydb;create=true');
	}
	@Test
	void hsqldbCustomDatabaseName() {
		assertThat(EmbeddedDatabaseConnection.HSQLDB.getUrl('myhsqldb')).isEqualTo('jdbc:hsqldb:mem:myhsqldb');
	}
	@Test
	void getUrlWithNullDatabaseNameForHsqldb() {
		assertThatIllegalArgumentException().isThrownBy(() -> EmbeddedDatabaseConnection.HSQLDB.getUrl(null))
			.withMessageContaining('DatabaseName must not be empty');
	}
	@Test
	void getUrlWithEmptyDatabaseNameForHsqldb() {
		assertThatIllegalArgumentException().isThrownBy(() -> EmbeddedDatabaseConnection.HSQLDB.getUrl('  '))
			.withMessageContaining('DatabaseName must not be empty');
	}
	@ParameterizedTest(name = '{0} - {1}')
	@MethodSource('embeddedDriverAndUrlParameters')
	void isEmbeddedWithDriverAndUrl(String driverClassName, String url, boolean embedded) {
		assertThat(EmbeddedDatabaseConnection.isEmbedded(driverClassName, url)).isEqualTo(embedded);
	}
	static Object[] embeddedDriverAndUrlParameters() {
		return new Object[] {
				new Object[] { EmbeddedDatabaseConnection.H2.getDriverClassName(), 'jdbc:h2:~/test', false },
				new Object[] { EmbeddedDatabaseConnection.H2.getDriverClassName(), 'jdbc:h2:mem:test;DB_CLOSE_DELAY=-1',
						true },
				new Object[] { EmbeddedDatabaseConnection.H2.getDriverClassName(), null, true },
				new Object[] { EmbeddedDatabaseConnection.HSQLDB.getDriverClassName(), 'jdbc:hsqldb:hsql://localhost',
						false },
				new Object[] { EmbeddedDatabaseConnection.HSQLDB.getDriverClassName(), 'jdbc:hsqldb:mem:test', true },
				new Object[] { EmbeddedDatabaseConnection.HSQLDB.getDriverClassName(), null, true },
				new Object[] { EmbeddedDatabaseConnection.DERBY.getDriverClassName(), 'jdbc:derby:memory:test', true },
				new Object[] { EmbeddedDatabaseConnection.DERBY.getDriverClassName(), null, true },
				new Object[] { 'com.mysql.cj.jdbc.Driver', 'jdbc:mysql:mem:test', false },
				new Object[] { 'com.mysql.cj.jdbc.Driver', null, false },
				new Object[] { null, 'jdbc:none:mem:test', false }, new Object[] { null, null, false } };
	}
	@Test
	void isEmbeddedWithH2DataSource() {
		testEmbeddedDatabase(new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2).build());
	}
	@Test
	void isEmbeddedWithHsqlDataSource() {
		testEmbeddedDatabase(new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.HSQL).build());
	}
	@Test
	void isEmbeddedWithDerbyDataSource() {
		testEmbeddedDatabase(new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.DERBY).build());
	}
	void testEmbeddedDatabase(EmbeddedDatabase database) {
		try {
			assertThat(EmbeddedDatabaseConnection.isEmbedded(database)).isTrue();
		}
		finally {
			database.shutdown();
		}
	}
	@Test
	void isEmbeddedWithUnknownDataSource() throws SQLException {
		assertThat(EmbeddedDatabaseConnection.isEmbedded(mockDataSource('unknown-db', null))).isFalse();
	}
	@Test
	void isEmbeddedWithH2File() throws SQLException {
		assertThat(EmbeddedDatabaseConnection
			.isEmbedded(mockDataSource(EmbeddedDatabaseConnection.H2.getDriverClassName(), 'jdbc:h2:~/test')))
			.isFalse();
	}
	@Test
	void isEmbeddedWithMissingDriverClassMetadata() throws SQLException {
		assertThat(EmbeddedDatabaseConnection.isEmbedded(mockDataSource(null, 'jdbc:h2:meme:test'))).isFalse();
	}
	@Test
	void isEmbeddedWithMissingUrlMetadata() throws SQLException {
		assertThat(EmbeddedDatabaseConnection
			.isEmbedded(mockDataSource(EmbeddedDatabaseConnection.H2.getDriverClassName(), null))).isTrue();
	}
	DataSource mockDataSource(String productName, String connectionUrl) throws SQLException {
		DatabaseMetaData metaData = mock(DatabaseMetaData.class);
		given(metaData.getDatabaseProductName()).willReturn(productName);
		given(metaData.getURL()).willReturn(connectionUrl);
		Connection connection = mock(Connection.class);
		given(connection.getMetaData()).willReturn(metaData);
		DataSource dataSource = mock(DataSource.class);
		given(dataSource.getConnection()).willReturn(connection);
		return dataSource;
	}
}
/*
package org.springframework.boot.jdbc;
/**
class DataSourceBuilderTests {
	private DataSource dataSource;
	@AfterEach
	void shutdownDataSource() throws IOException {
		if (this.dataSource instanceof Closeable closeable) {
			closeable.close();
		}
	}
	@Test
	void buildWhenHikariAvailableReturnsHikariDataSource() {
		this.dataSource = DataSourceBuilder.create().url('jdbc:h2:test').build();
		assertThat(this.dataSource).isInstanceOf(HikariDataSource.class);
		HikariDataSource hikariDataSource = (HikariDataSource) this.dataSource;
		assertThat(hikariDataSource.getJdbcUrl()).isEqualTo('jdbc:h2:test');
	}
	@Test // gh-26633
	void buildWhenHikariDataSourceWithNullPasswordReturnsHikariDataSource() {
		this.dataSource = DataSourceBuilder.create().url('jdbc:h2:test').username('test').password(null).build();
		assertThat(this.dataSource).isInstanceOf(HikariDataSource.class);
		HikariDataSource hikariDataSource = (HikariDataSource) this.dataSource;
		assertThat(hikariDataSource.getJdbcUrl()).isEqualTo('jdbc:h2:test');
	}
	@Test
	void buildWhenHikariNotAvailableReturnsTomcatDataSource() {
		this.dataSource = DataSourceBuilder.create(new HidePackagesClassLoader('com.zaxxer.hikari'))
			.url('jdbc:h2:test')
			.build();
		assertThat(this.dataSource).isInstanceOf(org.apache.tomcat.jdbc.pool.DataSource.class);
	}
	@Test // gh-26633
	void buildWhenTomcatDataSourceWithNullPasswordReturnsDataSource() {
		this.dataSource = DataSourceBuilder.create(new HidePackagesClassLoader('com.zaxxer.hikari'))
			.url('jdbc:h2:test')
			.username('test')
			.password(null)
			.build();
		assertThat(this.dataSource).isInstanceOf(org.apache.tomcat.jdbc.pool.DataSource.class);
	}
	@Test
	void buildWhenHikariAndTomcatNotAvailableReturnsDbcp2DataSource() {
		this.dataSource = DataSourceBuilder
			.create(new HidePackagesClassLoader('com.zaxxer.hikari', 'org.apache.tomcat.jdbc.pool'))
			.url('jdbc:h2:test')
			.build();
		assertThat(this.dataSource).isInstanceOf(BasicDataSource.class);
	}
	@Test // gh-26633
	void buildWhenDbcp2DataSourceWithNullPasswordReturnsDbcp2DataSource() {
		this.dataSource = DataSourceBuilder
			.create(new HidePackagesClassLoader('com.zaxxer.hikari', 'org.apache.tomcat.jdbc.pool'))
			.url('jdbc:h2:test')
			.username('test')
			.password(null)
			.build();
		assertThat(this.dataSource).isInstanceOf(BasicDataSource.class);
	}
	@Test
	void buildWhenHikariAndTomcatAndDbcpNotAvailableReturnsOracleUcpDataSource() {
		this.dataSource = DataSourceBuilder
			.create(new HidePackagesClassLoader('com.zaxxer.hikari', 'org.apache.tomcat.jdbc.pool',
					'org.apache.commons.dbcp2'))
			.url('jdbc:h2:test')
			.build();
		assertThat(this.dataSource).isInstanceOf(PoolDataSourceImpl.class);
	}
	@Test
	void buildWhenHikariTypeSpecifiedReturnsExpectedDataSource() {
		HikariDataSource hikariDataSource = DataSourceBuilder.create().type(HikariDataSource.class).build();
		assertThat(hikariDataSource).isInstanceOf(HikariDataSource.class);
	}
	@Test
	void buildWhenSimpleDriverTypeSpecifiedReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create().url('jdbc:h2:test').type(SimpleDriverDataSource.class).build();
		assertThat(this.dataSource).isInstanceOf(SimpleDriverDataSource.class);
		SimpleDriverDataSource simpleDriverDataSource = (SimpleDriverDataSource) this.dataSource;
		assertThat(simpleDriverDataSource.getUrl()).isEqualTo('jdbc:h2:test');
		assertThat(simpleDriverDataSource.getDriver()).isInstanceOf(Driver.class);
	}
	@Test
	void buildWhenOracleTypeSpecifiedReturnsExpectedDataSource() throws SQLException {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:oracle:thin:@localhost:1521:xe')
			.type(OracleDataSource.class)
			.username('test')
			.build();
		assertThat(this.dataSource).isInstanceOf(OracleDataSource.class);
		OracleDataSource oracleDataSource = (OracleDataSource) this.dataSource;
		assertThat(oracleDataSource.getURL()).isEqualTo('jdbc:oracle:thin:@localhost:1521:xe');
		assertThat(oracleDataSource.getUser()).isEqualTo('test');
	}
	@Test // gh-26631
	void buildWhenOracleTypeSpecifiedWithDriverClassReturnsExpectedDataSource() throws SQLException {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:oracle:thin:@localhost:1521:xe')
			.type(OracleDataSource.class)
			.driverClassName('oracle.jdbc.pool.OracleDataSource')
			.username('test')
			.build();
		assertThat(this.dataSource).isInstanceOf(OracleDataSource.class);
		OracleDataSource oracleDataSource = (OracleDataSource) this.dataSource;
		assertThat(oracleDataSource.getURL()).isEqualTo('jdbc:oracle:thin:@localhost:1521:xe');
		assertThat(oracleDataSource.getUser()).isEqualTo('test');
	}
	@Test
	void buildWhenOracleUcpTypeSpecifiedReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create()
			.driverClassName('org.hsqldb.jdbc.JDBCDriver')
			.type(PoolDataSourceImpl.class)
			.username('test')
			.build();
		assertThat(this.dataSource).isInstanceOf(PoolDataSourceImpl.class);
		PoolDataSourceImpl upcDataSource = (PoolDataSourceImpl) this.dataSource;
		assertThat(upcDataSource.getConnectionFactoryClassName()).isEqualTo('org.hsqldb.jdbc.JDBCDriver');
		assertThat(upcDataSource.getUser()).isEqualTo('test');
	}
	@Test
	void buildWhenH2TypeSpecifiedReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:h2:test')
			.type(JdbcDataSource.class)
			.username('test')
			.password('secret')
			.build();
		assertThat(this.dataSource).isInstanceOf(JdbcDataSource.class);
		JdbcDataSource h2DataSource = (JdbcDataSource) this.dataSource;
		assertThat(h2DataSource.getUser()).isEqualTo('test');
		assertThat(h2DataSource.getPassword()).isEqualTo('secret');
	}
	@Test // gh-26631
	void buildWhenH2TypeSpecifiedWithDriverClassReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:h2:test')
			.type(JdbcDataSource.class)
			.driverClassName('org.h2.jdbcx.JdbcDataSource')
			.username('test')
			.password('secret')
			.build();
		assertThat(this.dataSource).isInstanceOf(JdbcDataSource.class);
		JdbcDataSource h2DataSource = (JdbcDataSource) this.dataSource;
		assertThat(h2DataSource.getUser()).isEqualTo('test');
		assertThat(h2DataSource.getPassword()).isEqualTo('secret');
	}
	@Test
	void buildWhenPostgresTypeSpecifiedReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:postgresql://localhost/test')
			.type(PGSimpleDataSource.class)
			.username('test')
			.build();
		assertThat(this.dataSource).isInstanceOf(PGSimpleDataSource.class);
		PGSimpleDataSource pgDataSource = (PGSimpleDataSource) this.dataSource;
		assertThat(pgDataSource.getUser()).isEqualTo('test');
	}
	@Test // gh-26631
	void buildWhenPostgresTypeSpecifiedWithDriverClassReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:postgresql://localhost/test')
			.type(PGSimpleDataSource.class)
			.driverClassName('org.postgresql.ds.PGSimpleDataSource')
			.username('test')
			.build();
		assertThat(this.dataSource).isInstanceOf(PGSimpleDataSource.class);
		PGSimpleDataSource pgDataSource = (PGSimpleDataSource) this.dataSource;
		assertThat(pgDataSource.getUser()).isEqualTo('test');
	}
	@Test // gh-26647
	void buildWhenSqlServerTypeSpecifiedReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:sqlserver://localhost/test')
			.type(SQLServerDataSource.class)
			.username('test')
			.build();
		assertThat(this.dataSource).isInstanceOf(SQLServerDataSource.class);
		SQLServerDataSource sqlServerDataSource = (SQLServerDataSource) this.dataSource;
		assertThat(sqlServerDataSource.getUser()).isEqualTo('test');
	}
	@Test
	void buildWhenMappedTypeSpecifiedAndNoSuitableOptionalMappingBuilds() {
		assertThatNoException().isThrownBy(
				() -> DataSourceBuilder.create().type(OracleDataSource.class).driverClassName('com.example').build());
	}
	@Test
	void buildWhenCustomSubclassTypeSpecifiedReturnsDataSourceWithOnlyBasePropertiesSet() {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:h2:test')
			.type(CustomTomcatDataSource.class)
			.username('test')
			.build();
		assertThat(this.dataSource).isInstanceOf(CustomTomcatDataSource.class);
		CustomTomcatDataSource testDataSource = (CustomTomcatDataSource) this.dataSource;
		assertThat(testDataSource.getUrl()).isEqualTo('jdbc:h2:test');
		assertThat(testDataSource.getJdbcUrl()).isNull();
		assertThat(testDataSource.getUsername()).isEqualTo('test');
		assertThat(testDataSource.getUser()).isNull();
		assertThat(testDataSource.getDriverClassName()).isEqualTo(Driver.class.getName());
		assertThat(testDataSource.getDriverClass()).isNull();
	}
	@Test
	void buildWhenCustomTypeSpecifiedReturnsDataSourceWithPropertiesSetViaReflection() {
		this.dataSource = DataSourceBuilder.create()
			.type(CustomDataSource.class)
			.username('test')
			.password('secret')
			.url('jdbc:h2:test')
			.driverClassName('com.example')
			.build();
		assertThat(this.dataSource).isInstanceOf(CustomDataSource.class);
		CustomDataSource testDataSource = (CustomDataSource) this.dataSource;
		assertThat(testDataSource.getUrl()).isEqualTo('jdbc:h2:test');
		assertThat(testDataSource.getUsername()).isEqualTo('test');
		assertThat(testDataSource.getPassword()).isEqualTo('secret');
		assertThat(testDataSource.getDriverClassName()).isEqualTo('com.example');
	}
	@Test
	void buildWhenCustomTypeSpecifiedAndNoSuitableOptionalSetterBuilds() {
		assertThatNoException().isThrownBy(() -> DataSourceBuilder.create()
			.type(LimitedCustomDataSource.class)
			.driverClassName('com.example')
			.build());
	}
	@Test
	void buildWhenCustomTypeSpecifiedAndNoSuitableMandatorySetterThrowsException() {
		assertThatExceptionOfType(UnsupportedDataSourcePropertyException.class).isThrownBy(
				() -> DataSourceBuilder.create().type(LimitedCustomDataSource.class).url('jdbc:com.example').build());
	}
	@Test
	void buildWhenDerivedWithNewUrlReturnsNewDataSource() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setJdbcUrl('jdbc:h2:test');
		HikariDataSource built = (HikariDataSource) DataSourceBuilder.derivedFrom(dataSource)
			.url('jdbc:h2:test2')
			.build();
		assertThat(built.getUsername()).isEqualTo('test');
		assertThat(built.getPassword()).isEqualTo('secret');
		assertThat(built.getJdbcUrl()).isEqualTo('jdbc:h2:test2');
	}
	@Test
	void buildWhenDerivedWithNewUsernameAndPasswordReturnsNewDataSource() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setJdbcUrl('jdbc:h2:test');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource);
		HikariDataSource built = (HikariDataSource) builder.username('test2').password('secret2').build();
		assertThat(built.getUsername()).isEqualTo('test2');
		assertThat(built.getPassword()).isEqualTo('secret2');
		assertThat(built.getJdbcUrl()).isEqualTo('jdbc:h2:test');
	}
	@Test
	void buildWhenDerivedFromOracleDataSourceWithPasswordNotSetThrowsException() throws Exception {
		oracle.jdbc.datasource.impl.OracleDataSource dataSource = new oracle.jdbc.datasource.impl.OracleDataSource();
		dataSource.setUser('test');
		dataSource.setPassword('secret');
		dataSource.setURL('example.com');
		assertThatExceptionOfType(UnsupportedDataSourcePropertyException.class)
			.isThrownBy(() -> DataSourceBuilder.derivedFrom(dataSource).url('example.org').build());
	}
	@Test
	void buildWhenDerivedFromOracleUcpWithPasswordNotSetThrowsException() throws Exception {
		PoolDataSource dataSource = new PoolDataSourceImpl();
		dataSource.setUser('test');
		dataSource.setPassword('secret');
		dataSource.setURL('example.com');
		assertThatExceptionOfType(UnsupportedDataSourcePropertyException.class)
			.isThrownBy(() -> DataSourceBuilder.derivedFrom(dataSource).url('example.org').build());
	}
	@Test
	void buildWhenDerivedFromOracleDataSourceWithPasswordSetReturnsDataSource() throws Exception {
		oracle.jdbc.datasource.impl.OracleDataSource dataSource = new oracle.jdbc.datasource.impl.OracleDataSource();
		dataSource.setUser('test');
		dataSource.setPassword('secret');
		dataSource.setURL('example.com');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource);
		oracle.jdbc.datasource.impl.OracleDataSource built = (oracle.jdbc.datasource.impl.OracleDataSource) builder
			.username('test2')
			.password('secret2')
			.build();
		assertThat(built.getUser()).isEqualTo('test2');
		assertThat(built).extracting('password')
			.extracting((opaque) -> ((OpaqueString) opaque).get())
			.isEqualTo('secret2');
		assertThat(built.getURL()).isEqualTo('example.com');
	}
	@Test
	void buildWhenDerivedFromOracleUcpWithPasswordSetReturnsDataSource() throws SQLException {
		PoolDataSource dataSource = new PoolDataSourceImpl();
		dataSource.setUser('test');
		dataSource.setPassword('secret');
		dataSource.setURL('example.com');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource);
		PoolDataSource built = (PoolDataSource) builder.username('test2').password('secret2').build();
		assertThat(built.getUser()).isEqualTo('test2');
		assertThat(built).extracting('password')
			.extracting((opaque) -> ((oracle.ucp.util.OpaqueString) opaque).get())
			.isEqualTo('secret2');
		assertThat(built.getURL()).isEqualTo('example.com');
	}
	@Test
	void buildWhenDerivedFromEmbeddedDatabase() {
		EmbeddedDatabase database = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.HSQL).build();
		SimpleDriverDataSource built = (SimpleDriverDataSource) DataSourceBuilder.derivedFrom(database)
			.username('test')
			.password('secret')
			.build();
		assertThat(built.getUsername()).isEqualTo('test');
		assertThat(built.getPassword()).isEqualTo('secret');
		assertThat(built.getUrl()).startsWith('jdbc:hsqldb:mem');
	}
	@Test
	void buildWhenDerivedFromWrappedDataSource() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setJdbcUrl('jdbc:h2:test');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(wrap(wrap(dataSource)));
		HikariDataSource built = (HikariDataSource) builder.username('test2').password('secret2').build();
		assertThat(built.getUsername()).isEqualTo('test2');
		assertThat(built.getPassword()).isEqualTo('secret2');
		assertThat(built.getJdbcUrl()).isEqualTo('jdbc:h2:test');
	}
	@Test // gh-26644
	void buildWhenDerivedFromExistingDatabaseWithTypeChange() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setJdbcUrl('jdbc:postgresql://localhost:5432/postgres');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource).type(SimpleDriverDataSource.class);
		SimpleDriverDataSource built = (SimpleDriverDataSource) builder.username('test2').password('secret2').build();
		assertThat(built.getUsername()).isEqualTo('test2');
		assertThat(built.getPassword()).isEqualTo('secret2');
		assertThat(built.getUrl()).isEqualTo('jdbc:postgresql://localhost:5432/postgres');
	}
	@Test // gh-27295
	void buildWhenDerivedFromCustomType() {
		CustomDataSource dataSource = new CustomDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setUrl('jdbc:postgresql://localhost:5432/postgres');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource)
			.username('alice')
			.password('confidential');
		CustomDataSource testSource = (CustomDataSource) builder.build();
		assertThat(testSource).isNotSameAs(dataSource);
		assertThat(testSource.getUsername()).isEqualTo('alice');
		assertThat(testSource.getUrl()).isEqualTo('jdbc:postgresql://localhost:5432/postgres');
		assertThat(testSource.getPassword()).isEqualTo('confidential');
	}
	@Test // gh-27295
	void buildWhenDerivedFromCustomTypeWithTypeChange() {
		CustomDataSource dataSource = new CustomDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setUrl('jdbc:postgresql://localhost:5432/postgres');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource).type(SimpleDriverDataSource.class);
		SimpleDriverDataSource testSource = (SimpleDriverDataSource) builder.build();
		assertThat(testSource.getUsername()).isEqualTo('test');
		assertThat(testSource.getUrl()).isEqualTo('jdbc:postgresql://localhost:5432/postgres');
		assertThat(testSource.getPassword()).isEqualTo('secret');
	}
	@Test
	void buildWhenDerivedFromCustomTypeDeriveDriverClassNameFromUrl() {
		NoDriverClassNameDataSource dataSource = new NoDriverClassNameDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setUrl('jdbc:postgresql://localhost:5432/postgres');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource).type(SimpleDriverDataSource.class);
		SimpleDriverDataSource testSource = (SimpleDriverDataSource) builder.build();
		assertThat(testSource.getUsername()).isEqualTo('test');
		assertThat(testSource.getUrl()).isEqualTo('jdbc:postgresql://localhost:5432/postgres');
		assertThat(testSource.getPassword()).isEqualTo('secret');
		assertThat(testSource.getDriver()).isInstanceOf(org.postgresql.Driver.class);
	}
	@Test
	void buildWhenDerivedFromCustomTypeDeriveDriverClassNameFromOverridenUrl() {
		NoDriverClassNameDataSource dataSource = new NoDriverClassNameDataSource();
		dataSource.setUsername('test');
		dataSource.setPassword('secret');
		dataSource.setUrl('jdbc:mysql://localhost:5432/mysql');
		DataSourceBuilder<?> builder = DataSourceBuilder.derivedFrom(dataSource)
			.type(SimpleDriverDataSource.class)
			.url('jdbc:mariadb://localhost:5432/mariadb');
		SimpleDriverDataSource testSource = (SimpleDriverDataSource) builder.build();
		assertThat(testSource.getUsername()).isEqualTo('test');
		assertThat(testSource.getUrl()).isEqualTo('jdbc:mariadb://localhost:5432/mariadb');
		assertThat(testSource.getPassword()).isEqualTo('secret');
		assertThat(testSource.getDriver()).isInstanceOf(org.mariadb.jdbc.Driver.class);
	}
	@Test // gh-31920
	void buildWhenC3P0TypeSpecifiedReturnsExpectedDataSource() {
		this.dataSource = DataSourceBuilder.create()
			.url('jdbc:postgresql://localhost:5432/postgres')
			.type(ComboPooledDataSource.class)
			.username('test')
			.password('secret')
			.driverClassName('com.example.Driver')
			.build();
		assertThat(this.dataSource).isInstanceOf(ComboPooledDataSource.class);
		ComboPooledDataSource c3p0DataSource = (ComboPooledDataSource) this.dataSource;
		assertThat(c3p0DataSource.getJdbcUrl()).isEqualTo('jdbc:postgresql://localhost:5432/postgres');
		assertThat(c3p0DataSource.getUser()).isEqualTo('test');
		assertThat(c3p0DataSource.getPassword()).isEqualTo('secret');
		assertThat(c3p0DataSource.getDriverClass()).isEqualTo('com.example.Driver');
	}
	private DataSource wrap(DataSource target) {
		return new DataSourceWrapper(target);
	}
	private static final class DataSourceWrapper implements DataSource {
		private final DataSource delegate;
		private DataSourceWrapper(DataSource delegate) {
			this.delegate = delegate;
		}
		@Override
		public Logger getParentLogger() throws SQLFeatureNotSupportedException {
			return this.delegate.getParentLogger();
		}
		@Override
		public <T> T unwrap(Class<T> iface) throws SQLException {
			return this.delegate.unwrap(iface);
		}
		@Override
		public boolean isWrapperFor(Class<?> iface) throws SQLException {
			return this.delegate.isWrapperFor(iface);
		}
		@Override
		public Connection getConnection() throws SQLException {
			return this.delegate.getConnection();
		}
		@Override
		public Connection getConnection(String username, String password) throws SQLException {
			return this.delegate.getConnection(username, password);
		}
		@Override
		public PrintWriter getLogWriter() throws SQLException {
			return this.delegate.getLogWriter();
		}
		@Override
		public void setLogWriter(PrintWriter out) throws SQLException {
			this.delegate.setLogWriter(out);
		}
		@Override
		public void setLoginTimeout(int seconds) throws SQLException {
			this.delegate.setLoginTimeout(seconds);
		}
		@Override
		public int getLoginTimeout() throws SQLException {
			return this.delegate.getLoginTimeout();
		}
	}
	final class HidePackagesClassLoader extends URLClassLoader {
		private final String[] hiddenPackages;
		HidePackagesClassLoader(String... hiddenPackages) {
			super(new URL[0], HidePackagesClassLoader.class.getClassLoader());
			this.hiddenPackages = hiddenPackages;
		}
		@Override
		protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
			if (Arrays.stream(this.hiddenPackages).anyMatch(name::startsWith)) {
				throw new ClassNotFoundException();
			}
			return super.loadClass(name, resolve);
		}
	}
	static class CustomTomcatDataSource extends org.apache.tomcat.jdbc.pool.DataSource {
		private String jdbcUrl;
		private String user;
		private String driverClass;
		String getJdbcUrl() {
			return this.jdbcUrl;
		}
		void setJdbcUrl(String jdbcUrl) {
			this.jdbcUrl = jdbcUrl;
		}
		String getUser() {
			return this.user;
		}
		void setUser(String user) {
			this.user = user;
		}
		String getDriverClass() {
			return this.driverClass;
		}
		void setDriverClass(String driverClass) {
			this.driverClass = driverClass;
		}
	}
	static class LimitedCustomDataSource extends AbstractDataSource {
		private String username;
		private String password;
		@Override
		public Connection getConnection() throws SQLException {
			throw new UnsupportedOperationException();
		}
		@Override
		public Connection getConnection(String username, String password) throws SQLException {
			throw new UnsupportedOperationException();
		}
		String getUsername() {
			return this.username;
		}
		void setUsername(String username) {
			this.username = username;
		}
		String getPassword() {
			return this.password;
		}
		void setPassword(String password) {
			this.password = password;
		}
	}
	static class NoDriverClassNameDataSource extends LimitedCustomDataSource {
		private String url;
		String getUrl() {
			return this.url;
		}
		void setUrl(String url) {
			this.url = url;
		}
	}
	static class CustomDataSource extends LimitedCustomDataSource {
		private String driverClassName;
		private String url;
		String getDriverClassName() {
			return this.driverClassName;
		}
		void setDriverClassName(String driverClassName) {
			this.driverClassName = driverClassName;
		}
		String getUrl() {
			return this.url;
		}
		void setUrl(String url) {
			this.url = url;
		}
	}
}
/*
package org.springframework.boot.jdbc;
/**
class HikariCheckpointRestoreLifecycleTests {
	private final HikariCheckpointRestoreLifecycle lifecycle;
	private final HikariDataSource dataSource;
	HikariCheckpointRestoreLifecycleTests() {
		HikariConfig config = new HikariConfig();
		config.setAllowPoolSuspension(true);
		config.setJdbcUrl('jdbc:hsqldb:mem:test-' + UUID.randomUUID());
		config.setPoolName('lifecycle-tests');
		this.dataSource = new HikariDataSource(config);
		this.lifecycle = new HikariCheckpointRestoreLifecycle(this.dataSource);
	}
	@Test
	void startedWhenStartedShouldSucceed() {
		assertThat(this.lifecycle.isRunning()).isTrue();
		this.lifecycle.start();
		assertThat(this.lifecycle.isRunning()).isTrue();
	}
	@Test
	void stopWhenStoppedShouldSucceed() {
		assertThat(this.lifecycle.isRunning()).isTrue();
		this.lifecycle.stop();
		assertThat(this.dataSource.isRunning()).isFalse();
		assertThatNoException().isThrownBy(this.lifecycle::stop);
	}
	@Test
	void whenStoppedAndStartedDataSourceShouldPauseAndResume() {
		assertThat(this.lifecycle.isRunning()).isTrue();
		this.lifecycle.stop();
		assertThat(this.dataSource.isRunning()).isFalse();
		assertThat(this.dataSource.isClosed()).isFalse();
		assertThat(this.lifecycle.isRunning()).isFalse();
		assertThat(this.dataSource.getHikariPoolMXBean().getTotalConnections()).isZero();
		this.lifecycle.start();
		assertThat(this.dataSource.isRunning()).isTrue();
		assertThat(this.dataSource.isClosed()).isFalse();
		assertThat(this.lifecycle.isRunning()).isTrue();
	}
	@Test
	void whenDataSourceIsClosedThenStartShouldThrow() {
		this.dataSource.close();
		assertThatExceptionOfType(RuntimeException.class).isThrownBy(this.lifecycle::start);
	}
	@Test
	void startHasNoEffectWhenDataSourceIsNotAHikariDataSource() {
		HikariCheckpointRestoreLifecycle nonHikariLifecycle = new HikariCheckpointRestoreLifecycle(
				mock(DataSource.class));
		assertThat(nonHikariLifecycle.isRunning()).isFalse();
		nonHikariLifecycle.start();
		assertThat(nonHikariLifecycle.isRunning()).isFalse();
	}
	@Test
	void stopHasNoEffectWhenDataSourceIsNotAHikariDataSource() {
		HikariCheckpointRestoreLifecycle nonHikariLifecycle = new HikariCheckpointRestoreLifecycle(
				mock(DataSource.class));
		assertThat(nonHikariLifecycle.isRunning()).isFalse();
		nonHikariLifecycle.stop();
		assertThat(nonHikariLifecycle.isRunning()).isFalse();
	}
}
/*
package org.springframework.boot.jdbc;
/**
class DataSourceBuilderRuntimeHintsTests {
	@Test
	void shouldRegisterDataSourceConstructors() {
		ReflectionHints hints = registerHints();
		Stream
			.of(com.mchange.v2.c3p0.ComboPooledDataSource.class, org.h2.jdbcx.JdbcDataSource.class,
					com.zaxxer.hikari.HikariDataSource.class, org.apache.commons.dbcp2.BasicDataSource.class,
					oracle.jdbc.datasource.OracleDataSource.class, oracle.ucp.jdbc.PoolDataSource.class,
					org.postgresql.ds.PGSimpleDataSource.class,
					org.springframework.jdbc.datasource.SimpleDriverDataSource.class,
					org.apache.tomcat.jdbc.pool.DataSource.class)
			.forEach((dataSourceType) -> {
				TypeHint typeHint = hints.getTypeHint(dataSourceType);
				assertThat(typeHint).withFailMessage(() -> 'No hints found for data source type ' + dataSourceType)
					.isNotNull();
				Set<MemberCategory> memberCategories = typeHint.getMemberCategories();
				assertThat(memberCategories).containsExactly(MemberCategory.INVOKE_PUBLIC_CONSTRUCTORS);
			});
	}
	private ReflectionHints registerHints() {
		RuntimeHints hints = new RuntimeHints();
		new DataSourceBuilderRuntimeHints().registerHints(hints, getClass().getClassLoader());
		return hints.reflection();
	}
}
/*
package org.springframework.boot.jdbc;
/**
class DataSourceUnwrapperTests {
	@Test
	void unwrapWithTarget() {
		DataSource dataSource = new HikariDataSource();
		assertThat(DataSourceUnwrapper.unwrap(dataSource, HikariConfigMXBean.class, HikariDataSource.class))
			.isSameAs(dataSource);
	}
	@Test
	void unwrapWithWrongTarget() {
		DataSource dataSource = new HikariDataSource();
		assertThat(DataSourceUnwrapper.unwrap(dataSource, SmartDataSource.class, SingleConnectionDataSource.class))
			.isNull();
	}
	@Test
	void unwrapWithDelegate() {
		DataSource dataSource = new HikariDataSource();
		DataSource actual = wrapInDelegate(wrapInDelegate(dataSource));
		assertThat(DataSourceUnwrapper.unwrap(actual, HikariConfigMXBean.class, HikariDataSource.class))
			.isSameAs(dataSource);
	}
	@Test
	void unwrapWithProxy() {
		DataSource dataSource = new HikariDataSource();
		DataSource actual = wrapInProxy(wrapInProxy(dataSource));
		assertThat(DataSourceUnwrapper.unwrap(actual, HikariConfigMXBean.class, HikariDataSource.class))
			.isSameAs(dataSource);
	}
	@Test
	void unwrapWithProxyAndDelegate() {
		DataSource dataSource = new HikariDataSource();
		DataSource actual = wrapInProxy(wrapInDelegate(dataSource));
		assertThat(DataSourceUnwrapper.unwrap(actual, HikariConfigMXBean.class, HikariDataSource.class))
			.isSameAs(dataSource);
	}
	@Test
	void unwrapWithSeveralLevelOfWrapping() {
		DataSource dataSource = new HikariDataSource();
		DataSource actual = wrapInProxy(wrapInDelegate(wrapInDelegate(wrapInProxy(wrapInDelegate(dataSource)))));
		assertThat(DataSourceUnwrapper.unwrap(actual, HikariConfigMXBean.class, HikariDataSource.class))
			.isSameAs(dataSource);
	}
	@Test
	void unwrapDataSourceProxy() {
		org.apache.tomcat.jdbc.pool.DataSource dataSource = new org.apache.tomcat.jdbc.pool.DataSource();
		DataSource actual = wrapInDelegate(wrapInProxy(dataSource));
		assertThat(DataSourceUnwrapper.unwrap(actual, PoolConfiguration.class, DataSourceProxy.class))
			.isSameAs(dataSource);
	}
	@Test
	void unwrappingIsNotAttemptedWhenTargetIsNotAnInterface() {
		DataSource dataSource = mock(DataSource.class);
		assertThat(DataSourceUnwrapper.unwrap(dataSource, HikariDataSource.class)).isNull();
		then(dataSource).shouldHaveNoMoreInteractions();
	}
	@Test
	void unwrappingIsNotAttemptedWhenDataSourceIsNotWrapperForTarget() throws SQLException {
		DataSource dataSource = mock(DataSource.class);
		assertThat(DataSourceUnwrapper.unwrap(dataSource, Consumer.class)).isNull();
		then(dataSource).should().isWrapperFor(Consumer.class);
		then(dataSource).shouldHaveNoMoreInteractions();
	}
	private DataSource wrapInProxy(DataSource dataSource) {
		return (DataSource) new ProxyFactory(dataSource).getProxy();
	}
	private DataSource wrapInDelegate(DataSource dataSource) {
		return new DelegatingDataSource(dataSource);
	}
}
/*
package org.springframework.boot.jdbc;
/**
@ClassPathExclusions('spring-jdbc-*.jar')
class DataSourceUnwrapperNoSpringJdbcTests {
	@Test
	void unwrapWithProxy() {
		DataSource dataSource = new HikariDataSource();
		DataSource actual = wrapInProxy(wrapInProxy(dataSource));
		assertThat(DataSourceUnwrapper.unwrap(actual, HikariConfigMXBean.class, HikariDataSource.class))
			.isSameAs(dataSource);
	}
	@Test
	void unwrapDataSourceProxy() {
		org.apache.tomcat.jdbc.pool.DataSource dataSource = new org.apache.tomcat.jdbc.pool.DataSource();
		DataSource actual = wrapInProxy(wrapInProxy(dataSource));
		assertThat(DataSourceUnwrapper.unwrap(actual, PoolConfiguration.class, DataSourceProxy.class))
			.isSameAs(dataSource);
	}
	private DataSource wrapInProxy(DataSource dataSource) {
		return (DataSource) new ProxyFactory(dataSource).getProxy();
	}
}
/*
package org.springframework.boot.jdbc;
/**
class DatabaseDriverClassNameTests {
	private static final Set<DatabaseDriver> EXCLUDED_DRIVERS = Collections
		.unmodifiableSet(EnumSet.of(DatabaseDriver.UNKNOWN, DatabaseDriver.DB2_AS400, DatabaseDriver.INFORMIX,
				DatabaseDriver.HANA, DatabaseDriver.PHOENIX, DatabaseDriver.TERADATA, DatabaseDriver.REDSHIFT));
	@ParameterizedTest(name = '{0} {2}')
	@MethodSource
	void databaseClassIsOfRequiredType(DatabaseDriver driver, String className, Class<?> requiredType)
			throws Exception {
		assertThat(getInterfaceNames(className.replace(".", "/"))).contains(requiredType.getName().replace(".", "/"));
	}
	private List<String> getInterfaceNames(String className) throws IOException {
		// Use ASM to avoid unwanted side effects of loading JDBC drivers
		ClassReader classReader = new ClassReader(getClass().getResourceAsStream('/' + className + '.class'));
		List<String> interfaceNames = new ArrayList<>();
		for (String name : classReader.getInterfaces()) {
			interfaceNames.add(name);
			interfaceNames.addAll(getInterfaceNames(name));
		}
		String superName = classReader.getSuperName();
		if (superName != null) {
			interfaceNames.addAll(getInterfaceNames(superName));
		}
		return interfaceNames;
	}
	static Stream<? extends Arguments> databaseClassIsOfRequiredType() {
		return Stream.concat(argumentsForType(Driver.class, DatabaseDriver::getDriverClassName),
				argumentsForType(XADataSource.class,
						(databaseDriver) -> databaseDriver.getXaDataSourceClassName() != null,
						DatabaseDriver::getXaDataSourceClassName));
	}
	private static Stream<? extends Arguments> argumentsForType(Class<?> type,
			Function<DatabaseDriver, String> classNameExtractor) {
		return argumentsForType(type, (databaseDriver) -> true, classNameExtractor);
	}
	private static Stream<? extends Arguments> argumentsForType(Class<?> type, Predicate<DatabaseDriver> predicate,
			Function<DatabaseDriver, String> classNameExtractor) {
		return Stream.of(DatabaseDriver.values())
			.filter((databaseDriver) -> !EXCLUDED_DRIVERS.contains(databaseDriver))
			.filter(predicate)
			.map((databaseDriver) -> Arguments.of(databaseDriver, classNameExtractor.apply(databaseDriver), type));
	}
}
/*
package org.springframework.boot.jdbc.init;
/**
class DataSourceScriptDatabaseInitializerTests
		extends AbstractScriptDatabaseInitializerTests<DataSourceScriptDatabaseInitializer> {
	private final HikariDataSource embeddedDataSource = DataSourceBuilder.create()
		.type(HikariDataSource.class)
		.url('jdbc:h2:mem:' + UUID.randomUUID())
		.build();
	private final HikariDataSource standaloneDataSource = DataSourceBuilder.create()
		.type(HikariDataSource.class)
		.url('jdbc:h2:file:'
				+ new BuildOutput(DataSourceScriptDatabaseInitializerTests.class).getRootLocation().getAbsolutePath()
				+ '/' + UUID.randomUUID())
		.build();
	@AfterEach
	void closeDataSource() {
		this.embeddedDataSource.close();
		this.standaloneDataSource.close();
	}
	@Test
	void whenDatabaseIsInaccessibleThenItIsAssumedNotToBeEmbedded() {
		DataSourceScriptDatabaseInitializer initializer = new DataSourceScriptDatabaseInitializer(
				new HikariDataSource(), new DatabaseInitializationSettings());
		assertThat(initializer.isEmbeddedDatabase()).isFalse();
	}
	@Test
	void whenCustomizeIsOverriddenThenDatabasePopulatorIsConfiguredAccordingly() {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setContinueOnError(true);
		settings.setDataLocations(Collections.singletonList('data.sql'));
		DataSourceScriptDatabaseInitializer initializer = new DataSourceScriptDatabaseInitializer(
				this.embeddedDataSource, settings) {
			@Override
			protected void customize(ResourceDatabasePopulator populator) {
				assertThat(populator).hasFieldOrPropertyWithValue('continueOnError', true);
				populator.setContinueOnError(false);
			}
		};
		assertThatExceptionOfType(ScriptStatementFailedException.class).isThrownBy(initializer::initializeDatabase);
	}
	@Override
	protected DataSourceScriptDatabaseInitializer createEmbeddedDatabaseInitializer(
			DatabaseInitializationSettings settings) {
		return new DataSourceScriptDatabaseInitializer(this.embeddedDataSource, settings);
	}
	@Override
	protected DataSourceScriptDatabaseInitializer createStandaloneDatabaseInitializer(
			DatabaseInitializationSettings settings) {
		return new DataSourceScriptDatabaseInitializer(this.standaloneDataSource, settings);
	}
	@Override
	protected int numberOfEmbeddedRows(String sql) {
		return numberOfRows(this.embeddedDataSource, sql);
	}
	@Override
	protected int numberOfStandaloneRows(String sql) {
		return numberOfRows(this.standaloneDataSource, sql);
	}
	private int numberOfRows(DataSource dataSource, String sql) {
		return new JdbcTemplate(dataSource).queryForObject(sql, Integer.class);
	}
	@Override
	protected void assertDatabaseAccessed(boolean accessed, DataSourceScriptDatabaseInitializer initializer) {
		assertThat(((HikariDataSource) initializer.getDataSource()).isRunning()).isEqualTo(accessed);
	}
}
/*
package org.springframework.boot.jdbc.init;
/**
class PlatformPlaceholderDatabaseDriverResolverTests {
	@Test
	void resolveAllWithPlatformWhenThereAreNoValuesShouldReturnEmptyList() {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver().resolveAll('test')).isEmpty();
	}
	@Test
	void resolveAllWithPlatformWhenValueDoesNotContainPlaceholderShouldReturnValueUnchanged() {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver().resolveAll('test', 'schema.sql'))
			.containsExactly('schema.sql');
	}
	@Test
	void resolveAllWithPlatformWhenValuesContainPlaceholdersShouldReturnValuesWithPlaceholdersReplaced() {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver().resolveAll('postgresql', 'schema.sql',
				'schema-@@platform@@.sql', 'data-@@platform@@.sql'))
			.containsExactly('schema.sql', 'schema-postgresql.sql', 'data-postgresql.sql');
	}
	@Test
	void resolveAllWithDataSourceWhenThereAreNoValuesShouldReturnEmptyList() {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver().resolveAll(mock(DataSource.class))).isEmpty();
	}
	@Test
	void resolveAllWithDataSourceWhenValueDoesNotContainPlaceholderShouldReturnValueUnchanged() {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver().resolveAll(mock(DataSource.class), 'schema.sql'))
			.containsExactly('schema.sql');
	}
	@Test
	void resolveAllWithDataSourceWhenValueDoesNotContainPlaceholderShouldNotInteractWithDataSource() {
		DataSource dataSource = mock(DataSource.class);
		new PlatformPlaceholderDatabaseDriverResolver().resolveAll(dataSource, 'schema.sql');
		then(dataSource).shouldHaveNoInteractions();
	}
	@Test
	void resolveAllWithFailingDataSourceWhenValuesContainPlaceholdersShouldThrowNestedCause() throws SQLException {
		DataSource dataSource = mock(DataSource.class);
		given(dataSource.getConnection()).willThrow(new IllegalStateException('Test: invalid password'));
		assertThatIllegalStateException()
			.isThrownBy(() -> new PlatformPlaceholderDatabaseDriverResolver().resolveAll(dataSource, 'schema.sql',
					'schema-@@platform@@.sql', 'data-@@platform@@.sql'))
			.withMessage('Failed to determine DatabaseDriver')
			.withStackTraceContaining('Test: invalid password');
	}
	@Test
	void resolveAllWithDataSourceWhenValuesContainPlaceholdersShouldReturnValuesWithPlaceholdersReplaced()
			throws SQLException {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver().resolveAll(dataSourceWithProductName('PostgreSQL'),
				'schema.sql', 'schema-@@platform@@.sql', 'data-@@platform@@.sql'))
			.containsExactly('schema.sql', 'schema-postgresql.sql', 'data-postgresql.sql');
	}
	@Test
	void resolveAllWithDataSourceWhenDriverMappingsAreCustomizedShouldResolvePlaceholderUsingCustomMapping()
			throws SQLException {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver()
			.withDriverPlatform(DatabaseDriver.POSTGRESQL, 'postgres')
			.resolveAll(dataSourceWithProductName('PostgreSQL'), 'schema-@@platform@@.sql'))
			.containsExactly('schema-postgres.sql');
	}
	@Test
	void resolveAllWithDataSourceWhenValueIsAnEmptyStringShouldReturnValueUnchanged() {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver().resolveAll(mock(DataSource.class), ''))
			.containsExactly('');
	}
	@Test
	void resolveAllWithDataSourceWhenDriverIsUnknownShouldThrow() {
		assertThatIllegalStateException().isThrownBy(() -> new PlatformPlaceholderDatabaseDriverResolver()
			.resolveAll(dataSourceWithProductName('CustomDB'), 'schema-@@platform@@.sql'));
	}
	@Test
	void resolveAllWithDataSourceWhenPlaceholderIsCustomizedShouldResolvePlaceholders() throws SQLException {
		assertThat(new PlatformPlaceholderDatabaseDriverResolver('##platform##')
			.resolveAll(dataSourceWithProductName('PostgreSQL'), 'schema-##platform##.sql', 'schema-@@platform@@.sql'))
			.containsExactly('schema-postgresql.sql', 'schema-@@platform@@.sql');
	}
	private DataSource dataSourceWithProductName(String productName) throws SQLException {
		DataSource dataSource = mock(DataSource.class);
		Connection connection = mock(Connection.class);
		given(dataSource.getConnection()).willReturn(connection);
		DatabaseMetaData metadata = mock(DatabaseMetaData.class);
		given(connection.getMetaData()).willReturn(metadata);
		given(metadata.getDatabaseProductName()).willReturn(productName);
		return dataSource;
	}
}
/*
package org.springframework.boot.jdbc;
/**
@ClassPathExclusions('Hikari*.jar')
class DataSourceBuilderNoHikariTests {
	@Test
	void findTypeReturnsTomcatDataSource() {
		assertThat(DataSourceBuilder.findType(null)).isEqualTo(org.apache.tomcat.jdbc.pool.DataSource.class);
	}
	@Test
	void createAndBuildReturnsTomcatDataSource() {
		DataSource dataSource = DataSourceBuilder.create().build();
		assertThat(dataSource).isInstanceOf(org.apache.tomcat.jdbc.pool.DataSource.class);
	}
}
/*
package org.springframework.boot.jdbc;
/**
class DatabaseDriverTests {
	@Test
	void classNameForKnownDatabase() {
		String driverClassName = DatabaseDriver.fromJdbcUrl('jdbc:postgresql://hostname/dbname').getDriverClassName();
		assertThat(driverClassName).isEqualTo('org.postgresql.Driver');
	}
	@Test
	void nullClassNameForUnknownDatabase() {
		String driverClassName = DatabaseDriver.fromJdbcUrl('jdbc:unknowndb://hostname/dbname').getDriverClassName();
		assertThat(driverClassName).isNull();
	}
	@Test
	void unknownOnNullJdbcUrl() {
		DatabaseDriver actual = DatabaseDriver.fromJdbcUrl(null);
		assertThat(actual).isEqualTo(DatabaseDriver.UNKNOWN);
	}
	@Test
	void failureOnMalformedJdbcUrl() {
		assertThatIllegalArgumentException().isThrownBy(() -> DatabaseDriver.fromJdbcUrl('malformed:url'))
			.withMessageContaining('URL must start with');
	}
	@Test
	void unknownOnNullProductName() {
		DatabaseDriver actual = DatabaseDriver.fromProductName(null);
		assertThat(actual).isEqualTo(DatabaseDriver.UNKNOWN);
	}
	@Test
	void databaseProductNameLookups() {
		assertThat(DatabaseDriver.fromProductName('newone')).isEqualTo(DatabaseDriver.UNKNOWN);
		assertThat(DatabaseDriver.fromProductName('Apache Derby')).isEqualTo(DatabaseDriver.DERBY);
		assertThat(DatabaseDriver.fromProductName('H2')).isEqualTo(DatabaseDriver.H2);
		assertThat(DatabaseDriver.fromProductName('HDB')).isEqualTo(DatabaseDriver.HANA);
		assertThat(DatabaseDriver.fromProductName('HSQL Database Engine')).isEqualTo(DatabaseDriver.HSQLDB);
		assertThat(DatabaseDriver.fromProductName('SQLite')).isEqualTo(DatabaseDriver.SQLITE);
		assertThat(DatabaseDriver.fromProductName('MySQL')).isEqualTo(DatabaseDriver.MYSQL);
		assertThat(DatabaseDriver.fromProductName('MariaDB')).isEqualTo(DatabaseDriver.MARIADB);
		assertThat(DatabaseDriver.fromProductName('Oracle')).isEqualTo(DatabaseDriver.ORACLE);
		assertThat(DatabaseDriver.fromProductName('PostgreSQL')).isEqualTo(DatabaseDriver.POSTGRESQL);
		assertThat(DatabaseDriver.fromProductName('Redshift')).isEqualTo(DatabaseDriver.REDSHIFT);
		assertThat(DatabaseDriver.fromProductName('Microsoft SQL Server')).isEqualTo(DatabaseDriver.SQLSERVER);
		assertThat(DatabaseDriver.fromProductName('SQL SERVER')).isEqualTo(DatabaseDriver.SQLSERVER);
		assertThat(DatabaseDriver.fromProductName('DB2')).isEqualTo(DatabaseDriver.DB2);
		assertThat(DatabaseDriver.fromProductName('Firebird 2.5.WI')).isEqualTo(DatabaseDriver.FIREBIRD);
		assertThat(DatabaseDriver.fromProductName('Firebird 2.1.LI')).isEqualTo(DatabaseDriver.FIREBIRD);
		assertThat(DatabaseDriver.fromProductName('DB2/LINUXX8664')).isEqualTo(DatabaseDriver.DB2);
		assertThat(DatabaseDriver.fromProductName('DB2 UDB for AS/400')).isEqualTo(DatabaseDriver.DB2_AS400);
		assertThat(DatabaseDriver.fromProductName('DB3 XDB for AS/400')).isEqualTo(DatabaseDriver.DB2_AS400);
		assertThat(DatabaseDriver.fromProductName('Teradata')).isEqualTo(DatabaseDriver.TERADATA);
		assertThat(DatabaseDriver.fromProductName('Informix Dynamic Server')).isEqualTo(DatabaseDriver.INFORMIX);
		assertThat(DatabaseDriver.fromProductName('Apache Phoenix')).isEqualTo(DatabaseDriver.PHOENIX);
		assertThat(DatabaseDriver.fromProductName('ClickHouse')).isEqualTo(DatabaseDriver.CLICKHOUSE);
	}
	@Test
	void databaseJdbcUrlLookups() {
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:newone://localhost')).isEqualTo(DatabaseDriver.UNKNOWN);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:derby:sample')).isEqualTo(DatabaseDriver.DERBY);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:h2:~/sample')).isEqualTo(DatabaseDriver.H2);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:hsqldb:hsql://localhost')).isEqualTo(DatabaseDriver.HSQLDB);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:sqlite:sample.db')).isEqualTo(DatabaseDriver.SQLITE);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:mysql://localhost:3306/sample')).isEqualTo(DatabaseDriver.MYSQL);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:oracle:thin:@localhost:1521:orcl'))
			.isEqualTo(DatabaseDriver.ORACLE);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:postgresql://127.0.0.1:5432/sample'))
			.isEqualTo(DatabaseDriver.POSTGRESQL);
		assertThat(DatabaseDriver
			.fromJdbcUrl('jdbc:redshift://examplecluster.abc123xyz789.us-west-2.redshift.amazonaws.com:5439/sample'))
			.isEqualTo(DatabaseDriver.REDSHIFT);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:jtds:sqlserver://127.0.0.1:1433/sample'))
			.isEqualTo(DatabaseDriver.JTDS);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:sap:localhost')).isEqualTo(DatabaseDriver.HANA);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:sqlserver://127.0.0.1:1433')).isEqualTo(DatabaseDriver.SQLSERVER);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:firebirdsql://localhost/sample'))
			.isEqualTo(DatabaseDriver.FIREBIRD);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:firebird://localhost/sample')).isEqualTo(DatabaseDriver.FIREBIRD);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:db2://localhost:50000/sample ')).isEqualTo(DatabaseDriver.DB2);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:as400://localhost')).isEqualTo(DatabaseDriver.DB2_AS400);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:teradata://localhost/SAMPLE')).isEqualTo(DatabaseDriver.TERADATA);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:informix-sqli://localhost:1533/sample'))
			.isEqualTo(DatabaseDriver.INFORMIX);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:informix-direct://sample')).isEqualTo(DatabaseDriver.INFORMIX);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:phoenix:localhost')).isEqualTo(DatabaseDriver.PHOENIX);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:tc:mysql://localhost:3306/sample'))
			.isEqualTo(DatabaseDriver.TESTCONTAINERS);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:clickhouse://localhost:3306/sample'))
			.isEqualTo(DatabaseDriver.CLICKHOUSE);
		assertThat(DatabaseDriver.fromJdbcUrl('jdbc:ch://localhost:3306/sample')).isEqualTo(DatabaseDriver.CLICKHOUSE);
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public class TomcatDataSourcePoolMetadataTests
		extends AbstractDataSourcePoolMetadataTests<TomcatDataSourcePoolMetadata> {
	private final TomcatDataSourcePoolMetadata dataSourceMetadata = new TomcatDataSourcePoolMetadata(
			createDataSource(0, 2));
	@Override
	protected TomcatDataSourcePoolMetadata getDataSourceMetadata() {
		return this.dataSourceMetadata;
	}
	@Override
	public void getValidationQuery() {
		DataSource dataSource = createDataSource(0, 4);
		dataSource.setValidationQuery('SELECT FROM FOO');
		assertThat(new TomcatDataSourcePoolMetadata(dataSource).getValidationQuery()).isEqualTo('SELECT FROM FOO');
	}
	@Override
	public void getDefaultAutoCommit() {
		DataSource dataSource = createDataSource(0, 4);
		dataSource.setDefaultAutoCommit(false);
		assertThat(new TomcatDataSourcePoolMetadata(dataSource).getDefaultAutoCommit()).isFalse();
	}
	private DataSource createDataSource(int minSize, int maxSize) {
		DataSource dataSource = initializeBuilder().type(DataSource.class).build();
		dataSource.setMinIdle(minSize);
		dataSource.setMaxActive(maxSize);
		dataSource.setMinEvictableIdleTimeMillis(5000);
		// Avoid warnings
		dataSource.setInitialSize(minSize);
		dataSource.setMaxIdle(maxSize);
		return dataSource;
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
abstract class AbstractDataSourcePoolMetadataTests<D extends AbstractDataSourcePoolMetadata<?>> {
	/**
	 * Return a data source metadata instance with a min size of 0 and max size of 2. Idle
	 * connections are not reclaimed immediately.
	 * @return the data source metadata
	 */
	protected abstract D getDataSourceMetadata();
	@Test
	void getMaxPoolSize() {
		assertThat(getDataSourceMetadata().getMax()).isEqualTo(2);
	}
	@Test
	void getMinPoolSize() {
		assertThat(getDataSourceMetadata().getMin()).isZero();
	}
	@Test
	void getPoolSizeNoConnection() {
		// Make sure the pool is initialized
		JdbcTemplate jdbcTemplate = new JdbcTemplate(getDataSourceMetadata().getDataSource());
		jdbcTemplate.execute((ConnectionCallback<Void>) (connection) -> null);
		assertThat(getDataSourceMetadata().getActive()).isZero();
		assertThat(getDataSourceMetadata().getUsage()).isZero();
	}
	@Test
	void getPoolSizeOneConnection() {
		JdbcTemplate jdbcTemplate = new JdbcTemplate(getDataSourceMetadata().getDataSource());
		jdbcTemplate.execute((ConnectionCallback<Void>) (connection) -> {
			assertThat(getDataSourceMetadata().getActive()).isOne();
			assertThat(getDataSourceMetadata().getUsage()).isEqualTo(0.5f);
			return null;
		});
	}
	@Test
	void getIdle() {
		JdbcTemplate jdbcTemplate = new JdbcTemplate(getDataSourceMetadata().getDataSource());
		jdbcTemplate.execute((ConnectionCallback<Void>) (connection) -> null);
		assertThat(getDataSourceMetadata().getIdle()).isOne();
	}
	@Test
	void getPoolSizeTwoConnections() {
		final JdbcTemplate jdbcTemplate = new JdbcTemplate(getDataSourceMetadata().getDataSource());
		jdbcTemplate.execute((ConnectionCallback<Void>) (connection) -> {
			jdbcTemplate.execute((ConnectionCallback<Void>) (connection1) -> {
				assertThat(getDataSourceMetadata().getActive()).isEqualTo(2);
				assertThat(getDataSourceMetadata().getUsage()).isOne();
				return null;
			});
			return null;
		});
	}
	@Test
	abstract void getValidationQuery() throws Exception;
	@Test
	abstract void getDefaultAutoCommit() throws Exception;
	protected DataSourceBuilder<?> initializeBuilder() {
		return DataSourceBuilder.create()
			.driverClassName('org.hsqldb.jdbc.JDBCDriver')
			.url('jdbc:hsqldb:mem:test')
			.username('sa');
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
class OracleUcpDataSourcePoolMetadataTests
		extends AbstractDataSourcePoolMetadataTests<OracleUcpDataSourcePoolMetadata> {
	private final OracleUcpDataSourcePoolMetadata dataSourceMetadata = new OracleUcpDataSourcePoolMetadata(
			createDataSource(0, 2));
	@Override
	protected OracleUcpDataSourcePoolMetadata getDataSourceMetadata() {
		return this.dataSourceMetadata;
	}
	@Override
	void getValidationQuery() throws SQLException {
		PoolDataSource dataSource = createDataSource(0, 4);
		dataSource.setSQLForValidateConnection('SELECT NULL FROM DUAL');
		assertThat(new OracleUcpDataSourcePoolMetadata(dataSource).getValidationQuery())
			.isEqualTo('SELECT NULL FROM DUAL');
	}
	@Override
	void getDefaultAutoCommit() throws SQLException {
		PoolDataSource dataSource = createDataSource(0, 4);
		dataSource.setConnectionProperty('autoCommit', 'false');
		assertThat(new OracleUcpDataSourcePoolMetadata(dataSource).getDefaultAutoCommit()).isFalse();
	}
	private PoolDataSource createDataSource(int minSize, int maxSize) {
		try {
			PoolDataSource dataSource = initializeBuilder().type(PoolDataSourceImpl.class).build();
			dataSource.setInitialPoolSize(minSize);
			dataSource.setMinPoolSize(minSize);
			dataSource.setMaxPoolSize(maxSize);
			return dataSource;
		}
		catch (SQLException ex) {
			throw new IllegalStateException('Error while configuring PoolDataSource', ex);
		}
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
class CommonsDbcp2DataSourcePoolMetadataTests
		extends AbstractDataSourcePoolMetadataTests<CommonsDbcp2DataSourcePoolMetadata> {
	private final CommonsDbcp2DataSourcePoolMetadata dataSourceMetadata = createDataSourceMetadata(0, 2);
	@Override
	protected CommonsDbcp2DataSourcePoolMetadata getDataSourceMetadata() {
		return this.dataSourceMetadata;
	}
	@Test
	void getPoolUsageWithNoCurrent() {
		CommonsDbcp2DataSourcePoolMetadata dsm = new CommonsDbcp2DataSourcePoolMetadata(createDataSource()) {
			@Override
			public Integer getActive() {
				return null;
			}
		};
		assertThat(dsm.getUsage()).isNull();
	}
	@Test
	void getPoolUsageWithNoMax() {
		CommonsDbcp2DataSourcePoolMetadata dsm = new CommonsDbcp2DataSourcePoolMetadata(createDataSource()) {
			@Override
			public Integer getMax() {
				return null;
			}
		};
		assertThat(dsm.getUsage()).isNull();
	}
	@Test
	void getPoolUsageWithUnlimitedPool() {
		DataSourcePoolMetadata unlimitedDataSource = createDataSourceMetadata(0, -1);
		assertThat(unlimitedDataSource.getUsage()).isEqualTo(-1f);
	}
	@Override
	public void getValidationQuery() {
		BasicDataSource dataSource = createDataSource();
		dataSource.setValidationQuery('SELECT FROM FOO');
		assertThat(new CommonsDbcp2DataSourcePoolMetadata(dataSource).getValidationQuery())
			.isEqualTo('SELECT FROM FOO');
	}
	@Override
	public void getDefaultAutoCommit() {
		BasicDataSource dataSource = createDataSource();
		dataSource.setDefaultAutoCommit(false);
		assertThat(new CommonsDbcp2DataSourcePoolMetadata(dataSource).getDefaultAutoCommit()).isFalse();
	}
	private CommonsDbcp2DataSourcePoolMetadata createDataSourceMetadata(int minSize, int maxSize) {
		BasicDataSource dataSource = createDataSource();
		dataSource.setMinIdle(minSize);
		dataSource.setMaxTotal(maxSize);
		dataSource.setMinEvictableIdle(Duration.ofSeconds(5));
		return new CommonsDbcp2DataSourcePoolMetadata(dataSource);
	}
	private BasicDataSource createDataSource() {
		return initializeBuilder().type(BasicDataSource.class).build();
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
@ExtendWith(MockitoExtension.class)
class CompositeDataSourcePoolMetadataProviderTests {
	@Mock
	private DataSourcePoolMetadataProvider firstProvider;
	@Mock
	private DataSourcePoolMetadata first;
	@Mock
	private DataSource firstDataSource;
	@Mock
	private DataSourcePoolMetadataProvider secondProvider;
	@Mock
	private DataSourcePoolMetadata second;
	@Mock
	private DataSource secondDataSource;
	@Mock
	private DataSource unknownDataSource;
	@BeforeEach
	void setup() {
		given(this.firstProvider.getDataSourcePoolMetadata(this.firstDataSource)).willReturn(this.first);
		given(this.firstProvider.getDataSourcePoolMetadata(this.secondDataSource)).willReturn(this.second);
	}
	@Test
	void createWithProviders() {
		CompositeDataSourcePoolMetadataProvider provider = new CompositeDataSourcePoolMetadataProvider(
				Arrays.asList(this.firstProvider, this.secondProvider));
		assertThat(provider.getDataSourcePoolMetadata(this.firstDataSource)).isSameAs(this.first);
		assertThat(provider.getDataSourcePoolMetadata(this.secondDataSource)).isSameAs(this.second);
		assertThat(provider.getDataSourcePoolMetadata(this.unknownDataSource)).isNull();
	}
}
/*
package org.springframework.boot.jdbc.metadata;
/**
public class HikariDataSourcePoolMetadataTests
		extends AbstractDataSourcePoolMetadataTests<HikariDataSourcePoolMetadata> {
	private final HikariDataSourcePoolMetadata dataSourceMetadata = new HikariDataSourcePoolMetadata(
			createDataSource(0, 2));
	@Override
	protected HikariDataSourcePoolMetadata getDataSourceMetadata() {
		return this.dataSourceMetadata;
	}
	@Override
	public void getValidationQuery() {
		HikariDataSource dataSource = createDataSource(0, 4);
		dataSource.setConnectionTestQuery('SELECT FROM FOO');
		assertThat(new HikariDataSourcePoolMetadata(dataSource).getValidationQuery()).isEqualTo('SELECT FROM FOO');
	}
	@Override
	public void getDefaultAutoCommit() {
		HikariDataSource dataSource = createDataSource(0, 4);
		dataSource.setAutoCommit(false);
		assertThat(new HikariDataSourcePoolMetadata(dataSource).getDefaultAutoCommit()).isFalse();
	}
	private HikariDataSource createDataSource(int minSize, int maxSize) {
		HikariDataSource dataSource = initializeBuilder().type(HikariDataSource.class).build();
		dataSource.setMinimumIdle(minSize);
		dataSource.setMaximumPoolSize(maxSize);
		dataSource.setIdleTimeout(5000);
		return dataSource;
	}
}
/*
package org.springframework.boot.jms;
/**
class ConnectionFactoryUnwrapperTests {
	@Test
	void unwrapWithSingleConnectionFactory() {
		ConnectionFactory connectionFactory = new SingleConnectionFactory();
		assertThat(ConnectionFactoryUnwrapper.unwrap(connectionFactory)).isSameAs(connectionFactory);
	}
	@Test
	void unwrapWithConnectionFactory() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		assertThat(ConnectionFactoryUnwrapper.unwrap(connectionFactory)).isSameAs(connectionFactory);
	}
	@Test
	void unwrapWithCachingConnectionFactory() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		assertThat(ConnectionFactoryUnwrapper.unwrap(new CachingConnectionFactory(connectionFactory)))
			.isSameAs(connectionFactory);
	}
	@Test
	void unwrapWithNestedCachingConnectionFactories() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		CachingConnectionFactory firstCachingConnectionFactory = new CachingConnectionFactory(connectionFactory);
		CachingConnectionFactory secondCachingConnectionFactory = new CachingConnectionFactory(
				firstCachingConnectionFactory);
		assertThat(ConnectionFactoryUnwrapper.unwrap(secondCachingConnectionFactory)).isSameAs(connectionFactory);
	}
	@Test
	void unwrapWithJmsPoolConnectionFactory() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		JmsPoolConnectionFactory poolConnectionFactory = new JmsPoolConnectionFactory();
		poolConnectionFactory.setConnectionFactory(connectionFactory);
		assertThat(ConnectionFactoryUnwrapper.unwrap(poolConnectionFactory)).isSameAs(connectionFactory);
	}
	@Test
	void unwrapWithNestedJmsPoolConnectionFactories() {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		JmsPoolConnectionFactory firstPooledConnectionFactory = new JmsPoolConnectionFactory();
		firstPooledConnectionFactory.setConnectionFactory(connectionFactory);
		JmsPoolConnectionFactory secondPooledConnectionFactory = new JmsPoolConnectionFactory();
		secondPooledConnectionFactory.setConnectionFactory(firstPooledConnectionFactory);
		assertThat(ConnectionFactoryUnwrapper.unwrap(secondPooledConnectionFactory)).isSameAs(connectionFactory);
	}
	@Test
	@ClassPathExclusions('pooled-jms-*')
	void unwrapWithoutJmsPoolOnClasspath() {
		assertThat(ClassUtils.isPresent('org.messaginghub.pooled.jms.JmsPoolConnectionFactory', null)).isFalse();
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		assertThat(ConnectionFactoryUnwrapper.unwrap(new CachingConnectionFactory(connectionFactory)))
			.isSameAs(connectionFactory);
	}
}
/*
package org.springframework.boot.context;
/**
class FileEncodingApplicationListenerTests {
	private final FileEncodingApplicationListener initializer = new FileEncodingApplicationListener();
	private final ConfigurableEnvironment environment = new StandardEnvironment();
	private final ApplicationEnvironmentPreparedEvent event = new ApplicationEnvironmentPreparedEvent(
			new DefaultBootstrapContext(), new SpringApplication(), new String[0], this.environment);
	@Test
	void testIllegalState() {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'spring.mandatory_file_encoding=FOO');
		ConfigurationPropertySources.attach(this.environment);
		assertThatIllegalStateException().isThrownBy(() -> this.initializer.onApplicationEvent(this.event));
	}
	@Test
	void testSunnyDayNothingMandated() {
		this.initializer.onApplicationEvent(this.event);
	}
	@Test
	void testSunnyDayMandated() {
		assertThat(System.getProperty('file.encoding')).isNotNull();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,
				'spring.mandatory_file_encoding:' + System.getProperty('file.encoding'));
		ConfigurationPropertySources.attach(this.environment);
		this.initializer.onApplicationEvent(this.event);
	}
}
/*
package org.springframework.boot.context.annotation;
/**
class UserConfigurationsTests {
	@Test
	void ofShouldCreateUnorderedConfigurations() {
		UserConfigurations configurations = UserConfigurations.of(OutputStream.class, InputStream.class);
		assertThat(Configurations.getClasses(configurations)).containsExactly(OutputStream.class, InputStream.class);
	}
}
/*
package org.springframework.boot.context.annotation;
/**
class ConfigurationsTests {
	@Test
	void createWhenClassesIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TestConfigurations((Collection<Class<?>>) null))
			.withMessageContaining('Classes must not be null');
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void createShouldSortClassesUsingSortMethod() {
		TestDeprecatedSortedConfigurations configurations = new TestDeprecatedSortedConfigurations(
				Arrays.asList(OutputStream.class, InputStream.class));
		assertThat(configurations.getClasses()).containsExactly(InputStream.class, OutputStream.class);
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void getClassesShouldMergeByClassAndSortUsingSortMethod() {
		Configurations c1 = new TestDeprecatedSortedConfigurations(
				Arrays.asList(OutputStream.class, InputStream.class));
		Configurations c2 = new TestConfigurations(Collections.singletonList(Short.class));
		Configurations c3 = new TestDeprecatedSortedConfigurations(Arrays.asList(String.class, Integer.class));
		Configurations c4 = new TestConfigurations(Arrays.asList(Long.class, Byte.class));
		Class<?>[] classes = Configurations.getClasses(c1, c2, c3, c4);
		assertThat(classes).containsExactly(Short.class, Long.class, Byte.class, InputStream.class, Integer.class,
				OutputStream.class, String.class);
	}
	@Test
	void createShouldSortClasses() {
		TestConfigurations configurations = new TestConfigurations(Sorter.instance, OutputStream.class,
				InputStream.class);
		assertThat(configurations.getClasses()).containsExactly(InputStream.class, OutputStream.class);
	}
	@Test
	void getClassesShouldMergeByClassAndSort() {
		Configurations c1 = new TestSortedConfigurations(OutputStream.class, InputStream.class);
		Configurations c2 = new TestConfigurations(Short.class);
		Configurations c3 = new TestSortedConfigurations(String.class, Integer.class);
		Configurations c4 = new TestConfigurations(Long.class, Byte.class);
		Class<?>[] classes = Configurations.getClasses(c1, c2, c3, c4);
		assertThat(classes).containsExactly(Short.class, Long.class, Byte.class, InputStream.class, Integer.class,
				OutputStream.class, String.class);
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	static class TestConfigurations extends Configurations {
		TestConfigurations(Class<?>... classes) {
			this(Arrays.asList(classes));
		}
		TestConfigurations(UnaryOperator<Collection<Class<?>>> sorter, Class<?>... classes) {
			super(sorter, Arrays.asList(classes));
		}
		TestConfigurations(Collection<Class<?>> classes) {
			super(classes);
		}
		@Override
		protected Configurations merge(Set<Class<?>> mergedClasses) {
			return new TestConfigurations(mergedClasses);
		}
	}
	@Order(Ordered.LOWEST_PRECEDENCE)
	static class TestSortedConfigurations extends Configurations {
		protected TestSortedConfigurations(Class<?>... classes) {
			this(Arrays.asList(classes));
		}
		protected TestSortedConfigurations(Collection<Class<?>> classes) {
			super(Sorter.instance, classes);
		}
		@Override
		protected Configurations merge(Set<Class<?>> mergedClasses) {
			return new TestSortedConfigurations(mergedClasses);
		}
	}
	@Order(Ordered.LOWEST_PRECEDENCE)
	@SuppressWarnings('removal')
	static class TestDeprecatedSortedConfigurations extends Configurations {
		protected TestDeprecatedSortedConfigurations(Collection<Class<?>> classes) {
			super(classes);
		}
		@Override
		protected Collection<Class<?>> sort(Collection<Class<?>> classes) {
			return Sorter.instance.apply(classes);
		}
		@Override
		protected Configurations merge(Set<Class<?>> mergedClasses) {
			return new TestDeprecatedSortedConfigurations(mergedClasses);
		}
	}
	static class Sorter implements UnaryOperator<Collection<Class<?>>> {
		static final Sorter instance = new Sorter();
		@Override
		public Collection<Class<?>> apply(Collection<Class<?>> classes) {
			ArrayList<Class<?>> sorted = new ArrayList<>(classes);
			sorted.sort(Comparator.comparing(ClassUtils::getShortName));
			return sorted;
		}
	}
}
/*
package org.springframework.boot.context.annotation;
/**
class ImportCandidatesTests {
	@Test
	void loadReadsFromClasspathFile() {
		ImportCandidates candidates = ImportCandidates.load(TestAnnotation.class, null);
		assertThat(candidates).containsExactly('class1', 'class2', 'class3');
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	public @interface TestAnnotation {
	}
}
/*
package org.springframework.boot.context.metrics.buffering;
/**
class BufferingApplicationStartupTests {
	@Test
	void shouldNotRecordEventsWhenOverCapacity() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(2);
		applicationStartup.start('first').end();
		applicationStartup.start('second').end();
		applicationStartup.start('third').end();
		assertThat(applicationStartup.getBufferedTimeline().getEvents()).hasSize(2);
	}
	@Test
	void shouldNotRecordEventsWhenFiltered() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(5);
		applicationStartup.addFilter((step) -> step.getName().startsWith('spring'));
		applicationStartup.start('spring.first').end();
		StartupStep filtered = applicationStartup.start('filtered.second');
		applicationStartup.start('spring.third').end();
		filtered.end();
		List<TimelineEvent> events = applicationStartup.getBufferedTimeline().getEvents();
		assertThat(events).hasSize(2);
		StartupTimeline.TimelineEvent firstEvent = events.get(0);
		assertThat(firstEvent.getStartupStep().getId()).isZero();
		assertThat(firstEvent.getStartupStep().getParentId()).isNull();
		StartupTimeline.TimelineEvent secondEvent = events.get(1);
		assertThat(secondEvent.getStartupStep().getId()).isEqualTo(2);
		assertThat(secondEvent.getStartupStep().getParentId()).isOne();
	}
	@Test
	void bufferShouldNotBeEmptyWhenGettingSnapshot() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(2);
		applicationStartup.start('first').end();
		applicationStartup.start('second').end();
		assertThat(applicationStartup.getBufferedTimeline().getEvents()).hasSize(2);
		assertThat(applicationStartup.getBufferedTimeline().getEvents()).hasSize(2);
	}
	@Test
	void bufferShouldBeEmptyWhenDraining() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(2);
		applicationStartup.start('first').end();
		applicationStartup.start('second').end();
		assertThat(applicationStartup.drainBufferedTimeline().getEvents()).hasSize(2);
		assertThat(applicationStartup.getBufferedTimeline().getEvents()).isEmpty();
	}
	@Test
	void startRecordingShouldFailIfEventsWereRecorded() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(2);
		applicationStartup.start('first').end();
		assertThatIllegalStateException().isThrownBy(applicationStartup::startRecording)
			.withMessage('Cannot restart recording once steps have been buffered.');
	}
	@Test
	void taggingShouldFailWhenEventAlreadyRecorded() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(2);
		StartupStep step = applicationStartup.start('first');
		step.end();
		assertThatIllegalStateException().isThrownBy(() -> step.tag('name', 'value'))
			.withMessage('StartupStep has already ended.');
	}
	@Test
	void taggingShouldFailWhenRemovingEntry() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(2);
		StartupStep step = applicationStartup.start('first');
		step.tag('name', 'value');
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> step.getTags().iterator().remove());
	}
	@Test // gh-25792
	void outOfOrderWithMultipleEndCallsShouldNotFail() {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(200);
		StartupStep one = applicationStartup.start('one');
		StartupStep two = applicationStartup.start('two');
		StartupStep three = applicationStartup.start('three');
		two.end();
		two.end();
		two.end();
		StartupStep four = applicationStartup.start('four');
		four.end();
		three.end();
		one.end();
	}
	@Test // gh-25792
	void multiThreadedAccessShouldWork() throws InterruptedException {
		BufferingApplicationStartup applicationStartup = new BufferingApplicationStartup(5000);
		Queue<Exception> errors = new ConcurrentLinkedQueue<>();
		List<Thread> threads = new ArrayList<>();
		for (int thread = 0; thread < 20; thread++) {
			String prefix = 'thread-' + thread + '-';
			threads.add(new Thread(() -> {
				try {
					for (int i = 0; i < 100; i++) {
						StartupStep step = applicationStartup.start(prefix + i);
						try {
							Thread.sleep(1);
						}
						catch (InterruptedException ex) {
							// Ignore
						}
						step.end();
					}
				}
				catch (Exception ex) {
					errors.add(ex);
				}
			}));
		}
		threads.forEach(Thread::start);
		for (Thread thread : threads) {
			thread.join();
		}
		assertThat(errors).isEmpty();
	}
}
/*
package org.springframework.boot.context.filtersample;
public class SampleTypeExcludeFilter extends TypeExcludeFilter {
	@Override
	public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
			throws IOException {
		return metadataReader.getClassMetadata().getClassName().equals(ExampleFilteredComponent.class.getName());
	}
}
/*
package org.springframework.boot.context.filtersample;
@Component
public class ExampleFilteredComponent {
}
/*
package org.springframework.boot.context.filtersample;
@Component
public class ExampleComponent {
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentTests {
	private final DeferredLogFactory logFactory = Supplier::get;
	private final DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
	private final MockApplicationEnvironment environment = new MockApplicationEnvironment();
	private final ResourceLoader resourceLoader = new DefaultResourceLoader();
	private final Collection<String> additionalProfiles = Collections.emptyList();
	private final ConversionService conversionService = DefaultConversionService.getSharedInstance();
	@Test
	void createExposesEnvironmentBinderToConfigDataLocationResolvers() {
		this.environment.setProperty('spring', 'boot');
		TestConfigDataEnvironment configDataEnvironment = new TestConfigDataEnvironment(this.logFactory,
				this.bootstrapContext, this.environment, this.resourceLoader, this.additionalProfiles, null);
		assertThat(configDataEnvironment.getConfigDataLocationResolversBinder().bind('spring', String.class).get())
			.isEqualTo('boot');
	}
	@Test
	void createCreatesContributorsBasedOnExistingSources() {
		MockPropertySource propertySource1 = new MockPropertySource('p1');
		MockPropertySource propertySource2 = new MockPropertySource('p2');
		MockPropertySource propertySource3 = new MockPropertySource('p3');
		this.environment.getPropertySources().addLast(propertySource1);
		this.environment.getPropertySources().addLast(propertySource2);
		this.environment.getPropertySources().addLast(propertySource3);
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		List<ConfigDataEnvironmentContributor> children = configDataEnvironment.getContributors()
			.getRoot()
			.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION);
		Object[] wrapped = children.stream()
			.filter((child) -> child.getKind() == Kind.EXISTING)
			.map(ConfigDataEnvironmentContributor::getPropertySource)
			.toArray();
		assertThat(wrapped[1]).isEqualTo(propertySource1);
		assertThat(wrapped[2]).isEqualTo(propertySource2);
		assertThat(wrapped[3]).isEqualTo(propertySource3);
	}
	@Test
	void createWhenHasDefaultPropertySourceMovesItToLastContributor() {
		MockPropertySource defaultPropertySource = new MockPropertySource('defaultProperties');
		MockPropertySource propertySource1 = new MockPropertySource('p2');
		MockPropertySource propertySource2 = new MockPropertySource('p3');
		this.environment.getPropertySources().addLast(defaultPropertySource);
		this.environment.getPropertySources().addLast(propertySource1);
		this.environment.getPropertySources().addLast(propertySource2);
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		List<ConfigDataEnvironmentContributor> children = configDataEnvironment.getContributors()
			.getRoot()
			.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION);
		Object[] wrapped = children.stream()
			.filter((child) -> child.getKind() == Kind.EXISTING)
			.map(ConfigDataEnvironmentContributor::getPropertySource)
			.toArray();
		assertThat(wrapped[1]).isEqualTo(propertySource1);
		assertThat(wrapped[2]).isEqualTo(propertySource2);
		assertThat(wrapped[3]).isEqualTo(defaultPropertySource);
	}
	@Test
	void createCreatesInitialImportContributorsInCorrectOrder() {
		this.environment.setProperty('spring.config.location', 'l1,l2');
		this.environment.setProperty('spring.config.additional-location', 'a1,a2');
		this.environment.setProperty('spring.config.import', 'i1,i2');
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		List<ConfigDataEnvironmentContributor> children = configDataEnvironment.getContributors()
			.getRoot()
			.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION);
		Object[] imports = children.stream()
			.filter((child) -> child.getKind() == Kind.INITIAL_IMPORT)
			.map(ConfigDataEnvironmentContributor::getImports)
			.map(Object::toString)
			.toArray();
		assertThat(imports).containsExactly('[i2]', '[i1]', '[a2]', '[a1]', '[l2]', '[l1]');
	}
	@Test
	void processAndApplyAddsImportedSourceToEnvironment(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
	}
	@Test
	void processAndApplyOnlyAddsActiveContributors(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
		assertThat(this.environment.getProperty('other')).isNull();
	}
	@Test
	void processAndApplyMovesDefaultPropertySourceToLast(TestInfo info) {
		MockPropertySource defaultPropertySource = new MockPropertySource('defaultProperties');
		this.environment.getPropertySources().addFirst(defaultPropertySource);
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		configDataEnvironment.processAndApply();
		List<PropertySource<?>> sources = this.environment.getPropertySources().stream().toList();
		assertThat(sources.get(sources.size() - 1)).isSameAs(defaultPropertySource);
	}
	@Test
	void processAndApplySetsDefaultProfiles(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getDefaultProfiles()).containsExactly('one', 'two', 'three');
	}
	@Test
	void processAndApplySetsActiveProfiles(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getActiveProfiles()).containsExactly('one', 'two', 'three');
	}
	@Test
	void processAndApplySetsActiveProfilesAndProfileGroups(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getActiveProfiles()).containsExactly('one', 'four', 'five', 'two', 'three');
	}
	@Test
	void processAndApplyDoesNotSetProfilesFromIgnoreProfilesContributors(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null) {
			@Override
			protected ConfigDataEnvironmentContributors createContributors(
					List<ConfigDataEnvironmentContributor> contributors) {
				Map<String, Object> source = new LinkedHashMap<>();
				source.put('spring.profiles.active', 'ignore1');
				source.put('spring.profiles.include', 'ignore2');
				ConfigData data = new ConfigData(Collections.singleton(new MapPropertySource('test', source)),
						ConfigData.Option.IGNORE_PROFILES);
				contributors.add(ConfigDataEnvironmentContributor.ofUnboundImport(ConfigDataLocation.of('test'),
						mock(ConfigDataResource.class), false, data, 0,
						ConfigDataEnvironmentTests.this.conversionService));
				return super.createContributors(contributors);
			}
		};
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getActiveProfiles()).containsExactly('test');
	}
	@ParameterizedTest
	@ValueSource(strings = { 'include', 'include[0]' })
	void processAndApplyWhenHasProfileIncludeInProfileSpecificDocumentThrowsException(String property, TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null) {
			@Override
			protected ConfigDataEnvironmentContributors createContributors(
					List<ConfigDataEnvironmentContributor> contributors) {
				Map<String, Object> source = new LinkedHashMap<>();
				source.put('spring.config.activate.on-profile', 'activate');
				source.put('spring.profiles.' + property, 'include');
				ConfigData data = new ConfigData(Collections.singleton(new MapPropertySource('test', source)));
				contributors.add(ConfigDataEnvironmentContributor.ofUnboundImport(ConfigDataLocation.of('test'),
						mock(ConfigDataResource.class), false, data, 0,
						ConfigDataEnvironmentTests.this.conversionService));
				return super.createContributors(contributors);
			}
		};
		assertThatExceptionOfType(InactiveConfigDataAccessException.class)
			.isThrownBy(configDataEnvironment::processAndApply);
	}
	@ParameterizedTest
	@ValueSource(strings = { 'spring.profiles.include', 'spring.profiles.include[0]' })
	void processAndApplyIncludesProfilesFromSpringProfilesInclude(String property, TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null) {
			@Override
			protected ConfigDataEnvironmentContributors createContributors(
					List<ConfigDataEnvironmentContributor> contributors) {
				Map<String, Object> source = new LinkedHashMap<>();
				source.put(property, 'included');
				ConfigData data = new ConfigData(Collections.singleton(new MapPropertySource('test', source)));
				contributors.add(ConfigDataEnvironmentContributor.ofUnboundImport(ConfigDataLocation.of('test'),
						mock(ConfigDataResource.class), false, data, 0,
						ConfigDataEnvironmentTests.this.conversionService));
				return super.createContributors(contributors);
			}
		};
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getActiveProfiles()).containsExactly('included');
	}
	@Test
	void processAndApplyDoesNotSetProfilesFromIgnoreProfilesContributorsWhenNoProfilesActive(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null) {
			@Override
			protected ConfigDataEnvironmentContributors createContributors(
					List<ConfigDataEnvironmentContributor> contributors) {
				Map<String, Object> source = new LinkedHashMap<>();
				source.put('spring.profiles.active', 'ignore1');
				source.put('spring.profiles.include', 'ignore2');
				ConfigData data = new ConfigData(Collections.singleton(new MapPropertySource('test', source)),
						ConfigData.Option.IGNORE_PROFILES);
				contributors.add(ConfigDataEnvironmentContributor.ofUnboundImport(ConfigDataLocation.of('test'),
						mock(ConfigDataResource.class), false, data, 0,
						ConfigDataEnvironmentTests.this.conversionService));
				return super.createContributors(contributors);
			}
		};
		configDataEnvironment.processAndApply();
		assertThat(this.environment.getActiveProfiles()).isEmpty();
		assertThat(this.environment.getProperty('spring')).isEqualTo('boot');
	}
	@Test
	@Disabled('Disabled until spring.profiles support is dropped')
	void processAndApplyWhenHasInvalidPropertyThrowsException() {
		this.environment.setProperty('spring.profile', 'a');
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, null);
		assertThatExceptionOfType(InvalidConfigDataPropertyException.class)
			.isThrownBy(configDataEnvironment::processAndApply);
	}
	@Test
	void processAndApplyWhenHasListenerCallsOnPropertySourceAdded(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		TestConfigDataEnvironmentUpdateListener listener = new TestConfigDataEnvironmentUpdateListener();
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, listener);
		configDataEnvironment.processAndApply();
		assertThat(listener.getAddedPropertySources()).hasSize(1);
		AddedPropertySource addedPropertySource = listener.getAddedPropertySources().get(0);
		assertThat(addedPropertySource.getPropertySource().getProperty('spring')).isEqualTo('boot');
		assertThat(addedPropertySource.getLocation()).hasToString(getConfigLocation(info));
		assertThat(addedPropertySource.getResource().toString()).contains('class path resource')
			.contains(info.getTestMethod().get().getName());
	}
	@Test
	void processAndApplyWhenHasListenerCallsOnSetProfiles(TestInfo info) {
		this.environment.setProperty('spring.config.location', getConfigLocation(info));
		TestConfigDataEnvironmentUpdateListener listener = new TestConfigDataEnvironmentUpdateListener();
		ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,
				this.environment, this.resourceLoader, this.additionalProfiles, listener);
		configDataEnvironment.processAndApply();
		assertThat(listener.getProfiles().getActive()).containsExactly('one', 'two', 'three');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void configDataLoadersAreLoadedUsingClassLoaderFromResourceLoader() {
		ResourceLoader resourceLoader = mock(ResourceLoader.class);
		ClassLoader classLoader = new ClassLoader() {
			@Override
			public Enumeration<URL> getResources(String name) throws IOException {
				if (SpringFactoriesLoader.FACTORIES_RESOURCE_LOCATION.equals(name)) {
					return Collections.enumeration(List.of(new File(
							'src/test/resources/org/springframework/boot/context/config/separate-class-loader-spring.factories')
						.toURI()
						.toURL()));
				}
				return super.getResources(name);
			}
		};
		given(resourceLoader.getClassLoader()).willReturn(classLoader);
		TestConfigDataEnvironment configDataEnvironment = new TestConfigDataEnvironment(this.logFactory,
				this.bootstrapContext, this.environment, resourceLoader, this.additionalProfiles, null);
		assertThat(configDataEnvironment).extracting('loaders.loaders')
			.asInstanceOf(InstanceOfAssertFactories.LIST)
			.extracting((item) -> (Class) item.getClass())
			.containsOnly(SeparateClassLoaderConfigDataLoader.class);
	}
	private String getConfigLocation(TestInfo info) {
		return 'optional:classpath:' + info.getTestClass().get().getName().replace(".", "/") + '-'
				+ info.getTestMethod().get().getName() + '.properties';
	}
	static class TestConfigDataEnvironment extends ConfigDataEnvironment {
		private Binder configDataLocationResolversBinder;
		TestConfigDataEnvironment(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext,
				ConfigurableEnvironment environment, ResourceLoader resourceLoader,
				Collection<String> additionalProfiles, ConfigDataEnvironmentUpdateListener environmentUpdateListener) {
			super(logFactory, bootstrapContext, environment, resourceLoader, additionalProfiles,
					environmentUpdateListener);
		}
		@Override
		protected ConfigDataLocationResolvers createConfigDataLocationResolvers(DeferredLogFactory logFactory,
				ConfigurableBootstrapContext bootstrapContext, Binder binder, ResourceLoader resourceLoader) {
			this.configDataLocationResolversBinder = binder;
			return super.createConfigDataLocationResolvers(logFactory, bootstrapContext, binder, resourceLoader);
		}
		Binder getConfigDataLocationResolversBinder() {
			return this.configDataLocationResolversBinder;
		}
	}
	static class SeparateClassLoaderConfigDataLoader implements ConfigDataLoader<ConfigDataResource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource)
				throws IOException, ConfigDataResourceNotFoundException {
			return null;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
@ExtendWith(MockitoExtension.class)
class ConfigDataImporterTests {
	private final DeferredLogFactory logFactory = Supplier::get;
	@Mock
	private ConfigDataLocationResolvers resolvers;
	@Mock
	private ConfigDataLoaders loaders;
	@Mock
	private Binder binder;
	@Mock
	private ConfigDataLocationResolverContext locationResolverContext;
	@Mock
	private ConfigDataLoaderContext loaderContext;
	@Mock
	private ConfigDataActivationContext activationContext;
	@Mock
	private Profiles profiles;
	@BeforeEach
	void setup() {
		given(this.activationContext.getProfiles()).willReturn(this.profiles);
	}
	@Test
	void loadImportsResolvesAndLoadsLocations() throws Exception {
		ConfigDataLocation location1 = ConfigDataLocation.of('test1');
		ConfigDataLocation location2 = ConfigDataLocation.of('test2');
		TestResource resource1 = new TestResource('r1');
		TestResource resource2 = new TestResource('r2');
		ConfigData configData1 = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigData configData2 = new ConfigData(Collections.singleton(new MockPropertySource()));
		given(this.resolvers.resolve(this.locationResolverContext, location1, this.profiles))
			.willReturn(Collections.singletonList(new ConfigDataResolutionResult(location1, resource1, false)));
		given(this.resolvers.resolve(this.locationResolverContext, location2, this.profiles))
			.willReturn(Collections.singletonList(new ConfigDataResolutionResult(location2, resource2, false)));
		given(this.loaders.load(this.loaderContext, resource1)).willReturn(configData1);
		given(this.loaders.load(this.loaderContext, resource2)).willReturn(configData2);
		ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, ConfigDataNotFoundAction.FAIL,
				this.resolvers, this.loaders);
		Collection<ConfigData> loaded = importer
			.resolveAndLoad(this.activationContext, this.locationResolverContext, this.loaderContext,
					Arrays.asList(location1, location2))
			.values();
		assertThat(loaded).containsExactly(configData2, configData1);
	}
	@Test
	void loadImportsWhenAlreadyImportedLocationSkipsLoad() throws Exception {
		ConfigDataLocation location1 = ConfigDataLocation.of('test1');
		ConfigDataLocation location2 = ConfigDataLocation.of('test2');
		ConfigDataLocation location3 = ConfigDataLocation.of('test3');
		List<ConfigDataLocation> locations1and2 = Arrays.asList(location1, location2);
		List<ConfigDataLocation> locations2and3 = Arrays.asList(location2, location3);
		TestResource resource1 = new TestResource('r1');
		TestResource resource2 = new TestResource('r2');
		TestResource resource3 = new TestResource('r3');
		ConfigData configData1 = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigData configData2 = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigData configData3 = new ConfigData(Collections.singleton(new MockPropertySource()));
		given(this.resolvers.resolve(this.locationResolverContext, location1, this.profiles))
			.willReturn(Collections.singletonList(new ConfigDataResolutionResult(location1, resource1, false)));
		given(this.resolvers.resolve(this.locationResolverContext, location2, this.profiles))
			.willReturn(Collections.singletonList(new ConfigDataResolutionResult(location2, resource2, false)));
		given(this.resolvers.resolve(this.locationResolverContext, location3, this.profiles))
			.willReturn(Collections.singletonList(new ConfigDataResolutionResult(location3, resource3, false)));
		given(this.loaders.load(this.loaderContext, resource1)).willReturn(configData1);
		given(this.loaders.load(this.loaderContext, resource2)).willReturn(configData2);
		given(this.loaders.load(this.loaderContext, resource3)).willReturn(configData3);
		ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, ConfigDataNotFoundAction.FAIL,
				this.resolvers, this.loaders);
		Collection<ConfigData> loaded1and2 = importer
			.resolveAndLoad(this.activationContext, this.locationResolverContext, this.loaderContext, locations1and2)
			.values();
		Collection<ConfigData> loaded2and3 = importer
			.resolveAndLoad(this.activationContext, this.locationResolverContext, this.loaderContext, locations2and3)
			.values();
		assertThat(loaded1and2).containsExactly(configData2, configData1);
		assertThat(loaded2and3).containsExactly(configData3);
	}
	static class TestResource extends ConfigDataResource {
		private final String name;
		TestResource(String name) {
			this.name = name;
		}
		@Override
		public String toString() {
			return this.name;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class LocationResourceLoaderTests {
	private final LocationResourceLoader loader = new LocationResourceLoader(new DefaultResourceLoader());
	@TempDir
	File temp;
	@Test
	void isPatternWhenHasAsteriskReturnsTrue() {
		assertThat(this.loader.isPattern('spring/*/boot')).isTrue();
	}
	@Test
	void isPatternWhenNoAsteriskReturnsFalse() {
		assertThat(this.loader.isPattern('spring/boot')).isFalse();
	}
	@Test
	void getResourceWhenPatternThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> this.loader.getResource('spring/boot/*'))
			.withMessage('Location "spring/boot/*" must not be a pattern');
	}
	@Test
	void getResourceReturnsResource() throws Exception {
		File file = new File(this.temp, 'file');
		FileCopyUtils.copy('test'.getBytes(), file);
		Resource resource = this.loader.getResource(file.toURI().toString());
		assertThat(resource.getInputStream()).hasContent('test');
	}
	@Test
	void getResourceWhenNotUrlReturnsResource() throws Exception {
		File file = new File(this.temp, 'file');
		FileCopyUtils.copy('test'.getBytes(), file);
		Resource resource = this.loader.getResource(file.getAbsolutePath());
		assertThat(resource.getInputStream()).hasContent('test');
	}
	@Test
	void getResourceWhenNonCleanPathReturnsResource() throws Exception {
		File file = new File(this.temp, 'file');
		FileCopyUtils.copy('test'.getBytes(), file);
		Resource resource = this.loader.getResource(this.temp.getAbsolutePath() + '/spring/../file');
		assertThat(resource.getInputStream()).hasContent('test');
	}
	@Test
	void getResourcesWhenNotPatternThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> this.loader.getResources('spring/boot', ResourceType.FILE))
			.withMessage('Location "spring/boot" must be a pattern');
	}
	@Test
	void getResourcesWhenLocationStartsWithClasspathWildcardThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.loader.getResources('classpath*:spring/boot/*/', ResourceType.FILE))
			.withMessage('Location "classpath*:spring/boot/*/" cannot use classpath wildcards');
	}
	@Test
	void getResourcesWhenLocationContainsMultipleWildcardsThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.loader.getResources('spring/*/boot/*/', ResourceType.FILE))
			.withMessage('Location "spring/*/boot/*/" cannot contain multiple wildcards');
	}
	@Test
	void getResourcesWhenPatternDoesNotEndWithAsteriskSlashThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> this.loader.getResources('spring/boot/*', ResourceType.FILE))
			.withMessage('Location "spring/boot/*" must end with "*/"');
	}
	@Test
	void getFileResourceReturnsResources() throws Exception {
		createTree();
		Resource[] resources = this.loader.getResources(this.temp.getAbsolutePath() + '/*/file', ResourceType.FILE);
		assertThat(resources).hasSize(2);
		assertThat(resources[0].getInputStream()).hasContent('a');
		assertThat(resources[1].getInputStream()).hasContent('b');
	}
	@Test
	void getDirectoryResourceReturnsResources() throws Exception {
		createTree();
		Resource[] resources = this.loader.getResources(this.temp.getAbsolutePath() + '/*/', ResourceType.DIRECTORY);
		assertThat(resources).hasSize(2);
		assertThat(resources[0].getFilename()).isEqualTo('a');
		assertThat(resources[1].getFilename()).isEqualTo('b');
	}
	@Test
	void getResourcesWhenHasHiddenDirectoriesFiltersResults() throws IOException {
		createTree();
		File hiddenDirectory = new File(this.temp, '..a');
		hiddenDirectory.mkdirs();
		FileCopyUtils.copy('h'.getBytes(), new File(hiddenDirectory, 'file'));
		Resource[] resources = this.loader.getResources(this.temp.getAbsolutePath() + '/*/file', ResourceType.FILE);
		assertThat(resources).hasSize(2);
		assertThat(resources[0].getInputStream()).hasContent('a');
		assertThat(resources[1].getInputStream()).hasContent('b');
	}
	private void createTree() throws IOException {
		File directoryA = new File(this.temp, 'a');
		File directoryB = new File(this.temp, 'b');
		directoryA.mkdirs();
		directoryB.mkdirs();
		FileCopyUtils.copy('a'.getBytes(), new File(directoryA, 'file'));
		FileCopyUtils.copy('b'.getBytes(), new File(directoryB, 'file'));
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataPropertiesTests {
	private static final CloudPlatform NULL_CLOUD_PLATFORM = null;
	private static final Profiles NULL_PROFILES = null;
	private static final List<ConfigDataLocation> NO_IMPORTS = Collections.emptyList();
	@Test
	void getImportsReturnsImports() {
		ConfigDataLocation l1 = ConfigDataLocation.of('one');
		ConfigDataLocation l2 = ConfigDataLocation.of('two');
		ConfigDataLocation l3 = ConfigDataLocation.of('three');
		List<ConfigDataLocation> imports = Arrays.asList(l1, l2, l3);
		ConfigDataProperties properties = new ConfigDataProperties(imports, null);
		assertThat(properties.getImports()).containsExactly(l1, l2, l3);
	}
	@Test
	void getImportsWhenImportsAreNullReturnsEmptyList() {
		ConfigDataProperties properties = new ConfigDataProperties(null, null);
		assertThat(properties.getImports()).isEmpty();
	}
	@Test
	void isActiveWhenNullCloudPlatformAgainstNullCloudPlatform() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS, new Activate(null, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM, NULL_PROFILES);
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenNullCloudPlatformAgainstSpecificCloudPlatform() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS, new Activate(null, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(CloudPlatform.KUBERNETES, NULL_PROFILES);
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenSpecificCloudPlatformAgainstNullCloudPlatform() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS,
				new Activate(CloudPlatform.KUBERNETES, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM, NULL_PROFILES);
		assertThat(properties.isActive(context)).isFalse();
	}
	@Test
	void isActiveWhenSpecificCloudPlatformAgainstMatchingSpecificCloudPlatform() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS,
				new Activate(CloudPlatform.KUBERNETES, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(CloudPlatform.KUBERNETES, NULL_PROFILES);
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenSpecificCloudPlatformAgainstDifferentSpecificCloudPlatform() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS,
				new Activate(CloudPlatform.KUBERNETES, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(CloudPlatform.HEROKU, NULL_PROFILES);
		assertThat(properties.isActive(context)).isFalse();
	}
	@Test
	void isActiveWhenNoneCloudPlatformAgainstNullCloudPlatform() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS, new Activate(CloudPlatform.NONE, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM, NULL_PROFILES);
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenNullProfilesAgainstNullProfiles() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS, new Activate(null, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM, NULL_PROFILES);
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenNullProfilesAgainstSpecificProfiles() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS, new Activate(null, null));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM,
				createTestProfiles());
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenSpecificProfilesAgainstNullProfiles() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS,
				new Activate(null, new String[] { 'a' }));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM, null);
		assertThat(properties.isActive(context)).isFalse();
	}
	@Test
	void isActiveWhenSpecificProfilesAgainstMatchingSpecificProfiles() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS,
				new Activate(null, new String[] { 'a' }));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM,
				createTestProfiles());
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenSpecificProfilesAgainstMissingSpecificProfiles() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS,
				new Activate(null, new String[] { 'x' }));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM,
				createTestProfiles());
		assertThat(properties.isActive(context)).isFalse();
	}
	@Test
	void isActiveWhenProfileExpressionAgainstSpecificProfiles() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS,
				new Activate(null, new String[] { 'a | b' }));
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM,
				createTestProfiles());
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveWhenActivateIsNull() {
		ConfigDataProperties properties = new ConfigDataProperties(NO_IMPORTS, null);
		ConfigDataActivationContext context = new ConfigDataActivationContext(NULL_CLOUD_PLATFORM,
				createTestProfiles());
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveAgainstBoundData() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('spring.config.activate.on-cloud-platform', 'kubernetes');
		source.put('spring.config.activate.on-profile', 'a | b');
		Binder binder = new Binder(source);
		ConfigDataProperties properties = ConfigDataProperties.get(binder);
		ConfigDataActivationContext context = new ConfigDataActivationContext(CloudPlatform.KUBERNETES,
				createTestProfiles());
		assertThat(properties.isActive(context)).isTrue();
	}
	@Test
	void isActiveAgainstBoundDataWhenProfilesDontMatch() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('spring.config.activate.on-cloud-platform', 'kubernetes');
		source.put('spring.config.activate.on-profile', 'x | z');
		Binder binder = new Binder(source);
		ConfigDataProperties properties = ConfigDataProperties.get(binder);
		ConfigDataActivationContext context = new ConfigDataActivationContext(CloudPlatform.KUBERNETES,
				createTestProfiles());
		assertThat(properties.isActive(context)).isFalse();
	}
	@Test
	void isActiveAgainstBoundDataWhenCloudPlatformDoesntMatch() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('spring.config.activate.on-cloud-platform', 'cloud-foundry');
		source.put('spring.config.activate.on-profile', 'a | b');
		Binder binder = new Binder(source);
		ConfigDataProperties properties = ConfigDataProperties.get(binder);
		ConfigDataActivationContext context = new ConfigDataActivationContext(CloudPlatform.KUBERNETES,
				createTestProfiles());
		assertThat(properties.isActive(context)).isFalse();
	}
	@Test
	void getImportOriginWhenCommaListReturnsOrigin() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('spring.config.import', 'one,two,three');
		Binder binder = new Binder(source);
		ConfigDataProperties properties = ConfigDataProperties.get(binder);
		assertThat(properties.getImports().get(1).getOrigin())
			.hasToString('\'spring.config.import\' from property source \'source\'');
	}
	@Test
	void getImportOriginWhenBracketListReturnsOrigin() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('spring.config.import[0]', 'one');
		source.put('spring.config.import[1]', 'two');
		source.put('spring.config.import[2]', 'three');
		Binder binder = new Binder(source);
		ConfigDataProperties properties = ConfigDataProperties.get(binder);
		assertThat(properties.getImports().get(1).getOrigin())
			.hasToString('\'spring.config.import[1]\' from property source \'source\'');
	}
	private Profiles createTestProfiles() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		environment.setDefaultProfiles('d', 'e', 'f');
		Binder binder = Binder.get(environment);
		return new Profiles(environment, binder, null);
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentPostProcessorIntegrationTests {
	private SpringApplication application;
	@TempDir
	public File temp;
	@BeforeEach
	void setup() {
		this.application = new SpringApplication(Config.class);
		this.application.setWebApplicationType(WebApplicationType.NONE);
	}
	@AfterEach
	void clearProperties() {
		System.clearProperty('the.property');
	}
	@Test
	void runWhenUsingCustomResourceLoader() {
		this.application.setResourceLoader(new ResourceLoader() {
			@Override
			public Resource getResource(String location) {
				if (location.equals('classpath:/custom.properties')) {
					return new ByteArrayResource('the.property: fromcustom'.getBytes(), location);
				}
				return new ClassPathResource('doesnotexist');
			}
			@Override
			public ClassLoader getClassLoader() {
				return getClass().getClassLoader();
			}
		});
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=custom');
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('fromcustom');
	}
	@Test
	void runLoadsApplicationPropertiesOnClasspath() {
		ConfigurableApplicationContext context = this.application.run();
		String property = context.getEnvironment().getProperty('foo');
		assertThat(property).isEqualTo('bucket');
	}
	@Test
	void runLoadsApplicationYamlOnClasspath() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=customapplication');
		String property = context.getEnvironment().getProperty('yamlkey');
		assertThat(property).isEqualTo('yamlvalue');
	}
	@Test
	void runLoadsFileWithCustomName() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testproperties');
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('frompropertiesfile');
	}
	@Test
	void runWhenPropertiesAndYamlShouldPreferProperties() {
		ConfigurableApplicationContext context = this.application.run();
		String property = context.getEnvironment().getProperty('duplicate');
		assertThat(property).isEqualTo('properties');
	}
	@Test
	void runWhenMultipleCustomNamesLoadsEachName() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=moreproperties,testproperties');
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('frompropertiesfile');
	}
	@Test
	void runWhenNoActiveProfilesLoadsDefaultProfileFile() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testprofiles');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromdefaultpropertiesfile');
	}
	@Test
	void runWhenActiveProfilesDoesNotLoadDefault() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testprofilesdocument',
				'--spring.config.location=classpath:configdata/profiles/', '--spring.profiles.default=thedefault',
				'--spring.profiles.active=other');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromotherprofile');
	}
	@Test
	void runWhenHasCustomDefaultProfileLoadsDefaultProfileFile() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testprofiles',
				'--spring.profiles.default=thedefault');
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('fromdefaultpropertiesfile');
	}
	@Test
	void runWhenHasCustomSpringConfigLocationLoadsAllFromSpecifiedLocation() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:application.properties,classpath:testproperties.properties');
		String property1 = context.getEnvironment().getProperty('the.property');
		String property2 = context.getEnvironment().getProperty('my.property');
		String property3 = context.getEnvironment().getProperty('foo');
		assertThat(property1).isEqualTo('frompropertiesfile');
		assertThat(property2).isEqualTo('frompropertiesfile');
		assertThat(property3).isEqualTo('bucket');
	}
	@Test
	void runWhenOneCustomLocationDoesNotExistLoadsOthers() {
		ConfigurableApplicationContext context = this.application.run(
				'--spring.config.location=classpath:application.properties,classpath:testproperties.properties,optional:classpath:nonexistent.properties');
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('frompropertiesfile');
	}
	@Test
	void runWhenProfileSpecificMandatoryLocationDoesNotExistShouldNotFail() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testprofiles',
				'--spring.config.location=classpath:configdata/profiles/');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromyamlfile');
	}
	@Test
	void runWhenProfileSpecificMandatoryLocationDoesNotExistShouldFailWhenProfileActive() {
		this.application.setAdditionalProfiles('prod');
		assertThatExceptionOfType(ConfigDataResourceNotFoundException.class).isThrownBy(() -> this.application
			.run('--spring.config.name=testprofiles', '--spring.config.location=classpath:configdata/profiles/'));
	}
	@Test
	void runWhenHasActiveProfilesFromMultipleLocationsActivatesProfileFromOneLocation() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:enableprofile.properties,classpath:enableother.properties');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.getActiveProfiles()).containsExactly('other');
		String property = environment.getProperty('other.property');
		assertThat(property).isEqualTo('fromotherpropertiesfile');
	}
	@Test
	void runWhenHasActiveProfilesFromMultipleAdditionalLocationsWithOneSwitchedOffLoadsExpectedProperties() {
		ConfigurableApplicationContext context = this.application.run(
				'--spring.config.additional-location=classpath:enabletwoprofiles.properties,classpath:enableprofile.properties');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.getActiveProfiles()).containsExactly('myprofile');
		String property = environment.getProperty('my.property');
		assertThat(property).isEqualTo('fromprofilepropertiesfile');
	}
	@Test
	void runWhenHasLocalFileLoadsWithLocalFileTakingPrecedenceOverClasspath() throws Exception {
		File localFile = new File(new File('.'), 'application.properties');
		assertThat(localFile).doesNotExist();
		try {
			Properties properties = new Properties();
			properties.put('my.property', 'fromlocalfile');
			try (OutputStream outputStream = new FileOutputStream(localFile)) {
				properties.store(outputStream, '');
			}
			ConfigurableApplicationContext context = this.application.run();
			String property = context.getEnvironment().getProperty('my.property');
			assertThat(property).isEqualTo('fromlocalfile');
		}
		finally {
			localFile.delete();
		}
	}
	@Test
	void runWhenHasCommandLinePropertiesLoadsWithCommandLineTakingPrecedence() {
		StandardEnvironment environment = new StandardEnvironment();
		environment.getPropertySources()
			.addFirst(new SimpleCommandLinePropertySource('--the.property=fromcommandline'));
		this.application.setEnvironment(environment);
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testproperties');
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('fromcommandline');
	}
	@Test
	void runWhenHasSystemPropertyLoadsWithSystemPropertyTakingPrecedence() {
		System.setProperty('the.property', 'fromsystem');
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testproperties');
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('fromsystem');
	}
	@Test
	void runWhenHasDefaultPropertiesIncludesDefaultPropertiesLast() {
		this.application.setDefaultProperties(Collections.singletonMap('my.fallback', 'foo'));
		ConfigurableApplicationContext context = this.application.run();
		String property = context.getEnvironment().getProperty('my.fallback');
		assertThat(property).isEqualTo('foo');
	}
	@Test
	void runWhenHasDefaultPropertiesWithConfigLocationConfigurationLoadsExpectedProperties() {
		this.application.setDefaultProperties(Collections.singletonMap('spring.config.name', 'testproperties'));
		ConfigurableApplicationContext context = this.application.run();
		String property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('frompropertiesfile');
	}
	@Test
	void runWhenHasActiveProfilesFromDefaultPropertiesAndFileLoadsWithFileTakingPrecedence() {
		this.application.setDefaultProperties(Collections.singletonMap('spring.profiles.active', 'dev'));
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=enableprofile');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('myprofile');
	}
	@Test
	void runWhenProgrammaticallySetProfilesLoadsWithSetProfilesTakePrecedenceOverDefaultProfile() {
		this.application.setAdditionalProfiles('other');
		ConfigurableApplicationContext context = this.application.run();
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromotherpropertiesfile');
	}
	@Test
	void runWhenTwoProfilesSetProgrammaticallyLoadsWithPreservedProfileOrder() {
		this.application.setAdditionalProfiles('other', 'dev');
		ConfigurableApplicationContext context = this.application.run();
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromdevpropertiesfile');
	}
	@Test
	void runWhenProfilesPresentBeforeConfigFileProcessingAugmentsProfileActivatedByConfigFile() {
		this.application.setAdditionalProfiles('other');
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=enableprofile');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('other', 'myprofile');
		String property = context.getEnvironment().getProperty('other.property');
		assertThat(property).isEqualTo('fromotherpropertiesfile');
		property = context.getEnvironment().getProperty('the.property');
		assertThat(property).isEqualTo('fromprofilepropertiesfile');
	}
	@Test
	void runWhenProfilePropertiesUsedInPlaceholdersLoadsWithResolvedPlaceholders() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=enableprofile');
		String property = context.getEnvironment().getProperty('one.more');
		assertThat(property).isEqualTo('fromprofilepropertiesfile');
	}
	@Test
	void runWhenDuplicateProfileSetProgrammaticallyAndViaPropertyLoadsWithProfiles() {
		this.application.setAdditionalProfiles('dev');
		ConfigurableApplicationContext context = this.application.run('--spring.profiles.active=dev,other');
		assertThat(context.getEnvironment().getActiveProfiles()).contains('dev', 'other');
		assertThat(context.getEnvironment().getProperty('my.property')).isEqualTo('fromotherpropertiesfile');
	}
	@Test
	void runWhenProfilesActivatedViaBracketNotationSetsProfiles() {
		ConfigurableApplicationContext context = this.application.run('--spring.profiles.active[0]=dev',
				'--spring.profiles.active[1]=other');
		assertThat(context.getEnvironment().getActiveProfiles()).contains('dev', 'other');
		assertThat(context.getEnvironment().getProperty('my.property')).isEqualTo('fromotherpropertiesfile');
	}
	@Test
	void loadWhenProfileInMultiDocumentFilesLoadsExpectedProperties() {
		this.application.setAdditionalProfiles('dev');
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testprofiles',
				'--spring.config.location=classpath:configdata/profiles/');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromdevprofile');
		property = context.getEnvironment().getProperty('my.other');
		assertThat(property).isEqualTo('notempty');
	}
	@Test
	void runWhenMultipleActiveProfilesWithMultiDocumentFilesLoadsInOrderOfDocument() {
		this.application.setAdditionalProfiles('other', 'dev');
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testprofiles',
				'--spring.config.location=classpath:configdata/profiles/');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromotherprofile');
		property = context.getEnvironment().getProperty('my.other');
		assertThat(property).isEqualTo('notempty');
		property = context.getEnvironment().getProperty('dev.property');
		assertThat(property).isEqualTo('devproperty');
	}
	@Test
	void runWhenHasAndProfileExpressionLoadsExpectedProperties() {
		assertProfileExpression('devandother', 'dev', 'other');
	}
	@Test
	void runWhenHasComplexProfileExpressionsLoadsExpectedProperties() {
		assertProfileExpression('devorotherandanother', 'dev', 'another');
	}
	@Test
	void runWhenProfileExpressionsDoNotMatchLoadsExpectedProperties() {
		assertProfileExpression('fromyamlfile', 'dev');
	}
	@Test
	void runWhenHasNegatedProfilesLoadsExpectedProperties() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testnegatedprofiles',
				'--spring.config.location=classpath:configdata/profiles/');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromnototherprofile');
		property = context.getEnvironment().getProperty('my.notother');
		assertThat(property).isEqualTo('foo');
	}
	@Test
	void runWhenHasNegatedProfilesWithProfileActiveLoadsExpectedProperties() {
		this.application.setAdditionalProfiles('other');
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testnegatedprofiles',
				'--spring.config.location=classpath:configdata/profiles/');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromotherprofile');
		property = context.getEnvironment().getProperty('my.notother');
		assertThat(property).isNull();
	}
	@Test
	void runWhenHasActiveProfileConfigurationInMultiDocumentFileLoadsInExpectedOrder() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testsetprofiles',
				'--spring.config.location=classpath:configdata/profiles/');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('dev');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(context.getEnvironment().getActiveProfiles()).contains('dev');
		assertThat(property).isEqualTo('fromdevprofile');
		assertThat(context.getEnvironment().getPropertySources()).extracting('name')
			.contains(
					'Config resource "class path resource [configdata/profiles/testsetprofiles.yml]" via location "classpath:configdata/profiles/" (document #0)',
					'Config resource "class path resource [configdata/profiles/testsetprofiles.yml]" via location "classpath:configdata/profiles/" (document #1)');
	}
	@Test
	void runWhenHasYamlWithCommaSeparatedMultipleProfilesLoadsExpectedProperties() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testsetmultiprofiles');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('dev', 'healthcheck');
	}
	@Test
	void runWhenHasYamlWithListProfilesLoadsExpectedProperties() {
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testsetmultiprofileslist');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('dev', 'healthcheck');
	}
	@Test
	void loadWhenHasWhitespaceTrims() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=testsetmultiprofileswhitespace');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('dev', 'healthcheck');
	}
	@Test
	void loadWhenHasConfigLocationAsFile() {
		String location = 'file:src/test/resources/specificlocation.properties';
		ConfigurableApplicationContext context = this.application.run('--spring.config.location=' + location);
		assertThat(context.getEnvironment()).has(matchingPropertySource('Config resource "file [' + Strings
			.join(Arrays.asList('src', 'test', 'resources', 'specificlocation.properties'), File.separatorChar)
				+ ']" via location "' + location + '"'));
	}
	@Test
	void loadWhenHasRelativeConfigLocationUsesFileLocation() {
		String location = 'src/test/resources/specificlocation.properties';
		ConfigurableApplicationContext context = this.application.run('--spring.config.location=' + location);
		assertThat(context.getEnvironment()).has(matchingPropertySource('Config resource "file [' + Strings
			.join(Arrays.asList('src', 'test', 'resources', 'specificlocation.properties'), File.separatorChar)
				+ ']" via location "' + location + '"'));
	}
	@Test
	void loadWhenCustomDefaultProfileAndActiveFromPreviousSourceDoesNotActivateDefault() {
		ConfigurableApplicationContext context = this.application.run('--spring.profiles.default=customdefault',
				'--spring.profiles.active=dev');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo('fromdevpropertiesfile');
		assertThat(context.getEnvironment().containsProperty('customdefault')).isFalse();
	}
	@Test
	void runWhenCustomDefaultProfileSameAsActiveFromFileActivatesProfile() {
		ConfigurableApplicationContext context = this.application.run(
				'--spring.config.location=classpath:configdata/profiles/', '--spring.profiles.default=customdefault',
				'--spring.config.name=customprofile');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.containsProperty('customprofile')).isTrue();
		assertThat(environment.containsProperty('customprofile-customdefault')).isTrue();
		assertThat(environment.acceptsProfiles(Profiles.of('customdefault'))).isTrue();
	}
	@Test
	void runWhenActiveProfilesCanBeConfiguredUsingPlaceholdersResolvedAgainstTheEnvironmentLoadsExpectedProperties() {
		ConfigurableApplicationContext context = this.application.run('--activeProfile=testPropertySource',
				'--spring.config.name=testactiveprofiles');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactly('testPropertySource');
	}
	@Test
	void runWhenHasAdditionalLocationLoadsWithAdditionalTakingPrecedenceOverDefaultLocation() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.additional-location=classpath:override.properties');
		assertThat(context.getEnvironment().getProperty('foo')).isEqualTo('bar');
		assertThat(context.getEnvironment().getProperty('value')).isEqualTo('1234');
	}
	@Test
	void runWhenMultipleAdditionalLocationsLoadsWithLastWinning() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.additional-location=classpath:override.properties,classpath:some.properties');
		assertThat(context.getEnvironment().getProperty('foo')).isEqualTo('spam');
		assertThat(context.getEnvironment().getProperty('value')).isEqualTo('1234');
	}
	@Test
	void runWhenAdditionalLocationAndLocationLoadsWithAdditionalTakingPrecedenceOverConfigured() {
		ConfigurableApplicationContext context = this.application.run(
				'--spring.config.location=classpath:some.properties',
				'--spring.config.additional-location=classpath:override.properties');
		assertThat(context.getEnvironment().getProperty('foo')).isEqualTo('bar');
		assertThat(context.getEnvironment().getProperty('value')).isNull();
	}
	@Test
	void runWhenPropertiesFromCustomPropertySourceLoaderShouldLoadFromCustomSource() {
		ConfigurableApplicationContext context = this.application.run();
		assertThat(context.getEnvironment().getProperty('customloader1')).isEqualTo('true');
	}
	@Test
	void runWhenCustomDefaultPropertySourceLoadsWithoutReplacingCustomSource() {
		// gh-17011
		Map<String, Object> source = new HashMap<>();
		source.put('mapkey', 'mapvalue');
		MapPropertySource propertySource = new MapPropertySource('defaultProperties', source) {
			@Override
			public Object getProperty(String name) {
				if ('spring.config.name'.equals(name)) {
					return 'gh17001';
				}
				return super.getProperty(name);
			}
		};
		StandardEnvironment environment = new StandardEnvironment();
		environment.getPropertySources().addFirst(propertySource);
		this.application.setEnvironment(environment);
		ConfigurableApplicationContext context = this.application.run();
		assertThat(context.getEnvironment().getProperty('mapkey')).isEqualTo('mapvalue');
		assertThat(context.getEnvironment().getProperty('gh17001loaded')).isEqualTo('true');
	}
	@Test
	void runWhenConfigLocationHasUnknownFileExtensionFailsFast() {
		String location = 'classpath:application.unknown';
		assertThatIllegalStateException().isThrownBy(() -> this.application.run('--spring.config.location=' + location))
			.withMessageContaining('Unable to load config data')
			.withMessageContaining(location)
			.satisfies((ex) -> assertThat(ex.getCause()).hasMessageContaining('File extension is not known')
				.hasMessageContaining('it must end in "/"'));
	}
	@Test
	void runWhenConfigLocationHasOptionalMissingDirectoryContinuesToLoad() {
		String location = 'optional:classpath:application.unknown/';
		this.application.run('--spring.config.location=' + location);
	}
	@Test
	void runWhenConfigLocationHasNonOptionalMissingFileDirectoryThrowsResourceNotFoundException() {
		File location = new File(this.temp, 'application.unknown');
		assertThatExceptionOfType(ConfigDataLocationNotFoundException.class).isThrownBy(() -> this.application
			.run('--spring.config.location=' + StringUtils.cleanPath(location.getAbsolutePath()) + '/'));
	}
	@Test
	void runWhenConfigLocationHasNonOptionalMissingClasspathDirectoryThrowsLocationNotFoundException() {
		String location = 'classpath:application.unknown/';
		assertThatExceptionOfType(ConfigDataLocationNotFoundException.class)
			.isThrownBy(() -> this.application.run('--spring.config.location=' + location));
	}
	@Test
	void runWhenConfigLocationHasNonOptionalEmptyFileDirectoryDoesNotThrowException() {
		File location = new File(this.temp, 'application.empty');
		location.mkdirs();
		assertThatNoException().isThrownBy(() -> this.application
			.run('--spring.config.location=' + StringUtils.cleanPath(location.getAbsolutePath()) + '/'));
	}
	@Test
	void runWhenConfigLocationHasMandatoryDirectoryThatDoesntExistThrowsException() {
		assertThatExceptionOfType(ConfigDataLocationNotFoundException.class)
			.isThrownBy(() -> this.application.run('--spring.config.location=' + StringUtils.cleanPath('invalid/')));
	}
	@Test
	void runWhenConfigLocationHasNonOptionalEmptyFileDoesNotThrowException() throws IOException {
		File location = new File(this.temp, 'application.properties');
		FileCopyUtils.copy(new byte[0], location);
		assertThatNoException()
			.isThrownBy(() -> this.application.run('--spring.config.location=classpath:/application.properties,'
					+ StringUtils.cleanPath(location.getAbsolutePath())));
	}
	@Test
	void runWhenResolvedIsOptionalDoesNotThrowException() {
		ApplicationContext context = this.application.run('--spring.config.location=test:optionalresult');
		assertThat(context.getEnvironment().containsProperty('spring')).isFalse();
	}
	@Test
	void runWhenUsingInvalidPropertyThrowsException() {
		assertThatExceptionOfType(InvalidConfigDataPropertyException.class)
			.isThrownBy(() -> this.application.run('--spring.config.location=classpath:invalidproperty.properties'));
	}
	@Test
	void runWhenImportUsesPlaceholder() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:application-import-with-placeholder.properties');
		assertThat(context.getEnvironment().getProperty('my.value')).isEqualTo('iwasimported');
	}
	@Test
	void runWhenImportFromEarlierDocumentUsesPlaceholder() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:application-import-with-placeholder-in-document.properties');
		assertThat(context.getEnvironment().getProperty('my.value')).isEqualTo('iwasimported');
	}
	@Test // gh-26858
	void runWhenImportWithProfileVariantOrdersPropertySourcesCorrectly() {
		this.application.setAdditionalProfiles('dev');
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:application-import-with-profile-variant.properties');
		assertThat(context.getEnvironment().getProperty('my.value'))
			.isEqualTo('application-import-with-profile-variant-imported-dev');
	}
	@Test
	void runWhenImportWithProfileVariantAndDirectProfileImportOrdersPropertySourcesCorrectly() {
		this.application.setAdditionalProfiles('dev');
		ConfigurableApplicationContext context = this.application.run(
				'--spring.config.location=classpath:application-import-with-profile-variant-and-direct-profile-import.properties');
		assertThat(context.getEnvironment().getProperty('my.value'))
			.isEqualTo('application-import-with-profile-variant-imported-dev');
	}
	@Test
	void runWhenHasPropertyInProfileDocumentThrowsException() {
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.application.run(
				'--spring.config.location=classpath:application-import-with-placeholder-in-profile-document.properties'))
			.withCauseInstanceOf(InactiveConfigDataAccessException.class);
	}
	@Test // gh-29386
	void runWhenHasPropertyInEarlierProfileDocumentThrowsException() {
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.application.run(
				'--spring.config.location=classpath:application-import-with-placeholder-in-earlier-profile-document.properties'))
			.withCauseInstanceOf(InactiveConfigDataAccessException.class);
	}
	@Test // gh-29386
	void runWhenHasPropertyInEarlierDocumentLoads() {
		ConfigurableApplicationContext context = this.application.run(
				'--spring.config.location=classpath:application-import-with-placeholder-in-earlier-document.properties');
		assertThat(context.getEnvironment().getProperty('my.value'))
			.isEqualTo('application-import-with-placeholder-in-earlier-document-imported');
	}
	@Test
	void runWhenHasNonOptionalImportThrowsException() {
		assertThatExceptionOfType(ConfigDataResourceNotFoundException.class).isThrownBy(
				() -> this.application.run('--spring.config.location=classpath:missing-appplication.properties'));
	}
	@Test
	void runWhenHasNonOptionalImportAndIgnoreNotFoundPropertyDoesNotThrowException() {
		this.application.run('--spring.config.on-not-found=ignore',
				'--spring.config.location=classpath:missing-appplication.properties');
	}
	@Test
	void runWhenHasIncludedProfilesActivatesProfiles() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:application-include-profiles.properties');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactlyInAnyOrder('p1', 'p2', 'p3', 'p4',
				'p5');
	}
	@Test
	void runWhenHasIncludedProfilesWithPlaceholderActivatesProfiles() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:application-include-profiles-with-placeholder.properties');
		assertThat(context.getEnvironment().getActiveProfiles()).containsExactlyInAnyOrder('p1', 'p2', 'p3', 'p4',
				'p5');
	}
	@Test
	void runWhenHasIncludedProfilesWithProfileSpecificDocumentThrowsException() {
		assertThatExceptionOfType(InactiveConfigDataAccessException.class).isThrownBy(() -> this.application.run(
				'--spring.config.location=classpath:application-include-profiles-in-profile-specific-document.properties'));
	}
	@Test
	void runWhenHasIncludedProfilesWithListSyntaxWithProfileSpecificDocumentThrowsException() {
		assertThatExceptionOfType(InvalidConfigDataPropertyException.class).isThrownBy(() -> this.application.run(
				'--spring.config.name=application-include-profiles-list-in-profile-specific-file',
				'--spring.profiles.active=test'));
	}
	@Test
	void runWhenImportingIncludesParentOrigin() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=classpath:application-import-with-placeholder.properties');
		Binder binder = Binder.get(context.getEnvironment());
		List<ConfigurationProperty> properties = new ArrayList<>();
		BindHandler bindHandler = new BindHandler() {
			@Override
			public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context,
					Object result) {
				properties.add(context.getConfigurationProperty());
				return result;
			}
		};
		binder.bind('my.value', Bindable.of(String.class), bindHandler);
		assertThat(properties).hasSize(1);
		Origin origin = properties.get(0).getOrigin();
		assertThat(origin.toString()).contains('application-import-with-placeholder-imported');
		assertThat(origin.getParent().toString()).contains('application-import-with-placeholder');
	}
	@Test
	void runWhenHasWildcardLocationLoadsFromAllMatchingLocations() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.location=file:src/test/resources/config/*/', '--spring.config.name=testproperties');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.getProperty('first.property')).isEqualTo('apple');
		assertThat(environment.getProperty('second.property')).isEqualTo('ball');
	}
	@Test
	void runWhenOptionalWildcardLocationDoesNotExistDoesNotThrowException() {
		assertThatNoException().isThrownBy(() -> this.application
			.run('--spring.config.location=optional:file:src/test/resources/nonexistent/*/testproperties.properties'));
	}
	@Test
	void runWhenMandatoryWildcardLocationDoesNotExistThrowsException() {
		assertThatExceptionOfType(ConfigDataLocationNotFoundException.class).isThrownBy(() -> this.application
			.run('--spring.config.location=file:src/test/resources/nonexistent/*/testproperties.properties'));
	}
	@Test
	void runWhenMandatoryWildcardLocationHasEmptyFileDirectory() {
		assertThatNoException()
			.isThrownBy(() -> this.application.run('--spring.config.location=file:src/test/resources/config/*/'));
	}
	@Test
	void runWhenMandatoryWildcardLocationHasNoSubdirectories() {
		assertThatExceptionOfType(ConfigDataLocationNotFoundException.class)
			.isThrownBy(
					() -> this.application.run('--spring.config.location=file:src/test/resources/config/0-empty/*/'))
			.withMessage('Config data location "file:src/test/resources/config/0-empty/*/" contains no subdirectories');
	}
	@Test
	void runWhenHasMandatoryWildcardLocationThatDoesNotExist() {
		assertThatExceptionOfType(ConfigDataLocationNotFoundException.class)
			.isThrownBy(() -> this.application.run('--spring.config.location=file:invalid/*/'));
	}
	@Test
	void runWhenHasOptionalWildcardLocationThatDoesNotExistDoesNotThrow() {
		assertThatNoException()
			.isThrownBy(() -> this.application.run('--spring.config.location=optional:file:invalid/*/'));
	}
	@Test
	void runWhenOptionalWildcardLocationHasNoSubdirectoriesDoesNotThrow() {
		assertThatNoException().isThrownBy(() -> this.application
			.run('--spring.config.location=optional:file:src/test/resources/config/0-empty/*/'));
	}
	@Test // gh-24990
	void runWhenHasProfileSpecificFileWithActiveOnProfileProperty() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=application-activate-on-profile-in-profile-specific-file');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.getProperty('test1')).isEqualTo('test1');
		assertThat(environment.getProperty('test2')).isEqualTo('test2');
	}
	@Test // gh-26960
	void runWhenHasProfileSpecificImportWithImportImportsSecondProfileSpecificFile() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=application-profile-specific-import-with-import');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.containsProperty('application-profile-specific-import-with-import')).isTrue();
		assertThat(environment.containsProperty('application-profile-specific-import-with-import-p1')).isTrue();
		assertThat(environment.containsProperty('application-profile-specific-import-with-import-p2')).isFalse();
		assertThat(environment.containsProperty('application-profile-specific-import-with-import-import')).isTrue();
		assertThat(environment.containsProperty('application-profile-specific-import-with-import-import-p1')).isTrue();
		assertThat(environment.containsProperty('application-profile-specific-import-with-import-import-p2')).isTrue();
	}
	@Test // gh-26960
	void runWhenHasProfileSpecificImportWithCustomImportResolvesProfileSpecific() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=application-profile-specific-import-with-custom-import');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.containsProperty('test:boot')).isTrue();
		assertThat(environment.containsProperty('test:boot:ps')).isTrue();
	}
	@Test // gh-26593
	void runWhenHasFilesInRootAndConfigWithProfiles() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=file-in-root-and-config-with-profile', '--spring.profiles.active=p1,p2');
		ConfigurableEnvironment environment = context.getEnvironment();
		assertThat(environment.containsProperty('file-in-root-and-config-with-profile')).isTrue();
		assertThat(environment.containsProperty('file-in-root-and-config-with-profile-p1')).isTrue();
		assertThat(environment.containsProperty('file-in-root-and-config-with-profile-p2')).isTrue();
		assertThat(environment.containsProperty('config-file-in-root-and-config-with-profile')).isTrue();
		assertThat(environment.containsProperty('config-file-in-root-and-config-with-profile-p1')).isTrue();
		assertThat(environment.containsProperty('config-file-in-root-and-config-with-profile-p2')).isTrue();
		assertThat(environment.getProperty('v1')).isEqualTo('config-file-in-root-and-config-with-profile-p2');
		assertThat(environment.getProperty('v2')).isEqualTo('file-in-root-and-config-with-profile-p2');
	}
	private Condition<ConfigurableEnvironment> matchingPropertySource(final String sourceName) {
		return new Condition<>('environment containing property source ' + sourceName) {
			@Override
			public boolean matches(ConfigurableEnvironment value) {
				value.getPropertySources().forEach((ps) -> System.out.println(ps.getName()));
				return value.getPropertySources().contains(sourceName);
			}
		};
	}
	private void assertProfileExpression(String value, String... activeProfiles) {
		this.application.setAdditionalProfiles(activeProfiles);
		ConfigurableApplicationContext context = this.application.run('--spring.config.name=testprofileexpression',
				'--spring.config.location=classpath:configdata/profiles/');
		String property = context.getEnvironment().getProperty('my.property');
		assertThat(property).isEqualTo(value);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
	static class LocationResolver implements ConfigDataLocationResolver<TestConfigDataResource> {
		@Override
		public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
			return location.hasPrefix('test:');
		}
		@Override
		public List<TestConfigDataResource> resolve(ConfigDataLocationResolverContext context,
				ConfigDataLocation location)
				throws ConfigDataLocationNotFoundException, ConfigDataResourceNotFoundException {
			return Collections.singletonList(new TestConfigDataResource(location, false));
		}
		@Override
		public List<TestConfigDataResource> resolveProfileSpecific(ConfigDataLocationResolverContext context,
				ConfigDataLocation location, org.springframework.boot.context.config.Profiles profiles)
				throws ConfigDataLocationNotFoundException {
			return Collections.singletonList(new TestConfigDataResource(location, true));
		}
	}
	static class Loader implements ConfigDataLoader<TestConfigDataResource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, TestConfigDataResource resource)
				throws IOException, ConfigDataResourceNotFoundException {
			if (resource.isOptional()) {
				return null;
			}
			Map<String, Object> map = new LinkedHashMap<>();
			if (!resource.isProfileSpecific()) {
				map.put('spring', 'boot');
			}
			String suffix = (!resource.isProfileSpecific()) ? '' : ':ps';
			map.put(resource + suffix, 'true');
			MapPropertySource propertySource = new MapPropertySource('loaded' + suffix, map);
			return new ConfigData(Collections.singleton(propertySource));
		}
	}
	static class TestConfigDataResource extends ConfigDataResource {
		private final ConfigDataLocation location;
		private final boolean profileSpecific;
		TestConfigDataResource(ConfigDataLocation location, boolean profileSpecific) {
			super(location.toString().contains('optionalresult'));
			this.location = location;
			this.profileSpecific = profileSpecific;
		}
		boolean isProfileSpecific() {
			return this.profileSpecific;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			TestConfigDataResource other = (TestConfigDataResource) obj;
			return ObjectUtils.nullSafeEquals(this.location, other.location)
					&& this.profileSpecific == other.profileSpecific;
		}
		@Override
		public int hashCode() {
			return 0;
		}
		@Override
		public String toString() {
			return this.location.toString();
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationBindHandlerTests {
	private static final Bindable<ConfigDataLocation[]> ARRAY = Bindable.of(ConfigDataLocation[].class);
	private static final Bindable<ValueObject> VALUE_OBJECT = Bindable.of(ValueObject.class);
	private final ConfigDataLocationBindHandler handler = new ConfigDataLocationBindHandler();
	@Test
	void bindToArrayFromCommaStringPropertySetsOrigin() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('locations', 'a,b,c');
		Binder binder = new Binder(source);
		ConfigDataLocation[] bound = binder.bind('locations', ARRAY, this.handler).get();
		String expectedLocation = '\'locations\' from property source \'source\'';
		assertThat(bound[0]).hasToString('a');
		assertThat(bound[0].getOrigin()).hasToString(expectedLocation);
		assertThat(bound[1]).hasToString('b');
		assertThat(bound[1].getOrigin()).hasToString(expectedLocation);
		assertThat(bound[2]).hasToString('c');
		assertThat(bound[2].getOrigin()).hasToString(expectedLocation);
	}
	@Test
	void bindToArrayFromCommaStringPropertyIgnoresEmptyElements() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('locations', ',a,,b,c,');
		Binder binder = new Binder(source);
		ConfigDataLocation[] bound = binder.bind('locations', ARRAY, this.handler).get();
		String expectedLocation = '\'locations\' from property source \'source\'';
		assertThat(bound[0]).hasToString('a');
		assertThat(bound[0].getOrigin()).hasToString(expectedLocation);
		assertThat(bound[1]).hasToString('b');
		assertThat(bound[1].getOrigin()).hasToString(expectedLocation);
		assertThat(bound[2]).hasToString('c');
		assertThat(bound[2].getOrigin()).hasToString(expectedLocation);
	}
	@Test
	void bindToArrayFromIndexedPropertiesSetsOrigin() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('locations[0]', 'a');
		source.put('locations[1]', 'b');
		source.put('locations[2]', 'c');
		Binder binder = new Binder(source);
		ConfigDataLocation[] bound = binder.bind('locations', ARRAY, this.handler).get();
		assertThat(bound[0]).hasToString('a');
		assertThat(bound[0].getOrigin()).hasToString('\'locations[0]\' from property source \'source\'');
		assertThat(bound[1]).hasToString('b');
		assertThat(bound[1].getOrigin()).hasToString('\'locations[1]\' from property source \'source\'');
		assertThat(bound[2]).hasToString('c');
		assertThat(bound[2].getOrigin()).hasToString('\'locations[2]\' from property source \'source\'');
	}
	@Test
	void bindToValueObjectFromCommaStringPropertySetsOrigin() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('test.locations', 'a,b,c');
		Binder binder = new Binder(source);
		ValueObject bound = binder.bind('test', VALUE_OBJECT, this.handler).get();
		String expectedLocation = '\'test.locations\' from property source \'source\'';
		assertThat(bound.getLocation(0)).hasToString('a');
		assertThat(bound.getLocation(0).getOrigin()).hasToString(expectedLocation);
		assertThat(bound.getLocation(1)).hasToString('b');
		assertThat(bound.getLocation(1).getOrigin()).hasToString(expectedLocation);
		assertThat(bound.getLocation(2)).hasToString('c');
		assertThat(bound.getLocation(2).getOrigin()).hasToString(expectedLocation);
	}
	@Test
	void bindToValueObjectFromCommaStringPropertyIgnoresEmptyElements() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('test.locations', ',a,b,,c,');
		Binder binder = new Binder(source);
		ValueObject bound = binder.bind('test', VALUE_OBJECT, this.handler).get();
		String expectedLocation = '\'test.locations\' from property source \'source\'';
		assertThat(bound.getLocation(0)).hasToString('a');
		assertThat(bound.getLocation(0).getOrigin()).hasToString(expectedLocation);
		assertThat(bound.getLocation(1)).hasToString('b');
		assertThat(bound.getLocation(1).getOrigin()).hasToString(expectedLocation);
		assertThat(bound.getLocation(2)).hasToString('c');
		assertThat(bound.getLocation(2).getOrigin()).hasToString(expectedLocation);
	}
	@Test
	void bindToValueObjectFromIndexedPropertiesSetsOrigin() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('test.locations[0]', 'a');
		source.put('test.locations[1]', 'b');
		source.put('test.locations[2]', 'c');
		Binder binder = new Binder(source);
		ValueObject bound = binder.bind('test', VALUE_OBJECT, this.handler).get();
		assertThat(bound.getLocation(0)).hasToString('a');
		assertThat(bound.getLocation(0).getOrigin())
			.hasToString('\'test.locations[0]\' from property source \'source\'');
		assertThat(bound.getLocation(1)).hasToString('b');
		assertThat(bound.getLocation(1).getOrigin())
			.hasToString('\'test.locations[1]\' from property source \'source\'');
		assertThat(bound.getLocation(2)).hasToString('c');
		assertThat(bound.getLocation(2).getOrigin())
			.hasToString('\'test.locations[2]\' from property source \'source\'');
	}
	static class ValueObject {
		private final List<ConfigDataLocation> locations;
		ValueObject(List<ConfigDataLocation> locations) {
			this.locations = locations;
		}
		ConfigDataLocation getLocation(int index) {
			return this.locations.get(index);
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class TestConfigDataBootstrap {
	static class LocationResolver implements ConfigDataLocationResolver<Resource> {
		@Override
		public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
			context.getBootstrapContext().get(Binder.class); // gh-24559
			return location.hasPrefix('testbootstrap:');
		}
		@Override
		public List<Resource> resolve(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
			context.getBootstrapContext()
				.registerIfAbsent(ResolverHelper.class, InstanceSupplier.from(() -> new ResolverHelper(location)));
			ResolverHelper helper = context.getBootstrapContext().get(ResolverHelper.class);
			return Collections.singletonList(new Resource(helper));
		}
	}
	static class Loader implements ConfigDataLoader<Resource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, Resource location) throws IOException {
			context.getBootstrapContext()
				.registerIfAbsent(LoaderHelper.class,
						(bootstrapContext) -> new LoaderHelper(location, () -> bootstrapContext.get(Binder.class)));
			LoaderHelper helper = context.getBootstrapContext().get(LoaderHelper.class);
			context.getBootstrapContext().addCloseListener(helper);
			return new ConfigData(
					Collections.singleton(new MapPropertySource('loaded', Collections.singletonMap('test', 'test'))));
		}
	}
	static class Resource extends ConfigDataResource {
		private final ResolverHelper resolverHelper;
		Resource(ResolverHelper resolverHelper) {
			this.resolverHelper = resolverHelper;
		}
		@Override
		public String toString() {
			return 'test';
		}
		ResolverHelper getResolverHelper() {
			return this.resolverHelper;
		}
	}
	static class ResolverHelper {
		private final ConfigDataLocation location;
		ResolverHelper(ConfigDataLocation location) {
			this.location = location;
		}
		ConfigDataLocation getLocation() {
			return this.location;
		}
	}
	static class LoaderHelper implements ApplicationListener<BootstrapContextClosedEvent> {
		private final Resource location;
		private final Supplier<Binder> binder;
		LoaderHelper(Resource location, Supplier<Binder> binder) {
			this.location = location;
			this.binder = binder;
		}
		Resource getLocation() {
			return this.location;
		}
		String getBound() {
			return this.binder.get().bind('myprop', String.class).orElse(null);
		}
		String getProfileBound() {
			return this.binder.get().bind('myprofileprop', String.class).orElse(null);
		}
		@Override
		public void onApplicationEvent(BootstrapContextClosedEvent event) {
			event.getApplicationContext().getBeanFactory().registerSingleton('loaderHelper', this);
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class AnsiOutputApplicationListenerTests {
	private ConfigurableApplicationContext context;
	@BeforeEach
	void resetAnsi() {
		AnsiOutput.setEnabled(Enabled.DETECT);
	}
	@AfterEach
	void cleanUp() {
		resetAnsi();
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void enabled() {
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		Map<String, Object> props = new HashMap<>();
		props.put('spring.output.ansi.enabled', 'ALWAYS');
		application.setDefaultProperties(props);
		this.context = application.run();
		assertThat(AnsiOutputEnabledValue.get()).isEqualTo(Enabled.ALWAYS);
	}
	@Test
	void disabled() {
		SpringApplication application = new SpringApplication(Config.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		Map<String, Object> props = new HashMap<>();
		props.put('spring.output.ansi.enabled', 'never');
		application.setDefaultProperties(props);
		this.context = application.run();
		assertThat(AnsiOutputEnabledValue.get()).isEqualTo(Enabled.NEVER);
	}
	@Test
	void disabledViaApplicationProperties() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(environment, 'spring.config.name=ansi');
		SpringApplication application = new SpringApplication(Config.class);
		application.setEnvironment(environment);
		application.setWebApplicationType(WebApplicationType.NONE);
		this.context = application.run();
		assertThat(AnsiOutputEnabledValue.get()).isEqualTo(Enabled.NEVER);
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationRuntimeHintsTests {
	@Test
	void registerWithDefaultSettings() {
		RuntimeHints hints = new RuntimeHints();
		new TestConfigDataLocationRuntimeHints().registerHints(hints, null);
		assertThat(hints.resources().resourcePatternHints()).singleElement()
			.satisfies(includes('application*.properties', 'application*.xml', 'application*.yaml', 'application*.yml',
					'config/application*.properties', 'config/application*.xml', 'config/application*.yaml',
					'config/application*.yml'));
	}
	@Test
	void registerWithCustomName() {
		RuntimeHints hints = new RuntimeHints();
		new TestConfigDataLocationRuntimeHints() {
			@Override
			protected List<String> getFileNames(ClassLoader classLoader) {
				return List.of('test');
			}
		}.registerHints(hints, null);
		assertThat(hints.resources().resourcePatternHints()).singleElement()
			.satisfies(includes('test*.properties', 'test*.xml', 'test*.yaml', 'test*.yml', 'config/test*.properties',
					'config/test*.xml', 'config/test*.yaml', 'config/test*.yml'));
	}
	@Test
	void registerWithCustomLocation() {
		RuntimeHints hints = new RuntimeHints();
		new TestConfigDataLocationRuntimeHints() {
			@Override
			protected List<String> getLocations(ClassLoader classLoader) {
				return List.of('config/');
			}
		}.registerHints(hints, null);
		assertThat(hints.resources().resourcePatternHints()).singleElement()
			.satisfies(includes('config/application*.properties', 'config/application*.xml', 'config/application*.yaml',
					'config/application*.yml'));
	}
	@Test
	void registerWithCustomExtension() {
		RuntimeHints hints = new RuntimeHints();
		new ConfigDataLocationRuntimeHints() {
			@Override
			protected List<String> getExtensions(ClassLoader classLoader) {
				return List.of('.conf');
			}
		}.registerHints(hints, null);
		assertThat(hints.resources().resourcePatternHints()).singleElement()
			.satisfies(includes('application*.conf', 'config/application*.conf'));
	}
	@Test
	void registerWithUnknownLocationDoesNotAddHint() {
		RuntimeHints hints = new RuntimeHints();
		new ConfigDataLocationRuntimeHints() {
			@Override
			protected List<String> getLocations(ClassLoader classLoader) {
				return List.of(UUID.randomUUID().toString());
			}
		}.registerHints(hints, null);
		assertThat(hints.resources().resourcePatternHints()).isEmpty();
	}
	private Consumer<ResourcePatternHints> includes(String... patterns) {
		return (hint) -> {
			assertThat(hint.getIncludes().stream().map(ResourcePatternHint::getPattern)).contains(patterns);
			assertThat(hint.getExcludes()).isEmpty();
		};
	}
	static class TestConfigDataLocationRuntimeHints extends ConfigDataLocationRuntimeHints {
		private final MockSpringFactoriesLoader springFactoriesLoader;
		TestConfigDataLocationRuntimeHints(MockSpringFactoriesLoader springFactoriesLoader) {
			this.springFactoriesLoader = springFactoriesLoader;
		}
		TestConfigDataLocationRuntimeHints() {
			this(springFactoriesLoader());
		}
		private static MockSpringFactoriesLoader springFactoriesLoader() {
			MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
			springFactoriesLoader.add(PropertySourceLoader.class, PropertiesPropertySourceLoader.class,
					YamlPropertySourceLoader.class);
			return springFactoriesLoader;
		}
		@Override
		protected SpringFactoriesLoader getSpringFactoriesLoader(ClassLoader classLoader) {
			return this.springFactoriesLoader;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationTests {
	@Test
	void isOptionalWhenNotPrefixedWithOptionalReturnsFalse() {
		ConfigDataLocation location = ConfigDataLocation.of('test');
		assertThat(location.isOptional()).isFalse();
	}
	@Test
	void isOptionalWhenPrefixedWithOptionalReturnsTrue() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:test');
		assertThat(location.isOptional()).isTrue();
	}
	@Test
	void getValueWhenNotPrefixedWithOptionalReturnsValue() {
		ConfigDataLocation location = ConfigDataLocation.of('test');
		assertThat(location.getValue()).isEqualTo('test');
	}
	@Test
	void getValueWhenPrefixedWithOptionalReturnsValueWithoutPrefix() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:test');
		assertThat(location.getValue()).isEqualTo('test');
	}
	@Test
	void hasPrefixWhenPrefixedReturnsTrue() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:test:path');
		assertThat(location.hasPrefix('test:')).isTrue();
	}
	@Test
	void hasPrefixWhenNotPrefixedReturnsFalse() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:file:path');
		assertThat(location.hasPrefix('test:')).isFalse();
	}
	@Test
	void getNonPrefixedValueWhenPrefixedReturnsNonPrefixed() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:test:path');
		assertThat(location.getNonPrefixedValue('test:')).isEqualTo('path');
	}
	@Test
	void getNonPrefixedValueWhenNotPrefixedReturnsOriginalValue() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:file:path');
		assertThat(location.getNonPrefixedValue('test:')).isEqualTo('file:path');
	}
	@Test
	void getOriginWhenNoOriginReturnsNull() {
		ConfigDataLocation location = ConfigDataLocation.of('test');
		assertThat(location.getOrigin()).isNull();
	}
	@Test
	void getOriginWhenWithOriginReturnsOrigin() {
		Origin origin = mock(Origin.class);
		ConfigDataLocation location = ConfigDataLocation.of('test').withOrigin(origin);
		assertThat(location.getOrigin()).isSameAs(origin);
	}
	@Test
	void equalsAndHashCode() {
		ConfigDataLocation l1 = ConfigDataLocation.of('a');
		ConfigDataLocation l2 = ConfigDataLocation.of('a');
		ConfigDataLocation l3 = ConfigDataLocation.of('optional:a');
		ConfigDataLocation l4 = ConfigDataLocation.of('b');
		assertThat(l1).hasSameHashCodeAs(l2).hasSameHashCodeAs(l3);
		assertThat(l1).isEqualTo(l2).isEqualTo(l3).isNotEqualTo(l4);
	}
	@Test
	void toStringReturnsOriginalString() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:test');
		assertThat(location).hasToString('optional:test');
	}
	@Test
	void withOriginSetsOrigin() {
		Origin origin = mock(Origin.class);
		ConfigDataLocation location = ConfigDataLocation.of('test').withOrigin(origin);
		assertThat(location.getOrigin()).isSameAs(origin);
	}
	@Test
	void ofWhenNullValueReturnsNull() {
		assertThat(ConfigDataLocation.of(null)).isNull();
	}
	@Test
	void ofWhenEmptyValueReturnsNull() {
		assertThat(ConfigDataLocation.of('')).isNull();
	}
	@Test
	void ofWhenEmptyOptionalValueReturnsNull() {
		assertThat(ConfigDataLocation.of('optional:')).isNull();
	}
	@Test
	void ofReturnsLocation() {
		assertThat(ConfigDataLocation.of('test')).hasToString('test');
	}
	@Test
	void splitWhenNoSemiColonReturnsSingleElement() {
		ConfigDataLocation location = ConfigDataLocation.of('test');
		ConfigDataLocation[] split = location.split();
		assertThat(split).containsExactly(ConfigDataLocation.of('test'));
	}
	@Test
	void splitWhenSemiColonReturnsElements() {
		ConfigDataLocation location = ConfigDataLocation.of('one;two;three');
		ConfigDataLocation[] split = location.split();
		assertThat(split).containsExactly(ConfigDataLocation.of('one'), ConfigDataLocation.of('two'),
				ConfigDataLocation.of('three'));
	}
	@Test
	void splitOnCharReturnsElements() {
		ConfigDataLocation location = ConfigDataLocation.of('one::two::three');
		ConfigDataLocation[] split = location.split('::');
		assertThat(split).containsExactly(ConfigDataLocation.of('one'), ConfigDataLocation.of('two'),
				ConfigDataLocation.of('three'));
	}
	@Test
	void splitWhenHasOriginReturnsElementsWithOriginSet() {
		Origin origin = mock(Origin.class);
		ConfigDataLocation location = ConfigDataLocation.of('a;b').withOrigin(origin);
		ConfigDataLocation[] split = location.split();
		assertThat(split[0].getOrigin()).isEqualTo(origin);
		assertThat(split[1].getOrigin()).isEqualTo(origin);
	}
}
/*
package org.springframework.boot.context.config;
/**
class TestPropertySourceLoader2 implements PropertySourceLoader {
	@Override
	public String[] getFileExtensions() {
		return new String[] { 'custom' };
	}
	@Override
	public List<PropertySource<?>> load(String name, Resource resource) throws IOException {
		Map<String, Object> map = Collections.singletonMap('customloader2', 'true');
		return Collections.singletonList(new MapPropertySource(name, map));
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentContributorTests {
	private static final ConfigDataLocation TEST_LOCATION = ConfigDataLocation.of('test');
	private final ConfigDataActivationContext activationContext = new ConfigDataActivationContext(
			CloudPlatform.KUBERNETES, null);
	private final ConversionService conversionService = DefaultConversionService.getSharedInstance();
	@Test
	void getKindReturnsKind() {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(TEST_LOCATION,
				this.conversionService);
		assertThat(contributor.getKind()).isEqualTo(Kind.INITIAL_IMPORT);
	}
	@Test
	void isActiveWhenPropertiesIsNullReturnsTrue() {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(TEST_LOCATION,
				this.conversionService);
		assertThat(contributor.isActive(null)).isTrue();
	}
	@Test
	void isActiveWhenPropertiesIsActiveReturnsTrue() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.activate.on-cloud-platform', 'kubernetes');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.isActive(this.activationContext)).isTrue();
	}
	@Test
	void isActiveWhenPropertiesIsNotActiveReturnsFalse() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.activate.on-cloud-platform', 'heroku');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.isActive(this.activationContext)).isFalse();
	}
	@Test
	void getLocationReturnsLocation() {
		ConfigData configData = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigDataResource resource = mock(ConfigDataResource.class);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofUnboundImport(TEST_LOCATION,
				resource, false, configData, 0, this.conversionService);
		assertThat(contributor.getResource()).isSameAs(resource);
	}
	@Test
	void getPropertySourceReturnsPropertySource() {
		MockPropertySource propertySource = new MockPropertySource();
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource,
				this.conversionService);
		assertThat(contributor.getPropertySource()).isSameAs(propertySource);
	}
	@Test
	void getConfigurationPropertySourceReturnsAdaptedPropertySource() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring', 'boot');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofUnboundImport(null, null,
				false, configData, 0, this.conversionService);
		assertThat(contributor.getConfigurationPropertySource()
			.getConfigurationProperty(ConfigurationPropertyName.of('spring'))
			.getValue()).isEqualTo('boot');
	}
	@Test
	void getImportsWhenPropertiesIsNullReturnsEmptyList() {
		ConfigData configData = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.getImports()).isEmpty();
	}
	@Test
	void getImportsReturnsImports() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'spring,boot');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.getImports()).containsExactly(ConfigDataLocation.of('spring'),
				ConfigDataLocation.of('boot'));
	}
	@Test
	void getImportsIgnoresEmptyElements() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'spring,,boot,');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.getImports()).containsExactly(ConfigDataLocation.of('spring'),
				ConfigDataLocation.of('boot'));
	}
	@Test
	void hasUnprocessedImportsWhenNoImportsReturnsFalse() {
		ConfigData configData = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.hasUnprocessedImports(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isFalse();
	}
	@Test
	void hasUnprocessedImportsWhenHasNoChildrenForPhaseReturnsTrue() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'springboot');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.hasUnprocessedImports(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isTrue();
	}
	@Test
	void hasUnprocessedImportsWhenHasChildrenForPhaseReturnsFalse() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'springboot');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		ConfigData childConfigData = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigDataEnvironmentContributor childContributor = createBoundContributor(null, childConfigData, 0);
		ConfigDataEnvironmentContributor withChildren = contributor.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION,
				Collections.singletonList(childContributor));
		assertThat(withChildren.hasUnprocessedImports(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isFalse();
		assertThat(withChildren.hasUnprocessedImports(ImportPhase.AFTER_PROFILE_ACTIVATION)).isTrue();
	}
	@Test
	void getChildrenWhenHasNoChildrenReturnsEmptyList() {
		ConfigData configData = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		assertThat(contributor.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isEmpty();
		assertThat(contributor.getChildren(ImportPhase.AFTER_PROFILE_ACTIVATION)).isEmpty();
	}
	@Test
	void getChildrenWhenHasChildrenReturnsChildren() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'springboot');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0);
		ConfigData childConfigData = new ConfigData(Collections.singleton(new MockPropertySource()));
		ConfigDataEnvironmentContributor childContributor = createBoundContributor(null, childConfigData, 0);
		ConfigDataEnvironmentContributor withChildren = contributor.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION,
				Collections.singletonList(childContributor));
		assertThat(withChildren.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).containsExactly(childContributor);
		assertThat(withChildren.getChildren(ImportPhase.AFTER_PROFILE_ACTIVATION)).isEmpty();
	}
	@Test
	void streamReturnsStream() {
		ConfigDataEnvironmentContributor contributor = createBoundContributor('a');
		Stream<String> stream = contributor.stream().map(this::getLocationName);
		assertThat(stream).containsExactly('a');
	}
	@Test
	void iteratorWhenSingleContributorReturnsSingletonIterator() {
		ConfigDataEnvironmentContributor contributor = createBoundContributor('a');
		assertThat(asLocationsList(contributor.iterator())).containsExactly('a');
	}
	@Test
	void iteratorWhenTypicalStructureReturnsCorrectlyOrderedIterator() {
		ConfigDataEnvironmentContributor fileApplication = createBoundContributor('file:application.properties');
		ConfigDataEnvironmentContributor fileProfile = createBoundContributor('file:application-profile.properties');
		ConfigDataEnvironmentContributor fileImports = createBoundContributor('file:./');
		fileImports = fileImports.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION,
				Collections.singletonList(fileApplication));
		fileImports = fileImports.withChildren(ImportPhase.AFTER_PROFILE_ACTIVATION,
				Collections.singletonList(fileProfile));
		ConfigDataEnvironmentContributor classpathApplication = createBoundContributor(
				'classpath:application.properties');
		ConfigDataEnvironmentContributor classpathProfile = createBoundContributor(
				'classpath:application-profile.properties');
		ConfigDataEnvironmentContributor classpathImports = createBoundContributor('classpath:/');
		classpathImports = classpathImports.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION,
				Collections.singletonList(classpathApplication));
		classpathImports = classpathImports.withChildren(ImportPhase.AFTER_PROFILE_ACTIVATION,
				Collections.singletonList(classpathProfile));
		ConfigDataEnvironmentContributor root = createBoundContributor('root');
		root = root.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION, Arrays.asList(fileImports, classpathImports));
		assertThat(asLocationsList(root.iterator())).containsExactly('file:application-profile.properties',
				'file:application.properties', 'file:./', 'classpath:application-profile.properties',
				'classpath:application.properties', 'classpath:/', 'root');
	}
	@Test
	void withChildrenReturnsNewInstanceWithChildren() {
		ConfigDataEnvironmentContributor root = createBoundContributor('root');
		ConfigDataEnvironmentContributor child = createBoundContributor('child');
		ConfigDataEnvironmentContributor withChildren = root.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION,
				Collections.singletonList(child));
		assertThat(root.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isEmpty();
		assertThat(withChildren.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).containsExactly(child);
	}
	@Test
	void withChildrenAfterProfileActivationMovesProfileSpecificChildren() {
		ConfigDataEnvironmentContributor root = createBoundContributor('root');
		ConfigDataEnvironmentContributor child1 = createBoundContributor('child1');
		ConfigDataEnvironmentContributor grandchild = createBoundContributor(new TestResource('grandchild'),
				new ConfigData(Collections.singleton(new MockPropertySource()),
						PropertySourceOptions.always(Option.PROFILE_SPECIFIC)),
				0);
		child1 = child1.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION, Collections.singletonList(grandchild));
		root = root.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION, Collections.singletonList(child1));
		ConfigDataEnvironmentContributor child2 = createBoundContributor('child2');
		root = root.withChildren(ImportPhase.AFTER_PROFILE_ACTIVATION, Collections.singletonList(child2));
		assertThat(asLocationsList(root.iterator())).containsExactly('grandchild', 'child2', 'child1', 'root');
	}
	@Test
	void withReplacementReplacesChild() {
		ConfigDataEnvironmentContributor root = createBoundContributor('root');
		ConfigDataEnvironmentContributor child = createBoundContributor('child');
		ConfigDataEnvironmentContributor grandchild = createBoundContributor('grandchild');
		child = child.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION, Collections.singletonList(grandchild));
		root = root.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION, Collections.singletonList(child));
		ConfigDataEnvironmentContributor updated = createBoundContributor('updated');
		ConfigDataEnvironmentContributor withReplacement = root.withReplacement(grandchild, updated);
		assertThat(asLocationsList(root.iterator())).containsExactly('grandchild', 'child', 'root');
		assertThat(asLocationsList(withReplacement.iterator())).containsExactly('updated', 'child', 'root');
	}
	@Test
	void ofCreatesRootContributor() {
		ConfigDataEnvironmentContributor one = createBoundContributor('one');
		ConfigDataEnvironmentContributor two = createBoundContributor('two');
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.of(Arrays.asList(one, two),
				this.conversionService);
		assertThat(contributor.getKind()).isEqualTo(Kind.ROOT);
		assertThat(contributor.getResource()).isNull();
		assertThat(contributor.getImports()).isEmpty();
		assertThat(contributor.isActive(this.activationContext)).isTrue();
		assertThat(contributor.getPropertySource()).isNull();
		assertThat(contributor.getConfigurationPropertySource()).isNull();
		assertThat(contributor.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).containsExactly(one, two);
	}
	@Test
	void ofInitialImportCreatedInitialImportContributor() {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(TEST_LOCATION,
				this.conversionService);
		assertThat(contributor.getKind()).isEqualTo(Kind.INITIAL_IMPORT);
		assertThat(contributor.getResource()).isNull();
		assertThat(contributor.getImports()).containsExactly(TEST_LOCATION);
		assertThat(contributor.isActive(this.activationContext)).isTrue();
		assertThat(contributor.getPropertySource()).isNull();
		assertThat(contributor.getConfigurationPropertySource()).isNull();
		assertThat(contributor.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isEmpty();
	}
	@Test
	void ofExistingCreatesExistingContributor() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'test');
		propertySource.setProperty('spring.config.activate.on-cloud-platform', 'cloudfoundry');
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource,
				this.conversionService);
		assertThat(contributor.getKind()).isEqualTo(Kind.EXISTING);
		assertThat(contributor.getResource()).isNull();
		assertThat(contributor.getImports()).isEmpty(); // Properties must not be bound
		assertThat(contributor.isActive(this.activationContext)).isTrue();
		assertThat(contributor.getPropertySource()).isEqualTo(propertySource);
		assertThat(contributor.getConfigurationPropertySource()).isNotNull();
		assertThat(contributor.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isEmpty();
	}
	@Test
	void ofUnboundImportCreatesImportedContributor() {
		TestResource resource = new TestResource('test');
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'test');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofUnboundImport(TEST_LOCATION,
				resource, false, configData, 0, this.conversionService);
		assertThat(contributor.getKind()).isEqualTo(Kind.UNBOUND_IMPORT);
		assertThat(contributor.getResource()).isSameAs(resource);
		assertThat(contributor.getImports()).isEmpty();
		assertThat(contributor.isActive(this.activationContext)).isFalse();
		assertThat(contributor.getPropertySource()).isEqualTo(propertySource);
		assertThat(contributor.getConfigurationPropertySource()).isNotNull();
		assertThat(contributor.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isEmpty();
	}
	@Test
	void bindCreatesImportedContributor() {
		TestResource resource = new TestResource('test');
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'test');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource));
		ConfigDataEnvironmentContributor contributor = createBoundContributor(resource, configData, 0);
		assertThat(contributor.getKind()).isEqualTo(Kind.BOUND_IMPORT);
		assertThat(contributor.getResource()).isSameAs(resource);
		assertThat(contributor.getImports()).containsExactly(TEST_LOCATION);
		assertThat(contributor.isActive(this.activationContext)).isTrue();
		assertThat(contributor.getPropertySource()).isEqualTo(propertySource);
		assertThat(contributor.getConfigurationPropertySource()).isNotNull();
		assertThat(contributor.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isEmpty();
	}
	@Test
	void bindWhenConfigDataHasIgnoreImportsOptionsCreatesImportedContributorWithoutImports() {
		TestResource resource = new TestResource('test');
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.config.import', 'test');
		ConfigData configData = new ConfigData(Collections.singleton(propertySource), ConfigData.Option.IGNORE_IMPORTS);
		ConfigDataEnvironmentContributor contributor = createBoundContributor(resource, configData, 0);
		assertThat(contributor.getKind()).isEqualTo(Kind.BOUND_IMPORT);
		assertThat(contributor.getResource()).isSameAs(resource);
		assertThat(contributor.getImports()).isEmpty();
		assertThat(contributor.isActive(this.activationContext)).isTrue();
		assertThat(contributor.getPropertySource()).isEqualTo(propertySource);
		assertThat(contributor.getConfigurationPropertySource()).isNotNull();
		assertThat(contributor.getChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isEmpty();
	}
	@Test // gh-25029
	void withBoundPropertiesWhenIgnoringImportsAndNothingBound() {
		TestResource resource = new TestResource('a');
		ConfigData configData = new ConfigData(Collections.singleton(new MockPropertySource()), Option.IGNORE_IMPORTS);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofUnboundImport(TEST_LOCATION,
				resource, false, configData, 0, this.conversionService);
		ConfigDataEnvironmentContributor bound = contributor.withBoundProperties(Collections.singleton(contributor),
				null);
		assertThat(bound).isNotNull();
	}
	private ConfigDataEnvironmentContributor createBoundContributor(String location) {
		return createBoundContributor(new TestResource(location),
				new ConfigData(Collections.singleton(new MockPropertySource())), 0);
	}
	private ConfigDataEnvironmentContributor createBoundContributor(ConfigDataResource resource, ConfigData configData,
			int propertySourceIndex) {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofUnboundImport(TEST_LOCATION,
				resource, false, configData, propertySourceIndex, this.conversionService);
		return contributor.withBoundProperties(Collections.singleton(contributor), null);
	}
	private List<String> asLocationsList(Iterator<ConfigDataEnvironmentContributor> iterator) {
		List<String> list = new ArrayList<>();
		iterator.forEachRemaining((contributor) -> list.add(getLocationName(contributor)));
		return list;
	}
	private String getLocationName(ConfigDataEnvironmentContributor contributor) {
		return contributor.getResource().toString();
	}
	static class TestResource extends ConfigDataResource {
		private final String location;
		TestResource(String location) {
			this.location = location;
		}
		@Override
		public String toString() {
			return this.location;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataActivationContextTests {
	@Test
	void getCloudPlatformWhenCloudPropertyNotPresentDeducesCloudPlatform() {
		Environment environment = new MockEnvironment();
		Binder binder = Binder.get(environment);
		ConfigDataActivationContext context = new ConfigDataActivationContext(environment, binder);
		assertThat(context.getCloudPlatform()).isNull();
	}
	@Test
	void getCloudPlatformWhenCloudPropertyInEnvironmentDeducesCloudPlatform() {
		MockEnvironment environment = createKubernetesEnvironment();
		Binder binder = Binder.get(environment);
		ConfigDataActivationContext context = new ConfigDataActivationContext(environment, binder);
		assertThat(context.getCloudPlatform()).isEqualTo(CloudPlatform.KUBERNETES);
	}
	@Test
	void getCloudPlatformWhenCloudPropertyHasBeenContributedDuringInitialLoadDeducesCloudPlatform() {
		Environment environment = createKubernetesEnvironment();
		Binder binder = new Binder(
				new MapConfigurationPropertySource(Collections.singletonMap('spring.main.cloud-platform', 'HEROKU')));
		ConfigDataActivationContext context = new ConfigDataActivationContext(environment, binder);
		assertThat(context.getCloudPlatform()).isEqualTo(CloudPlatform.HEROKU);
	}
	@Test
	void getProfilesWhenWithoutProfilesReturnsNull() {
		Environment environment = new MockEnvironment();
		Binder binder = Binder.get(environment);
		ConfigDataActivationContext context = new ConfigDataActivationContext(environment, binder);
		assertThat(context.getProfiles()).isNull();
	}
	@Test
	void getProfilesWhenWithProfilesReturnsProfiles() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		Binder binder = Binder.get(environment);
		ConfigDataActivationContext context = new ConfigDataActivationContext(environment, binder);
		Profiles profiles = new Profiles(environment, binder, null);
		context = context.withProfiles(profiles);
		assertThat(context.getProfiles()).isEqualTo(profiles);
	}
	private MockEnvironment createKubernetesEnvironment() {
		MockEnvironment environment = new MockEnvironment();
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('KUBERNETES_SERVICE_HOST', 'host');
		map.put('KUBERNETES_SERVICE_PORT', 'port');
		PropertySource<?> propertySource = new MapPropertySource(
				StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, map);
		environment.getPropertySources().addLast(propertySource);
		return environment;
	}
}
/*
package org.springframework.boot.context.config;
/**
@ExtendWith(MockitoExtension.class)
class ConfigDataEnvironmentContributorsTests {
	private static final ConfigDataLocation LOCATION_1 = ConfigDataLocation.of('location1');
	private static final ConfigDataLocation LOCATION_2 = ConfigDataLocation.of('location2');
	private final DeferredLogFactory logFactory = Supplier::get;
	private final DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
	private final ConversionService conversionService = DefaultConversionService.getSharedInstance();
	private ConfigDataImporter importer;
	private ConfigDataActivationContext activationContext;
	@BeforeEach
	void setup() {
		MockEnvironment environment = new MockEnvironment();
		Binder binder = Binder.get(environment);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				binder, new DefaultResourceLoader(getClass().getClassLoader()),
				SpringFactoriesLoader.forDefaultResourceLocation(getClass().getClassLoader()));
		ConfigDataLoaders loaders = new ConfigDataLoaders(this.logFactory, this.bootstrapContext,
				SpringFactoriesLoader.forDefaultResourceLocation());
		this.importer = new ConfigDataImporter(this.logFactory, ConfigDataNotFoundAction.FAIL, resolvers, loaders);
		this.activationContext = new ConfigDataActivationContext(CloudPlatform.KUBERNETES, null);
	}
	@Test
	void createCreatesWithInitialContributors() {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, List.of(contributor), this.conversionService);
		Iterator<ConfigDataEnvironmentContributor> iterator = contributors.iterator();
		assertThat(iterator.next()).isSameAs(contributor);
		assertThat(iterator.next().getKind()).isEqualTo(Kind.ROOT);
	}
	@Test
	void withProcessedImportsWhenHasNoUnprocessedImportsReturnsSameInstance() {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor
			.ofExisting(new MockPropertySource(), this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, List.of(contributor), this.conversionService);
		ConfigDataEnvironmentContributors withProcessedImports = contributors.withProcessedImports(this.importer,
				this.activationContext);
		assertThat(withProcessedImports).isSameAs(contributors);
	}
	@Test
	void withProcessedImportsResolvesAndLoads() {
		this.importer = mock(ConfigDataImporter.class);
		List<ConfigDataLocation> locations = Collections.singletonList(LOCATION_1);
		MockPropertySource propertySource = new MockPropertySource();
		Map<ConfigDataResolutionResult, ConfigData> imported = new LinkedHashMap<>();
		imported.put(new ConfigDataResolutionResult(LOCATION_1, new TestConfigDataResource('a'), false),
				new ConfigData(List.of(propertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(locations)))
			.willReturn(imported);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, List.of(contributor), this.conversionService);
		ConfigDataEnvironmentContributors withProcessedImports = contributors.withProcessedImports(this.importer,
				this.activationContext);
		Iterator<ConfigDataEnvironmentContributor> iterator = withProcessedImports.iterator();
		assertThat(iterator.next().getPropertySource()).isSameAs(propertySource);
		assertThat(iterator.next().getKind()).isEqualTo(Kind.INITIAL_IMPORT);
		assertThat(iterator.next().getKind()).isEqualTo(Kind.ROOT);
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void withProcessedImportsResolvesAndLoadsChainedImports() {
		this.importer = mock(ConfigDataImporter.class);
		List<ConfigDataLocation> initialLocations = Collections.singletonList(LOCATION_1);
		MockPropertySource initialPropertySource = new MockPropertySource();
		initialPropertySource.setProperty('spring.config.import', 'location2');
		Map<ConfigDataResolutionResult, ConfigData> initialImported = new LinkedHashMap<>();
		initialImported.put(new ConfigDataResolutionResult(LOCATION_1, new TestConfigDataResource('a'), false),
				new ConfigData(List.of(initialPropertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(initialLocations)))
			.willReturn(initialImported);
		List<ConfigDataLocation> secondLocations = Collections.singletonList(LOCATION_2);
		MockPropertySource secondPropertySource = new MockPropertySource();
		Map<ConfigDataResolutionResult, ConfigData> secondImported = new LinkedHashMap<>();
		secondImported.put(new ConfigDataResolutionResult(LOCATION_2, new TestConfigDataResource('b'), false),
				new ConfigData(List.of(secondPropertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(secondLocations)))
			.willReturn(secondImported);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, List.of(contributor), this.conversionService);
		ConfigDataEnvironmentContributors withProcessedImports = contributors.withProcessedImports(this.importer,
				this.activationContext);
		Iterator<ConfigDataEnvironmentContributor> iterator = withProcessedImports.iterator();
		assertThat(iterator.next().getPropertySource()).isSameAs(secondPropertySource);
		assertThat(iterator.next().getPropertySource()).isSameAs(initialPropertySource);
		assertThat(iterator.next().getKind()).isEqualTo(Kind.INITIAL_IMPORT);
		assertThat(iterator.next().getKind()).isEqualTo(Kind.ROOT);
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void withProcessedImportsProvidesLocationResolverContextWithAccessToBinder() {
		MockPropertySource existingPropertySource = new MockPropertySource();
		existingPropertySource.setProperty('test', 'springboot');
		ConfigDataEnvironmentContributor existingContributor = ConfigDataEnvironmentContributor
			.ofExisting(existingPropertySource, this.conversionService);
		this.importer = mock(ConfigDataImporter.class);
		List<ConfigDataLocation> locations = Collections.singletonList(LOCATION_1);
		MockPropertySource propertySource = new MockPropertySource();
		Map<ConfigDataResolutionResult, ConfigData> imported = new LinkedHashMap<>();
		imported.put(new ConfigDataResolutionResult(LOCATION_1, new TestConfigDataResource('a"'), false),
				new ConfigData(List.of(propertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(locations)))
			.willReturn(imported);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(existingContributor, contributor), this.conversionService);
		contributors.withProcessedImports(this.importer, this.activationContext);
		then(this.importer).should()
			.resolveAndLoad(any(),
					assertArg((context) -> assertThat(context.getBinder().bind('test', String.class).get())
						.isEqualTo('springboot')),
					any(), any());
	}
	@Test
	void withProcessedImportsProvidesLocationResolverContextWithAccessToParent() {
		this.importer = mock(ConfigDataImporter.class);
		List<ConfigDataLocation> initialLocations = Collections.singletonList(LOCATION_1);
		MockPropertySource initialPropertySource = new MockPropertySource();
		initialPropertySource.setProperty('spring.config.import', 'location2');
		Map<ConfigDataResolutionResult, ConfigData> initialImported = new LinkedHashMap<>();
		initialImported.put(new ConfigDataResolutionResult(LOCATION_1, new TestConfigDataResource('a'), false),
				new ConfigData(List.of(initialPropertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(initialLocations)))
			.willReturn(initialImported);
		List<ConfigDataLocation> secondLocations = Collections.singletonList(LOCATION_2);
		MockPropertySource secondPropertySource = new MockPropertySource();
		Map<ConfigDataResolutionResult, ConfigData> secondImported = new LinkedHashMap<>();
		secondImported.put(new ConfigDataResolutionResult(LOCATION_2, new TestConfigDataResource('b'), false),
				new ConfigData(List.of(secondPropertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(secondLocations)))
			.willReturn(secondImported);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, List.of(contributor), this.conversionService);
		ArgumentCaptor<ConfigDataLocationResolverContext> locationResolverContext = ArgumentCaptor
			.forClass(ConfigDataLocationResolverContext.class);
		contributors.withProcessedImports(this.importer, this.activationContext);
		then(this.importer).should()
			.resolveAndLoad(any(), locationResolverContext.capture(), any(), eq(secondLocations));
		ConfigDataLocationResolverContext context = locationResolverContext.getValue();
		assertThat(context.getParent()).hasToString('a');
	}
	@Test
	void withProcessedImportsProvidesLocationResolverContextWithAccessToBootstrapRegistry() {
		MockPropertySource existingPropertySource = new MockPropertySource();
		existingPropertySource.setProperty('test', 'springboot');
		ConfigDataEnvironmentContributor existingContributor = ConfigDataEnvironmentContributor
			.ofExisting(existingPropertySource, this.conversionService);
		this.importer = mock(ConfigDataImporter.class);
		List<ConfigDataLocation> locations = Collections.singletonList(LOCATION_1);
		MockPropertySource propertySource = new MockPropertySource();
		Map<ConfigDataResolutionResult, ConfigData> imported = new LinkedHashMap<>();
		imported.put(new ConfigDataResolutionResult(LOCATION_1, new TestConfigDataResource('a"'), false),
				new ConfigData(List.of(propertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(locations)))
			.willReturn(imported);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(existingContributor, contributor), this.conversionService);
		contributors.withProcessedImports(this.importer, this.activationContext);
		then(this.importer).should()
			.resolveAndLoad(any(),
					assertArg((context) -> assertThat(context.getBootstrapContext()).isSameAs(this.bootstrapContext)),
					any(), any());
	}
	@Test
	void withProcessedImportsProvidesLoaderContextWithAccessToBootstrapRegistry() {
		MockPropertySource existingPropertySource = new MockPropertySource();
		existingPropertySource.setProperty('test', 'springboot');
		ConfigDataEnvironmentContributor existingContributor = ConfigDataEnvironmentContributor
			.ofExisting(existingPropertySource, this.conversionService);
		this.importer = mock(ConfigDataImporter.class);
		List<ConfigDataLocation> locations = Collections.singletonList(LOCATION_1);
		MockPropertySource propertySource = new MockPropertySource();
		Map<ConfigDataResolutionResult, ConfigData> imported = new LinkedHashMap<>();
		imported.put(new ConfigDataResolutionResult(LOCATION_1, new TestConfigDataResource('a"'), false),
				new ConfigData(List.of(propertySource)));
		given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(locations)))
			.willReturn(imported);
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(existingContributor, contributor), this.conversionService);
		contributors.withProcessedImports(this.importer, this.activationContext);
		then(this.importer).should()
			.resolveAndLoad(any(), any(),
					assertArg((context) -> assertThat(context.getBootstrapContext()).isSameAs(this.bootstrapContext)),
					any());
	}
	@Test
	void getBinderProvidesBinder() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('test', 'springboot');
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, List.of(contributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext);
		assertThat(binder.bind('test', String.class).get()).isEqualTo('springboot');
	}
	@Test
	void getBinderWhenHasMultipleSourcesPicksFirst() {
		MockPropertySource firstPropertySource = new MockPropertySource();
		firstPropertySource.setProperty('test', 'one');
		MockPropertySource secondPropertySource = new MockPropertySource();
		secondPropertySource.setProperty('test', 'two');
		ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource));
		ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0);
		ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(firstContributor, secondContributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext);
		assertThat(binder.bind('test', String.class).get()).isEqualTo('one');
	}
	@Test
	void getBinderWhenHasInactiveIgnoresInactive() {
		MockPropertySource firstPropertySource = new MockPropertySource();
		firstPropertySource.setProperty('test', 'one');
		firstPropertySource.setProperty('spring.config.activate.on-profile', 'production');
		MockPropertySource secondPropertySource = new MockPropertySource();
		secondPropertySource.setProperty('test', 'two');
		ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource));
		ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0);
		ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(firstContributor, secondContributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext);
		assertThat(binder.bind('test', String.class).get()).isEqualTo('two');
	}
	@Test
	void getBinderWhenHasPlaceholderResolvesPlaceholder() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('test', '${other}');
		propertySource.setProperty('other', 'springboot');
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource,
				this.conversionService);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, List.of(contributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext);
		assertThat(binder.bind('test', String.class).get()).isEqualTo('springboot');
	}
	@Test
	void getBinderWhenHasPlaceholderAndInactiveResolvesPlaceholderOnlyFromActive() {
		MockPropertySource firstPropertySource = new MockPropertySource();
		firstPropertySource.setProperty('other', 'one');
		firstPropertySource.setProperty('spring.config.activate.on-profile', 'production');
		MockPropertySource secondPropertySource = new MockPropertySource();
		secondPropertySource.setProperty('other', 'two');
		secondPropertySource.setProperty('test', '${other}');
		ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource));
		ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0);
		ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(firstContributor, secondContributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext);
		assertThat(binder.bind('test', String.class).get()).isEqualTo('two');
	}
	@Test
	void getBinderWhenFailOnBindToInactiveSourceWithFirstInactiveThrowsException() {
		MockPropertySource firstPropertySource = new MockPropertySource();
		firstPropertySource.setProperty('test', 'one');
		firstPropertySource.setProperty('spring.config.activate.on-profile', 'production');
		MockPropertySource secondPropertySource = new MockPropertySource();
		secondPropertySource.setProperty('test', 'two');
		ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource));
		ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0);
		ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(firstContributor, secondContributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> binder.bind('test', String.class))
			.satisfies((ex) -> assertThat(ex.getCause()).isInstanceOf(InactiveConfigDataAccessException.class));
	}
	@Test
	void getBinderWhenFailOnBindToInactiveSourceWithLastInactiveThrowsException() {
		MockPropertySource firstPropertySource = new MockPropertySource();
		firstPropertySource.setProperty('test', 'one');
		MockPropertySource secondPropertySource = new MockPropertySource();
		secondPropertySource.setProperty('spring.config.activate.on-profile', 'production');
		secondPropertySource.setProperty('test', 'two');
		ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource));
		ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0);
		ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(firstContributor, secondContributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> binder.bind('test', String.class))
			.satisfies((ex) -> assertThat(ex.getCause()).isInstanceOf(InactiveConfigDataAccessException.class));
	}
	@Test
	void getBinderWhenFailOnBindToInactiveSourceWithResolveToInactiveThrowsException() {
		MockPropertySource firstPropertySource = new MockPropertySource();
		firstPropertySource.setProperty('other', 'one');
		firstPropertySource.setProperty('spring.config.activate.on-profile', 'production');
		MockPropertySource secondPropertySource = new MockPropertySource();
		secondPropertySource.setProperty('test', '${other}');
		secondPropertySource.setProperty('other', 'one');
		ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource));
		ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0);
		ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);
		ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,
				this.bootstrapContext, Arrays.asList(firstContributor, secondContributor), this.conversionService);
		Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> binder.bind('test', String.class))
			.satisfies((ex) -> assertThat(ex.getCause()).isInstanceOf(InactiveConfigDataAccessException.class));
	}
	private ConfigDataEnvironmentContributor createBoundImportContributor(ConfigData configData,
			int propertySourceIndex) {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofUnboundImport(null, null,
				false, configData, propertySourceIndex, this.conversionService);
		return contributor.withBoundProperties(Collections.singleton(contributor), null);
	}
	private static class TestConfigDataResource extends ConfigDataResource {
		private final String value;
		TestConfigDataResource(String value) {
			this.value = value;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigTreeConfigDataLocationResolverTests {
	private final ConfigTreeConfigDataLocationResolver resolver = new ConfigTreeConfigDataLocationResolver(
			new DefaultResourceLoader());
	private final ConfigDataLocationResolverContext context = mock(ConfigDataLocationResolverContext.class);
	@TempDir
	File temp;
	@Test
	void isResolvableWhenPrefixMatchesReturnsTrue() {
		assertThat(this.resolver.isResolvable(this.context, ConfigDataLocation.of('configtree:/etc/config'))).isTrue();
	}
	@Test
	void isResolvableWhenPrefixDoesNotMatchReturnsFalse() {
		assertThat(this.resolver.isResolvable(this.context, ConfigDataLocation.of('http://etc/config'))).isFalse();
		assertThat(this.resolver.isResolvable(this.context, ConfigDataLocation.of('/etc/config'))).isFalse();
	}
	@Test
	void resolveReturnsConfigVolumeMountLocation() {
		List<ConfigTreeConfigDataResource> locations = this.resolver.resolve(this.context,
				ConfigDataLocation.of('configtree:/etc/config/'));
		assertThat(locations).hasSize(1);
		assertThat(locations).extracting(Object::toString)
			.containsExactly('config tree [' + new File('/etc/config').getAbsolutePath() + ']');
	}
	@Test
	void resolveWildcardPattern() throws Exception {
		File directoryA = new File(this.temp, 'a');
		File directoryB = new File(this.temp, 'b');
		directoryA.mkdirs();
		directoryB.mkdirs();
		FileCopyUtils.copy('test'.getBytes(), new File(directoryA, 'spring'));
		FileCopyUtils.copy('test'.getBytes(), new File(directoryB, 'boot'));
		List<ConfigTreeConfigDataResource> locations = this.resolver.resolve(this.context,
				ConfigDataLocation.of('configtree:' + this.temp.getAbsolutePath() + '/*/'));
		assertThat(locations).hasSize(2);
		assertThat(locations).extracting(Object::toString)
			.containsExactly('config tree [' + directoryA.getAbsolutePath() + ']',
					'config tree [' + directoryB.getAbsolutePath() + ']');
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigTreeConfigDataLoaderTests {
	private final ConfigTreeConfigDataLoader loader = new ConfigTreeConfigDataLoader();
	private final ConfigDataLoaderContext loaderContext = mock(ConfigDataLoaderContext.class);
	@TempDir
	Path directory;
	@Test
	void loadReturnsConfigDataWithPropertySource() throws IOException {
		File file = this.directory.resolve('hello').toFile();
		file.getParentFile().mkdirs();
		FileCopyUtils.copy('world\n'.getBytes(StandardCharsets.UTF_8), file);
		ConfigTreeConfigDataResource location = new ConfigTreeConfigDataResource(this.directory.toString());
		ConfigData configData = this.loader.load(this.loaderContext, location);
		assertThat(configData.getPropertySources()).hasSize(1);
		PropertySource<?> source = configData.getPropertySources().get(0);
		assertThat(source.getName()).isEqualTo('Config tree "' + this.directory.toString() + '"');
		assertThat(source.getProperty('hello')).hasToString('world');
	}
	@Test
	void loadWhenPathDoesNotExistThrowsException() {
		File missing = this.directory.resolve('missing').toFile();
		ConfigTreeConfigDataResource location = new ConfigTreeConfigDataResource(missing.toString());
		assertThatExceptionOfType(ConfigDataResourceNotFoundException.class)
			.isThrownBy(() -> this.loader.load(this.loaderContext, location));
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentPostProcessorImportCombinedWithProfileSpecificIntegrationTests {
	private SpringApplication application;
	@TempDir
	public File temp;
	@BeforeEach
	void setup() {
		this.application = new SpringApplication(Config.class);
		this.application.setWebApplicationType(WebApplicationType.NONE);
	}
	@Test
	void testWithoutProfile() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=configimportwithprofilespecific');
		String value = context.getEnvironment().getProperty('prop');
		assertThat(value).isEqualTo('fromicwps1');
	}
	@Test
	void testWithProfile() {
		ConfigurableApplicationContext context = this.application
			.run('--spring.config.name=configimportwithprofilespecific', '--spring.profiles.active=prod');
		String value = context.getEnvironment().getProperty('prop');
		assertThat(value).isEqualTo('fromicwps2');
	}
	static class LocationResolver implements ConfigDataLocationResolver<Resource> {
		@Override
		public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
			return location.hasPrefix('icwps:');
		}
		@Override
		public List<Resource> resolve(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
			return Collections.emptyList();
		}
		@Override
		public List<Resource> resolveProfileSpecific(ConfigDataLocationResolverContext context,
				ConfigDataLocation location, Profiles profiles) {
			return Collections.singletonList(new Resource(profiles));
		}
	}
	static class Loader implements ConfigDataLoader<Resource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, Resource resource) throws IOException {
			List<PropertySource<?>> propertySources = new ArrayList<>();
			Map<PropertySource<?>, Options> propertySourceOptions = new HashMap<>();
			propertySources.add(new MapPropertySource('icwps1', Collections.singletonMap('prop', 'fromicwps1')));
			if (resource.profiles.isAccepted('prod')) {
				MapPropertySource profileSpecificPropertySource = new MapPropertySource('icwps2',
						Collections.singletonMap('prop', 'fromicwps2'));
				propertySources.add(profileSpecificPropertySource);
				propertySourceOptions.put(profileSpecificPropertySource, Options.of(Option.PROFILE_SPECIFIC));
			}
			return new ConfigData(propertySources, propertySourceOptions::get);
		}
	}
	private static class Resource extends ConfigDataResource {
		private final Profiles profiles;
		Resource(Profiles profiles) {
			this.profiles = profiles;
		}
		@Override
		public String toString() {
			return 'icwps:';
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class StandardConfigDataResourceTests {
	StandardConfigDataReference reference = mock(StandardConfigDataReference.class);
	private final Resource resource = mock(Resource.class);
	@Test
	void createWhenReferenceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new StandardConfigDataResource(null, this.resource))
			.withMessage('Reference must not be null');
	}
	@Test
	void createWhenResourceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new StandardConfigDataResource(this.reference, null))
			.withMessage('Resource must not be null');
	}
	@Test
	void equalsWhenResourceIsTheSameReturnsTrue() {
		Resource resource = new ClassPathResource('config/');
		StandardConfigDataResource location = new StandardConfigDataResource(this.reference, resource);
		StandardConfigDataResource other = new StandardConfigDataResource(this.reference, resource);
		assertThat(location).isEqualTo(other);
	}
	@Test
	void equalsWhenResourceIsDifferentReturnsFalse() {
		Resource resource1 = new ClassPathResource('config/');
		Resource resource2 = new ClassPathResource('configdata/');
		StandardConfigDataResource location = new StandardConfigDataResource(this.reference, resource1);
		StandardConfigDataResource other = new StandardConfigDataResource(this.reference, resource2);
		assertThat(location).isNotEqualTo(other);
	}
	@Test // gh-34212
	void equalsAndHashCodeWhenSameUnderlyingResource() throws IOException {
		ClassPathResource classPathResource = new ClassPathResource('log4j2.springboot');
		FileUrlResource fileUrlResource = new FileUrlResource(classPathResource.getURL());
		ConfigDataResource classPathConfigDataResource = new StandardConfigDataResource(this.reference,
				classPathResource);
		ConfigDataResource fileUrlConfigDataResource = new StandardConfigDataResource(this.reference, fileUrlResource);
		assertThat(classPathConfigDataResource.hashCode()).isEqualTo(fileUrlConfigDataResource.hashCode());
		assertThat(classPathConfigDataResource).isEqualTo(fileUrlConfigDataResource);
	}
}
/*
package org.springframework.boot.context.config;
/**
class InactiveConfigDataAccessExceptionTests {
	private final MockPropertySource propertySource = new MockPropertySource();
	private final ConfigDataResource resource = new TestConfigDataResource();
	private final String propertyName = 'spring';
	private final Origin origin = new PropertySourceOrigin(this.propertySource, this.propertyName);
	@Test
	void createHasCorrectMessage() {
		InactiveConfigDataAccessException exception = new InactiveConfigDataAccessException(this.propertySource,
				this.resource, this.propertyName, this.origin);
		assertThat(exception).hasMessage('Inactive property source "mockProperties" imported from location "test" '
				+ 'cannot contain property "spring" [origin: \'spring\' from property source \'mockProperties\']');
	}
	@Test
	void createWhenNoLocationHasCorrectMessage() {
		InactiveConfigDataAccessException exception = new InactiveConfigDataAccessException(this.propertySource, null,
				this.propertyName, this.origin);
		assertThat(exception).hasMessage('Inactive property source "mockProperties" '
				+ 'cannot contain property "spring" [origin: \'spring\' from property source \'mockProperties\']');
	}
	@Test
	void createWhenNoOriginHasCorrectMessage() {
		InactiveConfigDataAccessException exception = new InactiveConfigDataAccessException(this.propertySource,
				this.resource, this.propertyName, null);
		assertThat(exception).hasMessage('Inactive property source "mockProperties" imported from location "test" '
				+ 'cannot contain property "spring"');
	}
	@Test
	void getPropertySourceReturnsPropertySource() {
		InactiveConfigDataAccessException exception = new InactiveConfigDataAccessException(this.propertySource,
				this.resource, this.propertyName, this.origin);
		assertThat(exception.getPropertySource()).isSameAs(this.propertySource);
	}
	@Test
	void getLocationReturnsLocation() {
		InactiveConfigDataAccessException exception = new InactiveConfigDataAccessException(this.propertySource,
				this.resource, this.propertyName, this.origin);
		assertThat(exception.getLocation()).isSameAs(this.resource);
	}
	@Test
	void getPropertyNameReturnsPropertyName() {
		InactiveConfigDataAccessException exception = new InactiveConfigDataAccessException(this.propertySource,
				this.resource, this.propertyName, this.origin);
		assertThat(exception.getPropertyName()).isSameAs(this.propertyName);
	}
	@Test
	void getOriginReturnsOrigin() {
		InactiveConfigDataAccessException exception = new InactiveConfigDataAccessException(this.propertySource,
				this.resource, this.propertyName, this.origin);
		assertThat(exception.getOrigin()).isSameAs(this.origin);
	}
	@Test
	void throwIfPropertyFoundWhenSourceIsNullDoesNothing() {
		ConfigDataEnvironmentContributor contributor = mock(ConfigDataEnvironmentContributor.class);
		given(contributor.getConfigurationPropertySource()).willReturn(null);
		InactiveConfigDataAccessException.throwIfPropertyFound(contributor, ConfigurationPropertyName.of('spring'));
	}
	@Test
	void throwIfPropertyFoundWhenPropertyNotFoundDoesNothing() {
		ConfigDataEnvironmentContributor contributor = mock(ConfigDataEnvironmentContributor.class);
		ConfigurationPropertySource configurationPropertySource = ConfigurationPropertySource.from(this.propertySource);
		given(contributor.getConfigurationPropertySource()).willReturn(configurationPropertySource);
		InactiveConfigDataAccessException.throwIfPropertyFound(contributor, ConfigurationPropertyName.of('spring'));
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void throwIfPropertyFoundWhenPropertyFoundThrowsException() {
		this.propertySource.setProperty('spring', 'test');
		ConfigDataEnvironmentContributor contributor = mock(ConfigDataEnvironmentContributor.class);
		ConfigurationPropertySource configurationPropertySource = ConfigurationPropertySource.from(this.propertySource);
		given(contributor.getConfigurationPropertySource()).willReturn(configurationPropertySource);
		given(contributor.getPropertySource()).willReturn((PropertySource) this.propertySource);
		given(contributor.getResource()).willReturn(this.resource);
		assertThatExceptionOfType(InactiveConfigDataAccessException.class)
			.isThrownBy(() -> InactiveConfigDataAccessException.throwIfPropertyFound(contributor,
					ConfigurationPropertyName.of('spring')))
			.withMessage('Inactive property source "mockProperties" imported from location "test" '
					+ 'cannot contain property "spring" [origin: \'spring\' from property source \'mockProperties\']');
	}
	private static final class TestConfigDataResource extends ConfigDataResource {
		@Override
		public String toString() {
			return 'test';
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationResolverTests {
	private final ConfigDataLocationResolver<?> resolver = new TestConfigDataLocationResolver();
	private final ConfigDataLocationResolverContext context = mock(ConfigDataLocationResolverContext.class);
	@Test
	void resolveProfileSpecificReturnsEmptyList() {
		assertThat(this.resolver.resolveProfileSpecific(this.context, null, null)).isEmpty();
	}
	static class TestConfigDataLocationResolver implements ConfigDataLocationResolver<ConfigDataResource> {
		@Override
		public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
			return true;
		}
		@Override
		public List<ConfigDataResource> resolve(ConfigDataLocationResolverContext context,
				ConfigDataLocation location) {
			return null;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLoadersTests {
	private final DeferredLogFactory logFactory = Supplier::get;
	private final DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
	private final ConfigDataLoaderContext context = mock(ConfigDataLoaderContext.class);
	@TempDir
	private File tempDir;
	@Test
	void createWhenLoaderHasDeferredLogFactoryParameterInjectsDeferredLogFactory() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLoader.class, DeferredLogFactoryConfigDataLoader.class);
		ConfigDataLoaders loaders = new ConfigDataLoaders(this.logFactory, this.bootstrapContext,
				springFactoriesLoader);
		assertThat(loaders).extracting('loaders')
			.asInstanceOf(InstanceOfAssertFactories.LIST)
			.satisfies(this::containsValidDeferredLogFactoryConfigDataLoader);
	}
	private void containsValidDeferredLogFactoryConfigDataLoader(List<?> list) {
		assertThat(list).hasSize(1);
		DeferredLogFactoryConfigDataLoader loader = (DeferredLogFactoryConfigDataLoader) list.get(0);
		assertThat(loader.getLogFactory()).isSameAs(this.logFactory);
	}
	@Test
	void createWhenLoaderHasLogParameterThrowsException() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLoader.class, LogConfigDataLoader.class);
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ConfigDataLoaders(this.logFactory, this.bootstrapContext, springFactoriesLoader))
			.havingCause()
			.isInstanceOf(IllegalArgumentException.class)
			.withMessageContaining('use DeferredLogFactory');
	}
	@Test
	void createWhenLoaderHasBootstrapParametersInjectsBootstrapContext() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLoader.class, BootstrappingConfigDataLoader.class);
		new ConfigDataLoaders(this.logFactory, this.bootstrapContext, springFactoriesLoader);
		assertThat(this.bootstrapContext.get(String.class)).isEqualTo('boot');
	}
	@Test
	void loadWhenSingleLoaderSupportsLocationReturnsLoadedConfigData() throws Exception {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLoader.class, TestConfigDataLoader.class);
		ConfigDataLoaders loaders = new ConfigDataLoaders(this.logFactory, this.bootstrapContext,
				springFactoriesLoader);
		TestConfigDataResource location = new TestConfigDataResource('test');
		ConfigData loaded = loaders.load(this.context, location);
		assertThat(getLoader(loaded)).isInstanceOf(TestConfigDataLoader.class);
	}
	@Test
	void loadWhenMultipleLoadersSupportLocationThrowsException() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLoader.class, AnotherConfigDataLoader.class, TestConfigDataLoader.class);
		ConfigDataLoaders loaders = new ConfigDataLoaders(this.logFactory, this.bootstrapContext,
				springFactoriesLoader);
		TestConfigDataResource location = new TestConfigDataResource('test');
		assertThatIllegalStateException().isThrownBy(() -> loaders.load(this.context, location))
			.withMessageContaining('Multiple loaders found for resource "test"');
	}
	@Test
	void loadWhenNoLoaderSupportsLocationThrowsException() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLoader.class, NonLoadableConfigDataLoader.class);
		ConfigDataLoaders loaders = new ConfigDataLoaders(this.logFactory, this.bootstrapContext,
				springFactoriesLoader);
		TestConfigDataResource location = new TestConfigDataResource('test');
		assertThatIllegalStateException().isThrownBy(() -> loaders.load(this.context, location))
			.withMessage('No loader found for resource "test"');
	}
	@Test
	void loadWhenGenericTypeDoesNotMatchSkipsLoader() throws Exception {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLoader.class, OtherConfigDataLoader.class, SpecificConfigDataLoader.class);
		ConfigDataLoaders loaders = new ConfigDataLoaders(this.logFactory, this.bootstrapContext,
				springFactoriesLoader);
		TestConfigDataResource location = new TestConfigDataResource('test');
		ConfigData loaded = loaders.load(this.context, location);
		assertThat(getLoader(loaded)).isInstanceOf(SpecificConfigDataLoader.class);
	}
	private ConfigDataLoader<?> getLoader(ConfigData loaded) {
		return (ConfigDataLoader<?>) loaded.getPropertySources().get(0).getProperty('loader');
	}
	private static ConfigData createConfigData(ConfigDataLoader<?> loader, ConfigDataResource resource) {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('loader', loader);
		propertySource.setProperty('resource', resource);
		List<PropertySource<?>> propertySources = Arrays.asList(propertySource);
		return new ConfigData(propertySources);
	}
	static class TestConfigDataResource extends ConfigDataResource {
		private final String value;
		TestConfigDataResource(String value) {
			this.value = value;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
	static class OtherConfigDataResource extends ConfigDataResource {
	}
	static class DeferredLogFactoryConfigDataLoader implements ConfigDataLoader<ConfigDataResource> {
		private final DeferredLogFactory logFactory;
		DeferredLogFactoryConfigDataLoader(DeferredLogFactory logFactory) {
			assertThat(logFactory).isNotNull();
			this.logFactory = logFactory;
		}
		@Override
		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException {
			throw new AssertionError('Unexpected call');
		}
		DeferredLogFactory getLogFactory() {
			return this.logFactory;
		}
	}
	static class LogConfigDataLoader implements ConfigDataLoader<ConfigDataResource> {
		final Log logger;
		LogConfigDataLoader(Log logger) {
			this.logger = logger;
		}
		@Override
		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException {
			throw new AssertionError('Unexpected call');
		}
	}
	static class BootstrappingConfigDataLoader implements ConfigDataLoader<ConfigDataResource> {
		BootstrappingConfigDataLoader(ConfigurableBootstrapContext configurableBootstrapContext,
				BootstrapRegistry bootstrapRegistry, BootstrapContext bootstrapContext) {
			assertThat(configurableBootstrapContext).isNotNull();
			assertThat(bootstrapRegistry).isNotNull();
			assertThat(bootstrapContext).isNotNull();
			assertThat(configurableBootstrapContext).isEqualTo(bootstrapRegistry).isEqualTo(bootstrapContext);
			bootstrapRegistry.register(String.class, InstanceSupplier.of('boot'));
		}
		@Override
		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException {
			throw new AssertionError('Unexpected call');
		}
	}
	static class TestConfigDataLoader implements ConfigDataLoader<ConfigDataResource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException {
			return createConfigData(this, resource);
		}
	}
	static class AnotherConfigDataLoader implements ConfigDataLoader<ConfigDataResource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, ConfigDataResource resource) throws IOException {
			return createConfigData(this, resource);
		}
	}
	static class NonLoadableConfigDataLoader extends TestConfigDataLoader {
		@Override
		public boolean isLoadable(ConfigDataLoaderContext context, ConfigDataResource resource) {
			return false;
		}
	}
	static class SpecificConfigDataLoader implements ConfigDataLoader<TestConfigDataResource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, TestConfigDataResource location) throws IOException {
			return createConfigData(this, location);
		}
	}
	static class OtherConfigDataLoader implements ConfigDataLoader<OtherConfigDataResource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, OtherConfigDataResource location) throws IOException {
			return createConfigData(this, location);
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class StandardConfigDataLocationResolverTests {
	private StandardConfigDataLocationResolver resolver;
	private final ConfigDataLocationResolverContext context = mock(ConfigDataLocationResolverContext.class);
	private MockEnvironment environment;
	private Binder environmentBinder;
	private final ResourceLoader resourceLoader = new DefaultResourceLoader();
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.environmentBinder = Binder.get(this.environment);
		this.resolver = new StandardConfigDataLocationResolver(new DeferredLogs(), this.environmentBinder,
				this.resourceLoader);
	}
	@Test
	void isResolvableAlwaysReturnsTrue() {
		assertThat(this.resolver.isResolvable(this.context, ConfigDataLocation.of('test'))).isTrue();
	}
	@Test
	void resolveWhenLocationIsDirectoryResolvesAllMatchingFilesInDirectory() {
		ConfigDataLocation location = ConfigDataLocation.of('classpath:/configdata/properties/');
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).hasSize(1);
		assertThat(locations).extracting(Object::toString)
			.containsExactly('class path resource [configdata/properties/application.properties]');
	}
	@Test
	void resolveWhenLocationIsFileResolvesFile() {
		ConfigDataLocation location = ConfigDataLocation
			.of('file:src/test/resources/configdata/properties/application.properties');
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).hasSize(1);
		assertThat(locations).extracting(Object::toString)
			.containsExactly(
					filePath('src', 'test', 'resources', 'configdata', 'properties', 'application.properties'));
	}
	@Test
	void resolveWhenLocationIsFileAndNoMatchingLoaderThrowsException() {
		ConfigDataLocation location = ConfigDataLocation
			.of('file:src/test/resources/configdata/properties/application.unknown');
		assertThatIllegalStateException().isThrownBy(() -> this.resolver.resolve(this.context, location))
			.withMessageStartingWith('Unable to load config data from')
			.satisfies((ex) -> assertThat(ex.getCause()).hasMessageStartingWith('File extension is not known'));
	}
	@Test
	void resolveWhenLocationHasUnknownPrefixAndNoMatchingLoaderThrowsException() {
		ConfigDataLocation location = ConfigDataLocation
			.of('typo:src/test/resources/configdata/properties/application.unknown');
		assertThatIllegalStateException().isThrownBy(() -> this.resolver.resolve(this.context, location))
			.withMessageStartingWith('Unable to load config data from')
			.satisfies((ex) -> assertThat(ex.getCause()).hasMessageStartingWith(
					'Incorrect ConfigDataLocationResolver chosen or file extension is not known to any PropertySourceLoader'));
	}
	@Test
	void resolveWhenLocationWildcardIsSpecifiedForClasspathLocationThrowsException() {
		ConfigDataLocation location = ConfigDataLocation.of('classpath*:application.properties');
		assertThatIllegalStateException().isThrownBy(() -> this.resolver.resolve(this.context, location))
			.withMessageContaining('Location "classpath*:application.properties" cannot use classpath wildcards');
	}
	@Test
	void resolveWhenLocationWildcardIsNotBeforeLastSlashThrowsException() {
		ConfigDataLocation location = ConfigDataLocation.of('file:src/test/resources/*/config/');
		assertThatIllegalStateException().isThrownBy(() -> this.resolver.resolve(this.context, location))
			.withMessageStartingWith('Location "')
			.withMessageEndingWith('" must end with "*/"');
	}
	@Test
	void createWhenConfigNameHasWildcardThrowsException() {
		this.environment.setProperty('spring.config.name', '*/application');
		assertThatIllegalStateException()
			.isThrownBy(() -> new StandardConfigDataLocationResolver(new DeferredLogs(), this.environmentBinder,
					this.resourceLoader))
			.withMessageStartingWith('Config name "')
			.withMessageEndingWith('" cannot contain "*"');
	}
	@Test
	void resolveWhenLocationHasMultipleWildcardsThrowsException() {
		ConfigDataLocation location = ConfigDataLocation.of('file:src/test/resources/config/**/');
		assertThatIllegalStateException().isThrownBy(() -> this.resolver.resolve(this.context, location))
			.withMessageStartingWith('Location "')
			.withMessageEndingWith('" cannot contain multiple wildcards');
	}
	@Test
	void resolveWhenLocationIsWildcardDirectoriesRestrictsToOneLevelDeep() {
		ConfigDataLocation location = ConfigDataLocation.of('file:src/test/resources/config/*/');
		this.environment.setProperty('spring.config.name', 'testproperties');
		this.resolver = new StandardConfigDataLocationResolver(new DeferredLogs(), this.environmentBinder,
				this.resourceLoader);
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).hasSize(3);
		assertThat(locations).extracting(Object::toString)
			.contains(filePath('src', 'test', 'resources', 'config', '1-first', 'testproperties.properties'))
			.contains(filePath('src', 'test', 'resources', 'config', '2-second', 'testproperties.properties'))
			.doesNotContain(filePath('src', 'test', 'resources', 'config', '3-third', 'testproperties.properties'));
	}
	@Test
	void resolveWhenLocationIsWildcardDirectoriesSortsAlphabeticallyBasedOnAbsolutePath() {
		ConfigDataLocation location = ConfigDataLocation.of('file:src/test/resources/config/*/');
		this.environment.setProperty('spring.config.name', 'testproperties');
		this.resolver = new StandardConfigDataLocationResolver(new DeferredLogs(), this.environmentBinder,
				this.resourceLoader);
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).extracting(Object::toString)
			.containsExactly(filePath('src', 'test', 'resources', 'config', '0-empty', 'testproperties.properties'),
					filePath('src', 'test', 'resources', 'config', '1-first', 'testproperties.properties'),
					filePath('src', 'test', 'resources', 'config', '2-second', 'testproperties.properties'));
	}
	@Test
	void resolveWhenLocationIsWildcardAndMatchingFilePresentShouldNotFail() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:file:src/test/resources/a-file/*/');
		assertThatNoException().isThrownBy(() -> this.resolver.resolve(this.context, location));
	}
	@Test
	void resolveWhenLocationIsWildcardFilesLoadsAllFilesThatMatch() {
		ConfigDataLocation location = ConfigDataLocation
			.of('file:src/test/resources/config/*/testproperties.properties');
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).hasSize(3);
		assertThat(locations).extracting(Object::toString)
			.contains(filePath('src', 'test', 'resources', 'config', '1-first', 'testproperties.properties'))
			.contains(filePath('src', 'test', 'resources', 'config', '2-second', 'testproperties.properties'))
			.doesNotContain(
					filePath('src', 'test', 'resources', 'config', 'nested', '3-third', 'testproperties.properties'));
	}
	@Test
	void resolveWhenLocationIsRelativeAndFileResolves() {
		this.environment.setProperty('spring.config.name', 'other');
		ConfigDataLocation location = ConfigDataLocation.of('other.properties');
		this.resolver = new StandardConfigDataLocationResolver(new DeferredLogs(), this.environmentBinder,
				this.resourceLoader);
		StandardConfigDataReference parentReference = new StandardConfigDataReference(
				ConfigDataLocation.of('classpath:configdata/properties/application.properties'), null,
				'classpath:configdata/properties/application', null, 'properties',
				new PropertiesPropertySourceLoader());
		ClassPathResource parentResource = new ClassPathResource('configdata/properties/application.properties');
		StandardConfigDataResource parent = new StandardConfigDataResource(parentReference, parentResource);
		given(this.context.getParent()).willReturn(parent);
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).hasSize(1);
		assertThat(locations).extracting(Object::toString)
			.contains('class path resource [configdata/properties/other.properties]');
	}
	@Test
	void resolveWhenLocationIsRelativeAndDirectoryResolves() {
		this.environment.setProperty('spring.config.name', 'testproperties');
		ConfigDataLocation location = ConfigDataLocation.of('nested/3-third/');
		this.resolver = new StandardConfigDataLocationResolver(new DeferredLogs(), this.environmentBinder,
				this.resourceLoader);
		StandardConfigDataReference parentReference = new StandardConfigDataReference(
				ConfigDataLocation.of('optional:classpath:configdata/'), null, 'classpath:config/specific', null,
				'properties', new PropertiesPropertySourceLoader());
		ClassPathResource parentResource = new ClassPathResource('config/specific.properties');
		StandardConfigDataResource parent = new StandardConfigDataResource(parentReference, parentResource);
		given(this.context.getParent()).willReturn(parent);
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).hasSize(1);
		assertThat(locations).extracting(Object::toString)
			.contains('class path resource [config/nested/3-third/testproperties.properties]');
	}
	@Test
	void resolveWhenLocationIsRelativeAndNoMatchingLoaderThrowsException() {
		ConfigDataLocation location = ConfigDataLocation.of('application.other');
		StandardConfigDataReference parentReference = new StandardConfigDataReference(
				ConfigDataLocation.of('classpath:configdata/properties/application.properties'), null,
				'configdata/properties/application', null, 'properties', new PropertiesPropertySourceLoader());
		ClassPathResource parentResource = new ClassPathResource('configdata/properties/application.properties');
		StandardConfigDataResource parent = new StandardConfigDataResource(parentReference, parentResource);
		given(this.context.getParent()).willReturn(parent);
		assertThatIllegalStateException().isThrownBy(() -> this.resolver.resolve(this.context, location))
			.withMessageStartingWith('Unable to load config data from "application.other"')
			.satisfies((ex) -> assertThat(ex.getCause()).hasMessageStartingWith('File extension is not known'));
	}
	@Test
	void resolveWhenLocationUsesOptionalExtensionSyntaxResolves() throws Exception {
		ConfigDataLocation location = ConfigDataLocation.of('classpath:/application-props-no-extension[.properties]');
		List<StandardConfigDataResource> locations = this.resolver.resolve(this.context, location);
		assertThat(locations).hasSize(1);
		StandardConfigDataResource resolved = locations.get(0);
		assertThat(resolved.getResource().getFilename()).endsWith('application-props-no-extension');
		ConfigData loaded = new StandardConfigDataLoader().load(null, resolved);
		PropertySource<?> propertySource = loaded.getPropertySources().get(0);
		assertThat(propertySource.getProperty('withnotext')).isEqualTo('test');
	}
	@Test
	void resolveProfileSpecificReturnsProfileSpecificFiles() {
		ConfigDataLocation location = ConfigDataLocation.of('classpath:/configdata/properties/');
		Profiles profiles = mock(Profiles.class);
		given(profiles.iterator()).willReturn(Collections.singletonList('dev').iterator());
		List<StandardConfigDataResource> locations = this.resolver.resolveProfileSpecific(this.context, location,
				profiles);
		assertThat(locations).hasSize(1);
		assertThat(locations).extracting(Object::toString)
			.containsExactly('class path resource [configdata/properties/application-dev.properties]');
	}
	@Test
	void resolveProfileSpecificWhenLocationIsFileReturnsEmptyList() {
		ConfigDataLocation location = ConfigDataLocation.of('classpath:/configdata/properties/application.properties');
		Profiles profiles = mock(Profiles.class);
		given(profiles.iterator()).willReturn(Collections.emptyIterator());
		given(profiles.getActive()).willReturn(Collections.singletonList('dev'));
		List<StandardConfigDataResource> locations = this.resolver.resolveProfileSpecific(this.context, location,
				profiles);
		assertThat(locations).isEmpty();
	}
	@Test
	void resolveWhenOptionalAndLoaderIsUnknownShouldNotFail() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:some-unknown-loader:dummy.properties');
		assertThatNoException().isThrownBy(() -> this.resolver.resolve(this.context, location));
	}
	@Test
	void resolveWhenOptionalAndLoaderIsUnknownAndExtensionIsUnknownShouldNotFail() {
		ConfigDataLocation location = ConfigDataLocation
			.of('optional:some-unknown-loader:dummy.some-unknown-extension');
		assertThatNoException().isThrownBy(() -> this.resolver.resolve(this.context, location));
	}
	@Test
	void resolveWhenOptionalAndExtensionIsUnknownShouldNotFail() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:file:dummy.some-unknown-extension');
		assertThatNoException().isThrownBy(() -> this.resolver.resolve(this.context, location));
	}
	private String filePath(String... components) {
		return 'file [' + String.join(File.separator, components) + ']';
	}
}
/*
package org.springframework.boot.context.config;
/**
class InvalidConfigDataPropertyExceptionTests {
	private final ConfigDataResource resource = new TestConfigDataResource();
	private final ConfigurationPropertyName replacement = ConfigurationPropertyName.of('replacement');
	private final ConfigurationPropertyName invalid = ConfigurationPropertyName.of('invalid');
	private final ConfigurationProperty property = new ConfigurationProperty(this.invalid, 'bad',
			MockOrigin.of('origin'));
	private final ConversionService conversionService = DefaultConversionService.getSharedInstance();
	@Test
	void createHasCorrectMessage() {
		assertThat(new InvalidConfigDataPropertyException(this.property, false, this.replacement, this.resource))
			.hasMessage(
					'Property "invalid" imported from location "test" is invalid and should be replaced with "replacement" [origin: origin]');
	}
	@Test
	void createWhenNoLocationHasCorrectMessage() {
		assertThat(new InvalidConfigDataPropertyException(this.property, false, this.replacement, null))
			.hasMessage('Property "invalid" is invalid and should be replaced with "replacement" [origin: origin]');
	}
	@Test
	void createWhenNoReplacementHasCorrectMessage() {
		assertThat(new InvalidConfigDataPropertyException(this.property, false, null, this.resource))
			.hasMessage('Property "invalid" imported from location "test" is invalid [origin: origin]');
	}
	@Test
	void createWhenNoOriginHasCorrectMessage() {
		ConfigurationProperty property = new ConfigurationProperty(this.invalid, 'bad', null);
		assertThat(new InvalidConfigDataPropertyException(property, false, this.replacement, this.resource)).hasMessage(
				'Property "invalid" imported from location "test" is invalid and should be replaced with "replacement"');
	}
	@Test
	void createWhenProfileSpecificHasCorrectMessage() {
		ConfigurationProperty property = new ConfigurationProperty(this.invalid, 'bad', null);
		assertThat(new InvalidConfigDataPropertyException(property, true, null, this.resource))
			.hasMessage('Property "invalid" imported from location "test" is invalid in a profile specific resource');
	}
	@Test
	void getPropertyReturnsProperty() {
		InvalidConfigDataPropertyException exception = new InvalidConfigDataPropertyException(this.property, false,
				this.replacement, this.resource);
		assertThat(exception.getProperty()).isEqualTo(this.property);
	}
	@Test
	void getLocationReturnsLocation() {
		InvalidConfigDataPropertyException exception = new InvalidConfigDataPropertyException(this.property, false,
				this.replacement, this.resource);
		assertThat(exception.getLocation()).isEqualTo(this.resource);
	}
	@Test
	void getReplacementReturnsReplacement() {
		InvalidConfigDataPropertyException exception = new InvalidConfigDataPropertyException(this.property, false,
				this.replacement, this.resource);
		assertThat(exception.getReplacement()).isEqualTo(this.replacement);
	}
	@Test
	void throwOrWarnWhenHasInvalidPropertyThrowsException() {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty('spring.profiles', 'a');
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource,
				this.conversionService);
		assertThatExceptionOfType(InvalidConfigDataPropertyException.class)
			.isThrownBy(() -> InvalidConfigDataPropertyException.throwIfPropertyFound(contributor))
			.withMessageStartingWith('Property "spring.profiles" is invalid and should be replaced with '
					+ '"spring.config.activate.on-profile"');
	}
	@Test
	void throwOrWarnWhenWhenHasInvalidProfileSpecificPropertyThrowsException() {
		throwOrWarnWhenWhenHasInvalidProfileSpecificPropertyThrowsException('spring.profiles.include');
		throwOrWarnWhenWhenHasInvalidProfileSpecificPropertyThrowsException('spring.profiles.active');
		throwOrWarnWhenWhenHasInvalidProfileSpecificPropertyThrowsException('spring.profiles.default');
	}
	@Test
	void throwOrWarnWhenWhenHasInvalidProfileSpecificPropertyOnIgnoringProfilesContributorDoesNotThrowException() {
		ConfigDataEnvironmentContributor contributor = createInvalidProfileSpecificPropertyContributor(
				'spring.profiles.active', ConfigData.Option.IGNORE_PROFILES);
		assertThatNoException().isThrownBy(() -> InvalidConfigDataPropertyException.throwIfPropertyFound(contributor));
	}
	private void throwOrWarnWhenWhenHasInvalidProfileSpecificPropertyThrowsException(String name) {
		ConfigDataEnvironmentContributor contributor = createInvalidProfileSpecificPropertyContributor(name);
		assertThatExceptionOfType(InvalidConfigDataPropertyException.class)
			.isThrownBy(() -> InvalidConfigDataPropertyException.throwIfPropertyFound(contributor))
			.withMessageStartingWith('Property "' + name + '" is invalid in a profile specific resource');
	}
	private ConfigDataEnvironmentContributor createInvalidProfileSpecificPropertyContributor(String name,
			ConfigData.Option... configDataOptions) {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty(name, 'a');
		return new ConfigDataEnvironmentContributor(Kind.BOUND_IMPORT, null, null, true, propertySource,
				ConfigurationPropertySource.from(propertySource), null, ConfigData.Options.of(configDataOptions), null,
				this.conversionService);
	}
	@Test
	void throwOrWarnWhenHasNoInvalidPropertyDoesNothing() {
		ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor
			.ofExisting(new MockPropertySource(), this.conversionService);
		InvalidConfigDataPropertyException.throwIfPropertyFound(contributor);
	}
	private static final class TestConfigDataResource extends ConfigDataResource {
		@Override
		public String toString() {
			return 'test';
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigTreeConfigDataResourceTests {
	@Test
	void constructorWhenPathStringIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigTreeConfigDataResource((String) null))
			.withMessage('Path must not be null');
	}
	@Test
	void constructorWhenPathIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigTreeConfigDataResource((Path) null))
			.withMessage('Path must not be null');
	}
	@Test
	void equalsWhenPathIsTheSameReturnsTrue() {
		ConfigTreeConfigDataResource location = new ConfigTreeConfigDataResource('/etc/config');
		ConfigTreeConfigDataResource other = new ConfigTreeConfigDataResource('/etc/config');
		assertThat(location).isEqualTo(other);
	}
	@Test
	void equalsWhenPathIsDifferentReturnsFalse() {
		ConfigTreeConfigDataResource location = new ConfigTreeConfigDataResource('/etc/config');
		ConfigTreeConfigDataResource other = new ConfigTreeConfigDataResource('other-location');
		assertThat(location).isNotEqualTo(other);
	}
	@Test
	void toStringReturnsDescriptiveString() {
		ConfigTreeConfigDataResource location = new ConfigTreeConfigDataResource('/etc/config');
		assertThat(location).hasToString('config tree [' + new File('/etc/config').getAbsolutePath() + ']');
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataTests {
	@Test
	void createWhenPropertySourcesIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigData(null))
			.withMessage('PropertySources must not be null');
	}
	@Test
	void createWhenOptionsIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigData(Collections.emptyList(), (Option[]) null))
			.withMessage('Options must not be null');
	}
	@Test
	void getPropertySourcesReturnsCopyOfSources() {
		MapPropertySource source = new MapPropertySource('test', Collections.emptyMap());
		List<MapPropertySource> sources = new ArrayList<>(Collections.singleton(source));
		ConfigData configData = new ConfigData(sources);
		sources.clear();
		assertThat(configData.getPropertySources()).containsExactly(source);
	}
	@Test
	void getOptionsWhenOptionsSetAtConstructionAlwaysReturnsSameOptions() {
		MapPropertySource source = new MapPropertySource('test', Collections.emptyMap());
		ConfigData configData = new ConfigData(Collections.singleton(source), Option.IGNORE_IMPORTS);
		assertThat(configData.getOptions(source).asSet()).containsExactly(Option.IGNORE_IMPORTS);
	}
	@Test
	void getOptionsReturnsOptionsFromPropertySourceOptions() {
		MapPropertySource source1 = new MapPropertySource('test', Collections.emptyMap());
		MapPropertySource source2 = new MapPropertySource('test', Collections.emptyMap());
		Options options1 = Options.of(Option.IGNORE_IMPORTS);
		Options options2 = Options.of(Option.IGNORE_PROFILES);
		PropertySourceOptions propertySourceOptions = (source) -> (source != source1) ? options2 : options1;
		ConfigData configData = new ConfigData(Arrays.asList(source1, source2), propertySourceOptions);
		assertThat(configData.getOptions(source1)).isEqualTo(options1);
		assertThat(configData.getOptions(source2)).isEqualTo(options2);
	}
	@Test
	void getOptionsWhenPropertySourceOptionsReturnsNullReturnsNone() {
		MapPropertySource source = new MapPropertySource('test', Collections.emptyMap());
		PropertySourceOptions propertySourceOptions = (propertySource) -> null;
		ConfigData configData = new ConfigData(Collections.singleton(source), propertySourceOptions);
		assertThat(configData.getOptions(source)).isEqualTo(Options.NONE);
	}
	@Test
	void optionsOfCreatesOptions() {
		Options options = Options.of(Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES);
		assertThat(options.asSet()).containsExactly(Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES);
	}
	@Test
	void optionsOfUsesCopyOfOptions() {
		Option[] array = { Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES };
		Options options = Options.of(array);
		array[0] = Option.PROFILE_SPECIFIC;
		assertThat(options.asSet()).containsExactly(Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES);
	}
	@Test
	void optionsNoneReturnsEmptyOptions() {
		assertThat(Options.NONE.asSet()).isEmpty();
	}
	@Test
	void optionsWithoutReturnsNewOptions() {
		Options options = Options.of(Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES);
		Options without = options.without(Option.IGNORE_PROFILES);
		assertThat(options.asSet()).containsExactly(Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES);
		assertThat(without.asSet()).containsExactly(Option.IGNORE_IMPORTS);
	}
	@Test
	void optionsWithReturnsNewOptions() {
		Options options = Options.of(Option.IGNORE_IMPORTS);
		Options with = options.with(Option.IGNORE_PROFILES);
		assertThat(options.asSet()).containsExactly(Option.IGNORE_IMPORTS);
		assertThat(with.asSet()).containsExactly(Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES);
	}
	@Test
	void propertySourceOptionsAlwaysReturnsSameOptionsEachTime() {
		PropertySourceOptions options = PropertySourceOptions.always(Option.IGNORE_IMPORTS, Option.IGNORE_PROFILES);
		assertThat(options.get(mock(PropertySource.class)).asSet()).containsExactly(Option.IGNORE_IMPORTS,
				Option.IGNORE_PROFILES);
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLoaderTests {
	private final TestConfigDataLoader loader = new TestConfigDataLoader();
	private final ConfigDataLoaderContext context = mock(ConfigDataLoaderContext.class);
	@Test
	void isLoadableAlwaysReturnsTrue() {
		assertThat(this.loader.isLoadable(this.context, new TestConfigDataResource())).isTrue();
	}
	static class TestConfigDataLoader implements ConfigDataLoader<TestConfigDataResource> {
		@Override
		public ConfigData load(ConfigDataLoaderContext context, TestConfigDataResource resource) throws IOException {
			return null;
		}
	}
	static class TestConfigDataResource extends ConfigDataResource {
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentContributorPlaceholdersResolverTests {
	private final ConversionService conversionService = DefaultConversionService.getSharedInstance();
	@Test
	void resolvePlaceholdersWhenNotStringReturnsResolved() {
		ConfigDataEnvironmentContributorPlaceholdersResolver resolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				Collections.emptyList(), null, null, false, this.conversionService);
		assertThat(resolver.resolvePlaceholders(123)).isEqualTo(123);
	}
	@Test
	void resolvePlaceholdersWhenNotFoundReturnsOriginal() {
		ConfigDataEnvironmentContributorPlaceholdersResolver resolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				Collections.emptyList(), null, null, false, this.conversionService);
		assertThat(resolver.resolvePlaceholders('${test}')).isEqualTo('${test}');
	}
	@Test
	void resolvePlaceholdersWhenFoundReturnsFirstMatch() {
		List<ConfigDataEnvironmentContributor> contributors = new ArrayList<>();
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s1', 'nope', 't1'), true,
				this.conversionService));
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s2', 'test', 't2'), true,
				this.conversionService));
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s3', 'test', 't3'), true,
				this.conversionService));
		ConfigDataEnvironmentContributorPlaceholdersResolver resolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				contributors, null, null, true, this.conversionService);
		assertThat(resolver.resolvePlaceholders('${test}')).isEqualTo('t2');
	}
	@Test
	void shouldUseConversionService() {
		GenericConversionService conversionService = new GenericConversionService();
		conversionService.addConverter(CustomValue.class, String.class, (input) -> 'custom-value');
		List<ConfigDataEnvironmentContributor> contributors = new ArrayList<>();
		contributors.add(new TestConfigDataEnvironmentContributor(
				new TestPropertySource('s1', Map.of('test', new CustomValue())), true, conversionService));
		ConfigDataEnvironmentContributorPlaceholdersResolver resolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				contributors, null, null, true, conversionService);
		assertThat(resolver.resolvePlaceholders('${test}')).isEqualTo('custom-value');
	}
	@Test
	void resolvePlaceholdersWhenFoundInInactiveThrowsException() {
		List<ConfigDataEnvironmentContributor> contributors = new ArrayList<>();
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s1', 'nope', 't1'), true,
				this.conversionService));
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s2', 'test', 't2'), true,
				this.conversionService));
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s3', 'test', 't3'), false,
				this.conversionService));
		ConfigDataEnvironmentContributorPlaceholdersResolver resolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				contributors, null, null, true, this.conversionService);
		assertThatExceptionOfType(InactiveConfigDataAccessException.class)
			.isThrownBy(() -> resolver.resolvePlaceholders('${test}'))
			.satisfies(propertyNameAndOriginOf('test', 's3'));
	}
	@Test
	void resolvePlaceholderWhenFoundInInactiveAndIgnoringReturnsResolved() {
		List<ConfigDataEnvironmentContributor> contributors = new ArrayList<>();
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s1', 'nope', 't1'), true,
				this.conversionService));
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s2', 'test', 't2'), true,
				this.conversionService));
		contributors.add(new TestConfigDataEnvironmentContributor(new TestPropertySource('s3', 'test', 't3'), false,
				this.conversionService));
		ConfigDataEnvironmentContributorPlaceholdersResolver resolver = new ConfigDataEnvironmentContributorPlaceholdersResolver(
				contributors, null, null, false, this.conversionService);
		assertThat(resolver.resolvePlaceholders('${test}')).isEqualTo('t2');
	}
	private Consumer<InactiveConfigDataAccessException> propertyNameAndOriginOf(String propertyName, String origin) {
		return (ex) -> {
			assertThat(ex.getPropertyName()).isEqualTo(propertyName);
			assertThat(((PropertySourceOrigin) (ex.getOrigin())).getPropertySource().getName()).isEqualTo(origin);
		};
	}
	static class TestPropertySource extends MapPropertySource implements OriginLookup<String> {
		TestPropertySource(String name, String key, String value) {
			this(name, Collections.singletonMap(key, value));
		}
		TestPropertySource(String name, Map<String, Object> source) {
			super(name, source);
		}
		@Override
		public Origin getOrigin(String key) {
			if (getSource().containsKey(key)) {
				return new PropertySourceOrigin(this, key);
			}
			return null;
		}
	}
	static class TestConfigDataEnvironmentContributor extends ConfigDataEnvironmentContributor {
		private final boolean active;
		protected TestConfigDataEnvironmentContributor(PropertySource<?> propertySource, boolean active,
				ConversionService conversionService) {
			super(Kind.ROOT, null, null, false, propertySource, null, null, null, null, conversionService);
			this.active = active;
		}
		@Override
		boolean isActive(ConfigDataActivationContext activationContext) {
			return this.active;
		}
	}
	private static final class CustomValue {
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataLocationNotFoundExceptionTests {
	private final Origin origin = mock(Origin.class);
	private final ConfigDataLocation location = ConfigDataLocation.of('optional:test').withOrigin(this.origin);
	private final ConfigDataLocationNotFoundException exception = new ConfigDataLocationNotFoundException(
			this.location);
	@Test
	void createWhenLocationIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigDataLocationNotFoundException(null))
			.withMessage('Location must not be null');
	}
	@Test
	void getLocationReturnsLocation() {
		assertThat(this.exception.getLocation()).isSameAs(this.location);
	}
	@Test
	void getOriginReturnsLocationOrigin() {
		assertThat(this.exception.getOrigin()).isSameAs(this.origin);
	}
	@Test
	void getReferenceDescriptionReturnsLocationString() {
		assertThat(this.exception.getReferenceDescription()).isEqualTo('location "optional:test"');
	}
	@Test
	void getMessageReturnsMessage() {
		assertThat(this.exception).hasMessage('Config data location "optional:test" cannot be found');
	}
}
/*
package org.springframework.boot.context.config;
/**
class TestPropertySourceLoader1 implements PropertySourceLoader {
	@Override
	public String[] getFileExtensions() {
		return new String[] { 'custom' };
	}
	@Override
	public List<PropertySource<?>> load(String name, Resource resource) throws IOException {
		Map<String, Object> map = Collections.singletonMap('customloader1', 'true');
		return Collections.singletonList(new MapPropertySource(name, map));
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataNotFoundFailureAnalyzerTests {
	private final ConfigDataNotFoundFailureAnalyzer analyzer = new ConfigDataNotFoundFailureAnalyzer();
	@Test
	void analyzeWhenConfigDataLocationNotFoundException() {
		ConfigDataLocation location = ConfigDataLocation.of('test');
		ConfigDataLocationNotFoundException exception = new ConfigDataLocationNotFoundException(location);
		FailureAnalysis result = this.analyzer.analyze(exception);
		assertThat(result.getDescription()).isEqualTo('Config data location "test" does not exist');
		assertThat(result.getAction())
			.isEqualTo('Check that the value "test" is correct, or prefix it with "optional:"');
	}
	@Test
	void analyzeWhenOptionalConfigDataLocationNotFoundException() {
		ConfigDataLocation location = ConfigDataLocation.of('optional:test');
		ConfigDataLocationNotFoundException exception = new ConfigDataLocationNotFoundException(location);
		FailureAnalysis result = this.analyzer.analyze(exception);
		assertThat(result.getDescription()).isEqualTo('Config data location "optional:test" does not exist');
		assertThat(result.getAction()).isEqualTo('Check that the value "optional:test" is correct');
	}
	@Test
	void analyzeWhenConfigDataLocationWithOriginNotFoundException() {
		ConfigDataLocation location = ConfigDataLocation.of('test').withOrigin(new TestOrigin('origin'));
		ConfigDataLocationNotFoundException exception = new ConfigDataLocationNotFoundException(location);
		FailureAnalysis result = this.analyzer.analyze(exception);
		assertThat(result.getDescription()).isEqualTo('Config data location "test" does not exist');
		assertThat(result.getAction())
			.isEqualTo('Check that the value "test" at origin is correct, or prefix it with "optional:"');
	}
	@Test
	void analyzeWhenConfigDataResourceNotFoundException() {
		ConfigDataResource resource = new TestConfigDataResource('myresource');
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(resource);
		FailureAnalysis result = this.analyzer.analyze(exception);
		assertThat(result.getDescription()).isEqualTo('Config data resource "myresource" does not exist');
		assertThat(result.getAction()).isEqualTo('Check that the value is correct');
	}
	@Test
	void analyzeWhenConfigDataResourceWithLocationNotFoundException() {
		ConfigDataLocation location = ConfigDataLocation.of('test');
		ConfigDataResource resource = new TestConfigDataResource('myresource');
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(resource)
			.withLocation(location);
		FailureAnalysis result = this.analyzer.analyze(exception);
		assertThat(result.getDescription())
			.isEqualTo('Config data resource "myresource" via location "test" does not exist');
		assertThat(result.getAction())
			.isEqualTo('Check that the value "test" is correct, or prefix it with "optional:"');
	}
	static class TestOrigin implements Origin {
		private final String string;
		TestOrigin(String string) {
			this.string = string;
		}
		@Override
		public String toString() {
			return this.string;
		}
	}
	static class TestConfigDataResource extends ConfigDataResource {
		private final String string;
		TestConfigDataResource(String string) {
			this.string = string;
		}
		@Override
		public String toString() {
			return this.string;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
@ExtendWith(MockitoExtension.class)
class ConfigDataLocationResolversTests {
	private final DeferredLogFactory logFactory = Supplier::get;
	private final DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
	@Mock
	private Binder binder;
	@Mock
	private ConfigDataLocationResolverContext context;
	@Mock
	private Profiles profiles;
	@TempDir
	private File tempDir;
	@Test
	void createWhenInjectingDeferredLogFactoryCreatesResolver() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, TestLogResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		assertThat(resolvers.getResolvers()).hasSize(1);
		assertThat(resolvers.getResolvers().get(0)).isExactlyInstanceOf(TestLogResolver.class);
		TestLogResolver resolver = (TestLogResolver) resolvers.getResolvers().get(0);
		assertThat(resolver.getDeferredLogFactory()).isSameAs(this.logFactory);
	}
	@Test
	void createWhenInjectingBinderCreatesResolver() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, TestBoundResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		assertThat(resolvers.getResolvers()).hasSize(1);
		assertThat(resolvers.getResolvers().get(0)).isExactlyInstanceOf(TestBoundResolver.class);
		assertThat(((TestBoundResolver) resolvers.getResolvers().get(0)).getBinder()).isSameAs(this.binder);
	}
	@Test
	void createWhenNotInjectingBinderCreatesResolver() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, TestResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		assertThat(resolvers.getResolvers()).hasSize(1);
		assertThat(resolvers.getResolvers().get(0)).isExactlyInstanceOf(TestResolver.class);
	}
	@Test
	void createWhenResolverHasBootstrapParametersInjectsBootstrapContext() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, TestBootstrappingResolver.class);
		new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext, this.binder,
				new DefaultResourceLoader(), springFactoriesLoader);
		assertThat(this.bootstrapContext.get(String.class)).isEqualTo('boot');
	}
	@Test
	void createOrdersResolvers() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, TestResolver.class, LowestTestResolver.class,
				HighestTestResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		assertThat(resolvers.getResolvers().get(0)).isExactlyInstanceOf(HighestTestResolver.class);
		assertThat(resolvers.getResolvers().get(1)).isExactlyInstanceOf(TestResolver.class);
		assertThat(resolvers.getResolvers().get(2)).isExactlyInstanceOf(LowestTestResolver.class);
	}
	@Test
	void resolveResolvesUsingFirstSupportedResolver() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, LowestTestResolver.class,
				HighestTestResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		ConfigDataLocation location = ConfigDataLocation.of('LowestTestResolver:test');
		List<ConfigDataResolutionResult> resolved = resolvers.resolve(this.context, location, null);
		assertThat(resolved).hasSize(1);
		TestConfigDataResource resource = (TestConfigDataResource) resolved.get(0).getResource();
		assertThat(resource.getResolver()).isInstanceOf(LowestTestResolver.class);
		assertThat(resource.getLocation()).isEqualTo(location);
		assertThat(resource.isProfileSpecific()).isFalse();
	}
	@Test
	void resolveWhenProfileMergesResolvedLocations() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, LowestTestResolver.class,
				HighestTestResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		ConfigDataLocation location = ConfigDataLocation.of('LowestTestResolver:test');
		List<ConfigDataResolutionResult> resolved = resolvers.resolve(this.context, location, this.profiles);
		assertThat(resolved).hasSize(2);
		TestConfigDataResource resource = (TestConfigDataResource) resolved.get(0).getResource();
		assertThat(resource.getResolver()).isInstanceOf(LowestTestResolver.class);
		assertThat(resource.getLocation()).isEqualTo(location);
		assertThat(resource.isProfileSpecific()).isFalse();
		TestConfigDataResource profileResource = (TestConfigDataResource) resolved.get(1).getResource();
		assertThat(profileResource.getResolver()).isInstanceOf(LowestTestResolver.class);
		assertThat(profileResource.getLocation()).isEqualTo(location);
		assertThat(profileResource.isProfileSpecific()).isTrue();
	}
	@Test
	void resolveWhenNoResolverThrowsException() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, LowestTestResolver.class,
				HighestTestResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		ConfigDataLocation location = ConfigDataLocation.of('Missing:test');
		assertThatExceptionOfType(UnsupportedConfigDataLocationException.class)
			.isThrownBy(() -> resolvers.resolve(this.context, location, null))
			.satisfies((ex) -> assertThat(ex.getLocation()).isEqualTo(location));
	}
	@Test
	void resolveWhenOptional() {
		MockSpringFactoriesLoader springFactoriesLoader = new MockSpringFactoriesLoader();
		springFactoriesLoader.add(ConfigDataLocationResolver.class, OptionalResourceTestResolver.class);
		ConfigDataLocationResolvers resolvers = new ConfigDataLocationResolvers(this.logFactory, this.bootstrapContext,
				this.binder, new DefaultResourceLoader(), springFactoriesLoader);
		ConfigDataLocation location = ConfigDataLocation.of('OptionalResourceTestResolver:test');
		List<ConfigDataResolutionResult> resolved = resolvers.resolve(this.context, location, null);
		assertThat(resolved.get(0).getResource().isOptional()).isTrue();
	}
	static class TestResolver implements ConfigDataLocationResolver<TestConfigDataResource> {
		private final boolean optionalResource;
		TestResolver() {
			this(false);
		}
		private TestResolver(boolean optionalResource) {
			this.optionalResource = optionalResource;
		}
		@Override
		public boolean isResolvable(ConfigDataLocationResolverContext context, ConfigDataLocation location) {
			String name = getClass().getName();
			name = name.substring(name.lastIndexOf('$') + 1);
			return location.hasPrefix(name + ':');
		}
		@Override
		public List<TestConfigDataResource> resolve(ConfigDataLocationResolverContext context,
				ConfigDataLocation location) {
			return Collections.singletonList(new TestConfigDataResource(this.optionalResource, this, location, false));
		}
		@Override
		public List<TestConfigDataResource> resolveProfileSpecific(ConfigDataLocationResolverContext context,
				ConfigDataLocation location, Profiles profiles) {
			return Collections.singletonList(new TestConfigDataResource(this.optionalResource, this, location, true));
		}
	}
	static class TestLogResolver extends TestResolver {
		private final DeferredLogFactory deferredLogFactory;
		TestLogResolver(DeferredLogFactory deferredLogFactory) {
			this.deferredLogFactory = deferredLogFactory;
		}
		DeferredLogFactory getDeferredLogFactory() {
			return this.deferredLogFactory;
		}
	}
	static class TestBoundResolver extends TestResolver {
		private final Binder binder;
		TestBoundResolver(Binder binder) {
			this.binder = binder;
		}
		Binder getBinder() {
			return this.binder;
		}
	}
	static class TestBootstrappingResolver extends TestResolver {
		TestBootstrappingResolver(ConfigurableBootstrapContext configurableBootstrapContext,
				BootstrapRegistry bootstrapRegistry, BootstrapContext bootstrapContext) {
			assertThat(configurableBootstrapContext).isNotNull();
			assertThat(bootstrapRegistry).isNotNull();
			assertThat(bootstrapContext).isNotNull();
			assertThat(configurableBootstrapContext).isEqualTo(bootstrapRegistry).isEqualTo(bootstrapContext);
			bootstrapRegistry.register(String.class, InstanceSupplier.of('boot'));
		}
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	static class HighestTestResolver extends TestResolver {
	}
	@Order(Ordered.LOWEST_PRECEDENCE)
	static class LowestTestResolver extends TestResolver {
	}
	static class OptionalResourceTestResolver extends TestResolver {
		OptionalResourceTestResolver() {
			super(true);
		}
	}
	static class TestConfigDataResource extends ConfigDataResource {
		private final TestResolver resolver;
		private final ConfigDataLocation location;
		private final boolean profileSpecific;
		TestConfigDataResource(boolean optional, TestResolver resolver, ConfigDataLocation location,
				boolean profileSpecific) {
			super(optional);
			this.resolver = resolver;
			this.location = location;
			this.profileSpecific = profileSpecific;
		}
		TestResolver getResolver() {
			return this.resolver;
		}
		ConfigDataLocation getLocation() {
			return this.location;
		}
		boolean isProfileSpecific() {
			return this.profileSpecific;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataPropertiesRuntimeHintsTests {
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new ConfigDataPropertiesRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(ConfigDataProperties.class)).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onType(ConfigDataLocation.class)).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onType(Activate.class)).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(ConfigDataLocation.class, 'of')).accepts(hints);
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataEnvironmentPostProcessorBootstrapContextIntegrationTests {
	private SpringApplication application;
	@BeforeEach
	void setup() {
		this.application = new SpringApplication(Config.class);
		this.application.setWebApplicationType(WebApplicationType.NONE);
	}
	@Test
	void bootstrapsApplicationContext() {
		try (ConfigurableApplicationContext context = this.application
			.run('--spring.config.import=classpath:application-bootstrap-registry-integration-tests.properties')) {
			LoaderHelper bean = context.getBean(TestConfigDataBootstrap.LoaderHelper.class);
			assertThat(bean).isNotNull();
			assertThat(bean.getBound()).isEqualTo('igotbound');
			assertThat(bean.getProfileBound()).isEqualTo('igotprofilebound');
			assertThat(bean.getLocation().getResolverHelper().getLocation())
				.isEqualTo(ConfigDataLocation.of('testbootstrap:test'));
		}
	}
	@Configuration
	static class Config {
	}
}
/*
package org.springframework.boot.context.config;
/**
class ConfigDataResourceNotFoundExceptionTests {
	private final ConfigDataResource resource = new TestConfigDataResource();
	private final ConfigDataLocation location = ConfigDataLocation.of('optional:test');
	private final Throwable cause = new RuntimeException();
	private File exists;
	private File missing;
	@TempDir
	File temp;
	@BeforeEach
	void setup() throws IOException {
		this.exists = new File(this.temp, 'exists');
		this.missing = new File(this.temp, 'missing');
		try (OutputStream out = new FileOutputStream(this.exists)) {
			out.write('test'.getBytes());
		}
	}
	@Test
	void createWhenResourceIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigDataResourceNotFoundException(null))
			.withMessage('Resource must not be null');
	}
	@Test
	void createWithResourceCreatesInstance() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource);
		assertThat(exception.getResource()).isSameAs(this.resource);
	}
	@Test
	void createWithResourceAndCauseCreatesInstance() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource,
				this.cause);
		assertThat(exception.getResource()).isSameAs(this.resource);
		assertThat(exception.getCause()).isSameAs(this.cause);
	}
	@Test
	void getResourceReturnsResource() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource);
		assertThat(exception.getResource()).isSameAs(this.resource);
	}
	@Test
	void getLocationWhenHasNoLocationReturnsNull() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource);
		assertThat(exception.getLocation()).isNull();
	}
	@Test
	void getLocationWhenHasLocationReturnsLocation() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource)
			.withLocation(this.location);
		assertThat(exception.getLocation()).isSameAs(this.location);
	}
	@Test
	void getReferenceDescriptionWhenHasNoLocationReturnsDescription() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource);
		assertThat(exception.getReferenceDescription()).isEqualTo('resource "mytestresource"');
	}
	@Test
	void getReferenceDescriptionWhenHasLocationReturnsDescription() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource)
			.withLocation(this.location);
		assertThat(exception.getReferenceDescription())
			.isEqualTo('resource "mytestresource" via location "optional:test"');
	}
	@Test
	void withLocationReturnsNewInstanceWithLocation() {
		ConfigDataResourceNotFoundException exception = new ConfigDataResourceNotFoundException(this.resource)
			.withLocation(this.location);
		assertThat(exception.getLocation()).isSameAs(this.location);
	}
	@Test
	void throwIfDoesNotExistWhenPathExistsDoesNothing() {
		ConfigDataResourceNotFoundException.throwIfDoesNotExist(this.resource, this.exists.toPath());
	}
	@Test
	void throwIfDoesNotExistWhenPathDoesNotExistThrowsException() {
		assertThatExceptionOfType(ConfigDataResourceNotFoundException.class).isThrownBy(
				() -> ConfigDataResourceNotFoundException.throwIfDoesNotExist(this.resource, this.missing.toPath()));
	}
	@Test
	void throwIfDoesNotExistWhenFileExistsDoesNothing() {
		ConfigDataResourceNotFoundException.throwIfDoesNotExist(this.resource, this.exists);
	}
	@Test
	void throwIfDoesNotExistWhenFileDoesNotExistThrowsException() {
		assertThatExceptionOfType(ConfigDataResourceNotFoundException.class)
			.isThrownBy(() -> ConfigDataResourceNotFoundException.throwIfDoesNotExist(this.resource, this.missing));
	}
	@Test
	void throwIfDoesNotExistWhenResourceExistsDoesNothing() {
		ConfigDataResourceNotFoundException.throwIfDoesNotExist(this.resource, new FileSystemResource(this.exists));
	}
	@Test
	void throwIfDoesNotExistWhenResourceDoesNotExistThrowsException() {
		assertThatExceptionOfType(ConfigDataResourceNotFoundException.class)
			.isThrownBy(() -> ConfigDataResourceNotFoundException.throwIfDoesNotExist(this.resource,
					new FileSystemResource(this.missing)));
	}
	static class TestConfigDataResource extends ConfigDataResource {
		@Override
		public String toString() {
			return 'mytestresource';
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
class StandardConfigDataLoaderTests {
	private final StandardConfigDataLoader loader = new StandardConfigDataLoader();
	private final ConfigDataLoaderContext loaderContext = mock(ConfigDataLoaderContext.class);
	@Test
	void loadWhenLocationResultsInMultiplePropertySourcesAddsAllToConfigData() throws IOException {
		ClassPathResource resource = new ClassPathResource('configdata/yaml/application.yml');
		StandardConfigDataReference reference = new StandardConfigDataReference(
				ConfigDataLocation.of('classpath:configdata/yaml/application.yml'), null,
				'classpath:configdata/yaml/application', null, 'yml', new YamlPropertySourceLoader());
		StandardConfigDataResource location = new StandardConfigDataResource(reference, resource);
		ConfigData configData = this.loader.load(this.loaderContext, location);
		assertThat(configData.getPropertySources()).hasSize(2);
		PropertySource<?> source1 = configData.getPropertySources().get(0);
		PropertySource<?> source2 = configData.getPropertySources().get(1);
		assertThat(source1.getName())
			.isEqualTo('Config resource "class path resource [configdata/yaml/application.yml]" '
					+ 'via location "classpath:configdata/yaml/application.yml" (document #0)');
		assertThat(source1.getProperty('foo')).isEqualTo('bar');
		assertThat(source2.getName())
			.isEqualTo('Config resource "class path resource [configdata/yaml/application.yml]" '
					+ 'via location "classpath:configdata/yaml/application.yml" (document #1)');
		assertThat(source2.getProperty('hello')).isEqualTo('world');
	}
	@Test
	void loadWhenPropertySourceIsEmptyAddsNothingToConfigData() throws IOException {
		ClassPathResource resource = new ClassPathResource('config/0-empty/testproperties.properties');
		StandardConfigDataReference reference = new StandardConfigDataReference(
				ConfigDataLocation.of('classpath:config/0-empty/testproperties.properties'), null,
				'config/0-empty/testproperties', null, 'properties', new PropertiesPropertySourceLoader());
		StandardConfigDataResource location = new StandardConfigDataResource(reference, resource);
		ConfigData configData = this.loader.load(this.loaderContext, location);
		assertThat(configData.getPropertySources()).isEmpty();
	}
}
/*
package org.springframework.boot.context.config;
/**
class ProfilesTests {
	@Test
	void getActiveWhenNoEnvironmentProfilesAndNoPropertyReturnsEmptyArray() {
		Environment environment = new MockEnvironment();
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).isEmpty();
	}
	@Test
	void getActiveWhenNoEnvironmentProfilesAndBinderProperty() {
		Environment environment = new MockEnvironment();
		Binder binder = new Binder(
				new MapConfigurationPropertySource(Collections.singletonMap('spring.profiles.active', 'a,b,c')));
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getActiveWhenNoEnvironmentProfilesAndEnvironmentProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getActiveWhenEnvironmentProfilesAndBinderProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		Binder binder = new Binder(
				new MapConfigurationPropertySource(Collections.singletonMap('spring.profiles.active', 'd,e,f')));
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c', 'd', 'e', 'f');
	}
	@Test
	void getActiveWhenEnvironmentProfilesAndBinderPropertyShouldReturnEnvironmentProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		List<ConfigurationPropertySource> sources = new ArrayList<>();
		ConfigurationPropertySources.get(environment).forEach(sources::add);
		sources.add(new MapConfigurationPropertySource(Collections.singletonMap('spring.profiles.active', 'd,e,f')));
		Binder binder = new Binder(sources);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getActiveWhenEnvironmentProfilesAndEnvironmentProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		environment.setProperty('spring.profiles.active', 'd,e,f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c', 'd', 'e', 'f');
	}
	@Test
	void getActiveWhenNoEnvironmentProfilesAndEnvironmentPropertyInBindNotation() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active[0]', 'a');
		environment.setProperty('spring.profiles.active[1]', 'b');
		environment.setProperty('spring.profiles.active[2]', 'c');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getActiveWhenEnvironmentProfilesInBindNotationAndEnvironmentPropertyReturnsEnvironmentProfiles() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		environment.setProperty('spring.profiles.active[0]', 'd');
		environment.setProperty('spring.profiles.active[1]', 'e');
		environment.setProperty('spring.profiles.active[2]', 'f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c', 'd', 'e', 'f');
	}
	@Test
	void getActiveWhenHasDuplicatesReturnsUniqueElements() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,a,b,c');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getActiveWithProfileGroups() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'd,e');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getActive()).containsExactly('a', 'd', 'e', 'b', 'c');
	}
	@Test
	void getActiveWhenHasAdditionalIncludesAdditional() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'd,e,f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, Arrays.asList('a', 'b', 'c'));
		assertThat(profiles.getActive()).containsExactly('a', 'b', 'c', 'd', 'e', 'f');
	}
	@Test
	void getDefaultWhenNoEnvironmentProfilesAndNoPropertyReturnsEmptyArray() {
		Environment environment = new MockEnvironment();
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('default');
	}
	@Test
	void getDefaultWhenNoEnvironmentProfilesAndBinderProperty() {
		Environment environment = new MockEnvironment();
		Binder binder = new Binder(
				new MapConfigurationPropertySource(Collections.singletonMap('spring.profiles.default', 'a,b,c')));
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getDefaultWhenDefaultEnvironmentProfileAndBinderProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.default', 'default');
		List<ConfigurationPropertySource> sources = new ArrayList<>();
		ConfigurationPropertySources.get(environment).forEach(sources::add);
		sources.add(new MapConfigurationPropertySource(Collections.singletonMap('spring.profiles.default', 'a,b,c')));
		Binder binder = new Binder(sources);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('default');
	}
	@Test
	void getDefaultWhenNoEnvironmentProfilesAndEnvironmentProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.default', 'a,b,c');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getDefaultWhenEnvironmentProfilesAndBinderProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('a', 'b', 'c');
		Binder binder = new Binder(
				new MapConfigurationPropertySource(Collections.singletonMap('spring.profiles.default', 'd,e,f')));
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getDefaultWhenEnvironmentProfilesAndEnvironmentProperty() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('a', 'b', 'c');
		environment.setProperty('spring.profiles.default', 'd,e,f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getDefaultWhenNoEnvironmentProfilesAndEnvironmentPropertyInBindNotation() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.default[0]', 'a');
		environment.setProperty('spring.profiles.default[1]', 'b');
		environment.setProperty('spring.profiles.default[2]', 'c');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getDefaultWhenHasDuplicatesReturnsUniqueElements() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.default', 'a,b,a,b,c');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'b', 'c');
	}
	@Test
	void getDefaultWithProfileGroups() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.default', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'd,e');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'd', 'e', 'b', 'c');
	}
	@Test
	void getDefaultWhenEnvironmentProfilesInBindNotationAndEnvironmentPropertyReturnsBoth() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('a', 'b', 'c');
		environment.setProperty('spring.profiles.default[0]', 'd');
		environment.setProperty('spring.profiles.default[1]', 'e');
		environment.setProperty('spring.profiles.default[2]', 'f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getDefault()).containsExactly('a', 'b', 'c');
	}
	@Test
	void iteratorIteratesAllActiveProfiles() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		environment.setDefaultProfiles('d', 'e', 'f');
		Binder binder = Binder.get(environment);
		Profiles profiles1 = new Profiles(environment, binder, null);
		Profiles profiles = profiles1;
		assertThat(profiles).containsExactly('a', 'b', 'c');
	}
	@Test
	void iteratorIteratesAllDefaultProfilesWhenNoActive() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('d', 'e', 'f');
		Binder binder = Binder.get(environment);
		Profiles profiles1 = new Profiles(environment, binder, null);
		Profiles profiles = profiles1;
		assertThat(profiles).containsExactly('d', 'e', 'f');
	}
	@Test
	void isActiveWhenActiveContainsProfileReturnsTrue() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		Binder binder = Binder.get(environment);
		Profiles profiles1 = new Profiles(environment, binder, null);
		Profiles profiles = profiles1;
		assertThat(profiles.isAccepted('a')).isTrue();
	}
	@Test
	void isActiveWhenActiveDoesNotContainProfileReturnsFalse() {
		MockEnvironment environment = new MockEnvironment();
		environment.setActiveProfiles('a', 'b', 'c');
		Binder binder = Binder.get(environment);
		Profiles profiles1 = new Profiles(environment, binder, null);
		Profiles profiles = profiles1;
		assertThat(profiles.isAccepted('x')).isFalse();
	}
	@Test
	void isActiveWhenNoActiveAndDefaultContainsProfileReturnsTrue() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('d', 'e', 'f');
		Binder binder = Binder.get(environment);
		Profiles profiles1 = new Profiles(environment, binder, null);
		Profiles profiles = profiles1;
		assertThat(profiles.isAccepted('d')).isTrue();
	}
	@Test
	void isActiveWhenNoActiveAndDefaultDoesNotContainProfileReturnsFalse() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('d', 'e', 'f');
		Binder binder = Binder.get(environment);
		Profiles profiles1 = new Profiles(environment, binder, null);
		Profiles profiles = profiles1;
		assertThat(profiles.isAccepted('x')).isFalse();
	}
	@Test
	void iteratorWithProfileGroups() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'e,f');
		environment.setProperty('spring.profiles.group.e', 'x,y');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles).containsExactly('a', 'e', 'x', 'y', 'f', 'b', 'c');
	}
	@Test
	void iteratorWithProfileGroupsAndNoActive() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.group.a', 'e,f');
		environment.setProperty('spring.profiles.group.e', 'x,y');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles).containsExactly('default');
	}
	@Test
	void iteratorWithProfileGroupsForDefault() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.group.default', 'e,f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles).containsExactly('default', 'e', 'f');
	}
	@Test
	void getAcceptedWithProfileGroups() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'e,f');
		environment.setProperty('spring.profiles.group.e', 'x,y');
		environment.setDefaultProfiles('g', 'h', 'i');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getAccepted()).containsExactly('a', 'e', 'x', 'y', 'f', 'b', 'c');
	}
	@Test
	void getAcceptedWhenNoActiveAndDefaultWithGroups() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('d', 'e', 'f');
		environment.setProperty('spring.profiles.group.e', 'x,y');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getAccepted()).containsExactly('d', 'e', 'x', 'y', 'f');
	}
	@Test
	void isAcceptedWithGroupsReturnsTrue() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'e,f');
		environment.setProperty('spring.profiles.group.e', 'x,y');
		environment.setDefaultProfiles('g', 'h', 'i');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.isAccepted('a')).isTrue();
		assertThat(profiles.isAccepted('e')).isTrue();
		assertThat(profiles.isAccepted('g')).isFalse();
	}
	@Test
	void isAcceptedWhenNoActiveAndDefaultWithGroupsContainsProfileReturnsTrue() {
		MockEnvironment environment = new MockEnvironment();
		environment.setDefaultProfiles('d', 'e', 'f');
		environment.setProperty('spring.profiles.group.e', 'x,y');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.isAccepted('d')).isTrue();
		assertThat(profiles.isAccepted('x')).isTrue();
	}
	@Test
	void simpleRecursiveReferenceInProfileGroupIgnoresDuplicates() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'a,e,f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getAccepted()).containsExactly('a', 'e', 'f', 'b', 'c');
	}
	@Test
	void multipleRecursiveReferenceInProfileGroupIgnoresDuplicates() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'a,b,f');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getAccepted()).containsExactly('a', 'b', 'f', 'c');
	}
	@Test
	void complexRecursiveReferenceInProfileGroupIgnoresDuplicates() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('spring.profiles.active', 'a,b,c');
		environment.setProperty('spring.profiles.group.a', 'e,f,g');
		environment.setProperty('spring.profiles.group.e', 'a,x,y,g');
		Binder binder = Binder.get(environment);
		Profiles profiles = new Profiles(environment, binder, null);
		assertThat(profiles.getAccepted()).containsExactly('a', 'e', 'x', 'y', 'g', 'f', 'b', 'c');
	}
}
/*
package org.springframework.boot.context.config;
/**
class UnsupportedConfigDataLocationExceptionTests {
	@Test
	void createSetsMessage() {
		UnsupportedConfigDataLocationException exception = new UnsupportedConfigDataLocationException(
				ConfigDataLocation.of('test'));
		assertThat(exception).hasMessage('Unsupported config data location "test"');
	}
	@Test
	void getLocationReturnsLocation() {
		ConfigDataLocation location = ConfigDataLocation.of('test');
		UnsupportedConfigDataLocationException exception = new UnsupportedConfigDataLocationException(location);
		assertThat(exception.getLocation()).isEqualTo(location);
	}
}
/*
package org.springframework.boot.context.config;
class TestConfigDataEnvironmentUpdateListener implements ConfigDataEnvironmentUpdateListener {
	private final List<AddedPropertySource> addedPropertySources = new ArrayList<>();
	private Profiles profiles;
	@Override
	public void onPropertySourceAdded(PropertySource<?> propertySource, ConfigDataLocation location,
			ConfigDataResource resource) {
		this.addedPropertySources.add(new AddedPropertySource(propertySource, location, resource));
	}
	@Override
	public void onSetProfiles(Profiles profiles) {
		this.profiles = profiles;
	}
	List<AddedPropertySource> getAddedPropertySources() {
		return Collections.unmodifiableList(this.addedPropertySources);
	}
	Profiles getProfiles() {
		return this.profiles;
	}
	static class AddedPropertySource {
		private final PropertySource<?> propertySource;
		private final ConfigDataLocation location;
		private final ConfigDataResource resource;
		AddedPropertySource(PropertySource<?> propertySource, ConfigDataLocation location,
				ConfigDataResource resource) {
			this.propertySource = propertySource;
			this.location = location;
			this.resource = resource;
		}
		PropertySource<?> getPropertySource() {
			return this.propertySource;
		}
		ConfigDataLocation getLocation() {
			return this.location;
		}
		ConfigDataResource getResource() {
			return this.resource;
		}
	}
}
/*
package org.springframework.boot.context.config;
/**
@ExtendWith(MockitoExtension.class)
class ConfigDataEnvironmentPostProcessorTests {
	private final StandardEnvironment environment = new StandardEnvironment();
	private final SpringApplication application = new SpringApplication();
	@Mock
	private ConfigDataEnvironment configDataEnvironment;
	@Spy
	private ConfigDataEnvironmentPostProcessor postProcessor = new ConfigDataEnvironmentPostProcessor(Supplier::get,
			new DefaultBootstrapContext());
	@Test
	void postProcessEnvironmentWhenNoLoaderCreatesDefaultLoaderInstance() {
		willReturn(this.configDataEnvironment).given(this.postProcessor).getConfigDataEnvironment(any(), any(), any());
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		then(this.postProcessor).should()
			.getConfigDataEnvironment(any(),
					assertArg((resourceLoader) -> assertThat(resourceLoader).isInstanceOf(DefaultResourceLoader.class)),
					any());
		then(this.configDataEnvironment).should().processAndApply();
	}
	@Test
	void postProcessEnvironmentWhenCustomLoaderUsesSpecifiedLoaderInstance() {
		ResourceLoader resourceLoader = mock(ResourceLoader.class);
		this.application.setResourceLoader(resourceLoader);
		willReturn(this.configDataEnvironment).given(this.postProcessor).getConfigDataEnvironment(any(), any(), any());
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		then(this.postProcessor).should()
			.getConfigDataEnvironment(any(),
					assertArg((resourceLoaderB) -> assertThat(resourceLoaderB).isSameAs(resourceLoader)), any());
		then(this.configDataEnvironment).should().processAndApply();
	}
	@Test
	void postProcessEnvironmentWhenHasAdditionalProfilesOnSpringApplicationUsesAdditionalProfiles() {
		this.application.setAdditionalProfiles('dev');
		willReturn(this.configDataEnvironment).given(this.postProcessor).getConfigDataEnvironment(any(), any(), any());
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		then(this.postProcessor).should()
			.getConfigDataEnvironment(any(), any(),
					assertArg((additionalProperties) -> assertThat(additionalProperties).containsExactly('dev')));
		then(this.configDataEnvironment).should().processAndApply();
	}
	@Test
	void postProcessEnvironmentWhenNoActiveProfiles() {
		willReturn(this.configDataEnvironment).given(this.postProcessor).getConfigDataEnvironment(any(), any(), any());
		this.postProcessor.postProcessEnvironment(this.environment, this.application);
		then(this.postProcessor).should().getConfigDataEnvironment(any(), any(ResourceLoader.class), any());
		then(this.configDataEnvironment).should().processAndApply();
		assertThat(this.environment.getActiveProfiles()).isEmpty();
	}
	@Test
	void applyToAppliesPostProcessing() {
		int before = this.environment.getPropertySources().size();
		TestConfigDataEnvironmentUpdateListener listener = new TestConfigDataEnvironmentUpdateListener();
		ConfigDataEnvironmentPostProcessor.applyTo(this.environment, null, null, Collections.singleton('dev'),
				listener);
		assertThat(this.environment.getPropertySources()).hasSizeGreaterThan(before);
		assertThat(this.environment.getActiveProfiles()).containsExactly('dev');
		assertThat(listener.getAddedPropertySources()).isNotEmpty();
		assertThat(listener.getProfiles().getActive()).containsExactly('dev');
		assertThat(listener.getAddedPropertySources().stream().anyMatch((added) -> hasDevProfile(added.getResource())))
			.isTrue();
	}
	private boolean hasDevProfile(ConfigDataResource resource) {
		return (resource instanceof StandardConfigDataResource standardResource)
				&& 'dev'.equals(standardResource.getProfile());
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConversionServiceDeducerTests {
	@Test
	void getConversionServicesWhenHasConversionServiceBeanContainsOnlyBean() {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				CustomConverterServiceConfiguration.class);
		ConversionServiceDeducer deducer = new ConversionServiceDeducer(applicationContext);
		TestApplicationConversionService expected = applicationContext.getBean(TestApplicationConversionService.class);
		assertThat(deducer.getConversionServices()).containsExactly(expected);
	}
	@Test
	void getConversionServiceWhenHasNoConversionServiceBeanAndNoQualifiedBeansAndNoBeanFactoryConversionServiceReturnsEmptyList() {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(EmptyConfiguration.class);
		ConversionServiceDeducer deducer = new ConversionServiceDeducer(applicationContext);
		assertThat(deducer.getConversionServices()).isEmpty();
	}
	@Test
	void getConversionServiceWhenHasNoConversionServiceBeanAndNoQualifiedBeansAndBeanFactoryConversionServiceContainsOnlyBeanFactoryInstance() {
		ConfigurableApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				EmptyConfiguration.class);
		ConversionService conversionService = new ApplicationConversionService();
		applicationContext.getBeanFactory().setConversionService(conversionService);
		ConversionServiceDeducer deducer = new ConversionServiceDeducer(applicationContext);
		List<ConversionService> conversionServices = deducer.getConversionServices();
		assertThat(conversionServices).containsOnly(conversionService);
		assertThat(conversionServices.get(0)).isSameAs(conversionService);
	}
	@Test
	void getConversionServiceWhenHasQualifiedConverterBeansContainsCustomizedFormattingService() {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				CustomConverterConfiguration.class);
		ConversionServiceDeducer deducer = new ConversionServiceDeducer(applicationContext);
		List<ConversionService> conversionServices = deducer.getConversionServices();
		assertThat(conversionServices).hasSize(2);
		assertThat(conversionServices.get(0)).isExactlyInstanceOf(FormattingConversionService.class);
		assertThat(conversionServices.get(0).canConvert(InputStream.class, OutputStream.class)).isTrue();
		assertThat(conversionServices.get(0).canConvert(CharSequence.class, InputStream.class)).isTrue();
		assertThat(conversionServices.get(1)).isSameAs(ApplicationConversionService.getSharedInstance());
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConverterServiceConfiguration {
		@Bean(ConfigurableApplicationContext.CONVERSION_SERVICE_BEAN_NAME)
		TestApplicationConversionService conversionService() {
			return new TestApplicationConversionService();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConverterConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		TestConverter testConverter() {
			return new TestConverter();
		}
		@Bean
		@ConfigurationPropertiesBinding
		StringConverter stringConverter() {
			return new StringConverter();
		}
	}
	private static final class TestApplicationConversionService extends ApplicationConversionService {
	}
	private static final class TestConverter implements Converter<InputStream, OutputStream> {
		@Override
		public OutputStream convert(InputStream source) {
			throw new UnsupportedOperationException();
		}
	}
	private static final class StringConverter implements Converter<String, InputStream> {
		@Override
		public InputStream convert(String source) {
			throw new UnsupportedOperationException();
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
public class WithPublicObjectToObjectMethod {
	private final String value;
	WithPublicObjectToObjectMethod(String value) {
		this.value = value;
	}
	String getValue() {
		return this.value;
	}
	public static Optional<WithPublicObjectToObjectMethod> from(String value) {
		return Optional.of(new WithPublicObjectToObjectMethod(value));
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBindExceptionTests {
	@Test
	void createFromBeanHasDetails() {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(Example.class);
		ConfigurationPropertiesBean bean = ConfigurationPropertiesBean.get(applicationContext,
				applicationContext.getBean(Example.class), 'example');
		ConfigurationPropertiesBindException exception = new ConfigurationPropertiesBindException(bean,
				new IllegalStateException());
		assertThat(exception.getMessage()).isEqualTo('Error creating bean with name "example": '
				+ 'Could not bind properties to "ConfigurationPropertiesBindExceptionTests.Example" : '
				+ 'prefix=, ignoreInvalidFields=false, ignoreUnknownFields=true');
		assertThat(exception.getBeanType()).isEqualTo(Example.class);
		assertThat(exception.getBeanName()).isEqualTo('example');
		assertThat(exception.getAnnotation()).isInstanceOf(ConfigurationProperties.class);
		assertThat(exception.getCause()).isInstanceOf(IllegalStateException.class);
	}
	@Component('example')
	@ConfigurationProperties
	static class Example {
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBeanTests {
	@Test
	void getAllReturnsAll() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				NonAnnotatedComponent.class, AnnotatedComponent.class, AnnotatedBeanConfiguration.class,
				ValueObjectConfiguration.class)) {
			Map<String, ConfigurationPropertiesBean> all = ConfigurationPropertiesBean.getAll(context);
			assertThat(all).containsOnlyKeys('annotatedComponent', 'annotatedBean', ValueObject.class.getName());
			ConfigurationPropertiesBean component = all.get('annotatedComponent');
			assertThat(component.getName()).isEqualTo('annotatedComponent');
			assertThat(component.getInstance()).isInstanceOf(AnnotatedComponent.class);
			assertThat(component.getAnnotation()).isNotNull();
			assertThat(component.getType()).isEqualTo(AnnotatedComponent.class);
			assertThat(component.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
			ConfigurationPropertiesBean bean = all.get('annotatedBean');
			assertThat(bean.getName()).isEqualTo('annotatedBean');
			assertThat(bean.getInstance()).isInstanceOf(AnnotatedBean.class);
			assertThat(bean.getType()).isEqualTo(AnnotatedBean.class);
			assertThat(bean.getAnnotation()).isNotNull();
			assertThat(bean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
			ConfigurationPropertiesBean valueObject = all.get(ValueObject.class.getName());
			assertThat(valueObject.getName()).isEqualTo(ValueObject.class.getName());
			assertThat(valueObject.getInstance()).isInstanceOf(ValueObject.class);
			assertThat(valueObject.getType()).isEqualTo(ValueObject.class);
			assertThat(valueObject.getAnnotation()).isNotNull();
			assertThat(valueObject.asBindTarget().getBindMethod()).isEqualTo(BindMethod.VALUE_OBJECT);
		}
	}
	@Test
	void getAllDoesNotFindABeanDeclaredInAStaticBeanMethodOnAConfigurationAndConfigurationPropertiesAnnotatedClass() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				StaticBeanMethodConfiguration.class)) {
			Map<String, ConfigurationPropertiesBean> all = ConfigurationPropertiesBean.getAll(context);
			assertThat(all).containsOnlyKeys('configurationPropertiesBeanTests.StaticBeanMethodConfiguration');
		}
	}
	@Test
	void getAllWhenHasBadBeanDoesNotFail() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				NonAnnotatedComponent.class, AnnotatedComponent.class, AnnotatedBeanConfiguration.class,
				ValueObjectConfiguration.class, BadBeanConfiguration.class)) {
			Map<String, ConfigurationPropertiesBean> all = ConfigurationPropertiesBean.getAll(context);
			assertThat(all).isNotEmpty();
		}
	}
	@Test
	void getWhenNotAnnotatedReturnsNull() throws Throwable {
		get(NonAnnotatedComponent.class, 'nonAnnotatedComponent',
				(propertiesBean) -> assertThat(propertiesBean).isNull());
	}
	@Test
	void getWhenBeanIsAnnotatedReturnsBean() throws Throwable {
		get(AnnotatedComponent.class, 'annotatedComponent', (propertiesBean) -> {
			assertThat(propertiesBean).isNotNull();
			assertThat(propertiesBean.getName()).isEqualTo('annotatedComponent');
			assertThat(propertiesBean.getInstance()).isInstanceOf(AnnotatedComponent.class);
			assertThat(propertiesBean.getType()).isEqualTo(AnnotatedComponent.class);
			assertThat(propertiesBean.getAnnotation().prefix()).isEqualTo('prefix');
			assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
		});
	}
	@Test
	void getWhenFactoryMethodIsAnnotatedReturnsBean() throws Throwable {
		get(NonAnnotatedBeanConfiguration.class, 'nonAnnotatedBean', (propertiesBean) -> {
			assertThat(propertiesBean).isNotNull();
			assertThat(propertiesBean.getName()).isEqualTo('nonAnnotatedBean');
			assertThat(propertiesBean.getInstance()).isInstanceOf(NonAnnotatedBean.class);
			assertThat(propertiesBean.getType()).isEqualTo(NonAnnotatedBean.class);
			assertThat(propertiesBean.getAnnotation().prefix()).isEqualTo('prefix');
			assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
		});
	}
	@Test
	void getWhenImportedFactoryMethodIsAnnotatedAndMetadataCachingIsDisabledReturnsBean() throws Throwable {
		getWithoutBeanMetadataCaching(NonAnnotatedBeanImportConfiguration.class, 'nonAnnotatedBean',
				(propertiesBean) -> {
					assertThat(propertiesBean).isNotNull();
					assertThat(propertiesBean.getName()).isEqualTo('nonAnnotatedBean');
					assertThat(propertiesBean.getInstance()).isInstanceOf(NonAnnotatedBean.class);
					assertThat(propertiesBean.getType()).isEqualTo(NonAnnotatedBean.class);
					assertThat(propertiesBean.getAnnotation().prefix()).isEqualTo('prefix');
					assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
				});
	}
	@Test
	void getWhenImportedFactoryMethodIsAnnotatedReturnsBean() throws Throwable {
		get(NonAnnotatedBeanImportConfiguration.class, 'nonAnnotatedBean', (propertiesBean) -> {
			assertThat(propertiesBean).isNotNull();
			assertThat(propertiesBean.getName()).isEqualTo('nonAnnotatedBean');
			assertThat(propertiesBean.getInstance()).isInstanceOf(NonAnnotatedBean.class);
			assertThat(propertiesBean.getType()).isEqualTo(NonAnnotatedBean.class);
			assertThat(propertiesBean.getAnnotation().prefix()).isEqualTo('prefix');
			assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
		});
	}
	@Test
	void getWhenHasFactoryMethodBindsUsingMethodReturnType() throws Throwable {
		get(NonAnnotatedGenericBeanConfiguration.class, 'nonAnnotatedGenericBean', (propertiesBean) -> {
			assertThat(propertiesBean.getType()).isEqualTo(NonAnnotatedGenericBean.class);
			assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
			ResolvableType type = propertiesBean.asBindTarget().getType();
			assertThat(type.resolve()).isEqualTo(NonAnnotatedGenericBean.class);
			assertThat(type.resolveGeneric(0)).isEqualTo(String.class);
		});
	}
	@Test
	void getWhenHasFactoryMethodWithoutAnnotationBindsUsingMethodType() throws Throwable {
		get(AnnotatedGenericBeanConfiguration.class, 'annotatedGenericBean', (propertiesBean) -> {
			assertThat(propertiesBean.getType()).isEqualTo(AnnotatedGenericBean.class);
			assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
			ResolvableType type = propertiesBean.asBindTarget().getType();
			assertThat(type.resolve()).isEqualTo(AnnotatedGenericBean.class);
			assertThat(type.resolveGeneric(0)).isEqualTo(String.class);
		});
	}
	@Test
	void getWhenHasNoFactoryMethodBindsUsingObjectType() throws Throwable {
		get(AnnotatedGenericComponent.class, 'annotatedGenericComponent', (propertiesBean) -> {
			assertThat(propertiesBean.getType()).isEqualTo(AnnotatedGenericComponent.class);
			assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN);
			ResolvableType type = propertiesBean.asBindTarget().getType();
			assertThat(type.resolve()).isEqualTo(AnnotatedGenericComponent.class);
			assertThat(type.getGeneric(0).resolve()).isNull();
		});
	}
	@Test
	void getWhenHasFactoryMethodAndBeanAnnotationFavorsFactoryMethod() throws Throwable {
		get(AnnotatedBeanConfiguration.class, 'annotatedBean',
				(propertiesBean) -> assertThat(propertiesBean.getAnnotation().prefix()).isEqualTo('factory'));
	}
	@Test
	void getWhenHasValidatedBeanBindsWithBeanAnnotation() throws Throwable {
		get(ValidatedBeanConfiguration.class, 'validatedBean', (propertiesBean) -> {
			Validated validated = propertiesBean.asBindTarget().getAnnotation(Validated.class);
			assertThat(validated.value()).containsExactly(BeanGroup.class);
		});
	}
	@Test
	void getWhenHasValidatedFactoryMethodBindsWithFactoryMethodAnnotation() throws Throwable {
		get(ValidatedMethodConfiguration.class, 'annotatedBean', (propertiesBean) -> {
			Validated validated = propertiesBean.asBindTarget().getAnnotation(Validated.class);
			assertThat(validated.value()).containsExactly(FactoryMethodGroup.class);
		});
	}
	@Test
	void getWhenHasValidatedBeanAndFactoryMethodBindsWithFactoryMethodAnnotation() throws Throwable {
		get(ValidatedMethodAndBeanConfiguration.class, 'validatedBean', (propertiesBean) -> {
			Validated validated = propertiesBean.asBindTarget().getAnnotation(Validated.class);
			assertThat(validated.value()).containsExactly(FactoryMethodGroup.class);
		});
	}
	@Test
	void forValueObjectWithConstructorBindingAnnotatedClassReturnsBean() {
		ConfigurationPropertiesBean propertiesBean = ConfigurationPropertiesBean
			.forValueObject(ConstructorBindingOnConstructor.class, 'valueObjectBean');
		assertThat(propertiesBean.getName()).isEqualTo('valueObjectBean');
		assertThat(propertiesBean.getInstance()).isNull();
		assertThat(propertiesBean.getType()).isEqualTo(ConstructorBindingOnConstructor.class);
		assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.VALUE_OBJECT);
		assertThat(propertiesBean.getAnnotation()).isNotNull();
		Bindable<?> target = propertiesBean.asBindTarget();
		assertThat(target.getType()).isEqualTo(ResolvableType.forClass(ConstructorBindingOnConstructor.class));
		assertThat(target.getValue()).isNull();
		assertThat(BindConstructorProvider.DEFAULT.getBindConstructor(ConstructorBindingOnConstructor.class, false))
			.isNotNull();
	}
	@Test
	void forValueObjectWithRecordReturnsBean() {
		Class<?> implicitConstructorBinding = new ByteBuddy(ClassFileVersion.JAVA_V16).makeRecord()
			.name('org.springframework.boot.context.properties.ImplicitConstructorBinding')
			.annotateType(AnnotationDescription.Builder.ofType(ConfigurationProperties.class)
				.define('prefix', 'implicit')
				.build())
			.defineRecordComponent('someString', String.class)
			.defineRecordComponent('someInteger', Integer.class)
			.make()
			.load(getClass().getClassLoader())
			.getLoaded();
		ConfigurationPropertiesBean propertiesBean = ConfigurationPropertiesBean
			.forValueObject(implicitConstructorBinding, 'implicitBindingRecord');
		assertThat(propertiesBean.getName()).isEqualTo('implicitBindingRecord');
		assertThat(propertiesBean.getInstance()).isNull();
		assertThat(propertiesBean.getType()).isEqualTo(implicitConstructorBinding);
		assertThat(propertiesBean.asBindTarget().getBindMethod()).isEqualTo(BindMethod.VALUE_OBJECT);
		assertThat(propertiesBean.getAnnotation()).isNotNull();
		Bindable<?> target = propertiesBean.asBindTarget();
		assertThat(target.getType()).isEqualTo(ResolvableType.forClass(implicitConstructorBinding));
		assertThat(target.getValue()).isNull();
		Constructor<?> bindConstructor = BindConstructorProvider.DEFAULT.getBindConstructor(implicitConstructorBinding,
				false);
		assertThat(bindConstructor).isNotNull();
		assertThat(bindConstructor.getParameterTypes()).containsExactly(String.class, Integer.class);
	}
	@Test
	void forValueObjectWhenJavaBeanBindTypeThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> ConfigurationPropertiesBean.forValueObject(AnnotatedBean.class, 'annotatedBean'))
			.withMessage('Bean "annotatedBean" is not a @ConfigurationProperties value object');
		assertThatIllegalStateException()
			.isThrownBy(() -> ConfigurationPropertiesBean.forValueObject(NonAnnotatedBean.class, 'nonAnnotatedBean'))
			.withMessage('Bean "nonAnnotatedBean" is not a @ConfigurationProperties value object');
	}
	@Test
	void deduceBindMethodWhenNoConstructorBindingReturnsJavaBean() {
		BindMethod bindType = ConfigurationPropertiesBean.deduceBindMethod(NoConstructorBinding.class);
		assertThat(bindType).isEqualTo(BindMethod.JAVA_BEAN);
	}
	@Test
	void deduceBindMethodWhenConstructorBindingOnConstructorReturnsValueObject() {
		BindMethod bindType = ConfigurationPropertiesBean.deduceBindMethod(ConstructorBindingOnConstructor.class);
		assertThat(bindType).isEqualTo(BindMethod.VALUE_OBJECT);
	}
	@Test
	void deduceBindMethodWhenNoConstructorBindingAnnotationOnSingleParameterizedConstructorReturnsValueObject() {
		BindMethod bindType = ConfigurationPropertiesBean.deduceBindMethod(ConstructorBindingNoAnnotation.class);
		assertThat(bindType).isEqualTo(BindMethod.VALUE_OBJECT);
	}
	@Test
	void deduceBindMethodWhenConstructorBindingOnMultipleConstructorsThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(
					() -> ConfigurationPropertiesBean.deduceBindMethod(ConstructorBindingOnMultipleConstructors.class))
			.withMessage(ConstructorBindingOnMultipleConstructors.class.getName()
					+ ' has more than one @ConstructorBinding constructor');
	}
	@Test
	void deduceBindMethodWithMultipleConstructorsReturnJavaBean() {
		BindMethod bindType = ConfigurationPropertiesBean
			.deduceBindMethod(NoConstructorBindingOnMultipleConstructors.class);
		assertThat(bindType).isEqualTo(BindMethod.JAVA_BEAN);
	}
	@Test
	void deduceBindMethodWithNoArgConstructorReturnsJavaBean() {
		BindMethod bindType = ConfigurationPropertiesBean.deduceBindMethod(JavaBeanWithNoArgConstructor.class);
		assertThat(bindType).isEqualTo(BindMethod.JAVA_BEAN);
	}
	@Test
	void deduceBindMethodWithSingleArgAutowiredConstructorReturnsJavaBean() {
		BindMethod bindType = ConfigurationPropertiesBean.deduceBindMethod(JavaBeanWithAutowiredConstructor.class);
		assertThat(bindType).isEqualTo(BindMethod.JAVA_BEAN);
	}
	@Test
	void constructorBindingAndAutowiredConstructorsShouldThrowException() {
		assertThatIllegalStateException().isThrownBy(
				() -> ConfigurationPropertiesBean.deduceBindMethod(ConstructorBindingAndAutowiredConstructors.class));
	}
	@Test
	void innerClassWithSyntheticFieldShouldReturnJavaBean() {
		BindMethod bindType = ConfigurationPropertiesBean.deduceBindMethod(Inner.class);
		assertThat(bindType).isEqualTo(BindMethod.JAVA_BEAN);
	}
	@Test
	void innerClassWithParameterizedConstructorShouldReturnJavaBean() {
		BindMethod bindType = ConfigurationPropertiesBean.deduceBindMethod(ParameterizedConstructorInner.class);
		assertThat(bindType).isEqualTo(BindMethod.JAVA_BEAN);
	}
	private void get(Class<?> configuration, String beanName, ThrowingConsumer<ConfigurationPropertiesBean> consumer)
			throws Throwable {
		get(configuration, beanName, true, consumer);
	}
	private void getWithoutBeanMetadataCaching(Class<?> configuration, String beanName,
			ThrowingConsumer<ConfigurationPropertiesBean> consumer) throws Throwable {
		get(configuration, beanName, false, consumer);
	}
	private void get(Class<?> configuration, String beanName, boolean cacheBeanMetadata,
			ThrowingConsumer<ConfigurationPropertiesBean> consumer) throws Throwable {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			context.getBeanFactory().setCacheBeanMetadata(cacheBeanMetadata);
			context.register(configuration);
			context.refresh();
			Object bean = context.getBean(beanName);
			consumer.accept(ConfigurationPropertiesBean.get(context, bean, beanName));
		}
	}
	@Component('nonAnnotatedComponent')
	static class NonAnnotatedComponent {
	}
	@Component('annotatedComponent')
	@ConfigurationProperties(prefix = 'prefix')
	static class AnnotatedComponent {
	}
	@ConfigurationProperties(prefix = 'prefix')
	static class AnnotatedBean {
	}
	static class NonAnnotatedBean {
	}
	static class NonAnnotatedGenericBean<T> {
	}
	@ConfigurationProperties
	static class AnnotatedGenericBean<T> {
	}
	@Component('annotatedGenericComponent')
	@ConfigurationProperties
	static class AnnotatedGenericComponent<T> {
	}
	@Validated(BeanGroup.class)
	@ConfigurationProperties
	static class ValidatedBean {
	}
	@Configuration(proxyBeanMethods = false)
	static class NonAnnotatedBeanConfiguration {
		@Bean
		@ConfigurationProperties(prefix = 'prefix')
		NonAnnotatedBean nonAnnotatedBean() {
			return new NonAnnotatedBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonAnnotatedGenericBeanConfiguration {
		@Bean
		@ConfigurationProperties
		NonAnnotatedGenericBean<String> nonAnnotatedGenericBean() {
			return new NonAnnotatedGenericBean<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnnotatedGenericBeanConfiguration {
		@Bean
		AnnotatedGenericBean<String> annotatedGenericBean() {
			return new AnnotatedGenericBean<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnnotatedBeanConfiguration {
		@Bean
		@ConfigurationProperties(prefix = 'factory')
		AnnotatedBean annotatedBean() {
			return new AnnotatedBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ValidatedBeanConfiguration {
		@Bean
		ValidatedBean validatedBean() {
			return new ValidatedBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ValidatedMethodConfiguration {
		@Bean
		@Validated(FactoryMethodGroup.class)
		AnnotatedBean annotatedBean() {
			return new AnnotatedBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ValidatedMethodAndBeanConfiguration {
		@Bean
		@Validated(FactoryMethodGroup.class)
		ValidatedBean validatedBean() {
			return new ValidatedBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ValueObject.class)
	static class ValueObjectConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class BadBeanConfiguration {
		@Bean
		@Lazy
		BadBean badBean() {
			return new BadBean();
		}
	}
	static class BadBean {
		BadBean() {
			throw new IllegalStateException();
		}
	}
	@ConfigurationProperties
	static class ValueObject {
		ValueObject(String name) {
		}
	}
	static class BeanGroup {
	}
	static class FactoryMethodGroup {
	}
	@ConfigurationProperties
	static class NoConstructorBinding {
	}
	@ConfigurationProperties
	static class ConstructorBindingNoAnnotation {
		ConstructorBindingNoAnnotation(String name) {
		}
	}
	@ConfigurationProperties
	static class ConstructorBindingOnConstructor {
		ConstructorBindingOnConstructor(String name) {
			this(name, -1);
		}
		@ConstructorBinding
		ConstructorBindingOnConstructor(String name, int age) {
		}
	}
	@ConfigurationProperties
	static class ConstructorBindingOnMultipleConstructors {
		@ConstructorBinding
		ConstructorBindingOnMultipleConstructors(String name) {
			this(name, -1);
		}
		@ConstructorBinding
		ConstructorBindingOnMultipleConstructors(String name, int age) {
		}
	}
	@ConfigurationProperties
	static class NoConstructorBindingOnMultipleConstructors {
		NoConstructorBindingOnMultipleConstructors(String name) {
			this(name, -1);
		}
		NoConstructorBindingOnMultipleConstructors(String name, int age) {
		}
	}
	@ConfigurationProperties
	static class JavaBeanWithAutowiredConstructor {
		@Autowired
		JavaBeanWithAutowiredConstructor(String name) {
		}
	}
	@ConfigurationProperties
	static class JavaBeanWithNoArgConstructor {
		JavaBeanWithNoArgConstructor() {
		}
	}
	@ConfigurationProperties
	static class ConstructorBindingAndAutowiredConstructors {
		@Autowired
		ConstructorBindingAndAutowiredConstructors(String name) {
		}
		@ConstructorBinding
		ConstructorBindingAndAutowiredConstructors(Integer age) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(NonAnnotatedBeanConfigurationImportSelector.class)
	static class NonAnnotatedBeanImportConfiguration {
	}
	static class NonAnnotatedBeanConfigurationImportSelector implements ImportSelector {
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			return new String[] { NonAnnotatedBeanConfiguration.class.getName() };
		}
	}
	@ConfigurationProperties
	class Inner {
	}
	@ConfigurationProperties
	class ParameterizedConstructorInner {
		ParameterizedConstructorInner(Integer age) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConfigurationProperties
	static class StaticBeanMethodConfiguration {
		@Bean
		static String stringBean() {
			return 'example';
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
@ExtendWith(OutputCaptureExtension.class)
class ConfigurationPropertiesTests {
	private AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@AfterEach
	void cleanup() {
		this.context.close();
		System.clearProperty('name');
		System.clearProperty('nested.name');
		System.clearProperty('nested_name');
	}
	@Test
	void loadShouldBind() {
		load(BasicConfiguration.class, 'name=foo');
		assertThat(this.context.getBeanNamesForType(BasicProperties.class)).hasSize(1);
		assertThat(this.context.containsBean(BasicProperties.class.getName())).isTrue();
		assertThat(this.context.getBean(BasicProperties.class).name).isEqualTo('foo');
	}
	@Test
	void loadShouldBindNested() {
		load(NestedConfiguration.class, 'name=foo', 'nested.name=bar');
		assertThat(this.context.getBeanNamesForType(NestedProperties.class)).hasSize(1);
		assertThat(this.context.getBean(NestedProperties.class).name).isEqualTo('foo');
		assertThat(this.context.getBean(NestedProperties.class).nested.name).isEqualTo('bar');
	}
	@Test
	void loadWhenUsingSystemPropertiesShouldBind() {
		System.setProperty('name', 'foo');
		load(BasicConfiguration.class);
		assertThat(this.context.getBeanNamesForType(BasicProperties.class)).hasSize(1);
		assertThat(this.context.getBean(BasicProperties.class).name).isEqualTo('foo');
	}
	@Test
	void loadWhenUsingSystemPropertiesShouldBindNested() {
		System.setProperty('name', 'foo');
		System.setProperty('nested.name', 'bar');
		load(NestedConfiguration.class);
		assertThat(this.context.getBeanNamesForType(NestedProperties.class)).hasSize(1);
		assertThat(this.context.getBean(NestedProperties.class).name).isEqualTo('foo');
		assertThat(this.context.getBean(NestedProperties.class).nested.name).isEqualTo('bar');
	}
	@Test
	void loadWhenHasIgnoreUnknownFieldsFalseAndNoUnknownFieldsShouldBind() {
		removeSystemProperties();
		load(IgnoreUnknownFieldsFalseConfiguration.class, 'name=foo');
		IgnoreUnknownFieldsFalseProperties bean = this.context.getBean(IgnoreUnknownFieldsFalseProperties.class);
		assertThat(((BasicProperties) bean).name).isEqualTo('foo');
	}
	@Test
	void loadWhenHasIgnoreUnknownFieldsFalseAndUnknownFieldsShouldFail() {
		removeSystemProperties();
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class)
			.isThrownBy(() -> load(IgnoreUnknownFieldsFalseConfiguration.class, 'name=foo', 'bar=baz'))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	void givenIgnoreUnknownFieldsFalseAndIgnoreInvalidFieldsTrueWhenThereAreUnknownFieldsThenBindingShouldFail() {
		removeSystemProperties();
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class).isThrownBy(
				() -> load(IgnoreUnknownFieldsFalseIgnoreInvalidFieldsTrueConfiguration.class, 'name=foo', 'bar=baz'))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	void loadWhenHasIgnoreInvalidFieldsTrueAndInvalidFieldsShouldBind() {
		load(IgnoreInvalidFieldsFalseProperties.class, 'com.example.bar=spam');
		IgnoreInvalidFieldsFalseProperties bean = this.context.getBean(IgnoreInvalidFieldsFalseProperties.class);
		assertThat(bean.getBar()).isZero();
	}
	@Test
	void loadWhenHasPrefixShouldBind() {
		load(PrefixConfiguration.class, 'spring.foo.name=foo');
		PrefixProperties bean = this.context.getBean(PrefixProperties.class);
		assertThat(((BasicProperties) bean).name).isEqualTo('foo');
	}
	@Test
	void loadWhenPropertiesHaveAnnotationOnBaseClassShouldBind() {
		load(AnnotationOnBaseClassConfiguration.class, 'name=foo');
		AnnotationOnBaseClassProperties bean = this.context.getBean(AnnotationOnBaseClassProperties.class);
		assertThat(((BasicProperties) bean).name).isEqualTo('foo');
	}
	@Test
	void loadWhenBindingArrayShouldBind() {
		load(BasicConfiguration.class, 'name=foo', 'array=1,2,3');
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.array).containsExactly(1, 2, 3);
	}
	@Test
	void loadWhenBindingArrayFromYamlArrayShouldBind() {
		load(BasicConfiguration.class, 'name=foo', 'list[0]=1', 'list[1]=2', 'list[2]=3');
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.list).containsExactly(1, 2, 3);
	}
	@Test
	void loadWhenBindingOver256ElementsShouldBind() {
		List<String> pairs = new ArrayList<>();
		pairs.add('name:foo');
		for (int i = 0; i < 1000; i++) {
			pairs.add('list[' + i + ']:' + i);
		}
		load(BasicConfiguration.class, StringUtils.toStringArray(pairs));
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.list).hasSize(1000);
	}
	@Test
	void loadWhenBindingWithoutAndAnnotationShouldFail() {
		assertThatIllegalStateException().isThrownBy(() -> load(WithoutAndAnnotationConfiguration.class, 'name:foo'))
			.withMessageContaining('No ConfigurationProperties annotation found');
	}
	@Test
	void loadWhenBindingWithoutAnnotationValueShouldBind() {
		load(WithoutAnnotationValueConfiguration.class, 'name=foo');
		WithoutAnnotationValueProperties bean = this.context.getBean(WithoutAnnotationValueProperties.class);
		assertThat(bean.name).isEqualTo('foo');
	}
	@Test
	void loadWhenBindingWithDefaultsInXmlShouldBind() {
		removeSystemProperties();
		load(new Class<?>[] { DefaultsInXmlConfiguration.class });
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.name).isEqualTo('bar');
	}
	@Test
	void loadWhenBindingWithDefaultsInJavaConfigurationShouldBind() {
		load(DefaultsInJavaConfiguration.class);
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.name).isEqualTo('bar');
	}
	@Test
	void loadWhenBindingTwoBeansShouldBind() {
		load(new Class<?>[] { WithoutAnnotationValueConfiguration.class, BasicConfiguration.class });
		assertThat(this.context.getBean(BasicProperties.class)).isNotNull();
		assertThat(this.context.getBean(WithoutAnnotationValueProperties.class)).isNotNull();
	}
	@Test
	void loadWhenBindingWithParentContextShouldBind() {
		AnnotationConfigApplicationContext parent = load(BasicConfiguration.class, 'name=parent');
		this.context = new AnnotationConfigApplicationContext();
		this.context.setParent(parent);
		load(new Class<?>[] { BasicConfiguration.class, BasicPropertiesConsumer.class }, 'name=child');
		assertThat(this.context.getBean(BasicProperties.class)).isNotNull();
		assertThat(parent.getBean(BasicProperties.class)).isNotNull();
		assertThat(this.context.getBean(BasicPropertiesConsumer.class).getName()).isEqualTo('child');
		parent.close();
	}
	@Test
	void loadWhenBindingOnlyParentContextShouldBind() {
		AnnotationConfigApplicationContext parent = load(BasicConfiguration.class, 'name=foo');
		this.context = new AnnotationConfigApplicationContext();
		this.context.setParent(parent);
		load(BasicPropertiesConsumer.class);
		assertThat(this.context.getBeanNamesForType(BasicProperties.class)).isEmpty();
		assertThat(parent.getBeanNamesForType(BasicProperties.class)).hasSize(1);
		assertThat(this.context.getBean(BasicPropertiesConsumer.class).getName()).isEqualTo('foo');
	}
	@Test
	void loadWhenPrefixedPropertiesDeclaredAsBeanShouldBind() {
		load(PrefixPropertiesDeclaredAsBeanConfiguration.class, 'spring.foo.name=foo');
		PrefixProperties bean = this.context.getBean(PrefixProperties.class);
		assertThat(((BasicProperties) bean).name).isEqualTo('foo');
	}
	@Test
	void loadWhenPrefixedPropertiesDeclaredAsAnnotationValueShouldBind() {
		load(PrefixPropertiesDeclaredAsAnnotationValueConfiguration.class, 'spring.foo.name=foo');
		PrefixProperties bean = this.context.getBean('spring.foo-' + PrefixProperties.class.getName(),
				PrefixProperties.class);
		assertThat(((BasicProperties) bean).name).isEqualTo('foo');
	}
	@Test
	void loadWhenMultiplePrefixedPropertiesDeclaredAsAnnotationValueShouldBind() {
		load(MultiplePrefixPropertiesDeclaredAsAnnotationValueConfiguration.class, 'spring.foo.name=foo',
				'spring.bar.name=bar');
		PrefixProperties bean1 = this.context.getBean(PrefixProperties.class);
		AnotherPrefixProperties bean2 = this.context.getBean(AnotherPrefixProperties.class);
		assertThat(((BasicProperties) bean1).name).isEqualTo('foo');
		assertThat(((BasicProperties) bean2).name).isEqualTo('bar');
	}
	@Test
	void loadWhenBindingToMapKeyWithPeriodShouldBind() {
		load(MapProperties.class, 'mymap.key1.key2:value12', 'mymap.key3:value3');
		MapProperties bean = this.context.getBean(MapProperties.class);
		assertThat(bean.mymap).containsOnly(entry('key3', 'value3'), entry('key1.key2', 'value12'));
	}
	@Test
	void loadWhenPrefixedPropertiesAreReplacedOnBeanMethodShouldBind() {
		load(PrefixedPropertiesReplacedOnBeanMethodConfiguration.class, 'external.name=bar', 'spam.name=foo');
		PrefixProperties bean = this.context.getBean(PrefixProperties.class);
		assertThat(((BasicProperties) bean).name).isEqualTo('foo');
	}
	@Test
	void loadShouldBindToJavaTimeDuration() {
		load(BasicConfiguration.class, 'duration=PT1M');
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.getDuration().getSeconds()).isEqualTo(60);
	}
	@Test
	void loadWhenBindingToValidatedImplementationOfInterfaceShouldBind() {
		load(ValidatedImplementationConfiguration.class, 'test.foo=bar');
		ValidatedImplementationProperties bean = this.context.getBean(ValidatedImplementationProperties.class);
		assertThat(bean.getFoo()).isEqualTo('bar');
	}
	@Test
	void loadWithPropertyPlaceholderValueShouldBind() {
		load(WithPropertyPlaceholderValueConfiguration.class, 'default.value=foo');
		WithPropertyPlaceholderValueProperties bean = this.context
			.getBean(WithPropertyPlaceholderValueProperties.class);
		assertThat(bean.getValue()).isEqualTo('foo');
	}
	@Test
	void loadWithPropertyPlaceholderShouldNotAlterPropertySourceOrder() {
		load(WithPropertyPlaceholderWithLocalPropertiesValueConfiguration.class, 'com.example.bar=a');
		SimplePrefixedProperties bean = this.context.getBean(SimplePrefixedProperties.class);
		assertThat(bean.getBar()).isEqualTo('a');
	}
	@Test
	void loadWhenHasPostConstructShouldTriggerPostConstructWithBoundBean() {
		MockEnvironment environment = new MockEnvironment();
		environment.setProperty('bar', 'foo');
		this.context.setEnvironment(environment);
		this.context.register(WithPostConstructConfiguration.class);
		this.context.refresh();
		WithPostConstructConfiguration bean = this.context.getBean(WithPostConstructConfiguration.class);
		assertThat(bean.initialized).isTrue();
	}
	@Test
	void loadShouldNotInitializeFactoryBeans() {
		WithFactoryBeanConfiguration.factoryBeanInitialized = false;
		this.context = new AnnotationConfigApplicationContext() {
			@Override
			protected void onRefresh() {
				assertThat(WithFactoryBeanConfiguration.factoryBeanInitialized).as('Initialized too early').isFalse();
				super.onRefresh();
			}
		};
		this.context.register(WithFactoryBeanConfiguration.class);
		BeanDefinition beanDefinition = BeanDefinitionBuilder.rootBeanDefinition(FactoryBeanTester.class)
			.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE)
			.getBeanDefinition();
		this.context.registerBeanDefinition('test', beanDefinition);
		this.context.refresh();
		assertThat(WithFactoryBeanConfiguration.factoryBeanInitialized).as('Not Initialized').isTrue();
	}
	@Test
	void loadWhenUsingRelaxedFormsShouldBindToEnum() {
		bindToEnum('test.theValue=FOO');
		bindToEnum('test.theValue=foo');
		bindToEnum('test.the-value=FoO');
		bindToEnum('test.THE_VALUE=FoO');
	}
	private void bindToEnum(String... inlinedProperties) {
		load(WithEnumProperties.class, inlinedProperties);
		WithEnumProperties bean = this.context.getBean(WithEnumProperties.class);
		assertThat(bean.getTheValue()).isEqualTo(FooEnum.FOO);
		resetContext();
	}
	@Test
	void loadWhenUsingRelaxedFormsShouldBindToEnumSet() {
		bindToEnumSet('test.the-values=foo,bar', FooEnum.FOO, FooEnum.BAR);
		bindToEnumSet('test.the-values=foo', FooEnum.FOO);
	}
	private void bindToEnumSet(String inlinedProperty, FooEnum... expected) {
		load(WithEnumProperties.class, inlinedProperty);
		WithEnumProperties bean = this.context.getBean(WithEnumProperties.class);
		assertThat(bean.getTheValues()).contains(expected);
		resetContext();
	}
	@Test
	void loadShouldBindToCharArray() {
		load(WithCharArrayProperties.class, 'test.chars=word');
		WithCharArrayProperties bean = this.context.getBean(WithCharArrayProperties.class);
		assertThat(bean.getChars()).isEqualTo('word'.toCharArray());
	}
	@Test
	void loadWhenUsingRelaxedFormsAndOverrideShouldBind() {
		load(WithRelaxedNamesProperties.class, 'test.FOO_BAR=test1', 'test.FOO_BAR=test2', 'test.BAR-B-A-Z=testa',
				'test.BAR-B-A-Z=testb');
		WithRelaxedNamesProperties bean = this.context.getBean(WithRelaxedNamesProperties.class);
		assertThat(bean.getFooBar()).isEqualTo('test2');
		assertThat(bean.getBarBAZ()).isEqualTo('testb');
	}
	@Test
	void loadShouldBindToMap() {
		load(WithMapProperties.class, 'test.map.foo=bar');
		WithMapProperties bean = this.context.getBean(WithMapProperties.class);
		assertThat(bean.getMap()).containsOnly(entry('foo', 'bar'));
	}
	@Test
	void loadShouldBindToMapWithNumericKey() {
		load(MapWithNumericKeyProperties.class, 'sample.properties.1.name=One');
		MapWithNumericKeyProperties bean = this.context.getBean(MapWithNumericKeyProperties.class);
		assertThat(bean.getProperties().get('1').name).isEqualTo('One');
	}
	@Test
	void loadWhenUsingSystemPropertiesShouldBindToMap() {
		this.context.getEnvironment()
			.getPropertySources()
			.addLast(new SystemEnvironmentPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
					Collections.singletonMap('TEST_MAP_FOO_BAR', 'baz')));
		load(WithComplexMapProperties.class);
		WithComplexMapProperties bean = this.context.getBean(WithComplexMapProperties.class);
		assertThat(bean.getMap()).containsOnlyKeys('foo');
		assertThat(bean.getMap().get('foo')).containsOnly(entry('bar', 'baz'));
	}
	@Test
	void loadWhenDotsInSystemEnvironmentPropertiesShouldBind() {
		this.context.getEnvironment()
			.getPropertySources()
			.addLast(new SystemEnvironmentPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
					Collections.singletonMap('com.example.bar', 'baz')));
		load(SimplePrefixedProperties.class);
		SimplePrefixedProperties bean = this.context.getBean(SimplePrefixedProperties.class);
		assertThat(bean.getBar()).isEqualTo('baz');
	}
	@Test
	void loadWhenEnvironmentPrefixSetShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		sources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				new SystemEnvironmentPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
						Collections.singletonMap('MY_SPRING_FOO_NAME', 'Jane')));
		SpringApplication application = new SpringApplication(PrefixConfiguration.class);
		application.setApplicationContextFactory((webApplicationType) -> ConfigurationPropertiesTests.this.context);
		application.setEnvironmentPrefix('my');
		application.setEnvironment(this.context.getEnvironment());
		application.run();
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.name).isEqualTo('Jane');
	}
	@Test
	void loadWhenOverridingPropertiesShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		sources.addFirst(
				new SystemEnvironmentPropertySource('system', Collections.singletonMap('SPRING_FOO_NAME', 'Jane')));
		sources.addLast(new MapPropertySource('test', Collections.singletonMap('spring.foo.name', 'John')));
		load(PrefixConfiguration.class);
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.name).isEqualTo('Jane');
	}
	@Test
	void loadWhenJsr303ConstraintDoesNotMatchShouldFail() {
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class)
			.isThrownBy(() -> load(ValidatedJsr303Configuration.class, 'description='))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	void loadValidatedOnBeanMethodAndJsr303ConstraintDoesNotMatchShouldFail() {
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class)
			.isThrownBy(() -> load(ValidatedOnBeanJsr303Configuration.class, 'description='))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	void loadWhenJsr303ConstraintDoesNotMatchOnNestedThatIsNotAnnotatedWithValidShouldNotFail() {
		assertThatNoException()
			.isThrownBy(() -> load(ValidatedNestedJsr303Properties.class, 'properties.description='));
	}
	@Test
	void loadWhenJsr303ConstraintDoesNotMatchOnNestedThatIsNotDirectlyAnnotatedButIsValidShouldFail() {
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class)
			.isThrownBy(() -> load(ValidatedValidNestedJsr303Properties.class))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	void loadWhenJsr303ConstraintMatchesShouldBind() {
		load(ValidatedJsr303Configuration.class, 'description=foo');
		ValidatedJsr303Properties bean = this.context.getBean(ValidatedJsr303Properties.class);
		assertThat(bean.getDescription()).isEqualTo('foo');
	}
	@Test
	void loadWhenJsr303ConstraintDoesNotMatchAndNotValidatedAnnotationShouldBind() {
		load(NonValidatedJsr303Configuration.class, 'name=foo');
		NonValidatedJsr303Properties bean = this.context.getBean(NonValidatedJsr303Properties.class);
		assertThat(((BasicProperties) bean).name).isEqualTo('foo');
	}
	@Test
	void loadWhenHasMultiplePropertySourcesPlaceholderConfigurerShouldLogWarning(CapturedOutput output) {
		load(MultiplePropertySourcesPlaceholderConfigurerConfiguration.class);
		assertThat(output).contains('Multiple PropertySourcesPlaceholderConfigurer beans registered');
	}
	@Test
	void loadWhenOverridingPropertiesWithPlaceholderResolutionInEnvironmentShouldBindWithOverride() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		sources
			.addFirst(new SystemEnvironmentPropertySource('system', Collections.singletonMap('COM_EXAMPLE_BAR', '10')));
		Map<String, Object> source = new HashMap<>();
		source.put('com.example.bar', 5);
		source.put('com.example.foo', '${com.example.bar}');
		sources.addLast(new MapPropertySource('test', source));
		load(SimplePrefixedProperties.class);
		SimplePrefixedProperties bean = this.context.getBean(SimplePrefixedProperties.class);
		assertThat(bean.getFoo()).isEqualTo(10);
	}
	@Test
	void loadWhenHasUnboundElementsFromSystemEnvironmentShouldNotThrowException() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		sources.addFirst(new MapPropertySource('test', Collections.singletonMap('com.example.foo', 5)));
		sources.addLast(new SystemEnvironmentPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				Collections.singletonMap('COM_EXAMPLE_OTHER', '10')));
		load(SimplePrefixedProperties.class);
		SimplePrefixedProperties bean = this.context.getBean(SimplePrefixedProperties.class);
		assertThat(bean.getFoo()).isEqualTo(5);
	}
	@Test
	void loadShouldSupportRebindableConfigurationPropertiesRegisteredAsBean() {
		testRebindableConfigurationProperties(PrototypePropertiesBeanConfiguration.class);
	}
	@Test
	void loadShouldSupportRebindableConfigurationPropertiesRegisteredUsingRegistrar() {
		testRebindableConfigurationProperties(PrototypePropertiesRegistrarConfiguration.class);
	}
	void testRebindableConfigurationProperties(Class<?> configurationClass) {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('example.one', 'foo');
		sources.addFirst(new MapPropertySource('test-source', source));
		this.context.register(configurationClass);
		this.context.refresh();
		PrototypeBean first = this.context.getBean(PrototypeBean.class);
		assertThat(first.getOne()).isEqualTo('foo');
		source.put('example.one', 'bar');
		sources.addFirst(new MapPropertySource('extra', Collections.singletonMap('example.two', 'baz')));
		PrototypeBean second = this.context.getBean(PrototypeBean.class);
		assertThat(second.getOne()).isEqualTo('bar');
		assertThat(second.getTwo()).isEqualTo('baz');
	}
	@Test
	void loadWhenHasPropertySourcesPlaceholderConfigurerShouldSupportRebindableConfigurationPropertiesRegisteredAsBean() {
		testPropertySourcesPlaceholderConfigurerShouldSupportRebindableConfigurationProperties(
				PrototypePropertiesBeanConfiguration.class);
	}
	@Test
	void loadWhenHasPropertySourcesPlaceholderConfigurerShouldSupportRebindableConfigurationPropertiesRegisteredUsingRegistrar() {
		testPropertySourcesPlaceholderConfigurerShouldSupportRebindableConfigurationProperties(
				PrototypePropertiesRegistrarConfiguration.class);
	}
	void testPropertySourcesPlaceholderConfigurerShouldSupportRebindableConfigurationProperties(
			Class<?> configurationClass) {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('example.one', 'foo');
		sources.addFirst(new MapPropertySource('test-source', source));
		this.context.register(configurationClass);
		this.context.register(PropertySourcesPlaceholderConfigurer.class);
		this.context.refresh();
		PrototypeBean first = this.context.getBean(PrototypeBean.class);
		assertThat(first.getOne()).isEqualTo('foo');
		source.put('example.one', 'bar');
		sources.addFirst(new MapPropertySource('extra', Collections.singletonMap('example.two', 'baz')));
		PrototypeBean second = this.context.getBean(PrototypeBean.class);
		assertThat(second.getOne()).isEqualTo('bar');
		assertThat(second.getTwo()).isEqualTo('baz');
	}
	@Test
	void customProtocolResolverIsInvoked() {
		this.context = new AnnotationConfigApplicationContext();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, 'test.resource=application.properties');
		ProtocolResolver protocolResolver = mock(ProtocolResolver.class);
		given(protocolResolver.resolve(anyString(), any(ResourceLoader.class))).willReturn(null);
		this.context.addProtocolResolver(protocolResolver);
		this.context.register(PropertiesWithResource.class);
		this.context.refresh();
		then(protocolResolver).should().resolve(eq('application.properties'), any(ResourceLoader.class));
	}
	@Test
	void customProtocolResolver() {
		this.context = new AnnotationConfigApplicationContext();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,
				'test.resource=test:/application.properties');
		this.context.addProtocolResolver(new TestProtocolResolver());
		this.context.register(PropertiesWithResource.class);
		this.context.refresh();
		Resource resource = this.context.getBean(PropertiesWithResource.class).getResource();
		assertThat(resource).isNotNull();
		assertThat(resource).isInstanceOf(ClassPathResource.class);
		assertThat(resource.exists()).isTrue();
		assertThat(((ClassPathResource) resource).getPath()).isEqualTo('application.properties');
	}
	@Test
	void loadShouldUseConverterBean() {
		prepareConverterContext(PersonConverterConfiguration.class, PersonProperties.class);
		Person person = this.context.getBean(PersonProperties.class).getPerson();
		assertThat(person.firstName).isEqualTo('John');
		assertThat(person.lastName).isEqualTo('Smith');
	}
	@Test
	void loadShouldUseStringConverterBeanWhenValueIsCharSequence() {
		this.context.register(PersonConverterConfiguration.class, PersonProperties.class);
		PropertySource<?> testProperties = new MapPropertySource('test', Map.of('test.person', new CharSequence() {
			private final String value = 'John Smith';
			@Override
			public int length() {
				return this.value.length();
			}
			@Override
			public char charAt(int index) {
				return this.value.charAt(index);
			}
			@Override
			public CharSequence subSequence(int start, int end) {
				return this.value.subSequence(start, end);
			}
			@Override
			public String toString() {
				return this.value;
			}
		}));
		this.context.getEnvironment().getPropertySources().addLast(testProperties);
		this.context.refresh();
		Person person = this.context.getBean(PersonProperties.class).getPerson();
		assertThat(person.firstName).isEqualTo('John');
		assertThat(person.lastName).isEqualTo('Smith');
	}
	@Test
	void loadWhenBeanFactoryConversionServiceAndConverterBeanCanUseBeanFactoryConverter() {
		DefaultConversionService conversionService = new DefaultConversionService();
		conversionService.addConverter(new AlienConverter());
		this.context.getBeanFactory().setConversionService(conversionService);
		load(new Class<?>[] { PersonConverterConfiguration.class, PersonAndAlienProperties.class },
				'test.person=John Smith', 'test.alien=Alf Tanner');
		PersonAndAlienProperties properties = this.context.getBean(PersonAndAlienProperties.class);
		assertThat(properties.getPerson().firstName).isEqualTo('John');
		assertThat(properties.getPerson().lastName).isEqualTo('Smith');
		assertThat(properties.getAlien().name).isEqualTo('rennaT flA');
	}
	@Test
	void loadWhenBeanFactoryConversionServiceAndConverterBeanCanUseConverterBean() {
		DefaultConversionService conversionService = new DefaultConversionService();
		conversionService.addConverter(new PersonConverter());
		this.context.getBeanFactory().setConversionService(conversionService);
		load(new Class<?>[] { AlienConverterConfiguration.class, PersonAndAlienProperties.class },
				'test.person=John Smith', 'test.alien=Alf Tanner');
		PersonAndAlienProperties properties = this.context.getBean(PersonAndAlienProperties.class);
		assertThat(properties.getPerson().firstName).isEqualTo('John');
		assertThat(properties.getPerson().lastName).isEqualTo('Smith');
		assertThat(properties.getAlien().name).isEqualTo('rennaT flA');
	}
	@Test // gh-38734
	void loadWhenBeanFactoryConversionServiceAndConverterBeanCanUseConverterBeanWithCollections() {
		DefaultConversionService conversionService = new DefaultConversionService();
		conversionService.addConverter(new PersonConverter());
		this.context.getBeanFactory().setConversionService(conversionService);
		load(new Class<?>[] { AlienConverterConfiguration.class, PersonAndAliensProperties.class },
				'test.person=John Smith', 'test.aliens=Alf Tanner,Gilbert');
		PersonAndAliensProperties properties = this.context.getBean(PersonAndAliensProperties.class);
		assertThat(properties.getPerson().firstName).isEqualTo('John');
		assertThat(properties.getPerson().lastName).isEqualTo('Smith');
		assertThat(properties.getAliens().get(0).name).isEqualTo('rennaT flA');
		assertThat(properties.getAliens().get(1).name).isEqualTo('trebliG');
	}
	@Test
	void loadWhenConfigurationConverterIsNotQualifiedShouldNotConvert() {
		assertThatExceptionOfType(BeanCreationException.class)
			.isThrownBy(() -> prepareConverterContext(NonQualifiedConverterConfiguration.class, PersonProperties.class))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	void loadShouldUseGenericConverterBean() {
		prepareConverterContext(GenericConverterConfiguration.class, PersonProperties.class);
		Person person = this.context.getBean(PersonProperties.class).getPerson();
		assertThat(person.firstName).isEqualTo('John');
		assertThat(person.lastName).isEqualTo('Smith');
	}
	@Test
	void loadShouldUseFormatterBean() {
		prepareConverterContext(FormatterConfiguration.class, PersonProperties.class);
		Person person = this.context.getBean(PersonProperties.class).getPerson();
		assertThat(person.firstName).isEqualTo('John');
		assertThat(person.lastName).isEqualTo('Smith');
	}
	@Test
	void loadWhenGenericConfigurationConverterIsNotQualifiedShouldNotConvert() {
		assertThatExceptionOfType(BeanCreationException.class).isThrownBy(
				() -> prepareConverterContext(NonQualifiedGenericConverterConfiguration.class, PersonProperties.class))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	@SuppressWarnings('rawtypes')
	void loadShouldBindToBeanWithGenerics() {
		load(GenericConfiguration.class, 'foo.bar=hello');
		AGenericClass foo = this.context.getBean(AGenericClass.class);
		assertThat(foo.getBar()).isNotNull();
	}
	private void prepareConverterContext(Class<?>... config) {
		load(config, 'test.person=John Smith');
	}
	@Test
	void loadWhenHasConfigurationPropertiesValidatorShouldApplyValidator() {
		assertThatException().isThrownBy(() -> load(WithCustomValidatorConfiguration.class)).satisfies((ex) -> {
			assertThat(ex).hasCauseInstanceOf(BindException.class);
			assertThat(ex.getCause()).hasCauseExactlyInstanceOf(BindValidationException.class);
		});
	}
	@Test
	void loadWhenHasUnsupportedConfigurationPropertiesValidatorShouldBind() {
		load(WithUnsupportedCustomValidatorConfiguration.class, 'test.foo=bar');
		WithSetterThatThrowsValidationExceptionProperties bean = this.context
			.getBean(WithSetterThatThrowsValidationExceptionProperties.class);
		assertThat(bean.getFoo()).isEqualTo('bar');
	}
	@Test
	void loadWhenConfigurationPropertiesIsAlsoValidatorShouldApplyValidator() {
		assertThatException().isThrownBy(() -> load(ValidatorProperties.class)).satisfies((ex) -> {
			assertThat(ex).hasCauseInstanceOf(BindException.class);
			assertThat(ex.getCause()).hasCauseExactlyInstanceOf(BindValidationException.class);
		});
	}
	@Test
	void loadWhenConstructorBoundConfigurationPropertiesIsAlsoValidatorShouldApplyValidator() {
		assertThatException().isThrownBy(() -> load(ValidatorConstructorBoundPropertiesConfiguration.class))
			.satisfies((ex) -> {
				assertThat(ex).hasCauseInstanceOf(BindException.class);
				assertThat(ex.getCause()).hasCauseExactlyInstanceOf(BindValidationException.class);
			});
	}
	@Test
	void loadWhenConfigurationPropertiesWithValidDefaultValuesShouldNotFail() {
		AnnotationConfigApplicationContext context = load(ValidatorPropertiesWithDefaultValues.class);
		ValidatorPropertiesWithDefaultValues bean = context.getBean(ValidatorPropertiesWithDefaultValues.class);
		assertThat(bean.getBar()).isEqualTo('a');
	}
	@Test
	void loadWhenSetterThrowsValidationExceptionShouldFail() {
		assertThatExceptionOfType(BeanCreationException.class)
			.isThrownBy(() -> load(WithSetterThatThrowsValidationExceptionProperties.class, 'test.foo=spam'))
			.withCauseInstanceOf(BindException.class);
	}
	@Test
	void loadWhenFailsShouldIncludeAnnotationDetails() {
		removeSystemProperties();
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class)
			.isThrownBy(() -> load(IgnoreUnknownFieldsFalseConfiguration.class, 'name=foo', 'bar=baz'))
			.withMessageContaining('Could not bind properties to '
					+ '"ConfigurationPropertiesTests.IgnoreUnknownFieldsFalseProperties" : '
					+ 'prefix=, ignoreInvalidFields=false, ignoreUnknownFields=false');
	}
	@Test
	void loadWhenHasCustomPropertyEditorShouldBind() {
		this.context.getBeanFactory().registerCustomEditor(Person.class, PersonPropertyEditor.class);
		load(PersonProperties.class, 'test.person=boot,spring');
		PersonProperties bean = this.context.getBean(PersonProperties.class);
		assertThat(bean.getPerson().firstName).isEqualTo('spring');
		assertThat(bean.getPerson().lastName).isEqualTo('boot');
	}
	@Test
	void loadWhenBindingToListOfGenericClassShouldBind() {
		// gh-12166
		load(ListOfGenericClassProperties.class, 'test.list=java.lang.RuntimeException');
		ListOfGenericClassProperties bean = this.context.getBean(ListOfGenericClassProperties.class);
		assertThat(bean.getList()).containsExactly(RuntimeException.class);
	}
	@Test
	void loadWhenBindingCurrentDirectoryToFileShouldBind() {
		load(FileProperties.class, 'test.file=.');
		FileProperties bean = this.context.getBean(FileProperties.class);
		assertThat(bean.getFile()).isEqualTo(new File('.'));
	}
	@Test
	void loadWhenBindingToDataSizeShouldBind() {
		load(DataSizeProperties.class, 'test.size=10GB', 'test.another-size=5');
		DataSizeProperties bean = this.context.getBean(DataSizeProperties.class);
		assertThat(bean.getSize()).isEqualTo(DataSize.ofGigabytes(10));
		assertThat(bean.getAnotherSize()).isEqualTo(DataSize.ofKilobytes(5));
	}
	@Test
	void loadWhenTopLevelConverterNotFoundExceptionShouldNotFail() {
		load(PersonProperties.class, 'test=boot');
	}
	@Test
	void loadWhenConfigurationPropertiesContainsMapWithPositiveAndNegativeIntegerKeys() {
		// gh-14136
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.map.x.[-1].a', 'baz');
		source.put('test.map.x.1.a', 'bar');
		source.put('test.map.x.1.b', 1);
		sources.addLast(new MapPropertySource('test', source));
		load(WithIntegerMapProperties.class);
		WithIntegerMapProperties bean = this.context.getBean(WithIntegerMapProperties.class);
		Map<Integer, Foo> x = bean.getMap().get('x');
		assertThat(x.get(-1).getA()).isEqualTo('baz');
		assertThat(x.get(-1).getB()).isZero();
		assertThat(x.get(1).getA()).isEqualTo('bar');
		assertThat(x.get(1).getB()).isOne();
	}
	@Test
	void loadWhenConfigurationPropertiesInjectsAnotherBeanShouldNotFail() {
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class)
			.isThrownBy(() -> load(OtherInjectPropertiesConfiguration.class))
			.havingCause()
			.isInstanceOf(BindException.class)
			.withMessageContaining(OtherInjectedProperties.class.getName())
			.withMessageContaining('Failed to bind properties under "test"');
	}
	@Test
	void loadWhenBindingToConstructorParametersShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.foo', 'baz');
		source.put('test.bar', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(ConstructorParameterConfiguration.class);
		ConstructorParameterProperties bean = this.context.getBean(ConstructorParameterProperties.class);
		assertThat(bean.getFoo()).isEqualTo('baz');
		assertThat(bean.getBar()).isEqualTo(5);
	}
	@Test
	void loadWhenBindingToConstructorParametersWithCustomDataUnitShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.duration', '12');
		source.put('test.size', '13');
		source.put('test.period', '14');
		sources.addLast(new MapPropertySource('test', source));
		load(ConstructorParameterWithUnitConfiguration.class);
		ConstructorParameterWithUnitProperties bean = this.context
			.getBean(ConstructorParameterWithUnitProperties.class);
		assertThat(bean.getDuration()).isEqualTo(Duration.ofDays(12));
		assertThat(bean.getSize()).isEqualTo(DataSize.ofMegabytes(13));
		assertThat(bean.getPeriod()).isEqualTo(Period.ofYears(14));
	}
	@Test
	void loadWhenBindingToConstructorParametersWithDefaultValuesShouldBind() {
		load(ConstructorParameterConfiguration.class);
		ConstructorParameterProperties bean = this.context.getBean(ConstructorParameterProperties.class);
		assertThat(bean.getFoo()).isEqualTo('hello');
		assertThat(bean.getBar()).isZero();
	}
	@Test
	void loadWhenBindingToConstructorParametersWithEmptyDefaultValueShouldBind() {
		load(ConstructorParameterEmptyDefaultValueConfiguration.class);
		ConstructorParameterEmptyDefaultValueProperties bean = this.context
			.getBean(ConstructorParameterEmptyDefaultValueProperties.class);
		assertThat(bean.getSet()).isEmpty();
		assertThat(bean.getMap()).isEmpty();
		assertThat(bean.getArray()).isEmpty();
		assertThat(bean.getOptional()).isEmpty();
	}
	@Test
	void loadWhenBindingToConstructorParametersWithDefaultDataUnitShouldBind() {
		load(ConstructorParameterWithUnitConfiguration.class);
		ConstructorParameterWithUnitProperties bean = this.context
			.getBean(ConstructorParameterWithUnitProperties.class);
		assertThat(bean.getDuration()).isEqualTo(Duration.ofDays(2));
		assertThat(bean.getSize()).isEqualTo(DataSize.ofMegabytes(3));
		assertThat(bean.getPeriod()).isEqualTo(Period.ofYears(4));
	}
	@Test
	void loadWhenBindingToConstructorParametersWithCustomDataFormatShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.duration', '12d');
		source.put('test.period', '13y');
		sources.addLast(new MapPropertySource('test', source));
		load(ConstructorParameterWithFormatConfiguration.class);
		ConstructorParameterWithFormatProperties bean = this.context
			.getBean(ConstructorParameterWithFormatProperties.class);
		assertThat(bean.getDuration()).isEqualTo(Duration.ofDays(12));
		assertThat(bean.getPeriod()).isEqualTo(Period.ofYears(13));
	}
	@Test
	void loadWhenBindingToConstructorParametersWithNotMatchingCustomDurationFormatShouldFail() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.duration', 'P12D');
		sources.addLast(new MapPropertySource('test', source));
		assertThatException().isThrownBy(() -> load(ConstructorParameterWithFormatConfiguration.class))
			.havingCause()
			.isInstanceOf(BindException.class);
	}
	@Test
	void loadWhenBindingToConstructorParametersWithNotMatchingCustomPeriodFormatShouldFail() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.period', 'P12D');
		sources.addLast(new MapPropertySource('test', source));
		assertThatException().isThrownBy(() -> load(ConstructorParameterWithFormatConfiguration.class))
			.havingCause()
			.isInstanceOf(BindException.class);
	}
	@Test
	void loadWhenBindingToConstructorParametersWithDefaultDataFormatShouldBind() {
		load(ConstructorParameterWithFormatConfiguration.class);
		ConstructorParameterWithFormatProperties bean = this.context
			.getBean(ConstructorParameterWithFormatProperties.class);
		assertThat(bean.getDuration()).isEqualTo(Duration.ofDays(2));
		assertThat(bean.getPeriod()).isEqualTo(Period.ofYears(3));
	}
	@Test
	void loadWhenBindingToConstructorParametersShouldValidate() {
		assertThatException().isThrownBy(() -> load(ConstructorParameterValidationConfiguration.class))
			.satisfies((ex) -> {
				assertThat(ex).hasCauseInstanceOf(BindException.class);
				assertThat(ex.getCause()).hasCauseExactlyInstanceOf(BindValidationException.class);
			});
	}
	@Test
	void loadWhenBindingOnBeanWithoutBeanDefinitionShouldBind() {
		load(BasicConfiguration.class, 'name=test');
		BasicProperties bean = this.context.getBean(BasicProperties.class);
		assertThat(bean.name).isEqualTo('test');
		bean.name = 'override';
		this.context.getBean(ConfigurationPropertiesBindingPostProcessor.class)
			.postProcessBeforeInitialization(bean, 'does-not-exist');
		assertThat(bean.name).isEqualTo('test');
	}
	@Test
	void loadWhenBindingToNestedConstructorPropertiesShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.name', 'spring');
		source.put('test.nested.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(NestedConstructorPropertiesConfiguration.class);
		NestedConstructorProperties bean = this.context.getBean(NestedConstructorProperties.class);
		assertThat(bean.getName()).isEqualTo('spring');
		assertThat(bean.getNested().getAge()).isEqualTo(5);
	}
	@Test // gh-18485
	void loadWhenBindingToMultiConstructorConfigurationProperties() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested[0].name', 'spring');
		source.put('test.nested[0].age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(MultiConstructorConfigurationPropertiesConfiguration.class);
		MultiConstructorConfigurationListProperties bean = this.context
			.getBean(MultiConstructorConfigurationListProperties.class);
		MultiConstructorConfigurationProperties nested = bean.getNested().get(0);
		assertThat(nested.getName()).isEqualTo('spring');
		assertThat(nested.getAge()).isEqualTo(5);
	}
	@Test // gh-18485
	void loadWhenBindingToMultiConstructorConfigurationPropertiesUsingShortcutSyntax() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested[0]', 'spring');
		sources.addLast(new MapPropertySource('test', source));
		load(MultiConstructorConfigurationPropertiesConfiguration.class);
		MultiConstructorConfigurationListProperties bean = this.context
			.getBean(MultiConstructorConfigurationListProperties.class);
		MultiConstructorConfigurationProperties nested = bean.getNested().get(0);
		assertThat(nested.getName()).isEqualTo('spring');
		assertThat(nested.getAge()).isZero();
	}
	@Test // gh-18481
	void loadWhenBindingToNestedConstructorPropertiesWithDeducedNestedShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.name', 'spring');
		source.put('test.nested.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(DeducedNestedConstructorPropertiesConfiguration.class);
		DeducedNestedConstructorProperties bean = this.context.getBean(DeducedNestedConstructorProperties.class);
		assertThat(bean.getName()).isEqualTo('spring');
		assertThat(bean.getNested().getAge()).isEqualTo(5);
	}
	@Test
	void loadWhenBindingToNestedPropertiesWithSyntheticConstructorShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(SyntheticConstructorPropertiesConfiguration.class);
		SyntheticNestedConstructorProperties bean = this.context.getBean(SyntheticNestedConstructorProperties.class);
		assertThat(bean.getNested().getAge()).isEqualTo(5);
	}
	@Test
	void loadWhenBindingToJavaBeanWithNestedConstructorBindingShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(JavaBeanNestedConstructorBindingPropertiesConfiguration.class);
		JavaBeanNestedConstructorBindingProperties bean = this.context
			.getBean(JavaBeanNestedConstructorBindingProperties.class);
		assertThat(bean.getNested().getAge()).isEqualTo(5);
	}
	@Test
	void loadWhenBindingToNestedWithMultipleConstructorsShouldBind() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(NestedMultipleConstructorsConfiguration.class);
		NestedMultipleConstructorProperties bean = this.context.getBean(NestedMultipleConstructorProperties.class);
		assertThat(bean.getNested().getAge()).isEqualTo(5);
	}
	@Test
	void loadWhenBindingToJavaBeanWithoutExplicitConstructorBindingOnNestedShouldUseSetterBasedBinding() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(JavaBeanNonDefaultConstructorPropertiesConfiguration.class);
		JavaBeanNonDefaultConstructorProperties bean = this.context
			.getBean(JavaBeanNonDefaultConstructorProperties.class);
		assertThat(bean.getNested().getAge()).isEqualTo(10);
	}
	@Test // gh-18652
	void loadWhenBeanFactoryContainsSingletonForConstructorBindingTypeShouldNotFail() {
		ConfigurableListableBeanFactory beanFactory = this.context.getBeanFactory();
		((BeanDefinitionRegistry) beanFactory).registerBeanDefinition('test',
				new RootBeanDefinition(ConstructorParameterProperties.class));
		beanFactory.registerSingleton('test', new ConstructorParameterProperties('bar', 5));
		load(TestConfiguration.class);
	}
	@Test
	void loadWhenConstructorBindingWithOuterClassDeducedConstructorBound() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested.outer.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		load(ConstructorBindingWithOuterClassConstructorBoundConfiguration.class);
		ConstructorBindingWithOuterClassConstructorBoundProperties bean = this.context
			.getBean(ConstructorBindingWithOuterClassConstructorBoundProperties.class);
		assertThat(bean.getNested().getOuter().getAge()).isEqualTo(5);
	}
	@Test
	void loadWhenConstructorBindingWithOuterClassAndNestedAutowiredShouldThrowException() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test.nested.age', '5');
		sources.addLast(new MapPropertySource('test', source));
		assertThatExceptionOfType(ConfigurationPropertiesBindException.class).isThrownBy(
				() -> load(ConstructorBindingWithOuterClassConstructorBoundAndNestedAutowiredConfiguration.class));
	}
	@Test
	void loadWhenConfigurationPropertiesPrefixMatchesPropertyInEnvironment() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('test', 'bar');
		source.put('test.a', 'baz');
		sources.addLast(new MapPropertySource('test', source));
		load(WithPublicStringConstructorPropertiesConfiguration.class);
		WithPublicStringConstructorProperties bean = this.context.getBean(WithPublicStringConstructorProperties.class);
		assertThat(bean.getA()).isEqualTo('baz');
	}
	@Test // gh-26201
	void loadWhenBoundToRandomPropertyPlaceholder() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		sources.addFirst(new RandomValuePropertySource());
		Map<String, Object> source = new HashMap<>();
		source.put('com.example.bar', '${random.int[100,200]}');
		sources.addLast(new MapPropertySource('test', source));
		load(SimplePrefixedProperties.class);
		SimplePrefixedProperties bean = this.context.getBean(SimplePrefixedProperties.class);
		assertThat(bean.getBar()).isNotNull().containsOnlyDigits();
	}
	@Test
	void boundPropertiesShouldBeRecorded() {
		load(NestedConfiguration.class, 'name=foo', 'nested.name=bar');
		BoundConfigurationProperties bound = BoundConfigurationProperties.get(this.context);
		Set<ConfigurationPropertyName> keys = bound.getAll().keySet();
		assertThat(keys.stream().map(ConfigurationPropertyName::toString)).contains('name', 'nested.name');
	}
	@Test // gh-28592
	void loadWhenBindingWithCustomConverterAndObjectToObjectMethod() {
		this.context.getBeanFactory().setConversionService(ApplicationConversionService.getSharedInstance());
		load(WithCustomConverterAndObjectToObjectMethodConfiguration.class, 'test.item=foo');
		WithCustomConverterAndObjectToObjectMethodProperties bean = this.context
			.getBean(WithCustomConverterAndObjectToObjectMethodProperties.class);
		assertThat(bean.getItem().getValue()).isEqualTo('foo');
	}
	@Test // gh-33710
	void loadWhenConstructorUsedInBeanMethodAndNotAsConstructorBinding() {
		load(ConstructorUsedInBeanMethodConfiguration.class, 'test.two=bound-2');
		ConstructorUsedDirectly bean = this.context.getBean(ConstructorUsedDirectly.class);
		assertThat(bean.getOne()).isEqualTo('bean-method-1');
		assertThat(bean.getTwo()).isEqualTo('bound-2');
	}
	@Test // gh-33409
	void loadWhenConstructorUsedInNestedPropertyAndNotAsConstructorBinding() {
		load(ConstructorUsedInNestedPropertyConfiguration.class, 'test.nested.two=bound-2');
		ConstructorUsedInNestedProperty bean = this.context.getBean(ConstructorUsedInNestedProperty.class);
		assertThat(bean.getNested().getOne()).isEqualTo('nested-1');
		assertThat(bean.getNested().getTwo()).isEqualTo('bound-2');
	}
	@Test // gh-34407
	void loadWhenNestedRecordWithExistingInstance() {
		load(NestedRecordInstancePropertiesConfiguration.class, 'test.nested.name=spring');
		NestedRecordInstanceProperties bean = this.context.getBean(NestedRecordInstanceProperties.class);
		assertThat(bean.getNested().name()).isEqualTo('spring');
	}
	@Test
	void loadWhenPotentiallyConstructorBoundPropertiesAreImportedUsesJavaBeanBinding() {
		load(PotentiallyConstructorBoundPropertiesImporter.class, 'test.prop=alpha');
		PotentiallyConstructorBoundProperties properties = this.context
			.getBean(PotentiallyConstructorBoundProperties.class);
		assertThat(properties.getProp()).isEqualTo('alpha');
	}
	@Test
	void loadWhenBindingClasspathPatternToResourceArrayShouldBindMultipleValues() {
		load(ResourceArrayPropertiesConfiguration.class,
				'test.resources=classpath*:org/springframework/boot/context/properties/*.class');
		ResourceArrayProperties properties = this.context.getBean(ResourceArrayProperties.class);
		assertThat(properties.getResources()).hasSizeGreaterThan(1);
	}
	@Test
	void loadWhenBindingClasspathPatternToResourceCollectionShouldBindMultipleValues() {
		load(ResourceCollectionPropertiesConfiguration.class,
				'test.resources=classpath*:org/springframework/boot/context/properties/*.class');
		ResourceCollectionProperties properties = this.context.getBean(ResourceCollectionProperties.class);
		assertThat(properties.getResources()).hasSizeGreaterThan(1);
	}
	@Test
	void loadWhenBindingToConstructorParametersWithConversionToCustomListImplementation() {
		load(ConstructorBoundCustomListPropertiesConfiguration.class, 'test.values=a,b');
		assertThat(this.context.getBean(ConstructorBoundCustomListProperties.class).getValues()).containsExactly('a',
				'b');
	}
	@Test
	void loadWhenBindingToJavaBeanWithConversionToCustomListImplementation() {
		load(SetterBoundCustomListPropertiesConfiguration.class, 'test.values=a,b');
		assertThat(this.context.getBean(SetterBoundCustomListProperties.class).getValues()).containsExactly('a', 'b');
	}
	private AnnotationConfigApplicationContext load(Class<?> configuration, String... inlinedProperties) {
		return load(new Class<?>[] { configuration }, inlinedProperties);
	}
	private AnnotationConfigApplicationContext load(Class<?>[] configuration, String... inlinedProperties) {
		this.context.register(configuration);
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, inlinedProperties);
		this.context.refresh();
		return this.context;
	}
	/**
	 * Strict tests need a known set of properties so we remove system items which may be
	 * environment specific.
	 */
	private void removeSystemProperties() {
		MutablePropertySources sources = this.context.getEnvironment().getPropertySources();
		sources.remove('systemProperties');
		sources.remove('systemEnvironment');
	}
	private void resetContext() {
		this.context.close();
		this.context = new AnnotationConfigApplicationContext();
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(BasicProperties.class)
	static class BasicConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(NestedProperties.class)
	static class NestedConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(IgnoreUnknownFieldsFalseProperties.class)
	static class IgnoreUnknownFieldsFalseConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(IgnoreUnknownFieldsFalseIgnoreInvalidFieldsTrueProperties.class)
	static class IgnoreUnknownFieldsFalseIgnoreInvalidFieldsTrueConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(PrefixProperties.class)
	static class PrefixConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ValidatedJsr303Properties.class)
	static class ValidatedJsr303Configuration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class ValidatedOnBeanJsr303Configuration {
		@Bean
		@Validated
		NonValidatedJsr303Properties properties() {
			return new NonValidatedJsr303Properties();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(NonValidatedJsr303Properties.class)
	static class NonValidatedJsr303Configuration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(AnnotationOnBaseClassProperties.class)
	static class AnnotationOnBaseClassConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WithoutAndAnnotationConfiguration.class)
	static class WithoutAndAnnotationConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WithoutAnnotationValueProperties.class)
	static class WithoutAnnotationValueConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	@ImportResource('org/springframework/boot/context/properties/testProperties.xml')
	static class DefaultsInXmlConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class DefaultsInJavaConfiguration {
		@Bean
		BasicProperties basicProperties() {
			BasicProperties test = new BasicProperties();
			test.setName('bar');
			return test;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class PrefixPropertiesDeclaredAsBeanConfiguration {
		@Bean
		PrefixProperties prefixProperties() {
			return new PrefixProperties();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(PrefixProperties.class)
	static class PrefixPropertiesDeclaredAsAnnotationValueConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties({ PrefixProperties.class, AnotherPrefixProperties.class })
	static class MultiplePrefixPropertiesDeclaredAsAnnotationValueConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class PrefixedPropertiesReplacedOnBeanMethodConfiguration {
		@Bean
		@ConfigurationProperties(prefix = 'spam')
		PrefixProperties prefixProperties() {
			return new PrefixProperties();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class ValidatedImplementationConfiguration {
		@Bean
		ValidatedImplementationProperties testProperties() {
			return new ValidatedImplementationProperties();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	@ConfigurationProperties
	static class WithPostConstructConfiguration {
		private String bar;
		private boolean initialized;
		void setBar(String bar) {
			this.bar = bar;
		}
		String getBar() {
			return this.bar;
		}
		@PostConstruct
		void init() {
			assertThat(this.bar).isNotNull();
			this.initialized = true;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WithPropertyPlaceholderValueProperties.class)
	static class WithPropertyPlaceholderValueConfiguration {
		@Bean
		static PropertySourcesPlaceholderConfigurer configurer() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(SimplePrefixedProperties.class)
	static class WithPropertyPlaceholderWithLocalPropertiesValueConfiguration {
		@Bean
		static PropertySourcesPlaceholderConfigurer configurer() {
			PropertySourcesPlaceholderConfigurer placeholderConfigurer = new PropertySourcesPlaceholderConfigurer();
			Properties properties = new Properties();
			properties.put('com.example.bar', 'b');
			placeholderConfigurer.setProperties(properties);
			return placeholderConfigurer;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class WithFactoryBeanConfiguration {
		static boolean factoryBeanInitialized;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class MultiplePropertySourcesPlaceholderConfigurerConfiguration {
		@Bean
		static PropertySourcesPlaceholderConfigurer configurer1() {
			return new PropertySourcesPlaceholderConfigurer();
		}
		@Bean
		static PropertySourcesPlaceholderConfigurer configurer2() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class PrototypePropertiesBeanConfiguration {
		@Bean
		@Scope(BeanDefinition.SCOPE_PROTOTYPE)
		@ConfigurationProperties('example')
		PrototypeBean prototypeBean() {
			return new PrototypeBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(PrototypeBeanProperties.class)
	static class PrototypePropertiesRegistrarConfiguration {
	}
	@ConfigurationProperties('example')
	@Scope(BeanDefinition.SCOPE_PROTOTYPE)
	static class PrototypeBeanProperties extends PrototypeBean {
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class PropertiesWithResource {
		private Resource resource;
		Resource getResource() {
			return this.resource;
		}
		void setResource(Resource resource) {
			this.resource = resource;
		}
	}
	static class TestProtocolResolver implements ProtocolResolver {
		static final String PREFIX = 'test:/';
		@Override
		public Resource resolve(String location, ResourceLoader resourceLoader) {
			if (location.startsWith(PREFIX)) {
				String path = location.substring(PREFIX.length());
				return new ClassPathResource(path);
			}
			return null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PersonConverterConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		Converter<String, Person> personConverter() {
			return new PersonConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AlienConverterConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		Converter<String, Alien> alienConverter() {
			return new AlienConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonQualifiedConverterConfiguration {
		@Bean
		Converter<String, Person> personConverter() {
			return new PersonConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class GenericConverterConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		GenericConverter genericPersonConverter() {
			return new GenericPersonConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FormatterConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		Formatter<Person> personFormatter() {
			return new PersonFormatter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonQualifiedGenericConverterConfiguration {
		@Bean
		GenericConverter genericPersonConverter() {
			return new GenericPersonConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class GenericConfiguration {
		@Bean
		@ConfigurationProperties('foo')
		AGenericClass<String> aBeanToBind() {
			return new AGenericClass<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WithCustomValidatorProperties.class)
	static class WithCustomValidatorConfiguration {
		@Bean(name = EnableConfigurationProperties.VALIDATOR_BEAN_NAME)
		CustomPropertiesValidator validator() {
			return new CustomPropertiesValidator();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WithSetterThatThrowsValidationExceptionProperties.class)
	static class WithUnsupportedCustomValidatorConfiguration {
		@Bean(name = EnableConfigurationProperties.VALIDATOR_BEAN_NAME)
		CustomPropertiesValidator validator() {
			return new CustomPropertiesValidator();
		}
	}
	static class AGenericClass<T> {
		private T bar;
		T getBar() {
			return this.bar;
		}
		void setBar(T bar) {
			this.bar = bar;
		}
	}
	static class PrototypeBean {
		private String one;
		private String two;
		String getOne() {
			return this.one;
		}
		void setOne(String one) {
			this.one = one;
		}
		String getTwo() {
			return this.two;
		}
		void setTwo(String two) {
			this.two = two;
		}
	}
	// Must be a raw type
	@SuppressWarnings('rawtypes')
	static class FactoryBeanTester implements FactoryBean, InitializingBean {
		@Override
		public Object getObject() {
			return Object.class;
		}
		@Override
		public Class<?> getObjectType() {
			return null;
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
		@Override
		public void afterPropertiesSet() {
			WithFactoryBeanConfiguration.factoryBeanInitialized = true;
		}
	}
	@ConfigurationProperties
	public static class BasicProperties {
		private String name;
		private int[] array;
		private List<Integer> list = new ArrayList<>();
		private Duration duration;
		// No getter - you should be able to bind to a write-only bean
		public void setName(String name) {
			// Must be public for XML
			this.name = name;
		}
		void setArray(int... values) {
			this.array = values;
		}
		int[] getArray() {
			return this.array;
		}
		List<Integer> getList() {
			return this.list;
		}
		void setList(List<Integer> list) {
			this.list = list;
		}
		Duration getDuration() {
			return this.duration;
		}
		void setDuration(Duration duration) {
			this.duration = duration;
		}
	}
	@ConfigurationProperties
	static class NestedProperties {
		private String name;
		private final Nested nested = new Nested();
		void setName(String name) {
			this.name = name;
		}
		Nested getNested() {
			return this.nested;
		}
		static class Nested {
			private String name;
			void setName(String name) {
				this.name = name;
			}
		}
	}
	@ConfigurationProperties(ignoreUnknownFields = false)
	static class IgnoreUnknownFieldsFalseProperties extends BasicProperties {
	}
	@ConfigurationProperties(ignoreUnknownFields = false, ignoreInvalidFields = true)
	static class IgnoreUnknownFieldsFalseIgnoreInvalidFieldsTrueProperties extends BasicProperties {
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'com.example', ignoreInvalidFields = true)
	static class IgnoreInvalidFieldsFalseProperties {
		private long bar;
		void setBar(long bar) {
			this.bar = bar;
		}
		long getBar() {
			return this.bar;
		}
	}
	@ConfigurationProperties(prefix = 'spring.foo')
	static class PrefixProperties extends BasicProperties {
	}
	@ConfigurationProperties(prefix = 'spring.bar')
	static class AnotherPrefixProperties extends BasicProperties {
	}
	static class Jsr303Properties extends BasicProperties {
		@NotEmpty
		private String description;
		String getDescription() {
			return this.description;
		}
		void setDescription(String description) {
			this.description = description;
		}
	}
	@ConfigurationProperties
	@Validated
	static class ValidatedJsr303Properties extends Jsr303Properties {
	}
	@ConfigurationProperties
	static class NonValidatedJsr303Properties extends Jsr303Properties {
	}
	@EnableConfigurationProperties
	@ConfigurationProperties
	@Validated
	static class ValidatedNestedJsr303Properties {
		private final Jsr303Properties properties = new Jsr303Properties();
		Jsr303Properties getProperties() {
			return this.properties;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties
	@Validated
	static class ValidatedValidNestedJsr303Properties {
		@Valid
		private final Jsr303Properties properties = new Jsr303Properties();
		Jsr303Properties getProperties() {
			return this.properties;
		}
	}
	static class AnnotationOnBaseClassProperties extends BasicProperties {
	}
	@ConfigurationProperties
	static class WithoutAnnotationValueProperties {
		private String name;
		void setName(String name) {
			this.name = name;
		}
		// No getter - you should be able to bind to a write-only bean
	}
	@EnableConfigurationProperties
	@ConfigurationProperties
	static class MapProperties {
		private Map<String, String> mymap;
		void setMymap(Map<String, String> mymap) {
			this.mymap = mymap;
		}
		Map<String, String> getMymap() {
			return this.mymap;
		}
	}
	@Component
	static class BasicPropertiesConsumer {
		@Autowired
		private BasicProperties properties;
		@PostConstruct
		void init() {
			assertThat(this.properties).isNotNull();
		}
		String getName() {
			return this.properties.name;
		}
	}
	interface InterfaceForValidatedImplementation {
		String getFoo();
	}
	@ConfigurationProperties('test')
	@Validated
	static class ValidatedImplementationProperties implements InterfaceForValidatedImplementation {
		@NotNull
		private String foo;
		@Override
		public String getFoo() {
			return this.foo;
		}
		void setFoo(String foo) {
			this.foo = foo;
		}
	}
	@ConfigurationProperties(prefix = 'test')
	@Validated
	static class WithPropertyPlaceholderValueProperties {
		@Value('${default.value}')
		private String value;
		void setValue(String value) {
			this.value = value;
		}
		String getValue() {
			return this.value;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class WithEnumProperties {
		private FooEnum theValue;
		private List<FooEnum> theValues;
		void setTheValue(FooEnum value) {
			this.theValue = value;
		}
		FooEnum getTheValue() {
			return this.theValue;
		}
		List<FooEnum> getTheValues() {
			return this.theValues;
		}
		void setTheValues(List<FooEnum> theValues) {
			this.theValues = theValues;
		}
	}
	enum FooEnum {
		FOO, BAZ, BAR
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test', ignoreUnknownFields = false)
	static class WithCharArrayProperties {
		private char[] chars;
		char[] getChars() {
			return this.chars;
		}
		void setChars(char[] chars) {
			this.chars = chars;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class WithRelaxedNamesProperties {
		private String fooBar;
		private String barBAZ;
		String getFooBar() {
			return this.fooBar;
		}
		void setFooBar(String fooBar) {
			this.fooBar = fooBar;
		}
		String getBarBAZ() {
			return this.barBAZ;
		}
		void setBarBAZ(String barBAZ) {
			this.barBAZ = barBAZ;
		}
	}
	@Validated
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class WithMapProperties {
		private Map<String, String> map;
		Map<String, String> getMap() {
			return this.map;
		}
		void setMap(Map<String, String> map) {
			this.map = map;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class WithComplexMapProperties {
		private Map<String, Map<String, String>> map;
		Map<String, Map<String, String>> getMap() {
			return this.map;
		}
		void setMap(Map<String, Map<String, String>> map) {
			this.map = map;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class WithIntegerMapProperties {
		private Map<String, Map<Integer, Foo>> map;
		Map<String, Map<Integer, Foo>> getMap() {
			return this.map;
		}
		void setMap(Map<String, Map<Integer, Foo>> map) {
			this.map = map;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'com.example', ignoreUnknownFields = false)
	static class SimplePrefixedProperties {
		private int foo;
		private String bar;
		String getBar() {
			return this.bar;
		}
		void setBar(String bar) {
			this.bar = bar;
		}
		int getFoo() {
			return this.foo;
		}
		void setFoo(int foo) {
			this.foo = foo;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class PersonProperties {
		private Person person;
		Person getPerson() {
			return this.person;
		}
		void setPerson(Person person) {
			this.person = person;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class PersonAndAlienProperties {
		private Person person;
		private Alien alien;
		Person getPerson() {
			return this.person;
		}
		void setPerson(Person person) {
			this.person = person;
		}
		Alien getAlien() {
			return this.alien;
		}
		void setAlien(Alien alien) {
			this.alien = alien;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class PersonAndAliensProperties {
		private Person person;
		private List<Alien> aliens;
		Person getPerson() {
			return this.person;
		}
		void setPerson(Person person) {
			this.person = person;
		}
		List<Alien> getAliens() {
			return this.aliens;
		}
		void setAliens(List<Alien> aliens) {
			this.aliens = aliens;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'sample')
	static class MapWithNumericKeyProperties {
		private final Map<String, BasicProperties> properties = new LinkedHashMap<>();
		Map<String, BasicProperties> getProperties() {
			return this.properties;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties
	static class ValidatorProperties implements Validator {
		private String foo;
		@Override
		public boolean supports(Class<?> type) {
			return type == ValidatorProperties.class;
		}
		@Override
		public void validate(Object target, Errors errors) {
			ValidationUtils.rejectIfEmpty(errors, 'foo', 'TEST1');
		}
		String getFoo() {
			return this.foo;
		}
		void setFoo(String foo) {
			this.foo = foo;
		}
	}
	@EnableConfigurationProperties(ValidatorConstructorBoundProperties.class)
	static class ValidatorConstructorBoundPropertiesConfiguration {
	}
	@ConfigurationProperties
	static class ValidatorConstructorBoundProperties implements Validator {
		private final String foo;
		ValidatorConstructorBoundProperties(String foo) {
			this.foo = foo;
		}
		@Override
		public boolean supports(Class<?> type) {
			return type == ValidatorConstructorBoundProperties.class;
		}
		@Override
		public void validate(Object target, Errors errors) {
			ValidationUtils.rejectIfEmpty(errors, 'foo', 'TEST1');
		}
		String getFoo() {
			return this.foo;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class WithSetterThatThrowsValidationExceptionProperties {
		private String foo;
		String getFoo() {
			return this.foo;
		}
		void setFoo(String foo) {
			this.foo = foo;
			if (!foo.equals('bar')) {
				throw new IllegalArgumentException('Wrong value for foo');
			}
		}
	}
	@ConfigurationProperties(prefix = 'custom')
	static class WithCustomValidatorProperties {
		private String foo;
		String getFoo() {
			return this.foo;
		}
		void setFoo(String foo) {
			this.foo = foo;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class ListOfGenericClassProperties {
		private List<Class<? extends Throwable>> list;
		List<Class<? extends Throwable>> getList() {
			return this.list;
		}
		void setList(List<Class<? extends Throwable>> list) {
			this.list = list;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class FileProperties {
		private File file;
		File getFile() {
			return this.file;
		}
		void setFile(File file) {
			this.file = file;
		}
	}
	@EnableConfigurationProperties
	@ConfigurationProperties(prefix = 'test')
	static class DataSizeProperties {
		private DataSize size;
		@DataSizeUnit(DataUnit.KILOBYTES)
		private DataSize anotherSize;
		DataSize getSize() {
			return this.size;
		}
		void setSize(DataSize size) {
			this.size = size;
		}
		DataSize getAnotherSize() {
			return this.anotherSize;
		}
		void setAnotherSize(DataSize anotherSize) {
			this.anotherSize = anotherSize;
		}
	}
	@ConfigurationProperties(prefix = 'test')
	static class OtherInjectedProperties {
		final DataSizeProperties dataSizeProperties;
		OtherInjectedProperties(ObjectProvider<DataSizeProperties> dataSizeProperties) {
			this.dataSizeProperties = dataSizeProperties.getIfUnique();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(OtherInjectedProperties.class)
	static class OtherInjectPropertiesConfiguration {
	}
	@ConfigurationProperties(prefix = 'test')
	@Validated
	static class ConstructorParameterProperties {
		@NotEmpty
		private final String foo;
		private final int bar;
		ConstructorParameterProperties(@DefaultValue('hello') String foo, int bar) {
			this.foo = foo;
			this.bar = bar;
		}
		String getFoo() {
			return this.foo;
		}
		int getBar() {
			return this.bar;
		}
	}
	@ConfigurationProperties(prefix = 'test')
	static class ConstructorParameterEmptyDefaultValueProperties {
		private final Set<String> set;
		private final Map<String, String> map;
		private final int[] array;
		private final Optional<String> optional;
		ConstructorParameterEmptyDefaultValueProperties(@DefaultValue Set<String> set,
				@DefaultValue Map<String, String> map, @DefaultValue int[] array,
				@DefaultValue Optional<String> optional) {
			this.set = set;
			this.map = map;
			this.array = array;
			this.optional = optional;
		}
		Set<String> getSet() {
			return this.set;
		}
		Map<String, String> getMap() {
			return this.map;
		}
		int[] getArray() {
			return this.array;
		}
		Optional<String> getOptional() {
			return this.optional;
		}
	}
	@ConfigurationProperties(prefix = 'test')
	static class ConstructorParameterWithUnitProperties {
		private final Duration duration;
		private final DataSize size;
		private final Period period;
		@ConstructorBinding
		ConstructorParameterWithUnitProperties(@DefaultValue('2') @DurationUnit(ChronoUnit.DAYS) Duration duration,
				@DefaultValue('3') @DataSizeUnit(DataUnit.MEGABYTES) DataSize size,
				@DefaultValue('4') @PeriodUnit(ChronoUnit.YEARS) Period period) {
			this.size = size;
			this.duration = duration;
			this.period = period;
		}
		Duration getDuration() {
			return this.duration;
		}
		DataSize getSize() {
			return this.size;
		}
		Period getPeriod() {
			return this.period;
		}
	}
	@ConfigurationProperties(prefix = 'test')
	static class ConstructorParameterWithFormatProperties {
		private final Duration duration;
		private final Period period;
		ConstructorParameterWithFormatProperties(
				@DefaultValue('2d') @DurationFormat(DurationStyle.SIMPLE) Duration duration,
				@DefaultValue('3y') @PeriodFormat(PeriodStyle.SIMPLE) Period period) {
			this.duration = duration;
			this.period = period;
		}
		Duration getDuration() {
			return this.duration;
		}
		Period getPeriod() {
			return this.period;
		}
	}
	@ConfigurationProperties(prefix = 'test')
	@Validated
	static class ConstructorParameterValidatedProperties {
		@NotEmpty
		private final String foo;
		ConstructorParameterValidatedProperties(String foo) {
			this.foo = foo;
		}
		String getFoo() {
			return this.foo;
		}
	}
	@EnableConfigurationProperties(ConstructorParameterProperties.class)
	static class ConstructorParameterConfiguration {
	}
	@EnableConfigurationProperties(ConstructorParameterEmptyDefaultValueProperties.class)
	static class ConstructorParameterEmptyDefaultValueConfiguration {
	}
	@EnableConfigurationProperties(ConstructorParameterWithUnitProperties.class)
	static class ConstructorParameterWithUnitConfiguration {
	}
	@EnableConfigurationProperties(ConstructorParameterWithFormatProperties.class)
	static class ConstructorParameterWithFormatConfiguration {
	}
	@EnableConfigurationProperties(ConstructorParameterValidatedProperties.class)
	static class ConstructorParameterValidationConfiguration {
	}
	static class CustomPropertiesValidator implements Validator {
		@Override
		public boolean supports(Class<?> type) {
			return type == WithCustomValidatorProperties.class;
		}
		@Override
		public void validate(Object target, Errors errors) {
			ValidationUtils.rejectIfEmpty(errors, 'foo', 'TEST1');
		}
	}
	static class PersonConverter implements Converter<String, Person> {
		@Override
		public Person convert(String source) {
			String[] content = StringUtils.split(source, ' ');
			return new Person(content[0], content[1]);
		}
	}
	static class AlienConverter implements Converter<String, Alien> {
		@Override
		public Alien convert(String source) {
			return new Alien(new StringBuilder(source).reverse().toString());
		}
	}
	static class GenericPersonConverter implements GenericConverter {
		@Override
		public Set<ConvertiblePair> getConvertibleTypes() {
			return Collections.singleton(new ConvertiblePair(String.class, Person.class));
		}
		@Override
		public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
			String[] content = StringUtils.split((String) source, ' ');
			return new Person(content[0], content[1]);
		}
	}
	static class PersonFormatter implements Formatter<Person> {
		@Override
		public String print(Person person, Locale locale) {
			return person.getFirstName() + ' ' + person.getLastName();
		}
		@Override
		public Person parse(String text, Locale locale) throws ParseException {
			String[] content = text.split(' ');
			return new Person(content[0], content[1]);
		}
	}
	static class PersonPropertyEditor extends PropertyEditorSupport {
		@Override
		public void setAsText(String text) {
			String[] content = text.split(',');
			setValue(new Person(content[1], content[0]));
		}
	}
	static class Person {
		private final String firstName;
		private final String lastName;
		Person(String firstName, String lastName) {
			this.firstName = firstName;
			this.lastName = lastName;
		}
		String getFirstName() {
			return this.firstName;
		}
		String getLastName() {
			return this.lastName;
		}
	}
	static class Alien {
		private final String name;
		Alien(String name) {
			this.name = name;
		}
		String getName() {
			return this.name;
		}
	}
	static class Foo {
		private String a;
		private int b;
		String getA() {
			return this.a;
		}
		void setA(String a) {
			this.a = a;
		}
		int getB() {
			return this.b;
		}
		void setB(int b) {
			this.b = b;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(NestedConstructorProperties.class)
	static class NestedConstructorPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class NestedConstructorProperties {
		private final String name;
		private final Nested nested;
		NestedConstructorProperties(String name, Nested nested) {
			this.name = name;
			this.nested = nested;
		}
		String getName() {
			return this.name;
		}
		Nested getNested() {
			return this.nested;
		}
		static class Nested {
			private final int age;
			@ConstructorBinding
			Nested(int age) {
				this.age = age;
			}
			int getAge() {
				return this.age;
			}
		}
	}
	@ConfigurationProperties('test')
	static class NestedMultipleConstructorProperties {
		private final String name;
		private final Nested nested;
		NestedMultipleConstructorProperties(String name, Nested nested) {
			this.name = name;
			this.nested = nested;
		}
		String getName() {
			return this.name;
		}
		Nested getNested() {
			return this.nested;
		}
		static class Nested {
			private int age;
			Nested(String property) {
			}
			@ConstructorBinding
			Nested(int age) {
				this.age = age;
			}
			int getAge() {
				return this.age;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(NestedMultipleConstructorProperties.class)
	static class NestedMultipleConstructorsConfiguration {
	}
	@ConfigurationProperties('test')
	static class ConstructorBindingWithOuterClassConstructorBoundProperties {
		private final Nested nested;
		ConstructorBindingWithOuterClassConstructorBoundProperties(Nested nested) {
			this.nested = nested;
		}
		Nested getNested() {
			return this.nested;
		}
		static class Nested {
			private Outer outer;
			Outer getOuter() {
				return this.outer;
			}
			void setOuter(Outer nested) {
				this.outer = nested;
			}
		}
	}
	@ConfigurationProperties('test')
	static class ConstructorBindingWithOuterClassConstructorBoundAndNestedAutowired {
		private final Nested nested;
		ConstructorBindingWithOuterClassConstructorBoundAndNestedAutowired(Nested nested) {
			this.nested = nested;
		}
		Nested getNested() {
			return this.nested;
		}
		static class Nested {
			private final int age;
			@Autowired
			Nested(int age) {
				this.age = age;
			}
			int getAge() {
				return this.age;
			}
		}
	}
	static class Outer {
		private final int age;
		Outer(int age) {
			this.age = age;
		}
		int getAge() {
			return this.age;
		}
	}
	@EnableConfigurationProperties(ConstructorBindingWithOuterClassConstructorBoundProperties.class)
	static class ConstructorBindingWithOuterClassConstructorBoundConfiguration {
	}
	@EnableConfigurationProperties(ConstructorBindingWithOuterClassConstructorBoundAndNestedAutowired.class)
	static class ConstructorBindingWithOuterClassConstructorBoundAndNestedAutowiredConfiguration {
	}
	@ConfigurationProperties('test')
	static class MultiConstructorConfigurationListProperties {
		private final List<MultiConstructorConfigurationProperties> nested = new ArrayList<>();
		List<MultiConstructorConfigurationProperties> getNested() {
			return this.nested;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(MultiConstructorConfigurationListProperties.class)
	static class MultiConstructorConfigurationPropertiesConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(JavaBeanNestedConstructorBindingProperties.class)
	static class JavaBeanNestedConstructorBindingPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class JavaBeanNestedConstructorBindingProperties {
		private Nested nested;
		Nested getNested() {
			return this.nested;
		}
		void setNested(Nested nested) {
			this.nested = nested;
		}
		static final class Nested {
			private final int age;
			@ConstructorBinding
			private Nested(int age) {
				this.age = age;
			}
			int getAge() {
				return this.age;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(JavaBeanNonDefaultConstructorProperties.class)
	static class JavaBeanNonDefaultConstructorPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class JavaBeanNonDefaultConstructorProperties {
		private Nested nested;
		Nested getNested() {
			return this.nested;
		}
		void setNested(Nested nested) {
			this.nested = nested;
		}
		static final class Nested {
			private int age;
			private Nested() {
			}
			private Nested(int age) {
				this.age = age;
			}
			int getAge() {
				return this.age;
			}
			void setAge(int age) {
				this.age = age + 5;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(SyntheticNestedConstructorProperties.class)
	static class SyntheticConstructorPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class SyntheticNestedConstructorProperties {
		private final Nested nested;
		SyntheticNestedConstructorProperties(Nested nested) {
			this.nested = nested;
		}
		Nested getNested() {
			return this.nested;
		}
		static final class Nested {
			private int age;
			private Nested() {
			}
			int getAge() {
				return this.age;
			}
			void setAge(int age) {
				this.age = age;
			}
			static class AnotherNested {
				private final Nested nested;
				AnotherNested(String name) {
					this.nested = new Nested();
				}
				Nested getNested() {
					return this.nested;
				}
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(DeducedNestedConstructorProperties.class)
	static class DeducedNestedConstructorPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class DeducedNestedConstructorProperties {
		private final String name;
		private final Nested nested;
		DeducedNestedConstructorProperties(String name, Nested nested) {
			this.name = name;
			this.nested = nested;
		}
		String getName() {
			return this.name;
		}
		Nested getNested() {
			return this.nested;
		}
		static class Nested {
			private final int age;
			Nested(int age) {
				this.age = age;
			}
			int getAge() {
				return this.age;
			}
		}
	}
	@Configuration
	@EnableConfigurationProperties(WithPublicStringConstructorProperties.class)
	static class WithPublicStringConstructorPropertiesConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WithCustomConverterAndObjectToObjectMethodProperties.class)
	static class WithCustomConverterAndObjectToObjectMethodConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		WithObjectToObjectMethodConverter withObjectToObjectMethodConverter() {
			return new WithObjectToObjectMethodConverter();
		}
	}
	@ConfigurationProperties('test')
	static class WithCustomConverterAndObjectToObjectMethodProperties {
		private WithPublicObjectToObjectMethod item;
		WithPublicObjectToObjectMethod getItem() {
			return this.item;
		}
		void setItem(WithPublicObjectToObjectMethod item) {
			this.item = item;
		}
	}
	static class WithObjectToObjectMethodConverter implements Converter<String, WithPublicObjectToObjectMethod> {
		@Override
		public WithPublicObjectToObjectMethod convert(String source) {
			return new WithPublicObjectToObjectMethod(source);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	static class ConstructorUsedInBeanMethodConfiguration {
		@Bean
		@ConfigurationProperties('test')
		ConstructorUsedDirectly constructorUsedInBeanMethod() {
			return new ConstructorUsedDirectly('bean-method-1', 'bean-method-2');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ConstructorUsedInNestedProperty.class)
	static class ConstructorUsedInNestedPropertyConfiguration {
	}
	@ConfigurationProperties('test')
	static class ConstructorUsedInNestedProperty {
		@NestedConfigurationProperty
		private ConstructorUsedDirectly nested = new ConstructorUsedDirectly('nested-1', 'nested-2');
		ConstructorUsedDirectly getNested() {
			return this.nested;
		}
		void setNested(ConstructorUsedDirectly nested) {
			this.nested = nested;
		}
	}
	static class ConstructorUsedDirectly {
		private String one;
		private String two;
		ConstructorUsedDirectly(String one, String two) {
			this.one = one;
			this.two = two;
		}
		String getOne() {
			return this.one;
		}
		void setOne(String one) {
			this.one = one;
		}
		String getTwo() {
			return this.two;
		}
		void setTwo(String two) {
			this.two = two;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(NestedRecordInstanceProperties.class)
	static class NestedRecordInstancePropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class NestedRecordInstanceProperties {
		@NestedConfigurationProperty
		private NestedRecord nested = new NestedRecord('unnamed');
		NestedRecord getNested() {
			return this.nested;
		}
		void setNested(NestedRecord nestedRecord) {
			this.nested = nestedRecord;
		}
	}
	record NestedRecord(String name) {
	}
	@EnableConfigurationProperties
	@Import(PotentiallyConstructorBoundProperties.class)
	static class PotentiallyConstructorBoundPropertiesImporter {
		@Bean
		String notAProperty() {
			return 'notAProperty';
		}
	}
	@ConfigurationProperties('test')
	static class PotentiallyConstructorBoundProperties {
		private String prop;
		PotentiallyConstructorBoundProperties(String notAProperty) {
		}
		String getProp() {
			return this.prop;
		}
		void setProp(String prop) {
			this.prop = prop;
		}
	}
	@EnableConfigurationProperties(ResourceArrayProperties.class)
	static class ResourceArrayPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class ResourceArrayProperties {
		private Resource[] resources;
		Resource[] getResources() {
			return this.resources;
		}
		void setResources(Resource[] resources) {
			this.resources = resources;
		}
	}
	@EnableConfigurationProperties(ResourceCollectionProperties.class)
	static class ResourceCollectionPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class ResourceCollectionProperties {
		private Collection<Resource> resources;
		Collection<Resource> getResources() {
			return this.resources;
		}
		void setResources(Collection<Resource> resources) {
			this.resources = resources;
		}
	}
	@EnableConfigurationProperties(ConstructorBoundCustomListProperties.class)
	static class ConstructorBoundCustomListPropertiesConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		static Converter<ArrayList<?>, CustomList<?>> arrayListToCustomList() {
			return new Converter<>() {
				@Override
				public CustomList<?> convert(ArrayList<?> source) {
					return new CustomList<>(source);
				}
			};
		}
	}
	@ConfigurationProperties('test')
	static class ConstructorBoundCustomListProperties {
		private final CustomList<String> values;
		ConstructorBoundCustomListProperties(CustomList<String> values) {
			this.values = values;
		}
		CustomList<String> getValues() {
			return this.values;
		}
	}
	@EnableConfigurationProperties(SetterBoundCustomListProperties.class)
	static class SetterBoundCustomListPropertiesConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		static Converter<ArrayList<?>, CustomList<?>> arrayListToCustomList() {
			return new Converter<>() {
				@Override
				public CustomList<?> convert(ArrayList<?> source) {
					return new CustomList<>(source);
				}
			};
		}
	}
	@ConfigurationProperties('test')
	static class SetterBoundCustomListProperties {
		private CustomList<String> values;
		CustomList<String> getValues() {
			return this.values;
		}
		void setValues(CustomList<String> values) {
			this.values = values;
		}
	}
	static final class CustomList<E> extends ArrayList<E> {
		CustomList(List<E> delegate) {
			super(delegate);
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class PropertySourcesDeducerTests {
	@Test
	void getPropertySourcesWhenHasSinglePropertySourcesPlaceholderConfigurerReturnsBean() {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				PropertySourcesPlaceholderConfigurerConfiguration.class);
		PropertySourcesDeducer deducer = new PropertySourcesDeducer(applicationContext);
		PropertySources propertySources = deducer.getPropertySources();
		assertThat(propertySources.get('test')).isInstanceOf(TestPropertySource.class);
	}
	@Test
	void getPropertySourcesWhenHasNoPropertySourcesPlaceholderConfigurerReturnsEnvironmentSources() {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(EmptyConfiguration.class);
		ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
		environment.getPropertySources().addFirst(new TestPropertySource());
		PropertySourcesDeducer deducer = new PropertySourcesDeducer(applicationContext);
		PropertySources propertySources = deducer.getPropertySources();
		assertThat(propertySources.get('test')).isInstanceOf(TestPropertySource.class);
	}
	@Test
	void getPropertySourcesWhenHasMultiplePropertySourcesPlaceholderConfigurerReturnsEnvironmentSources() {
		ApplicationContext applicationContext = new AnnotationConfigApplicationContext(
				MultiplePropertySourcesPlaceholderConfigurerConfiguration.class);
		ConfigurableEnvironment environment = (ConfigurableEnvironment) applicationContext.getEnvironment();
		environment.getPropertySources().addFirst(new TestPropertySource());
		PropertySourcesDeducer deducer = new PropertySourcesDeducer(applicationContext);
		PropertySources propertySources = deducer.getPropertySources();
		assertThat(propertySources.get('test')).isInstanceOf(TestPropertySource.class);
	}
	@Test
	void getPropertySourcesWhenUnavailableThrowsException() {
		ApplicationContext applicationContext = mock(ApplicationContext.class);
		Environment environment = mock(Environment.class);
		given(applicationContext.getEnvironment()).willReturn(environment);
		PropertySourcesDeducer deducer = new PropertySourcesDeducer(applicationContext);
		assertThatIllegalStateException().isThrownBy(deducer::getPropertySources)
			.withMessage('Unable to obtain PropertySources from PropertySourcesPlaceholderConfigurer or Environment');
	}
	@Configuration(proxyBeanMethods = false)
	static class PropertySourcesPlaceholderConfigurerConfiguration {
		@Bean
		static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
			PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();
			MutablePropertySources propertySources = new MutablePropertySources();
			propertySources.addFirst(new TestPropertySource());
			configurer.setPropertySources(propertySources);
			return configurer;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class MultiplePropertySourcesPlaceholderConfigurerConfiguration {
		@Bean
		static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer1() {
			return new PropertySourcesPlaceholderConfigurer();
		}
		@Bean
		static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer2() {
			return new PropertySourcesPlaceholderConfigurer();
		}
	}
	private static class TestPropertySource extends MapPropertySource {
		TestPropertySource() {
			super('test', Collections.emptyMap());
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
@ConfigurationProperties(prefix = 'test')
public class WithPublicStringConstructorProperties {
	private String a;
	public WithPublicStringConstructorProperties() {
	}
	public WithPublicStringConstructorProperties(String a) {
		this.a = a;
	}
	public String getA() {
		return this.a;
	}
	public void setA(String a) {
		this.a = a;
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesCharSequenceToObjectConverterTests {
	@ConversionServiceTest
	void convertWhenCanConvertViaToString(ConversionService conversionService) {
		assertThat(conversionService.convert(new StringBuilder('1'), Integer.class)).isOne();
	}
	@ConversionServiceTest
	void convertWhenCanConvertDirectlySkipsStringConversion(ConversionService conversionService) {
		assertThat(conversionService.convert(new String('1'), Long.class)).isOne();
		if (!ConversionServiceArguments.isApplicationConversionService(conversionService)) {
			assertThat(conversionService.convert(new StringBuilder('1'), Long.class)).isEqualTo(2);
		}
	}
	@Test
	@SuppressWarnings('unchecked')
	void convertWhenTargetIsList() {
		ConversionService conversionService = new ApplicationConversionService();
		StringBuilder source = new StringBuilder('1,2,3');
		TypeDescriptor sourceType = TypeDescriptor.valueOf(StringBuilder.class);
		TypeDescriptor targetType = TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class));
		List<String> converted = (List<String>) conversionService.convert(source, sourceType, targetType);
		assertThat(converted).containsExactly('1', '2', '3');
	}
	@Test
	@SuppressWarnings('unchecked')
	void convertWhenTargetIsListAndNotUsingApplicationConversionService() {
		FormattingConversionService conversionService = new DefaultFormattingConversionService();
		conversionService.addConverter(new ConfigurationPropertiesCharSequenceToObjectConverter(conversionService));
		StringBuilder source = new StringBuilder('1,2,3');
		TypeDescriptor sourceType = TypeDescriptor.valueOf(StringBuilder.class);
		TypeDescriptor targetType = TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class));
		List<String> converted = (List<String>) conversionService.convert(source, sourceType, targetType);
		assertThat(converted).containsExactly('1', '2', '3');
	}
	static Stream<? extends Arguments> conversionServices() {
		return ConversionServiceArguments.with((conversionService) -> {
			conversionService.addConverter(new StringToIntegerConverter());
			conversionService.addConverter(new StringToLongConverter());
			conversionService.addConverter(new CharSequenceToLongConverter());
			conversionService.addConverter(new ConfigurationPropertiesCharSequenceToObjectConverter(conversionService));
		});
	}
	static class StringToIntegerConverter implements Converter<String, Integer> {
		@Override
		public Integer convert(String source) {
			return Integer.valueOf(source);
		}
	}
	static class StringToLongConverter implements Converter<String, Long> {
		@Override
		public Long convert(String source) {
			return Long.valueOf(source);
		}
	}
	static class CharSequenceToLongConverter implements Converter<CharSequence, Long> {
		@Override
		public Long convert(CharSequence source) {
			return Long.parseLong(source.toString()) + 1;
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBeanFactoryInitializationAotProcessorTests {
	private final ConfigurationPropertiesBeanFactoryInitializationAotProcessor processor = new ConfigurationPropertiesBeanFactoryInitializationAotProcessor();
	@Test
	void configurationPropertiesBeanFactoryInitializationAotProcessorIsRegistered() {
		assertThat(AotServices.factories().load(BeanFactoryInitializationAotProcessor.class))
			.anyMatch(ConfigurationPropertiesBeanFactoryInitializationAotProcessor.class::isInstance);
	}
	@Test
	void processNoMatchesReturnsNullContribution() {
		assertThat(process(String.class)).isNull();
	}
	@Test
	void manuallyRegisteredSingletonBindsAsJavaBean() {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		beanFactory.registerSingleton('test', new SampleProperties());
		ConfigurationPropertiesReflectionHintsContribution contribution = process(beanFactory);
		assertThat(singleBindable(contribution)).hasBindMethod(BindMethod.JAVA_BEAN).hasType(SampleProperties.class);
		assertThat(typeHints(contribution).map(TypeHint::getType))
			.containsExactly(TypeReference.of(SampleProperties.class));
	}
	@Test
	void javaBeanConfigurationPropertiesBindAsJavaBean() {
		ConfigurationPropertiesReflectionHintsContribution contribution = process(EnableJavaBeanProperties.class);
		assertThat(singleBindable(contribution)).hasBindMethod(BindMethod.JAVA_BEAN).hasType(JavaBeanProperties.class);
		assertThat(typeHints(contribution).map(TypeHint::getType))
			.containsExactly(TypeReference.of(JavaBeanProperties.class));
	}
	@Test
	void constructorBindingConfigurationPropertiesBindAsValueObject() {
		ConfigurationPropertiesReflectionHintsContribution contribution = process(
				EnableConstructorBindingProperties.class);
		assertThat(singleBindable(contribution)).hasBindMethod(BindMethod.VALUE_OBJECT)
			.hasType(ConstructorBindingProperties.class);
		assertThat(typeHints(contribution).map(TypeHint::getType))
			.containsExactly(TypeReference.of(ConstructorBindingProperties.class));
	}
	@Test
	void possibleConstructorBindingPropertiesDefinedThroughBeanMethodBindAsJavaBean() {
		ConfigurationPropertiesReflectionHintsContribution contribution = process(
				PossibleConstructorBindingPropertiesBeanMethodConfiguration.class);
		assertThat(singleBindable(contribution)).hasBindMethod(BindMethod.JAVA_BEAN)
			.hasType(PossibleConstructorBindingProperties.class);
		assertThat(typeHints(contribution).map(TypeHint::getType))
			.containsExactly(TypeReference.of(PossibleConstructorBindingProperties.class));
	}
	@Test
	void possibleConstructorBindingPropertiesDefinedThroughEnabledAnnotationBindAsValueObject() {
		ConfigurationPropertiesReflectionHintsContribution contribution = process(
				EnablePossibleConstructorBindingProperties.class);
		assertThat(singleBindable(contribution)).hasBindMethod(BindMethod.VALUE_OBJECT)
			.hasType(PossibleConstructorBindingProperties.class);
		assertThat(typeHints(contribution).map(TypeHint::getType))
			.containsExactly(TypeReference.of(PossibleConstructorBindingProperties.class));
	}
	private Stream<TypeHint> typeHints(ConfigurationPropertiesReflectionHintsContribution contribution) {
		TestGenerationContext generationContext = new TestGenerationContext();
		contribution.applyTo(generationContext, null);
		return generationContext.getRuntimeHints().reflection().typeHints();
	}
	private ConfigurationPropertiesReflectionHintsContribution process(Class<?> config) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(config)) {
			return process(context.getBeanFactory());
		}
	}
	private ConfigurationPropertiesReflectionHintsContribution process(ConfigurableListableBeanFactory beanFactory) {
		return this.processor.processAheadOfTime(beanFactory);
	}
	private BindableAssertProvider singleBindable(ConfigurationPropertiesReflectionHintsContribution contribution) {
		assertThat(contribution.getBindables()).hasSize(1);
		return new BindableAssertProvider(contribution.getBindables().iterator().next());
	}
	@ConfigurationProperties('test')
	static class SampleProperties {
	}
	@EnableConfigurationProperties(JavaBeanProperties.class)
	static class EnableJavaBeanProperties {
	}
	@ConfigurationProperties('java-bean')
	static class JavaBeanProperties {
		private String value;
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
	}
	@EnableConfigurationProperties(ConstructorBindingProperties.class)
	static class EnableConstructorBindingProperties {
	}
	@ConfigurationProperties('constructor-binding')
	static class ConstructorBindingProperties {
		private final String value;
		ConstructorBindingProperties(String value) {
			this.value = value;
		}
		String getValue() {
			return this.value;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PossibleConstructorBindingPropertiesBeanMethodConfiguration {
		@Bean
		@ConfigurationProperties(prefix = 'bean-method')
		PossibleConstructorBindingProperties possibleConstructorBindingProperties() {
			return new PossibleConstructorBindingProperties('alpha');
		}
	}
	@EnableConfigurationProperties(PossibleConstructorBindingProperties.class)
	static class EnablePossibleConstructorBindingProperties {
	}
	@ConfigurationProperties('possible-constructor-binding')
	static class PossibleConstructorBindingProperties {
		private String value;
		PossibleConstructorBindingProperties(String arg) {
		}
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
	}
	static class BindableAssertProvider implements AssertProvider<BindableAssert> {
		private final Bindable<?> bindable;
		BindableAssertProvider(Bindable<?> bindable) {
			this.bindable = bindable;
		}
		@Override
		public BindableAssert assertThat() {
			return new BindableAssert(this.bindable);
		}
	}
	static class BindableAssert extends AbstractAssert<BindableAssert, Bindable<?>> {
		BindableAssert(Bindable<?> bindable) {
			super(bindable, BindableAssert.class);
		}
		BindableAssert hasBindMethod(BindMethod bindMethod) {
			if (this.actual.getBindMethod() != bindMethod) {
				throwAssertionError(
						new BasicErrorMessageFactory('Expected %s to have bind method %s but bind method was %s',
								this.actual, bindMethod, this.actual.getBindMethod()));
			}
			return this;
		}
		BindableAssert hasType(Class<?> type) {
			if (!type.equals(this.actual.getType().resolve())) {
				throwAssertionError(new BasicErrorMessageFactory('Expected %s to have type %s but type was %s',
						this.actual, type, this.actual.getType().resolve()));
			}
			return this;
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesScanTests {
	private AnnotationConfigApplicationContext context;
	@BeforeEach
	void setup() {
		this.context = new AnnotationConfigApplicationContext();
	}
	@AfterEach
	void teardown() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void scanImportBeanRegistrarShouldBeEnvironmentAwareWithRequiredProfile() {
		this.context.getEnvironment().addActiveProfile('test');
		load(TestConfiguration.class);
		assertThat(this.context.containsBean(
				'profile-org.springframework.boot.context.properties.scan.valid.a.AScanConfiguration$MyProfileProperties'))
			.isTrue();
	}
	@Test
	void scanImportBeanRegistrarShouldBeEnvironmentAwareWithoutRequiredProfile() {
		load(TestConfiguration.class);
		assertThat(this.context.containsBean(
				'profile-org.springframework.boot.context.properties.scan.valid.a.AScanConfiguration$MyProfileProperties'))
			.isFalse();
	}
	@Test
	void scanImportBeanRegistrarShouldBeResourceLoaderAwareWithRequiredResource() {
		DefaultResourceLoader resourceLoader = mock(DefaultResourceLoader.class);
		this.context.setResourceLoader(resourceLoader);
		willCallRealMethod().given(resourceLoader).getClassLoader();
		given(resourceLoader.getResource('test')).willReturn(new ByteArrayResource('test'.getBytes()));
		load(TestConfiguration.class);
		assertThat(this.context.containsBean(
				'resource-org.springframework.boot.context.properties.scan.valid.a.AScanConfiguration$MyResourceProperties'))
			.isTrue();
	}
	@Test
	void scanImportBeanRegistrarShouldBeResourceLoaderAwareWithoutRequiredResource() {
		load(TestConfiguration.class);
		assertThat(this.context.containsBean(
				'resource-org.springframework.boot.context.properties.scan.valid.a.AScanConfiguration$MyResourceProperties'))
			.isFalse();
	}
	@Test
	void scanImportBeanRegistrarShouldUsePackageName() {
		load(TestAnotherPackageConfiguration.class);
		assertThat(this.context.getBeanNamesForType(BProperties.class)).containsOnly(
				'b.first-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BFirstProperties',
				'b.second-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BSecondProperties');
	}
	@Test
	void scanImportBeanRegistrarShouldApplyTypeExcludeFilter() {
		this.context.getBeanFactory().registerSingleton('filter', new ConfigurationPropertiesTestTypeExcludeFilter());
		this.context.register(TestAnotherPackageConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeanNamesForType(BProperties.class)).containsOnly(
				'b.first-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BFirstProperties');
	}
	@Test
	void scanShouldBindConfigurationProperties() {
		load(TestAnotherPackageConfiguration.class, 'b.first.name=constructor', 'b.second.number=42');
		assertThat(this.context.getBean(BFirstProperties.class).getName()).isEqualTo('constructor');
		assertThat(this.context.getBean(BSecondProperties.class).getNumber()).isEqualTo(42);
	}
	private void load(Class<?> configuration, String... inlinedProperties) {
		this.context.register(configuration);
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, inlinedProperties);
		this.context.refresh();
	}
	@ConfigurationPropertiesScan(basePackageClasses = AScanConfiguration.class)
	static class TestConfiguration {
	}
	@ConfigurationPropertiesScan(basePackages = 'org.springframework.boot.context.properties.scan.valid.b')
	static class TestAnotherPackageConfiguration {
	}
	static class ConfigurationPropertiesTestTypeExcludeFilter extends TypeExcludeFilter {
		@Override
		public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory)
				throws IOException {
			AssignableTypeFilter typeFilter = new AssignableTypeFilter(BFirstProperties.class);
			return !typeFilter.match(metadataReader, metadataReaderFactory);
		}
		@Override
		public boolean equals(Object o) {
			return (this == o);
		}
		@Override
		public int hashCode() {
			return Objects.hash(42);
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
@EnableConfigurationProperties
@ConfigurationProperties
class ValidatorPropertiesWithDefaultValues implements Validator {
	private String bar = 'a';
	@Override
	public boolean supports(Class<?> type) {
		return type == ValidatorPropertiesWithDefaultValues.class;
	}
	@Override
	public void validate(Object target, Errors errors) {
		ValidationUtils.rejectIfEmpty(errors, 'bar', 'foo.empty');
	}
	public String getBar() {
		return this.bar;
	}
	public void setBar(String bar) {
		this.bar = bar;
	}
}
/*
package org.springframework.boot.context.properties;
/**
class EnableConfigurationPropertiesRegistrarTests {
	private DefaultListableBeanFactory beanFactory;
	private EnableConfigurationPropertiesRegistrar registrar;
	@BeforeEach
	void setup() {
		this.beanFactory = spy(new DefaultListableBeanFactory());
		this.registrar = new EnableConfigurationPropertiesRegistrar();
	}
	@Test
	void typeWithDefaultConstructorShouldRegisterRootBeanDefinition() {
		register(TestConfiguration.class);
		BeanDefinition definition = this.beanFactory
			.getBeanDefinition('foo-' + getClass().getName() + '$FooProperties');
		assertThat(definition).satisfies(hasBindMethod(BindMethod.JAVA_BEAN));
	}
	@Test
	void constructorBoundPropertiesShouldRegisterConfigurationPropertiesBeanDefinition() {
		register(TestConfiguration.class);
		BeanDefinition definition = this.beanFactory
			.getBeanDefinition('bar-' + getClass().getName() + '$BarProperties');
		assertThat(definition).satisfies(hasBindMethod(BindMethod.VALUE_OBJECT));
	}
	@Test
	void typeWithMultipleConstructorsShouldRegisterGenericBeanDefinition() {
		register(TestConfiguration.class);
		BeanDefinition definition = this.beanFactory
			.getBeanDefinition('bing-' + getClass().getName() + '$BingProperties');
		assertThat(definition).satisfies(hasBindMethod(BindMethod.JAVA_BEAN));
	}
	@Test
	void typeWithNoAnnotationShouldFail() {
		assertThatIllegalStateException().isThrownBy(() -> register(InvalidConfiguration.class))
			.withMessageContaining('No ConfigurationProperties annotation found')
			.withMessageContaining(EnableConfigurationPropertiesRegistrar.class.getName());
	}
	@Test
	void registrationWithDuplicatedTypeShouldRegisterSingleBeanDefinition() {
		register(DuplicateConfiguration.class);
		String name = 'foo-' + getClass().getName() + '$FooProperties';
		then(this.beanFactory).should().registerBeanDefinition(eq(name), any());
	}
	@Test
	void registrationWithNoTypeShouldNotRegisterAnything() {
		register(EmptyConfiguration.class);
		String[] names = this.beanFactory.getBeanNamesForType(Object.class);
		for (String name : names) {
			assertThat(name).doesNotContain('-');
		}
	}
	private Consumer<BeanDefinition> hasBindMethod(BindMethod bindMethod) {
		return (definition) -> {
			assertThat(definition.hasAttribute(BindMethod.class.getName())).isTrue();
			assertThat(definition.getAttribute(BindMethod.class.getName())).isEqualTo(bindMethod);
		};
	}
	private void register(Class<?> configuration) {
		AnnotationMetadata metadata = AnnotationMetadata.introspect(configuration);
		this.registrar.registerBeanDefinitions(metadata, this.beanFactory);
	}
	@EnableConfigurationProperties({ FooProperties.class, BarProperties.class, BingProperties.class })
	static class TestConfiguration {
	}
	@EnableConfigurationProperties(EnableConfigurationPropertiesRegistrarTests.class)
	static class InvalidConfiguration {
	}
	@EnableConfigurationProperties({ FooProperties.class, FooProperties.class })
	static class DuplicateConfiguration {
	}
	@EnableConfigurationProperties
	static class EmptyConfiguration {
	}
	@ConfigurationProperties(prefix = 'foo')
	static class FooProperties {
	}
	@ConfigurationProperties(prefix = 'bar')
	static class BarProperties {
		BarProperties(String foo) {
		}
	}
	@ConfigurationProperties(prefix = 'bing')
	static class BingProperties {
		BingProperties() {
		}
		BingProperties(String foo) {
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class PropertyMapperTests {
	private final PropertyMapper map = PropertyMapper.get();
	@Test
	void fromNullValue() {
		ExampleDest dest = new ExampleDest();
		this.map.from((String) null).to(dest::setName);
		assertThat(dest.getName()).isNull();
	}
	@Test
	void fromValue() {
		ExampleDest dest = new ExampleDest();
		this.map.from('Hello World').to(dest::setName);
		assertThat(dest.getName()).isEqualTo('Hello World');
	}
	@Test
	void fromValueAsIntShouldAdaptValue() {
		Integer result = this.map.from('123').asInt(Long::valueOf).toInstance(Integer::valueOf);
		assertThat(result).isEqualTo(123);
	}
	@Test
	void fromValueAlwaysApplyingWhenNonNullShouldAlwaysApplyNonNullToSource() {
		this.map.alwaysApplyingWhenNonNull().from((String) null).toCall(Assertions::fail);
	}
	@Test
	void fromWhenSupplierIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.map.from((Supplier<?>) null))
			.withMessageContaining('Supplier must not be null');
	}
	@Test
	void toWhenConsumerIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.map.from(() -> '').to(null))
			.withMessageContaining('Consumer must not be null');
	}
	@Test
	void toShouldMapFromSupplier() {
		ExampleSource source = new ExampleSource('test');
		ExampleDest dest = new ExampleDest();
		this.map.from(source::getName).to(dest::setName);
		assertThat(dest.getName()).isEqualTo('test');
	}
	@Test
	void asIntShouldAdaptSupplier() {
		Integer result = this.map.from(() -> '123').asInt(Long::valueOf).toInstance(Integer::valueOf);
		assertThat(result).isEqualTo(123);
	}
	@Test
	void asWhenAdapterIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.map.from(() -> '').as(null))
			.withMessageContaining('Adapter must not be null');
	}
	@Test
	void asShouldAdaptSupplier() {
		ExampleDest dest = new ExampleDest();
		this.map.from(() -> 123).as(String::valueOf).to(dest::setName);
		assertThat(dest.getName()).isEqualTo('123');
	}
	@Test
	void whenNonNullWhenSuppliedNullShouldNotMap() {
		this.map.from(() -> null).whenNonNull().as(String::valueOf).toCall(Assertions::fail);
	}
	@Test
	void whenNonNullWhenSuppliedThrowsNullPointerExceptionShouldNotMap() {
		this.map.from(() -> {
			throw new NullPointerException();
		}).whenNonNull().as(String::valueOf).toCall(Assertions::fail);
	}
	@Test
	void whenTrueWhenValueIsTrueShouldMap() {
		Boolean result = this.map.from(true).whenTrue().toInstance(Boolean::valueOf);
		assertThat(result).isTrue();
	}
	@Test
	void whenTrueWhenValueIsFalseShouldNotMap() {
		this.map.from(false).whenTrue().toCall(Assertions::fail);
	}
	@Test
	void whenFalseWhenValueIsFalseShouldMap() {
		Boolean result = this.map.from(false).whenFalse().toInstance(Boolean::valueOf);
		assertThat(result).isFalse();
	}
	@Test
	void whenFalseWhenValueIsTrueShouldNotMap() {
		this.map.from(true).whenFalse().toCall(Assertions::fail);
	}
	@Test
	void whenHasTextWhenValueIsNullShouldNotMap() {
		this.map.from(() -> null).whenHasText().toCall(Assertions::fail);
	}
	@Test
	void whenHasTextWhenValueIsEmptyShouldNotMap() {
		this.map.from('').whenHasText().toCall(Assertions::fail);
	}
	@Test
	void whenHasTextWhenValueHasTextShouldMap() {
		Integer result = this.map.from(123).whenHasText().toInstance(Integer::valueOf);
		assertThat(result).isEqualTo(123);
	}
	@Test
	void whenEqualToWhenValueIsEqualShouldMatch() {
		String result = this.map.from('123').whenEqualTo('123').toInstance(String::new);
		assertThat(result).isEqualTo('123');
	}
	@Test
	void whenEqualToWhenValueIsNotEqualShouldNotMatch() {
		this.map.from('123').whenEqualTo('321').toCall(Assertions::fail);
	}
	@Test
	void whenInstanceOfWhenValueIsTargetTypeShouldMatch() {
		Long result = this.map.from(123L).whenInstanceOf(Long.class).toInstance((value) -> value + 1);
		assertThat(result).isEqualTo(124L);
	}
	@Test
	void whenInstanceOfWhenValueIsNotTargetTypeShouldNotMatch() {
		Supplier<Number> supplier = () -> 123L;
		this.map.from(supplier).whenInstanceOf(Double.class).toCall(Assertions::fail);
	}
	@Test
	void whenWhenValueMatchesShouldMap() {
		String result = this.map.from('123').when('123'::equals).toInstance(String::new);
		assertThat(result).isEqualTo('123');
	}
	@Test
	void whenWhenValueDoesNotMatchShouldNotMap() {
		this.map.from('123').when('321'::equals).toCall(Assertions::fail);
	}
	@Test
	void whenWhenCombinedWithAsUsesSourceValue() {
		Count<String> source = new Count<>(() -> '123');
		Long result = this.map.from(source)
			.when('123'::equals)
			.as(Integer::valueOf)
			.when((v) -> v == 123)
			.as(Integer::longValue)
			.toInstance(Long::valueOf);
		assertThat(result).isEqualTo(123);
		assertThat(source.getCount()).isOne();
	}
	@Test
	void alwaysApplyingWhenNonNullShouldAlwaysApplyNonNullToSource() {
		this.map.alwaysApplyingWhenNonNull().from(() -> null).toCall(Assertions::fail);
	}
	@Test
	void whenWhenValueNotMatchesShouldSupportChainedCalls() {
		this.map.from('123').when('456'::equals).when('123'::equals).toCall(Assertions::fail);
	}
	@Test
	void whenWhenValueMatchesShouldSupportChainedCalls() {
		String result = this.map.from('123').when((s) -> s.contains('2')).when('123'::equals).toInstance(String::new);
		assertThat(result).isEqualTo('123');
	}
	@Test
	void toImmutableReturnsNewInstance() {
		Immutable instance = this.map.from('Spring').toInstance(Immutable::of);
		instance = this.map.from('123').as(Integer::valueOf).to(instance, Immutable::withAge);
		assertThat(instance).hasToString('Spring 123');
	}
	@Test
	void toImmutableWhenFilteredReturnsOriginalInstance() {
		Immutable instance = this.map.from('Spring').toInstance(Immutable::of);
		instance = this.map.from('123').when('345'::equals).as(Integer::valueOf).to(instance, Immutable::withAge);
		assertThat(instance).hasToString('Spring null');
	}
	static class Count<T> implements Supplier<T> {
		private final Supplier<T> source;
		private int count;
		Count(Supplier<T> source) {
			this.source = source;
		}
		@Override
		public T get() {
			this.count++;
			return this.source.get();
		}
		int getCount() {
			return this.count;
		}
	}
	static class ExampleSource {
		private final String name;
		ExampleSource(String name) {
			this.name = name;
		}
		String getName() {
			return this.name;
		}
	}
	static class ExampleDest {
		private String name;
		void setName(String name) {
			this.name = name;
		}
		String getName() {
			return this.name;
		}
	}
	static class Immutable {
		private final String name;
		private final Integer age;
		Immutable(String name, Integer age) {
			this.name = name;
			this.age = age;
		}
		Immutable withAge(Integer age) {
			return new Immutable(this.name, age);
		}
		@Override
		public String toString() {
			return '%s %s'.formatted(this.name, this.age);
		}
		static Immutable of(String name) {
			return new Immutable(name, null);
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class PropertySourcesPlaceholdersResolverTests {
	private PropertySourcesPlaceholdersResolver resolver;
	@Test
	void placeholderResolverIfEnvironmentNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new PropertySourcesPlaceholdersResolver((Environment) null))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void resolveIfPlaceholderPresentResolvesProperty() {
		MutablePropertySources sources = getPropertySources();
		this.resolver = new PropertySourcesPlaceholdersResolver(sources);
		Object resolved = this.resolver.resolvePlaceholders('${FOO}');
		assertThat(resolved).isEqualTo('hello world');
	}
	@Test
	void resolveIfPlaceholderAbsentUsesDefault() {
		this.resolver = new PropertySourcesPlaceholdersResolver((PropertySources) null);
		Object resolved = this.resolver.resolvePlaceholders('${FOO:bar}');
		assertThat(resolved).isEqualTo('bar');
	}
	@Test
	void resolveIfPlaceholderAbsentAndNoDefaultUsesPlaceholder() {
		this.resolver = new PropertySourcesPlaceholdersResolver((PropertySources) null);
		Object resolved = this.resolver.resolvePlaceholders('${FOO}');
		assertThat(resolved).isEqualTo('${FOO}');
	}
	@Test
	void resolveIfHelperPresentShouldUseIt() {
		MutablePropertySources sources = getPropertySources();
		TestPropertyPlaceholderHelper helper = new TestPropertyPlaceholderHelper('$<', '>');
		this.resolver = new PropertySourcesPlaceholdersResolver(sources, helper);
		Object resolved = this.resolver.resolvePlaceholders('$<FOO>');
		assertThat(resolved).isEqualTo('hello world');
	}
	private MutablePropertySources getPropertySources() {
		MutablePropertySources sources = new MutablePropertySources();
		Map<String, Object> source = new HashMap<>();
		source.put('FOO', 'hello world');
		sources.addFirst(new MapPropertySource('test', source));
		return sources;
	}
	static class TestPropertyPlaceholderHelper extends PropertyPlaceholderHelper {
		TestPropertyPlaceholderHelper(String placeholderPrefix, String placeholderSuffix) {
			super(placeholderPrefix, placeholderSuffix);
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
@ExtendWith(MockitoExtension.class)
class BindResultTests {
	@Mock
	private Consumer<String> consumer;
	@Mock
	private Function<String, String> mapper;
	@Mock
	private Supplier<String> supplier;
	@Test
	void getWhenHasValueShouldReturnValue() {
		BindResult<String> result = BindResult.of('foo');
		assertThat(result.get()).isEqualTo('foo');
	}
	@Test
	void getWhenHasNoValueShouldThrowException() {
		BindResult<String> result = BindResult.of(null);
		assertThatExceptionOfType(NoSuchElementException.class).isThrownBy(result::get)
			.withMessageContaining('No value bound');
	}
	@Test
	void isBoundWhenHasValueShouldReturnTrue() {
		BindResult<String> result = BindResult.of('foo');
		assertThat(result.isBound()).isTrue();
	}
	@Test
	void isBoundWhenHasNoValueShouldFalse() {
		BindResult<String> result = BindResult.of(null);
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void ifBoundWhenConsumerIsNullShouldThrowException() {
		BindResult<String> result = BindResult.of('foo');
		assertThatIllegalArgumentException().isThrownBy(() -> result.ifBound(null))
			.withMessageContaining('Consumer must not be null');
	}
	@Test
	void ifBoundWhenHasValueShouldCallConsumer() {
		BindResult<String> result = BindResult.of('foo');
		result.ifBound(this.consumer);
		then(this.consumer).should().accept('foo');
	}
	@Test
	void ifBoundWhenHasNoValueShouldNotCallConsumer() {
		BindResult<String> result = BindResult.of(null);
		result.ifBound(this.consumer);
		then(this.consumer).shouldHaveNoInteractions();
	}
	@Test
	void mapWhenMapperIsNullShouldThrowException() {
		BindResult<String> result = BindResult.of('foo');
		assertThatIllegalArgumentException().isThrownBy(() -> result.map(null))
			.withMessageContaining('Mapper must not be null');
	}
	@Test
	void mapWhenHasValueShouldCallMapper() {
		BindResult<String> result = BindResult.of('foo');
		given(this.mapper.apply('foo')).willReturn('bar');
		assertThat(result.map(this.mapper).get()).isEqualTo('bar');
	}
	@Test
	void mapWhenHasNoValueShouldNotCallMapper() {
		BindResult<String> result = BindResult.of(null);
		result.map(this.mapper);
		then(this.mapper).shouldHaveNoInteractions();
	}
	@Test
	void orElseWhenHasValueShouldReturnValue() {
		BindResult<String> result = BindResult.of('foo');
		assertThat(result.orElse('bar')).isEqualTo('foo');
	}
	@Test
	void orElseWhenHasValueNoShouldReturnOther() {
		BindResult<String> result = BindResult.of(null);
		assertThat(result.orElse('bar')).isEqualTo('bar');
	}
	@Test
	void orElseGetWhenHasValueShouldReturnValue() {
		BindResult<String> result = BindResult.of('foo');
		assertThat(result.orElseGet(this.supplier)).isEqualTo('foo');
		then(this.supplier).shouldHaveNoInteractions();
	}
	@Test
	void orElseGetWhenHasValueNoShouldReturnOther() {
		BindResult<String> result = BindResult.of(null);
		given(this.supplier.get()).willReturn('bar');
		assertThat(result.orElseGet(this.supplier)).isEqualTo('bar');
	}
	@Test
	void orElseThrowWhenHasValueShouldReturnValue() throws Exception {
		BindResult<String> result = BindResult.of('foo');
		assertThat(result.orElseThrow(IOException::new)).isEqualTo('foo');
	}
	@Test
	void orElseThrowWhenHasNoValueShouldThrowException() {
		BindResult<String> result = BindResult.of(null);
		assertThatIOException().isThrownBy(() -> result.orElseThrow(IOException::new));
	}
	@Test
	void hashCodeAndEquals() {
		BindResult<?> result1 = BindResult.of('foo');
		BindResult<?> result2 = BindResult.of('foo');
		BindResult<?> result3 = BindResult.of('bar');
		BindResult<?> result4 = BindResult.of(null);
		assertThat(result1).hasSameHashCodeAs(result2);
		assertThat(result1).isEqualTo(result1).isEqualTo(result2).isNotEqualTo(result3).isNotEqualTo(result4);
	}
	@Test
	void ofWhenHasValueShouldReturnBoundResultOfValue() {
		BindResult<Object> result = BindResult.of('foo');
		assertThat(result.isBound()).isTrue();
		assertThat(result.get()).isEqualTo('foo');
	}
	@Test
	void ofWhenValueIsNullShouldReturnUnbound() {
		BindResult<Object> result = BindResult.of(null);
		assertThat(result.isBound()).isFalse();
		assertThat(result).isSameAs(BindResult.of(null));
	}
	static class ExampleBean {
		private final String value;
		ExampleBean() {
			this.value = 'new';
		}
		ExampleBean(String value) {
			this.value = value;
		}
		String getValue() {
			return this.value;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
@ExtendWith(MockitoExtension.class)
class BoundPropertiesTrackingBindHandlerTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private BoundPropertiesTrackingBindHandler handler;
	private Binder binder;
	@Mock
	private Consumer<ConfigurationProperty> consumer;
	@BeforeEach
	void setup() {
		this.binder = new Binder(this.sources);
		this.handler = new BoundPropertiesTrackingBindHandler(this.consumer);
	}
	@Test
	void handlerShouldCallRecordBindingIfConfigurationPropertyIsNotNull() {
		this.sources.add(new MockConfigurationPropertySource('foo.age', 4));
		this.binder.bind('foo', Bindable.of(ExampleBean.class), this.handler);
		then(this.consumer).should().accept(any(ConfigurationProperty.class));
		then(this.consumer).should(never()).accept(null);
	}
	static class ExampleBean {
		private int age;
		int getAge() {
			return this.age;
		}
		void setAge(int age) {
			this.age = age;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
public class JavaBeanWithPublicConstructor {
	private String value;
	public JavaBeanWithPublicConstructor() {
	}
	public JavaBeanWithPublicConstructor(String value) {
		setValue(value);
	}
	public String getValue() {
		return this.value;
	}
	public void setValue(String value) {
		this.value = value;
	}
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
class ValidationErrorsTests {
	private static final ConfigurationPropertyName NAME = ConfigurationPropertyName.of('foo');
	@Test
	void createWhenNameIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ValidationErrors(null, Collections.emptySet(), Collections.emptyList()))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void createWhenBoundPropertiesIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ValidationErrors(NAME, null, Collections.emptyList()))
			.withMessageContaining('BoundProperties must not be null');
	}
	@Test
	void createWhenErrorsIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ValidationErrors(NAME, Collections.emptySet(), null))
			.withMessageContaining('Errors must not be null');
	}
	@Test
	void getNameShouldReturnName() {
		ConfigurationPropertyName name = NAME;
		ValidationErrors errors = new ValidationErrors(name, Collections.emptySet(), Collections.emptyList());
		assertThat((Object) errors.getName()).isEqualTo(name);
	}
	@Test
	void getBoundPropertiesShouldReturnBoundProperties() {
		Set<ConfigurationProperty> boundProperties = new LinkedHashSet<>();
		boundProperties.add(new ConfigurationProperty(NAME, 'foo', null));
		ValidationErrors errors = new ValidationErrors(NAME, boundProperties, Collections.emptyList());
		assertThat(errors.getBoundProperties()).isEqualTo(boundProperties);
	}
	@Test
	void getErrorsShouldReturnErrors() {
		List<ObjectError> allErrors = new ArrayList<>();
		allErrors.add(new ObjectError('foo', 'bar'));
		ValidationErrors errors = new ValidationErrors(NAME, Collections.emptySet(), allErrors);
		assertThat(errors.getAllErrors()).isEqualTo(allErrors);
	}
	@Test
	void iteratorShouldIterateErrors() {
		List<ObjectError> allErrors = new ArrayList<>();
		allErrors.add(new ObjectError('foo', 'bar'));
		ValidationErrors errors = new ValidationErrors(NAME, Collections.emptySet(), allErrors);
		assertThat(errors.iterator()).toIterable().containsExactlyElementsOf(allErrors);
	}
	@Test
	void getErrorsShouldAdaptFieldErrorsToBeOriginProviders() {
		Set<ConfigurationProperty> boundProperties = new LinkedHashSet<>();
		ConfigurationPropertyName name1 = ConfigurationPropertyName.of('foo.bar');
		Origin origin1 = MockOrigin.of('line1');
		boundProperties.add(new ConfigurationProperty(name1, 'boot', origin1));
		ConfigurationPropertyName name2 = ConfigurationPropertyName.of('foo.baz.bar');
		Origin origin2 = MockOrigin.of('line2');
		boundProperties.add(new ConfigurationProperty(name2, 'boot', origin2));
		List<ObjectError> allErrors = new ArrayList<>();
		allErrors.add(new FieldError('objectname', 'bar', 'message'));
		ValidationErrors errors = new ValidationErrors(ConfigurationPropertyName.of('foo.baz'), boundProperties,
				allErrors);
		assertThat(Origin.from(errors.getAllErrors().get(0))).isEqualTo(origin2);
	}
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
class OriginTrackedFieldErrorTests {
	private static final FieldError FIELD_ERROR = new FieldError('foo', 'bar', 'faf');
	private static final Origin ORIGIN = MockOrigin.of('afile');
	@Test
	void ofWhenFieldErrorIsNullShouldReturnNull() {
		assertThat(OriginTrackedFieldError.of(null, ORIGIN)).isNull();
	}
	@Test
	void ofWhenOriginIsNullShouldReturnFieldErrorWithoutOrigin() {
		assertThat(OriginTrackedFieldError.of(FIELD_ERROR, null)).isSameAs(FIELD_ERROR);
	}
	@Test
	void ofShouldReturnOriginCapableFieldError() {
		FieldError fieldError = OriginTrackedFieldError.of(FIELD_ERROR, ORIGIN);
		assertThat(fieldError.getObjectName()).isEqualTo('foo');
		assertThat(fieldError.getField()).isEqualTo('bar');
		assertThat(Origin.from(fieldError)).isEqualTo(ORIGIN);
	}
	@Test
	void toStringShouldAddOrigin() {
		assertThat(OriginTrackedFieldError.of(FIELD_ERROR, ORIGIN))
			.hasToString('Field error in object "foo" on field "bar": rejected value [null]'
					+ '; codes []; arguments []; default message [faf]; origin afile');
	}
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
class BindValidationExceptionTests {
	@Test
	void createWhenValidationErrorsIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new BindValidationException(null))
			.withMessageContaining('ValidationErrors must not be null');
	}
	@Test
	void getValidationErrorsShouldReturnValidationErrors() {
		ValidationErrors errors = mock(ValidationErrors.class);
		BindValidationException exception = new BindValidationException(errors);
		assertThat(exception.getValidationErrors()).isEqualTo(errors);
	}
}
/*
package org.springframework.boot.context.properties.bind.validation;
/**
class ValidationBindHandlerTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private ValidationBindHandler handler;
	private Binder binder;
	private LocalValidatorFactoryBean validator;
	@BeforeEach
	void setup() {
		this.binder = new Binder(this.sources);
		this.validator = new LocalValidatorFactoryBean();
		this.validator.afterPropertiesSet();
		this.handler = new ValidationBindHandler(this.validator);
	}
	@Test
	void bindShouldBindWithoutHandler() {
		this.sources.add(new MockConfigurationPropertySource('foo.age', 4));
		ExampleValidatedBean bean = this.binder.bind('foo', Bindable.of(ExampleValidatedBean.class)).get();
		assertThat(bean.getAge()).isEqualTo(4);
	}
	@Test
	void bindShouldFailWithHandler() {
		this.sources.add(new MockConfigurationPropertySource('foo.age', 4));
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleValidatedBean.class), this.handler))
			.withCauseInstanceOf(BindValidationException.class);
	}
	@Test
	void bindShouldValidateNestedProperties() {
		this.sources.add(new MockConfigurationPropertySource('foo.nested.age', 4));
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleValidatedWithNestedBean.class), this.handler))
			.withCauseInstanceOf(BindValidationException.class);
	}
	@Test
	void bindShouldFailWithAccessToOrigin() {
		this.sources.add(new MockConfigurationPropertySource('foo.age', 4, 'file'));
		BindValidationException cause = bindAndExpectValidationError(() -> this.binder
			.bind(ConfigurationPropertyName.of('foo'), Bindable.of(ExampleValidatedBean.class), this.handler));
		ObjectError objectError = cause.getValidationErrors().getAllErrors().get(0);
		assertThat(Origin.from(objectError)).hasToString('file');
	}
	@Test
	void bindShouldFailWithAccessToBoundProperties() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.nested.name', 'baz');
		source.put('foo.nested.age', '4');
		source.put('faf.bar', 'baz');
		this.sources.add(source);
		BindValidationException cause = bindAndExpectValidationError(() -> this.binder.bind(
				ConfigurationPropertyName.of('foo'), Bindable.of(ExampleValidatedWithNestedBean.class), this.handler));
		Set<ConfigurationProperty> boundProperties = cause.getValidationErrors().getBoundProperties();
		assertThat(boundProperties).extracting((p) -> p.getName().toString())
			.contains('foo.nested.age', 'foo.nested.name');
	}
	@Test
	void bindShouldFailWithAccessToNameAndValue() {
		this.sources.add(new MockConfigurationPropertySource('foo.nested.age', '4'));
		BindValidationException cause = bindAndExpectValidationError(() -> this.binder.bind(
				ConfigurationPropertyName.of('foo'), Bindable.of(ExampleValidatedWithNestedBean.class), this.handler));
		assertThat(cause.getValidationErrors().getName()).hasToString('foo.nested');
		assertThat(cause.getMessage()).contains('nested.age');
		assertThat(cause.getMessage()).contains('rejected value [4]');
	}
	@Test
	void bindShouldFailIfExistingValueIsInvalid() {
		ExampleValidatedBean existingValue = new ExampleValidatedBean();
		BindValidationException cause = bindAndExpectValidationError(
				() -> this.binder.bind(ConfigurationPropertyName.of('foo'),
						Bindable.of(ExampleValidatedBean.class).withExistingValue(existingValue), this.handler));
		FieldError fieldError = (FieldError) cause.getValidationErrors().getAllErrors().get(0);
		assertThat(fieldError.getField()).isEqualTo('age');
	}
	@Test
	void bindShouldValidateWithoutAnnotation() {
		ExampleNonValidatedBean existingValue = new ExampleNonValidatedBean();
		bindAndExpectValidationError(() -> this.binder.bind(ConfigurationPropertyName.of('foo'),
				Bindable.of(ExampleNonValidatedBean.class).withExistingValue(existingValue), this.handler));
	}
	@Test
	void bindShouldNotValidateDepthGreaterThanZero() {
		// gh-12227
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'baz');
		this.sources.add(source);
		ExampleValidatedBeanWithGetterException existingValue = new ExampleValidatedBeanWithGetterException();
		this.binder.bind(ConfigurationPropertyName.of('foo'),
				Bindable.of(ExampleValidatedBeanWithGetterException.class).withExistingValue(existingValue),
				this.handler);
	}
	@Test
	void bindShouldNotValidateIfOtherHandlersInChainThrowError() {
		this.sources.add(new MockConfigurationPropertySource('foo', 'hello'));
		ExampleValidatedBean bean = new ExampleValidatedBean();
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleValidatedBean.class).withExistingValue(bean),
					this.handler))
			.withCauseInstanceOf(ConverterNotFoundException.class);
	}
	@Test
	void bindShouldValidateIfOtherHandlersInChainIgnoreError() {
		TestHandler testHandler = new TestHandler(null);
		this.handler = new ValidationBindHandler(testHandler, this.validator);
		this.sources.add(new MockConfigurationPropertySource('foo', 'hello'));
		ExampleValidatedBean bean = new ExampleValidatedBean();
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleValidatedBean.class).withExistingValue(bean),
					this.handler))
			.withCauseInstanceOf(BindValidationException.class);
	}
	@Test
	void bindShouldValidateIfOtherHandlersInChainReplaceErrorWithResult() {
		TestHandler testHandler = new TestHandler(new ExampleValidatedBeanSubclass());
		this.handler = new ValidationBindHandler(testHandler, this.validator);
		this.sources.add(new MockConfigurationPropertySource('foo', 'hello'));
		this.sources.add(new MockConfigurationPropertySource('foo.age', 'bad'));
		this.sources.add(new MockConfigurationPropertySource('foo.years', '99'));
		ExampleValidatedBean bean = new ExampleValidatedBean();
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleValidatedBean.class).withExistingValue(bean),
					this.handler))
			.withCauseInstanceOf(BindValidationException.class)
			.satisfies((ex) -> assertThat(ex.getCause()).hasMessageContaining('years'));
	}
	@Test
	void validationErrorsForCamelCaseFieldsShouldContainRejectedValue() {
		this.sources.add(new MockConfigurationPropertySource('foo.inner.person-age', 2));
		BindValidationException cause = bindAndExpectValidationError(() -> this.binder
			.bind(ConfigurationPropertyName.of('foo'), Bindable.of(ExampleCamelCase.class), this.handler));
		assertThat(cause.getMessage()).contains('rejected value [2]');
	}
	@Test
	void validationShouldBeSkippedIfPreviousValidationErrorPresent() {
		this.sources.add(new MockConfigurationPropertySource('foo.inner.person-age', 2));
		BindValidationException cause = bindAndExpectValidationError(() -> this.binder
			.bind(ConfigurationPropertyName.of('foo'), Bindable.of(ExampleCamelCase.class), this.handler));
		FieldError fieldError = (FieldError) cause.getValidationErrors().getAllErrors().get(0);
		assertThat(fieldError.getField()).isEqualTo('personAge');
	}
	@Test
	void validateMapValues() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.items.[itemOne].number', 'one');
		source.put('test.items.[ITEM2].number', 'two');
		this.sources.add(source);
		Validator validator = getMapValidator();
		this.handler = new ValidationBindHandler(validator);
		this.binder.bind(ConfigurationPropertyName.of('test'), Bindable.of(ExampleWithMap.class), this.handler);
	}
	@Test
	void validateMapValuesWithNonUniformSource() {
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('test.items.itemOne.number', 'one');
		map.put('test.items.ITEM2.number', 'two');
		this.sources.add(ConfigurationPropertySources.from(new MapPropertySource('test', map)).iterator().next());
		Validator validator = getMapValidator();
		this.handler = new ValidationBindHandler(validator);
		this.binder.bind(ConfigurationPropertyName.of('test'), Bindable.of(ExampleWithMap.class), this.handler);
	}
	private Validator getMapValidator() {
		return new Validator() {
			@Override
			public boolean supports(Class<?> type) {
				return ExampleWithMap.class == type;
			}
			@Override
			public void validate(Object target, Errors errors) {
				ExampleWithMap value = (ExampleWithMap) target;
				value.getItems().forEach((k, v) -> {
					try {
						errors.pushNestedPath('items[' + k + ']');
						ValidationUtils.rejectIfEmptyOrWhitespace(errors, 'number', 'NUMBER_ERR');
					}
					finally {
						errors.popNestedPath();
					}
				});
			}
		};
	}
	private BindValidationException bindAndExpectValidationError(Runnable action) {
		try {
			action.run();
		}
		catch (BindException ex) {
			return (BindValidationException) ex.getCause();
		}
		throw new IllegalStateException('Did not throw');
	}
	static class ExampleNonValidatedBean {
		@Min(5)
		private int age;
		int getAge() {
			return this.age;
		}
		void setAge(int age) {
			this.age = age;
		}
	}
	@Validated
	static class ExampleValidatedBean {
		@Min(5)
		private int age;
		int getAge() {
			return this.age;
		}
		void setAge(int age) {
			this.age = age;
		}
	}
	public static class ExampleValidatedBeanSubclass extends ExampleValidatedBean {
		@Min(100)
		private int years;
		ExampleValidatedBeanSubclass() {
			setAge(20);
		}
		public int getYears() {
			return this.years;
		}
		public void setYears(int years) {
			this.years = years;
		}
	}
	@Validated
	static class ExampleValidatedWithNestedBean {
		@Valid
		private ExampleNested nested = new ExampleNested();
		ExampleNested getNested() {
			return this.nested;
		}
		void setNested(ExampleNested nested) {
			this.nested = nested;
		}
	}
	static class ExampleNested {
		private String name;
		@Min(5)
		private int age;
		@NotNull
		private String address;
		String getName() {
			return this.name;
		}
		void setName(String name) {
			this.name = name;
		}
		int getAge() {
			return this.age;
		}
		void setAge(int age) {
			this.age = age;
		}
		String getAddress() {
			return this.address;
		}
		void setAddress(String address) {
			this.address = address;
		}
	}
	@Validated
	static class ExampleCamelCase {
		@Valid
		private final InnerProperties inner = new InnerProperties();
		InnerProperties getInner() {
			return this.inner;
		}
		static class InnerProperties {
			@Min(5)
			private int personAge;
			int getPersonAge() {
				return this.personAge;
			}
			void setPersonAge(int personAge) {
				this.personAge = personAge;
			}
		}
	}
	@Validated
	static class ExampleValidatedBeanWithGetterException {
		int getAge() {
			throw new RuntimeException();
		}
	}
	static class ExampleWithMap {
		private final Map<String, ExampleMapValue> items = new LinkedHashMap<>();
		Map<String, ExampleMapValue> getItems() {
			return this.items;
		}
	}
	static class ExampleMapValue {
		private String number;
		String getNumber() {
			return this.number;
		}
		void setNumber(String number) {
			this.number = number;
		}
	}
	static class TestHandler extends AbstractBindHandler {
		private final Object result;
		TestHandler(Object result) {
			this.result = result;
		}
		@Override
		public Object onFailure(ConfigurationPropertyName name, Bindable<?> target, BindContext context,
				Exception error) throws Exception {
			return this.result;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class BackCompatibilityBinderIntegrationTests {
	@Test
	void bindWhenBindingCamelCaseToEnvironmentWithExtractUnderscore() {
		// gh-10873
		MockEnvironment environment = new MockEnvironment();
		SystemEnvironmentPropertySource propertySource = new SystemEnvironmentPropertySource(
				StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				Collections.singletonMap('FOO_ZK_NODES', 'foo'));
		environment.getPropertySources().addFirst(propertySource);
		ExampleCamelCaseBean result = Binder.get(environment)
			.bind('foo', Bindable.of(ExampleCamelCaseBean.class))
			.get();
		assertThat(result.getZkNodes()).isEqualTo('foo');
	}
	@Test
	void bindWhenUsingSystemEnvironmentToOverride() {
		MockEnvironment environment = new MockEnvironment();
		SystemEnvironmentPropertySource propertySource = new SystemEnvironmentPropertySource('override',
				Collections.singletonMap('foo.password', 'test'));
		environment.getPropertySources().addFirst(propertySource);
		PasswordProperties result = Binder.get(environment).bind('foo', Bindable.of(PasswordProperties.class)).get();
		assertThat(result.getPassword()).isEqualTo('test');
	}
	static class ExampleCamelCaseBean {
		private String zkNodes;
		String getZkNodes() {
			return this.zkNodes;
		}
		void setZkNodes(String zkNodes) {
			this.zkNodes = zkNodes;
		}
	}
	static class PasswordProperties {
		private String password;
		String getPassword() {
			return this.password;
		}
		void setPassword(String password) {
			this.password = password;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class ValueObjectBinderTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private final Binder binder = new Binder(this.sources);
	@Test
	void bindToClassShouldCreateBoundBean() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		source.put('foo.long-value', '34');
		source.put('foo.boolean-value', 'true');
		source.put('foo.string-value', 'foo');
		source.put('foo.enum-value', 'foo-bar');
		this.sources.add(source);
		ExampleValueBean bean = this.binder.bind('foo', Bindable.of(ExampleValueBean.class)).get();
		assertThat(bean.getIntValue()).isEqualTo(12);
		assertThat(bean.getLongValue()).isEqualTo(34);
		assertThat(bean.isBooleanValue()).isTrue();
		assertThat(bean.getStringValue()).isEqualTo('foo');
		assertThat(bean.getEnumValue()).isEqualTo(ExampleEnum.FOO_BAR);
	}
	@Test
	void bindToClassWhenHasNoPrefixShouldCreateBoundBean() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('int-value', '12');
		source.put('long-value', '34');
		source.put('boolean-value', 'true');
		source.put('string-value', 'foo');
		source.put('enum-value', 'foo-bar');
		this.sources.add(source);
		ExampleValueBean bean = this.binder.bind(ConfigurationPropertyName.of(''), Bindable.of(ExampleValueBean.class))
			.get();
		assertThat(bean.getIntValue()).isEqualTo(12);
		assertThat(bean.getLongValue()).isEqualTo(34);
		assertThat(bean.isBooleanValue()).isTrue();
		assertThat(bean.getStringValue()).isEqualTo('foo');
		assertThat(bean.getEnumValue()).isEqualTo(ExampleEnum.FOO_BAR);
	}
	@Test
	void bindToAbstractClassWithShouldNotBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.name', 'test');
		this.sources.add(source);
		boolean bound = this.binder.bind('foo', Bindable.of(ExampleAbstractBean.class)).isBound();
		assertThat(bound).isFalse();
	}
	@Test
	void bindToClassWithMultipleConstructorsShouldNotBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		this.sources.add(source);
		boolean bound = this.binder.bind('foo', Bindable.of(MultipleConstructorsBean.class)).isBound();
		assertThat(bound).isFalse();
	}
	@Test
	void bindToClassWithMultipleConstructorsAndFilterShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		this.sources.add(source);
		Constructor<?>[] constructors = MultipleConstructorsBean.class.getDeclaredConstructors();
		Constructor<?> constructor = (constructors[0].getParameterCount() == 1) ? constructors[0] : constructors[1];
		Binder binder = new Binder(this.sources, null, (ConversionService) null, null, null,
				(bindable, isNestedConstructorBinding) -> constructor);
		MultipleConstructorsBean bound = binder.bind('foo', Bindable.of(MultipleConstructorsBean.class)).get();
		assertThat(bound.getIntValue()).isEqualTo(12);
	}
	@Test
	void bindToClassWithOnlyDefaultConstructorShouldNotBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		this.sources.add(source);
		boolean bound = this.binder.bind('foo', Bindable.of(DefaultConstructorBean.class)).isBound();
		assertThat(bound).isFalse();
	}
	@Test
	void bindToClassWithMultipleConstructorsWhenOnlyOneIsNotPrivateShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		this.sources.add(source);
		MultipleConstructorsOnlyOneNotPrivateBean bean = this.binder
			.bind('foo', Bindable.of(MultipleConstructorsOnlyOneNotPrivateBean.class))
			.get();
		bean = bean.withString('test');
		assertThat(bean.getIntValue()).isEqualTo(12);
		assertThat(bean.getStringValue()).isEqualTo('test');
	}
	@Test
	void bindToClassShouldBindNested() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value-bean.int-value', '123');
		source.put('foo.value-bean.long-value', '34');
		source.put('foo.value-bean.string-value', 'foo');
		this.sources.add(source);
		ExampleNestedBean bean = this.binder.bind('foo', Bindable.of(ExampleNestedBean.class)).get();
		assertThat(bean.getValueBean().getIntValue()).isEqualTo(123);
		assertThat(bean.getValueBean().getLongValue()).isEqualTo(34);
		assertThat(bean.getValueBean().isBooleanValue()).isFalse();
		assertThat(bean.getValueBean().getStringValue()).isEqualTo('foo');
		assertThat(bean.getValueBean().getEnumValue()).isNull();
	}
	@Test
	void bindToClassWithNoValueForPrimitiveShouldUseDefault() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.string-value', 'foo');
		this.sources.add(source);
		ExampleValueBean bean = this.binder.bind('foo', Bindable.of(ExampleValueBean.class)).get();
		assertThat(bean.getIntValue()).isZero();
		assertThat(bean.getLongValue()).isZero();
		assertThat(bean.isBooleanValue()).isFalse();
		assertThat(bean.getStringValue()).isEqualTo('foo');
	}
	@Test
	void bindToClassWithNoValueAndDefaultValueShouldNotBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.string-value', 'foo');
		this.sources.add(source);
		assertThat(this.binder.bind('foo', Bindable.of(ExampleDefaultValueBean.class)).isBound()).isFalse();
	}
	@Test
	void bindToClassWhenNoParameterBoundShouldReturnNull() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		this.sources.add(source.nonIterable());
		BindResult<ExampleFailingConstructorBean> result = this.binder.bind('foo',
				Bindable.of(ExampleFailingConstructorBean.class));
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindWithAnnotations() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.date', '2014-04-01');
		this.sources.add(source);
		ConverterAnnotatedExampleBean bean = this.binder.bind('foo', Bindable.of(ConverterAnnotatedExampleBean.class))
			.get();
		assertThat(bean.getDate()).hasToString('2014-04-01');
	}
	@Test
	void bindWithAnnotationsAndDefaultValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'hello');
		this.sources.add(source);
		ConverterAnnotatedExampleBean bean = this.binder.bind('foo', Bindable.of(ConverterAnnotatedExampleBean.class))
			.get();
		assertThat(bean.getDate()).hasToString('2019-05-10');
	}
	@Test
	void bindToClassWhenHasPackagePrivateConstructorShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.property', 'test');
		this.sources.add(source);
		ExamplePackagePrivateConstructorBean bound = this.binder
			.bind('foo', Bindable.of(ExamplePackagePrivateConstructorBean.class))
			.get();
		assertThat(bound.getProperty()).isEqualTo('test');
	}
	@Test
	void createShouldReturnCreatedValue() {
		ExampleValueBean value = this.binder.bindOrCreate('foo', Bindable.of(ExampleValueBean.class));
		assertThat(value.getIntValue()).isZero();
		assertThat(value.getLongValue()).isZero();
		assertThat(value.isBooleanValue()).isFalse();
		assertThat(value.getStringValue()).isNull();
		assertThat(value.getEnumValue()).isNull();
	}
	@Test
	void createWithNestedShouldReturnCreatedValue() {
		ExampleNestedBean value = this.binder.bindOrCreate('foo', Bindable.of(ExampleNestedBean.class));
		assertThat(value.getValueBean()).isNull();
	}
	@Test
	void createWithDefaultValuesShouldReturnCreatedWithDefaultValues() {
		ExampleDefaultValueBean value = this.binder.bindOrCreate('foo', Bindable.of(ExampleDefaultValueBean.class));
		assertThat(value.getIntValue()).isEqualTo(5);
		assertThat(value.getStringsList()).containsOnly('a', 'b', 'c');
		assertThat(value.getCustomList()).containsOnly('x,y,z');
	}
	@Test
	void createWithDefaultValuesAndAnnotationsShouldReturnCreatedWithDefaultValues() {
		ConverterAnnotatedExampleBean bean = this.binder.bindOrCreate('foo',
				Bindable.of(ConverterAnnotatedExampleBean.class));
		assertThat(bean.getDate()).hasToString('2019-05-10');
	}
	@Test
	void bindWhenAllPropertiesBoundShouldClearConfigurationProperty() { // gh-18704
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'hello');
		this.sources.add(source);
		Bindable<ValidatingConstructorBean> target = Bindable.of(ValidatingConstructorBean.class);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.binder.bind('foo', target))
			.satisfies(this::noConfigurationProperty);
	}
	@Test
	void bindToClassShouldBindWithGenerics() {
		// gh-19156
		ResolvableType type = ResolvableType.forClassWithGenerics(Map.class, String.class, String.class);
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value.bar', 'baz');
		this.sources.add(source);
		GenericValue<Map<String, String>> bean = this.binder
			.bind('foo', Bindable
				.<GenericValue<Map<String, String>>>of(ResolvableType.forClassWithGenerics(GenericValue.class, type)))
			.get();
		assertThat(bean.getValue()).containsEntry('bar', 'baz');
	}
	@Test
	void bindWhenParametersWithDefaultValueShouldReturnNonNullValues() {
		NestedConstructorBeanWithDefaultValue bound = this.binder.bindOrCreate('foo',
				Bindable.of(NestedConstructorBeanWithDefaultValue.class));
		assertThat(bound.getNestedImmutable().getFoo()).isEqualTo('hello');
		assertThat(bound.getNestedJavaBean()).isNotNull();
	}
	@Test
	void bindWhenJavaLangParameterWithEmptyDefaultValueShouldThrowException() {
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bindOrCreate('foo',
					Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForJavaLangTypes.class)))
			.withStackTraceContaining('Parameter of type java.lang.String must have a non-empty default value.');
	}
	@Test
	void bindWhenCollectionParameterWithEmptyDefaultValueShouldReturnEmptyInstance() {
		NestedConstructorBeanWithEmptyDefaultValueForCollectionTypes bound = this.binder.bindOrCreate('foo',
				Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForCollectionTypes.class));
		assertThat(bound.getListValue()).isEmpty();
	}
	@Test
	void bindWhenMapParametersWithEmptyDefaultValueShouldReturnEmptyInstance() {
		NestedConstructorBeanWithEmptyDefaultValueForMapTypes bound = this.binder.bindOrCreate('foo',
				Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForMapTypes.class));
		assertThat(bound.getMapValue()).isEmpty();
	}
	@Test
	void bindWhenEnumMapParametersWithEmptyDefaultValueShouldReturnEmptyInstance() {
		NestedConstructorBeanWithEmptyDefaultValueForEnumMapTypes bound = this.binder.bindOrCreate('foo',
				Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForEnumMapTypes.class));
		assertThat(bound.getMapValue()).isEmpty();
	}
	@Test
	void bindWhenArrayParameterWithEmptyDefaultValueShouldReturnEmptyInstance() {
		NestedConstructorBeanWithEmptyDefaultValueForArrayTypes bound = this.binder.bindOrCreate('foo',
				Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForArrayTypes.class));
		assertThat(bound.getArrayValue()).isEmpty();
	}
	@Test
	void bindWhenOptionalParameterWithEmptyDefaultValueShouldReturnEmptyInstance() {
		NestedConstructorBeanWithEmptyDefaultValueForOptionalTypes bound = this.binder.bindOrCreate('foo',
				Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForOptionalTypes.class));
		assertThat(bound.getOptionalValue()).isEmpty();
	}
	@Test
	void bindWhenEnumParameterWithEmptyDefaultValueShouldThrowException() {
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bindOrCreate('foo',
					Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForEnumTypes.class)))
			.withStackTraceContaining(
					'Parameter of type org.springframework.boot.context.properties.bind.ValueObjectBinderTests$NestedConstructorBeanWithEmptyDefaultValueForEnumTypes$Foo must have a non-empty default value.');
	}
	@Test
	void bindWhenPrimitiveParameterWithEmptyDefaultValueShouldThrowException() {
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bindOrCreate('foo',
					Bindable.of(NestedConstructorBeanWithEmptyDefaultValueForPrimitiveTypes.class)))
			.withStackTraceContaining('Parameter of type int must have a non-empty default value.');
	}
	@Test
	void bindWhenBindingToPathTypeWithValue() { // gh-21263
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.name', 'test');
		source.put('test.path', 'specific_value');
		this.sources.add(source);
		Bindable<PathBean> target = Bindable.of(PathBean.class);
		PathBean bound = this.binder.bind('test', target).get();
		assertThat(bound.getName()).isEqualTo('test');
		assertThat(bound.getPath()).isEqualTo(Paths.get('specific_value'));
	}
	@Test
	void bindWhenBindingToPathTypeWithDefaultValue() { // gh-21263
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.name', 'test');
		this.sources.add(source);
		Bindable<PathBean> target = Bindable.of(PathBean.class);
		PathBean bound = this.binder.bindOrCreate('test', target);
		assertThat(bound.getName()).isEqualTo('test');
		assertThat(bound.getPath()).isEqualTo(Paths.get('default_value'));
	}
	@Test
	void bindToAnnotationNamedConstructorParameter() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.import', 'test');
		this.sources.add(source);
		Bindable<NamedConstructorParameter> target = Bindable.of(NamedConstructorParameter.class);
		NamedConstructorParameter bound = this.binder.bindOrCreate('test', target);
		assertThat(bound.getImportName()).isEqualTo('test');
	}
	@Test
	void bindToAnnotationNamedRecordComponent() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.import', 'test');
		this.sources.add(source);
		Bindable<NamedRecordComponent> target = Bindable.of(NamedRecordComponent.class);
		NamedRecordComponent bound = this.binder.bindOrCreate('test', target);
		assertThat(bound.importName()).isEqualTo('test');
	}
	@Test
	void bindToRecordWithDefaultValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.record.property1', 'value-from-config-1');
		this.sources.add(source);
		String recordProperties = '''
				public record RecordProperties(
					@org.springframework.boot.context.properties.bind.DefaultValue('default-value-1') String property1,
					@org.springframework.boot.context.properties.bind.DefaultValue('default-value-2') String property2) {
				}
				''';
		TestCompiler.forSystem().withSources(SourceFile.of(recordProperties)).compile((compiled) -> {
			try {
				ClassLoader cl = compiled.getClassLoader();
				Object bean = this.binder.bind('test.record', Class.forName('RecordProperties', true, cl)).get();
				assertThat(bean).hasFieldOrPropertyWithValue('property1', 'value-from-config-1')
					.hasFieldOrPropertyWithValue('property2', 'default-value-2');
			}
			catch (ClassNotFoundException ex) {
				fail('Expected generated class "RecordProperties" not found', ex);
			}
		});
	}
	@Test // gh-38201
	void bindWhenNonExtractableParameterNamesOnPropertyAndNonIterablePropertySource() throws Exception {
		verifyJsonPathParametersCannotBeResolved();
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.value', 'test');
		this.sources.add(source.nonIterable());
		Bindable<NonExtractableParameterName> target = Bindable.of(NonExtractableParameterName.class);
		NonExtractableParameterName bound = this.binder.bindOrCreate('test', target);
		assertThat(bound.getValue()).isEqualTo('test');
	}
	@Test
	void createWhenNonExtractableParameterNamesOnPropertyAndNonIterablePropertySource() throws Exception {
		assertThat(new DefaultParameterNameDiscoverer()
			.getParameterNames(CharacterIndex.class.getDeclaredConstructor(CharSequence.class))).isNull();
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		this.sources.add(source.nonIterable());
		Bindable<CharacterIndex> target = Bindable.of(CharacterIndex.class).withBindMethod(BindMethod.VALUE_OBJECT);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.binder.bindOrCreate('test', target))
			.withStackTraceContaining('Ensure that the compiler uses the "-parameters" flag');
	}
	private void verifyJsonPathParametersCannotBeResolved() throws NoSuchFieldException {
		Class<?> jsonPathClass = NonExtractableParameterName.class.getDeclaredField('jsonPath').getType();
		Constructor<?>[] constructors = jsonPathClass.getDeclaredConstructors();
		assertThat(constructors).hasSize(1);
		constructors[0].setAccessible(true);
		assertThat(new DefaultParameterNameDiscoverer().getParameterNames(constructors[0])).isNull();
	}
	private void noConfigurationProperty(BindException ex) {
		assertThat(ex.getProperty()).isNull();
	}
	static class ExampleValueBean {
		private final int intValue;
		private final long longValue;
		private final boolean booleanValue;
		private final String stringValue;
		private final ExampleEnum enumValue;
		ExampleValueBean(int intValue, long longValue, boolean booleanValue, String stringValue,
				ExampleEnum enumValue) {
			this.intValue = intValue;
			this.longValue = longValue;
			this.booleanValue = booleanValue;
			this.stringValue = stringValue;
			this.enumValue = enumValue;
		}
		int getIntValue() {
			return this.intValue;
		}
		long getLongValue() {
			return this.longValue;
		}
		boolean isBooleanValue() {
			return this.booleanValue;
		}
		String getStringValue() {
			return this.stringValue;
		}
		ExampleEnum getEnumValue() {
			return this.enumValue;
		}
	}
	public enum ExampleEnum {
		FOO_BAR,
		BAR_BAZ
	}
	static class MultipleConstructorsBean {
		private final int intValue;
		MultipleConstructorsBean(int intValue) {
			this(intValue, 23L, 'hello');
		}
		MultipleConstructorsBean(int intValue, long longValue, String stringValue) {
			this.intValue = intValue;
		}
		int getIntValue() {
			return this.intValue;
		}
	}
	static class MultipleConstructorsOnlyOneNotPrivateBean {
		private final int intValue;
		private final String stringValue;
		MultipleConstructorsOnlyOneNotPrivateBean(int intValue) {
			this(intValue, 23L, 'hello');
		}
		private MultipleConstructorsOnlyOneNotPrivateBean(int intValue, long longValue, String stringValue) {
			this.intValue = intValue;
			this.stringValue = stringValue;
		}
		int getIntValue() {
			return this.intValue;
		}
		String getStringValue() {
			return this.stringValue;
		}
		MultipleConstructorsOnlyOneNotPrivateBean withString(String stringValue) {
			return new MultipleConstructorsOnlyOneNotPrivateBean(this.intValue, 0, stringValue);
		}
	}
	abstract static class ExampleAbstractBean {
		private final String name;
		ExampleAbstractBean(String name) {
			this.name = name;
		}
		String getName() {
			return this.name;
		}
	}
	static class DefaultConstructorBean {
		DefaultConstructorBean() {
		}
	}
	static class ExampleNestedBean {
		private final ExampleValueBean valueBean;
		ExampleNestedBean(ExampleValueBean valueBean) {
			this.valueBean = valueBean;
		}
		ExampleValueBean getValueBean() {
			return this.valueBean;
		}
	}
	static class ExampleDefaultValueBean {
		private final int intValue;
		private final List<String> stringsList;
		private final List<String> customList;
		ExampleDefaultValueBean(@DefaultValue('5') int intValue,
				@DefaultValue({ 'a', 'b', 'c' }) List<String> stringsList,
				@DefaultValue('x,y,z') List<String> customList) {
			this.intValue = intValue;
			this.stringsList = stringsList;
			this.customList = customList;
		}
		int getIntValue() {
			return this.intValue;
		}
		List<String> getStringsList() {
			return this.stringsList;
		}
		List<String> getCustomList() {
			return this.customList;
		}
	}
	static class ExampleFailingConstructorBean {
		private final String name;
		private final Object value;
		ExampleFailingConstructorBean(String name, String value) {
			Assert.notNull(name, '"name" must be not null.');
			Assert.notNull(value, '"value" must be not null.');
			this.name = name;
			this.value = value;
		}
		String getName() {
			return this.name;
		}
		Object getValue() {
			return this.value;
		}
	}
	static class ConverterAnnotatedExampleBean {
		private final LocalDate date;
		private final String bar;
		ConverterAnnotatedExampleBean(
				@DefaultValue('2019-05-10') @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate date, String bar) {
			this.date = date;
			this.bar = bar;
		}
		LocalDate getDate() {
			return this.date;
		}
		String getBar() {
			return this.bar;
		}
	}
	static class ExamplePackagePrivateConstructorBean {
		private final String property;
		ExamplePackagePrivateConstructorBean(String property) {
			this.property = property;
		}
		String getProperty() {
			return this.property;
		}
	}
	static class ValidatingConstructorBean {
		private final String foo;
		private final String bar;
		ValidatingConstructorBean(String foo, String bar) {
			Assert.notNull(foo, 'Foo must not be null');
			this.foo = foo;
			this.bar = bar;
		}
		String getFoo() {
			return this.foo;
		}
		String getBar() {
			return this.bar;
		}
	}
	static class GenericValue<T> {
		private final T value;
		GenericValue(T value) {
			this.value = value;
		}
		T getValue() {
			return this.value;
		}
	}
	static class NestedConstructorBeanWithDefaultValue {
		private final NestedImmutable nestedImmutable;
		private final NestedJavaBean nestedJavaBean;
		NestedConstructorBeanWithDefaultValue(@DefaultValue NestedImmutable nestedImmutable,
				@DefaultValue NestedJavaBean nestedJavaBean) {
			this.nestedImmutable = nestedImmutable;
			this.nestedJavaBean = nestedJavaBean;
		}
		NestedImmutable getNestedImmutable() {
			return this.nestedImmutable;
		}
		NestedJavaBean getNestedJavaBean() {
			return this.nestedJavaBean;
		}
	}
	static class NestedImmutable {
		private final String foo;
		private final String bar;
		NestedImmutable(@DefaultValue('hello') String foo, String bar) {
			this.foo = foo;
			this.bar = bar;
		}
		String getFoo() {
			return this.foo;
		}
		String getBar() {
			return this.bar;
		}
	}
	static class NestedJavaBean {
		private String value;
		String getValue() {
			return this.value;
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForJavaLangTypes {
		private final String stringValue;
		NestedConstructorBeanWithEmptyDefaultValueForJavaLangTypes(@DefaultValue String stringValue) {
			this.stringValue = stringValue;
		}
		String getStringValue() {
			return this.stringValue;
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForCollectionTypes {
		private final List<String> listValue;
		NestedConstructorBeanWithEmptyDefaultValueForCollectionTypes(@DefaultValue List<String> listValue) {
			this.listValue = listValue;
		}
		List<String> getListValue() {
			return this.listValue;
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForMapTypes {
		private final Map<String, String> mapValue;
		NestedConstructorBeanWithEmptyDefaultValueForMapTypes(@DefaultValue Map<String, String> mapValue) {
			this.mapValue = mapValue;
		}
		Map<String, String> getMapValue() {
			return this.mapValue;
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForEnumMapTypes {
		private final EnumMap<ExampleEnum, String> mapValue;
		NestedConstructorBeanWithEmptyDefaultValueForEnumMapTypes(@DefaultValue EnumMap<ExampleEnum, String> mapValue) {
			this.mapValue = mapValue;
		}
		EnumMap<ExampleEnum, String> getMapValue() {
			return this.mapValue;
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForArrayTypes {
		private final String[] arrayValue;
		NestedConstructorBeanWithEmptyDefaultValueForArrayTypes(@DefaultValue String[] arrayValue) {
			this.arrayValue = arrayValue;
		}
		String[] getArrayValue() {
			return this.arrayValue;
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForOptionalTypes {
		private final Optional<String> optionalValue;
		NestedConstructorBeanWithEmptyDefaultValueForOptionalTypes(@DefaultValue Optional<String> optionalValue) {
			this.optionalValue = optionalValue;
		}
		Optional<String> getOptionalValue() {
			return this.optionalValue;
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForEnumTypes {
		private final Foo foo;
		NestedConstructorBeanWithEmptyDefaultValueForEnumTypes(@DefaultValue Foo foo) {
			this.foo = foo;
		}
		Foo getFoo() {
			return this.foo;
		}
		enum Foo {
			BAR, BAZ
		}
	}
	static class NestedConstructorBeanWithEmptyDefaultValueForPrimitiveTypes {
		private final int intValue;
		NestedConstructorBeanWithEmptyDefaultValueForPrimitiveTypes(@DefaultValue int intValue) {
			this.intValue = intValue;
		}
		int getIntValue() {
			return this.intValue;
		}
	}
	static class PathBean {
		private final String name;
		private final Path path;
		PathBean(String name, @DefaultValue('default_value') Path path) {
			this.name = name;
			this.path = path;
		}
		String getName() {
			return this.name;
		}
		Path getPath() {
			return this.path;
		}
	}
	static class NamedConstructorParameter {
		private final String importName;
		NamedConstructorParameter(@Name('import') String importName) {
			this.importName = importName;
		}
		String getImportName() {
			return this.importName;
		}
	}
	record NamedRecordComponent(@Name('import') String importName) {
	}
	static class NonExtractableParameterName {
		private String value;
		private JsonPath jsonPath;
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
		JsonPath getJsonPath() {
			return this.jsonPath;
		}
		void setJsonPath(JsonPath jsonPath) {
			this.jsonPath = jsonPath;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind.test;
/**
class PackagePrivateBeanBindingTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private Binder binder;
	private ConfigurationPropertyName name;
	@BeforeEach
	void setup() {
		this.binder = new Binder(this.sources);
		this.name = ConfigurationPropertyName.of('foo');
	}
	@Test
	void bindToPackagePrivateClassShouldBindToInstance() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', '999');
		this.sources.add(source);
		ExamplePackagePrivateBean bean = this.binder.bind(this.name, Bindable.of(ExamplePackagePrivateBean.class))
			.get();
		assertThat(bean.getBar()).isEqualTo(999);
	}
	static class ExamplePackagePrivateBean {
		private int bar;
		int getBar() {
			return this.bar;
		}
		void setBar(int bar) {
			this.bar = bar;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class BindableTests {
	@Test
	void ofClassWhenTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Bindable.of((Class<?>) null))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void ofTypeWhenTypeIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Bindable.of((ResolvableType) null))
			.withMessageContaining('Type must not be null');
	}
	@Test
	void ofClassShouldSetType() {
		assertThat(Bindable.of(String.class).getType()).isEqualTo(ResolvableType.forClass(String.class));
	}
	@Test
	void ofTypeShouldSetType() {
		ResolvableType type = ResolvableType.forClass(String.class);
		assertThat(Bindable.of(type).getType()).isEqualTo(type);
	}
	@Test
	void ofInstanceShouldSetTypeAndExistingValue() {
		String instance = 'foo';
		ResolvableType type = ResolvableType.forClass(String.class);
		assertThat(Bindable.ofInstance(instance).getType()).isEqualTo(type);
		assertThat(Bindable.ofInstance(instance).getValue().get()).isEqualTo('foo');
	}
	@Test
	void ofClassWithExistingValueShouldSetTypeAndExistingValue() {
		assertThat(Bindable.of(String.class).withExistingValue('foo').getValue().get()).isEqualTo('foo');
	}
	@Test
	void ofTypeWithExistingValueShouldSetTypeAndExistingValue() {
		assertThat(Bindable.of(ResolvableType.forClass(String.class)).withExistingValue('foo').getValue().get())
			.isEqualTo('foo');
	}
	@Test
	void ofTypeWhenExistingValueIsNotInstanceOfTypeShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> Bindable.of(ResolvableType.forClass(String.class)).withExistingValue(123))
			.withMessageContaining('ExistingValue must be an instance of ' + String.class.getName());
	}
	@Test
	void ofTypeWhenPrimitiveWithExistingValueWrapperShouldNotThrowException() {
		Bindable<Integer> bindable = Bindable.<Integer>of(ResolvableType.forClass(int.class)).withExistingValue(123);
		assertThat(bindable.getType().resolve()).isEqualTo(int.class);
		assertThat(bindable.getValue().get()).isEqualTo(123);
	}
	@Test
	void getBoxedTypeWhenNotBoxedShouldReturnType() {
		Bindable<String> bindable = Bindable.of(String.class);
		assertThat(bindable.getBoxedType()).isEqualTo(ResolvableType.forClass(String.class));
	}
	@Test
	void getBoxedTypeWhenPrimitiveShouldReturnBoxedType() {
		Bindable<Integer> bindable = Bindable.of(int.class);
		assertThat(bindable.getType()).isEqualTo(ResolvableType.forClass(int.class));
		assertThat(bindable.getBoxedType()).isEqualTo(ResolvableType.forClass(Integer.class));
	}
	@Test
	void getBoxedTypeWhenPrimitiveArrayShouldReturnBoxedType() {
		Bindable<int[]> bindable = Bindable.of(int[].class);
		assertThat(bindable.getType().getComponentType()).isEqualTo(ResolvableType.forClass(int.class));
		assertThat(bindable.getBoxedType().isArray()).isTrue();
		assertThat(bindable.getBoxedType().getComponentType()).isEqualTo(ResolvableType.forClass(Integer.class));
	}
	@Test
	void getAnnotationsShouldReturnEmptyArray() {
		assertThat(Bindable.of(String.class).getAnnotations()).isEmpty();
	}
	@Test
	void withAnnotationsShouldSetAnnotations() {
		Annotation annotation = mock(Annotation.class);
		assertThat(Bindable.of(String.class).withAnnotations(annotation).getAnnotations()).containsExactly(annotation);
	}
	@Test
	void getAnnotationWhenMatchShouldReturnAnnotation() {
		Test annotation = AnnotationUtils.synthesizeAnnotation(Test.class);
		assertThat(Bindable.of(String.class).withAnnotations(annotation).getAnnotation(Test.class))
			.isSameAs(annotation);
	}
	@Test
	void getAnnotationWhenNoMatchShouldReturnNull() {
		Test annotation = AnnotationUtils.synthesizeAnnotation(Test.class);
		assertThat(Bindable.of(String.class).withAnnotations(annotation).getAnnotation(Bean.class)).isNull();
	}
	@Test
	void toStringShouldShowDetails() {
		Annotation annotation = AnnotationUtils.synthesizeAnnotation(TestAnnotation.class);
		Bindable<String> bindable = Bindable.of(String.class).withExistingValue('foo').withAnnotations(annotation);
		assertThat(bindable.toString())
			.contains('type = java.lang.String, value = "provided", annotations = array<Annotation>['
					+ '@org.springframework.boot.context.properties.bind.BindableTests.TestAnnotation()]');
	}
	@Test
	void equalsAndHashCode() {
		Annotation annotation = AnnotationUtils.synthesizeAnnotation(TestAnnotation.class);
		Bindable<String> bindable1 = Bindable.of(String.class).withExistingValue('foo').withAnnotations(annotation);
		Bindable<String> bindable2 = Bindable.of(String.class).withExistingValue('foo').withAnnotations(annotation);
		Bindable<String> bindable3 = Bindable.of(String.class).withExistingValue('fof').withAnnotations(annotation);
		assertThat(bindable1).hasSameHashCodeAs(bindable2);
		assertThat(bindable1).isEqualTo(bindable1).isEqualTo(bindable2);
		assertThat(bindable1).isEqualTo(bindable3);
	}
	@Test // gh-18218
	void withExistingValueDoesNotForgetAnnotations() {
		Annotation annotation = AnnotationUtils.synthesizeAnnotation(TestAnnotation.class);
		Bindable<?> bindable = Bindable.of(String.class).withAnnotations(annotation).withExistingValue('');
		assertThat(bindable.getAnnotations()).containsExactly(annotation);
	}
	@Test // gh-18218
	void withSuppliedValueDoesNotForgetAnnotations() {
		Annotation annotation = AnnotationUtils.synthesizeAnnotation(TestAnnotation.class);
		Bindable<?> bindable = Bindable.of(String.class).withAnnotations(annotation).withSuppliedValue(() -> '');
		assertThat(bindable.getAnnotations()).containsExactly(annotation);
	}
	@Test
	void hasBindRestrictionWhenDefaultReturnsFalse() {
		Bindable<String> bindable = Bindable.of(String.class);
		for (BindRestriction bindRestriction : BindRestriction.values()) {
			assertThat(bindable.hasBindRestriction(bindRestriction)).isFalse();
		}
	}
	@Test
	void withBindRestrictionAddsBindRestriction() {
		Bindable<String> bindable = Bindable.of(String.class);
		Bindable<String> restricted = bindable.withBindRestrictions(BindRestriction.NO_DIRECT_PROPERTY);
		assertThat(bindable.hasBindRestriction(BindRestriction.NO_DIRECT_PROPERTY)).isFalse();
		assertThat(restricted.hasBindRestriction(BindRestriction.NO_DIRECT_PROPERTY)).isTrue();
	}
	@Test
	void whenTypeCouldUseJavaBeanOrValueObjectJavaBeanBindingCanBeSpecified() {
		BindMethod bindMethod = Bindable.of(JavaBeanOrValueObject.class)
			.withBindMethod(BindMethod.JAVA_BEAN)
			.getBindMethod();
		assertThat(bindMethod).isEqualTo(BindMethod.JAVA_BEAN);
	}
	@Test
	void whenTypeCouldUseJavaBeanOrValueObjectExistingValueForcesJavaBeanBinding() {
		BindMethod bindMethod = Bindable.of(JavaBeanOrValueObject.class)
			.withExistingValue(new JavaBeanOrValueObject('value'))
			.getBindMethod();
		assertThat(bindMethod).isEqualTo(BindMethod.JAVA_BEAN);
	}
	@Test
	void whenBindingIsValueObjectExistingValueThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> Bindable.of(JavaBeanOrValueObject.class)
			.withBindMethod(BindMethod.VALUE_OBJECT)
			.withExistingValue(new JavaBeanOrValueObject('value')));
	}
	@Test
	void whenBindableHasExistingValueValueObjectBindMethodThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> Bindable.of(JavaBeanOrValueObject.class)
			.withExistingValue(new JavaBeanOrValueObject('value'))
			.withBindMethod(BindMethod.VALUE_OBJECT));
	}
	@Test
	void whenBindableHasSuppliedValueValueObjectBindMethodThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> Bindable.of(JavaBeanOrValueObject.class)
			.withSuppliedValue(() -> new JavaBeanOrValueObject('value'))
			.withBindMethod(BindMethod.VALUE_OBJECT));
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface TestAnnotation {
	}
	static class JavaBeanOrValueObject {
		private String property;
		JavaBeanOrValueObject(String property) {
			this.property = property;
		}
		String getProperty() {
			return this.property;
		}
		void setProperty(String property) {
			this.property = property;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class DataObjectPropertyNameTests {
	@Test
	void toDashedCaseConvertsValue() {
		assertThat(DataObjectPropertyName.toDashedForm('Foo')).isEqualTo('foo');
		assertThat(DataObjectPropertyName.toDashedForm('foo')).isEqualTo('foo');
		assertThat(DataObjectPropertyName.toDashedForm('fooBar')).isEqualTo('foo-bar');
		assertThat(DataObjectPropertyName.toDashedForm('foo_bar')).isEqualTo('foo-bar');
		assertThat(DataObjectPropertyName.toDashedForm('_foo_bar')).isEqualTo('-foo-bar');
		assertThat(DataObjectPropertyName.toDashedForm('foo_Bar')).isEqualTo('foo-bar');
	}
	@Test
	void toDashedFormWhenContainsIndexedAddsNoDashToIndex() {
		assertThat(DataObjectPropertyName.toDashedForm('test[fooBar]')).isEqualTo('test[fooBar]');
		assertThat(DataObjectPropertyName.toDashedForm('testAgain[fooBar]')).isEqualTo('test-again[fooBar]');
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class JavaBeanBinderTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private final Binder binder = new Binder(this.sources);
	@Test
	void bindToClassShouldCreateBoundBean() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		source.put('foo.long-value', '34');
		source.put('foo.string-value', 'foo');
		source.put('foo.enum-value', 'foo-bar');
		this.sources.add(source);
		ExampleValueBean bean = this.binder.bind('foo', Bindable.of(ExampleValueBean.class)).get();
		assertThat(bean.getIntValue()).isEqualTo(12);
		assertThat(bean.getLongValue()).isEqualTo(34);
		assertThat(bean.getStringValue()).isEqualTo('foo');
		assertThat(bean.getEnumValue()).isEqualTo(ExampleEnum.FOO_BAR);
	}
	@Test
	void bindRenamedPropertyToClassBean() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('renamed.public', 'alpha');
		this.sources.add(source);
		ExampleRenamedPropertyBean bean = this.binder.bind('renamed', Bindable.of(ExampleRenamedPropertyBean.class))
			.get();
		assertThat(bean.getExampleProperty()).isEqualTo('alpha');
	}
	@Test
	void bindToClassWhenHasNoPrefixShouldCreateBoundBean() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('int-value', '12');
		source.put('long-value', '34');
		source.put('string-value', 'foo');
		source.put('enum-value', 'foo-bar');
		this.sources.add(source);
		ExampleValueBean bean = this.binder.bind(ConfigurationPropertyName.of(''), Bindable.of(ExampleValueBean.class))
			.get();
		assertThat(bean.getIntValue()).isEqualTo(12);
		assertThat(bean.getLongValue()).isEqualTo(34);
		assertThat(bean.getStringValue()).isEqualTo('foo');
		assertThat(bean.getEnumValue()).isEqualTo(ExampleEnum.FOO_BAR);
	}
	@Test
	void bindToInstanceShouldBindToInstance() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		source.put('foo.long-value', '34');
		source.put('foo.string-value', 'foo');
		source.put('foo.enum-value', 'foo-bar');
		this.sources.add(source);
		ExampleValueBean bean = new ExampleValueBean();
		ExampleValueBean boundBean = this.binder
			.bind('foo', Bindable.of(ExampleValueBean.class).withExistingValue(bean))
			.get();
		assertThat(boundBean).isSameAs(bean);
		assertThat(bean.getIntValue()).isEqualTo(12);
		assertThat(bean.getLongValue()).isEqualTo(34);
		assertThat(bean.getStringValue()).isEqualTo('foo');
		assertThat(bean.getEnumValue()).isEqualTo(ExampleEnum.FOO_BAR);
	}
	@Test
	void bindToInstanceWithNoPropertiesShouldReturnUnbound() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		this.sources.add(source);
		ExampleDefaultsBean bean = new ExampleDefaultsBean();
		BindResult<ExampleDefaultsBean> boundBean = this.binder.bind('foo',
				Bindable.of(ExampleDefaultsBean.class).withExistingValue(bean));
		assertThat(boundBean.isBound()).isFalse();
		assertThat(bean.getFoo()).isEqualTo(123);
		assertThat(bean.getBar()).isEqualTo(456);
	}
	@Test
	void bindToClassShouldLeaveDefaults() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', '999');
		this.sources.add(source);
		ExampleDefaultsBean bean = this.binder.bind('foo', Bindable.of(ExampleDefaultsBean.class)).get();
		assertThat(bean.getFoo()).isEqualTo(123);
		assertThat(bean.getBar()).isEqualTo(999);
	}
	@Test
	void bindToExistingInstanceShouldLeaveDefaults() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', '999');
		this.sources.add(source);
		ExampleDefaultsBean bean = new ExampleDefaultsBean();
		bean.setFoo(888);
		ExampleDefaultsBean boundBean = this.binder
			.bind('foo', Bindable.of(ExampleDefaultsBean.class).withExistingValue(bean))
			.get();
		assertThat(boundBean).isSameAs(bean);
		assertThat(bean.getFoo()).isEqualTo(888);
		assertThat(bean.getBar()).isEqualTo(999);
	}
	@Test
	void bindToClassShouldBindToMap() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.map.foo-bar', '1');
		source.put('foo.map.bar-baz', '2');
		this.sources.add(source);
		ExampleMapBean bean = this.binder.bind('foo', Bindable.of(ExampleMapBean.class)).get();
		assertThat(bean.getMap()).containsExactly(entry(ExampleEnum.FOO_BAR, 1), entry(ExampleEnum.BAR_BAZ, 2));
	}
	@Test
	void bindToClassShouldBindToList() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.list[0]', 'foo-bar');
		source.put('foo.list[1]', 'bar-baz');
		this.sources.add(source);
		ExampleListBean bean = this.binder.bind('foo', Bindable.of(ExampleListBean.class)).get();
		assertThat(bean.getList()).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	@Test
	void bindToListIfUnboundElementsPresentShouldThrowException() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.list[0]', 'foo-bar');
		source.put('foo.list[2]', 'bar-baz');
		this.sources.add(source);
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleListBean.class)))
			.withCauseInstanceOf(UnboundConfigurationPropertiesException.class);
	}
	@Test
	void bindToClassShouldBindToSet() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.set[0]', 'foo-bar');
		source.put('foo.set[1]', 'bar-baz');
		this.sources.add(source);
		ExampleSetBean bean = this.binder.bind('foo', Bindable.of(ExampleSetBean.class)).get();
		assertThat(bean.getSet()).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	@Test
	void bindToClassShouldBindToCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.collection[0]', 'foo-bar');
		source.put('foo.collection[1]', 'bar-baz');
		this.sources.add(source);
		ExampleCollectionBean bean = this.binder.bind('foo', Bindable.of(ExampleCollectionBean.class)).get();
		assertThat(bean.getCollection()).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	@Test
	void bindToClassShouldBindToCollectionWithDelimiter() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.collection', 'foo-bar|bar-baz');
		this.sources.add(source);
		ExampleCollectionBeanWithDelimiter bean = this.binder
			.bind('foo', Bindable.of(ExampleCollectionBeanWithDelimiter.class))
			.get();
		assertThat(bean.getCollection()).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	@Test
	void bindToClassWhenHasNoSetterShouldBindToMap() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.map.foo-bar', '1');
		source.put('foo.map.bar-baz', '2');
		this.sources.add(source);
		ExampleMapBeanWithoutSetter bean = this.binder.bind('foo', Bindable.of(ExampleMapBeanWithoutSetter.class))
			.get();
		assertThat(bean.getMap()).containsExactly(entry(ExampleEnum.FOO_BAR, 1), entry(ExampleEnum.BAR_BAZ, 2));
	}
	@Test
	void bindToClassWhenHasNoSetterShouldBindToList() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.list[0]', 'foo-bar');
		source.put('foo.list[1]', 'bar-baz');
		this.sources.add(source);
		ExampleListBeanWithoutSetter bean = this.binder.bind('foo', Bindable.of(ExampleListBeanWithoutSetter.class))
			.get();
		assertThat(bean.getList()).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	@Test
	void bindToClassWhenHasNoSetterShouldBindToSet() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.set[0]', 'foo-bar');
		source.put('foo.set[1]', 'bar-baz');
		this.sources.add(source);
		ExampleSetBeanWithoutSetter bean = this.binder.bind('foo', Bindable.of(ExampleSetBeanWithoutSetter.class))
			.get();
		assertThat(bean.getSet()).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	@Test
	void bindToClassWhenHasNoSetterShouldBindToCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.collection[0]', 'foo-bar');
		source.put('foo.collection[1]', 'bar-baz');
		this.sources.add(source);
		ExampleCollectionBeanWithoutSetter bean = this.binder
			.bind('foo', Bindable.of(ExampleCollectionBeanWithoutSetter.class))
			.get();
		assertThat(bean.getCollection()).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	@Test
	void bindToClassShouldBindNested() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value-bean.int-value', '123');
		source.put('foo.value-bean.string-value', 'foo');
		this.sources.add(source);
		ExampleNestedBean bean = this.binder.bind('foo', Bindable.of(ExampleNestedBean.class)).get();
		assertThat(bean.getValueBean().getIntValue()).isEqualTo(123);
		assertThat(bean.getValueBean().getStringValue()).isEqualTo('foo');
	}
	@Test
	void bindToClassWhenIterableShouldBindNestedBasedOnInstance() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value-bean.int-value', '123');
		source.put('foo.value-bean.string-value', 'foo');
		this.sources.add(source);
		ExampleNestedBeanWithoutSetterOrType bean = this.binder
			.bind('foo', Bindable.of(ExampleNestedBeanWithoutSetterOrType.class))
			.get();
		ExampleValueBean valueBean = (ExampleValueBean) bean.getValueBean();
		assertThat(valueBean.getIntValue()).isEqualTo(123);
		assertThat(valueBean.getStringValue()).isEqualTo('foo');
	}
	@Test
	void bindToClassWhenNotIterableShouldNotBindNestedBasedOnInstance() {
		// If we can"t tell that binding will happen, we don"t want to randomly invoke
		// getters on the class and cause side effects
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value-bean.int-value', '123');
		source.put('foo.value-bean.string-value', 'foo');
		this.sources.add(source.nonIterable());
		BindResult<ExampleNestedBeanWithoutSetterOrType> bean = this.binder.bind('foo',
				Bindable.of(ExampleNestedBeanWithoutSetterOrType.class));
		assertThat(bean.isBound()).isFalse();
	}
	@Test
	void bindToClassWhenHasNoSetterShouldBindNested() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value-bean.int-value', '123');
		source.put('foo.value-bean.string-value', 'foo');
		this.sources.add(source);
		ExampleNestedBeanWithoutSetter bean = this.binder.bind('foo', Bindable.of(ExampleNestedBeanWithoutSetter.class))
			.get();
		assertThat(bean.getValueBean().getIntValue()).isEqualTo(123);
		assertThat(bean.getValueBean().getStringValue()).isEqualTo('foo');
	}
	@Test
	void bindToClassWhenHasNoSetterAndImmutableShouldThrowException() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.nested.foo', 'bar');
		this.sources.add(source);
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleImmutableNestedBeanWithoutSetter.class)));
	}
	@Test
	void bindToInstanceWhenNoNestedShouldLeaveNestedAsNull() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('faf.value-bean.int-value', '123');
		this.sources.add(source);
		ExampleNestedBean bean = new ExampleNestedBean();
		BindResult<ExampleNestedBean> boundBean = this.binder.bind('foo',
				Bindable.of(ExampleNestedBean.class).withExistingValue(bean));
		assertThat(boundBean.isBound()).isFalse();
		assertThat(bean.getValueBean()).isNull();
	}
	@Test
	void bindToClassWithOverriddenPropertyShouldSetSubclassProperty() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value-bean.int-value', '123');
		source.put('foo.value-bean.sub-int-value', '456');
		this.sources.add(source);
		ExampleNestedSubclassBean bean = this.binder.bind('foo', Bindable.of(ExampleNestedSubclassBean.class)).get();
		assertThat(bean.getValueBean()).isNotNull();
		assertThat(bean.getValueBean().getIntValue()).isEqualTo(123);
		assertThat(bean.getValueBean().getSubIntValue()).isEqualTo(456);
	}
	@Test
	void bindToClassWhenPropertiesMissingShouldReturnUnbound() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('faf.int-value', '12');
		this.sources.add(source);
		BindResult<ExampleValueBean> bean = this.binder.bind('foo', Bindable.of(ExampleValueBean.class));
		assertThat(bean.isBound()).isFalse();
	}
	@Test
	void bindToClassWhenNoDefaultConstructorShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', 'bar');
		this.sources.add(source);
		BindResult<ExampleWithNonDefaultConstructor> bean = this.binder.bind('foo',
				Bindable.of(ExampleWithNonDefaultConstructor.class));
		assertThat(bean.isBound()).isTrue();
		ExampleWithNonDefaultConstructor boundBean = bean.get();
		assertThat(boundBean.getValue()).isEqualTo('bar');
	}
	@Test
	void bindToInstanceWhenNoDefaultConstructorShouldBind() {
		Binder binder = new Binder(this.sources, null, (ConversionService) null, null, null,
				(bindable, isNestedConstructorBinding) -> null);
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', 'bar');
		this.sources.add(source);
		ExampleWithNonDefaultConstructor bean = new ExampleWithNonDefaultConstructor('faf');
		ExampleWithNonDefaultConstructor boundBean = binder
			.bind('foo', Bindable.of(ExampleWithNonDefaultConstructor.class).withExistingValue(bean))
			.get();
		assertThat(boundBean).isSameAs(bean);
		assertThat(bean.getValue()).isEqualTo('bar');
	}
	@Test
	void bindToClassShouldBindHierarchy() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '123');
		source.put('foo.long-value', '456');
		this.sources.add(source);
		ExampleSubclassBean bean = this.binder.bind('foo', Bindable.of(ExampleSubclassBean.class)).get();
		assertThat(bean.getIntValue()).isEqualTo(123);
		assertThat(bean.getLongValue()).isEqualTo(456);
	}
	@Test
	void bindToClassWhenPropertyCannotBeConvertedShouldThrowException() {
		this.sources.add(new MockConfigurationPropertySource('foo.int-value', 'foo'));
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(ExampleValueBean.class)));
	}
	@Test
	void bindToClassWhenPropertyCannotBeConvertedAndIgnoreErrorsShouldNotSetValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.int-value', '12');
		source.put('foo.long-value', 'bang');
		source.put('foo.string-value', 'foo');
		source.put('foo.enum-value', 'foo-bar');
		this.sources.add(source);
		IgnoreErrorsBindHandler handler = new IgnoreErrorsBindHandler();
		ExampleValueBean bean = this.binder.bind('foo', Bindable.of(ExampleValueBean.class), handler).get();
		assertThat(bean.getIntValue()).isEqualTo(12);
		assertThat(bean.getLongValue()).isZero();
		assertThat(bean.getStringValue()).isEqualTo('foo');
		assertThat(bean.getEnumValue()).isEqualTo(ExampleEnum.FOO_BAR);
	}
	@Test
	void bindToClassWhenMismatchedGetSetShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', '123');
		this.sources.add(source);
		ExampleMismatchBean bean = this.binder.bind('foo', Bindable.of(ExampleMismatchBean.class)).get();
		assertThat(bean.getValue()).isEqualTo('123');
	}
	@Test
	void bindToClassShouldNotInvokeExtraMethods() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource('foo.value', '123');
		this.sources.add(source.nonIterable());
		ExampleWithThrowingGetters bean = this.binder.bind('foo', Bindable.of(ExampleWithThrowingGetters.class)).get();
		assertThat(bean.getValue()).isEqualTo(123);
	}
	@Test
	void bindToClassWithSelfReferenceShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', '123');
		this.sources.add(source);
		ExampleWithSelfReference bean = this.binder.bind('foo', Bindable.of(ExampleWithSelfReference.class)).get();
		assertThat(bean.getValue()).isEqualTo(123);
	}
	@Test
	void bindToInstanceWithExistingValueShouldReturnUnbound() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		this.sources.add(source);
		ExampleNestedBean existingValue = new ExampleNestedBean();
		ExampleValueBean valueBean = new ExampleValueBean();
		existingValue.setValueBean(valueBean);
		BindResult<ExampleNestedBean> result = this.binder.bind('foo',
				Bindable.of(ExampleNestedBean.class).withExistingValue(existingValue));
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindWithAnnotations() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.date', '2014-04-01');
		this.sources.add(source);
		ConverterAnnotatedExampleBean bean = this.binder.bind('foo', Bindable.of(ConverterAnnotatedExampleBean.class))
			.get();
		assertThat(bean.getDate()).hasToString('2014-04-01');
	}
	@Test
	void bindWhenValueIsConvertedWithPropertyEditorShouldBind() {
		// gh-12166
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', 'java.lang.RuntimeException');
		this.sources.add(source);
		ExampleWithPropertyEditorType bean = this.binder.bind('foo', Bindable.of(ExampleWithPropertyEditorType.class))
			.get();
		assertThat(bean.getValue()).isEqualTo(RuntimeException.class);
	}
	@Test
	void bindToClassShouldIgnoreInvalidAccessors() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.name', 'something');
		this.sources.add(source);
		ExampleWithInvalidAccessors bean = this.binder.bind('foo', Bindable.of(ExampleWithInvalidAccessors.class))
			.get();
		assertThat(bean.getName()).isEqualTo('something');
	}
	@Test
	void bindToClassShouldIgnoreStaticAccessors() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.name', 'invalid');
		source.put('foo.counter', '42');
		this.sources.add(source);
		ExampleWithStaticAccessors bean = this.binder.bind('foo', Bindable.of(ExampleWithStaticAccessors.class)).get();
		assertThat(ExampleWithStaticAccessors.name).isNull();
		assertThat(bean.getCounter()).isEqualTo(42);
	}
	@Test
	void bindToClassShouldCacheWithGenerics() {
		// gh-16821
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.integers[a].value', '1');
		source.put('foo.booleans[b].value', 'true');
		this.sources.add(source);
		ExampleWithGenericMap bean = this.binder.bind('foo', Bindable.of(ExampleWithGenericMap.class)).get();
		assertThat(bean.getIntegers().get('a').getValue()).isOne();
		assertThat(bean.getBooleans().get('b').getValue()).isTrue();
	}
	@Test
	void bindToClassWithOverloadedSetterShouldUseSetterThatMatchesField() {
		// gh-16206
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.property', 'some string');
		this.sources.add(source);
		PropertyWithOverloadedSetter bean = this.binder.bind('foo', Bindable.of(PropertyWithOverloadedSetter.class))
			.get();
		assertThat(bean.getProperty()).isEqualTo('some string');
	}
	@Test
	void beanPropertiesPreferMatchingType() {
		// gh-16206
		ResolvableType type = ResolvableType.forClass(PropertyWithOverloadedSetter.class);
		Bean<PropertyWithOverloadedSetter> bean = new Bean<>(type, type.resolve()) {
			@Override
			protected void addProperties(Method[] declaredMethods, Field[] declaredFields) {
				// We override here because we need a specific order of the declared
				// methods and the JVM doesn"t give us one
				int intSetter = -1;
				int stringSetter = -1;
				for (int i = 0; i < declaredMethods.length; i++) {
					Method method = declaredMethods[i];
					if (method.getName().equals('setProperty')) {
						if (method.getParameters()[0].getType().equals(int.class)) {
							intSetter = i;
						}
						else {
							stringSetter = i;
						}
					}
				}
				if (intSetter > stringSetter) {
					Method method = declaredMethods[intSetter];
					declaredMethods[intSetter] = declaredMethods[stringSetter];
					declaredMethods[stringSetter] = method;
				}
				super.addProperties(declaredMethods, declaredFields);
			}
		};
		BeanProperty property = bean.getProperties().get('property');
		PropertyWithOverloadedSetter target = new PropertyWithOverloadedSetter();
		property.setValue(() -> target, 'some string');
	}
	@Test
	void bindOrCreateWithNestedShouldReturnCreatedValue() {
		NestedJavaBean result = this.binder.bindOrCreate('foo', Bindable.of(NestedJavaBean.class));
		assertThat(result.getNested().getBar()).isEqualTo(456);
	}
	@Test
	void bindWhenHasPackagePrivateSetterShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.property', 'test');
		this.sources.add(source);
		PackagePrivateSetterBean bean = this.binder.bind('foo', Bindable.of(PackagePrivateSetterBean.class)).get();
		assertThat(bean.getProperty()).isEqualTo('test');
	}
	@Test
	void bindUsesConsistentPropertyOrder() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.gamma', '0');
		source.put('foo.alpha', '0');
		source.put('foo.beta', '0');
		this.sources.add(source);
		PropertyOrderBean bean = this.binder.bind('foo', Bindable.of(PropertyOrderBean.class)).get();
		assertThat(bean.getAlpha()).isZero();
		assertThat(bean.getBeta()).isOne();
		assertThat(bean.getGamma()).isEqualTo(2);
	}
	@Test // gh-23007
	void bindWhenBeanWithGetSetIsMethodsFoundUsesGetterThatMatchesSetter() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.names', 'spring,boot');
		this.sources.add(source);
		JavaBeanWithGetSetIs bean = this.binder.bind('test', Bindable.of(JavaBeanWithGetSetIs.class)).get();
		assertThat(bean.getNames()).containsExactly('spring', 'boot');
	}
	@Test // gh-23007
	void bindWhenBeanWithGetIsMethodsFoundDoesNotUseIsGetter() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.names', 'spring,boot');
		this.sources.add(source);
		JavaBeanWithGetIs bean = this.binder.bind('test', Bindable.of(JavaBeanWithGetIs.class)).get();
		assertThat(bean.getNames()).containsExactly('spring', 'boot');
	}
	@Test // gh-33105
	void bindWhenHasBridgeMethods() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('test.value', 'spring-boot');
		this.sources.add(source);
		ApplicationConversionService conversionService = new ApplicationConversionService();
		conversionService.addConverter(String.class, BridgeType.class, BridgeType::new);
		Binder binder = new Binder(this.sources, null, conversionService);
		BridgeMethods bean = binder.bind('test', Bindable.of(BridgeMethods.class)).get();
		assertThat(bean.getValue()).hasToString('spring-boot');
	}
	static class ExampleValueBean {
		private int intValue;
		private long longValue;
		private String stringValue;
		private ExampleEnum enumValue;
		int getIntValue() {
			return this.intValue;
		}
		void setIntValue(int intValue) {
			this.intValue = intValue;
		}
		long getLongValue() {
			return this.longValue;
		}
		void setLongValue(long longValue) {
			this.longValue = longValue;
		}
		String getStringValue() {
			return this.stringValue;
		}
		void setStringValue(String stringValue) {
			this.stringValue = stringValue;
		}
		ExampleEnum getEnumValue() {
			return this.enumValue;
		}
		void setEnumValue(ExampleEnum enumValue) {
			this.enumValue = enumValue;
		}
	}
	static class ExampleRenamedPropertyBean {
		@Name('public')
		private String exampleProperty;
		String getExampleProperty() {
			return this.exampleProperty;
		}
		void setExampleProperty(String exampleProperty) {
			this.exampleProperty = exampleProperty;
		}
	}
	static class ExampleDefaultsBean {
		private int foo = 123;
		private int bar = 456;
		int getFoo() {
			return this.foo;
		}
		void setFoo(int foo) {
			this.foo = foo;
		}
		int getBar() {
			return this.bar;
		}
		void setBar(int bar) {
			this.bar = bar;
		}
	}
	static class ExampleMapBean {
		private Map<ExampleEnum, Integer> map;
		Map<ExampleEnum, Integer> getMap() {
			return this.map;
		}
		void setMap(Map<ExampleEnum, Integer> map) {
			this.map = map;
		}
	}
	static class ExampleListBean {
		private List<ExampleEnum> list;
		List<ExampleEnum> getList() {
			return this.list;
		}
		void setList(List<ExampleEnum> list) {
			this.list = list;
		}
	}
	static class ExampleSetBean {
		private Set<ExampleEnum> set;
		Set<ExampleEnum> getSet() {
			return this.set;
		}
		void setSet(Set<ExampleEnum> set) {
			this.set = set;
		}
	}
	static class ExampleCollectionBean {
		private Collection<ExampleEnum> collection;
		Collection<ExampleEnum> getCollection() {
			return this.collection;
		}
		void setCollection(Collection<ExampleEnum> collection) {
			this.collection = collection;
		}
	}
	static class ExampleMapBeanWithoutSetter {
		private final Map<ExampleEnum, Integer> map = new LinkedHashMap<>();
		Map<ExampleEnum, Integer> getMap() {
			return this.map;
		}
	}
	static class ExampleListBeanWithoutSetter {
		private final List<ExampleEnum> list = new ArrayList<>();
		List<ExampleEnum> getList() {
			return this.list;
		}
	}
	static class ExampleSetBeanWithoutSetter {
		private final Set<ExampleEnum> set = new LinkedHashSet<>();
		Set<ExampleEnum> getSet() {
			return this.set;
		}
	}
	static class ExampleCollectionBeanWithoutSetter {
		private final Collection<ExampleEnum> collection = new ArrayList<>();
		Collection<ExampleEnum> getCollection() {
			return this.collection;
		}
	}
	static class ExampleCollectionBeanWithDelimiter {
		@Delimiter('|')
		private Collection<ExampleEnum> collection;
		Collection<ExampleEnum> getCollection() {
			return this.collection;
		}
		void setCollection(Collection<ExampleEnum> collection) {
			this.collection = collection;
		}
	}
	static class ExampleNestedBean {
		private ExampleValueBean valueBean;
		ExampleValueBean getValueBean() {
			return this.valueBean;
		}
		void setValueBean(ExampleValueBean valueBean) {
			this.valueBean = valueBean;
		}
	}
	static class ExampleNestedBeanWithoutSetter {
		private final ExampleValueBean valueBean = new ExampleValueBean();
		ExampleValueBean getValueBean() {
			return this.valueBean;
		}
	}
	static class ExampleNestedBeanWithoutSetterOrType {
		private final ExampleValueBean valueBean = new ExampleValueBean();
		Object getValueBean() {
			return this.valueBean;
		}
	}
	static class ExampleImmutableNestedBeanWithoutSetter {
		private final NestedImmutable nested = new NestedImmutable();
		NestedImmutable getNested() {
			return this.nested;
		}
		static class NestedImmutable {
			String getFoo() {
				return 'foo';
			}
		}
	}
	static class ExampleNestedSubclassBean extends ExampleNestedBean {
		private ExampleValueSubclassBean valueBean;
		@Override
		ExampleValueSubclassBean getValueBean() {
			return this.valueBean;
		}
		void setValueBean(ExampleValueSubclassBean valueBean) {
			this.valueBean = valueBean;
		}
		static class ExampleValueSubclassBean extends ExampleValueBean {
			private int subIntValue;
			int getSubIntValue() {
				return this.subIntValue;
			}
			void setSubIntValue(int intValue) {
				this.subIntValue = intValue;
			}
		}
	}
	static class ExampleWithNonDefaultConstructor {
		private String value;
		ExampleWithNonDefaultConstructor(String value) {
			this.value = value;
		}
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
	}
	static class ExampleSuperClassBean {
		private int intValue;
		int getIntValue() {
			return this.intValue;
		}
		void setIntValue(int intValue) {
			this.intValue = intValue;
		}
	}
	static class ExampleSubclassBean extends ExampleSuperClassBean {
		private long longValue;
		long getLongValue() {
			return this.longValue;
		}
		void setLongValue(long longValue) {
			this.longValue = longValue;
		}
	}
	static class ExampleMismatchBean {
		private int value;
		String getValue() {
			return String.valueOf(this.value);
		}
		void setValue(int value) {
			this.value = value;
		}
	}
	static class ExampleWithThrowingGetters {
		private int value;
		int getValue() {
			return this.value;
		}
		void setValue(int value) {
			this.value = value;
		}
		List<String> getNames() {
			throw new RuntimeException();
		}
		ExampleValueBean getNested() {
			throw new RuntimeException();
		}
	}
	static class ExampleWithSelfReference {
		private int value;
		private ExampleWithSelfReference self;
		int getValue() {
			return this.value;
		}
		void setValue(int value) {
			this.value = value;
		}
		ExampleWithSelfReference getSelf() {
			return this.self;
		}
		void setSelf(ExampleWithSelfReference self) {
			this.self = self;
		}
	}
	static class ExampleWithInvalidAccessors {
		private String name;
		String getName() {
			return this.name;
		}
		void setName(String name) {
			this.name = name;
		}
		String get() {
			throw new IllegalArgumentException('should not be invoked');
		}
		boolean is() {
			throw new IllegalArgumentException('should not be invoked');
		}
	}
	static class ExampleWithStaticAccessors {
		private static String name;
		private int counter;
		static String getName() {
			return name;
		}
		static void setName(String name) {
			ExampleWithStaticAccessors.name = name;
		}
		int getCounter() {
			return this.counter;
		}
		void setCounter(int counter) {
			this.counter = counter;
		}
	}
	public enum ExampleEnum {
		FOO_BAR,
		BAR_BAZ
	}
	static class ConverterAnnotatedExampleBean {
		@DateTimeFormat(iso = DateTimeFormat.ISO.DATE)
		private LocalDate date;
		LocalDate getDate() {
			return this.date;
		}
		void setDate(LocalDate date) {
			this.date = date;
		}
	}
	static class ExampleWithPropertyEditorType {
		private Class<? extends Throwable> value;
		Class<? extends Throwable> getValue() {
			return this.value;
		}
		void setValue(Class<? extends Throwable> value) {
			this.value = value;
		}
	}
	static class ExampleWithGenericMap {
		private final Map<String, GenericValue<Integer>> integers = new LinkedHashMap<>();
		private final Map<String, GenericValue<Boolean>> booleans = new LinkedHashMap<>();
		Map<String, GenericValue<Integer>> getIntegers() {
			return this.integers;
		}
		Map<String, GenericValue<Boolean>> getBooleans() {
			return this.booleans;
		}
	}
	static class GenericValue<T> {
		private T value;
		T getValue() {
			return this.value;
		}
		void setValue(T value) {
			this.value = value;
		}
	}
	static class PropertyWithOverloadedSetter {
		private String property;
		void setProperty(int property) {
			this.property = String.valueOf(property);
		}
		void setProperty(String property) {
			this.property = property;
		}
		String getProperty() {
			return this.property;
		}
	}
	static class NestedJavaBean {
		private ExampleDefaultsBean nested = new ExampleDefaultsBean();
		ExampleDefaultsBean getNested() {
			return this.nested;
		}
		void setNested(ExampleDefaultsBean nested) {
			this.nested = nested;
		}
	}
	static class PackagePrivateSetterBean {
		private String property;
		String getProperty() {
			return this.property;
		}
		void setProperty(String property) {
			this.property = property;
		}
	}
	static class JavaBeanWithGetSetIs {
		private List<String> names = new ArrayList<>();
		List<String> getNames() {
			return this.names;
		}
		void setNames(List<String> names) {
			this.names = names;
		}
		boolean isNames() {
			return !this.names.isEmpty();
		}
	}
	static class JavaBeanWithGetIs {
		private final List<String> names = new ArrayList<>();
		boolean isNames() {
			return !this.names.isEmpty();
		}
		List<String> getNames() {
			return this.names;
		}
	}
	static class PropertyOrderBean {
		static AtomicInteger atomic = new AtomicInteger();
		private int alpha;
		private int beta;
		private int gamma;
		int getAlpha() {
			return this.alpha;
		}
		void setAlpha(int alpha) {
			this.alpha = alpha + atomic.getAndIncrement();
		}
		int getBeta() {
			return this.beta;
		}
		void setBeta(int beta) {
			this.beta = beta + atomic.getAndIncrement();
		}
		int getGamma() {
			return this.gamma;
		}
		void setGamma(int gamma) {
			this.gamma = gamma + atomic.getAndIncrement();
		}
	}
	static class BridgeMethodsBase<T extends BridgeBaseType> {
		private T value;
		T getValue() {
			return this.value;
		}
		void setValue(T value) {
			this.value = value;
		}
	}
	static class BridgeMethods extends BridgeMethodsBase<BridgeType> {
		@Override
		BridgeType getValue() {
			return super.getValue();
		}
	}
	static class BridgeBaseType {
	}
	static class BridgeType extends BridgeBaseType {
		private final String value;
		BridgeType(String value) {
			this.value = value;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind.handler;
/**
class NoUnboundElementsBindHandlerTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private Binder binder;
	@Test
	void bindWhenNotUsingNoUnboundElementsHandlerShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo', 'bar');
		source.put('example.baz', 'bar');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
		Example bound = this.binder.bind(ConfigurationPropertyName.of('example'), Bindable.of(Example.class)).get();
		assertThat(bound.getFoo()).isEqualTo('bar');
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo', 'bar');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
		Example bound = this.binder.bind('example', Bindable.of(Example.class), new NoUnboundElementsBindHandler())
			.get();
		assertThat(bound.getFoo()).isEqualTo('bar');
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerThrowException() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo', 'bar');
		source.put('example.baz', 'bar');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(
					() -> this.binder.bind('example', Bindable.of(Example.class), new NoUnboundElementsBindHandler()))
			.satisfies((ex) -> assertThat(ex.getCause().getMessage())
				.contains('The elements [example.baz] were left unbound'));
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerShouldBindIfPrefixDifferent() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo', 'bar');
		source.put('other.baz', 'bar');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
		Example bound = this.binder.bind('example', Bindable.of(Example.class), new NoUnboundElementsBindHandler())
			.get();
		assertThat(bound.getFoo()).isEqualTo('bar');
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerShouldBindIfUnboundSystemProperties() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo', 'bar');
		source.put('example.other', 'baz');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
		NoUnboundElementsBindHandler handler = new NoUnboundElementsBindHandler(BindHandler.DEFAULT,
				((configurationPropertySource) -> false));
		Example bound = this.binder.bind('example', Bindable.of(Example.class), handler).get();
		assertThat(bound.getFoo()).isEqualTo('bar');
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerShouldBindIfUnboundCollectionProperties() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('example.foo[0]', 'bar');
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('example.foo[0]', 'bar');
		source2.put('example.foo[1]', 'baz');
		this.sources.add(source1);
		this.sources.add(source2);
		this.binder = new Binder(this.sources);
		NoUnboundElementsBindHandler handler = new NoUnboundElementsBindHandler();
		ExampleWithList bound = this.binder.bind('example', Bindable.of(ExampleWithList.class), handler).get();
		assertThat(bound.getFoo()).containsExactly('bar');
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerAndUnboundListElementsShouldThrowException() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo[0]', 'bar');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(
					() -> this.binder.bind('example', Bindable.of(Example.class), new NoUnboundElementsBindHandler()))
			.satisfies((ex) -> assertThat(ex.getCause().getMessage())
				.contains('The elements [example.foo[0]] were left unbound'));
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerShouldBindIfUnboundNestedCollectionProperties() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('example.nested[0].string-value', 'bar');
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('example.nested[0].string-value', 'bar');
		source2.put('example.nested[0].int-value', '2');
		source2.put('example.nested[1].string-value', 'baz');
		source2.put('example.nested[1].other-nested.baz', 'baz');
		this.sources.add(source1);
		this.sources.add(source2);
		this.binder = new Binder(this.sources);
		NoUnboundElementsBindHandler handler = new NoUnboundElementsBindHandler();
		ExampleWithNestedList bound = this.binder.bind('example', Bindable.of(ExampleWithNestedList.class), handler)
			.get();
		assertThat(bound.getNested().get(0).getStringValue()).isEqualTo('bar');
	}
	@Test
	void bindWhenUsingNoUnboundElementsHandlerAndUnboundCollectionElementsWithInvalidPropertyShouldThrowException() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('example.nested[0].string-value', 'bar');
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('example.nested[0].string-value', 'bar');
		source2.put('example.nested[1].int-value', '1');
		source2.put('example.nested[1].invalid', 'baz');
		this.sources.add(source1);
		this.sources.add(source2);
		this.binder = new Binder(this.sources);
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('example', Bindable.of(ExampleWithNestedList.class),
					new NoUnboundElementsBindHandler()))
			.satisfies((ex) -> assertThat(ex.getCause().getMessage())
				.contains('The elements [example.nested[1].invalid] were left unbound'));
	}
	static class Example {
		private String foo;
		String getFoo() {
			return this.foo;
		}
		void setFoo(String foo) {
			this.foo = foo;
		}
	}
	static class ExampleWithList {
		private List<String> foo;
		List<String> getFoo() {
			return this.foo;
		}
		void setFoo(List<String> foo) {
			this.foo = foo;
		}
	}
	static class ExampleWithNestedList {
		private List<Nested> nested;
		List<Nested> getNested() {
			return this.nested;
		}
		void setNested(List<Nested> nested) {
			this.nested = nested;
		}
	}
	static class Nested {
		private String stringValue;
		private Integer intValue;
		private OtherNested otherNested;
		String getStringValue() {
			return this.stringValue;
		}
		void setStringValue(String value) {
			this.stringValue = value;
		}
		Integer getIntValue() {
			return this.intValue;
		}
		void setIntValue(Integer intValue) {
			this.intValue = intValue;
		}
		OtherNested getOtherNested() {
			return this.otherNested;
		}
		void setOtherNested(OtherNested otherNested) {
			this.otherNested = otherNested;
		}
	}
	static class OtherNested {
		private String baz;
		String getBaz() {
			return this.baz;
		}
		void setBaz(String baz) {
			this.baz = baz;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind.handler;
/**
class IgnoreTopLevelConverterNotFoundBindHandlerTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private Binder binder;
	@BeforeEach
	void setup() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example', 'bar');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
	}
	@Test
	void bindWhenHandlerNotPresentShouldFail() {
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('example', Bindable.of(Example.class)))
			.withCauseInstanceOf(ConverterNotFoundException.class);
	}
	@Test
	void bindWhenTopLevelContextAndExceptionIgnorableShouldNotFail() {
		this.binder.bind('example', Bindable.of(Example.class), new IgnoreTopLevelConverterNotFoundBindHandler());
	}
	@Test
	void bindWhenExceptionNotIgnorableShouldFail() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo', '1');
		this.sources.add(source);
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('example', Bindable.of(Example.class),
					new IgnoreTopLevelConverterNotFoundBindHandler()))
			.withCauseInstanceOf(IllegalStateException.class);
	}
	@Test
	void bindWhenExceptionInNestedContextShouldFail() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.map', 'hello');
		this.sources.add(source);
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('example', Bindable.of(Example.class),
					new IgnoreTopLevelConverterNotFoundBindHandler()))
			.withCauseInstanceOf(ConverterNotFoundException.class);
	}
	static class Example {
		private int foo;
		private Map<String, String> map;
		int getFoo() {
			return this.foo;
		}
		void setFoo(int foo) {
			throw new IllegalStateException();
		}
		Map<String, String> getMap() {
			return this.map;
		}
		void setMap(Map<String, String> map) {
			this.map = map;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind.handler;
/**
class IgnoreErrorsBindHandlerTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private Binder binder;
	@BeforeEach
	void setup() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('example.foo', 'bar');
		this.sources.add(source);
		this.binder = new Binder(this.sources);
	}
	@Test
	void bindWhenNotIgnoringErrorsShouldFail() {
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('example', Bindable.of(Example.class)));
	}
	@Test
	void bindWhenIgnoringErrorsShouldBind() {
		Example bound = this.binder.bind('example', Bindable.of(Example.class), new IgnoreErrorsBindHandler()).get();
		assertThat(bound.getFoo()).isZero();
	}
	static class Example {
		private int foo;
		int getFoo() {
			return this.foo;
		}
		void setFoo(int foo) {
			this.foo = foo;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class CollectionBinderTests {
	private static final Bindable<List<Integer>> INTEGER_LIST = Bindable.listOf(Integer.class);
	private static final Bindable<List<String>> STRING_LIST = Bindable.listOf(String.class);
	private static final Bindable<Set<String>> STRING_SET = Bindable.setOf(String.class);
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private Binder binder = new Binder(this.sources);
	@Test
	void bindToCollectionShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', '1');
		source.put('foo[1]', '2');
		source.put('foo[2]', '3');
		this.sources.add(source);
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToSetShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', 'a');
		source.put('foo[1]', 'b');
		source.put('foo[2]', 'c');
		this.sources.add(source);
		Set<String> result = this.binder.bind('foo', STRING_SET).get();
		assertThat(result).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToCollectionWhenNestedShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0][0]', '1');
		source.put('foo[0][1]', '2');
		source.put('foo[1][0]', '3');
		source.put('foo[1][1]', '4');
		this.sources.add(source);
		Bindable<List<List<Integer>>> target = Bindable
			.of(ResolvableType.forClassWithGenerics(List.class, INTEGER_LIST.getType()));
		List<List<Integer>> result = this.binder.bind('foo', target).get();
		assertThat(result).hasSize(2);
		assertThat(result.get(0)).containsExactly(1, 2);
		assertThat(result.get(1)).containsExactly(3, 4);
	}
	@Test
	void bindToCollectionWhenNotInOrderShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[1]', '2');
		source.put('foo[0]', '1');
		source.put('foo[2]', '3');
		this.sources.add(source);
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToCollectionWhenNonSequentialShouldThrowException() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', '2');
		source.put('foo[1]', '1');
		source.put('foo[3]', '3');
		this.sources.add(source);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.binder.bind('foo', INTEGER_LIST))
			.satisfies((ex) -> {
				Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex.getCause())
					.getUnboundProperties();
				assertThat(unbound).hasSize(1);
				ConfigurationProperty property = unbound.iterator().next();
				assertThat(property.getName()).hasToString('foo[3]');
				assertThat(property.getValue()).isEqualTo('3');
			});
	}
	@Test
	void bindToNonScalarCollectionWhenNonSequentialShouldThrowException() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0].value', '1');
		source.put('foo[1].value', '2');
		source.put('foo[4].value', '4');
		this.sources.add(source);
		Bindable<List<JavaBean>> target = Bindable.listOf(JavaBean.class);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.binder.bind('foo', target))
			.satisfies((ex) -> {
				Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex.getCause())
					.getUnboundProperties();
				assertThat(unbound).hasSize(1);
				ConfigurationProperty property = unbound.iterator().next();
				assertThat(property.getName()).hasToString('foo[4].value');
				assertThat(property.getValue()).isEqualTo('4');
			});
	}
	@Test
	void bindToCollectionWhenNonIterableShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[1]', '2');
		source.put('foo[0]', '1');
		source.put('foo[2]', '3');
		this.sources.add(source.nonIterable());
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToCollectionWhenMultipleSourceShouldOnlyUseFirst() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('bar', 'baz');
		this.sources.add(source1);
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('foo[0]', '1');
		source2.put('foo[1]', '2');
		this.sources.add(source2);
		MockConfigurationPropertySource source3 = new MockConfigurationPropertySource();
		source3.put('foo[0]', '7');
		source3.put('foo[1]', '8');
		source3.put('foo[2]', '9');
		this.sources.add(source3);
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2);
	}
	@Test
	void bindToCollectionWhenHasExistingCollectionShouldReplaceAllContents() {
		this.sources.add(new MockConfigurationPropertySource('foo[0]', '1'));
		List<Integer> existing = new LinkedList<>();
		existing.add(1000);
		existing.add(1001);
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST.withExistingValue(existing)).get();
		assertThat(result).isExactlyInstanceOf(LinkedList.class);
		assertThat(result).containsExactly(1);
	}
	@Test
	void bindToCollectionWhenHasExistingCollectionButNoValueShouldReturnUnbound() {
		this.sources.add(new MockConfigurationPropertySource('faf[0]', '1'));
		List<Integer> existing = new LinkedList<>();
		existing.add(1000);
		BindResult<List<Integer>> result = this.binder.bind('foo', INTEGER_LIST.withExistingValue(existing));
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindToCollectionShouldRespectCollectionType() {
		this.sources.add(new MockConfigurationPropertySource('foo[0]', '1'));
		ResolvableType type = ResolvableType.forClassWithGenerics(LinkedList.class, Integer.class);
		Object defaultList = this.binder.bind('foo', INTEGER_LIST).get();
		Object customList = this.binder.bind('foo', Bindable.of(type)).get();
		assertThat(customList).isExactlyInstanceOf(LinkedList.class).isNotInstanceOf(defaultList.getClass());
	}
	@Test
	void bindToCollectionWhenNoValueShouldReturnUnbound() {
		this.sources.add(new MockConfigurationPropertySource('faf.bar', '1'));
		BindResult<List<Integer>> result = this.binder.bind('foo', INTEGER_LIST);
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindToCollectionWhenCommaListShouldReturnPopulatedCollection() {
		this.sources.add(new MockConfigurationPropertySource('foo', '1,2,3'));
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToCollectionWhenCommaListWithPlaceholdersShouldReturnPopulatedCollection() {
		StandardEnvironment environment = new StandardEnvironment();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(environment, 'bar=1,2,3');
		this.binder = new Binder(this.sources, new PropertySourcesPlaceholdersResolver(environment));
		this.sources.add(new MockConfigurationPropertySource('foo', '${bar}'));
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToCollectionWhenCommaListAndIndexedShouldOnlyUseFirst() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('foo', '1,2');
		this.sources.add(source1);
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('foo[0]', '2');
		source2.put('foo[1]', '3');
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2);
	}
	@Test
	void bindToCollectionWhenIndexedAndCommaListShouldOnlyUseFirst() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('foo[0]', '1');
		source1.put('foo[1]', '2');
		this.sources.add(source1);
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('foo', '2,3');
		List<Integer> result = this.binder.bind('foo', INTEGER_LIST).get();
		assertThat(result).containsExactly(1, 2);
	}
	@Test
	void bindToCollectionWhenItemContainsCommasShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', '1,2');
		source.put('foo[1]', '3');
		this.sources.add(source);
		List<String> result = this.binder.bind('foo', STRING_LIST).get();
		assertThat(result).containsExactly('1,2', '3');
	}
	@Test
	void bindToCollectionWhenEmptyStringShouldReturnEmptyCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', '');
		this.sources.add(source);
		List<String> result = this.binder.bind('foo', STRING_LIST).get();
		assertThat(result).isEmpty();
	}
	@Test
	void bindToNonScalarCollectionShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0].value', 'a');
		source.put('foo[1].value', 'b');
		source.put('foo[2].value', 'c');
		this.sources.add(source);
		Bindable<List<JavaBean>> target = Bindable.listOf(JavaBean.class);
		List<JavaBean> result = this.binder.bind('foo', target).get();
		assertThat(result).hasSize(3);
		List<String> values = result.stream().map(JavaBean::getValue).toList();
		assertThat(values).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToImmutableCollectionShouldReturnPopulatedCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.values', 'a,b,c');
		this.sources.add(source);
		Set<String> result = this.binder.bind('foo.values', STRING_SET.withExistingValue(Collections.emptySet())).get();
		assertThat(result).hasSize(3);
	}
	@Test
	void bindToCollectionShouldAlsoCallSetterIfPresent() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.items', 'a,b,c');
		this.sources.add(source);
		ExampleCollectionBean result = this.binder.bind('foo', ExampleCollectionBean.class).get();
		assertThat(result.getItems()).hasSize(4);
		assertThat(result.getItems()).containsExactly('a', 'b', 'c', 'd');
	}
	@Test
	void bindToCollectionWithNoDefaultConstructor() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.items', 'a,b,c,c');
		this.sources.add(source);
		ExampleCustomNoDefaultConstructorBean result = this.binder
			.bind('foo', ExampleCustomNoDefaultConstructorBean.class)
			.get();
		assertThat(result.getItems()).hasSize(4);
		assertThat(result.getItems()).containsExactly('a', 'b', 'c', 'c');
	}
	@Test
	void bindToCollectionWithDefaultConstructor() {
		// gh-12322
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.items', 'a,b,c,c');
		this.sources.add(source);
		ExampleCustomWithDefaultConstructorBean result = this.binder
			.bind('foo', ExampleCustomWithDefaultConstructorBean.class)
			.get();
		assertThat(result.getItems()).hasSize(4);
		assertThat(result.getItems()).containsExactly('a', 'b', 'c', 'c');
	}
	@Test
	void bindToListShouldAllowDuplicateValues() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.items', 'a,b,c,c');
		this.sources.add(source);
		ExampleCollectionBean result = this.binder.bind('foo', ExampleCollectionBean.class).get();
		assertThat(result.getItems()).hasSize(5);
		assertThat(result.getItems()).containsExactly('a', 'b', 'c', 'c', 'd');
	}
	@Test
	void bindToSetShouldNotAllowDuplicateValues() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.items-set', 'a,b,c,c');
		this.sources.add(source);
		ExampleCollectionBean result = this.binder.bind('foo', ExampleCollectionBean.class).get();
		assertThat(result.getItemsSet()).hasSize(3);
		assertThat(result.getItemsSet()).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToBeanWithNestedCollectionShouldPopulateCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', 'one');
		source.put('foo.foos[0].value', 'two');
		source.put('foo.foos[1].value', 'three');
		this.sources.add(source);
		Bindable<BeanWithNestedCollection> target = Bindable.of(BeanWithNestedCollection.class);
		BeanWithNestedCollection foo = this.binder.bind('foo', target).get();
		assertThat(foo.getValue()).isEqualTo('one');
		assertThat(foo.getFoos().get(0).getValue()).isEqualTo('two');
		assertThat(foo.getFoos().get(1).getValue()).isEqualTo('three');
	}
	@Test
	void bindToNestedCollectionWhenEmptyStringShouldReturnEmptyCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', 'one');
		source.put('foo.foos', '');
		this.sources.add(source);
		Bindable<BeanWithNestedCollection> target = Bindable.of(BeanWithNestedCollection.class);
		BeanWithNestedCollection foo = this.binder.bind('foo', target).get();
		assertThat(foo.getValue()).isEqualTo('one');
		assertThat(foo.getFoos()).isEmpty();
	}
	@Test
	void bindToCollectionShouldUsePropertyEditor() {
		// gh-12166
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', 'java.lang.RuntimeException');
		source.put('foo[1]', 'java.lang.IllegalStateException');
		this.sources.add(source);
		assertThat(this.binder.bind('foo', Bindable.listOf(Class.class)).get()).containsExactly(RuntimeException.class,
				IllegalStateException.class);
	}
	@Test
	void bindToCollectionWhenStringShouldUsePropertyEditor() {
		// gh-12166
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', 'java.lang.RuntimeException,java.lang.IllegalStateException');
		this.sources.add(source);
		assertThat(this.binder.bind('foo', Bindable.listOf(Class.class)).get()).containsExactly(RuntimeException.class,
				IllegalStateException.class);
	}
	@Test
	void bindToBeanWithNestedCollectionAndNonIterableSourceShouldNotFail() {
		// gh-10702
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		this.sources.add(source.nonIterable());
		Bindable<BeanWithNestedCollection> target = Bindable.of(BeanWithNestedCollection.class);
		this.binder.bind('foo', target);
	}
	@Test
	void bindToBeanWithClonedArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar[0]', 'hello');
		this.sources.add(source);
		Bindable<ClonedArrayBean> target = Bindable.of(ClonedArrayBean.class);
		ClonedArrayBean bean = this.binder.bind('foo', target).get();
		assertThat(bean.getBar()).containsExactly('hello');
	}
	@Test
	void bindToBeanWithExceptionInGetterForExistingValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.values', 'a,b,c');
		this.sources.add(source);
		BeanWithGetterException result = this.binder.bind('foo', Bindable.of(BeanWithGetterException.class)).get();
		assertThat(result.getValues()).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToBeanWithEnumSetCollection() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.values[0]', 'foo-bar,bar-baz');
		this.sources.add(source);
		BeanWithEnumSetCollection result = this.binder.bind('foo', Bindable.of(BeanWithEnumSetCollection.class)).get();
		assertThat(result.getValues().get(0)).containsExactly(ExampleEnum.FOO_BAR, ExampleEnum.BAR_BAZ);
	}
	static class ExampleCollectionBean {
		private final List<String> items = new ArrayList<>();
		private Set<String> itemsSet = new LinkedHashSet<>();
		List<String> getItems() {
			return this.items;
		}
		void setItems(List<String> items) {
			this.items.add('d');
		}
		Set<String> getItemsSet() {
			return this.itemsSet;
		}
		void setItemsSet(Set<String> itemsSet) {
			this.itemsSet = itemsSet;
		}
	}
	static class ExampleCustomNoDefaultConstructorBean {
		private MyCustomNoDefaultConstructorList items = new MyCustomNoDefaultConstructorList(
				Collections.singletonList('foo'));
		MyCustomNoDefaultConstructorList getItems() {
			return this.items;
		}
		void setItems(MyCustomNoDefaultConstructorList items) {
			this.items = items;
		}
	}
	static class MyCustomNoDefaultConstructorList extends ArrayList<String> {
		MyCustomNoDefaultConstructorList(List<String> items) {
			addAll(items);
		}
	}
	static class ExampleCustomWithDefaultConstructorBean {
		private final MyCustomWithDefaultConstructorList items = new MyCustomWithDefaultConstructorList();
		MyCustomWithDefaultConstructorList getItems() {
			return this.items;
		}
		void setItems(MyCustomWithDefaultConstructorList items) {
			this.items.clear();
			this.items.addAll(items);
		}
	}
	static class MyCustomWithDefaultConstructorList extends ArrayList<String> {
	}
	static class BeanWithNestedCollection {
		private String value;
		private List<BeanWithNestedCollection> foos;
		List<BeanWithNestedCollection> getFoos() {
			return this.foos;
		}
		void setFoos(List<BeanWithNestedCollection> foos) {
			this.foos = foos;
		}
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
	}
	static class ClonedArrayBean {
		private String[] bar;
		String[] getBar() {
			return this.bar.clone();
		}
		void setBar(String[] bar) {
			this.bar = bar;
		}
	}
	static class BeanWithGetterException {
		private List<String> values;
		void setValues(List<String> values) {
			this.values = values;
		}
		List<String> getValues() {
			return Collections.unmodifiableList(this.values);
		}
	}
	static class BeanWithEnumSetCollection {
		private List<EnumSet<ExampleEnum>> values;
		void setValues(List<EnumSet<ExampleEnum>> values) {
			this.values = values;
		}
		List<EnumSet<ExampleEnum>> getValues() {
			return this.values;
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class ArrayBinderTests {
	private static final Bindable<List<Integer>> INTEGER_LIST = Bindable.listOf(Integer.class);
	private static final Bindable<Integer[]> INTEGER_ARRAY = Bindable.of(Integer[].class);
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private final Binder binder = new Binder(this.sources);
	@Test
	void bindToArrayShouldReturnArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', '1');
		source.put('foo[1]', '2');
		source.put('foo[2]', '3');
		this.sources.add(source);
		Integer[] result = this.binder.bind('foo', INTEGER_ARRAY).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToCollectionShouldTriggerOnSuccess() {
		this.sources.add(new MockConfigurationPropertySource('foo[0]', '1', 'line1'));
		BindHandler handler = mockBindHandler();
		this.binder.bind('foo', INTEGER_LIST, handler);
		InOrder inOrder = inOrder(handler);
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo[0]')), eq(Bindable.of(Integer.class)), any(), eq(1));
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo')), eq(INTEGER_LIST), any(), isA(List.class));
	}
	@Test
	void bindToArrayShouldReturnPrimitiveArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', '1');
		source.put('foo[1]', '2');
		source.put('foo[2]', '3');
		this.sources.add(source);
		int[] result = this.binder.bind('foo', Bindable.of(int[].class)).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToArrayWhenNestedShouldReturnPopulatedArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0][0]', '1');
		source.put('foo[0][1]', '2');
		source.put('foo[1][0]', '3');
		source.put('foo[1][1]', '4');
		this.sources.add(source);
		ResolvableType type = ResolvableType.forArrayComponent(INTEGER_ARRAY.getType());
		Bindable<Integer[][]> target = Bindable.of(type);
		Integer[][] result = this.binder.bind('foo', target).get();
		assertThat(result).hasDimensions(2, 2);
		assertThat(result[0]).containsExactly(1, 2);
		assertThat(result[1]).containsExactly(3, 4);
	}
	@Test
	void bindToArrayWhenNestedListShouldReturnPopulatedArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0][0]', '1');
		source.put('foo[0][1]', '2');
		source.put('foo[1][0]', '3');
		source.put('foo[1][1]', '4');
		this.sources.add(source);
		ResolvableType type = ResolvableType.forArrayComponent(INTEGER_LIST.getType());
		Bindable<List<Integer>[]> target = Bindable.of(type);
		List<Integer>[] result = this.binder.bind('foo', target).get();
		assertThat(result).hasSize(2);
		assertThat(result[0]).containsExactly(1, 2);
		assertThat(result[1]).containsExactly(3, 4);
	}
	@Test
	void bindToArrayWhenNotInOrderShouldReturnPopulatedArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[1]', '2');
		source.put('foo[0]', '1');
		source.put('foo[2]', '3');
		this.sources.add(source);
		Integer[] result = this.binder.bind('foo', INTEGER_ARRAY).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToArrayWhenNonSequentialShouldThrowException() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', '2');
		source.put('foo[1]', '1');
		source.put('foo[3]', '3');
		this.sources.add(source);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.binder.bind('foo', INTEGER_ARRAY))
			.satisfies((ex) -> {
				Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex.getCause())
					.getUnboundProperties();
				assertThat(unbound).hasSize(1);
				ConfigurationProperty property = unbound.iterator().next();
				assertThat(property.getName()).hasToString('foo[3]');
				assertThat(property.getValue()).isEqualTo('3');
			});
	}
	@Test
	void bindToArrayWhenNonIterableShouldReturnPopulatedArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[1]', '2');
		source.put('foo[0]', '1');
		source.put('foo[2]', '3');
		this.sources.add(source.nonIterable());
		Integer[] result = this.binder.bind('foo', INTEGER_ARRAY).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToArrayWhenMultipleSourceShouldOnlyUseFirst() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('bar', 'baz');
		this.sources.add(source1);
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('foo[0]', '1');
		source2.put('foo[1]', '2');
		this.sources.add(source2);
		MockConfigurationPropertySource source3 = new MockConfigurationPropertySource();
		source3.put('foo[0]', '7');
		source3.put('foo[1]', '8');
		source3.put('foo[2]', '9');
		this.sources.add(source3);
		Integer[] result = this.binder.bind('foo', INTEGER_ARRAY).get();
		assertThat(result).containsExactly(1, 2);
	}
	@Test
	void bindToArrayWhenHasExistingCollectionShouldReplaceAllContents() {
		this.sources.add(new MockConfigurationPropertySource('foo[0]', '1'));
		Integer[] existing = new Integer[2];
		existing[0] = 1000;
		existing[1] = 1001;
		Integer[] result = this.binder.bind('foo', INTEGER_ARRAY.withExistingValue(existing)).get();
		assertThat(result).containsExactly(1);
	}
	@Test
	void bindToArrayWhenNoValueShouldReturnUnbound() {
		this.sources.add(new MockConfigurationPropertySource('faf.bar', '1'));
		BindResult<Integer[]> result = this.binder.bind('foo', INTEGER_ARRAY);
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindToArrayShouldTriggerOnSuccess() {
		this.sources.add(new MockConfigurationPropertySource('foo[0]', '1', 'line1'));
		BindHandler handler = mockBindHandler();
		Bindable<Integer[]> target = INTEGER_ARRAY;
		this.binder.bind('foo', target, handler);
		InOrder inOrder = inOrder(handler);
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo[0]')), eq(Bindable.of(Integer.class)), any(), eq(1));
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo')), eq(target), any(), isA(Integer[].class));
	}
	@Test
	void bindToArrayWhenCommaListShouldReturnPopulatedArray() {
		this.sources.add(new MockConfigurationPropertySource('foo', '1,2,3'));
		int[] result = this.binder.bind('foo', Bindable.of(int[].class)).get();
		assertThat(result).containsExactly(1, 2, 3);
	}
	@Test
	void bindToArrayWhenCommaListAndIndexedShouldOnlyUseFirst() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('foo', '1,2');
		this.sources.add(source1);
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('foo[0]', '2');
		source2.put('foo[1]', '3');
		int[] result = this.binder.bind('foo', Bindable.of(int[].class)).get();
		assertThat(result).containsExactly(1, 2);
	}
	@Test
	void bindToArrayWhenIndexedAndCommaListShouldOnlyUseFirst() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('foo[0]', '1');
		source1.put('foo[1]', '2');
		this.sources.add(source1);
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('foo', '2,3');
		int[] result = this.binder.bind('foo', Bindable.of(int[].class)).get();
		assertThat(result).containsExactly(1, 2);
	}
	@Test
	void bindToArrayShouldBindCharArray() {
		this.sources.add(new MockConfigurationPropertySource('foo', 'word'));
		char[] result = this.binder.bind('foo', Bindable.of(char[].class)).get();
		assertThat(result).containsExactly('word'.toCharArray());
	}
	@Test
	void bindToArrayWhenEmptyStringShouldReturnEmptyArray() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', '');
		this.sources.add(source);
		String[] result = this.binder.bind('foo', Bindable.of(String[].class)).get();
		assertThat(result).isEmpty();
	}
	@Test
	void bindToArrayWhenHasSpacesShouldTrim() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', '1,  2,3');
		this.sources.add(source);
		String[] result = this.binder.bind('foo', Bindable.of(String[].class)).get();
		assertThat(result).containsExactly('1', '2', '3');
	}
	@Test
	void bindToArrayShouldUsePropertyEditor() {
		// gh-12166
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', 'java.lang.RuntimeException');
		source.put('foo[1]', 'java.lang.IllegalStateException');
		this.sources.add(source);
		assertThat(this.binder.bind('foo', Bindable.of(Class[].class)).get()).containsExactly(RuntimeException.class,
				IllegalStateException.class);
	}
	@Test
	void bindToArrayWhenStringShouldUsePropertyEditor() {
		// gh-12166
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', 'java.lang.RuntimeException,java.lang.IllegalStateException');
		this.sources.add(source);
		assertThat(this.binder.bind('foo', Bindable.of(Class[].class)).get()).containsExactly(RuntimeException.class,
				IllegalStateException.class);
	}
	private BindHandler mockBindHandler() {
		BindHandler handler = mock(BindHandler.class);
		given(handler.onStart(any(), any(), any())).willAnswer(InvocationArgument.index(1));
		given(handler.onCreate(any(), any(), any(), any())).willAnswer(InvocationArgument.index(3));
		given(handler.onSuccess(any(), any(), any(), any())).willAnswer(InvocationArgument.index(3));
		return handler;
	}
	private static final class InvocationArgument<T> implements Answer<T> {
		private final int index;
		private InvocationArgument(int index) {
			this.index = index;
		}
		@Override
		public T answer(InvocationOnMock invocation) throws Throwable {
			return invocation.getArgument(this.index);
		}
		private static <T> InvocationArgument<T> index(int index) {
			return new InvocationArgument<>(index);
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class BindableRuntimeHintsRegistrarTests {
	@Test
	void registerHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		Class<?>[] types = { BoundConfigurationProperties.class, ConfigurationPropertiesBean.class };
		BindableRuntimeHintsRegistrar registrar = new BindableRuntimeHintsRegistrar(types);
		registrar.registerHints(runtimeHints);
		for (Class<?> type : types) {
			assertThat(RuntimeHintsPredicates.reflection().onType(type)).accepts(runtimeHints);
		}
	}
	@Test
	void registerHintsWithIterable() {
		RuntimeHints runtimeHints = new RuntimeHints();
		List<Class<?>> types = Arrays.asList(BoundConfigurationProperties.class, ConfigurationPropertiesBean.class);
		BindableRuntimeHintsRegistrar registrar = BindableRuntimeHintsRegistrar.forTypes(types);
		registrar.registerHints(runtimeHints);
		for (Class<?> type : types) {
			assertThat(RuntimeHintsPredicates.reflection().onType(type)).accepts(runtimeHints);
		}
	}
	@Test
	void registerHintsWhenNoClasses() {
		RuntimeHints runtimeHints = new RuntimeHints();
		BindableRuntimeHintsRegistrar registrar = new BindableRuntimeHintsRegistrar(new Class<?>[0]);
		registrar.registerHints(runtimeHints);
		assertThat(runtimeHints.reflection().typeHints()).isEmpty();
	}
	@Test
	void registerHintsViaForType() {
		RuntimeHints runtimeHints = new RuntimeHints();
		Class<?>[] types = { BoundConfigurationProperties.class, ConfigurationPropertiesBean.class };
		BindableRuntimeHintsRegistrar registrar = BindableRuntimeHintsRegistrar.forTypes(types);
		registrar.registerHints(runtimeHints);
		for (Class<?> type : types) {
			assertThat(RuntimeHintsPredicates.reflection().onType(type)).accepts(runtimeHints);
		}
	}
	@Test
	void registerHintsWhenJavaBean() {
		RuntimeHints runtimeHints = registerHints(JavaBean.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement().satisfies(javaBeanBinding(JavaBean.class));
	}
	@Test
	void registerHintsWhenJavaBeanWithSeveralConstructors() throws NoSuchMethodException {
		RuntimeHints runtimeHints = registerHints(WithSeveralConstructors.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement()
			.satisfies(javaBeanBinding(WithSeveralConstructors.class,
					WithSeveralConstructors.class.getDeclaredConstructor()));
	}
	@Test
	void registerHintsWhenJavaBeanWithMapOfPojo() {
		RuntimeHints runtimeHints = registerHints(WithMap.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(2)
			.anySatisfy(javaBeanBinding(WithMap.class, 'getAddresses'))
			.anySatisfy(javaBeanBinding(Address.class));
	}
	@Test
	void registerHintsWhenJavaBeanWithListOfPojo() {
		RuntimeHints runtimeHints = registerHints(WithList.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(2)
			.anySatisfy(javaBeanBinding(WithList.class, 'getAllAddresses'))
			.anySatisfy(javaBeanBinding(Address.class));
	}
	@Test
	void registerHintsWhenJavaBeanWitArrayOfPojo() {
		RuntimeHints runtimeHints = registerHints(WithArray.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(2)
			.anySatisfy(javaBeanBinding(WithArray.class, 'getAllAddresses'))
			.anySatisfy(javaBeanBinding(Address.class));
	}
	@Test
	void registerHintsWhenJavaBeanWithListOfJavaType() {
		RuntimeHints runtimeHints = registerHints(WithSimpleList.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement()
			.satisfies(javaBeanBinding(WithSimpleList.class, 'getNames'));
	}
	@Test
	void registerHintsWhenValueObject() {
		RuntimeHints runtimeHints = registerHints(Immutable.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement()
			.satisfies(valueObjectBinding(Immutable.class));
	}
	@Test
	void registerHintsWhenValueObjectWithSpecificConstructor() throws NoSuchMethodException {
		RuntimeHints runtimeHints = registerHints(ImmutableWithSeveralConstructors.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement()
			.satisfies(valueObjectBinding(ImmutableWithSeveralConstructors.class,
					ImmutableWithSeveralConstructors.class.getDeclaredConstructor(String.class)));
	}
	@Test
	void registerHintsWhenValueObjectWithSeveralLayersOfPojo() {
		RuntimeHints runtimeHints = registerHints(ImmutableWithList.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(3)
			.anySatisfy(valueObjectBinding(ImmutableWithList.class))
			.anySatisfy(valueObjectBinding(Person.class))
			.anySatisfy(valueObjectBinding(Address.class));
	}
	@Test
	void registerHintsWhenHasNestedTypeNotUsedIsIgnored() {
		RuntimeHints runtimeHints = registerHints(WithNested.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement().satisfies(javaBeanBinding(WithNested.class));
	}
	@Test
	void registerHintsWhenWhenHasNestedExternalType() {
		RuntimeHints runtimeHints = registerHints(WithExternalNested.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(3)
			.anySatisfy(
					javaBeanBinding(WithExternalNested.class, 'getName', 'setName', 'getSampleType', 'setSampleType'))
			.anySatisfy(javaBeanBinding(SampleType.class, 'getNested'))
			.anySatisfy(javaBeanBinding(SampleType.Nested.class));
	}
	@Test
	void registerHintsWhenHasRecursiveType() {
		RuntimeHints runtimeHints = registerHints(WithRecursive.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(2)
			.anySatisfy(javaBeanBinding(WithRecursive.class, 'getRecursive', 'setRecursive'))
			.anySatisfy(javaBeanBinding(Recursive.class, 'getRecursive', 'setRecursive'));
	}
	@Test
	void registerHintsWhenValueObjectWithRecursiveType() {
		RuntimeHints runtimeHints = registerHints(ImmutableWithRecursive.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(2)
			.anySatisfy(valueObjectBinding(ImmutableWithRecursive.class))
			.anySatisfy(valueObjectBinding(ImmutableRecursive.class));
	}
	@Test
	void registerHintsWhenHasWellKnownTypes() {
		RuntimeHints runtimeHints = registerHints(WithWellKnownTypes.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement()
			.satisfies(javaBeanBinding(WithWellKnownTypes.class, 'getApplicationContext', 'setApplicationContext',
					'getEnvironment', 'setEnvironment'));
	}
	@Test
	void registerHintsWhenHasCrossReference() {
		RuntimeHints runtimeHints = registerHints(WithCrossReference.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(3)
			.anySatisfy(javaBeanBinding(WithCrossReference.class, 'getCrossReferenceA', 'setCrossReferenceA'))
			.anySatisfy(javaBeanBinding(CrossReferenceA.class, 'getCrossReferenceB', 'setCrossReferenceB'))
			.anySatisfy(javaBeanBinding(CrossReferenceB.class, 'getCrossReferenceA', 'setCrossReferenceA'));
	}
	@Test
	void registerHintsWhenHasUnresolvedGeneric() {
		RuntimeHints runtimeHints = registerHints(WithGeneric.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(2)
			.anySatisfy(javaBeanBinding(WithGeneric.class, 'getGeneric'))
			.anySatisfy(javaBeanBinding(GenericObject.class));
	}
	@Test
	void registerHintsWhenHasNestedGenerics() {
		RuntimeHints runtimeHints = registerHints(NestedGenerics.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(2);
		assertThat(RuntimeHintsPredicates.reflection().onType(NestedGenerics.class)).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(NestedGenerics.Nested.class)).accepts(runtimeHints);
	}
	@Test
	void registerHintsWhenHasMultipleNestedClasses() {
		RuntimeHints runtimeHints = registerHints(TripleNested.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(3);
		assertThat(RuntimeHintsPredicates.reflection().onType(TripleNested.class)).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(TripleNested.DoubleNested.class)).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onType(TripleNested.DoubleNested.Nested.class))
			.accepts(runtimeHints);
	}
	@Test
	void registerHintsWhenHasPackagePrivateGettersAndSetters() {
		RuntimeHints runtimeHints = registerHints(PackagePrivateGettersAndSetters.class);
		assertThat(runtimeHints.reflection().typeHints()).singleElement()
			.satisfies(javaBeanBinding(PackagePrivateGettersAndSetters.class, 'getAlpha', 'setAlpha', 'getBravo',
					'setBravo'));
	}
	@Test
	void registerHintsWhenHasInheritedNestedProperties() {
		RuntimeHints runtimeHints = registerHints(ExtendingProperties.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(3);
		assertThat(runtimeHints.reflection().getTypeHint(BaseProperties.class)).satisfies((entry) -> {
			assertThat(entry.getMemberCategories()).isEmpty();
			assertThat(entry.methods()).extracting(ExecutableHint::getName)
				.containsExactlyInAnyOrder('getInheritedNested', 'setInheritedNested');
		});
		assertThat(runtimeHints.reflection().getTypeHint(ExtendingProperties.class))
			.satisfies(javaBeanBinding(ExtendingProperties.class, 'getBravo', 'setBravo'));
		assertThat(runtimeHints.reflection().getTypeHint(InheritedNested.class))
			.satisfies(javaBeanBinding(InheritedNested.class, 'getAlpha', 'setAlpha'));
	}
	@Test
	void registerHintsWhenHasComplexNestedProperties() {
		RuntimeHints runtimeHints = registerHints(ComplexNestedProperties.class);
		assertThat(runtimeHints.reflection().typeHints()).hasSize(4);
		assertThat(runtimeHints.reflection().getTypeHint(Retry.class)).satisfies((entry) -> {
			assertThat(entry.getMemberCategories()).isEmpty();
			assertThat(entry.methods()).extracting(ExecutableHint::getName)
				.containsExactlyInAnyOrder('getCount', 'setCount');
		});
		assertThat(runtimeHints.reflection().getTypeHint(ListenerRetry.class))
			.satisfies(javaBeanBinding(ListenerRetry.class, 'isStateless', 'setStateless'));
		assertThat(runtimeHints.reflection().getTypeHint(Simple.class))
			.satisfies(javaBeanBinding(Simple.class, 'getRetry'));
		assertThat(runtimeHints.reflection().getTypeHint(ComplexNestedProperties.class))
			.satisfies(javaBeanBinding(ComplexNestedProperties.class, 'getSimple'));
	}
	@Test
	void registerHintsDoesNotThrowWhenParameterInformationForConstructorBindingIsNotAvailable()
			throws NoSuchMethodException, SecurityException {
		Constructor<?> constructor = PoolProperties.InterceptorProperty.class.getConstructor(String.class,
				String.class);
		String[] parameterNames = new StandardReflectionParameterNameDiscoverer().getParameterNames(constructor);
		assertThat(parameterNames).isNull();
		assertThatNoException().isThrownBy(() -> registerHints(PoolProperties.class));
	}
	private Consumer<TypeHint> javaBeanBinding(Class<?> type, String... expectedMethods) {
		return javaBeanBinding(type, type.getDeclaredConstructors()[0], expectedMethods);
	}
	private Consumer<TypeHint> javaBeanBinding(Class<?> type, Constructor<?> constructor, String... expectedMethods) {
		return (entry) -> {
			assertThat(entry.getType()).isEqualTo(TypeReference.of(type));
			assertThat(entry.constructors()).singleElement().satisfies(match(constructor));
			assertThat(entry.getMemberCategories()).isEmpty();
			assertThat(entry.methods()).extracting(ExecutableHint::getName).containsExactlyInAnyOrder(expectedMethods);
		};
	}
	private Consumer<TypeHint> valueObjectBinding(Class<?> type) {
		return valueObjectBinding(type, type.getDeclaredConstructors()[0]);
	}
	private Consumer<TypeHint> valueObjectBinding(Class<?> type, Constructor<?> constructor) {
		return (entry) -> {
			assertThat(entry.getType()).isEqualTo(TypeReference.of(type));
			assertThat(entry.constructors()).singleElement().satisfies(match(constructor));
			assertThat(entry.getMemberCategories()).isEmpty();
			assertThat(entry.methods()).isEmpty();
		};
	}
	private Consumer<ExecutableHint> match(Constructor<?> constructor) {
		return (executableHint) -> {
			assertThat(executableHint.getName()).isEqualTo('<init>');
			assertThat(Arrays.stream(constructor.getParameterTypes()).map(TypeReference::of).toList())
				.isEqualTo(executableHint.getParameterTypes());
		};
	}
	private RuntimeHints registerHints(Class<?>... types) {
		RuntimeHints hints = new RuntimeHints();
		BindableRuntimeHintsRegistrar.forTypes(types).registerHints(hints);
		return hints;
	}
	public static class JavaBean {
	}
	public static class WithSeveralConstructors {
		WithSeveralConstructors() {
		}
		WithSeveralConstructors(String ignored) {
		}
	}
	public static class WithMap {
		public Map<String, Address> getAddresses() {
			return Collections.emptyMap();
		}
	}
	public static class WithList {
		public List<Address> getAllAddresses() {
			return Collections.emptyList();
		}
	}
	public static class WithSimpleList {
		public List<String> getNames() {
			return Collections.emptyList();
		}
	}
	public static class WithArray {
		public Address[] getAllAddresses() {
			return new Address[0];
		}
	}
	public static class Immutable {
		@SuppressWarnings('unused')
		private final String name;
		Immutable(String name) {
			this.name = name;
		}
	}
	public static class ImmutableWithSeveralConstructors {
		@SuppressWarnings('unused')
		private final String name;
		@ConstructorBinding
		ImmutableWithSeveralConstructors(String name) {
			this.name = name;
		}
		ImmutableWithSeveralConstructors() {
			this('test');
		}
	}
	public static class ImmutableWithList {
		@SuppressWarnings('unused')
		private final List<Person> family;
		ImmutableWithList(List<Person> family) {
			this.family = family;
		}
	}
	public static class WithNested {
		static class OneLevelDown {
		}
	}
	public static class WithExternalNested {
		private String name;
		@NestedConfigurationProperty
		private SampleType sampleType;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public SampleType getSampleType() {
			return this.sampleType;
		}
		public void setSampleType(SampleType sampleType) {
			this.sampleType = sampleType;
		}
	}
	public static class WithRecursive {
		@NestedConfigurationProperty
		private Recursive recursive;
		public Recursive getRecursive() {
			return this.recursive;
		}
		public void setRecursive(Recursive recursive) {
			this.recursive = recursive;
		}
	}
	public static class ImmutableWithRecursive {
		@NestedConfigurationProperty
		private final ImmutableRecursive recursive;
		ImmutableWithRecursive(ImmutableRecursive recursive) {
			this.recursive = recursive;
		}
	}
	public static class WithWellKnownTypes implements ApplicationContextAware, EnvironmentAware {
		private ApplicationContext applicationContext;
		private Environment environment;
		public ApplicationContext getApplicationContext() {
			return this.applicationContext;
		}
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		public Environment getEnvironment() {
			return this.environment;
		}
		@Override
		public void setEnvironment(Environment environment) {
			this.environment = environment;
		}
	}
	public static class SampleType {
		private final Nested nested = new Nested();
		public Nested getNested() {
			return this.nested;
		}
		static class Nested {
		}
	}
	public static class PackagePrivateGettersAndSetters {
		private String alpha;
		private Map<String, String> bravo;
		String getAlpha() {
			return this.alpha;
		}
		void setAlpha(String alpha) {
			this.alpha = alpha;
		}
		Map<String, String> getBravo() {
			return this.bravo;
		}
		void setBravo(Map<String, String> bravo) {
			this.bravo = bravo;
		}
	}
	public static class Address {
	}
	public static class Person {
		@SuppressWarnings('unused')
		private final String firstName;
		@SuppressWarnings('unused')
		private final String lastName;
		@NestedConfigurationProperty
		private final Address address;
		Person(String firstName, String lastName, Address address) {
			this.firstName = firstName;
			this.lastName = lastName;
			this.address = address;
		}
	}
	public static class Recursive {
		private Recursive recursive;
		public Recursive getRecursive() {
			return this.recursive;
		}
		public void setRecursive(Recursive recursive) {
			this.recursive = recursive;
		}
	}
	public static class ImmutableRecursive {
		@SuppressWarnings('unused')
		private final ImmutableRecursive recursive;
		ImmutableRecursive(ImmutableRecursive recursive) {
			this.recursive = recursive;
		}
	}
	public static class WithCrossReference {
		@NestedConfigurationProperty
		private CrossReferenceA crossReferenceA;
		public void setCrossReferenceA(CrossReferenceA crossReferenceA) {
			this.crossReferenceA = crossReferenceA;
		}
		public CrossReferenceA getCrossReferenceA() {
			return this.crossReferenceA;
		}
	}
	public static class CrossReferenceA {
		@NestedConfigurationProperty
		private CrossReferenceB crossReferenceB;
		public void setCrossReferenceB(CrossReferenceB crossReferenceB) {
			this.crossReferenceB = crossReferenceB;
		}
		public CrossReferenceB getCrossReferenceB() {
			return this.crossReferenceB;
		}
	}
	public static class CrossReferenceB {
		private CrossReferenceA crossReferenceA;
		public void setCrossReferenceA(CrossReferenceA crossReferenceA) {
			this.crossReferenceA = crossReferenceA;
		}
		public CrossReferenceA getCrossReferenceA() {
			return this.crossReferenceA;
		}
	}
	public static class WithGeneric {
		@NestedConfigurationProperty
		private GenericObject<?> generic;
		public GenericObject<?> getGeneric() {
			return this.generic;
		}
	}
	public static final class GenericObject<T> {
		private final T value;
		GenericObject(T value) {
			this.value = value;
		}
		public T getValue() {
			return this.value;
		}
	}
	public static class NestedGenerics {
		private final Map<String, List<Nested>> nested = new HashMap<>();
		public Map<String, List<Nested>> getNested() {
			return this.nested;
		}
		public static class Nested {
			private String field;
			public String getField() {
				return this.field;
			}
			public void setField(String field) {
				this.field = field;
			}
		}
	}
	public static class TripleNested {
		private final DoubleNested doubleNested = new DoubleNested();
		public DoubleNested getDoubleNested() {
			return this.doubleNested;
		}
		public static class DoubleNested {
			private final Nested nested = new Nested();
			public Nested getNested() {
				return this.nested;
			}
			public static class Nested {
				private String field;
				public String getField() {
					return this.field;
				}
				public void setField(String field) {
					this.field = field;
				}
			}
		}
	}
	public abstract static class BaseProperties {
		private InheritedNested inheritedNested;
		public InheritedNested getInheritedNested() {
			return this.inheritedNested;
		}
		public void setInheritedNested(InheritedNested inheritedNested) {
			this.inheritedNested = inheritedNested;
		}
		public static class InheritedNested {
			private String alpha;
			public String getAlpha() {
				return this.alpha;
			}
			public void setAlpha(String alpha) {
				this.alpha = alpha;
			}
		}
	}
	public static class ExtendingProperties extends BaseProperties {
		private String bravo;
		public String getBravo() {
			return this.bravo;
		}
		public void setBravo(String bravo) {
			this.bravo = bravo;
		}
	}
	public static class ComplexNestedProperties {
		private final Simple simple = new Simple();
		public Simple getSimple() {
			return this.simple;
		}
		public static class Simple {
			private final ListenerRetry retry = new ListenerRetry();
			public ListenerRetry getRetry() {
				return this.retry;
			}
		}
		public abstract static class Retry {
			private int count = 5;
			public int getCount() {
				return this.count;
			}
			public void setCount(int count) {
				this.count = count;
			}
		}
		public static class ListenerRetry extends Retry {
			private boolean stateless;
			public boolean isStateless() {
				return this.stateless;
			}
			public void setStateless(boolean stateless) {
				this.stateless = stateless;
			}
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class MapBinderTests {
	private static final Bindable<Map<String, String>> STRING_STRING_MAP = Bindable.mapOf(String.class, String.class);
	private static final Bindable<Map<String, Integer>> STRING_INTEGER_MAP = Bindable.mapOf(String.class,
			Integer.class);
	private static final Bindable<Map<Integer, Integer>> INTEGER_INTEGER_MAP = Bindable.mapOf(Integer.class,
			Integer.class);
	private static final Bindable<Map<String, Object>> STRING_OBJECT_MAP = Bindable.mapOf(String.class, Object.class);
	private static final Bindable<Map<String, String[]>> STRING_ARRAY_MAP = Bindable.mapOf(String.class,
			String[].class);
	private static final Bindable<EnumMap<ExampleEnum, String>> EXAMPLE_ENUM_STRING_ENUM_MAP = Bindable
		.of(ResolvableType.forClassWithGenerics(EnumMap.class, ExampleEnum.class, String.class));
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private final Binder binder = new Binder(this.sources);
	@Test
	void bindToMapShouldReturnPopulatedMap() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', '1');
		source.put('foo.[baz]', '2');
		source.put('foo[BiNg]', '3');
		this.sources.add(source);
		Map<String, String> result = this.binder.bind('foo', STRING_STRING_MAP).get();
		assertThat(result).hasSize(3);
		assertThat(result).containsEntry('bar', '1');
		assertThat(result).containsEntry('baz', '2');
		assertThat(result).containsEntry('BiNg', '3');
	}
	@Test
	@SuppressWarnings('unchecked')
	void bindToMapWithEmptyPrefix() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', '1');
		this.sources.add(source);
		Map<String, Object> result = this.binder.bind('', STRING_OBJECT_MAP).get();
		assertThat((Map<String, Object>) result.get('foo')).containsEntry('bar', '1');
	}
	@Test
	void bindToMapShouldConvertMapValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', '1');
		source.put('foo.[baz]', '2');
		source.put('foo[BiNg]', '3');
		source.put('faf.bar', 'x');
		this.sources.add(source);
		Map<String, Integer> result = this.binder.bind('foo', STRING_INTEGER_MAP).get();
		assertThat(result).hasSize(3);
		assertThat(result).containsEntry('bar', 1);
		assertThat(result).containsEntry('baz', 2);
		assertThat(result).containsEntry('BiNg', 3);
	}
	@Test
	void bindToMapShouldBindToMapValue() {
		ResolvableType type = ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(String.class),
				STRING_INTEGER_MAP.getType());
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar.baz', '1');
		source.put('foo.bar.bin', '2');
		source.put('foo.far.baz', '3');
		source.put('foo.far.bin', '4');
		source.put('faf.far.bin', 'x');
		this.sources.add(source);
		Map<String, Map<String, Integer>> result = this.binder
			.bind('foo', Bindable.<Map<String, Map<String, Integer>>>of(type))
			.get();
		assertThat(result).hasSize(2);
		assertThat(result.get('bar')).containsEntry('baz', 1).containsEntry('bin', 2);
		assertThat(result.get('far')).containsEntry('baz', 3).containsEntry('bin', 4);
	}
	@Test
	void bindToMapShouldBindNestedMapValue() {
		ResolvableType nestedType = ResolvableType.forClassWithGenerics(Map.class,
				ResolvableType.forClass(String.class), STRING_INTEGER_MAP.getType());
		ResolvableType type = ResolvableType.forClassWithGenerics(Map.class, ResolvableType.forClass(String.class),
				nestedType);
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.nested.bar.baz', '1');
		source.put('foo.nested.bar.bin', '2');
		source.put('foo.nested.far.baz', '3');
		source.put('foo.nested.far.bin', '4');
		source.put('faf.nested.far.bin', 'x');
		this.sources.add(source);
		Bindable<Map<String, Map<String, Map<String, Integer>>>> target = Bindable.of(type);
		Map<String, Map<String, Map<String, Integer>>> result = this.binder.bind('foo', target).get();
		Map<String, Map<String, Integer>> nested = result.get('nested');
		assertThat(nested).hasSize(2);
		assertThat(nested.get('bar')).containsEntry('baz', 1).containsEntry('bin', 2);
		assertThat(nested.get('far')).containsEntry('baz', 3).containsEntry('bin', 4);
	}
	@Test
	@SuppressWarnings('unchecked')
	void bindToMapWhenMapValueIsObjectShouldBindNestedMapValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.nested.bar.baz', '1');
		source.put('foo.nested.bar.bin', '2');
		source.put('foo.nested.far.baz', '3');
		source.put('foo.nested.far.bin', '4');
		source.put('faf.nested.far.bin', 'x');
		this.sources.add(source);
		Map<String, Object> result = this.binder.bind('foo', Bindable.mapOf(String.class, Object.class)).get();
		Map<String, Object> nested = (Map<String, Object>) result.get('nested');
		assertThat(nested).hasSize(2);
		Map<String, Object> bar = (Map<String, Object>) nested.get('bar');
		assertThat(bar).containsEntry('baz', '1').containsEntry('bin', '2');
		Map<String, Object> far = (Map<String, Object>) nested.get('far');
		assertThat(far).containsEntry('baz', '3').containsEntry('bin', '4');
	}
	@Test
	void bindToMapWhenMapValueIsObjectAndNoRootShouldBindNestedMapValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('commit.id', 'abcdefg');
		source.put('branch', 'master');
		source.put('foo', 'bar');
		this.sources.add(source);
		Map<String, Object> result = this.binder.bind('', Bindable.mapOf(String.class, Object.class)).get();
		assertThat(result).containsEntry('commit', Collections.singletonMap('id', 'abcdefg'));
		assertThat(result).containsEntry('branch', 'master');
		assertThat(result).containsEntry('foo', 'bar');
	}
	@Test
	void bindToMapWhenEmptyRootNameShouldBindMap() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('bar.baz', '1');
		source.put('bar.bin', '2');
		this.sources.add(source);
		Map<String, Integer> result = this.binder.bind('', STRING_INTEGER_MAP).get();
		assertThat(result).hasSize(2);
		assertThat(result).containsEntry('bar.baz', 1).containsEntry('bar.bin', 2);
	}
	@Test
	void bindToMapWhenMultipleCandidateShouldBindFirst() {
		MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();
		source1.put('foo.bar', '1');
		source1.put('foo.baz', '2');
		this.sources.add(source1);
		MockConfigurationPropertySource source2 = new MockConfigurationPropertySource();
		source2.put('foo.baz', '3');
		source2.put('foo.bin', '4');
		this.sources.add(source2);
		Map<String, Integer> result = this.binder.bind('foo', STRING_INTEGER_MAP).get();
		assertThat(result).hasSize(3);
		assertThat(result).containsEntry('bar', 1);
		assertThat(result).containsEntry('baz', 2);
		assertThat(result).containsEntry('bin', 4);
	}
	@Test
	void bindToMapWhenMultipleInSameSourceCandidateShouldBindFirst() {
		Map<String, Object> map = new HashMap<>();
		map.put('foo.bar', '1');
		map.put('foo.b-az', '2');
		map.put('foo.ba-z', '3');
		map.put('foo.bin', '4');
		MapConfigurationPropertySource propertySource = new MapConfigurationPropertySource(map);
		this.sources.add(propertySource);
		Map<String, Integer> result = this.binder.bind('foo', STRING_INTEGER_MAP).get();
		assertThat(result).hasSize(4);
		assertThat(result).containsEntry('bar', 1);
		assertThat(result).containsEntry('b-az', 2);
		assertThat(result).containsEntry('ba-z', 3);
		assertThat(result).containsEntry('bin', 4);
	}
	@Test
	void bindToMapWhenHasExistingMapShouldReplaceOnlyNewContents() {
		this.sources.add(new MockConfigurationPropertySource('foo.bar', '1'));
		Map<String, Integer> existing = new HashMap<>();
		existing.put('bar', 1000);
		existing.put('baz', 1001);
		Bindable<Map<String, Integer>> target = STRING_INTEGER_MAP.withExistingValue(existing);
		Map<String, Integer> result = this.binder.bind('foo', target).get();
		assertThat(result).isExactlyInstanceOf(HashMap.class);
		assertThat(result).hasSize(2);
		assertThat(result).containsEntry('bar', 1);
		assertThat(result).containsEntry('baz', 1001);
	}
	@Test
	void bindToMapShouldRespectMapType() {
		this.sources.add(new MockConfigurationPropertySource('foo.bar', '1'));
		ResolvableType type = ResolvableType.forClassWithGenerics(HashMap.class, String.class, Integer.class);
		Object defaultMap = this.binder.bind('foo', STRING_INTEGER_MAP).get();
		Object customMap = this.binder.bind('foo', Bindable.of(type)).get();
		assertThat(customMap).isExactlyInstanceOf(HashMap.class).isNotInstanceOf(defaultMap.getClass());
	}
	@Test
	void bindToMapWhenNoValueShouldReturnUnbound() {
		this.sources.add(new MockConfigurationPropertySource('faf.bar', '1'));
		BindResult<Map<String, Integer>> result = this.binder.bind('foo', STRING_INTEGER_MAP);
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindToMapShouldConvertKey() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo[0]', '1');
		source.put('foo[1]', '2');
		source.put('foo[9]', '3');
		this.sources.add(source);
		Map<Integer, Integer> result = this.binder.bind('foo', INTEGER_INTEGER_MAP).get();
		assertThat(result).hasSize(3);
		assertThat(result).containsEntry(0, 1);
		assertThat(result).containsEntry(1, 2);
		assertThat(result).containsEntry(9, 3);
	}
	@Test
	void bindToMapShouldBeGreedyForStrings() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.aaa.bbb.ccc', 'b');
		source.put('foo.bbb.ccc.ddd', 'a');
		source.put('foo.ccc.ddd.eee', 'r');
		this.sources.add(source);
		Map<String, String> result = this.binder.bind('foo', STRING_STRING_MAP).get();
		assertThat(result).hasSize(3);
		assertThat(result).containsEntry('aaa.bbb.ccc', 'b');
		assertThat(result).containsEntry('bbb.ccc.ddd', 'a');
		assertThat(result).containsEntry('ccc.ddd.eee', 'r');
	}
	@Test
	void bindToMapShouldBeGreedyForScalars() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.aaa.bbb.ccc', 'foo-bar');
		source.put('foo.bbb.ccc.ddd', 'BAR_BAZ');
		source.put('foo.ccc.ddd.eee', 'bazboo');
		this.sources.add(source);
		Map<String, ExampleEnum> result = this.binder.bind('foo', Bindable.mapOf(String.class, ExampleEnum.class))
			.get();
		assertThat(result).hasSize(3);
		assertThat(result).containsEntry('aaa.bbb.ccc', ExampleEnum.FOO_BAR);
		assertThat(result).containsEntry('bbb.ccc.ddd', ExampleEnum.BAR_BAZ);
		assertThat(result).containsEntry('ccc.ddd.eee', ExampleEnum.BAZ_BOO);
	}
	@Test
	void bindToMapWithPlaceholdersShouldBeGreedyForScalars() {
		StandardEnvironment environment = new StandardEnvironment();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(environment, 'foo=boo');
		MockConfigurationPropertySource source = new MockConfigurationPropertySource('foo.aaa.bbb.ccc', 'baz-${foo}');
		this.sources.add(source);
		Binder binder = new Binder(this.sources, new PropertySourcesPlaceholdersResolver(environment));
		Map<String, ExampleEnum> result = binder.bind('foo', Bindable.mapOf(String.class, ExampleEnum.class)).get();
		assertThat(result).containsEntry('aaa.bbb.ccc', ExampleEnum.BAZ_BOO);
	}
	@Test
	void bindToMapWithNoPropertiesShouldReturnUnbound() {
		BindResult<Map<String, ExampleEnum>> result = this.binder.bind('foo',
				Bindable.mapOf(String.class, ExampleEnum.class));
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindToMapShouldTriggerOnSuccess() {
		this.sources.add(new MockConfigurationPropertySource('foo.bar', '1', 'line1'));
		BindHandler handler = mockBindHandler();
		Bindable<Map<String, Integer>> target = STRING_INTEGER_MAP;
		this.binder.bind('foo', target, handler);
		InOrder ordered = inOrder(handler);
		ordered.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo.bar')), eq(Bindable.of(Integer.class)), any(), eq(1));
		ordered.verify(handler).onSuccess(eq(ConfigurationPropertyName.of('foo')), eq(target), any(), isA(Map.class));
	}
	@Test
	void bindToMapStringArrayShouldTriggerOnSuccess() {
		this.sources.add(new MockConfigurationPropertySource('foo.bar', 'a,b,c', 'line1'));
		BindHandler handler = mockBindHandler();
		Bindable<Map<String, String[]>> target = STRING_ARRAY_MAP;
		this.binder.bind('foo', target, handler);
		InOrder ordered = inOrder(handler);
		ordered.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo.bar')), eq(Bindable.of(String[].class)), any(),
					assertArg((array) -> assertThat((String[]) array).containsExactly('a', 'b', 'c')));
		ordered.verify(handler).onSuccess(eq(ConfigurationPropertyName.of('foo')), eq(target), any(), isA(Map.class));
	}
	@Test
	void bindToMapNonScalarCollectionShouldPopulateMap() {
		Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class);
		Bindable<Map<String, List<JavaBean>>> target = getMapBindable(String.class, valueType.getType());
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar[0].value', 'a');
		source.put('foo.bar[1].value', 'b');
		source.put('foo.bar[2].value', 'c');
		this.sources.add(source);
		Map<String, List<JavaBean>> map = this.binder.bind('foo', target).get();
		List<String> values = map.get('bar').stream().map(JavaBean::getValue).toList();
		assertThat(values).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToPropertiesShouldBeEquivalentToMapOfStringString() {
		this.sources.add(new MockConfigurationPropertySource('foo.bar.baz', '1', 'line1'));
		Bindable<Properties> target = Bindable.of(Properties.class);
		Properties properties = this.binder.bind('foo', target).get();
		assertThat(properties.getProperty('bar.baz')).isEqualTo('1');
	}
	@Test
	void bindToMapShouldNotTreatClassWithStringConstructorAsScalar() {
		this.sources.add(new MockConfigurationPropertySource('foo.bar.pattern', '1', 'line1'));
		Bindable<Map<String, Foo>> target = Bindable.mapOf(String.class, Foo.class);
		Map<String, Foo> map = this.binder.bind('foo', target).get();
		assertThat(map.get('bar').getPattern()).isEqualTo('1');
	}
	@Test
	void bindToMapStringArrayWithDotKeysShouldPreserveDot() {
		MockConfigurationPropertySource mockSource = new MockConfigurationPropertySource();
		mockSource.put('foo.bar.baz[0]', 'a');
		mockSource.put('foo.bar.baz[1]', 'b');
		mockSource.put('foo.bar.baz[2]', 'c');
		this.sources.add(mockSource);
		Map<String, String[]> map = this.binder.bind('foo', STRING_ARRAY_MAP).get();
		assertThat(map.get('bar.baz')).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToMapStringArrayWithDotKeysAndCommaSeparatedShouldPreserveDot() {
		MockConfigurationPropertySource mockSource = new MockConfigurationPropertySource();
		mockSource.put('foo.bar.baz', 'a,b,c');
		this.sources.add(mockSource);
		Map<String, String[]> map = this.binder.bind('foo', STRING_ARRAY_MAP).get();
		assertThat(map.get('bar.baz')).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToMapStringCollectionWithDotKeysShouldPreserveDot() {
		Bindable<List<String>> valueType = Bindable.listOf(String.class);
		Bindable<Map<String, List<String>>> target = getMapBindable(String.class, valueType.getType());
		MockConfigurationPropertySource mockSource = new MockConfigurationPropertySource();
		mockSource.put('foo.bar.baz[0]', 'a');
		mockSource.put('foo.bar.baz[1]', 'b');
		mockSource.put('foo.bar.baz[2]', 'c');
		this.sources.add(mockSource);
		Map<String, List<String>> map = this.binder.bind('foo', target).get();
		List<String> values = map.get('bar.baz');
		assertThat(values).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToMapNonScalarCollectionWithDotKeysShouldBind() {
		Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class);
		Bindable<Map<String, List<JavaBean>>> target = getMapBindable(String.class, valueType.getType());
		MockConfigurationPropertySource mockSource = new MockConfigurationPropertySource();
		mockSource.put('foo.bar.baz[0].value', 'a');
		mockSource.put('foo.bar.baz[1].value', 'b');
		mockSource.put('foo.bar.baz[2].value', 'c');
		this.sources.add(mockSource);
		Map<String, List<JavaBean>> map = this.binder.bind('foo', target).get();
		List<String> values = map.get('bar.baz').stream().map(JavaBean::getValue).toList();
		assertThat(values).containsExactly('a', 'b', 'c');
	}
	@Test
	void bindToListOfMaps() {
		Bindable<List<Integer>> listBindable = Bindable.listOf(Integer.class);
		Bindable<Map<String, List<Integer>>> mapBindable = getMapBindable(String.class, listBindable.getType());
		Bindable<List<Map<String, List<Integer>>>> target = getListBindable(mapBindable.getType());
		MockConfigurationPropertySource mockSource = new MockConfigurationPropertySource();
		mockSource.put('foo[0].a', '1,2,3');
		mockSource.put('foo[1].b', '4,5,6');
		this.sources.add(mockSource);
		List<Map<String, List<Integer>>> list = this.binder.bind('foo', target).get();
		assertThat(list.get(0).get('a')).containsExactly(1, 2, 3);
		assertThat(list.get(1).get('b')).containsExactly(4, 5, 6);
	}
	@Test
	void bindToMapWithNumberKeyAndCommaSeparated() {
		Bindable<List<String>> listBindable = Bindable.listOf(String.class);
		Bindable<Map<Integer, List<String>>> target = getMapBindable(Integer.class, listBindable.getType());
		MockConfigurationPropertySource mockSource = new MockConfigurationPropertySource();
		mockSource.put('foo[0]', 'a,b,c');
		mockSource.put('foo[1]', 'e,f,g');
		this.sources.add(mockSource);
		Map<Integer, List<String>> map = this.binder.bind('foo', target).get();
		assertThat(map.get(0)).containsExactly('a', 'b', 'c');
		assertThat(map.get(1)).containsExactly('e', 'f', 'g');
	}
	@Test
	void bindToMapWithNumberKeyAndIndexed() {
		Bindable<List<Integer>> listBindable = Bindable.listOf(Integer.class);
		Bindable<Map<Integer, List<Integer>>> target = getMapBindable(Integer.class, listBindable.getType());
		MockConfigurationPropertySource mockSource = new MockConfigurationPropertySource();
		mockSource.put('foo[0][0]', '8');
		mockSource.put('foo[0][1]', '9');
		this.sources.add(mockSource);
		Map<Integer, List<Integer>> map = this.binder.bind('foo', target).get();
		assertThat(map.get(0)).containsExactly(8, 9);
	}
	@Test
	void bindingWithSquareBracketMap() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.[x [B] y]', '[ball]');
		this.sources.add(source);
		Map<String, String> map = this.binder.bind('foo', STRING_STRING_MAP).get();
		assertThat(map).containsEntry('x [B] y', '[ball]');
	}
	@Test
	void nestedMapsShouldNotBindToNull() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.value', 'one');
		source.put('foo.foos.foo1.value', 'two');
		source.put('foo.foos.foo2.value', 'three');
		this.sources.add(source);
		BindResult<NestableFoo> foo = this.binder.bind('foo', NestableFoo.class);
		assertThat(foo.get().getValue()).isNotNull();
		assertThat(foo.get().getFoos().get('foo1').getValue()).isEqualTo('two');
		assertThat(foo.get().getFoos().get('foo2').getValue()).isEqualTo('three');
	}
	@Test
	void bindToMapWithCustomConverter() {
		DefaultConversionService conversionService = new DefaultConversionService();
		conversionService.addConverter(new MapConverter());
		Binder binder = new Binder(this.sources, null, conversionService, null);
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', 'a,b');
		this.sources.add(source);
		Map<String, String> map = binder.bind('foo', STRING_STRING_MAP).get();
		assertThat(map).containsKey('a');
		assertThat(map).containsKey('b');
	}
	@Test
	void bindToMapWithCustomConverterAndChildElements() {
		// gh-11892
		DefaultConversionService conversionService = new DefaultConversionService();
		conversionService.addConverter(new MapConverter());
		Binder binder = new Binder(this.sources, null, conversionService, null);
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', 'boom');
		source.put('foo.a', 'a');
		source.put('foo.b', 'b');
		this.sources.add(source);
		Map<String, String> map = binder.bind('foo', STRING_STRING_MAP).get();
		assertThat(map).containsEntry('a', 'a');
		assertThat(map).containsEntry('b', 'b');
	}
	@Test
	void bindToMapWithNoConverterForValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', 'a,b');
		this.sources.add(source);
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> this.binder.bind('foo', STRING_STRING_MAP));
	}
	@Test
	@SuppressWarnings('rawtypes')
	void bindToMapWithPropertyEditorForKey() {
		// gh-12166
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.[java.lang.RuntimeException]', 'bar');
		this.sources.add(source);
		Map<Class, String> map = this.binder.bind('foo', Bindable.mapOf(Class.class, String.class)).get();
		assertThat(map).containsExactly(entry(RuntimeException.class, 'bar'));
	}
	@Test
	@SuppressWarnings('rawtypes')
	void bindToMapWithPropertyEditorForValue() {
		// gh-12166
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'java.lang.RuntimeException');
		this.sources.add(source);
		Map<String, Class> map = this.binder.bind('foo', Bindable.mapOf(String.class, Class.class)).get();
		assertThat(map).containsExactly(entry('bar', RuntimeException.class));
	}
	@Test
	void bindToMapWithNoDefaultConstructor() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.items.a', 'b');
		this.sources.add(source);
		ExampleCustomNoDefaultConstructorBean result = this.binder
			.bind('foo', ExampleCustomNoDefaultConstructorBean.class)
			.get();
		assertThat(result.getItems()).containsOnly(entry('foo', 'bar'), entry('a', 'b'));
	}
	@Test
	void bindToMapWithDefaultConstructor() {
		// gh-12322
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.items.a', 'b');
		this.sources.add(source);
		ExampleCustomWithDefaultConstructorBean result = this.binder
			.bind('foo', ExampleCustomWithDefaultConstructorBean.class)
			.get();
		assertThat(result.getItems()).containsExactly(entry('a', 'b'));
	}
	@Test
	void bindToImmutableMapShouldReturnPopulatedMap() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.values.c', 'd');
		source.put('foo.values.e', 'f');
		this.sources.add(source);
		Map<String, String> result = this.binder
			.bind('foo.values', STRING_STRING_MAP.withExistingValue(Collections.singletonMap('a', 'b')))
			.get();
		assertThat(result).hasSize(3);
		assertThat(result).containsExactly(entry('a', 'b'), entry('c', 'd'), entry('e', 'f'));
	}
	@Test
	void bindToBeanWithExceptionInGetterForExistingValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.values.a', 'b');
		this.sources.add(source);
		BeanWithGetterException result = this.binder.bind('foo', Bindable.of(BeanWithGetterException.class)).get();
		assertThat(result.getValues()).containsExactly(entry('a', 'b'));
	}
	@Test
	void bindToMapWithWildcardShouldConvertToTheRightType() {
		// gh-18767
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.addresses.localhost[0]', '127.0.0.1');
		source.put('foo.addresses.localhost[1]', '127.0.0.2');
		this.sources.add(source);
		MapWithWildcardProperties result = this.binder.bind('foo', Bindable.of(MapWithWildcardProperties.class)).get();
		assertThat(result.getAddresses().get('localhost').stream().map(InetAddress::getHostAddress))
			.containsExactly('127.0.0.1', '127.0.0.2');
	}
	@Test
	void bindToMapWithPlaceholdersShouldResolve() {
		DefaultConversionService conversionService = new DefaultConversionService();
		conversionService.addConverter(new MapConverter());
		StandardEnvironment environment = new StandardEnvironment();
		Binder binder = new Binder(this.sources, new PropertySourcesPlaceholdersResolver(environment),
				conversionService, null, null);
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(environment, 'bar=bc');
		this.sources.add(new MockConfigurationPropertySource('foo', 'a${bar},${bar}d'));
		Map<String, String> map = binder.bind('foo', STRING_STRING_MAP).get();
		assertThat(map).containsKey('abc');
		assertThat(map).containsKey('bcd');
	}
	@Test
	void bindToCustomMapWithoutCtorAndConverterShouldResolve() {
		DefaultConversionService conversionService = new DefaultConversionService();
		conversionService.addConverter(new CustomMapConverter());
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.custom-map', 'value');
		this.sources.add(source);
		Binder binder = new Binder(this.sources, null, conversionService, null);
		CustomMapWithoutDefaultCtor result = binder.bind('foo', Bindable.of(CustomMapWithoutDefaultCtor.class)).get();
		assertThat(result.getCustomMap().getSource()).isEqualTo('value');
	}
	@Test
	void bindToEnumMapShouldBind() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('props.foo-bar', 'value');
		this.sources.add(source);
		Binder binder = new Binder(this.sources, null, null, null);
		EnumMap<ExampleEnum, String> result = binder.bind('props', EXAMPLE_ENUM_STRING_ENUM_MAP).get();
		assertThat(result).hasSize(1).containsEntry(ExampleEnum.FOO_BAR, 'value');
	}
	private <K, V> Bindable<Map<K, V>> getMapBindable(Class<K> keyGeneric, ResolvableType valueType) {
		ResolvableType keyType = ResolvableType.forClass(keyGeneric);
		return Bindable.of(ResolvableType.forClassWithGenerics(Map.class, keyType, valueType));
	}
	private <T> Bindable<List<T>> getListBindable(ResolvableType type) {
		return Bindable.of(ResolvableType.forClassWithGenerics(List.class, type));
	}
	private BindHandler mockBindHandler() {
		BindHandler handler = mock(BindHandler.class);
		given(handler.onStart(any(), any(), any())).willAnswer(InvocationArgument.index(1));
		given(handler.onCreate(any(), any(), any(), any())).willAnswer(InvocationArgument.index(3));
		given(handler.onSuccess(any(), any(), any(), any())).willAnswer(InvocationArgument.index(3));
		return handler;
	}
	static class Foo {
		private String pattern;
		Foo() {
		}
		Foo(String pattern) {
			this.pattern = pattern;
		}
		String getPattern() {
			return this.pattern;
		}
		void setPattern(String pattern) {
			this.pattern = pattern;
		}
	}
	static class NestableFoo {
		private final Map<String, NestableFoo> foos = new LinkedHashMap<>();
		private String value;
		Map<String, NestableFoo> getFoos() {
			return this.foos;
		}
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
	}
	static class MapConverter implements Converter<String, Map<String, String>> {
		@Override
		public Map<String, String> convert(String s) {
			return StringUtils.commaDelimitedListToSet(s).stream().collect(Collectors.toMap((k) -> k, (k) -> ''));
		}
	}
	static class ExampleCustomNoDefaultConstructorBean {
		private MyCustomNoDefaultConstructorMap items = new MyCustomNoDefaultConstructorMap(
				Collections.singletonMap('foo', 'bar'));
		MyCustomNoDefaultConstructorMap getItems() {
			return this.items;
		}
		void setItems(MyCustomNoDefaultConstructorMap items) {
			this.items = items;
		}
	}
	static class MyCustomNoDefaultConstructorMap extends HashMap<String, String> {
		MyCustomNoDefaultConstructorMap(Map<String, String> items) {
			putAll(items);
		}
	}
	static class ExampleCustomWithDefaultConstructorBean {
		private final MyCustomWithDefaultConstructorMap items = new MyCustomWithDefaultConstructorMap();
		MyCustomWithDefaultConstructorMap getItems() {
			return this.items;
		}
		void setItems(MyCustomWithDefaultConstructorMap items) {
			this.items.clear();
			this.items.putAll(items);
		}
	}
	static class MyCustomWithDefaultConstructorMap extends HashMap<String, String> {
	}
	static class BeanWithGetterException {
		private Map<String, String> values;
		void setValues(Map<String, String> values) {
			this.values = values;
		}
		Map<String, String> getValues() {
			return Collections.unmodifiableMap(this.values);
		}
	}
	static class MapWithWildcardProperties {
		private Map<String, ? extends List<? extends InetAddress>> addresses;
		Map<String, ? extends List<? extends InetAddress>> getAddresses() {
			return this.addresses;
		}
		void setAddresses(Map<String, ? extends List<? extends InetAddress>> addresses) {
			this.addresses = addresses;
		}
	}
	static class CustomMapWithoutDefaultCtor {
		private final CustomMap customMap;
		CustomMapWithoutDefaultCtor(CustomMap customMap) {
			this.customMap = customMap;
		}
		CustomMap getCustomMap() {
			return this.customMap;
		}
		static final class CustomMap extends AbstractMap<String, Object> {
			private final String source;
			CustomMap(String source) {
				this.source = source;
			}
			@Override
			public Set<Entry<String, Object>> entrySet() {
				return Collections.emptySet();
			}
			String getSource() {
				return this.source;
			}
		}
	}
	private static final class CustomMapConverter implements Converter<String, CustomMap> {
		@Override
		public CustomMap convert(String source) {
			return new CustomMap(source);
		}
	}
	private static final class InvocationArgument<T> implements Answer<T> {
		private final int index;
		private InvocationArgument(int index) {
			this.index = index;
		}
		@Override
		public T answer(InvocationOnMock invocation) throws Throwable {
			return invocation.getArgument(this.index);
		}
		private static <T> InvocationArgument<T> index(int index) {
			return new InvocationArgument<>(index);
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class DefaultBindConstructorProviderTests {
	private final DefaultBindConstructorProvider provider = new DefaultBindConstructorProvider();
	@Test
	void getBindConstructorWhenHasOnlyDefaultConstructorReturnsNull() {
		Constructor<?> constructor = this.provider.getBindConstructor(OnlyDefaultConstructor.class, false);
		assertThat(constructor).isNull();
	}
	@Test
	void getBindConstructorWhenHasMultipleAmbiguousConstructorsReturnsNull() {
		Constructor<?> constructor = this.provider.getBindConstructor(MultipleAmbiguousConstructors.class, false);
		assertThat(constructor).isNull();
	}
	@Test
	void getBindConstructorWhenHasTwoConstructorsWithOneConstructorBindingReturnsConstructor() {
		Constructor<?> constructor = this.provider.getBindConstructor(TwoConstructorsWithOneConstructorBinding.class,
				false);
		assertThat(constructor).isNotNull();
		assertThat(constructor.getParameterCount()).isOne();
	}
	@Test
	void getBindConstructorWhenHasOneConstructorWithAutowiredReturnsNull() {
		Constructor<?> constructor = this.provider.getBindConstructor(OneConstructorWithAutowired.class, false);
		assertThat(constructor).isNull();
	}
	@Test
	void getBindConstructorWhenHasTwoConstructorsWithOneAutowiredReturnsNull() {
		Constructor<?> constructor = this.provider.getBindConstructor(TwoConstructorsWithOneAutowired.class, false);
		assertThat(constructor).isNull();
	}
	@Test
	void getBindConstructorWhenHasTwoConstructorsWithOneAutowiredAndOneConstructorBindingThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.provider
				.getBindConstructor(TwoConstructorsWithOneAutowiredAndOneConstructorBinding.class, false))
			.withMessageContaining('declares @ConstructorBinding and @Autowired');
	}
	@Test
	void getBindConstructorWhenHasOneConstructorWithConstructorBindingReturnsConstructor() {
		Constructor<?> constructor = this.provider.getBindConstructor(OneConstructorWithConstructorBinding.class,
				false);
		assertThat(constructor).isNotNull();
	}
	@Test
	void getBindConstructorWhenHasTwoConstructorsWithBothConstructorBindingThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.provider.getBindConstructor(TwoConstructorsWithBothConstructorBinding.class, false))
			.withMessageContaining('has more than one @ConstructorBinding');
	}
	@Test
	void getBindConstructorWhenIsTypeWithPrivateConstructorReturnsNull() {
		Constructor<?> constructor = this.provider.getBindConstructor(TypeWithPrivateConstructor.class, false);
		assertThat(constructor).isNull();
	}
	@Test
	void getBindConstructorWhenIsMemberTypeWithPrivateConstructorReturnsNull() {
		Constructor<?> constructor = this.provider.getBindConstructor(MemberTypeWithPrivateConstructor.Member.class,
				false);
		assertThat(constructor).isNull();
	}
	@Test
	void getBindConstructorFromProxiedClassWithOneAutowiredConstructorReturnsNull() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				ProxiedWithOneConstructorWithAutowired.class)) {
			ProxiedWithOneConstructorWithAutowired bean = context.getBean(ProxiedWithOneConstructorWithAutowired.class);
			Constructor<?> bindConstructor = this.provider.getBindConstructor(bean.getClass(), false);
			assertThat(bindConstructor).isNull();
		}
	}
	@Test
	void getBindConstructorWhenHasExistingValueAndOneConstructorWithoutAnnotationsReturnsNull() {
		OneConstructorWithoutAnnotations existingValue = new OneConstructorWithoutAnnotations('name', 123);
		Bindable<?> bindable = Bindable.of(OneConstructorWithoutAnnotations.class).withExistingValue(existingValue);
		Constructor<?> bindConstructor = this.provider.getBindConstructor(bindable, false);
		assertThat(bindConstructor).isNull();
	}
	@Test
	void getBindConstructorWhenHasExistingValueAndOneConstructorWithConstructorBindingReturnsConstructor() {
		OneConstructorWithConstructorBinding existingValue = new OneConstructorWithConstructorBinding('name', 123);
		Bindable<?> bindable = Bindable.of(OneConstructorWithConstructorBinding.class).withExistingValue(existingValue);
		Constructor<?> bindConstructor = this.provider.getBindConstructor(bindable, false);
		assertThat(bindConstructor).isNotNull();
	}
	@Test
	void getBindConstructorWhenHasExistingValueAndValueIsRecordReturnsConstructor() {
		OneConstructorOnRecord existingValue = new OneConstructorOnRecord('name', 123);
		Bindable<?> bindable = Bindable.of(OneConstructorOnRecord.class).withExistingValue(existingValue);
		Constructor<?> bindConstructor = this.provider.getBindConstructor(bindable, false);
		assertThat(bindConstructor).isNotNull();
	}
	static class OnlyDefaultConstructor {
	}
	static class MultipleAmbiguousConstructors {
		MultipleAmbiguousConstructors() {
		}
		MultipleAmbiguousConstructors(String name) {
		}
	}
	static class TwoConstructorsWithOneConstructorBinding {
		@ConstructorBinding
		TwoConstructorsWithOneConstructorBinding(String name) {
			this(name, 100);
		}
		TwoConstructorsWithOneConstructorBinding(String name, int age) {
		}
	}
	static class OneConstructorWithAutowired {
		@Autowired
		OneConstructorWithAutowired(String name, int age) {
		}
	}
	static class TwoConstructorsWithOneAutowired {
		@Autowired
		TwoConstructorsWithOneAutowired(String name) {
			this(name, 100);
		}
		TwoConstructorsWithOneAutowired(String name, int age) {
		}
	}
	static class TwoConstructorsWithOneAutowiredAndOneConstructorBinding {
		@Autowired
		TwoConstructorsWithOneAutowiredAndOneConstructorBinding(String name) {
			this(name, 100);
		}
		@ConstructorBinding
		TwoConstructorsWithOneAutowiredAndOneConstructorBinding(String name, int age) {
		}
	}
	static class OneConstructorWithConstructorBinding {
		@ConstructorBinding
		OneConstructorWithConstructorBinding(String name, int age) {
		}
	}
	static class OneConstructorWithoutAnnotations {
		OneConstructorWithoutAnnotations(String name, int age) {
		}
	}
	record OneConstructorOnRecord(String name, int age) {
	}
	static class TwoConstructorsWithBothConstructorBinding {
		@ConstructorBinding
		TwoConstructorsWithBothConstructorBinding(String name) {
			this(name, 100);
		}
		@ConstructorBinding
		TwoConstructorsWithBothConstructorBinding(String name, int age) {
		}
	}
	static final class TypeWithPrivateConstructor {
		private TypeWithPrivateConstructor(Environment environment) {
		}
	}
	static class MemberTypeWithPrivateConstructor {
		static final class Member {
			private Member(String name) {
			}
		}
	}
	@Configuration
	static class ProxiedWithOneConstructorWithAutowired {
		@Autowired
		ProxiedWithOneConstructorWithAutowired(Environment environment) {
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
@ExtendWith(MockitoExtension.class)
class BindConverterTests {
	@Mock
	private Consumer<PropertyEditorRegistry> propertyEditorInitializer;
	@Test
	void createWhenPropertyEditorInitializerIsNullShouldCreate() {
		BindConverter.get(null, null);
	}
	@Test
	void createWhenPropertyEditorInitializerIsNotNullShouldUseToInitialize() {
		BindConverter.get(null, this.propertyEditorInitializer);
		then(this.propertyEditorInitializer).should().accept(any(PropertyEditorRegistry.class));
	}
	@Test
	void canConvertWhenHasDefaultEditorShouldReturnTrue() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null);
		assertThat(bindConverter.canConvert('java.lang.RuntimeException', ResolvableType.forClass(Class.class)))
			.isTrue();
	}
	@Test
	void canConvertWhenHasCustomEditorShouldReturnTrue() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor);
		assertThat(bindConverter.canConvert('test', ResolvableType.forClass(SampleType.class))).isTrue();
	}
	@Test
	void canConvertWhenHasEditorByConventionShouldReturnTrue() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null);
		assertThat(bindConverter.canConvert('test', ResolvableType.forClass(ConventionType.class))).isTrue();
	}
	@Test
	void canConvertWhenHasEditorForCollectionElementShouldReturnTrue() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor);
		assertThat(bindConverter.canConvert('test', ResolvableType.forClassWithGenerics(List.class, SampleType.class)))
			.isTrue();
	}
	@Test
	void canConvertWhenHasEditorForArrayElementShouldReturnTrue() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor);
		assertThat(bindConverter.canConvert('test', ResolvableType.forClass(SampleType[].class))).isTrue();
	}
	@Test
	void canConvertWhenConversionServiceCanConvertShouldReturnTrue() {
		BindConverter bindConverter = getBindConverter(new SampleTypeConverter());
		assertThat(bindConverter.canConvert('test', ResolvableType.forClass(SampleType.class))).isTrue();
	}
	@Test
	void canConvertWhenNotPropertyEditorAndConversionServiceCannotConvertShouldReturnFalse() {
		BindConverter bindConverter = BindConverter.get(null, null);
		assertThat(bindConverter.canConvert('test', ResolvableType.forClass(SampleType.class))).isFalse();
	}
	@Test
	void convertWhenHasDefaultEditorShouldConvert() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null);
		Class<?> converted = bindConverter.convert('java.lang.RuntimeException', ResolvableType.forClass(Class.class));
		assertThat(converted).isEqualTo(RuntimeException.class);
	}
	@Test
	void convertWhenHasCustomEditorShouldConvert() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor);
		SampleType converted = bindConverter.convert('test', ResolvableType.forClass(SampleType.class));
		assertThat(converted.getText()).isEqualTo('test');
	}
	@Test
	void convertWhenHasEditorByConventionShouldConvert() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null);
		ConventionType converted = bindConverter.convert('test', ResolvableType.forClass(ConventionType.class));
		assertThat(converted.getText()).isEqualTo('test');
	}
	@Test
	void convertWhenHasEditorForCollectionElementShouldConvert() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor);
		List<SampleType> converted = bindConverter.convert('test',
				ResolvableType.forClassWithGenerics(List.class, SampleType.class));
		assertThat(converted).hasSize(1);
		assertThat(converted.get(0).getText()).isEqualTo('test');
	}
	@Test
	void convertWhenHasEditorForArrayElementShouldConvert() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor);
		SampleType[] converted = bindConverter.convert('test', ResolvableType.forClass(SampleType[].class));
		assertThat(converted).isNotEmpty();
		assertThat(converted[0].getText()).isEqualTo('test');
	}
	@Test
	void convertWhenConversionServiceCanConvertShouldConvert() {
		BindConverter bindConverter = getBindConverter(new SampleTypeConverter());
		SampleType converted = bindConverter.convert('test', ResolvableType.forClass(SampleType.class));
		assertThat(converted.getText()).isEqualTo('test');
	}
	@Test
	void convertWhenNotPropertyEditorAndConversionServiceCannotConvertShouldThrowException() {
		BindConverter bindConverter = BindConverter.get(null, null);
		assertThatExceptionOfType(ConverterNotFoundException.class)
			.isThrownBy(() -> bindConverter.convert('test', ResolvableType.forClass(SampleType.class)));
	}
	@Test
	void convertWhenConvertingToFileShouldExcludeFileEditor() {
		// For back compatibility we want true file conversion and not an accidental
		// classpath resource reference. See gh-12163
		BindConverter bindConverter = BindConverter.get(Collections.singletonList(new GenericConversionService()),
				null);
		File result = bindConverter.convert('.', ResolvableType.forClass(File.class));
		assertThat(result.getPath()).isEqualTo('.');
	}
	@Test
	void fallsBackToApplicationConversionService() {
		BindConverter bindConverter = BindConverter.get(Collections.singletonList(new GenericConversionService()),
				null);
		Duration result = bindConverter.convert('10s', ResolvableType.forClass(Duration.class));
		assertThat(result.getSeconds()).isEqualTo(10);
	}
	@Test // gh-27028
	void convertWhenConversionFailsThrowsConversionFailedExceptionRatherThanConverterNotFoundException() {
		BindConverter bindConverter = BindConverter.get(Collections.singletonList(new GenericConversionService()),
				null);
		assertThatExceptionOfType(ConversionFailedException.class)
			.isThrownBy(() -> bindConverter.convert('com.example.Missing', ResolvableType.forClass(Class.class)))
			.withRootCauseInstanceOf(ClassNotFoundException.class);
	}
	@Test
	void convertWhenUsingTypeConverterConversionServiceFromMultipleThreads() {
		BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor);
		ResolvableType type = ResolvableType.forClass(SampleType.class);
		List<Thread> threads = new ArrayList<>();
		List<SampleType> results = Collections.synchronizedList(new ArrayList<>());
		for (int i = 0; i < 40; i++) {
			threads.add(new Thread(() -> {
				for (int j = 0; j < 20; j++) {
					results.add(bindConverter.convert('test', type));
				}
			}));
		}
		threads.forEach(Thread::start);
		for (Thread thread : threads) {
			try {
				thread.join();
			}
			catch (InterruptedException ex) {
				// Ignore
			}
		}
		assertThat(results).isNotEmpty().doesNotContainNull();
	}
	private BindConverter getPropertyEditorOnlyBindConverter(
			Consumer<PropertyEditorRegistry> propertyEditorInitializer) {
		return BindConverter.get(Collections.singletonList(new ThrowingConversionService()), propertyEditorInitializer);
	}
	private BindConverter getBindConverter(Converter<?, ?> converter) {
		GenericConversionService conversionService = new GenericConversionService();
		conversionService.addConverter(converter);
		return BindConverter.get(Collections.singletonList(conversionService), null);
	}
	private void registerSampleTypeEditor(PropertyEditorRegistry registry) {
		registry.registerCustomEditor(SampleType.class, new SampleTypePropertyEditor());
	}
	static class SampleType {
		private String text;
		String getText() {
			return this.text;
		}
	}
	static class SampleTypePropertyEditor extends PropertyEditorSupport {
		@Override
		public void setAsText(String text) {
			setValue(null);
			if (text != null) {
				SampleType value = new SampleType();
				value.text = text;
				setValue(value);
			}
		}
	}
	static class SampleTypeConverter implements Converter<String, SampleType> {
		@Override
		public SampleType convert(String source) {
			SampleType result = new SampleType();
			result.text = source;
			return result;
		}
	}
	static class ConventionType {
		private String text;
		String getText() {
			return this.text;
		}
	}
	static class ConventionTypeEditor extends PropertyEditorSupport {
		@Override
		public void setAsText(String text) {
			ConventionType value = new ConventionType();
			value.text = text;
			setValue(value);
		}
	}
	/**
	 * {@link ConversionService} that always throws an {@link AssertionError}.
	 */
	static class ThrowingConversionService implements ConversionService {
		@Override
		public boolean canConvert(Class<?> sourceType, Class<?> targetType) {
			throw new AssertionError('Should not call conversion service');
		}
		@Override
		public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {
			throw new AssertionError('Should not call conversion service');
		}
		@Override
		public <T> T convert(Object source, Class<T> targetType) {
			throw new AssertionError('Should not call conversion service');
		}
		@Override
		public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {
			throw new AssertionError('Should not call conversion service');
		}
	}
}
/*
package org.springframework.boot.context.properties.bind;
/**
class BinderTests {
	private final List<ConfigurationPropertySource> sources = new ArrayList<>();
	private Binder binder = new Binder(this.sources);
	@Test
	void createWhenSourcesIsNullArrayShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Binder((ConfigurationPropertySource[]) null))
			.withMessageContaining('Sources must not be null');
	}
	@Test
	void createWhenSourcesIsNullIterableShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Binder((Iterable<ConfigurationPropertySource>) null))
			.withMessageContaining('Sources must not be null');
	}
	@Test
	void createWhenArraySourcesContainsNullElementShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Binder(new ConfigurationPropertySource[] { null }))
			.withMessageContaining('Sources must not contain null elements');
	}
	@Test
	void createWhenIterableSourcesContainsNullElementShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Binder(Collections.singletonList(null)))
			.withMessageContaining('Sources must not contain null elements');
	}
	@Test
	void bindWhenNameIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.binder.bind((ConfigurationPropertyName) null, Bindable.of(String.class),
					BindHandler.DEFAULT))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void bindWhenTargetIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.binder.bind(ConfigurationPropertyName.of('foo'), null, BindHandler.DEFAULT))
			.withMessageContaining('Target must not be null');
	}
	@Test
	void bindToValueWhenPropertyIsMissingShouldReturnUnbound() {
		this.sources.add(new MockConfigurationPropertySource());
		BindResult<String> result = this.binder.bind('foo', Bindable.of(String.class));
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindToValueShouldReturnPropertyValue() {
		this.sources.add(new MockConfigurationPropertySource('foo', 123));
		BindResult<Integer> result = this.binder.bind('foo', Bindable.of(Integer.class));
		assertThat(result.get()).isEqualTo(123);
	}
	@Test
	void bindToValueShouldReturnPropertyValueFromSecondSource() {
		this.sources.add(new MockConfigurationPropertySource('foo', 123));
		this.sources.add(new MockConfigurationPropertySource('bar', 234));
		BindResult<Integer> result = this.binder.bind('bar', Bindable.of(Integer.class));
		assertThat(result.get()).isEqualTo(234);
	}
	@Test
	void bindToValueShouldReturnConvertedPropertyValue() {
		this.sources.add(new MockConfigurationPropertySource('foo', '123'));
		BindResult<Integer> result = this.binder.bind('foo', Bindable.of(Integer.class));
		assertThat(result.get()).isEqualTo(123);
	}
	@Test
	void bindToValueWhenMultipleCandidatesShouldReturnFirst() {
		this.sources.add(new MockConfigurationPropertySource('foo', 123));
		this.sources.add(new MockConfigurationPropertySource('foo', 234));
		BindResult<Integer> result = this.binder.bind('foo', Bindable.of(Integer.class));
		assertThat(result.get()).isEqualTo(123);
	}
	@Test
	void bindToValueWithPlaceholdersShouldResolve() {
		StandardEnvironment environment = new StandardEnvironment();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(environment, 'bar=23');
		this.sources.add(new MockConfigurationPropertySource('foo', '1${bar}'));
		this.binder = new Binder(this.sources, new PropertySourcesPlaceholdersResolver(environment));
		BindResult<Integer> result = this.binder.bind('foo', Bindable.of(Integer.class));
		assertThat(result.get()).isEqualTo(123);
	}
	@Test
	void bindToValueWithMissingPlaceholderShouldResolveToValueWithPlaceholder() {
		StandardEnvironment environment = new StandardEnvironment();
		this.sources.add(new MockConfigurationPropertySource('foo', '${bar}'));
		this.binder = new Binder(this.sources, new PropertySourcesPlaceholdersResolver(environment));
		BindResult<String> result = this.binder.bind('foo', Bindable.of(String.class));
		assertThat(result.get()).isEqualTo('${bar}');
	}
	@Test
	void bindToValueWithCustomPropertyEditorShouldReturnConvertedValue() {
		this.binder = new Binder(this.sources, null, null,
				(registry) -> registry.registerCustomEditor(JavaBean.class, new JavaBeanPropertyEditor()));
		this.sources.add(new MockConfigurationPropertySource('foo', '123'));
		BindResult<JavaBean> result = this.binder.bind('foo', Bindable.of(JavaBean.class));
		assertThat(result.get().getValue()).isEqualTo('123');
	}
	@Test
	void bindToValueShouldTriggerOnSuccess() {
		this.sources.add(new MockConfigurationPropertySource('foo', '1', 'line1'));
		BindHandler handler = mockBindHandler();
		Bindable<Integer> target = Bindable.of(Integer.class);
		this.binder.bind('foo', target, handler);
		InOrder ordered = inOrder(handler);
		ordered.verify(handler).onSuccess(eq(ConfigurationPropertyName.of('foo')), eq(target), any(), eq(1));
	}
	@Test
	void bindOrCreateWhenNotBoundShouldTriggerOnCreate() {
		BindHandler handler = mock(BindHandler.class);
		Bindable<JavaBean> target = Bindable.of(JavaBean.class);
		this.binder.bindOrCreate('foo', target, handler);
		InOrder ordered = inOrder(handler);
		ordered.verify(handler).onCreate(eq(ConfigurationPropertyName.of('foo')), eq(target), any(), any());
	}
	@Test
	void bindToJavaBeanShouldReturnPopulatedBean() {
		this.sources.add(new MockConfigurationPropertySource('foo.value', 'bar'));
		JavaBean result = this.binder.bind('foo', Bindable.of(JavaBean.class)).get();
		assertThat(result.getValue()).isEqualTo('bar');
	}
	@Test
	void bindToJavaBeanWhenNonIterableShouldReturnPopulatedBean() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource('foo.value', 'bar');
		this.sources.add(source.nonIterable());
		JavaBean result = this.binder.bind('foo', Bindable.of(JavaBean.class)).get();
		assertThat(result.getValue()).isEqualTo('bar');
	}
	@Test
	void bindToJavaBeanWhenHasPropertyWithSameNameShouldStillBind() {
		// gh-10945
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', 'boom');
		source.put('foo.value', 'bar');
		this.sources.add(source);
		JavaBean result = this.binder.bind('foo', Bindable.of(JavaBean.class)).get();
		assertThat(result.getValue()).isEqualTo('bar');
	}
	@Test
	void bindToJavaBeanShouldTriggerOnSuccess() {
		this.sources.add(new MockConfigurationPropertySource('foo.value', 'bar', 'line1'));
		BindHandler handler = mockBindHandler();
		Bindable<JavaBean> target = Bindable.of(JavaBean.class);
		this.binder.bind('foo', target, handler);
		InOrder inOrder = inOrder(handler);
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo.value')), eq(Bindable.of(String.class)), any(), eq('bar'));
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo')), eq(target), any(), isA(JavaBean.class));
	}
	@Test
	void bindWhenHasCustomDefaultHandlerShouldTriggerOnSuccess() {
		this.sources.add(new MockConfigurationPropertySource('foo.value', 'bar', 'line1'));
		BindHandler handler = mockBindHandler();
		Binder binder = new Binder(this.sources, null, null, null, handler);
		Bindable<JavaBean> target = Bindable.of(JavaBean.class);
		binder.bind('foo', target);
		InOrder inOrder = inOrder(handler);
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo.value')), eq(Bindable.of(String.class)), any(), eq('bar'));
		inOrder.verify(handler)
			.onSuccess(eq(ConfigurationPropertyName.of('foo')), eq(target), any(), isA(JavaBean.class));
	}
	@Test
	void bindWhenHasMalformedDateShouldThrowException() {
		this.sources.add(new MockConfigurationPropertySource('foo', '2014-04-01T01:30:00.000-05:00'));
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.binder.bind('foo', Bindable.of(LocalDate.class)))
			.withCauseInstanceOf(ConversionFailedException.class);
	}
	@Test
	void bindWhenHasAnnotationsShouldChangeConvertedValue() {
		this.sources.add(new MockConfigurationPropertySource('foo', '2014-04-01T01:30:00.000-05:00'));
		DateTimeFormat annotation = AnnotationUtils.synthesizeAnnotation(
				Collections.singletonMap('iso', DateTimeFormat.ISO.DATE_TIME), DateTimeFormat.class, null);
		LocalDate result = this.binder.bind('foo', Bindable.of(LocalDate.class).withAnnotations(annotation)).get();
		assertThat(result).hasToString('2014-04-01');
	}
	@Test
	void bindToValidatedBeanWithResourceAndNonEnumerablePropertySource() {
		ConfigurationPropertySources.from(new PropertySource<String>('test') {
			@Override
			public Object getProperty(String name) {
				return null;
			}
		}).forEach(this.sources::add);
		Validator validator = new SpringValidatorAdapter(
				Validation.byDefaultProvider().configure().buildValidatorFactory().getValidator());
		this.binder.bind('foo', Bindable.of(ResourceBean.class), new ValidationBindHandler(validator));
	}
	@Test
	void bindToBeanWithCycle() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		this.sources.add(source.nonIterable());
		Bindable<CycleBean1> target = Bindable.of(CycleBean1.class);
		this.binder.bind('foo', target);
	}
	@Test
	@SuppressWarnings('rawtypes')
	void bindToBeanWithUnresolvableGenerics() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'hello');
		this.sources.add(source);
		Bindable<GenericBean> target = Bindable.of(GenericBean.class);
		this.binder.bind('foo', target);
	}
	@Test
	void bindWithEmptyPrefixShouldIgnorePropertiesWithEmptyName() {
		Map<String, Object> source = new HashMap<>();
		source.put('value', 'hello');
		source.put('', 'bar');
		Iterable<ConfigurationPropertySource> propertySources = ConfigurationPropertySources
			.from(new MapPropertySource('test', source));
		propertySources.forEach(this.sources::add);
		Bindable<JavaBean> target = Bindable.of(JavaBean.class);
		JavaBean result = this.binder.bind('', target).get();
		assertThat(result.getValue()).isEqualTo('hello');
	}
	@Test
	void bindOrCreateWhenBindSuccessfulShouldReturnBoundValue() {
		this.sources.add(new MockConfigurationPropertySource('foo.value', 'bar'));
		JavaBean result = this.binder.bindOrCreate('foo', Bindable.of(JavaBean.class));
		assertThat(result.getValue()).isEqualTo('bar');
		assertThat(result.getItems()).isEmpty();
	}
	@Test
	void bindOrCreateWhenUnboundShouldReturnCreatedValue() {
		JavaBean value = this.binder.bindOrCreate('foo', Bindable.of(JavaBean.class));
		assertThat(value).isNotNull();
		assertThat(value).isInstanceOf(JavaBean.class);
	}
	@Test
	void bindToJavaBeanWhenHandlerOnStartReturnsNullShouldReturnUnbound() { // gh-18129
		this.sources.add(new MockConfigurationPropertySource('foo.value', 'bar'));
		BindResult<JavaBean> result = this.binder.bind('foo', Bindable.of(JavaBean.class), new BindHandler() {
			@Override
			public <T> Bindable<T> onStart(ConfigurationPropertyName name, Bindable<T> target, BindContext context) {
				return null;
			}
		});
		assertThat(result.isBound()).isFalse();
	}
	@Test
	void bindToJavaBeanWithPublicConstructor() {
		Bindable<JavaBeanWithPublicConstructor> bindable = Bindable.of(JavaBeanWithPublicConstructor.class);
		JavaBeanWithPublicConstructor result = bindToJavaBeanWithPublicConstructor(bindable);
		assertThat(result.getValue()).isEqualTo('constructor');
	}
	@Test
	void bindToJavaBeanWithPublicConstructorWhenHasBindRestriction() {
		Bindable<JavaBeanWithPublicConstructor> bindable = Bindable.of(JavaBeanWithPublicConstructor.class)
			.withBindRestrictions(BindRestriction.NO_DIRECT_PROPERTY);
		JavaBeanWithPublicConstructor result = bindToJavaBeanWithPublicConstructor(bindable);
		assertThat(result.getValue()).isEqualTo('setter');
	}
	private JavaBeanWithPublicConstructor bindToJavaBeanWithPublicConstructor(
			Bindable<JavaBeanWithPublicConstructor> bindable) {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo', 'constructor');
		source.put('foo.value', 'setter');
		this.sources.add(source);
		return this.binder.bindOrCreate('foo', bindable);
	}
	private BindHandler mockBindHandler() {
		BindHandler handler = mock(BindHandler.class);
		given(handler.onStart(any(), any(), any())).willAnswer(InvocationArgument.index(1));
		given(handler.onCreate(any(), any(), any(), any())).willAnswer(InvocationArgument.index(3));
		given(handler.onSuccess(any(), any(), any(), any())).willAnswer(InvocationArgument.index(3));
		return handler;
	}
	static class JavaBean {
		private String value;
		private final List<String> items = Collections.emptyList();
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
		List<String> getItems() {
			return this.items;
		}
	}
	static class NestedJavaBean {
		private DefaultValuesBean valuesBean = new DefaultValuesBean();
		DefaultValuesBean getValuesBean() {
			return this.valuesBean;
		}
		void setValuesBean(DefaultValuesBean valuesBean) {
			this.valuesBean = valuesBean;
		}
	}
	static class DefaultValuesBean {
		private String value = 'hello';
		private final List<String> items = Collections.emptyList();
		String getValue() {
			return this.value;
		}
		void setValue(String value) {
			this.value = value;
		}
		List<String> getItems() {
			return this.items;
		}
	}
	public enum ExampleEnum {
		FOO_BAR, BAR_BAZ, BAZ_BOO
	}
	@Validated
	static class ResourceBean {
		private Resource resource;
		Resource getResource() {
			return this.resource;
		}
		void setResource(Resource resource) {
			this.resource = resource;
		}
	}
	static class CycleBean1 {
		private CycleBean2 two;
		CycleBean2 getTwo() {
			return this.two;
		}
		void setTwo(CycleBean2 two) {
			this.two = two;
		}
	}
	static class CycleBean2 {
		private CycleBean1 one;
		CycleBean1 getOne() {
			return this.one;
		}
		void setOne(CycleBean1 one) {
			this.one = one;
		}
	}
	static class GenericBean<T> {
		private T bar;
		T getBar() {
			return this.bar;
		}
		void setBar(T bar) {
			this.bar = bar;
		}
	}
	static class JavaBeanPropertyEditor extends PropertyEditorSupport {
		@Override
		public void setAsText(String text) {
			JavaBean value = new JavaBean();
			value.setValue(text);
			setValue(value);
		}
	}
	private static final class InvocationArgument<T> implements Answer<T> {
		private final int index;
		private InvocationArgument(int index) {
			this.index = index;
		}
		@Override
		public T answer(InvocationOnMock invocation) throws Throwable {
			return invocation.getArgument(this.index);
		}
		private static <T> InvocationArgument<T> index(int index) {
			return new InvocationArgument<>(index);
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
@SpringJUnitConfig
@TestPropertySource(properties = 'immutable.property=test-property-source')
class ConfigurationPropertiesTestBeanTests {
	@TestBean
	private ImmutableProperties properties;
	@Autowired
	private SomeConfiguration someConfiguration;
	@Test
	void propertiesCanBeOverriddenUsingTestBean() {
		assertThat(this.properties.property).isEqualTo('test-bean');
		assertThat(this.someConfiguration.properties.property).isEqualTo('test-bean');
	}
	static ImmutableProperties properties() {
		return new ImmutableProperties('test-bean');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ImmutableProperties.class)
	static class SomeConfiguration {
		private final ImmutableProperties properties;
		SomeConfiguration(ImmutableProperties properties) {
			this.properties = properties;
		}
	}
	@ConfigurationProperties('immutable')
	static class ImmutableProperties {
		private final String property;
		ImmutableProperties(String property) {
			this.property = property;
		}
		String getProperty() {
			return this.property;
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesScanRegistrarTests {
	private final DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	private final ConfigurationPropertiesScanRegistrar registrar = new ConfigurationPropertiesScanRegistrar(
			new MockEnvironment(), null);
	@Test
	void registerBeanDefinitionsShouldScanForConfigurationProperties() throws IOException {
		this.registrar.registerBeanDefinitions(getAnnotationMetadata(ConfigurationPropertiesScanConfiguration.class),
				this.beanFactory);
		BeanDefinition bingDefinition = this.beanFactory.getBeanDefinition(
				'bing-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$BingProperties');
		BeanDefinition fooDefinition = this.beanFactory.getBeanDefinition(
				'foo-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$FooProperties');
		BeanDefinition barDefinition = this.beanFactory.getBeanDefinition(
				'bar-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$BarProperties');
		assertThat(bingDefinition).satisfies(hasBindMethod(BindMethod.JAVA_BEAN));
		assertThat(fooDefinition).satisfies(hasBindMethod(BindMethod.JAVA_BEAN));
		assertThat(barDefinition).satisfies(hasBindMethod(BindMethod.VALUE_OBJECT));
	}
	@Test
	void scanWhenBeanDefinitionExistsShouldSkip() throws IOException {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		beanFactory.setAllowBeanDefinitionOverriding(false);
		this.registrar.registerBeanDefinitions(
				getAnnotationMetadata(ConfigurationPropertiesScanConfiguration.TestConfiguration.class), beanFactory);
		assertThat(beanFactory.containsBeanDefinition(
				'foo-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$FooProperties'))
			.isTrue();
		assertThat(beanFactory.getBeanDefinitionNames())
			.filteredOn((name) -> name.toLowerCase(Locale.ENGLISH).contains('fooproperties'))
			.hasSize(1);
	}
	@Test
	void scanWhenBasePackagesAndBasePackageClassesProvidedShouldUseThat() throws IOException {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		beanFactory.setAllowBeanDefinitionOverriding(false);
		this.registrar.registerBeanDefinitions(
				getAnnotationMetadata(ConfigurationPropertiesScanConfiguration.DifferentPackageConfiguration.class),
				beanFactory);
		assertThat(beanFactory.containsBeanDefinition(
				'foo-org.springframework.boot.context.properties.scan.valid.ConfigurationPropertiesScanConfiguration$FooProperties'))
			.isFalse();
		BeanDefinition aDefinition = beanFactory.getBeanDefinition(
				'a-org.springframework.boot.context.properties.scan.valid.a.AScanConfiguration$AProperties');
		BeanDefinition bFirstDefinition = beanFactory.getBeanDefinition(
				'b.first-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BFirstProperties');
		BeanDefinition bSecondDefinition = beanFactory.getBeanDefinition(
				'b.second-org.springframework.boot.context.properties.scan.valid.b.BScanConfiguration$BSecondProperties');
		assertThat(aDefinition).satisfies(hasBindMethod(BindMethod.JAVA_BEAN));
		// Constructor injection
		assertThat(bFirstDefinition).satisfies(hasBindMethod(BindMethod.VALUE_OBJECT));
		// Post-processing injection
		assertThat(bSecondDefinition).satisfies(hasBindMethod(BindMethod.JAVA_BEAN));
	}
	@Test
	void scanWhenComponentAnnotationPresentShouldSkipType() throws IOException {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		beanFactory.setAllowBeanDefinitionOverriding(false);
		this.registrar.registerBeanDefinitions(getAnnotationMetadata(CombinedScanConfiguration.class), beanFactory);
		assertThat(beanFactory.getBeanDefinitionCount()).isZero();
	}
	@Test
	void scanWhenOtherComponentAnnotationPresentShouldSkipType() throws IOException {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		beanFactory.setAllowBeanDefinitionOverriding(false);
		this.registrar.registerBeanDefinitions(getAnnotationMetadata(OtherCombinedScanConfiguration.class),
				beanFactory);
		assertThat(beanFactory.getBeanDefinitionCount()).isZero();
	}
	private Consumer<BeanDefinition> hasBindMethod(BindMethod bindMethod) {
		return (definition) -> {
			assertThat(definition.hasAttribute(BindMethod.class.getName())).isTrue();
			assertThat(definition.getAttribute(BindMethod.class.getName())).isEqualTo(bindMethod);
		};
	}
	private AnnotationMetadata getAnnotationMetadata(Class<?> source) throws IOException {
		return new SimpleMetadataReaderFactory().getMetadataReader(source.getName()).getAnnotationMetadata();
	}
	@ConfigurationPropertiesScan(basePackageClasses = CombinedConfiguration.class)
	static class CombinedScanConfiguration {
	}
	@ConfigurationPropertiesScan(basePackageClasses = OtherCombinedConfiguration.class)
	static class OtherCombinedScanConfiguration {
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SpringConfigurationPropertySourceTests {
	@Test
	void createWhenPropertySourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new SpringConfigurationPropertySource(null, mock(PropertyMapper.class)))
			.withMessageContaining('PropertySource must not be null');
	}
	@Test
	void getValueShouldUseDirectMapping() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key1', 'value1');
		source.put('key2', 'value2');
		source.put('key3', 'value3');
		PropertySource<?> propertySource = new MapPropertySource('test', source);
		TestPropertyMapper mapper = new TestPropertyMapper();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.key');
		mapper.addFromConfigurationProperty(name, 'key2');
		SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper);
		assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo('value2');
	}
	@Test
	void getValueOriginAndPropertySource() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key', 'value');
		PropertySource<?> propertySource = new MapPropertySource('test', source);
		TestPropertyMapper mapper = new TestPropertyMapper();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.key');
		mapper.addFromConfigurationProperty(name, 'key');
		SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper);
		ConfigurationProperty configurationProperty = adapter.getConfigurationProperty(name);
		assertThat(configurationProperty.getOrigin()).hasToString('\'key\' from property source \'test\'');
		assertThat(configurationProperty.getSource()).isEqualTo(adapter);
	}
	@Test
	void getValueWhenOriginCapableShouldIncludeSourceOrigin() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key', 'value');
		PropertySource<?> propertySource = new OriginCapablePropertySource<>(new MapPropertySource('test', source));
		TestPropertyMapper mapper = new TestPropertyMapper();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.key');
		mapper.addFromConfigurationProperty(name, 'key');
		SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper);
		assertThat(adapter.getConfigurationProperty(name).getOrigin()).hasToString('TestOrigin key');
	}
	@Test
	void containsDescendantOfShouldReturnEmpty() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('foo.bar', 'value');
		PropertySource<?> propertySource = new MapPropertySource('test', source);
		SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource,
				DefaultPropertyMapper.INSTANCE);
		assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of('foo')))
			.isEqualTo(ConfigurationPropertyState.UNKNOWN);
	}
	@Test
	void fromWhenPropertySourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> SpringConfigurationPropertySource.from(null))
			.withMessageContaining('Source must not be null');
	}
	@Test
	void fromWhenNonEnumerableShouldReturnNonIterable() {
		PropertySource<?> propertySource = new PropertySource<>('test', new Object()) {
			@Override
			public Object getProperty(String name) {
				return null;
			}
		};
		assertThat(SpringConfigurationPropertySource.from(propertySource))
			.isNotInstanceOf(IterableConfigurationPropertySource.class);
	}
	@Test
	void fromWhenEnumerableButRestrictedShouldReturnNonIterable() {
		Map<String, Object> source = new LinkedHashMap<>() {
			@Override
			public int size() {
				throw new UnsupportedOperationException('Same as security restricted');
			}
		};
		PropertySource<?> propertySource = new MapPropertySource('test', source);
		assertThat(SpringConfigurationPropertySource.from(propertySource))
			.isNotInstanceOf(IterableConfigurationPropertySource.class);
	}
	@Test
	void getWhenEnumerableShouldBeIterable() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('fooBar', 'Spring ${barBaz} ${bar-baz}');
		source.put('barBaz', 'Boot');
		PropertySource<?> propertySource = new MapPropertySource('test', source);
		assertThat(SpringConfigurationPropertySource.from(propertySource))
			.isInstanceOf(IterableConfigurationPropertySource.class);
	}
	@Test
	void containsDescendantOfWhenRandomSourceAndRandomPropertyReturnsPresent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomValuePropertySource());
		ConfigurationPropertyName name = ConfigurationPropertyName.of('random');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
		assertThat(source.getConfigurationProperty(name)).isNull();
	}
	@Test
	void containsDescendantOfWhenRandomSourceAndRandomPrefixedPropertyReturnsPresent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomValuePropertySource());
		ConfigurationPropertyName name = ConfigurationPropertyName.of('random.int');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.PRESENT);
		assertThat(source.getConfigurationProperty(name)).isNotNull();
	}
	@Test
	void containsDescendantOfWhenRandomSourceWithDifferentNameAndRandomPrefixedPropertyReturnsPresent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomValuePropertySource('different'));
		ConfigurationPropertyName name = ConfigurationPropertyName.of('random.int');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.PRESENT);
		assertThat(source.getConfigurationProperty(name)).isNotNull();
	}
	@Test
	void containsDescendantOfWhenRandomSourceAndNonRandomPropertyReturnsAbsent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomValuePropertySource());
		ConfigurationPropertyName name = ConfigurationPropertyName.of('abandon.int');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
		assertThat(source.getConfigurationProperty(name)).isNull();
	}
	@Test
	void containsDescendantOfWhenWrappedRandomSourceAndRandomPropertyReturnsPresent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomWrapperPropertySource());
		ConfigurationPropertyName name = ConfigurationPropertyName.of('cachedrandom');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
		assertThat(source.getConfigurationProperty(name)).isNull();
	}
	@Test
	void containsDescendantOfWhenWrappedRandomSourceAndRandomPrefixedPropertyReturnsPresent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomWrapperPropertySource());
		ConfigurationPropertyName name = ConfigurationPropertyName.of('cachedrandom.something.int');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
		assertThat(source.getConfigurationProperty(name)).isNull();
	}
	@Test
	void containsDescendantOfWhenWrappedRandomSourceWithMatchingNameAndRandomPrefixedPropertyReturnsPresent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomWrapperPropertySource('cachedrandom'));
		ConfigurationPropertyName name = ConfigurationPropertyName.of('cachedrandom.something.int');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.PRESENT);
		assertThat(source.getConfigurationProperty(name)).isNotNull();
	}
	@Test
	void containsDescendantOfWhenWrappedRandomSourceAndRandomDashPrefixedPropertyReturnsPresent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomWrapperPropertySource());
		ConfigurationPropertyName name = ConfigurationPropertyName.of('cached-random.something.int');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
		assertThat(source.getConfigurationProperty(name)).isNull();
	}
	@Test
	void containsDescendantOfWhenWrappedRandomSourceAndNonRandomPropertyReturnsAbsent() {
		SpringConfigurationPropertySource source = SpringConfigurationPropertySource
			.from(new RandomWrapperPropertySource());
		ConfigurationPropertyName name = ConfigurationPropertyName.of('abandon.something.int');
		assertThat(source.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
		assertThat(source.getConfigurationProperty(name)).isNull();
	}
	static class RandomWrapperPropertySource extends PropertySource<RandomValuePropertySource> {
		private final String prefix;
		RandomWrapperPropertySource() {
			this('cachedRandom');
		}
		RandomWrapperPropertySource(String name) {
			super(name, new RandomValuePropertySource());
			this.prefix = name + '.';
		}
		@Override
		public Object getProperty(String name) {
			name = name.toLowerCase(Locale.ROOT);
			if (!name.startsWith(this.prefix)) {
				return null;
			}
			return getSource().getProperty('random.' + name.substring(this.prefix.length()));
		}
	}
	/**
	 * Test {@link PropertySource} that"s also an {@link OriginLookup}.
	 *
	 * @param <T> The source type
	 */
	static class OriginCapablePropertySource<T> extends PropertySource<T> implements OriginLookup<String> {
		private final PropertySource<T> propertySource;
		OriginCapablePropertySource(PropertySource<T> propertySource) {
			super(propertySource.getName(), propertySource.getSource());
			this.propertySource = propertySource;
		}
		@Override
		public Object getProperty(String name) {
			return this.propertySource.getProperty(name);
		}
		@Override
		public Origin getOrigin(String name) {
			return new Origin() {
				@Override
				public String toString() {
					return 'TestOrigin ' + name;
				}
			};
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class MutuallyExclusiveConfigurationPropertiesExceptionTests {
	@Test
	void createWhenConfiguredNamesIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new MutuallyExclusiveConfigurationPropertiesException(null, Arrays.asList('a', 'b')))
			.withMessage('ConfiguredNames must contain 2 or more names');
	}
	@Test
	void createWhenConfiguredNamesContainsOneElementThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new MutuallyExclusiveConfigurationPropertiesException(Collections.singleton('a'),
					Arrays.asList('a', 'b')))
			.withMessage('ConfiguredNames must contain 2 or more names');
	}
	@Test
	void createWhenMutuallyExclusiveNamesIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new MutuallyExclusiveConfigurationPropertiesException(Arrays.asList('a', 'b'), null))
			.withMessage('MutuallyExclusiveNames must contain 2 or more names');
	}
	@Test
	void createWhenMutuallyExclusiveNamesContainsOneElementThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new MutuallyExclusiveConfigurationPropertiesException(Arrays.asList('a', 'b'),
					Collections.singleton('a')))
			.withMessage('MutuallyExclusiveNames must contain 2 or more names');
	}
	@Test
	void createBuildsSensibleMessage() {
		List<String> names = Arrays.asList('a', 'b');
		assertThat(new MutuallyExclusiveConfigurationPropertiesException(names, names))
			.hasMessage('The configuration properties "a, b" are mutually exclusive '
					+ 'and "a, b" have been configured together');
	}
	@Test
	void getConfiguredNamesReturnsConfiguredNames() {
		List<String> configuredNames = Arrays.asList('a', 'b');
		List<String> mutuallyExclusiveNames = Arrays.asList('a', 'b', 'c');
		MutuallyExclusiveConfigurationPropertiesException exception = new MutuallyExclusiveConfigurationPropertiesException(
				configuredNames, mutuallyExclusiveNames);
		assertThat(exception.getConfiguredNames()).hasSameElementsAs(configuredNames);
	}
	@Test
	void getMutuallyExclusiveNamesReturnsMutuallyExclusiveNames() {
		List<String> configuredNames = Arrays.asList('a', 'b');
		List<String> mutuallyExclusiveNames = Arrays.asList('a', 'b', 'c');
		MutuallyExclusiveConfigurationPropertiesException exception = new MutuallyExclusiveConfigurationPropertiesException(
				configuredNames, mutuallyExclusiveNames);
		assertThat(exception.getMutuallyExclusiveNames()).hasSameElementsAs(mutuallyExclusiveNames);
	}
	@Test
	void throwIfMultipleNonNullValuesInWhenEntriesHasAllNullsDoesNotThrowException() {
		assertThatNoException().isThrownBy(
				() -> MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
					entries.put('a', null);
					entries.put('b', null);
					entries.put('c', null);
				}));
	}
	@Test
	void throwIfMultipleNonNullValuesInWhenEntriesHasSingleNonNullDoesNotThrowException() {
		assertThatNoException().isThrownBy(
				() -> MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
					entries.put('a', null);
					entries.put('b', 'B');
					entries.put('c', null);
				}));
	}
	@Test
	void throwIfMultipleNonNullValuesInWhenEntriesHasTwoNonNullsThrowsException() {
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class).isThrownBy(
				() -> MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
					entries.put('a', 'a');
					entries.put('b', 'B');
					entries.put('c', null);
				}))
			.satisfies((ex) -> {
				assertThat(ex.getConfiguredNames()).containsExactly('a', 'b');
				assertThat(ex.getMutuallyExclusiveNames()).containsExactly('a', 'b', 'c');
			});
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SpringConfigurationPropertySourcesTests {
	@Test
	void createWhenPropertySourcesIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new SpringConfigurationPropertySources(null))
			.withMessageContaining('Sources must not be null');
	}
	@Test
	void shouldAdaptPropertySource() {
		MutablePropertySources sources = new MutablePropertySources();
		sources.addFirst(new MapPropertySource('test', Collections.singletonMap('a', 'b')));
		Iterator<ConfigurationPropertySource> iterator = new SpringConfigurationPropertySources(sources).iterator();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('a');
		assertThat(iterator.next().getConfigurationProperty(name).getValue()).isEqualTo('b');
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void shouldAdaptSystemEnvironmentPropertySource() {
		MutablePropertySources sources = new MutablePropertySources();
		sources.addLast(new SystemEnvironmentPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				Collections.singletonMap('SERVER_PORT', '1234')));
		Iterator<ConfigurationPropertySource> iterator = new SpringConfigurationPropertySources(sources).iterator();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('server.port');
		assertThat(iterator.next().getConfigurationProperty(name).getValue()).isEqualTo('1234');
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void shouldExtendedAdaptSystemEnvironmentPropertySource() {
		MutablePropertySources sources = new MutablePropertySources();
		sources.addLast(new SystemEnvironmentPropertySource(
				'test-' + StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				Collections.singletonMap('SERVER_PORT', '1234')));
		Iterator<ConfigurationPropertySource> iterator = new SpringConfigurationPropertySources(sources).iterator();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('server.port');
		assertThat(iterator.next().getConfigurationProperty(name).getValue()).isEqualTo('1234');
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void shouldNotAdaptSystemEnvironmentPropertyOverrideSource() {
		MutablePropertySources sources = new MutablePropertySources();
		sources
			.addLast(new SystemEnvironmentPropertySource('override', Collections.singletonMap('server.port', '1234')));
		Iterator<ConfigurationPropertySource> iterator = new SpringConfigurationPropertySources(sources).iterator();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('server.port');
		assertThat(iterator.next().getConfigurationProperty(name).getValue()).isEqualTo('1234');
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void shouldAdaptSystemEnvironmentPropertySourceWithUnderscoreValue() {
		MutablePropertySources sources = new MutablePropertySources();
		sources.addLast(new SystemEnvironmentPropertySource(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME,
				Collections.singletonMap('_', '1234')));
		Iterator<ConfigurationPropertySource> iterator = new SpringConfigurationPropertySources(sources).iterator();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('bar');
		assertThat(iterator.next().getConfigurationProperty(name)).isNull();
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void shouldAdaptMultiplePropertySources() {
		MutablePropertySources sources = new MutablePropertySources();
		sources.addLast(new SystemEnvironmentPropertySource('system', Collections.singletonMap('SERVER_PORT', '1234')));
		sources.addLast(new MapPropertySource('test1', Collections.singletonMap('server.po-rt', '4567')));
		sources.addLast(new MapPropertySource('test2', Collections.singletonMap('a', 'b')));
		Iterator<ConfigurationPropertySource> iterator = new SpringConfigurationPropertySources(sources).iterator();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('server.port');
		assertThat(iterator.next().getConfigurationProperty(name).getValue()).isEqualTo('1234');
		assertThat(iterator.next().getConfigurationProperty(name).getValue()).isEqualTo('4567');
		assertThat(iterator.next().getConfigurationProperty(ConfigurationPropertyName.of('a')).getValue())
			.isEqualTo('b');
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void shouldFlattenEnvironment() {
		StandardEnvironment environment = new StandardEnvironment();
		environment.getPropertySources().addFirst(new MapPropertySource('foo', Collections.singletonMap('foo', 'bar')));
		environment.getPropertySources().addFirst(new MapPropertySource('far', Collections.singletonMap('far', 'far')));
		MutablePropertySources sources = new MutablePropertySources();
		sources.addFirst(new PropertySource<Environment>('env', environment) {
			@Override
			public String getProperty(String key) {
				return this.source.getProperty(key);
			}
		});
		sources.addLast(new MapPropertySource('baz', Collections.singletonMap('baz', 'barf')));
		SpringConfigurationPropertySources configurationSources = new SpringConfigurationPropertySources(sources);
		assertThat(configurationSources.iterator()).toIterable().hasSize(5);
	}
	@Test
	void shouldTrackChanges() {
		MutablePropertySources sources = new MutablePropertySources();
		SpringConfigurationPropertySources configurationSources = new SpringConfigurationPropertySources(sources);
		assertThat(configurationSources.iterator()).toIterable().isEmpty();
		MapPropertySource source1 = new MapPropertySource('test1', Collections.singletonMap('a', 'b'));
		sources.addLast(source1);
		assertThat(configurationSources.iterator()).toIterable().hasSize(1);
		MapPropertySource source2 = new MapPropertySource('test2', Collections.singletonMap('b', 'c'));
		sources.addLast(source2);
		assertThat(configurationSources.iterator()).toIterable().hasSize(2);
	}
	@Test
	void shouldTrackWhenSourceHasIdenticalName() {
		MutablePropertySources sources = new MutablePropertySources();
		SpringConfigurationPropertySources configurationSources = new SpringConfigurationPropertySources(sources);
		ConfigurationPropertyName name = ConfigurationPropertyName.of('a');
		MapPropertySource source1 = new MapPropertySource('test', Collections.singletonMap('a', 's1'));
		sources.addLast(source1);
		assertThat(configurationSources.iterator().next().getConfigurationProperty(name).getValue()).isEqualTo('s1');
		MapPropertySource source2 = new MapPropertySource('test', Collections.singletonMap('a', 's2'));
		sources.remove('test');
		sources.addLast(source2);
		assertThat(configurationSources.iterator().next().getConfigurationProperty(name).getValue()).isEqualTo('s2');
	}
	@Test // gh-21659
	void shouldAdaptRandomPropertySource() {
		MutablePropertySources sources = new MutablePropertySources();
		sources.addFirst(new RandomValuePropertySource());
		Iterator<ConfigurationPropertySource> iterator = new SpringConfigurationPropertySources(sources).iterator();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('random.int');
		assertThat(iterator.next().getConfigurationProperty(name).getValue()).isNotNull();
		assertThat(iterator.hasNext()).isFalse();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourcesTests {
	@Test
	void attachShouldAddAdapterAtBeginning() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		MutablePropertySources sources = environment.getPropertySources();
		sources.addLast(new SystemEnvironmentPropertySource('system', Collections.singletonMap('SERVER_PORT', '1234')));
		sources.addLast(new MapPropertySource('config', Collections.singletonMap('server.port', '4568')));
		int size = sources.size();
		ConfigurationPropertySources.attach(environment);
		assertThat(sources).hasSize(size + 1);
		PropertyResolver resolver = new PropertySourcesPropertyResolver(sources);
		assertThat(resolver.getProperty('server.port')).isEqualTo('1234');
	}
	@Test
	void attachShouldReattachInMergedSetup() {
		ConfigurableEnvironment parent = new StandardEnvironment();
		ConfigurationPropertySources.attach(parent);
		ConfigurableEnvironment child = new StandardEnvironment();
		child.merge(parent);
		child.getPropertySources()
			.addLast(new MapPropertySource('config', Collections.singletonMap('my.example_property', '1234')));
		ConfigurationPropertySources.attach(child);
		assertThat(child.getProperty('my.example-property')).isEqualTo('1234');
	}
	@Test
	void attachWhenAlreadyAttachedWithSameSourcesShouldReturnExistingInstance() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		MutablePropertySources sources = environment.getPropertySources();
		sources.addLast(new SystemEnvironmentPropertySource('system', Collections.singletonMap('SERVER_PORT', '1234')));
		sources.addLast(new MapPropertySource('config', Collections.singletonMap('server.port', '4568')));
		ConfigurationPropertySources.attach(environment);
		Iterable<ConfigurationPropertySource> first = ConfigurationPropertySources.get(environment);
		ConfigurationPropertySources.attach(environment);
		Iterable<ConfigurationPropertySource> second = ConfigurationPropertySources.get(environment);
		assertThat(first).isSameAs(second);
	}
	@Test
	void getWhenNotAttachedShouldReturnAdapted() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		assertThat(ConfigurationPropertySources.get(environment)).isNotEmpty();
	}
	@Test
	void getWhenAttachedShouldReturnAttached() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		MutablePropertySources sources = environment.getPropertySources();
		sources.addFirst(new MapPropertySource('test', Collections.singletonMap('a', 'b')));
		int expectedSize = sources.size();
		ConfigurationPropertySources.attach(environment);
		assertThat(ConfigurationPropertySources.get(environment)).hasSize(expectedSize);
	}
	@Test
	void environmentPropertyExpansionShouldWorkWhenAttached() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('fooBar', 'Spring ${barBaz} ${bar-baz}');
		source.put('barBaz', 'Boot');
		PropertySource<?> propertySource = new MapPropertySource('test', source);
		environment.getPropertySources().addFirst(propertySource);
		ConfigurationPropertySources.attach(environment);
		assertThat(environment.getProperty('foo-bar')).isEqualTo('Spring Boot Boot');
	}
	@Test
	void fromPropertySourceShouldReturnSpringConfigurationPropertySource() {
		PropertySource<?> source = new MapPropertySource('foo', Collections.singletonMap('foo', 'bar'));
		ConfigurationPropertySource configurationPropertySource = ConfigurationPropertySources.from(source)
			.iterator()
			.next();
		assertThat(configurationPropertySource).isInstanceOf(SpringConfigurationPropertySource.class);
	}
	@Test
	void fromPropertySourceShouldFlattenPropertySources() {
		StandardEnvironment environment = new StandardEnvironment();
		environment.getPropertySources().addFirst(new MapPropertySource('foo', Collections.singletonMap('foo', 'bar')));
		environment.getPropertySources().addFirst(new MapPropertySource('far', Collections.singletonMap('far', 'far')));
		MutablePropertySources sources = new MutablePropertySources();
		sources.addFirst(new PropertySource<Environment>('env', environment) {
			@Override
			public String getProperty(String key) {
				return this.source.getProperty(key);
			}
		});
		sources.addLast(new MapPropertySource('baz', Collections.singletonMap('baz', 'barf')));
		Iterable<ConfigurationPropertySource> configurationSources = ConfigurationPropertySources.from(sources);
		assertThat(configurationSources.iterator()).toIterable().hasSize(5);
	}
	@Test // gh-20625
	void environmentPropertyAccessWhenImmutableShouldBePerformant() {
		long baseline = testPropertySourcePerformance(false);
		long immutable = testPropertySourcePerformance(true);
		assertThat(immutable).isLessThan(baseline / 2);
	}
	@Test // gh-20625
	void environmentPropertyAccessWhenMutableWithCacheShouldBePerformant() {
		StandardEnvironment environment = createPerformanceTestEnvironment(false);
		long uncached = testPropertySourcePerformance(environment);
		ConfigurationPropertyCaching.get(environment).enable();
		long cached = testPropertySourcePerformance(environment);
		assertThat(cached).isLessThan(uncached / 2);
	}
	@Test // gh-20625
	@Disabled('for manual testing')
	void environmentPropertyAccessWhenMutableShouldBeTolerable() {
		assertThat(testPropertySourcePerformance(false)).isLessThan(5000);
	}
	@Test // gh-21416
	void descendantOfPropertyAccessWhenMutableWithCacheShouldBePerformant() {
		Function<StandardEnvironment, Long> descendantOfPerformance = (environment) -> {
			Iterable<ConfigurationPropertySource> sources = ConfigurationPropertySources.get(environment);
			ConfigurationPropertyName missing = ConfigurationPropertyName.of('missing');
			long start = System.nanoTime();
			for (int i = 0; i < 1000; i++) {
				for (ConfigurationPropertySource source : sources) {
					assertThat(source.containsDescendantOf(missing)).isEqualTo(ConfigurationPropertyState.ABSENT);
				}
			}
			return TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
		};
		StandardEnvironment environment = createPerformanceTestEnvironment(false);
		long baseline = descendantOfPerformance.apply(environment);
		ConfigurationPropertyCaching.get(environment).enable();
		long cached = descendantOfPerformance.apply(environment);
		assertThat(cached).isLessThan(baseline / 2);
	}
	private long testPropertySourcePerformance(boolean immutable) {
		StandardEnvironment environment = createPerformanceTestEnvironment(immutable);
		return testPropertySourcePerformance(environment);
	}
	private StandardEnvironment createPerformanceTestEnvironment(boolean immutable) {
		StandardEnvironment environment = new StandardEnvironment();
		MutablePropertySources propertySources = environment.getPropertySources();
		for (int i = 0; i < 100; i++) {
			propertySources.addLast(new TestPropertySource(i, immutable));
		}
		ConfigurationPropertySources.attach(environment);
		return environment;
	}
	private long testPropertySourcePerformance(StandardEnvironment environment) {
		long start = System.nanoTime();
		for (int i = 0; i < 1000; i++) {
			environment.getProperty('missing' + i);
		}
		long total = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);
		assertThat(environment.getProperty('test-10-property-80')).isEqualTo('test-10-property-80-value');
		return total;
	}
	static class TestPropertySource extends MapPropertySource implements OriginLookup<String> {
		private final boolean immutable;
		TestPropertySource(int index, boolean immutable) {
			super('test-' + index, createProperties(index));
			this.immutable = immutable;
		}
		private static Map<String, Object> createProperties(int index) {
			Map<String, Object> map = new LinkedHashMap<>();
			for (int i = 0; i < 1000; i++) {
				String name = 'test-' + index + '-property-' + i;
				String value = name + '-value';
				map.put(name, value);
			}
			return map;
		}
		@Override
		public Origin getOrigin(String key) {
			return null;
		}
		@Override
		public boolean isImmutable() {
			return this.immutable;
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertyStateTests {
	@Test
	void searchWhenIterableIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ConfigurationPropertyState.search(null, (e) -> true))
			.withMessageContaining('Source must not be null');
	}
	@Test
	void searchWhenPredicateIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ConfigurationPropertyState.search(Collections.emptyList(), null))
			.withMessageContaining('Predicate must not be null');
	}
	@Test
	void searchWhenContainsItemShouldReturnPresent() {
		List<String> source = Arrays.asList('a', 'b', 'c');
		ConfigurationPropertyState result = ConfigurationPropertyState.search(source, 'b'::equals);
		assertThat(result).isEqualTo(ConfigurationPropertyState.PRESENT);
	}
	@Test
	void searchWhenContainsNoItemShouldReturnAbsent() {
		List<String> source = Arrays.asList('a', 'x', 'c');
		ConfigurationPropertyState result = ConfigurationPropertyState.search(source, 'b'::equals);
		assertThat(result).isEqualTo(ConfigurationPropertyState.ABSENT);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourceTests {
	@Test
	void fromCreatesConfigurationPropertySourcesPropertySource() {
		MockPropertySource source = new MockPropertySource();
		source.setProperty('spring', 'boot');
		ConfigurationPropertySource adapted = ConfigurationPropertySource.from(source);
		assertThat(adapted.getConfigurationProperty(ConfigurationPropertyName.of('spring')).getValue())
			.isEqualTo('boot');
	}
	@Test
	void fromWhenSourceIsAlreadyConfigurationPropertySourcesPropertySourceReturnsNull() {
		ConfigurationPropertySourcesPropertySource source = mock(ConfigurationPropertySourcesPropertySource.class);
		assertThat(ConfigurationPropertySource.from(source)).isNull();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SystemEnvironmentPropertyMapperTests extends AbstractPropertyMapperTests {
	@Override
	protected PropertyMapper getMapper() {
		return SystemEnvironmentPropertyMapper.INSTANCE;
	}
	@Test
	void mapFromStringShouldReturnBestGuess() {
		assertThat(mapPropertySourceName('SERVER')).isEqualTo('server');
		assertThat(mapPropertySourceName('SERVER_PORT')).isEqualTo('server.port');
		assertThat(mapPropertySourceName('HOST_0')).isEqualTo('host[0]');
		assertThat(mapPropertySourceName('HOST_0_1')).isEqualTo('host[0][1]');
		assertThat(mapPropertySourceName('HOST_0_NAME')).isEqualTo('host[0].name');
		assertThat(mapPropertySourceName('HOST_F00_NAME')).isEqualTo('host.f00.name');
		assertThat(mapPropertySourceName('S-ERVER')).isEqualTo('s-erver');
	}
	@Test
	void mapFromConfigurationShouldReturnBestGuess() {
		assertThat(mapConfigurationPropertyName('server')).containsExactly('SERVER');
		assertThat(mapConfigurationPropertyName('server.port')).containsExactly('SERVER_PORT');
		assertThat(mapConfigurationPropertyName('host[0]')).containsExactly('HOST_0');
		assertThat(mapConfigurationPropertyName('host[0][1]')).containsExactly('HOST_0_1');
		assertThat(mapConfigurationPropertyName('host[0].name')).containsExactly('HOST_0_NAME');
		assertThat(mapConfigurationPropertyName('host.f00.name')).containsExactly('HOST_F00_NAME');
		assertThat(mapConfigurationPropertyName('foo.the-bar')).containsExactly('FOO_THEBAR', 'FOO_THE_BAR');
	}
	@Test
	void underscoreShouldMapToEmptyString() {
		ConfigurationPropertyName mapped = getMapper().map('_');
		assertThat(mapped.isEmpty()).isTrue();
	}
	@Test
	void underscoreWithWhitespaceShouldMapToEmptyString() {
		ConfigurationPropertyName mapped = getMapper().map(' _');
		assertThat(mapped.isEmpty()).isTrue();
	}
	@Test
	void isAncestorOfConsidersLegacyNames() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.spring-boot');
		BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> check = getMapper().getAncestorOfCheck();
		assertThat(check.test(name, ConfigurationPropertyName.adapt('MY_SPRING_BOOT_PROPERTY', "_"))).isTrue();
		assertThat(check.test(name, ConfigurationPropertyName.adapt('MY_SPRINGBOOT_PROPERTY', "_"))).isTrue();
		assertThat(check.test(name, ConfigurationPropertyName.adapt('MY_BOOT_PROPERTY', "_"))).isFalse();
	}
	@Test
	void isAncestorOfWhenNonCanonicalSource() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('my.springBoot', ".");
		BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> check = getMapper().getAncestorOfCheck();
		assertThat(check.test(name, ConfigurationPropertyName.of('my.spring-boot.property'))).isTrue();
		assertThat(check.test(name, ConfigurationPropertyName.of('my.springboot.property'))).isTrue();
		assertThat(check.test(name, ConfigurationPropertyName.of('my.boot.property'))).isFalse();
	}
	@Test
	void isAncestorOfWhenNonCanonicalAndDashedSource() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('my.springBoot.input-value', ".");
		BiPredicate<ConfigurationPropertyName, ConfigurationPropertyName> check = getMapper().getAncestorOfCheck();
		assertThat(check.test(name, ConfigurationPropertyName.of('my.spring-boot.input-value.property'))).isTrue();
		assertThat(check.test(name, ConfigurationPropertyName.of('my.springboot.inputvalue.property'))).isTrue();
		assertThat(check.test(name, ConfigurationPropertyName.of('my.boot.property'))).isFalse();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class AliasedConfigurationPropertySourceTests {
	@Test
	void getConfigurationPropertyShouldConsiderAliases() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'bing');
		source.put('foo.baz', 'biff');
		ConfigurationPropertySource aliased = source.nonIterable()
			.withAliases(new ConfigurationPropertyNameAliases('foo.bar', 'foo.bar1'));
		assertThat(getValue(aliased, 'foo.bar')).isEqualTo('bing');
		assertThat(getValue(aliased, 'foo.bar1')).isEqualTo('bing');
	}
	@Test
	void getConfigurationPropertyWhenNotAliasesShouldReturnValue() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'bing');
		source.put('foo.baz', 'biff');
		ConfigurationPropertySource aliased = source.nonIterable()
			.withAliases(new ConfigurationPropertyNameAliases('foo.bar', 'foo.bar1'));
		assertThat(getValue(aliased, 'foo.baz')).isEqualTo('biff');
	}
	@Test
	void containsDescendantOfWhenSourceReturnsUnknownShouldReturnUnknown() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().unknown(name);
		ConfigurationPropertySource aliased = source
			.withAliases(new ConfigurationPropertyNameAliases('foo.bar', 'foo.bar1'));
		assertThat(aliased.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.UNKNOWN);
	}
	@Test
	void containsDescendantOfWhenSourceReturnsPresentShouldReturnPresent() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().present(name)
			.unknown(ConfigurationPropertyName.of('bar'));
		ConfigurationPropertySource aliased = source
			.withAliases(new ConfigurationPropertyNameAliases('foo.bar', 'foo.bar1'));
		assertThat(aliased.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.PRESENT);
	}
	@Test
	void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().absent(name)
			.absent(ConfigurationPropertyName.of('bar'));
		ConfigurationPropertySource aliased = source.withAliases(new ConfigurationPropertyNameAliases('foo', 'bar'));
		assertThat(aliased.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
	}
	@Test
	void containsDescendantOfWhenAnyIsPresentShouldReturnPresent() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().absent(name)
			.present(ConfigurationPropertyName.of('bar'));
		ConfigurationPropertySource aliased = source.withAliases(new ConfigurationPropertyNameAliases('foo', 'bar'));
		assertThat(aliased.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.PRESENT);
	}
	@Test
	void containsDescendantOfWhenPresentInAliasShouldReturnPresent() {
		ConfigurationPropertySource source = new MapConfigurationPropertySource(
				Collections.singletonMap('foo.bar', 'foobar'));
		ConfigurationPropertySource aliased = source
			.withAliases(new ConfigurationPropertyNameAliases('foo.bar', 'baz.foo'));
		assertThat(aliased.containsDescendantOf(ConfigurationPropertyName.of('baz')))
			.isEqualTo(ConfigurationPropertyState.PRESENT);
	}
	private Object getValue(ConfigurationPropertySource source, String name) {
		ConfigurationProperty property = source.getConfigurationProperty(ConfigurationPropertyName.of(name));
		return (property != null) ? property.getValue() : null;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class MapConfigurationPropertySourceTests {
	@Test
	void createWhenMapIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new MapConfigurationPropertySource(null))
			.withMessageContaining('Map must not be null');
	}
	@Test
	void createWhenMapHasEntriesShouldAdaptMap() {
		Map<Object, Object> map = new LinkedHashMap<>();
		map.put('foo.BAR', 'spring');
		map.put(ConfigurationPropertyName.of('foo.baz'), 'boot');
		MapConfigurationPropertySource source = new MapConfigurationPropertySource(map);
		assertThat(getValue(source, 'foo.bar')).isEqualTo('spring');
		assertThat(getValue(source, 'foo.baz')).isEqualTo('boot');
	}
	@Test
	void putAllWhenMapIsNullShouldThrowException() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		assertThatIllegalArgumentException().isThrownBy(() -> source.putAll(null))
			.withMessageContaining('Map must not be null');
	}
	@Test
	void putAllShouldPutEntries() {
		Map<Object, Object> map = new LinkedHashMap<>();
		map.put('foo.BAR', 'spring');
		map.put('foo.baz', 'boot');
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.putAll(map);
		assertThat(getValue(source, 'foo.bar')).isEqualTo('spring');
		assertThat(getValue(source, 'foo.baz')).isEqualTo('boot');
	}
	@Test
	void putShouldPutEntry() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('foo.bar', 'baz');
		assertThat(getValue(source, 'foo.bar')).isEqualTo('baz');
	}
	@Test
	void getConfigurationPropertyShouldGetFromMemory() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('foo.bar', 'baz');
		assertThat(getValue(source, 'foo.bar')).isEqualTo('baz');
		source.put('foo.bar', 'big');
		assertThat(getValue(source, 'foo.bar')).isEqualTo('big');
	}
	@Test
	void iteratorShouldGetFromMemory() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('foo.BAR', 'spring');
		source.put('foo.baz', 'boot');
		assertThat(source.iterator()).toIterable()
			.containsExactly(ConfigurationPropertyName.of('foo.bar'), ConfigurationPropertyName.of('foo.baz'));
	}
	@Test
	void streamShouldGetFromMemory() {
		MapConfigurationPropertySource source = new MapConfigurationPropertySource();
		source.put('foo.BAR', 'spring');
		source.put('foo.baz', 'boot');
		assertThat(source.stream()).containsExactly(ConfigurationPropertyName.of('foo.bar'),
				ConfigurationPropertyName.of('foo.baz'));
	}
	private Object getValue(ConfigurationPropertySource source, String name) {
		ConfigurationProperty property = source.getConfigurationProperty(ConfigurationPropertyName.of(name));
		return (property != null) ? property.getValue() : null;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public abstract class AbstractPropertyMapperTests {
	protected abstract PropertyMapper getMapper();
	protected final List<String> mapConfigurationPropertyName(String configurationPropertyName) {
		return getMapper().map(ConfigurationPropertyName.of(configurationPropertyName));
	}
	protected final String mapPropertySourceName(String propertySourceName) {
		return getMapper().map(propertySourceName).toString();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourcesCachingTests {
	private List<ConfigurationPropertySource> sources;
	private ConfigurationPropertySourcesCaching caching;
	@BeforeEach
	void setup() {
		this.sources = new ArrayList<>();
		for (int i = 0; i < 4; i++) {
			this.sources.add(mockSource(i % 2 == 0));
		}
		this.caching = new ConfigurationPropertySourcesCaching(this.sources);
	}
	private ConfigurationPropertySource mockSource(boolean cachingSource) {
		if (!cachingSource) {
			return mock(ConfigurationPropertySource.class);
		}
		ConfigurationPropertySource source = mock(ConfigurationPropertySource.class,
				withSettings().extraInterfaces(CachingConfigurationPropertySource.class));
		ConfigurationPropertyCaching caching = mock(ConfigurationPropertyCaching.class);
		given(((CachingConfigurationPropertySource) source).getCaching()).willReturn(caching);
		return source;
	}
	@Test
	void enableDelegatesToCachingConfigurationPropertySources() {
		this.caching.enable();
		then(getCaching(0)).should().enable();
		then(getCaching(2)).should().enable();
	}
	@Test
	void enableWhenSourcesIsNullDoesNothing() {
		new ConfigurationPropertySourcesCaching(null).enable();
	}
	@Test
	void disableDelegatesToCachingConfigurationPropertySources() {
		this.caching.disable();
		then(getCaching(0)).should().disable();
		then(getCaching(2)).should().disable();
	}
	@Test
	void disableWhenSourcesIsNullDoesNothing() {
		new ConfigurationPropertySourcesCaching(null).disable();
	}
	@Test
	void setTimeToLiveDelegatesToCachingConfigurationPropertySources() {
		Duration ttl = Duration.ofDays(1);
		this.caching.setTimeToLive(ttl);
		then(getCaching(0)).should().setTimeToLive(ttl);
		then(getCaching(2)).should().setTimeToLive(ttl);
	}
	@Test
	void setTimeToLiveWhenSourcesIsNullDoesNothing() {
		new ConfigurationPropertySourcesCaching(null).setTimeToLive(Duration.ofSeconds(1));
	}
	@Test
	void clearDelegatesToCachingConfigurationPropertySources() {
		this.caching.clear();
		then(getCaching(0)).should().clear();
		then(getCaching(2)).should().clear();
	}
	@Test
	void clearWhenSourcesIsNullDoesNothing() {
		new ConfigurationPropertySourcesCaching(null).enable();
	}
	private ConfigurationPropertyCaching getCaching(int index) {
		return CachingConfigurationPropertySource.find(this.sources.get(index));
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class UnboundElementsSourceFilterTests {
	private UnboundElementsSourceFilter filter;
	private ConfigurationPropertySource source;
	@BeforeEach
	void setUp() {
		this.filter = new UnboundElementsSourceFilter();
		this.source = mock(ConfigurationPropertySource.class);
	}
	@Test
	void filterWhenSourceIsSystemPropertiesPropertySourceShouldReturnFalse() {
		MockPropertySource propertySource = new MockPropertySource(
				StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME);
		given(this.source.getUnderlyingSource()).willReturn(propertySource);
		assertThat(this.filter.apply(this.source)).isFalse();
	}
	@Test
	void filterWhenSourceIsSystemEnvironmentPropertySourceShouldReturnFalse() {
		MockPropertySource propertySource = new MockPropertySource(
				StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME);
		given(this.source.getUnderlyingSource()).willReturn(propertySource);
		assertThat(this.filter.apply(this.source)).isFalse();
	}
	@Test
	void filterWhenSourceIsNotSystemShouldReturnTrue() {
		MockPropertySource propertySource = new MockPropertySource('test');
		given(this.source.getUnderlyingSource()).willReturn(propertySource);
		assertThat(this.filter.apply(this.source)).isTrue();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertyNameTests {
	@Test
	void ofNameShouldNotBeNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> ConfigurationPropertyName.of(null))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void ofNameShouldNotStartWithDash() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('-foo'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameShouldNotStartWithDot() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('.foo'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameShouldNotEndWithDot() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('foo.'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameShouldNotContainUppercase() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('fOo'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameShouldNotContainInvalidChars() {
		String invalid = '_@$%*+=":;';
		for (char c : invalid.toCharArray()) {
			assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
				.isThrownBy(() -> ConfigurationPropertyName.of('foo' + c))
				.satisfies((ex) -> assertThat(ex.getMessage()).contains('is not valid'));
		}
	}
	@Test
	void ofNameWhenSimple() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('name');
		assertThat(name).hasToString('name');
		assertThat(name.getNumberOfElements()).isOne();
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('name');
		assertThat(name.isIndexed(0)).isFalse();
	}
	@Test
	void ofNameWhenStartsWithNumber() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('1foo');
		assertThat(name).hasToString('1foo');
		assertThat(name.getNumberOfElements()).isOne();
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('1foo');
		assertThat(name.isIndexed(0)).isFalse();
	}
	@Test
	void ofNameWhenRunOnAssociative() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo[bar]');
		assertThat(name).hasToString('foo[bar]');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('bar');
		assertThat(name.isIndexed(0)).isFalse();
		assertThat(name.isIndexed(1)).isTrue();
	}
	@Test
	void ofNameWhenDotOnAssociative() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar');
		assertThat(name).hasToString('foo.bar');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('bar');
		assertThat(name.isIndexed(0)).isFalse();
		assertThat(name.isIndexed(1)).isFalse();
	}
	@Test
	void ofNameWhenDotAndAssociative() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.[bar]');
		assertThat(name).hasToString('foo[bar]');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('bar');
		assertThat(name.isIndexed(0)).isFalse();
		assertThat(name.isIndexed(1)).isTrue();
	}
	@Test
	void ofNameWhenDoubleRunOnAndAssociative() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo[bar]baz');
		assertThat(name).hasToString('foo[bar].baz');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('bar');
		assertThat(name.getElement(2, Form.ORIGINAL)).isEqualTo('baz');
		assertThat(name.isIndexed(0)).isFalse();
		assertThat(name.isIndexed(1)).isTrue();
		assertThat(name.isIndexed(2)).isFalse();
	}
	@Test
	void ofNameWhenDoubleDotAndAssociative() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.[bar].baz');
		assertThat(name).hasToString('foo[bar].baz');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('bar');
		assertThat(name.getElement(2, Form.ORIGINAL)).isEqualTo('baz');
		assertThat(name.isIndexed(0)).isFalse();
		assertThat(name.isIndexed(1)).isTrue();
		assertThat(name.isIndexed(2)).isFalse();
	}
	@Test
	void ofNameWhenMissingCloseBracket() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('[bar'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameWhenMissingOpenBracket() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('bar]'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameWhenMultipleMismatchedBrackets() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('[a[[[b]ar]'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameWhenNestedBrackets() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo[a[c][[b]ar]]');
		assertThat(name).hasToString('foo[a[c][[b]ar]]');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('a[c][[b]ar]');
	}
	@Test
	void ofNameWithWhitespaceInName() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('foo. bar'))
			.withMessageContaining('is not valid');
	}
	@Test
	void ofNameWithWhitespaceInAssociativeElement() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo[b a r]');
		assertThat(name).hasToString('foo[b a r]');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('b a r');
		assertThat(name.isIndexed(0)).isFalse();
		assertThat(name.isIndexed(1)).isTrue();
	}
	@Test
	void ofNameWithUppercaseInAssociativeElement() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo[BAR]');
		assertThat(name).hasToString('foo[BAR]');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('BAR');
		assertThat(name.isIndexed(0)).isFalse();
		assertThat(name.isIndexed(1)).isTrue();
	}
	@Test
	void ofWhenNameIsEmptyShouldReturnEmptyName() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('');
		assertThat(name.toString()).isEmpty();
		assertThat(name.append('foo')).hasToString('foo');
	}
	@Test
	void ofIfValidWhenNameIsValidReturnsName() {
		ConfigurationPropertyName name = ConfigurationPropertyName.ofIfValid('spring.bo-ot');
		assertThat(name).hasToString('spring.bo-ot');
	}
	@Test
	void ofIfValidWhenNameIsNotValidReturnsNull() {
		ConfigurationPropertyName name = ConfigurationPropertyName.ofIfValid('spring.bo!oot');
		assertThat(name).isNull();
	}
	@Test
	void adaptWhenNameIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ConfigurationPropertyName.adapt(null, "."))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void adaptWhenElementValueProcessorIsNullShouldAdapt() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('foo', ".", null);
		assertThat(name).hasToString('foo');
	}
	@Test
	void adaptShouldCreateName() {
		ConfigurationPropertyName expected = ConfigurationPropertyName.of('foo.bar.baz');
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('foo.bar.baz', ".");
		assertThat(name).isEqualTo(expected);
	}
	@Test
	void adaptShouldStripInvalidChars() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('f@@.b%r', ".");
		assertThat(name.getElement(0, Form.UNIFORM)).isEqualTo('f');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('f');
		assertThat(name.getElement(1, Form.UNIFORM)).isEqualTo('br');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('br');
		assertThat(name).hasToString('f.br');
	}
	@Test
	void adaptShouldSupportUnderscore() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('f-_o.b_r', ".");
		assertThat(name.getElement(0, Form.UNIFORM)).isEqualTo('fo');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('f-_o');
		assertThat(name.getElement(1, Form.UNIFORM)).isEqualTo('br');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('b_r');
		assertThat(name).hasToString('f-o.br');
	}
	@Test
	void adaptShouldSupportMixedCase() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('fOo.bAr', ".");
		assertThat(name.getElement(0, Form.UNIFORM)).isEqualTo('foo');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('fOo');
		assertThat(name.getElement(1, Form.UNIFORM)).isEqualTo('bar');
		assertThat(name.getElement(1, Form.ORIGINAL)).isEqualTo('bAr');
		assertThat(name).hasToString('foo.bar');
	}
	@Test
	void adaptShouldUseElementValueProcessor() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('FOO_THE-BAR', "_",
				(c) -> c.toString().replace('-', ''));
		assertThat(name).hasToString('foo.thebar');
	}
	@Test
	void adaptShouldSupportIndexedElements() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('foo', ".");
		assertThat(name).hasToString('foo');
		assertThat(name.getNumberOfElements()).isOne();
		name = ConfigurationPropertyName.adapt('[foo]', ".");
		assertThat(name).hasToString('[foo]');
		assertThat(name.getNumberOfElements()).isOne();
		name = ConfigurationPropertyName.adapt('foo.bar', ".");
		assertThat(name).hasToString('foo.bar');
		assertThat(name.getNumberOfElements()).isEqualTo(2);
		name = ConfigurationPropertyName.adapt('foo[foo.bar]', ".");
		assertThat(name).hasToString('foo[foo.bar]');
		assertThat(name.getNumberOfElements()).isEqualTo(2);
		name = ConfigurationPropertyName.adapt('foo.[bar].baz', ".");
		assertThat(name).hasToString('foo[bar].baz');
		assertThat(name.getNumberOfElements()).isEqualTo(3);
	}
	@Test
	void adaptUnderscoreShouldReturnEmpty() {
		assertThat(ConfigurationPropertyName.adapt('_', "_").isEmpty()).isTrue();
		assertThat(ConfigurationPropertyName.adapt('_', ".").isEmpty()).isTrue();
	}
	@Test
	void isEmptyWhenEmptyShouldReturnTrue() {
		assertThat(ConfigurationPropertyName.of('').isEmpty()).isTrue();
	}
	@Test
	void isEmptyWhenNotEmptyShouldReturnFalse() {
		assertThat(ConfigurationPropertyName.of('x').isEmpty()).isFalse();
	}
	@Test
	void isLastElementIndexedWhenIndexedShouldReturnTrue() {
		assertThat(ConfigurationPropertyName.of('foo[0]').isLastElementIndexed()).isTrue();
	}
	@Test
	void isLastElementIndexedWhenNotIndexedShouldReturnFalse() {
		assertThat(ConfigurationPropertyName.of('foo.bar').isLastElementIndexed()).isFalse();
		assertThat(ConfigurationPropertyName.of('foo[0].bar').isLastElementIndexed()).isFalse();
	}
	@Test
	void getLastElementShouldGetLastElement() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('foo.bAr', ".");
		assertThat(name.getLastElement(Form.ORIGINAL)).isEqualTo('bAr');
		assertThat(name.getLastElement(Form.UNIFORM)).isEqualTo('bar');
	}
	@Test
	void getLastElementWhenEmptyShouldReturnEmptyString() {
		ConfigurationPropertyName name = ConfigurationPropertyName.EMPTY;
		assertThat(name.getLastElement(Form.ORIGINAL)).isEmpty();
		assertThat(name.getLastElement(Form.UNIFORM)).isEmpty();
	}
	@Test
	void getElementShouldNotIncludeAngleBrackets() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('[foo]');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('foo');
		assertThat(name.getElement(0, Form.UNIFORM)).isEqualTo('foo');
	}
	@Test
	void getElementInUniformFormShouldNotIncludeDashes() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('f-o-o');
		assertThat(name.getElement(0, Form.ORIGINAL)).isEqualTo('f-o-o');
		assertThat(name.getElement(0, Form.UNIFORM)).isEqualTo('foo');
	}
	@Test
	void getElementInOriginalFormShouldReturnElement() {
		assertThat(getElements('foo.bar', Form.ORIGINAL)).containsExactly('foo', 'bar');
		assertThat(getElements('foo[0]', Form.ORIGINAL)).containsExactly('foo', '0');
		assertThat(getElements('foo.[0]', Form.ORIGINAL)).containsExactly('foo', '0');
		assertThat(getElements('foo[baz]', Form.ORIGINAL)).containsExactly('foo', 'baz');
		assertThat(getElements('foo.baz', Form.ORIGINAL)).containsExactly('foo', 'baz');
		assertThat(getElements('foo[baz].bar', Form.ORIGINAL)).containsExactly('foo', 'baz', 'bar');
		assertThat(getElements('foo.baz.bar', Form.ORIGINAL)).containsExactly('foo', 'baz', 'bar');
		assertThat(getElements('foo.baz-bar', Form.ORIGINAL)).containsExactly('foo', 'baz-bar');
	}
	@Test
	void getElementInUniformFormShouldReturnElement() {
		assertThat(getElements('foo.bar', Form.UNIFORM)).containsExactly('foo', 'bar');
		assertThat(getElements('foo[0]', Form.UNIFORM)).containsExactly('foo', '0');
		assertThat(getElements('foo.[0]', Form.UNIFORM)).containsExactly('foo', '0');
		assertThat(getElements('foo[baz]', Form.UNIFORM)).containsExactly('foo', 'baz');
		assertThat(getElements('foo.baz', Form.UNIFORM)).containsExactly('foo', 'baz');
		assertThat(getElements('foo[baz].bar', Form.UNIFORM)).containsExactly('foo', 'baz', 'bar');
		assertThat(getElements('foo.baz.bar', Form.UNIFORM)).containsExactly('foo', 'baz', 'bar');
		assertThat(getElements('foo.baz-bar', Form.UNIFORM)).containsExactly('foo', 'bazbar');
	}
	private List<CharSequence> getElements(String name, Form form) {
		ConfigurationPropertyName propertyName = ConfigurationPropertyName.of(name);
		List<CharSequence> result = new ArrayList<>(propertyName.getNumberOfElements());
		for (int i = 0; i < propertyName.getNumberOfElements(); i++) {
			result.add(propertyName.getElement(i, form));
		}
		return result;
	}
	@Test
	void getNumberOfElementsShouldReturnNumberOfElement() {
		assertThat(ConfigurationPropertyName.of('').getNumberOfElements()).isZero();
		assertThat(ConfigurationPropertyName.of('x').getNumberOfElements()).isOne();
		assertThat(ConfigurationPropertyName.of('x.y').getNumberOfElements()).isEqualTo(2);
		assertThat(ConfigurationPropertyName.of('x[0].y').getNumberOfElements()).isEqualTo(3);
	}
	@Test
	void appendWhenNotIndexedShouldAppendWithDot() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		assertThat(name.append('bar')).hasToString('foo.bar');
	}
	@Test
	void appendWhenIndexedShouldAppendWithBrackets() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo').append('[bar]');
		assertThat(name.isLastElementIndexed()).isTrue();
		assertThat(name).hasToString('foo[bar]');
	}
	@Test
	void appendWhenElementNameIsNotValidShouldThrowException() {
		assertThatExceptionOfType(InvalidConfigurationPropertyNameException.class)
			.isThrownBy(() -> ConfigurationPropertyName.of('foo').append('-bar'))
			.withMessageContaining('Configuration property name "-bar" is not valid');
	}
	@Test
	void appendWhenElementNameMultiDotShouldAppend() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo').append('bar.baz');
		assertThat(name).hasToString('foo.bar.baz');
		assertThat(name.getNumberOfElements()).isEqualTo(3);
	}
	@Test
	void appendWhenElementNameIsNullShouldReturnName() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		assertThat((Object) name.append((String) null)).isSameAs(name);
	}
	@Test
	void appendConfigurationPropertyNameShouldReturnAppendedName() {
		ConfigurationPropertyName n1 = ConfigurationPropertyName.of('spring.boot');
		ConfigurationPropertyName n2 = ConfigurationPropertyName.of('tests.code');
		assertThat(n1.append(n2)).hasToString('spring.boot.tests.code');
	}
	@Test
	void appendConfigurationPropertyNameWhenNullShouldReturnName() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		assertThat((Object) name.append((ConfigurationPropertyName) null)).isSameAs(name);
	}
	@Test
	void getParentShouldReturnParent() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('this.is.a.multipart.name');
		ConfigurationPropertyName p1 = name.getParent();
		ConfigurationPropertyName p2 = p1.getParent();
		ConfigurationPropertyName p3 = p2.getParent();
		ConfigurationPropertyName p4 = p3.getParent();
		ConfigurationPropertyName p5 = p4.getParent();
		assertThat(p1).hasToString('this.is.a.multipart');
		assertThat(p2).hasToString('this.is.a');
		assertThat(p3).hasToString('this.is');
		assertThat(p4).hasToString('this');
		assertThat(p5).isEqualTo(ConfigurationPropertyName.EMPTY);
	}
	@Test
	void getParentWhenEmptyShouldReturnEmpty() {
		assertThat(ConfigurationPropertyName.EMPTY.getParent()).isEqualTo(ConfigurationPropertyName.EMPTY);
	}
	@Test
	void chopWhenLessThenSizeShouldReturnChopped() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.chop(1)).hasToString('foo');
		assertThat(name.chop(2)).hasToString('foo.bar');
	}
	@Test
	void chopWhenGreaterThanSizeShouldReturnExisting() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.chop(4)).isEqualTo(name);
	}
	@Test
	void chopWhenEqualToSizeShouldReturnExisting() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.chop(3)).isEqualTo(name);
	}
	@Test
	void subNameWhenOffsetLessThanSizeShouldReturnSubName() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.subName(1)).hasToString('bar.baz');
		assertThat(name.subName(2)).hasToString('baz');
	}
	@Test
	void subNameWhenOffsetZeroShouldReturnName() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.subName(0)).isSameAs(name);
	}
	@Test
	void subNameWhenOffsetEqualToSizeShouldReturnEmpty() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.subName(3)).isSameAs(ConfigurationPropertyName.EMPTY);
	}
	@Test
	void subNameWhenOffsetMoreThanSizeShouldReturnEmpty() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> name.subName(4));
	}
	@Test
	void subNameWhenOffsetNegativeShouldThrowException() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar.baz');
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> name.subName(-1));
	}
	@Test
	void isParentOfWhenSameShouldReturnFalse() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		assertThat(name.isParentOf(name)).isFalse();
	}
	@Test
	void isParentOfWhenParentShouldReturnTrue() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertyName child = ConfigurationPropertyName.of('foo.bar');
		assertThat(name.isParentOf(child)).isTrue();
		assertThat(child.isParentOf(name)).isFalse();
	}
	@Test
	void isParentOfWhenGrandparentShouldReturnFalse() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertyName grandchild = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.isParentOf(grandchild)).isFalse();
		assertThat(grandchild.isParentOf(name)).isFalse();
	}
	@Test
	void isParentOfWhenRootReturnTrue() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('');
		ConfigurationPropertyName child = ConfigurationPropertyName.of('foo');
		ConfigurationPropertyName grandchild = ConfigurationPropertyName.of('foo.bar');
		assertThat(name.isParentOf(child)).isTrue();
		assertThat(name.isParentOf(grandchild)).isFalse();
		assertThat(child.isAncestorOf(name)).isFalse();
	}
	@Test
	void isAncestorOfWhenSameShouldReturnFalse() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		assertThat(name.isAncestorOf(name)).isFalse();
	}
	@Test
	void isAncestorOfWhenParentShouldReturnTrue() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertyName child = ConfigurationPropertyName.of('foo.bar');
		assertThat(name.isAncestorOf(child)).isTrue();
		assertThat(child.isAncestorOf(name)).isFalse();
	}
	@Test
	void isAncestorOfWhenGrandparentShouldReturnTrue() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertyName grandchild = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.isAncestorOf(grandchild)).isTrue();
		assertThat(grandchild.isAncestorOf(name)).isFalse();
	}
	@Test
	void isAncestorOfWhenRootShouldReturnTrue() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('');
		ConfigurationPropertyName grandchild = ConfigurationPropertyName.of('foo.bar.baz');
		assertThat(name.isAncestorOf(grandchild)).isTrue();
		assertThat(grandchild.isAncestorOf(name)).isFalse();
	}
	@Test
	void compareShouldSortNames() {
		List<ConfigurationPropertyName> names = new ArrayList<>();
		names.add(ConfigurationPropertyName.of('foo[10]'));
		names.add(ConfigurationPropertyName.of('foo.bard'));
		names.add(ConfigurationPropertyName.of('foo[2]'));
		names.add(ConfigurationPropertyName.of('foo.bar'));
		names.add(ConfigurationPropertyName.of('foo.baz'));
		names.add(ConfigurationPropertyName.of('foo'));
		Collections.sort(names);
		assertThat(names.stream().map(ConfigurationPropertyName::toString).toList()).containsExactly('foo', 'foo[2]',
				'foo[10]', 'foo.bar', 'foo.bard', 'foo.baz');
	}
	@Test
	void compareDifferentLengthsShouldSortNames() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('spring.web.resources.chain.strategy.content');
		ConfigurationPropertyName other = ConfigurationPropertyName
			.of('spring.web.resources.chain.strategy.content.enabled');
		assertThat(name).isLessThan(other);
	}
	@Test
	void toStringShouldBeLowerCaseDashed() {
		ConfigurationPropertyName name = ConfigurationPropertyName.adapt('fOO.b_-a-r', ".");
		assertThat(name).hasToString('foo.b-a-r');
	}
	@Test
	void toStringFromOfShouldBeLowerCaseDashed() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo.bar-baz');
		assertThat(name).hasToString('foo.bar-baz');
	}
	@Test
	void equalsAndHashCode() {
		ConfigurationPropertyName n01 = ConfigurationPropertyName.of('foo[bar]');
		ConfigurationPropertyName n02 = ConfigurationPropertyName.of('foo[bar]');
		ConfigurationPropertyName n03 = ConfigurationPropertyName.of('foo.bar');
		ConfigurationPropertyName n04 = ConfigurationPropertyName.of('f-o-o.b-a-r');
		ConfigurationPropertyName n05 = ConfigurationPropertyName.of('foo[BAR]');
		ConfigurationPropertyName n06 = ConfigurationPropertyName.of('oof[bar]');
		ConfigurationPropertyName n07 = ConfigurationPropertyName.of('foo.bar');
		ConfigurationPropertyName n08 = ConfigurationPropertyName.EMPTY;
		ConfigurationPropertyName n09 = ConfigurationPropertyName.of('foo');
		ConfigurationPropertyName n10 = ConfigurationPropertyName.of('fo');
		ConfigurationPropertyName n11 = ConfigurationPropertyName.adapt('foo.BaR', ".");
		ConfigurationPropertyName n12 = ConfigurationPropertyName.of('f-o-o[b-a-r]');
		ConfigurationPropertyName n13 = ConfigurationPropertyName.of('f-o-o[b-a-r--]');
		ConfigurationPropertyName n14 = ConfigurationPropertyName.of('[1]');
		ConfigurationPropertyName n15 = ConfigurationPropertyName.of('[-1]');
		assertThat((Object) n01).isEqualTo(n01);
		assertThat(n01).hasSameHashCodeAs(n01);
		assertThat((Object) n01).isEqualTo(n02);
		assertThat(n01).hasSameHashCodeAs(n02);
		assertThat((Object) n01).isEqualTo(n03);
		assertThat(n01).hasSameHashCodeAs(n03);
		assertThat((Object) n01).isEqualTo(n04);
		assertThat(n01).hasSameHashCodeAs(n04);
		assertThat((Object) n11).isEqualTo(n03);
		assertThat(n11).hasSameHashCodeAs(n03);
		assertThat((Object) n03).isEqualTo(n11);
		assertThat(n03).hasSameHashCodeAs(n11);
		assertThat((Object) n01).isNotEqualTo(n05);
		assertThat((Object) n01).isNotEqualTo(n06);
		assertThat((Object) n07).isNotEqualTo(n08);
		assertThat((Object) n09).isNotEqualTo(n10);
		assertThat((Object) n10).isNotEqualTo(n09);
		assertThat((Object) n12).isNotEqualTo(n13);
		assertThat((Object) n14).isNotEqualTo(n15);
	}
	@Test
	void equalsAndHashCodeAfterOperations() {
		ConfigurationPropertyName n1 = ConfigurationPropertyName.of('nested');
		ConfigurationPropertyName n2 = ConfigurationPropertyName.EMPTY.append('nested');
		ConfigurationPropertyName n3 = ConfigurationPropertyName.of('nested.value').getParent();
		assertThat(n1).hasSameHashCodeAs(n2).hasSameHashCodeAs(n3);
		assertThat(n1).isEqualTo(n2).isEqualTo(n3);
	}
	@Test
	void equalsWhenStartsWith() {
		// gh-14665
		ConfigurationPropertyName n1 = ConfigurationPropertyName.of('my.sources[0].xame');
		ConfigurationPropertyName n2 = ConfigurationPropertyName.of('my.sources[0].xamespace');
		assertThat(n1).isNotEqualTo(n2);
	}
	@Test
	void equalsWhenStartsWithOfAdaptedName() {
		// gh-15152
		ConfigurationPropertyName n1 = ConfigurationPropertyName.adapt('example.mymap.ALPHA', ".");
		ConfigurationPropertyName n2 = ConfigurationPropertyName.adapt('example.mymap.ALPHA_BRAVO', ".");
		assertThat(n1).isNotEqualTo(n2);
	}
	@Test
	void equalsWhenStartsWithOfAdaptedNameOfIllegalChars() {
		// gh-15152
		ConfigurationPropertyName n1 = ConfigurationPropertyName.adapt('example.mymap.ALPH!', ".");
		ConfigurationPropertyName n2 = ConfigurationPropertyName.adapt('example.mymap.ALPHA!BRAVO', ".");
		assertThat(n1).isNotEqualTo(n2);
	}
	@Test
	void equalsWhenNameStartsTheSameUsingDashedCompare() {
		// gh-16855
		ConfigurationPropertyName n1 = ConfigurationPropertyName.of('management.metrics.web.server.auto-time-request');
		ConfigurationPropertyName n2 = ConfigurationPropertyName.of('management.metrics.web.server.auto-time-requests');
		assertThat(n1).isNotEqualTo(n2);
		assertThat(n2).isNotEqualTo(n1);
	}
	@Test // gh-30317
	void equalsWhenAdaptedNameMatchesDueToRemovalOfTrailingNonUniformCharacters() {
		ConfigurationPropertyName name1 = ConfigurationPropertyName.of('example.demo');
		ConfigurationPropertyName name2 = ConfigurationPropertyName.adapt('example.demo$$', ".");
		assertThat(name1).isEqualTo(name2);
		assertThat(name2).isEqualTo(name1);
	}
	@Test // gh-34804
	void equalsSymmetricWhenNameMatchesDueToIgnoredTrailingDashes() {
		ConfigurationPropertyName n1 = ConfigurationPropertyName.of('example.demo');
		ConfigurationPropertyName n2 = ConfigurationPropertyName.of('example.demo--');
		assertThat(n2).isEqualTo(n1);
		assertThat(n1).isEqualTo(n2);
	}
	@Test
	void isValidWhenValidShouldReturnTrue() {
		assertThat(ConfigurationPropertyName.isValid('')).isTrue();
		assertThat(ConfigurationPropertyName.isValid('foo')).isTrue();
		assertThat(ConfigurationPropertyName.isValid('foo.bar')).isTrue();
		assertThat(ConfigurationPropertyName.isValid('foo[0]')).isTrue();
		assertThat(ConfigurationPropertyName.isValid('foo[0].baz')).isTrue();
		assertThat(ConfigurationPropertyName.isValid('foo.b1')).isTrue();
		assertThat(ConfigurationPropertyName.isValid('foo.b-a-r')).isTrue();
		assertThat(ConfigurationPropertyName.isValid('foo[FooBar].baz')).isTrue();
	}
	@Test
	void isValidWhenNotValidShouldReturnFalse() {
		assertThat(ConfigurationPropertyName.isValid(null)).isFalse();
		assertThat(ConfigurationPropertyName.isValid('-foo')).isFalse();
		assertThat(ConfigurationPropertyName.isValid('FooBar')).isFalse();
		assertThat(ConfigurationPropertyName.isValid('foo!bar')).isFalse();
	}
	@Test
	void hashCodeIsStored() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('hash.code');
		int hashCode = name.hashCode();
		// hasFieldOrPropertyWithValue would look up for hashCode()
		assertThat(ReflectionTestUtils.getField(name, 'hashCode')).isEqualTo(hashCode);
	}
	@Test
	void hasIndexedElementWhenHasIndexedElementReturnsTrue() {
		assertThat(ConfigurationPropertyName.of('foo[bar]').hasIndexedElement()).isTrue();
	}
	@Test
	void hasIndexedElementWhenHasNoIndexedElementReturnsFalse() {
		assertThat(ConfigurationPropertyName.of('foo.bar').hasIndexedElement()).isFalse();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class PrefixedIterableConfigurationPropertySourceTests {
	@Test
	void streamShouldConsiderPrefix() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('my.foo.bar', 'bing');
		source.put('my.foo.baz', 'biff');
		source.put('hello.bing', 'blah');
		IterableConfigurationPropertySource prefixed = source.withPrefix('my');
		assertThat(prefixed.stream()).containsExactly(ConfigurationPropertyName.of('foo.bar'),
				ConfigurationPropertyName.of('foo.baz'), ConfigurationPropertyName.of('hello.bing'));
	}
	@Test
	void emptyPrefixShouldReturnOriginalStream() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('my.foo.bar', 'bing');
		source.put('my.foo.baz', 'biff');
		source.put('hello.bing', 'blah');
		IterableConfigurationPropertySource prefixed = source.withPrefix('');
		assertThat(prefixed.stream()).containsExactly(ConfigurationPropertyName.of('my.foo.bar'),
				ConfigurationPropertyName.of('my.foo.baz'), ConfigurationPropertyName.of('hello.bing'));
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class CachingConfigurationPropertySourceTests {
	@Test
	void findWhenNullSourceReturnsNull() {
		ConfigurationPropertySource source = null;
		assertThat(CachingConfigurationPropertySource.find(source)).isNull();
	}
	@Test
	void findWhenNotCachingConfigurationPropertySourceReturnsNull() {
		ConfigurationPropertySource source = mock(ConfigurationPropertySource.class);
		assertThat(CachingConfigurationPropertySource.find(source)).isNull();
	}
	@Test
	void findWhenCachingConfigurationPropertySourceReturnsCaching() {
		ConfigurationPropertySource source = mock(ConfigurationPropertySource.class,
				withSettings().extraInterfaces(CachingConfigurationPropertySource.class));
		ConfigurationPropertyCaching caching = mock(ConfigurationPropertyCaching.class);
		given(((CachingConfigurationPropertySource) source).getCaching()).willReturn(caching);
		assertThat(CachingConfigurationPropertySource.find(source)).isEqualTo(caching);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class AliasedIterableConfigurationPropertySourceTests extends AliasedConfigurationPropertySourceTests {
	@Test
	void streamShouldIncludeAliases() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar', 'bing');
		source.put('foo.baz', 'biff');
		IterableConfigurationPropertySource aliased = source
			.withAliases(new ConfigurationPropertyNameAliases('foo.bar', 'foo.bar1'));
		assertThat(aliased.stream()).containsExactly(ConfigurationPropertyName.of('foo.bar'),
				ConfigurationPropertyName.of('foo.bar1'), ConfigurationPropertyName.of('foo.baz'));
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourcesPropertyResolverTests {
	@Test
	void standardPropertyResolverResolvesMultipleTimes() {
		StandardEnvironment environment = new StandardEnvironment();
		CountingMockPropertySource propertySource = createMockPropertySource(environment, true);
		environment.getProperty('missing');
		assertThat(propertySource.getCount('missing')).isEqualTo(2);
	}
	@Test
	void configurationPropertySourcesPropertyResolverResolvesSingleTime() {
		ResolverEnvironment environment = new ResolverEnvironment();
		CountingMockPropertySource propertySource = createMockPropertySource(environment, true);
		environment.getProperty('missing');
		assertThat(propertySource.getCount('missing')).isOne();
	}
	@Test
	void containsPropertyWhenValidConfigurationPropertyName() {
		ResolverEnvironment environment = new ResolverEnvironment();
		CountingMockPropertySource propertySource = createMockPropertySource(environment, true);
		assertThat(environment.containsProperty('spring')).isTrue();
		assertThat(environment.containsProperty('sprong')).isFalse();
		assertThat(propertySource.getCount('spring')).isOne();
		assertThat(propertySource.getCount('sprong')).isOne();
	}
	@Test
	void containsPropertyWhenNotValidConfigurationPropertyName() {
		ResolverEnvironment environment = new ResolverEnvironment();
		CountingMockPropertySource propertySource = createMockPropertySource(environment, true);
		assertThat(environment.containsProperty('spr!ng')).isTrue();
		assertThat(environment.containsProperty('spr*ng')).isFalse();
		assertThat(propertySource.getCount('spr!ng')).isOne();
		assertThat(propertySource.getCount('spr*ng')).isOne();
	}
	@Test
	void getPropertyWhenValidConfigurationPropertyName() {
		ResolverEnvironment environment = new ResolverEnvironment();
		CountingMockPropertySource propertySource = createMockPropertySource(environment, true);
		assertThat(environment.getProperty('spring')).isEqualTo('boot');
		assertThat(environment.getProperty('sprong')).isNull();
		assertThat(propertySource.getCount('spring')).isOne();
		assertThat(propertySource.getCount('sprong')).isOne();
	}
	@Test
	void getPropertyWhenNotValidConfigurationPropertyName() {
		ResolverEnvironment environment = new ResolverEnvironment();
		CountingMockPropertySource propertySource = createMockPropertySource(environment, true);
		assertThat(environment.getProperty('spr!ng')).isEqualTo('boot');
		assertThat(environment.getProperty('spr*ng')).isNull();
		assertThat(propertySource.getCount('spr!ng')).isOne();
		assertThat(propertySource.getCount('spr*ng')).isOne();
	}
	@Test
	void getPropertyWhenNotAttached() {
		ResolverEnvironment environment = new ResolverEnvironment();
		CountingMockPropertySource propertySource = createMockPropertySource(environment, false);
		assertThat(environment.getProperty('spring')).isEqualTo('boot');
		assertThat(environment.getProperty('sprong')).isNull();
		assertThat(propertySource.getCount('spring')).isOne();
		assertThat(propertySource.getCount('sprong')).isOne();
	}
	@Test // gh-26732
	void getPropertyAsTypeWhenHasPlaceholder() {
		ResolverEnvironment environment = new ResolverEnvironment();
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.withProperty('v1', '1');
		propertySource.withProperty('v2', '${v1}');
		environment.getPropertySources().addFirst(propertySource);
		assertThat(environment.getProperty('v2')).isEqualTo('1');
		assertThat(environment.getProperty('v2', Integer.class)).isOne();
	}
	private CountingMockPropertySource createMockPropertySource(StandardEnvironment environment, boolean attach) {
		CountingMockPropertySource propertySource = new CountingMockPropertySource();
		propertySource.withProperty('spring', 'boot');
		propertySource.withProperty('spr!ng', 'boot');
		environment.getPropertySources().addFirst(propertySource);
		if (attach) {
			ConfigurationPropertySources.attach(environment);
		}
		return propertySource;
	}
	static class ResolverEnvironment extends StandardEnvironment {
		@Override
		protected ConfigurablePropertyResolver createPropertyResolver(MutablePropertySources propertySources) {
			return new ConfigurationPropertySourcesPropertyResolver(propertySources);
		}
	}
	static class CountingMockPropertySource extends MockPropertySource {
		private final Map<String, AtomicInteger> counts = new HashMap<>();
		@Override
		public Object getProperty(String name) {
			incrementCount(name);
			return super.getProperty(name);
		}
		@Override
		public boolean containsProperty(String name) {
			incrementCount(name);
			return super.containsProperty(name);
		}
		private void incrementCount(String name) {
			this.counts.computeIfAbsent(name, (k) -> new AtomicInteger()).incrementAndGet();
		}
		int getCount(String name) {
			AtomicInteger count = this.counts.get(name);
			return (count != null) ? count.get() : 0;
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class PrefixedConfigurationPropertySourceTests {
	@Test
	void getConfigurationPropertyShouldConsiderPrefix() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('my.foo.bar', 'bing');
		source.put('my.foo.baz', 'biff');
		ConfigurationPropertySource prefixed = source.nonIterable().withPrefix('my');
		assertThat(getName(prefixed, 'foo.bar')).hasToString('foo.bar');
		assertThat(getValue(prefixed, 'foo.bar')).isEqualTo('bing');
		assertThat(getName(prefixed, 'foo.baz')).hasToString('foo.baz');
		assertThat(getValue(prefixed, 'foo.baz')).isEqualTo('biff');
	}
	@Test
	void containsDescendantOfWhenSourceReturnsUnknownShouldReturnUnknown() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().unknown(name);
		ConfigurationPropertySource prefixed = source.withPrefix('my');
		assertThat(prefixed.containsDescendantOf(ConfigurationPropertyName.of('foo')))
			.isEqualTo(ConfigurationPropertyState.UNKNOWN);
	}
	@Test
	void containsDescendantOfWhenSourceReturnsPresentShouldReturnPresent() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().present(name)
			.unknown(ConfigurationPropertyName.of('bar'));
		ConfigurationPropertySource prefixed = source.withPrefix('my');
		assertThat(prefixed.containsDescendantOf(ConfigurationPropertyName.of('foo')))
			.isEqualTo(ConfigurationPropertyState.PRESENT);
	}
	@Test
	void containsDescendantOfWhenSourceReturnsAbsentShouldReturnAbsent() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().absent(name)
			.absent(ConfigurationPropertyName.of('bar'));
		ConfigurationPropertySource prefixed = source.withPrefix('my');
		assertThat(prefixed.containsDescendantOf(ConfigurationPropertyName.of('foo')))
			.isEqualTo(ConfigurationPropertyState.ABSENT);
	}
	@Test
	void withPrefixWhenPrefixIsNullReturnsOriginalSource() {
		ConfigurationPropertySource source = new MockConfigurationPropertySource().nonIterable();
		ConfigurationPropertySource prefixed = source.withPrefix(null);
		assertThat(prefixed).isSameAs(source);
	}
	@Test
	void withPrefixWhenPrefixIsEmptyReturnsOriginalSource() {
		ConfigurationPropertySource source = new MockConfigurationPropertySource().nonIterable();
		ConfigurationPropertySource prefixed = source.withPrefix('');
		assertThat(prefixed).isSameAs(source);
	}
	private ConfigurationPropertyName getName(ConfigurationPropertySource source, String name) {
		ConfigurationProperty property = source.getConfigurationProperty(ConfigurationPropertyName.of(name));
		return (property != null) ? property.getName() : null;
	}
	private Object getValue(ConfigurationPropertySource source, String name) {
		ConfigurationProperty property = source.getConfigurationProperty(ConfigurationPropertyName.of(name));
		return (property != null) ? property.getValue() : null;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class DefaultPropertyMapperTests extends AbstractPropertyMapperTests {
	@Override
	protected PropertyMapper getMapper() {
		return DefaultPropertyMapper.INSTANCE;
	}
	@Test
	void mapFromStringShouldReturnBestGuess() {
		assertThat(mapPropertySourceName('server')).isEqualTo('server');
		assertThat(mapPropertySourceName('server.port')).isEqualTo('server.port');
		assertThat(mapPropertySourceName('host[0]')).isEqualTo('host[0]');
		assertThat(mapPropertySourceName('host[0][1]')).isEqualTo('host[0][1]');
		assertThat(mapPropertySourceName('host[0].name')).isEqualTo('host[0].name');
		assertThat(mapPropertySourceName('host.f00.name')).isEqualTo('host.f00.name');
		assertThat(mapPropertySourceName('my.host-name')).isEqualTo('my.host-name');
		assertThat(mapPropertySourceName('my.hostName')).isEqualTo('my.hostname');
		assertThat(mapPropertySourceName('my.HOST_NAME')).isEqualTo('my.hostname');
		assertThat(mapPropertySourceName('s[!@#$%^&*()=+]e-rVeR')).isEqualTo('s[!@#$%^&*()=+].e-rver');
		assertThat(mapPropertySourceName('host[FOO].name')).isEqualTo('host[FOO].name');
	}
	@Test
	void mapFromConfigurationShouldReturnBestGuess() {
		assertThat(mapConfigurationPropertyName('server')).containsExactly('server');
		assertThat(mapConfigurationPropertyName('server.port')).containsExactly('server.port');
		assertThat(mapConfigurationPropertyName('host[0]')).containsExactly('host[0]');
		assertThat(mapConfigurationPropertyName('host[0][1]')).containsExactly('host[0][1]');
		assertThat(mapConfigurationPropertyName('host[0].name')).containsExactly('host[0].name');
		assertThat(mapConfigurationPropertyName('host.f00.name')).containsExactly('host.f00.name');
		assertThat(mapConfigurationPropertyName('my.host-name')).containsExactly('my.host-name');
		assertThat(mapConfigurationPropertyName('host[FOO].name')).containsExactly('host[FOO].name');
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class TestPropertyMapper implements PropertyMapper {
	private final MultiValueMap<ConfigurationPropertyName, String> fromConfig = new LinkedMultiValueMap<>();
	private final Map<String, ConfigurationPropertyName> fromSource = new LinkedHashMap<>();
	void addFromPropertySource(String from, String to) {
		this.fromSource.put(from, ConfigurationPropertyName.of(to));
	}
	void addFromConfigurationProperty(ConfigurationPropertyName from, String... to) {
		for (String propertySourceName : to) {
			this.fromConfig.add(from, propertySourceName);
		}
	}
	@Override
	public List<String> map(ConfigurationPropertyName configurationPropertyName) {
		return this.fromConfig.getOrDefault(configurationPropertyName, Collections.emptyList());
	}
	@Override
	public ConfigurationPropertyName map(String propertySourceName) {
		return this.fromSource.getOrDefault(propertySourceName, ConfigurationPropertyName.EMPTY);
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
public class MockConfigurationPropertySource implements IterableConfigurationPropertySource {
	private final Map<ConfigurationPropertyName, OriginTrackedValue> map = new LinkedHashMap<>();
	public MockConfigurationPropertySource() {
	}
	public MockConfigurationPropertySource(String configurationPropertyName, Object value) {
		this(configurationPropertyName, value, null);
	}
	public MockConfigurationPropertySource(String configurationPropertyName, Object value, String origin) {
		put(ConfigurationPropertyName.of(configurationPropertyName),
				OriginTrackedValue.of(value, MockOrigin.of(origin)));
	}
	public MockConfigurationPropertySource(Map<String, String> configs) {
		configs.forEach(this::put);
	}
	public void put(String name, String value) {
		put(ConfigurationPropertyName.of(name), value);
	}
	public void put(ConfigurationPropertyName name, String value) {
		put(name, OriginTrackedValue.of(value));
	}
	private void put(ConfigurationPropertyName name, OriginTrackedValue value) {
		this.map.put(name, value);
	}
	public ConfigurationPropertySource nonIterable() {
		return new NonIterable();
	}
	@Override
	public Iterator<ConfigurationPropertyName> iterator() {
		return this.map.keySet().iterator();
	}
	@Override
	public Stream<ConfigurationPropertyName> stream() {
		return this.map.keySet().stream();
	}
	@Override
	public Object getUnderlyingSource() {
		return this.map;
	}
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		OriginTrackedValue result = this.map.get(name);
		if (result == null) {
			result = findValue(name);
		}
		return ConfigurationProperty.of(name, result);
	}
	private OriginTrackedValue findValue(ConfigurationPropertyName name) {
		return this.map.get(name);
	}
	private final class NonIterable implements ConfigurationPropertySource {
		@Override
		public Object getUnderlyingSource() {
			return MockConfigurationPropertySource.this.map;
		}
		@Override
		public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
			return MockConfigurationPropertySource.this.getConfigurationProperty(name);
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertyNameAliasesTests {
	@Test
	void createWithStringWhenNullNameShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigurationPropertyNameAliases((String) null))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void createWithStringShouldAddMapping() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases('foo', 'bar', 'baz');
		assertThat(aliases.getAliases(ConfigurationPropertyName.of('foo')))
			.containsExactly(ConfigurationPropertyName.of('bar'), ConfigurationPropertyName.of('baz'));
	}
	@Test
	void createWithNameShouldAddMapping() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases(
				ConfigurationPropertyName.of('foo'), ConfigurationPropertyName.of('bar'),
				ConfigurationPropertyName.of('baz'));
		assertThat(aliases.getAliases(ConfigurationPropertyName.of('foo')))
			.containsExactly(ConfigurationPropertyName.of('bar'), ConfigurationPropertyName.of('baz'));
	}
	@Test
	void addAliasesFromStringShouldAddMapping() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		aliases.addAliases('foo', 'bar', 'baz');
		assertThat(aliases.getAliases(ConfigurationPropertyName.of('foo')))
			.containsExactly(ConfigurationPropertyName.of('bar'), ConfigurationPropertyName.of('baz'));
	}
	@Test
	void addAliasesFromNameShouldAddMapping() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		aliases.addAliases(ConfigurationPropertyName.of('foo'), ConfigurationPropertyName.of('bar'),
				ConfigurationPropertyName.of('baz'));
		assertThat(aliases.getAliases(ConfigurationPropertyName.of('foo')))
			.containsExactly(ConfigurationPropertyName.of('bar'), ConfigurationPropertyName.of('baz'));
	}
	@Test
	void addWhenHasExistingShouldAddAdditionalMappings() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		aliases.addAliases('foo', 'bar');
		aliases.addAliases('foo', 'baz');
		assertThat(aliases.getAliases(ConfigurationPropertyName.of('foo')))
			.containsExactly(ConfigurationPropertyName.of('bar'), ConfigurationPropertyName.of('baz'));
	}
	@Test
	void getAliasesWhenNotMappedShouldReturnEmptyList() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		assertThat(aliases.getAliases(ConfigurationPropertyName.of('foo'))).isEmpty();
	}
	@Test
	void getAliasesWhenMappedShouldReturnMapping() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		aliases.addAliases('foo', 'bar');
		assertThat(aliases.getAliases(ConfigurationPropertyName.of('foo')))
			.containsExactly(ConfigurationPropertyName.of('bar'));
	}
	@Test
	void getNameForAliasWhenHasMappingShouldReturnName() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		aliases.addAliases('foo', 'bar');
		aliases.addAliases('foo', 'baz');
		assertThat((Object) aliases.getNameForAlias(ConfigurationPropertyName.of('bar')))
			.isEqualTo(ConfigurationPropertyName.of('foo'));
		assertThat((Object) aliases.getNameForAlias(ConfigurationPropertyName.of('baz')))
			.isEqualTo(ConfigurationPropertyName.of('foo'));
	}
	@Test
	void getNameForAliasWhenNotMappedShouldReturnNull() {
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		aliases.addAliases('foo', 'bar');
		assertThat((Object) aliases.getNameForAlias(ConfigurationPropertyName.of('baz'))).isNull();
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SpringIterableConfigurationPropertySourceTests {
	@Test
	void createWhenPropertySourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new SpringIterableConfigurationPropertySource(null, mock(PropertyMapper.class)))
			.withMessageContaining('PropertySource must not be null');
	}
	@Test
	void iteratorShouldAdaptNames() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key1', 'value1');
		source.put('key2', 'value2');
		source.put('key3', 'value3');
		source.put('key4', 'value4');
		EnumerablePropertySource<?> propertySource = new MapPropertySource('test', source);
		TestPropertyMapper mapper1 = new TestPropertyMapper();
		mapper1.addFromPropertySource('key1', 'my.key1');
		mapper1.addFromPropertySource('key2', 'my.key2a');
		mapper1.addFromPropertySource('key4', 'my.key4');
		TestPropertyMapper mapper2 = new TestPropertyMapper();
		mapper2.addFromPropertySource('key2', 'my.key2b');
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(
				propertySource, mapper1, mapper2);
		assertThat(adapter.iterator()).toIterable()
			.extracting(Object::toString)
			.containsExactly('my.key1', 'my.key2a', 'my.key4');
	}
	@Test
	void getValueShouldUseDirectMapping() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key1', 'value1');
		source.put('key2', 'value2');
		source.put('key3', 'value3');
		EnumerablePropertySource<?> propertySource = new MapPropertySource('test', source);
		TestPropertyMapper mapper = new TestPropertyMapper();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.key');
		mapper.addFromConfigurationProperty(name, 'key2');
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(
				propertySource, mapper);
		assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo('value2');
	}
	@Test
	void getValueShouldUseEnumerableMapping() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key1', 'value1');
		source.put('key2', 'value2');
		source.put('key3', 'value3');
		EnumerablePropertySource<?> propertySource = new MapPropertySource('test', source);
		TestPropertyMapper mapper = new TestPropertyMapper();
		mapper.addFromPropertySource('key1', 'my.missing');
		mapper.addFromPropertySource('key2', 'my.k-e-y');
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(
				propertySource, mapper);
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.key');
		assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo('value2');
	}
	@Test
	void getValueOrigin() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key', 'value');
		EnumerablePropertySource<?> propertySource = new MapPropertySource('test', source);
		TestPropertyMapper mapper = new TestPropertyMapper();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.key');
		mapper.addFromConfigurationProperty(name, 'key');
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(
				propertySource, mapper);
		assertThat(adapter.getConfigurationProperty(name).getOrigin())
			.hasToString('\'key\' from property source \'test\'');
	}
	@Test
	void getValueWhenOriginCapableShouldIncludeSourceOrigin() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('key', 'value');
		EnumerablePropertySource<?> propertySource = new OriginCapablePropertySource<>(
				new MapPropertySource('test', source));
		TestPropertyMapper mapper = new TestPropertyMapper();
		ConfigurationPropertyName name = ConfigurationPropertyName.of('my.key');
		mapper.addFromConfigurationProperty(name, 'key');
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(
				propertySource, mapper);
		assertThat(adapter.getConfigurationProperty(name).getOrigin()).hasToString('TestOrigin key');
	}
	@Test
	void containsDescendantOfShouldCheckSourceNames() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('foo.bar', 'value');
		source.put('faf', 'value');
		EnumerablePropertySource<?> propertySource = new OriginCapablePropertySource<>(
				new MapPropertySource('test', source));
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(
				propertySource, DefaultPropertyMapper.INSTANCE);
		assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of('foo')))
			.isEqualTo(ConfigurationPropertyState.PRESENT);
		assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of('faf')))
			.isEqualTo(ConfigurationPropertyState.ABSENT);
		assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of('fof')))
			.isEqualTo(ConfigurationPropertyState.ABSENT);
	}
	@Test
	void containsDescendantOfWhenSystemEnvironmentPropertySourceShouldLegacyProperty() {
		Map<String, Object> source = new LinkedHashMap<>();
		source.put('FOO_BAR_BAZ_BONG', 'bing');
		source.put('FOO_ALPHABRAVO_GAMMA', 'delta');
		SystemEnvironmentPropertySource propertySource = new SystemEnvironmentPropertySource(
				StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, source);
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(
				propertySource, SystemEnvironmentPropertyMapper.INSTANCE);
		assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of('foo.bar-baz')))
			.isEqualTo(ConfigurationPropertyState.PRESENT);
		assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of('foo.alpha-bravo')))
			.isEqualTo(ConfigurationPropertyState.PRESENT);
		assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of('foo.blah')))
			.isEqualTo(ConfigurationPropertyState.ABSENT);
	}
	@Test
	void simpleMapPropertySourceKeyDataChangeInvalidatesCache() {
		// gh-13344
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('key1', 'value1');
		map.put('key2', 'value2');
		EnumerablePropertySource<?> source = new MapPropertySource('test', map);
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source,
				DefaultPropertyMapper.INSTANCE);
		assertThat(adapter.stream()).hasSize(2);
		map.put('key3', 'value3');
		assertThat(adapter.stream()).hasSize(3);
	}
	@Test
	void concurrentModificationExceptionInvalidatesCache() {
		// gh-17013
		ConcurrentModificationThrowingMap<String, Object> map = new ConcurrentModificationThrowingMap<>();
		map.put('key1', 'value1');
		map.put('key2', 'value2');
		EnumerablePropertySource<?> source = new MapPropertySource('test', map);
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source,
				DefaultPropertyMapper.INSTANCE);
		assertThat(adapter.stream()).hasSize(2);
		map.setThrowException(true);
		map.put('key3', 'value3');
		assertThat(adapter.stream()).hasSize(3);
	}
	@Test
	void originTrackedMapPropertySourceKeyAdditionInvalidatesCache() {
		// gh-13344
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('key1', 'value1');
		map.put('key2', 'value2');
		EnumerablePropertySource<?> source = new OriginTrackedMapPropertySource('test', map);
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source,
				DefaultPropertyMapper.INSTANCE);
		assertThat(adapter.stream()).hasSize(2);
		map.put('key3', 'value3');
		assertThat(adapter.stream()).hasSize(3);
	}
	@Test
	void readOnlyOriginTrackedMapPropertySourceKeyAdditionDoesNotInvalidateCache() {
		// gh-16717
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('key1', 'value1');
		map.put('key2', 'value2');
		EnumerablePropertySource<?> source = new OriginTrackedMapPropertySource('test', map, true);
		SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source,
				DefaultPropertyMapper.INSTANCE);
		assertThat(adapter.stream()).hasSize(2);
		map.put('key3', 'value3');
		assertThat(adapter.stream()).hasSize(2);
	}
	@Test
	void orderOfUnderlyingSourceIsPreserved() {
		Map<String, Object> map = new LinkedHashMap<>();
		map.put('test.map.alpha', 'value1');
		map.put('test.map.bravo', 'value2');
		map.put('test.map.charlie', 'value3');
		map.put('test.map.delta', 'value4');
		EnumerablePropertySource<?> source = new OriginTrackedMapPropertySource('test', map, true);
		SpringIterableConfigurationPropertySource propertySource = new SpringIterableConfigurationPropertySource(source,
				DefaultPropertyMapper.INSTANCE);
		assertThat(propertySource.stream().map(ConfigurationPropertyName::toString)).containsExactly('test.map.alpha',
				'test.map.bravo', 'test.map.charlie', 'test.map.delta');
	}
	/**
	 * Test {@link PropertySource} that"s also an {@link OriginLookup}.
	 *
	 * @param <T> the source type
	 */
	static class OriginCapablePropertySource<T> extends EnumerablePropertySource<T> implements OriginLookup<String> {
		private final EnumerablePropertySource<T> propertySource;
		OriginCapablePropertySource(EnumerablePropertySource<T> propertySource) {
			super(propertySource.getName(), propertySource.getSource());
			this.propertySource = propertySource;
		}
		@Override
		public Object getProperty(String name) {
			return this.propertySource.getProperty(name);
		}
		@Override
		public String[] getPropertyNames() {
			return this.propertySource.getPropertyNames();
		}
		@Override
		public Origin getOrigin(String name) {
			return new Origin() {
				@Override
				public String toString() {
					return 'TestOrigin ' + name;
				}
			};
		}
	}
	static class ConcurrentModificationThrowingMap<K, V> extends LinkedHashMap<K, V> {
		private boolean throwException;
		void setThrowException(boolean throwException) {
			this.throwException = throwException;
		}
		@Override
		public Set<K> keySet() {
			return new KeySet(super.keySet());
		}
		private class KeySet extends LinkedHashSet<K> {
			KeySet(Set<K> keySet) {
				super(keySet);
			}
			@Override
			public Iterator<K> iterator() {
				if (ConcurrentModificationThrowingMap.this.throwException) {
					ConcurrentModificationThrowingMap.this.throwException = false;
					throw new ConcurrentModificationException();
				}
				return super.iterator();
			}
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertySourcesPropertySourceTests {
	private final List<ConfigurationPropertySource> configurationSources = new ArrayList<>();
	private final ConfigurationPropertySourcesPropertySource propertySource = new ConfigurationPropertySourcesPropertySource(
			'test', this.configurationSources);
	@Test
	void getPropertyShouldReturnValue() {
		this.configurationSources.add(new MockConfigurationPropertySource('foo.bar', 'baz'));
		assertThat(this.propertySource.getProperty('foo.bar')).isEqualTo('baz');
	}
	@Test
	void getPropertyWhenNameIsNotValidShouldReturnNull() {
		this.configurationSources.add(new MockConfigurationPropertySource('foo.bar', 'baz'));
		assertThat(this.propertySource.getProperty('FOO.B-A-R')).isNull();
		assertThat(this.propertySource.getProperty('FOO.B A R')).isNull();
		assertThat(this.propertySource.getProperty('.foo.bar')).isNull();
	}
	@Test
	void getPropertyWhenMultipleShouldReturnFirst() {
		this.configurationSources.add(new MockConfigurationPropertySource('foo.bar', 'baz'));
		this.configurationSources.add(new MockConfigurationPropertySource('foo.bar', 'bill'));
		assertThat(this.propertySource.getProperty('foo.bar')).isEqualTo('baz');
	}
	@Test
	void getPropertyWhenNoneShouldReturnFirst() {
		this.configurationSources.add(new MockConfigurationPropertySource('foo.bar', 'baz'));
		assertThat(this.propertySource.getProperty('foo.foo')).isNull();
	}
	@Test
	void getPropertyOriginShouldReturnOrigin() {
		this.configurationSources.add(new MockConfigurationPropertySource('foo.bar', 'baz', 'line1'));
		assertThat(this.propertySource.getOrigin('foo.bar')).hasToString('line1');
	}
	@Test
	void getPropertyOriginWhenMissingShouldReturnNull() {
		this.configurationSources.add(new MockConfigurationPropertySource('foo.bar', 'baz', 'line1'));
		assertThat(this.propertySource.getOrigin('foo.foo')).isNull();
	}
	@Test
	void getNameShouldReturnName() {
		assertThat(this.propertySource.getName()).isEqualTo('test');
	}
	@Test
	void getSourceShouldReturnSource() {
		assertThat(this.propertySource.getSource()).isSameAs(this.configurationSources);
	}
}
/*
package org.springframework.boot.context.properties.source;
class KnownAncestorsConfigurationPropertySource implements ConfigurationPropertySource {
	private final Map<ConfigurationPropertyName, ConfigurationPropertyState> ancestors = new HashMap<>();
	@Override
	public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {
		return null;
	}
	@Override
	public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {
		ConfigurationPropertyState state = this.ancestors.get(name);
		assertThat(state).isNotNull();
		return state;
	}
	KnownAncestorsConfigurationPropertySource absent(ConfigurationPropertyName name) {
		return ancestor(name, ConfigurationPropertyState.ABSENT);
	}
	KnownAncestorsConfigurationPropertySource present(ConfigurationPropertyName name) {
		return ancestor(name, ConfigurationPropertyState.PRESENT);
	}
	KnownAncestorsConfigurationPropertySource unknown(ConfigurationPropertyName name) {
		return ancestor(name, ConfigurationPropertyState.UNKNOWN);
	}
	private KnownAncestorsConfigurationPropertySource ancestor(ConfigurationPropertyName name,
			ConfigurationPropertyState state) {
		this.ancestors.put(name, state);
		return this;
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class FilteredConfigurationPropertiesSourceTests {
	@Test
	void createWhenSourceIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new FilteredConfigurationPropertiesSource(null, Objects::nonNull))
			.withMessageContaining('Source must not be null');
	}
	@Test
	void createWhenFilterIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new FilteredConfigurationPropertiesSource(new MockConfigurationPropertySource(), null))
			.withMessageContaining('Filter must not be null');
	}
	@Test
	void getValueShouldFilterNames() {
		ConfigurationPropertySource source = createTestSource();
		ConfigurationPropertySource filtered = source.filter(this::noBrackets);
		ConfigurationPropertyName name = ConfigurationPropertyName.of('a');
		assertThat(source.getConfigurationProperty(name).getValue()).isEqualTo('1');
		assertThat(filtered.getConfigurationProperty(name).getValue()).isEqualTo('1');
		ConfigurationPropertyName bracketName = ConfigurationPropertyName.of('a[1]');
		assertThat(source.getConfigurationProperty(bracketName).getValue()).isEqualTo('2');
		assertThat(filtered.getConfigurationProperty(bracketName)).isNull();
	}
	@Test
	void containsDescendantOfWhenSourceReturnsEmptyShouldReturnEmpty() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().unknown(name);
		ConfigurationPropertySource filtered = source.filter((n) -> true);
		assertThat(filtered.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.UNKNOWN);
	}
	@Test
	void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().absent(name);
		ConfigurationPropertySource filtered = source.filter((n) -> true);
		assertThat(filtered.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.ABSENT);
	}
	@Test
	void containsDescendantOfWhenSourceReturnsTrueShouldReturnEmpty() {
		ConfigurationPropertyName name = ConfigurationPropertyName.of('foo');
		ConfigurationPropertySource source = new KnownAncestorsConfigurationPropertySource().present(name);
		ConfigurationPropertySource filtered = source.filter((n) -> true);
		assertThat(filtered.containsDescendantOf(name)).isEqualTo(ConfigurationPropertyState.UNKNOWN);
	}
	protected final ConfigurationPropertySource createTestSource() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('a', '1');
		source.put('a[1]', '2');
		source.put('b', '3');
		source.put('b[1]', '4');
		source.put('c', '5');
		return convertSource(source);
	}
	protected ConfigurationPropertySource convertSource(MockConfigurationPropertySource source) {
		return source.nonIterable();
	}
	private boolean noBrackets(ConfigurationPropertyName name) {
		return !name.toString().contains('[');
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class SoftReferenceConfigurationPropertyCacheTests {
	private static final Clock FIXED_CLOCK = Clock.fixed(Instant.parse('2020-01-02T09:00:00Z'), ZoneOffset.UTC);
	private Clock clock = FIXED_CLOCK;
	private final AtomicInteger createCount = new AtomicInteger();
	private TestSoftReferenceConfigurationPropertyCache cache = new TestSoftReferenceConfigurationPropertyCache(false);
	@Test
	void getReturnsValueWithCorrectCounts() {
		get(this.cache).assertCounts(0, 0);
		get(this.cache).assertCounts(0, 1);
		get(this.cache).assertCounts(0, 2);
	}
	@Test
	void getWhenNeverExpireReturnsValueWithCorrectCounts() {
		this.cache = new TestSoftReferenceConfigurationPropertyCache(true);
		get(this.cache).assertCounts(0, 0);
		get(this.cache).assertCounts(0, 0);
		get(this.cache).assertCounts(0, 0);
	}
	@Test
	void enableEnablesCachingWithUnlimitedTimeToLive() {
		this.cache.enable();
		get(this.cache).assertCounts(0, 0);
		tick(Duration.ofDays(300));
		get(this.cache).assertCounts(0, 0);
	}
	@Test
	void setTimeToLiveEnablesCachingWithTimeToLive() {
		this.cache.setTimeToLive(Duration.ofDays(1));
		get(this.cache).assertCounts(0, 0);
		tick(Duration.ofHours(2));
		get(this.cache).assertCounts(0, 0);
		tick(Duration.ofDays(2));
		get(this.cache).assertCounts(0, 1);
	}
	@Test
	void setTimeToLiveWhenZeroDisablesCaching() {
		this.cache.setTimeToLive(Duration.ZERO);
		get(this.cache).assertCounts(0, 0);
		get(this.cache).assertCounts(0, 1);
		get(this.cache).assertCounts(0, 2);
	}
	@Test
	void setTimeToLiveWhenNullDisablesCaching() {
		this.cache.setTimeToLive(null);
		get(this.cache).assertCounts(0, 0);
		get(this.cache).assertCounts(0, 1);
		get(this.cache).assertCounts(0, 2);
	}
	@Test
	void clearExpiresCache() {
		this.cache.enable();
		get(this.cache).assertCounts(0, 0);
		get(this.cache).assertCounts(0, 0);
		this.cache.clear();
		get(this.cache).assertCounts(0, 1);
	}
	private Value get(SoftReferenceConfigurationPropertyCache<Value> cache) {
		return cache.get(this::createValue, this::updateValue);
	}
	private Value createValue() {
		return new Value(this.createCount.getAndIncrement(), -1);
	}
	private Value updateValue(Value value) {
		return new Value(value.createCount, value.refreshCount + 1);
	}
	private void tick(Duration duration) {
		this.clock = Clock.offset(this.clock, duration);
	}
	/**
	 * Testable {@link SoftReferenceConfigurationPropertyCache} that actually uses real
	 * references.
	 */
	class TestSoftReferenceConfigurationPropertyCache extends SoftReferenceConfigurationPropertyCache<Value> {
		private Value value;
		TestSoftReferenceConfigurationPropertyCache(boolean neverExpire) {
			super(neverExpire);
		}
		@Override
		protected Value getValue() {
			return this.value;
		}
		@Override
		protected void setValue(Value value) {
			this.value = value;
		}
		@Override
		protected Instant now() {
			return SoftReferenceConfigurationPropertyCacheTests.this.clock.instant();
		}
	}
	/**
	 * Value used for testing.
	 */
	static class Value {
		private final int createCount;
		private final int refreshCount;
		Value(int createCount, int refreshCount) {
			this.createCount = createCount;
			this.refreshCount = refreshCount;
		}
		void assertCounts(int expectedCreateCount, int expectedRefreshCount) {
			assertThat(this.createCount).as('created').isEqualTo(expectedCreateCount);
			assertThat(this.refreshCount).as('refreshed').isEqualTo(expectedRefreshCount);
		}
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class FilteredIterableConfigurationPropertiesSourceTests extends FilteredConfigurationPropertiesSourceTests {
	@Test
	void iteratorShouldFilterNames() {
		MockConfigurationPropertySource source = (MockConfigurationPropertySource) createTestSource();
		IterableConfigurationPropertySource filtered = source.filter(this::noBrackets);
		assertThat(filtered.iterator()).toIterable()
			.extracting(ConfigurationPropertyName::toString)
			.containsExactly('a', 'b', 'c');
	}
	@Override
	protected ConfigurationPropertySource convertSource(MockConfigurationPropertySource source) {
		return source;
	}
	@Test
	void containsDescendantOfShouldUseContents() {
		MockConfigurationPropertySource source = new MockConfigurationPropertySource();
		source.put('foo.bar.baz', '1');
		source.put('foo.bar[0]', '1');
		source.put('faf.bar[0]', '1');
		IterableConfigurationPropertySource filtered = source.filter(this::noBrackets);
		assertThat(filtered.containsDescendantOf(ConfigurationPropertyName.of('foo')))
			.isEqualTo(ConfigurationPropertyState.PRESENT);
		assertThat(filtered.containsDescendantOf(ConfigurationPropertyName.of('faf')))
			.isEqualTo(ConfigurationPropertyState.ABSENT);
	}
	private boolean noBrackets(ConfigurationPropertyName name) {
		return !name.toString().contains('[');
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertyCachingTests {
	private StandardEnvironment environment;
	private MapPropertySource propertySource;
	@BeforeEach
	void setup() {
		this.environment = new StandardEnvironment();
		this.propertySource = new MapPropertySource('test', Collections.singletonMap('spring', 'boot'));
		this.environment.getPropertySources().addLast(this.propertySource);
	}
	@Test
	void getFromEnvironmentReturnsCaching() {
		ConfigurationPropertyCaching caching = ConfigurationPropertyCaching.get(this.environment);
		assertThat(caching).isInstanceOf(ConfigurationPropertySourcesCaching.class);
	}
	@Test
	void getFromEnvironmentForUnderlyingSourceReturnsCaching() {
		ConfigurationPropertyCaching caching = ConfigurationPropertyCaching.get(this.environment, this.propertySource);
		assertThat(caching).isInstanceOf(SoftReferenceConfigurationPropertyCache.class);
	}
	@Test
	void getFromSourcesWhenSourcesIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ConfigurationPropertyCaching.get((Iterable<ConfigurationPropertySource>) null))
			.withMessage('Sources must not be null');
	}
	@Test
	void getFromSourcesReturnsCachingComposite() {
		List<ConfigurationPropertySource> sources = new ArrayList<>();
		sources.add(SpringConfigurationPropertySource.from(this.propertySource));
		ConfigurationPropertyCaching caching = ConfigurationPropertyCaching.get(sources);
		assertThat(caching).isInstanceOf(ConfigurationPropertySourcesCaching.class);
	}
	@Test
	void getFromSourcesForUnderlyingSourceReturnsCaching() {
		List<ConfigurationPropertySource> sources = new ArrayList<>();
		sources.add(SpringConfigurationPropertySource.from(this.propertySource));
		ConfigurationPropertyCaching caching = ConfigurationPropertyCaching.get(sources, this.propertySource);
		assertThat(caching).isInstanceOf(SoftReferenceConfigurationPropertyCache.class);
	}
	@Test
	void getFromSourcesForUnderlyingSourceWhenCantFindThrowsException() {
		List<ConfigurationPropertySource> sources = new ArrayList<>();
		sources.add(SpringConfigurationPropertySource.from(this.propertySource));
		MapPropertySource anotherPropertySource = new MapPropertySource('test2', Collections.emptyMap());
		assertThatIllegalStateException()
			.isThrownBy(() -> ConfigurationPropertyCaching.get(sources, anotherPropertySource))
			.withMessage('Unable to find cache from configuration property sources');
	}
}
/*
package org.springframework.boot.context.properties.source;
/**
class ConfigurationPropertyTests {
	private static final ConfigurationPropertyName NAME = ConfigurationPropertyName.of('foo');
	private final ConfigurationPropertySource source = ConfigurationPropertySource.from(mock(PropertySource.class));
	@Test
	void createWhenNameIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigurationProperty(null, 'bar', null))
			.withMessageContaining('Name must not be null');
	}
	@Test
	void createWhenValueIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ConfigurationProperty(NAME, null, null))
			.withMessageContaining('Value must not be null');
	}
	@Test
	void getNameShouldReturnName() {
		ConfigurationProperty property = ConfigurationProperty.of(this.source, NAME, 'foo', null);
		assertThat((Object) property.getName()).isEqualTo(NAME);
	}
	@Test
	void getValueShouldReturnValue() {
		ConfigurationProperty property = ConfigurationProperty.of(this.source, NAME, 'foo', null);
		assertThat(property.getValue()).isEqualTo('foo');
	}
	@Test
	void getPropertyOriginShouldReturnValuePropertyOrigin() {
		Origin origin = mock(Origin.class);
		OriginProvider property = ConfigurationProperty.of(this.source, NAME, 'foo', origin);
		assertThat(property.getOrigin()).isEqualTo(origin);
	}
	@Test
	void getPropertySourceShouldReturnPropertySource() {
		Origin origin = mock(Origin.class);
		ConfigurationProperty property = ConfigurationProperty.of(this.source, NAME, 'foo', origin);
		assertThat(property.getSource()).isEqualTo(this.source);
	}
	@Test
	void equalsAndHashCode() {
		ConfigurationProperty property1 = new ConfigurationProperty(ConfigurationPropertyName.of('foo'), 'bar', null);
		ConfigurationProperty property2 = new ConfigurationProperty(ConfigurationPropertyName.of('foo'), 'bar', null);
		ConfigurationProperty property3 = new ConfigurationProperty(ConfigurationPropertyName.of('foo'), 'baz', null);
		ConfigurationProperty property4 = new ConfigurationProperty(ConfigurationPropertyName.of('baz'), 'bar', null);
		assertThat(property1).hasSameHashCodeAs(property2);
		assertThat(property1).isEqualTo(property2).isNotEqualTo(property3).isNotEqualTo(property4);
	}
	@Test
	void toStringShouldReturnValue() {
		ConfigurationProperty property = ConfigurationProperty.of(this.source, NAME, 'foo', null);
		assertThat(property.toString()).contains('name').contains('value');
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBeanRegistrationAotProcessorTests {
	private final DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	private final ConfigurationPropertiesBeanRegistrationAotProcessor processor = new ConfigurationPropertiesBeanRegistrationAotProcessor();
	@Test
	void configurationPropertiesBeanRegistrationAotProcessorIsRegistered() {
		assertThat(AotServices.factories().load(BeanRegistrationAotProcessor.class))
			.anyMatch(ConfigurationPropertiesBeanRegistrationAotProcessor.class::isInstance);
	}
	@Test
	void processAheadOfTimeWithNoConfigurationPropertiesBean() {
		RootBeanDefinition beanDefinition = new RootBeanDefinition(String.class);
		this.beanFactory.registerBeanDefinition('test', beanDefinition);
		BeanRegistrationAotContribution contribution = this.processor
			.processAheadOfTime(RegisteredBean.of(this.beanFactory, 'test'));
		assertThat(contribution).isNull();
	}
	@Test
	void processAheadOfTimeWithJavaBeanConfigurationPropertiesBean() {
		BeanRegistrationAotContribution contribution = process(JavaBeanSampleBean.class);
		assertThat(contribution).isNull();
	}
	@Test
	void processAheadOfTimeWithValueObjectConfigurationPropertiesBean() {
		BeanRegistrationAotContribution contribution = process(ValueObjectSampleBean.class);
		assertThat(contribution).isNotNull();
	}
	private BeanRegistrationAotContribution process(Class<?> type) {
		ConfigurationPropertiesBeanRegistrar beanRegistrar = new ConfigurationPropertiesBeanRegistrar(this.beanFactory);
		beanRegistrar.register(type);
		RegisteredBean registeredBean = RegisteredBean.of(this.beanFactory,
				this.beanFactory.getBeanDefinitionNames()[0]);
		return this.processor.processAheadOfTime(registeredBean);
	}
	@Test
	@CompileWithForkedClassLoader
	void aotContributedInitializerBindsValueObject() {
		compile(createContext(ValueObjectSampleBeanConfiguration.class), (freshContext) -> {
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(freshContext, 'test.name=Hello');
			freshContext.refresh();
			ValueObjectSampleBean bean = freshContext.getBean(ValueObjectSampleBean.class);
			assertThat(bean.name).isEqualTo('Hello');
		});
	}
	@Test
	@CompileWithForkedClassLoader
	void aotContributedInitializerBindsValueObjectWithSpecificConstructor() {
		compile(createContext(ValueObjectSampleBeanWithSpecificConstructorConfiguration.class), (freshContext) -> {
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(freshContext, 'test.name=Hello',
					'test.counter=30');
			freshContext.refresh();
			ValueObjectWithSpecificConstructorSampleBean bean = freshContext
				.getBean(ValueObjectWithSpecificConstructorSampleBean.class);
			assertThat(bean.name).isEqualTo('Hello');
			assertThat(bean.counter).isEqualTo(30);
		});
	}
	@Test
	@CompileWithForkedClassLoader
	void aotContributedInitializerBindsJavaBean() {
		compile(createContext(), (freshContext) -> {
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(freshContext, 'test.name=Hello');
			freshContext.refresh();
			JavaBeanSampleBean bean = freshContext.getBean(JavaBeanSampleBean.class);
			assertThat(bean.getName()).isEqualTo('Hello');
		});
	}
	@Test
	@CompileWithForkedClassLoader
	void aotContributedInitializerBindsScannedValueObject() {
		compile(createContext(ScanTestConfiguration.class), (freshContext) -> {
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(freshContext, 'b.first.name=Hello');
			freshContext.refresh();
			BFirstProperties bean = freshContext.getBean(BFirstProperties.class);
			assertThat(bean.getName()).isEqualTo('Hello');
		});
	}
	@Test
	@CompileWithForkedClassLoader
	void aotContributedInitializerBindsScannedJavaBean() {
		compile(createContext(ScanTestConfiguration.class), (freshContext) -> {
			TestPropertySourceUtils.addInlinedPropertiesToEnvironment(freshContext, 'b.second.number=42');
			freshContext.refresh();
			BSecondProperties bean = freshContext.getBean(BSecondProperties.class);
			assertThat(bean.getNumber()).isEqualTo(42);
		});
	}
	private GenericApplicationContext createContext(Class<?>... types) {
		GenericApplicationContext context = new AnnotationConfigApplicationContext();
		context.registerBean(JavaBeanSampleBeanConfiguration.class);
		Arrays.stream(types).forEach((type) -> context.registerBean(type));
		return context;
	}
	@SuppressWarnings('unchecked')
	private void compile(GenericApplicationContext context, Consumer<GenericApplicationContext> freshContext) {
		TestGenerationContext generationContext = new TestGenerationContext(TestTarget.class);
		ClassName className = new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext);
		generationContext.writeGeneratedContent();
		TestCompiler.forSystem().with(generationContext).compile((compiled) -> {
			GenericApplicationContext freshApplicationContext = new GenericApplicationContext();
			ApplicationContextInitializer<GenericApplicationContext> initializer = compiled
				.getInstance(ApplicationContextInitializer.class, className.toString());
			initializer.initialize(freshApplicationContext);
			freshContext.accept(freshApplicationContext);
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(JavaBeanSampleBean.class)
	static class JavaBeanSampleBeanConfiguration {
	}
	@ConfigurationProperties('test')
	public static class JavaBeanSampleBean {
		private String name;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ValueObjectSampleBean.class)
	static class ValueObjectSampleBeanConfiguration {
	}
	@ConfigurationProperties('test')
	public static class ValueObjectSampleBean {
		@SuppressWarnings('unused')
		private final String name;
		ValueObjectSampleBean(String name) {
			this.name = name;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ValueObjectWithSpecificConstructorSampleBean.class)
	static class ValueObjectSampleBeanWithSpecificConstructorConfiguration {
	}
	@ConfigurationProperties('test')
	public static class ValueObjectWithSpecificConstructorSampleBean {
		@SuppressWarnings('unused')
		private final String name;
		@SuppressWarnings('unused')
		private final Integer counter;
		ValueObjectWithSpecificConstructorSampleBean(String name, Integer counter) {
			this.name = name;
			this.counter = counter;
		}
		@SuppressWarnings('unused')
		private ValueObjectWithSpecificConstructorSampleBean(String name) {
			this(name, 42);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConfigurationPropertiesScan(basePackageClasses = BScanConfiguration.class)
	static class ScanTestConfiguration {
	}
	static class TestTarget {
	}
}
/*
package org.springframework.boot.context.properties;
/**
public class MultiConstructorConfigurationProperties {
	private String name;
	private int age;
	public MultiConstructorConfigurationProperties() {
	}
	public MultiConstructorConfigurationProperties(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return this.age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBindHandlerAdvisorTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@AfterEach
	void cleanup() {
		this.context.close();
	}
	@Test
	void loadWithoutConfigurationPropertiesBindHandlerAdvisor() {
		load(WithoutConfigurationPropertiesBindHandlerAdvisor.class, 'foo.bar.default.content-type=text/plain',
				'foo.bar.bindings.input.destination=d1', 'foo.bar.bindings.input.content-type=text/xml',
				'foo.bar.bindings.output.destination=d2');
		BindingServiceProperties properties = this.context.getBean(BindingServiceProperties.class);
		BindingProperties input = properties.getBindings().get('input');
		assertThat(input.getDestination()).isEqualTo('d1');
		assertThat(input.getContentType()).isEqualTo('text/xml');
		BindingProperties output = properties.getBindings().get('output');
		assertThat(output.getDestination()).isEqualTo('d2');
		assertThat(output.getContentType()).isEqualTo('application/json');
	}
	@Test
	void loadWithConfigurationPropertiesBindHandlerAdvisor() {
		load(WithConfigurationPropertiesBindHandlerAdvisor.class, 'foo.bar.default.content-type=text/plain',
				'foo.bar.bindings.input.destination=d1', 'foo.bar.bindings.input.content-type=text/xml',
				'foo.bar.bindings.output.destination=d2');
		BindingServiceProperties properties = this.context.getBean(BindingServiceProperties.class);
		BindingProperties input = properties.getBindings().get('input');
		assertThat(input.getDestination()).isEqualTo('d1');
		assertThat(input.getContentType()).isEqualTo('text/xml');
		BindingProperties output = properties.getBindings().get('output');
		assertThat(output.getDestination()).isEqualTo('d2');
		assertThat(output.getContentType()).isEqualTo('text/plain');
	}
	private AnnotationConfigApplicationContext load(Class<?> configuration, String... inlinedProperties) {
		return load(new Class<?>[] { configuration }, inlinedProperties);
	}
	private AnnotationConfigApplicationContext load(Class<?>[] configuration, String... inlinedProperties) {
		this.context.register(configuration);
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, inlinedProperties);
		this.context.refresh();
		return this.context;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(BindingServiceProperties.class)
	static class WithoutConfigurationPropertiesBindHandlerAdvisor {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(BindingServiceProperties.class)
	@Import(DefaultValuesConfigurationPropertiesBindHandlerAdvisor.class)
	static class WithConfigurationPropertiesBindHandlerAdvisor {
	}
	static class DefaultValuesConfigurationPropertiesBindHandlerAdvisor
			implements ConfigurationPropertiesBindHandlerAdvisor {
		@Override
		public BindHandler apply(BindHandler bindHandler) {
			return new DefaultValuesBindHandler(bindHandler);
		}
	}
	static class DefaultValuesBindHandler extends AbstractBindHandler {
		private final Map<ConfigurationPropertyName, ConfigurationPropertyName> mappings;
		DefaultValuesBindHandler(BindHandler bindHandler) {
			super(bindHandler);
			this.mappings = new LinkedHashMap<>();
			this.mappings.put(ConfigurationPropertyName.of('foo.bar.bindings'),
					ConfigurationPropertyName.of('foo.bar.default'));
		}
		@Override
		public <T> Bindable<T> onStart(ConfigurationPropertyName name, Bindable<T> target, BindContext context) {
			ConfigurationPropertyName defaultName = getDefaultName(name);
			if (defaultName != null) {
				BindResult<T> result = context.getBinder().bind(defaultName, target);
				if (result.isBound()) {
					return target.withExistingValue(result.get());
				}
			}
			return super.onStart(name, target, context);
		}
		private ConfigurationPropertyName getDefaultName(ConfigurationPropertyName name) {
			for (Map.Entry<ConfigurationPropertyName, ConfigurationPropertyName> mapping : this.mappings.entrySet()) {
				ConfigurationPropertyName from = mapping.getKey();
				ConfigurationPropertyName to = mapping.getValue();
				if (name.getNumberOfElements() == from.getNumberOfElements() + 1 && from.isParentOf(name)) {
					return to;
				}
			}
			return null;
		}
	}
	@ConfigurationProperties('foo.bar')
	static class BindingServiceProperties {
		private final Map<String, BindingProperties> bindings = new TreeMap<>();
		Map<String, BindingProperties> getBindings() {
			return this.bindings;
		}
	}
	static class BindingProperties {
		private String destination;
		private String contentType = 'application/json';
		String getDestination() {
			return this.destination;
		}
		void setDestination(String destination) {
			this.destination = destination;
		}
		String getContentType() {
			return this.contentType;
		}
		void setContentType(String contentType) {
			this.contentType = contentType;
		}
	}
}
/*
package org.springframework.boot.context.properties;
/**
class ConfigurationPropertiesBeanRegistrarTests {
	private final BeanDefinitionRegistry registry = new DefaultListableBeanFactory();
	private final ConfigurationPropertiesBeanRegistrar registrar = new ConfigurationPropertiesBeanRegistrar(
			this.registry);
	@Test
	void registerWhenNotAlreadyRegisteredAddBeanDefinition() {
		String beanName = 'beancp-' + BeanConfigurationProperties.class.getName();
		this.registrar.register(BeanConfigurationProperties.class);
		BeanDefinition definition = this.registry.getBeanDefinition(beanName);
		assertThat(definition).isNotNull();
		assertThat(definition.getBeanClassName()).isEqualTo(BeanConfigurationProperties.class.getName());
	}
	@Test
	void registerWhenAlreadyContainsNameDoesNotReplace() {
		String beanName = 'beancp-' + BeanConfigurationProperties.class.getName();
		this.registry.registerBeanDefinition(beanName, new RootBeanDefinition());
		this.registrar.register(BeanConfigurationProperties.class);
		BeanDefinition definition = this.registry.getBeanDefinition(beanName);
		assertThat(definition).isNotNull();
		assertThat(definition.getBeanClassName()).isNull();
	}
	@Test
	void registerWhenNoAnnotationThrowsException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> this.registrar.register(NoAnnotationConfigurationProperties.class))
			.withMessageContaining('No ConfigurationProperties annotation found');
	}
	@Test
	void registerWhenValueObjectRegistersValueObjectBeanDefinition() {
		String beanName = 'valuecp-' + ValueObjectConfigurationProperties.class.getName();
		this.registrar.register(ValueObjectConfigurationProperties.class);
		BeanDefinition definition = this.registry.getBeanDefinition(beanName);
		assertThat(definition).satisfies(hasBindMethodAttribute(BindMethod.VALUE_OBJECT));
	}
	@Test
	void registerWhenNotValueObjectRegistersRootBeanDefinitionWithJavaBeanBindMethod() {
		String beanName = MultiConstructorBeanConfigurationProperties.class.getName();
		this.registrar.register(MultiConstructorBeanConfigurationProperties.class);
		BeanDefinition definition = this.registry.getBeanDefinition(beanName);
		assertThat(definition).satisfies(hasBindMethodAttribute(BindMethod.JAVA_BEAN));
	}
	@Test
	void registerWhenNoScopeUsesSingleton() {
		String beanName = 'beancp-' + BeanConfigurationProperties.class.getName();
		this.registrar.register(BeanConfigurationProperties.class);
		BeanDefinition definition = this.registry.getBeanDefinition(beanName);
		assertThat(definition).isNotNull();
		assertThat(definition.getScope()).isEqualTo(BeanDefinition.SCOPE_SINGLETON);
	}
	@Test
	void registerScopedBeanDefinition() {
		String beanName = 'beancp-' + ScopedBeanConfigurationProperties.class.getName();
		this.registrar.register(ScopedBeanConfigurationProperties.class);
		BeanDefinition beanDefinition = this.registry.getBeanDefinition(beanName);
		assertThat(beanDefinition).isNotNull();
		assertThat(beanDefinition.getBeanClassName()).isEqualTo(ScopedBeanConfigurationProperties.class.getName());
		assertThat(beanDefinition.getScope()).isEqualTo(BeanDefinition.SCOPE_PROTOTYPE);
	}
	@Test
	void registerScopedBeanDefinitionWithProxyMode() {
		String beanName = 'beancp-' + ProxyScopedBeanConfigurationProperties.class.getName();
		this.registrar.register(ProxyScopedBeanConfigurationProperties.class);
		BeanDefinition proxiedBeanDefinition = this.registry.getBeanDefinition(beanName);
		assertThat(proxiedBeanDefinition).isNotNull();
		assertThat(proxiedBeanDefinition.getBeanClassName()).isEqualTo(ScopedProxyFactoryBean.class.getName());
		String targetBeanName = (String) proxiedBeanDefinition.getPropertyValues().get('targetBeanName');
		assertThat(targetBeanName).isNotNull();
		BeanDefinition beanDefinition = this.registry.getBeanDefinition(targetBeanName);
		assertThat(beanDefinition).isNotNull();
		assertThat(beanDefinition.getBeanClassName()).isEqualTo(ProxyScopedBeanConfigurationProperties.class.getName());
		assertThat(beanDefinition.getScope()).isEqualTo(BeanDefinition.SCOPE_PROTOTYPE);
	}
	@Test
	void registerBeanDefinitionWithCommonDefinitionAnnotations() {
		String beanName = 'beancp-' + PrimaryConfigurationProperties.class.getName();
		this.registrar.register(PrimaryConfigurationProperties.class);
		BeanDefinition beanDefinition = this.registry.getBeanDefinition(beanName);
		assertThat(beanDefinition).isNotNull();
		assertThat(beanDefinition.isPrimary()).isEqualTo(true);
	}
	private Consumer<BeanDefinition> hasBindMethodAttribute(BindMethod bindMethod) {
		return (definition) -> {
			assertThat(definition.hasAttribute(BindMethod.class.getName())).isTrue();
			assertThat(definition.getAttribute(BindMethod.class.getName())).isEqualTo(bindMethod);
		};
	}
	@ConfigurationProperties(prefix = 'beancp')
	static class BeanConfigurationProperties {
	}
	@ConfigurationProperties(prefix = 'beancp')
	@Scope(BeanDefinition.SCOPE_PROTOTYPE)
	static class ScopedBeanConfigurationProperties {
	}
	@ConfigurationProperties(prefix = 'beancp')
	@Scope(scopeName = BeanDefinition.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
	static class ProxyScopedBeanConfigurationProperties {
	}
	@ConfigurationProperties(prefix = 'beancp')
	@Primary
	static class PrimaryConfigurationProperties {
	}
	static class NoAnnotationConfigurationProperties {
	}
	@ConfigurationProperties('valuecp')
	static class ValueObjectConfigurationProperties {
		ValueObjectConfigurationProperties(String name) {
		}
	}
	@ConfigurationProperties
	static class MultiConstructorBeanConfigurationProperties {
		MultiConstructorBeanConfigurationProperties() {
		}
		MultiConstructorBeanConfigurationProperties(String name) {
		}
	}
}
/*
package org.springframework.boot.context.properties.scan.valid.b;
/**
public class BScanConfiguration {
	public interface BProperties {
	}
	@ConfigurationProperties(prefix = 'b.first')
	public static class BFirstProperties implements BProperties {
		private final String name;
		public BFirstProperties(String name) {
			this.name = name;
		}
		public String getName() {
			return this.name;
		}
	}
	@ConfigurationProperties(prefix = 'b.second')
	public static class BSecondProperties implements BProperties {
		private int number;
		public int getNumber() {
			return this.number;
		}
		public void setNumber(int number) {
			this.number = number;
		}
	}
}
/*
package org.springframework.boot.context.properties.scan.valid;
/**
@ConfigurationPropertiesScan
public class ConfigurationPropertiesScanConfiguration {
	@ConfigurationPropertiesScan
	@EnableConfigurationProperties({ ConfigurationPropertiesScanConfiguration.FooProperties.class })
	public static class TestConfiguration {
	}
	@ConfigurationPropertiesScan(basePackages = 'org.springframework.boot.context.properties.scan.valid.a',
			basePackageClasses = BScanConfiguration.class)
	public static class DifferentPackageConfiguration {
	}
	@ConfigurationProperties(prefix = 'foo')
	static class FooProperties {
	}
	@ConfigurationProperties(prefix = 'bar')
	static class BarProperties {
		BarProperties(String foo) {
		}
	}
	@ConfigurationProperties(prefix = 'bing')
	static class BingProperties {
		BingProperties() {
		}
		BingProperties(String foo) {
		}
	}
}
/*
package org.springframework.boot.context.properties.scan.valid.a;
/**
public class AScanConfiguration {
	@ConfigurationProperties(prefix = 'a')
	static class AProperties {
	}
	@Profile('test')
	@ConfigurationProperties(prefix = 'profile')
	static class MyProfileProperties {
	}
	@Conditional(TestResourceCondition.class)
	@ConfigurationProperties(prefix = 'resource')
	static class MyResourceProperties {
	}
	static class TestResourceCondition implements Condition {
		@Override
		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
			return context.getResourceLoader().getResource('test').exists();
		}
	}
}
/*
package org.springframework.boot.context.properties.scan.combined.c;
/**
public class CombinedConfiguration {
	@Component
	@ConfigurationProperties(prefix = 'b')
	static class MyProperties {
	}
}
/*
package org.springframework.boot.context.properties.scan.combined.d;
/**
public class OtherCombinedConfiguration {
	@RestController
	@ConfigurationProperties(prefix = 'c')
	static class MyControllerProperties {
	}
}
/*
package org.springframework.boot.context.properties;
/**
class NotConstructorBoundInjectionFailureAnalyzerTests {
	private final NotConstructorBoundInjectionFailureAnalyzer analyzer = new NotConstructorBoundInjectionFailureAnalyzer();
	@Test
	void failureAnalysisForConfigurationPropertiesThatShouldHaveBeenConstructorBound() {
		FailureAnalysis analysis = analyzeFailure(
				createFailure(ShouldHaveUsedConstructorBindingPropertiesConfiguration.class));
		assertThat(analysis.getDescription()).isEqualTo(ConstructorBoundProperties.class.getSimpleName()
				+ ' is annotated with @' + ConstructorBinding.class.getSimpleName()
				+ ' but it is defined as a regular bean which caused dependency injection to fail.');
		assertThat(analysis.getAction())
			.isEqualTo('Update your configuration so that ' + ConstructorBoundProperties.class.getSimpleName()
					+ ' is defined via @' + ConfigurationPropertiesScan.class.getSimpleName() + ' or @'
					+ EnableConfigurationProperties.class.getSimpleName() + '.');
	}
	@Test
	void failureAnalysisForNonConstructorBoundProperties() {
		FailureAnalysis analysis = analyzeFailure(createFailure(JavaBeanBoundPropertiesConfiguration.class));
		assertThat(analysis).isNull();
	}
	private FatalBeanException createFailure(Class<?> config) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			context.register(config);
			context.refresh();
			return null;
		}
		catch (FatalBeanException ex) {
			return ex;
		}
	}
	private FailureAnalysis analyzeFailure(Exception failure) {
		assertThat(failure).isNotNull();
		FailureAnalysis analysis = this.analyzer.analyze(failure);
		if (analysis != null) {
			new LoggingFailureAnalysisReporter().report(analysis);
		}
		return analysis;
	}
	@ConfigurationProperties('test')
	static class ConstructorBoundProperties {
		private final String name;
		ConstructorBoundProperties(String name) {
			this.name = name;
		}
		String getName() {
			return this.name;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ConstructorBoundProperties.class)
	static class ShouldHaveUsedConstructorBindingPropertiesConfiguration {
	}
	@ConfigurationProperties('test')
	static class JavaBeanBoundProperties {
		private String name;
		@Autowired
		JavaBeanBoundProperties(String dependency) {
		}
		String getName() {
			return this.name;
		}
		void setName(String name) {
			this.name = name;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(JavaBeanBoundProperties.class)
	static class JavaBeanBoundPropertiesConfiguration {
	}
}
/*
package org.springframework.boot.context.properties;
/**
class IncompatibleConfigurationFailureAnalyzerTests {
	@Test
	void incompatibleConfigurationListsKeys() {
		FailureAnalysis failureAnalysis = performAnalysis('spring.first.key', 'spring.second.key');
		assertThat(failureAnalysis.getDescription()).contains(
				'The following configuration properties have incompatible values: [spring.first.key, spring.second.key]');
		assertThat(failureAnalysis.getAction())
			.contains('Review the docs for spring.first.key, spring.second.key and change the configured values.');
	}
	private FailureAnalysis performAnalysis(String... keys) {
		IncompatibleConfigurationException failure = new IncompatibleConfigurationException(keys);
		return new IncompatibleConfigurationFailureAnalyzer().analyze(failure);
	}
}
/*
package org.springframework.boot.context.logging;
/**
@ExtendWith(OutputCaptureExtension.class)
class LoggingApplicationListenerIntegrationTests {
	@Test
	void loggingSystemRegisteredInTheContext() {
		try (ConfigurableApplicationContext context = new SpringApplicationBuilder(SampleService.class)
			.web(WebApplicationType.NONE)
			.run()) {
			SampleService service = context.getBean(SampleService.class);
			assertThat(service.loggingSystem).isNotNull();
		}
	}
	@Test
	void logFileRegisteredInTheContextWhenApplicable(@TempDir File tempDir) {
		String logFile = new File(tempDir, 'test.log').getAbsolutePath();
		try (ConfigurableApplicationContext context = new SpringApplicationBuilder(SampleService.class)
			.web(WebApplicationType.NONE)
			.properties('logging.file.name=' + logFile)
			.run()) {
			SampleService service = context.getBean(SampleService.class);
			assertThat(service.logFile).isNotNull();
			assertThat(service.logFile).hasToString(logFile);
		}
		finally {
			System.clearProperty(LoggingSystemProperty.LOG_FILE.getEnvironmentVariableName());
		}
	}
	@Test
	void loggingPerformedDuringChildApplicationStartIsNotLost(CapturedOutput output) {
		new SpringApplicationBuilder(Config.class).web(WebApplicationType.NONE)
			.child(Config.class)
			.web(WebApplicationType.NONE)
			.listeners(new ApplicationListener<ApplicationStartingEvent>() {
				private final Logger logger = LoggerFactory.getLogger(getClass());
				@Override
				public void onApplicationEvent(ApplicationStartingEvent event) {
					this.logger.info('Child application starting');
				}
			})
			.run();
		assertThat(output).contains('Child application starting');
	}
	@Component
	static class SampleService {
		private final LoggingSystem loggingSystem;
		private final LogFile logFile;
		SampleService(LoggingSystem loggingSystem, ObjectProvider<LogFile> logFile) {
			this.loggingSystem = loggingSystem;
			this.logFile = logFile.getIfAvailable();
		}
	}
	static class Config {
	}
}
/*
package org.springframework.boot.context.logging;
/**
@ExtendWith(OutputCaptureExtension.class)
@ClassPathExclusions('log4j*.jar')
class LoggingApplicationListenerTests {
	private static final String[] NO_ARGS = {};
	private final LoggingApplicationListener listener = new LoggingApplicationListener();
	private final LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
	private final ch.qos.logback.classic.Logger logger = this.loggerContext.getLogger(getClass());
	private final DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
	private final SpringApplication springApplication = new SpringApplication(TestConfiguration.class);
	private final GenericApplicationContext context = new GenericApplicationContext();
	@TempDir
	public Path tempDir;
	private File logFile;
	private Set<Object> systemPropertyNames;
	private CapturedOutput output;
	@BeforeEach
	void init(CapturedOutput output) throws IOException {
		this.systemPropertyNames = new HashSet<>(System.getProperties().keySet());
		this.output = output;
		this.logFile = new File(this.tempDir.toFile(), 'foo.log');
		LogManager.getLogManager().readConfiguration(JavaLoggingSystem.class.getResourceAsStream('logging.properties'));
		multicastEvent(new ApplicationStartingEvent(this.bootstrapContext, new SpringApplication(), NO_ARGS));
		new File(this.tempDir.toFile(), 'spring.log').delete();
		ConfigurableEnvironment environment = this.context.getEnvironment();
		ConfigurationPropertySources.attach(environment);
	}
	@AfterEach
	void clear() {
		LoggingSystem loggingSystem = LoggingSystem.get(getClass().getClassLoader());
		loggingSystem.setLogLevel('ROOT', LogLevel.INFO);
		loggingSystem.cleanUp();
		if (loggingSystem.getShutdownHandler() != null) {
			loggingSystem.getShutdownHandler().run();
		}
		System.clearProperty(LoggingSystem.class.getName());
		System.clearProperty(LoggingSystem.SYSTEM_PROPERTY);
		System.getProperties().keySet().retainAll(this.systemPropertyNames);
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void baseConfigLocation() {
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.info('Hello world', new RuntimeException('Expected'));
		assertThat(this.output).contains('Hello world');
		assertThat(this.output).doesNotContain('???');
		assertThat(this.output).contains('[junit-');
		assertThat(new File(this.tempDir + '/spring.log')).doesNotExist();
	}
	@Test
	void overrideConfigLocation() {
		addPropertiesToEnvironment(this.context, 'logging.config=classpath:logback-nondefault.xml');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.info('Hello world');
		assertThat(this.output).contains('Hello world').doesNotContain('???').startsWith('null ').endsWith('BOOTBOOT');
	}
	@Test
	@ClassPathExclusions('janino-*.jar')
	void tryingToUseJaninoWhenItIsNotOnTheClasspathFailsGracefully(CapturedOutput output) {
		addPropertiesToEnvironment(this.context, 'logging.config=classpath:logback-janino.xml');
		assertThatIllegalStateException()
			.isThrownBy(() -> this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader()));
		assertThat(output)
			.contains('Logging system failed to initialize using configuration from "classpath:logback-janino.xml"');
	}
	@Test
	void trailingWhitespaceInLoggingConfigShouldBeTrimmed() {
		addPropertiesToEnvironment(this.context, 'logging.config=classpath:logback-nondefault.xml ');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.info('Hello world');
		assertThat(this.output).contains('Hello world').doesNotContain('???').startsWith('null ').endsWith('BOOTBOOT');
	}
	@Test
	void overrideConfigDoesNotExist() {
		addPropertiesToEnvironment(this.context, 'logging.config=doesnotexist.xml');
		assertThatIllegalStateException()
			.isThrownBy(() -> this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader()));
		assertThat(this.output)
			.contains('Logging system failed to initialize using configuration from "doesnotexist.xml"')
			.doesNotContain('JoranException');
	}
	@Test
	void azureDefaultLoggingConfigDoesNotCauseAFailure() {
		addPropertiesToEnvironment(this.context,
				'logging.config=-Djava.util.logging.config.file=\'d:\\home\\site\\wwwroot\\bin\\apache-tomcat-7.0.52\\conf\\logging.properties\'');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.info('Hello world');
		assertThat(this.output).contains('Hello world').doesNotContain('???');
		assertThat(new File(this.tempDir.toFile(), '/spring.log')).doesNotExist();
	}
	@Test
	void tomcatNopLoggingConfigDoesNotCauseAFailure() {
		addPropertiesToEnvironment(this.context, 'LOGGING_CONFIG=-Dnop');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.info('Hello world');
		assertThat(this.output).contains('Hello world').doesNotContain('???');
		assertThat(new File(this.tempDir.toFile(), '/spring.log')).doesNotExist();
	}
	@Test
	void overrideConfigBroken() {
		addPropertiesToEnvironment(this.context, 'logging.config=classpath:logback-broken.xml');
		assertThatIllegalStateException().isThrownBy(() -> {
			this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
			assertThat(this.output).contains(
					'Logging system failed to initialize using configuration from "classpath:logback-broken.xml"');
			assertThat(this.output).contains('ConsolAppender');
		});
	}
	@Test
	void addLogFileProperty() {
		addPropertiesToEnvironment(this.context, 'logging.config=classpath:logback-nondefault.xml',
				'logging.file.name=' + this.logFile);
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		Log logger = LogFactory.getLog(LoggingApplicationListenerTests.class);
		String existingOutput = this.output.toString();
		logger.info('Hello world');
		String output = this.output.toString().substring(existingOutput.length()).trim();
		assertThat(output).startsWith(this.logFile.getAbsolutePath());
	}
	@Test
	void addLogFilePropertyWithDefault() {
		assertThat(this.logFile).doesNotExist();
		addPropertiesToEnvironment(this.context, 'logging.file.name=' + this.logFile);
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		Log logger = LogFactory.getLog(LoggingApplicationListenerTests.class);
		logger.info('Hello world');
		assertThat(this.logFile).isFile();
	}
	@Test
	void addLogPathProperty() {
		addPropertiesToEnvironment(this.context, 'logging.config=classpath:logback-nondefault.xml',
				'logging.file.path=' + this.tempDir);
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		Log logger = LogFactory.getLog(LoggingApplicationListenerTests.class);
		String existingOutput = this.output.toString();
		logger.info('Hello world');
		String output = this.output.toString().substring(existingOutput.length()).trim();
		assertThat(output).startsWith(new File(this.tempDir.toFile(), 'spring.log').getAbsolutePath());
	}
	@Test
	void parseDebugArg() {
		addPropertiesToEnvironment(this.context, 'debug');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.trace('testattrace');
		assertThat(this.output).contains('testatdebug');
		assertThat(this.output).doesNotContain('testattrace');
	}
	@Test
	void parseDebugArgExpandGroups() {
		addPropertiesToEnvironment(this.context, 'debug');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.loggerContext.getLogger('org.springframework.boot.actuate.endpoint.web').debug('testdebugwebgroup');
		this.loggerContext.getLogger('org.hibernate.SQL').debug('testdebugsqlgroup');
		assertThat(this.output).contains('testdebugwebgroup');
		assertThat(this.output).contains('testdebugsqlgroup');
		LoggerGroups loggerGroups = (LoggerGroups) ReflectionTestUtils.getField(this.listener, 'loggerGroups');
		assertThat(loggerGroups.get('web').getConfiguredLevel()).isEqualTo(LogLevel.DEBUG);
	}
	@Test
	void parseTraceArg() {
		addPropertiesToEnvironment(this.context, 'trace');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.trace('testattrace');
		assertThat(this.output).contains('testatdebug');
		assertThat(this.output).contains('testattrace');
	}
	@Test
	void disableDebugArg() {
		disableDebugTraceArg('debug=false');
	}
	@Test
	void disableTraceArg() {
		disableDebugTraceArg('trace=false');
	}
	private void disableDebugTraceArg(String... environment) {
		addPropertiesToEnvironment(this.context, environment);
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.trace('testattrace');
		assertThat(this.output).doesNotContain('testatdebug');
		assertThat(this.output).doesNotContain('testattrace');
	}
	@Test
	void parseLevels() {
		addPropertiesToEnvironment(this.context, 'logging.level.org.springframework.boot=TRACE');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.trace('testattrace');
		assertThat(this.output).contains('testatdebug');
		assertThat(this.output).contains('testattrace');
	}
	@Test
	void parseLevelsCaseInsensitive() {
		addPropertiesToEnvironment(this.context, 'logging.level.org.springframework.boot=TrAcE');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.trace('testattrace');
		assertThat(this.output).contains('testatdebug');
		assertThat(this.output).contains('testattrace');
	}
	@Test
	void parseLevelsTrimsWhitespace() {
		addPropertiesToEnvironment(this.context, 'logging.level.org.springframework.boot= trace ');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.trace('testattrace');
		assertThat(this.output).contains('testatdebug');
		assertThat(this.output).contains('testattrace');
	}
	@Test
	void parseLevelsWithPlaceholder() {
		addPropertiesToEnvironment(this.context, 'foo=TRACE', 'logging.level.org.springframework.boot=${foo}');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.trace('testattrace');
		assertThat(this.output).contains('testatdebug');
		assertThat(this.output).contains('testattrace');
	}
	@Test
	void parseLevelsFails() {
		this.logger.setLevel(Level.INFO);
		addPropertiesToEnvironment(this.context, 'logging.level.org.springframework.boot=GARBAGE');
		assertThatExceptionOfType(BindException.class)
			.isThrownBy(() -> this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader()));
	}
	@Test
	void parseLevelsNone() {
		addPropertiesToEnvironment(this.context, 'logging.level.org.springframework.boot=OFF');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.error('testaterror');
		assertThat(this.output).doesNotContain('testatdebug').doesNotContain('testaterror');
	}
	@Test
	void parseLevelsMapsFalseToOff() {
		addPropertiesToEnvironment(this.context, 'logging.level.org.springframework.boot=false');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		this.logger.error('testaterror');
		assertThat(this.output).doesNotContain('testatdebug').doesNotContain('testaterror');
	}
	@Test
	void parseArgsDisabled() {
		this.listener.setParseArgs(false);
		addPropertiesToEnvironment(this.context, 'debug');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		assertThat(this.output).doesNotContain('testatdebug');
	}
	@Test
	void parseArgsDoesntReplace() {
		this.listener.setSpringBootLogging(LogLevel.ERROR);
		this.listener.setParseArgs(false);
		multicastEvent(new ApplicationStartingEvent(this.bootstrapContext, this.springApplication,
				new String[] { '--debug' }));
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		assertThat(this.output).doesNotContain('testatdebug');
	}
	@Test
	void bridgeHandlerLifecycle() {
		assertThat(bridgeHandlerInstalled()).isTrue();
		multicastEvent(new ContextClosedEvent(this.context));
		assertThat(bridgeHandlerInstalled()).isFalse();
	}
	@Test
	void defaultExceptionConversionWord() {
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.info('Hello world', new RuntimeException('Wrapper', new RuntimeException('Expected')));
		assertThat(this.output).contains('Hello world');
		assertThat(this.output).doesNotContain('Wrapped by: java.lang.RuntimeException: Wrapper');
	}
	@Test
	void overrideExceptionConversionWord() {
		addPropertiesToEnvironment(this.context, 'logging.exceptionConversionWord=%rEx');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.info('Hello world', new RuntimeException('Wrapper', new RuntimeException('Expected')));
		assertThat(this.output).contains('Hello world');
		assertThat(this.output).contains('Wrapped by: java.lang.RuntimeException: Wrapper');
	}
	@Test
	void shutdownHookIsRegisteredByDefault() throws Exception {
		TestLoggingApplicationListener listener = new TestLoggingApplicationListener();
		Object registered = ReflectionTestUtils.getField(listener, TestLoggingApplicationListener.class,
				'shutdownHookRegistered');
		((AtomicBoolean) registered).set(false);
		System.setProperty(LoggingSystem.class.getName(), TestShutdownHandlerLoggingSystem.class.getName());
		multicastEvent(listener, new ApplicationStartingEvent(this.bootstrapContext, new SpringApplication(), NO_ARGS));
		listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertThat(listener.shutdownHook).isNotNull();
		listener.shutdownHook.run();
		assertThat(TestShutdownHandlerLoggingSystem.shutdownLatch.await(30, TimeUnit.SECONDS)).isTrue();
	}
	@Test
	void shutdownHookRegistrationCanBeDisabled() {
		TestLoggingApplicationListener listener = new TestLoggingApplicationListener();
		Object registered = ReflectionTestUtils.getField(listener, TestLoggingApplicationListener.class,
				'shutdownHookRegistered');
		((AtomicBoolean) registered).set(false);
		System.setProperty(LoggingSystem.class.getName(), TestShutdownHandlerLoggingSystem.class.getName());
		addPropertiesToEnvironment(this.context, 'logging.register_shutdown_hook=false');
		multicastEvent(listener, new ApplicationStartingEvent(this.bootstrapContext, new SpringApplication(), NO_ARGS));
		listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertThat(listener.shutdownHook).isNull();
	}
	@Test
	void closingContextCleansUpLoggingSystem() {
		System.setProperty(LoggingSystem.SYSTEM_PROPERTY, TestCleanupLoggingSystem.class.getName());
		multicastEvent(new ApplicationStartingEvent(this.bootstrapContext, this.springApplication, new String[0]));
		TestCleanupLoggingSystem loggingSystem = (TestCleanupLoggingSystem) ReflectionTestUtils.getField(this.listener,
				'loggingSystem');
		assertThat(loggingSystem.cleanedUp).isFalse();
		multicastEvent(new ContextClosedEvent(this.context));
		assertThat(loggingSystem.cleanedUp).isTrue();
	}
	@Test
	void closingChildContextDoesNotCleanUpLoggingSystem() {
		System.setProperty(LoggingSystem.SYSTEM_PROPERTY, TestCleanupLoggingSystem.class.getName());
		multicastEvent(new ApplicationStartingEvent(this.bootstrapContext, this.springApplication, new String[0]));
		TestCleanupLoggingSystem loggingSystem = (TestCleanupLoggingSystem) ReflectionTestUtils.getField(this.listener,
				'loggingSystem');
		assertThat(loggingSystem.cleanedUp).isFalse();
		GenericApplicationContext childContext = new GenericApplicationContext();
		childContext.setParent(this.context);
		multicastEvent(new ContextClosedEvent(childContext));
		assertThat(loggingSystem.cleanedUp).isFalse();
		multicastEvent(new ContextClosedEvent(this.context));
		assertThat(loggingSystem.cleanedUp).isTrue();
		childContext.close();
	}
	@Test
	void systemPropertiesAreSetForLoggingConfiguration() {
		addPropertiesToEnvironment(this.context, 'logging.exception-conversion-word=conversion',
				'logging.file.name=' + this.logFile, 'logging.file.path=path', 'logging.pattern.console=console',
				'logging.pattern.file=file', 'logging.pattern.level=level', 'logging.pattern.correlation=correlation',
				'logging.pattern.rolling-file-name=my.log.%d{yyyyMMdd}.%i.gz');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertThat(getSystemProperty(LoggingSystemProperty.CONSOLE_PATTERN)).isEqualTo('console');
		assertThat(getSystemProperty(LoggingSystemProperty.FILE_PATTERN)).isEqualTo('file');
		assertThat(getSystemProperty(LoggingSystemProperty.EXCEPTION_CONVERSION_WORD)).isEqualTo('conversion');
		assertThat(getSystemProperty(LoggingSystemProperty.LOG_FILE)).isEqualTo(this.logFile.getAbsolutePath());
		assertThat(getSystemProperty(LoggingSystemProperty.LEVEL_PATTERN)).isEqualTo('level');
		assertThat(getSystemProperty(LoggingSystemProperty.LOG_PATH)).isEqualTo('path');
		assertThat(getSystemProperty(LoggingSystemProperty.PID)).isNotNull();
	}
	@Test
	void environmentPropertiesIgnoreUnresolvablePlaceholders() {
		// gh-7719
		addPropertiesToEnvironment(this.context, 'logging.pattern.console=console ${doesnotexist}');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertThat(getSystemProperty(LoggingSystemProperty.CONSOLE_PATTERN)).isEqualTo('console ${doesnotexist}');
	}
	@Test
	void environmentPropertiesResolvePlaceholders() {
		addPropertiesToEnvironment(this.context, 'logging.pattern.console=console ${pid}');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertThat(getSystemProperty(LoggingSystemProperty.CONSOLE_PATTERN))
			.isEqualTo(this.context.getEnvironment().getProperty('logging.pattern.console'));
	}
	@Test
	void logFilePropertiesCanReferenceSystemProperties() {
		addPropertiesToEnvironment(this.context, 'logging.file.name=' + this.tempDir + '${PID}.log');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertThat(getSystemProperty(LoggingSystemProperty.LOG_FILE))
			.isEqualTo(this.tempDir + new ApplicationPid().toString() + '.log');
	}
	@Test
	void applicationFailedEventCleansUpLoggingSystem() {
		System.setProperty(LoggingSystem.SYSTEM_PROPERTY, TestCleanupLoggingSystem.class.getName());
		multicastEvent(new ApplicationStartingEvent(this.bootstrapContext, this.springApplication, new String[0]));
		TestCleanupLoggingSystem loggingSystem = (TestCleanupLoggingSystem) ReflectionTestUtils.getField(this.listener,
				'loggingSystem');
		assertThat(loggingSystem.cleanedUp).isFalse();
		multicastEvent(new ApplicationFailedEvent(this.springApplication, new String[0],
				new GenericApplicationContext(), new Exception()));
		assertThat(loggingSystem.cleanedUp).isTrue();
	}
	@Test
	void cleanupOccursAfterWebServerShutdown() {
		System.setProperty(LoggingSystem.SYSTEM_PROPERTY, TestCleanupLoggingSystem.class.getName());
		this.springApplication.setWebApplicationType(WebApplicationType.NONE);
		ConfigurableApplicationContext context = this.springApplication.run();
		ApplicationListener<?> listener = this.springApplication.getListeners()
			.stream()
			.filter(LoggingApplicationListener.class::isInstance)
			.findFirst()
			.get();
		TestCleanupLoggingSystem loggingSystem = (TestCleanupLoggingSystem) ReflectionTestUtils.getField(listener,
				'loggingSystem');
		assertThat(loggingSystem.cleanedUp).isFalse();
		WebServerStyleLifecycle lifecycle = context.getBean(WebServerStyleLifecycle.class);
		AtomicBoolean called = new AtomicBoolean();
		AtomicBoolean cleanupOnStop = new AtomicBoolean();
		lifecycle.onStop = () -> {
			called.set(true);
			cleanupOnStop.set(loggingSystem.cleanedUp);
		};
		context.close();
		assertThat(called).isTrue();
		assertThat(cleanupOnStop).isFalse();
		assertThat(loggingSystem.cleanedUp).isTrue();
	}
	@Test
	void lowPriorityPropertySourceShouldNotOverrideRootLoggerConfig() {
		MutablePropertySources propertySources = this.context.getEnvironment().getPropertySources();
		propertySources
			.addFirst(new MapPropertySource('test1', Collections.singletonMap('logging.level.ROOT', 'DEBUG')));
		propertySources.addLast(new MapPropertySource('test2', Collections.singletonMap('logging.level.root', 'WARN')));
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		this.logger.debug('testatdebug');
		assertThat(this.output).contains('testatdebug');
	}
	@Test
	void loggingGroupsDefaultsAreApplied() {
		addPropertiesToEnvironment(this.context, 'logging.level.web=TRACE');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertTraceEnabled('org.springframework.core', false);
		assertTraceEnabled('org.springframework.core.codec', true);
		assertTraceEnabled('org.springframework.http', true);
		assertTraceEnabled('org.springframework.web', true);
		assertTraceEnabled('org.springframework.boot.actuate.endpoint.web', true);
		assertTraceEnabled('org.springframework.boot.web.servlet.ServletContextInitializerBeans', true);
	}
	@Test
	void loggingGroupsCanBeDefined() {
		addPropertiesToEnvironment(this.context, 'logging.group.foo=com.foo.bar,com.foo.baz',
				'logging.level.foo=TRACE');
		this.listener.initialize(this.context.getEnvironment(), this.context.getClassLoader());
		assertTraceEnabled('com.foo', false);
		assertTraceEnabled('com.foo.bar', true);
		assertTraceEnabled('com.foo.baz', true);
	}
	private String getSystemProperty(LoggingSystemProperty property) {
		return System.getProperty(property.getEnvironmentVariableName());
	}
	private void assertTraceEnabled(String name, boolean expected) {
		assertThat(this.loggerContext.getLogger(name).isTraceEnabled()).isEqualTo(expected);
	}
	private void multicastEvent(ApplicationEvent event) {
		multicastEvent(this.listener, event);
	}
	private void multicastEvent(ApplicationListener<?> listener, ApplicationEvent event) {
		SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();
		multicaster.addApplicationListener(listener);
		multicaster.multicastEvent(event);
	}
	private boolean bridgeHandlerInstalled() {
		Logger rootLogger = LogManager.getLogManager().getLogger('');
		Handler[] handlers = rootLogger.getHandlers();
		for (Handler handler : handlers) {
			if (handler instanceof SLF4JBridgeHandler) {
				return true;
			}
		}
		return false;
	}
	private void addPropertiesToEnvironment(ConfigurableApplicationContext context, String... pairs) {
		ConfigurableEnvironment environment = context.getEnvironment();
		Map<String, Object> properties = new HashMap<>();
		for (String pair : pairs) {
			String[] split = pair.split('=', 2);
			properties.put(split[0], (split.length == 2) ? split[1] : '');
		}
		MapPropertySource propertySource = new MapPropertySource('logging-config', properties);
		environment.getPropertySources().addFirst(propertySource);
	}
	static class TestShutdownHandlerLoggingSystem extends AbstractLoggingSystem {
		private static CountDownLatch shutdownLatch;
		TestShutdownHandlerLoggingSystem(ClassLoader classLoader) {
			super(classLoader);
			TestShutdownHandlerLoggingSystem.shutdownLatch = new CountDownLatch(1);
		}
		@Override
		protected String[] getStandardConfigLocations() {
			return new String[] { 'foo.bar' };
		}
		@Override
		protected void loadDefaults(LoggingInitializationContext initializationContext, LogFile logFile) {
		}
		@Override
		protected void loadConfiguration(LoggingInitializationContext initializationContext, String location,
				LogFile logFile) {
		}
		@Override
		public void setLogLevel(String loggerName, LogLevel level) {
		}
		@Override
		public List<LoggerConfiguration> getLoggerConfigurations() {
			return null;
		}
		@Override
		public LoggerConfiguration getLoggerConfiguration(String loggerName) {
			return null;
		}
		@Override
		public Runnable getShutdownHandler() {
			return () -> TestShutdownHandlerLoggingSystem.shutdownLatch.countDown();
		}
	}
	static class TestLoggingApplicationListener extends LoggingApplicationListener {
		private Runnable shutdownHook;
		@Override
		void registerShutdownHook(Runnable shutdownHook) {
			this.shutdownHook = shutdownHook;
		}
	}
	static final class TestCleanupLoggingSystem extends LoggingSystem {
		private boolean cleanedUp = false;
		TestCleanupLoggingSystem(ClassLoader classLoader) {
		}
		@Override
		public void beforeInitialize() {
		}
		@Override
		public void setLogLevel(String loggerName, LogLevel level) {
		}
		@Override
		public List<LoggerConfiguration> getLoggerConfigurations() {
			return null;
		}
		@Override
		public LoggerConfiguration getLoggerConfiguration(String loggerName) {
			return null;
		}
		@Override
		public void cleanUp() {
			this.cleanedUp = true;
		}
	}
	@Configuration
	@Import(WebServerStyleLifecycle.class)
	static class TestConfiguration {
	}
	static class WebServerStyleLifecycle implements SmartLifecycle {
		private volatile boolean running;
		Runnable onStop;
		@Override
		public void start() {
			this.running = true;
		}
		@Override
		public void stop() {
			this.running = false;
			this.onStop.run();
		}
		@Override
		public boolean isRunning() {
			return this.running;
		}
		@Override
		public int getPhase() {
			return Integer.MAX_VALUE - 1;
		}
	}
}
/*
package org.springframework.boot.context;
/**
class TypeExcludeFilterTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void loadsTypeExcludeFilters() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.getBeanFactory().registerSingleton('filter1', new WithoutMatchOverrideFilter());
		this.context.getBeanFactory().registerSingleton('filter2', new SampleTypeExcludeFilter());
		this.context.register(Config.class);
		this.context.refresh();
		assertThat(this.context.getBean(ExampleComponent.class)).isNotNull();
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(ExampleFilteredComponent.class));
	}
	@Configuration(proxyBeanMethods = false)
	@ComponentScan(basePackageClasses = SampleTypeExcludeFilter.class,
			excludeFilters = @Filter(type = FilterType.CUSTOM, classes = SampleTypeExcludeFilter.class))
	static class Config {
	}
	static class WithoutMatchOverrideFilter extends TypeExcludeFilter {
	}
}
/*
package org.springframework.boot.context;
/**
@ExtendWith(OutputCaptureExtension.class)
class ConfigurationWarningsApplicationContextInitializerTests {
	private static final String DEFAULT_SCAN_WARNING = 'Your ApplicationContext is unlikely to '
			+ 'start due to a @ComponentScan of the default package.';
	private static final String ORGSPRING_SCAN_WARNING = 'Your ApplicationContext is unlikely to '
			+ 'start due to a @ComponentScan of "org.springframework".';
	@Test
	void logWarningInDefaultPackage(CapturedOutput output) {
		load(InDefaultPackageConfiguration.class);
		assertThat(output).contains(DEFAULT_SCAN_WARNING);
	}
	@Test
	void logWarningInDefaultPackageAndMetaAnnotation(CapturedOutput output) {
		load(InDefaultPackageWithMetaAnnotationConfiguration.class);
		assertThat(output).contains(DEFAULT_SCAN_WARNING);
	}
	@Test
	void noLogIfInRealPackage(CapturedOutput output) {
		load(InRealPackageConfiguration.class);
		assertThat(output).doesNotContain(DEFAULT_SCAN_WARNING);
	}
	@Test
	void noLogWithoutComponentScanAnnotation(CapturedOutput output) {
		load(InDefaultPackageWithoutScanConfiguration.class);
		assertThat(output).doesNotContain(DEFAULT_SCAN_WARNING);
	}
	@Test
	void noLogIfHasValue(CapturedOutput output) {
		load(InDefaultPackageWithValueConfiguration.class);
		assertThat(output).doesNotContain(DEFAULT_SCAN_WARNING);
	}
	@Test
	void noLogIfHasBasePackages(CapturedOutput output) {
		load(InDefaultPackageWithBasePackagesConfiguration.class);
		assertThat(output).doesNotContain(DEFAULT_SCAN_WARNING);
	}
	@Test
	void noLogIfHasBasePackageClasses(CapturedOutput output) {
		load(InDefaultPackageWithBasePackageClassesConfiguration.class);
		assertThat(output).doesNotContain(DEFAULT_SCAN_WARNING);
	}
	@Test
	void logWarningInOrgSpringPackage(CapturedOutput output) {
		load(InOrgSpringPackageConfiguration.class);
		assertThat(output).contains(ORGSPRING_SCAN_WARNING);
	}
	@Test
	void logWarningIfScanningProblemPackages(CapturedOutput output) {
		load(InRealButScanningProblemPackages.class);
		assertThat(output).contains('Your ApplicationContext is unlikely to start due to a '
				+ '@ComponentScan of the default package, "org.springframework".');
	}
	private void load(Class<?> configClass) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			new TestConfigurationWarningsApplicationContextInitializer().initialize(context);
			context.register(configClass);
			context.refresh();
		}
	}
	/**
	 * Testable version of {@link ConfigurationWarningsApplicationContextInitializer}.
	 */
	static class TestConfigurationWarningsApplicationContextInitializer
			extends ConfigurationWarningsApplicationContextInitializer {
		@Override
		protected Check[] getChecks() {
			return new Check[] { new TestComponentScanPackageCheck() };
		}
	}
	/**
	 * Testable ComponentScanPackageCheck that doesn"t need to use the default or
	 * {@code org.springframework} package.
	 */
	static class TestComponentScanPackageCheck extends ComponentScanPackageCheck {
		@Override
		protected Set<String> getComponentScanningPackages(BeanDefinitionRegistry registry) {
			Set<String> scannedPackages = super.getComponentScanningPackages(registry);
			Set<String> result = new LinkedHashSet<>();
			for (String scannedPackage : scannedPackages) {
				if (scannedPackage.endsWith('dflt')) {
					result.add('');
				}
				else if (scannedPackage.endsWith('orgspring')) {
					result.add('org.springframework');
				}
				else {
					result.add(scannedPackage);
				}
			}
			return result;
		}
	}
}
/*
package org.springframework.boot.context.event;
/**
class EventPublishingRunListenerTests {
	@Test
	void shouldPublishLifecycleEvents() {
		DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
		StaticApplicationContext context = new StaticApplicationContext();
		TestApplicationListener applicationListener = new TestApplicationListener();
		SpringApplication application = mock(SpringApplication.class);
		given(application.getListeners()).willReturn(Collections.singleton(applicationListener));
		EventPublishingRunListener publishingListener = new EventPublishingRunListener(application, null);
		applicationListener.assertReceivedNoEvents();
		publishingListener.starting(bootstrapContext);
		applicationListener.assertReceivedEvent(ApplicationStartingEvent.class);
		publishingListener.environmentPrepared(bootstrapContext, null);
		applicationListener.assertReceivedEvent(ApplicationEnvironmentPreparedEvent.class);
		publishingListener.contextPrepared(context);
		applicationListener.assertReceivedEvent(ApplicationContextInitializedEvent.class);
		publishingListener.contextLoaded(context);
		applicationListener.assertReceivedEvent(ApplicationPreparedEvent.class);
		context.refresh();
		publishingListener.started(context, null);
		applicationListener.assertReceivedEvent(ApplicationStartedEvent.class, AvailabilityChangeEvent.class);
		publishingListener.ready(context, null);
		applicationListener.assertReceivedEvent(ApplicationReadyEvent.class, AvailabilityChangeEvent.class);
	}
	@Test
	void initialEventListenerCanAddAdditionalListenersToApplication() {
		SpringApplication application = new SpringApplication();
		DefaultBootstrapContext bootstrapContext = new DefaultBootstrapContext();
		ConfigurableEnvironment environment = new StandardEnvironment();
		TestApplicationListener lateAddedApplicationListener = new TestApplicationListener();
		ApplicationListener<ApplicationStartingEvent> listener = (event) -> event.getSpringApplication()
			.addListeners(lateAddedApplicationListener);
		application.addListeners(listener);
		EventPublishingRunListener runListener = new EventPublishingRunListener(application, null);
		runListener.starting(bootstrapContext);
		runListener.environmentPrepared(bootstrapContext, environment);
		lateAddedApplicationListener.assertReceivedEvent(ApplicationEnvironmentPreparedEvent.class);
	}
	static class TestApplicationListener implements ApplicationListener<ApplicationEvent> {
		private final Deque<ApplicationEvent> events = new ArrayDeque<>();
		@Override
		public void onApplicationEvent(ApplicationEvent event) {
			this.events.add(event);
		}
		void assertReceivedNoEvents() {
			assertThat(this.events).isEmpty();
		}
		void assertReceivedEvent(Class<?>... eventClasses) {
			List<ApplicationEvent> receivedEvents = new ArrayList<>();
			while (!this.events.isEmpty()) {
				receivedEvents.add(this.events.pollFirst());
			}
			assertThat(receivedEvents).extracting('class').contains((Object[]) eventClasses);
		}
	}
}
/*
package org.springframework.boot.context.configwarnings.dflt;
@Configuration(proxyBeanMethods = false)
@ComponentScan('org.springframework.boot.context.configwarnings.nested')
public class InDefaultPackageWithValueConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.dflt;
@Configuration(proxyBeanMethods = false)
public class InDefaultPackageWithoutScanConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.dflt;
@Configuration(proxyBeanMethods = false)
@MetaComponentScan
public class InDefaultPackageWithMetaAnnotationConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.dflt;
@Configuration(proxyBeanMethods = false)
@ComponentScan(basePackageClasses = ExampleBean.class)
public class InDefaultPackageWithBasePackageClassesConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.dflt;
@Configuration(proxyBeanMethods = false)
@ComponentScan
public class InDefaultPackageConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.dflt;
@Configuration(proxyBeanMethods = false)
@ComponentScan(basePackages = 'org.springframework.boot.context.configwarnings.nested')
public class InDefaultPackageWithBasePackagesConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.annotation;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@ComponentScan
public @interface MetaComponentScan {
}
/*
package org.springframework.boot.context.configwarnings.orgspring;
@Configuration(proxyBeanMethods = false)
@ComponentScan
public class InOrgSpringPackageConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.real;
@Configuration(proxyBeanMethods = false)
@ComponentScan(basePackageClasses = { InDefaultPackageConfiguration.class, InOrgSpringPackageConfiguration.class })
public class InRealButScanningProblemPackages {
}
/*
package org.springframework.boot.context.configwarnings.real;
@Configuration(proxyBeanMethods = false)
@ComponentScan
public class InRealPackageConfiguration {
}
/*
package org.springframework.boot.context.configwarnings.real.nested;
@Component
public class ExampleBean {
}
/*
package org.springframework.boot.context;
/**
class ApplicationPidFileWriterTests {
	private static final ApplicationPreparedEvent EVENT = new ApplicationPreparedEvent(new SpringApplication(),
			new String[] {}, mock(ConfigurableApplicationContext.class));
	@TempDir
	File tempDir;
	@BeforeEach
	@AfterEach
	void resetListener() {
		System.clearProperty('PIDFILE');
		System.clearProperty('PID_FAIL_ON_WRITE_ERROR');
		ApplicationPidFileWriter.reset();
	}
	@Test
	void createPidFile() {
		File file = new File(this.tempDir, 'pid');
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.onApplicationEvent(EVENT);
		assertThat(contentOf(file)).isNotEmpty();
	}
	@Test
	void overridePidFile() {
		File file = new File(this.tempDir, 'pid');
		System.setProperty('PIDFILE', new File(this.tempDir, 'override').getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.onApplicationEvent(EVENT);
		assertThat(contentOf(new File(System.getProperty('PIDFILE')))).isNotEmpty();
	}
	@Test
	void overridePidFileWithSpring() {
		File file = new File(this.tempDir, 'pid');
		SpringApplicationEvent event = createPreparedEvent('spring.pid.file', file.getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter();
		listener.onApplicationEvent(event);
		assertThat(contentOf(file)).isNotEmpty();
	}
	@Test
	void tryEnvironmentPreparedEvent() throws Exception {
		File file = new File(this.tempDir, 'pid');
		file.createNewFile();
		SpringApplicationEvent event = createEnvironmentPreparedEvent('spring.pid.file', file.getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter();
		listener.onApplicationEvent(event);
		assertThat(contentOf(file)).isEmpty();
		listener.setTriggerEventType(ApplicationEnvironmentPreparedEvent.class);
		listener.onApplicationEvent(event);
		assertThat(contentOf(file)).isNotEmpty();
	}
	@Test
	void tryReadyEvent() throws Exception {
		File file = new File(this.tempDir, 'pid');
		file.createNewFile();
		SpringApplicationEvent event = createReadyEvent('spring.pid.file', file.getAbsolutePath());
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter();
		listener.onApplicationEvent(event);
		assertThat(contentOf(file)).isEmpty();
		listener.setTriggerEventType(ApplicationReadyEvent.class);
		listener.onApplicationEvent(event);
		assertThat(contentOf(file)).isNotEmpty();
	}
	@Test
	void withNoEnvironment() {
		File file = new File(this.tempDir, 'pid');
		ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
		listener.setTriggerEventType(ApplicationStartingEvent.class);
		listener.onApplicationEvent(
				new ApplicationStartingEvent(new DefaultBootstrapContext(), new SpringApplication(), new String[] {}));
		assertThat(contentOf(file)).isNotEmpty();
	}
	@Test
	void continueWhenPidFileIsReadOnly() throws Exception {
		withReadOnlyPidFile((file) -> {
			ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
			listener.onApplicationEvent(EVENT);
			assertThat(contentOf(file)).isEmpty();
		});
	}
	@Test
	void throwWhenPidFileIsReadOnly() throws Exception {
		withReadOnlyPidFile((file) -> {
			System.setProperty('PID_FAIL_ON_WRITE_ERROR', 'true');
			ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
			assertThatIllegalStateException().isThrownBy(() -> listener.onApplicationEvent(EVENT))
				.withMessageContaining('Cannot create pid file');
		});
	}
	@Test
	void throwWhenPidFileIsReadOnlyWithSpring() throws Exception {
		withReadOnlyPidFile((file) -> {
			SpringApplicationEvent event = createPreparedEvent('spring.pid.fail-on-write-error', 'true');
			ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file);
			assertThatIllegalStateException().isThrownBy(() -> listener.onApplicationEvent(event))
				.withMessageContaining('Cannot create pid file');
		});
	}
	private void withReadOnlyPidFile(Consumer<File> consumer) throws IOException {
		File file = new File(this.tempDir, 'pid');
		file.createNewFile();
		file.setReadOnly();
		try {
			consumer.accept(file);
		}
		finally {
			file.setWritable(true);
		}
	}
	private SpringApplicationEvent createEnvironmentPreparedEvent(String propName, String propValue) {
		ConfigurableEnvironment environment = createEnvironment(propName, propValue);
		return new ApplicationEnvironmentPreparedEvent(new DefaultBootstrapContext(), new SpringApplication(),
				new String[] {}, environment);
	}
	private SpringApplicationEvent createPreparedEvent(String propName, String propValue) {
		ConfigurableEnvironment environment = createEnvironment(propName, propValue);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		given(context.getEnvironment()).willReturn(environment);
		return new ApplicationPreparedEvent(new SpringApplication(), new String[] {}, context);
	}
	private SpringApplicationEvent createReadyEvent(String propName, String propValue) {
		ConfigurableEnvironment environment = createEnvironment(propName, propValue);
		ConfigurableApplicationContext context = mock(ConfigurableApplicationContext.class);
		given(context.getEnvironment()).willReturn(environment);
		return new ApplicationReadyEvent(new SpringApplication(), new String[] {}, context, null);
	}
	private ConfigurableEnvironment createEnvironment(String propName, String propValue) {
		MockPropertySource propertySource = mockPropertySource(propName, propValue);
		ConfigurableEnvironment environment = new StandardEnvironment();
		environment.getPropertySources().addLast(propertySource);
		return environment;
	}
	private MockPropertySource mockPropertySource(String name, String value) {
		MockPropertySource propertySource = new MockPropertySource();
		propertySource.setProperty(name, value);
		return propertySource;
	}
}
/*
package org.springframework.boot.context;
/**
class ContextIdApplicationContextInitializerTests {
	private final ContextIdApplicationContextInitializer initializer = new ContextIdApplicationContextInitializer();
	private final List<ConfigurableApplicationContext> contexts = new ArrayList<>();
	@AfterEach
	void closeContexts() {
		Collections.reverse(this.contexts);
		this.contexts.forEach(ConfigurableApplicationContext::close);
	}
	@Test
	void singleContextWithDefaultName() {
		ConfigurableApplicationContext context = createContext(null);
		assertThat(context.getId()).isEqualTo('application');
	}
	@Test
	void singleContextWithCustomName() {
		ConfigurableApplicationContext context = createContext(null, 'spring.application.name=test');
		assertThat(context.getId()).isEqualTo('test');
	}
	@Test
	void linearHierarchy() {
		ConfigurableApplicationContext grandparent = createContext(null);
		ConfigurableApplicationContext parent = createContext(grandparent);
		ConfigurableApplicationContext child = createContext(parent);
		assertThat(child.getId()).isEqualTo('application-1-1');
	}
	@Test
	void complexHierarchy() {
		ConfigurableApplicationContext grandparent = createContext(null);
		ConfigurableApplicationContext parent1 = createContext(grandparent);
		ConfigurableApplicationContext parent2 = createContext(grandparent);
		ConfigurableApplicationContext child1_1 = createContext(parent1);
		assertThat(child1_1.getId()).isEqualTo('application-1-1');
		ConfigurableApplicationContext child1_2 = createContext(parent1);
		assertThat(child1_2.getId()).isEqualTo('application-1-2');
		ConfigurableApplicationContext child2_1 = createContext(parent2);
		assertThat(child2_1.getId()).isEqualTo('application-2-1');
	}
	@Test
	void contextWithParentWithNoContextIdFallsBackToDefaultId() {
		ConfigurableApplicationContext parent = new AnnotationConfigApplicationContext();
		this.contexts.add(parent);
		parent.refresh();
		assertThat(createContext(parent).getId()).isEqualTo('application');
	}
	private ConfigurableApplicationContext createContext(ConfigurableApplicationContext parent, String... properties) {
		ConfigurableApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(context, properties);
		if (parent != null) {
			context.setParent(parent);
		}
		this.initializer.initialize(context);
		context.refresh();
		this.contexts.add(context);
		return context;
	}
}
/*
package org.springframework.boot.task;
/**
class SimpleAsyncTaskExecutorBuilderTests {
	private final SimpleAsyncTaskExecutorBuilder builder = new SimpleAsyncTaskExecutorBuilder();
	@Test
	void threadNamePrefixShouldApply() {
		SimpleAsyncTaskExecutor executor = this.builder.threadNamePrefix('test-').build();
		assertThat(executor.getThreadNamePrefix()).isEqualTo('test-');
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void virtualThreadsShouldApply() {
		SimpleAsyncTaskExecutor executor = this.builder.virtualThreads(true).build();
		SimpleAsyncTaskExecutorAssert.assertThat(executor).usesVirtualThreads();
	}
	@Test
	void concurrencyLimitShouldApply() {
		SimpleAsyncTaskExecutor executor = this.builder.concurrencyLimit(1).build();
		assertThat(executor.getConcurrencyLimit()).isEqualTo(1);
	}
	@Test
	void taskDecoratorShouldApply() {
		TaskDecorator taskDecorator = mock(TaskDecorator.class);
		SimpleAsyncTaskExecutor executor = this.builder.taskDecorator(taskDecorator).build();
		assertThat(executor).extracting('taskDecorator').isSameAs(taskDecorator);
	}
	@Test
	void customizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((SimpleAsyncTaskExecutorCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((Set<SimpleAsyncTaskExecutorCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersShouldApply() {
		SimpleAsyncTaskExecutorCustomizer customizer = mock(SimpleAsyncTaskExecutorCustomizer.class);
		SimpleAsyncTaskExecutor executor = this.builder.customizers(customizer).build();
		then(customizer).should().customize(executor);
	}
	@Test
	void customizersShouldBeAppliedLast() {
		TaskDecorator taskDecorator = mock(TaskDecorator.class);
		SimpleAsyncTaskExecutor executor = spy(new SimpleAsyncTaskExecutor());
		this.builder.threadNamePrefix('test-')
			.virtualThreads(true)
			.concurrencyLimit(1)
			.taskDecorator(taskDecorator)
			.additionalCustomizers((taskExecutor) -> {
				then(taskExecutor).should().setConcurrencyLimit(1);
				then(taskExecutor).should().setVirtualThreads(true);
				then(taskExecutor).should().setThreadNamePrefix('test-');
				then(taskExecutor).should().setTaskDecorator(taskDecorator);
			});
		this.builder.configure(executor);
	}
	@Test
	void customizersShouldReplaceExisting() {
		SimpleAsyncTaskExecutorCustomizer customizer1 = mock(SimpleAsyncTaskExecutorCustomizer.class);
		SimpleAsyncTaskExecutorCustomizer customizer2 = mock(SimpleAsyncTaskExecutorCustomizer.class);
		SimpleAsyncTaskExecutor executor = this.builder.customizers(customizer1)
			.customizers(Collections.singleton(customizer2))
			.build();
		then(customizer1).shouldHaveNoInteractions();
		then(customizer2).should().customize(executor);
	}
	@Test
	void additionalCustomizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((SimpleAsyncTaskExecutorCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((Set<SimpleAsyncTaskExecutorCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersShouldAddToExisting() {
		SimpleAsyncTaskExecutorCustomizer customizer1 = mock(SimpleAsyncTaskExecutorCustomizer.class);
		SimpleAsyncTaskExecutorCustomizer customizer2 = mock(SimpleAsyncTaskExecutorCustomizer.class);
		SimpleAsyncTaskExecutor executor = this.builder.customizers(customizer1)
			.additionalCustomizers(customizer2)
			.build();
		then(customizer1).should().customize(executor);
		then(customizer2).should().customize(executor);
	}
	@Test
	void taskTerminationTimeoutShouldApply() {
		SimpleAsyncTaskExecutor executor = this.builder.taskTerminationTimeout(Duration.ofSeconds(1)).build();
		assertThat(executor).extracting('taskTerminationTimeout').isEqualTo(1000L);
	}
}
/*
package org.springframework.boot.task;
/**
class ThreadPoolTaskExecutorBuilderTests {
	private final ThreadPoolTaskExecutorBuilder builder = new ThreadPoolTaskExecutorBuilder();
	@Test
	void poolSettingsShouldApply() {
		ThreadPoolTaskExecutor executor = this.builder.queueCapacity(10)
			.corePoolSize(4)
			.maxPoolSize(8)
			.allowCoreThreadTimeOut(true)
			.keepAlive(Duration.ofMinutes(1))
			.build();
		assertThat(executor).hasFieldOrPropertyWithValue('queueCapacity', 10);
		assertThat(executor.getCorePoolSize()).isEqualTo(4);
		assertThat(executor.getMaxPoolSize()).isEqualTo(8);
		assertThat(executor).hasFieldOrPropertyWithValue('allowCoreThreadTimeOut', true);
		assertThat(executor.getKeepAliveSeconds()).isEqualTo(60);
	}
	@Test
	void acceptTasksAfterContextCloseShouldApply() {
		ThreadPoolTaskExecutor executor = this.builder.acceptTasksAfterContextClose(true).build();
		assertThat(executor).hasFieldOrPropertyWithValue('acceptTasksAfterContextClose', true);
	}
	@Test
	void awaitTerminationShouldApply() {
		ThreadPoolTaskExecutor executor = this.builder.awaitTermination(true).build();
		assertThat(executor).hasFieldOrPropertyWithValue('waitForTasksToCompleteOnShutdown', true);
	}
	@Test
	void awaitTerminationPeriodShouldApplyWithMillisecondPrecision() {
		Duration period = Duration.ofMillis(50);
		ThreadPoolTaskExecutor executor = this.builder.awaitTerminationPeriod(period).build();
		assertThat(executor).hasFieldOrPropertyWithValue('awaitTerminationMillis', period.toMillis());
	}
	@Test
	void threadNamePrefixShouldApply() {
		ThreadPoolTaskExecutor executor = this.builder.threadNamePrefix('test-').build();
		assertThat(executor.getThreadNamePrefix()).isEqualTo('test-');
	}
	@Test
	void taskDecoratorShouldApply() {
		TaskDecorator taskDecorator = mock(TaskDecorator.class);
		ThreadPoolTaskExecutor executor = this.builder.taskDecorator(taskDecorator).build();
		assertThat(executor).extracting('taskDecorator').isSameAs(taskDecorator);
	}
	@Test
	void customizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((ThreadPoolTaskExecutorCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((Set<ThreadPoolTaskExecutorCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersShouldApply() {
		ThreadPoolTaskExecutorCustomizer customizer = mock(ThreadPoolTaskExecutorCustomizer.class);
		ThreadPoolTaskExecutor executor = this.builder.customizers(customizer).build();
		then(customizer).should().customize(executor);
	}
	@Test
	void customizersShouldBeAppliedLast() {
		TaskDecorator taskDecorator = mock(TaskDecorator.class);
		ThreadPoolTaskExecutor executor = spy(new ThreadPoolTaskExecutor());
		this.builder.queueCapacity(10)
			.corePoolSize(4)
			.maxPoolSize(8)
			.allowCoreThreadTimeOut(true)
			.keepAlive(Duration.ofMinutes(1))
			.awaitTermination(true)
			.awaitTerminationPeriod(Duration.ofSeconds(30))
			.threadNamePrefix('test-')
			.taskDecorator(taskDecorator)
			.additionalCustomizers((taskExecutor) -> {
				then(taskExecutor).should().setQueueCapacity(10);
				then(taskExecutor).should().setCorePoolSize(4);
				then(taskExecutor).should().setMaxPoolSize(8);
				then(taskExecutor).should().setAllowCoreThreadTimeOut(true);
				then(taskExecutor).should().setKeepAliveSeconds(60);
				then(taskExecutor).should().setWaitForTasksToCompleteOnShutdown(true);
				then(taskExecutor).should().setAwaitTerminationSeconds(30);
				then(taskExecutor).should().setThreadNamePrefix('test-');
				then(taskExecutor).should().setTaskDecorator(taskDecorator);
			});
		this.builder.configure(executor);
	}
	@Test
	void customizersShouldReplaceExisting() {
		ThreadPoolTaskExecutorCustomizer customizer1 = mock(ThreadPoolTaskExecutorCustomizer.class);
		ThreadPoolTaskExecutorCustomizer customizer2 = mock(ThreadPoolTaskExecutorCustomizer.class);
		ThreadPoolTaskExecutor executor = this.builder.customizers(customizer1)
			.customizers(Collections.singleton(customizer2))
			.build();
		then(customizer1).shouldHaveNoInteractions();
		then(customizer2).should().customize(executor);
	}
	@Test
	void additionalCustomizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((ThreadPoolTaskExecutorCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((Set<ThreadPoolTaskExecutorCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersShouldAddToExisting() {
		ThreadPoolTaskExecutorCustomizer customizer1 = mock(ThreadPoolTaskExecutorCustomizer.class);
		ThreadPoolTaskExecutorCustomizer customizer2 = mock(ThreadPoolTaskExecutorCustomizer.class);
		ThreadPoolTaskExecutor executor = this.builder.customizers(customizer1)
			.additionalCustomizers(customizer2)
			.build();
		then(customizer1).should().customize(executor);
		then(customizer2).should().customize(executor);
	}
}
/*
package org.springframework.boot.task;
/**
class ThreadPoolTaskSchedulerBuilderTests {
	private final ThreadPoolTaskSchedulerBuilder builder = new ThreadPoolTaskSchedulerBuilder();
	@Test
	void poolSettingsShouldApply() {
		ThreadPoolTaskScheduler scheduler = this.builder.poolSize(4).build();
		assertThat(scheduler.getPoolSize()).isEqualTo(4);
	}
	@Test
	void awaitTerminationShouldApply() {
		ThreadPoolTaskScheduler executor = this.builder.awaitTermination(true).build();
		assertThat(executor).hasFieldOrPropertyWithValue('waitForTasksToCompleteOnShutdown', true);
	}
	@Test
	void awaitTerminationPeriodShouldApply() {
		Duration period = Duration.ofMinutes(1);
		ThreadPoolTaskScheduler executor = this.builder.awaitTerminationPeriod(period).build();
		assertThat(executor).hasFieldOrPropertyWithValue('awaitTerminationMillis', period.toMillis());
	}
	@Test
	void threadNamePrefixShouldApply() {
		ThreadPoolTaskScheduler scheduler = this.builder.threadNamePrefix('test-').build();
		assertThat(scheduler.getThreadNamePrefix()).isEqualTo('test-');
	}
	@Test
	void customizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((ThreadPoolTaskSchedulerCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((Set<ThreadPoolTaskSchedulerCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersShouldApply() {
		ThreadPoolTaskSchedulerCustomizer customizer = mock(ThreadPoolTaskSchedulerCustomizer.class);
		ThreadPoolTaskScheduler scheduler = this.builder.customizers(customizer).build();
		then(customizer).should().customize(scheduler);
	}
	@Test
	void customizersShouldBeAppliedLast() {
		ThreadPoolTaskScheduler scheduler = spy(new ThreadPoolTaskScheduler());
		this.builder.poolSize(4).threadNamePrefix('test-').additionalCustomizers((taskScheduler) -> {
			then(taskScheduler).should().setPoolSize(4);
			then(taskScheduler).should().setThreadNamePrefix('test-');
		});
		this.builder.configure(scheduler);
	}
	@Test
	void customizersShouldReplaceExisting() {
		ThreadPoolTaskSchedulerCustomizer customizer1 = mock(ThreadPoolTaskSchedulerCustomizer.class);
		ThreadPoolTaskSchedulerCustomizer customizer2 = mock(ThreadPoolTaskSchedulerCustomizer.class);
		ThreadPoolTaskScheduler scheduler = this.builder.customizers(customizer1)
			.customizers(Collections.singleton(customizer2))
			.build();
		then(customizer1).shouldHaveNoInteractions();
		then(customizer2).should().customize(scheduler);
	}
	@Test
	void additionalCustomizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((ThreadPoolTaskSchedulerCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((Set<ThreadPoolTaskSchedulerCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersShouldAddToExisting() {
		ThreadPoolTaskSchedulerCustomizer customizer1 = mock(ThreadPoolTaskSchedulerCustomizer.class);
		ThreadPoolTaskSchedulerCustomizer customizer2 = mock(ThreadPoolTaskSchedulerCustomizer.class);
		ThreadPoolTaskScheduler scheduler = this.builder.customizers(customizer1)
			.additionalCustomizers(customizer2)
			.build();
		then(customizer1).should().customize(scheduler);
		then(customizer2).should().customize(scheduler);
	}
}
/*
package org.springframework.boot.task;
/**
class SimpleAsyncTaskSchedulerBuilderTests {
	private final SimpleAsyncTaskSchedulerBuilder builder = new SimpleAsyncTaskSchedulerBuilder();
	@Test
	void threadNamePrefixShouldApply() {
		SimpleAsyncTaskScheduler scheduler = this.builder.threadNamePrefix('test-').build();
		assertThat(scheduler.getThreadNamePrefix()).isEqualTo('test-');
	}
	@Test
	void concurrencyLimitShouldApply() {
		SimpleAsyncTaskScheduler scheduler = this.builder.concurrencyLimit(1).build();
		assertThat(scheduler.getConcurrencyLimit()).isEqualTo(1);
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void virtualThreadsShouldApply() {
		SimpleAsyncTaskScheduler scheduler = this.builder.virtualThreads(true).build();
		assertThat(scheduler).extracting('virtualThreadDelegate').isNotNull();
	}
	@Test
	void customizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((SimpleAsyncTaskSchedulerCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((Set<SimpleAsyncTaskSchedulerCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersShouldApply() {
		SimpleAsyncTaskSchedulerCustomizer customizer = mock(SimpleAsyncTaskSchedulerCustomizer.class);
		SimpleAsyncTaskScheduler scheduler = this.builder.customizers(customizer).build();
		then(customizer).should().customize(scheduler);
	}
	@Test
	void customizersShouldBeAppliedLast() {
		SimpleAsyncTaskScheduler scheduler = spy(new SimpleAsyncTaskScheduler());
		this.builder.concurrencyLimit(1).threadNamePrefix('test-').additionalCustomizers((taskScheduler) -> {
			then(taskScheduler).should().setConcurrencyLimit(1);
			then(taskScheduler).should().setThreadNamePrefix('test-');
		});
		this.builder.configure(scheduler);
	}
	@Test
	void customizersShouldReplaceExisting() {
		SimpleAsyncTaskSchedulerCustomizer customizer1 = mock(SimpleAsyncTaskSchedulerCustomizer.class);
		SimpleAsyncTaskSchedulerCustomizer customizer2 = mock(SimpleAsyncTaskSchedulerCustomizer.class);
		SimpleAsyncTaskScheduler scheduler = this.builder.customizers(customizer1)
			.customizers(Collections.singleton(customizer2))
			.build();
		then(customizer1).shouldHaveNoInteractions();
		then(customizer2).should().customize(scheduler);
	}
	@Test
	void additionalCustomizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((SimpleAsyncTaskSchedulerCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((Set<SimpleAsyncTaskSchedulerCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersShouldAddToExisting() {
		SimpleAsyncTaskSchedulerCustomizer customizer1 = mock(SimpleAsyncTaskSchedulerCustomizer.class);
		SimpleAsyncTaskSchedulerCustomizer customizer2 = mock(SimpleAsyncTaskSchedulerCustomizer.class);
		SimpleAsyncTaskScheduler scheduler = this.builder.customizers(customizer1)
			.additionalCustomizers(customizer2)
			.build();
		then(customizer1).should().customize(scheduler);
		then(customizer2).should().customize(scheduler);
	}
	@Test
	void taskTerminationTimeoutShouldApply() {
		SimpleAsyncTaskScheduler scheduler = this.builder.taskTerminationTimeout(Duration.ofSeconds(1)).build();
		assertThat(scheduler).extracting('taskTerminationTimeout').isEqualTo(1000L);
	}
}
/*
package org.springframework.boot;
/**
class LazyInitializationExcludeFilterTests {
	@Test
	void forBeanTypesMatchesTypes() {
		LazyInitializationExcludeFilter filter = LazyInitializationExcludeFilter.forBeanTypes(CharSequence.class,
				Number.class);
		String beanName = 'test';
		BeanDefinition beanDefinition = mock(BeanDefinition.class);
		assertThat(filter.isExcluded(beanName, beanDefinition, CharSequence.class)).isTrue();
		assertThat(filter.isExcluded(beanName, beanDefinition, String.class)).isTrue();
		assertThat(filter.isExcluded(beanName, beanDefinition, StringBuilder.class)).isTrue();
		assertThat(filter.isExcluded(beanName, beanDefinition, Number.class)).isTrue();
		assertThat(filter.isExcluded(beanName, beanDefinition, Long.class)).isTrue();
		assertThat(filter.isExcluded(beanName, beanDefinition, Boolean.class)).isFalse();
	}
}
/*
package org.springframework.boot.web.context;
/**
class WebServerApplicationContextTests {
	@Test
	void hasServerNamespaceWhenContextIsNotWebServerApplicationContextReturnsFalse() {
		ApplicationContext context = mock(ApplicationContext.class);
		assertThat(WebServerApplicationContext.hasServerNamespace(context, 'test')).isFalse();
	}
	@Test
	void hasServerNamespaceWhenContextIsWebServerApplicationContextAndNamespaceDoesNotMatchReturnsFalse() {
		ApplicationContext context = mock(WebServerApplicationContext.class);
		assertThat(WebServerApplicationContext.hasServerNamespace(context, 'test')).isFalse();
	}
	@Test
	void hasServerNamespaceWhenContextIsWebServerApplicationContextAndNamespaceMatchesReturnsTrue() {
		WebServerApplicationContext context = mock(WebServerApplicationContext.class);
		given(context.getServerNamespace()).willReturn('test');
		assertThat(WebServerApplicationContext.hasServerNamespace(context, 'test')).isTrue();
	}
}
/*
package org.springframework.boot.web.context;
/**
class WebServerPortFileWriterTests {
	@TempDir
	File tempDir;
	@BeforeEach
	@AfterEach
	void reset() {
		System.clearProperty('PORTFILE');
	}
	@Test
	void createPortFile() {
		File file = new File(this.tempDir, 'port.file');
		WebServerPortFileWriter listener = new WebServerPortFileWriter(file);
		listener.onApplicationEvent(mockEvent('', 8080));
		assertThat(contentOf(file)).isEqualTo('8080');
	}
	@Test
	void overridePortFileWithDefault() {
		System.setProperty('PORTFILE', new File(this.tempDir, 'port.file').getAbsolutePath());
		WebServerPortFileWriter listener = new WebServerPortFileWriter();
		listener.onApplicationEvent(mockEvent('', 8080));
		String content = contentOf(new File(System.getProperty('PORTFILE')));
		assertThat(content).isEqualTo('8080');
	}
	@Test
	void overridePortFileWithExplicitFile() {
		File file = new File(this.tempDir, 'port.file');
		System.setProperty('PORTFILE', new File(this.tempDir, 'override.file').getAbsolutePath());
		WebServerPortFileWriter listener = new WebServerPortFileWriter(file);
		listener.onApplicationEvent(mockEvent('', 8080));
		String content = contentOf(new File(System.getProperty('PORTFILE')));
		assertThat(content).isEqualTo('8080');
	}
	@Test
	void createManagementPortFile() {
		File file = new File(this.tempDir, 'port.file');
		WebServerPortFileWriter listener = new WebServerPortFileWriter(file);
		listener.onApplicationEvent(mockEvent('', 8080));
		listener.onApplicationEvent(mockEvent('management', 9090));
		assertThat(contentOf(file)).isEqualTo('8080');
		String managementFile = file.getName();
		managementFile = managementFile.substring(0,
				managementFile.length() - StringUtils.getFilenameExtension(managementFile).length() - 1);
		managementFile = managementFile + '-management.' + StringUtils.getFilenameExtension(file.getName());
		String content = contentOf(new File(file.getParentFile(), managementFile));
		assertThat(content).isEqualTo('9090');
		assertThat(collectFileNames(file.getParentFile())).contains(managementFile);
	}
	@Test
	void createUpperCaseManagementPortFile() {
		File file = new File(this.tempDir, 'port.file');
		file = new File(file.getParentFile(), file.getName().toUpperCase(Locale.ENGLISH));
		WebServerPortFileWriter listener = new WebServerPortFileWriter(file);
		listener.onApplicationEvent(mockEvent('management', 9090));
		String managementFile = file.getName();
		managementFile = managementFile.substring(0,
				managementFile.length() - StringUtils.getFilenameExtension(managementFile).length() - 1);
		managementFile = managementFile + '-MANAGEMENT.' + StringUtils.getFilenameExtension(file.getName());
		String content = contentOf(new File(file.getParentFile(), managementFile));
		assertThat(content).isEqualTo('9090');
		assertThat(collectFileNames(file.getParentFile())).contains(managementFile);
	}
	private WebServerInitializedEvent mockEvent(String namespace, int port) {
		WebServer webServer = mock(WebServer.class);
		given(webServer.getPort()).willReturn(port);
		WebServerApplicationContext applicationContext = mock(WebServerApplicationContext.class);
		given(applicationContext.getServerNamespace()).willReturn(namespace);
		given(applicationContext.getWebServer()).willReturn(webServer);
		WebServerInitializedEvent event = mock(WebServerInitializedEvent.class);
		given(event.getApplicationContext()).willReturn(applicationContext);
		given(event.getWebServer()).willReturn(webServer);
		return event;
	}
	private Set<String> collectFileNames(File directory) {
		Set<String> names = new HashSet<>();
		if (directory.isDirectory()) {
			for (File file : directory.listFiles()) {
				names.add(file.getName());
			}
		}
		return names;
	}
}
/*
package org.springframework.boot.web.context;
/**
class MissingWebServerFactoryBeanFailureAnalyzerTests {
	@Test
	void missingServletWebServerFactoryBeanFailure() {
		ApplicationContextException failure = createFailure(new ServletWebServerApplicationContext());
		assertThat(failure).isNotNull();
		FailureAnalysis analysis = new MissingWebServerFactoryBeanFailureAnalyzer().analyze(failure);
		assertThat(analysis).isNotNull();
		assertThat(analysis.getDescription()).isEqualTo('Web application could not be started as there was no '
				+ ServletWebServerFactory.class.getName() + ' bean defined in the context.');
		assertThat(analysis.getAction()).isEqualTo(
				'Check your application"s dependencies for a supported servlet web server.\nCheck the configured web '
						+ 'application type.');
	}
	@Test
	void missingReactiveWebServerFactoryBeanFailure() {
		ApplicationContextException failure = createFailure(new ReactiveWebServerApplicationContext());
		FailureAnalysis analysis = new MissingWebServerFactoryBeanFailureAnalyzer().analyze(failure);
		assertThat(analysis).isNotNull();
		assertThat(analysis.getDescription()).isEqualTo('Web application could not be started as there was no '
				+ ReactiveWebServerFactory.class.getName() + ' bean defined in the context.');
		assertThat(analysis.getAction()).isEqualTo(
				'Check your application"s dependencies for a supported reactive web server.\nCheck the configured web '
						+ 'application type.');
	}
	private ApplicationContextException createFailure(ConfigurableApplicationContext context) {
		try {
			context.refresh();
			context.close();
			return null;
		}
		catch (ApplicationContextException ex) {
			return ex;
		}
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class UndertowWebServerRuntimeHintsTests {
	@Test
	void registersHints() throws ClassNotFoundException {
		RuntimeHints runtimeHints = new RuntimeHints();
		new UndertowWebServerRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onField(Undertow.class, 'listeners')).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.reflection().onField(Undertow.class, 'channels')).accepts(runtimeHints);
		assertThat(reflectionOnField('io.undertow.Undertow$ListenerConfig', 'type')).accepts(runtimeHints);
		assertThat(reflectionOnField('io.undertow.Undertow$ListenerConfig', 'port')).accepts(runtimeHints);
		assertThat(reflectionOnField('io.undertow.protocols.ssl.UndertowAcceptingSslChannel', 'ssl'))
			.accepts(runtimeHints);
	}
	private FieldHintPredicate reflectionOnField(String className, String fieldName) throws ClassNotFoundException {
		return RuntimeHintsPredicates.reflection()
			.onField(ReflectionUtils.findField(Class.forName(className), fieldName));
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class JarResourceManagerTests {
	@TempDir
	static File tempDir;
	@ResourceManagersTest
	void emptyPathIsHandledCorrectly(String filename, ResourceManager resourceManager) throws IOException {
		Resource resource = resourceManager.getResource('');
		assertThat(resource).isNotNull();
		assertThat(resource.isDirectory()).isTrue();
	}
	@ResourceManagersTest
	void rootPathIsHandledCorrectly(String filename, ResourceManager resourceManager) throws IOException {
		Resource resource = resourceManager.getResource('/');
		assertThat(resource).isNotNull();
		assertThat(resource.isDirectory()).isTrue();
	}
	@ResourceManagersTest
	void resourceIsFoundInJarFile(String filename, ResourceManager resourceManager) throws IOException {
		Resource resource = resourceManager.getResource('/hello.txt');
		assertThat(resource).isNotNull();
		assertThat(resource.isDirectory()).isFalse();
		assertThat(resource.getContentLength()).isEqualTo(5);
	}
	@ResourceManagersTest
	void resourceIsFoundInJarFileWithoutLeadingSlash(String filename, ResourceManager resourceManager)
			throws IOException {
		Resource resource = resourceManager.getResource('hello.txt');
		assertThat(resource).isNotNull();
		assertThat(resource.isDirectory()).isFalse();
		assertThat(resource.getContentLength()).isEqualTo(5);
	}
	static List<Arguments> resourceManagers() throws IOException {
		File jar = new File(tempDir, 'test.jar');
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(jar))) {
			out.putNextEntry(new ZipEntry('hello.txt'));
			out.write('hello'.getBytes());
		}
		File troublesomeNameJar = new File(tempDir, 'test##1.0.jar');
		FileCopyUtils.copy(jar, troublesomeNameJar);
		return Arrays.asList(Arguments.of(jar.getName(), new JarResourceManager(jar)),
				Arguments.of(troublesomeNameJar.getName(), new JarResourceManager(troublesomeNameJar)));
	}
	@ParameterizedTest(name = '[{index}] {0}')
	@MethodSource('resourceManagers')
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.RUNTIME)
	private @interface ResourceManagersTest {
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class FileSessionPersistenceTests {
	private File dir;
	private FileSessionPersistence persistence;
	private final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
	private final Date expiration = new Date(System.currentTimeMillis() + 10000);
	@BeforeEach
	void setup(@TempDir File tempDir) {
		this.dir = tempDir;
		this.dir.mkdir();
		this.persistence = new FileSessionPersistence(this.dir);
	}
	@Test
	void loadsNullForMissingFile() {
		Map<String, PersistentSession> attributes = this.persistence.loadSessionAttributes('test', this.classLoader);
		assertThat(attributes).isNull();
	}
	@Test
	void persistAndLoad() {
		Map<String, PersistentSession> sessionData = new LinkedHashMap<>();
		Map<String, Object> data = new LinkedHashMap<>();
		data.put('spring', 'boot');
		PersistentSession session = new PersistentSession(this.expiration, data);
		sessionData.put('abc', session);
		this.persistence.persistSessions('test', sessionData);
		Map<String, PersistentSession> restored = this.persistence.loadSessionAttributes('test', this.classLoader);
		assertThat(restored).isNotNull();
		assertThat(restored.get('abc').getExpiration()).isEqualTo(this.expiration);
		assertThat(restored.get('abc').getSessionData()).containsEntry('spring', 'boot');
	}
	@Test
	void dontRestoreExpired() {
		Date expired = new Date(System.currentTimeMillis() - 1000);
		Map<String, PersistentSession> sessionData = new LinkedHashMap<>();
		Map<String, Object> data = new LinkedHashMap<>();
		data.put('spring', 'boot');
		PersistentSession session = new PersistentSession(expired, data);
		sessionData.put('abc', session);
		this.persistence.persistSessions('test', sessionData);
		Map<String, PersistentSession> restored = this.persistence.loadSessionAttributes('test', this.classLoader);
		assertThat(restored).isNotNull();
		assertThat(restored).doesNotContainKey('abc');
	}
	@Test
	void deleteFileOnClear() {
		File sessionFile = new File(this.dir, 'test.session');
		Map<String, PersistentSession> sessionData = new LinkedHashMap<>();
		this.persistence.persistSessions('test', sessionData);
		assertThat(sessionFile).exists();
		this.persistence.clear('test');
		assertThat(sessionFile).doesNotExist();
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class UndertowServletWebServerFactoryTests extends AbstractServletWebServerFactoryTests {
	@Override
	protected UndertowServletWebServerFactory getFactory() {
		return new UndertowServletWebServerFactory(0);
	}
	@AfterEach
	void awaitClosureOfSslRelatedInputStreams() {
		// https://issues.redhat.com/browse/UNDERTOW-1705
		File resource = new File(this.tempDir, 'test.txt');
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> (!resource.isFile()) || resource.delete());
	}
	@Test
	void errorPage404() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.addErrorPages(new ErrorPage(HttpStatus.NOT_FOUND, '/hello'));
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(), '/hello'));
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
		assertThat(getResponse(getLocalUrl('/not-found'))).isEqualTo('Hello World');
	}
	@Test
	void setNullBuilderCustomizersThrows() {
		UndertowServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setBuilderCustomizers(null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void addNullAddBuilderCustomizersThrows() {
		UndertowServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addBuilderCustomizers((UndertowBuilderCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void builderCustomizers() {
		UndertowServletWebServerFactory factory = getFactory();
		UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(UndertowBuilderCustomizer.class));
		factory.setBuilderCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addBuilderCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) customizers);
		for (UndertowBuilderCustomizer customizer : customizers) {
			ordered.verify(customizer).customize(any(Builder.class));
		}
	}
	@Test
	void setNullDeploymentInfoCustomizersThrows() {
		UndertowServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setDeploymentInfoCustomizers(null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void addNullAddDeploymentInfoCustomizersThrows() {
		UndertowServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addDeploymentInfoCustomizers((UndertowDeploymentInfoCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void deploymentInfo() {
		UndertowServletWebServerFactory factory = getFactory();
		UndertowDeploymentInfoCustomizer[] customizers = new UndertowDeploymentInfoCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(UndertowDeploymentInfoCustomizer.class));
		factory.setDeploymentInfoCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addDeploymentInfoCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) customizers);
		for (UndertowDeploymentInfoCustomizer customizer : customizers) {
			ordered.verify(customizer).customize(any(DeploymentInfo.class));
		}
	}
	@Test
	void basicSslClasspathKeyStore() throws Exception {
		testBasicSslWithKeyStore('classpath:test.jks');
	}
	@Test
	void defaultContextPath() {
		UndertowServletWebServerFactory factory = getFactory();
		final AtomicReference<String> contextPath = new AtomicReference<>();
		factory.addDeploymentInfoCustomizers((deploymentInfo) -> contextPath.set(deploymentInfo.getContextPath()));
		this.webServer = factory.getWebServer();
		assertThat(contextPath.get()).isEqualTo('/');
	}
	@Test
	void useForwardHeaders() throws Exception {
		UndertowServletWebServerFactory factory = getFactory();
		factory.setUseForwardHeaders(true);
		assertForwardHeaderIsUsed(factory);
	}
	@Test
	void eachFactoryUsesADiscreteServletContainer() {
		assertThat(getServletContainerFromNewFactory()).isNotEqualTo(getServletContainerFromNewFactory());
	}
	@Test
	void accessLogCanBeEnabled() throws IOException, URISyntaxException {
		testAccessLog(null, null, 'access_log.log');
	}
	@Test
	void accessLogCanBeCustomized() throws IOException, URISyntaxException {
		testAccessLog('my_access.', 'logz', 'my_access.logz');
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenRequestsAreRejectedWithServiceUnavailable() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
			registration.setAsyncSupported(true);
		});
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> request = initiateGetRequest(port, '/blocking');
		blockingServlet.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		assertThat(result.get()).isNull();
		blockingServlet.admitOne();
		assertThat(request.get()).isInstanceOf(HttpResponse.class);
		Object rejectedResult = initiateGetRequest(port, '/').get();
		assertThat(rejectedResult).isInstanceOf(HttpResponse.class);
		assertThat(((HttpResponse) rejectedResult).getCode()).isEqualTo(HttpStatus.SERVICE_UNAVAILABLE.value());
		this.webServer.stop();
	}
	@Test
	void whenServerIsShuttingDownARequestOnAnIdleConnectionAreRejectedWithServiceUnavailable() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
			registration.setAsyncSupported(true);
		});
		HttpClient httpClient = HttpClients.createMinimal();
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> keepAliveRequest = initiateGetRequest(httpClient, port, '/blocking');
		blockingServlet.awaitQueue();
		blockingServlet.admitOne();
		assertThat(keepAliveRequest.get()).isInstanceOf(HttpResponse.class);
		Future<Object> request = initiateGetRequest(port, '/blocking');
		blockingServlet.awaitQueue();
		this.webServer.shutDownGracefully((result) -> {
		});
		HttpResponse idleConnectionResponse = (HttpResponse) initiateGetRequest(httpClient, port, '/').get();
		assertThat(idleConnectionResponse.getCode()).isEqualTo(503);
		blockingServlet.admitOne();
		Object response = request.get();
		assertThat(response).isInstanceOf(HttpResponse.class);
		this.webServer.stop();
	}
	@Test
	@Override
	@Disabled('https://issues.redhat.com/browse/UNDERTOW-2420')
	protected void portClashOfSecondaryConnectorResultsInPortInUseException() throws Exception {
		super.portClashOfSecondaryConnectorResultsInPortInUseException();
	}
	@Test
	@Override
	@Disabled('Restart after stop is not supported with Undertow')
	protected void restartAfterStop() {
	}
	@Test
	@Override
	@Disabled('Undertow"s architecture prevents separating stop and destroy')
	protected void servletContextListenerContextDestroyedIsNotCalledWhenContainerIsStopped() {
	}
	private void testAccessLog(String prefix, String suffix, String expectedFile)
			throws IOException, URISyntaxException {
		UndertowServletWebServerFactory factory = getFactory();
		factory.setAccessLogEnabled(true);
		factory.setAccessLogPrefix(prefix);
		factory.setAccessLogSuffix(suffix);
		File accessLogDirectory = this.tempDir;
		factory.setAccessLogDirectory(accessLogDirectory);
		assertThat(accessLogDirectory).isEmptyDirectory();
		this.webServer = factory.getWebServer(new ServletRegistrationBean<>(new ExampleServlet(), '/hello'));
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
		File accessLog = new File(accessLogDirectory, expectedFile);
		awaitFile(accessLog);
		assertThat(accessLogDirectory.listFiles()).contains(accessLog);
	}
	@Override
	protected void addConnector(int port, AbstractServletWebServerFactory factory) {
		((UndertowServletWebServerFactory) factory)
			.addBuilderCustomizers((builder) -> builder.addHttpListener(port, '0.0.0.0'));
	}
	@Test
	void sslRestrictedProtocolsEmptyCipherFailure() {
		assertThatIOException()
			.isThrownBy(() -> testRestrictedSSLProtocolsAndCipherSuites(new String[] { 'TLSv1.2' },
					new String[] { 'TLS_EMPTY_RENEGOTIATION_INFO_SCSV' }))
			.isInstanceOfAny(SSLException.class, SSLHandshakeException.class, SocketException.class);
	}
	@Test
	void sslRestrictedProtocolsECDHETLS1Failure() {
		assertThatIOException()
			.isThrownBy(() -> testRestrictedSSLProtocolsAndCipherSuites(new String[] { 'TLSv1' },
					new String[] { 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256' }))
			.isInstanceOfAny(SSLException.class, SocketException.class);
	}
	@Test
	void sslRestrictedProtocolsECDHESuccess() throws Exception {
		testRestrictedSSLProtocolsAndCipherSuites(new String[] { 'TLSv1.2' },
				new String[] { 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256' });
	}
	@Test
	void sslRestrictedProtocolsRSATLS12Success() throws Exception {
		testRestrictedSSLProtocolsAndCipherSuites(new String[] { 'TLSv1.2' },
				new String[] { 'TLS_RSA_WITH_AES_128_CBC_SHA256' });
	}
	@Test
	void sslRestrictedProtocolsRSATLS11Failure() {
		assertThatIOException()
			.isThrownBy(() -> testRestrictedSSLProtocolsAndCipherSuites(new String[] { 'TLSv1.1' },
					new String[] { 'TLS_RSA_WITH_AES_128_CBC_SHA256' }))
			.isInstanceOfAny(SSLException.class, SocketException.class);
	}
	@Override
	protected JspServlet getJspServlet() {
		return null; // Undertow does not support JSPs
	}
	private void awaitFile(File file) {
		Awaitility.waitAtMost(Duration.ofSeconds(10)).until(file::exists, is(true));
	}
	private ServletContainer getServletContainerFromNewFactory() {
		UndertowServletWebServer container = (UndertowServletWebServer) getFactory().getWebServer();
		try {
			return container.getDeploymentManager().getDeployment().getServletContainer();
		}
		finally {
			container.stop();
		}
	}
	@Override
	protected Map<String, String> getActualMimeMappings() {
		return ((UndertowServletWebServer) this.webServer).getDeploymentManager()
			.getDeployment()
			.getMimeExtensionMappings();
	}
	@Override
	protected Charset getCharset(Locale locale) {
		DeploymentInfo info = ((UndertowServletWebServer) this.webServer).getDeploymentManager()
			.getDeployment()
			.getDeploymentInfo();
		String charsetName = info.getLocaleCharsetMapping().get(locale.toString());
		return (charsetName != null) ? Charset.forName(charsetName) : null;
	}
	@Override
	protected void handleExceptionCausedByBlockedPortOnPrimaryConnector(RuntimeException ex, int blockedPort) {
		assertThat(ex).isInstanceOf(PortInUseException.class);
		assertThat(((PortInUseException) ex).getPort()).isEqualTo(blockedPort);
		Undertow undertow = (Undertow) ReflectionTestUtils.getField(this.webServer, 'undertow');
		assertThat(undertow.getWorker()).isNull();
	}
	@Override
	protected void handleExceptionCausedByBlockedPortOnSecondaryConnector(RuntimeException ex, int blockedPort) {
		handleExceptionCausedByBlockedPortOnPrimaryConnector(ex, blockedPort);
	}
	@Override
	protected String startedLogMessage() {
		return ((UndertowServletWebServer) this.webServer).getStartLogMessage();
	}
}
/*
package org.springframework.boot.web.embedded.undertow;
/**
class UndertowReactiveWebServerFactoryTests extends AbstractReactiveWebServerFactoryTests {
	@TempDir
	File tempDir;
	@Override
	protected UndertowReactiveWebServerFactory getFactory() {
		return new UndertowReactiveWebServerFactory(0);
	}
	@Test
	void setNullBuilderCustomizersShouldThrowException() {
		UndertowReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setBuilderCustomizers(null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void addNullBuilderCustomizersShouldThrowException() {
		UndertowReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addBuilderCustomizers((UndertowBuilderCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void builderCustomizersShouldBeInvoked() {
		UndertowReactiveWebServerFactory factory = getFactory();
		HttpHandler handler = mock(HttpHandler.class);
		UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(UndertowBuilderCustomizer.class));
		factory.setBuilderCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addBuilderCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer(handler);
		InOrder ordered = inOrder((Object[]) customizers);
		for (UndertowBuilderCustomizer customizer : customizers) {
			ordered.verify(customizer).customize(any(Undertow.Builder.class));
		}
	}
	@Test
	void useForwardedHeaders() {
		UndertowReactiveWebServerFactory factory = getFactory();
		factory.setUseForwardHeaders(true);
		assertForwardHeaderIsUsed(factory);
	}
	@Test
	void accessLogCanBeEnabled() {
		testAccessLog(null, null, 'access_log.log');
	}
	@Test
	void accessLogCanBeCustomized() {
		testAccessLog('my_access.', 'logz', 'my_access.logz');
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenNewConnectionsAreRejectedWithServiceUnavailable() {
		UndertowReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		this.webServer.shutDownGracefully((result) -> {
		});
		WebClient webClient = getWebClient(this.webServer.getPort()).build();
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> {
			blockingHandler.stopBlocking();
			try {
				webClient.get().retrieve().toBodilessEntity().block();
				return false;
			}
			catch (RuntimeException ex) {
				return ex instanceof ServiceUnavailable;
			}
		});
		this.webServer.stop();
	}
	private void testAccessLog(String prefix, String suffix, String expectedFile) {
		UndertowReactiveWebServerFactory factory = getFactory();
		factory.setAccessLogEnabled(true);
		factory.setAccessLogPrefix(prefix);
		factory.setAccessLogSuffix(suffix);
		File accessLogDirectory = this.tempDir;
		factory.setAccessLogDirectory(accessLogDirectory);
		assertThat(accessLogDirectory).isEmptyDirectory();
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		WebClient client = getWebClient(this.webServer.getPort()).build();
		Mono<String> result = client.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
		assertThat(result.block(Duration.ofSeconds(30))).isEqualTo('Hello World');
		File accessLog = new File(accessLogDirectory, expectedFile);
		awaitFile(accessLog);
		assertThat(accessLogDirectory.listFiles()).contains(accessLog);
	}
	private void awaitFile(File file) {
		Awaitility.waitAtMost(Duration.ofSeconds(10)).until(file::exists, is(true));
	}
	@Override
	protected String startedLogMessage() {
		return ((UndertowWebServer) this.webServer).getStartLogMessage();
	}
	@Override
	protected void addConnector(int port, AbstractReactiveWebServerFactory factory) {
		((UndertowReactiveWebServerFactory) factory)
			.addBuilderCustomizers((builder) -> builder.addHttpListener(port, '0.0.0.0'));
	}
}
/*
package org.springframework.boot.web.embedded.test;
/**
class MockPkcs11SecurityProviderExtension implements BeforeAllCallback, AfterAllCallback {
	@Override
	public void beforeAll(ExtensionContext context) throws Exception {
		Security.addProvider(MockPkcs11SecurityProvider.INSTANCE);
	}
	@Override
	public void afterAll(ExtensionContext context) throws Exception {
		Security.removeProvider(MockPkcs11SecurityProvider.NAME);
	}
}
/*
package org.springframework.boot.web.embedded.test;
/**
public class MockKeyStoreSpi extends KeyStoreSpi {
	private static final KeyPairGenerator KEYGEN;
	static {
		try {
			KEYGEN = KeyPairGenerator.getInstance('RSA');
			KEYGEN.initialize(2048);
		}
		catch (NoSuchAlgorithmException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private final Map<String, KeyPair> aliases = new HashMap<>();
	@Override
	public Key engineGetKey(String alias, char[] password) {
		final KeyPair keyPair = this.aliases.get(alias);
		return (keyPair != null) ? keyPair.getPrivate() : null;
	}
	@Override
	public Certificate[] engineGetCertificateChain(String alias) {
		return new Certificate[0];
	}
	@Override
	public Certificate engineGetCertificate(String alias) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Date engineGetCreationDate(String alias) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void engineSetCertificateEntry(String alias, Certificate cert) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void engineDeleteEntry(String alias) {
		throw new UnsupportedOperationException();
	}
	@Override
	public Enumeration<String> engineAliases() {
		return Collections.enumeration(this.aliases.keySet());
	}
	@Override
	public boolean engineContainsAlias(String alias) {
		this.aliases.put(alias, KEYGEN.generateKeyPair());
		return true;
	}
	@Override
	public int engineSize() {
		throw new UnsupportedOperationException();
	}
	@Override
	public boolean engineIsKeyEntry(String alias) {
		return this.aliases.containsKey(alias);
	}
	@Override
	public boolean engineIsCertificateEntry(String alias) {
		return false;
	}
	@Override
	public String engineGetCertificateAlias(Certificate cert) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void engineStore(OutputStream stream, char[] password) {
		throw new UnsupportedOperationException();
	}
	@Override
	public void engineLoad(InputStream stream, char[] password) {
	}
}
/*
package org.springframework.boot.web.embedded.test;
/**
@ExtendWith(MockPkcs11SecurityProviderExtension.class)
@Retention(RetentionPolicy.RUNTIME)
public @interface MockPkcs11Security {
}
/*
package org.springframework.boot.web.embedded.test;
/**
public class MockPkcs11SecurityProvider extends Provider {
	/**
	 * The name of the mock provider.
	 */
	public static final String NAME = 'Mock-PKCS11';
	static final MockPkcs11SecurityProvider INSTANCE = new MockPkcs11SecurityProvider();
	MockPkcs11SecurityProvider() {
		super(NAME, '0.1', 'Mock PKCS11 Provider');
		putService(new Service(this, 'KeyStore', 'PKCS11', MockKeyStoreSpi.class.getName(), null, null));
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class JettyServletWebServerFactoryTests extends AbstractServletWebServerFactoryTests {
	@Override
	protected JettyServletWebServerFactory getFactory() {
		JettyServletWebServerFactory factory = new JettyServletWebServerFactory(0);
		factory.addServerCustomizers((server) -> {
			for (Connector connector : server.getConnectors()) {
				if (connector instanceof ServerConnector serverConnector) {
					// TODO Set the shutdown idle timeout in main code?
					serverConnector.setShutdownIdleTimeout(10000);
				}
			}
		});
		return factory;
	}
	@Override
	protected void addConnector(int port, AbstractServletWebServerFactory factory) {
		((JettyServletWebServerFactory) factory).addServerCustomizers((server) -> {
			ServerConnector connector = new ServerConnector(server);
			connector.setPort(port);
			server.addConnector(connector);
		});
	}
	@Override
	protected JspServlet getJspServlet() throws Exception {
		WebAppContext context = findWebAppContext((JettyWebServer) this.webServer);
		ServletHolder holder = context.getServletHandler().getServlet('jsp');
		if (holder == null) {
			return null;
		}
		holder.start();
		holder.initialize();
		return (JspServlet) holder.getServlet();
	}
	@Override
	protected Map<String, String> getActualMimeMappings() {
		WebAppContext context = findWebAppContext((JettyWebServer) this.webServer);
		return context.getMimeTypes().getMimeMap();
	}
	@Override
	protected Charset getCharset(Locale locale) {
		WebAppContext context = findWebAppContext((JettyWebServer) this.webServer);
		String charsetName = context.getLocaleEncoding(locale);
		return (charsetName != null) ? Charset.forName(charsetName) : null;
	}
	@Override
	protected void handleExceptionCausedByBlockedPortOnPrimaryConnector(RuntimeException ex, int blockedPort) {
		assertThat(ex).isInstanceOf(PortInUseException.class);
		assertThat(((PortInUseException) ex).getPort()).isEqualTo(blockedPort);
	}
	@Override
	protected void handleExceptionCausedByBlockedPortOnSecondaryConnector(RuntimeException ex, int blockedPort) {
		handleExceptionCausedByBlockedPortOnPrimaryConnector(ex, blockedPort);
	}
	@Test
	@Override
	@Disabled('Jetty 12 does not support User-Agent-based compression')
	protected void noCompressionForUserAgent() {
	}
	@Test
	@Override
	@Disabled('Jetty 12 does not support SSL session tracking')
	protected void sslSessionTracking() {
	}
	@Test
	void contextPathIsLoggedOnStartupWhenCompressionIsEnabled(CapturedOutput output) {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setContextPath('/custom');
		Compression compression = new Compression();
		compression.setEnabled(true);
		factory.setCompression(compression);
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(output).containsOnlyOnce('with context path "/custom"');
	}
	@Test
	void jettyConfigurations() throws Exception {
		JettyServletWebServerFactory factory = getFactory();
		Configuration[] configurations = new Configuration[] { mockConfiguration(Configuration1.class),
				mockConfiguration(Configuration2.class), mockConfiguration(Configuration3.class),
				mockConfiguration(Configuration4.class) };
		factory.setConfigurations(Arrays.asList(configurations[0], configurations[1]));
		factory.addConfigurations(configurations[2], configurations[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) configurations);
		for (Configuration configuration : configurations) {
			ordered.verify(configuration).configure(any(WebAppContext.class));
		}
	}
	Configuration mockConfiguration(Class<? extends Configuration> type) {
		Configuration mock = mock(type);
		ClassMatcher classMatcher = new ClassMatcher();
		given(mock.getProtectedClasses()).willReturn(classMatcher);
		given(mock.getHiddenClasses()).willReturn(classMatcher);
		return mock;
	}
	@Test
	void jettyCustomizations() {
		JettyServletWebServerFactory factory = getFactory();
		JettyServerCustomizer[] configurations = new JettyServerCustomizer[4];
		Arrays.setAll(configurations, (i) -> mock(JettyServerCustomizer.class));
		factory.setServerCustomizers(Arrays.asList(configurations[0], configurations[1]));
		factory.addServerCustomizers(configurations[2], configurations[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) configurations);
		for (JettyServerCustomizer configuration : configurations) {
			ordered.verify(configuration).customize(any(Server.class));
		}
	}
	@Test
	void sessionTimeout() {
		JettyServletWebServerFactory factory = getFactory();
		factory.getSession().setTimeout(Duration.ofSeconds(10));
		assertTimeout(factory, 10);
	}
	@Test
	void sessionTimeoutInMinutes() {
		JettyServletWebServerFactory factory = getFactory();
		factory.getSession().setTimeout(Duration.ofMinutes(1));
		assertTimeout(factory, 60);
	}
	@Test
	void sslCiphersConfiguration() {
		Ssl ssl = new Ssl();
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setKeyStorePassword('secret');
		ssl.setKeyPassword('password');
		ssl.setCiphers(new String[] { 'ALPHA', 'BRAVO', 'CHARLIE' });
		JettyServletWebServerFactory factory = getFactory();
		factory.setSsl(ssl);
		this.webServer = factory.getWebServer();
		this.webServer.start();
		JettyWebServer jettyWebServer = (JettyWebServer) this.webServer;
		ServerConnector connector = (ServerConnector) jettyWebServer.getServer().getConnectors()[0];
		SslConnectionFactory connectionFactory = connector.getConnectionFactory(SslConnectionFactory.class);
		SslContextFactory sslContextFactory = extractSslContextFactory(connectionFactory);
		assertThat(sslContextFactory.getIncludeCipherSuites()).containsExactly('ALPHA', 'BRAVO', 'CHARLIE');
		assertThat(sslContextFactory.getExcludeCipherSuites()).isEmpty();
	}
	@Test
	void destroyCalledWithoutStart() {
		JettyServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.destroy();
		Server server = ((JettyWebServer) this.webServer).getServer();
		assertThat(server.isStopped()).isTrue();
	}
	@Test
	void sslEnabledMultiProtocolsConfiguration() {
		JettyServletWebServerFactory factory = getFactory();
		factory.setSsl(getSslSettings('TLSv1.1', 'TLSv1.2'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		JettyWebServer jettyWebServer = (JettyWebServer) this.webServer;
		ServerConnector connector = (ServerConnector) jettyWebServer.getServer().getConnectors()[0];
		SslConnectionFactory connectionFactory = connector.getConnectionFactory(SslConnectionFactory.class);
		SslContextFactory sslContextFactory = extractSslContextFactory(connectionFactory);
		assertThat(sslContextFactory.getIncludeProtocols()).containsExactly('TLSv1.1', 'TLSv1.2');
	}
	@Test
	void sslEnabledProtocolsConfiguration() {
		JettyServletWebServerFactory factory = getFactory();
		factory.setSsl(getSslSettings('TLSv1.1'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		JettyWebServer jettyWebServer = (JettyWebServer) this.webServer;
		ServerConnector connector = (ServerConnector) jettyWebServer.getServer().getConnectors()[0];
		SslConnectionFactory connectionFactory = connector.getConnectionFactory(SslConnectionFactory.class);
		SslContextFactory sslContextFactory = extractSslContextFactory(connectionFactory);
		assertThat(sslContextFactory.getIncludeProtocols()).containsExactly('TLSv1.1');
	}
	@Test
	void sslServerNameBundlesConfigurationThrowsException() {
		Ssl ssl = new Ssl();
		ssl.setBundle('test');
		List<ServerNameSslBundle> bundles = List.of(new ServerNameSslBundle('first', 'test1'),
				new ServerNameSslBundle('second', 'test2'));
		ssl.setServerNameBundles(bundles);
		JettyServletWebServerFactory factory = getFactory();
		factory.setSsl(ssl);
		assertThatIllegalStateException().isThrownBy(() -> this.webServer = factory.getWebServer())
			.withMessageContaining('Server name SSL bundles are not supported with Jetty');
	}
	private SslContextFactory extractSslContextFactory(SslConnectionFactory connectionFactory) {
		try {
			return connectionFactory.getSslContextFactory();
		}
		catch (NoSuchMethodError ex) {
			Method getSslContextFactory = ReflectionUtils.findMethod(connectionFactory.getClass(),
					'getSslContextFactory');
			return (SslContextFactory) ReflectionUtils.invokeMethod(getSslContextFactory, connectionFactory);
		}
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
			registration.setAsyncSupported(true);
		});
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> request = initiateGetRequest(port, '/blocking');
		blockingServlet.awaitQueue();
		this.webServer.shutDownGracefully((result) -> {
		});
		Future<Object> unconnectableRequest = initiateGetRequest(port, '/');
		blockingServlet.admitOne();
		Object response = request.get();
		assertThat(response).isInstanceOf(HttpResponse.class);
		assertThat(unconnectableRequest.get()).isInstanceOf(HttpHostConnectException.class);
		this.webServer.stop();
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenResponseToRequestOnIdleConnectionWillHaveAConnectionCloseHeader()
			throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
			registration.setAsyncSupported(true);
		});
		this.webServer.start();
		int port = this.webServer.getPort();
		HttpClient client = HttpClients.createMinimal();
		Future<Object> request = initiateGetRequest(client, port, '/blocking');
		blockingServlet.awaitQueue();
		blockingServlet.admitOne();
		Object response = request.get();
		assertThat(response).isInstanceOf(HttpResponse.class);
		assertThat(((HttpResponse) response).getCode()).isEqualTo(200);
		assertThat(((HttpResponse) response).getFirstHeader('Connection')).isNull();
		this.webServer.shutDownGracefully((result) -> {
		});
		request = initiateGetRequest(client, port, '/blocking');
		blockingServlet.awaitQueue();
		blockingServlet.admitOne();
		response = request.get();
		assertThat(response).isInstanceOf(HttpResponse.class);
		assertThat(((HttpResponse) response).getCode()).isEqualTo(200);
		assertThat(((HttpResponse) response).getFirstHeader('Connection')).isNotNull()
			.extracting(Header::getValue)
			.isEqualTo('close');
		this.webServer.stop();
	}
	@Test
	void whenARequestCompletesAfterGracefulShutdownHasBegunThenItHasAConnectionCloseHeader()
			throws InterruptedException, ExecutionException {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
			registration.setAsyncSupported(true);
		});
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> request = initiateGetRequest(port, '/blocking');
		blockingServlet.awaitQueue();
		AtomicReference<GracefulShutdownResult> result = new AtomicReference<>();
		this.webServer.shutDownGracefully(result::set);
		blockingServlet.admitOne();
		Awaitility.await().atMost(Duration.ofSeconds(5)).until(() -> GracefulShutdownResult.IDLE == result.get());
		Object requestResult = request.get();
		assertThat(requestResult).isInstanceOf(HttpResponse.class);
		assertThat(((HttpResponse) requestResult).getFirstHeader('Connection').getValue()).isEqualTo('close');
	}
	private Ssl getSslSettings(String... enabledProtocols) {
		Ssl ssl = new Ssl();
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setKeyStorePassword('secret');
		ssl.setKeyPassword('password');
		ssl.setCiphers(new String[] { 'ALPHA', 'BRAVO', 'CHARLIE' });
		ssl.setEnabledProtocols(enabledProtocols);
		return ssl;
	}
	private void assertTimeout(JettyServletWebServerFactory factory, int expected) {
		this.webServer = factory.getWebServer();
		JettyWebServer jettyWebServer = (JettyWebServer) this.webServer;
		WebAppContext webAppContext = findWebAppContext(jettyWebServer);
		int actual = webAppContext.getSessionHandler().getMaxInactiveInterval();
		assertThat(actual).isEqualTo(expected);
	}
	@Test
	void wrappedHandlers() throws Exception {
		JettyServletWebServerFactory factory = getFactory();
		factory.setServerCustomizers(Collections.singletonList((server) -> {
			Handler handler = server.getHandler();
			Handler.Wrapper wrapper = new Handler.Wrapper();
			wrapper.setHandler(handler);
			server.setHandler(wrapper);
		}));
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.start();
		assertThat(getResponse(getLocalUrl('/hello'))).isEqualTo('Hello World');
	}
	@Test
	void basicSslClasspathKeyStore() throws Exception {
		testBasicSslWithKeyStore('classpath:test.jks');
	}
	@Test
	void useForwardHeaders() throws Exception {
		JettyServletWebServerFactory factory = getFactory();
		factory.setUseForwardHeaders(true);
		assertForwardHeaderIsUsed(factory);
	}
	@Test
	void defaultThreadPool() {
		JettyServletWebServerFactory factory = getFactory();
		factory.setThreadPool(null);
		assertThat(factory.getThreadPool()).isNull();
		this.webServer = factory.getWebServer();
		assertThat(((JettyWebServer) this.webServer).getServer().getThreadPool()).isNotNull();
	}
	@Test
	void customThreadPool() {
		JettyServletWebServerFactory factory = getFactory();
		ThreadPool threadPool = mock(ThreadPool.class);
		factory.setThreadPool(threadPool);
		this.webServer = factory.getWebServer();
		assertThat(((JettyWebServer) this.webServer).getServer().getThreadPool()).isSameAs(threadPool);
	}
	@Test
	void startFailsWhenThreadPoolIsTooSmall() {
		JettyServletWebServerFactory factory = getFactory();
		factory.addServerCustomizers((server) -> {
			QueuedThreadPool threadPool = server.getBean(QueuedThreadPool.class);
			threadPool.setMaxThreads(2);
			threadPool.setMinThreads(2);
		});
		assertThatExceptionOfType(WebServerException.class).isThrownBy(factory.getWebServer()::start)
			.withCauseInstanceOf(IllegalStateException.class);
	}
	@Test
	void specificIPAddressNotReverseResolved() throws Exception {
		JettyServletWebServerFactory factory = getFactory();
		InetAddress localhost = InetAddress.getLocalHost();
		factory.setAddress(InetAddress.getByAddress(localhost.getAddress()));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		Connector connector = ((JettyWebServer) this.webServer).getServer().getConnectors()[0];
		assertThat(((ServerConnector) connector).getHost()).isEqualTo(localhost.getHostAddress());
	}
	@Test
	void specificIPAddressWithSslIsNotReverseResolved() throws Exception {
		JettyServletWebServerFactory factory = getFactory();
		InetAddress localhost = InetAddress.getLocalHost();
		factory.setAddress(InetAddress.getByAddress(localhost.getAddress()));
		Ssl ssl = new Ssl();
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setKeyStorePassword('secret');
		ssl.setKeyPassword('password');
		factory.setSsl(ssl);
		this.webServer = factory.getWebServer();
		this.webServer.start();
		Connector connector = ((JettyWebServer) this.webServer).getServer().getConnectors()[0];
		assertThat(((ServerConnector) connector).getHost()).isEqualTo(localhost.getHostAddress());
	}
	@Test
	void faultyListenerCausesStartFailure() {
		JettyServletWebServerFactory factory = getFactory();
		factory.addServerCustomizers((JettyServerCustomizer) (server) -> {
			Collection<WebAppContext> contexts = server.getBeans(WebAppContext.class);
			EventListener eventListener = new ServletContextListener() {
				@Override
				public void contextInitialized(ServletContextEvent event) {
					throw new RuntimeException();
				}
				@Override
				public void contextDestroyed(ServletContextEvent event) {
				}
			};
			WebAppContext context = contexts.iterator().next();
			try {
				context.addEventListener(eventListener);
			}
			catch (NoSuchMethodError ex) {
				// Jetty 10
				Method addEventListener = ReflectionUtils.findMethod(context.getClass(), 'addEventListener',
						EventListener.class);
				ReflectionUtils.invokeMethod(addEventListener, context, eventListener);
			}
		});
		assertThatExceptionOfType(WebServerException.class).isThrownBy(() -> {
			JettyWebServer jettyWebServer = (JettyWebServer) factory.getWebServer();
			try {
				jettyWebServer.start();
			}
			finally {
				QueuedThreadPool threadPool = (QueuedThreadPool) jettyWebServer.getServer().getThreadPool();
				assertThat(threadPool.isRunning()).isFalse();
			}
		});
	}
	@Test
	void errorHandlerCanBeOverridden() {
		JettyServletWebServerFactory factory = getFactory();
		factory.addConfigurations(new AbstractConfiguration(new AbstractConfiguration.Builder()) {
			@Override
			public void configure(WebAppContext context) throws Exception {
				context.setErrorHandler(new CustomErrorHandler());
			}
		});
		JettyWebServer jettyWebServer = (JettyWebServer) factory.getWebServer();
		WebAppContext context = findWebAppContext(jettyWebServer);
		assertThat(context.getErrorHandler()).isInstanceOf(CustomErrorHandler.class);
	}
	@Test
	void shouldApplyMaxConnections() {
		JettyServletWebServerFactory factory = getFactory();
		factory.setMaxConnections(1);
		this.webServer = factory.getWebServer();
		Server server = ((JettyWebServer) this.webServer).getServer();
		ConnectionLimit connectionLimit = server.getBean(ConnectionLimit.class);
		assertThat(connectionLimit).isNotNull();
		assertThat(connectionLimit.getMaxConnections()).isOne();
	}
	@Test
	void shouldApplyMaxConnectionsToConnectors() {
		JettyServletWebServerFactory factory = getFactory();
		factory.setMaxConnections(1);
		this.webServer = factory.getWebServer();
		Server server = ((JettyWebServer) this.webServer).getServer();
		assertThat(server.getConnectors()).isEmpty();
		ConnectionLimit connectionLimit = server.getBean(ConnectionLimit.class);
		assertThat(connectionLimit).extracting('_connectors')
			.asInstanceOf(InstanceOfAssertFactories.list(AbstractConnector.class))
			.hasSize(1);
	}
	@Override
	protected String startedLogMessage() {
		return ((JettyWebServer) this.webServer).getStartedLogMessage();
	}
	private WebAppContext findWebAppContext(JettyWebServer webServer) {
		return findWebAppContext(webServer.getServer().getHandler());
	}
	private WebAppContext findWebAppContext(Handler handler) {
		if (handler instanceof WebAppContext webAppContext) {
			return webAppContext;
		}
		if (handler instanceof Handler.Wrapper wrapper) {
			return findWebAppContext(wrapper.getHandler());
		}
		throw new IllegalStateException('No WebAppContext found');
	}
	private static final class CustomErrorHandler extends ErrorPageErrorHandler {
	}
	interface Configuration1 extends Configuration {
	}
	interface Configuration2 extends Configuration {
	}
	interface Configuration3 extends Configuration {
	}
	interface Configuration4 extends Configuration {
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class LoaderHidingResourceTests {
	@Test
	void listHidesLoaderResources(@TempDir File temp) throws IOException {
		URI warUri = createExampleWar(temp);
		Resource resource = new PathResourceFactory().newResource(warUri);
		LoaderHidingResource loaderHidingResource = new LoaderHidingResource(resource, resource);
		assertThat(deepList(loaderHidingResource)).hasOnlyElementsOfType(LoaderHidingResource.class)
			.extracting(Resource::getName)
			.contains('/assets/image.jpg')
			.doesNotContain('/org/springframework/boot/Loader.class');
	}
	@Test
	void getAllResourcesHidesLoaderResources(@TempDir File temp) throws IOException {
		URI warUri = createExampleWar(temp);
		Resource resource = new PathResourceFactory().newResource(warUri);
		LoaderHidingResource loaderHidingResource = new LoaderHidingResource(resource, resource);
		Collection<Resource> allResources = loaderHidingResource.getAllResources();
		assertThat(allResources).hasOnlyElementsOfType(LoaderHidingResource.class)
			.extracting(Resource::getName)
			.contains('/assets/image.jpg')
			.doesNotContain('/org/springframework/boot/Loader.class');
	}
	@Test
	void resolveHidesLoaderResources(@TempDir File temp) throws IOException {
		URI warUri = createExampleWar(temp);
		Resource resource = new PathResourceFactory().newResource(warUri);
		LoaderHidingResource loaderHidingResource = new LoaderHidingResource(resource, resource);
		assertThat(loaderHidingResource.resolve('/assets/image.jpg').exists()).isTrue();
		assertThat(loaderHidingResource.resolve('/assets/image.jpg')).isInstanceOf(LoaderHidingResource.class);
		assertThat(loaderHidingResource.resolve('/assets/non-existent.jpg').exists()).isFalse();
		assertThat(loaderHidingResource.resolve('/assets/non-existent.jpg')).isInstanceOf(LoaderHidingResource.class);
		assertThat(loaderHidingResource.resolve('/org/springframework/boot/Loader.class')).isNull();
	}
	private URI createExampleWar(File temp) throws IOException {
		File exampleWarFile = new File(temp, 'example.war');
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(exampleWarFile))) {
			out.putNextEntry(new ZipEntry('org/'));
			out.putNextEntry(new ZipEntry('org/springframework/'));
			out.putNextEntry(new ZipEntry('org/springframework/boot/'));
			out.putNextEntry(new ZipEntry('org/springframework/boot/Loader.class'));
			out.putNextEntry(new ZipEntry('assets/'));
			out.putNextEntry(new ZipEntry('assets/image.jpg'));
		}
		URI warUri = URI.create('jar:' + exampleWarFile.toURI() + '!/');
		FileSystems.newFileSystem(warUri, Collections.emptyMap());
		return warUri;
	}
	private List<Resource> deepList(Resource resource) {
		List<Resource> all = new ArrayList<>();
		for (Resource listed : resource.list()) {
			all.add(listed);
			all.addAll(deepList(listed));
		}
		return all;
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
class JettyReactiveWebServerFactoryTests extends AbstractReactiveWebServerFactoryTests {
	@Override
	protected JettyReactiveWebServerFactory getFactory() {
		return new JettyReactiveWebServerFactory(0);
	}
	@Test
	@Override
	@Disabled('Jetty 12 does not support User-Agent-based compression')
	// TODO Is this true with Jetty 12?
	protected void noCompressionForUserAgent() {
	}
	@Test
	void setNullServerCustomizersShouldThrowException() {
		JettyReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setServerCustomizers(null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void addNullServerCustomizersShouldThrowException() {
		JettyReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addServerCustomizers((JettyServerCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void jettyCustomizersShouldBeInvoked() {
		HttpHandler handler = mock(HttpHandler.class);
		JettyReactiveWebServerFactory factory = getFactory();
		JettyServerCustomizer[] configurations = new JettyServerCustomizer[4];
		Arrays.setAll(configurations, (i) -> mock(JettyServerCustomizer.class));
		factory.setServerCustomizers(Arrays.asList(configurations[0], configurations[1]));
		factory.addServerCustomizers(configurations[2], configurations[3]);
		this.webServer = factory.getWebServer(handler);
		InOrder ordered = inOrder((Object[]) configurations);
		for (JettyServerCustomizer configuration : configurations) {
			ordered.verify(configuration).customize(any(Server.class));
		}
	}
	@Test
	void specificIPAddressNotReverseResolved() throws Exception {
		JettyReactiveWebServerFactory factory = getFactory();
		InetAddress localhost = InetAddress.getLocalHost();
		factory.setAddress(InetAddress.getByAddress(localhost.getAddress()));
		this.webServer = factory.getWebServer(mock(HttpHandler.class));
		this.webServer.start();
		Connector connector = ((JettyWebServer) this.webServer).getServer().getConnectors()[0];
		assertThat(((ServerConnector) connector).getHost()).isEqualTo(localhost.getHostAddress());
	}
	@Test
	void useForwardedHeaders() {
		JettyReactiveWebServerFactory factory = getFactory();
		factory.setUseForwardHeaders(true);
		assertForwardHeaderIsUsed(factory);
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() {
		JettyReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		WebClient webClient = getWebClient(this.webServer.getPort()).build();
		this.webServer.shutDownGracefully((result) -> {
		});
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> {
			blockingHandler.stopBlocking();
			try {
				webClient.get().retrieve().toBodilessEntity().block();
				return false;
			}
			catch (RuntimeException ex) {
				return ex.getCause() instanceof ConnectException;
			}
		});
		this.webServer.stop();
	}
	@Test
	void shouldApplyMaxConnections() {
		JettyReactiveWebServerFactory factory = getFactory();
		factory.setMaxConnections(1);
		this.webServer = factory.getWebServer(new EchoHandler());
		Server server = ((JettyWebServer) this.webServer).getServer();
		ConnectionLimit connectionLimit = server.getBean(ConnectionLimit.class);
		assertThat(connectionLimit).isNotNull();
		assertThat(connectionLimit.getMaxConnections()).isOne();
	}
	@Override
	protected String startedLogMessage() {
		return ((JettyWebServer) this.webServer).getStartedLogMessage();
	}
	@Override
	protected void addConnector(int port, AbstractReactiveWebServerFactory factory) {
		((JettyReactiveWebServerFactory) factory).addServerCustomizers((server) -> {
			ServerConnector connector = new ServerConnector(server);
			connector.setPort(port);
			server.addConnector(connector);
		});
	}
}
/*
package org.springframework.boot.web.embedded.jetty;
/**
@MockPkcs11Security
class SslServerCustomizerTests {
	@Test
	@SuppressWarnings('rawtypes')
	void whenHttp2IsNotEnabledServerConnectorHasSslAndHttpConnectionFactories() {
		Server server = createCustomizedServer();
		assertThat(server.getConnectors()).hasSize(1);
		List<ConnectionFactory> factories = new ArrayList<>(server.getConnectors()[0].getConnectionFactories());
		assertThat(factories).extracting((factory) -> (Class) factory.getClass())
			.containsExactly(SslConnectionFactory.class, HttpConnectionFactory.class);
	}
	@Test
	@SuppressWarnings('rawtypes')
	@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
			disabledReason = 'conscrypt doesn"t support Linux/macOS aarch64, see https://github.com/google/conscrypt/issues/1051')
	void whenHttp2IsEnabledServerConnectorsHasSslAlpnH2AndHttpConnectionFactories() {
		Http2 http2 = new Http2();
		http2.setEnabled(true);
		Server server = createCustomizedServer(http2);
		assertThat(server.getConnectors()).hasSize(1);
		List<ConnectionFactory> factories = new ArrayList<>(server.getConnectors()[0].getConnectionFactories());
		assertThat(factories).extracting((factory) -> (Class) factory.getClass())
			.containsExactly(SslConnectionFactory.class, ALPNServerConnectionFactory.class,
					HTTP2ServerConnectionFactory.class, HttpConnectionFactory.class);
	}
	@Test
	@DisabledOnOs(os = { OS.LINUX, OS.MAC }, architecture = 'aarch64',
			disabledReason = 'conscrypt doesn"t support Linux/macOS aarch64, see https://github.com/google/conscrypt/issues/1051')
	void alpnConnectionFactoryHasNullDefaultProtocolToAllowNegotiationToHttp11() {
		Http2 http2 = new Http2();
		http2.setEnabled(true);
		Server server = createCustomizedServer(http2);
		assertThat(server.getConnectors()).hasSize(1);
		List<ConnectionFactory> factories = new ArrayList<>(server.getConnectors()[0].getConnectionFactories());
		assertThat(((ALPNServerConnectionFactory) factories.get(1)).getDefaultProtocol()).isNull();
	}
	@Test
	void configureSslWhenSslIsEnabledWithNoKeyStoreAndNotPkcs11ThrowsException() {
		Ssl ssl = new Ssl();
		assertThatIllegalStateException().isThrownBy(() -> {
			SslServerCustomizer customizer = new SslServerCustomizer(null, null, null, WebServerSslBundle.get(ssl));
			customizer.configureSsl(new SslContextFactory.Server(), ssl.getClientAuth());
		}).withMessageContaining('SSL is enabled but no trust material is configured');
	}
	@Test
	void configureSslWhenSslIsEnabledWithPkcs11AndKeyStoreThrowsException() {
		Ssl ssl = new Ssl();
		ssl.setKeyStoreType('PKCS11');
		ssl.setKeyStoreProvider(MockPkcs11SecurityProvider.NAME);
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setKeyPassword('password');
		assertThatIllegalStateException().isThrownBy(() -> {
			SslServerCustomizer customizer = new SslServerCustomizer(null, null, null, WebServerSslBundle.get(ssl));
			customizer.configureSsl(new SslContextFactory.Server(), ssl.getClientAuth());
		}).withMessageContaining('must be empty or null for PKCS11 hardware key stores');
	}
	@Test
	void customizeWhenSslIsEnabledWithPkcs11AndKeyStoreProvider() {
		Ssl ssl = new Ssl();
		ssl.setKeyStoreType('PKCS11');
		ssl.setKeyStoreProvider(MockPkcs11SecurityProvider.NAME);
		ssl.setKeyStorePassword('1234');
		assertThatNoException().isThrownBy(() -> {
			SslServerCustomizer customizer = new SslServerCustomizer(null, null, null, WebServerSslBundle.get(ssl));
			customizer.configureSsl(new SslContextFactory.Server(), ssl.getClientAuth());
		});
	}
	private Server createCustomizedServer() {
		return createCustomizedServer(new Http2());
	}
	private Server createCustomizedServer(Http2 http2) {
		Ssl ssl = new Ssl();
		ssl.setKeyStore('classpath:test.jks');
		return createCustomizedServer(ssl, http2);
	}
	private Server createCustomizedServer(Ssl ssl, Http2 http2) {
		Server server = new Server();
		new SslServerCustomizer(http2, new InetSocketAddress(0), ssl.getClientAuth(), WebServerSslBundle.get(ssl))
			.customize(server);
		return server;
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class TomcatEmbeddedWebappClassLoaderTests {
	@TempDir
	File tempDir;
	@Test
	void getResourceFindsResourceFromParentClassLoader() throws Exception {
		File war = createWar();
		withWebappClassLoader(war, (classLoader) -> assertThat(classLoader.getResource('test.txt'))
			.isEqualTo(new URL(webInfClassesUrlString(war) + 'test.txt')));
	}
	@Test
	void getResourcesOnlyFindsResourcesFromParentClassLoader() throws Exception {
		File warFile = createWar();
		withWebappClassLoader(warFile, (classLoader) -> {
			List<URL> urls = new ArrayList<>();
			CollectionUtils.toIterator(classLoader.getResources('test.txt')).forEachRemaining(urls::add);
			assertThat(urls).containsExactly(new URL(webInfClassesUrlString(warFile) + 'test.txt'));
		});
	}
	private void withWebappClassLoader(File war, ClassLoaderConsumer consumer) throws Exception {
		URLClassLoader parent = new URLClassLoader(new URL[] { new URL(webInfClassesUrlString(war)) }, null);
		try (ParallelWebappClassLoader classLoader = new TomcatEmbeddedWebappClassLoader(parent)) {
			StandardContext context = new StandardContext();
			context.setName('test');
			StandardRoot resources = new StandardRoot();
			resources.setContext(context);
			resources.addJarResources(new WarResourceSet(resources, '/', war.getAbsolutePath()));
			resources.start();
			classLoader.setResources(resources);
			classLoader.start();
			try {
				consumer.accept(classLoader);
			}
			finally {
				classLoader.stop();
				classLoader.close();
				resources.stop();
			}
		}
		parent.close();
	}
	private String webInfClassesUrlString(File war) {
		return 'jar:file:' + war.getAbsolutePath() + '!/WEB-INF/classes/';
	}
	private File createWar() throws IOException {
		File warFile = new File(this.tempDir, 'test.war');
		try (JarOutputStream warOut = new JarOutputStream(new FileOutputStream(warFile))) {
			createEntries(warOut, 'WEB-INF/', 'WEB-INF/classes/', 'WEB-INF/classes/test.txt');
		}
		return warFile;
	}
	private void createEntries(JarOutputStream out, String... names) throws IOException {
		for (String name : names) {
			out.putNextEntry(new ZipEntry(name));
			out.closeEntry();
		}
	}
	interface ClassLoaderConsumer {
		void accept(ClassLoader classLoader) throws Exception;
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class TomcatReactiveWebServerFactoryTests extends AbstractReactiveWebServerFactoryTests {
	@Override
	protected TomcatReactiveWebServerFactory getFactory() {
		return new TomcatReactiveWebServerFactory(0);
	}
	@Test
	void tomcatCustomizers() {
		TomcatReactiveWebServerFactory factory = getFactory();
		TomcatContextCustomizer[] customizers = new TomcatContextCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(TomcatContextCustomizer.class));
		factory.setTomcatContextCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addContextCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer(mock(HttpHandler.class));
		InOrder ordered = inOrder((Object[]) customizers);
		for (TomcatContextCustomizer customizer : customizers) {
			then(customizer).should(ordered).customize(any(Context.class));
		}
	}
	@Test
	void contextIsAddedToHostBeforeCustomizersAreCalled() {
		TomcatReactiveWebServerFactory factory = getFactory();
		TomcatContextCustomizer customizer = mock(TomcatContextCustomizer.class);
		factory.addContextCustomizers(customizer);
		this.webServer = factory.getWebServer(mock(HttpHandler.class));
		then(customizer).should().customize(assertArg((context) -> assertThat(context.getParent()).isNotNull()));
	}
	@Test
	void defaultTomcatListeners() {
		TomcatReactiveWebServerFactory factory = getFactory();
		if (AprLifecycleListener.isAprAvailable()) {
			assertThat(factory.getContextLifecycleListeners()).singleElement().isInstanceOf(AprLifecycleListener.class);
		}
		else {
			assertThat(factory.getContextLifecycleListeners()).isEmpty();
		}
	}
	@Test
	void tomcatListeners() {
		TomcatReactiveWebServerFactory factory = getFactory();
		LifecycleListener[] listeners = new LifecycleListener[4];
		Arrays.setAll(listeners, (i) -> mock(LifecycleListener.class));
		factory.setContextLifecycleListeners(Arrays.asList(listeners[0], listeners[1]));
		factory.addContextLifecycleListeners(listeners[2], listeners[3]);
		this.webServer = factory.getWebServer(mock(HttpHandler.class));
		InOrder ordered = inOrder((Object[]) listeners);
		for (LifecycleListener listener : listeners) {
			then(listener).should(ordered).lifecycleEvent(any(LifecycleEvent.class));
		}
	}
	@Test
	void setNullConnectorCustomizersShouldThrowException() {
		TomcatReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setTomcatConnectorCustomizers(null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void addNullAddConnectorCustomizersShouldThrowException() {
		TomcatReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addConnectorCustomizers((TomcatConnectorCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void setNullProtocolHandlerCustomizersShouldThrowException() {
		TomcatReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setTomcatProtocolHandlerCustomizers(null))
			.withMessageContaining('TomcatProtocolHandlerCustomizers must not be null');
	}
	@Test
	void addNullProtocolHandlerCustomizersShouldThrowException() {
		TomcatReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addProtocolHandlerCustomizers((TomcatProtocolHandlerCustomizer[]) null))
			.withMessageContaining('TomcatProtocolHandlerCustomizers must not be null');
	}
	@Test
	void tomcatConnectorCustomizersShouldBeInvoked() {
		TomcatReactiveWebServerFactory factory = getFactory();
		HttpHandler handler = mock(HttpHandler.class);
		TomcatConnectorCustomizer[] customizers = new TomcatConnectorCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(TomcatConnectorCustomizer.class));
		factory.setTomcatConnectorCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addConnectorCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer(handler);
		InOrder ordered = inOrder((Object[]) customizers);
		for (TomcatConnectorCustomizer customizer : customizers) {
			then(customizer).should(ordered).customize(any(Connector.class));
		}
	}
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void tomcatProtocolHandlerCustomizersShouldBeInvoked() {
		TomcatReactiveWebServerFactory factory = getFactory();
		HttpHandler handler = mock(HttpHandler.class);
		TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol<?>>[] customizers = new TomcatProtocolHandlerCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class));
		factory.setTomcatProtocolHandlerCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addProtocolHandlerCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer(handler);
		InOrder ordered = inOrder((Object[]) customizers);
		for (TomcatProtocolHandlerCustomizer customizer : customizers) {
			then(customizer).should(ordered).customize(any(ProtocolHandler.class));
		}
	}
	@Test
	void tomcatAdditionalConnectors() {
		TomcatReactiveWebServerFactory factory = getFactory();
		Connector[] connectors = new Connector[4];
		Arrays.setAll(connectors, (i) -> new Connector());
		factory.addAdditionalTomcatConnectors(connectors);
		this.webServer = factory.getWebServer(mock(HttpHandler.class));
		Map<Service, Connector[]> connectorsByService = ((TomcatWebServer) this.webServer).getServiceConnectors();
		assertThat(connectorsByService.values().iterator().next()).hasSize(connectors.length + 1);
	}
	@Test
	void addNullAdditionalConnectorsThrows() {
		TomcatReactiveWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.addAdditionalTomcatConnectors((Connector[]) null))
			.withMessageContaining('Connectors must not be null');
	}
	@Test
	void useForwardedHeaders() {
		TomcatReactiveWebServerFactory factory = getFactory();
		RemoteIpValve valve = new RemoteIpValve();
		valve.setProtocolHeader('X-Forwarded-Proto');
		factory.addEngineValves(valve);
		assertForwardHeaderIsUsed(factory);
	}
	@Test
	void referenceClearingIsDisabled() {
		TomcatReactiveWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(mock(HttpHandler.class));
		this.webServer.start();
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		StandardContext context = (StandardContext) tomcat.getHost().findChildren()[0];
		assertThat(context.getClearReferencesObjectStreamClassCaches()).isFalse();
		assertThat(context.getClearReferencesRmiTargets()).isFalse();
		assertThat(context.getClearReferencesThreadLocals()).isFalse();
	}
	@Test
	void portClashOfPrimaryConnectorResultsInPortInUseException() throws Exception {
		doWithBlockedPort((port) -> assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {
			AbstractReactiveWebServerFactory factory = getFactory();
			factory.setPort(port);
			this.webServer = factory.getWebServer(mock(HttpHandler.class));
			this.webServer.start();
		}).satisfies((ex) -> handleExceptionCausedByBlockedPortOnPrimaryConnector(ex, port)));
	}
	@Override
	protected void assertThatSslWithInvalidAliasCallFails(ThrowingCallable call) {
		assertThatExceptionOfType(WebServerException.class).isThrownBy(call);
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() {
		TomcatReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		WebClient webClient = getWebClient(this.webServer.getPort()).build();
		this.webServer.shutDownGracefully((result) -> {
		});
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> {
			blockingHandler.stopBlocking();
			try {
				webClient.get().retrieve().toBodilessEntity().block();
				return false;
			}
			catch (RuntimeException ex) {
				return ex.getCause() instanceof ConnectException;
			}
		});
		this.webServer.stop();
	}
	@Test
	void whenGetTomcatWebServerIsOverriddenThenWebServerCreationCanBeCustomized() {
		AtomicReference<TomcatWebServer> webServerReference = new AtomicReference<>();
		TomcatWebServer webServer = (TomcatWebServer) new TomcatReactiveWebServerFactory() {
			@Override
			protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {
				webServerReference.set(new TomcatWebServer(tomcat));
				return webServerReference.get();
			}
		}.getWebServer(new EchoHandler());
		assertThat(webServerReference).hasValue(webServer);
	}
	private void handleExceptionCausedByBlockedPortOnPrimaryConnector(RuntimeException ex, int blockedPort) {
		assertThat(ex).isInstanceOf(PortInUseException.class);
		assertThat(((PortInUseException) ex).getPort()).isEqualTo(blockedPort);
	}
	@Override
	protected String startedLogMessage() {
		return ((TomcatWebServer) this.webServer).getStartedLogMessage();
	}
	@Override
	protected void addConnector(int port, AbstractReactiveWebServerFactory factory) {
		Connector connector = new Connector('org.apache.coyote.http11.Http11NioProtocol');
		connector.setPort(port);
		((TomcatReactiveWebServerFactory) factory).addAdditionalTomcatConnectors(connector);
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class TldPatternsTests {
	@Test
	void tomcatSkipAlignsWithTomcatDefaults() throws IOException {
		assertThat(TldPatterns.TOMCAT_SKIP).containsExactlyInAnyOrderElementsOf(getTomcatDefaultJarsToSkip());
	}
	@Test
	void tomcatScanAlignsWithTomcatDefaults() throws IOException {
		assertThat(TldPatterns.TOMCAT_SCAN).containsExactlyInAnyOrderElementsOf(getTomcatDefaultJarsToScan());
	}
	private Set<String> getTomcatDefaultJarsToSkip() throws IOException {
		return getTomcatDefault('tomcat.util.scan.StandardJarScanFilter.jarsToSkip');
	}
	private Set<String> getTomcatDefaultJarsToScan() throws IOException {
		return getTomcatDefault('tomcat.util.scan.StandardJarScanFilter.jarsToScan');
	}
	private Set<String> getTomcatDefault(String key) throws IOException {
		ClassLoader classLoader = getClass().getClassLoader();
		try (InputStream inputStream = classLoader.getResource('catalina.properties').openStream()) {
			Properties properties = new Properties();
			properties.load(inputStream);
			String jarsToSkip = properties.getProperty(key);
			return StringUtils.commaDelimitedListToSet(jarsToSkip);
		}
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class CompressionConnectorCustomizerTests {
	private static final int MIN_SIZE = 100;
	private final String[] mimeTypes = { 'text/html', 'text/xml', 'text/xhtml' };
	private final String[] excludedUserAgents = { 'SomeUserAgent', 'AnotherUserAgent' };
	private Compression compression;
	@BeforeEach
	void setup() {
		this.compression = new Compression();
		this.compression.setEnabled(true);
		this.compression.setMinResponseSize(DataSize.ofBytes(MIN_SIZE));
		this.compression.setMimeTypes(this.mimeTypes);
		this.compression.setExcludedUserAgents(this.excludedUserAgents);
	}
	@Test
	void shouldCustomizeCompression() {
		CompressionConnectorCustomizer compressionConnectorCustomizer = new CompressionConnectorCustomizer(
				this.compression);
		Connector connector = new Connector('org.apache.coyote.http11.Http11NioProtocol');
		Http2Protocol upgradeProtocol = new Http2Protocol();
		upgradeProtocol.setHttp11Protocol((AbstractHttp11Protocol<?>) connector.getProtocolHandler());
		connector.addUpgradeProtocol(upgradeProtocol);
		compressionConnectorCustomizer.customize(connector);
		AbstractHttp11Protocol<?> abstractHttp11Protocol = (AbstractHttp11Protocol<?>) connector.getProtocolHandler();
		compressionOn(abstractHttp11Protocol.getCompression());
		minSize(abstractHttp11Protocol.getCompressionMinSize());
		mimeType(abstractHttp11Protocol.getCompressibleMimeTypes());
		excludedUserAgents(abstractHttp11Protocol.getNoCompressionUserAgents());
	}
	private void compressionOn(String compression) {
		assertThat(compression).isEqualTo('on');
	}
	private void minSize(int minSize) {
		assertThat(minSize).isEqualTo(MIN_SIZE);
	}
	private void mimeType(String[] mimeTypes) {
		assertThat(mimeTypes).isEqualTo(this.mimeTypes);
	}
	private void excludedUserAgents(String combinedUserAgents) {
		assertThat(combinedUserAgents).isEqualTo('SomeUserAgent,AnotherUserAgent');
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
@ExtendWith(OutputCaptureExtension.class)
@DirtiesUrlFactories
@MockPkcs11Security
class SslConnectorCustomizerTests {
	private final Log logger = LogFactory.getLog(SslConnectorCustomizerTests.class);
	private Tomcat tomcat;
	@BeforeEach
	void setup() {
		this.tomcat = new Tomcat();
		Connector connector = new Connector('org.apache.coyote.http11.Http11NioProtocol');
		connector.setPort(0);
		this.tomcat.setConnector(connector);
	}
	@AfterEach
	void stop() throws Exception {
		System.clearProperty('javax.net.ssl.trustStorePassword');
		this.tomcat.stop();
	}
	@Test
	void sslCiphersConfiguration() throws Exception {
		Ssl ssl = new Ssl();
		ssl.setKeyStore('classpath:test.jks');
		ssl.setKeyStorePassword('secret');
		ssl.setCiphers(new String[] { 'ALPHA', 'BRAVO', 'CHARLIE' });
		Connector connector = this.tomcat.getConnector();
		SslConnectorCustomizer customizer = new SslConnectorCustomizer(this.logger, connector, ssl.getClientAuth());
		customizer.customize(WebServerSslBundle.get(ssl), Collections.emptyMap());
		this.tomcat.start();
		SSLHostConfig[] sslHostConfigs = connector.getProtocolHandler().findSslHostConfigs();
		assertThat(sslHostConfigs[0].getCiphers()).isEqualTo('ALPHA:BRAVO:CHARLIE');
	}
	@Test
	void sslEnabledMultipleProtocolsConfiguration() throws Exception {
		Ssl ssl = new Ssl();
		ssl.setKeyPassword('password');
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setEnabledProtocols(new String[] { 'TLSv1.1', 'TLSv1.2' });
		ssl.setCiphers(new String[] { 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256', 'BRAVO' });
		Connector connector = this.tomcat.getConnector();
		SslConnectorCustomizer customizer = new SslConnectorCustomizer(this.logger, connector, ssl.getClientAuth());
		customizer.customize(WebServerSslBundle.get(ssl), Collections.emptyMap());
		this.tomcat.start();
		SSLHostConfig sslHostConfig = connector.getProtocolHandler().findSslHostConfigs()[0];
		assertThat(sslHostConfig.getSslProtocol()).isEqualTo('TLS');
		assertThat(sslHostConfig.getEnabledProtocols()).containsExactlyInAnyOrder('TLSv1.1', 'TLSv1.2');
	}
	@Test
	void sslEnabledProtocolsConfiguration() throws Exception {
		Ssl ssl = new Ssl();
		ssl.setKeyPassword('password');
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setEnabledProtocols(new String[] { 'TLSv1.2' });
		ssl.setCiphers(new String[] { 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256', 'BRAVO' });
		Connector connector = this.tomcat.getConnector();
		SslConnectorCustomizer customizer = new SslConnectorCustomizer(this.logger, connector, ssl.getClientAuth());
		customizer.customize(WebServerSslBundle.get(ssl), Collections.emptyMap());
		this.tomcat.start();
		SSLHostConfig sslHostConfig = connector.getProtocolHandler().findSslHostConfigs()[0];
		assertThat(sslHostConfig.getSslProtocol()).isEqualTo('TLS');
		assertThat(sslHostConfig.getEnabledProtocols()).containsExactly('TLSv1.2');
	}
	@Test
	void customizeWhenSslIsEnabledWithNoKeyStoreAndNotPkcs11ThrowsException() {
		assertThatIllegalStateException().isThrownBy(() -> {
			SslConnectorCustomizer customizer = new SslConnectorCustomizer(this.logger, this.tomcat.getConnector(),
					Ssl.ClientAuth.NONE);
			customizer.customize(WebServerSslBundle.get(new Ssl()), Collections.emptyMap());
		}).withMessageContaining('SSL is enabled but no trust material is configured');
	}
	@Test
	void customizeWhenSslIsEnabledWithPkcs11AndKeyStoreThrowsException() {
		Ssl ssl = new Ssl();
		ssl.setKeyStoreType('PKCS11');
		ssl.setKeyStoreProvider(MockPkcs11SecurityProvider.NAME);
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setKeyPassword('password');
		assertThatIllegalStateException().isThrownBy(() -> {
			SslConnectorCustomizer customizer = new SslConnectorCustomizer(this.logger, this.tomcat.getConnector(),
					ssl.getClientAuth());
			customizer.customize(WebServerSslBundle.get(ssl), Collections.emptyMap());
		}).withMessageContaining('must be empty or null for PKCS11 hardware key stores');
	}
	@Test
	void customizeWhenSslIsEnabledWithPkcs11AndKeyStoreProvider() {
		Ssl ssl = new Ssl();
		ssl.setKeyStoreType('PKCS11');
		ssl.setKeyStoreProvider(MockPkcs11SecurityProvider.NAME);
		ssl.setKeyStorePassword('1234');
		SslConnectorCustomizer customizer = new SslConnectorCustomizer(this.logger, this.tomcat.getConnector(),
				ssl.getClientAuth());
		assertThatNoException()
			.isThrownBy(() -> customizer.customize(WebServerSslBundle.get(ssl), Collections.emptyMap()));
	}
}
/*
package org.springframework.boot.web.embedded.tomcat;
/**
class TomcatServletWebServerFactoryTests extends AbstractServletWebServerFactoryTests {
	@Override
	protected TomcatServletWebServerFactory getFactory() {
		return new TomcatServletWebServerFactory(0);
	}
	@AfterEach
	void restoreTccl() {
		Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
	}
	// JMX MBean names clash if you get more than one Engine with the same name...
	@Test
	void tomcatEngineNames() {
		TomcatServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		factory.setPort(0);
		TomcatWebServer tomcatWebServer = (TomcatWebServer) factory.getWebServer();
		// Make sure that the names are different
		String firstName = ((TomcatWebServer) this.webServer).getTomcat().getEngine().getName();
		String secondName = tomcatWebServer.getTomcat().getEngine().getName();
		assertThat(firstName).as('Tomcat engines must have different names').isNotEqualTo(secondName);
		tomcatWebServer.stop();
	}
	@Test
	void defaultTomcatListeners() {
		TomcatServletWebServerFactory factory = getFactory();
		if (AprLifecycleListener.isAprAvailable()) {
			assertThat(factory.getContextLifecycleListeners()).singleElement().isInstanceOf(AprLifecycleListener.class);
		}
		else {
			assertThat(factory.getContextLifecycleListeners()).isEmpty();
		}
	}
	@Test
	void tomcatListeners() {
		TomcatServletWebServerFactory factory = getFactory();
		LifecycleListener[] listeners = new LifecycleListener[4];
		Arrays.setAll(listeners, (i) -> mock(LifecycleListener.class));
		factory.setContextLifecycleListeners(Arrays.asList(listeners[0], listeners[1]));
		factory.addContextLifecycleListeners(listeners[2], listeners[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) listeners);
		for (LifecycleListener listener : listeners) {
			then(listener).should(ordered).lifecycleEvent(any(LifecycleEvent.class));
		}
	}
	@Test
	void tomcatCustomizers() {
		TomcatServletWebServerFactory factory = getFactory();
		TomcatContextCustomizer[] customizers = new TomcatContextCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(TomcatContextCustomizer.class));
		factory.setTomcatContextCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addContextCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) customizers);
		for (TomcatContextCustomizer customizer : customizers) {
			then(customizer).should(ordered).customize(any(Context.class));
		}
	}
	@Test
	void contextIsAddedToHostBeforeCustomizersAreCalled() {
		TomcatServletWebServerFactory factory = getFactory();
		TomcatContextCustomizer customizer = mock(TomcatContextCustomizer.class);
		factory.addContextCustomizers(customizer);
		this.webServer = factory.getWebServer();
		then(customizer).should().customize(assertArg((context) -> assertThat(context.getParent()).isNotNull()));
	}
	@Test
	void tomcatConnectorCustomizers() {
		TomcatServletWebServerFactory factory = getFactory();
		TomcatConnectorCustomizer[] customizers = new TomcatConnectorCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(TomcatConnectorCustomizer.class));
		factory.setTomcatConnectorCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addConnectorCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) customizers);
		for (TomcatConnectorCustomizer customizer : customizers) {
			then(customizer).should(ordered).customize(any(Connector.class));
		}
	}
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void tomcatProtocolHandlerCustomizersShouldBeInvoked() {
		TomcatServletWebServerFactory factory = getFactory();
		TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol<?>>[] customizers = new TomcatProtocolHandlerCustomizer[4];
		Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class));
		factory.setTomcatProtocolHandlerCustomizers(Arrays.asList(customizers[0], customizers[1]));
		factory.addProtocolHandlerCustomizers(customizers[2], customizers[3]);
		this.webServer = factory.getWebServer();
		InOrder ordered = inOrder((Object[]) customizers);
		for (TomcatProtocolHandlerCustomizer customizer : customizers) {
			then(customizer).should(ordered).customize(any(ProtocolHandler.class));
		}
	}
	@Test
	void tomcatProtocolHandlerCanBeCustomized() {
		TomcatServletWebServerFactory factory = getFactory();
		TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol<?>> customizer = (protocolHandler) -> protocolHandler
			.setProcessorCache(250);
		factory.addProtocolHandlerCustomizers(customizer);
		Tomcat tomcat = getTomcat(factory);
		Connector connector = ((TomcatWebServer) this.webServer).getServiceConnectors().get(tomcat.getService())[0];
		AbstractHttp11Protocol<?> protocolHandler = (AbstractHttp11Protocol<?>) connector.getProtocolHandler();
		assertThat(protocolHandler.getProcessorCache()).isEqualTo(250);
	}
	@Test
	void tomcatAdditionalConnectors() {
		TomcatServletWebServerFactory factory = getFactory();
		Connector[] connectors = new Connector[4];
		Arrays.setAll(connectors, (i) -> {
			Connector connector = new Connector();
			connector.setPort(0);
			return connector;
		});
		factory.addAdditionalTomcatConnectors(connectors);
		this.webServer = factory.getWebServer();
		Map<Service, Connector[]> connectorsByService = new HashMap<>(
				((TomcatWebServer) this.webServer).getServiceConnectors());
		assertThat(connectorsByService.values().iterator().next()).hasSize(connectors.length + 1);
		this.webServer.start();
		this.webServer.stop();
		connectorsByService.forEach((service, serviceConnectors) -> {
			for (Connector connector : serviceConnectors) {
				assertThat(connector.getProtocolHandler()).extracting('endpoint.serverSock').isNull();
			}
		});
	}
	@Test
	void addNullAdditionalConnectorThrows() {
		TomcatServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.addAdditionalTomcatConnectors((Connector[]) null))
			.withMessageContaining('Connectors must not be null');
	}
	@Test
	void sessionTimeout() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.getSession().setTimeout(Duration.ofSeconds(10));
		assertTimeout(factory, 1);
	}
	@Test
	void sessionTimeoutInMinutes() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.getSession().setTimeout(Duration.ofMinutes(1));
		assertTimeout(factory, 1);
	}
	@Test
	void noSessionTimeout() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.getSession().setTimeout(null);
		assertTimeout(factory, -1);
	}
	@Test
	void valve() {
		TomcatServletWebServerFactory factory = getFactory();
		Valve valve = mock(Valve.class);
		factory.addContextValves(valve);
		this.webServer = factory.getWebServer();
		then(valve).should().setNext(any(Valve.class));
	}
	@Test
	void setNullTomcatContextCustomizersThrows() {
		TomcatServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setTomcatContextCustomizers(null))
			.withMessageContaining('TomcatContextCustomizers must not be null');
	}
	@Test
	void addNullContextCustomizersThrows() {
		TomcatServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addContextCustomizers((TomcatContextCustomizer[]) null))
			.withMessageContaining('TomcatContextCustomizers must not be null');
	}
	@Test
	void setNullTomcatConnectorCustomizersThrows() {
		TomcatServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setTomcatConnectorCustomizers(null))
			.withMessageContaining('TomcatConnectorCustomizers must not be null');
	}
	@Test
	void addNullConnectorCustomizersThrows() {
		TomcatServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addConnectorCustomizers((TomcatConnectorCustomizer[]) null))
			.withMessageContaining('TomcatConnectorCustomizers must not be null');
	}
	@Test
	void setNullTomcatProtocolHandlerCustomizersThrows() {
		TomcatServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException().isThrownBy(() -> factory.setTomcatProtocolHandlerCustomizers(null))
			.withMessageContaining('TomcatProtocolHandlerCustomizers must not be null');
	}
	@Test
	void addNullTomcatProtocolHandlerCustomizersThrows() {
		TomcatServletWebServerFactory factory = getFactory();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> factory.addProtocolHandlerCustomizers((TomcatProtocolHandlerCustomizer[]) null))
			.withMessageContaining('TomcatProtocolHandlerCustomizers must not be null');
	}
	@Test
	void uriEncoding() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.setUriEncoding(StandardCharsets.US_ASCII);
		Tomcat tomcat = getTomcat(factory);
		Connector connector = ((TomcatWebServer) this.webServer).getServiceConnectors().get(tomcat.getService())[0];
		assertThat(connector.getURIEncoding()).isEqualTo('US-ASCII');
	}
	@Test
	void defaultUriEncoding() {
		TomcatServletWebServerFactory factory = getFactory();
		Tomcat tomcat = getTomcat(factory);
		Connector connector = ((TomcatWebServer) this.webServer).getServiceConnectors().get(tomcat.getService())[0];
		assertThat(connector.getURIEncoding()).isEqualTo('UTF-8');
	}
	@Test
	void startupFailureDoesNotResultInUnstoppedThreadsBeingReported(CapturedOutput output) throws Exception {
		super.portClashOfPrimaryConnectorResultsInPortInUseException();
		assertThat(output).doesNotContain('appears to have started a thread named [main]');
	}
	@Test
	void destroyCalledWithoutStart() {
		TomcatServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer(exampleServletRegistration());
		this.webServer.destroy();
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		assertThat(tomcat.getServer().getState()).isSameAs(LifecycleState.DESTROYED);
	}
	@Override
	protected void addConnector(int port, AbstractServletWebServerFactory factory) {
		Connector connector = new Connector('org.apache.coyote.http11.Http11NioProtocol');
		connector.setPort(port);
		((TomcatServletWebServerFactory) factory).addAdditionalTomcatConnectors(connector);
	}
	@Test
	void useForwardHeaders() throws Exception {
		TomcatServletWebServerFactory factory = getFactory();
		factory.addContextValves(new RemoteIpValve());
		assertForwardHeaderIsUsed(factory);
	}
	@Test
	void disableDoesNotSaveSessionFiles() throws Exception {
		TomcatServletWebServerFactory factory = getFactory();
		// If baseDir is not set SESSIONS.ser is written to a different temp directory
		// each time. By setting it we can really ensure that data isn"t saved
		factory.setBaseDirectory(this.tempDir);
		this.webServer = factory.getWebServer(sessionServletRegistration());
		this.webServer.start();
		String s1 = getResponse(getLocalUrl('/session'));
		String s2 = getResponse(getLocalUrl('/session'));
		this.webServer.stop();
		this.webServer = factory.getWebServer(sessionServletRegistration());
		this.webServer.start();
		String s3 = getResponse(getLocalUrl('/session'));
		String message = 'Session error s1=' + s1 + ' s2=' + s2 + ' s3=' + s3;
		assertThat(s2.split(':')[0]).as(message).isEqualTo(s1.split(':')[1]);
		assertThat(s3.split(':')[0]).as(message).isNotEqualTo(s2.split(':')[1]);
	}
	@Test
	void jndiLookupsCanBePerformedDuringApplicationContextRefresh() throws NamingException {
		Thread.currentThread().setContextClassLoader(getClass().getClassLoader());
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0) {
			@Override
			protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {
				tomcat.enableNaming();
				return super.getTomcatWebServer(tomcat);
			}
		};
		// Server is created in onRefresh
		this.webServer = factory.getWebServer();
		// Lookups should now be possible
		new InitialContext().lookup('java:comp/env');
		// Called in finishRefresh, giving us an opportunity to remove the context binding
		// and avoid a leak
		this.webServer.start();
		// Lookups should no longer be possible
		assertThatExceptionOfType(NamingException.class).isThrownBy(() -> new InitialContext().lookup('java:comp/env'));
	}
	@Test
	void defaultLocaleCharsetMappingsAreOverridden() throws IOException {
		TomcatServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		// override defaults, see org.apache.catalina.util.CharsetMapperDefault.properties
		Properties charsetMapperDefault = PropertiesLoaderUtils
			.loadProperties(new ClassPathResource('CharsetMapperDefault.properties', CharsetMapper.class));
		for (String language : charsetMapperDefault.stringPropertyNames()) {
			assertThat(getCharset(new Locale(language))).isEqualTo(StandardCharsets.UTF_8);
		}
	}
	@Test
	@Disabled('See https://github.com/apache/tomcat/commit/c3e33b62101c5ee155808dd1932acde0cac65fe3')
	void sessionIdGeneratorIsConfiguredWithAttributesFromTheManager() {
		System.setProperty('jvmRoute', 'test');
		try {
			TomcatServletWebServerFactory factory = getFactory();
			this.webServer = factory.getWebServer();
			this.webServer.start();
		}
		finally {
			System.clearProperty('jvmRoute');
		}
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		Context context = (Context) tomcat.getHost().findChildren()[0];
		SessionIdGenerator sessionIdGenerator = context.getManager().getSessionIdGenerator();
		assertThat(sessionIdGenerator).isInstanceOf(LazySessionIdGenerator.class);
		assertThat(sessionIdGenerator.getJvmRoute()).isEqualTo('test');
	}
	@Test
	void tldSkipPatternsShouldBeAppliedToContextJarScanner() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.addTldSkipPatterns('foo.jar', 'bar.jar');
		this.webServer = factory.getWebServer();
		this.webServer.start();
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		Context context = (Context) tomcat.getHost().findChildren()[0];
		JarScanFilter jarScanFilter = context.getJarScanner().getJarScanFilter();
		assertThat(jarScanFilter.check(JarScanType.TLD, 'foo.jar')).isFalse();
		assertThat(jarScanFilter.check(JarScanType.TLD, 'bar.jar')).isFalse();
		assertThat(jarScanFilter.check(JarScanType.TLD, 'test.jar')).isTrue();
	}
	@Test
	void tldScanPatternsShouldBeAppliedToContextJarScanner() {
		TomcatServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		this.webServer.start();
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		Context context = (Context) tomcat.getHost().findChildren()[0];
		JarScanFilter jarScanFilter = context.getJarScanner().getJarScanFilter();
		String tldScan = ((StandardJarScanFilter) jarScanFilter).getTldScan();
		assertThat(tldScan).isEqualTo('log4j-taglib*.jar,log4j-jakarta-web*.jar,log4javascript*.jar,slf4j-taglib*.jar');
	}
	@Test
	void customTomcatHttpOnlyCookie() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.getSession().getCookie().setHttpOnly(false);
		this.webServer = factory.getWebServer();
		this.webServer.start();
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		Context context = (Context) tomcat.getHost().findChildren()[0];
		assertThat(context.getUseHttpOnly()).isFalse();
	}
	@Test
	void exceptionThrownOnLoadFailureWhenFailCtxIfServletStartFailsIsTrue() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.addContextCustomizers((context) -> {
			if (context instanceof StandardContext standardContext) {
				standardContext.setFailCtxIfServletStartFails(true);
			}
		});
		this.webServer = factory
			.getWebServer((context) -> context.addServlet('failing', FailingServlet.class).setLoadOnStartup(0));
		assertThatExceptionOfType(WebServerException.class).isThrownBy(this.webServer::start);
	}
	@Test
	void exceptionThrownOnLoadFailureWhenFailCtxIfServletStartFailsIsFalse() {
		TomcatServletWebServerFactory factory = getFactory();
		factory.addContextCustomizers((context) -> {
			if (context instanceof StandardContext standardContext) {
				standardContext.setFailCtxIfServletStartFails(false);
			}
		});
		this.webServer = factory
			.getWebServer((context) -> context.addServlet('failing', FailingServlet.class).setLoadOnStartup(0));
		this.webServer.start();
	}
	@Test
	void referenceClearingIsDisabled() {
		TomcatServletWebServerFactory factory = getFactory();
		this.webServer = factory.getWebServer();
		this.webServer.start();
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		StandardContext context = (StandardContext) tomcat.getHost().findChildren()[0];
		assertThat(context.getClearReferencesObjectStreamClassCaches()).isFalse();
		assertThat(context.getClearReferencesRmiTargets()).isFalse();
		assertThat(context.getClearReferencesThreadLocals()).isFalse();
	}
	@Test
	void nonExistentUploadDirectoryIsCreatedUponMultipartUpload() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
		AtomicReference<ServletContext> servletContextReference = new AtomicReference<>();
		factory.addInitializers((servletContext) -> {
			servletContextReference.set(servletContext);
			Dynamic servlet = servletContext.addServlet('upload', new HttpServlet() {
				@Override
				protected void doPost(HttpServletRequest req, HttpServletResponse resp)
						throws ServletException, IOException {
					req.getParts();
				}
			});
			servlet.addMapping('/upload');
			servlet.setMultipartConfig(new MultipartConfigElement((String) null));
		});
		this.webServer = factory.getWebServer();
		this.webServer.start();
		File temp = (File) servletContextReference.get().getAttribute(ServletContext.TEMPDIR);
		FileSystemUtils.deleteRecursively(temp);
		RestTemplate restTemplate = new RestTemplate();
		HttpHeaders headers = new HttpHeaders();
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
		body.add('file', new ByteArrayResource(new byte[1024 * 1024]));
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);
		ResponseEntity<String> response = restTemplate.postForEntity(getLocalUrl('/upload'), requestEntity,
				String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void exceptionThrownOnContextListenerDestroysServer() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0) {
			@Override
			protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {
				try {
					return super.getTomcatWebServer(tomcat);
				}
				finally {
					assertThat(tomcat.getServer().getState()).isEqualTo(LifecycleState.DESTROYED);
				}
			}
		};
		assertThatExceptionOfType(WebServerException.class).isThrownBy(
				() -> factory.getWebServer((context) -> context.addListener(new FailingServletContextListener())));
	}
	@Test
	void registerJspServletWithDefaultLoadOnStartup() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
		factory.addInitializers((context) -> context.addServlet('manually-registered-jsp-servlet', JspServlet.class));
		this.webServer = factory.getWebServer();
		this.webServer.start();
	}
	@Override
	protected void assertThatSslWithInvalidAliasCallFails(ThrowingCallable call) {
		assertThatExceptionOfType(WebServerException.class).isThrownBy(call);
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
			registration.setAsyncSupported(true);
		});
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> request = initiateGetRequest(port, '/blocking');
		blockingServlet.awaitQueue();
		this.webServer.shutDownGracefully((result) -> {
		});
		Object unconnectableRequest = Awaitility.await()
			.until(() -> initiateGetRequest(HttpClients.createDefault(), port, '/').get(),
					(result) -> result instanceof Exception);
		assertThat(unconnectableRequest).isInstanceOf(HttpHostConnectException.class);
		blockingServlet.admitOne();
		assertThat(request.get()).isInstanceOf(HttpResponse.class);
		this.webServer.stop();
	}
	@Test
	void whenServerIsShuttingDownARequestOnAnIdleConnectionResultsInConnectionReset() throws Exception {
		AbstractServletWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingServlet blockingServlet = new BlockingServlet();
		this.webServer = factory.getWebServer((context) -> {
			Dynamic registration = context.addServlet('blockingServlet', blockingServlet);
			registration.addMapping('/blocking');
			registration.setAsyncSupported(true);
		});
		HttpClient httpClient = HttpClients.createMinimal();
		this.webServer.start();
		int port = this.webServer.getPort();
		Future<Object> keepAliveRequest = initiateGetRequest(httpClient, port, '/blocking');
		blockingServlet.awaitQueue();
		blockingServlet.admitOne();
		assertThat(keepAliveRequest.get()).isInstanceOf(HttpResponse.class);
		Future<Object> request = initiateGetRequest(port, '/blocking');
		blockingServlet.awaitQueue();
		this.webServer.shutDownGracefully((result) -> {
		});
		Object idleConnectionRequestResult = Awaitility.await().until(() -> {
			Future<Object> idleConnectionRequest = initiateGetRequest(httpClient, port, '/');
			Object result = idleConnectionRequest.get();
			return result;
		}, (result) -> result instanceof Exception);
		assertThat(idleConnectionRequestResult).isInstanceOfAny(SocketException.class, NoHttpResponseException.class);
		if (idleConnectionRequestResult instanceof SocketException socketException) {
			assertThat(socketException).hasMessage('Connection reset');
		}
		blockingServlet.admitOne();
		Object response = request.get();
		assertThat(response).isInstanceOf(HttpResponse.class);
		this.webServer.stop();
	}
	@Test
	void shouldUpdateSslWhenReloadingSslBundles() throws Exception {
		TomcatServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		DefaultSslBundleRegistry bundles = new DefaultSslBundleRegistry('test',
				createPemSslBundle('classpath:org/springframework/boot/web/embedded/tomcat/1.crt',
						'classpath:org/springframework/boot/web/embedded/tomcat/1.key'));
		factory.setSslBundles(bundles);
		factory.setSsl(Ssl.forBundle('test'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		RememberingHostnameVerifier verifier = new RememberingHostnameVerifier();
		SSLContext sslContext = new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build();
		TlsSocketStrategy tlsSocketStrategy = new DefaultClientTlsStrategy(sslContext, verifier);
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(tlsSocketStrategy);
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
		assertThat(verifier.getLastPrincipal()).isEqualTo('CN=1');
		requestFactory = createHttpComponentsRequestFactory(tlsSocketStrategy);
		bundles.updateBundle('test', createPemSslBundle('classpath:org/springframework/boot/web/embedded/tomcat/2.crt',
				'classpath:org/springframework/boot/web/embedded/tomcat/2.key'));
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
		assertThat(verifier.getLastPrincipal()).isEqualTo('CN=2');
	}
	@Test
	void sslWithHttp11Nio2Protocol() throws Exception {
		TomcatServletWebServerFactory factory = getFactory();
		addTestTxtFile(factory);
		factory.setProtocol(Http11Nio2Protocol.class.getName());
		factory.setSsl(getSsl(null, 'password', 'src/test/resources/test.jks'));
		this.webServer = factory.getWebServer();
		this.webServer.start();
		HttpComponentsClientHttpRequestFactory requestFactory = createHttpComponentsRequestFactory(
				createTrustSelfSignedTlsSocketStrategy());
		assertThat(getResponse(getLocalUrl('https', '/test.txt'), requestFactory)).isEqualTo('test');
	}
	@Override
	protected JspServlet getJspServlet() throws ServletException {
		Tomcat tomcat = ((TomcatWebServer) this.webServer).getTomcat();
		Container container = tomcat.getHost().findChildren()[0];
		StandardWrapper standardWrapper = (StandardWrapper) container.findChild('jsp');
		if (standardWrapper == null) {
			return null;
		}
		standardWrapper.load();
		return (JspServlet) standardWrapper.getServlet();
	}
	@Override
	protected Map<String, String> getActualMimeMappings() {
		Context context = (Context) ((TomcatWebServer) this.webServer).getTomcat().getHost().findChildren()[0];
		Map<String, String> mimeMappings = new HashMap<>();
		for (String extension : context.findMimeMappings()) {
			mimeMappings.put(extension, context.findMimeMapping(extension));
		}
		return mimeMappings;
	}
	@Override
	protected Charset getCharset(Locale locale) {
		Context context = (Context) ((TomcatWebServer) this.webServer).getTomcat().getHost().findChildren()[0];
		CharsetMapper mapper = ((TomcatEmbeddedContext) context).getCharsetMapper();
		String charsetName = mapper.getCharset(locale);
		return (charsetName != null) ? Charset.forName(charsetName) : null;
	}
	private void assertTimeout(TomcatServletWebServerFactory factory, int expected) {
		Tomcat tomcat = getTomcat(factory);
		Context context = (Context) tomcat.getHost().findChildren()[0];
		assertThat(context.getSessionTimeout()).isEqualTo(expected);
	}
	private Tomcat getTomcat(TomcatServletWebServerFactory factory) {
		this.webServer = factory.getWebServer();
		return ((TomcatWebServer) this.webServer).getTomcat();
	}
	@Override
	protected void handleExceptionCausedByBlockedPortOnPrimaryConnector(RuntimeException ex, int blockedPort) {
		assertThat(ex).isInstanceOf(PortInUseException.class);
		assertThat(((PortInUseException) ex).getPort()).isEqualTo(blockedPort);
	}
	@Override
	protected void handleExceptionCausedByBlockedPortOnSecondaryConnector(RuntimeException ex, int blockedPort) {
		assertThat(ex).isInstanceOf(ConnectorStartFailedException.class);
		assertThat(((ConnectorStartFailedException) ex).getPort()).isEqualTo(blockedPort);
	}
	@Override
	protected String startedLogMessage() {
		return ((TomcatWebServer) this.webServer).getStartedLogMessage();
	}
	private static final class RememberingHostnameVerifier implements HostnameVerifier {
		private volatile String lastPrincipal;
		@Override
		public boolean verify(String hostname, SSLSession session) {
			try {
				this.lastPrincipal = session.getPeerPrincipal().getName();
			}
			catch (SSLPeerUnverifiedException ex) {
				throw new RuntimeException(ex);
			}
			return true;
		}
		String getLastPrincipal() {
			return this.lastPrincipal;
		}
	}
}
/*
package org.springframework.boot.web.embedded.netty;
/**
class NettyReactiveWebServerFactoryTests extends AbstractReactiveWebServerFactoryTests {
	@Test
	void exceptionIsThrownWhenPortIsAlreadyInUse() {
		AbstractReactiveWebServerFactory factory = getFactory();
		factory.setPort(0);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		factory.setPort(this.webServer.getPort());
		assertThatExceptionOfType(PortInUseException.class).isThrownBy(factory.getWebServer(new EchoHandler())::start)
			.satisfies(this::portMatchesRequirement)
			.withCauseInstanceOf(Throwable.class);
	}
	@Test
	void getPortWhenDisposableServerPortOperationIsUnsupportedReturnsMinusOne() {
		NettyReactiveWebServerFactory factory = new NoPortNettyReactiveWebServerFactory(0);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		assertThat(this.webServer.getPort()).isEqualTo(-1);
	}
	@Test
	void resourceFactoryAndWebServerLifecycle() {
		NettyReactiveWebServerFactory factory = getFactory();
		factory.setPort(0);
		ReactorResourceFactory resourceFactory = new ReactorResourceFactory();
		factory.setResourceFactory(resourceFactory);
		this.webServer = factory.getWebServer(new EchoHandler());
		assertThatNoException().isThrownBy(() -> {
			resourceFactory.start();
			this.webServer.start();
			this.webServer.stop();
			resourceFactory.stop();
			resourceFactory.start();
			this.webServer.start();
		});
	}
	private void portMatchesRequirement(PortInUseException exception) {
		assertThat(exception.getPort()).isEqualTo(this.webServer.getPort());
	}
	@Test
	void nettyCustomizers() {
		NettyReactiveWebServerFactory factory = getFactory();
		NettyServerCustomizer[] customizers = new NettyServerCustomizer[2];
		for (int i = 0; i < customizers.length; i++) {
			customizers[i] = mock(NettyServerCustomizer.class);
			given(customizers[i].apply(any(HttpServer.class))).will((invocation) -> invocation.getArgument(0));
		}
		factory.setServerCustomizers(Arrays.asList(customizers[0], customizers[1]));
		this.webServer = factory.getWebServer(new EchoHandler());
		InOrder ordered = inOrder((Object[]) customizers);
		for (NettyServerCustomizer customizer : customizers) {
			ordered.verify(customizer).apply(any(HttpServer.class));
		}
	}
	@Test
	void useForwardedHeaders() {
		NettyReactiveWebServerFactory factory = getFactory();
		factory.setUseForwardHeaders(true);
		assertForwardHeaderIsUsed(factory);
	}
	@Test
	void whenSslIsConfiguredWithAValidAliasARequestSucceeds() {
		Mono<String> result = testSslWithAlias('test-alias');
		StepVerifier.create(result).expectNext('Hello World').expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void whenSslBundleIsUpdatedThenSslIsReloaded() {
		DefaultSslBundleRegistry bundles = new DefaultSslBundleRegistry('bundle1', createSslBundle('1.key', '1.crt'));
		Mono<String> result = testSslWithBundle(bundles, 'bundle1');
		StepVerifier.create(result).expectNext('Hello World').expectComplete().verify(Duration.ofSeconds(30));
		bundles.updateBundle('bundle1', createSslBundle('2.key', '2.crt'));
		Mono<String> result2 = executeSslRequest();
		StepVerifier.create(result2).expectNext('Hello World').expectComplete().verify(Duration.ofSeconds(30));
	}
	@Test
	void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() {
		NettyReactiveWebServerFactory factory = getFactory();
		factory.setShutdown(Shutdown.GRACEFUL);
		BlockingHandler blockingHandler = new BlockingHandler();
		this.webServer = factory.getWebServer(blockingHandler);
		this.webServer.start();
		WebClient webClient = getWebClient(this.webServer.getPort()).build();
		this.webServer.shutDownGracefully((result) -> {
		});
		Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> {
			blockingHandler.stopBlocking();
			try {
				webClient.get().retrieve().toBodilessEntity().block();
				return false;
			}
			catch (RuntimeException ex) {
				return ex.getCause() instanceof ConnectException;
			}
		});
		this.webServer.stop();
	}
	@Override
	@Test
	@Disabled('Reactor Netty does not support mutiple ports')
	protected void startedLogMessageWithMultiplePorts() {
	}
	private Mono<String> testSslWithAlias(String alias) {
		String keyStore = 'classpath:test.jks';
		String keyPassword = 'password';
		NettyReactiveWebServerFactory factory = getFactory();
		Ssl ssl = new Ssl();
		ssl.setKeyStore(keyStore);
		ssl.setKeyPassword(keyPassword);
		ssl.setKeyAlias(alias);
		factory.setSsl(ssl);
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		return executeSslRequest();
	}
	private Mono<String> testSslWithBundle(SslBundles sslBundles, String bundle) {
		NettyReactiveWebServerFactory factory = getFactory();
		factory.setSslBundles(sslBundles);
		factory.setSsl(Ssl.forBundle(bundle));
		this.webServer = factory.getWebServer(new EchoHandler());
		this.webServer.start();
		return executeSslRequest();
	}
	private Mono<String> executeSslRequest() {
		ReactorClientHttpConnector connector = buildTrustAllSslConnector();
		WebClient client = WebClient.builder()
			.baseUrl('https://localhost:' + this.webServer.getPort())
			.clientConnector(connector)
			.build();
		return client.post()
			.uri('/test')
			.contentType(MediaType.TEXT_PLAIN)
			.body(BodyInserters.fromValue('Hello World'))
			.retrieve()
			.bodyToMono(String.class);
	}
	@Override
	protected NettyReactiveWebServerFactory getFactory() {
		return new NettyReactiveWebServerFactory(0);
	}
	@Override
	protected String startedLogMessage() {
		return ((NettyWebServer) this.webServer).getStartedLogMessage();
	}
	@Override
	protected void addConnector(int port, AbstractReactiveWebServerFactory factory) {
		throw new UnsupportedOperationException('Reactor Netty does not support multiple ports');
	}
	private static SslBundle createSslBundle(String key, String certificate) {
		return SslBundle.of(new PemSslStoreBundle(
				new PemSslStoreDetails(null, 'classpath:org/springframework/boot/web/embedded/netty/' + certificate,
						'classpath:org/springframework/boot/web/embedded/netty/' + key),
				null));
	}
	static class NoPortNettyReactiveWebServerFactory extends NettyReactiveWebServerFactory {
		NoPortNettyReactiveWebServerFactory(int port) {
			super(port);
		}
		@Override
		NettyWebServer createNettyWebServer(HttpServer httpServer, ReactorHttpHandlerAdapter handlerAdapter,
				Duration lifecycleTimeout, Shutdown shutdown) {
			return new NoPortNettyWebServer(httpServer, handlerAdapter, lifecycleTimeout, shutdown);
		}
	}
	static class NoPortNettyWebServer extends NettyWebServer {
		NoPortNettyWebServer(HttpServer httpServer, ReactorHttpHandlerAdapter handlerAdapter, Duration lifecycleTimeout,
				Shutdown shutdown) {
			super(httpServer, handlerAdapter, lifecycleTimeout, shutdown, null);
		}
		@Override
		DisposableServer startHttpServer() {
			return new NoPortDisposableServer(super.startHttpServer());
		}
	}
	static class NoPortDisposableServer implements DisposableServer {
		private final DisposableServer delegate;
		NoPortDisposableServer(DisposableServer delegate) {
			this.delegate = delegate;
		}
		@Override
		public SocketAddress address() {
			return this.delegate.address();
		}
		@Override
		public String host() {
			return this.delegate.host();
		}
		@Override
		public String path() {
			return this.delegate.path();
		}
		@Override
		public Channel channel() {
			return this.delegate.channel();
		}
		@Override
		public void dispose() {
			this.delegate.dispose();
		}
		@Override
		public void disposeNow() {
			this.delegate.disposeNow();
		}
		@Override
		public void disposeNow(Duration timeout) {
			this.delegate.disposeNow(timeout);
		}
		@Override
		public CoreSubscriber<Void> disposeSubscriber() {
			return this.delegate.disposeSubscriber();
		}
		@Override
		public boolean isDisposed() {
			return this.delegate.isDisposed();
		}
		@Override
		public Mono<Void> onDispose() {
			return this.delegate.onDispose();
		}
		@Override
		public DisposableChannel onDispose(Disposable onDispose) {
			return this.delegate.onDispose(onDispose);
		}
	}
}
/*
package org.springframework.boot.web.server;
/**
@ExtendWith(MockitoExtension.class)
class WebServerFactoryCustomizerBeanPostProcessorTests {
	private final WebServerFactoryCustomizerBeanPostProcessor processor = new WebServerFactoryCustomizerBeanPostProcessor();
	@Mock
	private ListableBeanFactory beanFactory;
	@BeforeEach
	void setup() {
		this.processor.setBeanFactory(this.beanFactory);
	}
	@Test
	void setBeanFactoryWhenNotListableShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.processor.setBeanFactory(mock(BeanFactory.class)))
			.withMessageContaining('WebServerCustomizerBeanPostProcessor can only be used with a ListableBeanFactory');
	}
	@Test
	void postProcessBeforeShouldReturnBean() {
		Object bean = new Object();
		Object result = this.processor.postProcessBeforeInitialization(bean, 'foo');
		assertThat(result).isSameAs(bean);
	}
	@Test
	void postProcessAfterShouldReturnBean() {
		Object bean = new Object();
		Object result = this.processor.postProcessAfterInitialization(bean, 'foo');
		assertThat(result).isSameAs(bean);
	}
	@Test
	void postProcessAfterShouldCallInterfaceCustomizers() {
		Map<String, Object> beans = addInterfaceBeans();
		addMockBeans(beans);
		postProcessBeforeInitialization(WebServerFactory.class);
		assertThat(wasCalled(beans, 'one')).isFalse();
		assertThat(wasCalled(beans, 'two')).isFalse();
		assertThat(wasCalled(beans, 'all')).isTrue();
	}
	@Test
	void postProcessAfterWhenWebServerFactoryOneShouldCallInterfaceCustomizers() {
		Map<String, Object> beans = addInterfaceBeans();
		addMockBeans(beans);
		postProcessBeforeInitialization(WebServerFactoryOne.class);
		assertThat(wasCalled(beans, 'one')).isTrue();
		assertThat(wasCalled(beans, 'two')).isFalse();
		assertThat(wasCalled(beans, 'all')).isTrue();
	}
	@Test
	void postProcessAfterWhenWebServerFactoryTwoShouldCallInterfaceCustomizers() {
		Map<String, Object> beans = addInterfaceBeans();
		addMockBeans(beans);
		postProcessBeforeInitialization(WebServerFactoryTwo.class);
		assertThat(wasCalled(beans, 'one')).isFalse();
		assertThat(wasCalled(beans, 'two')).isTrue();
		assertThat(wasCalled(beans, 'all')).isTrue();
	}
	private Map<String, Object> addInterfaceBeans() {
		WebServerFactoryOneCustomizer oneCustomizer = new WebServerFactoryOneCustomizer();
		WebServerFactoryTwoCustomizer twoCustomizer = new WebServerFactoryTwoCustomizer();
		WebServerFactoryAllCustomizer allCustomizer = new WebServerFactoryAllCustomizer();
		Map<String, Object> beans = new LinkedHashMap<>();
		beans.put('one', oneCustomizer);
		beans.put('two', twoCustomizer);
		beans.put('all', allCustomizer);
		return beans;
	}
	@Test
	void postProcessAfterShouldCallLambdaCustomizers() {
		List<String> called = new ArrayList<>();
		addLambdaBeans(called);
		postProcessBeforeInitialization(WebServerFactory.class);
		assertThat(called).containsExactly('all');
	}
	@Test
	void postProcessAfterWhenWebServerFactoryOneShouldCallLambdaCustomizers() {
		List<String> called = new ArrayList<>();
		addLambdaBeans(called);
		postProcessBeforeInitialization(WebServerFactoryOne.class);
		assertThat(called).containsExactly('one', 'all');
	}
	@Test
	void postProcessAfterWhenWebServerFactoryTwoShouldCallLambdaCustomizers() {
		List<String> called = new ArrayList<>();
		addLambdaBeans(called);
		postProcessBeforeInitialization(WebServerFactoryTwo.class);
		assertThat(called).containsExactly('two', 'all');
	}
	private void addLambdaBeans(List<String> called) {
		WebServerFactoryCustomizer<WebServerFactoryOne> one = (f) -> called.add('one');
		WebServerFactoryCustomizer<WebServerFactoryTwo> two = (f) -> called.add('two');
		WebServerFactoryCustomizer<WebServerFactory> all = (f) -> called.add('all');
		Map<String, Object> beans = new LinkedHashMap<>();
		beans.put('one', one);
		beans.put('two', two);
		beans.put('all', all);
		addMockBeans(beans);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private void addMockBeans(Map<String, ?> beans) {
		given(this.beanFactory.getBeansOfType(WebServerFactoryCustomizer.class, false, false))
			.willReturn((Map<String, WebServerFactoryCustomizer>) beans);
	}
	private void postProcessBeforeInitialization(Class<?> type) {
		this.processor.postProcessBeforeInitialization(mock(type), 'foo');
	}
	private boolean wasCalled(Map<String, ?> beans, String name) {
		return ((MockWebServerFactoryCustomizer<?>) beans.get(name)).wasCalled();
	}
	interface WebServerFactoryOne extends WebServerFactory {
	}
	interface WebServerFactoryTwo extends WebServerFactory {
	}
	static class MockWebServerFactoryCustomizer<T extends WebServerFactory> implements WebServerFactoryCustomizer<T> {
		private boolean called;
		@Override
		public void customize(T factory) {
			this.called = true;
		}
		boolean wasCalled() {
			return this.called;
		}
	}
	static class WebServerFactoryOneCustomizer extends MockWebServerFactoryCustomizer<WebServerFactoryOne> {
	}
	static class WebServerFactoryTwoCustomizer extends MockWebServerFactoryCustomizer<WebServerFactoryTwo> {
	}
	static class WebServerFactoryAllCustomizer extends MockWebServerFactoryCustomizer<WebServerFactory> {
	}
}
/*
package org.springframework.boot.web.server;
/**
class MimeMappingsTests {
	@Test
	void defaultsCannotBeModified() {
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> MimeMappings.DEFAULT.add('foo', 'foo/bar'));
	}
	@Test
	void createFromExisting() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('foo', 'bar');
		MimeMappings clone = new MimeMappings(mappings);
		mappings.add('baz', 'bar');
		assertThat(clone.get('foo')).isEqualTo('bar');
		assertThat(clone.get('baz')).isNull();
	}
	@Test
	void createFromMap() {
		Map<String, String> mappings = new HashMap<>();
		mappings.put('foo', 'bar');
		MimeMappings clone = new MimeMappings(mappings);
		mappings.put('baz', 'bar');
		assertThat(clone.get('foo')).isEqualTo('bar');
		assertThat(clone.get('baz')).isNull();
	}
	@Test
	void iterate() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('foo', 'bar');
		mappings.add('baz', 'boo');
		List<MimeMappings.Mapping> mappingList = new ArrayList<>();
		for (MimeMappings.Mapping mapping : mappings) {
			mappingList.add(mapping);
		}
		assertThat(mappingList.get(0).getExtension()).isEqualTo('foo');
		assertThat(mappingList.get(0).getMimeType()).isEqualTo('bar');
		assertThat(mappingList.get(1).getExtension()).isEqualTo('baz');
		assertThat(mappingList.get(1).getMimeType()).isEqualTo('boo');
	}
	@Test
	void getAll() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('foo', 'bar');
		mappings.add('baz', 'boo');
		List<MimeMappings.Mapping> mappingList = new ArrayList<>(mappings.getAll());
		assertThat(mappingList.get(0).getExtension()).isEqualTo('foo');
		assertThat(mappingList.get(0).getMimeType()).isEqualTo('bar');
		assertThat(mappingList.get(1).getExtension()).isEqualTo('baz');
		assertThat(mappingList.get(1).getMimeType()).isEqualTo('boo');
	}
	@Test
	void addNew() {
		MimeMappings mappings = new MimeMappings();
		assertThat(mappings.add('foo', 'bar')).isNull();
	}
	@Test
	void addReplacesExisting() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('foo', 'bar');
		assertThat(mappings.add('foo', 'baz')).isEqualTo('bar');
	}
	@Test
	void remove() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('foo', 'bar');
		assertThat(mappings.remove('foo')).isEqualTo('bar');
		assertThat(mappings.remove('foo')).isNull();
	}
	@Test
	void get() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('foo', 'bar');
		assertThat(mappings.get('foo')).isEqualTo('bar');
	}
	@Test
	void getMissing() {
		MimeMappings mappings = new MimeMappings();
		assertThat(mappings.get('foo')).isNull();
	}
	@Test
	void makeUnmodifiable() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('foo', 'bar');
		MimeMappings unmodifiable = MimeMappings.unmodifiableMappings(mappings);
		try {
			unmodifiable.remove('foo');
		}
		catch (UnsupportedOperationException ex) {
			// Expected
		}
		mappings.remove('foo');
		assertThat(unmodifiable.get('foo')).isNull();
	}
	@Test
	void mimeTypesInDefaultMappingsAreCorrectlyStructured() {
		String regName = '[A-Za-z0-9!#$&.+\\-^_]{1,127}';
		Pattern pattern = Pattern.compile('^' + regName + '/' + regName + '$');
		assertThat(MimeMappings.DEFAULT).allSatisfy((mapping) -> assertThat(mapping.getMimeType()).matches(pattern));
	}
	@Test
	void getCommonTypeOnDefaultMimeMappingsDoesNotLoadMappings() {
		DefaultMimeMappings mappings = new DefaultMimeMappings();
		assertThat(mappings.get('json')).isEqualTo('application/json');
		assertThat((Object) mappings).extracting('loaded').isNull();
	}
	@Test
	void getExoticTypeOnDefaultMimeMappingsLoadsMappings() {
		DefaultMimeMappings mappings = new DefaultMimeMappings();
		assertThat(mappings.get('123')).isEqualTo('application/vnd.lotus-1-2-3');
		assertThat((Object) mappings).extracting('loaded').isNotNull();
	}
	@Test
	void iterateOnDefaultMimeMappingsLoadsMappings() {
		DefaultMimeMappings mappings = new DefaultMimeMappings();
		assertThat(mappings).isNotEmpty();
		assertThat((Object) mappings).extracting('loaded').isNotNull();
	}
	@Test
	void commonMappingsAreSubsetOfAllMappings() {
		MimeMappings defaultMappings = new DefaultMimeMappings();
		MimeMappings commonMappings = (MimeMappings) ReflectionTestUtils.getField(DefaultMimeMappings.class, 'COMMON');
		for (Mapping commonMapping : commonMappings) {
			assertThat(defaultMappings.get(commonMapping.getExtension())).isEqualTo(commonMapping.getMimeType());
		}
	}
	@Test
	void lazyCopyWhenNotMutatedDelegates() {
		DefaultMimeMappings mappings = new DefaultMimeMappings();
		MimeMappings lazyCopy = MimeMappings.lazyCopy(mappings);
		assertThat(lazyCopy.get('json')).isEqualTo('application/json');
		assertThat((Object) mappings).extracting('loaded').isNull();
	}
	@Test
	void lazyCopyWhenMutatedCreatesCopy() {
		DefaultMimeMappings mappings = new DefaultMimeMappings();
		MimeMappings lazyCopy = MimeMappings.lazyCopy(mappings);
		lazyCopy.add('json', 'other/json');
		assertThat(lazyCopy.get('json')).isEqualTo('other/json');
		assertThat((Object) mappings).extracting('loaded').isNotNull();
	}
	@Test
	void lazyCopyWhenMutatedCreatesCopyOnlyOnce() {
		MimeMappings mappings = new MimeMappings();
		mappings.add('json', 'one/json');
		MimeMappings lazyCopy = MimeMappings.lazyCopy(mappings);
		lazyCopy.add('first', 'copy/yes');
		assertThat(lazyCopy.get('json')).isEqualTo('one/json');
		mappings.add('json', 'two/json');
		lazyCopy.add('second', 'copy/no');
		assertThat(lazyCopy.get('json')).isEqualTo('one/json');
	}
	@Test
	void mimeMappingsMatchesTomcatDefaults() throws IOException {
		Properties ourDefaultMimeMappings = PropertiesLoaderUtils
			.loadProperties(new ClassPathResource('mime-mappings.properties', getClass()));
		Properties tomcatDefaultMimeMappings = PropertiesLoaderUtils
			.loadProperties(new ClassPathResource('MimeTypeMappings.properties', Tomcat.class));
		assertThat(ourDefaultMimeMappings).containsExactlyInAnyOrderEntriesOf(tomcatDefaultMimeMappings);
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new MimeMappingsRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource()
			.forResource('org/springframework/boot/web/server/mime-mappings.properties')).accepts(runtimeHints);
	}
}
/*
package org.springframework.boot.web.server;
/**
@MockPkcs11Security
class WebServerSslBundleTests {
	@Test
	void whenSslDisabledThrowsException() {
		Ssl ssl = new Ssl();
		ssl.setEnabled(false);
		assertThatIllegalStateException().isThrownBy(() -> WebServerSslBundle.get(ssl))
			.withMessage('SSL is not enabled');
	}
	@Test
	void whenFromJksProperties() {
		Ssl ssl = new Ssl();
		ssl.setKeyStore('classpath:test.p12');
		ssl.setKeyStorePassword('secret');
		ssl.setKeyStoreType('PKCS12');
		ssl.setTrustStore('classpath:test.p12');
		ssl.setTrustStorePassword('secret');
		ssl.setTrustStoreType('PKCS12');
		ssl.setKeyPassword('password');
		ssl.setKeyAlias('alias');
		ssl.setClientAuth(Ssl.ClientAuth.NONE);
		ssl.setCiphers(new String[] { 'ONE', 'TWO', 'THREE' });
		ssl.setEnabledProtocols(new String[] { 'TLSv1.1', 'TLSv1.2' });
		ssl.setProtocol('TestProtocol');
		SslBundle bundle = WebServerSslBundle.get(ssl);
		assertThat(bundle).isNotNull();
		assertThat(bundle.getProtocol()).isEqualTo('TestProtocol');
		SslBundleKey key = bundle.getKey();
		assertThat(key.getPassword()).isEqualTo('password');
		assertThat(key.getAlias()).isEqualTo('alias');
		SslStoreBundle stores = bundle.getStores();
		assertThat(stores.getKeyStorePassword()).isEqualTo('secret');
		assertThat(stores.getKeyStore()).isNotNull();
		assertThat(stores.getTrustStore()).isNotNull();
		SslOptions options = bundle.getOptions();
		assertThat(options.getCiphers()).containsExactly('ONE', 'TWO', 'THREE');
		assertThat(options.getEnabledProtocols()).containsExactly('TLSv1.1', 'TLSv1.2');
	}
	@Test
	void whenFromJksPropertiesWithPkcs11StoreType() {
		Ssl ssl = new Ssl();
		ssl.setKeyStoreType('PKCS11');
		ssl.setKeyStoreProvider(MockPkcs11SecurityProvider.NAME);
		ssl.setKeyStore('src/test/resources/test.jks');
		ssl.setKeyPassword('password');
		ssl.setClientAuth(Ssl.ClientAuth.NONE);
		assertThatIllegalStateException().isThrownBy(() -> WebServerSslBundle.get(ssl))
			.withMessageContaining('must be empty or null for PKCS11 hardware key stores');
	}
	@Test
	void whenFromPkcs11Properties() {
		Ssl ssl = new Ssl();
		ssl.setKeyStoreType('PKCS11');
		ssl.setKeyStoreProvider(MockPkcs11SecurityProvider.NAME);
		ssl.setTrustStoreType('PKCS11');
		ssl.setTrustStoreProvider(MockPkcs11SecurityProvider.NAME);
		ssl.setKeyPassword('password');
		ssl.setClientAuth(Ssl.ClientAuth.NONE);
		SslBundle bundle = WebServerSslBundle.get(ssl);
		assertThat(bundle).isNotNull();
		assertThat(bundle.getProtocol()).isEqualTo('TLS');
		SslBundleKey key = bundle.getKey();
		assertThat(key.getPassword()).isEqualTo('password');
		SslStoreBundle stores = bundle.getStores();
		assertThat(stores.getKeyStore()).isNotNull();
		assertThat(stores.getTrustStore()).isNotNull();
	}
	@Test
	void whenFromPemProperties() {
		Ssl ssl = new Ssl();
		ssl.setCertificate('classpath:test-cert.pem');
		ssl.setCertificatePrivateKey('classpath:test-key.pem');
		ssl.setTrustCertificate('classpath:test-cert-chain.pem');
		ssl.setKeyStoreType('PKCS12');
		ssl.setTrustStoreType('PKCS12');
		ssl.setKeyPassword('password');
		ssl.setClientAuth(Ssl.ClientAuth.NONE);
		ssl.setCiphers(new String[] { 'ONE', 'TWO', 'THREE' });
		ssl.setEnabledProtocols(new String[] { 'TLSv1.1', 'TLSv1.2' });
		ssl.setProtocol('TLSv1.1');
		SslBundle bundle = WebServerSslBundle.get(ssl);
		assertThat(bundle).isNotNull();
		SslBundleKey key = bundle.getKey();
		assertThat(key.getAlias()).isNull();
		assertThat(key.getPassword()).isEqualTo('password');
		SslStoreBundle stores = bundle.getStores();
		assertThat(stores.getKeyStorePassword()).isNull();
		assertThat(stores.getKeyStore()).isNotNull();
		assertThat(stores.getTrustStore()).isNotNull();
		SslOptions options = bundle.getOptions();
		assertThat(options.getCiphers()).containsExactly('ONE', 'TWO', 'THREE');
		assertThat(options.getEnabledProtocols()).containsExactly('TLSv1.1', 'TLSv1.2');
	}
	@Test
	void whenPemKeyStoreAndJksTrustStoreProperties() {
		Ssl ssl = new Ssl();
		ssl.setCertificate('classpath:test-cert.pem');
		ssl.setCertificatePrivateKey('classpath:test-key.pem');
		ssl.setKeyStoreType('PKCS12');
		ssl.setKeyPassword('password');
		ssl.setTrustStore('classpath:test.p12');
		ssl.setTrustStorePassword('secret');
		ssl.setTrustStoreType('PKCS12');
		ssl.setClientAuth(Ssl.ClientAuth.NONE);
		ssl.setCiphers(new String[] { 'ONE', 'TWO', 'THREE' });
		ssl.setEnabledProtocols(new String[] { 'TLSv1.1', 'TLSv1.2' });
		ssl.setProtocol('TLSv1.1');
		SslBundle bundle = WebServerSslBundle.get(ssl);
		assertThat(bundle).isNotNull();
		SslBundleKey key = bundle.getKey();
		assertThat(key.getAlias()).isNull();
		assertThat(key.getPassword()).isEqualTo('password');
		SslStoreBundle stores = bundle.getStores();
		assertThat(stores.getKeyStorePassword()).isNull();
		assertThat(stores.getKeyStore()).isNotNull();
		assertThat(stores.getTrustStore()).isNotNull();
		SslOptions options = bundle.getOptions();
		assertThat(options.getCiphers()).containsExactly('ONE', 'TWO', 'THREE');
		assertThat(options.getEnabledProtocols()).containsExactly('TLSv1.1', 'TLSv1.2');
	}
	@Test
	void whenJksKeyStoreAndPemTrustStoreProperties() {
		Ssl ssl = new Ssl();
		ssl.setKeyStore('classpath:test.p12');
		ssl.setKeyStoreType('PKCS12');
		ssl.setKeyPassword('password');
		ssl.setTrustCertificate('classpath:test-cert-chain.pem');
		ssl.setTrustStorePassword('secret');
		ssl.setTrustStoreType('PKCS12');
		ssl.setClientAuth(Ssl.ClientAuth.NONE);
		ssl.setCiphers(new String[] { 'ONE', 'TWO', 'THREE' });
		ssl.setEnabledProtocols(new String[] { 'TLSv1.1', 'TLSv1.2' });
		ssl.setProtocol('TLSv1.1');
		SslBundle bundle = WebServerSslBundle.get(ssl);
		assertThat(bundle).isNotNull();
		SslBundleKey key = bundle.getKey();
		assertThat(key.getAlias()).isNull();
		assertThat(key.getPassword()).isEqualTo('password');
		SslStoreBundle stores = bundle.getStores();
		assertThat(stores.getKeyStorePassword()).isNull();
		assertThat(stores.getKeyStore()).isNotNull();
		assertThat(stores.getTrustStore()).isNotNull();
		SslOptions options = bundle.getOptions();
		assertThat(options.getCiphers()).containsExactly('ONE', 'TWO', 'THREE');
		assertThat(options.getEnabledProtocols()).containsExactly('TLSv1.1', 'TLSv1.2');
	}
	@Test
	void whenMissingPropertiesThrowsException() {
		Ssl ssl = new Ssl();
		assertThatIllegalStateException().isThrownBy(() -> WebServerSslBundle.get(ssl))
			.withMessageContaining('SSL is enabled but no trust material is configured');
	}
}
/*
package org.springframework.boot.web.server;
/**
class CompressionTests {
	@Test
	void defaultCompressibleMimeTypesMatchesTomcatsDefault() {
		assertThat(new Compression().getMimeTypes()).containsExactlyInAnyOrder(getTomcatDefaultCompressibleMimeTypes());
	}
	private String[] getTomcatDefaultCompressibleMimeTypes() {
		Http11NioProtocol protocol = new Http11NioProtocol();
		return protocol.getCompressibleMimeTypes();
	}
}
/*
package org.springframework.boot.web.client;
/**
@SuppressWarnings('removal')
class ClientHttpRequestFactoriesTests {
	@Test
	void getReturnsRequestFactoryOfExpectedType() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories
			.get(ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	void getOfGeneralTypeReturnsRequestFactoryOfExpectedType() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(ClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	void getOfSimpleFactoryReturnsSimpleFactory() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(SimpleClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(SimpleClientHttpRequestFactory.class);
	}
	@Test
	void getOfHttpComponentsFactoryReturnsHttpComponentsFactory() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories
			.get(HttpComponentsClientHttpRequestFactory.class, ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	void getOfReactorFactoryReturnsReactorFactory() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(ReactorClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(ReactorClientHttpRequestFactory.class);
	}
	@Test
	void getOfOkHttpFactoryReturnsOkHttpFactory() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(
				org.springframework.http.client.OkHttp3ClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(org.springframework.http.client.OkHttp3ClientHttpRequestFactory.class);
	}
	@Test
	void getOfJdkFactoryReturnsJdkFactory() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(JdkClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(JdkClientHttpRequestFactory.class);
	}
	@Test
	void getOfUnknownTypeCreatesFactory() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(TestClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(TestClientHttpRequestFactory.class);
	}
	@Test
	void getOfUnknownTypeWithConnectTimeoutCreatesFactoryAndConfiguresConnectTimeout() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(TestClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS.withConnectTimeout(Duration.ofSeconds(60)));
		assertThat(requestFactory).isInstanceOf(TestClientHttpRequestFactory.class);
		assertThat(((TestClientHttpRequestFactory) requestFactory).connectTimeout)
			.isEqualTo(Duration.ofSeconds(60).toMillis());
	}
	@Test
	void getOfUnknownTypeWithReadTimeoutCreatesFactoryAndConfiguresReadTimeout() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(TestClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS.withReadTimeout(Duration.ofSeconds(90)));
		assertThat(requestFactory).isInstanceOf(TestClientHttpRequestFactory.class);
		assertThat(((TestClientHttpRequestFactory) requestFactory).readTimeout)
			.isEqualTo(Duration.ofSeconds(90).toMillis());
	}
	@Test
	void getOfUnconfigurableTypeWithConnectTimeoutThrows() {
		assertThatIllegalStateException()
			.isThrownBy(() -> ClientHttpRequestFactories.get(UnconfigurableClientHttpRequestFactory.class,
					ClientHttpRequestFactorySettings.DEFAULTS.withConnectTimeout(Duration.ofSeconds(60))))
			.withMessageContaining('suitable setConnectTimeout method');
	}
	@Test
	void getOfUnconfigurableTypeWithReadTimeoutThrows() {
		assertThatIllegalStateException()
			.isThrownBy(() -> ClientHttpRequestFactories.get(UnconfigurableClientHttpRequestFactory.class,
					ClientHttpRequestFactorySettings.DEFAULTS.withReadTimeout(Duration.ofSeconds(60))))
			.withMessageContaining('suitable setReadTimeout method');
	}
	@Test
	void getOfTypeWithDeprecatedConnectTimeoutThrowsWithConnectTimeout() {
		assertThatIllegalStateException()
			.isThrownBy(() -> ClientHttpRequestFactories.get(DeprecatedMethodsClientHttpRequestFactory.class,
					ClientHttpRequestFactorySettings.DEFAULTS.withConnectTimeout(Duration.ofSeconds(60))))
			.withMessageContaining('setConnectTimeout method marked as deprecated');
	}
	@Test
	void getOfTypeWithDeprecatedReadTimeoutThrowsWithReadTimeout() {
		assertThatIllegalStateException()
			.isThrownBy(() -> ClientHttpRequestFactories.get(DeprecatedMethodsClientHttpRequestFactory.class,
					ClientHttpRequestFactorySettings.DEFAULTS.withReadTimeout(Duration.ofSeconds(60))))
			.withMessageContaining('setReadTimeout method marked as deprecated');
	}
	@Test
	void connectTimeoutCanBeConfiguredOnAWrappedRequestFactory() {
		SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
		BufferingClientHttpRequestFactory result = ClientHttpRequestFactories.get(
				() -> new BufferingClientHttpRequestFactory(requestFactory),
				ClientHttpRequestFactorySettings.DEFAULTS.withConnectTimeout(Duration.ofMillis(1234)));
		assertThat(result).extracting('requestFactory').isSameAs(requestFactory);
		assertThat(requestFactory).hasFieldOrPropertyWithValue('connectTimeout', 1234);
	}
	@Test
	void readTimeoutCanBeConfiguredOnAWrappedRequestFactory() {
		SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
		BufferingClientHttpRequestFactory result = ClientHttpRequestFactories.get(
				() -> new BufferingClientHttpRequestFactory(requestFactory),
				ClientHttpRequestFactorySettings.DEFAULTS.withReadTimeout(Duration.ofMillis(1234)));
		assertThat(result).extracting('requestFactory').isSameAs(requestFactory);
		assertThat(requestFactory).hasFieldOrPropertyWithValue('readTimeout', 1234);
	}
	@Test
	void reflectiveShouldFavorDurationTimeoutMethods() {
		IntAndDurationTimeoutsClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(
				IntAndDurationTimeoutsClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS.withConnectTimeout(Duration.ofSeconds(1))
					.withReadTimeout(Duration.ofSeconds(2)));
		assertThat((requestFactory).connectTimeout).isZero();
		assertThat((requestFactory).readTimeout).isZero();
		assertThat((requestFactory).connectTimeoutDuration).isEqualTo(Duration.ofSeconds(1));
		assertThat((requestFactory).readTimeoutDuration).isEqualTo(Duration.ofSeconds(2));
	}
	public static class TestClientHttpRequestFactory implements ClientHttpRequestFactory {
		private int connectTimeout;
		private int readTimeout;
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
		public void setConnectTimeout(int timeout) {
			this.connectTimeout = timeout;
		}
		public void setReadTimeout(int timeout) {
			this.readTimeout = timeout;
		}
	}
	public static class UnconfigurableClientHttpRequestFactory implements ClientHttpRequestFactory {
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
	}
	public static class DeprecatedMethodsClientHttpRequestFactory implements ClientHttpRequestFactory {
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
		@Deprecated(since = '3.0.0', forRemoval = false)
		public void setConnectTimeout(int timeout) {
		}
		@Deprecated(since = '3.0.0', forRemoval = false)
		public void setReadTimeout(int timeout) {
		}
		@Deprecated(since = '3.0.0', forRemoval = false)
		public void setBufferRequestBody(boolean bufferRequestBody) {
		}
	}
	public static class IntAndDurationTimeoutsClientHttpRequestFactory implements ClientHttpRequestFactory {
		private int readTimeout;
		private int connectTimeout;
		private Duration readTimeoutDuration;
		private Duration connectTimeoutDuration;
		@Override
		public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) {
			throw new UnsupportedOperationException();
		}
		public void setConnectTimeout(int timeout) {
			this.connectTimeout = timeout;
		}
		public void setReadTimeout(int timeout) {
			this.readTimeout = timeout;
		}
		public void setConnectTimeout(Duration timeout) {
			this.connectTimeoutDuration = timeout;
		}
		public void setReadTimeout(Duration timeout) {
			this.readTimeoutDuration = timeout;
		}
	}
}
/*
package org.springframework.boot.web.client;
/**
@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar' })
@SuppressWarnings('removal')
class ClientHttpRequestFactoriesReactorTests
		extends AbstractClientHttpRequestFactoriesTests<ReactorClientHttpRequestFactory> {
	ClientHttpRequestFactoriesReactorTests() {
		super(ReactorClientHttpRequestFactory.class);
	}
	@Override
	protected long connectTimeout(ReactorClientHttpRequestFactory requestFactory) {
		return (int) ((HttpClient) ReflectionTestUtils.getField(requestFactory, 'httpClient')).configuration()
			.options()
			.get(ChannelOption.CONNECT_TIMEOUT_MILLIS);
	}
	@Override
	protected long readTimeout(ReactorClientHttpRequestFactory requestFactory) {
		return ((Duration) ReflectionTestUtils.getField(requestFactory, 'readTimeout')).toMillis();
	}
	@Override
	protected boolean supportsSettingConnectTimeout() {
		return true;
	}
	@Override
	protected boolean supportsSettingReadTimeout() {
		return true;
	}
}
/*
package org.springframework.boot.web.client;
/**
@DirtiesUrlFactories
@SuppressWarnings('removal')
abstract class AbstractClientHttpRequestFactoriesTests<T extends ClientHttpRequestFactory> {
	private final Class<T> requestFactoryType;
	protected AbstractClientHttpRequestFactoriesTests(Class<T> requestFactoryType) {
		this.requestFactoryType = requestFactoryType;
	}
	@Test
	void getReturnsRequestFactoryOfExpectedType() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories
			.get(ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(this.requestFactoryType);
	}
	@Test
	void getOfGeneralTypeReturnsRequestFactoryOfExpectedType() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(ClientHttpRequestFactory.class,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(this.requestFactoryType);
	}
	@Test
	void getOfSpecificTypeReturnsRequestFactoryOfExpectedType() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories.get(this.requestFactoryType,
				ClientHttpRequestFactorySettings.DEFAULTS);
		assertThat(requestFactory).isInstanceOf(this.requestFactoryType);
	}
	@Test
	@SuppressWarnings('unchecked')
	void getReturnsRequestFactoryWithConfiguredConnectTimeout() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories
			.get(ClientHttpRequestFactorySettings.DEFAULTS.withConnectTimeout(Duration.ofSeconds(60)));
		assertThat(connectTimeout((T) requestFactory)).isEqualTo(Duration.ofSeconds(60).toMillis());
	}
	@Test
	@SuppressWarnings('unchecked')
	void getReturnsRequestFactoryWithConfiguredReadTimeout() {
		ClientHttpRequestFactory requestFactory = ClientHttpRequestFactories
			.get(ClientHttpRequestFactorySettings.DEFAULTS.withReadTimeout(Duration.ofSeconds(120)));
		assertThat(readTimeout((T) requestFactory)).isEqualTo(Duration.ofSeconds(120).toMillis());
	}
	@Test
	void shouldSetConnectTimeoutsWhenUsingReflective() {
		Assumptions.assumeTrue(supportsSettingConnectTimeout());
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.DEFAULTS
			.withConnectTimeout(Duration.ofSeconds(1));
		T requestFactory = ClientHttpRequestFactories
			.get(() -> ClientHttpRequestFactories.get(this.requestFactoryType, settings), settings);
		assertThat(connectTimeout(requestFactory)).isEqualTo(1000);
	}
	@Test
	void shouldSetReadTimeoutsWhenUsingReflective() {
		Assumptions.assumeTrue(supportsSettingReadTimeout());
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.DEFAULTS
			.withReadTimeout(Duration.ofSeconds(2));
		T requestFactory = ClientHttpRequestFactories
			.get(() -> ClientHttpRequestFactories.get(this.requestFactoryType, settings), settings);
		assertThat(readTimeout(requestFactory)).isEqualTo(2000);
	}
	@ParameterizedTest
	@ValueSource(strings = { 'GET', 'POST' })
	void connectWithSslBundle(String httpMethod) throws Exception {
		TomcatServletWebServerFactory webServerFactory = new TomcatServletWebServerFactory(0);
		Ssl ssl = new Ssl();
		ssl.setClientAuth(ClientAuth.NEED);
		ssl.setKeyPassword('password');
		ssl.setKeyStore('classpath:test.jks');
		ssl.setTrustStore('classpath:test.jks');
		webServerFactory.setSsl(ssl);
		WebServer webServer = webServerFactory
			.getWebServer((context) -> context.addServlet('test', TestServlet.class).addMapping('/'));
		try {
			webServer.start();
			int port = webServer.getPort();
			URI uri = new URI('https://localhost:%s'.formatted(port));
			ClientHttpRequestFactory insecureRequestFactory = ClientHttpRequestFactories
				.get(ClientHttpRequestFactorySettings.DEFAULTS);
			ClientHttpRequest insecureRequest = insecureRequestFactory.createRequest(uri, HttpMethod.GET);
			assertThatExceptionOfType(SSLHandshakeException.class)
				.isThrownBy(() -> insecureRequest.execute().getBody());
			JksSslStoreDetails storeDetails = JksSslStoreDetails.forLocation('classpath:test.jks');
			JksSslStoreBundle stores = new JksSslStoreBundle(storeDetails, storeDetails);
			SslBundle sslBundle = SslBundle.of(stores, SslBundleKey.of('password'));
			ClientHttpRequestFactory secureRequestFactory = ClientHttpRequestFactories
				.get(ClientHttpRequestFactorySettings.DEFAULTS.withSslBundle(sslBundle));
			ClientHttpRequest secureRequest = secureRequestFactory.createRequest(uri, HttpMethod.valueOf(httpMethod));
			String secureResponse = StreamUtils.copyToString(secureRequest.execute().getBody(), StandardCharsets.UTF_8);
			assertThat(secureResponse).contains('Received ' + httpMethod + ' request to /');
		}
		finally {
			webServer.stop();
		}
	}
	protected abstract boolean supportsSettingConnectTimeout();
	protected abstract long connectTimeout(T requestFactory);
	protected abstract boolean supportsSettingReadTimeout();
	protected abstract long readTimeout(T requestFactory);
	public static class TestServlet extends HttpServlet {
		@Override
		public void service(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
			res.getWriter().println('Received ' + req.getMethod() + ' request to ' + req.getRequestURI());
		}
	}
}
/*
package org.springframework.boot.web.client;
/**
@ClassPathExclusions({ 'httpclient5-*.jar', 'jetty-client-*.jar', 'reactor-netty-http-*.jar' })
@SuppressWarnings('removal')
class ClientHttpRequestFactoriesSimpleTests
		extends AbstractClientHttpRequestFactoriesTests<SimpleClientHttpRequestFactory> {
	ClientHttpRequestFactoriesSimpleTests() {
		super(SimpleClientHttpRequestFactory.class);
	}
	@Override
	protected long connectTimeout(SimpleClientHttpRequestFactory requestFactory) {
		return (int) ReflectionTestUtils.getField(requestFactory, 'connectTimeout');
	}
	@Override
	protected long readTimeout(SimpleClientHttpRequestFactory requestFactory) {
		return (int) ReflectionTestUtils.getField(requestFactory, 'readTimeout');
	}
	@Override
	protected boolean supportsSettingConnectTimeout() {
		return true;
	}
	@Override
	protected boolean supportsSettingReadTimeout() {
		return true;
	}
}
/*
package org.springframework.boot.web.client;
/**
@ExtendWith(MockitoExtension.class)
class RootUriTemplateHandlerTests {
	private URI uri;
	@Mock
	public UriTemplateHandler delegate;
	public UriTemplateHandler handler;
	@BeforeEach
	void setup() throws URISyntaxException {
		this.uri = new URI('https://example.com/hello');
		this.handler = new RootUriTemplateHandler('https://example.com', this.delegate);
	}
	@Test
	void createWithNullRootUriShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new RootUriTemplateHandler((String) null, mock(UriTemplateHandler.class)))
			.withMessageContaining('RootUri must not be null');
	}
	@Test
	void createWithNullHandlerShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new RootUriTemplateHandler('https://example.com', null))
			.withMessageContaining('Handler must not be null');
	}
	@Test
	@SuppressWarnings('unchecked')
	void expandMapVariablesShouldPrefixRoot() {
		given(this.delegate.expand(anyString(), any(Map.class))).willReturn(this.uri);
		HashMap<String, Object> uriVariables = new HashMap<>();
		URI expanded = this.handler.expand('/hello', uriVariables);
		then(this.delegate).should().expand('https://example.com/hello', uriVariables);
		assertThat(expanded).isEqualTo(this.uri);
	}
	@Test
	@SuppressWarnings('unchecked')
	void expandMapVariablesWhenPathDoesNotStartWithSlashShouldNotPrefixRoot() {
		given(this.delegate.expand(anyString(), any(Map.class))).willReturn(this.uri);
		HashMap<String, Object> uriVariables = new HashMap<>();
		URI expanded = this.handler.expand('https://spring.io/hello', uriVariables);
		then(this.delegate).should().expand('https://spring.io/hello', uriVariables);
		assertThat(expanded).isEqualTo(this.uri);
	}
	@Test
	void expandArrayVariablesShouldPrefixRoot() {
		given(this.delegate.expand(anyString(), any(Object[].class))).willReturn(this.uri);
		Object[] uriVariables = new Object[0];
		URI expanded = this.handler.expand('/hello', uriVariables);
		then(this.delegate).should().expand('https://example.com/hello', uriVariables);
		assertThat(expanded).isEqualTo(this.uri);
	}
	@Test
	void expandArrayVariablesWhenPathDoesNotStartWithSlashShouldNotPrefixRoot() {
		given(this.delegate.expand(anyString(), any(Object[].class))).willReturn(this.uri);
		Object[] uriVariables = new Object[0];
		URI expanded = this.handler.expand('https://spring.io/hello', uriVariables);
		then(this.delegate).should().expand('https://spring.io/hello', uriVariables);
		assertThat(expanded).isEqualTo(this.uri);
	}
}
/*
package org.springframework.boot.web.client;
/**
abstract class AbstractRestTemplateBuilderRequestFactoryConfigurationTests<T extends ClientHttpRequestFactory> {
	private final Class<? extends ClientHttpRequestFactory> factoryType;
	private final RestTemplateBuilder builder = new RestTemplateBuilder();
	protected AbstractRestTemplateBuilderRequestFactoryConfigurationTests(Class<T> factoryType) {
		this.factoryType = factoryType;
	}
	@Test
	@SuppressWarnings('unchecked')
	void connectTimeoutCanBeConfiguredOnFactory() {
		ClientHttpRequestFactory requestFactory = this.builder.requestFactory(this.factoryType)
			.connectTimeout(Duration.ofMillis(1234))
			.build()
			.getRequestFactory();
		assertThat(connectTimeout((T) requestFactory)).isEqualTo(1234);
	}
	@Test
	@SuppressWarnings('unchecked')
	void readTimeoutCanBeConfiguredOnFactory() {
		ClientHttpRequestFactory requestFactory = this.builder.requestFactory(this.factoryType)
			.readTimeout(Duration.ofMillis(1234))
			.build()
			.getRequestFactory();
		assertThat(readTimeout((T) requestFactory)).isEqualTo(1234);
	}
	@Test
	@SuppressWarnings('unchecked')
	void connectTimeoutCanBeConfiguredOnDetectedFactory() {
		ClientHttpRequestFactory requestFactory = this.builder.connectTimeout(Duration.ofMillis(1234))
			.build()
			.getRequestFactory();
		assertThat(connectTimeout((T) requestFactory)).isEqualTo(1234);
	}
	@Test
	@SuppressWarnings('unchecked')
	void readTimeoutCanBeConfiguredOnDetectedFactory() {
		ClientHttpRequestFactory requestFactory = this.builder.readTimeout(Duration.ofMillis(1234))
			.build()
			.getRequestFactory();
		assertThat(readTimeout((T) requestFactory)).isEqualTo(1234);
	}
	protected abstract long connectTimeout(T requestFactory);
	protected abstract long readTimeout(T requestFactory);
}
/*
package org.springframework.boot.web.client;
/**
@SuppressWarnings('removal')
class ClientHttpRequestFactoriesHttpComponentsTests
		extends AbstractClientHttpRequestFactoriesTests<HttpComponentsClientHttpRequestFactory> {
	ClientHttpRequestFactoriesHttpComponentsTests() {
		super(HttpComponentsClientHttpRequestFactory.class);
	}
	@Override
	protected long connectTimeout(HttpComponentsClientHttpRequestFactory requestFactory) {
		return (long) ReflectionTestUtils.getField(requestFactory, 'connectTimeout');
	}
	@Override
	@SuppressWarnings('unchecked')
	protected long readTimeout(HttpComponentsClientHttpRequestFactory requestFactory) {
		HttpClient httpClient = requestFactory.getHttpClient();
		Object connectionManager = ReflectionTestUtils.getField(httpClient, 'connManager');
		SocketConfig socketConfig = ((Resolver<HttpRoute, SocketConfig>) ReflectionTestUtils.getField(connectionManager,
				'socketConfigResolver'))
			.resolve(null);
		return socketConfig.getSoTimeout().toMilliseconds();
	}
	@Override
	protected boolean supportsSettingConnectTimeout() {
		return true;
	}
	@Override
	protected boolean supportsSettingReadTimeout() {
		return false;
	}
}
/*
package org.springframework.boot.web.client;
/**
@ExtendWith(MockitoExtension.class)
class RestTemplateBuilderTests {
	private final RestTemplateBuilder builder = new RestTemplateBuilder();
	@Mock
	private HttpMessageConverter<Object> messageConverter;
	@Mock
	private ClientHttpRequestInterceptor interceptor;
	@Test
	void createWhenCustomizersAreNullShouldThrowException() {
		RestTemplateCustomizer[] customizers = null;
		assertThatIllegalArgumentException().isThrownBy(() -> new RestTemplateBuilder(customizers))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void createWithCustomizersShouldApplyCustomizers() {
		RestTemplateCustomizer customizer = mock(RestTemplateCustomizer.class);
		RestTemplate template = new RestTemplateBuilder(customizer).build();
		then(customizer).should().customize(template);
	}
	@Test
	void buildShouldDetectRequestFactory() {
		RestTemplate restTemplate = this.builder.build();
		assertThat(restTemplate.getRequestFactory()).isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	void detectRequestFactoryWhenFalseShouldDisableDetection() {
		RestTemplate restTemplate = this.builder.detectRequestFactory(false).build();
		assertThat(restTemplate.getRequestFactory()).isInstanceOf(SimpleClientHttpRequestFactory.class);
	}
	@Test
	void rootUriShouldApply() {
		RestTemplate restTemplate = this.builder.rootUri('https://example.com').build();
		MockRestServiceServer server = MockRestServiceServer.bindTo(restTemplate).build();
		server.expect(requestTo('https://example.com/hello')).andRespond(withSuccess());
		restTemplate.getForEntity('/hello', String.class);
		server.verify();
	}
	@Test
	void rootUriShouldApplyAfterUriTemplateHandler() {
		UriTemplateHandler uriTemplateHandler = mock(UriTemplateHandler.class);
		RestTemplate template = this.builder.uriTemplateHandler(uriTemplateHandler)
			.rootUri('https://example.com')
			.build();
		UriTemplateHandler handler = template.getUriTemplateHandler();
		handler.expand('/hello');
		assertThat(handler).isInstanceOf(RootUriBuilderFactory.class);
		then(uriTemplateHandler).should().expand('https://example.com/hello');
	}
	@Test
	void messageConvertersWhenConvertersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.messageConverters((HttpMessageConverter<?>[]) null))
			.withMessageContaining('MessageConverters must not be null');
	}
	@Test
	void messageConvertersCollectionWhenConvertersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.messageConverters((Set<HttpMessageConverter<?>>) null))
			.withMessageContaining('MessageConverters must not be null');
	}
	@Test
	void messageConvertersShouldApply() {
		RestTemplate template = this.builder.messageConverters(this.messageConverter).build();
		assertThat(template.getMessageConverters()).containsOnly(this.messageConverter);
	}
	@Test
	void messageConvertersShouldReplaceExisting() {
		RestTemplate template = this.builder.messageConverters(new ResourceHttpMessageConverter())
			.messageConverters(Collections.singleton(this.messageConverter))
			.build();
		assertThat(template.getMessageConverters()).containsOnly(this.messageConverter);
	}
	@Test
	void additionalMessageConvertersWhenConvertersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalMessageConverters((HttpMessageConverter<?>[]) null))
			.withMessageContaining('MessageConverters must not be null');
	}
	@Test
	void additionalMessageConvertersCollectionWhenConvertersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalMessageConverters((Set<HttpMessageConverter<?>>) null))
			.withMessageContaining('MessageConverters must not be null');
	}
	@Test
	void additionalMessageConvertersShouldAddToExisting() {
		HttpMessageConverter<?> resourceConverter = new ResourceHttpMessageConverter();
		RestTemplate template = this.builder.messageConverters(resourceConverter)
			.additionalMessageConverters(this.messageConverter)
			.build();
		assertThat(template.getMessageConverters()).containsOnly(resourceConverter, this.messageConverter);
	}
	@Test
	void defaultMessageConvertersShouldSetDefaultList() {
		RestTemplate template = new RestTemplate(Collections.singletonList(new StringHttpMessageConverter()));
		this.builder.defaultMessageConverters().configure(template);
		assertThat(template.getMessageConverters()).hasSameSizeAs(new RestTemplate().getMessageConverters());
	}
	@Test
	void defaultMessageConvertersShouldClearExisting() {
		RestTemplate template = new RestTemplate(Collections.singletonList(new StringHttpMessageConverter()));
		this.builder.additionalMessageConverters(this.messageConverter).defaultMessageConverters().configure(template);
		assertThat(template.getMessageConverters()).hasSameSizeAs(new RestTemplate().getMessageConverters());
	}
	@Test
	void interceptorsWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.interceptors((ClientHttpRequestInterceptor[]) null))
			.withMessageContaining('interceptors must not be null');
	}
	@Test
	void interceptorsCollectionWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.interceptors((Set<ClientHttpRequestInterceptor>) null))
			.withMessageContaining('interceptors must not be null');
	}
	@Test
	void interceptorsShouldApply() {
		RestTemplate template = this.builder.interceptors(this.interceptor).build();
		assertThat(template.getInterceptors()).containsOnly(this.interceptor);
	}
	@Test
	void interceptorsShouldReplaceExisting() {
		RestTemplate template = this.builder.interceptors(mock(ClientHttpRequestInterceptor.class))
			.interceptors(Collections.singleton(this.interceptor))
			.build();
		assertThat(template.getInterceptors()).containsOnly(this.interceptor);
	}
	@Test
	void additionalInterceptorsWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalInterceptors((ClientHttpRequestInterceptor[]) null))
			.withMessageContaining('interceptors must not be null');
	}
	@Test
	void additionalInterceptorsCollectionWhenInterceptorsAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalInterceptors((Set<ClientHttpRequestInterceptor>) null))
			.withMessageContaining('interceptors must not be null');
	}
	@Test
	void additionalInterceptorsShouldAddToExisting() {
		ClientHttpRequestInterceptor interceptor = mock(ClientHttpRequestInterceptor.class);
		RestTemplate template = this.builder.interceptors(interceptor).additionalInterceptors(this.interceptor).build();
		assertThat(template.getInterceptors()).containsOnly(interceptor, this.interceptor);
	}
	@Test
	void requestFactoryClassWhenFactoryIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.requestFactory((Class<ClientHttpRequestFactory>) null))
			.withMessageContaining('RequestFactoryType must not be null');
	}
	@Test
	void requestFactoryClassShouldApply() {
		RestTemplate template = this.builder.requestFactory(SimpleClientHttpRequestFactory.class).build();
		assertThat(template.getRequestFactory()).isInstanceOf(SimpleClientHttpRequestFactory.class);
	}
	@Test
	void requestFactoryPackagePrivateClassShouldApply() {
		RestTemplate template = this.builder.requestFactory(TestClientHttpRequestFactory.class).build();
		assertThat(template.getRequestFactory()).isInstanceOf(TestClientHttpRequestFactory.class);
	}
	@Test
	void requestFactoryWhenSupplierIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.requestFactory((Supplier<ClientHttpRequestFactory>) null))
			.withMessageContaining('RequestFactorySupplier must not be null');
	}
	@Test
	@SuppressWarnings('removal')
	void requestFactoryWhenFunctionIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.builder.requestFactory(
				(Function<org.springframework.boot.web.client.ClientHttpRequestFactorySettings, ClientHttpRequestFactory>) null))
			.withMessageContaining('RequestFactoryFunction must not be null');
	}
	@Test
	void requestFactoryShouldApply() {
		ClientHttpRequestFactory requestFactory = mock(ClientHttpRequestFactory.class);
		RestTemplate template = this.builder.requestFactory(() -> requestFactory).build();
		assertThat(template.getRequestFactory()).isSameAs(requestFactory);
	}
	@Test
	void uriTemplateHandlerWhenHandlerIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.builder.uriTemplateHandler(null))
			.withMessageContaining('UriTemplateHandler must not be null');
	}
	@Test
	void uriTemplateHandlerShouldApply() {
		UriTemplateHandler uriTemplateHandler = mock(UriTemplateHandler.class);
		RestTemplate template = this.builder.uriTemplateHandler(uriTemplateHandler).build();
		assertThat(template.getUriTemplateHandler()).isSameAs(uriTemplateHandler);
	}
	@Test
	void errorHandlerWhenHandlerIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.builder.errorHandler(null))
			.withMessageContaining('ErrorHandler must not be null');
	}
	@Test
	void errorHandlerShouldApply() {
		ResponseErrorHandler errorHandler = mock(ResponseErrorHandler.class);
		RestTemplate template = this.builder.errorHandler(errorHandler).build();
		assertThat(template.getErrorHandler()).isSameAs(errorHandler);
	}
	@Test
	void basicAuthenticationShouldApply() {
		RestTemplate template = this.builder.basicAuthentication('spring', 'boot', StandardCharsets.UTF_8).build();
		ClientHttpRequest request = createRequest(template);
		assertThat(request.getHeaders()).containsOnlyKeys(HttpHeaders.AUTHORIZATION);
		assertThat(request.getHeaders().get(HttpHeaders.AUTHORIZATION)).containsExactly('Basic c3ByaW5nOmJvb3Q=');
	}
	@Test
	void defaultHeaderAddsHeader() {
		RestTemplate template = this.builder.defaultHeader('spring', 'boot').build();
		ClientHttpRequest request = createRequest(template);
		assertThat(request.getHeaders()).contains(entry('spring', Collections.singletonList('boot')));
	}
	@Test
	void defaultHeaderAddsHeaderValues() {
		String name = HttpHeaders.ACCEPT;
		String[] values = { MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE };
		RestTemplate template = this.builder.defaultHeader(name, values).build();
		ClientHttpRequest request = createRequest(template);
		assertThat(request.getHeaders()).contains(entry(name, Arrays.asList(values)));
	}
	@Test // gh-17885
	void defaultHeaderWhenUsingMockRestServiceServerAddsHeader() {
		RestTemplate template = this.builder.defaultHeader('spring', 'boot').build();
		MockRestServiceServer.bindTo(template).build();
		ClientHttpRequest request = createRequest(template);
		assertThat(request.getHeaders()).contains(entry('spring', Collections.singletonList('boot')));
	}
	@Test
	void requestFactorySettingsAppliesSettings() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.defaults()
			.withConnectTimeout(Duration.ofSeconds(1));
		RestTemplate template = this.builder.requestFactorySettings(settings).build();
		assertThat(template.getRequestFactory()).extracting('connectTimeout').isEqualTo(1000L);
	}
	@Test
	void requestCustomizersAddsCustomizers() {
		RestTemplate template = this.builder
			.requestCustomizers((request) -> request.getHeaders().add('spring', 'framework'))
			.build();
		ClientHttpRequest request = createRequest(template);
		assertThat(request.getHeaders()).contains(entry('spring', Collections.singletonList('framework')));
	}
	@Test
	void additionalRequestCustomizersAddsCustomizers() {
		RestTemplate template = this.builder
			.requestCustomizers((request) -> request.getHeaders().add('spring', 'framework'))
			.additionalRequestCustomizers((request) -> request.getHeaders().add('for', 'java'))
			.build();
		ClientHttpRequest request = createRequest(template);
		assertThat(request.getHeaders()).contains(entry('spring', Collections.singletonList('framework')))
			.contains(entry('for', Collections.singletonList('java')));
	}
	@Test
	void customizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.builder.customizers((RestTemplateCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.customizers((Set<RestTemplateCustomizer>) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void customizersShouldApply() {
		RestTemplateCustomizer customizer = mock(RestTemplateCustomizer.class);
		RestTemplate template = this.builder.customizers(customizer).build();
		then(customizer).should().customize(template);
	}
	@Test
	void customizersShouldBeAppliedLast() {
		RestTemplate template = spy(new RestTemplate());
		this.builder.additionalCustomizers(
				(restTemplate) -> then(restTemplate).should().setRequestFactory(any(ClientHttpRequestFactory.class)));
		this.builder.configure(template);
	}
	@Test
	void customizersShouldReplaceExisting() {
		RestTemplateCustomizer customizer1 = mock(RestTemplateCustomizer.class);
		RestTemplateCustomizer customizer2 = mock(RestTemplateCustomizer.class);
		RestTemplate template = this.builder.customizers(customizer1)
			.customizers(Collections.singleton(customizer2))
			.build();
		then(customizer1).shouldHaveNoInteractions();
		then(customizer2).should().customize(template);
	}
	@Test
	void additionalCustomizersWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((RestTemplateCustomizer[]) null))
			.withMessageContaining('Customizers must not be null');
	}
	@Test
	void additionalCustomizersCollectionWhenCustomizersAreNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.builder.additionalCustomizers((Set<RestTemplateCustomizer>) null))
			.withMessageContaining('RestTemplateCustomizers must not be null');
	}
	@Test
	void additionalCustomizersShouldAddToExisting() {
		RestTemplateCustomizer customizer1 = mock(RestTemplateCustomizer.class);
		RestTemplateCustomizer customizer2 = mock(RestTemplateCustomizer.class);
		RestTemplate template = this.builder.customizers(customizer1).additionalCustomizers(customizer2).build();
		InOrder ordered = inOrder(customizer1, customizer2);
		ordered.verify(customizer1).customize(template);
		ordered.verify(customizer2).customize(template);
	}
	@Test
	void customizerShouldBeAppliedAtTheEnd() {
		ResponseErrorHandler errorHandler = mock(ResponseErrorHandler.class);
		ClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();
		this.builder.interceptors(this.interceptor)
			.messageConverters(this.messageConverter)
			.rootUri('http://localhost:8080')
			.errorHandler(errorHandler)
			.basicAuthentication('spring', 'boot')
			.requestFactory(() -> requestFactory)
			.customizers((restTemplate) -> {
				assertThat(restTemplate.getInterceptors()).hasSize(1);
				assertThat(restTemplate.getMessageConverters()).contains(this.messageConverter);
				assertThat(restTemplate.getUriTemplateHandler()).isInstanceOf(RootUriBuilderFactory.class);
				assertThat(restTemplate.getErrorHandler()).isEqualTo(errorHandler);
				ClientHttpRequestFactory actualRequestFactory = restTemplate.getRequestFactory();
				assertThat(actualRequestFactory).isInstanceOf(InterceptingClientHttpRequestFactory.class);
				ClientHttpRequestInitializer initializer = restTemplate.getClientHttpRequestInitializers().get(0);
				assertThat(initializer).isInstanceOf(RestTemplateBuilderClientHttpRequestInitializer.class);
			})
			.build();
	}
	@Test
	void buildShouldReturnRestTemplate() {
		RestTemplate template = this.builder.build();
		assertThat(template.getClass()).isEqualTo(RestTemplate.class);
	}
	@Test
	void buildClassShouldReturnClassInstance() {
		RestTemplateSubclass template = this.builder.build(RestTemplateSubclass.class);
		assertThat(template.getClass()).isEqualTo(RestTemplateSubclass.class);
	}
	@Test
	void configureShouldApply() {
		RestTemplate template = new RestTemplate();
		this.builder.configure(template);
		assertThat(template.getRequestFactory()).isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
	}
	@Test
	void unwrappingDoesNotAffectRequestFactoryThatIsSetOnTheBuiltTemplate() {
		SimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();
		RestTemplate template = this.builder.requestFactory(() -> new BufferingClientHttpRequestFactory(requestFactory))
			.build();
		assertThat(template.getRequestFactory()).isInstanceOf(BufferingClientHttpRequestFactory.class);
	}
	private ClientHttpRequest createRequest(RestTemplate template) {
		return ReflectionTestUtils.invokeMethod(template, 'createRequest', URI.create('http://localhost'),
				HttpMethod.GET);
	}
	static class RestTemplateSubclass extends RestTemplate {
	}
	static class TestClientHttpRequestFactory extends SimpleClientHttpRequestFactory {
	}
	static class TestHttpComponentsClientHttpRequestFactory extends HttpComponentsClientHttpRequestFactory {
	}
}
/*
package org.springframework.boot.web.client;
/**
@ClassPathExclusions('httpclient5-*.jar')
@SuppressWarnings('removal')
class ClientHttpRequestFactoriesJettyTests
		extends AbstractClientHttpRequestFactoriesTests<JettyClientHttpRequestFactory> {
	ClientHttpRequestFactoriesJettyTests() {
		super(JettyClientHttpRequestFactory.class);
	}
	@Override
	protected long connectTimeout(JettyClientHttpRequestFactory requestFactory) {
		return ((HttpClient) ReflectionTestUtils.getField(requestFactory, 'httpClient')).getConnectTimeout();
	}
	@Override
	protected long readTimeout(JettyClientHttpRequestFactory requestFactory) {
		return (long) ReflectionTestUtils.getField(requestFactory, 'readTimeout');
	}
	@Override
	protected boolean supportsSettingConnectTimeout() {
		return true;
	}
	@Override
	protected boolean supportsSettingReadTimeout() {
		return true;
	}
}
/*
package org.springframework.boot.web.client;
/**
@SuppressWarnings('removal')
class ClientHttpRequestFactorySettingsTests {
	private static final Duration ONE_SECOND = Duration.ofSeconds(1);
	@Test
	void defaultsHasNullValues() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.DEFAULTS;
		assertThat(settings.connectTimeout()).isNull();
		assertThat(settings.readTimeout()).isNull();
		assertThat(settings.sslBundle()).isNull();
	}
	@Test
	void withConnectTimeoutReturnsInstanceWithUpdatedConnectionTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.DEFAULTS
			.withConnectTimeout(ONE_SECOND);
		assertThat(settings.connectTimeout()).isEqualTo(ONE_SECOND);
		assertThat(settings.readTimeout()).isNull();
		assertThat(settings.sslBundle()).isNull();
	}
	@Test
	void withReadTimeoutReturnsInstanceWithUpdatedReadTimeout() {
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.DEFAULTS
			.withReadTimeout(ONE_SECOND);
		assertThat(settings.connectTimeout()).isNull();
		assertThat(settings.readTimeout()).isEqualTo(ONE_SECOND);
		assertThat(settings.sslBundle()).isNull();
	}
	@Test
	void withSslBundleReturnsInstanceWithUpdatedSslBundle() {
		SslBundle sslBundle = mock(SslBundle.class);
		ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.DEFAULTS.withSslBundle(sslBundle);
		assertThat(settings.connectTimeout()).isNull();
		assertThat(settings.readTimeout()).isNull();
		assertThat(settings.sslBundle()).isSameAs(sslBundle);
	}
}
/*
package org.springframework.boot.web.client;
/**
class RootUriBuilderFactoryTests {
	@Test
	void uriStringPrefixesRoot() throws URISyntaxException {
		UriBuilderFactory builderFactory = new RootUriBuilderFactory('https://example.com',
				mock(UriTemplateHandler.class));
		UriBuilder builder = builderFactory.uriString('/hello');
		assertThat(builder.build()).isEqualTo(new URI('https://example.com/hello'));
	}
}
/*
package org.springframework.boot.web.client;
/**
class RestTemplateBuilderClientHttpRequestInitializerTests {
	private final MockClientHttpRequest request = new MockClientHttpRequest();
	@Test
	void createRequestWhenHasBasicAuthAndNoAuthHeaderAddsHeader() {
		new RestTemplateBuilderClientHttpRequestInitializer(new BasicAuthentication('spring', 'boot', null),
				Collections.emptyMap(), Collections.emptySet())
			.initialize(this.request);
		assertThat(this.request.getHeaders().get(HttpHeaders.AUTHORIZATION)).containsExactly('Basic c3ByaW5nOmJvb3Q=');
	}
	@Test
	void createRequestWhenHasBasicAuthAndExistingAuthHeaderDoesNotAddHeader() {
		this.request.getHeaders().setBasicAuth('boot', 'spring');
		new RestTemplateBuilderClientHttpRequestInitializer(new BasicAuthentication('spring', 'boot', null),
				Collections.emptyMap(), Collections.emptySet())
			.initialize(this.request);
		assertThat(this.request.getHeaders().get(HttpHeaders.AUTHORIZATION)).doesNotContain('Basic c3ByaW5nOmJvb3Q=');
	}
	@Test
	void createRequestWhenHasDefaultHeadersAddsMissing() {
		this.request.getHeaders().add('one', 'existing');
		Map<String, List<String>> defaultHeaders = new LinkedHashMap<>();
		defaultHeaders.put('one', Collections.singletonList('1'));
		defaultHeaders.put('two', Arrays.asList('2', '3'));
		defaultHeaders.put('three', Collections.singletonList('4'));
		new RestTemplateBuilderClientHttpRequestInitializer(null, defaultHeaders, Collections.emptySet())
			.initialize(this.request);
		assertThat(this.request.getHeaders().get('one')).containsExactly('existing');
		assertThat(this.request.getHeaders().get('two')).containsExactly('2', '3');
		assertThat(this.request.getHeaders().get('three')).containsExactly('4');
	}
	@Test
	@SuppressWarnings('unchecked')
	void createRequestWhenHasRequestCustomizersAppliesThemInOrder() {
		Set<RestTemplateRequestCustomizer<?>> customizers = new LinkedHashSet<>();
		customizers.add(mock(RestTemplateRequestCustomizer.class));
		customizers.add(mock(RestTemplateRequestCustomizer.class));
		customizers.add(mock(RestTemplateRequestCustomizer.class));
		new RestTemplateBuilderClientHttpRequestInitializer(null, Collections.emptyMap(), customizers)
			.initialize(this.request);
		InOrder inOrder = inOrder(customizers.toArray());
		for (RestTemplateRequestCustomizer<?> customizer : customizers) {
			inOrder.verify((RestTemplateRequestCustomizer<ClientHttpRequest>) customizer).customize(this.request);
		}
	}
}
/*
package org.springframework.boot.web.servlet;
/**
class WebListenerHandlerTests {
	private final WebListenerHandler handler = new WebListenerHandler();
	private final SimpleBeanDefinitionRegistry registry = new SimpleBeanDefinitionRegistry();
	@Test
	void listener() throws IOException {
		AnnotatedBeanDefinition definition = mock(AnnotatedBeanDefinition.class);
		given(definition.getBeanClassName()).willReturn(TestListener.class.getName());
		given(definition.getMetadata())
			.willReturn(new SimpleMetadataReaderFactory().getMetadataReader(TestListener.class.getName())
				.getAnnotationMetadata());
		this.handler.handle(definition, this.registry);
		this.registry.getBeanDefinition(TestListener.class.getName() + 'Registrar');
	}
	@WebListener
	static class TestListener implements ServletContextAttributeListener {
		@Override
		public void attributeAdded(ServletContextAttributeEvent event) {
		}
		@Override
		public void attributeRemoved(ServletContextAttributeEvent event) {
		}
		@Override
		public void attributeReplaced(ServletContextAttributeEvent event) {
		}
	}
}
/*
package org.springframework.boot.web.servlet.context.config;
/**
@Configuration(proxyBeanMethods = false)
public class ExampleServletWebServerApplicationConfiguration {
	@Bean
	public MockServletWebServerFactory webServerFactory() {
		return new MockServletWebServerFactory();
	}
	@Bean
	public Servlet servlet() {
		return new MockServlet();
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
@DirtiesUrlFactories
class ServletWebServerMvcIntegrationTests {
	private AnnotationConfigServletWebServerApplicationContext context;
	@AfterEach
	void closeContext() {
		try {
			this.context.close();
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	@Test
	void tomcat() throws Exception {
		this.context = new AnnotationConfigServletWebServerApplicationContext(TomcatConfig.class);
		doTest(this.context, '/hello');
	}
	@Test
	void jetty() throws Exception {
		this.context = new AnnotationConfigServletWebServerApplicationContext(JettyConfig.class);
		doTest(this.context, '/hello');
	}
	@Test
	void undertow() throws Exception {
		this.context = new AnnotationConfigServletWebServerApplicationContext(UndertowConfig.class);
		doTest(this.context, '/hello');
	}
	@Test
	void advancedConfig() throws Exception {
		this.context = new AnnotationConfigServletWebServerApplicationContext(AdvancedConfig.class);
		doTest(this.context, '/example/spring/hello');
	}
	private void doTest(AnnotationConfigServletWebServerApplicationContext context, String resourcePath)
			throws Exception {
		SimpleClientHttpRequestFactory clientHttpRequestFactory = new SimpleClientHttpRequestFactory();
		ClientHttpRequest request = clientHttpRequestFactory.createRequest(
				new URI('http://localhost:' + context.getWebServer().getPort() + resourcePath), HttpMethod.GET);
		try (ClientHttpResponse response = request.execute()) {
			assertThat(response.getBody()).hasContent('Hello World');
		}
	}
	// Simple main method for testing in a browser
	@SuppressWarnings('resource')
	static void main(String[] args) {
		new AnnotationConfigServletWebServerApplicationContext(JettyServletWebServerFactory.class, Config.class);
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Config.class)
	static class TomcatConfig {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Config.class)
	static class JettyConfig {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new JettyServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Config.class)
	static class UndertowConfig {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new UndertowServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class Config {
		@Bean
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
			// Alternatively you can use ServletContextInitializer beans including
			// ServletRegistration and FilterRegistration. Read the
			// EmbeddedWebApplicationContext Javadoc for details.
		}
		@Bean
		HelloWorldController helloWorldController() {
			return new HelloWorldController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	@PropertySource('classpath:/org/springframework/boot/web/servlet/context/conf.properties')
	static class AdvancedConfig {
		private final Environment env;
		AdvancedConfig(Environment env) {
			this.env = env;
		}
		@Bean
		ServletWebServerFactory webServerFactory() {
			JettyServletWebServerFactory factory = new JettyServletWebServerFactory(0);
			factory.setContextPath(this.env.getProperty('context'));
			return factory;
		}
		@Bean
		ServletRegistrationBean<DispatcherServlet> dispatcherRegistration(DispatcherServlet dispatcherServlet) {
			ServletRegistrationBean<DispatcherServlet> registration = new ServletRegistrationBean<>(dispatcherServlet);
			registration.addUrlMappings('/spring/*');
			return registration;
		}
		@Bean
		DispatcherServlet dispatcherServlet() {
			// Can configure dispatcher servlet here as would usually do through
			// init-params
			return new DispatcherServlet();
		}
		@Bean
		HelloWorldController helloWorldController() {
			return new HelloWorldController();
		}
	}
	@Controller
	static class HelloWorldController {
		@RequestMapping('/hello')
		@ResponseBody
		String sayHello() {
			return 'Hello World';
		}
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
class XmlServletWebServerApplicationContextTests {
	private static final String PATH = XmlServletWebServerApplicationContextTests.class.getPackage()
		.getName()
		.replace(".", "/") + '/';
	private static final String FILE = 'exampleEmbeddedWebApplicationConfiguration.xml';
	private XmlServletWebServerApplicationContext context;
	@Test
	void createFromResource() {
		this.context = new XmlServletWebServerApplicationContext(new ClassPathResource(FILE, getClass()));
		verifyContext();
	}
	@Test
	void createFromResourceLocation() {
		this.context = new XmlServletWebServerApplicationContext(PATH + FILE);
		verifyContext();
	}
	@Test
	void createFromRelativeResourceLocation() {
		this.context = new XmlServletWebServerApplicationContext(getClass(), FILE);
		verifyContext();
	}
	@Test
	void loadAndRefreshFromResource() {
		this.context = new XmlServletWebServerApplicationContext();
		this.context.load(new ClassPathResource(FILE, getClass()));
		this.context.refresh();
		verifyContext();
	}
	@Test
	void loadAndRefreshFromResourceLocation() {
		this.context = new XmlServletWebServerApplicationContext();
		this.context.load(PATH + FILE);
		this.context.refresh();
		verifyContext();
	}
	@Test
	void loadAndRefreshFromRelativeResourceLocation() {
		this.context = new XmlServletWebServerApplicationContext();
		this.context.load(getClass(), FILE);
		this.context.refresh();
		verifyContext();
	}
	private void verifyContext() {
		MockServletWebServerFactory factory = this.context.getBean(MockServletWebServerFactory.class);
		Servlet servlet = this.context.getBean(Servlet.class);
		then(factory.getServletContext()).should().addServlet('servlet', servlet);
	}
}
/*
package org.springframework.boot.web.servlet.context;
/**
@ExtendWith({ OutputCaptureExtension.class, MockitoExtension.class })
class ServletWebServerApplicationContextTests {
	private final ServletWebServerApplicationContext context = new ServletWebServerApplicationContext();
	@Captor
	private ArgumentCaptor<Filter> filterCaptor;
	@AfterEach
	void cleanup() {
		this.context.close();
	}
	@Test
	void startRegistrations() {
		addWebServerFactoryBean();
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		// Ensure that the context has been set up
		assertThat(this.context.getServletContext()).isEqualTo(factory.getServletContext());
		then(factory.getServletContext()).should()
			.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
		// Ensure WebApplicationContextUtils.registerWebApplicationScopes was called
		assertThat(this.context.getBeanFactory().getRegisteredScope(WebApplicationContext.SCOPE_SESSION))
			.isInstanceOf(SessionScope.class);
		// Ensure WebApplicationContextUtils.registerEnvironmentBeans was called
		assertThat(this.context.containsBean(WebApplicationContext.SERVLET_CONTEXT_BEAN_NAME)).isTrue();
	}
	@Test
	void doesNotRegistersShutdownHook() {
		// See gh-314 for background. We no longer register the shutdown hook
		// since it is really the caller"s responsibility. The shutdown hook could
		// also be problematic in a classic WAR deployment.
		addWebServerFactoryBean();
		this.context.refresh();
		assertThat(this.context).hasFieldOrPropertyWithValue('shutdownHook', null);
	}
	@Test
	void ServletWebServerInitializedEventPublished() {
		addWebServerFactoryBean();
		this.context.registerBeanDefinition('listener', new RootBeanDefinition(TestApplicationListener.class));
		this.context.refresh();
		List<ApplicationEvent> events = this.context.getBean(TestApplicationListener.class).receivedEvents();
		assertThat(events).hasSize(2)
			.extracting('class')
			.containsExactly(ServletWebServerInitializedEvent.class, ContextRefreshedEvent.class);
		ServletWebServerInitializedEvent initializedEvent = (ServletWebServerInitializedEvent) events.get(0);
		assertThat(initializedEvent.getSource().getPort()).isGreaterThanOrEqualTo(0);
		assertThat(initializedEvent.getApplicationContext()).isEqualTo(this.context);
	}
	@Test
	void localPortIsAvailable() {
		addWebServerFactoryBean();
		new ServerPortInfoApplicationContextInitializer().initialize(this.context);
		this.context.refresh();
		ConfigurableEnvironment environment = this.context.getEnvironment();
		assertThat(environment.containsProperty('local.server.port')).isTrue();
		assertThat(environment.getProperty('local.server.port')).isEqualTo('8080');
	}
	@Test
	void stopOnStop() {
		addWebServerFactoryBean();
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory();
		then(factory.getWebServer()).should().start();
		this.context.stop();
		then(factory.getWebServer()).should().stop();
	}
	@Test
	void startOnStartAfterStop() {
		addWebServerFactoryBean();
		this.context.refresh();
		MockServletWebServerFactory factory = getWebServerFactory(