Dir(), 'build/resources/main/META-INF/build-info.properties');
		assertThat(file).isFile();
		Properties properties = buildInfoProperties(file);
		assertThat(properties).containsEntry('build.artifact', 'example-app');
		assertThat(properties).containsEntry('build.version', '1.2.3');
		assertThat(properties).containsEntry('build.group', 'com.example');
		assertThat(properties).containsEntry('build.name', 'Example application');
		assertThat(properties).containsKey('build.time');
	}
	@TestTemplate
	void buildInfoAdditional() {
		this.gradleBuild.script(Examples.DIR + 'integrating-with-actuator/build-info-additional')
			.build('bootBuildInfo');
		File file = new File(this.gradleBuild.getProjectDir(), 'build/resources/main/META-INF/build-info.properties');
		assertThat(file).isFile();
		Properties properties = buildInfoProperties(file);
		assertThat(properties).containsEntry('build.a', 'alpha');
		assertThat(properties).containsEntry('build.b', 'bravo');
	}
	@TestTemplate
	void buildInfoExcludeTime() {
		this.gradleBuild.script(Examples.DIR + 'integrating-with-actuator/build-info-exclude-time')
			.build('bootBuildInfo');
		File file = new File(this.gradleBuild.getProjectDir(), 'build/resources/main/META-INF/build-info.properties');
		assertThat(file).isFile();
		Properties properties = buildInfoProperties(file);
		assertThat(properties).doesNotContainKey('build.time');
	}
	private Properties buildInfoProperties(File file) {
		assertThat(file).isFile();
		Properties properties = new Properties();
		try (FileReader reader = new FileReader(file)) {
			properties.load(reader);
			return properties;
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.gradle.docs;
/**
@ExtendWith(GradleMultiDslExtension.class)
class RunningDocumentationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void bootRunMain() throws IOException {
		writeMainClass();
		assertThat(this.gradleBuild.script(Examples.DIR + 'running/boot-run-main').build('bootRun').getOutput())
			.contains('com.example.ExampleApplication');
	}
	@TestTemplate
	void applicationPluginMainClassName() throws IOException {
		writeMainClass();
		assertThat(this.gradleBuild.script(Examples.DIR + 'running/application-plugin-main-class-name')
			.build('bootRun')
			.getOutput()).contains('com.example.ExampleApplication');
	}
	@TestTemplate
	void springBootDslMainClassName() throws IOException {
		writeMainClass();
		assertThat(this.gradleBuild.script(Examples.DIR + 'running/spring-boot-dsl-main-class-name')
			.build('bootRun')
			.getOutput()).contains('com.example.ExampleApplication');
	}
	@TestTemplate
	void bootRunSourceResources() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'running/boot-run-source-resources')
			.build('configuredClasspath')
			.getOutput()).contains(new File('src/main/resources').getPath());
	}
	@TestTemplate
	void bootRunDisableOptimizedLaunch() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'running/boot-run-disable-optimized-launch')
			.build('optimizedLaunch')
			.getOutput()).contains('false');
	}
	@TestTemplate
	void bootRunSystemPropertyDefaultValue() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'running/boot-run-system-property')
			.build('configuredSystemProperties')
			.getOutput()).contains('com.example.property = default');
	}
	@TestTemplate
	void bootRunSystemProperty() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'running/boot-run-system-property')
			.build('-Pexample=custom', 'configuredSystemProperties')
			.getOutput()).contains('com.example.property = custom');
	}
	private void writeMainClass() throws IOException {
		File exampleApplication = new File(this.gradleBuild.getProjectDir(),
				'src/main/java/com/example/ExampleApplication.java');
		exampleApplication.getParentFile().mkdirs();
		try (PrintWriter writer = new PrintWriter(new FileWriter(exampleApplication))) {
			writer.println('package com.example;');
			writer.println('public class ExampleApplication {');
			writer.println('    public static void main(String[] args) {');
			writer.println('        System.out.println(ExampleApplication.class.getName());');
			writer.println('    }');
			writer.println('}');
		}
	}
}
/*
package org.springframework.boot.gradle.docs;
/**
@ExtendWith(GradleMultiDslExtension.class)
class PackagingDocumentationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void warContainerDependencyEvaluatesSuccessfully() {
		this.gradleBuild.script(Examples.DIR + 'packaging/war-container-dependency').build();
	}
	@TestTemplate
	void bootJarMainClass() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-main-class').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			assertThat(jar.getManifest().getMainAttributes().getValue('Start-Class'))
				.isEqualTo('com.example.ExampleApplication');
		}
	}
	@TestTemplate
	void bootJarManifestMainClass() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-manifest-main-class').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			assertThat(jar.getManifest().getMainAttributes().getValue('Start-Class'))
				.isEqualTo('com.example.ExampleApplication');
		}
	}
	@TestTemplate
	void applicationPluginMainClass() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/application-plugin-main-class').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			assertThat(jar.getManifest().getMainAttributes().getValue('Start-Class'))
				.isEqualTo('com.example.ExampleApplication');
		}
	}
	@TestTemplate
	void springBootDslMainClass() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/spring-boot-dsl-main-class').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			assertThat(jar.getManifest().getMainAttributes().getValue('Start-Class'))
				.isEqualTo('com.example.ExampleApplication');
		}
	}
	@TestTemplate
	void bootWarIncludeDevtools() throws IOException {
		jarFile(new File(this.gradleBuild.getProjectDir(), 'spring-boot-devtools-1.2.3.RELEASE.jar'));
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-war-include-devtools').build('bootWar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.war');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			assertThat(jar.getEntry('WEB-INF/lib/spring-boot-devtools-1.2.3.RELEASE.jar')).isNotNull();
		}
	}
	@TestTemplate
	void bootJarRequiresUnpack() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-requires-unpack').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			JarEntry entry = jar.getJarEntry('BOOT-INF/lib/jruby-complete-1.7.25.jar');
			assertThat(entry).isNotNull();
			assertThat(entry.getComment()).startsWith('UNPACK:');
		}
	}
	@TestTemplate
	void bootJarIncludeLaunchScript() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-include-launch-script').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		assertThat(FileCopyUtils.copyToString(new FileReader(file))).startsWith('#!/bin/bash');
	}
	@TestTemplate
	void bootJarLaunchScriptProperties() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-launch-script-properties').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		assertThat(FileCopyUtils.copyToString(new FileReader(file))).contains('example-app.log');
	}
	@TestTemplate
	void bootJarCustomLaunchScript() throws IOException {
		File customScriptFile = new File(this.gradleBuild.getProjectDir(), 'src/custom.script');
		customScriptFile.getParentFile().mkdirs();
		FileCopyUtils.copy('custom', new FileWriter(customScriptFile));
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-custom-launch-script').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		assertThat(FileCopyUtils.copyToString(new FileReader(file))).startsWith('custom');
	}
	@TestTemplate
	void bootWarPropertiesLauncher() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-war-properties-launcher').build('bootWar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.war');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			assertThat(jar.getManifest().getMainAttributes().getValue('Main-Class'))
				.isEqualTo('org.springframework.boot.loader.launch.PropertiesLauncher');
		}
	}
	@TestTemplate
	void onlyBootJar() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/only-boot-jar').build('assemble');
		File plainJar = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '-plain.jar');
		assertThat(plainJar).doesNotExist();
		File bootJar = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(bootJar).isFile();
		try (JarFile jar = new JarFile(bootJar)) {
			assertThat(jar.getEntry('BOOT-INF/')).isNotNull();
		}
	}
	@TestTemplate
	void classifiedBootJar() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-and-jar-classifiers').build('assemble');
		File plainJar = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(plainJar).isFile();
		try (JarFile jar = new JarFile(plainJar)) {
			assertThat(jar.getEntry('BOOT-INF/')).isNull();
		}
		File bootJar = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '-boot.jar');
		assertThat(bootJar).isFile();
		try (JarFile jar = new JarFile(bootJar)) {
			assertThat(jar.getEntry('BOOT-INF/')).isNotNull();
		}
	}
	@TestTemplate
	void bootJarLayeredDisabled() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-layered-disabled').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			JarEntry entry = jar.getJarEntry('BOOT-INF/layers.idx');
			assertThat(entry).isNull();
		}
	}
	@TestTemplate
	void bootJarLayeredCustom() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-layered-custom').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			JarEntry entry = jar.getJarEntry('BOOT-INF/layers.idx');
			assertThat(entry).isNotNull();
			assertThat(Collections.list(jar.entries())
				.stream()
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith('BOOT-INF/lib/spring-boot'))).isNotEmpty();
		}
	}
	@TestTemplate
	void bootJarLayeredExcludeTools() throws IOException {
		this.gradleBuild.script(Examples.DIR + 'packaging/boot-jar-layered-exclude-tools').build('bootJar');
		File file = new File(this.gradleBuild.getProjectDir(),
				'build/libs/' + this.gradleBuild.getProjectDir().getName() + '.jar');
		assertThat(file).isFile();
		try (JarFile jar = new JarFile(file)) {
			JarEntry entry = jar.getJarEntry('BOOT-INF/layers.idx');
			assertThat(entry).isNotNull();
			assertThat(Collections.list(jar.entries())
				.stream()
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith('BOOT-INF/lib/spring-boot'))).isEmpty();
		}
	}
	@TestTemplate
	void bootBuildImageWithBuilder() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-builder')
			.build('bootBuildImageBuilder');
		assertThat(result.getOutput()).contains('builder=mine/java-cnb-builder').contains('runImage=mine/java-cnb-run');
	}
	@TestTemplate
	void bootBuildImageWithCustomBuildpackJvmVersion() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-env')
			.build('bootBuildImageEnvironment');
		assertThat(result.getOutput()).contains('BP_JVM_VERSION=17');
	}
	@TestTemplate
	void bootBuildImageWithCustomProxySettings() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-env-proxy')
			.build('bootBuildImageEnvironment');
		assertThat(result.getOutput()).contains('HTTP_PROXY=http://proxy.example.com')
			.contains('HTTPS_PROXY=https://proxy.example.com');
	}
	@TestTemplate
	void bootBuildImageWithCustomRuntimeConfiguration() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-env-runtime')
			.build('bootBuildImageEnvironment');
		assertThat(result.getOutput()).contains('BPE_DELIM_JAVA_TOOL_OPTIONS= ')
			.contains('BPE_APPEND_JAVA_TOOL_OPTIONS=-XX:+HeapDumpOnOutOfMemoryError');
	}
	@TestTemplate
	void bootBuildImageWithCustomImageName() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-name')
			.build('bootBuildImageName');
		assertThat(result.getOutput()).contains('example.com/library/' + this.gradleBuild.getProjectDir().getName());
	}
	@TestTemplate
	void bootBuildImageWithDockerHostMinikube() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-docker-host')
			.build('bootBuildImageDocker');
		assertThat(result.getOutput()).contains('host=tcp://192.168.99.100:2376')
			.contains('tlsVerify=true')
			.contains('certPath=/home/user/.minikube/certs');
	}
	@TestTemplate
	void bootBuildImageWithDockerHostPodman() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-docker-host-podman')
			.build('bootBuildImageDocker');
		assertThat(result.getOutput()).contains('host=unix:///run/user/1000/podman/podman.sock')
			.contains('bindHostToBuilder=true');
	}
	@TestTemplate
	void bootBuildImageWithDockerHostColima() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-docker-host-colima')
			.build('bootBuildImageDocker');
		assertThat(result.getOutput())
			.contains('host=unix://' + System.getProperty('user.home') + '/.colima/docker.sock');
	}
	@TestTemplate
	void bootBuildImageWithDockerUserAuth() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-docker-auth-user')
			.build('bootBuildImageDocker');
		assertThat(result.getOutput()).contains('username=user')
			.contains('password=secret')
			.contains('url=https://docker.example.com/v1/')
			.contains('email=user@example.com');
	}
	@TestTemplate
	void bootBuildImageWithDockerTokenAuth() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-docker-auth-token')
			.build('bootBuildImageDocker');
		assertThat(result.getOutput()).contains('token=9cbaf023786cd7...');
	}
	@TestTemplate
	void bootBuildImagePublish() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-publish')
			.build('bootBuildImagePublish');
		assertThat(result.getOutput()).contains('true');
	}
	@TestTemplate
	void bootBuildImageWithBuildpacks() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-buildpacks')
			.build('bootBuildImageBuildpacks');
		assertThat(result.getOutput()).contains('file:///path/to/example-buildpack.tgz')
			.contains('urn:cnb:builder:paketo-buildpacks/java');
	}
	@TestTemplate
	void bootBuildImageWithCaches() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-caches')
			.build('bootBuildImageCaches');
		assertThat(result.getOutput()).containsPattern('buildCache=cache-gradle-[\\d]+.build')
			.containsPattern('launchCache=cache-gradle-[\\d]+.launch');
	}
	@TestTemplate
	void bootBuildImageWithBindCaches() {
		BuildResult result = this.gradleBuild.script(Examples.DIR + 'packaging/boot-build-image-bind-caches')
			.build('bootBuildImageCaches');
		assertThat(result.getOutput()).containsPattern('buildWorkspace=/tmp/cache-gradle-[\\d]+.work')
			.containsPattern('buildCache=/tmp/cache-gradle-[\\d]+.build')
			.containsPattern('launchCache=/tmp/cache-gradle-[\\d]+.launch');
	}
	protected void jarFile(File file) throws IOException {
		try (JarOutputStream jar = new JarOutputStream(new FileOutputStream(file))) {
			jar.putNextEntry(new ZipEntry('META-INF/MANIFEST.MF'));
			new Manifest().write(jar);
			jar.closeEntry();
		}
	}
}
/*
package org.springframework.boot.gradle.docs;
/**
@ExtendWith(GradleMultiDslExtension.class)
class GettingStartedDocumentationTests {
	GradleBuild gradleBuild;
	// NOTE: We can"t run any "apply-plugin" tests because during a release the
	// jar won"t be there
	@TestTemplate
	void typicalPluginsAppliesExceptedPlugins() {
		this.gradleBuild.script(Examples.DIR + 'getting-started/typical-plugins').build('verify');
	}
}
/*
package org.springframework.boot.gradle.docs;
/**
@ExtendWith(GradleMultiDslExtension.class)
class PublishingDocumentationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void mavenPublish() {
		assertThat(this.gradleBuild.script(Examples.DIR + 'publishing/maven-publish')
			.build('publishingConfiguration')
			.getOutput()).contains('MavenPublication').contains('https://repo.example.com');
	}
}
/*
package org.springframework.boot.gradle.tasks.run;
/**
@GradleCompatibility(configurationCache = true)
class BootRunIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void basicExecution() throws IOException {
		copyClasspathApplication();
		new File(this.gradleBuild.getProjectDir(), 'src/main/resources').mkdirs();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('1. ' + canonicalPathOf('build/classes/java/main'));
		assertThat(result.getOutput()).contains('2. ' + canonicalPathOf('build/resources/main'));
		assertThat(result.getOutput()).doesNotContain(canonicalPathOf('src/main/resources'));
	}
	@TestTemplate
	void sourceResourcesCanBeUsed() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('1. ' + canonicalPathOf('src/main/resources'));
		assertThat(result.getOutput()).contains('2. ' + canonicalPathOf('build/classes/java/main'));
		assertThat(result.getOutput()).doesNotContain(canonicalPathOf('build/resources/main'));
	}
	@TestTemplate
	void springBootExtensionMainClassNameIsUsed() throws IOException {
		copyMainClassApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('com.example.bootrun.main.CustomMainClass');
	}
	@TestTemplate
	void applicationPluginMainClassNameIsUsed() throws IOException {
		copyMainClassApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('com.example.bootrun.main.CustomMainClass');
	}
	@TestTemplate
	void applicationPluginMainClassNameIsNotUsedWhenItIsNull() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput())
			.contains('Main class name = com.example.bootrun.classpath.BootRunClasspathApplication');
	}
	@TestTemplate
	void defaultJvmArgs() throws IOException {
		copyJvmArgsApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('-XX:TieredStopAtLevel=1');
	}
	@TestTemplate
	void optimizedLaunchDisabledJvmArgs() throws IOException {
		copyJvmArgsApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).doesNotContain('-Xverify:none').doesNotContain('-XX:TieredStopAtLevel=1');
	}
	@TestTemplate
	void applicationPluginJvmArgumentsAreUsed() throws IOException {
		if (this.gradleBuild.isConfigurationCache()) {
			// https://github.com/gradle/gradle/pull/23924
			GradleVersion gradleVersion = GradleVersion.version(this.gradleBuild.getGradleVersion());
			Assumptions.assumeThat(gradleVersion)
				.isLessThan(GradleVersion.version('8.0'))
				.isGreaterThanOrEqualTo(GradleVersion.version('8.1-rc-1'));
		}
		copyJvmArgsApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('-Dcom.bar=baz')
			.contains('-Dcom.foo=bar')
			.contains('-XX:TieredStopAtLevel=1');
	}
	@TestTemplate
	void jarTypeFilteringIsAppliedToTheClasspath() throws IOException {
		copyClasspathApplication();
		File flatDirRepository = new File(this.gradleBuild.getProjectDir(), 'repository');
		createDependenciesStarterJar(new File(flatDirRepository, 'starter.jar'));
		createStandardJar(new File(flatDirRepository, 'standard.jar'));
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('standard.jar').doesNotContain('starter.jar');
	}
	@TestTemplate
	void classesFromASecondarySourceSetCanBeOnTheClasspath() throws IOException {
		File output = new File(this.gradleBuild.getProjectDir(), 'src/secondary/java/com/example/bootrun/main');
		output.mkdirs();
		FileSystemUtils.copyRecursively(new File('src/test/java/com/example/bootrun/main'), output);
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('com.example.bootrun.main.CustomMainClass');
	}
	@TestTemplate
	void developmentOnlyDependenciesAreOnTheClasspath() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void testAndDevelopmentOnlyDependenciesAreOnTheClasspath() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('bootRun');
		assertThat(result.task(':bootRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('commons-lang3-3.12.0.jar');
	}
	private void copyMainClassApplication() throws IOException {
		copyApplication('main');
	}
	private void copyClasspathApplication() throws IOException {
		copyApplication('classpath');
	}
	private void copyJvmArgsApplication() throws IOException {
		copyApplication('jvmargs');
	}
	private void copyApplication(String name) throws IOException {
		File output = new File(this.gradleBuild.getProjectDir(), 'src/main/java/com/example/bootrun/' + name);
		output.mkdirs();
		FileSystemUtils.copyRecursively(new File('src/test/java/com/example/bootrun/' + name), output);
	}
	private String canonicalPathOf(String path) throws IOException {
		return new File(this.gradleBuild.getProjectDir(), path).getCanonicalPath();
	}
	private void createStandardJar(File location) throws IOException {
		createJar(location, (attributes) -> {
		});
	}
	private void createDependenciesStarterJar(File location) throws IOException {
		createJar(location, (attributes) -> attributes.putValue('Spring-Boot-Jar-Type', 'dependencies-starter'));
	}
	private void createJar(File location, Consumer<Attributes> attributesConfigurer) throws IOException {
		location.getParentFile().mkdirs();
		Manifest manifest = new Manifest();
		Attributes attributes = manifest.getMainAttributes();
		attributes.put(Attributes.Name.MANIFEST_VERSION, '1.0');
		attributesConfigurer.accept(attributes);
		new JarOutputStream(new FileOutputStream(location), manifest).close();
	}
}
/*
package org.springframework.boot.gradle.tasks.run;
/**
@GradleCompatibility(configurationCache = true)
class BootTestRunIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void basicExecution() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('1. ' + canonicalPathOf('build/classes/java/test'))
			.contains('2. ' + canonicalPathOf('build/resources/test'))
			.contains('3. ' + canonicalPathOf('build/classes/java/main'))
			.contains('4. ' + canonicalPathOf('build/resources/main'));
	}
	@TestTemplate
	void defaultJvmArgs() throws IOException {
		copyJvmArgsApplication();
		BuildResult result = this.gradleBuild.build('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('-XX:TieredStopAtLevel=1');
	}
	@TestTemplate
	void optimizedLaunchDisabledJvmArgs() throws IOException {
		copyJvmArgsApplication();
		BuildResult result = this.gradleBuild.build('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).doesNotContain('-Xverify:none').doesNotContain('-XX:TieredStopAtLevel=1');
	}
	@TestTemplate
	void applicationPluginJvmArgumentsAreUsed() throws IOException {
		if (this.gradleBuild.isConfigurationCache()) {
			// https://github.com/gradle/gradle/pull/23924
			GradleVersion gradleVersion = GradleVersion.version(this.gradleBuild.getGradleVersion());
			Assumptions.assumeThat(gradleVersion)
				.isLessThan(GradleVersion.version('8.0'))
				.isGreaterThanOrEqualTo(GradleVersion.version('8.1-rc-1'));
		}
		copyJvmArgsApplication();
		BuildResult result = this.gradleBuild.build('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('-Dcom.bar=baz')
			.contains('-Dcom.foo=bar')
			.contains('-XX:TieredStopAtLevel=1');
	}
	@TestTemplate
	void jarTypeFilteringIsAppliedToTheClasspath() throws IOException {
		copyClasspathApplication();
		File flatDirRepository = new File(this.gradleBuild.getProjectDir(), 'repository');
		createDependenciesStarterJar(new File(flatDirRepository, 'starter.jar'));
		createStandardJar(new File(flatDirRepository, 'standard.jar'));
		BuildResult result = this.gradleBuild.build('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('standard.jar').doesNotContain('starter.jar');
	}
	@TestTemplate
	void failsGracefullyWhenNoTestMainMethodIsFound() throws IOException {
		copyApplication('nomain');
		BuildResult result = this.gradleBuild.buildAndFail('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.FAILED);
		if (this.gradleBuild.isConfigurationCache() && this.gradleBuild.gradleVersionIsAtLeast('8.0')) {
			assertThat(result.getOutput())
				.contains('Main class name has not been configured and it could not be resolved from classpath');
		}
		else {
			assertThat(result.getOutput())
				.contains('Main class name has not been configured and it could not be resolved from classpath '
						+ canonicalPathOf('build/classes/java/test'));
		}
	}
	@TestTemplate
	void developmentOnlyDependenciesAreNotOnTheClasspath() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).doesNotContain('commons-lang3-3.12.0.jar');
	}
	@TestTemplate
	void testAndDevelopmentOnlyDependenciesAreOnTheClasspath() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('bootTestRun');
		assertThat(result.task(':bootTestRun').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(result.getOutput()).contains('commons-lang3-3.12.0.jar');
	}
	private void copyClasspathApplication() throws IOException {
		copyApplication('classpath');
	}
	private void copyJvmArgsApplication() throws IOException {
		copyApplication('jvmargs');
	}
	private void copyApplication(String name) throws IOException {
		File output = new File(this.gradleBuild.getProjectDir(), 'src/test/java/com/example/boottestrun/' + name);
		output.mkdirs();
		FileSystemUtils.copyRecursively(new File('src/test/java/com/example/boottestrun/' + name), output);
	}
	private String canonicalPathOf(String path) throws IOException {
		return new File(this.gradleBuild.getProjectDir(), path).getCanonicalPath();
	}
	private void createStandardJar(File location) throws IOException {
		createJar(location, (attributes) -> {
		});
	}
	private void createDependenciesStarterJar(File location) throws IOException {
		createJar(location, (attributes) -> attributes.putValue('Spring-Boot-Jar-Type', 'dependencies-starter'));
	}
	private void createJar(File location, Consumer<Attributes> attributesConfigurer) throws IOException {
		location.getParentFile().mkdirs();
		Manifest manifest = new Manifest();
		Attributes attributes = manifest.getMainAttributes();
		attributes.put(Attributes.Name.MANIFEST_VERSION, '1.0');
		attributesConfigurer.accept(attributes);
		new JarOutputStream(new FileOutputStream(location), manifest).close();
	}
}
/*
package org.springframework.boot.gradle.tasks.buildinfo;
/**
@ClassPathExclusions('kotlin-daemon-client-*')
class BuildInfoTests {
	@TempDir
	File temp;
	@Test
	void basicExecution() {
		Properties properties = buildInfoProperties(createTask(createProject('test')));
		assertThat(properties).containsKey('build.time');
		assertThat(properties).doesNotContainKey('build.artifact');
		assertThat(properties).doesNotContainKey('build.group');
		assertThat(properties).containsEntry('build.name', 'test');
		assertThat(properties).containsEntry('build.version', 'unspecified');
	}
	@Test
	void customArtifactIsReflectedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getProperties().getArtifact().set('custom');
		assertThat(buildInfoProperties(task)).containsEntry('build.artifact', 'custom');
	}
	@Test
	void artifactCanBeExcludedFromProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getExcludes().addAll('artifact');
		assertThat(buildInfoProperties(task)).doesNotContainKey('build.artifact');
	}
	@Test
	void projectGroupIsReflectedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getProject().setGroup('com.example');
		assertThat(buildInfoProperties(task)).containsEntry('build.group', 'com.example');
	}
	@Test
	void customGroupIsReflectedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getProperties().getGroup().set('com.example');
		assertThat(buildInfoProperties(task)).containsEntry('build.group', 'com.example');
	}
	@Test
	void groupCanBeExcludedFromProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getExcludes().add('group');
		assertThat(buildInfoProperties(task)).doesNotContainKey('build.group');
	}
	@Test
	void customNameIsReflectedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getProperties().getName().set('Example');
		assertThat(buildInfoProperties(task)).containsEntry('build.name', 'Example');
	}
	@Test
	void nameCanBeExcludedFromProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getExcludes().add('name');
		assertThat(buildInfoProperties(task)).doesNotContainKey('build.name');
	}
	@Test
	void projectVersionIsReflectedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getProject().setVersion('1.2.3');
		assertThat(buildInfoProperties(task)).containsEntry('build.version', '1.2.3');
	}
	@Test
	void customVersionIsReflectedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getProperties().getVersion().set('2.3.4');
		assertThat(buildInfoProperties(task)).containsEntry('build.version', '2.3.4');
	}
	@Test
	void versionCanBeExcludedFromProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getExcludes().add('version');
		assertThat(buildInfoProperties(task)).doesNotContainKey('build.version');
	}
	@Test
	void timeIsSetInProperties() {
		BuildInfo task = createTask(createProject('test'));
		assertThat(buildInfoProperties(task)).containsKey('build.time');
	}
	@Test
	void timeCanBeExcludedFromProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getExcludes().add('time');
		assertThat(buildInfoProperties(task)).doesNotContainKey('build.time');
	}
	@Test
	void timeCanBeCustomizedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		String isoTime = DateTimeFormatter.ISO_INSTANT.format(Instant.now());
		task.getProperties().getTime().set(isoTime);
		assertThat(buildInfoProperties(task)).containsEntry('build.time', isoTime);
	}
	@Test
	void additionalPropertiesAreReflectedInProperties() {
		BuildInfo task = createTask(createProject('test'));
		task.getProperties().getAdditional().put('a', 'alpha');
		task.getProperties().getAdditional().put('b', 'bravo');
		assertThat(buildInfoProperties(task)).containsEntry('build.a', 'alpha').containsEntry('build.b', 'bravo');
	}
	@Test
	void additionalPropertiesCanBeExcluded() {
		BuildInfo task = createTask(createProject('test'));
		task.getProperties().getAdditional().put('a', 'alpha');
		task.getExcludes().add('b');
		assertThat(buildInfoProperties(task)).containsEntry('build.a', 'alpha').doesNotContainKey('b');
	}
	@Test
	void nullAdditionalPropertyProducesInformativeFailure() {
		BuildInfo task = createTask(createProject('test'));
		assertThatException().isThrownBy(() -> task.getProperties().getAdditional().put('a', null))
			.withMessage('Cannot add an entry with a null value to a property of type Map.');
	}
	private Project createProject(String projectName) {
		File projectDir = new File(this.temp, projectName);
		Project project = GradleProjectBuilder.builder().withProjectDir(projectDir).withName(projectName).build();
		((ProjectInternal) project).getServices()
			.get(GradlePropertiesController.class)
			.loadGradlePropertiesFrom(projectDir, false);
		return project;
	}
	private BuildInfo createTask(Project project) {
		return project.getTasks().create('testBuildInfo', BuildInfo.class);
	}
	private Properties buildInfoProperties(BuildInfo task) {
		task.generateBuildProperties();
		return buildInfoProperties(new File(task.getDestinationDir().get().getAsFile(), 'build-info.properties'));
	}
	private Properties buildInfoProperties(File file) {
		assertThat(file).isFile();
		Properties properties = new Properties();
		try (FileReader reader = new FileReader(file)) {
			properties.load(reader);
			return properties;
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.buildinfo;
/**
@GradleCompatibility(configurationCache = true)
class BuildInfoIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void defaultValues() {
		assertThat(this.gradleBuild.build('buildInfo').task(':buildInfo').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Properties buildInfoProperties = buildInfoProperties();
		assertThat(buildInfoProperties).containsKey('build.time');
		assertThat(buildInfoProperties).doesNotContainKey('build.artifact');
		assertThat(buildInfoProperties).doesNotContainKey('build.group');
		assertThat(buildInfoProperties).containsEntry('build.name', this.gradleBuild.getProjectDir().getName());
		assertThat(buildInfoProperties).containsEntry('build.version', 'unspecified');
	}
	@TestTemplate
	void basicExecution() {
		assertThat(this.gradleBuild.build('buildInfo').task(':buildInfo').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Properties buildInfoProperties = buildInfoProperties();
		assertThat(buildInfoProperties).containsKey('build.time');
		assertThat(buildInfoProperties).containsEntry('build.artifact', 'foo');
		assertThat(buildInfoProperties).containsEntry('build.group', 'foo');
		assertThat(buildInfoProperties).containsEntry('build.additional', 'foo');
		assertThat(buildInfoProperties).containsEntry('build.name', 'foo');
		assertThat(buildInfoProperties).containsEntry('build.version', '0.1.0');
	}
	@TestTemplate
	void notUpToDateWhenExecutedTwiceAsTimeChanges() {
		assertThat(this.gradleBuild.build('buildInfo').task(':buildInfo').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Properties first = buildInfoProperties();
		String firstBuildTime = first.getProperty('build.time');
		assertThat(firstBuildTime).isNotNull();
		assertThat(this.gradleBuild.build('buildInfo').task(':buildInfo').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Properties second = buildInfoProperties();
		String secondBuildTime = second.getProperty('build.time');
		assertThat(secondBuildTime).isNotNull();
		assertThat(Instant.parse(firstBuildTime)).isBefore(Instant.parse(secondBuildTime));
	}
	@TestTemplate
	void upToDateWhenExecutedTwiceWithFixedTime() {
		assertThat(this.gradleBuild.build('buildInfo', '-PnullTime').task(':buildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.build('buildInfo', '-PnullTime').task(':buildInfo').getOutcome())
			.isEqualTo(TaskOutcome.UP_TO_DATE);
	}
	@TestTemplate
	void notUpToDateWhenExecutedTwiceWithFixedTimeAndChangedProjectVersion() {
		assertThat(this.gradleBuild.scriptProperty('projectVersion', '0.1.0')
			.build('buildInfo')
			.task(':buildInfo')
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('projectVersion', '0.2.0')
			.build('buildInfo')
			.task(':buildInfo')
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void notUpToDateWhenExecutedTwiceWithFixedTimeAndChangedGradlePropertiesProjectVersion() throws IOException {
		Path gradleProperties = new File(this.gradleBuild.getProjectDir(), 'gradle.properties').toPath();
		Files.writeString(gradleProperties, 'version=0.1.0', StandardOpenOption.CREATE, StandardOpenOption.WRITE,
				StandardOpenOption.TRUNCATE_EXISTING);
		assertThat(this.gradleBuild.build('buildInfo').task(':buildInfo').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Files.writeString(gradleProperties, 'version=0.2.0', StandardOpenOption.CREATE, StandardOpenOption.WRITE,
				StandardOpenOption.TRUNCATE_EXISTING);
		assertThat(this.gradleBuild.build('buildInfo').task(':buildInfo').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void reproducibleOutputWithFixedTime() throws IOException, InterruptedException {
		assertThat(this.gradleBuild.build('buildInfo', '-PnullTime').task(':buildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		File buildInfoProperties = new File(this.gradleBuild.getProjectDir(), 'build/buildInfo/build-info.properties');
		String firstHash = FileUtils.sha1Hash(buildInfoProperties);
		assertThat(buildInfoProperties.delete()).isTrue();
		Thread.sleep(1500);
		assertThat(this.gradleBuild.build('buildInfo', '-PnullTime').task(':buildInfo').getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		String secondHash = FileUtils.sha1Hash(buildInfoProperties);
		assertThat(firstHash).isEqualTo(secondHash);
	}
	@TestTemplate
	void excludeProperties() {
		assertThat(this.gradleBuild.build('buildInfo').task(':buildInfo').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Properties buildInfoProperties = buildInfoProperties();
		assertThat(buildInfoProperties).doesNotContainKey('build.group');
		assertThat(buildInfoProperties).doesNotContainKey('build.artifact');
		assertThat(buildInfoProperties).doesNotContainKey('build.version');
		assertThat(buildInfoProperties).doesNotContainKey('build.name');
	}
	private Properties buildInfoProperties() {
		File file = new File(this.gradleBuild.getProjectDir(), 'build/buildInfo/build-info.properties');
		assertThat(file).isFile();
		Properties properties = new Properties();
		try (FileReader reader = new FileReader(file)) {
			properties.load(reader);
			return properties;
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class DefaultTimeZoneOffsetTests {
	// gh-21005
	@Test
	void removeFromWithLongInDifferentTimeZonesReturnsSameValue() {
		long time = OffsetDateTime.of(2000, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).toInstant().toEpochMilli();
		TimeZone timeZone1 = TimeZone.getTimeZone('GMT');
		TimeZone timeZone2 = TimeZone.getTimeZone('GMT+8');
		TimeZone timeZone3 = TimeZone.getTimeZone('GMT-8');
		long result1 = new DefaultTimeZoneOffset(timeZone1).removeFrom(time);
		long result2 = new DefaultTimeZoneOffset(timeZone2).removeFrom(time);
		long result3 = new DefaultTimeZoneOffset(timeZone3).removeFrom(time);
		long dosTime1 = toDosTime(Calendar.getInstance(timeZone1), result1);
		long dosTime2 = toDosTime(Calendar.getInstance(timeZone2), result2);
		long dosTime3 = toDosTime(Calendar.getInstance(timeZone3), result3);
		assertThat(dosTime1).isEqualTo(dosTime2).isEqualTo(dosTime3);
	}
	@Test
	void removeFromWithFileTimeReturnsFileTime() {
		long time = OffsetDateTime.of(2000, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).toInstant().toEpochMilli();
		long result = new DefaultTimeZoneOffset(TimeZone.getTimeZone('GMT+8')).removeFrom(time);
		assertThat(result).isNotEqualTo(time).isEqualTo(946656000000L);
	}
	/**
	 * Identical functionality to package-private
	 * org.apache.commons.compress.archivers.zip.ZipUtil.toDosTime(Calendar, long, byte[],
	 * int) method used by {@link ZipArchiveOutputStream} to convert times.
	 * @param calendar the source calendar
	 * @param time the time to convert
	 * @return the DOS time
	 */
	private long toDosTime(Calendar calendar, long time) {
		calendar.setTimeInMillis(time);
		final int year = calendar.get(Calendar.YEAR);
		final int month = calendar.get(Calendar.MONTH) + 1;
		return ((year - 1980) << 25) | (month << 21) | (calendar.get(Calendar.DAY_OF_MONTH) << 16)
				| (calendar.get(Calendar.HOUR_OF_DAY) << 11) | (calendar.get(Calendar.MINUTE) << 5)
				| (calendar.get(Calendar.SECOND) >> 1);
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@GradleCompatibility(configurationCache = true)
class BootWarIntegrationTests extends AbstractBootArchiveIntegrationTests {
	BootWarIntegrationTests() {
		super('bootWar', 'WEB-INF/lib/', 'WEB-INF/classes/', 'WEB-INF/');
	}
	@Override
	String[] getExpectedApplicationLayerContents(String... additionalFiles) {
		Set<String> contents = new TreeSet<>(Arrays.asList(additionalFiles));
		contents.addAll(Arrays.asList('WEB-INF/classpath.idx', 'WEB-INF/layers.idx', 'META-INF/'));
		return contents.toArray(new String[0]);
	}
	@Override
	void multiModuleImplicitLayers() throws IOException {
		whenTestingWithTheConfigurationCacheAssumeThatTheGradleVersionIsLessThan8();
		super.multiModuleImplicitLayers();
	}
	@Override
	void multiModuleCustomLayers() throws IOException {
		whenTestingWithTheConfigurationCacheAssumeThatTheGradleVersionIsLessThan8();
		super.multiModuleCustomLayers();
	}
	private void whenTestingWithTheConfigurationCacheAssumeThatTheGradleVersionIsLessThan8() {
		if (this.gradleBuild.isConfigurationCache()) {
			// With Gradle 8.0, a configuration cache bug prevents ResolvedDependencies
			// from processing dependencies on the runtime classpath
			Assumptions.assumeThat(GradleVersion.version(this.gradleBuild.getGradleVersion()))
				.isLessThan(GradleVersion.version('8.0'));
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
abstract class AbstractBootArchiveTests<T extends Jar & BootArchive> {
	@TempDir
	File temp;
	private final Class<T> taskClass;
	private final String launcherClass;
	private final String libPath;
	private final String classesPath;
	private final String indexPath;
	private Project project;
	private T task;
	protected AbstractBootArchiveTests(Class<T> taskClass, String launcherClass, String libPath, String classesPath,
			String indexPath) {
		this.taskClass = taskClass;
		this.launcherClass = launcherClass;
		this.libPath = libPath;
		this.classesPath = classesPath;
		this.indexPath = indexPath;
	}
	@BeforeEach
	void createTask() {
		File projectDir = new File(this.temp, 'project');
		projectDir.mkdirs();
		this.project = GradleProjectBuilder.builder().withProjectDir(projectDir).build();
		this.project.setDescription('Test project for ' + this.taskClass.getSimpleName());
		this.task = configure(this.project.getTasks().create('testArchive', this.taskClass));
	}
	@Test
	void basicArchiveCreation() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Main-Class')).isEqualTo(this.launcherClass);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Start-Class')).isEqualTo('com.example.Main');
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Classes'))
				.isEqualTo(this.classesPath);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Lib')).isEqualTo(this.libPath);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Version')).isNotNull();
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Implementation-Title'))
				.isEqualTo(this.project.getName());
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Implementation-Version')).isNull();
		}
	}
	@Test
	void whenImplementationNameIsCustomizedItShouldAppearInArchiveManifest() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.getManifest().getAttributes().put('Implementation-Title', 'Customized');
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Implementation-Title'))
				.isEqualTo('Customized');
		}
	}
	@Test
	void whenProjectVersionIsSetThenImplementationVersionShouldAppearInArchiveManifest() throws IOException {
		this.project.setVersion('1.0.0');
		this.task.getMainClass().set('com.example.Main');
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Implementation-Version')).isEqualTo('1.0.0');
		}
	}
	@Test
	void whenImplementationVersionIsCustomizedItShouldAppearInArchiveManifest() throws IOException {
		this.project.setVersion('1.0.0');
		this.task.getMainClass().set('com.example.Main');
		this.task.getManifest().getAttributes().put('Implementation-Version', 'Customized');
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Implementation-Version'))
				.isEqualTo('Customized');
		}
	}
	@Test
	void classpathJarsArePackagedBeneathLibPathAndAreStored() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.classpath(jarFile('one.jar'), jarFile('two.jar'));
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.libPath + 'one.jar')).isNotNull()
				.extracting(ZipEntry::getMethod)
				.isEqualTo(ZipEntry.STORED);
			assertThat(jarFile.getEntry(this.libPath + 'two.jar')).isNotNull()
				.extracting(ZipEntry::getMethod)
				.isEqualTo(ZipEntry.STORED);
		}
	}
	@Test
	void classpathDirectoriesArePackagedBeneathClassesPath() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		File classpathDirectory = new File(this.temp, 'classes');
		File applicationClass = new File(classpathDirectory, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		this.task.classpath(classpathDirectory);
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.classesPath + 'com/example/Application.class')).isNotNull();
		}
	}
	@Test
	void moduleInfoClassIsPackagedInTheRootOfTheArchive() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		File classpathDirectory = new File(this.temp, 'classes');
		File moduleInfoClass = new File(classpathDirectory, 'module-info.class');
		moduleInfoClass.getParentFile().mkdirs();
		moduleInfoClass.createNewFile();
		File applicationClass = new File(classpathDirectory, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		this.task.classpath(classpathDirectory);
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.classesPath + 'com/example/Application.class')).isNotNull();
			assertThat(jarFile.getEntry('com/example/Application.class')).isNull();
			assertThat(jarFile.getEntry('module-info.class')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + '/module-info.class')).isNull();
		}
	}
	@Test
	void classpathCanBeSetUsingAFileCollection() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.classpath(jarFile('one.jar'));
		this.task.setClasspath(this.task.getProject().files(jarFile('two.jar')));
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.libPath + 'one.jar')).isNull();
			assertThat(jarFile.getEntry(this.libPath + 'two.jar')).isNotNull();
		}
	}
	@Test
	void classpathCanBeSetUsingAnObject() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.classpath(jarFile('one.jar'));
		this.task.setClasspath(jarFile('two.jar'));
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.libPath + 'one.jar')).isNull();
			assertThat(jarFile.getEntry(this.libPath + 'two.jar')).isNotNull();
		}
	}
	@Test
	void filesOnTheClasspathThatAreNotZipFilesAreSkipped() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.classpath(new File('test.pom'));
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.libPath + '/test.pom')).isNull();
		}
	}
	@Test
	void loaderIsWrittenToTheRootOfTheJarAfterManifest() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('org/springframework/boot/loader/launch/LaunchedClassLoader.class'))
				.isNotNull();
			assertThat(jarFile.getEntry('org/springframework/boot/loader/')).isNotNull();
		}
		// gh-16698
		try (ZipInputStream zipInputStream = new ZipInputStream(
				new FileInputStream(this.task.getArchiveFile().get().getAsFile()))) {
			assertThat(zipInputStream.getNextEntry().getName()).isEqualTo('META-INF/');
			assertThat(zipInputStream.getNextEntry().getName()).isEqualTo('META-INF/MANIFEST.MF');
		}
	}
	@Test
	void loaderIsWrittenToTheRootOfTheJarWhenUsingThePropertiesLauncher() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		executeTask();
		this.task.getManifest()
			.getAttributes()
			.put('Main-Class', 'org.springframework.boot.loader.launch.PropertiesLauncher');
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('org/springframework/boot/loader/launch/LaunchedClassLoader.class'))
				.isNotNull();
			assertThat(jarFile.getEntry('org/springframework/boot/loader/')).isNotNull();
		}
	}
	@Test
	void loaderIsWrittenToTheRootOfTheJarWhenUsingClassicLoader() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.getLoaderImplementation().set(LoaderImplementation.CLASSIC);
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('org/springframework/boot/loader/LaunchedURLClassLoader.class')).isNotNull();
			assertThat(jarFile.getEntry('org/springframework/boot/loader/')).isNotNull();
		}
	}
	@Test
	void unpackCommentIsAddedToEntryIdentifiedByAPattern() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.classpath(jarFile('one.jar'), jarFile('two.jar'));
		this.task.requiresUnpack('**/one.jar');
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.libPath + 'one.jar').getComment()).startsWith('UNPACK:');
			assertThat(jarFile.getEntry(this.libPath + 'two.jar').getComment()).isNull();
		}
	}
	@Test
	void unpackCommentIsAddedToEntryIdentifiedByASpec() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.classpath(jarFile('one.jar'), jarFile('two.jar'));
		this.task.requiresUnpack((element) -> element.getName().endsWith('two.jar'));
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.libPath + 'two.jar').getComment()).startsWith('UNPACK:');
			assertThat(jarFile.getEntry(this.libPath + 'one.jar').getComment()).isNull();
		}
	}
	@Test
	void launchScriptCanBePrepended() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.launchScript();
		executeTask();
		Map<String, String> properties = new HashMap<>();
		properties.put('initInfoProvides', this.task.getArchiveBaseName().get());
		properties.put('initInfoShortDescription', this.project.getDescription());
		properties.put('initInfoDescription', this.project.getDescription());
		File archiveFile = this.task.getArchiveFile().get().getAsFile();
		assertThat(Files.readAllBytes(archiveFile.toPath()))
			.startsWith(new DefaultLaunchScript(null, properties).toByteArray());
		try (ZipFile zipFile = new ZipFile(archiveFile)) {
			assertThat(zipFile.getEntries().hasMoreElements()).isTrue();
		}
		try {
			Set<PosixFilePermission> permissions = Files.getPosixFilePermissions(archiveFile.toPath());
			assertThat(permissions).contains(PosixFilePermission.OWNER_EXECUTE);
		}
		catch (UnsupportedOperationException ex) {
			// Windows, presumably. Continue
		}
	}
	@Test
	void customLaunchScriptCanBePrepended() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		File customScript = new File(this.temp, 'custom.script');
		Files.writeString(customScript.toPath(), 'custom script', StandardOpenOption.CREATE);
		this.task.launchScript((configuration) -> configuration.setScript(customScript));
		executeTask();
		Path path = this.task.getArchiveFile().get().getAsFile().toPath();
		assertThat(Files.readString(path, StandardCharsets.ISO_8859_1)).startsWith('custom script');
	}
	@Test
	void launchScriptInitInfoPropertiesCanBeCustomized() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.launchScript((configuration) -> {
			configuration.getProperties().put('initInfoProvides', 'provides');
			configuration.getProperties().put('initInfoShortDescription', 'short description');
			configuration.getProperties().put('initInfoDescription', 'description');
		});
		executeTask();
		Path path = this.task.getArchiveFile().get().getAsFile().toPath();
		String content = Files.readString(path, StandardCharsets.ISO_8859_1);
		assertThat(content).containsSequence('Provides:          provides');
		assertThat(content).containsSequence('Short-Description: short description');
		assertThat(content).containsSequence('Description:       description');
	}
	@Test
	void customMainClassInTheManifestIsHonored() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.getManifest().getAttributes().put('Main-Class', 'com.example.CustomLauncher');
		executeTask();
		assertThat(this.task.getArchiveFile().get().getAsFile()).exists();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Main-Class'))
				.isEqualTo('com.example.CustomLauncher');
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Start-Class')).isEqualTo('com.example.Main');
			assertThat(jarFile.getEntry('org/springframework/boot/loader/launch/LaunchedClassLoader.class')).isNull();
		}
	}
	@Test
	void customStartClassInTheManifestIsHonored() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.getManifest().getAttributes().put('Start-Class', 'com.example.CustomMain');
		executeTask();
		assertThat(this.task.getArchiveFile().get().getAsFile()).exists();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Main-Class')).isEqualTo(this.launcherClass);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Start-Class'))
				.isEqualTo('com.example.CustomMain');
		}
	}
	@Test
	void fileTimestampPreservationCanBeDisabled() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.setPreserveFileTimestamps(false);
		executeTask();
		assertThat(this.task.getArchiveFile().get().getAsFile()).exists();
		long expectedTime = DefaultTimeZoneOffset.INSTANCE.removeFrom(BootZipCopyAction.CONSTANT_TIME_FOR_ZIP_ENTRIES);
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			Enumeration<JarEntry> entries = jarFile.entries();
			while (entries.hasMoreElements()) {
				JarEntry entry = entries.nextElement();
				assertThat(entry.getTime()).isEqualTo(expectedTime);
			}
		}
	}
	@Test
	void constantTimestampMatchesGradleInternalTimestamp() {
		assertThat(DefaultTimeZoneOffset.INSTANCE.removeFrom(BootZipCopyAction.CONSTANT_TIME_FOR_ZIP_ENTRIES))
			.isEqualTo(ZipCopyAction.CONSTANT_TIME_FOR_ZIP_ENTRIES);
	}
	@Test
	void reproducibleOrderingCanBeEnabled() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.from(newFile('bravo.txt'), newFile('alpha.txt'), newFile('charlie.txt'));
		this.task.setReproducibleFileOrder(true);
		executeTask();
		assertThat(this.task.getArchiveFile().get().getAsFile()).exists();
		List<String> textFiles = new ArrayList<>();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			Enumeration<JarEntry> entries = jarFile.entries();
			while (entries.hasMoreElements()) {
				JarEntry entry = entries.nextElement();
				if (entry.getName().endsWith('.txt')) {
					textFiles.add(entry.getName());
				}
			}
		}
		assertThat(textFiles).containsExactly('alpha.txt', 'bravo.txt', 'charlie.txt');
	}
	@Test
	void devtoolsJarIsExcludedByDefault() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.classpath(newFile('spring-boot-devtools-0.1.2.jar'));
		executeTask();
		assertThat(this.task.getArchiveFile().get().getAsFile()).exists();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry(this.libPath + 'spring-boot-devtools-0.1.2.jar')).isNull();
		}
	}
	@Test
	void allEntriesUseUnixPlatformAndUtf8NameEncoding() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		this.task.setMetadataCharset('UTF-8');
		File classpathDirectory = new File(this.temp, 'classes');
		File resource = new File(classpathDirectory, 'some-resource.xml');
		resource.getParentFile().mkdirs();
		resource.createNewFile();
		this.task.classpath(classpathDirectory);
		executeTask();
		File archivePath = this.task.getArchiveFile().get().getAsFile();
		try (ZipFile zip = new ZipFile(archivePath)) {
			Enumeration<ZipArchiveEntry> entries = zip.getEntries();
			while (entries.hasMoreElements()) {
				ZipArchiveEntry entry = entries.nextElement();
				assertThat(entry.getPlatform()).isEqualTo(ZipArchiveEntry.PLATFORM_UNIX);
				assertThat(entry.getGeneralPurposeBit().usesUTF8ForNames()).isTrue();
			}
		}
	}
	@Test
	void loaderIsWrittenFirstThenApplicationClassesThenLibraries() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		File classpathDirectory = new File(this.temp, 'classes');
		File applicationClass = new File(classpathDirectory, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		this.task.classpath(classpathDirectory, jarFile('first-library.jar'), jarFile('second-library.jar'),
				jarFile('third-library.jar'));
		this.task.requiresUnpack('second-library.jar');
		executeTask();
		assertThat(getEntryNames(this.task.getArchiveFile().get().getAsFile())).containsSubsequence(
				'org/springframework/boot/loader/', this.classesPath + 'com/example/Application.class',
				this.libPath + 'first-library.jar', this.libPath + 'second-library.jar',
				this.libPath + 'third-library.jar');
	}
	@Test
	void archiveShouldBeLayeredByDefault() throws IOException {
		addContent();
		executeTask();
		try (JarFile jarFile = new JarFile(this.task.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Classes'))
				.isEqualTo(this.classesPath);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Lib')).isEqualTo(this.libPath);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Layers-Index'))
				.isEqualTo(this.indexPath + 'layers.idx');
			assertThat(getEntryNames(jarFile)).contains(this.libPath + JarModeLibrary.TOOLS.getName());
		}
	}
	@Test
	void jarWhenLayersDisabledShouldNotContainLayersIndex() throws IOException {
		List<String> entryNames = getEntryNames(
				createLayeredJar((configuration) -> configuration.getEnabled().set(false)));
		assertThat(entryNames).isNotEmpty().doesNotContain(this.indexPath + 'layers.idx');
	}
	@Test
	void whenJarIsLayeredThenManifestContainsEntryForLayersIndexInPlaceOfClassesAndLib() throws IOException {
		try (JarFile jarFile = new JarFile(createLayeredJar())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Classes'))
				.isEqualTo(this.classesPath);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Lib')).isEqualTo(this.libPath);
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Layers-Index'))
				.isEqualTo(this.indexPath + 'layers.idx');
		}
	}
	@Test
	void whenJarIsLayeredThenLayersIndexIsPresentAndCorrect() throws IOException {
		try (JarFile jarFile = new JarFile(createLayeredJar())) {
			List<String> entryNames = getEntryNames(jarFile);
			assertThat(entryNames).contains(this.libPath + 'first-library.jar', this.libPath + 'second-library.jar',
					this.libPath + 'third-library-SNAPSHOT.jar', this.libPath + 'first-project-library.jar',
					this.libPath + 'second-project-library-SNAPSHOT.jar',
					this.classesPath + 'com/example/Application.class', this.classesPath + 'application.properties',
					this.classesPath + 'static/test.css');
			List<String> index = entryLines(jarFile, this.indexPath + 'layers.idx');
			assertThat(getLayerNames(index)).containsExactly('dependencies', 'spring-boot-loader',
					'snapshot-dependencies', 'application');
			String layerToolsJar = this.libPath + JarModeLibrary.TOOLS.getName();
			List<String> expected = new ArrayList<>();
			expected.add('- \'dependencies\':');
			expected.add('  - \'' + this.libPath + 'first-library.jar\'');
			expected.add('  - \'' + this.libPath + 'first-project-library.jar\'');
			expected.add('  - \'' + this.libPath + 'fourth-library.jar\'');
			expected.add('  - \'' + this.libPath + 'second-library.jar\'');
			if (!layerToolsJar.contains('SNAPSHOT')) {
				expected.add('  - \'' + layerToolsJar + '\'');
			}
			expected.add('- \'spring-boot-loader\':');
			expected.add('  - \'org/\'');
			expected.add('- \'snapshot-dependencies\':');
			expected.add('  - \'' + this.libPath + 'second-project-library-SNAPSHOT.jar\'');
			if (layerToolsJar.contains('SNAPSHOT')) {
				expected.add('  - \'' + layerToolsJar + '\'');
			}
			expected.add('  - \'' + this.libPath + 'third-library-SNAPSHOT.jar\'');
			expected.add('- \'application\':');
			Set<String> applicationContents = new TreeSet<>();
			applicationContents.add('  - \'' + this.classesPath + '\'');
			applicationContents.add('  - \'' + this.indexPath + 'classpath.idx\'');
			applicationContents.add('  - \'' + this.indexPath + 'layers.idx\'');
			applicationContents.add('  - \'META-INF/\'');
			expected.addAll(applicationContents);
			assertThat(index).containsExactlyElementsOf(expected);
		}
	}
	@Test
	void whenJarIsLayeredWithCustomStrategiesThenLayersIndexIsPresentAndCorrect() throws IOException {
		File jar = createLayeredJar((layered) -> {
			layered.application((application) -> {
				application.intoLayer('resources', (spec) -> spec.include('static/**'));
				application.intoLayer('application');
			});
			layered.dependencies((dependencies) -> {
				dependencies.intoLayer('my-snapshot-deps', (spec) -> spec.include('com.example:*:*.SNAPSHOT'));
				dependencies.intoLayer('my-internal-deps', (spec) -> spec.include('com.example:*:*'));
				dependencies.intoLayer('my-deps');
			});
			layered.getLayerOrder()
				.set(List.of('my-deps', 'my-internal-deps', 'my-snapshot-deps', 'resources', 'application'));
		});
		try (JarFile jarFile = new JarFile(jar)) {
			List<String> entryNames = getEntryNames(jar);
			assertThat(entryNames).contains(this.libPath + 'first-library.jar', this.libPath + 'second-library.jar',
					this.libPath + 'third-library-SNAPSHOT.jar', this.libPath + 'first-project-library.jar',
					this.libPath + 'second-project-library-SNAPSHOT.jar',
					this.classesPath + 'com/example/Application.class', this.classesPath + 'application.properties',
					this.classesPath + 'static/test.css');
			List<String> index = entryLines(jarFile, this.indexPath + 'layers.idx');
			assertThat(getLayerNames(index)).containsExactly('my-deps', 'my-internal-deps', 'my-snapshot-deps',
					'resources', 'application');
			String layerToolsJar = this.libPath + JarModeLibrary.TOOLS.getName();
			List<String> expected = new ArrayList<>();
			expected.add('- \'my-deps\':');
			expected.add('  - \'' + layerToolsJar + '\'');
			expected.add('- \'my-internal-deps\':');
			expected.add('  - \'' + this.libPath + 'first-library.jar\'');
			expected.add('  - \'' + this.libPath + 'first-project-library.jar\'');
			expected.add('  - \'' + this.libPath + 'fourth-library.jar\'');
			expected.add('  - \'' + this.libPath + 'second-library.jar\'');
			expected.add('- \'my-snapshot-deps\':');
			expected.add('  - \'' + this.libPath + 'second-project-library-SNAPSHOT.jar\'');
			expected.add('  - \'' + this.libPath + 'third-library-SNAPSHOT.jar\'');
			expected.add('- \'resources\':');
			expected.add('  - \'' + this.classesPath + 'static/\'');
			expected.add('- \'application\':');
			Set<String> applicationContents = new TreeSet<>();
			applicationContents.add('  - \'' + this.classesPath + 'application.properties\'');
			applicationContents.add('  - \'' + this.classesPath + 'com/\'');
			applicationContents.add('  - \'' + this.indexPath + 'classpath.idx\'');
			applicationContents.add('  - \'' + this.indexPath + 'layers.idx\'');
			applicationContents.add('  - \'META-INF/\'');
			applicationContents.add('  - \'org/\'');
			expected.addAll(applicationContents);
			assertThat(index).containsExactlyElementsOf(expected);
		}
	}
	@Test
	void whenArchiveIsLayeredThenLayerToolsAreAddedToTheJar() throws IOException {
		List<String> entryNames = getEntryNames(createLayeredJar());
		assertThat(entryNames).contains(this.libPath + JarModeLibrary.TOOLS.getName());
	}
	@Test
	void shouldAddToolsToTheJar() throws IOException {
		this.task.getMainClass().set('com.example.Main');
		executeTask();
		List<String> entryNames = getEntryNames(this.task.getArchiveFile().get().getAsFile());
		assertThat(entryNames).isNotEmpty().contains(this.libPath + JarModeLibrary.TOOLS.getName());
	}
	@Test
	@SuppressWarnings('removal')
	void whenArchiveIsLayeredAndIncludeLayerToolsIsFalseThenLayerToolsAreNotAddedToTheJar() throws IOException {
		List<String> entryNames = getEntryNames(
				createLayeredJar((configuration) -> configuration.getIncludeLayerTools().set(false)));
		assertThat(entryNames).isNotEmpty().doesNotContain(this.libPath + JarModeLibrary.TOOLS.getName());
	}
	@Test
	void whenIncludeToolsIsFalseThenToolsAreNotAddedToTheJar() throws IOException {
		this.task.getIncludeTools().set(false);
		this.task.getMainClass().set('com.example.Main');
		executeTask();
		List<String> entryNames = getEntryNames(this.task.getArchiveFile().get().getAsFile());
		assertThat(entryNames).isNotEmpty().doesNotContain(this.libPath + JarModeLibrary.TOOLS.getName());
	}
	protected File jarFile(String name) throws IOException {
		File file = newFile(name);
		try (JarOutputStream jar = new JarOutputStream(new FileOutputStream(file))) {
			jar.putNextEntry(new ZipEntry('META-INF/MANIFEST.MF'));
			new Manifest().write(jar);
			jar.closeEntry();
		}
		return file;
	}
	private T configure(T task) {
		AbstractArchiveTask archiveTask = task;
		archiveTask.getArchiveBaseName().set('test');
		File destination = new File(this.temp, 'destination');
		destination.mkdirs();
		archiveTask.getDestinationDirectory().set(destination);
		return task;
	}
	protected abstract void executeTask();
	protected T getTask() {
		return this.task;
	}
	protected List<String> getEntryNames(File file) throws IOException {
		try (JarFile jarFile = new JarFile(file)) {
			return getEntryNames(jarFile);
		}
	}
	protected List<String> getEntryNames(JarFile jarFile) {
		List<String> entryNames = new ArrayList<>();
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			entryNames.add(entries.nextElement().getName());
		}
		return entryNames;
	}
	protected File newFile(String name) throws IOException {
		File file = new File(this.temp, name);
		file.createNewFile();
		return file;
	}
	File createLayeredJar() throws IOException {
		return createLayeredJar(false);
	}
	File createLayeredJar(boolean addReachabilityProperties) throws IOException {
		return createLayeredJar(addReachabilityProperties, (spec) -> {
		});
	}
	File createLayeredJar(Action<LayeredSpec> action) throws IOException {
		return createLayeredJar(false, action);
	}
	File createLayeredJar(boolean addReachabilityProperties, Action<LayeredSpec> action) throws IOException {
		applyLayered(action);
		addContent(addReachabilityProperties);
		executeTask();
		return getTask().getArchiveFile().get().getAsFile();
	}
	File createPopulatedJar() throws IOException {
		return createPopulatedJar(false);
	}
	File createPopulatedJar(boolean addReachabilityProperties) throws IOException {
		addContent(addReachabilityProperties);
		executeTask();
		return getTask().getArchiveFile().get().getAsFile();
	}
	abstract void applyLayered(Action<LayeredSpec> action);
	void addContent() throws IOException {
		addContent(false);
	}
	@SuppressWarnings('unchecked')
	void addContent(boolean addReachabilityProperties) throws IOException {
		this.task.getMainClass().set('com.example.Main');
		File classesJavaMain = new File(this.temp, 'classes/java/main');
		File applicationClass = new File(classesJavaMain, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		File resourcesMain = new File(this.temp, 'resources/main');
		File applicationProperties = new File(resourcesMain, 'application.properties');
		applicationProperties.getParentFile().mkdirs();
		applicationProperties.createNewFile();
		File staticResources = new File(resourcesMain, 'static');
		staticResources.mkdir();
		File css = new File(staticResources, 'test.css');
		css.createNewFile();
		if (addReachabilityProperties) {
			createReachabilityProperties(resourcesMain, 'com.example', 'first-library', '1.0.0', 'true');
			createReachabilityProperties(resourcesMain, 'com.example', 'second-library', '1.0.0', 'true');
			createReachabilityProperties(resourcesMain, 'com.example', 'fourth-library', '1.0.0', 'false');
		}
		this.task.classpath(classesJavaMain, resourcesMain, jarFile('first-library.jar'), jarFile('second-library.jar'),
				jarFile('third-library-SNAPSHOT.jar'), jarFile('fourth-library.jar'),
				jarFile('first-project-library.jar'), jarFile('second-project-library-SNAPSHOT.jar'));
		Set<ResolvedArtifactResult> resolvedArtifacts = new LinkedHashSet<>();
		resolvedArtifacts.add(mockArtifact('first-library.jar', 'com.example', 'first-library', '1.0.0'));
		resolvedArtifacts.add(mockArtifact('second-library.jar', 'com.example', 'second-library', '1.0.0'));
		resolvedArtifacts
			.add(mockArtifact('third-library-SNAPSHOT.jar', 'com.example', 'third-library', '1.0.0.SNAPSHOT'));
		resolvedArtifacts.add(mockArtifact('fourth-library.jar', 'com.example', 'fourth-library', '1.0.0'));
		resolvedArtifacts
			.add(mockArtifact('first-project-library.jar', 'com.example', 'first-project-library', '1.0.0'));
		resolvedArtifacts.add(mockArtifact('second-project-library-SNAPSHOT.jar', 'com.example',
				'second-project-library', '1.0.0.SNAPSHOT'));
		ArtifactCollection artifacts = mock(ArtifactCollection.class);
		given(artifacts.getResolvedArtifacts()).willReturn(this.project.provider(() -> resolvedArtifacts));
		ResolvableDependencies resolvableDependencies = mock(ResolvableDependencies.class);
		given(resolvableDependencies.getArtifacts()).willReturn(artifacts);
		Configuration configuration = mock(Configuration.class);
		given(configuration.getIncoming()).willReturn(resolvableDependencies);
		DependencySet dependencies = mock(DependencySet.class);
		DomainObjectSet<ProjectDependency> projectDependencies = mock(DomainObjectSet.class);
		given(dependencies.withType(ProjectDependency.class)).willReturn(projectDependencies);
		given(configuration.getAllDependencies()).willReturn(dependencies);
		willAnswer((invocation) -> {
			invocation.getArgument(0, Action.class).execute(resolvableDependencies);
			return null;
		}).given(resolvableDependencies).afterResolve(any(Action.class));
		given(configuration.getIncoming()).willReturn(resolvableDependencies);
		populateResolvedDependencies(configuration);
	}
	protected void createReachabilityProperties(File directory, String groupId, String artifactId, String version,
			String override) throws IOException {
		File targetDirectory = new File(directory,
				'META-INF/native-image/%s/%s/%s'.formatted(groupId, artifactId, version));
		File target = new File(targetDirectory, 'reachability-metadata.properties');
		targetDirectory.mkdirs();
		FileCopyUtils.copy('override=%s\n'.formatted(override).getBytes(StandardCharsets.ISO_8859_1), target);
	}
	private void populateResolvedDependencies(Configuration configuration) {
		getTask().resolvedArtifacts(configuration.getIncoming().getArtifacts().getResolvedArtifacts());
	}
	private ResolvedArtifactResult mockArtifact(String fileName, String group, String module, String version) {
		ModuleComponentArtifactIdentifier moduleId = mock(ModuleComponentArtifactIdentifier.class);
		ModuleComponentIdentifier componentId = mock(ModuleComponentIdentifier.class);
		given(moduleId.getComponentIdentifier()).willReturn(componentId);
		given(componentId.getGroup()).willReturn(group);
		given(componentId.getModule()).willReturn(module);
		given(componentId.getVersion()).willReturn(version);
		ResolvedArtifactResult libraryArtifact = mock(ResolvedArtifactResult.class);
		File file = new File(this.temp, fileName).getAbsoluteFile();
		given(libraryArtifact.getFile()).willReturn(file);
		given(libraryArtifact.getId()).willReturn(moduleId);
		return libraryArtifact;
	}
	List<String> entryLines(JarFile jarFile, String entryName) throws IOException {
		try (BufferedReader reader = new BufferedReader(
				new InputStreamReader(jarFile.getInputStream(jarFile.getEntry(entryName))))) {
			return reader.lines().toList();
		}
	}
	private Set<String> getLayerNames(List<String> index) {
		Set<String> layerNames = new LinkedHashSet<>();
		for (String line : index) {
			if (line.startsWith('- ')) {
				layerNames.add(line.substring(3, line.length() - 2));
			}
		}
		return layerNames;
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class DockerSpecTests {
	private DockerSpec dockerSpec;
	@BeforeEach
	void prepareDockerSpec(@TempDir File temp) {
		this.dockerSpec = GradleProjectBuilder.builder()
			.withProjectDir(temp)
			.build()
			.getObjects()
			.newInstance(DockerSpec.class);
	}
	@Test
	void asDockerConfigurationWithDefaults() {
		DockerConfiguration dockerConfiguration = this.dockerSpec.asDockerConfiguration();
		assertThat(dockerConfiguration.getHost()).isNull();
		assertThat(dockerConfiguration.getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithHostConfiguration() {
		this.dockerSpec.getHost().set('docker.example.com');
		this.dockerSpec.getTlsVerify().set(true);
		this.dockerSpec.getCertPath().set('/tmp/ca-cert');
		DockerConfiguration dockerConfiguration = this.dockerSpec.asDockerConfiguration();
		DockerHostConfiguration host = dockerConfiguration.getHost();
		assertThat(host.getAddress()).isEqualTo('docker.example.com');
		assertThat(host.isSecure()).isTrue();
		assertThat(host.getCertificatePath()).isEqualTo('/tmp/ca-cert');
		assertThat(host.getContext()).isNull();
		assertThat(dockerConfiguration.isBindHostToBuilder()).isFalse();
		assertThat(this.dockerSpec.asDockerConfiguration().getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithHostConfigurationNoTlsVerify() {
		this.dockerSpec.getHost().set('docker.example.com');
		DockerConfiguration dockerConfiguration = this.dockerSpec.asDockerConfiguration();
		DockerHostConfiguration host = dockerConfiguration.getHost();
		assertThat(host.getAddress()).isEqualTo('docker.example.com');
		assertThat(host.isSecure()).isFalse();
		assertThat(host.getCertificatePath()).isNull();
		assertThat(host.getContext()).isNull();
		assertThat(dockerConfiguration.isBindHostToBuilder()).isFalse();
		assertThat(this.dockerSpec.asDockerConfiguration().getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithContextConfiguration() {
		this.dockerSpec.getContext().set('test-context');
		DockerConfiguration dockerConfiguration = this.dockerSpec.asDockerConfiguration();
		DockerHostConfiguration host = dockerConfiguration.getHost();
		assertThat(host.getContext()).isEqualTo('test-context');
		assertThat(host.getAddress()).isNull();
		assertThat(host.isSecure()).isFalse();
		assertThat(host.getCertificatePath()).isNull();
		assertThat(dockerConfiguration.isBindHostToBuilder()).isFalse();
		assertThat(this.dockerSpec.asDockerConfiguration().getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithHostAndContextFails() {
		this.dockerSpec.getContext().set('test-context');
		this.dockerSpec.getHost().set('docker.example.com');
		assertThatExceptionOfType(GradleException.class).isThrownBy(this.dockerSpec::asDockerConfiguration)
			.withMessageContaining('Invalid Docker configuration');
	}
	@Test
	void asDockerConfigurationWithBindHostToBuilder() {
		this.dockerSpec.getHost().set('docker.example.com');
		this.dockerSpec.getBindHostToBuilder().set(true);
		DockerConfiguration dockerConfiguration = this.dockerSpec.asDockerConfiguration();
		DockerHostConfiguration host = dockerConfiguration.getHost();
		assertThat(host.getAddress()).isEqualTo('docker.example.com');
		assertThat(host.isSecure()).isFalse();
		assertThat(host.getCertificatePath()).isNull();
		assertThat(dockerConfiguration.isBindHostToBuilder()).isTrue();
		assertThat(this.dockerSpec.asDockerConfiguration().getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithUserAuth() {
		this.dockerSpec.builderRegistry((registry) -> {
			registry.getUsername().set('user1');
			registry.getPassword().set('secret1');
			registry.getUrl().set('https://docker1.example.com');
			registry.getEmail().set('docker1@example.com');
		});
		this.dockerSpec.publishRegistry((registry) -> {
			registry.getUsername().set('user2');
			registry.getPassword().set('secret2');
			registry.getUrl().set('https://docker2.example.com');
			registry.getEmail().set('docker2@example.com');
		});
		DockerConfiguration dockerConfiguration = this.dockerSpec.asDockerConfiguration();
		assertThat(decoded(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'user1\'')
			.contains('\'password\' : \'secret1\'')
			.contains('\'email\' : \'docker1@example.com\'')
			.contains('\'serveraddress\' : \'https://docker1.example.com\'');
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'user2\'')
			.contains('\'password\' : \'secret2\'')
			.contains('\'email\' : \'docker2@example.com\'')
			.contains('\'serveraddress\' : \'https://docker2.example.com\'');
		assertThat(this.dockerSpec.asDockerConfiguration().getHost()).isNull();
	}
	@Test
	void asDockerConfigurationWithIncompleteBuilderUserAuthFails() {
		this.dockerSpec.builderRegistry((registry) -> {
			registry.getUsername().set('user1');
			registry.getUrl().set('https://docker1.example.com');
			registry.getEmail().set('docker1@example.com');
		});
		assertThatExceptionOfType(GradleException.class).isThrownBy(this.dockerSpec::asDockerConfiguration)
			.withMessageContaining('Invalid Docker builder registry configuration');
	}
	@Test
	void asDockerConfigurationWithIncompletePublishUserAuthFails() {
		this.dockerSpec.publishRegistry((registry) -> {
			registry.getUsername().set('user2');
			registry.getUrl().set('https://docker2.example.com');
			registry.getEmail().set('docker2@example.com');
		});
		assertThatExceptionOfType(GradleException.class).isThrownBy(this.dockerSpec::asDockerConfiguration)
			.withMessageContaining('Invalid Docker publish registry configuration');
	}
	@Test
	void asDockerConfigurationWithTokenAuth() {
		this.dockerSpec.builderRegistry((registry) -> registry.getToken().set('token1'));
		this.dockerSpec.publishRegistry((registry) -> registry.getToken().set('token2'));
		DockerConfiguration dockerConfiguration = this.dockerSpec.asDockerConfiguration();
		assertThat(decoded(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()))
			.contains('\'identitytoken\' : \'token1\'');
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'identitytoken\' : \'token2\'');
	}
	@Test
	void asDockerConfigurationWithUserAndTokenAuthFails() {
		this.dockerSpec.builderRegistry((registry) -> {
			registry.getUsername().set('user');
			registry.getPassword().set('secret');
			registry.getToken().set('token');
		});
		assertThatExceptionOfType(GradleException.class).isThrownBy(this.dockerSpec::asDockerConfiguration)
			.withMessageContaining('Invalid Docker builder registry configuration');
	}
	String decoded(String value) {
		return new String(Base64.getDecoder().decode(value));
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@GradleCompatibility(configurationCache = true)
class BootJarIntegrationTests extends AbstractBootArchiveIntegrationTests {
	BootJarIntegrationTests() {
		super('bootJar', 'BOOT-INF/lib/', 'BOOT-INF/classes/', 'BOOT-INF/');
	}
	@TestTemplate
	void signed() throws Exception {
		assertThat(this.gradleBuild.build('bootJar').task(':bootJar').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		File jar = new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0];
		try (JarFile jarFile = new JarFile(jar)) {
			assertThat(jarFile.getEntry('META-INF/BOOT.SF')).isNotNull();
		}
	}
	@TestTemplate
	void whenAResolvableCopyOfAnUnresolvableConfigurationIsResolvedThenResolutionSucceeds() {
		this.gradleBuild.expectDeprecationWarningsWithAtLeastVersion('8.0').build('build');
	}
	@TestTemplate
	void packagedApplicationClasspath() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('launch');
		String output = result.getOutput();
		assertThat(output).containsPattern('1\\. .*classes');
		assertThat(output).containsPattern('2\\. .*library-1.0-SNAPSHOT.jar');
		assertThat(output).containsPattern('3\\. .*commons-lang3-3.9.jar');
		assertThat(output).containsPattern('4\\. .*spring-boot-jarmode-tools.*.jar');
		assertThat(output).doesNotContain('5. ');
	}
	@TestTemplate
	void explodedApplicationClasspath() throws IOException {
		copyClasspathApplication();
		BuildResult result = this.gradleBuild.build('launch');
		String output = result.getOutput();
		assertThat(output).containsPattern('1\\. .*classes');
		assertThat(output).containsPattern('2\\. .*spring-boot-jarmode-tools.*.jar');
		assertThat(output).containsPattern('3\\. .*library-1.0-SNAPSHOT.jar');
		assertThat(output).containsPattern('4\\. .*commons-lang3-3.9.jar');
		assertThat(output).doesNotContain('5. ');
	}
	private void copyClasspathApplication() throws IOException {
		copyApplication('classpath');
	}
	@Override
	String[] getExpectedApplicationLayerContents(String... additionalFiles) {
		Set<String> contents = new TreeSet<>(Arrays.asList(additionalFiles));
		contents.addAll(Arrays.asList('BOOT-INF/classpath.idx', 'BOOT-INF/layers.idx', 'META-INF/'));
		return contents.toArray(new String[0]);
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@GradleCompatibility
class MavenPublishingIntegrationTests {
	GradleBuild gradleBuild;
	@TestTemplate
	void bootJarCanBePublished() {
		BuildResult result = this.gradleBuild.build('publish');
		assertThat(result.task(':publish').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(artifactWithSuffix('jar')).isFile();
		assertThat(artifactWithSuffix('pom')).is(pomWith().groupId('com.example')
			.artifactId(this.gradleBuild.getProjectDir().getName())
			.version('1.0')
			.noPackaging()
			.noDependencies());
	}
	@TestTemplate
	void bootWarCanBePublished() {
		BuildResult result = this.gradleBuild.build('publish');
		assertThat(result.task(':publish').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(artifactWithSuffix('war')).isFile();
		assertThat(artifactWithSuffix('pom')).is(pomWith().groupId('com.example')
			.artifactId(this.gradleBuild.getProjectDir().getName())
			.version('1.0')
			.packaging('war')
			.noDependencies());
	}
	private File artifactWithSuffix(String suffix) {
		String name = this.gradleBuild.getProjectDir().getName();
		return new File(new File(this.gradleBuild.getProjectDir(), 'build/repo'),
				String.format('com/example/%s/1.0/%s-1.0.%s', name, name, suffix));
	}
	private PomCondition pomWith() {
		return new PomCondition();
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@ClassPathExclusions('kotlin-daemon-client-*')
class BootJarTests extends AbstractBootArchiveTests<BootJar> {
	BootJarTests() {
		super(BootJar.class, 'org.springframework.boot.loader.launch.JarLauncher', 'BOOT-INF/lib/', 'BOOT-INF/classes/',
				'BOOT-INF/');
	}
	@BeforeEach
	void setUp() {
		this.getTask().getTargetJavaVersion().set(JavaVersion.VERSION_17);
	}
	@Test
	void contentCanBeAddedToBootInfUsingCopySpecFromGetter() throws IOException {
		BootJar bootJar = getTask();
		bootJar.getMainClass().set('com.example.Application');
		bootJar.getBootInf().into('test').from(new File('build.gradle').getAbsolutePath());
		bootJar.copy();
		try (JarFile jarFile = new JarFile(bootJar.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getJarEntry('BOOT-INF/test/build.gradle')).isNotNull();
		}
	}
	@Test
	void contentCanBeAddedToBootInfUsingCopySpecAction() throws IOException {
		BootJar bootJar = getTask();
		bootJar.getMainClass().set('com.example.Application');
		bootJar.bootInf((copySpec) -> copySpec.into('test').from(new File('build.gradle').getAbsolutePath()));
		bootJar.copy();
		try (JarFile jarFile = new JarFile(bootJar.getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getJarEntry('BOOT-INF/test/build.gradle')).isNotNull();
		}
	}
	@Test
	void jarsInLibAreStored() throws IOException {
		try (JarFile jarFile = new JarFile(createLayeredJar())) {
			assertThat(jarFile.getEntry('BOOT-INF/lib/first-library.jar').getMethod()).isZero();
			assertThat(jarFile.getEntry('BOOT-INF/lib/second-library.jar').getMethod()).isZero();
			assertThat(jarFile.getEntry('BOOT-INF/lib/third-library-SNAPSHOT.jar').getMethod()).isZero();
			assertThat(jarFile.getEntry('BOOT-INF/lib/first-project-library.jar').getMethod()).isZero();
			assertThat(jarFile.getEntry('BOOT-INF/lib/second-project-library-SNAPSHOT.jar').getMethod()).isZero();
		}
	}
	@Test
	void whenJarIsLayeredClasspathIndexPointsToLayeredLibs() throws IOException {
		try (JarFile jarFile = new JarFile(createLayeredJar())) {
			assertThat(entryLines(jarFile, 'BOOT-INF/classpath.idx')).containsExactly(
					'- \'BOOT-INF/lib/first-library.jar\'', '- \'BOOT-INF/lib/second-library.jar\'',
					'- \'BOOT-INF/lib/third-library-SNAPSHOT.jar\'', '- \'BOOT-INF/lib/fourth-library.jar\'',
					'- \'BOOT-INF/lib/first-project-library.jar\'',
					'- \'BOOT-INF/lib/second-project-library-SNAPSHOT.jar\'');
		}
	}
	@Test
	void classpathIndexPointsToBootInfLibs() throws IOException {
		try (JarFile jarFile = new JarFile(createPopulatedJar())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Classpath-Index'))
				.isEqualTo('BOOT-INF/classpath.idx');
			assertThat(entryLines(jarFile, 'BOOT-INF/classpath.idx')).containsExactly(
					'- \'BOOT-INF/lib/first-library.jar\'', '- \'BOOT-INF/lib/second-library.jar\'',
					'- \'BOOT-INF/lib/third-library-SNAPSHOT.jar\'', '- \'BOOT-INF/lib/fourth-library.jar\'',
					'- \'BOOT-INF/lib/first-project-library.jar\'',
					'- \'BOOT-INF/lib/second-project-library-SNAPSHOT.jar\'');
		}
	}
	@Test
	void metaInfEntryIsPackagedInTheRootOfTheArchive() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		File classpathDirectory = new File(this.temp, 'classes');
		File metaInfEntry = new File(classpathDirectory, 'META-INF/test');
		metaInfEntry.getParentFile().mkdirs();
		metaInfEntry.createNewFile();
		File applicationClass = new File(classpathDirectory, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		getTask().classpath(classpathDirectory);
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('BOOT-INF/classes/com/example/Application.class')).isNotNull();
			assertThat(jarFile.getEntry('com/example/Application.class')).isNull();
			assertThat(jarFile.getEntry('BOOT-INF/classes/META-INF/test')).isNull();
			assertThat(jarFile.getEntry('META-INF/test')).isNotNull();
		}
	}
	@Test
	void aopXmlIsPackagedBeneathClassesDirectory() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		File classpathDirectory = new File(this.temp, 'classes');
		File aopXml = new File(classpathDirectory, 'META-INF/aop.xml');
		aopXml.getParentFile().mkdirs();
		aopXml.createNewFile();
		File applicationClass = new File(classpathDirectory, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		getTask().classpath(classpathDirectory);
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('BOOT-INF/classes/com/example/Application.class')).isNotNull();
			assertThat(jarFile.getEntry('com/example/Application.class')).isNull();
			assertThat(jarFile.getEntry('BOOT-INF/classes/META-INF/aop.xml')).isNotNull();
			assertThat(jarFile.getEntry('META-INF/aop.xml')).isNull();
		}
	}
	@Test
	void kotlinModuleIsPackagedBeneathClassesDirectory() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		File classpathDirectory = new File(this.temp, 'classes');
		File kotlinModule = new File(classpathDirectory, 'META-INF/example.kotlin_module');
		kotlinModule.getParentFile().mkdirs();
		kotlinModule.createNewFile();
		File applicationClass = new File(classpathDirectory, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		getTask().classpath(classpathDirectory);
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('BOOT-INF/classes/com/example/Application.class')).isNotNull();
			assertThat(jarFile.getEntry('com/example/Application.class')).isNull();
			assertThat(jarFile.getEntry('BOOT-INF/classes/META-INF/example.kotlin_module')).isNotNull();
			assertThat(jarFile.getEntry('META-INF/example.kotlin_module')).isNull();
		}
	}
	@Test
	void metaInfServicesEntryIsPackagedBeneathClassesDirectory() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		File classpathDirectory = new File(this.temp, 'classes');
		File service = new File(classpathDirectory, 'META-INF/services/com.example.Service');
		service.getParentFile().mkdirs();
		service.createNewFile();
		File applicationClass = new File(classpathDirectory, 'com/example/Application.class');
		applicationClass.getParentFile().mkdirs();
		applicationClass.createNewFile();
		getTask().classpath(classpathDirectory);
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('BOOT-INF/classes/com/example/Application.class')).isNotNull();
			assertThat(jarFile.getEntry('com/example/Application.class')).isNull();
			assertThat(jarFile.getEntry('BOOT-INF/classes/META-INF/services/com.example.Service')).isNotNull();
			assertThat(jarFile.getEntry('META-INF/services/com.example.Service')).isNull();
		}
	}
	@Test
	void nativeImageArgFileWithExcludesIsWritten() throws IOException {
		try (JarFile jarFile = new JarFile(createLayeredJar(true))) {
			assertThat(entryLines(jarFile, 'META-INF/native-image/argfile')).containsExactly('--exclude-config',
					'\\Qfirst-library.jar\\E', '^/META-INF/native-image/.*', '--exclude-config',
					'\\Qsecond-library.jar\\E', '^/META-INF/native-image/.*');
		}
	}
	@Test
	void nativeImageArgFileIsNotWrittenWhenExcludesAreEmpty() throws IOException {
		try (JarFile jarFile = new JarFile(createLayeredJar(false))) {
			assertThat(jarFile.getEntry('META-INF/native-image/argfile')).isNull();
		}
	}
	@Test
	void javaVersionIsWrittenToManifest() throws IOException {
		try (JarFile jarFile = new JarFile(createPopulatedJar())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Build-Jdk-Spec'))
				.isEqualTo(JavaVersion.VERSION_17.getMajorVersion());
		}
	}
	@Override
	void applyLayered(Action<LayeredSpec> action) {
		getTask().layered(action);
	}
	@Override
	protected void executeTask() {
		getTask().copy();
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class LaunchScriptConfigurationTests {
	private final AbstractArchiveTask task = mock(AbstractArchiveTask.class);
	private final Project project = mock(Project.class);
	@BeforeEach
	void setUp() {
		given(this.task.getProject()).willReturn(this.project);
	}
	@Test
	void initInfoProvidesUsesArchiveBaseNameByDefault() {
		Property<String> baseName = stringProperty('base-name');
		given(this.task.getArchiveBaseName()).willReturn(baseName);
		assertThat(new LaunchScriptConfiguration(this.task).getProperties()).containsEntry('initInfoProvides',
				'base-name');
	}
	@Test
	void initInfoShortDescriptionUsesDescriptionByDefault() {
		given(this.project.getDescription()).willReturn('Project description');
		Property<String> baseName = stringProperty('base-name');
		given(this.task.getArchiveBaseName()).willReturn(baseName);
		assertThat(new LaunchScriptConfiguration(this.task).getProperties()).containsEntry('initInfoShortDescription',
				'Project description');
	}
	@Test
	void initInfoShortDescriptionUsesArchiveBaseNameWhenDescriptionIsNull() {
		Property<String> baseName = stringProperty('base-name');
		given(this.task.getArchiveBaseName()).willReturn(baseName);
		assertThat(new LaunchScriptConfiguration(this.task).getProperties()).containsEntry('initInfoShortDescription',
				'base-name');
	}
	@Test
	void initInfoShortDescriptionUsesSingleLineVersionOfMultiLineProjectDescription() {
		given(this.project.getDescription()).willReturn('Project\ndescription');
		Property<String> baseName = stringProperty('base-name');
		given(this.task.getArchiveBaseName()).willReturn(baseName);
		assertThat(new LaunchScriptConfiguration(this.task).getProperties()).containsEntry('initInfoShortDescription',
				'Project description');
	}
	@Test
	void initInfoDescriptionUsesArchiveBaseNameWhenDescriptionIsNull() {
		Property<String> baseName = stringProperty('base-name');
		given(this.task.getArchiveBaseName()).willReturn(baseName);
		assertThat(new LaunchScriptConfiguration(this.task).getProperties()).containsEntry('initInfoDescription',
				'base-name');
	}
	@Test
	void initInfoDescriptionUsesProjectDescriptionByDefault() {
		given(this.project.getDescription()).willReturn('Project description');
		Property<String> baseName = stringProperty('base-name');
		given(this.task.getArchiveBaseName()).willReturn(baseName);
		assertThat(new LaunchScriptConfiguration(this.task).getProperties()).containsEntry('initInfoDescription',
				'Project description');
	}
	@Test
	void initInfoDescriptionUsesCorrectlyFormattedMultiLineProjectDescription() {
		given(this.project.getDescription()).willReturn('The\nproject\ndescription');
		Property<String> baseName = stringProperty('base-name');
		given(this.task.getArchiveBaseName()).willReturn(baseName);
		assertThat(new LaunchScriptConfiguration(this.task).getProperties()).containsEntry('initInfoDescription',
				'The\n#  project\n#  description');
	}
	@SuppressWarnings('unchecked')
	private Property<String> stringProperty(String value) {
		Property<String> property = mock(Property.class);
		given(property.get()).willReturn(value);
		return property;
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class PomCondition extends Condition<File> {
	private final Set<String> expectedContents;
	private final Set<String> notExpectedContents;
	PomCondition() {
		this(new HashSet<>(), new HashSet<>());
	}
	private PomCondition(Set<String> expectedContents, Set<String> notExpectedContents) {
		super(new TextDescription('Pom file containing %s and not containing %s', expectedContents,
				notExpectedContents));
		this.expectedContents = expectedContents;
		this.notExpectedContents = notExpectedContents;
	}
	@Override
	public boolean matches(File pom) {
		try {
			String contents = FileCopyUtils.copyToString(new FileReader(pom));
			for (String expected : this.expectedContents) {
				if (!contents.contains(expected)) {
					return false;
				}
			}
			for (String notExpected : this.notExpectedContents) {
				if (contents.contains(notExpected)) {
					return false;
				}
			}
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
		return true;
	}
	@Override
	public Description description() {
		return new TextDescription('Pom file containing %s and not containing %s', this.expectedContents,
				this.notExpectedContents);
	}
	PomCondition groupId(String groupId) {
		this.expectedContents.add(String.format('<groupId>%s</groupId>', groupId));
		return this;
	}
	PomCondition artifactId(String artifactId) {
		this.expectedContents.add(String.format('<artifactId>%s</artifactId>', artifactId));
		return this;
	}
	PomCondition version(String version) {
		this.expectedContents.add(String.format('<version>%s</version>', version));
		return this;
	}
	PomCondition packaging(String packaging) {
		this.expectedContents.add(String.format('<packaging>%s</packaging>', packaging));
		return this;
	}
	PomCondition noDependencies() {
		this.notExpectedContents.add('<dependencies>');
		return this;
	}
	PomCondition noPackaging() {
		this.notExpectedContents.add('<packaging>');
		return this;
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@ClassPathExclusions('kotlin-daemon-client-*')
class BootWarTests extends AbstractBootArchiveTests<BootWar> {
	BootWarTests() {
		super(BootWar.class, 'org.springframework.boot.loader.launch.WarLauncher', 'WEB-INF/lib/', 'WEB-INF/classes/',
				'WEB-INF/');
	}
	@BeforeEach
	void setUp() {
		this.getTask().getTargetJavaVersion().set(JavaVersion.VERSION_17);
	}
	@Test
	void providedClasspathJarsArePackagedInWebInfLibProvided() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		getTask().providedClasspath(jarFile('one.jar'), jarFile('two.jar'));
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('WEB-INF/lib-provided/one.jar')).isNotNull();
			assertThat(jarFile.getEntry('WEB-INF/lib-provided/two.jar')).isNotNull();
		}
	}
	@Test
	void providedClasspathCanBeSetUsingAFileCollection() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		getTask().providedClasspath(jarFile('one.jar'));
		getTask().setProvidedClasspath(getTask().getProject().files(jarFile('two.jar')));
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('WEB-INF/lib-provided/one.jar')).isNull();
			assertThat(jarFile.getEntry('WEB-INF/lib-provided/two.jar')).isNotNull();
		}
	}
	@Test
	void providedClasspathCanBeSetUsingAnObject() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		getTask().providedClasspath(jarFile('one.jar'));
		getTask().setProvidedClasspath(jarFile('two.jar'));
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('WEB-INF/lib-provided/one.jar')).isNull();
			assertThat(jarFile.getEntry('WEB-INF/lib-provided/two.jar')).isNotNull();
		}
	}
	@Test
	void devtoolsJarIsExcludedByDefaultWhenItsOnTheProvidedClasspath() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		getTask().providedClasspath(newFile('spring-boot-devtools-0.1.2.jar'));
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('WEB-INF/lib-provided/spring-boot-devtools-0.1.2.jar')).isNull();
		}
	}
	@Test
	void webappResourcesInDirectoriesThatOverlapWithLoaderCanBePackaged() throws IOException {
		File webappDirectory = new File(this.temp, 'src/main/webapp');
		webappDirectory.mkdirs();
		File orgDirectory = new File(webappDirectory, 'org');
		orgDirectory.mkdir();
		new File(orgDirectory, 'foo.txt').createNewFile();
		getTask().from(webappDirectory);
		getTask().getMainClass().set('com.example.Main');
		executeTask();
		try (JarFile jarFile = new JarFile(getTask().getArchiveFile().get().getAsFile())) {
			assertThat(jarFile.getEntry('org/')).isNotNull();
			assertThat(jarFile.getEntry('org/foo.txt')).isNotNull();
		}
	}
	@Test
	void libProvidedEntriesAreWrittenAfterLibEntries() throws IOException {
		getTask().getMainClass().set('com.example.Main');
		getTask().classpath(jarFile('library.jar'));
		getTask().providedClasspath(jarFile('provided-library.jar'));
		executeTask();
		assertThat(getEntryNames(getTask().getArchiveFile().get().getAsFile()))
			.containsSubsequence('WEB-INF/lib/library.jar', 'WEB-INF/lib-provided/provided-library.jar');
	}
	@Test
	void whenWarIsLayeredClasspathIndexPointsToLayeredLibs() throws IOException {
		try (JarFile jarFile = new JarFile(createLayeredJar())) {
			assertThat(entryLines(jarFile, 'WEB-INF/classpath.idx')).containsExactly(
					'- \'WEB-INF/lib/first-library.jar\'', '- \'WEB-INF/lib/second-library.jar\'',
					'- \'WEB-INF/lib/third-library-SNAPSHOT.jar\'', '- \'WEB-INF/lib/fourth-library.jar\'',
					'- \'WEB-INF/lib/first-project-library.jar\'',
					'- \'WEB-INF/lib/second-project-library-SNAPSHOT.jar\'');
		}
	}
	@Test
	void classpathIndexPointsToWebInfLibs() throws IOException {
		try (JarFile jarFile = new JarFile(createPopulatedJar())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Spring-Boot-Classpath-Index'))
				.isEqualTo('WEB-INF/classpath.idx');
			assertThat(entryLines(jarFile, 'WEB-INF/classpath.idx')).containsExactly(
					'- \'WEB-INF/lib/first-library.jar\'', '- \'WEB-INF/lib/second-library.jar\'',
					'- \'WEB-INF/lib/third-library-SNAPSHOT.jar\'', '- \'WEB-INF/lib/fourth-library.jar\'',
					'- \'WEB-INF/lib/first-project-library.jar\'',
					'- \'WEB-INF/lib/second-project-library-SNAPSHOT.jar\'');
		}
	}
	@Test
	void javaVersionIsWrittenToManifest() throws IOException {
		try (JarFile jarFile = new JarFile(createPopulatedJar())) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Build-Jdk-Spec'))
				.isEqualTo(JavaVersion.VERSION_17.getMajorVersion());
		}
	}
	@Override
	protected void executeTask() {
		getTask().copy();
	}
	@Override
	void applyLayered(Action<LayeredSpec> action) {
		getTask().layered(action);
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
abstract class AbstractBootArchiveIntegrationTests {
	private final String taskName;
	private final String libPath;
	private final String classesPath;
	private final String indexPath;
	GradleBuild gradleBuild;
	protected AbstractBootArchiveIntegrationTests(String taskName, String libPath, String classesPath,
			String indexPath) {
		this.taskName = taskName;
		this.libPath = libPath;
		this.classesPath = classesPath;
		this.indexPath = indexPath;
	}
	@TestTemplate
	void basicBuild() {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void reproducibleArchive() throws IOException, InterruptedException {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		File jar = new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0];
		String firstHash = FileUtils.sha1Hash(jar);
		Thread.sleep(1500);
		assertThat(this.gradleBuild.build('clean', this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		String secondHash = FileUtils.sha1Hash(jar);
		assertThat(firstHash).isEqualTo(secondHash);
	}
	@TestTemplate
	void classicLoader() throws IOException {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		File jar = new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0];
		try (JarFile jarFile = new JarFile(jar)) {
			assertThat(jarFile.getEntry('org/springframework/boot/loader/LaunchedURLClassLoader.class')).isNotNull();
		}
	}
	@TestTemplate
	void upToDateWhenBuiltTwice() {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.UP_TO_DATE);
	}
	@TestTemplate
	void upToDateWhenBuiltTwiceWithLaunchScriptIncluded() {
		assertThat(this.gradleBuild.build('-PincludeLaunchScript=true', this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.build('-PincludeLaunchScript=true', this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.UP_TO_DATE);
	}
	@TestTemplate
	void notUpToDateWhenLaunchScriptWasNotIncludedAndThenIsIncluded() {
		assertThat(this.gradleBuild.scriptProperty('launchScript', '')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('launchScript', 'launchScript()')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void notUpToDateWhenLaunchScriptWasIncludedAndThenIsNotIncluded() {
		assertThat(this.gradleBuild.scriptProperty('launchScript', 'launchScript()')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('launchScript', '')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void notUpToDateWhenLaunchScriptPropertyChanges() {
		assertThat(this.gradleBuild.scriptProperty('launchScriptProperty', 'alpha')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('launchScriptProperty', 'bravo')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void applicationPluginMainClassNameIsUsed() throws IOException {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Start-Class'))
				.isEqualTo('com.example.CustomMain');
		}
	}
	@TestTemplate
	void springBootExtensionMainClassNameIsUsed() throws IOException {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Start-Class'))
				.isEqualTo('com.example.CustomMain');
		}
	}
	@TestTemplate
	void duplicatesAreHandledGracefully() {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void developmentOnlyDependenciesAreNotIncludedInTheArchiveByDefault() throws IOException {
		File srcMainResources = new File(this.gradleBuild.getProjectDir(), 'src/main/resources');
		srcMainResources.mkdirs();
		new File(srcMainResources, 'resource').createNewFile();
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Stream<String> libEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.libPath));
			assertThat(libEntryNames).containsExactly(this.libPath + 'commons-io-2.6.jar');
			Stream<String> classesEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.classesPath));
			assertThat(classesEntryNames).containsExactly(this.classesPath + 'resource');
		}
	}
	@TestTemplate
	void developmentOnlyDependenciesCanBeIncludedInTheArchive() throws IOException {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Stream<String> libEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.libPath));
			assertThat(libEntryNames).containsExactly(this.libPath + 'commons-io-2.6.jar',
					this.libPath + 'commons-lang3-3.9.jar');
		}
	}
	@TestTemplate
	void testAndDevelopmentOnlyDependenciesAreNotIncludedInTheArchiveByDefault() throws IOException {
		File srcMainResources = new File(this.gradleBuild.getProjectDir(), 'src/main/resources');
		srcMainResources.mkdirs();
		new File(srcMainResources, 'resource').createNewFile();
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Stream<String> libEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.libPath));
			assertThat(libEntryNames).containsExactly(this.libPath + 'commons-io-2.6.jar');
			Stream<String> classesEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.classesPath));
			assertThat(classesEntryNames).containsExactly(this.classesPath + 'resource');
		}
	}
	@TestTemplate
	void testAndDevelopmentOnlyDependenciesCanBeIncludedInTheArchive() throws IOException {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Stream<String> libEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.libPath));
			assertThat(libEntryNames).containsExactly(this.libPath + 'commons-io-2.6.jar',
					this.libPath + 'commons-lang3-3.9.jar');
		}
	}
	@TestTemplate
	void jarTypeFilteringIsApplied() throws IOException {
		File flatDirRepository = new File(this.gradleBuild.getProjectDir(), 'repository');
		createDependenciesStarterJar(new File(flatDirRepository, 'starter.jar'));
		createStandardJar(new File(flatDirRepository, 'standard.jar'));
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Stream<String> libEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.libPath));
			assertThat(libEntryNames).containsExactly(this.libPath + 'standard.jar');
		}
	}
	@TestTemplate
	void startClassIsSetByResolvingTheMainClass() throws IOException {
		copyMainClassApplication();
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Attributes mainAttributes = jarFile.getManifest().getMainAttributes();
			assertThat(mainAttributes.getValue('Start-Class'))
				.isEqualTo('com.example.' + this.taskName.toLowerCase(Locale.ENGLISH) + '.main.CustomMainClass');
		}
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.UP_TO_DATE);
	}
	@TestTemplate
	void upToDateWhenBuiltWithDefaultLayeredAndThenWithExplicitLayered() {
		assertThat(this.gradleBuild.scriptProperty('layered', '')
			.build('' + this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('layered', 'layered {}')
			.build('' + this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.UP_TO_DATE);
	}
	@TestTemplate
	void notUpToDateWhenBuiltWithoutLayersAndThenWithLayers() {
		assertThat(this.gradleBuild.scriptProperty('layerEnablement', 'enabled = false')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('layerEnablement', 'enabled = true')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void notUpToDateWhenBuiltWithLayerToolsAndThenWithoutLayerTools() {
		assertThat(this.gradleBuild.scriptProperty('layerTools', '')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('layerTools', 'includeLayerTools = false')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void notUpToDateWhenBuiltWithToolsAndThenWithoutTools() {
		assertThat(this.gradleBuild.scriptProperty('includeTools', '')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertThat(this.gradleBuild.scriptProperty('includeTools', 'includeTools = false')
			.build(this.taskName)
			.task(':' + this.taskName)
			.getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void layersWithCustomSourceSet() {
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
	}
	@TestTemplate
	void implicitLayers() throws IOException {
		writeMainClass();
		writeResource();
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		Map<String, List<String>> indexedLayers;
		String layerToolsJar = this.libPath + JarModeLibrary.TOOLS.getName();
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			assertThat(jarFile.getEntry(layerToolsJar)).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'commons-lang3-3.9.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-core-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'library-1.0-SNAPSHOT.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'example/Main.class')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'static/file.txt')).isNotNull();
			indexedLayers = readLayerIndex(jarFile);
		}
		List<String> layerNames = Arrays.asList('dependencies', 'spring-boot-loader', 'snapshot-dependencies',
				'application');
		assertThat(indexedLayers.keySet()).containsExactlyElementsOf(layerNames);
		Set<String> expectedDependencies = new TreeSet<>();
		expectedDependencies.add(this.libPath + 'commons-lang3-3.9.jar');
		expectedDependencies.add(this.libPath + 'spring-core-5.2.5.RELEASE.jar');
		expectedDependencies.add(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar');
		expectedDependencies.add(this.libPath + 'jul-to-slf4j-1.7.28.jar');
		expectedDependencies.add(this.libPath + 'log4j-api-2.12.1.jar');
		expectedDependencies.add(this.libPath + 'log4j-to-slf4j-2.12.1.jar');
		expectedDependencies.add(this.libPath + 'logback-classic-1.2.3.jar');
		expectedDependencies.add(this.libPath + 'logback-core-1.2.3.jar');
		expectedDependencies.add(this.libPath + 'slf4j-api-1.7.28.jar');
		expectedDependencies.add(this.libPath + 'spring-boot-starter-logging-2.2.0.RELEASE.jar');
		Set<String> expectedSnapshotDependencies = new TreeSet<>();
		expectedSnapshotDependencies.add(this.libPath + 'library-1.0-SNAPSHOT.jar');
		(layerToolsJar.contains('SNAPSHOT') ? expectedSnapshotDependencies : expectedDependencies).add(layerToolsJar);
		assertThat(indexedLayers.get('dependencies')).containsExactlyElementsOf(expectedDependencies);
		assertThat(indexedLayers.get('spring-boot-loader')).containsExactly('org/');
		assertThat(indexedLayers.get('snapshot-dependencies')).containsExactlyElementsOf(expectedSnapshotDependencies);
		assertThat(indexedLayers.get('application'))
			.containsExactly(getExpectedApplicationLayerContents(this.classesPath));
		BuildResult listLayers = this.gradleBuild.build('listLayers');
		assertThat(listLayers.task(':listLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		String listLayersOutput = listLayers.getOutput();
		assertThat(new BufferedReader(new StringReader(listLayersOutput)).lines()).containsSequence(layerNames);
		BuildResult extractLayers = this.gradleBuild.build('extractLayers');
		assertThat(extractLayers.task(':extractLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertExtractedLayers(layerNames, indexedLayers);
	}
	abstract String[] getExpectedApplicationLayerContents(String... additionalFiles);
	@TestTemplate
	void multiModuleImplicitLayers() throws IOException {
		writeSettingsGradle();
		writeMainClass();
		writeResource();
		assertThat(this.gradleBuild.build(this.taskName).task(':' + this.taskName).getOutcome())
			.isEqualTo(TaskOutcome.SUCCESS);
		Map<String, List<String>> indexedLayers;
		String layerToolsJar = this.libPath + JarModeLibrary.TOOLS.getName();
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			assertThat(jarFile.getEntry(layerToolsJar)).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'alpha-1.2.3.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'bravo-1.2.3.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'charlie-1.2.3.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'commons-lang3-3.9.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-core-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'library-1.0-SNAPSHOT.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'example/Main.class')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'static/file.txt')).isNotNull();
			indexedLayers = readLayerIndex(jarFile);
		}
		List<String> layerNames = Arrays.asList('dependencies', 'spring-boot-loader', 'snapshot-dependencies',
				'application');
		assertThat(indexedLayers.keySet()).containsExactlyElementsOf(layerNames);
		Set<String> expectedDependencies = new TreeSet<>();
		expectedDependencies.add(this.libPath + 'commons-lang3-3.9.jar');
		expectedDependencies.add(this.libPath + 'spring-core-5.2.5.RELEASE.jar');
		expectedDependencies.add(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar');
		Set<String> expectedSnapshotDependencies = new TreeSet<>();
		expectedSnapshotDependencies.add(this.libPath + 'library-1.0-SNAPSHOT.jar');
		(layerToolsJar.contains('SNAPSHOT') ? expectedSnapshotDependencies : expectedDependencies).add(layerToolsJar);
		assertThat(indexedLayers.get('dependencies')).containsExactlyElementsOf(expectedDependencies);
		assertThat(indexedLayers.get('spring-boot-loader')).containsExactly('org/');
		assertThat(indexedLayers.get('snapshot-dependencies')).containsExactlyElementsOf(expectedSnapshotDependencies);
		assertThat(indexedLayers.get('application'))
			.containsExactly(getExpectedApplicationLayerContents(this.classesPath, this.libPath + 'alpha-1.2.3.jar',
					this.libPath + 'bravo-1.2.3.jar', this.libPath + 'charlie-1.2.3.jar'));
		BuildResult listLayers = this.gradleBuild.build('listLayers');
		assertThat(listLayers.task(':listLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		String listLayersOutput = listLayers.getOutput();
		assertThat(new BufferedReader(new StringReader(listLayersOutput)).lines()).containsSequence(layerNames);
		BuildResult extractLayers = this.gradleBuild.build('extractLayers');
		assertThat(extractLayers.task(':extractLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertExtractedLayers(layerNames, indexedLayers);
	}
	@TestTemplate
	void customLayers() throws IOException {
		writeMainClass();
		writeResource();
		BuildResult build = this.gradleBuild.build(this.taskName);
		assertThat(build.task(':' + this.taskName).getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Map<String, List<String>> indexedLayers;
		String layerToolsJar = this.libPath + JarModeLibrary.TOOLS.getName();
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			assertThat(jarFile.getEntry(layerToolsJar)).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'commons-lang3-3.9.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-core-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'library-1.0-SNAPSHOT.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'example/Main.class')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'static/file.txt')).isNotNull();
			assertThat(jarFile.getEntry(this.indexPath + 'layers.idx')).isNotNull();
			indexedLayers = readLayerIndex(jarFile);
		}
		List<String> layerNames = Arrays.asList('dependencies', 'commons-dependencies', 'snapshot-dependencies',
				'static', 'app');
		assertThat(indexedLayers.keySet()).containsExactlyElementsOf(layerNames);
		Set<String> expectedDependencies = new TreeSet<>();
		expectedDependencies.add(this.libPath + 'spring-core-5.2.5.RELEASE.jar');
		expectedDependencies.add(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar');
		List<String> expectedSnapshotDependencies = new ArrayList<>();
		expectedSnapshotDependencies.add(this.libPath + 'library-1.0-SNAPSHOT.jar');
		(layerToolsJar.contains('SNAPSHOT') ? expectedSnapshotDependencies : expectedDependencies).add(layerToolsJar);
		assertThat(indexedLayers.get('dependencies')).containsExactlyElementsOf(expectedDependencies);
		assertThat(indexedLayers.get('commons-dependencies')).containsExactly(this.libPath + 'commons-lang3-3.9.jar');
		assertThat(indexedLayers.get('snapshot-dependencies')).containsExactlyElementsOf(expectedSnapshotDependencies);
		assertThat(indexedLayers.get('static')).containsExactly(this.classesPath + 'static/');
		List<String> appLayer = new ArrayList<>(indexedLayers.get('app'));
		String[] appLayerContents = getExpectedApplicationLayerContents(this.classesPath + 'example/');
		assertThat(appLayer).containsSubsequence(appLayerContents);
		appLayer.removeAll(Arrays.asList(appLayerContents));
		assertThat(appLayer).containsExactly('org/');
		BuildResult listLayers = this.gradleBuild.build('listLayers');
		assertThat(listLayers.task(':listLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		String listLayersOutput = listLayers.getOutput();
		assertThat(new BufferedReader(new StringReader(listLayersOutput)).lines()).containsSequence(layerNames);
		BuildResult extractLayers = this.gradleBuild.build('extractLayers');
		assertThat(extractLayers.task(':extractLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertExtractedLayers(layerNames, indexedLayers);
	}
	@TestTemplate
	void multiModuleCustomLayers() throws IOException {
		writeSettingsGradle();
		writeMainClass();
		writeResource();
		BuildResult build = this.gradleBuild.build(this.taskName);
		assertThat(build.task(':' + this.taskName).getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		Map<String, List<String>> indexedLayers;
		String layerToolsJar = this.libPath + JarModeLibrary.TOOLS.getName();
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			assertThat(jarFile.getEntry(layerToolsJar)).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'alpha-1.2.3.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'bravo-1.2.3.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'charlie-1.2.3.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'commons-lang3-3.9.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-core-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.libPath + 'library-1.0-SNAPSHOT.jar')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'example/Main.class')).isNotNull();
			assertThat(jarFile.getEntry(this.classesPath + 'static/file.txt')).isNotNull();
			assertThat(jarFile.getEntry(this.indexPath + 'layers.idx')).isNotNull();
			indexedLayers = readLayerIndex(jarFile);
		}
		List<String> layerNames = Arrays.asList('dependencies', 'commons-dependencies', 'snapshot-dependencies',
				'subproject-dependencies', 'static', 'app');
		assertThat(indexedLayers.keySet()).containsExactlyElementsOf(layerNames);
		Set<String> expectedSubprojectDependencies = new TreeSet<>();
		expectedSubprojectDependencies.add(this.libPath + 'alpha-1.2.3.jar');
		expectedSubprojectDependencies.add(this.libPath + 'bravo-1.2.3.jar');
		expectedSubprojectDependencies.add(this.libPath + 'charlie-1.2.3.jar');
		Set<String> expectedDependencies = new TreeSet<>();
		expectedDependencies.add(this.libPath + 'spring-core-5.2.5.RELEASE.jar');
		expectedDependencies.add(this.libPath + 'spring-jcl-5.2.5.RELEASE.jar');
		List<String> expectedSnapshotDependencies = new ArrayList<>();
		expectedSnapshotDependencies.add(this.libPath + 'library-1.0-SNAPSHOT.jar');
		(layerToolsJar.contains('SNAPSHOT') ? expectedSnapshotDependencies : expectedDependencies).add(layerToolsJar);
		assertThat(indexedLayers.get('subproject-dependencies'))
			.containsExactlyElementsOf(expectedSubprojectDependencies);
		assertThat(indexedLayers.get('dependencies')).containsExactlyElementsOf(expectedDependencies);
		assertThat(indexedLayers.get('commons-dependencies')).containsExactly(this.libPath + 'commons-lang3-3.9.jar');
		assertThat(indexedLayers.get('snapshot-dependencies')).containsExactlyElementsOf(expectedSnapshotDependencies);
		assertThat(indexedLayers.get('static')).containsExactly(this.classesPath + 'static/');
		List<String> appLayer = new ArrayList<>(indexedLayers.get('app'));
		String[] appLayerContents = getExpectedApplicationLayerContents(this.classesPath + 'example/');
		assertThat(appLayer).containsSubsequence(appLayerContents);
		appLayer.removeAll(Arrays.asList(appLayerContents));
		assertThat(appLayer).containsExactly('org/');
		BuildResult listLayers = this.gradleBuild.build('listLayers');
		assertThat(listLayers.task(':listLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		String listLayersOutput = listLayers.getOutput();
		assertThat(new BufferedReader(new StringReader(listLayersOutput)).lines()).containsSequence(layerNames);
		BuildResult extractLayers = this.gradleBuild.build('extractLayers');
		assertThat(extractLayers.task(':extractLayers').getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		assertExtractedLayers(layerNames, indexedLayers);
	}
	@TestTemplate
	void classesFromASecondarySourceSetCanBeIncludedInTheArchive() throws IOException {
		writeMainClass();
		File examplePackage = new File(this.gradleBuild.getProjectDir(), 'src/secondary/java/example');
		examplePackage.mkdirs();
		File main = new File(examplePackage, 'Secondary.java');
		try (PrintWriter writer = new PrintWriter(new FileWriter(main))) {
			writer.println('package example;');
			writer.println();
			writer.println('public class Secondary {}');
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
		BuildResult build = this.gradleBuild.build(this.taskName);
		assertThat(build.task(':' + this.taskName).getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Stream<String> classesEntryNames = jarFile.stream()
				.filter((entry) -> !entry.isDirectory())
				.map(JarEntry::getName)
				.filter((name) -> name.startsWith(this.classesPath));
			assertThat(classesEntryNames).containsExactly(this.classesPath + 'example/Main.class',
					this.classesPath + 'example/Secondary.class');
		}
	}
	@TestTemplate
	void javaVersionIsSetInManifest() throws IOException {
		BuildResult result = this.gradleBuild.build(this.taskName);
		assertThat(result.task(':' + this.taskName).getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		try (JarFile jarFile = new JarFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			assertThat(jarFile.getManifest().getMainAttributes().getValue('Build-Jdk-Spec')).isNotEmpty();
		}
	}
	@TestTemplate
	void defaultDirAndFileModesAreUsed() throws IOException {
		BuildResult result = this.gradleBuild.build(this.taskName);
		assertThat(result.task(':' + this.taskName).getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		try (ZipFile jarFile = new ZipFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Enumeration<ZipArchiveEntry> entries = jarFile.getEntries();
			while (entries.hasMoreElements()) {
				ZipArchiveEntry entry = entries.nextElement();
				if (entry.getName().startsWith('META-INF/')) {
					continue;
				}
				if (entry.isDirectory()) {
					assertEntryMode(entry, UnixStat.DIR_FLAG | UnixStat.DEFAULT_DIR_PERM);
				}
				else {
					assertEntryMode(entry, UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM);
				}
			}
		}
	}
	@TestTemplate
	void dirModeAndFileModeAreApplied() throws IOException {
		BuildResult result = this.gradleBuild.expectDeprecationWarningsWithAtLeastVersion('8.8-rc-1')
			.expectDeprecationMessages('The CopyProcessingSpec.setDirMode(Integer) method has been deprecated',
					'The CopyProcessingSpec.setFileMode(Integer) method has been deprecated',
					'upgrading_version_8.html#unix_file_permissions_deprecated')
			.build(this.taskName);
		assertThat(result.task(':' + this.taskName).getOutcome()).isEqualTo(TaskOutcome.SUCCESS);
		try (ZipFile jarFile = new ZipFile(new File(this.gradleBuild.getProjectDir(), 'build/libs').listFiles()[0])) {
			Enumeration<ZipArchiveEntry> entries = jarFile.getEntries();
			while (entries.hasMoreElements()) {
				ZipArchiveEntry entry = entries.nextElement();
				if (entry.getName().startsWith('META-INF/')) {
					continue;
				}
				if (entry.isDirectory()) {
					assertEntryMode(entry, 0500);
				}
				else {
					assertEntryMode(entry, 0400);
				}
			}
		}
	}
	private void copyMainClassApplication() throws IOException {
		copyApplication('main');
	}
	protected void copyApplication(String name) throws IOException {
		File output = new File(this.gradleBuild.getProjectDir(),
				'src/main/java/com/example/' + this.taskName.toLowerCase(Locale.ROOT) + '/' + name);
		output.mkdirs();
		FileSystemUtils.copyRecursively(
				new File('src/test/java/com/example/' + this.taskName.toLowerCase(Locale.ENGLISH) + '/' + name),
				output);
	}
	private void createStandardJar(File location) throws IOException {
		createJar(location, (attributes) -> {
		});
	}
	private void createDependenciesStarterJar(File location) throws IOException {
		createJar(location, (attributes) -> attributes.putValue('Spring-Boot-Jar-Type', 'dependencies-starter'));
	}
	private void createJar(File location, Consumer<Attributes> attributesConfigurer) throws IOException {
		location.getParentFile().mkdirs();
		Manifest manifest = new Manifest();
		Attributes attributes = manifest.getMainAttributes();
		attributes.put(Attributes.Name.MANIFEST_VERSION, '1.0');
		attributesConfigurer.accept(attributes);
		new JarOutputStream(new FileOutputStream(location), manifest).close();
	}
	private void writeSettingsGradle() {
		try (PrintWriter writer = new PrintWriter(
				new FileWriter(new File(this.gradleBuild.getProjectDir(), 'settings.gradle')))) {
			writer.println('include "alpha", "bravo", "charlie"');
			new File(this.gradleBuild.getProjectDir(), 'alpha').mkdirs();
			new File(this.gradleBuild.getProjectDir(), 'bravo').mkdirs();
			new File(this.gradleBuild.getProjectDir(), 'charlie').mkdirs();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void writeMainClass() {
		File examplePackage = new File(this.gradleBuild.getProjectDir(), 'src/main/java/example');
		examplePackage.mkdirs();
		File main = new File(examplePackage, 'Main.java');
		try (PrintWriter writer = new PrintWriter(new FileWriter(main))) {
			writer.println('package example;');
			writer.println();
			writer.println('import java.io.IOException;');
			writer.println();
			writer.println('public class Main {');
			writer.println();
			writer.println('    public static void main(String[] args) {');
			writer.println('    }');
			writer.println();
			writer.println('}');
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void writeResource() {
		try {
			Path path = this.gradleBuild.getProjectDir()
				.toPath()
				.resolve(Paths.get('src', 'main', 'resources', 'static', 'file.txt'));
			Files.createDirectories(path.getParent());
			Files.createFile(path);
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private Map<String, List<String>> readLayerIndex(JarFile jarFile) throws IOException {
		Map<String, List<String>> index = new LinkedHashMap<>();
		ZipEntry indexEntry = jarFile.getEntry(this.indexPath + 'layers.idx');
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(jarFile.getInputStream(indexEntry)))) {
			String line = reader.readLine();
			String layer = null;
			while (line != null) {
				if (line.startsWith('- ')) {
					layer = line.substring(3, line.length() - 2);
				}
				else if (line.startsWith('  - ')) {
					index.computeIfAbsent(layer, (key) -> new ArrayList<>()).add(line.substring(5, line.length() - 1));
				}
				line = reader.readLine();
			}
			return index;
		}
	}
	private Map<String, List<String>> readExtractedLayers(File root, List<String> layerNames) throws IOException {
		Map<String, List<String>> extractedLayers = new LinkedHashMap<>();
		for (String layerName : layerNames) {
			File layer = new File(root, layerName);
			assertThat(layer).isDirectory();
			List<String> files;
			try (Stream<Path> pathStream = Files.walk(layer.toPath())) {
				files = pathStream.filter((path) -> path.toFile().isFile())
					.map(layer.toPath()::relativize)
					.map(Path::toString)
					.map(StringUtils::cleanPath)
					.toList();
			}
			extractedLayers.put(layerName, files);
		}
		return extractedLayers;
	}
	private void assertExtractedLayers(List<String> layerNames, Map<String, List<String>> indexedLayers)
			throws IOException {
		Map<String, List<String>> extractedLayers = readExtractedLayers(this.gradleBuild.getProjectDir(), layerNames);
		assertThat(extractedLayers.keySet()).isEqualTo(indexedLayers.keySet());
		extractedLayers.forEach((name, contents) -> {
			List<String> index = indexedLayers.get(name);
			List<String> unexpected = new ArrayList<>();
			for (String file : contents) {
				if (!isInIndex(index, file)) {
					unexpected.add(name);
				}
			}
			assertThat(unexpected).isEmpty();
		});
	}
	private boolean isInIndex(List<String> index, String file) {
		for (String candidate : index) {
			if (file.equals(candidate) || candidate.endsWith('/') && file.startsWith(candidate)) {
				return true;
			}
		}
		return false;
	}
	private static void assertEntryMode(ZipArchiveEntry entry, int expectedMode) {
		assertThat(entry.getUnixMode())
			.withFailMessage(() -> 'Expected mode ' + Integer.toOctalString(expectedMode) + ' for entry '
					+ entry.getName() + ' but actual is ' + Integer.toOctalString(entry.getUnixMode()))
			.isEqualTo(expectedMode);
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class BootBuildImageTests {
	Project project;
	private BootBuildImage buildImage;
	@BeforeEach
	void setUp(@TempDir File temp) {
		File projectDir = new File(temp, 'project');
		projectDir.mkdirs();
		this.project = GradleProjectBuilder.builder().withProjectDir(projectDir).withName('build-image-test').build();
		this.project.setDescription('Test project for BootBuildImage');
		this.buildImage = this.project.getTasks().create('buildImage', BootBuildImage.class);
	}
	@Test
	void whenProjectVersionIsUnspecifiedThenItIsIgnoredWhenDerivingImageName() {
		assertThat(this.buildImage.getImageName().get()).isEqualTo('docker.io/library/build-image-test');
		BuildRequest request = this.buildImage.createRequest();
		assertThat(request.getName().getDomain()).isEqualTo('docker.io');
		assertThat(request.getName().getName()).isEqualTo('library/build-image-test');
		assertThat(request.getName().getTag()).isEqualTo('latest');
		assertThat(request.getName().getDigest()).isNull();
	}
	@Test
	void whenProjectVersionIsSpecifiedThenItIsUsedInTagOfImageName() {
		this.project.setVersion('1.2.3');
		assertThat(this.buildImage.getImageName().get()).isEqualTo('docker.io/library/build-image-test:1.2.3');
		BuildRequest request = this.buildImage.createRequest();
		assertThat(request.getName().getDomain()).isEqualTo('docker.io');
		assertThat(request.getName().getName()).isEqualTo('library/build-image-test');
		assertThat(request.getName().getTag()).isEqualTo('1.2.3');
		assertThat(request.getName().getDigest()).isNull();
	}
	@Test
	void whenImageNameIsSpecifiedThenItIsUsedInRequest() {
		this.project.setVersion('1.2.3');
		this.buildImage.getImageName().set('example.com/test/build-image:1.0');
		assertThat(this.buildImage.getImageName().get()).isEqualTo('example.com/test/build-image:1.0');
		BuildRequest request = this.buildImage.createRequest();
		assertThat(request.getName().getDomain()).isEqualTo('example.com');
		assertThat(request.getName().getName()).isEqualTo('test/build-image');
		assertThat(request.getName().getTag()).isEqualTo('1.0');
		assertThat(request.getName().getDigest()).isNull();
	}
	@Test
	void springBootVersionDefaultValueIsUsed() {
		BuildRequest request = this.buildImage.createRequest();
		assertThat(request.getCreator().getName()).isEqualTo('Spring Boot');
		assertThat(request.getCreator().getVersion()).isEmpty();
	}
	@Test
	void whenIndividualEntriesAreAddedToTheEnvironmentThenTheyAreIncludedInTheRequest() {
		this.buildImage.getEnvironment().put('ALPHA', 'a');
		this.buildImage.getEnvironment().put('BRAVO', 'b');
		assertThat(this.buildImage.createRequest().getEnv()).containsEntry('ALPHA', 'a')
			.containsEntry('BRAVO', 'b')
			.hasSize(2);
	}
	@Test
	void whenEntriesAreAddedToTheEnvironmentThenTheyAreIncludedInTheRequest() {
		Map<String, String> environment = new HashMap<>();
		environment.put('ALPHA', 'a');
		environment.put('BRAVO', 'b');
		this.buildImage.getEnvironment().putAll(environment);
		assertThat(this.buildImage.createRequest().getEnv()).containsEntry('ALPHA', 'a')
			.containsEntry('BRAVO', 'b')
			.hasSize(2);
	}
	@Test
	void whenTheEnvironmentIsSetItIsIncludedInTheRequest() {
		Map<String, String> environment = new HashMap<>();
		environment.put('ALPHA', 'a');
		environment.put('BRAVO', 'b');
		this.buildImage.getEnvironment().set(environment);
		assertThat(this.buildImage.createRequest().getEnv()).containsEntry('ALPHA', 'a')
			.containsEntry('BRAVO', 'b')
			.hasSize(2);
	}
	@Test
	void whenTheEnvironmentIsSetItReplacesAnyExistingEntriesAndIsIncludedInTheRequest() {
		Map<String, String> environment = new HashMap<>();
		environment.put('ALPHA', 'a');
		environment.put('BRAVO', 'b');
		this.buildImage.getEnvironment().put('C', 'Charlie');
		this.buildImage.getEnvironment().set(environment);
		assertThat(this.buildImage.createRequest().getEnv()).containsEntry('ALPHA', 'a')
			.containsEntry('BRAVO', 'b')
			.hasSize(2);
	}
	@Test
	void whenUsingDefaultConfigurationThenRequestHasVerboseLoggingDisabled() {
		assertThat(this.buildImage.createRequest().isVerboseLogging()).isFalse();
	}
	@Test
	void whenVerboseLoggingIsEnabledThenRequestHasVerboseLoggingEnabled() {
		this.buildImage.getVerboseLogging().set(true);
		assertThat(this.buildImage.createRequest().isVerboseLogging()).isTrue();
	}
	@Test
	void whenUsingDefaultConfigurationThenRequestHasCleanCacheDisabled() {
		assertThat(this.buildImage.createRequest().isCleanCache()).isFalse();
	}
	@Test
	void whenCleanCacheIsEnabledThenRequestHasCleanCacheEnabled() {
		this.buildImage.getCleanCache().set(true);
		assertThat(this.buildImage.createRequest().isCleanCache()).isTrue();
	}
	@Test
	void whenUsingDefaultConfigurationThenRequestHasPublishDisabled() {
		assertThat(this.buildImage.createRequest().isPublish()).isFalse();
	}
	@Test
	void whenNoBuilderIsConfiguredThenRequestHasDefaultBuilder() {
		BuildRequest request = this.buildImage.createRequest();
		assertThat(request.getBuilder().getName()).isEqualTo('paketobuildpacks/builder-jammy-java-tiny');
		assertThat(request.isTrustBuilder()).isTrue();
	}
	@Test
	void whenBuilderIsConfiguredThenRequestUsesSpecifiedBuilder() {
		this.buildImage.getBuilder().set('example.com/test/builder:1.2');
		BuildRequest request = this.buildImage.createRequest();
		assertThat(request.getBuilder().getName()).isEqualTo('test/builder');
		assertThat(request.isTrustBuilder()).isFalse();
	}
	@Test
	void whenTrustBuilderIsEnabledThenRequestHasTrustBuilderEnabled() {
		this.buildImage.getBuilder().set('example.com/test/builder:1.2');
		this.buildImage.getTrustBuilder().set(true);
		assertThat(this.buildImage.createRequest().isTrustBuilder()).isTrue();
	}
	@Test
	void whenNoRunImageIsConfiguredThenRequestUsesDefaultRunImage() {
		assertThat(this.buildImage.createRequest().getRunImage()).isNull();
	}
	@Test
	void whenRunImageIsConfiguredThenRequestUsesSpecifiedRunImage() {
		this.buildImage.getRunImage().set('example.com/test/run:1.0');
		assertThat(this.buildImage.createRequest().getRunImage().getName()).isEqualTo('test/run');
	}
	@Test
	void whenUsingDefaultConfigurationThenRequestHasAlwaysPullPolicy() {
		assertThat(this.buildImage.createRequest().getPullPolicy()).isEqualTo(PullPolicy.ALWAYS);
	}
	@Test
	void whenPullPolicyIsConfiguredThenRequestHasPullPolicy() {
		this.buildImage.getPullPolicy().set(PullPolicy.NEVER);
		assertThat(this.buildImage.createRequest().getPullPolicy()).isEqualTo(PullPolicy.NEVER);
	}
	@Test
	void whenNoBuildpacksAreConfiguredThenRequestUsesDefaultBuildpacks() {
		assertThat(this.buildImage.createRequest().getBuildpacks()).isEmpty();
	}
	@Test
	void whenBuildpacksAreConfiguredThenRequestHasBuildpacks() {
		this.buildImage.getBuildpacks().set(Arrays.asList('example/buildpack1', 'example/buildpack2'));
		assertThat(this.buildImage.createRequest().getBuildpacks())
			.containsExactly(BuildpackReference.of('example/buildpack1'), BuildpackReference.of('example/buildpack2'));
	}
	@Test
	void whenEntriesAreAddedToBuildpacksThenRequestHasBuildpacks() {
		this.buildImage.getBuildpacks().addAll(Arrays.asList('example/buildpack1', 'example/buildpack2'));
		assertThat(this.buildImage.createRequest().getBuildpacks())
			.containsExactly(BuildpackReference.of('example/buildpack1'), BuildpackReference.of('example/buildpack2'));
	}
	@Test
	void whenIndividualEntriesAreAddedToBuildpacksThenRequestHasBuildpacks() {
		this.buildImage.getBuildpacks().add('example/buildpack1');
		this.buildImage.getBuildpacks().add('example/buildpack2');
		assertThat(this.buildImage.createRequest().getBuildpacks())
			.containsExactly(BuildpackReference.of('example/buildpack1'), BuildpackReference.of('example/buildpack2'));
	}
	@Test
	void whenNoBindingsAreConfiguredThenRequestHasNoBindings() {
		assertThat(this.buildImage.createRequest().getBindings()).isEmpty();
	}
	@Test
	void whenBindingsAreConfiguredThenRequestHasBindings() {
		this.buildImage.getBindings().set(Arrays.asList('host-src:container-dest:ro', 'volume-name:container-dest:rw'));
		assertThat(this.buildImage.createRequest().getBindings())
			.containsExactly(Binding.of('host-src:container-dest:ro'), Binding.of('volume-name:container-dest:rw'));
	}
	@Test
	void whenEntriesAreAddedToBindingsThenRequestHasBindings() {
		this.buildImage.getBindings()
			.addAll(Arrays.asList('host-src:container-dest:ro', 'volume-name:container-dest:rw'));
		assertThat(this.buildImage.createRequest().getBindings())
			.containsExactly(Binding.of('host-src:container-dest:ro'), Binding.of('volume-name:container-dest:rw'));
	}
	@Test
	void whenIndividualEntriesAreAddedToBindingsThenRequestHasBindings() {
		this.buildImage.getBindings().add('host-src:container-dest:ro');
		this.buildImage.getBindings().add('volume-name:container-dest:rw');
		assertThat(this.buildImage.createRequest().getBindings())
			.containsExactly(Binding.of('host-src:container-dest:ro'), Binding.of('volume-name:container-dest:rw'));
	}
	@Test
	void whenNetworkIsConfiguredThenRequestHasNetwork() {
		this.buildImage.getNetwork().set('test');
		assertThat(this.buildImage.createRequest().getNetwork()).isEqualTo('test');
	}
	@Test
	void whenNoTagsAreConfiguredThenRequestHasNoTags() {
		assertThat(this.buildImage.createRequest().getTags()).isEmpty();
	}
	@Test
	void whenTagsAreConfiguredThenRequestHasTags() {
		this.buildImage.getTags()
			.set(Arrays.asList('my-app:latest', 'example.com/my-app:0.0.1-SNAPSHOT', 'example.com/my-app:latest'));
		assertThat(this.buildImage.createRequest().getTags()).containsExactly(ImageReference.of('my-app:latest'),
				ImageReference.of('example.com/my-app:0.0.1-SNAPSHOT'), ImageReference.of('example.com/my-app:latest'));
	}
	@Test
	void whenEntriesAreAddedToTagsThenRequestHasTags() {
		this.buildImage.getTags()
			.addAll(Arrays.asList('my-app:latest', 'example.com/my-app:0.0.1-SNAPSHOT', 'example.com/my-app:latest'));
		assertThat(this.buildImage.createRequest().getTags()).containsExactly(ImageReference.of('my-app:latest'),
				ImageReference.of('example.com/my-app:0.0.1-SNAPSHOT'), ImageReference.of('example.com/my-app:latest'));
	}
	@Test
	void whenIndividualEntriesAreAddedToTagsThenRequestHasTags() {
		this.buildImage.getTags().add('my-app:latest');
		this.buildImage.getTags().add('example.com/my-app:0.0.1-SNAPSHOT');
		this.buildImage.getTags().add('example.com/my-app:latest');
		assertThat(this.buildImage.createRequest().getTags()).containsExactly(ImageReference.of('my-app:latest'),
				ImageReference.of('example.com/my-app:0.0.1-SNAPSHOT'), ImageReference.of('example.com/my-app:latest'));
	}
	@Test
	void whenSecurityOptionsAreNotConfiguredThenRequestHasNoSecurityOptions() {
		assertThat(this.buildImage.createRequest().getSecurityOptions()).isNull();
	}
	@Test
	void whenSecurityOptionsAreEmptyThenRequestHasEmptySecurityOptions() {
		this.buildImage.getSecurityOptions().set(Collections.emptyList());
		assertThat(this.buildImage.createRequest().getSecurityOptions()).isEmpty();
	}
	@Test
	void whenSecurityOptionsAreConfiguredThenRequestHasSecurityOptions() {
		this.buildImage.getSecurityOptions().add('label=user:USER');
		this.buildImage.getSecurityOptions().add('label=role:ROLE');
		assertThat(this.buildImage.createRequest().getSecurityOptions()).containsExactly('label=user:USER',
				'label=role:ROLE');
	}
	@Test
	void whenImagePlatformIsNotConfiguredThenRequestHasNoImagePlatform() {
		assertThat(this.buildImage.createRequest().getImagePlatform()).isNull();
	}
	@Test
	void whenImagePlatformIsConfiguredThenRequestHasImagePlatform() {
		this.buildImage.getImagePlatform().set('linux/arm64/v1');
		assertThat(this.buildImage.createRequest().getImagePlatform()).isEqualTo(ImagePlatform.of('linux/arm64/v1'));
	}
}
/*
package com.example.bootrun.classpath;
/**
public class BootRunClasspathApplication {
	protected BootRunClasspathApplication() {
	}
	public static void main(String[] args) {
		System.out.println('Main class name = ' + BootRunClasspathApplication.class.getName());
		int i = 1;
		for (String entry : ManagementFactory.getRuntimeMXBean().getClassPath().split(File.pathSeparator)) {
			System.out.println(i++ + '. ' + entry);
		}
	}
}
/*
package com.example.bootrun.jvmargs;
/**
public class BootRunJvmArgsApplication {
	protected BootRunJvmArgsApplication() {
	}
	public static void main(String[] args) {
		int i = 1;
		for (String entry : ManagementFactory.getRuntimeMXBean().getInputArguments()) {
			System.out.println(i++ + '. ' + entry);
		}
	}
}
/*
package com.example.bootrun.main;
/**
public class CustomMainClass {
	protected CustomMainClass() {
	}
	public static void main(String[] args) {
		System.out.println(CustomMainClass.class.getName());
	}
}
/*
package com.example.bootjar.classpath;
/**
public class BootJarClasspathApplication {
	protected BootJarClasspathApplication() {
	}
	public static void main(String[] args) {
		int i = 1;
		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
		for (URL url : ((URLClassLoader) classLoader).getURLs()) {
			System.out.println(i++ + '. ' + url.getFile());
		}
	}
}
/*
package com.example.bootjar.main;
/**
public class CustomMainClass {
	protected CustomMainClass() {
	}
	public static void main(String[] args) {
		System.out.println(CustomMainClass.class.getName());
	}
}
/*
package com.example.bootwar.main;
/**
public class CustomMainClass {
	protected CustomMainClass() {
	}
	public static void main(String[] args) {
		System.out.println(CustomMainClass.class.getName());
	}
}
/*
package com.example.boottestrun.classpath;
/**
public class BootTestRunClasspathApplication {
	protected BootTestRunClasspathApplication() {
	}
	public static void main(String[] args) {
		System.out.println('Main class name = ' + BootTestRunClasspathApplication.class.getName());
		int i = 1;
		for (String entry : ManagementFactory.getRuntimeMXBean().getClassPath().split(File.pathSeparator)) {
			System.out.println(i++ + '. ' + entry);
		}
	}
}
/*
package com.example.boottestrun.jvmargs;
/**
public class BootTestRunJvmArgsApplication {
	protected BootTestRunJvmArgsApplication() {
	}
	public static void main(String[] args) {
		int i = 1;
		for (String entry : ManagementFactory.getRuntimeMXBean().getInputArguments()) {
			System.out.println(i++ + '. ' + entry);
		}
	}
}
/*
package com.example.boottestrun.nomain;
/**
public class BootTestRunNoMain {
}
/*
package org.springframework.boot.gradle.plugin;
/**
@DisableCachingByDefault(because = 'Not worth caching')
public class ResolveMainClassName extends DefaultTask {
	private static final String SPRING_BOOT_APPLICATION_CLASS_NAME = 'org.springframework.boot.autoconfigure.SpringBootApplication';
	private final RegularFileProperty outputFile;
	private final Property<String> configuredMainClass;
	private FileCollection classpath;
	/**
	 * Creates a new instance of the {@code ResolveMainClassName} task.
	 */
	public ResolveMainClassName() {
		this.outputFile = getProject().getObjects().fileProperty();
		this.configuredMainClass = getProject().getObjects().property(String.class);
	}
	/**
	 * Returns the classpath that the task will examine when resolving the main class
	 * name.
	 * @return the classpath
	 */
	@Classpath
	public FileCollection getClasspath() {
		return this.classpath;
	}
	/**
	 * Sets the classpath that the task will examine when resolving the main class name.
	 * @param classpath the classpath
	 */
	public void setClasspath(FileCollection classpath) {
		setClasspath((Object) classpath);
	}
	/**
	 * Sets the classpath that the task will examine when resolving the main class name.
	 * The given {@code classpath} is evaluated as per {@link Project#files(Object...)}.
	 * @param classpath the classpath
	 * @since 2.5.10
	 */
	public void setClasspath(Object classpath) {
		this.classpath = getProject().files(classpath);
	}
	/**
	 * Returns the property for the task"s output file that will contain the name of the
	 * main class.
	 * @return the output file
	 */
	@OutputFile
	public RegularFileProperty getOutputFile() {
		return this.outputFile;
	}
	/**
	 * Returns the property for the explicitly configured main class name that should be
	 * used in favor of resolving the main class name from the classpath.
	 * @return the configured main class name property
	 */
	@Input
	@Optional
	public Property<String> getConfiguredMainClassName() {
		return this.configuredMainClass;
	}
	@TaskAction
	void resolveAndStoreMainClassName() throws IOException {
		File outputFile = this.outputFile.getAsFile().get();
		outputFile.getParentFile().mkdirs();
		String mainClassName = resolveMainClassName();
		Files.writeString(outputFile.toPath(), mainClassName, StandardOpenOption.WRITE, StandardOpenOption.CREATE,
				StandardOpenOption.TRUNCATE_EXISTING);
	}
	private String resolveMainClassName() {
		String configuredMainClass = this.configuredMainClass.getOrNull();
		if (configuredMainClass != null) {
			return configuredMainClass;
		}
		return getClasspath().filter(File::isDirectory)
			.getFiles()
			.stream()
			.map(this::findMainClass)
			.filter(Objects::nonNull)
			.findFirst()
			.orElse('');
	}
	private String findMainClass(File file) {
		try {
			return MainClassFinder.findSingleMainClass(file, SPRING_BOOT_APPLICATION_CLASS_NAME);
		}
		catch (IOException ex) {
			return null;
		}
	}
	Provider<String> readMainClassName() {
		String classpath = getClasspath().filter(File::isDirectory)
			.getFiles()
			.stream()
			.map(File::getAbsolutePath)
			.collect(Collectors.joining(File.pathSeparator));
		return this.outputFile.map(new ClassNameReader(classpath));
	}
	private static final class ClassNameReader implements Transformer<String, RegularFile> {
		private final String classpath;
		private ClassNameReader(String classpath) {
			this.classpath = classpath;
		}
		@Override
		public String transform(RegularFile file) {
			if (file.getAsFile().length() == 0) {
				throw new InvalidUserDataException(
						'Main class name has not been configured and it could not be resolved from classpath '
								+ this.classpath);
			}
			Path output = file.getAsFile().toPath();
			try {
				return Files.readString(output);
			}
			catch (IOException ex) {
				throw new RuntimeException('Failed to read main class name from "' + output + '"');
			}
		}
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
public class SpringBootAotPlugin implements Plugin<Project> {
	/**
	 * Name of the main {@code aot} {@link SourceSet source set}.
	 */
	public static final String AOT_SOURCE_SET_NAME = 'aot';
	/**
	 * Name of the {@code aotTest} {@link SourceSet source set}.
	 */
	public static final String AOT_TEST_SOURCE_SET_NAME = 'aotTest';
	/**
	 * Name of the default {@link ProcessAot} task.
	 */
	public static final String PROCESS_AOT_TASK_NAME = 'processAot';
	/**
	 * Name of the default {@link ProcessAot} task.
	 */
	public static final String PROCESS_TEST_AOT_TASK_NAME = 'processTestAot';
	@Override
	public void apply(Project project) {
		PluginContainer plugins = project.getPlugins();
		plugins.withType(JavaPlugin.class).all((javaPlugin) -> {
			JavaPluginExtension javaPluginExtension = project.getExtensions().getByType(JavaPluginExtension.class);
			SourceSetContainer sourceSets = javaPluginExtension.getSourceSets();
			SourceSet mainSourceSet = sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
			SourceSet aotSourceSet = configureSourceSet(project, AOT_SOURCE_SET_NAME, mainSourceSet);
			SourceSet testSourceSet = sourceSets.getByName(SourceSet.TEST_SOURCE_SET_NAME);
			SourceSet aotTestSourceSet = configureSourceSet(project, AOT_TEST_SOURCE_SET_NAME, testSourceSet);
			plugins.withType(SpringBootPlugin.class).all((bootPlugin) -> {
				registerProcessAotTask(project, aotSourceSet, mainSourceSet);
				registerProcessTestAotTask(project, mainSourceSet, aotTestSourceSet, testSourceSet);
			});
		});
	}
	private SourceSet configureSourceSet(Project project, String newSourceSetName, SourceSet existingSourceSet) {
		JavaPluginExtension javaPluginExtension = project.getExtensions().getByType(JavaPluginExtension.class);
		SourceSetContainer sourceSets = javaPluginExtension.getSourceSets();
		return sourceSets.create(newSourceSetName, (sourceSet) -> {
			existingSourceSet.setRuntimeClasspath(existingSourceSet.getRuntimeClasspath().plus(sourceSet.getOutput()));
			project.getConfigurations()
				.getByName(sourceSet.getCompileClasspathConfigurationName())
				.attributes((attributes) -> {
					configureClassesAndResourcesLibraryElementsAttribute(project, attributes);
					configureJavaRuntimeUsageAttribute(project, attributes);
				});
		});
	}
	private void configureClassesAndResourcesLibraryElementsAttribute(Project project, AttributeContainer attributes) {
		LibraryElements classesAndResources = project.getObjects()
			.named(LibraryElements.class, LibraryElements.CLASSES_AND_RESOURCES);
		attributes.attribute(LibraryElements.LIBRARY_ELEMENTS_ATTRIBUTE, classesAndResources);
	}
	private void configureJavaRuntimeUsageAttribute(Project project, AttributeContainer attributes) {
		Usage javaRuntime = project.getObjects().named(Usage.class, Usage.JAVA_RUNTIME);
		attributes.attribute(Usage.USAGE_ATTRIBUTE, javaRuntime);
	}
	private void registerProcessAotTask(Project project, SourceSet aotSourceSet, SourceSet mainSourceSet) {
		TaskProvider<ResolveMainClassName> resolveMainClassName = project.getTasks()
			.named(SpringBootPlugin.RESOLVE_MAIN_CLASS_NAME_TASK_NAME, ResolveMainClassName.class);
		Configuration aotClasspath = createAotProcessingClasspath(project, PROCESS_AOT_TASK_NAME, mainSourceSet,
				Set.of(SpringBootPlugin.DEVELOPMENT_ONLY_CONFIGURATION_NAME,
						SpringBootPlugin.TEST_AND_DEVELOPMENT_ONLY_CONFIGURATION_NAME));
		project.getDependencies().add(aotClasspath.getName(), project.files(mainSourceSet.getOutput()));
		Configuration compileClasspath = project.getConfigurations()
			.getByName(aotSourceSet.getCompileClasspathConfigurationName());
		compileClasspath.extendsFrom(aotClasspath);
		Provider<Directory> resourcesOutput = project.getLayout()
			.getBuildDirectory()
			.dir('generated/' + aotSourceSet.getName() + 'Resources');
		TaskProvider<ProcessAot> processAot = project.getTasks()
			.register(PROCESS_AOT_TASK_NAME, ProcessAot.class, (task) -> {
				configureAotTask(project, aotSourceSet, task, resourcesOutput);
				task.getApplicationMainClass()
					.set(resolveMainClassName.flatMap(ResolveMainClassName::readMainClassName));
				task.setClasspath(aotClasspath);
			});
		aotSourceSet.getJava().srcDir(processAot.map(ProcessAot::getSourcesOutput));
		aotSourceSet.getResources().srcDir(resourcesOutput);
		ConfigurableFileCollection classesOutputFiles = project.files(processAot.map(ProcessAot::getClassesOutput));
		mainSourceSet.setRuntimeClasspath(mainSourceSet.getRuntimeClasspath().plus(classesOutputFiles));
		project.getDependencies().add(aotSourceSet.getImplementationConfigurationName(), classesOutputFiles);
		configureDependsOn(project, aotSourceSet, processAot);
	}
	private void configureAotTask(Project project, SourceSet sourceSet, AbstractAot task,
			Provider<Directory> resourcesOutput) {
		task.getSourcesOutput()
			.set(project.getLayout().getBuildDirectory().dir('generated/' + sourceSet.getName() + 'Sources'));
		task.getResourcesOutput().set(resourcesOutput);
		task.getClassesOutput()
			.set(project.getLayout().getBuildDirectory().dir('generated/' + sourceSet.getName() + 'Classes'));
		task.getGroupId().set(project.provider(() -> String.valueOf(project.getGroup())));
		task.getArtifactId().set(project.provider(project::getName));
		configureToolchainConvention(project, task);
	}
	private void configureToolchainConvention(Project project, AbstractAot aotTask) {
		JavaToolchainSpec toolchain = project.getExtensions().getByType(JavaPluginExtension.class).getToolchain();
		JavaToolchainService toolchainService = project.getExtensions().getByType(JavaToolchainService.class);
		aotTask.getJavaLauncher().convention(toolchainService.launcherFor(toolchain));
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private Configuration createAotProcessingClasspath(Project project, String taskName, SourceSet inputSourceSet,
			Set<String> developmentOnlyConfigurationNames) {
		Configuration base = project.getConfigurations()
			.getByName(inputSourceSet.getRuntimeClasspathConfigurationName());
		return project.getConfigurations().create(taskName + 'Classpath', (classpath) -> {
			classpath.setCanBeConsumed(false);
			if (!classpath.isCanBeResolved()) {
				throw new IllegalStateException('Unexpected');
			}
			classpath.setCanBeResolved(true);
			classpath.setDescription('Classpath of the ' + taskName + ' task.');
			removeDevelopmentOnly(base.getExtendsFrom(), developmentOnlyConfigurationNames)
				.forEach(classpath::extendsFrom);
			classpath.attributes((attributes) -> {
				ProviderFactory providers = project.getProviders();
				AttributeContainer baseAttributes = base.getAttributes();
				for (Attribute attribute : baseAttributes.keySet()) {
					attributes.attributeProvider(attribute,
							providers.provider(() -> baseAttributes.getAttribute(attribute)));
				}
			});
		});
	}
	private Stream<Configuration> removeDevelopmentOnly(Set<Configuration> configurations,
			Set<String> developmentOnlyConfigurationNames) {
		return configurations.stream()
			.filter((configuration) -> !developmentOnlyConfigurationNames.contains(configuration.getName()));
	}
	private void configureDependsOn(Project project, SourceSet aotSourceSet,
			TaskProvider<? extends AbstractAot> processAot) {
		project.getTasks()
			.named(aotSourceSet.getProcessResourcesTaskName())
			.configure((processResources) -> processResources.dependsOn(processAot));
	}
	private void registerProcessTestAotTask(Project project, SourceSet mainSourceSet, SourceSet aotTestSourceSet,
			SourceSet testSourceSet) {
		Configuration aotClasspath = createAotProcessingClasspath(project, PROCESS_TEST_AOT_TASK_NAME, testSourceSet,
				Set.of(SpringBootPlugin.DEVELOPMENT_ONLY_CONFIGURATION_NAME));
		addJUnitPlatformLauncherDependency(project, aotClasspath);
		Configuration compileClasspath = project.getConfigurations()
			.getByName(aotTestSourceSet.getCompileClasspathConfigurationName());
		compileClasspath.extendsFrom(aotClasspath);
		Provider<Directory> resourcesOutput = project.getLayout()
			.getBuildDirectory()
			.dir('generated/' + aotTestSourceSet.getName() + 'Resources');
		TaskProvider<ProcessTestAot> processTestAot = project.getTasks()
			.register(PROCESS_TEST_AOT_TASK_NAME, ProcessTestAot.class, (task) -> {
				configureAotTask(project, aotTestSourceSet, task, resourcesOutput);
				task.setClasspath(aotClasspath);
				task.setClasspathRoots(testSourceSet.getOutput());
			});
		aotTestSourceSet.getJava().srcDir(processTestAot.map(ProcessTestAot::getSourcesOutput));
		aotTestSourceSet.getResources().srcDir(resourcesOutput);
		project.getDependencies().add(aotClasspath.getName(), project.files(mainSourceSet.getOutput()));
		project.getDependencies().add(aotClasspath.getName(), project.files(testSourceSet.getOutput()));
		ConfigurableFileCollection classesOutputFiles = project
			.files(processTestAot.map(ProcessTestAot::getClassesOutput));
		testSourceSet.setRuntimeClasspath(testSourceSet.getRuntimeClasspath().plus(classesOutputFiles));
		project.getDependencies().add(aotTestSourceSet.getImplementationConfigurationName(), classesOutputFiles);
		configureDependsOn(project, aotTestSourceSet, processTestAot);
	}
	private void addJUnitPlatformLauncherDependency(Project project, Configuration configuration) {
		DependencyHandler dependencyHandler = project.getDependencies();
		Dependency springBootDependencies = dependencyHandler
			.create(dependencyHandler.platform(SpringBootPlugin.BOM_COORDINATES));
		DependencySet dependencies = configuration.getDependencies();
		dependencies.add(springBootDependencies);
		dependencies.add(dependencyHandler.create('org.junit.platform:junit-platform-launcher'));
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
public class SpringBootPlugin implements Plugin<Project> {
	private static final String SPRING_BOOT_VERSION = VersionExtractor.forClass(DependencyManagementPluginAction.class);
	/**
	 * The name of the {@link Configuration} that contains Spring Boot archives.
	 * @since 2.0.0
	 */
	public static final String BOOT_ARCHIVES_CONFIGURATION_NAME = 'bootArchives';
	/**
	 * The name of the default {@link BootJar} task.
	 * @since 2.0.0
	 */
	public static final String BOOT_JAR_TASK_NAME = 'bootJar';
	/**
	 * The name of the default {@link BootWar} task.
	 * @since 2.0.0
	 */
	public static final String BOOT_WAR_TASK_NAME = 'bootWar';
	/**
	 * The name of the default {@link BootBuildImage} task.
	 * @since 2.3.0
	 */
	public static final String BOOT_BUILD_IMAGE_TASK_NAME = 'bootBuildImage';
	static final String BOOT_RUN_TASK_NAME = 'bootRun';
	static final String BOOT_TEST_RUN_TASK_NAME = 'bootTestRun';
	/**
	 * The name of the {@code developmentOnly} configuration.
	 * @since 2.3.0
	 */
	public static final String DEVELOPMENT_ONLY_CONFIGURATION_NAME = 'developmentOnly';
	/**
	 * The name of the {@code testAndDevelopmentOnly} configuration.
	 * @since 3.2.0
	 */
	public static final String TEST_AND_DEVELOPMENT_ONLY_CONFIGURATION_NAME = 'testAndDevelopmentOnly';
	/**
	 * The name of the {@code productionRuntimeClasspath} configuration.
	 */
	public static final String PRODUCTION_RUNTIME_CLASSPATH_CONFIGURATION_NAME = 'productionRuntimeClasspath';
	/**
	 * The name of the {@link ResolveMainClassName} task used to resolve a main class from
	 * the output of the {@code main} source set.
	 * @since 3.0.0
	 */
	public static final String RESOLVE_MAIN_CLASS_NAME_TASK_NAME = 'resolveMainClassName';
	/**
	 * The name of the {@link ResolveMainClassName} task used to resolve a main class from
	 * the output of the {@code test} source set then, if needed, the output of the
	 * {@code main} source set.
	 * @since 3.1.0
	 */
	public static final String RESOLVE_TEST_MAIN_CLASS_NAME_TASK_NAME = 'resolveTestMainClassName';
	/**
	 * The coordinates {@code (group:name:version)} of the
	 * {@code spring-boot-dependencies} bom.
	 */
	public static final String BOM_COORDINATES = 'org.springframework.boot:spring-boot-dependencies:'
			+ SPRING_BOOT_VERSION;
	@Override
	public void apply(Project project) {
		createExtension(project);
		Configuration bootArchives = createBootArchivesConfiguration(project);
		registerPluginActions(project, bootArchives);
	}
	private void createExtension(Project project) {
		project.getExtensions().create('springBoot', SpringBootExtension.class, project);
	}
	private Configuration createBootArchivesConfiguration(Project project) {
		Configuration bootArchives = project.getConfigurations().create(BOOT_ARCHIVES_CONFIGURATION_NAME);
		bootArchives.setDescription('Configuration for Spring Boot archive artifacts.');
		bootArchives.setCanBeResolved(false);
		return bootArchives;
	}
	private void registerPluginActions(Project project, Configuration bootArchives) {
		SinglePublishedArtifact singlePublishedArtifact = new SinglePublishedArtifact(bootArchives,
				project.getArtifacts());
		List<PluginApplicationAction> actions = Arrays.asList(new JavaPluginAction(singlePublishedArtifact),
				new WarPluginAction(singlePublishedArtifact), new DependencyManagementPluginAction(),
				new ApplicationPluginAction(), new KotlinPluginAction(), new NativeImagePluginAction(),
				new CycloneDxPluginAction());
		for (PluginApplicationAction action : actions) {
			withPluginClassOfAction(action,
					(pluginClass) -> project.getPlugins().withType(pluginClass, (plugin) -> action.execute(project)));
		}
	}
	private void withPluginClassOfAction(PluginApplicationAction action,
			Consumer<Class<? extends Plugin<? extends Project>>> consumer) {
		Class<? extends Plugin<? extends Project>> pluginClass;
		try {
			pluginClass = action.getPluginClass();
		}
		catch (Throwable ex) {
			// Plugin class unavailable.
			return;
		}
		consumer.accept(pluginClass);
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
final class DependencyManagementPluginAction implements PluginApplicationAction {
	@Override
	public void execute(Project project) {
		project.getExtensions()
			.findByType(DependencyManagementExtension.class)
			.imports((importsHandler) -> importsHandler.mavenBom(SpringBootPlugin.BOM_COORDINATES));
	}
	@Override
	public Class<? extends Plugin<Project>> getPluginClass() {
		return DependencyManagementPlugin.class;
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
final class JavaPluginAction implements PluginApplicationAction {
	private static final String PARAMETERS_COMPILER_ARG = '-parameters';
	private final SinglePublishedArtifact singlePublishedArtifact;
	JavaPluginAction(SinglePublishedArtifact singlePublishedArtifact) {
		this.singlePublishedArtifact = singlePublishedArtifact;
	}
	@Override
	public Class<? extends Plugin<? extends Project>> getPluginClass() {
		return JavaPlugin.class;
	}
	@Override
	public void execute(Project project) {
		classifyJarTask(project);
		configureBuildTask(project);
		configureProductionRuntimeClasspathConfiguration(project);
		configureDevelopmentOnlyConfiguration(project);
		configureTestAndDevelopmentOnlyConfiguration(project);
		TaskProvider<ResolveMainClassName> resolveMainClassName = configureResolveMainClassNameTask(project);
		TaskProvider<BootJar> bootJar = configureBootJarTask(project, resolveMainClassName);
		configureBootBuildImageTask(project, bootJar);
		configureArtifactPublication(bootJar);
		configureBootRunTask(project, resolveMainClassName);
		TaskProvider<ResolveMainClassName> resolveMainTestClassName = configureResolveMainTestClassNameTask(project);
		configureBootTestRunTask(project, resolveMainTestClassName);
		project.afterEvaluate(this::configureUtf8Encoding);
		configureParametersCompilerArg(project);
		configureAdditionalMetadataLocations(project);
	}
	private void classifyJarTask(Project project) {
		project.getTasks()
			.named(JavaPlugin.JAR_TASK_NAME, Jar.class)
			.configure((task) -> task.getArchiveClassifier().convention('plain'));
	}
	private void configureBuildTask(Project project) {
		project.getTasks()
			.named(BasePlugin.ASSEMBLE_TASK_NAME)
			.configure((task) -> task.dependsOn(this.singlePublishedArtifact));
	}
	private TaskProvider<ResolveMainClassName> configureResolveMainClassNameTask(Project project) {
		return project.getTasks()
			.register(SpringBootPlugin.RESOLVE_MAIN_CLASS_NAME_TASK_NAME, ResolveMainClassName.class,
					(resolveMainClassName) -> {
						ExtensionContainer extensions = project.getExtensions();
						resolveMainClassName.setDescription('Resolves the name of the application"s main class.');
						resolveMainClassName.setGroup(BasePlugin.BUILD_GROUP);
						Callable<FileCollection> classpath = () -> project.getExtensions()
							.getByType(SourceSetContainer.class)
							.getByName(SourceSet.MAIN_SOURCE_SET_NAME)
							.getOutput();
						resolveMainClassName.setClasspath(classpath);
						resolveMainClassName.getConfiguredMainClassName().convention(project.provider(() -> {
							String javaApplicationMainClass = getJavaApplicationMainClass(extensions);
							if (javaApplicationMainClass != null) {
								return javaApplicationMainClass;
							}
							SpringBootExtension springBootExtension = project.getExtensions()
								.findByType(SpringBootExtension.class);
							return springBootExtension.getMainClass().getOrNull();
						}));
						resolveMainClassName.getOutputFile()
							.set(project.getLayout().getBuildDirectory().file('resolvedMainClassName'));
					});
	}
	private TaskProvider<ResolveMainClassName> configureResolveMainTestClassNameTask(Project project) {
		return project.getTasks()
			.register(SpringBootPlugin.RESOLVE_TEST_MAIN_CLASS_NAME_TASK_NAME, ResolveMainClassName.class,
					(resolveMainClassName) -> {
						resolveMainClassName.setDescription('Resolves the name of the application"s test main class.');
						resolveMainClassName.setGroup(BasePlugin.BUILD_GROUP);
						Callable<FileCollection> classpath = () -> {
							SourceSetContainer sourceSets = project.getExtensions().getByType(SourceSetContainer.class);
							return project.files(sourceSets.getByName(SourceSet.TEST_SOURCE_SET_NAME).getOutput(),
									sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME).getOutput());
						};
						resolveMainClassName.setClasspath(classpath);
						resolveMainClassName.getOutputFile()
							.set(project.getLayout().getBuildDirectory().file('resolvedMainTestClassName'));
					});
	}
	private static String getJavaApplicationMainClass(ExtensionContainer extensions) {
		JavaApplication javaApplication = extensions.findByType(JavaApplication.class);
		if (javaApplication == null) {
			return null;
		}
		return javaApplication.getMainClass().getOrNull();
	}
	private TaskProvider<BootJar> configureBootJarTask(Project project,
			TaskProvider<ResolveMainClassName> resolveMainClassName) {
		SourceSet mainSourceSet = javaPluginExtension(project).getSourceSets()
			.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		Configuration developmentOnly = project.getConfigurations()
			.getByName(SpringBootPlugin.DEVELOPMENT_ONLY_CONFIGURATION_NAME);
		Configuration testAndDevelopmentOnly = project.getConfigurations()
			.getByName(SpringBootPlugin.TEST_AND_DEVELOPMENT_ONLY_CONFIGURATION_NAME);
		Configuration productionRuntimeClasspath = project.getConfigurations()
			.getByName(SpringBootPlugin.PRODUCTION_RUNTIME_CLASSPATH_CONFIGURATION_NAME);
		Configuration runtimeClasspath = project.getConfigurations()
			.getByName(mainSourceSet.getRuntimeClasspathConfigurationName());
		Callable<FileCollection> classpath = () -> mainSourceSet.getRuntimeClasspath()
			.minus((developmentOnly.minus(productionRuntimeClasspath)))
			.minus((testAndDevelopmentOnly.minus(productionRuntimeClasspath)))
			.filter(new JarTypeFileSpec());
		return project.getTasks().register(SpringBootPlugin.BOOT_JAR_TASK_NAME, BootJar.class, (bootJar) -> {
			bootJar.setDescription(
					'Assembles an executable jar archive containing the main classes and their dependencies.');
			bootJar.setGroup(BasePlugin.BUILD_GROUP);
			bootJar.classpath(classpath);
			Provider<String> manifestStartClass = project
				.provider(() -> (String) bootJar.getManifest().getAttributes().get('Start-Class'));
			bootJar.getMainClass()
				.convention(resolveMainClassName.flatMap((resolver) -> manifestStartClass.isPresent()
						? manifestStartClass : resolver.readMainClassName()));
			bootJar.getTargetJavaVersion()
				.set(project.provider(() -> javaPluginExtension(project).getTargetCompatibility()));
			bootJar.resolvedArtifacts(runtimeClasspath.getIncoming().getArtifacts().getResolvedArtifacts());
		});
	}
	private void configureBootBuildImageTask(Project project, TaskProvider<BootJar> bootJar) {
		project.getTasks().register(SpringBootPlugin.BOOT_BUILD_IMAGE_TASK_NAME, BootBuildImage.class, (buildImage) -> {
			buildImage.setDescription('Builds an OCI image of the application using the output of the bootJar task');
			buildImage.setGroup(BasePlugin.BUILD_GROUP);
			buildImage.getArchiveFile().set(bootJar.get().getArchiveFile());
		});
	}
	private void configureArtifactPublication(TaskProvider<BootJar> bootJar) {
		this.singlePublishedArtifact.addJarCandidate(bootJar);
	}
	private void configureBootRunTask(Project project, TaskProvider<ResolveMainClassName> resolveMainClassName) {
		Callable<FileCollection> classpath = () -> javaPluginExtension(project).getSourceSets()
			.findByName(SourceSet.MAIN_SOURCE_SET_NAME)
			.getRuntimeClasspath()
			.filter(new JarTypeFileSpec());
		project.getTasks().register(SpringBootPlugin.BOOT_RUN_TASK_NAME, BootRun.class, (run) -> {
			run.setDescription('Runs this project as a Spring Boot application.');
			run.setGroup(ApplicationPlugin.APPLICATION_GROUP);
			run.classpath(classpath);
			run.getMainClass().convention(resolveMainClassName.flatMap(ResolveMainClassName::readMainClassName));
			configureToolchainConvention(project, run);
		});
	}
	private void configureBootTestRunTask(Project project, TaskProvider<ResolveMainClassName> resolveMainClassName) {
		Callable<FileCollection> classpath = () -> javaPluginExtension(project).getSourceSets()
			.findByName(SourceSet.TEST_SOURCE_SET_NAME)
			.getRuntimeClasspath()
			.filter(new JarTypeFileSpec());
		project.getTasks().register('bootTestRun', BootRun.class, (run) -> {
			run.setDescription('Runs this project as a Spring Boot application using the test runtime classpath.');
			run.setGroup(ApplicationPlugin.APPLICATION_GROUP);
			run.classpath(classpath);
			run.getMainClass().convention(resolveMainClassName.flatMap(ResolveMainClassName::readMainClassName));
			configureToolchainConvention(project, run);
		});
	}
	private void configureToolchainConvention(Project project, BootRun run) {
		JavaToolchainSpec toolchain = project.getExtensions().getByType(JavaPluginExtension.class).getToolchain();
		JavaToolchainService toolchainService = project.getExtensions().getByType(JavaToolchainService.class);
		run.getJavaLauncher().convention(toolchainService.launcherFor(toolchain));
	}
	private JavaPluginExtension javaPluginExtension(Project project) {
		return project.getExtensions().getByType(JavaPluginExtension.class);
	}
	private void configureUtf8Encoding(Project evaluatedProject) {
		evaluatedProject.getTasks().withType(JavaCompile.class).configureEach(this::configureUtf8Encoding);
	}
	private void configureUtf8Encoding(JavaCompile compile) {
		if (compile.getOptions().getEncoding() == null) {
			compile.getOptions().setEncoding('UTF-8');
		}
	}
	private void configureParametersCompilerArg(Project project) {
		project.getTasks().withType(JavaCompile.class).configureEach((compile) -> {
			List<String> compilerArgs = compile.getOptions().getCompilerArgs();
			if (!compilerArgs.contains(PARAMETERS_COMPILER_ARG)) {
				compilerArgs.add(PARAMETERS_COMPILER_ARG);
			}
		});
	}
	private void configureAdditionalMetadataLocations(Project project) {
		project.afterEvaluate((evaluated) -> evaluated.getTasks()
			.withType(JavaCompile.class)
			.configureEach(this::configureAdditionalMetadataLocations));
	}
	private void configureAdditionalMetadataLocations(JavaCompile compile) {
		SourceSetContainer sourceSets = compile.getProject()
			.getExtensions()
			.getByType(JavaPluginExtension.class)
			.getSourceSets();
		sourceSets.stream()
			.filter((candidate) -> candidate.getCompileJavaTaskName().equals(compile.getName()))
			.map((match) -> match.getResources().getSrcDirs())
			.findFirst()
			.ifPresent((locations) -> compile.doFirst(new AdditionalMetadataLocationsConfigurer(locations)));
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private void configureProductionRuntimeClasspathConfiguration(Project project) {
		Configuration productionRuntimeClasspath = project.getConfigurations()
			.create(SpringBootPlugin.PRODUCTION_RUNTIME_CLASSPATH_CONFIGURATION_NAME);
		productionRuntimeClasspath.setVisible(false);
		Configuration runtimeClasspath = project.getConfigurations()
			.getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);
		productionRuntimeClasspath.attributes((attributes) -> {
			ProviderFactory providers = project.getProviders();
			AttributeContainer sourceAttributes = runtimeClasspath.getAttributes();
			for (Attribute attribute : sourceAttributes.keySet()) {
				attributes.attributeProvider(attribute,
						providers.provider(() -> sourceAttributes.getAttribute(attribute)));
			}
		});
		productionRuntimeClasspath.setExtendsFrom(runtimeClasspath.getExtendsFrom());
		productionRuntimeClasspath.setCanBeResolved(runtimeClasspath.isCanBeResolved());
		productionRuntimeClasspath.setCanBeConsumed(runtimeClasspath.isCanBeConsumed());
	}
	private void configureDevelopmentOnlyConfiguration(Project project) {
		Configuration developmentOnly = project.getConfigurations()
			.create(SpringBootPlugin.DEVELOPMENT_ONLY_CONFIGURATION_NAME);
		developmentOnly
			.setDescription('Configuration for development-only dependencies such as Spring Boot"s DevTools.');
		Configuration runtimeClasspath = project.getConfigurations()
			.getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);
		runtimeClasspath.extendsFrom(developmentOnly);
	}
	private void configureTestAndDevelopmentOnlyConfiguration(Project project) {
		Configuration testAndDevelopmentOnly = project.getConfigurations()
			.create(SpringBootPlugin.TEST_AND_DEVELOPMENT_ONLY_CONFIGURATION_NAME);
		testAndDevelopmentOnly
			.setDescription('Configuration for test and development-only dependencies such as Spring Boot"s DevTools.');
		Configuration runtimeClasspath = project.getConfigurations()
			.getByName(JavaPlugin.RUNTIME_CLASSPATH_CONFIGURATION_NAME);
		runtimeClasspath.extendsFrom(testAndDevelopmentOnly);
		Configuration testImplementation = project.getConfigurations()
			.getByName(JavaPlugin.TEST_IMPLEMENTATION_CONFIGURATION_NAME);
		testImplementation.extendsFrom(testAndDevelopmentOnly);
	}
	/**
	 * Task {@link Action} to add additional meta-data locations. We need to use an
	 * inner-class rather than a lambda due to
	 * https://github.com/gradle/gradle/issues/5510.
	 */
	private static final class AdditionalMetadataLocationsConfigurer implements Action<Task> {
		private final Set<File> locations;
		private AdditionalMetadataLocationsConfigurer(Set<File> locations) {
			this.locations = locations;
		}
		@Override
		public void execute(Task task) {
			if (!(task instanceof JavaCompile compile)) {
				return;
			}
			if (hasConfigurationProcessorOnClasspath(compile)) {
				configureAdditionalMetadataLocations(compile);
			}
		}
		private boolean hasConfigurationProcessorOnClasspath(JavaCompile compile) {
			Set<File> files = (compile.getOptions().getAnnotationProcessorPath() != null)
					? compile.getOptions().getAnnotationProcessorPath().getFiles() : compile.getClasspath().getFiles();
			return files.stream()
				.map(File::getName)
				.anyMatch((name) -> name.startsWith('spring-boot-configuration-processor'));
		}
		private void configureAdditionalMetadataLocations(JavaCompile compile) {
			compile.getOptions()
				.getCompilerArgs()
				.add('-Aorg.springframework.boot.configurationprocessor.additionalMetadataLocations='
						+ StringUtils.collectionToCommaDelimitedString(this.locations));
		}
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
final class ApplicationPluginAction implements PluginApplicationAction {
	@Override
	public void execute(Project project) {
		JavaApplication javaApplication = project.getExtensions().getByType(JavaApplication.class);
		DistributionContainer distributions = project.getExtensions().getByType(DistributionContainer.class);
		Distribution distribution = distributions.create('boot');
		distribution.getDistributionBaseName()
			.convention((project.provider(() -> javaApplication.getApplicationName() + '-boot')));
		TaskProvider<CreateStartScripts> bootStartScripts = project.getTasks()
			.register('bootStartScripts', CreateStartScripts.class,
					(task) -> configureCreateStartScripts(project, javaApplication, distribution, task));
		CopySpec binCopySpec = project.copySpec().into('bin').from(bootStartScripts);
		configureFilePermissions(binCopySpec, 0755);
		distribution.getContents().with(binCopySpec);
		applyApplicationDefaultJvmArgsToRunTasks(project.getTasks(), javaApplication);
	}
	private void applyApplicationDefaultJvmArgsToRunTasks(TaskContainer tasks, JavaApplication javaApplication) {
		applyApplicationDefaultJvmArgsToRunTask(tasks, javaApplication, SpringBootPlugin.BOOT_RUN_TASK_NAME);
		applyApplicationDefaultJvmArgsToRunTask(tasks, javaApplication, SpringBootPlugin.BOOT_TEST_RUN_TASK_NAME);
	}
	private void applyApplicationDefaultJvmArgsToRunTask(TaskContainer tasks, JavaApplication javaApplication,
			String taskName) {
		tasks.named(taskName, BootRun.class)
			.configure((bootRun) -> bootRun.getConventionMapping()
				.map('jvmArgs', javaApplication::getApplicationDefaultJvmArgs));
	}
	private void configureCreateStartScripts(Project project, JavaApplication javaApplication,
			Distribution distribution, CreateStartScripts createStartScripts) {
		createStartScripts
			.setDescription('Generates OS-specific start scripts to run the project as a Spring Boot application.');
		((TemplateBasedScriptGenerator) createStartScripts.getUnixStartScriptGenerator())
			.setTemplate(project.getResources().getText().fromString(loadResource('/unixStartScript.txt')));
		((TemplateBasedScriptGenerator) createStartScripts.getWindowsStartScriptGenerator())
			.setTemplate(project.getResources().getText().fromString(loadResource('/windowsStartScript.txt')));
		project.getConfigurations().all((configuration) -> {
			if ('bootArchives'.equals(configuration.getName())) {
				distribution.getContents().with(artifactFilesToLibCopySpec(project, configuration));
				createStartScripts.setClasspath(configuration.getArtifacts().getFiles());
			}
		});
		createStartScripts.getConventionMapping()
			.map('outputDir', () -> project.getLayout().getBuildDirectory().dir('bootScripts').get().getAsFile());
		createStartScripts.getConventionMapping().map('applicationName', javaApplication::getApplicationName);
		createStartScripts.getConventionMapping().map('defaultJvmOpts', javaApplication::getApplicationDefaultJvmArgs);
	}
	private CopySpec artifactFilesToLibCopySpec(Project project, Configuration configuration) {
		CopySpec copySpec = project.copySpec().into('lib').from(artifactFiles(configuration));
		configureFilePermissions(copySpec, 0644);
		return copySpec;
	}
	private Callable<FileCollection> artifactFiles(Configuration configuration) {
		return () -> configuration.getArtifacts().getFiles();
	}
	@Override
	public Class<? extends Plugin<Project>> getPluginClass() {
		return ApplicationPlugin.class;
	}
	private String loadResource(String name) {
		try (InputStreamReader reader = new InputStreamReader(getClass().getResourceAsStream(name))) {
			char[] buffer = new char[4096];
			int read;
			StringWriter writer = new StringWriter();
			while ((read = reader.read(buffer)) > 0) {
				writer.write(buffer, 0, read);
			}
			return writer.toString();
		}
		catch (IOException ex) {
			throw new GradleException('Failed to read "' + name + '"', ex);
		}
	}
	private void configureFilePermissions(CopySpec copySpec, int mode) {
		if (GradleVersion.current().compareTo(GradleVersion.version('8.3')) >= 0) {
			copySpec.filePermissions((filePermissions) -> filePermissions.unix(Integer.toString(mode, 8)));
		}
		else {
			configureFileMode(copySpec, mode);
		}
	}
	@SuppressWarnings('deprecation')
	private void configureFileMode(CopySpec copySpec, int mode) {
		copySpec.setFileMode(mode);
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
final class SinglePublishedArtifact implements Buildable {
	private final Configuration configuration;
	private final ArtifactHandler handler;
	private PublishArtifact currentArtifact;
	SinglePublishedArtifact(Configuration configuration, ArtifactHandler handler) {
		this.configuration = configuration;
		this.handler = handler;
	}
	void addWarCandidate(TaskProvider<BootWar> candidate) {
		add(candidate);
	}
	void addJarCandidate(TaskProvider<BootJar> candidate) {
		if (this.currentArtifact == null) {
			add(candidate);
		}
	}
	private void add(TaskProvider<? extends Jar> artifact) {
		this.configuration.getArtifacts().remove(this.currentArtifact);
		this.currentArtifact = this.handler.add(this.configuration.getName(), artifact);
	}
	@Override
	public TaskDependency getBuildDependencies() {
		return this.configuration.getArtifacts().getBuildDependencies();
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
interface PluginApplicationAction extends Action<Project> {
	/**
	 * The class of the {@code Plugin} that, when applied, will trigger the execution of
	 * this action.
	 * @return the plugin class
	 * @throws ClassNotFoundException if the plugin class cannot be found
	 * @throws NoClassDefFoundError if an error occurs when defining the plugin class
	 */
	Class<? extends Plugin<? extends Project>> getPluginClass() throws ClassNotFoundException, NoClassDefFoundError;
}
/*
package org.springframework.boot.gradle.plugin;
/**
class KotlinPluginAction implements PluginApplicationAction {
	@Override
	public void execute(Project project) {
		ExtraPropertiesExtension extraProperties = project.getExtensions().getExtraProperties();
		if (!extraProperties.has('kotlin.version')) {
			String kotlinVersion = getKotlinVersion(project);
			extraProperties.set('kotlin.version', kotlinVersion);
		}
		enableJavaParametersOption(project);
	}
	private String getKotlinVersion(Project project) {
		return KotlinPluginWrapperKt.getKotlinPluginVersion(project);
	}
	private void enableJavaParametersOption(Project project) {
		project.getTasks()
			.withType(KotlinCompile.class)
			.configureEach((compile) -> compile.getKotlinOptions().setJavaParameters(true));
	}
	@Override
	public Class<? extends Plugin<? extends Project>> getPluginClass() {
		return KotlinPluginWrapper.class;
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
final class CycloneDxPluginAction implements PluginApplicationAction {
	@Override
	public Class<? extends Plugin<? extends Project>> getPluginClass() {
		return CycloneDxPlugin.class;
	}
	@Override
	public void execute(Project project) {
		TaskProvider<CycloneDxTask> cycloneDxTaskProvider = project.getTasks()
			.named('cyclonedxBom', CycloneDxTask.class);
		configureCycloneDxTask(cycloneDxTaskProvider);
		configureJavaPlugin(project, cycloneDxTaskProvider);
		configureSpringBootPlugin(project, cycloneDxTaskProvider);
	}
	private void configureCycloneDxTask(TaskProvider<CycloneDxTask> taskProvider) {
		taskProvider.configure((task) -> {
			task.getProjectType().convention('application');
			task.getOutputFormat().convention('json');
			task.getOutputName().convention('application.cdx');
			task.getIncludeLicenseText().convention(false);
		});
	}
	private void configureJavaPlugin(Project project, TaskProvider<CycloneDxTask> cycloneDxTaskProvider) {
		configurePlugin(project, JavaPlugin.class, (javaPlugin) -> {
			JavaPluginExtension javaPluginExtension = project.getExtensions().getByType(JavaPluginExtension.class);
			SourceSet main = javaPluginExtension.getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME);
			configureTask(project, main.getProcessResourcesTaskName(), Copy.class, (copy) -> {
				copy.dependsOn(cycloneDxTaskProvider);
				Provider<String> sbomFileName = cycloneDxTaskProvider
					.map((cycloneDxTask) -> cycloneDxTask.getOutputName().get() + getSbomExtension(cycloneDxTask));
				copy.from(cycloneDxTaskProvider, (spec) -> spec.include(sbomFileName.get()).into('META-INF/sbom'));
			});
		});
	}
	private void configureSpringBootPlugin(Project project, TaskProvider<CycloneDxTask> cycloneDxTaskProvider) {
		configurePlugin(project, SpringBootPlugin.class, (springBootPlugin) -> {
			configureBootJarTask(project, cycloneDxTaskProvider);
			configureBootWarTask(project, cycloneDxTaskProvider);
		});
	}
	private void configureBootJarTask(Project project, TaskProvider<CycloneDxTask> cycloneDxTaskProvider) {
		configureTask(project, SpringBootPlugin.BOOT_JAR_TASK_NAME, BootJar.class,
				(bootJar) -> configureBootJarTask(bootJar, cycloneDxTaskProvider));
	}
	private void configureBootWarTask(Project project, TaskProvider<CycloneDxTask> cycloneDxTaskProvider) {
		configureTask(project, SpringBootPlugin.BOOT_WAR_TASK_NAME, BootWar.class,
				(bootWar) -> configureBootWarTask(bootWar, cycloneDxTaskProvider));
	}
	private void configureBootJarTask(BootJar task, TaskProvider<CycloneDxTask> cycloneDxTaskProvider) {
		configureJarTask(task, cycloneDxTaskProvider);
	}
	private void configureBootWarTask(BootWar task, TaskProvider<CycloneDxTask> cycloneDxTaskProvider) {
		configureJarTask(task, cycloneDxTaskProvider);
	}
	private void configureJarTask(Jar task, TaskProvider<CycloneDxTask> cycloneDxTaskProvider) {
		Provider<String> sbomFileName = cycloneDxTaskProvider.map((cycloneDxTask) -> 'META-INF/sbom/'
				+ cycloneDxTask.getOutputName().get() + getSbomExtension(cycloneDxTask));
		task.manifest((manifest) -> {
			manifest.getAttributes().put('Sbom-Format', 'CycloneDX');
			manifest.getAttributes().put('Sbom-Location', sbomFileName);
		});
	}
	private String getSbomExtension(CycloneDxTask task) {
		String format = task.getOutputFormat().get();
		if ('all'.equals(format)) {
			return '.json';
		}
		return '.' + format;
	}
	private <T extends Task> void configureTask(Project project, String name, Class<T> type, Action<T> action) {
		project.getTasks().withType(type).configureEach((task) -> {
			if (task.getName().equals(name)) {
				action.execute(task);
			}
		});
	}
	private <T extends Plugin<?>> void configurePlugin(Project project, Class<T> plugin, Action<T> action) {
		project.getPlugins().withType(plugin, action);
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
class JarTypeFileSpec implements Spec<File> {
	private static final Set<String> EXCLUDED_JAR_TYPES = Collections.singleton('dependencies-starter');
	@Override
	public boolean isSatisfiedBy(File file) {
		try (JarFile jar = new JarFile(file)) {
			String jarType = jar.getManifest().getMainAttributes().getValue('Spring-Boot-Jar-Type');
			if (jarType != null && EXCLUDED_JAR_TYPES.contains(jarType)) {
				return false;
			}
		}
		catch (Exception ex) {
			// Continue
		}
		return true;
	}
}
/*
package org.springframework.boot.gradle.plugin;
/**
class WarPluginAction implements PluginApplicationAction {
	private final SinglePublishedArtifact singlePublishedArtifact;
	WarPluginAction(SinglePublishedArtifact singlePublishedArtifact) {
		this.singlePublishedArtifact = singlePublishedArtifact;
	}
	@Override
	public Class<? extends Plugin<? extends Project>> getPluginClass() {
		return WarPlugin.class;
	}
	@Override
	public void execute(Project project) {
		classifyWarTask(project);
		TaskProvider<BootWar> bootWar = configureBootWarTask(project);
		configureBootBuildImageTask(project, bootWar);
		configureArtifactPublication(bootWar);
	}
	private void classifyWarTask(Project project) {
		project.getTasks()
			.named(WarPlugin.WAR_TASK_NAME, War.class)
			.configure((war) -> war.getArchiveClassifier().convention('plain'));
	}
	private TaskProvider<BootWar> configureBootWarTask(Project project) {
		Configuration developmentOnly = project.getConfigurations()
			.getByName(SpringBootPlugin.DEVELOPMENT_ONLY_CONFIGURATION_NAME);
		Configuration testAndDevelopmentOnly = project.getConfigurations()
			.getByName(SpringBootPlugin.TEST_AND_DEVELOPMENT_ONLY_CONFIGURATION_NAME);
		Configuration productionRuntimeClasspath = project.getConfigurations()
			.getByName(SpringBootPlugin.PRODUCTION_RUNTIME_CLASSPATH_CONFIGURATION_NAME);
		SourceSet mainSourceSet = project.getExtensions()
			.getByType(SourceSetContainer.class)
			.getByName(SourceSet.MAIN_SOURCE_SET_NAME);
		Configuration runtimeClasspath = project.getConfigurations()
			.getByName(mainSourceSet.getRuntimeClasspathConfigurationName());
		Callable<FileCollection> classpath = () -> mainSourceSet.getRuntimeClasspath()
			.minus(providedRuntimeConfiguration(project))
			.minus((developmentOnly.minus(productionRuntimeClasspath)))
			.minus((testAndDevelopmentOnly.minus(productionRuntimeClasspath)))
			.filter(new JarTypeFileSpec());
		TaskProvider<ResolveMainClassName> resolveMainClassName = project.getTasks()
			.named(SpringBootPlugin.RESOLVE_MAIN_CLASS_NAME_TASK_NAME, ResolveMainClassName.class);
		TaskProvider<BootWar> bootWarProvider = project.getTasks()
			.register(SpringBootPlugin.BOOT_WAR_TASK_NAME, BootWar.class, (bootWar) -> {
				bootWar.setGroup(BasePlugin.BUILD_GROUP);
				bootWar.setDescription('Assembles an executable war archive containing webapp'
						+ ' content, and the main classes and their dependencies.');
				bootWar.providedClasspath(providedRuntimeConfiguration(project));
				bootWar.setClasspath(classpath);
				Provider<String> manifestStartClass = project
					.provider(() -> (String) bootWar.getManifest().getAttributes().get('Start-Class'));
				bootWar.getMainClass()
					.convention(resolveMainClassName.flatMap((resolver) -> manifestStartClass.isPresent()
							? manifestStartClass : resolver.readMainClassName()));
				bootWar.getTargetJavaVersion()
					.set(project.provider(() -> javaPluginExtension(project).getTargetCompatibility()));
				bootWar.resolvedArtifacts(runtimeClasspath.getIncoming().getArtifacts().getResolvedArtifacts());
			});
		bootWarProvider.map(War::getClasspath);
		return bootWarProvider;
	}
	private FileCollection providedRuntimeConfiguration(Project project) {
		ConfigurationContainer configurations = project.getConfigurations();
		return configurations.getByName(WarPlugin.PROVIDED_RUNTIME_CONFIGURATION_NAME);
	}
	private void configureBootBuildImageTask(Project project, TaskProvider<BootWar> bootWar) {
		project.getTasks()
			.named(SpringBootPlugin.BOOT_BUILD_IMAGE_TASK_NAME, BootBuildImage.class)
			.configure((buildImage) -> buildImage.getArchiveFile().set(bootWar.get().getArchiveFile()));
	}
	private void configureArtifactPublication(TaskProvider<BootWar> bootWar) {
		this.singlePublishedArtifact.addWarCandidate(bootWar);
	}
	private JavaPluginExtension javaPluginExtension(Project project) {
		return project.getExtensions().getByType(JavaPluginExtension.class);
	}
}
/*
/**
package org.springframework.boot.gradle.plugin;
/*
package org.springframework.boot.gradle.plugin;
/**
class NativeImagePluginAction implements PluginApplicationAction {
	@Override
	public Class<? extends Plugin<? extends Project>> getPluginClass() {
		return NativeImagePlugin.class;
	}
	@Override
	public void execute(Project project) {
		project.getPlugins().apply(SpringBootAotPlugin.class);
		project.getPlugins().withType(JavaPlugin.class).all((plugin) -> {
			JavaPluginExtension javaPluginExtension = project.getExtensions().getByType(JavaPluginExtension.class);
			SourceSetContainer sourceSets = javaPluginExtension.getSourceSets();
			GraalVMExtension graalVmExtension = configureGraalVmExtension(project);
			configureMainNativeBinaryClasspath(project, sourceSets, graalVmExtension);
			configureTestNativeBinaryClasspath(sourceSets, graalVmExtension);
			copyReachabilityMetadataToBootJar(project);
			configureJarManifestNativeAttribute(project);
		});
	}
	private void configureMainNativeBinaryClasspath(Project project, SourceSetContainer sourceSets,
			GraalVMExtension graalVmExtension) {
		FileCollection runtimeClasspath = sourceSets.getByName(SpringBootAotPlugin.AOT_SOURCE_SET_NAME)
			.getRuntimeClasspath();
		graalVmExtension.getBinaries().getByName(NativeImagePlugin.NATIVE_MAIN_EXTENSION).classpath(runtimeClasspath);
		Configuration nativeImageClasspath = project.getConfigurations().getByName('nativeImageClasspath');
		nativeImageClasspath.setExtendsFrom(removeDevelopmentOnly(nativeImageClasspath.getExtendsFrom()));
	}
	private Iterable<Configuration> removeDevelopmentOnly(Set<Configuration> configurations) {
		return configurations.stream()
			.filter(this::isNotDevelopmentOnly)
			.collect(Collectors.toCollection(LinkedHashSet::new));
	}
	private boolean isNotDevelopmentOnly(Configuration configuration) {
		return !SpringBootPlugin.DEVELOPMENT_ONLY_CONFIGURATION_NAME.equals(configuration.getName())
				&& !SpringBootPlugin.TEST_AND_DEVELOPMENT_ONLY_CONFIGURATION_NAME.equals(configuration.getName());
	}
	private void configureTestNativeBinaryClasspath(SourceSetContainer sourceSets, GraalVMExtension graalVmExtension) {
		FileCollection runtimeClasspath = sourceSets.getByName(SpringBootAotPlugin.AOT_TEST_SOURCE_SET_NAME)
			.getRuntimeClasspath();
		graalVmExtension.getBinaries().getByName(NativeImagePlugin.NATIVE_TEST_EXTENSION).classpath(runtimeClasspath);
	}
	private GraalVMExtension configureGraalVmExtension(Project project) {
		GraalVMExtension extension = project.getExtensions().getByType(GraalVMExtension.class);
		extension.getToolchainDetection().set(false);
		return extension;
	}
	private void copyReachabilityMetadataToBootJar(Project project) {
		project.getTasks()
			.named(SpringBootPlugin.BOOT_JAR_TASK_NAME, BootJar.class)
			.configure((bootJar) -> bootJar.from(project.getTasks().named('collectReachabilityMetadata')));
	}
	private void configureJarManifestNativeAttribute(Project project) {
		project.getTasks()
			.named(SpringBootPlugin.BOOT_JAR_TASK_NAME, BootJar.class)
			.configure(this::addNativeProcessedAttribute);
	}
	private void addNativeProcessedAttribute(BootJar bootJar) {
		bootJar.manifest(this::addNativeProcessedAttribute);
	}
	private void addNativeProcessedAttribute(Manifest manifest) {
		manifest.getAttributes().put('Spring-Boot-Native-Processed', true);
	}
}
/*
package org.springframework.boot.gradle.dsl;
/**
public class SpringBootExtension {
	private final Project project;
	private final Property<String> mainClass;
	/**
	 * Creates a new {@code SpringBootPluginExtension} that is associated with the given
	 * {@code project}.
	 * @param project the project
	 */
	public SpringBootExtension(Project project) {
		this.project = project;
		this.mainClass = this.project.getObjects().property(String.class);
	}
	/**
	 * Returns the fully-qualified name of the application"s main class.
	 * @return the fully-qualified name of the application"s main class
	 * @since 2.4.0
	 */
	public Property<String> getMainClass() {
		return this.mainClass;
	}
	/**
	 * Creates a new {@link BuildInfo} task named {@code bootBuildInfo} and configures the
	 * Java plugin"s {@code classes} task to depend upon it.
	 * <p>
	 * By default, the task"s destination dir will be a directory named {@code META-INF}
	 * beneath the main source set"s resources output directory, and the task"s project
	 * artifact will be the base name of the {@code bootWar} or {@code bootJar} task.
	 */
	public void buildInfo() {
		buildInfo(null);
	}
	/**
	 * Creates a new {@link BuildInfo} task named {@code bootBuildInfo} and configures the
	 * Java plugin"s {@code classes} task to depend upon it. The task is passed to the
	 * given {@code configurer} for further configuration.
	 * <p>
	 * By default, the task"s destination dir will be a directory named {@code META-INF}
	 * beneath the main source set"s resources output directory, and the task"s project
	 * artifact will be the base name of the {@code bootWar} or {@code bootJar} task.
	 * @param configurer the task configurer
	 */
	public void buildInfo(Action<BuildInfo> configurer) {
		TaskContainer tasks = this.project.getTasks();
		TaskProvider<BuildInfo> bootBuildInfo = tasks.register('bootBuildInfo', BuildInfo.class,
				this::configureBuildInfoTask);
		this.project.getPlugins().withType(JavaPlugin.class, (plugin) -> {
			tasks.named(JavaPlugin.CLASSES_TASK_NAME).configure((task) -> task.dependsOn(bootBuildInfo));
			bootBuildInfo.configure((buildInfo) -> buildInfo.getProperties()
				.getArtifact()
				.convention(this.project.provider(this::determineArtifactBaseName)));
		});
		if (configurer != null) {
			bootBuildInfo.configure(configurer);
		}
	}
	private void configureBuildInfoTask(BuildInfo task) {
		task.setGroup(BasePlugin.BUILD_GROUP);
		task.setDescription('Generates a META-INF/build-info.properties file.');
		task.getDestinationDir()
			.convention(this.project.getLayout()
				.dir(this.project.provider(() -> new File(determineMainSourceSetResourcesOutputDir(), 'META-INF'))));
	}
	private File determineMainSourceSetResourcesOutputDir() {
		return this.project.getExtensions()
			.getByType(JavaPluginExtension.class)
			.getSourceSets()
			.getByName(SourceSet.MAIN_SOURCE_SET_NAME)
			.getOutput()
			.getResourcesDir();
	}
	private String determineArtifactBaseName() {
		Jar artifactTask = findArtifactTask();
		return (artifactTask != null) ? artifactTask.getArchiveBaseName().get() : null;
	}
	private Jar findArtifactTask() {
		Jar artifactTask = (Jar) this.project.getTasks().findByName('bootWar');
		if (artifactTask != null) {
			return artifactTask;
		}
		return (Jar) this.project.getTasks().findByName('bootJar');
	}
}
/*
/**
package org.springframework.boot.gradle.dsl;
/*
package org.springframework.boot.gradle.util;
/**
public final class VersionExtractor {
	private VersionExtractor() {
	}
	/**
	 * Return the version information for the provided {@link Class}.
	 * @param cls the Class to retrieve the version for
	 * @return the version, or {@code null} if a version can not be extracted
	 */
	public static String forClass(Class<?> cls) {
		String implementationVersion = cls.getPackage().getImplementationVersion();
		if (implementationVersion != null) {
			return implementationVersion;
		}
		URL codeSourceLocation = cls.getProtectionDomain().getCodeSource().getLocation();
		try {
			URLConnection connection = codeSourceLocation.openConnection();
			if (connection instanceof JarURLConnection jarURLConnection) {
				return getImplementationVersion(jarURLConnection.getJarFile());
			}
			try (JarFile jarFile = new JarFile(new File(codeSourceLocation.toURI()))) {
				return getImplementationVersion(jarFile);
			}
		}
		catch (Exception ex) {
			return null;
		}
	}
	private static String getImplementationVersion(JarFile jarFile) throws IOException {
		return jarFile.getManifest().getMainAttributes().getValue(Attributes.Name.IMPLEMENTATION_VERSION);
	}
}
/*
/**
package org.springframework.boot.gradle.util;
/*
/**
package org.springframework.boot.gradle.tasks.run;
/*
package org.springframework.boot.gradle.tasks.run;
/**
@DisableCachingByDefault(because = 'Application should always run')
public abstract class BootRun extends JavaExec {
	public BootRun() {
		getOptimizedLaunch().convention(true);
	}
	/**
	 * Returns the property for whether the JVM"s launch should be optimized. The property
	 * defaults to {@code true}.
	 * @return whether the JVM"s launch should be optimized
	 * @since 3.0.0
	 */
	@Input
	public abstract Property<Boolean> getOptimizedLaunch();
	/**
	 * Adds the {@link SourceDirectorySet#getSrcDirs() source directories} of the given
	 * {@code sourceSet"s} {@link SourceSet#getResources() resources} to the start of the
	 * classpath in place of the {@link SourceSet#getOutput output"s}
	 * {@link SourceSetOutput#getResourcesDir() resources directory}.
	 * @param sourceSet the source set
	 */
	public void sourceResources(SourceSet sourceSet) {
		File resourcesDir = sourceSet.getOutput().getResourcesDir();
		Set<File> srcDirs = sourceSet.getResources().getSrcDirs();
		setClasspath(getProject().files(srcDirs, getClasspath()).filter((file) -> !file.equals(resourcesDir)));
	}
	@Override
	public void exec() {
		if (getOptimizedLaunch().get()) {
			setJvmArgs(getJvmArgs());
			jvmArgs('-XX:TieredStopAtLevel=1');
		}
		if (System.console() != null) {
			// Record that the console is available here for AnsiOutput to detect later
			getEnvironment().put('spring.output.ansi.console-available', true);
		}
		super.exec();
	}
}
/*
package org.springframework.boot.gradle.tasks.buildinfo;
/**
@SuppressWarnings('serial')
public abstract class BuildInfoProperties implements Serializable {
	private final SetProperty<String> excludes;
	private final Supplier<String> creationTime = () -> DateTimeFormatter.ISO_INSTANT.format(Instant.now());
	@Inject
	public BuildInfoProperties(Project project, SetProperty<String> excludes) {
		this.excludes = excludes;
		getGroup().convention(project.provider(() -> project.getGroup().toString()));
		getVersion().convention(project.provider(() -> project.getVersion().toString()));
		getArtifact()
			.convention(project.provider(() -> project.findProperty('archivesBaseName')).map(Object::toString));
		getName().convention(project.provider(project::getName));
	}
	/**
	 * Returns the {@code build.group} property. Defaults to the {@link Project#getGroup()
	 * Project"s group}.
	 * @return the group property
	 */
	@Internal
	public abstract Property<String> getGroup();
	/**
	 * Returns the {@code build.artifact} property.
	 * @return the artifact property
	 */
	@Internal
	public abstract Property<String> getArtifact();
	/**
	 * Returns the {@code build.version} property. Defaults to the
	 * {@link Project#getVersion() Project"s version}.
	 * @return the version
	 */
	@Internal
	public abstract Property<String> getVersion();
	/**
	 * Returns the {@code build.name} property. Defaults to the {@link Project#getName()
	 * Project"s name}.
	 * @return the name
	 */
	@Internal
	public abstract Property<String> getName();
	/**
	 * Returns the {@code build.time} property.
	 * @return the time
	 */
	@Internal
	public abstract Property<String> getTime();
	/**
	 * Returns the additional properties that will be included. When written, the name of
	 * each additional property is prefixed with {@code build.}.
	 * @return the additional properties
	 */
	@Internal
	public abstract MapProperty<String, Object> getAdditional();
	@Input
	@Optional
	String getArtifactIfNotExcluded() {
		return getIfNotExcluded(getArtifact(), 'artifact');
	}
	@Input
	@Optional
	String getGroupIfNotExcluded() {
		return getIfNotExcluded(getGroup(), 'group');
	}
	@Input
	@Optional
	String getNameIfNotExcluded() {
		return getIfNotExcluded(getName(), 'name');
	}
	@Input
	@Optional
	Instant getTimeIfNotExcluded() {
		String time = getIfNotExcluded(getTime(), 'time', this.creationTime);
		return (time != null) ? Instant.parse(time) : null;
	}
	@Input
	@Optional
	String getVersionIfNotExcluded() {
		return getIfNotExcluded(getVersion(), 'version');
	}
	@Input
	Map<String, String> getAdditionalIfNotExcluded() {
		return coerceToStringValues(applyExclusions(getAdditional().getOrElse(Collections.emptyMap())));
	}
	private <T> T getIfNotExcluded(Property<T> property, String name) {
		return getIfNotExcluded(property, name, () -> null);
	}
	private <T> T getIfNotExcluded(Property<T> property, String name, Supplier<T> defaultValue) {
		if (this.excludes.getOrElse(Collections.emptySet()).contains(name)) {
			return null;
		}
		return property.getOrElse(defaultValue.get());
	}
	private Map<String, String> coerceToStringValues(Map<String, Object> input) {
		Map<String, String> output = new HashMap<>();
		input.forEach((key, value) -> {
			if (value instanceof Provider<?> provider) {
				value = provider.getOrNull();
			}
			output.put(key, (value != null) ? value.toString() : null);
		});
		return output;
	}
	private Map<String, Object> applyExclusions(Map<String, Object> input) {
		Map<String, Object> output = new HashMap<>();
		Set<String> exclusions = this.excludes.getOrElse(Collections.emptySet());
		input.forEach((key, value) -> output.put(key, (!exclusions.contains(key)) ? value : null));
		return output;
	}
}
/*
package org.springframework.boot.gradle.tasks.buildinfo;
/**
@DisableCachingByDefault(because = 'Not worth caching')
public abstract class BuildInfo extends DefaultTask {
	private final BuildInfoProperties properties;
	public BuildInfo() {
		this.properties = getProject().getObjects().newInstance(BuildInfoProperties.class, getExcludes());
		getDestinationDir().convention(getProject().getLayout().getBuildDirectory().dir(getName()));
	}
	/**
	 * Returns the names of the properties to exclude from the output.
	 * @return names of the properties to exclude
	 * @since 3.0.0
	 */
	@Internal
	public abstract SetProperty<String> getExcludes();
	/**
	 * Generates the {@code build-info.properties} file in the configured
	 * {@link #getDestinationDir destination}.
	 */
	@TaskAction
	public void generateBuildProperties() {
		try {
			ProjectDetails details = new ProjectDetails(this.properties.getGroupIfNotExcluded(),
					this.properties.getArtifactIfNotExcluded(), this.properties.getVersionIfNotExcluded(),
					this.properties.getNameIfNotExcluded(), this.properties.getTimeIfNotExcluded(),
					this.properties.getAdditionalIfNotExcluded());
			new BuildPropertiesWriter(new File(getDestinationDir().get().getAsFile(), 'build-info.properties'))
				.writeBuildProperties(details);
		}
		catch (IOException ex) {
			throw new TaskExecutionException(this, ex);
		}
	}
	/**
	 * Returns the directory to which the {@code build-info.properties} file will be
	 * written.
	 * @return the destination directory
	 */
	@OutputDirectory
	public abstract DirectoryProperty getDestinationDir();
	/**
	 * Returns the {@link BuildInfoProperties properties} that will be included in the
	 * {@code build-info.properties} file.
	 * @return the properties
	 */
	@Nested
	public BuildInfoProperties getProperties() {
		return this.properties;
	}
	/**
	 * Executes the given {@code action} on the {@link #getProperties()} properties.
	 * @param action the action
	 */
	public void properties(Action<BuildInfoProperties> action) {
		action.execute(this.properties);
	}
}
/*
/**
package org.springframework.boot.gradle.tasks.buildinfo;
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
public enum ZipCompression {
	/**
	 * The entry should be {@link ZipEntry#STORED} in the archive.
	 */
	STORED,
	/**
	 * The entry should be {@link ZipEntry#DEFLATED} in the archive.
	 */
	DEFLATED
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class BootArchiveSupport {
	private static final byte[] ZIP_FILE_HEADER = new byte[] { "P", "K", 3, 4 };
	private static final String UNSPECIFIED_VERSION = 'unspecified';
	private static final Set<String> DEFAULT_LAUNCHER_CLASSES;
	static {
		Set<String> defaultLauncherClasses = new HashSet<>();
		defaultLauncherClasses.add('org.springframework.boot.loader.launch.JarLauncher');
		defaultLauncherClasses.add('org.springframework.boot.loader.launch.PropertiesLauncher');
		defaultLauncherClasses.add('org.springframework.boot.loader.launch.WarLauncher');
		DEFAULT_LAUNCHER_CLASSES = Collections.unmodifiableSet(defaultLauncherClasses);
	}
	private final PatternSet requiresUnpack = new PatternSet();
	private final PatternSet exclusions = new PatternSet();
	private final String loaderMainClass;
	private final Spec<FileCopyDetails> librarySpec;
	private final Function<FileCopyDetails, ZipCompression> compressionResolver;
	private LaunchScriptConfiguration launchScript;
	BootArchiveSupport(String loaderMainClass, Spec<FileCopyDetails> librarySpec,
			Function<FileCopyDetails, ZipCompression> compressionResolver) {
		this.loaderMainClass = loaderMainClass;
		this.librarySpec = librarySpec;
		this.compressionResolver = compressionResolver;
		this.requiresUnpack.include(Specs.satisfyNone());
	}
	void configureManifest(Manifest manifest, String mainClass, String classes, String lib, String classPathIndex,
			String layersIndex, String jdkVersion, String implementationTitle, Object implementationVersion) {
		Attributes attributes = manifest.getAttributes();
		attributes.putIfAbsent('Main-Class', this.loaderMainClass);
		attributes.putIfAbsent('Start-Class', mainClass);
		attributes.computeIfAbsent('Spring-Boot-Version', (name) -> determineSpringBootVersion());
		attributes.putIfAbsent('Spring-Boot-Classes', classes);
		attributes.putIfAbsent('Spring-Boot-Lib', lib);
		if (classPathIndex != null) {
			attributes.putIfAbsent('Spring-Boot-Classpath-Index', classPathIndex);
		}
		if (layersIndex != null) {
			attributes.putIfAbsent('Spring-Boot-Layers-Index', layersIndex);
		}
		attributes.putIfAbsent('Build-Jdk-Spec', jdkVersion);
		attributes.putIfAbsent('Implementation-Title', implementationTitle);
		if (implementationVersion != null) {
			String versionString = implementationVersion.toString();
			if (!UNSPECIFIED_VERSION.equals(versionString)) {
				attributes.putIfAbsent('Implementation-Version', versionString);
			}
		}
	}
	private String determineSpringBootVersion() {
		String version = getClass().getPackage().getImplementationVersion();
		return (version != null) ? version : 'unknown';
	}
	CopyAction createCopyAction(Jar jar, ResolvedDependencies resolvedDependencies,
			LoaderImplementation loaderImplementation, boolean supportsSignatureFile) {
		return createCopyAction(jar, resolvedDependencies, loaderImplementation, supportsSignatureFile, null, null);
	}
	CopyAction createCopyAction(Jar jar, ResolvedDependencies resolvedDependencies,
			LoaderImplementation loaderImplementation, boolean supportsSignatureFile, LayerResolver layerResolver,
			String jarmodeToolsLocation) {
		File output = jar.getArchiveFile().get().getAsFile();
		Manifest manifest = jar.getManifest();
		boolean preserveFileTimestamps = jar.isPreserveFileTimestamps();
		Integer dirPermissions = getUnixNumericDirPermissions(jar);
		Integer filePermissions = getUnixNumericFilePermissions(jar);
		boolean includeDefaultLoader = isUsingDefaultLoader(jar);
		Spec<FileTreeElement> requiresUnpack = this.requiresUnpack.getAsSpec();
		Spec<FileTreeElement> exclusions = this.exclusions.getAsExcludeSpec();
		LaunchScriptConfiguration launchScript = this.launchScript;
		Spec<FileCopyDetails> librarySpec = this.librarySpec;
		Function<FileCopyDetails, ZipCompression> compressionResolver = this.compressionResolver;
		String encoding = jar.getMetadataCharset();
		CopyAction action = new BootZipCopyAction(output, manifest, preserveFileTimestamps, dirPermissions,
				filePermissions, includeDefaultLoader, jarmodeToolsLocation, requiresUnpack, exclusions, launchScript,
				librarySpec, compressionResolver, encoding, resolvedDependencies, supportsSignatureFile, layerResolver,
				loaderImplementation);
		return jar.isReproducibleFileOrder() ? new ReproducibleOrderingCopyAction(action) : action;
	}
	private Integer getUnixNumericDirPermissions(CopySpec copySpec) {
		return (GradleVersion.current().compareTo(GradleVersion.version('8.3')) >= 0)
				? asUnixNumeric(copySpec.getDirPermissions()) : getDirMode(copySpec);
	}
	private Integer getUnixNumericFilePermissions(CopySpec copySpec) {
		return (GradleVersion.current().compareTo(GradleVersion.version('8.3')) >= 0)
				? asUnixNumeric(copySpec.getFilePermissions()) : getFileMode(copySpec);
	}
	private Integer asUnixNumeric(Property<ConfigurableFilePermissions> permissions) {
		return permissions.isPresent() ? permissions.get().toUnixNumeric() : null;
	}
	@SuppressWarnings('deprecation')
	private Integer getDirMode(CopySpec copySpec) {
		return copySpec.getDirMode();
	}
	@SuppressWarnings('deprecation')
	private Integer getFileMode(CopySpec copySpec) {
		return copySpec.getFileMode();
	}
	private boolean isUsingDefaultLoader(Jar jar) {
		return DEFAULT_LAUNCHER_CLASSES.contains(jar.getManifest().getAttributes().get('Main-Class'));
	}
	LaunchScriptConfiguration getLaunchScript() {
		return this.launchScript;
	}
	void setLaunchScript(LaunchScriptConfiguration launchScript) {
		this.launchScript = launchScript;
	}
	void requiresUnpack(String... patterns) {
		this.requiresUnpack.include(patterns);
	}
	void requiresUnpack(Spec<FileTreeElement> spec) {
		this.requiresUnpack.include(spec);
	}
	void excludeNonZipLibraryFiles(FileCopyDetails details) {
		if (this.librarySpec.isSatisfiedBy(details)) {
			excludeNonZipFiles(details);
		}
	}
	void excludeNonZipFiles(FileCopyDetails details) {
		if (!isZip(details.getFile())) {
			details.exclude();
		}
	}
	private boolean isZip(File file) {
		try {
			try (FileInputStream fileInputStream = new FileInputStream(file)) {
				return isZip(fileInputStream);
			}
		}
		catch (IOException ex) {
			return false;
		}
	}
	private boolean isZip(InputStream inputStream) throws IOException {
		for (byte headerByte : ZIP_FILE_HEADER) {
			if (inputStream.read() != headerByte) {
				return false;
			}
		}
		return true;
	}
	void moveModuleInfoToRoot(CopySpec spec) {
		spec.filesMatching('module-info.class', this::moveToRoot);
	}
	void moveToRoot(FileCopyDetails details) {
		details.setRelativePath(details.getRelativeSourcePath());
	}
	/**
	 * {@link CopyAction} variant that sorts entries to ensure reproducible ordering.
	 */
	private static final class ReproducibleOrderingCopyAction implements CopyAction {
		private final CopyAction delegate;
		private ReproducibleOrderingCopyAction(CopyAction delegate) {
			this.delegate = delegate;
		}
		@Override
		public WorkResult execute(CopyActionProcessingStream stream) {
			return this.delegate.execute((action) -> {
				Map<RelativePath, FileCopyDetailsInternal> detailsByPath = new TreeMap<>();
				stream.process((details) -> detailsByPath.put(details.getRelativePath(), details));
				detailsByPath.values().forEach(action::processFile);
			});
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@DisableCachingByDefault
public abstract class BootBuildImage extends DefaultTask {
	private final Property<PullPolicy> pullPolicy;
	private final String projectName;
	private final CacheSpec buildWorkspace;
	private final CacheSpec buildCache;
	private final CacheSpec launchCache;
	private final DockerSpec docker;
	public BootBuildImage() {
		this.projectName = getProject().getName();
		Project project = getProject();
		Property<String> projectVersion = project.getObjects()
			.property(String.class)
			.convention(project.provider(() -> project.getVersion().toString()));
		getImageName().convention(project.provider(() -> {
			ImageName imageName = ImageName.of(this.projectName);
			if ('unspecified'.equals(projectVersion.get())) {
				return ImageReference.of(imageName).toString();
			}
			return ImageReference.of(imageName, projectVersion.get()).toString();
		}));
		getTrustBuilder().convention((Boolean) null);
		getCleanCache().convention(false);
		getVerboseLogging().convention(false);
		getPublish().convention(false);
		this.buildWorkspace = getProject().getObjects().newInstance(CacheSpec.class);
		this.buildCache = getProject().getObjects().newInstance(CacheSpec.class);
		this.launchCache = getProject().getObjects().newInstance(CacheSpec.class);
		this.docker = getProject().getObjects().newInstance(DockerSpec.class);
		this.pullPolicy = getProject().getObjects().property(PullPolicy.class);
		getSecurityOptions().convention((Iterable<? extends String>) null);
	}
	/**
	 * Returns the property for the archive file from which the image will be built.
	 * @return the archive file property
	 */
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	public abstract RegularFileProperty getArchiveFile();
	/**
	 * Returns the name of the image that will be built. When {@code null}, the name will
	 * be derived from the {@link Project Project"s} {@link Project#getName() name} and
	 * {@link Project#getVersion version}.
	 * @return name of the image
	 */
	@Input
	@Optional
	@Option(option = 'imageName', description = 'The name of the image to generate')
	public abstract Property<String> getImageName();
	/**
	 * Returns the builder that will be used to build the image. When {@code null}, the
	 * default builder will be used.
	 * @return the builder
	 */
	@Input
	@Optional
	@Option(option = 'builder', description = 'The name of the builder image to use')
	public abstract Property<String> getBuilder();
	/**
	 * Whether to treat the builder as trusted.
	 * @return whether to trust the builder
	 * @since 3.4.0
	 */
	@Input
	@Optional
	@Option(option = 'trustBuilder', description = 'Consider the builder trusted')
	public abstract Property<Boolean> getTrustBuilder();
	/**
	 * Returns the run image that will be included in the built image. When {@code null},
	 * the run image bundled with the builder will be used.
	 * @return the run image
	 */
	@Input
	@Optional
	@Option(option = 'runImage', description = 'The name of the run image to use')
	public abstract Property<String> getRunImage();
	/**
	 * Returns the environment that will be used when building the image.
	 * @return the environment
	 */
	@Input
	public abstract MapProperty<String, String> getEnvironment();
	/**
	 * Returns whether caches should be cleaned before packaging.
	 * @return whether caches should be cleaned
	 * @since 3.0.0
	 */
	@Input
	@Option(option = 'cleanCache', description = 'Clean caches before packaging')
	public abstract Property<Boolean> getCleanCache();
	/**
	 * Whether verbose logging should be enabled while building the image.
	 * @return whether verbose logging should be enabled
	 * @since 3.0.0
	 */
	@Input
	public abstract Property<Boolean> getVerboseLogging();
	/**
	 * Returns image pull policy that will be used when building the image.
	 * @return whether images should be pulled
	 */
	@Input
	@Optional
	@Option(option = 'pullPolicy', description = 'The image pull policy')
	public Property<PullPolicy> getPullPolicy() {
		return this.pullPolicy;
	}
	/**
	 * Sets image pull policy that will be used when building the image.
	 * @param pullPolicy the pull policy to use
	 */
	public void setPullPolicy(String pullPolicy) {
		getPullPolicy().set(PullPolicy.valueOf(pullPolicy));
	}
	/**
	 * Whether the built image should be pushed to a registry.
	 * @return whether the built image should be pushed
	 * @since 3.0.0
	 */
	@Input
	@Option(option = 'publishImage', description = 'Publish the built image to a registry')
	public abstract Property<Boolean> getPublish();
	/**
	 * Returns the buildpacks that will be used when building the image.
	 * @return the buildpack references
	 */
	@Input
	@Optional
	public abstract ListProperty<String> getBuildpacks();
	/**
	 * Returns the volume bindings that will be mounted to the container when building the
	 * image.
	 * @return the bindings
	 */
	@Input
	@Optional
	public abstract ListProperty<String> getBindings();
	/**
	 * Returns the tags that will be created for the built image.
	 * @return the tags
	 */
	@Input
	@Optional
	public abstract ListProperty<String> getTags();
	/**
	 * Returns the network the build container will connect to.
	 * @return the network
	 */
	@Input
	@Optional
	@Option(option = 'network', description = 'Connect detect and build containers to network')
	public abstract Property<String> getNetwork();
	/**
	 * Returns the build temporary workspace that will be used when building the image.
	 * @return the cache
	 * @since 3.2.0
	 */
	@Nested
	@Optional
	public CacheSpec getBuildWorkspace() {
		return this.buildWorkspace;
	}
	/**
	 * Customizes the {@link CacheSpec} for the build temporary workspace using the given
	 * {@code action}.
	 * @param action the action
	 * @since 3.2.0
	 */
	public void buildWorkspace(Action<CacheSpec> action) {
		action.execute(this.buildWorkspace);
	}
	/**
	 * Returns the build cache that will be used when building the image.
	 * @return the cache
	 */
	@Nested
	@Optional
	public CacheSpec getBuildCache() {
		return this.buildCache;
	}
	/**
	 * Customizes the {@link CacheSpec} for the build cache using the given
	 * {@code action}.
	 * @param action the action
	 */
	public void buildCache(Action<CacheSpec> action) {
		action.execute(this.buildCache);
	}
	/**
	 * Returns the launch cache that will be used when building the image.
	 * @return the cache
	 */
	@Nested
	@Optional
	public CacheSpec getLaunchCache() {
		return this.launchCache;
	}
	/**
	 * Customizes the {@link CacheSpec} for the launch cache using the given
	 * {@code action}.
	 * @param action the action
	 */
	public void launchCache(Action<CacheSpec> action) {
		action.execute(this.launchCache);
	}
	/**
	 * Returns the date that will be used as the {@code Created} date of the image. When
	 * {@code null}, a fixed date that enables build reproducibility will be used.
	 * @return the created date
	 */
	@Input
	@Optional
	@Option(option = 'createdDate', description = 'The date to use as the created date of the image')
	public abstract Property<String> getCreatedDate();
	/**
	 * Returns the directory that contains application content in the image. When
	 * {@code null}, a default location will be used.
	 * @return the application directory
	 */
	@Input
	@Optional
	@Option(option = 'applicationDirectory', description = 'The directory containing application content in the image')
	public abstract Property<String> getApplicationDirectory();
	/**
	 * Returns the security options that will be applied to the builder container.
	 * @return the security options
	 */
	@Input
	@Optional
	@Option(option = 'securityOptions', description = 'Security options that will be applied to the builder container')
	public abstract ListProperty<String> getSecurityOptions();
	/**
	 * Returns the platform (os/architecture/variant) that will be used for all pulled
	 * images. When {@code null}, the system will choose a platform based on the host
	 * operating system and architecture.
	 * @return the image platform
	 */
	@Input
	@Optional
	@Option(option = 'imagePlatform',
			description = 'The platform (os/architecture/variant) that will be used for all pulled images')
	public abstract Property<String> getImagePlatform();
	/**
	 * Returns the Docker configuration the builder will use.
	 * @return docker configuration.
	 * @since 2.4.0
	 */
	@Nested
	public DockerSpec getDocker() {
		return this.docker;
	}
	/**
	 * Configures the Docker connection using the given {@code action}.
	 * @param action the action to apply
	 * @since 2.4.0
	 */
	public void docker(Action<DockerSpec> action) {
		action.execute(this.docker);
	}
	@TaskAction
	void buildImage() throws DockerEngineException, IOException {
		Builder builder = new Builder(this.docker.asDockerConfiguration());
		BuildRequest request = createRequest();
		builder.build(request);
	}
	BuildRequest createRequest() {
		return customize(BuildRequest.of(getImageName().map(ImageReference::of).get(),
				(owner) -> new ZipFileTarArchive(getArchiveFile().get().getAsFile(), owner)));
	}
	private BuildRequest customize(BuildRequest request) {
		request = customizeBuilder(request);
		if (getTrustBuilder().isPresent()) {
			request = request.withTrustBuilder(getTrustBuilder().get());
		}
		request = customizeRunImage(request);
		request = customizeEnvironment(request);
		request = customizeCreator(request);
		request = request.withCleanCache(getCleanCache().get());
		request = request.withVerboseLogging(getVerboseLogging().get());
		request = customizePullPolicy(request);
		request = request.withPublish(getPublish().get());
		request = customizeBuildpacks(request);
		request = customizeBindings(request);
		request = customizeTags(request);
		request = customizeCaches(request);
		request = request.withNetwork(getNetwork().getOrNull());
		request = customizeCreatedDate(request);
		request = customizeApplicationDirectory(request);
		request = customizeSecurityOptions(request);
		if (getImagePlatform().isPresent()) {
			request = request.withImagePlatform(getImagePlatform().get());
		}
		return request;
	}
	private BuildRequest customizeBuilder(BuildRequest request) {
		String builder = getBuilder().getOrNull();
		if (StringUtils.hasText(builder)) {
			return request.withBuilder(ImageReference.of(builder));
		}
		return request;
	}
	private BuildRequest customizeRunImage(BuildRequest request) {
		String runImage = getRunImage().getOrNull();
		if (StringUtils.hasText(runImage)) {
			return request.withRunImage(ImageReference.of(runImage));
		}
		return request;
	}
	private BuildRequest customizeEnvironment(BuildRequest request) {
		Map<String, String> environment = getEnvironment().getOrNull();
		if (!CollectionUtils.isEmpty(environment)) {
			request = request.withEnv(environment);
		}
		return request;
	}
	private BuildRequest customizeCreator(BuildRequest request) {
		String springBootVersion = VersionExtractor.forClass(BootBuildImage.class);
		if (StringUtils.hasText(springBootVersion)) {
			return request.withCreator(Creator.withVersion(springBootVersion));
		}
		return request;
	}
	private BuildRequest customizePullPolicy(BuildRequest request) {
		PullPolicy pullPolicy = getPullPolicy().getOrNull();
		if (pullPolicy != null) {
			request = request.withPullPolicy(pullPolicy);
		}
		return request;
	}
	private BuildRequest customizeBuildpacks(BuildRequest request) {
		List<String> buildpacks = getBuildpacks().getOrNull();
		if (!CollectionUtils.isEmpty(buildpacks)) {
			return request.withBuildpacks(buildpacks.stream().map(BuildpackReference::of).toList());
		}
		return request;
	}
	private BuildRequest customizeBindings(BuildRequest request) {
		List<String> bindings = getBindings().getOrNull();
		if (!CollectionUtils.isEmpty(bindings)) {
			return request.withBindings(bindings.stream().map(Binding::of).toList());
		}
		return request;
	}
	private BuildRequest customizeTags(BuildRequest request) {
		List<String> tags = getTags().getOrNull();
		if (!CollectionUtils.isEmpty(tags)) {
			return request.withTags(tags.stream().map(ImageReference::of).toList());
		}
		return request;
	}
	private BuildRequest customizeCaches(BuildRequest request) {
		if (this.buildWorkspace.asCache() != null) {
			request = request.withBuildWorkspace((this.buildWorkspace.asCache()));
		}
		if (this.buildCache.asCache() != null) {
			request = request.withBuildCache(this.buildCache.asCache());
		}
		if (this.launchCache.asCache() != null) {
			request = request.withLaunchCache(this.launchCache.asCache());
		}
		return request;
	}
	private BuildRequest customizeCreatedDate(BuildRequest request) {
		String createdDate = getCreatedDate().getOrNull();
		if (createdDate != null) {
			return request.withCreatedDate(createdDate);
		}
		return request;
	}
	private BuildRequest customizeApplicationDirectory(BuildRequest request) {
		String applicationDirectory = getApplicationDirectory().getOrNull();
		if (applicationDirectory != null) {
			return request.withApplicationDirectory(applicationDirectory);
		}
		return request;
	}
	private BuildRequest customizeSecurityOptions(BuildRequest request) {
		if (getSecurityOptions().isPresent()) {
			List<String> securityOptions = getSecurityOptions().getOrNull();
			if (securityOptions != null) {
				return request.withSecurityOptions(securityOptions);
			}
		}
		return request;
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@DisableCachingByDefault(because = 'Not worth caching')
public abstract class BootWar extends War implements BootArchive {
	private static final String LAUNCHER = 'org.springframework.boot.loader.launch.WarLauncher';
	private static final String CLASSES_DIRECTORY = 'WEB-INF/classes/';
	private static final String LIB_PROVIDED_DIRECTORY = 'WEB-INF/lib-provided/';
	private static final String LIB_DIRECTORY = 'WEB-INF/lib/';
	private static final String LAYERS_INDEX = 'WEB-INF/layers.idx';
	private static final String CLASSPATH_INDEX = 'WEB-INF/classpath.idx';
	private final BootArchiveSupport support;
	private final LayeredSpec layered;
	private final Provider<String> projectName;
	private final Provider<Object> projectVersion;
	private final ResolvedDependencies resolvedDependencies;
	private FileCollection providedClasspath;
	/**
	 * Creates a new {@code BootWar} task.
	 */
	public BootWar() {
		this.support = new BootArchiveSupport(LAUNCHER, new LibrarySpec(), new ZipCompressionResolver());
		Project project = getProject();
		this.layered = project.getObjects().newInstance(LayeredSpec.class);
		getWebInf().into('lib-provided', fromCallTo(this::getProvidedLibFiles));
		this.support.moveModuleInfoToRoot(getRootSpec());
		getRootSpec().eachFile(this.support::excludeNonZipLibraryFiles);
		this.projectName = project.provider(project::getName);
		this.projectVersion = project.provider(project::getVersion);
		this.resolvedDependencies = new ResolvedDependencies(project);
		getIncludeTools().convention(true);
	}
	private Object getProvidedLibFiles() {
		return (this.providedClasspath != null) ? this.providedClasspath : Collections.emptyList();
	}
	@Override
	public void resolvedArtifacts(Provider<Set<ResolvedArtifactResult>> resolvedArtifacts) {
		this.resolvedDependencies.resolvedArtifacts(resolvedArtifacts);
	}
	@Nested
	ResolvedDependencies getResolvedDependencies() {
		return this.resolvedDependencies;
	}
	@Override
	public void copy() {
		this.support.configureManifest(getManifest(), getMainClass().get(), CLASSES_DIRECTORY, LIB_DIRECTORY,
				CLASSPATH_INDEX, (isLayeredDisabled()) ? null : LAYERS_INDEX,
				this.getTargetJavaVersion().get().getMajorVersion(), this.projectName.get(), this.projectVersion.get());
		super.copy();
	}
	private boolean isLayeredDisabled() {
		return !this.layered.getEnabled().get();
	}
	@Override
	protected CopyAction createCopyAction() {
		LoaderImplementation loaderImplementation = getLoaderImplementation().getOrElse(LoaderImplementation.DEFAULT);
		LayerResolver layerResolver = null;
		if (!isLayeredDisabled()) {
			layerResolver = new LayerResolver(this.resolvedDependencies, this.layered, this::isLibrary);
		}
		String jarmodeToolsLocation = isIncludeJarmodeTools() ? LIB_DIRECTORY : null;
		return this.support.createCopyAction(this, this.resolvedDependencies, loaderImplementation, false,
				layerResolver, jarmodeToolsLocation);
	}
	@SuppressWarnings('removal')
	private boolean isIncludeJarmodeTools() {
		return Boolean.TRUE.equals(this.getIncludeTools().get())
				&& Boolean.TRUE.equals(this.layered.getIncludeLayerTools().get());
	}
	@Override
	public void requiresUnpack(String... patterns) {
		this.support.requiresUnpack(patterns);
	}
	@Override
	public void requiresUnpack(Spec<FileTreeElement> spec) {
		this.support.requiresUnpack(spec);
	}
	@Override
	public LaunchScriptConfiguration getLaunchScript() {
		return this.support.getLaunchScript();
	}
	@Override
	public void launchScript() {
		enableLaunchScriptIfNecessary();
	}
	@Override
	public void launchScript(Action<LaunchScriptConfiguration> action) {
		action.execute(enableLaunchScriptIfNecessary());
	}
	/**
	 * Returns the provided classpath, the contents of which will be included in the
	 * {@code WEB-INF/lib-provided} directory of the war.
	 * @return the provided classpath
	 */
	@Optional
	@Classpath
	public FileCollection getProvidedClasspath() {
		return this.providedClasspath;
	}
	/**
	 * Adds files to the provided classpath to include in the {@code WEB-INF/lib-provided}
	 * directory of the war. The given {@code classpath} is evaluated as per
	 * {@link Project#files(Object...)}.
	 * @param classpath the additions to the classpath
	 */
	public void providedClasspath(Object... classpath) {
		FileCollection existingClasspath = this.providedClasspath;
		this.providedClasspath = getProject()
			.files((existingClasspath != null) ? existingClasspath : Collections.emptyList(), classpath);
	}
	/**
	 * Sets the provided classpath to include in the {@code WEB-INF/lib-provided}
	 * directory of the war.
	 * @param classpath the classpath
	 * @since 2.0.7
	 */
	public void setProvidedClasspath(FileCollection classpath) {
		this.providedClasspath = getProject().files(classpath);
	}
	/**
	 * Sets the provided classpath to include in the {@code WEB-INF/lib-provided}
	 * directory of the war. The given {@code classpath} is evaluated as per
	 * {@link Project#files(Object...)}.
	 * @param classpath the classpath
	 * @since 2.0.7
	 */
	public void setProvidedClasspath(Object classpath) {
		this.providedClasspath = getProject().files(classpath);
	}
	/**
	 * Return the {@link ZipCompression} that should be used when adding the file
	 * represented by the given {@code details} to the jar. By default, any
	 * {@link #isLibrary(FileCopyDetails) library} is {@link ZipCompression#STORED stored}
	 * and all other files are {@link ZipCompression#DEFLATED deflated}.
	 * @param details the file copy details
	 * @return the compression to use
	 */
	protected ZipCompression resolveZipCompression(FileCopyDetails details) {
		return isLibrary(details) ? ZipCompression.STORED : ZipCompression.DEFLATED;
	}
	/**
	 * Returns the spec that describes the layers in a layered jar.
	 * @return the spec for the layers
	 * @since 2.5.0
	 */
	@Nested
	public LayeredSpec getLayered() {
		return this.layered;
	}
	/**
	 * Configures the war"s layering using the given {@code action}.
	 * @param action the action to apply
	 * @since 2.5.0
	 */
	public void layered(Action<LayeredSpec> action) {
		action.execute(this.layered);
	}
	/**
	 * Return if the {@link FileCopyDetails} are for a library. By default any file in
	 * {@code WEB-INF/lib} or {@code WEB-INF/lib-provided} is considered to be a library.
	 * @param details the file copy details
	 * @return {@code true} if the details are for a library
	 */
	protected boolean isLibrary(FileCopyDetails details) {
		String path = details.getRelativePath().getPathString();
		return path.startsWith(LIB_DIRECTORY) || path.startsWith(LIB_PROVIDED_DIRECTORY);
	}
	private LaunchScriptConfiguration enableLaunchScriptIfNecessary() {
		LaunchScriptConfiguration launchScript = this.support.getLaunchScript();
		if (launchScript == null) {
			launchScript = new LaunchScriptConfiguration(this);
			this.support.setLaunchScript(launchScript);
		}
		return launchScript;
	}
	/**
	 * Syntactic sugar that makes {@link CopySpec#into} calls a little easier to read.
	 * @param <T> the result type
	 * @param callable the callable
	 * @return an action to add the callable to the spec
	 */
	private static <T> Action<CopySpec> fromCallTo(Callable<T> callable) {
		return (spec) -> spec.from(callTo(callable));
	}
	/**
	 * Syntactic sugar that makes {@link CopySpec#from} calls a little easier to read.
	 * @param <T> the result type
	 * @param callable the callable
	 * @return the callable
	 */
	private static <T> Callable<T> callTo(Callable<T> callable) {
		return callable;
	}
	private final class LibrarySpec implements Spec<FileCopyDetails> {
		@Override
		public boolean isSatisfiedBy(FileCopyDetails details) {
			return isLibrary(details);
		}
	}
	private final class ZipCompressionResolver implements Function<FileCopyDetails, ZipCompression> {
		@Override
		public ZipCompression apply(FileCopyDetails details) {
			return resolveZipCompression(details);
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class LoaderZipEntries {
	private final LoaderImplementation loaderImplementation;
	private final Long entryTime;
	private final int dirMode;
	private final int fileMode;
	LoaderZipEntries(Long entryTime, int dirMode, int fileMode, LoaderImplementation loaderImplementation) {
		this.entryTime = entryTime;
		this.dirMode = dirMode;
		this.fileMode = fileMode;
		this.loaderImplementation = (loaderImplementation != null) ? loaderImplementation
				: LoaderImplementation.DEFAULT;
	}
	WrittenEntries writeTo(ZipArchiveOutputStream out) throws IOException {
		WrittenEntries written = new WrittenEntries();
		try (ZipInputStream loaderJar = new ZipInputStream(
				getClass().getResourceAsStream('/' + this.loaderImplementation.getJarResourceName()))) {
			java.util.zip.ZipEntry entry = loaderJar.getNextEntry();
			while (entry != null) {
				if (entry.isDirectory() && !entry.getName().equals('META-INF/')) {
					writeDirectory(new ZipArchiveEntry(entry), out);
					written.addDirectory(entry);
				}
				else if (entry.getName().endsWith('.class') || entry.getName().startsWith('META-INF/services/')) {
					writeFile(new ZipArchiveEntry(entry), loaderJar, out);
					written.addFile(entry);
				}
				entry = loaderJar.getNextEntry();
			}
		}
		return written;
	}
	private void writeDirectory(ZipArchiveEntry entry, ZipArchiveOutputStream out) throws IOException {
		prepareEntry(entry, this.dirMode);
		out.putArchiveEntry(entry);
		out.closeArchiveEntry();
	}
	private void writeFile(ZipArchiveEntry entry, ZipInputStream in, ZipArchiveOutputStream out) throws IOException {
		prepareEntry(entry, this.fileMode);
		out.putArchiveEntry(entry);
		copy(in, out);
		out.closeArchiveEntry();
	}
	private void prepareEntry(ZipArchiveEntry entry, int unixMode) {
		if (this.entryTime != null) {
			entry.setTime(DefaultTimeZoneOffset.INSTANCE.removeFrom(this.entryTime));
		}
		entry.setUnixMode(unixMode);
	}
	private void copy(InputStream in, OutputStream out) throws IOException {
		StreamUtils.copy(in, out);
	}
	/**
	 * Tracks entries that have been written.
	 */
	static class WrittenEntries {
		private final Set<String> directories = new LinkedHashSet<>();
		private final Set<String> files = new LinkedHashSet<>();
		private void addDirectory(ZipEntry entry) {
			this.directories.add(entry.getName());
		}
		private void addFile(ZipEntry entry) {
			this.files.add(entry.getName());
		}
		boolean isWrittenDirectory(FileTreeElement element) {
			String path = element.getRelativePath().getPathString();
			if (element.isDirectory() && !path.endsWith(('/'))) {
				path += '/';
			}
			return this.directories.contains(path);
		}
		Set<String> getFiles() {
			return this.files;
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class BootZipCopyAction implements CopyAction {
	static final long CONSTANT_TIME_FOR_ZIP_ENTRIES = OffsetDateTime.of(1980, 2, 1, 0, 0, 0, 0, ZoneOffset.UTC)
		.toInstant()
		.toEpochMilli();
	private static final Pattern REACHABILITY_METADATA_PROPERTIES_LOCATION_PATTERN = Pattern
		.compile(ReachabilityMetadataProperties.REACHABILITY_METADATA_PROPERTIES_LOCATION_TEMPLATE.formatted('.*', '.*',
				'.*'));
	private final File output;
	private final Manifest manifest;
	private final boolean preserveFileTimestamps;
	private final Integer dirMode;
	private final Integer fileMode;
	private final boolean includeDefaultLoader;
	private final String jarmodeToolsLocation;
	private final Spec<FileTreeElement> requiresUnpack;
	private final Spec<FileTreeElement> exclusions;
	private final LaunchScriptConfiguration launchScript;
	private final Spec<FileCopyDetails> librarySpec;
	private final Function<FileCopyDetails, ZipCompression> compressionResolver;
	private final String encoding;
	private final ResolvedDependencies resolvedDependencies;
	private final boolean supportsSignatureFile;
	private final LayerResolver layerResolver;
	private final LoaderImplementation loaderImplementation;
	BootZipCopyAction(File output, Manifest manifest, boolean preserveFileTimestamps, Integer dirMode, Integer fileMode,
			boolean includeDefaultLoader, String jarmodeToolsLocation, Spec<FileTreeElement> requiresUnpack,
			Spec<FileTreeElement> exclusions, LaunchScriptConfiguration launchScript, Spec<FileCopyDetails> librarySpec,
			Function<FileCopyDetails, ZipCompression> compressionResolver, String encoding,
			ResolvedDependencies resolvedDependencies, boolean supportsSignatureFile, LayerResolver layerResolver,
			LoaderImplementation loaderImplementation) {
		this.output = output;
		this.manifest = manifest;
		this.preserveFileTimestamps = preserveFileTimestamps;
		this.dirMode = dirMode;
		this.fileMode = fileMode;
		this.includeDefaultLoader = includeDefaultLoader;
		this.jarmodeToolsLocation = jarmodeToolsLocation;
		this.requiresUnpack = requiresUnpack;
		this.exclusions = exclusions;
		this.launchScript = launchScript;
		this.librarySpec = librarySpec;
		this.compressionResolver = compressionResolver;
		this.encoding = encoding;
		this.resolvedDependencies = resolvedDependencies;
		this.supportsSignatureFile = supportsSignatureFile;
		this.layerResolver = layerResolver;
		this.loaderImplementation = loaderImplementation;
	}
	@Override
	public WorkResult execute(CopyActionProcessingStream copyActions) {
		try {
			writeArchive(copyActions);
			return WorkResults.didWork(true);
		}
		catch (IOException ex) {
			throw new GradleException('Failed to create ' + this.output, ex);
		}
	}
	private void writeArchive(CopyActionProcessingStream copyActions) throws IOException {
		OutputStream output = new FileOutputStream(this.output);
		try {
			writeArchive(copyActions, output);
		}
		finally {
			closeQuietly(output);
		}
	}
	private void writeArchive(CopyActionProcessingStream copyActions, OutputStream output) throws IOException {
		ZipArchiveOutputStream zipOutput = new ZipArchiveOutputStream(output);
		writeLaunchScriptIfNecessary(zipOutput);
		try {
			setEncodingIfNecessary(zipOutput);
			Processor processor = new Processor(zipOutput);
			copyActions.process(processor::process);
			processor.finish();
		}
		finally {
			closeQuietly(zipOutput);
		}
	}
	private void writeLaunchScriptIfNecessary(ZipArchiveOutputStream outputStream) {
		if (this.launchScript == null) {
			return;
		}
		try {
			File file = this.launchScript.getScript();
			Map<String, String> properties = this.launchScript.getProperties();
			outputStream.writePreamble(new DefaultLaunchScript(file, properties).toByteArray());
			this.output.setExecutable(true);
		}
		catch (IOException ex) {
			throw new GradleException('Failed to write launch script to ' + this.output, ex);
		}
	}
	private void setEncodingIfNecessary(ZipArchiveOutputStream zipOutputStream) {
		if (this.encoding != null) {
			zipOutputStream.setEncoding(this.encoding);
		}
	}
	private void closeQuietly(OutputStream outputStream) {
		try {
			outputStream.close();
		}
		catch (IOException ex) {
			// Ignore
		}
	}
	/**
	 * Internal process used to copy {@link FileCopyDetails file details} to the zip file.
	 */
	private class Processor {
		private final ZipArchiveOutputStream out;
		private final LayersIndex layerIndex;
		private LoaderZipEntries.WrittenEntries writtenLoaderEntries;
		private final Set<String> writtenDirectories = new LinkedHashSet<>();
		private final Map<String, FileCopyDetails> writtenLibraries = new LinkedHashMap<>();
		private final Map<String, FileCopyDetails> reachabilityMetadataProperties = new HashMap<>();
		Processor(ZipArchiveOutputStream out) {
			this.out = out;
			this.layerIndex = (BootZipCopyAction.this.layerResolver != null)
					? new LayersIndex(BootZipCopyAction.this.layerResolver.getLayers()) : null;
		}
		void process(FileCopyDetails details) {
			if (skipProcessing(details)) {
				return;
			}
			try {
				writeLoaderEntriesIfNecessary(details);
				if (details.isDirectory()) {
					processDirectory(details);
				}
				else {
					processFile(details);
				}
			}
			catch (IOException ex) {
				throw new GradleException('Failed to add ' + details + ' to ' + BootZipCopyAction.this.output, ex);
			}
		}
		private boolean skipProcessing(FileCopyDetails details) {
			return BootZipCopyAction.this.exclusions.isSatisfiedBy(details)
					|| (this.writtenLoaderEntries != null && this.writtenLoaderEntries.isWrittenDirectory(details));
		}
		private void processDirectory(FileCopyDetails details) throws IOException {
			String name = details.getRelativePath().getPathString();
			ZipArchiveEntry entry = new ZipArchiveEntry(name + "/");
			prepareEntry(entry, name, getTime(details), getFileMode(details));
			this.out.putArchiveEntry(entry);
			this.out.closeArchiveEntry();
			this.writtenDirectories.add(name);
		}
		private void processFile(FileCopyDetails details) throws IOException {
			String name = details.getRelativePath().getPathString();
			ZipArchiveEntry entry = new ZipArchiveEntry(name);
			prepareEntry(entry, name, getTime(details), getFileMode(details));
			ZipCompression compression = BootZipCopyAction.this.compressionResolver.apply(details);
			if (compression == ZipCompression.STORED) {
				prepareStoredEntry(details, entry);
			}
			this.out.putArchiveEntry(entry);
			details.copyTo(this.out);
			this.out.closeArchiveEntry();
			if (BootZipCopyAction.this.librarySpec.isSatisfiedBy(details)) {
				this.writtenLibraries.put(name, details);
			}
			if (REACHABILITY_METADATA_PROPERTIES_LOCATION_PATTERN.matcher(name).matches()) {
				this.reachabilityMetadataProperties.put(name, details);
			}
			if (BootZipCopyAction.this.layerResolver != null) {
				Layer layer = BootZipCopyAction.this.layerResolver.getLayer(details);
				this.layerIndex.add(layer, name);
			}
		}
		private void writeParentDirectoriesIfNecessary(String name, Long time) throws IOException {
			String parentDirectory = getParentDirectory(name);
			if (parentDirectory != null && this.writtenDirectories.add(parentDirectory)) {
				ZipArchiveEntry entry = new ZipArchiveEntry(parentDirectory + "/");
				prepareEntry(entry, parentDirectory, time, getDirMode());
				this.out.putArchiveEntry(entry);
				this.out.closeArchiveEntry();
			}
		}
		private String getParentDirectory(String name) {
			int lastSlash = name.lastIndexOf("/");
			if (lastSlash == -1) {
				return null;
			}
			return name.substring(0, lastSlash);
		}
		void finish() throws IOException {
			writeLoaderEntriesIfNecessary(null);
			writeJarToolsIfNecessary();
			writeSignatureFileIfNecessary();
			writeClassPathIndexIfNecessary();
			writeNativeImageArgFileIfNecessary();
			// We must write the layer index last
			writeLayersIndexIfNecessary();
		}
		private void writeLoaderEntriesIfNecessary(FileCopyDetails details) throws IOException {
			if (!BootZipCopyAction.this.includeDefaultLoader || this.writtenLoaderEntries != null) {
				return;
			}
			if (isInMetaInf(details)) {
				// Always write loader entries after META-INF directory (see gh-16698)
				return;
			}
			LoaderZipEntries loaderEntries = new LoaderZipEntries(getTime(), getDirMode(), getFileMode(),
					BootZipCopyAction.this.loaderImplementation);
			this.writtenLoaderEntries = loaderEntries.writeTo(this.out);
			if (BootZipCopyAction.this.layerResolver != null) {
				for (String name : this.writtenLoaderEntries.getFiles()) {
					Layer layer = BootZipCopyAction.this.layerResolver.getLayer(name);
					this.layerIndex.add(layer, name);
				}
			}
		}
		private boolean isInMetaInf(FileCopyDetails details) {
			if (details == null) {
				return false;
			}
			String[] segments = details.getRelativePath().getSegments();
			return segments.length > 0 && 'META-INF'.equals(segments[0]);
		}
		private void writeJarToolsIfNecessary() throws IOException {
			if (BootZipCopyAction.this.jarmodeToolsLocation != null) {
				writeJarModeLibrary(BootZipCopyAction.this.jarmodeToolsLocation, JarModeLibrary.TOOLS);
			}
		}
		private void writeJarModeLibrary(String location, JarModeLibrary library) throws IOException {
			String name = location + library.getName();
			writeEntry(name, ZipEntryContentWriter.fromInputStream(library.openStream()), false,
					(entry) -> prepareStoredEntry(library.openStream(), entry));
			if (BootZipCopyAction.this.layerResolver != null) {
				Layer layer = BootZipCopyAction.this.layerResolver.getLayer(library);
				this.layerIndex.add(layer, name);
			}
		}
		private void writeSignatureFileIfNecessary() throws IOException {
			if (BootZipCopyAction.this.supportsSignatureFile && hasSignedLibrary()) {
				writeEntry('META-INF/BOOT.SF', (out) -> {
				}, false);
			}
		}
		private boolean hasSignedLibrary() throws IOException {
			for (FileCopyDetails writtenLibrary : this.writtenLibraries.values()) {
				if (FileUtils.isSignedJarFile(writtenLibrary.getFile())) {
					return true;
				}
			}
			return false;
		}
		private void writeClassPathIndexIfNecessary() throws IOException {
			Attributes manifestAttributes = BootZipCopyAction.this.manifest.getAttributes();
			String classPathIndex = (String) manifestAttributes.get('Spring-Boot-Classpath-Index');
			if (classPathIndex != null) {
				Set<String> libraryNames = this.writtenLibraries.keySet();
				List<String> lines = libraryNames.stream().map((line) -> '- \'' + line + '\'').toList();
				ZipEntryContentWriter writer = ZipEntryContentWriter.fromLines(BootZipCopyAction.this.encoding, lines);
				writeEntry(classPathIndex, writer, true);
			}
		}
		private void writeNativeImageArgFileIfNecessary() throws IOException {
			Set<String> excludes = new LinkedHashSet<>();
			for (Map.Entry<String, FileCopyDetails> entry : this.writtenLibraries.entrySet()) {
				DependencyDescriptor descriptor = BootZipCopyAction.this.resolvedDependencies
					.find(entry.getValue().getFile());
				LibraryCoordinates coordinates = (descriptor != null) ? descriptor.getCoordinates() : null;
				FileCopyDetails propertiesFile = (coordinates != null) ? this.reachabilityMetadataProperties
					.get(ReachabilityMetadataProperties.getLocation(coordinates)) : null;
				if (propertiesFile != null) {
					try (InputStream inputStream = propertiesFile.open()) {
						ReachabilityMetadataProperties properties = ReachabilityMetadataProperties
							.fromInputStream(inputStream);
						if (properties.isOverridden()) {
							excludes.add(entry.getKey());
						}
					}
				}
			}
			NativeImageArgFile argFile = new NativeImageArgFile(excludes);
			argFile.writeIfNecessary((lines) -> {
				ZipEntryContentWriter writer = ZipEntryContentWriter.fromLines(BootZipCopyAction.this.encoding, lines);
				writeEntry(NativeImageArgFile.LOCATION, writer, true);
			});
		}
		private void writeLayersIndexIfNecessary() throws IOException {
			if (BootZipCopyAction.this.layerResolver != null) {
				Attributes manifestAttributes = BootZipCopyAction.this.manifest.getAttributes();
				String name = (String) manifestAttributes.get('Spring-Boot-Layers-Index');
				Assert.state(StringUtils.hasText(name), 'Missing layer index manifest attribute');
				Layer layer = BootZipCopyAction.this.layerResolver.getLayer(name);
				this.layerIndex.add(layer, name);
				writeEntry(name, this.layerIndex::writeTo, false);
			}
		}
		private void writeEntry(String name, ZipEntryContentWriter entryWriter, boolean addToLayerIndex)
				throws IOException {
			writeEntry(name, entryWriter, addToLayerIndex, ZipEntryCustomizer.NONE);
		}
		private void writeEntry(String name, ZipEntryContentWriter entryWriter, boolean addToLayerIndex,
				ZipEntryCustomizer entryCustomizer) throws IOException {
			ZipArchiveEntry entry = new ZipArchiveEntry(name);
			prepareEntry(entry, name, getTime(), getFileMode());
			entryCustomizer.customize(entry);
			this.out.putArchiveEntry(entry);
			entryWriter.writeTo(this.out);
			this.out.closeArchiveEntry();
			if (addToLayerIndex && BootZipCopyAction.this.layerResolver != null) {
				Layer layer = BootZipCopyAction.this.layerResolver.getLayer(name);
				this.layerIndex.add(layer, name);
			}
		}
		private void prepareEntry(ZipArchiveEntry entry, String name, Long time, int mode) throws IOException {
			writeParentDirectoriesIfNecessary(name, time);
			entry.setUnixMode(mode);
			if (time != null) {
				entry.setTime(DefaultTimeZoneOffset.INSTANCE.removeFrom(time));
			}
		}
		private void prepareStoredEntry(FileCopyDetails details, ZipArchiveEntry archiveEntry) throws IOException {
			prepareStoredEntry(details.open(), archiveEntry);
			if (BootZipCopyAction.this.requiresUnpack.isSatisfiedBy(details)) {
				archiveEntry.setComment('UNPACK:' + FileUtils.sha1Hash(details.getFile()));
			}
		}
		private void prepareStoredEntry(InputStream input, ZipArchiveEntry archiveEntry) throws IOException {
			new CrcAndSize(input).setUpStoredEntry(archiveEntry);
		}
		private Long getTime() {
			return getTime(null);
		}
		private Long getTime(FileCopyDetails details) {
			if (!BootZipCopyAction.this.preserveFileTimestamps) {
				return CONSTANT_TIME_FOR_ZIP_ENTRIES;
			}
			if (details != null) {
				return details.getLastModified();
			}
			return null;
		}
		private int getDirMode() {
			return (BootZipCopyAction.this.dirMode != null) ? BootZipCopyAction.this.dirMode
					: UnixStat.DIR_FLAG | UnixStat.DEFAULT_DIR_PERM;
		}
		private int getFileMode() {
			return (BootZipCopyAction.this.fileMode != null) ? BootZipCopyAction.this.fileMode
					: UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM;
		}
		private int getFileMode(FileCopyDetails details) {
			return (BootZipCopyAction.this.fileMode != null) ? BootZipCopyAction.this.fileMode
					: UnixStat.FILE_FLAG | getPermissions(details);
		}
		private int getPermissions(FileCopyDetails details) {
			return (GradleVersion.current().compareTo(GradleVersion.version('8.3')) >= 0)
					? details.getPermissions().toUnixNumeric() : getMode(details);
		}
		@SuppressWarnings('deprecation')
		private int getMode(FileCopyDetails details) {
			return details.getMode();
		}
	}
	/**
	 * Callback interface used to customize a {@link ZipArchiveEntry}.
	 */
	@FunctionalInterface
	private interface ZipEntryCustomizer {
		ZipEntryCustomizer NONE = (entry) -> {
		};
		/**
		 * Customize the entry.
		 * @param entry the entry to customize
		 * @throws IOException on IO error
		 */
		void customize(ZipArchiveEntry entry) throws IOException;
	}
	/**
	 * Callback used to write a zip entry data.
	 */
	@FunctionalInterface
	private interface ZipEntryContentWriter {
		/**
		 * Write the entry data.
		 * @param out the output stream used to write the data
		 * @throws IOException on IO error
		 */
		void writeTo(ZipArchiveOutputStream out) throws IOException;
		/**
		 * Create a new {@link ZipEntryContentWriter} that will copy content from the
		 * given {@link InputStream}.
		 * @param in the source input stream
		 * @return a new {@link ZipEntryContentWriter} instance
		 */
		static ZipEntryContentWriter fromInputStream(InputStream in) {
			return (out) -> {
				StreamUtils.copy(in, out);
				in.close();
			};
		}
		/**
		 * Create a new {@link ZipEntryContentWriter} that will copy content from the
		 * given lines.
		 * @param encoding the required character encoding
		 * @param lines the lines to write
		 * @return a new {@link ZipEntryContentWriter} instance
		 */
		static ZipEntryContentWriter fromLines(String encoding, Collection<String> lines) {
			return (out) -> {
				OutputStreamWriter writer = new OutputStreamWriter(out, encoding);
				for (String line : lines) {
					writer.append(line).append('\n');
				}
				writer.flush();
			};
		}
	}
	/**
	 * Data holder for CRC and Size.
	 */
	private static class CrcAndSize {
		private static final int BUFFER_SIZE = 32 * 1024;
		private final CRC32 crc = new CRC32();
		private long size;
		CrcAndSize(InputStream inputStream) throws IOException {
			try (inputStream) {
				load(inputStream);
			}
		}
		private void load(InputStream inputStream) throws IOException {
			byte[] buffer = new byte[BUFFER_SIZE];
			int bytesRead;
			while ((bytesRead = inputStream.read(buffer)) != -1) {
				this.crc.update(buffer, 0, bytesRead);
				this.size += bytesRead;
			}
		}
		void setUpStoredEntry(ZipArchiveEntry entry) {
			entry.setSize(this.size);
			entry.setCompressedSize(this.size);
			entry.setCrc(this.crc.getValue());
			entry.setMethod(ZipEntry.STORED);
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
public class CacheSpec {
	private final ObjectFactory objectFactory;
	private Cache cache = null;
	@Inject
	public CacheSpec(ObjectFactory objectFactory) {
		this.objectFactory = objectFactory;
	}
	public Cache asCache() {
		return this.cache;
	}
	/**
	 * Configures a volume cache using the given {@code action}.
	 * @param action the action
	 */
	public void volume(Action<VolumeCacheSpec> action) {
		if (this.cache != null) {
			throw new GradleException('Each image building cache can be configured only once');
		}
		VolumeCacheSpec spec = this.objectFactory.newInstance(VolumeCacheSpec.class);
		action.execute(spec);
		this.cache = Cache.volume(spec.getName().get());
	}
	/**
	 * Configures a bind cache using the given {@code action}.
	 * @param action the action
	 */
	public void bind(Action<BindCacheSpec> action) {
		if (this.cache != null) {
			throw new GradleException('Each image building cache can be configured only once');
		}
		BindCacheSpec spec = this.objectFactory.newInstance(BindCacheSpec.class);
		action.execute(spec);
		this.cache = Cache.bind(spec.getSource().get());
	}
	/**
	 * Configuration for an image building cache stored in a Docker volume.
	 */
	public abstract static class VolumeCacheSpec {
		/**
		 * Returns the name of the cache.
		 * @return the cache name
		 */
		@Input
		public abstract Property<String> getName();
	}
	/**
	 * Configuration for an image building cache stored in a bind mount.
	 */
	public abstract static class BindCacheSpec {
		/**
		 * Returns the source of the cache.
		 * @return the cache source
		 */
		@Input
		public abstract Property<String> getSource();
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class LayerResolver {
	private final ResolvedDependencies resolvedDependencies;
	private final LayeredSpec layeredConfiguration;
	private final Spec<FileCopyDetails> librarySpec;
	LayerResolver(ResolvedDependencies resolvedDependencies, LayeredSpec layeredConfiguration,
			Spec<FileCopyDetails> librarySpec) {
		this.resolvedDependencies = resolvedDependencies;
		this.layeredConfiguration = layeredConfiguration;
		this.librarySpec = librarySpec;
	}
	Layer getLayer(FileCopyDetails details) {
		try {
			if (this.librarySpec.isSatisfiedBy(details)) {
				return getLayer(asLibrary(details));
			}
			return getLayer(details.getSourcePath());
		}
		catch (UnsupportedOperationException ex) {
			return null;
		}
	}
	Layer getLayer(Library library) {
		return this.layeredConfiguration.asLayers().getLayer(library);
	}
	Layer getLayer(String applicationResource) {
		return this.layeredConfiguration.asLayers().getLayer(applicationResource);
	}
	Iterable<Layer> getLayers() {
		return this.layeredConfiguration.asLayers();
	}
	private Library asLibrary(FileCopyDetails details) {
		File file = details.getFile();
		DependencyDescriptor dependency = this.resolvedDependencies.find(file);
		if (dependency == null) {
			return new Library(null, file, null, null, false, false, true);
		}
		LibraryCoordinates coordinates = dependency.getCoordinates();
		boolean projectDependency = dependency.isProjectDependency();
		return new Library(null, file, null, coordinates, false, projectDependency, true);
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@SuppressWarnings('serial')
public class LaunchScriptConfiguration implements Serializable {
	private static final Pattern WHITE_SPACE_PATTERN = Pattern.compile('\\s+');
	private static final Pattern LINE_FEED_PATTERN = Pattern.compile('\n');
	// We don"t care about the order, but Gradle"s configuration cache currently does.
	// https://github.com/gradle/gradle/pull/17863
	private final Map<String, String> properties = new TreeMap<>();
	private File script;
	public LaunchScriptConfiguration() {
	}
	LaunchScriptConfiguration(AbstractArchiveTask archiveTask) {
		Project project = archiveTask.getProject();
		String baseName = archiveTask.getArchiveBaseName().get();
		putIfMissing(this.properties, 'initInfoProvides', baseName);
		putIfMissing(this.properties, 'initInfoShortDescription', removeLineBreaks(project.getDescription()), baseName);
		putIfMissing(this.properties, 'initInfoDescription', augmentLineBreaks(project.getDescription()), baseName);
	}
	/**
	 * Returns the properties that are applied to the launch script when it"s being
	 * including in the executable archive.
	 * @return the properties
	 */
	@Input
	public Map<String, String> getProperties() {
		return this.properties;
	}
	/**
	 * Sets the properties that are applied to the launch script when it"s being including
	 * in the executable archive.
	 * @param properties the properties
	 */
	public void properties(Map<String, String> properties) {
		this.properties.putAll(properties);
	}
	/**
	 * Returns the script {@link File} that will be included in the executable archive.
	 * When {@code null}, the default launch script will be used.
	 * @return the script file
	 */
	@Optional
	@InputFile
	@PathSensitive(PathSensitivity.RELATIVE)
	public File getScript() {
		return this.script;
	}
	/**
	 * Sets the script {@link File} that will be included in the executable archive. When
	 * {@code null}, the default launch script will be used.
	 * @param script the script file
	 */
	public void setScript(File script) {
		this.script = script;
	}
	private String removeLineBreaks(String string) {
		return (string != null) ? WHITE_SPACE_PATTERN.matcher(string).replaceAll(' ') : null;
	}
	private String augmentLineBreaks(String string) {
		return (string != null) ? LINE_FEED_PATTERN.matcher(string).replaceAll('\n#  ') : null;
	}
	private void putIfMissing(Map<String, String> properties, String key, String... valueCandidates) {
		if (!properties.containsKey(key)) {
			for (String candidate : valueCandidates) {
				if (StringUtils.hasLength(candidate)) {
					properties.put(key, candidate);
					return;
				}
			}
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
public abstract class LayeredSpec {
	private ApplicationSpec application;
	private DependenciesSpec dependencies;
	private Layers layers;
	@Inject
	public LayeredSpec(ObjectFactory objects) {
		this.application = objects.newInstance(ApplicationSpec.class);
		this.dependencies = objects.newInstance(DependenciesSpec.class);
		getEnabled().convention(true);
		getIncludeLayerTools().convention(true);
	}
	/**
	 * Returns whether the layer tools should be included as a dependency in the layered
	 * archive.
	 * @return whether the layer tools should be included
	 * @since 3.0.0
	 * @deprecated since 3.3.0 for removal in 3.5.0 in favor of {@code includeTools}.
	 */
	@Input
	@Deprecated(since = '3.3.0', forRemoval = true)
	public abstract Property<Boolean> getIncludeLayerTools();
	/**
	 * Returns whether the layers.idx should be included in the archive.
	 * @return whether the layers.idx should be included
	 * @since 3.0.0
	 */
	@Input
	public abstract Property<Boolean> getEnabled();
	/**
	 * Returns the {@link ApplicationSpec} that controls the layers to which application
	 * classes and resources belong.
	 * @return the application spec
	 */
	@Input
	public ApplicationSpec getApplication() {
		return this.application;
	}
	/**
	 * Sets the {@link ApplicationSpec} that controls the layers to which application
	 * classes are resources belong.
	 * @param spec the application spec
	 */
	public void setApplication(ApplicationSpec spec) {
		this.application = spec;
	}
	/**
	 * Customizes the {@link ApplicationSpec} using the given {@code action}.
	 * @param action the action
	 */
	public void application(Action<ApplicationSpec> action) {
		action.execute(this.application);
	}
	/**
	 * Returns the {@link DependenciesSpec} that controls the layers to which dependencies
	 * belong.
	 * @return the dependencies spec
	 */
	@Input
	public DependenciesSpec getDependencies() {
		return this.dependencies;
	}
	/**
	 * Sets the {@link DependenciesSpec} that controls the layers to which dependencies
	 * belong.
	 * @param spec the dependencies spec
	 */
	public void setDependencies(DependenciesSpec spec) {
		this.dependencies = spec;
	}
	/**
	 * Customizes the {@link DependenciesSpec} using the given {@code action}.
	 * @param action the action
	 */
	public void dependencies(Action<DependenciesSpec> action) {
		action.execute(this.dependencies);
	}
	/**
	 * Returns the order of the layers in the archive from least to most frequently
	 * changing.
	 * @return the layer order
	 */
	@Input
	@Optional
	public abstract ListProperty<String> getLayerOrder();
	/**
	 * Return this configuration as a {@link Layers} instance. This method should only be
	 * called when the configuration is complete and will no longer be changed.
	 * @return the layers
	 */
	Layers asLayers() {
		Layers layers = this.layers;
		if (layers == null) {
			layers = createLayers();
			this.layers = layers;
		}
		return layers;
	}
	private Layers createLayers() {
		List<String> layerOrder = getLayerOrder().getOrNull();
		if (layerOrder == null || layerOrder.isEmpty()) {
			Assert.state(this.application.isEmpty() && this.dependencies.isEmpty(),
					'The "layerOrder" must be defined when using custom layering');
			return Layers.IMPLICIT;
		}
		List<Layer> layers = layerOrder.stream().map(Layer::new).toList();
		return new CustomLayers(layers, this.application.asSelectors(), this.dependencies.asSelectors());
	}
	/**
	 * Base class for specs that control the layers to which a category of content should
	 * belong.
	 *
	 * @param <S> the type of {@link IntoLayerSpec} used by this spec
	 */
	public abstract static class IntoLayersSpec<S extends IntoLayerSpec> implements Serializable {
		private final List<IntoLayerSpec> intoLayers;
		private final Function<String, S> specFactory;
		boolean isEmpty() {
			return this.intoLayers.isEmpty();
		}
		IntoLayersSpec(Function<String, S> specFactory, IntoLayerSpec... spec) {
			this.intoLayers = new ArrayList<>(Arrays.asList(spec));
			this.specFactory = specFactory;
		}
		public void intoLayer(String layer) {
			this.intoLayers.add(this.specFactory.apply(layer));
		}
		public void intoLayer(String layer, Action<S> action) {
			S spec = this.specFactory.apply(layer);
			action.execute(spec);
			this.intoLayers.add(spec);
		}
		<T> List<ContentSelector<T>> asSelectors(Function<IntoLayerSpec, ContentSelector<T>> selectorFactory) {
			return this.intoLayers.stream().map(selectorFactory).toList();
		}
	}
	/**
	 * Spec that controls the content that should be part of a particular layer.
	 */
	public static class IntoLayerSpec implements Serializable {
		private final String intoLayer;
		private final List<String> includes = new ArrayList<>();
		private final List<String> excludes = new ArrayList<>();
		/**
		 * Creates a new {@code IntoLayerSpec} that will control the content of the given
		 * layer.
		 * @param intoLayer the layer
		 */
		public IntoLayerSpec(String intoLayer) {
			this.intoLayer = intoLayer;
		}
		/**
		 * Adds patterns that control the content that is included in the layer. If no
		 * includes are specified then all content is included. If includes are specified
		 * then content must match an inclusion and not match any exclusions to be
		 * included.
		 * @param patterns the patterns to be included
		 */
		public void include(String... patterns) {
			this.includes.addAll(Arrays.asList(patterns));
		}
		/**
		 * Adds patterns that control the content that is excluded from the layer. If no
		 * excludes a specified no content is excluded. If exclusions are specified then
		 * any content that matches an exclusion will be excluded irrespective of whether
		 * it matches an include.
		 * @param patterns the patterns to be excluded
		 */
		public void exclude(String... patterns) {
			this.includes.addAll(Arrays.asList(patterns));
		}
		<T> ContentSelector<T> asSelector(Function<String, ContentFilter<T>> filterFactory) {
			Layer layer = new Layer(this.intoLayer);
			return new IncludeExcludeContentSelector<>(layer, this.includes, this.excludes, filterFactory);
		}
		String getIntoLayer() {
			return this.intoLayer;
		}
		List<String> getIncludes() {
			return this.includes;
		}
		List<String> getExcludes() {
			return this.excludes;
		}
	}
	/**
	 * Spec that controls the dependencies that should be part of a particular layer.
	 *
	 * @since 2.4.0
	 */
	public static class DependenciesIntoLayerSpec extends IntoLayerSpec {
		private boolean includeProjectDependencies;
		private boolean excludeProjectDependencies;
		/**
		 * Creates a new {@code IntoLayerSpec} that will control the content of the given
		 * layer.
		 * @param intoLayer the layer
		 */
		public DependenciesIntoLayerSpec(String intoLayer) {
			super(intoLayer);
		}
		/**
		 * Configures the layer to include project dependencies. If no includes are
		 * specified then all content is included. If includes are specified then content
		 * must match an inclusion and not match any exclusions to be included.
		 */
		public void includeProjectDependencies() {
			this.includeProjectDependencies = true;
		}
		/**
		 * Configures the layer to exclude project dependencies. If no excludes a
		 * specified no content is excluded. If exclusions are specified then any content
		 * that matches an exclusion will be excluded irrespective of whether it matches
		 * an include.
		 */
		public void excludeProjectDependencies() {
			this.excludeProjectDependencies = true;
		}
		ContentSelector<Library> asLibrarySelector(Function<String, ContentFilter<Library>> filterFactory) {
			Layer layer = new Layer(getIntoLayer());
			List<ContentFilter<Library>> includeFilters = getIncludes().stream()
				.map(filterFactory)
				.collect(Collectors.toCollection(ArrayList::new));
			if (this.includeProjectDependencies) {
				includeFilters.add(Library::isLocal);
			}
			List<ContentFilter<Library>> excludeFilters = getExcludes().stream()
				.map(filterFactory)
				.collect(Collectors.toCollection(ArrayList::new));
			if (this.excludeProjectDependencies) {
				excludeFilters.add(Library::isLocal);
			}
			return new IncludeExcludeContentSelector<>(layer, includeFilters, excludeFilters);
		}
	}
	/**
	 * An {@link IntoLayersSpec} that controls the layers to which application classes and
	 * resources belong.
	 */
	public static class ApplicationSpec extends IntoLayersSpec<IntoLayerSpec> {
		@Inject
		public ApplicationSpec() {
			super(new IntoLayerSpecFactory());
		}
		/**
		 * Creates a new {@code ApplicationSpec} with the given {@code contents}.
		 * @param contents specs for the layers in which application content should be
		 * included
		 */
		public ApplicationSpec(IntoLayerSpec... contents) {
			super(new IntoLayerSpecFactory(), contents);
		}
		List<ContentSelector<String>> asSelectors() {
			return asSelectors((spec) -> spec.asSelector(ApplicationContentFilter::new));
		}
		private static final class IntoLayerSpecFactory implements Function<String, IntoLayerSpec>, Serializable {
			@Override
			public IntoLayerSpec apply(String layer) {
				return new IntoLayerSpec(layer);
			}
		}
	}
	/**
	 * An {@link IntoLayersSpec} that controls the layers to which dependencies belong.
	 */
	public static class DependenciesSpec extends IntoLayersSpec<DependenciesIntoLayerSpec> implements Serializable {
		@Inject
		public DependenciesSpec() {
			super(new IntoLayerSpecFactory());
		}
		/**
		 * Creates a new {@code DependenciesSpec} with the given {@code contents}.
		 * @param contents specs for the layers in which dependencies should be included
		 */
		public DependenciesSpec(DependenciesIntoLayerSpec... contents) {
			super(new IntoLayerSpecFactory(), contents);
		}
		List<ContentSelector<Library>> asSelectors() {
			return asSelectors(
					(spec) -> ((DependenciesIntoLayerSpec) spec).asLibrarySelector(LibraryContentFilter::new));
		}
		private static final class IntoLayerSpecFactory
				implements Function<String, DependenciesIntoLayerSpec>, Serializable {
			@Override
			public DependenciesIntoLayerSpec apply(String layer) {
				return new DependenciesIntoLayerSpec(layer);
			}
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
@DisableCachingByDefault(because = 'Not worth caching')
public abstract class BootJar extends Jar implements BootArchive {
	private static final String LAUNCHER = 'org.springframework.boot.loader.launch.JarLauncher';
	private static final String CLASSES_DIRECTORY = 'BOOT-INF/classes/';
	private static final String LIB_DIRECTORY = 'BOOT-INF/lib/';
	private static final String LAYERS_INDEX = 'BOOT-INF/layers.idx';
	private static final String CLASSPATH_INDEX = 'BOOT-INF/classpath.idx';
	private final BootArchiveSupport support;
	private final CopySpec bootInfSpec;
	private final LayeredSpec layered;
	private final Provider<String> projectName;
	private final Provider<Object> projectVersion;
	private final ResolvedDependencies resolvedDependencies;
	private FileCollection classpath;
	/**
	 * Creates a new {@code BootJar} task.
	 */
	public BootJar() {
		this.support = new BootArchiveSupport(LAUNCHER, new LibrarySpec(), new ZipCompressionResolver());
		Project project = getProject();
		this.bootInfSpec = project.copySpec().into('BOOT-INF');
		this.layered = project.getObjects().newInstance(LayeredSpec.class);
		configureBootInfSpec(this.bootInfSpec);
		getMainSpec().with(this.bootInfSpec);
		this.projectName = project.provider(project::getName);
		this.projectVersion = project.provider(project::getVersion);
		this.resolvedDependencies = new ResolvedDependencies(project);
		getIncludeTools().convention(true);
	}
	private void configureBootInfSpec(CopySpec bootInfSpec) {
		bootInfSpec.into('classes', fromCallTo(this::classpathDirectories));
		bootInfSpec.into('lib', fromCallTo(this::classpathFiles)).eachFile(this.support::excludeNonZipFiles);
		this.support.moveModuleInfoToRoot(bootInfSpec);
		moveMetaInfToRoot(bootInfSpec);
	}
	private Iterable<File> classpathDirectories() {
		return classpathEntries(File::isDirectory);
	}
	private Iterable<File> classpathFiles() {
		return classpathEntries(File::isFile);
	}
	private Iterable<File> classpathEntries(Spec<File> filter) {
		return (this.classpath != null) ? this.classpath.filter(filter) : Collections.emptyList();
	}
	private void moveMetaInfToRoot(CopySpec spec) {
		spec.eachFile((file) -> {
			String path = file.getRelativeSourcePath().getPathString();
			if (path.startsWith('META-INF/') && !path.equals('META-INF/aop.xml') && !path.endsWith('.kotlin_module')
					&& !path.startsWith('META-INF/services/')) {
				this.support.moveToRoot(file);
			}
		});
	}
	@Override
	public void resolvedArtifacts(Provider<Set<ResolvedArtifactResult>> resolvedArtifacts) {
		this.resolvedDependencies.resolvedArtifacts(resolvedArtifacts);
	}
	@Nested
	ResolvedDependencies getResolvedDependencies() {
		return this.resolvedDependencies;
	}
	@Override
	public void copy() {
		this.support.configureManifest(getManifest(), getMainClass().get(), CLASSES_DIRECTORY, LIB_DIRECTORY,
				CLASSPATH_INDEX, (isLayeredDisabled()) ? null : LAYERS_INDEX,
				this.getTargetJavaVersion().get().getMajorVersion(), this.projectName.get(), this.projectVersion.get());
		super.copy();
	}
	private boolean isLayeredDisabled() {
		return !getLayered().getEnabled().get();
	}
	@Override
	protected CopyAction createCopyAction() {
		LoaderImplementation loaderImplementation = getLoaderImplementation().getOrElse(LoaderImplementation.DEFAULT);
		LayerResolver layerResolver = null;
		if (!isLayeredDisabled()) {
			layerResolver = new LayerResolver(this.resolvedDependencies, this.layered, this::isLibrary);
		}
		String jarmodeToolsLocation = isIncludeJarmodeTools() ? LIB_DIRECTORY : null;
		return this.support.createCopyAction(this, this.resolvedDependencies, loaderImplementation, true, layerResolver,
				jarmodeToolsLocation);
	}
	@SuppressWarnings('removal')
	private boolean isIncludeJarmodeTools() {
		return Boolean.TRUE.equals(this.getIncludeTools().get())
				&& Boolean.TRUE.equals(this.layered.getIncludeLayerTools().get());
	}
	@Override
	public void requiresUnpack(String... patterns) {
		this.support.requiresUnpack(patterns);
	}
	@Override
	public void requiresUnpack(Spec<FileTreeElement> spec) {
		this.support.requiresUnpack(spec);
	}
	@Override
	public LaunchScriptConfiguration getLaunchScript() {
		return this.support.getLaunchScript();
	}
	@Override
	public void launchScript() {
		enableLaunchScriptIfNecessary();
	}
	@Override
	public void launchScript(Action<LaunchScriptConfiguration> action) {
		action.execute(enableLaunchScriptIfNecessary());
	}
	/**
	 * Returns the spec that describes the layers in a layered jar.
	 * @return the spec for the layers
	 * @since 2.3.0
	 */
	@Nested
	public LayeredSpec getLayered() {
		return this.layered;
	}
	/**
	 * Configures the jar"s layering using the given {@code action}.
	 * @param action the action to apply
	 * @since 2.3.0
	 */
	public void layered(Action<LayeredSpec> action) {
		action.execute(this.layered);
	}
	@Override
	public FileCollection getClasspath() {
		return this.classpath;
	}
	@Override
	public void classpath(Object... classpath) {
		FileCollection existingClasspath = this.classpath;
		this.classpath = getProject().files((existingClasspath != null) ? existingClasspath : Collections.emptyList(),
				classpath);
	}
	@Override
	public void setClasspath(Object classpath) {
		this.classpath = getProject().files(classpath);
	}
	@Override
	public void setClasspath(FileCollection classpath) {
		this.classpath = getProject().files(classpath);
	}
	/**
	 * Returns a {@code CopySpec} that can be used to add content to the {@code BOOT-INF}
	 * directory of the jar.
	 * @return a {@code CopySpec} for {@code BOOT-INF}
	 * @since 2.0.3
	 */
	@Internal
	public CopySpec getBootInf() {
		CopySpec child = getProject().copySpec();
		this.bootInfSpec.with(child);
		return child;
	}
	/**
	 * Calls the given {@code action} to add content to the {@code BOOT-INF} directory of
	 * the jar.
	 * @param action the {@code Action} to call
	 * @return the {@code CopySpec} for {@code BOOT-INF} that was passed to the
	 * {@code Action}
	 * @since 2.0.3
	 */
	public CopySpec bootInf(Action<CopySpec> action) {
		CopySpec bootInf = getBootInf();
		action.execute(bootInf);
		return bootInf;
	}
	/**
	 * Return the {@link ZipCompression} that should be used when adding the file
	 * represented by the given {@code details} to the jar. By default, any
	 * {@link #isLibrary(FileCopyDetails) library} is {@link ZipCompression#STORED stored}
	 * and all other files are {@link ZipCompression#DEFLATED deflated}.
	 * @param details the file copy details
	 * @return the compression to use
	 */
	protected ZipCompression resolveZipCompression(FileCopyDetails details) {
		return isLibrary(details) ? ZipCompression.STORED : ZipCompression.DEFLATED;
	}
	/**
	 * Return if the {@link FileCopyDetails} are for a library. By default any file in
	 * {@code BOOT-INF/lib} is considered to be a library.
	 * @param details the file copy details
	 * @return {@code true} if the details are for a library
	 * @since 2.3.0
	 */
	protected boolean isLibrary(FileCopyDetails details) {
		String path = details.getRelativePath().getPathString();
		return path.startsWith(LIB_DIRECTORY);
	}
	private LaunchScriptConfiguration enableLaunchScriptIfNecessary() {
		LaunchScriptConfiguration launchScript = this.support.getLaunchScript();
		if (launchScript == null) {
			launchScript = new LaunchScriptConfiguration(this);
			this.support.setLaunchScript(launchScript);
		}
		return launchScript;
	}
	/**
	 * Syntactic sugar that makes {@link CopySpec#into} calls a little easier to read.
	 * @param <T> the result type
	 * @param callable the callable
	 * @return an action to add the callable to the spec
	 */
	private static <T> Action<CopySpec> fromCallTo(Callable<T> callable) {
		return (spec) -> spec.from(callTo(callable));
	}
	/**
	 * Syntactic sugar that makes {@link CopySpec#from} calls a little easier to read.
	 * @param <T> the result type
	 * @param callable the callable
	 * @return the callable
	 */
	private static <T> Callable<T> callTo(Callable<T> callable) {
		return callable;
	}
	private final class LibrarySpec implements Spec<FileCopyDetails> {
		@Override
		public boolean isSatisfiedBy(FileCopyDetails details) {
			return isLibrary(details);
		}
	}
	private final class ZipCompressionResolver implements Function<FileCopyDetails, ZipCompression> {
		@Override
		public ZipCompression apply(FileCopyDetails details) {
			return resolveZipCompression(details);
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
public abstract class DockerSpec {
	private final DockerRegistrySpec builderRegistry;
	private final DockerRegistrySpec publishRegistry;
	@Inject
	public DockerSpec(ObjectFactory objects) {
		this.builderRegistry = objects.newInstance(DockerRegistrySpec.class);
		this.publishRegistry = objects.newInstance(DockerRegistrySpec.class);
		getBindHostToBuilder().convention(false);
		getTlsVerify().convention(false);
	}
	DockerSpec(DockerRegistrySpec builderRegistry, DockerRegistrySpec publishRegistry) {
		this.builderRegistry = builderRegistry;
		this.publishRegistry = publishRegistry;
	}
	@Input
	@Optional
	public abstract Property<String> getContext();
	@Input
	@Optional
	public abstract Property<String> getHost();
	@Input
	@Optional
	public abstract Property<Boolean> getTlsVerify();
	@Input
	@Optional
	public abstract Property<String> getCertPath();
	@Input
	@Optional
	public abstract Property<Boolean> getBindHostToBuilder();
	/**
	 * Returns the {@link DockerRegistrySpec} that configures authentication to the
	 * builder registry.
	 * @return the registry spec
	 */
	@Nested
	public DockerRegistrySpec getBuilderRegistry() {
		return this.builderRegistry;
	}
	/**
	 * Customizes the {@link DockerRegistrySpec} that configures authentication to the
	 * builder registry.
	 * @param action the action to apply
	 */
	public void builderRegistry(Action<DockerRegistrySpec> action) {
		action.execute(this.builderRegistry);
	}
	/**
	 * Returns the {@link DockerRegistrySpec} that configures authentication to the
	 * publishing registry.
	 * @return the registry spec
	 */
	@Nested
	public DockerRegistrySpec getPublishRegistry() {
		return this.publishRegistry;
	}
	/**
	 * Customizes the {@link DockerRegistrySpec} that configures authentication to the
	 * publishing registry.
	 * @param action the action to apply
	 */
	public void publishRegistry(Action<DockerRegistrySpec> action) {
		action.execute(this.publishRegistry);
	}
	/**
	 * Returns this configuration as a {@link DockerConfiguration} instance. This method
	 * should only be called when the configuration is complete and will no longer be
	 * changed.
	 * @return the Docker configuration
	 */
	DockerConfiguration asDockerConfiguration() {
		DockerConfiguration dockerConfiguration = new DockerConfiguration();
		dockerConfiguration = customizeHost(dockerConfiguration);
		dockerConfiguration = dockerConfiguration.withBindHostToBuilder(getBindHostToBuilder().get());
		dockerConfiguration = customizeBuilderAuthentication(dockerConfiguration);
		dockerConfiguration = customizePublishAuthentication(dockerConfiguration);
		return dockerConfiguration;
	}
	private DockerConfiguration customizeHost(DockerConfiguration dockerConfiguration) {
		String context = getContext().getOrNull();
		String host = getHost().getOrNull();
		if (context != null && host != null) {
			throw new GradleException(
					'Invalid Docker configuration, either context or host can be provided but not both');
		}
		if (context != null) {
			return dockerConfiguration.withContext(context);
		}
		if (host != null) {
			return dockerConfiguration.withHost(host, getTlsVerify().get(), getCertPath().getOrNull());
		}
		return dockerConfiguration;
	}
	private DockerConfiguration customizeBuilderAuthentication(DockerConfiguration dockerConfiguration) {
		if (this.builderRegistry == null || this.builderRegistry.hasEmptyAuth()) {
			return dockerConfiguration;
		}
		if (this.builderRegistry.hasTokenAuth() && !this.builderRegistry.hasUserAuth()) {
			return dockerConfiguration.withBuilderRegistryTokenAuthentication(this.builderRegistry.getToken().get());
		}
		if (this.builderRegistry.hasUserAuth() && !this.builderRegistry.hasTokenAuth()) {
			return dockerConfiguration.withBuilderRegistryUserAuthentication(this.builderRegistry.getUsername().get(),
					this.builderRegistry.getPassword().get(), this.builderRegistry.getUrl().getOrNull(),
					this.builderRegistry.getEmail().getOrNull());
		}
		throw new GradleException(
				'Invalid Docker builder registry configuration, either token or username/password must be provided');
	}
	private DockerConfiguration customizePublishAuthentication(DockerConfiguration dockerConfiguration) {
		if (this.publishRegistry == null || this.publishRegistry.hasEmptyAuth()) {
			return dockerConfiguration.withEmptyPublishRegistryAuthentication();
		}
		if (this.publishRegistry.hasTokenAuth() && !this.publishRegistry.hasUserAuth()) {
			return dockerConfiguration.withPublishRegistryTokenAuthentication(this.publishRegistry.getToken().get());
		}
		if (this.publishRegistry.hasUserAuth() && !this.publishRegistry.hasTokenAuth()) {
			return dockerConfiguration.withPublishRegistryUserAuthentication(this.publishRegistry.getUsername().get(),
					this.publishRegistry.getPassword().get(), this.publishRegistry.getUrl().getOrNull(),
					this.publishRegistry.getEmail().getOrNull());
		}
		throw new GradleException(
				'Invalid Docker publish registry configuration, either token or username/password must be provided');
	}
	/**
	 * Encapsulates Docker registry authentication configuration options.
	 */
	public abstract static class DockerRegistrySpec {
		/**
		 * Returns the username to use when authenticating to the Docker registry.
		 * @return the registry username
		 */
		@Input
		@Optional
		public abstract Property<String> getUsername();
		/**
		 * Returns the password to use when authenticating to the Docker registry.
		 * @return the registry password
		 */
		@Input
		@Optional
		public abstract Property<String> getPassword();
		/**
		 * Returns the Docker registry URL.
		 * @return the registry URL
		 */
		@Input
		@Optional
		public abstract Property<String> getUrl();
		/**
		 * Returns the email address associated with the Docker registry username.
		 * @return the registry email address
		 */
		@Input
		@Optional
		public abstract Property<String> getEmail();
		/**
		 * Returns the identity token to use when authenticating to the Docker registry.
		 * @return the registry identity token
		 */
		@Input
		@Optional
		public abstract Property<String> getToken();
		boolean hasEmptyAuth() {
			return nonePresent(getUsername(), getPassword(), getUrl(), getEmail(), getToken());
		}
		private boolean nonePresent(Property<?>... properties) {
			for (Property<?> property : properties) {
				if (property.isPresent()) {
					return false;
				}
			}
			return true;
		}
		boolean hasUserAuth() {
			return allPresent(getUsername(), getPassword());
		}
		private boolean allPresent(Property<?>... properties) {
			for (Property<?> property : properties) {
				if (!property.isPresent()) {
					return false;
				}
			}
			return true;
		}
		boolean hasTokenAuth() {
			return getToken().isPresent();
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
public interface BootArchive extends Task {
	/**
	 * Returns the fully-qualified name of the application"s main class.
	 * @return the fully-qualified name of the application"s main class
	 * @since 2.4.0
	 */
	@Input
	Property<String> getMainClass();
	/**
	 * Adds Ant-style patterns that identify files that must be unpacked from the archive
	 * when it is launched.
	 * @param patterns the patterns
	 */
	void requiresUnpack(String... patterns);
	/**
	 * Adds a spec that identifies files that must be unpacked from the archive when it is
	 * launched.
	 * @param spec the spec
	 */
	void requiresUnpack(Spec<FileTreeElement> spec);
	/**
	 * Returns the {@link LaunchScriptConfiguration} that will control the script that is
	 * prepended to the archive.
	 * @return the launch script configuration, or {@code null} if the launch script has
	 * not been configured.
	 */
	@Nested
	@Optional
	LaunchScriptConfiguration getLaunchScript();
	/**
	 * Configures the archive to have a prepended launch script.
	 */
	void launchScript();
	/**
	 * Configures the archive to have a prepended launch script, customizing its
	 * configuration using the given {@code action}.
	 * @param action the action to apply
	 */
	void launchScript(Action<LaunchScriptConfiguration> action);
	/**
	 * Returns the classpath that will be included in the archive.
	 * @return the classpath
	 */
	@Optional
	@Classpath
	FileCollection getClasspath();
	/**
	 * Adds files to the classpath to include in the archive. The given {@code classpath}
	 * is evaluated as per {@link Project#files(Object...)}.
	 * @param classpath the additions to the classpath
	 */
	void classpath(Object... classpath);
	/**
	 * Sets the classpath to include in the archive. The given {@code classpath} is
	 * evaluated as per {@link Project#files(Object...)}.
	 * @param classpath the classpath
	 * @since 2.0.7
	 */
	void setClasspath(Object classpath);
	/**
	 * Sets the classpath to include in the archive.
	 * @param classpath the classpath
	 * @since 2.0.7
	 */
	void setClasspath(FileCollection classpath);
	/**
	 * Returns the target Java version of the project (e.g. as provided by the
	 * {@code targetCompatibility} build property).
	 * @return the target Java version
	 */
	@Input
	@Optional
	Property<JavaVersion> getTargetJavaVersion();
	/**
	 * Registers the given lazily provided {@code resolvedArtifacts}. They are used to map
	 * from the files in the {@link #getClasspath classpath} to their dependency
	 * coordinates.
	 * @param resolvedArtifacts the lazily provided resolved artifacts
	 * @since 3.0.7
	 */
	void resolvedArtifacts(Provider<Set<ResolvedArtifactResult>> resolvedArtifacts);
	/**
	 * The loader implementation that should be used with the archive.
	 * @return the loader implementation
	 * @since 3.2.0
	 */
	@Input
	@Optional
	Property<LoaderImplementation> getLoaderImplementation();
	/**
	 * Returns whether the JAR tools should be included as a dependency in the layered
	 * archive.
	 * @return whether the JAR tools should be included
	 * @since 3.3.0
	 */
	@Input
	Property<Boolean> getIncludeTools();
}
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class DefaultTimeZoneOffset {
	static final DefaultTimeZoneOffset INSTANCE = new DefaultTimeZoneOffset(TimeZone.getDefault());
	private final TimeZone defaultTimeZone;
	DefaultTimeZoneOffset(TimeZone defaultTimeZone) {
		this.defaultTimeZone = defaultTimeZone;
	}
	/**
	 * Remove the default offset from the given time.
	 * @param time the time to remove the default offset from
	 * @return the time with the default offset removed
	 */
	FileTime removeFrom(FileTime time) {
		return FileTime.fromMillis(removeFrom(time.toMillis()));
	}
	/**
	 * Remove the default offset from the given time.
	 * @param time the time to remove the default offset from
	 * @return the time with the default offset removed
	 */
	long removeFrom(long time) {
		return time - this.defaultTimeZone.getOffset(time);
	}
}
/*
/**
package org.springframework.boot.gradle.tasks.bundling;
/*
package org.springframework.boot.gradle.tasks.bundling;
/**
class ResolvedDependencies {
	private final Map<String, LibraryCoordinates> projectCoordinatesByPath;
	private final ListProperty<ComponentArtifactIdentifier> artifactIds;
	private final ListProperty<File> artifactFiles;
	ResolvedDependencies(Project project) {
		this.artifactIds = project.getObjects().listProperty(ComponentArtifactIdentifier.class);
		this.artifactFiles = project.getObjects().listProperty(File.class);
		this.projectCoordinatesByPath = projectCoordinatesByPath(project);
	}
	private static Map<String, LibraryCoordinates> projectCoordinatesByPath(Project project) {
		return project.getRootProject()
			.getAllprojects()
			.stream()
			.collect(Collectors.toMap(Project::getPath, ResolvedDependencies::libraryCoordinates));
	}
	private static LibraryCoordinates libraryCoordinates(Project project) {
		return LibraryCoordinates.of(Objects.toString(project.getGroup()), project.getName(),
				Objects.toString(project.getVersion()));
	}
	@Input
	ListProperty<ComponentArtifactIdentifier> getArtifactIds() {
		return this.artifactIds;
	}
	@Classpath
	ListProperty<File> getArtifactFiles() {
		return this.artifactFiles;
	}
	void resolvedArtifacts(Provider<Set<ResolvedArtifactResult>> resolvedArtifacts) {
		this.artifactFiles.addAll(
				resolvedArtifacts.map((artifacts) -> artifacts.stream().map(ResolvedArtifactResult::getFile).toList()));
		this.artifactIds.addAll(
				resolvedArtifacts.map((artifacts) -> artifacts.stream().map(ResolvedArtifactResult::getId).toList()));
	}
	DependencyDescriptor find(File file) {
		ComponentArtifactIdentifier id = findArtifactIdentifier(file);
		if (id == null) {
			return null;
		}
		if (id instanceof ModuleComponentArtifactIdentifier moduleComponentId) {
			ModuleComponentIdentifier moduleId = moduleComponentId.getComponentIdentifier();
			return new DependencyDescriptor(
					LibraryCoordinates.of(moduleId.getGroup(), moduleId.getModule(), moduleId.getVersion()), false);
		}
		ComponentIdentifier componentIdentifier = id.getComponentIdentifier();
		if (componentIdentifier instanceof ProjectComponentIdentifier projectComponentId) {
			String projectPath = projectComponentId.getProjectPath();
			LibraryCoordinates projectCoordinates = this.projectCoordinatesByPath.get(projectPath);
			if (projectCoordinates != null) {
				return new DependencyDescriptor(projectCoordinates, true);
			}
		}
		return null;
	}
	private ComponentArtifactIdentifier findArtifactIdentifier(File file) {
		List<File> files = this.artifactFiles.get();
		for (int i = 0; i < files.size(); i++) {
			if (file.equals(files.get(i))) {
				return this.artifactIds.get().get(i);
			}
		}
		return null;
	}
	/**
	 * Describes a dependency in a {@link ResolvedConfiguration}.
	 */
	static final class DependencyDescriptor {
		private final LibraryCoordinates coordinates;
		private final boolean projectDependency;
		private DependencyDescriptor(LibraryCoordinates coordinates, boolean projectDependency) {
			this.coordinates = coordinates;
			this.projectDependency = projectDependency;
		}
		LibraryCoordinates getCoordinates() {
			return this.coordinates;
		}
		boolean isProjectDependency() {
			return this.projectDependency;
		}
	}
}
/*
package org.springframework.boot.gradle.tasks.aot;
/**
@CacheableTask
public class ProcessTestAot extends AbstractAot {
	private FileCollection classpathRoots;
	public ProcessTestAot() {
		getMainClass().set('org.springframework.boot.test.context.SpringBootTestAotProcessor');
	}
	/**
	 * Returns the classpath roots that should be scanned for test classes to process.
	 * @return the classpath roots
	 */
	@InputFiles
	@PathSensitive(PathSensitivity.RELATIVE)
	public final FileCollection getClasspathRoots() {
		return this.classpathRoots;
	}
	/**
	 * Sets the classpath roots that should be scanned for test classes to process.
	 * @param classpathRoots the classpath roots
	 */
	public void setClasspathRoots(FileCollection classpathRoots) {
		this.classpathRoots = classpathRoots;
	}
	@InputFiles
	@SkipWhenEmpty
	@IgnoreEmptyDirectories
	@PathSensitive(PathSensitivity.RELATIVE)
	final FileTree getInputClasses() {
		return this.classpathRoots.getAsFileTree();
	}
	@Override
	@TaskAction
	public void exec() {
		List<String> args = new ArrayList<>();
		args.add(getClasspathRoots().getFiles()
			.stream()
			.filter(File::exists)
			.map(File::getAbsolutePath)
			.collect(Collectors.joining(File.pathSeparator)));
		args.addAll(processorArgs());
		setArgs(args);
		super.exec();
	}
}
/*
package org.springframework.boot.gradle.tasks.aot;
/**
@DisableCachingByDefault(because = 'Cacheability can only be determined by a concrete implementation')
public abstract class AbstractAot extends JavaExec {
	private final DirectoryProperty sourcesDir;
	private final DirectoryProperty resourcesDir;
	private final DirectoryProperty classesDir;
	private final Property<String> groupId;
	private final Property<String> artifactId;
	protected AbstractAot() {
		this.sourcesDir = getProject().getObjects().directoryProperty();
		this.resourcesDir = getProject().getObjects().directoryProperty();
		this.classesDir = getProject().getObjects().directoryProperty();
		this.groupId = getProject().getObjects().property(String.class);
		this.artifactId = getProject().getObjects().property(String.class);
	}
	/**
	 * The group ID of the application that is to be processed ahead-of-time.
	 * @return the group ID property
	 */
	@Input
	public final Property<String> getGroupId() {
		return this.groupId;
	}
	/**
	 * The artifact ID of the application that is to be processed ahead-of-time.
	 * @return the artifact ID property
	 */
	@Input
	public final Property<String> getArtifactId() {
		return this.artifactId;
	}
	/**
	 * The directory to which AOT-generated sources should be written.
	 * @return the sources directory property
	 */
	@OutputDirectory
	public final DirectoryProperty getSourcesOutput() {
		return this.sourcesDir;
	}
	/**
	 * The directory to which AOT-generated resources should be written.
	 * @return the resources directory property
	 */
	@OutputDirectory
	public final DirectoryProperty getResourcesOutput() {
		return this.resourcesDir;
	}
	/**
	 * The directory to which AOT-generated classes should be written.
	 * @return the classes directory property
	 */
	@OutputDirectory
	public final DirectoryProperty getClassesOutput() {
		return this.classesDir;
	}
	List<String> processorArgs() {
		List<String> args = new ArrayList<>();
		args.add(getSourcesOutput().getAsFile().get().getAbsolutePath());
		args.add(getResourcesOutput().getAsFile().get().getAbsolutePath());
		args.add(getClassesOutput().getAsFile().get().getAbsolutePath());
		args.add(getGroupId().get());
		args.add(getArtifactId().get());
		args.addAll(super.getArgs());
		return args;
	}
}
/*
/**
package org.springframework.boot.gradle.tasks.aot;
/*
package org.springframework.boot.gradle.tasks.aot;
/**
@CacheableTask
public abstract class ProcessAot extends AbstractAot {
	public ProcessAot() {
		getMainClass().set('org.springframework.boot.SpringApplicationAotProcessor');
	}
	/**
	 * Returns the main class of the application that is to be processed ahead-of-time.
	 * @return the application main class property
	 */
	@Input
	public abstract Property<String> getApplicationMainClass();
	@Override
	@TaskAction
	public void exec() {
		List<String> args = new ArrayList<>();
		args.add(getApplicationMainClass().get());
		args.addAll(processorArgs());
		setArgs(args);
		super.exec();
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println(SampleLibrary.getMessage());
		synchronized (args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleLibrary {
	public static String getMessage() {
		return 'Launched';
	}
}/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Launched');
		synchronized(args) {
			args.wait(); // Prevent exit'
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
@Testcontainers(disabledWithoutDocker = true)
@Disabled('Disabled until differences between running locally and in CI can be diagnosed')
class BuildImageRegistryIntegrationTests extends AbstractArchiveIntegrationTests {
	@Container
	static final RegistryContainer registry = TestImage.container(RegistryContainer.class);
	DockerClient dockerClient;
	String registryAddress;
	@BeforeEach
	void setUp() {
		assertThat(registry.isRunning()).isTrue();
		this.dockerClient = registry.getDockerClient();
		this.registryAddress = registry.getHost() + ':' + registry.getFirstMappedPort();
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithPublish(MavenBuild mavenBuild) {
		String repoName = 'test-image';
		String imageName = this.registryAddress + '/' + repoName;
		mavenBuild.project('dockerTest', 'build-image-publish')
			.goals('package')
			.systemProperty('spring-boot.build-image.imageName', imageName)
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('Successfully built image')
					.contains('Pushing image "' + imageName + ':latest' + '"')
					.contains('Pushed image "' + imageName + ':latest' + '"');
				ImageReference imageReference = ImageReference.of(imageName);
				DockerApi.ImageApi imageApi = new DockerApi().image();
				Image pulledImage = imageApi.pull(imageReference, null, UpdateListener.none());
				assertThat(pulledImage).isNotNull();
				imageApi.remove(imageReference, false);
			});
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
@DisabledIfDockerUnavailable
class BuildImageTests extends AbstractArchiveIntegrationTests {
	@TestTemplate
	void whenBuildImageIsInvokedWithoutRepackageTheArchiveIsRepackagedOnTheFly(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				File original = new File(project, 'target/build-image-0.0.1.BUILD-SNAPSHOT.jar.original');
				assertThat(original).doesNotExist();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image:0.0.1.BUILD-SNAPSHOT')
					.contains('Running detector')
					.contains('Running builder')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedOnTheCommandLineWithoutRepackageTheArchiveIsRepackagedOnTheFly(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-cmd-line')
			.goals('spring-boot:build-image')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-cmd-line-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				File original = new File(project, 'target/build-image-cmd-line-0.0.1.BUILD-SNAPSHOT.jar.original');
				assertThat(original).doesNotExist();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-cmd-line:0.0.1.BUILD-SNAPSHOT')
					.contains('Running detector')
					.contains('Running builder')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-cmd-line', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenPackageIsInvokedWithClassifierTheOriginalArchiveIsFound(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-classifier')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-classifier-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				File classifier = new File(project, 'target/build-image-classifier-0.0.1.BUILD-SNAPSHOT-test.jar');
				assertThat(classifier).doesNotExist();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-classifier:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-classifier', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithClassifierAndRepackageTheOriginalArchiveIsFound(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-fork-classifier')
			.goals('spring-boot:build-image')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-fork-classifier-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				File classifier = new File(project, 'target/build-image-fork-classifier-0.0.1.BUILD-SNAPSHOT-exec.jar');
				assertThat(classifier).exists();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-fork-classifier:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-fork-classifier', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithClassifierSourceWithoutRepackageTheArchiveIsRepackagedOnTheFly(
			MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-classifier-source')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-classifier-source-0.0.1.BUILD-SNAPSHOT-test.jar');
				assertThat(jar).isFile();
				File original = new File(project,
						'target/build-image-classifier-source-0.0.1.BUILD-SNAPSHOT-test.jar.original');
				assertThat(original).doesNotExist();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-classifier-source:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-classifier-source', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithRepackageTheExistingArchiveIsUsed(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-with-repackage')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-with-repackage-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				File original = new File(project,
						'target/build-image-with-repackage-0.0.1.BUILD-SNAPSHOT.jar.original');
				assertThat(original).isFile();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-with-repackage:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-with-repackage', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithClassifierAndRepackageTheExistingArchiveIsUsed(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-classifier-with-repackage')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-classifier-with-repackage-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				File original = new File(project,
						'target/build-image-classifier-with-repackage-0.0.1.BUILD-SNAPSHOT-test.jar');
				assertThat(original).isFile();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-classifier-with-repackage:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-classifier-with-repackage', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithClassifierSourceAndRepackageTheExistingArchiveIsUsed(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-classifier-source-with-repackage')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File jar = new File(project,
						'target/build-image-classifier-source-with-repackage-0.0.1.BUILD-SNAPSHOT-test.jar');
				assertThat(jar).isFile();
				File original = new File(project,
						'target/build-image-classifier-source-with-repackage-0.0.1.BUILD-SNAPSHOT-test.jar.original');
				assertThat(original).isFile();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-classifier-source-with-repackage:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-classifier-source-with-repackage', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithWarPackaging(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-war-packaging')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				File war = new File(project, 'target/build-image-war-packaging-0.0.1.BUILD-SNAPSHOT.war');
				assertThat(war).isFile();
				File original = new File(project, 'target/build-image-war-packaging-0.0.1.BUILD-SNAPSHOT.war.original');
				assertThat(original).doesNotExist();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-war-packaging:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-war-packaging', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithCustomImageName(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-custom-name')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.systemProperty('spring-boot.build-image.imageName', 'example.com/test/property-ignored:pom-preferred')
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-custom-name-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				File original = new File(project, 'target/build-image-custom-name-0.0.1.BUILD-SNAPSHOT.jar.original');
				assertThat(original).doesNotExist();
				assertThat(buildLog(project)).contains('Building image')
					.contains('example.com/test/build-image:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('example.com/test/build-image', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithCommandLineParameters(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.systemProperty('spring-boot.build-image.imageName', 'example.com/test/cmd-property-name:v1')
			.systemProperty('spring-boot.build-image.builder', 'ghcr.io/spring-io/spring-boot-cnb-test-builder:0.0.1')
			.systemProperty('spring-boot.build-image.trustBuilder', 'true')
			.systemProperty('spring-boot.build-image.runImage', 'paketobuildpacks/run-jammy-tiny')
			.systemProperty('spring-boot.build-image.createdDate', '2020-07-01T12:34:56Z')
			.systemProperty('spring-boot.build-image.applicationDirectory', '/application')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('example.com/test/cmd-property-name:v1')
					.contains('Running creator')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				Image image = new DockerApi().image()
					.inspect(ImageReference.of('example.com/test/cmd-property-name:v1'));
				assertThat(image.getCreated()).isEqualTo('2020-07-01T12:34:56Z');
				removeImage('example.com/test/cmd-property-name', 'v1');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithCustomBuilderImageAndRunImage(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-custom-builder')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-v2-builder:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('docker.io/library/build-image-v2-builder', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithTrustBuilder(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-trust-builder')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-v2-trust-builder:0.0.1.BUILD-SNAPSHOT')
					.contains('Running creator')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('docker.io/library/build-image-v2-trust-builder', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithEmptyEnvEntry(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-empty-env-entry')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.prepare(this::writeLongNameResource)
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-empty-env-entry:0.0.1.BUILD-SNAPSHOT')
					.contains('---> Test Info buildpack building')
					.contains('---> Test Info buildpack done')
					.contains('Successfully built image');
				removeImage('build-image-empty-env-entry', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithZipPackaging(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-zip-packaging')
			.goals('package')
			.prepare(this::writeLongNameResource)
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				File jar = new File(project, 'target/build-image-zip-packaging-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar).isFile();
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-zip-packaging:0.0.1.BUILD-SNAPSHOT')
					.contains('Main-Class: org.springframework.boot.loader.launch.PropertiesLauncher')
					.contains('Successfully built image');
				removeImage('build-image-zip-packaging', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithBuildpacks(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-custom-buildpacks')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-custom-buildpacks:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				removeImage('build-image-custom-buildpacks', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithBinding(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-bindings')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-bindings:0.0.1.BUILD-SNAPSHOT')
					.contains('binding: ca-certificates/type=ca-certificates')
					.contains('binding: ca-certificates/test.crt=---certificate one---')
					.contains('Successfully built image');
				removeImage('build-image-bindings', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithNetworkModeNone(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-network')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-network:0.0.1.BUILD-SNAPSHOT')
					.contains('Network status: curl failed')
					.contains('Successfully built image');
				removeImage('build-image-network', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedOnMultiModuleProjectWithPackageGoal(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-multi-module')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-multi-module-app:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				removeImage('build-image-multi-module-app', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithTags(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-tags')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-tags:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image')
					.contains('docker.io/library/build-image-tags:latest')
					.contains('Successfully created image tag');
				removeImage('build-image-tags', '0.0.1.BUILD-SNAPSHOT');
				removeImage('build-image-tags', 'latest');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithVolumeCaches(MavenBuild mavenBuild) {
		String testBuildId = randomString();
		mavenBuild.project('dockerTest', 'build-image-volume-caches')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.systemProperty('test-build-id', testBuildId)
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-volume-caches:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				removeImage('build-image-volume-caches', '0.0.1.BUILD-SNAPSHOT');
				deleteVolumes('cache-' + testBuildId + '.build', 'cache-' + testBuildId + '.launch');
			});
	}
	@TestTemplate
	@EnabledOnOs(value = OS.LINUX, disabledReason = 'Works with Docker Engine on Linux but is not reliable with '
			+ 'Docker Desktop on other OSs')
	void whenBuildImageIsInvokedWithBindCaches(MavenBuild mavenBuild) {
		String testBuildId = randomString();
		mavenBuild.project('dockerTest', 'build-image-bind-caches')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.systemProperty('test-build-id', testBuildId)
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-bind-caches:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				removeImage('build-image-bind-caches', '0.0.1.BUILD-SNAPSHOT');
				String tempDir = System.getProperty('java.io.tmpdir');
				Path buildCachePath = Paths.get(tempDir, 'junit-image-cache-' + testBuildId + '-build');
				Path launchCachePath = Paths.get(tempDir, 'junit-image-cache-' + testBuildId + '-launch');
				assertThat(buildCachePath).exists().isDirectory();
				assertThat(launchCachePath).exists().isDirectory();
				cleanupCache(buildCachePath);
				cleanupCache(launchCachePath);
			});
	}
	private static void cleanupCache(Path cachePath) {
		try {
			FileSystemUtils.deleteRecursively(cachePath);
		}
		catch (Exception ex) {
			// ignore
		}
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithCreatedDate(MavenBuild mavenBuild) {
		String testBuildId = randomString();
		mavenBuild.project('dockerTest', 'build-image-created-date')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-created-date:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				Image image = new DockerApi().image()
					.inspect(ImageReference.of('docker.io/library/build-image-created-date:0.0.1.BUILD-SNAPSHOT'));
				assertThat(image.getCreated()).isEqualTo('2020-07-01T12:34:56Z');
				removeImage('build-image-created-date', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithCurrentCreatedDate(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-current-created-date')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-current-created-date:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				Image image = new DockerApi().image()
					.inspect(ImageReference
						.of('docker.io/library/build-image-current-created-date:0.0.1.BUILD-SNAPSHOT'));
				OffsetDateTime createdDateTime = OffsetDateTime.parse(image.getCreated());
				OffsetDateTime current = OffsetDateTime.now().withOffsetSameInstant(createdDateTime.getOffset());
				assertThat(createdDateTime.getYear()).isEqualTo(current.getYear());
				assertThat(createdDateTime.getMonth()).isEqualTo(current.getMonth());
				assertThat(createdDateTime.getDayOfMonth()).isEqualTo(current.getDayOfMonth());
				removeImage('build-image-current-created-date', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithApplicationDirectory(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-app-dir')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-app-dir:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				removeImage('build-image-app-dir', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	void whenBuildImageIsInvokedWithEmptySecurityOptions(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-security-opts')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.execute((project) -> {
				assertThat(buildLog(project)).contains('Building image')
					.contains('docker.io/library/build-image-security-opts:0.0.1.BUILD-SNAPSHOT')
					.contains('Successfully built image');
				removeImage('build-image-security-opts', '0.0.1.BUILD-SNAPSHOT');
			});
	}
	@TestTemplate
	@EnabledOnOs(value = { OS.LINUX, OS.MAC }, architectures = 'aarch64',
			disabledReason = 'Lifecycle will only run on ARM architecture')
	void whenBuildImageIsInvokedOnLinuxArmWithImagePlatformLinuxArm(MavenBuild mavenBuild) throws IOException {
		String builderImage = 'ghcr.io/spring-io/spring-boot-cnb-test-builder:0.0.1';
		String runImage = 'docker.io/paketobuildpacks/run-jammy-tiny:latest';
		String buildpackImage = 'ghcr.io/spring-io/spring-boot-test-info:0.0.1';
		removeImages(builderImage, runImage, buildpackImage);
		mavenBuild.project('dockerTest', 'build-image-platform-linux-arm').goals('package').execute((project) -> {
			File jar = new File(project, 'target/build-image-platform-linux-arm-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar).isFile();
			assertThat(buildLog(project)).contains('Building image')
				.contains('docker.io/library/build-image-platform-linux-arm:0.0.1.BUILD-SNAPSHOT')
				.contains('Pulling builder image "' + builderImage + '" for platform "linux/arm64"')
				.contains('Pulling run image "' + runImage + '" for platform "linux/arm64"')
				.contains('Pulling buildpack image "' + buildpackImage + '" for platform "linux/arm64"')
				.contains('---> Test Info buildpack building')
				.contains('---> Test Info buildpack done')
				.contains('Successfully built image');
			removeImage('docker.io/library/build-image-platform-linux-arm', '0.0.1.BUILD-SNAPSHOT');
		});
		removeImages(builderImage, runImage, buildpackImage);
	}
	@TestTemplate
	@EnabledOnOs(value = { OS.LINUX, OS.MAC }, architectures = 'amd64',
			disabledReason = 'The expected failure condition will not fail on ARM architectures')
	void failsWhenBuildImageIsInvokedOnLinuxAmdWithImagePlatformLinuxArm(MavenBuild mavenBuild) throws IOException {
		String builderImage = 'ghcr.io/spring-io/spring-boot-cnb-test-builder:0.0.1';
		String runImage = 'docker.io/paketobuildpacks/run-jammy-tiny:latest';
		String buildpackImage = 'ghcr.io/spring-io/spring-boot-test-info:0.0.1';
		removeImages(buildpackImage, runImage, buildpackImage);
		mavenBuild.project('dockerTest', 'build-image-platform-linux-arm')
			.goals('package')
			.executeAndFail((project) -> assertThat(buildLog(project)).contains('Building image')
				.contains('docker.io/library/build-image-platform-linux-arm:0.0.1.BUILD-SNAPSHOT')
				.contains('Pulling builder image "' + builderImage + '" for platform "linux/arm64"')
				.contains('Pulling run image "' + runImage + '" for platform "linux/arm64"')
				.contains('Pulling buildpack image "' + buildpackImage + '" for platform "linux/arm64"')
				.contains('exec format error'));
		removeImages(builderImage, runImage, buildpackImage);
	}
	@TestTemplate
	void failsWhenBuildImageIsInvokedOnMultiModuleProjectWithBuildImageGoal(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-multi-module')
			.goals('spring-boot:build-image')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.executeAndFail((project) -> assertThat(buildLog(project)).contains('Error packaging archive for image'));
	}
	@TestTemplate
	void failsWhenBuilderFails(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-builder-error')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.executeAndFail((project) -> assertThat(buildLog(project)).contains('Building image')
				.contains('---> Test Info buildpack building')
				.contains('Forced builder failure')
				.containsPattern('Builder lifecycle ".*" failed with status code'));
	}
	@TestTemplate
	void failsWithBuildpackNotInBuilder(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-bad-buildpack')
			.goals('package')
			.systemProperty('spring-boot.build-image.pullPolicy', 'IF_NOT_PRESENT')
			.executeAndFail((project) -> assertThat(buildLog(project))
				.contains('"urn:cnb:builder:example/does-not-exist:0.0.1" not found in builder'));
	}
	@TestTemplate
	void failsWhenFinalNameIsMisconfigured(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-final-name')
			.goals('package')
			.executeAndFail((project) -> assertThat(buildLog(project)).contains('final-name.jar.original')
				.contains('is required for building an image'));
	}
	@TestTemplate
	void failsWhenCachesAreConfiguredTwice(MavenBuild mavenBuild) {
		mavenBuild.project('dockerTest', 'build-image-caches-multiple')
			.goals('package')
			.executeAndFail((project) -> assertThat(buildLog(project))
				.contains('Each image building cache can be configured only once'));
	}
	private void writeLongNameResource(File project) {
		StringBuilder name = new StringBuilder();
		new Random().ints("a", "z" + 1).limit(128).forEach((i) -> name.append((char) i));
		try {
			Path path = project.toPath().resolve(Paths.get('src', 'main', 'resources', name.toString()));
			Files.createDirectories(path.getParent());
			Files.createFile(path);
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private void removeImages(String... names) throws IOException {
		ImageApi imageApi = new DockerApi().image();
		for (String name : names) {
			try {
				imageApi.remove(ImageReference.of(name), false);
			}
			catch (DockerEngineException ex) {
				// ignore image remove failures
			}
		}
	}
	private void removeImage(String name, String version) {
		ImageReference imageReference = ImageReference.of(ImageName.of(name), version);
		try {
			new DockerApi().image().remove(imageReference, false);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to remove docker image ' + imageReference, ex);
		}
	}
	private void deleteVolumes(String... names) throws IOException {
		VolumeApi volumeApi = new DockerApi().volume();
		for (String name : names) {
			volumeApi.delete(VolumeName.of(name), false);
		}
	}
	private String randomString() {
		IntStream chars = new Random().ints("a", "z" + 1).limit(10);
		return chars.collect(StringBuilder::new, StringBuilder::appendCodePoint, StringBuilder::append).toString();
	}
}
/*
package org.springframework.boot.maven.sample;
/**
public class ClassWithMainMethod {
	public void run() {
		System.out.println('Hello World');
	}
	public static void main(String[] args) {
		new ClassWithMainMethod().run();
	}
}
/*
package org.springframework.boot.maven.sample;
/**
public class ClassWithoutMainMethod {
}
/*
package org.springframework.boot.maven;
/**
class PropertiesMergingResourceTransformerTests {
	private final PropertiesMergingResourceTransformer transformer = new PropertiesMergingResourceTransformer();
	@Test
	void testProcess() throws Exception {
		assertThat(this.transformer.hasTransformedResource()).isFalse();
		this.transformer.processResource('foo', new ByteArrayInputStream('foo=bar'.getBytes()), null, 0);
		assertThat(this.transformer.hasTransformedResource()).isTrue();
	}
	@Test
	void testMerge() throws Exception {
		this.transformer.processResource('foo', new ByteArrayInputStream('foo=bar'.getBytes()), null, 0);
		this.transformer.processResource('bar', new ByteArrayInputStream('foo=spam'.getBytes()), null, 0);
		assertThat(this.transformer.getData().getProperty('foo')).isEqualTo('bar,spam');
	}
	@Test
	void testOutput() throws Exception {
		this.transformer.setResource('foo');
		long time = 1592911068000L;
		this.transformer.processResource('foo', new ByteArrayInputStream('foo=bar'.getBytes()), null, time);
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		JarOutputStream os = new JarOutputStream(out);
		this.transformer.modifyOutputStream(os);
		os.flush();
		os.close();
		byte[] bytes = out.toByteArray();
		assertThat(bytes).isNotEmpty();
		List<JarEntry> entries = new ArrayList<>();
		try (JarInputStream is = new JarInputStream(new ByteArrayInputStream(bytes))) {
			JarEntry entry;
			while ((entry = is.getNextJarEntry()) != null) {
				entries.add(entry);
			}
		}
		assertThat(entries).hasSize(1);
		assertThat(entries.get(0).getTime()).isEqualTo(time);
	}
}
/*
package org.springframework.boot.maven;
/**
class JarTypeFilterTests {
	@TempDir
	Path temp;
	@Test
	void whenArtifactHasNoJarTypeThenItIsIncluded() {
		assertThat(new JarTypeFilter().filter(createArtifact(null))).isFalse();
	}
	@Test
	void whenArtifactHasJarTypeThatIsNotExcludedThenItIsIncluded() {
		assertThat(new JarTypeFilter().filter(createArtifact('something-included'))).isFalse();
	}
	@Test
	void whenArtifactHasDependenciesStarterJarTypeThenItIsExcluded() {
		assertThat(new JarTypeFilter().filter(createArtifact('dependencies-starter'))).isTrue();
	}
	@Test
	void whenArtifactHasAnnotationProcessorJarTypeThenItIsExcluded() {
		assertThat(new JarTypeFilter().filter(createArtifact('annotation-processor'))).isTrue();
	}
	@Test
	void whenArtifactHasNoManifestFileThenItIsIncluded() {
		assertThat(new JarTypeFilter().filter(createArtifactWithNoManifest())).isFalse();
	}
	private Artifact createArtifact(String springBootJarType) {
		Path jarPath = this.temp.resolve('test.jar');
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue('Manifest-Version', '1.0');
		if (springBootJarType != null) {
			manifest.getMainAttributes().putValue('Spring-Boot-Jar-Type', springBootJarType);
		}
		try {
			new JarOutputStream(new FileOutputStream(jarPath.toFile()), manifest).close();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
		return mockArtifact(jarPath);
	}
	private Artifact createArtifactWithNoManifest() {
		Path jarPath = this.temp.resolve('test.jar');
		try {
			new JarOutputStream(new FileOutputStream(jarPath.toFile())).close();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
		return mockArtifact(jarPath);
	}
	private Artifact mockArtifact(Path jarPath) {
		Artifact artifact = mock(Artifact.class);
		given(artifact.getFile()).willReturn(jarPath.toFile());
		return artifact;
	}
}
/*
package org.springframework.boot.maven;
/**
@SuppressWarnings({ 'rawtypes', 'unchecked' })
class IncludeFilterTests {
	@Test
	void includeSimple() throws ArtifactFilterException {
		IncludeFilter filter = new IncludeFilter(Arrays.asList(createInclude('com.foo', 'bar')));
		Artifact artifact = createArtifact('com.foo', 'bar');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).hasSize(1);
		assertThat(result.iterator().next()).isSameAs(artifact);
	}
	@Test
	void includeGroupIdNoMatch() throws ArtifactFilterException {
		IncludeFilter filter = new IncludeFilter(Arrays.asList(createInclude('com.foo', 'bar')));
		Artifact artifact = createArtifact('com.baz', 'bar');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).isEmpty();
	}
	@Test
	void includeArtifactIdNoMatch() throws ArtifactFilterException {
		IncludeFilter filter = new IncludeFilter(Arrays.asList(createInclude('com.foo', 'bar')));
		Artifact artifact = createArtifact('com.foo', 'biz');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).isEmpty();
	}
	@Test
	void includeClassifier() throws ArtifactFilterException {
		IncludeFilter filter = new IncludeFilter(Arrays.asList(createInclude('com.foo', 'bar', 'jdk5')));
		Artifact artifact = createArtifact('com.foo', 'bar', 'jdk5');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).hasSize(1);
		assertThat(result.iterator().next()).isSameAs(artifact);
	}
	@Test
	void includeClassifierNoTargetClassifier() throws ArtifactFilterException {
		IncludeFilter filter = new IncludeFilter(Arrays.asList(createInclude('com.foo', 'bar', 'jdk5')));
		Artifact artifact = createArtifact('com.foo', 'bar');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).isEmpty();
	}
	@Test
	void includeClassifierNoMatch() throws ArtifactFilterException {
		IncludeFilter filter = new IncludeFilter(Arrays.asList(createInclude('com.foo', 'bar', 'jdk5')));
		Artifact artifact = createArtifact('com.foo', 'bar', 'jdk6');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).isEmpty();
	}
	@Test
	void includeMulti() throws ArtifactFilterException {
		IncludeFilter filter = new IncludeFilter(Arrays.asList(createInclude('com.foo', 'bar'),
				createInclude('com.foo', 'bar2'), createInclude('org.acme', 'app')));
		Set<Artifact> artifacts = new HashSet<>();
		artifacts.add(createArtifact('com.foo', 'bar'));
		artifacts.add(createArtifact('com.foo', 'bar'));
		Artifact anotherAcme = createArtifact('org.acme', 'another-app');
		artifacts.add(anotherAcme);
		Set result = filter.filter(artifacts);
		assertThat(result).hasSize(2);
	}
	private Include createInclude(String groupId, String artifactId) {
		return createInclude(groupId, artifactId, null);
	}
	private Include createInclude(String groupId, String artifactId, String classifier) {
		Include include = new Include();
		include.setGroupId(groupId);
		include.setArtifactId(artifactId);
		if (classifier != null) {
			include.setClassifier(classifier);
		}
		return include;
	}
	private Artifact createArtifact(String groupId, String artifactId, String classifier) {
		Artifact a = mock(Artifact.class);
		given(a.getGroupId()).willReturn(groupId);
		given(a.getArtifactId()).willReturn(artifactId);
		given(a.getClassifier()).willReturn(classifier);
		return a;
	}
	private Artifact createArtifact(String groupId, String artifactId) {
		return createArtifact(groupId, artifactId, null);
	}
}
/*
package org.springframework.boot.maven;
/**
class SystemPropertyFormatterTests {
	@Test
	void parseEmpty() {
		assertThat(SystemPropertyFormatter.format(null, null)).isEmpty();
	}
	@Test
	void parseOnlyKey() {
		assertThat(SystemPropertyFormatter.format('key1', null)).isEqualTo('-Dkey1');
	}
	@Test
	void parseKeyWithValue() {
		assertThat(SystemPropertyFormatter.format('key1', 'value1')).isEqualTo('-Dkey1=\'value1\'');
	}
	@Test
	void parseKeyWithEmptyValue() {
		assertThat(SystemPropertyFormatter.format('key1', '')).isEqualTo('-Dkey1');
	}
	@Test
	void parseKeyWithOnlySpaces() {
		assertThat(SystemPropertyFormatter.format('key1', '   ')).isEqualTo('-Dkey1=\'   \'');
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MockitoExtension.class)
class ArtifactsLibrariesTests {
	@Mock
	private Artifact artifact;
	@Mock
	private ArtifactHandler artifactHandler;
	private Set<Artifact> artifacts;
	private final File file = new File('.');
	private ArtifactsLibraries libs;
	@Mock
	private LibraryCallback callback;
	@Captor
	private ArgumentCaptor<Library> libraryCaptor;
	@BeforeEach
	void setup() {
		this.artifacts = Collections.singleton(this.artifact);
		this.libs = new ArtifactsLibraries(this.artifacts, Collections.emptyList(), null, mock(Log.class));
		given(this.artifactHandler.getExtension()).willReturn('jar');
	}
	@Test
	void callbackForJars() throws Exception {
		given(this.artifact.getFile()).willReturn(this.file);
		given(this.artifact.getArtifactHandler()).willReturn(this.artifactHandler);
		given(this.artifact.getScope()).willReturn('compile');
		this.libs.doWithLibraries(this.callback);
		then(this.callback).should().library(assertArg((library) -> {
			assertThat(library.getFile()).isEqualTo(this.file);
			assertThat(library.getScope()).isEqualTo(LibraryScope.COMPILE);
			assertThat(library.isUnpackRequired()).isFalse();
		}));
	}
	@Test
	void callbackWithUnpack() throws Exception {
		given(this.artifact.getFile()).willReturn(this.file);
		given(this.artifact.getArtifactHandler()).willReturn(this.artifactHandler);
		given(this.artifact.getGroupId()).willReturn('gid');
		given(this.artifact.getArtifactId()).willReturn('aid');
		given(this.artifact.getScope()).willReturn('compile');
		Dependency unpack = new Dependency();
		unpack.setGroupId('gid');
		unpack.setArtifactId('aid');
		this.libs = new ArtifactsLibraries(this.artifacts, Collections.emptyList(), Collections.singleton(unpack),
				mock(Log.class));
		this.libs.doWithLibraries(this.callback);
		then(this.callback).should().library(assertArg((library) -> assertThat(library.isUnpackRequired()).isTrue()));
	}
	@Test
	void renamesDuplicates() throws Exception {
		Artifact artifact1 = mock(Artifact.class);
		Artifact artifact2 = mock(Artifact.class);
		given(artifact1.getScope()).willReturn('compile');
		given(artifact1.getGroupId()).willReturn('g1');
		given(artifact1.getArtifactId()).willReturn('artifact');
		given(artifact1.getBaseVersion()).willReturn('1.0');
		given(artifact1.getFile()).willReturn(new File('a'));
		given(artifact1.getArtifactHandler()).willReturn(this.artifactHandler);
		given(artifact2.getScope()).willReturn('compile');
		given(artifact2.getGroupId()).willReturn('g2');
		given(artifact2.getArtifactId()).willReturn('artifact');
		given(artifact2.getBaseVersion()).willReturn('1.0');
		given(artifact2.getFile()).willReturn(new File('a'));
		given(artifact2.getArtifactHandler()).willReturn(this.artifactHandler);
		this.artifacts = new LinkedHashSet<>(Arrays.asList(artifact1, artifact2));
		this.libs = new ArtifactsLibraries(this.artifacts, Collections.emptyList(), null, mock(Log.class));
		this.libs.doWithLibraries(this.callback);
		then(this.callback).should(times(2)).library(this.libraryCaptor.capture());
		assertThat(this.libraryCaptor.getAllValues().get(0).getName()).isEqualTo('g1-artifact-1.0.jar');
		assertThat(this.libraryCaptor.getAllValues().get(1).getName()).isEqualTo('g2-artifact-1.0.jar');
	}
	@Test
	void libraryCoordinatesVersionUsesBaseVersionOfArtifact() throws IOException {
		Artifact snapshotArtifact = mock(Artifact.class);
		given(snapshotArtifact.getScope()).willReturn('compile');
		given(snapshotArtifact.getArtifactId()).willReturn('artifact');
		given(snapshotArtifact.getBaseVersion()).willReturn('1.0-SNAPSHOT');
		given(snapshotArtifact.getFile()).willReturn(new File('a'));
		given(snapshotArtifact.getArtifactHandler()).willReturn(this.artifactHandler);
		this.artifacts = Collections.singleton(snapshotArtifact);
		new ArtifactsLibraries(this.artifacts, Collections.emptyList(), null, mock(Log.class))
			.doWithLibraries((library) -> {
				assertThat(library.isIncluded()).isTrue();
				assertThat(library.isLocal()).isFalse();
				assertThat(library.getCoordinates().getVersion()).isEqualTo('1.0-SNAPSHOT');
			});
	}
	@Test
	void artifactForLocalProjectProducesLocalLibrary() throws IOException {
		Artifact artifact = mock(Artifact.class);
		given(artifact.getScope()).willReturn('compile');
		given(artifact.getArtifactId()).willReturn('artifact');
		given(artifact.getBaseVersion()).willReturn('1.0-SNAPSHOT');
		given(artifact.getFile()).willReturn(new File('a'));
		given(artifact.getArtifactHandler()).willReturn(this.artifactHandler);
		MavenProject mavenProject = mock(MavenProject.class);
		given(mavenProject.getArtifact()).willReturn(artifact);
		this.artifacts = Collections.singleton(artifact);
		new ArtifactsLibraries(this.artifacts, Collections.singleton(mavenProject), null, mock(Log.class))
			.doWithLibraries((library) -> assertThat(library.isLocal()).isTrue());
	}
	@Test
	void attachedArtifactForLocalProjectProducesLocalLibrary() throws IOException {
		MavenProject mavenProject = mock(MavenProject.class);
		Artifact artifact = mock(Artifact.class);
		given(mavenProject.getArtifact()).willReturn(artifact);
		Artifact attachedArtifact = mock(Artifact.class);
		given(attachedArtifact.getScope()).willReturn('compile');
		given(attachedArtifact.getArtifactId()).willReturn('attached-artifact');
		given(attachedArtifact.getBaseVersion()).willReturn('1.0-SNAPSHOT');
		given(attachedArtifact.getFile()).willReturn(new File('a'));
		given(attachedArtifact.getArtifactHandler()).willReturn(this.artifactHandler);
		given(mavenProject.getAttachedArtifacts()).willReturn(Collections.singletonList(attachedArtifact));
		this.artifacts = Collections.singleton(attachedArtifact);
		new ArtifactsLibraries(this.artifacts, Collections.singleton(mavenProject), null, mock(Log.class))
			.doWithLibraries((library) -> assertThat(library.isLocal()).isTrue());
	}
	@Test
	void nonIncludedArtifact() throws IOException {
		Artifact artifact = mock(Artifact.class);
		given(artifact.getScope()).willReturn('compile');
		given(artifact.getArtifactId()).willReturn('artifact');
		given(artifact.getBaseVersion()).willReturn('1.0-SNAPSHOT');
		given(artifact.getFile()).willReturn(new File('a'));
		given(artifact.getArtifactHandler()).willReturn(this.artifactHandler);
		MavenProject mavenProject = mock(MavenProject.class);
		given(mavenProject.getArtifact()).willReturn(artifact);
		this.artifacts = Collections.singleton(artifact);
		new ArtifactsLibraries(this.artifacts, Collections.emptySet(), Collections.singleton(mavenProject), null,
				mock(Log.class))
			.doWithLibraries((library) -> assertThat(library.isIncluded()).isFalse());
	}
}
/*
package org.springframework.boot.maven;
/**
class RunArgumentsTests {
	@Test
	void parseNull() {
		String[] args = parseArgs(null);
		assertThat(args).isNotNull();
		assertThat(args).isEmpty();
	}
	@Test
	void parseNullArray() {
		String[] args = new RunArguments((String[]) null).asArray();
		assertThat(args).isNotNull();
		assertThat(args).isEmpty();
	}
	@Test
	void parseArrayContainingNullValue() {
		String[] args = new RunArguments(new String[] { 'foo', null, 'bar' }).asArray();
		assertThat(args).isNotNull();
		assertThat(args).containsOnly('foo', 'bar');
	}
	@Test
	void parseArrayContainingEmptyValue() {
		String[] args = new RunArguments(new String[] { 'foo', '', 'bar' }).asArray();
		assertThat(args).isNotNull();
		assertThat(args).containsOnly('foo', '', 'bar');
	}
	@Test
	void parseEmpty() {
		String[] args = parseArgs('   ');
		assertThat(args).isNotNull();
		assertThat(args).isEmpty();
	}
	@Test
	void parseDebugFlag() {
		String[] args = parseArgs('-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005');
		assertThat(args).hasSize(1);
		assertThat(args[0]).isEqualTo('-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005');
	}
	@Test
	void parseWithExtraSpaces() {
		String[] args = parseArgs('     -Dfoo=bar        -Dfoo2=bar2  ');
		assertThat(args).hasSize(2);
		assertThat(args[0]).isEqualTo('-Dfoo=bar');
		assertThat(args[1]).isEqualTo('-Dfoo2=bar2');
	}
	@Test
	void parseWithNewLinesAndTabs() {
		String[] args = parseArgs('     -Dfoo=bar \n\t\t -Dfoo2=bar2  ');
		assertThat(args).hasSize(2);
		assertThat(args[0]).isEqualTo('-Dfoo=bar');
		assertThat(args[1]).isEqualTo('-Dfoo2=bar2');
	}
	@Test
	void quoteHandledProperly() {
		String[] args = parseArgs('-Dvalue=\'My Value\'    ');
		assertThat(args).hasSize(1);
		assertThat(args[0]).isEqualTo('-Dvalue=My Value');
	}
	private String[] parseArgs(String args) {
		return new RunArguments(args).asArray();
	}
}
/*
package org.springframework.boot.maven;
/**
class EnvVariablesTests {
	@Test
	void asNull() {
		Map<String, String> args = new EnvVariables(null).asMap();
		assertThat(args).isEmpty();
	}
	@Test
	void asArray() {
		assertThat(new EnvVariables(getTestArgs()).asArray()).contains('key=My Value', 'key1= tt ', 'key2=   ',
				'key3=');
	}
	@Test
	void asMap() {
		assertThat(new EnvVariables(getTestArgs()).asMap()).containsExactly(entry('key', 'My Value'),
				entry('key1', ' tt '), entry('key2', '   '), entry('key3', ''));
	}
	private Map<String, String> getTestArgs() {
		Map<String, String> args = new LinkedHashMap<>();
		args.put('key', 'My Value');
		args.put('key1', ' tt ');
		args.put('key2', '   ');
		args.put('key3', null);
		return args;
	}
}
/*
package org.springframework.boot.maven;
/**
class ImageTests {
	@Test
	void getBuildRequestWhenNameIsNullDeducesName() {
		BuildRequest request = new Image().getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getName()).hasToString('docker.io/library/my-app:0.0.1-SNAPSHOT');
	}
	@Test
	void getBuildRequestWhenNameIsSetUsesName() {
		Image image = new Image();
		image.name = 'demo';
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getName()).hasToString('docker.io/library/demo:latest');
	}
	@Test
	void getBuildRequestWhenNoCustomizationsUsesDefaults() {
		BuildRequest request = new Image().getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getName()).hasToString('docker.io/library/my-app:0.0.1-SNAPSHOT');
		assertThat(request.getBuilder().toString()).contains('paketobuildpacks/builder-jammy-java-tiny');
		assertThat(request.isTrustBuilder()).isTrue();
		assertThat(request.getRunImage()).isNull();
		assertThat(request.getEnv()).isEmpty();
		assertThat(request.isCleanCache()).isFalse();
		assertThat(request.isVerboseLogging()).isFalse();
		assertThat(request.getPullPolicy()).isEqualTo(PullPolicy.ALWAYS);
		assertThat(request.isPublish()).isFalse();
		assertThat(request.getBuildpacks()).isEmpty();
		assertThat(request.getBindings()).isEmpty();
		assertThat(request.getNetwork()).isNull();
		assertThat(request.getImagePlatform()).isNull();
	}
	@Test
	void getBuildRequestWhenHasBuilderUsesBuilder() {
		Image image = new Image();
		image.builder = 'springboot/builder:2.2.x';
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuilder()).hasToString('docker.io/springboot/builder:2.2.x');
		assertThat(request.isTrustBuilder()).isFalse();
	}
	@Test
	void getBuildRequestWhenHasBuilderAndTrustBuilderUsesBuilderAndTrustBuilder() {
		Image image = new Image();
		image.builder = 'springboot/builder:2.2.x';
		image.trustBuilder = true;
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuilder()).hasToString('docker.io/springboot/builder:2.2.x');
		assertThat(request.isTrustBuilder()).isTrue();
	}
	@Test
	void getBuildRequestWhenHasDefaultBuilderAndTrustBuilderUsesTrustBuilder() {
		Image image = new Image();
		image.trustBuilder = false;
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuilder().toString()).contains('paketobuildpacks/builder-jammy-java-tiny');
		assertThat(request.isTrustBuilder()).isFalse();
	}
	@Test
	void getBuildRequestWhenHasRunImageUsesRunImage() {
		Image image = new Image();
		image.runImage = 'springboot/run:latest';
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getRunImage()).hasToString('docker.io/springboot/run:latest');
	}
	@Test
	void getBuildRequestWhenHasEnvUsesEnv() {
		Image image = new Image();
		image.env = Collections.singletonMap('test', 'test');
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getEnv()).containsExactly(entry('test', 'test'));
	}
	@Test
	void getBuildRequestWhenHasCleanCacheUsesCleanCache() {
		Image image = new Image();
		image.cleanCache = true;
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.isCleanCache()).isTrue();
	}
	@Test
	void getBuildRequestWhenHasVerboseLoggingUsesVerboseLogging() {
		Image image = new Image();
		image.verboseLogging = true;
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.isVerboseLogging()).isTrue();
	}
	@Test
	void getBuildRequestWhenHasPullPolicyUsesPullPolicy() {
		Image image = new Image();
		image.setPullPolicy(PullPolicy.NEVER);
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getPullPolicy()).isEqualTo(PullPolicy.NEVER);
	}
	@Test
	void getBuildRequestWhenHasPublishUsesPublish() {
		Image image = new Image();
		image.publish = true;
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.isPublish()).isTrue();
	}
	@Test
	void getBuildRequestWhenHasBuildpacksUsesBuildpacks() {
		Image image = new Image();
		image.buildpacks = Arrays.asList('example/buildpack1@0.0.1', 'example/buildpack2@0.0.2');
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuildpacks()).containsExactly(BuildpackReference.of('example/buildpack1@0.0.1'),
				BuildpackReference.of('example/buildpack2@0.0.2'));
	}
	@Test
	void getBuildRequestWhenHasBindingsUsesBindings() {
		Image image = new Image();
		image.bindings = Arrays.asList('host-src:container-dest:ro', 'volume-name:container-dest:rw');
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBindings()).containsExactly(Binding.of('host-src:container-dest:ro'),
				Binding.of('volume-name:container-dest:rw'));
	}
	@Test
	void getBuildRequestWhenNetworkUsesNetwork() {
		Image image = new Image();
		image.network = 'test';
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getNetwork()).isEqualTo('test');
	}
	@Test
	void getBuildRequestWhenHasTagsUsesTags() {
		Image image = new Image();
		image.tags = Arrays.asList('my-app:latest', 'example.com/my-app:0.0.1-SNAPSHOT', 'example.com/my-app:latest');
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getTags()).containsExactly(ImageReference.of('my-app:latest'),
				ImageReference.of('example.com/my-app:0.0.1-SNAPSHOT'), ImageReference.of('example.com/my-app:latest'));
	}
	@Test
	void getBuildRequestWhenHasBuildWorkspaceVolumeUsesWorkspace() {
		Image image = new Image();
		image.buildWorkspace = CacheInfo.fromVolume(new VolumeCacheInfo('build-work-vol'));
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuildWorkspace()).isEqualTo(Cache.volume('build-work-vol'));
	}
	@Test
	void getBuildRequestWhenHasBuildCacheVolumeUsesCache() {
		Image image = new Image();
		image.buildCache = CacheInfo.fromVolume(new VolumeCacheInfo('build-cache-vol'));
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuildCache()).isEqualTo(Cache.volume('build-cache-vol'));
	}
	@Test
	void getBuildRequestWhenHasLaunchCacheVolumeUsesCache() {
		Image image = new Image();
		image.launchCache = CacheInfo.fromVolume(new VolumeCacheInfo('launch-cache-vol'));
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getLaunchCache()).isEqualTo(Cache.volume('launch-cache-vol'));
	}
	@Test
	void getBuildRequestWhenHasBuildWorkspaceBindUsesWorkspace() {
		Image image = new Image();
		image.buildWorkspace = CacheInfo.fromBind(new BindCacheInfo('build-work-dir'));
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuildWorkspace()).isEqualTo(Cache.bind('build-work-dir'));
	}
	@Test
	void getBuildRequestWhenHasBuildCacheBindUsesCache() {
		Image image = new Image();
		image.buildCache = CacheInfo.fromBind(new BindCacheInfo('build-cache-dir'));
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getBuildCache()).isEqualTo(Cache.bind('build-cache-dir'));
	}
	@Test
	void getBuildRequestWhenHasLaunchCacheBindUsesCache() {
		Image image = new Image();
		image.launchCache = CacheInfo.fromBind(new BindCacheInfo('launch-cache-dir'));
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getLaunchCache()).isEqualTo(Cache.bind('launch-cache-dir'));
	}
	@Test
	void getBuildRequestWhenHasCreatedDateUsesCreatedDate() {
		Image image = new Image();
		image.createdDate = '2020-07-01T12:34:56Z';
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getCreatedDate()).isEqualTo('2020-07-01T12:34:56Z');
	}
	@Test
	void getBuildRequestWhenHasApplicationDirectoryUsesApplicationDirectory() {
		Image image = new Image();
		image.applicationDirectory = '/application';
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getApplicationDirectory()).isEqualTo('/application');
	}
	@Test
	void getBuildRequestWhenHasNoSecurityOptionsUsesNoSecurityOptions() {
		Image image = new Image();
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getSecurityOptions()).isNull();
	}
	@Test
	void getBuildRequestWhenHasSecurityOptionsUsesSecurityOptions() {
		Image image = new Image();
		image.securityOptions = List.of('label=user:USER', 'label=role:ROLE');
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getSecurityOptions()).containsExactly('label=user:USER', 'label=role:ROLE');
	}
	@Test
	void getBuildRequestWhenHasEmptySecurityOptionsUsesSecurityOptions() {
		Image image = new Image();
		image.securityOptions = Collections.emptyList();
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getSecurityOptions()).isEmpty();
	}
	@Test
	void getBuildRequestWhenHasImagePlatformUsesImagePlatform() {
		Image image = new Image();
		image.imagePlatform = 'linux/arm64';
		BuildRequest request = image.getBuildRequest(createArtifact(), mockApplicationContent());
		assertThat(request.getImagePlatform()).isEqualTo(ImagePlatform.of('linux/arm64'));
	}
	private Artifact createArtifact() {
		return new DefaultArtifact('com.example', 'my-app', VersionRange.createFromVersion('0.0.1-SNAPSHOT'), 'compile',
				'jar', null, new DefaultArtifactHandler());
	}
	private Function<Owner, TarArchive> mockApplicationContent() {
		return (owner) -> null;
	}
}
/*
package org.springframework.boot.maven;
/**
@SuppressWarnings({ 'rawtypes', 'unchecked' })
class ExcludeFilterTests {
	@Test
	void excludeSimple() throws ArtifactFilterException {
		ExcludeFilter filter = new ExcludeFilter(Arrays.asList(createExclude('com.foo', 'bar')));
		Set result = filter.filter(Collections.singleton(createArtifact('com.foo', 'bar')));
		assertThat(result).isEmpty();
	}
	@Test
	void excludeGroupIdNoMatch() throws ArtifactFilterException {
		ExcludeFilter filter = new ExcludeFilter(Arrays.asList(createExclude('com.foo', 'bar')));
		Artifact artifact = createArtifact('com.baz', 'bar');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).hasSize(1);
		assertThat(result.iterator().next()).isSameAs(artifact);
	}
	@Test
	void excludeArtifactIdNoMatch() throws ArtifactFilterException {
		ExcludeFilter filter = new ExcludeFilter(Arrays.asList(createExclude('com.foo', 'bar')));
		Artifact artifact = createArtifact('com.foo', 'biz');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).hasSize(1);
		assertThat(result.iterator().next()).isSameAs(artifact);
	}
	@Test
	void excludeClassifier() throws ArtifactFilterException {
		ExcludeFilter filter = new ExcludeFilter(Arrays.asList(createExclude('com.foo', 'bar', 'jdk5')));
		Set result = filter.filter(Collections.singleton(createArtifact('com.foo', 'bar', 'jdk5')));
		assertThat(result).isEmpty();
	}
	@Test
	void excludeClassifierNoTargetClassifier() throws ArtifactFilterException {
		ExcludeFilter filter = new ExcludeFilter(Arrays.asList(createExclude('com.foo', 'bar', 'jdk5')));
		Artifact artifact = createArtifact('com.foo', 'bar');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).hasSize(1);
		assertThat(result.iterator().next()).isSameAs(artifact);
	}
	@Test
	void excludeClassifierNoMatch() throws ArtifactFilterException {
		ExcludeFilter filter = new ExcludeFilter(Arrays.asList(createExclude('com.foo', 'bar', 'jdk5')));
		Artifact artifact = createArtifact('com.foo', 'bar', 'jdk6');
		Set result = filter.filter(Collections.singleton(artifact));
		assertThat(result).hasSize(1);
		assertThat(result.iterator().next()).isSameAs(artifact);
	}
	@Test
	void excludeMulti() throws ArtifactFilterException {
		ExcludeFilter filter = new ExcludeFilter(Arrays.asList(createExclude('com.foo', 'bar'),
				createExclude('com.foo', 'bar2'), createExclude('org.acme', 'app')));
		Set<Artifact> artifacts = new HashSet<>();
		artifacts.add(createArtifact('com.foo', 'bar'));
		artifacts.add(createArtifact('com.foo', 'bar'));
		Artifact anotherAcme = createArtifact('org.acme', 'another-app');
		artifacts.add(anotherAcme);
		Set result = filter.filter(artifacts);
		assertThat(result).hasSize(1);
		assertThat(result.iterator().next()).isSameAs(anotherAcme);
	}
	private Exclude createExclude(String groupId, String artifactId) {
		return createExclude(groupId, artifactId, null);
	}
	private Exclude createExclude(String groupId, String artifactId, String classifier) {
		Exclude exclude = new Exclude();
		exclude.setGroupId(groupId);
		exclude.setArtifactId(artifactId);
		if (classifier != null) {
			exclude.setClassifier(classifier);
		}
		return exclude;
	}
	private Artifact createArtifact(String groupId, String artifactId, String classifier) {
		Artifact a = mock(Artifact.class);
		given(a.getGroupId()).willReturn(groupId);
		given(a.getArtifactId()).willReturn(artifactId);
		given(a.getClassifier()).willReturn(classifier);
		return a;
	}
	private Artifact createArtifact(String groupId, String artifactId) {
		return createArtifact(groupId, artifactId, null);
	}
}
/*
package org.springframework.boot.maven;
/**
class CustomLayersProviderTests {
	private CustomLayersProvider customLayersProvider;
	@BeforeEach
	void setup() {
		this.customLayersProvider = new CustomLayersProvider();
	}
	@Test
	void getLayerResolverWhenDocumentValid() throws Exception {
		CustomLayers layers = this.customLayersProvider.getLayers(getDocument('layers.xml'));
		assertThat(layers).extracting('name')
			.containsExactly('my-deps', 'my-dependencies-name', 'snapshot-dependencies', 'my-resources',
					'configuration', 'application');
		Library snapshot = mockLibrary('test-SNAPSHOT.jar', 'org.foo', '1.0.0-SNAPSHOT');
		Library groupId = mockLibrary('my-library', 'com.acme', null);
		Library otherDependency = mockLibrary('other-library', 'org.foo', null);
		Library localSnapshotDependency = mockLibrary('local-library', 'org.foo', '1.0-SNAPSHOT');
		given(localSnapshotDependency.isLocal()).willReturn(true);
		assertThat(layers.getLayer(snapshot)).hasToString('snapshot-dependencies');
		assertThat(layers.getLayer(groupId)).hasToString('my-deps');
		assertThat(layers.getLayer(otherDependency)).hasToString('my-dependencies-name');
		assertThat(layers.getLayer(localSnapshotDependency)).hasToString('application');
		assertThat(layers.getLayer('META-INF/resources/test.css')).hasToString('my-resources');
		assertThat(layers.getLayer('application.yml')).hasToString('configuration');
		assertThat(layers.getLayer('test')).hasToString('application');
	}
	private Library mockLibrary(String name, String groupId, String version) {
		Library library = mock(Library.class);
		given(library.getName()).willReturn(name);
		given(library.getCoordinates()).willReturn(LibraryCoordinates.of(groupId, null, version));
		return library;
	}
	@Test
	void getLayerResolverWhenDocumentContainsLibraryLayerWithNoFilters() throws Exception {
		CustomLayers layers = this.customLayersProvider.getLayers(getDocument('dependencies-layer-no-filter.xml'));
		Library library = mockLibrary('my-library', 'com.acme', null);
		assertThat(layers.getLayer(library)).hasToString('my-deps');
		assertThatIllegalStateException().isThrownBy(() -> layers.getLayer('application.yml'))
			.withMessageContaining('match any layer');
	}
	@Test
	void getLayerResolverWhenDocumentContainsResourceLayerWithNoFilters() throws Exception {
		CustomLayers layers = this.customLayersProvider.getLayers(getDocument('application-layer-no-filter.xml'));
		Library library = mockLibrary('my-library', 'com.acme', null);
		assertThat(layers.getLayer('application.yml')).hasToString('my-layer');
		assertThatIllegalStateException().isThrownBy(() -> layers.getLayer(library))
			.withMessageContaining('match any layer');
	}
	private Document getDocument(String resourceName) throws Exception {
		ClassPathResource resource = new ClassPathResource(resourceName);
		InputSource inputSource = new InputSource(resource.getInputStream());
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(true);
		DocumentBuilder documentBuilder = factory.newDocumentBuilder();
		return documentBuilder.parse(inputSource);
	}
}
/*
package org.springframework.boot.maven;
/**
class MavenBuildOutputTimestampTests {
	@Test
	void shouldParseNull() {
		assertThat(parse(null)).isNull();
	}
	@Test
	void shouldParseSingleDigit() {
		assertThat(parse('0')).isEqualTo(Instant.parse('1970-01-01T00:00:00Z'));
	}
	@Test
	void shouldNotParseSingleCharacter() {
		assertThat(parse('a')).isNull();
	}
	@Test
	void shouldParseIso8601() {
		assertThat(parse('2011-12-03T10:15:30Z')).isEqualTo(Instant.parse('2011-12-03T10:15:30Z'));
	}
	@Test
	void shouldParseIso8601WithMilliseconds() {
		assertThat(parse('2011-12-03T10:15:30.12345Z')).isEqualTo(Instant.parse('2011-12-03T10:15:30Z'));
	}
	@Test
	void shouldFailIfIso8601BeforeMin() {
		assertThatIllegalArgumentException().isThrownBy(() -> parse('1970-01-01T00:00:00Z'))
			.withMessage(
					'"1970-01-01T00:00:00Z" is not within the valid range 1980-01-01T00:00:02Z to 2099-12-31T23:59:59Z');
	}
	@Test
	void shouldFailIfIso8601AfterMax() {
		assertThatIllegalArgumentException().isThrownBy(() -> parse('2100-01-01T00:00:00Z'))
			.withMessage(
					'"2100-01-01T00:00:00Z" is not within the valid range 1980-01-01T00:00:02Z to 2099-12-31T23:59:59Z');
	}
	@Test
	void shouldFailIfNotIso8601() {
		assertThatIllegalArgumentException().isThrownBy(() -> parse('dummy'))
			.withMessage('Can"t parse "dummy" to instant');
	}
	@Test
	void shouldParseIso8601WithOffset() {
		assertThat(parse('2019-10-05T20:37:42+06:00')).isEqualTo(Instant.parse('2019-10-05T14:37:42Z'));
	}
	@Test
	void shouldParseToFileTime() {
		assertThat(parseFileTime(null)).isEqualTo(null);
		assertThat(parseFileTime('0')).isEqualTo(FileTime.fromMillis(0));
		assertThat(parseFileTime('2019-10-05T14:37:42Z')).isEqualTo(FileTime.fromMillis(1570286262000L));
	}
	private static Instant parse(String timestamp) {
		return new MavenBuildOutputTimestamp(timestamp).toInstant();
	}
	private static FileTime parseFileTime(String timestamp) {
		return new MavenBuildOutputTimestamp(timestamp).toFileTime();
	}
}
/*
package org.springframework.boot.maven;
/**
class JavaCompilerPluginConfigurationTests {
	private MavenProject project;
	private Plugin plugin;
	@BeforeEach
	void setUp() {
		this.project = mock(MavenProject.class);
		this.plugin = mock(Plugin.class);
		given(this.project.getPlugin(anyString())).willReturn(this.plugin);
	}
	@Test
	void versionsAreNullWithNoConfiguration() {
		given(this.plugin.getConfiguration()).willReturn(null);
		given(this.project.getProperties()).willReturn(new Properties());
		JavaCompilerPluginConfiguration configuration = new JavaCompilerPluginConfiguration(this.project);
		assertThat(configuration.getSourceMajorVersion()).isNull();
		assertThat(configuration.getTargetMajorVersion()).isNull();
		assertThat(configuration.getReleaseVersion()).isNull();
	}
	@Test
	void versionsAreReturnedFromConfiguration() throws IOException, XmlPullParserException {
		Xpp3Dom dom = buildConfigurationDom('<source>1.9</source>', '<target>11</target>', '<release>12</release>');
		given(this.plugin.getConfiguration()).willReturn(dom);
		Properties properties = new Properties();
		properties.setProperty('maven.compiler.source', '1.8');
		properties.setProperty('maven.compiler.target', '10');
		properties.setProperty('maven.compiler.release', '11');
		given(this.project.getProperties()).willReturn(properties);
		JavaCompilerPluginConfiguration configuration = new JavaCompilerPluginConfiguration(this.project);
		assertThat(configuration.getSourceMajorVersion()).isEqualTo('9');
		assertThat(configuration.getTargetMajorVersion()).isEqualTo('11');
		assertThat(configuration.getReleaseVersion()).isEqualTo('12');
	}
	@Test
	void versionsAreReturnedFromProperties() {
		given(this.plugin.getConfiguration()).willReturn(null);
		Properties properties = new Properties();
		properties.setProperty('maven.compiler.source', '1.8');
		properties.setProperty('maven.compiler.target', '11');
		properties.setProperty('maven.compiler.release', '12');
		given(this.project.getProperties()).willReturn(properties);
		JavaCompilerPluginConfiguration configuration = new JavaCompilerPluginConfiguration(this.project);
		assertThat(configuration.getSourceMajorVersion()).isEqualTo('8');
		assertThat(configuration.getTargetMajorVersion()).isEqualTo('11');
		assertThat(configuration.getReleaseVersion()).isEqualTo('12');
	}
	private Xpp3Dom buildConfigurationDom(String... properties) throws IOException, XmlPullParserException {
		return Xpp3DomBuilder
			.build(new StringReader('<configuration>' + Arrays.toString(properties) + '</configuration>'));
	}
}
/*
package org.springframework.boot.maven;
/**
class AbstractRunMojoTests {
	@Test
	void argfileEscapesContent() throws IOException {
		ArgFile file = ArgFile.create('some \\ content');
		assertThat(file.path()).content(StandardCharsets.UTF_8).isEqualTo('\'some \\\\ content\'');
	}
}
/*
package org.springframework.boot.maven;
/**
class DockerTests {
	@Test
	void asDockerConfigurationWithDefaults() {
		Docker docker = new Docker();
		DockerConfiguration dockerConfiguration = createDockerConfiguration(docker);
		assertThat(dockerConfiguration.getHost()).isNull();
		assertThat(dockerConfiguration.getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithHostConfiguration() {
		Docker docker = new Docker();
		docker.setHost('docker.example.com');
		docker.setTlsVerify(true);
		docker.setCertPath('/tmp/ca-cert');
		DockerConfiguration dockerConfiguration = createDockerConfiguration(docker);
		DockerHostConfiguration host = dockerConfiguration.getHost();
		assertThat(host.getAddress()).isEqualTo('docker.example.com');
		assertThat(host.isSecure()).isTrue();
		assertThat(host.getCertificatePath()).isEqualTo('/tmp/ca-cert');
		assertThat(host.getContext()).isNull();
		assertThat(dockerConfiguration.isBindHostToBuilder()).isFalse();
		assertThat(createDockerConfiguration(docker).getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithContextConfiguration() {
		Docker docker = new Docker();
		docker.setContext('test-context');
		DockerConfiguration dockerConfiguration = createDockerConfiguration(docker);
		DockerHostConfiguration host = dockerConfiguration.getHost();
		assertThat(host.getContext()).isEqualTo('test-context');
		assertThat(host.getAddress()).isNull();
		assertThat(host.isSecure()).isFalse();
		assertThat(host.getCertificatePath()).isNull();
		assertThat(dockerConfiguration.isBindHostToBuilder()).isFalse();
		assertThat(createDockerConfiguration(docker).getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithHostAndContextFails() {
		Docker docker = new Docker();
		docker.setContext('test-context');
		docker.setHost('docker.example.com');
		assertThatIllegalArgumentException().isThrownBy(() -> createDockerConfiguration(docker))
			.withMessageContaining('Invalid Docker configuration');
	}
	@Test
	void asDockerConfigurationWithBindHostToBuilder() {
		Docker docker = new Docker();
		docker.setHost('docker.example.com');
		docker.setTlsVerify(true);
		docker.setCertPath('/tmp/ca-cert');
		docker.setBindHostToBuilder(true);
		DockerConfiguration dockerConfiguration = createDockerConfiguration(docker);
		DockerHostConfiguration host = dockerConfiguration.getHost();
		assertThat(host.getAddress()).isEqualTo('docker.example.com');
		assertThat(host.isSecure()).isTrue();
		assertThat(host.getCertificatePath()).isEqualTo('/tmp/ca-cert');
		assertThat(dockerConfiguration.isBindHostToBuilder()).isTrue();
		assertThat(createDockerConfiguration(docker).getBuilderRegistryAuthentication()).isNull();
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'\'')
			.contains('\'password\' : \'\'')
			.contains('\'email\' : \'\'')
			.contains('\'serveraddress\' : \'\'');
	}
	@Test
	void asDockerConfigurationWithUserAuth() {
		Docker docker = new Docker();
		docker.setBuilderRegistry(
				new Docker.DockerRegistry('user1', 'secret1', 'https://docker1.example.com', 'docker1@example.com'));
		docker.setPublishRegistry(
				new Docker.DockerRegistry('user2', 'secret2', 'https://docker2.example.com', 'docker2@example.com'));
		DockerConfiguration dockerConfiguration = createDockerConfiguration(docker);
		assertThat(decoded(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'user1\'')
			.contains('\'password\' : \'secret1\'')
			.contains('\'email\' : \'docker1@example.com\'')
			.contains('\'serveraddress\' : \'https://docker1.example.com\'');
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'username\' : \'user2\'')
			.contains('\'password\' : \'secret2\'')
			.contains('\'email\' : \'docker2@example.com\'')
			.contains('\'serveraddress\' : \'https://docker2.example.com\'');
	}
	@Test
	void asDockerConfigurationWithIncompleteBuilderUserAuthFails() {
		Docker docker = new Docker();
		docker.setBuilderRegistry(
				new Docker.DockerRegistry('user', null, 'https://docker.example.com', 'docker@example.com'));
		assertThatIllegalArgumentException().isThrownBy(() -> createDockerConfiguration(docker))
			.withMessageContaining('Invalid Docker builder registry configuration');
	}
	@Test
	void asDockerConfigurationWithIncompletePublishUserAuthFails() {
		Docker docker = new Docker();
		docker.setPublishRegistry(
				new Docker.DockerRegistry('user', null, 'https://docker.example.com', 'docker@example.com'));
		assertThatIllegalArgumentException().isThrownBy(() -> createDockerConfiguration(docker))
			.withMessageContaining('Invalid Docker publish registry configuration');
	}
	@Test
	void asDockerConfigurationWithIncompletePublishUserAuthDoesNotFailIfPublishIsDisabled() {
		Docker docker = new Docker();
		docker.setPublishRegistry(
				new Docker.DockerRegistry('user', null, 'https://docker.example.com', 'docker@example.com'));
		DockerConfiguration dockerConfiguration = docker.asDockerConfiguration(false);
		assertThat(dockerConfiguration.getPublishRegistryAuthentication()).isNull();
	}
	@Test
	void asDockerConfigurationWithTokenAuth() {
		Docker docker = new Docker();
		docker.setBuilderRegistry(new Docker.DockerRegistry('token1'));
		docker.setPublishRegistry(new Docker.DockerRegistry('token2'));
		DockerConfiguration dockerConfiguration = createDockerConfiguration(docker);
		assertThat(decoded(dockerConfiguration.getBuilderRegistryAuthentication().getAuthHeader()))
			.contains('\'identitytoken\' : \'token1\'');
		assertThat(decoded(dockerConfiguration.getPublishRegistryAuthentication().getAuthHeader()))
			.contains('\'identitytoken\' : \'token2\'');
	}
	@Test
	void asDockerConfigurationWithUserAndTokenAuthFails() {
		Docker.DockerRegistry dockerRegistry = new Docker.DockerRegistry();
		dockerRegistry.setUsername('user');
		dockerRegistry.setPassword('secret');
		dockerRegistry.setToken('token');
		Docker docker = new Docker();
		docker.setBuilderRegistry(dockerRegistry);
		assertThatIllegalArgumentException().isThrownBy(() -> createDockerConfiguration(docker))
			.withMessageContaining('Invalid Docker builder registry configuration');
	}
	@Test
	void asDockerConfigurationWithUserAndTokenAuthDoesNotFailIfPublishingIsDisabled() {
		Docker.DockerRegistry dockerRegistry = new Docker.DockerRegistry();
		dockerRegistry.setUsername('user');
		dockerRegistry.setPassword('secret');
		dockerRegistry.setToken('token');
		Docker docker = new Docker();
		docker.setPublishRegistry(dockerRegistry);
		DockerConfiguration dockerConfiguration = docker.asDockerConfiguration(false);
		assertThat(dockerConfiguration.getPublishRegistryAuthentication()).isNull();
	}
	private DockerConfiguration createDockerConfiguration(Docker docker) {
		return docker.asDockerConfiguration(true);
	}
	String decoded(String value) {
		return new String(Base64.getDecoder().decode(value));
	}
}
/*
package org.springframework.boot.maven;
/**
class CommandLineBuilderTests {
	public static final String CLASS_NAME = ClassWithMainMethod.class.getName();
	@Test
	void buildWithNullJvmArgumentsIsIgnored() {
		assertThat(CommandLineBuilder.forMainClass(CLASS_NAME).withJvmArguments((String[]) null).build())
			.containsExactly(CLASS_NAME);
	}
	@Test
	void buildWithNullIntermediateJvmArgumentIsIgnored() {
		assertThat(CommandLineBuilder.forMainClass(CLASS_NAME)
			.withJvmArguments('-verbose:class', null, '-verbose:gc')
			.build()).containsExactly('-verbose:class', '-verbose:gc', CLASS_NAME);
	}
	@Test
	void buildWithJvmArgument() {
		assertThat(CommandLineBuilder.forMainClass(CLASS_NAME).withJvmArguments('-verbose:class').build())
			.containsExactly('-verbose:class', CLASS_NAME);
	}
	@Test
	void buildWithNullSystemPropertyIsIgnored() {
		assertThat(CommandLineBuilder.forMainClass(CLASS_NAME).withSystemProperties(null).build())
			.containsExactly(CLASS_NAME);
	}
	@Test
	void buildWithSystemProperty() {
		assertThat(CommandLineBuilder.forMainClass(CLASS_NAME).withSystemProperties(Map.of('flag', 'enabled')).build())
			.containsExactly('-Dflag=\'enabled\'', CLASS_NAME);
	}
	@Test
	void buildWithNullArgumentsIsIgnored() {
		assertThat(CommandLineBuilder.forMainClass(CLASS_NAME).withArguments((String[]) null).build())
			.containsExactly(CLASS_NAME);
	}
	@Test
	void buildWithNullIntermediateArgumentIsIgnored() {
		assertThat(CommandLineBuilder.forMainClass(CLASS_NAME).withArguments('--test', null, '--another').build())
			.containsExactly(CLASS_NAME, '--test', '--another');
	}
}
/*
package org.springframework.boot.maven;
/**
class DependencyFilterMojoTests {
	@TempDir
	static Path temp;
	@Test
	void filterDependencies() throws MojoExecutionException {
		TestableDependencyFilterMojo mojo = new TestableDependencyFilterMojo(Collections.emptyList(), 'com.foo');
		Artifact artifact = createArtifact('com.bar', 'one');
		Set<Artifact> artifacts = mojo.filterDependencies(createArtifact('com.foo', 'one'),
				createArtifact('com.foo', 'two'), artifact);
		assertThat(artifacts).hasSize(1);
		assertThat(artifacts.iterator().next()).isSameAs(artifact);
	}
	@Test
	void filterGroupIdExactMatch() throws MojoExecutionException {
		TestableDependencyFilterMojo mojo = new TestableDependencyFilterMojo(Collections.emptyList(), 'com.foo');
		Artifact artifact = createArtifact('com.foo.bar', 'one');
		Set<Artifact> artifacts = mojo.filterDependencies(createArtifact('com.foo', 'one'),
				createArtifact('com.foo', 'two'), artifact);
		assertThat(artifacts).hasSize(1);
		assertThat(artifacts.iterator().next()).isSameAs(artifact);
	}
	@Test
	void filterScopeKeepOrder() throws MojoExecutionException {
		TestableDependencyFilterMojo mojo = new TestableDependencyFilterMojo(Collections.emptyList(), '',
				new ScopeFilter(null, Artifact.SCOPE_SYSTEM));
		Artifact one = createArtifact('com.foo', 'one');
		Artifact two = createArtifact('com.foo', 'two', Artifact.SCOPE_SYSTEM);
		Artifact three = createArtifact('com.foo', 'three', Artifact.SCOPE_RUNTIME);
		Set<Artifact> artifacts = mojo.filterDependencies(one, two, three);
		assertThat(artifacts).containsExactly(one, three);
	}
	@Test
	void filterGroupIdKeepOrder() throws MojoExecutionException {
		TestableDependencyFilterMojo mojo = new TestableDependencyFilterMojo(Collections.emptyList(), 'com.foo');
		Artifact one = createArtifact('com.foo', 'one');
		Artifact two = createArtifact('com.bar', 'two');
		Artifact three = createArtifact('com.bar', 'three');
		Artifact four = createArtifact('com.foo', 'four');
		Set<Artifact> artifacts = mojo.filterDependencies(one, two, three, four);
		assertThat(artifacts).containsExactly(two, three);
	}
	@Test
	void filterExcludeKeepOrder() throws MojoExecutionException {
		Exclude exclude = new Exclude();
		exclude.setGroupId('com.bar');
		exclude.setArtifactId('two');
		TestableDependencyFilterMojo mojo = new TestableDependencyFilterMojo(Collections.singletonList(exclude), '');
		Artifact one = createArtifact('com.foo', 'one');
		Artifact two = createArtifact('com.bar', 'two');
		Artifact three = createArtifact('com.bar', 'three');
		Artifact four = createArtifact('com.foo', 'four');
		Set<Artifact> artifacts = mojo.filterDependencies(one, two, three, four);
		assertThat(artifacts).containsExactly(one, three, four);
	}
	@Test
	void excludeByJarType() throws MojoExecutionException {
		TestableDependencyFilterMojo mojo = new TestableDependencyFilterMojo(Collections.emptyList(), '');
		Artifact one = createArtifact('com.foo', 'one', null, 'dependencies-starter');
		Artifact two = createArtifact('com.bar', 'two');
		Set<Artifact> artifacts = mojo.filterDependencies(one, two);
		assertThat(artifacts).containsExactly(two);
	}
	private static Artifact createArtifact(String groupId, String artifactId) {
		return createArtifact(groupId, artifactId, null);
	}
	private static Artifact createArtifact(String groupId, String artifactId, String scope) {
		return createArtifact(groupId, artifactId, scope, null);
	}
	private static Artifact createArtifact(String groupId, String artifactId, String scope, String jarType) {
		Artifact a = mock(Artifact.class);
		given(a.getGroupId()).willReturn(groupId);
		given(a.getArtifactId()).willReturn(artifactId);
		if (scope != null) {
			given(a.getScope()).willReturn(scope);
		}
		given(a.getFile()).willReturn(createArtifactFile(jarType));
		return a;
	}
	private static File createArtifactFile(String jarType) {
		Path jarPath = temp.resolve(UUID.randomUUID() + '.jar');
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue('Manifest-Version', '1.0');
		if (jarType != null) {
			manifest.getMainAttributes().putValue('Spring-Boot-Jar-Type', jarType);
		}
		try {
			new JarOutputStream(new FileOutputStream(jarPath.toFile()), manifest).close();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
		return jarPath.toFile();
	}
	private static final class TestableDependencyFilterMojo extends AbstractDependencyFilterMojo {
		private final ArtifactsFilter[] additionalFilters;
		private TestableDependencyFilterMojo(List<Exclude> excludes, String excludeGroupIds,
				ArtifactsFilter... additionalFilters) {
			setExcludes(excludes);
			setExcludeGroupIds(excludeGroupIds);
			this.additionalFilters = additionalFilters;
		}
		Set<Artifact> filterDependencies(Artifact... artifacts) throws MojoExecutionException {
			Set<Artifact> input = new LinkedHashSet<>(Arrays.asList(artifacts));
			return filterDependencies(input, this.additionalFilters);
		}
		@Override
		public void execute() {
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'repackage', defaultPhase = LifecyclePhase.PACKAGE, requiresProject = true, threadSafe = true,
		requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME,
		requiresDependencyCollection = ResolutionScope.COMPILE_PLUS_RUNTIME)
public class RepackageMojo extends AbstractPackagerMojo {
	private static final Pattern WHITE_SPACE_PATTERN = Pattern.compile('\\s+');
	/**
	 * Directory containing the generated archive.
	 * @since 1.0.0
	 */
	@Parameter(defaultValue = '${project.build.directory}', required = true)
	private File outputDirectory;
	/**
	 * Name of the generated archive.
	 * @since 1.0.0
	 */
	@Parameter(defaultValue = '${project.build.finalName}', readonly = true)
	private String finalName;
	/**
	 * Skip the execution.
	 * @since 1.2.0
	 */
	@Parameter(property = 'spring-boot.repackage.skip', defaultValue = 'false')
	private boolean skip;
	/**
	 * Classifier to add to the repackaged archive. If not given, the main artifact will
	 * be replaced by the repackaged archive. If given, the classifier will also be used
	 * to determine the source archive to repackage: if an artifact with that classifier
	 * already exists, it will be used as source and replaced. If no such artifact exists,
	 * the main artifact will be used as source and the repackaged archive will be
	 * attached as a supplemental artifact with that classifier. Attaching the artifact
	 * allows to deploy it alongside to the original one, see <a href=
	 * 'https://maven.apache.org/plugins/maven-deploy-plugin/examples/deploying-with-classifiers.html'
	 * >the Maven documentation for more details</a>.
	 * @since 1.0.0
	 */
	@Parameter
	private String classifier;
	/**
	 * Attach the repackaged archive to be installed into your local Maven repository or
	 * deployed to a remote repository. If no classifier has been configured, it will
	 * replace the normal jar. If a {@code classifier} has been configured such that the
	 * normal jar and the repackaged jar are different, it will be attached alongside the
	 * normal jar. When the property is set to {@code false}, the repackaged archive will
	 * not be installed or deployed.
	 * @since 1.4.0
	 */
	@Parameter(defaultValue = 'true')
	private boolean attach = true;
	/**
	 * A list of the libraries that must be unpacked from uber jars in order to run.
	 * Specify each library as a {@code <dependency>} with a {@code <groupId>} and a
	 * {@code <artifactId>} and they will be unpacked at runtime.
	 * @since 1.1.0
	 */
	@Parameter
	private List<Dependency> requiresUnpack;
	/**
	 * Make a fully executable jar for *nix machines by prepending a launch script to the
	 * jar.
	 * <p>
	 * Currently, some tools do not accept this format so you may not always be able to
	 * use this technique. For example, {@code jar -xf} may silently fail to extract a jar
	 * or war that has been made fully-executable. It is recommended that you only enable
	 * this option if you intend to execute it directly, rather than running it with
	 * {@code java -jar} or deploying it to a servlet container.
	 * @since 1.3.0
	 */
	@Parameter(defaultValue = 'false')
	private boolean executable;
	/**
	 * The embedded launch script to prepend to the front of the jar if it is fully
	 * executable. If not specified the "Spring Boot" default script will be used.
	 * @since 1.3.0
	 */
	@Parameter
	private File embeddedLaunchScript;
	/**
	 * Properties that should be expanded in the embedded launch script.
	 * @since 1.3.0
	 */
	@Parameter
	private Properties embeddedLaunchScriptProperties;
	/**
	 * Timestamp for reproducible output archive entries, either formatted as ISO 8601
	 * (<code>yyyy-MM-dd"T"HH:mm:ssXXX</code>) or an {@code int} representing seconds
	 * since the epoch.
	 * @since 2.3.0
	 */
	@Parameter(defaultValue = '${project.build.outputTimestamp}')
	private String outputTimestamp;
	/**
	 * The type of archive (which corresponds to how the dependencies are laid out inside
	 * it). Possible values are {@code JAR}, {@code WAR}, {@code ZIP}, {@code DIR},
	 * {@code NONE}. Defaults to a guess based on the archive type.
	 * @since 1.0.0
	 */
	@Parameter(property = 'spring-boot.repackage.layout')
	private LayoutType layout;
	/**
	 * The loader implementation that should be used.
	 * @since 3.2.0
	 */
	@Parameter
	private LoaderImplementation loaderImplementation;
	/**
	 * The layout factory that will be used to create the executable archive if no
	 * explicit layout is set. Alternative layouts implementations can be provided by 3rd
	 * parties.
	 * @since 1.5.0
	 */
	@Parameter
	private LayoutFactory layoutFactory;
	/**
	 * Return the type of archive that should be packaged by this MOJO.
	 * @return the value of the {@code layout} parameter, or {@code null} if the parameter
	 * is not provided
	 */
	@Override
	protected LayoutType getLayout() {
		return this.layout;
	}
	@Override
	protected LoaderImplementation getLoaderImplementation() {
		return this.loaderImplementation;
	}
	/**
	 * Return the layout factory that will be used to determine the
	 * {@link AbstractPackagerMojo.LayoutType} if no explicit layout is set.
	 * @return the value of the {@code layoutFactory} parameter, or {@code null} if the
	 * parameter is not provided
	 */
	@Override
	protected LayoutFactory getLayoutFactory() {
		return this.layoutFactory;
	}
	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		if (this.project.getPackaging().equals('pom')) {
			getLog().debug('repackage goal could not be applied to pom project.');
			return;
		}
		if (this.skip) {
			getLog().debug('skipping repackaging as per configuration.');
			return;
		}
		repackage();
	}
	private void repackage() throws MojoExecutionException {
		Artifact source = getSourceArtifact(this.classifier);
		File target = getTargetFile(this.finalName, this.classifier, this.outputDirectory);
		if (source.getFile() == null) {
			throw new MojoExecutionException(
					'Source file is not available, make sure "package" runs as part of the same lifecycle');
		}
		Repackager repackager = getRepackager(source.getFile());
		Libraries libraries = getLibraries(this.requiresUnpack);
		try {
			LaunchScript launchScript = getLaunchScript();
			repackager.repackage(target, libraries, launchScript, parseOutputTimestamp());
		}
		catch (IOException ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
		updateArtifact(source, target, repackager.getBackupFile());
	}
	private FileTime parseOutputTimestamp() throws MojoExecutionException {
		try {
			return new MavenBuildOutputTimestamp(this.outputTimestamp).toFileTime();
		}
		catch (IllegalArgumentException ex) {
			throw new MojoExecutionException('Invalid value for parameter "outputTimestamp"', ex);
		}
	}
	private Repackager getRepackager(File source) {
		return getConfiguredPackager(() -> new Repackager(source));
	}
	private LaunchScript getLaunchScript() throws IOException {
		if (this.executable || this.embeddedLaunchScript != null) {
			return new DefaultLaunchScript(this.embeddedLaunchScript, buildLaunchScriptProperties());
		}
		return null;
	}
	private Properties buildLaunchScriptProperties() {
		Properties properties = new Properties();
		if (this.embeddedLaunchScriptProperties != null) {
			properties.putAll(this.embeddedLaunchScriptProperties);
		}
		putIfMissing(properties, 'initInfoProvides', this.project.getArtifactId());
		putIfMissing(properties, 'initInfoShortDescription', this.project.getName(), this.project.getArtifactId());
		putIfMissing(properties, 'initInfoDescription', removeLineBreaks(this.project.getDescription()),
				this.project.getName(), this.project.getArtifactId());
		return properties;
	}
	private String removeLineBreaks(String description) {
		return (description != null) ? WHITE_SPACE_PATTERN.matcher(description).replaceAll(' ') : null;
	}
	private void putIfMissing(Properties properties, String key, String... valueCandidates) {
		if (!properties.containsKey(key)) {
			for (String candidate : valueCandidates) {
				if (StringUtils.hasLength(candidate)) {
					properties.put(key, candidate);
					return;
				}
			}
		}
	}
	private void updateArtifact(Artifact source, File target, File original) {
		if (this.attach) {
			attachArtifact(source, target, original);
		}
		else if (source.getFile().equals(target) && original.exists()) {
			String artifactId = (this.classifier != null) ? 'artifact with classifier ' + this.classifier
					: 'main artifact';
			getLog().info(String.format('Updating %s %s to %s', artifactId, source.getFile(), original));
			source.setFile(original);
		}
		else if (this.classifier != null) {
			getLog().info('Creating repackaged archive ' + target + ' with classifier ' + this.classifier);
		}
	}
	private void attachArtifact(Artifact source, File target, File original) {
		if (this.classifier != null && !source.getFile().equals(target)) {
			getLog().info('Attaching repackaged archive ' + target + ' with classifier ' + this.classifier);
			this.projectHelper.attachArtifact(this.project, this.project.getPackaging(), this.classifier, target);
		}
		else {
			String artifactId = (this.classifier != null) ? 'artifact with classifier ' + this.classifier
					: 'main artifact';
			getLog()
				.info(String.format('Replacing %s %s with repackaged archive, adding nested dependencies in BOOT-INF/.',
						artifactId, source.getFile()));
			getLog().info('The original artifact has been renamed to ' + original);
			source.setFile(target);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
final class VersionExtractor {
	private VersionExtractor() {
	}
	/**
	 * Return the version information for the provided {@link Class}.
	 * @param cls the Class to retrieve the version for
	 * @return the version, or {@code null} if a version can not be extracted
	 */
	static String forClass(Class<?> cls) {
		String implementationVersion = cls.getPackage().getImplementationVersion();
		if (implementationVersion != null) {
			return implementationVersion;
		}
		URL codeSourceLocation = cls.getProtectionDomain().getCodeSource().getLocation();
		try {
			URLConnection connection = codeSourceLocation.openConnection();
			if (connection instanceof JarURLConnection jarURLConnection) {
				return getImplementationVersion(jarURLConnection.getJarFile());
			}
			try (JarFile jarFile = new JarFile(new File(codeSourceLocation.toURI()))) {
				return getImplementationVersion(jarFile);
			}
		}
		catch (Exception ex) {
			return null;
		}
	}
	private static String getImplementationVersion(JarFile jarFile) throws IOException {
		return jarFile.getManifest().getMainAttributes().getValue(Attributes.Name.IMPLEMENTATION_VERSION);
	}
}
/*
package org.springframework.boot.maven;
/**
public class PropertiesMergingResourceTransformer implements ReproducibleResourceTransformer {
	// Set this in pom configuration with <resource>...</resource>
	private String resource;
	private final Properties data = new Properties();
	private long time;
	/**
	 * Return the data the properties being merged.
	 * @return the data
	 */
	public Properties getData() {
		return this.data;
	}
	@Override
	public boolean canTransformResource(String resource) {
		return this.resource != null && this.resource.equalsIgnoreCase(resource);
	}
	@Override
	@Deprecated(since = '2.4.0', forRemoval = false)
	public void processResource(String resource, InputStream inputStream, List<Relocator> relocators)
			throws IOException {
		processResource(resource, inputStream, relocators, 0);
	}
	@Override
	public void processResource(String resource, InputStream inputStream, List<Relocator> relocators, long time)
			throws IOException {
		Properties properties = new Properties();
		properties.load(inputStream);
		properties.forEach((name, value) -> process((String) name, (String) value));
		if (time > this.time) {
			this.time = time;
		}
	}
	private void process(String name, String value) {
		String existing = this.data.getProperty(name);
		this.data.setProperty(name, (existing != null) ? existing + ',' + value : value);
	}
	@Override
	public boolean hasTransformedResource() {
		return !this.data.isEmpty();
	}
	@Override
	public void modifyOutputStream(JarOutputStream os) throws IOException {
		JarEntry jarEntry = new JarEntry(this.resource);
		jarEntry.setTime(this.time);
		os.putNextEntry(jarEntry);
		this.data.store(os, 'Merged by PropertiesMergingResourceTransformer');
		os.flush();
		this.data.clear();
	}
	public String getResource() {
		return this.resource;
	}
	public void setResource(String resource) {
		this.resource = resource;
	}
}
/*
package org.springframework.boot.maven;
/**
class LoggingMainClassTimeoutWarningListener implements MainClassTimeoutWarningListener {
	private final Supplier<Log> log;
	LoggingMainClassTimeoutWarningListener(Supplier<Log> log) {
		this.log = log;
	}
	@Override
	public void handleTimeoutWarning(long duration, String mainMethod) {
		this.log.get()
			.warn('Searching for the main-class is taking some time, '
					+ 'consider using the mainClass configuration parameter');
	}
}
/*
package org.springframework.boot.maven;
/**
public class IncludeFilter extends DependencyFilter {
	public IncludeFilter(List<Include> includes) {
		super(includes);
	}
	@Override
	protected boolean filter(Artifact artifact) {
		for (FilterableDependency dependency : getFilters()) {
			if (equals(artifact, dependency)) {
				return false;
			}
		}
		return true;
	}
}
/*
package org.springframework.boot.maven;
/**
class RunArguments {
	private static final String[] NO_ARGS = {};
	private final Deque<String> args = new LinkedList<>();
	RunArguments(String arguments) {
		this(parseArgs(arguments));
	}
	RunArguments(String[] args) {
		if (args != null) {
			Arrays.stream(args).filter(Objects::nonNull).forEach(this.args::add);
		}
	}
	Deque<String> getArgs() {
		return this.args;
	}
	String[] asArray() {
		return this.args.toArray(new String[0]);
	}
	private static String[] parseArgs(String arguments) {
		if (arguments == null || arguments.trim().isEmpty()) {
			return NO_ARGS;
		}
		try {
			arguments = arguments.replace("\n", " ").replace("\t", " ");
			return CommandLineUtils.translateCommandline(arguments);
		}
		catch (Exception ex) {
			throw new IllegalArgumentException('Failed to parse arguments [' + arguments + ']', ex);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
public class Exclude extends FilterableDependency {
}
/*
package org.springframework.boot.maven;
/**
public class Image {
	String name;
	String builder;
	Boolean trustBuilder;
	String runImage;
	Map<String, String> env;
	Boolean cleanCache;
	boolean verboseLogging;
	PullPolicy pullPolicy;
	Boolean publish;
	List<String> buildpacks;
	List<String> bindings;
	String network;
	List<String> tags;
	CacheInfo buildWorkspace;
	CacheInfo buildCache;
	CacheInfo launchCache;
	String createdDate;
	String applicationDirectory;
	List<String> securityOptions;
	String imagePlatform;
	/**
	 * The name of the created image.
	 * @return the image name
	 */
	public String getName() {
		return this.name;
	}
	void setName(String name) {
		this.name = name;
	}
	/**
	 * The name of the builder image to use to create the image.
	 * @return the builder image name
	 */
	public String getBuilder() {
		return this.builder;
	}
	void setBuilder(String builder) {
		this.builder = builder;
	}
	/**
	 * If the builder should be treated as trusted.
	 * @return {@code true} if the builder should be treated as trusted
	 */
	public Boolean getTrustBuilder() {
		return this.trustBuilder;
	}
	void setTrustBuilder(Boolean trustBuilder) {
		this.trustBuilder = trustBuilder;
	}
	/**
	 * The name of the run image to use to create the image.
	 * @return the builder image name
	 */
	public String getRunImage() {
		return this.runImage;
	}
	void setRunImage(String runImage) {
		this.runImage = runImage;
	}
	/**
	 * Environment properties that should be passed to the builder.
	 * @return the environment properties
	 */
	public Map<String, String> getEnv() {
		return this.env;
	}
	/**
	 * If the cache should be cleaned before building.
	 * @return {@code true} if the cache should be cleaned
	 */
	public Boolean getCleanCache() {
		return this.cleanCache;
	}
	void setCleanCache(Boolean cleanCache) {
		this.cleanCache = cleanCache;
	}
	/**
	 * If verbose logging is required.
	 * @return {@code true} for verbose logging
	 */
	public boolean isVerboseLogging() {
		return this.verboseLogging;
	}
	/**
	 * If images should be pulled from a remote repository during image build.
	 * @return the pull policy
	 */
	public PullPolicy getPullPolicy() {
		return this.pullPolicy;
	}
	void setPullPolicy(PullPolicy pullPolicy) {
		this.pullPolicy = pullPolicy;
	}
	/**
	 * If the built image should be pushed to a registry.
	 * @return {@code true} if the image should be published
	 */
	public Boolean getPublish() {
		return this.publish;
	}
	void setPublish(Boolean publish) {
		this.publish = publish;
	}
	/**
	 * Returns the network the build container will connect to.
	 * @return the network
	 */
	public String getNetwork() {
		return this.network;
	}
	public void setNetwork(String network) {
		this.network = network;
	}
	/**
	 * Returns the created date for the image.
	 * @return the created date
	 */
	public String getCreatedDate() {
		return this.createdDate;
	}
	public void setCreatedDate(String createdDate) {
		this.createdDate = createdDate;
	}
	/**
	 * Returns the application content directory for the image.
	 * @return the application directory
	 */
	public String getApplicationDirectory() {
		return this.applicationDirectory;
	}
	public void setApplicationDirectory(String applicationDirectory) {
		this.applicationDirectory = applicationDirectory;
	}
	/**
	 * Returns the platform (os/architecture/variant) that will be used for all pulled
	 * images. When {@code null}, the system will choose a platform based on the host
	 * operating system and architecture.
	 * @return the image platform
	 */
	public String getImagePlatform() {
		return this.imagePlatform;
	}
	public void setImagePlatform(String imagePlatform) {
		this.imagePlatform = imagePlatform;
	}
	BuildRequest getBuildRequest(Artifact artifact, Function<Owner, TarArchive> applicationContent) {
		return customize(BuildRequest.of(getOrDeduceName(artifact), applicationContent));
	}
	private ImageReference getOrDeduceName(Artifact artifact) {
		if (StringUtils.hasText(this.name)) {
			return ImageReference.of(this.name);
		}
		ImageName imageName = ImageName.of(artifact.getArtifactId());
		return ImageReference.of(imageName, artifact.getVersion());
	}
	private BuildRequest customize(BuildRequest request) {
		if (StringUtils.hasText(this.builder)) {
			request = request.withBuilder(ImageReference.of(this.builder));
		}
		if (this.trustBuilder != null) {
			request = request.withTrustBuilder(this.trustBuilder);
		}
		if (StringUtils.hasText(this.runImage)) {
			request = request.withRunImage(ImageReference.of(this.runImage));
		}
		if (this.env != null && !this.env.isEmpty()) {
			request = request.withEnv(this.env);
		}
		if (this.cleanCache != null) {
			request = request.withCleanCache(this.cleanCache);
		}
		request = request.withVerboseLogging(this.verboseLogging);
		if (this.pullPolicy != null) {
			request = request.withPullPolicy(this.pullPolicy);
		}
		if (this.publish != null) {
			request = request.withPublish(this.publish);
		}
		if (!CollectionUtils.isEmpty(this.buildpacks)) {
			request = request.withBuildpacks(this.buildpacks.stream().map(BuildpackReference::of).toList());
		}
		if (!CollectionUtils.isEmpty(this.bindings)) {
			request = request.withBindings(this.bindings.stream().map(Binding::of).toList());
		}
		request = request.withNetwork(this.network);
		if (!CollectionUtils.isEmpty(this.tags)) {
			request = request.withTags(this.tags.stream().map(ImageReference::of).toList());
		}
		if (this.buildWorkspace != null) {
			request = request.withBuildWorkspace(this.buildWorkspace.asCache());
		}
		if (this.buildCache != null) {
			request = request.withBuildCache(this.buildCache.asCache());
		}
		if (this.launchCache != null) {
			request = request.withLaunchCache(this.launchCache.asCache());
		}
		if (StringUtils.hasText(this.createdDate)) {
			request = request.withCreatedDate(this.createdDate);
		}
		if (StringUtils.hasText(this.applicationDirectory)) {
			request = request.withApplicationDirectory(this.applicationDirectory);
		}
		if (this.securityOptions != null) {
			request = request.withSecurityOptions(this.securityOptions);
		}
		if (this.imagePlatform != null) {
			request = request.withImagePlatform(this.imagePlatform);
		}
		return request;
	}
}
/*
package org.springframework.boot.maven;
/**
final class CommandLineBuilder {
	private final List<String> options = new ArrayList<>();
	private final List<URL> classpathElements = new ArrayList<>();
	private final String mainClass;
	private final List<String> arguments = new ArrayList<>();
	private CommandLineBuilder(String mainClass) {
		this.mainClass = mainClass;
	}
	static CommandLineBuilder forMainClass(String mainClass) {
		return new CommandLineBuilder(mainClass);
	}
	CommandLineBuilder withJvmArguments(String... jvmArguments) {
		if (jvmArguments != null) {
			this.options.addAll(Arrays.stream(jvmArguments).filter(Objects::nonNull).toList());
		}
		return this;
	}
	CommandLineBuilder withSystemProperties(Map<String, String> systemProperties) {
		if (systemProperties != null) {
			systemProperties.entrySet()
				.stream()
				.map((e) -> SystemPropertyFormatter.format(e.getKey(), e.getValue()))
				.forEach(this.options::add);
		}
		return this;
	}
	CommandLineBuilder withClasspath(URL... elements) {
		this.classpathElements.addAll(Arrays.asList(elements));
		return this;
	}
	CommandLineBuilder withArguments(String... arguments) {
		if (arguments != null) {
			this.arguments.addAll(Arrays.stream(arguments).filter(Objects::nonNull).toList());
		}
		return this;
	}
	List<String> build() {
		List<String> commandLine = new ArrayList<>();
		if (!this.options.isEmpty()) {
			commandLine.addAll(this.options);
		}
		if (!this.classpathElements.isEmpty()) {
			commandLine.add('-cp');
			commandLine.add(ClasspathBuilder.build(this.classpathElements));
		}
		commandLine.add(this.mainClass);
		if (!this.arguments.isEmpty()) {
			commandLine.addAll(this.arguments);
		}
		return commandLine;
	}
	static class ClasspathBuilder {
		static String build(List<URL> classpathElements) {
			StringBuilder classpath = new StringBuilder();
			for (URL element : classpathElements) {
				if (!classpath.isEmpty()) {
					classpath.append(File.pathSeparator);
				}
				classpath.append(toFile(element));
			}
			return classpath.toString();
		}
		private static File toFile(URL element) {
			try {
				return new File(element.toURI());
			}
			catch (URISyntaxException ex) {
				throw new IllegalArgumentException(ex);
			}
		}
	}
	/**
	 * Format System properties.
	 */
	private static final class SystemPropertyFormatter {
		static String format(String key, String value) {
			if (key == null) {
				return '';
			}
			if (value == null || value.isEmpty()) {
				return String.format('-D%s', key);
			}
			return String.format('-D%s=\'%s\'', key, value);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'stop', requiresProject = true, defaultPhase = LifecyclePhase.POST_INTEGRATION_TEST)
public class StopMojo extends AbstractMojo {
	/**
	 * The Maven project.
	 * @since 1.4.1
	 */
	@Parameter(defaultValue = '${project}', readonly = true, required = true)
	private MavenProject project;
	/**
	 * The JMX name of the automatically deployed MBean managing the lifecycle of the
	 * application.
	 */
	@Parameter(defaultValue = SpringApplicationAdminClient.DEFAULT_OBJECT_NAME)
	private String jmxName;
	/**
	 * The port to use to look up the platform MBeanServer.
	 */
	@Parameter(defaultValue = '9001')
	private int jmxPort;
	/**
	 * Skip the execution.
	 * @since 1.3.2
	 */
	@Parameter(property = 'spring-boot.stop.skip', defaultValue = 'false')
	private boolean skip;
	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		if (this.skip) {
			getLog().debug('skipping stop as per configuration.');
			return;
		}
		getLog().info('Stopping application...');
		try (JMXConnector connector = SpringApplicationAdminClient.connect(this.jmxPort)) {
			MBeanServerConnection connection = connector.getMBeanServerConnection();
			stop(connection);
		}
		catch (IOException ex) {
			// The response won"t be received as the server has died - ignoring
			getLog().debug('Service is not reachable anymore (' + ex.getMessage() + ')');
		}
	}
	private void stop(MBeanServerConnection connection) throws IOException, MojoExecutionException {
		try {
			new SpringApplicationAdminClient(connection, this.jmxName).stop();
		}
		catch (InstanceNotFoundException ex) {
			throw new MojoExecutionException(
					'Spring application lifecycle JMX bean not found. Could not stop application gracefully', ex);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'run', requiresProject = true, defaultPhase = LifecyclePhase.VALIDATE,
		requiresDependencyResolution = ResolutionScope.TEST)
@Execute(phase = LifecyclePhase.TEST_COMPILE)
public class RunMojo extends AbstractRunMojo {
	/**
	 * Whether the JVM"s launch should be optimized.
	 * @since 2.2.0
	 */
	@Parameter(property = 'spring-boot.run.optimizedLaunch', defaultValue = 'true')
	private boolean optimizedLaunch;
	/**
	 * Flag to include the test classpath when running.
	 * @since 1.3.0
	 */
	@Parameter(property = 'spring-boot.run.useTestClasspath', defaultValue = 'false')
	private Boolean useTestClasspath;
	@Override
	protected RunArguments resolveJvmArguments() {
		RunArguments jvmArguments = super.resolveJvmArguments();
		if (this.optimizedLaunch) {
			jvmArguments.getArgs().addFirst('-XX:TieredStopAtLevel=1');
		}
		return jvmArguments;
	}
	@Override
	protected void run(JavaProcessExecutor processExecutor, File workingDirectory, List<String> args,
			Map<String, String> environmentVariables) throws MojoExecutionException, MojoFailureException {
		processExecutor
			.withRunProcessCustomizer(
					(runProcess) -> Runtime.getRuntime().addShutdownHook(new Thread(new RunProcessKiller(runProcess))))
			.run(workingDirectory, args, environmentVariables);
	}
	@Override
	protected boolean isUseTestClasspath() {
		return this.useTestClasspath;
	}
	private static final class RunProcessKiller implements Runnable {
		private final RunProcess runProcess;
		private RunProcessKiller(RunProcess runProcess) {
			this.runProcess = runProcess;
		}
		@Override
		public void run() {
			this.runProcess.kill();
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'build-info', defaultPhase = LifecyclePhase.GENERATE_RESOURCES, threadSafe = true)
public class BuildInfoMojo extends AbstractMojo {
	@Component
	private BuildContext buildContext;
	/**
	 * The Maven session.
	 */
	@Parameter(defaultValue = '${session}', readonly = true, required = true)
	private MavenSession session;
	/**
	 * The Maven project.
	 */
	@Parameter(defaultValue = '${project}', readonly = true, required = true)
	private MavenProject project;
	/**
	 * The location of the generated {@code build-info.properties} file.
	 */
	@Parameter(defaultValue = '${project.build.outputDirectory}/META-INF/build-info.properties')
	private File outputFile;
	/**
	 * The value used for the {@code build.time} property in a form suitable for
	 * {@link Instant#parse(CharSequence)}. Defaults to
	 * {@code project.build.outputTimestamp} or {@code session.request.startTime} if the
	 * former is not set. To disable the {@code build.time} property entirely, use
	 * {@code "off"} or add it to {@code excludeInfoProperties}.
	 * @since 2.2.0
	 */
	@Parameter(defaultValue = '${project.build.outputTimestamp}')
	private String time;
	/**
	 * Additional properties to store in the {@code build-info.properties} file. Each
	 * entry is prefixed by {@code build.} in the generated {@code build-info.properties}.
	 */
	@Parameter
	private Map<String, String> additionalProperties;
	/**
	 * Properties that should be excluded {@code build-info.properties} file. Can be used
	 * to exclude the standard {@code group}, {@code artifact}, {@code name},
	 * {@code version} or {@code time} properties as well as items from
	 * {@code additionalProperties}.
	 */
	@Parameter
	private List<String> excludeInfoProperties;
	/**
	 * Skip the execution.
	 * @since 3.1.0
	 */
	@Parameter(property = 'spring-boot.build-info.skip', defaultValue = 'false')
	private boolean skip;
	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		if (this.skip) {
			getLog().debug('skipping build-info as per configuration.');
			return;
		}
		try {
			ProjectDetails details = getProjectDetails();
			new BuildPropertiesWriter(this.outputFile).writeBuildProperties(details);
			this.buildContext.refresh(this.outputFile);
		}
		catch (NullAdditionalPropertyValueException ex) {
			throw new MojoFailureException('Failed to generate build-info.properties. ' + ex.getMessage(), ex);
		}
		catch (Exception ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
	}
	private ProjectDetails getProjectDetails() {
		String group = getIfNotExcluded('group', this.project.getGroupId());
		String artifact = getIfNotExcluded('artifact', this.project.getArtifactId());
		String version = getIfNotExcluded('version', this.project.getVersion());
		String name = getIfNotExcluded('name', this.project.getName());
		Instant time = getIfNotExcluded('time', getBuildTime());
		Map<String, String> additionalProperties = applyExclusions(this.additionalProperties);
		return new ProjectDetails(group, artifact, version, name, time, additionalProperties);
	}
	private <T> T getIfNotExcluded(String name, T value) {
		return (this.excludeInfoProperties == null || !this.excludeInfoProperties.contains(name)) ? value : null;
	}
	private Map<String, String> applyExclusions(Map<String, String> source) {
		if (source == null || this.excludeInfoProperties == null) {
			return source;
		}
		Map<String, String> result = new LinkedHashMap<>(source);
		this.excludeInfoProperties.forEach(result::remove);
		return result;
	}
	private Instant getBuildTime() {
		if (this.time == null || this.time.isEmpty()) {
			Date startTime = this.session.getRequest().getStartTime();
			return (startTime != null) ? startTime.toInstant() : Instant.now();
		}
		if ('off'.equalsIgnoreCase(this.time)) {
			return null;
		}
		return Instant.parse(this.time);
	}
}
/*
package org.springframework.boot.maven;
/**
public abstract class AbstractRunMojo extends AbstractDependencyFilterMojo {
	/**
	 * The Maven project.
	 * @since 1.0.0
	 */
	@Parameter(defaultValue = '${project}', readonly = true, required = true)
	private MavenProject project;
	/**
	 * The current Maven session. This is used for toolchain manager API calls.
	 * @since 2.3.0
	 */
	@Parameter(defaultValue = '${session}', readonly = true)
	private MavenSession session;
	/**
	 * The toolchain manager to use to locate a custom JDK.
	 * @since 2.3.0
	 */
	@Component
	private ToolchainManager toolchainManager;
	/**
	 * Add maven resources to the classpath directly, this allows live in-place editing of
	 * resources. Duplicate resources are removed from {@code target/classes} to prevent
	 * them from appearing twice if {@code ClassLoader.getResources()} is called. Please
	 * consider adding {@code spring-boot-devtools} to your project instead as it provides
	 * this feature and many more.
	 * @since 1.0.0
	 */
	@Parameter(property = 'spring-boot.run.addResources', defaultValue = 'false')
	private boolean addResources = false;
	/**
	 * Path to agent jars.
	 * @since 2.2.0
	 */
	@Parameter(property = 'spring-boot.run.agents')
	private File[] agents;
	/**
	 * Flag to say that the agent requires -noverify.
	 * @since 1.0.0
	 */
	@Parameter(property = 'spring-boot.run.noverify')
	private boolean noverify = false;
	/**
	 * Current working directory to use for the application. If not specified, basedir
	 * will be used.
	 * @since 1.5.0
	 */
	@Parameter(property = 'spring-boot.run.workingDirectory')
	private File workingDirectory;
	/**
	 * JVM arguments that should be associated with the forked process used to run the
	 * application. On command line, make sure to wrap multiple values between quotes.
	 * @since 1.1.0
	 */
	@Parameter(property = 'spring-boot.run.jvmArguments')
	private String jvmArguments;
	/**
	 * List of JVM system properties to pass to the process.
	 * @since 2.1.0
	 */
	@Parameter
	private Map<String, String> systemPropertyVariables;
	/**
	 * List of Environment variables that should be associated with the forked process
	 * used to run the application.
	 * @since 2.1.0
	 */
	@Parameter
	private Map<String, String> environmentVariables;
	/**
	 * Arguments that should be passed to the application.
	 * @since 1.0.0
	 */
	@Parameter
	private String[] arguments;
	/**
	 * Arguments from the command line that should be passed to the application. Use
	 * spaces to separate multiple arguments and make sure to wrap multiple values between
	 * quotes. When specified, takes precedence over {@link #arguments}.
	 * @since 2.2.3
	 */
	@Parameter(property = 'spring-boot.run.arguments')
	private String commandlineArguments;
	/**
	 * The spring profiles to activate. Convenience shortcut of specifying the
	 * "spring.profiles.active" argument. On command line use commas to separate multiple
	 * profiles.
	 * @since 1.3.0
	 */
	@Parameter(property = 'spring-boot.run.profiles')
	private String[] profiles;
	/**
	 * The name of the main class. If not specified the first compiled class found that
	 * contains a "main" method will be used.
	 * @since 1.0.0
	 */
	@Parameter(property = 'spring-boot.run.main-class')
	private String mainClass;
	/**
	 * Additional classpath elements that should be added to the classpath. An element can
	 * be a directory with classes and resources or a jar file.
	 * @since 3.2.0
	 */
	@Parameter(property = 'spring-boot.run.additional-classpath-elements')
	private String[] additionalClasspathElements;
	/**
	 * Directory containing the classes and resource files that should be used to run the
	 * application.
	 * @since 1.0.0
	 */
	@Parameter(defaultValue = '${project.build.outputDirectory}', required = true)
	private File classesDirectory;
	/**
	 * Skip the execution.
	 * @since 1.3.2
	 */
	@Parameter(property = 'spring-boot.run.skip', defaultValue = 'false')
	private boolean skip;
	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		if (this.skip) {
			getLog().debug('skipping run as per configuration.');
			return;
		}
		run(determineMainClass());
	}
	private String determineMainClass() throws MojoExecutionException {
		if (this.mainClass != null) {
			return this.mainClass;
		}
		return SpringBootApplicationClassFinder.findSingleClass(getClassesDirectories());
	}
	/**
	 * Returns the directories that contain the application"s classes and resources. When
	 * the application"s main class has not been configured, each directory is searched in
	 * turn for an appropriate main class.
	 * @return the directories that contain the application"s classes and resources
	 * @since 3.1.0
	 */
	protected List<File> getClassesDirectories() {
		return List.of(this.classesDirectory);
	}
	protected abstract boolean isUseTestClasspath();
	private void run(String startClassName) throws MojoExecutionException, MojoFailureException {
		List<String> args = new ArrayList<>();
		addAgents(args);
		addJvmArgs(args);
		addClasspath(args);
		args.add(startClassName);
		addArgs(args);
		JavaProcessExecutor processExecutor = new JavaProcessExecutor(this.session, this.toolchainManager);
		File workingDirectoryToUse = (this.workingDirectory != null) ? this.workingDirectory
				: this.project.getBasedir();
		if (getLog().isDebugEnabled()) {
			getLog().debug('Working directory: ' + workingDirectoryToUse);
			getLog().debug('Java arguments: ' + String.join(' ', args));
		}
		run(processExecutor, workingDirectoryToUse, args, determineEnvironmentVariables());
	}
	/**
	 * Run the application.
	 * @param processExecutor the {@link JavaProcessExecutor} to use
	 * @param workingDirectory the working directory of the forked JVM
	 * @param args the arguments (JVM arguments and application arguments)
	 * @param environmentVariables the environment variables
	 * @throws MojoExecutionException in case of MOJO execution errors
	 * @throws MojoFailureException in case of MOJO failures
	 * @since 3.0.0
	 */
	protected abstract void run(JavaProcessExecutor processExecutor, File workingDirectory, List<String> args,
			Map<String, String> environmentVariables) throws MojoExecutionException, MojoFailureException;
	/**
	 * Resolve the application arguments to use.
	 * @return a {@link RunArguments} defining the application arguments
	 */
	protected RunArguments resolveApplicationArguments() {
		RunArguments runArguments = (this.arguments != null) ? new RunArguments(this.arguments)
				: new RunArguments(this.commandlineArguments);
		addActiveProfileArgument(runArguments);
		return runArguments;
	}
	/**
	 * Resolve the environment variables to use.
	 * @return an {@link EnvVariables} defining the environment variables
	 */
	protected EnvVariables resolveEnvVariables() {
		return new EnvVariables(this.environmentVariables);
	}
	private void addArgs(List<String> args) {
		RunArguments applicationArguments = resolveApplicationArguments();
		Collections.addAll(args, applicationArguments.asArray());
		logArguments('Application argument', applicationArguments.asArray());
	}
	private Map<String, String> determineEnvironmentVariables() {
		EnvVariables envVariables = resolveEnvVariables();
		logArguments('Environment variable', envVariables.asArray());
		return envVariables.asMap();
	}
	/**
	 * Resolve the JVM arguments to use.
	 * @return a {@link RunArguments} defining the JVM arguments
	 */
	protected RunArguments resolveJvmArguments() {
		StringBuilder stringBuilder = new StringBuilder();
		if (this.systemPropertyVariables != null) {
			stringBuilder.append(this.systemPropertyVariables.entrySet()
				.stream()
				.map((e) -> SystemPropertyFormatter.format(e.getKey(), e.getValue()))
				.collect(Collectors.joining(' ')));
		}
		if (this.jvmArguments != null) {
			stringBuilder.append(' ').append(this.jvmArguments);
		}
		return new RunArguments(stringBuilder.toString());
	}
	private void addJvmArgs(List<String> args) {
		RunArguments jvmArguments = resolveJvmArguments();
		Collections.addAll(args, jvmArguments.asArray());
		logArguments('JVM argument', jvmArguments.asArray());
	}
	private void addAgents(List<String> args) {
		if (this.agents != null) {
			if (getLog().isInfoEnabled()) {
				getLog().info('Attaching agents: ' + Arrays.asList(this.agents));
			}
			for (File agent : this.agents) {
				args.add('-javaagent:' + agent);
			}
		}
		if (this.noverify) {
			args.add('-noverify');
		}
	}
	private void addActiveProfileArgument(RunArguments arguments) {
		if (this.profiles.length > 0) {
			StringBuilder arg = new StringBuilder('--spring.profiles.active=');
			for (int i = 0; i < this.profiles.length; i++) {
				arg.append(this.profiles[i]);
				if (i < this.profiles.length - 1) {
					arg.append(',');
				}
			}
			arguments.getArgs().addFirst(arg.toString());
			logArguments('Active profile', this.profiles);
		}
	}
	private void addClasspath(List<String> args) throws MojoExecutionException {
		try {
			StringBuilder classpath = new StringBuilder();
			for (URL ele : getClassPathUrls()) {
				if (!classpath.isEmpty()) {
					classpath.append(File.pathSeparator);
				}
				classpath.append(new File(ele.toURI()));
			}
			if (getLog().isDebugEnabled()) {
				getLog().debug('Classpath for forked process: ' + classpath);
			}
			args.add('-cp');
			if (needsClasspathArgFile()) {
				args.add('@' + ArgFile.create(classpath).path());
			}
			else {
				args.add(classpath.toString());
			}
		}
		catch (Exception ex) {
			throw new MojoExecutionException('Could not build classpath', ex);
		}
	}
	private boolean needsClasspathArgFile() {
		// Windows limits the maximum command length, so we use an argfile there
		return runsOnWindows();
	}
	private boolean runsOnWindows() {
		String os = System.getProperty('os.name');
		if (!StringUtils.hasLength(os)) {
			if (getLog().isWarnEnabled()) {
				getLog().warn('System property os.name is not set');
			}
			return false;
		}
		return os.toLowerCase(Locale.ROOT).contains('win');
	}
	protected URL[] getClassPathUrls() throws MojoExecutionException {
		try {
			List<URL> urls = new ArrayList<>();
			addAdditionalClasspathLocations(urls);
			addResources(urls);
			addProjectClasses(urls);
			addDependencies(urls);
			return urls.toArray(new URL[0]);
		}
		catch (IOException ex) {
			throw new MojoExecutionException('Unable to build classpath', ex);
		}
	}
	private void addAdditionalClasspathLocations(List<URL> urls) throws MalformedURLException {
		if (this.additionalClasspathElements != null) {
			for (String element : this.additionalClasspathElements) {
				urls.add(new File(element).toURI().toURL());
			}
		}
	}
	private void addResources(List<URL> urls) throws IOException {
		if (this.addResources) {
			for (Resource resource : this.project.getResources()) {
				File directory = new File(resource.getDirectory());
				urls.add(directory.toURI().toURL());
				for (File classesDirectory : getClassesDirectories()) {
					FileUtils.removeDuplicatesFromOutputDirectory(classesDirectory, directory);
				}
			}
		}
	}
	private void addProjectClasses(List<URL> urls) throws MalformedURLException {
		for (File classesDirectory : getClassesDirectories()) {
			urls.add(classesDirectory.toURI().toURL());
		}
	}
	private void addDependencies(List<URL> urls) throws MalformedURLException, MojoExecutionException {
		Set<Artifact> artifacts = (isUseTestClasspath()) ? filterDependencies(this.project.getArtifacts())
				: filterDependencies(this.project.getArtifacts(), new ExcludeTestScopeArtifactFilter());
		for (Artifact artifact : artifacts) {
			if (artifact.getFile() != null) {
				urls.add(artifact.getFile().toURI().toURL());
			}
		}
	}
	private void logArguments(String name, String[] args) {
		if (getLog().isDebugEnabled()) {
			String message = (args.length == 1) ? name + ': ' : name + 's: ';
			getLog().debug(Arrays.stream(args).collect(Collectors.joining(' ', message, '')));
		}
	}
	/**
	 * Format System properties.
	 */
	static class SystemPropertyFormatter {
		static String format(String key, String value) {
			if (key == null) {
				return '';
			}
			if (value == null || value.isEmpty()) {
				return String.format('-D%s', key);
			}
			return String.format('-D%s=\'%s\'', key, value);
		}
	}
	record ArgFile(Path path) {
		private void write(CharSequence content) throws IOException {
			Files.writeString(this.path, '\'' + escape(content) + '\'');
		}
		private String escape(CharSequence content) {
			return content.toString().replace('\\', '\\\\');
		}
		static ArgFile create(CharSequence content) throws IOException {
			Path tempFile = Files.createTempFile('spring-boot-', '.argfile');
			tempFile.toFile().deleteOnExit();
			ArgFile argFile = new ArgFile(tempFile);
			argFile.write(content);
			return argFile;
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'process-test-aot', defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES, threadSafe = true,
		requiresDependencyResolution = ResolutionScope.TEST, requiresDependencyCollection = ResolutionScope.TEST)
public class ProcessTestAotMojo extends AbstractAotMojo {
	private static final String JUNIT_PLATFORM_GROUP_ID = 'org.junit.platform';
	private static final String JUNIT_PLATFORM_COMMONS_ARTIFACT_ID = 'junit-platform-commons';
	private static final String JUNIT_PLATFORM_LAUNCHER_ARTIFACT_ID = 'junit-platform-launcher';
	private static final String AOT_PROCESSOR_CLASS_NAME = 'org.springframework.boot.test.context.SpringBootTestAotProcessor';
	/**
	 * Directory containing the classes and resource files that should be packaged into
	 * the archive.
	 */
	@Parameter(defaultValue = '${project.build.testOutputDirectory}', required = true)
	private File testClassesDirectory;
	/**
	 * Directory containing the classes and resource files that should be used to run the
	 * tests.
	 */
	@Parameter(defaultValue = '${project.build.outputDirectory}', required = true)
	private File classesDirectory;
	/**
	 * Directory containing the generated sources.
	 */
	@Parameter(defaultValue = '${project.build.directory}/spring-aot/test/sources', required = true)
	private File generatedSources;
	/**
	 * Directory containing the generated test resources.
	 */
	@Parameter(defaultValue = '${project.build.directory}/spring-aot/test/resources', required = true)
	private File generatedResources;
	/**
	 * Directory containing the generated test classes.
	 */
	@Parameter(defaultValue = '${project.build.directory}/spring-aot/test/classes', required = true)
	private File generatedTestClasses;
	/**
	 * Directory containing the generated test classes.
	 */
	@Parameter(defaultValue = '${project.build.directory}/spring-aot/main/classes', required = true)
	private File generatedClasses;
	@Component
	private RepositorySystem repositorySystem;
	@Component
	private ResolutionErrorHandler resolutionErrorHandler;
	@Override
	protected void executeAot() throws Exception {
		if (this.project.getPackaging().equals('pom')) {
			getLog().debug('process-test-aot goal could not be applied to pom project.');
			return;
		}
		if (Boolean.getBoolean('skipTests') || Boolean.getBoolean('maven.test.skip')) {
			getLog().info('Skipping AOT test processing since tests are skipped');
			return;
		}
		Path testOutputDirectory = Paths.get(this.project.getBuild().getTestOutputDirectory());
		if (Files.notExists(testOutputDirectory)) {
			getLog().info('Skipping AOT test processing since no tests have been detected');
			return;
		}
		generateAotAssets(getClassPath(true), AOT_PROCESSOR_CLASS_NAME, getAotArguments());
		compileSourceFiles(getClassPath(false), this.generatedSources, this.generatedTestClasses);
		copyAll(this.generatedResources.toPath().resolve('META-INF/native-image'),
				this.testClassesDirectory.toPath().resolve('META-INF/native-image'));
		copyAll(this.generatedTestClasses.toPath(), this.testClassesDirectory.toPath());
	}
	private String[] getAotArguments() {
		List<String> aotArguments = new ArrayList<>();
		aotArguments.add(this.testClassesDirectory.toPath().toAbsolutePath().normalize().toString());
		aotArguments.add(this.generatedSources.toString());
		aotArguments.add(this.generatedResources.toString());
		aotArguments.add(this.generatedTestClasses.toString());
		aotArguments.add(this.project.getGroupId());
		aotArguments.add(this.project.getArtifactId());
		return aotArguments.toArray(String[]::new);
	}
	protected URL[] getClassPath(boolean includeJUnitPlatformLauncher) throws Exception {
		File[] directories = new File[] { this.testClassesDirectory, this.generatedTestClasses, this.classesDirectory,
				this.generatedClasses };
		URL[] classPath = getClassPath(directories);
		if (!includeJUnitPlatformLauncher || this.project.getArtifactMap()
			.containsKey(JUNIT_PLATFORM_GROUP_ID + ':' + JUNIT_PLATFORM_LAUNCHER_ARTIFACT_ID)) {
			return classPath;
		}
		return addJUnitPlatformLauncher(classPath);
	}
	private URL[] addJUnitPlatformLauncher(URL[] classPath) throws Exception {
		String version = getJUnitPlatformVersion();
		DefaultArtifactHandler handler = new DefaultArtifactHandler('jar');
		handler.setIncludesDependencies(true);
		Set<Artifact> artifacts = resolveArtifact(new DefaultArtifact(JUNIT_PLATFORM_GROUP_ID,
				JUNIT_PLATFORM_LAUNCHER_ARTIFACT_ID, version, null, 'jar', null, handler));
		Set<URL> fullClassPath = new LinkedHashSet<>(Arrays.asList(classPath));
		for (Artifact artifact : artifacts) {
			fullClassPath.add(artifact.getFile().toURI().toURL());
		}
		return fullClassPath.toArray(URL[]::new);
	}
	private String getJUnitPlatformVersion() throws MojoExecutionException {
		String id = JUNIT_PLATFORM_GROUP_ID + ':' + JUNIT_PLATFORM_COMMONS_ARTIFACT_ID;
		Artifact platformCommonsArtifact = this.project.getArtifactMap().get(id);
		String version = (platformCommonsArtifact != null) ? platformCommonsArtifact.getBaseVersion() : null;
		if (version == null) {
			throw new MojoExecutionException(
					'Unable to find "%s" dependency. Please ensure JUnit is correctly configured.'.formatted(id));
		}
		return version;
	}
	private Set<Artifact> resolveArtifact(Artifact artifact) throws Exception {
		CollectRequest collectRequest = new CollectRequest();
		collectRequest.setRoot(RepositoryUtils.toDependency(artifact, null));
		collectRequest.setRepositories(this.project.getRemotePluginRepositories());
		DependencyRequest request = new DependencyRequest();
		request.setCollectRequest(collectRequest);
		request.setFilter(DependencyFilterUtils.classpathFilter(JavaScopes.RUNTIME));
		DependencyResult dependencyResult = this.repositorySystem
			.resolveDependencies(getSession().getRepositorySession(), request);
		return dependencyResult.getArtifactResults()
			.stream()
			.map(ArtifactResult::getArtifact)
			.map(RepositoryUtils::toArtifact)
			.collect(Collectors.toSet());
	}
}
/*
package org.springframework.boot.maven;
/**
public abstract class BuildImageMojo extends AbstractPackagerMojo {
	static {
		System.setProperty('org.slf4j.simpleLogger.log.org.apache.http.wire', 'ERROR');
	}
	/**
	 * Directory containing the source archive.
	 * @since 2.3.0
	 */
	@Parameter(defaultValue = '${project.build.directory}', required = true)
	private File sourceDirectory;
	/**
	 * Name of the source archive.
	 * @since 2.3.0
	 */
	@Parameter(defaultValue = '${project.build.finalName}', readonly = true)
	private String finalName;
	/**
	 * Skip the execution.
	 * @since 2.3.0
	 */
	@Parameter(property = 'spring-boot.build-image.skip', defaultValue = 'false')
	private boolean skip;
	/**
	 * Classifier used when finding the source archive.
	 * @since 2.3.0
	 */
	@Parameter
	private String classifier;
	/**
	 * Image configuration, with {@code builder}, {@code runImage}, {@code name},
	 * {@code env}, {@code cleanCache}, {@code verboseLogging}, {@code pullPolicy}, and
	 * {@code publish} options.
	 * @since 2.3.0
	 */
	@Parameter
	private Image image;
	/**
	 * Alias for {@link Image#name} to support configuration through command-line
	 * property.
	 * @since 2.3.0
	 */
	@Parameter(property = 'spring-boot.build-image.imageName', readonly = true)
	String imageName;
	/**
	 * Alias for {@link Image#builder} to support configuration through command-line
	 * property.
	 * @since 2.3.0
	 */
	@Parameter(property = 'spring-boot.build-image.builder', readonly = true)
	String imageBuilder;
	/**
	 * Alias for {@link Image#trustBuilder} to support configuration through command-line
	 * property.
	 */
	@Parameter(property = 'spring-boot.build-image.trustBuilder', readonly = true)
	Boolean trustBuilder;
	/**
	 * Alias for {@link Image#runImage} to support configuration through command-line
	 * property.
	 * @since 2.3.1
	 */
	@Parameter(property = 'spring-boot.build-image.runImage', readonly = true)
	String runImage;
	/**
	 * Alias for {@link Image#cleanCache} to support configuration through command-line
	 * property.
	 * @since 2.4.0
	 */
	@Parameter(property = 'spring-boot.build-image.cleanCache', readonly = true)
	Boolean cleanCache;
	/**
	 * Alias for {@link Image#pullPolicy} to support configuration through command-line
	 * property.
	 */
	@Parameter(property = 'spring-boot.build-image.pullPolicy', readonly = true)
	PullPolicy pullPolicy;
	/**
	 * Alias for {@link Image#publish} to support configuration through command-line
	 * property.
	 */
	@Parameter(property = 'spring-boot.build-image.publish', readonly = true)
	Boolean publish;
	/**
	 * Alias for {@link Image#network} to support configuration through command-line
	 * property.
	 * @since 2.6.0
	 */
	@Parameter(property = 'spring-boot.build-image.network', readonly = true)
	String network;
	/**
	 * Alias for {@link Image#createdDate} to support configuration through command-line
	 * property.
	 * @since 3.1.0
	 */
	@Parameter(property = 'spring-boot.build-image.createdDate', readonly = true)
	String createdDate;
	/**
	 * Alias for {@link Image#applicationDirectory} to support configuration through
	 * command-line property.
	 * @since 3.1.0
	 */
	@Parameter(property = 'spring-boot.build-image.applicationDirectory', readonly = true)
	String applicationDirectory;
	/**
	 * Alias for {@link Image#imagePlatform} to support configuration through command-line
	 * property.
	 * @since 3.4.0
	 */
	@Parameter(property = 'spring-boot.build-image.imagePlatform', readonly = true)
	String imagePlatform;
	/**
	 * Docker configuration options.
	 * @since 2.4.0
	 */
	@Parameter
	private Docker docker;
	/**
	 * The type of archive (which corresponds to how the dependencies are laid out inside
	 * it). Possible values are {@code JAR}, {@code WAR}, {@code ZIP}, {@code DIR},
	 * {@code NONE}. Defaults to a guess based on the archive type.
	 * @since 2.3.11
	 */
	@Parameter
	private LayoutType layout;
	/**
	 * The loader implementation that should be used.
	 * @since 3.2.0
	 */
	@Parameter
	private LoaderImplementation loaderImplementation;
	/**
	 * The layout factory that will be used to create the executable archive if no
	 * explicit layout is set. Alternative layouts implementations can be provided by 3rd
	 * parties.
	 * @since 2.3.11
	 */
	@Parameter
	private LayoutFactory layoutFactory;
	/**
	 * Return the type of archive that should be used when building the image.
	 * @return the value of the {@code layout} parameter, or {@code null} if the parameter
	 * is not provided
	 */
	@Override
	protected LayoutType getLayout() {
		return this.layout;
	}
	@Override
	protected LoaderImplementation getLoaderImplementation() {
		return this.loaderImplementation;
	}
	/**
	 * Return the layout factory that will be used to determine the
	 * {@link AbstractPackagerMojo.LayoutType} if no explicit layout is set.
	 * @return the value of the {@code layoutFactory} parameter, or {@code null} if the
	 * parameter is not provided
	 */
	@Override
	protected LayoutFactory getLayoutFactory() {
		return this.layoutFactory;
	}
	@Override
	public void execute() throws MojoExecutionException {
		if (this.project.getPackaging().equals('pom')) {
			getLog().debug('build-image goal could not be applied to pom project.');
			return;
		}
		if (this.skip) {
			getLog().debug('skipping build-image as per configuration.');
			return;
		}
		buildImage();
	}
	private void buildImage() throws MojoExecutionException {
		Libraries libraries = getLibraries(Collections.emptySet());
		try {
			BuildRequest request = getBuildRequest(libraries);
			DockerConfiguration dockerConfiguration = (this.docker != null)
					? this.docker.asDockerConfiguration(request.isPublish())
					: new Docker().asDockerConfiguration(request.isPublish());
			Builder builder = new Builder(new MojoBuildLog(this::getLog), dockerConfiguration);
			builder.build(request);
		}
		catch (IOException ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
	}
	private BuildRequest getBuildRequest(Libraries libraries) {
		ImagePackager imagePackager = new ImagePackager(getArchiveFile(), getBackupFile());
		Function<Owner, TarArchive> content = (owner) -> getApplicationContent(owner, libraries, imagePackager);
		Image image = (this.image != null) ? this.image : new Image();
		if (image.name == null && this.imageName != null) {
			image.setName(this.imageName);
		}
		if (image.builder == null && this.imageBuilder != null) {
			image.setBuilder(this.imageBuilder);
		}
		if (image.trustBuilder == null && this.trustBuilder != null) {
			image.setTrustBuilder(this.trustBuilder);
		}
		if (image.runImage == null && this.runImage != null) {
			image.setRunImage(this.runImage);
		}
		if (image.cleanCache == null && this.cleanCache != null) {
			image.setCleanCache(this.cleanCache);
		}
		if (image.pullPolicy == null && this.pullPolicy != null) {
			image.setPullPolicy(this.pullPolicy);
		}
		if (image.publish == null && this.publish != null) {
			image.setPublish(this.publish);
		}
		if (image.network == null && this.network != null) {
			image.setNetwork(this.network);
		}
		if (image.createdDate == null && this.createdDate != null) {
			image.setCreatedDate(this.createdDate);
		}
		if (image.applicationDirectory == null && this.applicationDirectory != null) {
			image.setApplicationDirectory(this.applicationDirectory);
		}
		if (image.imagePlatform == null && this.imagePlatform != null) {
			image.setImagePlatform(this.imagePlatform);
		}
		return customize(image.getBuildRequest(this.project.getArtifact(), content));
	}
	private TarArchive getApplicationContent(Owner owner, Libraries libraries, ImagePackager imagePackager) {
		ImagePackager packager = getConfiguredPackager(() -> imagePackager);
		return new PackagedTarArchive(owner, libraries, packager);
	}
	private File getArchiveFile() {
		// We can"t use "project.getArtifact().getFile()" because package can be done in a
		// forked lifecycle and will be null
		File archiveFile = getTargetFile(this.finalName, this.classifier, this.sourceDirectory);
		if (!archiveFile.exists()) {
			archiveFile = getSourceArtifact(this.classifier).getFile();
		}
		if (!archiveFile.exists()) {
			throw new IllegalStateException('A jar or war file is required for building image');
		}
		return archiveFile;
	}
	/**
	 * Return the {@link File} to use to back up the original source.
	 * @return the file to use to back up the original source
	 */
	private File getBackupFile() {
		// We can"t use "project.getAttachedArtifacts()" because package can be done in a
		// forked lifecycle and will be null
		if (this.classifier != null) {
			File backupFile = getTargetFile(this.finalName, null, this.sourceDirectory);
			if (backupFile.exists()) {
				return backupFile;
			}
			Artifact source = getSourceArtifact(null);
			if (!this.classifier.equals(source.getClassifier())) {
				return source.getFile();
			}
		}
		return null;
	}
	private BuildRequest customize(BuildRequest request) {
		request = customizeCreator(request);
		return request;
	}
	private BuildRequest customizeCreator(BuildRequest request) {
		String springBootVersion = VersionExtractor.forClass(BuildImageMojo.class);
		if (StringUtils.hasText(springBootVersion)) {
			request = request.withCreator(Creator.withVersion(springBootVersion));
		}
		return request;
	}
	/**
	 * {@link BuildLog} backed by Mojo logging.
	 */
	private static class MojoBuildLog extends AbstractBuildLog {
		private static final long THRESHOLD = Duration.ofSeconds(2).toMillis();
		private final Supplier<Log> log;
		MojoBuildLog(Supplier<Log> log) {
			this.log = log;
		}
		@Override
		protected void log(String message) {
			this.log.get().info(message);
		}
		@Override
		protected Consumer<TotalProgressEvent> getProgressConsumer(String message) {
			return new ProgressLog(message);
		}
		private class ProgressLog implements Consumer<TotalProgressEvent> {
			private final String message;
			private long last;
			ProgressLog(String message) {
				this.message = message;
				this.last = System.currentTimeMillis();
			}
			@Override
			public void accept(TotalProgressEvent progress) {
				log(progress.getPercent());
			}
			private void log(int percent) {
				if (percent == 100 || (System.currentTimeMillis() - this.last) > THRESHOLD) {
					MojoBuildLog.this.log.get().info(this.message + ' ' + percent + '%');
					this.last = System.currentTimeMillis();
				}
			}
		}
	}
	/**
	 * Adapter class to expose the packaged jar as a {@link TarArchive}.
	 */
	static class PackagedTarArchive implements TarArchive {
		static final long NORMALIZED_MOD_TIME = TarArchive.NORMALIZED_TIME.toEpochMilli();
		private final Owner owner;
		private final Libraries libraries;
		private final ImagePackager packager;
		PackagedTarArchive(Owner owner, Libraries libraries, ImagePackager packager) {
			this.owner = owner;
			this.libraries = libraries;
			this.packager = packager;
		}
		@Override
		public void writeTo(OutputStream outputStream) throws IOException {
			TarArchiveOutputStream tar = new TarArchiveOutputStream(outputStream);
			tar.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);
			try {
				this.packager.packageImage(this.libraries, (entry, entryWriter) -> write(entry, entryWriter, tar));
			}
			catch (RuntimeException ex) {
				outputStream.close();
				throw new RuntimeException('Error packaging archive for image', ex);
			}
		}
		private void write(ZipEntry jarEntry, EntryWriter entryWriter, TarArchiveOutputStream tar) {
			try {
				TarArchiveEntry tarEntry = convert(jarEntry);
				tar.putArchiveEntry(tarEntry);
				if (tarEntry.isFile()) {
					entryWriter.write(tar);
				}
				tar.closeArchiveEntry();
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
		private TarArchiveEntry convert(ZipEntry entry) {
			byte linkFlag = (entry.isDirectory()) ? TarConstants.LF_DIR : TarConstants.LF_NORMAL;
			TarArchiveEntry tarEntry = new TarArchiveEntry(entry.getName(), linkFlag, true);
			tarEntry.setUserId(this.owner.getUid());
			tarEntry.setGroupId(this.owner.getGid());
			tarEntry.setModTime(NORMALIZED_MOD_TIME);
			if (!entry.isDirectory()) {
				tarEntry.setSize(entry.getSize());
			}
			return tarEntry;
		}
	}
}
/*
package org.springframework.boot.maven;
/**
class JavaProcessExecutor {
	private static final int EXIT_CODE_SIGINT = 130;
	private final MavenSession mavenSession;
	private final ToolchainManager toolchainManager;
	private final Consumer<RunProcess> runProcessCustomizer;
	JavaProcessExecutor(MavenSession mavenSession, ToolchainManager toolchainManager) {
		this(mavenSession, toolchainManager, null);
	}
	private JavaProcessExecutor(MavenSession mavenSession, ToolchainManager toolchainManager,
			Consumer<RunProcess> runProcessCustomizer) {
		this.mavenSession = mavenSession;
		this.toolchainManager = toolchainManager;
		this.runProcessCustomizer = runProcessCustomizer;
	}
	JavaProcessExecutor withRunProcessCustomizer(Consumer<RunProcess> customizer) {
		Consumer<RunProcess> combinedCustomizer = (this.runProcessCustomizer != null)
				? this.runProcessCustomizer.andThen(customizer) : customizer;
		return new JavaProcessExecutor(this.mavenSession, this.toolchainManager, combinedCustomizer);
	}
	int run(File workingDirectory, List<String> args, Map<String, String> environmentVariables)
			throws MojoExecutionException {
		RunProcess runProcess = new RunProcess(workingDirectory, getJavaExecutable());
		if (this.runProcessCustomizer != null) {
			this.runProcessCustomizer.accept(runProcess);
		}
		try {
			int exitCode = runProcess.run(true, args, environmentVariables);
			if (!hasTerminatedSuccessfully(exitCode)) {
				throw new MojoExecutionException('Process terminated with exit code: ' + exitCode);
			}
			return exitCode;
		}
		catch (IOException ex) {
			throw new MojoExecutionException('Process execution failed', ex);
		}
	}
	RunProcess runAsync(File workingDirectory, List<String> args, Map<String, String> environmentVariables)
			throws MojoExecutionException {
		try {
			RunProcess runProcess = new RunProcess(workingDirectory, getJavaExecutable());
			runProcess.run(false, args, environmentVariables);
			return runProcess;
		}
		catch (IOException ex) {
			throw new MojoExecutionException('Process execution failed', ex);
		}
	}
	private boolean hasTerminatedSuccessfully(int exitCode) {
		return (exitCode == 0 || exitCode == EXIT_CODE_SIGINT);
	}
	private String getJavaExecutable() {
		Toolchain toolchain = this.toolchainManager.getToolchainFromBuildContext('jdk', this.mavenSession);
		String javaExecutable = (toolchain != null) ? toolchain.findTool('java') : null;
		return (javaExecutable != null) ? javaExecutable : new JavaExecutable().toString();
	}
}
/*
package org.springframework.boot.maven;
/**
public abstract class DependencyFilter extends AbstractArtifactsFilter {
	private final List<? extends FilterableDependency> filters;
	/**
	 * Create a new instance with the list of {@link FilterableDependency} instance(s) to
	 * use.
	 * @param dependencies the source dependencies
	 */
	public DependencyFilter(List<? extends FilterableDependency> dependencies) {
		this.filters = dependencies;
	}
	@Override
	public Set<Artifact> filter(Set<Artifact> artifacts) throws ArtifactFilterException {
		Set<Artifact> result = new HashSet<>();
		for (Artifact artifact : artifacts) {
			if (!filter(artifact)) {
				result.add(artifact);
			}
		}
		return result;
	}
	protected abstract boolean filter(Artifact artifact);
	/**
	 * Check if the specified {@link org.apache.maven.artifact.Artifact} matches the
	 * specified {@link org.springframework.boot.maven.FilterableDependency}. Returns
	 * {@code true} if it should be excluded
	 * @param artifact the Maven {@link Artifact}
	 * @param dependency the {@link FilterableDependency}
	 * @return {@code true} if the artifact matches the dependency
	 */
	protected final boolean equals(Artifact artifact, FilterableDependency dependency) {
		if (!dependency.getGroupId().equals(artifact.getGroupId())) {
			return false;
		}
		if (!dependency.getArtifactId().equals(artifact.getArtifactId())) {
			return false;
		}
		return (dependency.getClassifier() == null
				|| artifact.getClassifier() != null && dependency.getClassifier().equals(artifact.getClassifier()));
	}
	protected final List<? extends FilterableDependency> getFilters() {
		return this.filters;
	}
}
/*
package org.springframework.boot.maven;
/**
class EnvVariables {
	private final Map<String, String> variables;
	EnvVariables(Map<String, String> variables) {
		this.variables = parseEnvVariables(variables);
	}
	private static Map<String, String> parseEnvVariables(Map<String, String> args) {
		if (args == null || args.isEmpty()) {
			return Collections.emptyMap();
		}
		Map<String, String> result = new LinkedHashMap<>();
		for (Map.Entry<String, String> e : args.entrySet()) {
			if (e.getKey() != null) {
				result.put(e.getKey(), getValue(e.getValue()));
			}
		}
		return result;
	}
	private static String getValue(String value) {
		return (value != null) ? value : '';
	}
	Map<String, String> asMap() {
		return Collections.unmodifiableMap(this.variables);
	}
	String[] asArray() {
		List<String> args = new ArrayList<>(this.variables.size());
		for (Map.Entry<String, String> arg : this.variables.entrySet()) {
			args.add(arg.getKey() + '=' + arg.getValue());
		}
		return args.toArray(new String[0]);
	}
}
/*
package org.springframework.boot.maven;
/**
public abstract class AbstractDependencyFilterMojo extends AbstractMojo {
	static final ExcludeFilter DEVTOOLS_EXCLUDE_FILTER;
	static {
		Exclude exclude = new Exclude();
		exclude.setGroupId('org.springframework.boot');
		exclude.setArtifactId('spring-boot-devtools');
		DEVTOOLS_EXCLUDE_FILTER = new ExcludeFilter(exclude);
	}
	static final ExcludeFilter DOCKER_COMPOSE_EXCLUDE_FILTER;
	static {
		Exclude exclude = new Exclude();
		exclude.setGroupId('org.springframework.boot');
		exclude.setArtifactId('spring-boot-docker-compose');
		DOCKER_COMPOSE_EXCLUDE_FILTER = new ExcludeFilter(exclude);
	}
	/**
	 * The Maven project.
	 * @since 3.0.0
	 */
	@Parameter(defaultValue = '${project}', readonly = true, required = true)
	protected MavenProject project;
	/**
	 * Collection of artifact definitions to include. The {@link Include} element defines
	 * mandatory {@code groupId} and {@code artifactId} components and an optional
	 * {@code classifier} component. When configured as a property, values should be
	 * comma-separated with colon-separated components:
	 * {@code groupId:artifactId,groupId:artifactId:classifier}
	 * @since 1.2.0
	 */
	@Parameter(property = 'spring-boot.includes')
	private List<Include> includes;
	/**
	 * Collection of artifact definitions to exclude. The {@link Exclude} element defines
	 * mandatory {@code groupId} and {@code artifactId} components and an optional
	 * {@code classifier} component. When configured as a property, values should be
	 * comma-separated with colon-separated components:
	 * {@code groupId:artifactId,groupId:artifactId:classifier}
	 * @since 1.1.0
	 */
	@Parameter(property = 'spring-boot.excludes')
	private List<Exclude> excludes;
	/**
	 * Comma separated list of groupId names to exclude (exact match).
	 * @since 1.1.0
	 */
	@Parameter(property = 'spring-boot.excludeGroupIds', defaultValue = '')
	private String excludeGroupIds;
	protected void setExcludes(List<Exclude> excludes) {
		this.excludes = excludes;
	}
	protected void setIncludes(List<Include> includes) {
		this.includes = includes;
	}
	protected void setExcludeGroupIds(String excludeGroupIds) {
		this.excludeGroupIds = excludeGroupIds;
	}
	protected List<URL> getDependencyURLs(ArtifactsFilter... additionalFilters) throws MojoExecutionException {
		Set<Artifact> artifacts = filterDependencies(this.project.getArtifacts(), additionalFilters);
		List<URL> urls = new ArrayList<>();
		for (Artifact artifact : artifacts) {
			if (artifact.getFile() != null) {
				urls.add(toURL(artifact.getFile()));
			}
		}
		return urls;
	}
	protected final Set<Artifact> filterDependencies(Set<Artifact> dependencies, ArtifactsFilter... additionalFilters)
			throws MojoExecutionException {
		try {
			Set<Artifact> filtered = new LinkedHashSet<>(dependencies);
			filtered.retainAll(getFilters(additionalFilters).filter(dependencies));
			return filtered;
		}
		catch (ArtifactFilterException ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
	}
	protected URL toURL(File file) {
		try {
			return file.toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException('Invalid URL for ' + file, ex);
		}
	}
	/**
	 * Return artifact filters configured for this MOJO.
	 * @param additionalFilters optional additional filters to apply
	 * @return the filters
	 */
	private FilterArtifacts getFilters(ArtifactsFilter... additionalFilters) {
		FilterArtifacts filters = new FilterArtifacts();
		for (ArtifactsFilter additionalFilter : additionalFilters) {
			filters.addFilter(additionalFilter);
		}
		filters.addFilter(new MatchingGroupIdFilter(cleanFilterConfig(this.excludeGroupIds)));
		if (this.includes != null && !this.includes.isEmpty()) {
			filters.addFilter(new IncludeFilter(this.includes));
		}
		if (this.excludes != null && !this.excludes.isEmpty()) {
			filters.addFilter(new ExcludeFilter(this.excludes));
		}
		filters.addFilter(new JarTypeFilter());
		return filters;
	}
	private String cleanFilterConfig(String content) {
		if (content == null || content.trim().isEmpty()) {
			return '';
		}
		StringBuilder cleaned = new StringBuilder();
		StringTokenizer tokenizer = new StringTokenizer(content, ',');
		while (tokenizer.hasMoreElements()) {
			cleaned.append(tokenizer.nextToken().trim());
			if (tokenizer.hasMoreElements()) {
				cleaned.append(',');
			}
		}
		return cleaned.toString();
	}
	/**
	 * {@link ArtifactFilter} to exclude test scope dependencies.
	 */
	protected static class ExcludeTestScopeArtifactFilter extends AbstractArtifactFeatureFilter {
		ExcludeTestScopeArtifactFilter() {
			super('', Artifact.SCOPE_TEST);
		}
		@Override
		protected String getArtifactFeature(Artifact artifact) {
			return artifact.getScope();
		}
	}
	/**
	 * {@link ArtifactFilter} that only include runtime scopes.
	 */
	protected static class RuntimeArtifactFilter implements ArtifactFilter {
		private static final Collection<String> SCOPES = List.of(Artifact.SCOPE_COMPILE,
				Artifact.SCOPE_COMPILE_PLUS_RUNTIME, Artifact.SCOPE_RUNTIME);
		@Override
		public boolean include(Artifact artifact) {
			String scope = artifact.getScope();
			return !artifact.isOptional() && (scope == null || SCOPES.contains(scope));
		}
	}
}
/*
package org.springframework.boot.maven;
/**
public class Docker {
	private String host;
	private String context;
	private boolean tlsVerify;
	private String certPath;
	private boolean bindHostToBuilder;
	private DockerRegistry builderRegistry;
	private DockerRegistry publishRegistry;
	/**
	 * The host address of the Docker daemon.
	 * @return the Docker host
	 */
	public String getHost() {
		return this.host;
	}
	void setHost(String host) {
		this.host = host;
	}
	/**
	 * The Docker context to use to retrieve host configuration.
	 * @return the Docker context
	 */
	public String getContext() {
		return this.context;
	}
	public void setContext(String context) {
		this.context = context;
	}
	/**
	 * Whether the Docker daemon requires TLS communication.
	 * @return {@code true} to enable TLS
	 */
	public boolean isTlsVerify() {
		return this.tlsVerify;
	}
	void setTlsVerify(boolean tlsVerify) {
		this.tlsVerify = tlsVerify;
	}
	/**
	 * The path to TLS certificate and key files required for TLS communication with the
	 * Docker daemon.
	 * @return the TLS certificate path
	 */
	public String getCertPath() {
		return this.certPath;
	}
	void setCertPath(String certPath) {
		this.certPath = certPath;
	}
	/**
	 * Whether to use the configured Docker host in the builder container.
	 * @return {@code true} to use the configured Docker host in the builder container
	 */
	public boolean isBindHostToBuilder() {
		return this.bindHostToBuilder;
	}
	void setBindHostToBuilder(boolean bindHostToBuilder) {
		this.bindHostToBuilder = bindHostToBuilder;
	}
	/**
	 * Configuration of the Docker registry where builder and run images are stored.
	 * @return the registry configuration
	 */
	DockerRegistry getBuilderRegistry() {
		return this.builderRegistry;
	}
	/**
	 * Sets the {@link DockerRegistry} that configures authentication to the builder
	 * registry.
	 * @param builderRegistry the registry configuration
	 */
	void setBuilderRegistry(DockerRegistry builderRegistry) {
		this.builderRegistry = builderRegistry;
	}
	/**
	 * Configuration of the Docker registry where the generated image will be published.
	 * @return the registry configuration
	 */
	DockerRegistry getPublishRegistry() {
		return this.publishRegistry;
	}
	/**
	 * Sets the {@link DockerRegistry} that configures authentication to the publishing
	 * registry.
	 * @param builderRegistry the registry configuration
	 */
	void setPublishRegistry(DockerRegistry builderRegistry) {
		this.publishRegistry = builderRegistry;
	}
	/**
	 * Returns this configuration as a {@link DockerConfiguration} instance. This method
	 * should only be called when the configuration is complete and will no longer be
	 * changed.
	 * @param publish whether the image should be published
	 * @return the Docker configuration
	 */
	DockerConfiguration asDockerConfiguration(boolean publish) {
		DockerConfiguration dockerConfiguration = new DockerConfiguration();
		dockerConfiguration = customizeHost(dockerConfiguration);
		dockerConfiguration = dockerConfiguration.withBindHostToBuilder(this.bindHostToBuilder);
		dockerConfiguration = customizeBuilderAuthentication(dockerConfiguration);
		dockerConfiguration = customizePublishAuthentication(dockerConfiguration, publish);
		return dockerConfiguration;
	}
	private DockerConfiguration customizeHost(DockerConfiguration dockerConfiguration) {
		if (this.context != null && this.host != null) {
			throw new IllegalArgumentException(
					'Invalid Docker configuration, either context or host can be provided but not both');
		}
		if (this.context != null) {
			return dockerConfiguration.withContext(this.context);
		}
		if (this.host != null) {
			return dockerConfiguration.withHost(this.host, this.tlsVerify, this.certPath);
		}
		return dockerConfiguration;
	}
	private DockerConfiguration customizeBuilderAuthentication(DockerConfiguration dockerConfiguration) {
		if (this.builderRegistry == null || this.builderRegistry.isEmpty()) {
			return dockerConfiguration;
		}
		if (this.builderRegistry.hasTokenAuth() && !this.builderRegistry.hasUserAuth()) {
			return dockerConfiguration.withBuilderRegistryTokenAuthentication(this.builderRegistry.getToken());
		}
		if (this.builderRegistry.hasUserAuth() && !this.builderRegistry.hasTokenAuth()) {
			return dockerConfiguration.withBuilderRegistryUserAuthentication(this.builderRegistry.getUsername(),
					this.builderRegistry.getPassword(), this.builderRegistry.getUrl(), this.builderRegistry.getEmail());
		}
		throw new IllegalArgumentException(
				'Invalid Docker builder registry configuration, either token or username/password must be provided');
	}
	private DockerConfiguration customizePublishAuthentication(DockerConfiguration dockerConfiguration,
			boolean publish) {
		if (!publish) {
			return dockerConfiguration;
		}
		if (this.publishRegistry == null || this.publishRegistry.isEmpty()) {
			return dockerConfiguration.withEmptyPublishRegistryAuthentication();
		}
		if (this.publishRegistry.hasTokenAuth() && !this.publishRegistry.hasUserAuth()) {
			return dockerConfiguration.withPublishRegistryTokenAuthentication(this.publishRegistry.getToken());
		}
		if (this.publishRegistry.hasUserAuth() && !this.publishRegistry.hasTokenAuth()) {
			return dockerConfiguration.withPublishRegistryUserAuthentication(this.publishRegistry.getUsername(),
					this.publishRegistry.getPassword(), this.publishRegistry.getUrl(), this.publishRegistry.getEmail());
		}
		throw new IllegalArgumentException(
				'Invalid Docker publish registry configuration, either token or username/password must be provided');
	}
	/**
	 * Encapsulates Docker registry authentication configuration options.
	 */
	public static class DockerRegistry {
		private String username;
		private String password;
		private String url;
		private String email;
		private String token;
		public DockerRegistry() {
		}
		public DockerRegistry(String username, String password, String url, String email) {
			this.username = username;
			this.password = password;
			this.url = url;
			this.email = email;
		}
		public DockerRegistry(String token) {
			this.token = token;
		}
		/**
		 * The username that will be used for user authentication to the registry.
		 * @return the username
		 */
		public String getUsername() {
			return this.username;
		}
		void setUsername(String username) {
			this.username = username;
		}
		/**
		 * The password that will be used for user authentication to the registry.
		 * @return the password
		 */
		public String getPassword() {
			return this.password;
		}
		void setPassword(String password) {
			this.password = password;
		}
		/**
		 * The email address that will be used for user authentication to the registry.
		 * @return the email address
		 */
		public String getEmail() {
			return this.email;
		}
		void setEmail(String email) {
			this.email = email;
		}
		/**
		 * The URL of the registry.
		 * @return the registry URL
		 */
		String getUrl() {
			return this.url;
		}
		void setUrl(String url) {
			this.url = url;
		}
		/**
		 * The token that will be used for token authentication to the registry.
		 * @return the authentication token
		 */
		public String getToken() {
			return this.token;
		}
		void setToken(String token) {
			this.token = token;
		}
		boolean isEmpty() {
			return this.username == null && this.password == null && this.url == null && this.email == null
					&& this.token == null;
		}
		boolean hasTokenAuth() {
			return this.token != null;
		}
		boolean hasUserAuth() {
			return this.username != null && this.password != null;
		}
	}
}
/*
package org.springframework.boot.maven;
/**
public class CacheInfo {
	private Cache cache;
	public CacheInfo() {
	}
	private CacheInfo(Cache cache) {
		this.cache = cache;
	}
	public void setVolume(VolumeCacheInfo info) {
		Assert.state(this.cache == null, 'Each image building cache can be configured only once');
		this.cache = Cache.volume(info.getName());
	}
	public void setBind(BindCacheInfo info) {
		Assert.state(this.cache == null, 'Each image building cache can be configured only once');
		this.cache = Cache.bind(info.getSource());
	}
	Cache asCache() {
		return this.cache;
	}
	static CacheInfo fromVolume(VolumeCacheInfo cacheInfo) {
		return new CacheInfo(Cache.volume(cacheInfo.getName()));
	}
	static CacheInfo fromBind(BindCacheInfo cacheInfo) {
		return new CacheInfo(Cache.bind(cacheInfo.getSource()));
	}
	/**
	 * Encapsulates configuration of an image building cache stored in a volume.
	 */
	public static class VolumeCacheInfo {
		private String name;
		public VolumeCacheInfo() {
		}
		VolumeCacheInfo(String name) {
			this.name = name;
		}
		public String getName() {
			return this.name;
		}
		void setName(String name) {
			this.name = name;
		}
	}
	/**
	 * Encapsulates configuration of an image building cache stored in a bind mount.
	 */
	public static class BindCacheInfo {
		private String source;
		public BindCacheInfo() {
		}
		BindCacheInfo(String name) {
			this.source = name;
		}
		public String getSource() {
			return this.source;
		}
		void setSource(String source) {
			this.source = source;
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'process-aot', defaultPhase = LifecyclePhase.PREPARE_PACKAGE, threadSafe = true,
		requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME,
		requiresDependencyCollection = ResolutionScope.COMPILE_PLUS_RUNTIME)
public class ProcessAotMojo extends AbstractAotMojo {
	private static final String AOT_PROCESSOR_CLASS_NAME = 'org.springframework.boot.SpringApplicationAotProcessor';
	/**
	 * Directory containing the classes and resource files that should be packaged into
	 * the archive.
	 */
	@Parameter(defaultValue = '${project.build.outputDirectory}', required = true)
	private File classesDirectory;
	/**
	 * Directory containing the generated sources.
	 */
	@Parameter(defaultValue = '${project.build.directory}/spring-aot/main/sources', required = true)
	private File generatedSources;
	/**
	 * Directory containing the generated resources.
	 */
	@Parameter(defaultValue = '${project.build.directory}/spring-aot/main/resources', required = true)
	private File generatedResources;
	/**
	 * Directory containing the generated classes.
	 */
	@Parameter(defaultValue = '${project.build.directory}/spring-aot/main/classes', required = true)
	private File generatedClasses;
	/**
	 * Name of the main class to use as the source for the AOT process. If not specified
	 * the first compiled class found that contains a "main" method will be used.
	 */
	@Parameter(property = 'spring-boot.aot.main-class')
	private String mainClass;
	/**
	 * Application arguments that should be taken into account for AOT processing.
	 */
	@Parameter
	private String[] arguments;
	/**
	 * Spring profiles to take into account for AOT processing.
	 */
	@Parameter
	private String[] profiles;
	@Override
	protected void executeAot() throws Exception {
		if (this.project.getPackaging().equals('pom')) {
			getLog().debug('process-aot goal could not be applied to pom project.');
			return;
		}
		String applicationClass = (this.mainClass != null) ? this.mainClass
				: SpringBootApplicationClassFinder.findSingleClass(this.classesDirectory);
		URL[] classPath = getClassPath();
		generateAotAssets(classPath, AOT_PROCESSOR_CLASS_NAME, getAotArguments(applicationClass));
		compileSourceFiles(classPath, this.generatedSources, this.generatedClasses);
		copyAll(this.generatedResources.toPath(), this.classesDirectory.toPath());
		copyAll(this.generatedClasses.toPath(), this.classesDirectory.toPath());
	}
	private String[] getAotArguments(String applicationClass) {
		List<String> aotArguments = new ArrayList<>();
		aotArguments.add(applicationClass);
		aotArguments.add(this.generatedSources.toString());
		aotArguments.add(this.generatedResources.toString());
		aotArguments.add(this.generatedClasses.toString());
		aotArguments.add(this.project.getGroupId());
		aotArguments.add(this.project.getArtifactId());
		aotArguments.addAll(resolveArguments().getArgs());
		return aotArguments.toArray(String[]::new);
	}
	private URL[] getClassPath() throws Exception {
		File[] directories = new File[] { this.classesDirectory, this.generatedClasses };
		return getClassPath(directories, new ExcludeTestScopeArtifactFilter());
	}
	private RunArguments resolveArguments() {
		RunArguments runArguments = new RunArguments(this.arguments);
		if (!ObjectUtils.isEmpty(this.profiles)) {
			runArguments.getArgs().addFirst('--spring.profiles.active=' + String.join(',', this.profiles));
		}
		return runArguments;
	}
}
/*
package org.springframework.boot.maven;
/**
class SpringApplicationAdminClient {
	// Note: see SpringApplicationAdminJmxAutoConfiguration
	static final String DEFAULT_OBJECT_NAME = 'org.springframework.boot:type=Admin,name=SpringApplication';
	private final MBeanServerConnection connection;
	private final ObjectName objectName;
	SpringApplicationAdminClient(MBeanServerConnection connection, String jmxName) {
		this.connection = connection;
		this.objectName = toObjectName(jmxName);
	}
	/**
	 * Check if the spring application managed by this instance is ready. Returns
	 * {@code false} if the mbean is not yet deployed so this method should be repeatedly
	 * called until a timeout is reached.
	 * @return {@code true} if the application is ready to service requests
	 * @throws MojoExecutionException if the JMX service could not be contacted
	 */
	boolean isReady() throws MojoExecutionException {
		try {
			return (Boolean) this.connection.getAttribute(this.objectName, 'Ready');
		}
		catch (InstanceNotFoundException ex) {
			return false; // Instance not available yet
		}
		catch (AttributeNotFoundException ex) {
			throw new IllegalStateException('Unexpected: attribute "Ready" not available', ex);
		}
		catch (ReflectionException ex) {
			throw new MojoExecutionException('Failed to retrieve Ready attribute', ex.getCause());
		}
		catch (MBeanException | IOException ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
	}
	/**
	 * Stop the application managed by this instance.
	 * @throws MojoExecutionException if the JMX service could not be contacted
	 * @throws IOException if an I/O error occurs
	 * @throws InstanceNotFoundException if the lifecycle mbean cannot be found
	 */
	void stop() throws MojoExecutionException, IOException, InstanceNotFoundException {
		try {
			this.connection.invoke(this.objectName, 'shutdown', null, null);
		}
		catch (ReflectionException ex) {
			throw new MojoExecutionException('Shutdown failed', ex.getCause());
		}
		catch (MBeanException ex) {
			throw new MojoExecutionException('Could not invoke shutdown operation', ex);
		}
	}
	private ObjectName toObjectName(String name) {
		try {
			return new ObjectName(name);
		}
		catch (MalformedObjectNameException ex) {
			throw new IllegalArgumentException('Invalid jmx name "' + name + '"');
		}
	}
	/**
	 * Create a connector for an {@link javax.management.MBeanServer} exposed on the
	 * current machine and the current port. Security should be disabled.
	 * @param port the port on which the mbean server is exposed
	 * @return a connection
	 * @throws IOException if the connection to that server failed
	 */
	static JMXConnector connect(int port) throws IOException {
		String url = 'service:jmx:rmi:///jndi/rmi://127.0.0.1:' + port + '/jmxrmi';
		JMXServiceURL serviceUrl = new JMXServiceURL(url);
		return JMXConnectorFactory.connect(serviceUrl, null);
	}
}
/*
package org.springframework.boot.maven;
/**
public class MatchingGroupIdFilter extends AbstractArtifactFeatureFilter {
	/**
	 * Create a new instance with the CSV groupId values that should be excluded.
	 * @param exclude the group values to exclude
	 */
	public MatchingGroupIdFilter(String exclude) {
		super('', exclude);
	}
	@Override
	protected String getArtifactFeature(Artifact artifact) {
		return artifact.getGroupId();
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'build-image-no-fork', defaultPhase = LifecyclePhase.PACKAGE, requiresProject = true, threadSafe = true,
		requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME,
		requiresDependencyCollection = ResolutionScope.COMPILE_PLUS_RUNTIME)
public class BuildImageNoForkMojo extends BuildImageMojo {
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'build-image', defaultPhase = LifecyclePhase.PACKAGE, requiresProject = true, threadSafe = true,
		requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME,
		requiresDependencyCollection = ResolutionScope.COMPILE_PLUS_RUNTIME)
@Execute(phase = LifecyclePhase.PACKAGE)
public class BuildImageForkMojo extends BuildImageMojo {
}
/*
package org.springframework.boot.maven;
/**
public class Include extends FilterableDependency {
}
/*
package org.springframework.boot.maven;
/**
class JarTypeFilter extends DependencyFilter {
	private static final Set<String> EXCLUDED_JAR_TYPES = Collections
		.unmodifiableSet(new HashSet<>(Arrays.asList('annotation-processor', 'dependencies-starter')));
	JarTypeFilter() {
		super(Collections.emptyList());
	}
	@Override
	protected boolean filter(Artifact artifact) {
		try (JarFile jarFile = new JarFile(artifact.getFile())) {
			Manifest manifest = jarFile.getManifest();
			if (manifest != null) {
				String jarType = manifest.getMainAttributes().getValue('Spring-Boot-Jar-Type');
				if (jarType != null && EXCLUDED_JAR_TYPES.contains(jarType)) {
					return true;
				}
			}
		}
		catch (IOException ex) {
			// Continue
		}
		return false;
	}
}
/*
package org.springframework.boot.maven;
/**
public abstract class FilterableDependency {
	/**
	 * The groupId of the artifact to exclude.
	 */
	@Parameter(required = true)
	private String groupId;
	/**
	 * The artifactId of the artifact to exclude.
	 */
	@Parameter(required = true)
	private String artifactId;
	/**
	 * The classifier of the artifact to exclude.
	 */
	@Parameter
	private String classifier;
	String getGroupId() {
		return this.groupId;
	}
	void setGroupId(String groupId) {
		this.groupId = groupId;
	}
	String getArtifactId() {
		return this.artifactId;
	}
	void setArtifactId(String artifactId) {
		this.artifactId = artifactId;
	}
	String getClassifier() {
		return this.classifier;
	}
	void setClassifier(String classifier) {
		this.classifier = classifier;
	}
	/**
	 * Configures the include or exclude using a user-provided property in the form
	 * {@code groupId:artifactId} or {@code groupId:artifactId:classifier}.
	 * @param property the user-provided property
	 */
	public void set(String property) {
		String[] parts = property.split(':');
		Assert.isTrue(parts.length == 2 || parts.length == 3, getClass().getSimpleName()
				+ ' must be in the form groupId:artifactId or groupId:artifactId:classifier');
		setGroupId(parts[0]);
		setArtifactId(parts[1]);
		if (parts.length == 3) {
			setClassifier(parts[2]);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
class CustomLayersProvider {
	CustomLayers getLayers(Document document) {
		validate(document);
		Element root = document.getDocumentElement();
		List<ContentSelector<String>> applicationSelectors = getApplicationSelectors(root);
		List<ContentSelector<Library>> librarySelectors = getLibrarySelectors(root);
		List<Layer> layers = getLayers(root);
		return new CustomLayers(layers, applicationSelectors, librarySelectors);
	}
	private void validate(Document document) {
		Schema schema = loadSchema();
		try {
			Validator validator = schema.newValidator();
			validator.validate(new DOMSource(document));
		}
		catch (SAXException | IOException ex) {
			throw new IllegalStateException('Invalid layers.xml configuration', ex);
		}
	}
	private Schema loadSchema() {
		try {
			SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);
			return factory.newSchema(getClass().getResource('layers.xsd'));
		}
		catch (SAXException ex) {
			throw new IllegalStateException('Unable to load layers XSD');
		}
	}
	private List<ContentSelector<String>> getApplicationSelectors(Element root) {
		return getSelectors(root, 'application', (element) -> getSelector(element, ApplicationContentFilter::new));
	}
	private List<ContentSelector<Library>> getLibrarySelectors(Element root) {
		return getSelectors(root, 'dependencies', (element) -> getLibrarySelector(element, LibraryContentFilter::new));
	}
	private List<Layer> getLayers(Element root) {
		Element layerOrder = getChildElement(root, 'layerOrder');
		if (layerOrder == null) {
			return Collections.emptyList();
		}
		return getChildNodeTextContent(layerOrder, 'layer').stream().map(Layer::new).toList();
	}
	private <T> List<ContentSelector<T>> getSelectors(Element root, String elementName,
			Function<Element, ContentSelector<T>> selectorFactory) {
		Element element = getChildElement(root, elementName);
		if (element == null) {
			return Collections.emptyList();
		}
		List<ContentSelector<T>> selectors = new ArrayList<>();
		NodeList children = element.getChildNodes();
		for (int i = 0; i < children.getLength(); i++) {
			Node child = children.item(i);
			if (child instanceof Element childElement) {
				ContentSelector<T> selector = selectorFactory.apply(childElement);
				selectors.add(selector);
			}
		}
		return selectors;
	}
	private <T> ContentSelector<T> getSelector(Element element, Function<String, ContentFilter<T>> filterFactory) {
		Layer layer = new Layer(element.getAttribute('layer'));
		List<String> includes = getChildNodeTextContent(element, 'include');
		List<String> excludes = getChildNodeTextContent(element, 'exclude');
		return new IncludeExcludeContentSelector<>(layer, includes, excludes, filterFactory);
	}
	private ContentSelector<Library> getLibrarySelector(Element element,
			Function<String, ContentFilter<Library>> filterFactory) {
		Layer layer = new Layer(element.getAttribute('layer'));
		List<String> includes = getChildNodeTextContent(element, 'include');
		List<String> excludes = getChildNodeTextContent(element, 'exclude');
		Element includeModuleDependencies = getChildElement(element, 'includeModuleDependencies');
		Element excludeModuleDependencies = getChildElement(element, 'excludeModuleDependencies');
		List<ContentFilter<Library>> includeFilters = includes.stream()
			.map(filterFactory)
			.collect(Collectors.toCollection(ArrayList::new));
		if (includeModuleDependencies != null) {
			includeFilters.add(Library::isLocal);
		}
		List<ContentFilter<Library>> excludeFilters = excludes.stream()
			.map(filterFactory)
			.collect(Collectors.toCollection(ArrayList::new));
		if (excludeModuleDependencies != null) {
			excludeFilters.add(Library::isLocal);
		}
		return new IncludeExcludeContentSelector<>(layer, includeFilters, excludeFilters);
	}
	private List<String> getChildNodeTextContent(Element element, String tagName) {
		List<String> patterns = new ArrayList<>();
		NodeList nodes = element.getElementsByTagName(tagName);
		for (int i = 0; i < nodes.getLength(); i++) {
			Node node = nodes.item(i);
			if (node instanceof Element) {
				patterns.add(node.getTextContent());
			}
		}
		return patterns;
	}
	private Element getChildElement(Element element, String tagName) {
		NodeList nodes = element.getElementsByTagName(tagName);
		if (nodes.getLength() == 0) {
			return null;
		}
		if (nodes.getLength() > 1) {
			throw new IllegalStateException('Multiple "' + tagName + '" nodes found');
		}
		return (Element) nodes.item(0);
	}
}
/*
package org.springframework.boot.maven;
/**
public class Layers {
	private boolean enabled = true;
	@Deprecated(since = '3.3.0', forRemoval = true)
	private boolean includeLayerTools = true;
	private File configuration;
	/**
	 * Whether a {@code layers.idx} file should be added to the jar.
	 * @return true if a {@code layers.idx} file should be added.
	 */
	public boolean isEnabled() {
		return this.enabled;
	}
	/**
	 * Whether to include the layer tools jar.
	 * @return true if layer tools should be included
	 * @deprecated since 3.3.0 for removal in 3.5.0 in favor of {@code includeTools}.
	 */
	@Deprecated(since = '3.3.0', forRemoval = true)
	public boolean isIncludeLayerTools() {
		return this.includeLayerTools;
	}
	/**
	 * The location of the layers configuration file. If no file is provided, a default
	 * configuration is used with four layers: {@code application}, {@code resources},
	 * {@code snapshot-dependencies} and {@code dependencies}.
	 * @return the layers configuration file
	 */
	public File getConfiguration() {
		return this.configuration;
	}
	public void setConfiguration(File configuration) {
		this.configuration = configuration;
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'start', requiresProject = true, defaultPhase = LifecyclePhase.PRE_INTEGRATION_TEST,
		requiresDependencyResolution = ResolutionScope.TEST)
public class StartMojo extends AbstractRunMojo {
	private static final String ENABLE_MBEAN_PROPERTY = '--spring.application.admin.enabled=true';
	private static final String JMX_NAME_PROPERTY_PREFIX = '--spring.application.admin.jmx-name=';
	/**
	 * The JMX name of the automatically deployed MBean managing the lifecycle of the
	 * spring application.
	 */
	@Parameter(defaultValue = SpringApplicationAdminClient.DEFAULT_OBJECT_NAME)
	private String jmxName;
	/**
	 * The port to use to expose the platform MBeanServer.
	 */
	@Parameter(defaultValue = '9001')
	private int jmxPort;
	/**
	 * The number of milliseconds to wait between each attempt to check if the spring
	 * application is ready.
	 */
	@Parameter(property = 'spring-boot.start.wait', defaultValue = '500')
	private long wait;
	/**
	 * The maximum number of attempts to check if the spring application is ready.
	 * Combined with the 'wait' argument, this gives a global timeout value (30 sec by
	 * default)
	 */
	@Parameter(property = 'spring-boot.start.maxAttempts', defaultValue = '60')
	private int maxAttempts;
	private final Object lock = new Object();
	/**
	 * Flag to include the test classpath when running.
	 */
	@Parameter(property = 'spring-boot.run.useTestClasspath', defaultValue = 'false')
	private Boolean useTestClasspath;
	@Override
	protected void run(JavaProcessExecutor processExecutor, File workingDirectory, List<String> args,
			Map<String, String> environmentVariables) throws MojoExecutionException, MojoFailureException {
		RunProcess runProcess = processExecutor.runAsync(workingDirectory, args, environmentVariables);
		try {
			waitForSpringApplication();
		}
		catch (MojoExecutionException | MojoFailureException ex) {
			runProcess.kill();
			throw ex;
		}
	}
	@Override
	protected RunArguments resolveApplicationArguments() {
		RunArguments applicationArguments = super.resolveApplicationArguments();
		applicationArguments.getArgs().addLast(ENABLE_MBEAN_PROPERTY);
		applicationArguments.getArgs().addLast(JMX_NAME_PROPERTY_PREFIX + this.jmxName);
		return applicationArguments;
	}
	@Override
	protected RunArguments resolveJvmArguments() {
		RunArguments jvmArguments = super.resolveJvmArguments();
		List<String> remoteJmxArguments = new ArrayList<>();
		remoteJmxArguments.add('-Dcom.sun.management.jmxremote');
		remoteJmxArguments.add('-Dcom.sun.management.jmxremote.port=' + this.jmxPort);
		remoteJmxArguments.add('-Dcom.sun.management.jmxremote.authenticate=false');
		remoteJmxArguments.add('-Dcom.sun.management.jmxremote.ssl=false');
		remoteJmxArguments.add('-Djava.rmi.server.hostname=127.0.0.1');
		jvmArguments.getArgs().addAll(remoteJmxArguments);
		return jvmArguments;
	}
	private void waitForSpringApplication() throws MojoFailureException, MojoExecutionException {
		try {
			getLog().debug('Connecting to local MBeanServer at port ' + this.jmxPort);
			try (JMXConnector connector = execute(this.wait, this.maxAttempts, new CreateJmxConnector(this.jmxPort))) {
				if (connector == null) {
					throw new MojoExecutionException('JMX MBean server was not reachable before the configured '
							+ 'timeout (' + (this.wait * this.maxAttempts) + 'ms');
				}
				getLog().debug('Connected to local MBeanServer at port ' + this.jmxPort);
				MBeanServerConnection connection = connector.getMBeanServerConnection();
				doWaitForSpringApplication(connection);
			}
		}
		catch (IOException ex) {
			throw new MojoFailureException('Could not contact Spring Boot application via JMX on port ' + this.jmxPort
					+ '. Please make sure that no other process is using that port', ex);
		}
		catch (Exception ex) {
			throw new MojoExecutionException('Failed to connect to MBean server at port ' + this.jmxPort, ex);
		}
	}
	private void doWaitForSpringApplication(MBeanServerConnection connection)
			throws MojoExecutionException, MojoFailureException {
		final SpringApplicationAdminClient client = new SpringApplicationAdminClient(connection, this.jmxName);
		try {
			execute(this.wait, this.maxAttempts, () -> (client.isReady() ? true : null));
		}
		catch (ReflectionException ex) {
			throw new MojoExecutionException('Unable to retrieve "ready" attribute', ex.getCause());
		}
		catch (Exception ex) {
			throw new MojoFailureException('Could not invoke shutdown operation', ex);
		}
	}
	/**
	 * Execute a task, retrying it on failure.
	 * @param <T> the result type
	 * @param wait the wait time
	 * @param maxAttempts the maximum number of attempts
	 * @param callback the task to execute (possibly multiple times). The callback should
	 * return {@code null} to indicate that another attempt should be made
	 * @return the result
	 * @throws Exception in case of execution errors
	 */
	public <T> T execute(long wait, int maxAttempts, Callable<T> callback) throws Exception {
		getLog().debug('Waiting for spring application to start...');
		for (int i = 0; i < maxAttempts; i++) {
			T result = callback.call();
			if (result != null) {
				return result;
			}
			String message = 'Spring application is not ready yet, waiting ' + wait + 'ms (attempt ' + (i + 1) + ')';
			getLog().debug(message);
			synchronized (this.lock) {
				try {
					this.lock.wait(wait);
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
					throw new IllegalStateException('Interrupted while waiting for Spring Boot app to start.');
				}
			}
		}
		throw new MojoExecutionException(
				'Spring application did not start before the configured timeout (' + (wait * maxAttempts) + 'ms');
	}
	@Override
	protected boolean isUseTestClasspath() {
		return this.useTestClasspath;
	}
	private class CreateJmxConnector implements Callable<JMXConnector> {
		private final int port;
		CreateJmxConnector(int port) {
			this.port = port;
		}
		@Override
		public JMXConnector call() throws Exception {
			try {
				return SpringApplicationAdminClient.connect(this.port);
			}
			catch (IOException ex) {
				if (hasCauseWithType(ex, ConnectException.class)) {
					String message = 'MBean server at port ' + this.port + ' is not up yet...';
					getLog().debug(message);
					return null;
				}
				throw ex;
			}
		}
		private boolean hasCauseWithType(Throwable t, Class<? extends Exception> type) {
			return type.isAssignableFrom(t.getClass()) || t.getCause() != null && hasCauseWithType(t.getCause(), type);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
public class ExcludeFilter extends DependencyFilter {
	public ExcludeFilter(Exclude... excludes) {
		this(Arrays.asList(excludes));
	}
	public ExcludeFilter(List<Exclude> excludes) {
		super(excludes);
	}
	@Override
	protected boolean filter(Artifact artifact) {
		for (FilterableDependency dependency : getFilters()) {
			if (equals(artifact, dependency)) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.maven;
/**
public abstract class AbstractPackagerMojo extends AbstractDependencyFilterMojo {
	private static final org.springframework.boot.loader.tools.Layers IMPLICIT_LAYERS = org.springframework.boot.loader.tools.Layers.IMPLICIT;
	/**
	 * The Maven project.
	 * @since 1.0.0
	 */
	@Parameter(defaultValue = '${project}', readonly = true, required = true)
	protected MavenProject project;
	/**
	 * The Maven session.
	 * @since 2.4.0
	 */
	@Parameter(defaultValue = '${session}', readonly = true, required = true)
	protected MavenSession session;
	/**
	 * Maven project helper utils.
	 * @since 1.0.0
	 */
	@Component
	protected MavenProjectHelper projectHelper;
	/**
	 * The name of the main class. If not specified the first compiled class found that
	 * contains a {@code main} method will be used.
	 * @since 1.0.0
	 */
	@Parameter
	private String mainClass;
	/**
	 * Exclude Spring Boot devtools from the repackaged archive.
	 * @since 1.3.0
	 */
	@Parameter(property = 'spring-boot.repackage.excludeDevtools', defaultValue = 'true')
	private boolean excludeDevtools = true;
	/**
	 * Exclude Spring Boot dev services from the repackaged archive.
	 * @since 3.1.0
	 */
	@Parameter(property = 'spring-boot.repackage.excludeDockerCompose', defaultValue = 'true')
	private boolean excludeDockerCompose = true;
	/**
	 * Include system scoped dependencies.
	 * @since 1.4.0
	 */
	@Parameter(defaultValue = 'false')
	public boolean includeSystemScope;
	/**
	 * Include JAR tools.
	 * @since 3.3.0
	 */
	@Parameter(defaultValue = 'true')
	public boolean includeTools = true;
	/**
	 * Layer configuration with options to disable layer creation, exclude layer tools
	 * jar, and provide a custom layers configuration file.
	 * @since 2.3.0
	 */
	@Parameter
	private Layers layers = new Layers();
	/**
	 * Return the type of archive that should be packaged by this MOJO.
	 * @return {@code null}, indicating a layout type will be chosen based on the original
	 * archive type
	 */
	protected LayoutType getLayout() {
		return null;
	}
	/**
	 * Return the loader implementation that should be used.
	 * @return the loader implementation or {@code null}
	 * @since 3.2.0
	 */
	protected LoaderImplementation getLoaderImplementation() {
		return null;
	}
	/**
	 * Return the layout factory that will be used to determine the {@link LayoutType} if
	 * no explicit layout is set.
	 * @return {@code null}, indicating a default layout factory will be chosen
	 */
	protected LayoutFactory getLayoutFactory() {
		return null;
	}
	/**
	 * Return a {@link Packager} configured for this MOJO.
	 * @param <P> the packager type
	 * @param supplier a packager supplier
	 * @return a configured packager
	 */
	protected <P extends Packager> P getConfiguredPackager(Supplier<P> supplier) {
		P packager = supplier.get();
		packager.setLoaderImplementation(getLoaderImplementation());
		packager.setLayoutFactory(getLayoutFactory());
		packager.addMainClassTimeoutWarningListener(new LoggingMainClassTimeoutWarningListener(this::getLog));
		packager.setMainClass(this.mainClass);
		LayoutType layout = getLayout();
		if (layout != null) {
			getLog().info('Layout: ' + layout);
			packager.setLayout(layout.layout());
		}
		if (this.layers.isEnabled()) {
			packager.setLayers((this.layers.getConfiguration() != null)
					? getCustomLayers(this.layers.getConfiguration()) : IMPLICIT_LAYERS);
		}
		packager.setIncludeRelevantJarModeJars(getIncludeRelevantJarModeJars());
		return packager;
	}
	@SuppressWarnings('removal')
	private boolean getIncludeRelevantJarModeJars() {
		if (!this.includeTools) {
			return false;
		}
		return this.layers.isIncludeLayerTools();
	}
	private CustomLayers getCustomLayers(File configuration) {
		try {
			Document document = getDocumentIfAvailable(configuration);
			return new CustomLayersProvider().getLayers(document);
		}
		catch (Exception ex) {
			throw new IllegalStateException(
					'Failed to process custom layers configuration ' + configuration.getAbsolutePath(), ex);
		}
	}
	private Document getDocumentIfAvailable(File xmlFile) throws Exception {
		InputSource inputSource = new InputSource(new FileInputStream(xmlFile));
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		factory.setNamespaceAware(true);
		DocumentBuilder builder = factory.newDocumentBuilder();
		return builder.parse(inputSource);
	}
	/**
	 * Return {@link Libraries} that the packager can use.
	 * @param unpacks any libraries that require unpack
	 * @return the libraries to use
	 * @throws MojoExecutionException on execution error
	 */
	protected final Libraries getLibraries(Collection<Dependency> unpacks) throws MojoExecutionException {
		Set<Artifact> artifacts = this.project.getArtifacts();
		Set<Artifact> includedArtifacts = filterDependencies(artifacts, getAdditionalFilters());
		return new ArtifactsLibraries(artifacts, includedArtifacts, this.session.getProjects(), unpacks, getLog());
	}
	private ArtifactsFilter[] getAdditionalFilters() {
		List<ArtifactsFilter> filters = new ArrayList<>();
		if (this.excludeDevtools) {
			filters.add(DEVTOOLS_EXCLUDE_FILTER);
		}
		if (this.excludeDockerCompose) {
			filters.add(DOCKER_COMPOSE_EXCLUDE_FILTER);
		}
		if (!this.includeSystemScope) {
			filters.add(new ScopeFilter(null, Artifact.SCOPE_SYSTEM));
		}
		return filters.toArray(new ArtifactsFilter[0]);
	}
	/**
	 * Return the source {@link Artifact} to repackage. If a classifier is specified and
	 * an artifact with that classifier exists, it is used. Otherwise, the main artifact
	 * is used.
	 * @param classifier the artifact classifier
	 * @return the source artifact to repackage
	 */
	protected Artifact getSourceArtifact(String classifier) {
		Artifact sourceArtifact = getArtifact(classifier);
		return (sourceArtifact != null) ? sourceArtifact : this.project.getArtifact();
	}
	private Artifact getArtifact(String classifier) {
		if (classifier != null) {
			for (Artifact attachedArtifact : this.project.getAttachedArtifacts()) {
				if (classifier.equals(attachedArtifact.getClassifier()) && attachedArtifact.getFile() != null
						&& attachedArtifact.getFile().isFile()) {
					return attachedArtifact;
				}
			}
		}
		return null;
	}
	protected File getTargetFile(String finalName, String classifier, File targetDirectory) {
		String classifierSuffix = (classifier != null) ? classifier.trim() : '';
		if (!classifierSuffix.isEmpty() && !classifierSuffix.startsWith('-')) {
			classifierSuffix = '-' + classifierSuffix;
		}
		if (!targetDirectory.exists()) {
			targetDirectory.mkdirs();
		}
		return new File(targetDirectory,
				finalName + classifierSuffix + '.' + this.project.getArtifact().getArtifactHandler().getExtension());
	}
	/**
	 * Archive layout types.
	 */
	public enum LayoutType {
		/**
		 * Jar Layout.
		 */
		JAR(new Jar()),
		/**
		 * War Layout.
		 */
		WAR(new War()),
		/**
		 * Zip Layout.
		 */
		ZIP(new Expanded()),
		/**
		 * Directory Layout.
		 */
		DIR(new Expanded()),
		/**
		 * No Layout.
		 */
		NONE(new None());
		private final Layout layout;
		LayoutType(Layout layout) {
			this.layout = layout;
		}
		public Layout layout() {
			return this.layout;
		}
	}
}
/*
package org.springframework.boot.maven;
/**
class MavenBuildOutputTimestamp {
	private static final Instant DATE_MIN = Instant.parse('1980-01-01T00:00:02Z');
	private static final Instant DATE_MAX = Instant.parse('2099-12-31T23:59:59Z');
	private final String timestamp;
	/**
	 * Creates a new {@link MavenBuildOutputTimestamp}.
	 * @param timestamp timestamp or {@code null}
	 */
	MavenBuildOutputTimestamp(String timestamp) {
		this.timestamp = timestamp;
	}
	/**
	 * Returns the parsed timestamp as an {@code FileTime}.
	 * @return the parsed timestamp as an {@code FileTime}, or {@code null}
	 * @throws IllegalArgumentException if the outputTimestamp is neither ISO 8601 nor an
	 * integer, or it"s not within the valid range 1980-01-01T00:00:02Z to
	 * 2099-12-31T23:59:59Z
	 */
	FileTime toFileTime() {
		Instant instant = toInstant();
		if (instant == null) {
			return null;
		}
		return FileTime.from(instant);
	}
	/**
	 * Returns the parsed timestamp as an {@code Instant}.
	 * @return the parsed timestamp as an {@code Instant}, or {@code null}
	 * @throws IllegalArgumentException if the outputTimestamp is neither ISO 8601 nor an
	 * integer, or it"s not within the valid range 1980-01-01T00:00:02Z to
	 * 2099-12-31T23:59:59Z
	 */
	Instant toInstant() {
		if (!StringUtils.hasLength(this.timestamp)) {
			return null;
		}
		if (isNumeric(this.timestamp)) {
			return Instant.ofEpochSecond(Long.parseLong(this.timestamp));
		}
		if (this.timestamp.length() < 2) {
			return null;
		}
		try {
			Instant instant = OffsetDateTime.parse(this.timestamp)
				.withOffsetSameInstant(ZoneOffset.UTC)
				.truncatedTo(ChronoUnit.SECONDS)
				.toInstant();
			if (instant.isBefore(DATE_MIN) || instant.isAfter(DATE_MAX)) {
				throw new IllegalArgumentException(
						String.format('"%s" is not within the valid range %s to %s', instant, DATE_MIN, DATE_MAX));
			}
			return instant;
		}
		catch (DateTimeParseException pe) {
			throw new IllegalArgumentException(String.format('Can"t parse "%s" to instant', this.timestamp));
		}
	}
	private static boolean isNumeric(String str) {
		for (char c : str.toCharArray()) {
			if (!Character.isDigit(c)) {
				return false;
			}
		}
		return true;
	}
}
/*
/**
package org.springframework.boot.maven;
/*
package org.springframework.boot.maven;
/**
abstract class SpringBootApplicationClassFinder {
	private static final String SPRING_BOOT_APPLICATION_CLASS_NAME = 'org.springframework.boot.autoconfigure.SpringBootApplication';
	static String findSingleClass(File classesDirectory) throws MojoExecutionException {
		return findSingleClass(List.of(classesDirectory));
	}
	static String findSingleClass(List<File> classesDirectories) throws MojoExecutionException {
		try {
			for (File classesDirectory : classesDirectories) {
				String mainClass = MainClassFinder.findSingleMainClass(classesDirectory,
						SPRING_BOOT_APPLICATION_CLASS_NAME);
				if (mainClass != null) {
					return mainClass;
				}
			}
			throw new MojoExecutionException('Unable to find a suitable main class, please add a "mainClass" property');
		}
		catch (IOException ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
class JavaCompilerPluginConfiguration {
	private final MavenProject project;
	JavaCompilerPluginConfiguration(MavenProject project) {
		this.project = project;
	}
	String getSourceMajorVersion() {
		String version = getConfigurationValue('source');
		if (version == null) {
			version = getPropertyValue('maven.compiler.source');
		}
		return majorVersionFor(version);
	}
	String getTargetMajorVersion() {
		String version = getConfigurationValue('target');
		if (version == null) {
			version = getPropertyValue('maven.compiler.target');
		}
		return majorVersionFor(version);
	}
	String getReleaseVersion() {
		String version = getConfigurationValue('release');
		if (version == null) {
			version = getPropertyValue('maven.compiler.release');
		}
		return majorVersionFor(version);
	}
	private String getConfigurationValue(String propertyName) {
		Plugin plugin = this.project.getPlugin('org.apache.maven.plugins:maven-compiler-plugin');
		if (plugin != null) {
			Object pluginConfiguration = plugin.getConfiguration();
			if (pluginConfiguration instanceof Xpp3Dom dom) {
				return getNodeValue(dom, propertyName);
			}
		}
		return null;
	}
	private String getPropertyValue(String propertyName) {
		if (this.project.getProperties().containsKey(propertyName)) {
			return this.project.getProperties().get(propertyName).toString();
		}
		return null;
	}
	private String getNodeValue(Xpp3Dom dom, String... childNames) {
		Xpp3Dom childNode = dom.getChild(childNames[0]);
		if (childNode == null) {
			return null;
		}
		if (childNames.length > 1) {
			return getNodeValue(childNode, Arrays.copyOfRange(childNames, 1, childNames.length));
		}
		return childNode.getValue();
	}
	private String majorVersionFor(String version) {
		if (version != null && version.startsWith('1.')) {
			return version.substring('1.'.length());
		}
		return version;
	}
}
/*
package org.springframework.boot.maven;
/**
public class ArtifactsLibraries implements Libraries {
	private static final Map<String, LibraryScope> SCOPES;
	static {
		Map<String, LibraryScope> libraryScopes = new HashMap<>();
		libraryScopes.put(Artifact.SCOPE_COMPILE, LibraryScope.COMPILE);
		libraryScopes.put(Artifact.SCOPE_RUNTIME, LibraryScope.RUNTIME);
		libraryScopes.put(Artifact.SCOPE_PROVIDED, LibraryScope.PROVIDED);
		libraryScopes.put(Artifact.SCOPE_SYSTEM, LibraryScope.PROVIDED);
		SCOPES = Collections.unmodifiableMap(libraryScopes);
	}
	private final Set<Artifact> artifacts;
	private final Set<Artifact> includedArtifacts;
	private final Collection<MavenProject> localProjects;
	private final Collection<Dependency> unpacks;
	private final Log log;
	/**
	 * Creates a new {@code ArtifactsLibraries} from the given {@code artifacts}.
	 * @param artifacts the artifacts to represent as libraries
	 * @param localProjects projects for which {@link Library#isLocal() local} libraries
	 * should be created
	 * @param unpacks artifacts that should be unpacked on launch
	 * @param log the log
	 * @since 2.4.0
	 */
	public ArtifactsLibraries(Set<Artifact> artifacts, Collection<MavenProject> localProjects,
			Collection<Dependency> unpacks, Log log) {
		this(artifacts, artifacts, localProjects, unpacks, log);
	}
	/**
	 * Creates a new {@code ArtifactsLibraries} from the given {@code artifacts}.
	 * @param artifacts all artifacts that can be represented as libraries
	 * @param includedArtifacts the actual artifacts to include in the uber jar
	 * @param localProjects projects for which {@link Library#isLocal() local} libraries
	 * should be created
	 * @param unpacks artifacts that should be unpacked on launch
	 * @param log the log
	 * @since 2.4.8
	 */
	public ArtifactsLibraries(Set<Artifact> artifacts, Set<Artifact> includedArtifacts,
			Collection<MavenProject> localProjects, Collection<Dependency> unpacks, Log log) {
		this.artifacts = artifacts;
		this.includedArtifacts = includedArtifacts;
		this.localProjects = localProjects;
		this.unpacks = unpacks;
		this.log = log;
	}
	@Override
	public void doWithLibraries(LibraryCallback callback) throws IOException {
		Set<String> duplicates = getDuplicates(this.artifacts);
		for (Artifact artifact : this.artifacts) {
			String name = getFileName(artifact);
			File file = artifact.getFile();
			LibraryScope scope = SCOPES.get(artifact.getScope());
			if (scope == null || file == null) {
				continue;
			}
			if (duplicates.contains(name)) {
				this.log.debug('Duplicate found: ' + name);
				name = artifact.getGroupId() + '-' + name;
				this.log.debug('Renamed to: ' + name);
			}
			LibraryCoordinates coordinates = new ArtifactLibraryCoordinates(artifact);
			boolean unpackRequired = isUnpackRequired(artifact);
			boolean local = isLocal(artifact);
			boolean included = this.includedArtifacts.contains(artifact);
			callback.library(new Library(name, file, scope, coordinates, unpackRequired, local, included));
		}
	}
	private Set<String> getDuplicates(Set<Artifact> artifacts) {
		Set<String> duplicates = new HashSet<>();
		Set<String> seen = new HashSet<>();
		for (Artifact artifact : artifacts) {
			String fileName = getFileName(artifact);
			if (artifact.getFile() != null && !seen.add(fileName)) {
				duplicates.add(fileName);
			}
		}
		return duplicates;
	}
	private boolean isUnpackRequired(Artifact artifact) {
		if (this.unpacks != null) {
			for (Dependency unpack : this.unpacks) {
				if (artifact.getGroupId().equals(unpack.getGroupId())
						&& artifact.getArtifactId().equals(unpack.getArtifactId())) {
					return true;
				}
			}
		}
		return false;
	}
	private boolean isLocal(Artifact artifact) {
		for (MavenProject localProject : this.localProjects) {
			if (localProject.getArtifact().equals(artifact)) {
				return true;
			}
			for (Artifact attachedArtifact : localProject.getAttachedArtifacts()) {
				if (attachedArtifact.equals(artifact)) {
					return true;
				}
			}
		}
		return false;
	}
	private String getFileName(Artifact artifact) {
		StringBuilder sb = new StringBuilder();
		sb.append(artifact.getArtifactId()).append('-').append(artifact.getBaseVersion());
		String classifier = artifact.getClassifier();
		if (classifier != null) {
			sb.append('-').append(classifier);
		}
		sb.append('.').append(artifact.getArtifactHandler().getExtension());
		return sb.toString();
	}
	/**
	 * {@link LibraryCoordinates} backed by a Maven {@link Artifact}.
	 */
	private static class ArtifactLibraryCoordinates implements LibraryCoordinates {
		private final Artifact artifact;
		ArtifactLibraryCoordinates(Artifact artifact) {
			this.artifact = artifact;
		}
		@Override
		public String getGroupId() {
			return this.artifact.getGroupId();
		}
		@Override
		public String getArtifactId() {
			return this.artifact.getArtifactId();
		}
		@Override
		public String getVersion() {
			return this.artifact.getBaseVersion();
		}
		@Override
		public String toString() {
			return this.artifact.toString();
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@Mojo(name = 'test-run', requiresProject = true, defaultPhase = LifecyclePhase.VALIDATE,
		requiresDependencyResolution = ResolutionScope.TEST)
@Execute(phase = LifecyclePhase.TEST_COMPILE)
public class TestRunMojo extends AbstractRunMojo {
	/**
	 * Whether the JVM"s launch should be optimized.
	 */
	@Parameter(property = 'spring-boot.test-run.optimizedLaunch', defaultValue = 'true')
	private boolean optimizedLaunch;
	/**
	 * Directory containing the test classes and resource files that should be used to run
	 * the application.
	 */
	@Parameter(defaultValue = '${project.build.testOutputDirectory}', required = true)
	private File testClassesDirectory;
	@Override
	protected List<File> getClassesDirectories() {
		ArrayList<File> classesDirectories = new ArrayList<>(super.getClassesDirectories());
		classesDirectories.add(0, this.testClassesDirectory);
		return classesDirectories;
	}
	@Override
	protected boolean isUseTestClasspath() {
		return true;
	}
	@Override
	protected RunArguments resolveJvmArguments() {
		RunArguments jvmArguments = super.resolveJvmArguments();
		if (this.optimizedLaunch) {
			jvmArguments.getArgs().addFirst('-XX:TieredStopAtLevel=1');
		}
		return jvmArguments;
	}
	@Override
	protected void run(JavaProcessExecutor processExecutor, File workingDirectory, List<String> args,
			Map<String, String> environmentVariables) throws MojoExecutionException, MojoFailureException {
		processExecutor
			.withRunProcessCustomizer(
					(runProcess) -> Runtime.getRuntime().addShutdownHook(new Thread(new RunProcessKiller(runProcess))))
			.run(workingDirectory, args, environmentVariables);
	}
	private static final class RunProcessKiller implements Runnable {
		private final RunProcess runProcess;
		private RunProcessKiller(RunProcess runProcess) {
			this.runProcess = runProcess;
		}
		@Override
		public void run() {
			this.runProcess.kill();
		}
	}
}
/*
package org.springframework.boot.maven;
/**
public abstract class AbstractAotMojo extends AbstractDependencyFilterMojo {
	/**
	 * The current Maven session. This is used for toolchain manager API calls.
	 */
	@Parameter(defaultValue = '${session}', readonly = true)
	private MavenSession session;
	/**
	 * The toolchain manager to use to locate a custom JDK.
	 */
	@Component
	private ToolchainManager toolchainManager;
	/**
	 * Skip the execution.
	 */
	@Parameter(property = 'spring-boot.aot.skip', defaultValue = 'false')
	private boolean skip;
	/**
	 * List of JVM system properties to pass to the AOT process.
	 */
	@Parameter
	private Map<String, String> systemPropertyVariables;
	/**
	 * JVM arguments that should be associated with the AOT process. On command line, make
	 * sure to wrap multiple values between quotes.
	 */
	@Parameter(property = 'spring-boot.aot.jvmArguments')
	private String jvmArguments;
	/**
	 * Arguments that should be provided to the AOT compile process. On command line, make
	 * sure to wrap multiple values between quotes.
	 */
	@Parameter(property = 'spring-boot.aot.compilerArguments')
	private String compilerArguments;
	/**
	 * Return Maven execution session.
	 * @return session
	 * @since 3.0.10
	 */
	protected final MavenSession getSession() {
		return this.session;
	}
	@Override
	public void execute() throws MojoExecutionException, MojoFailureException {
		if (this.skip) {
			getLog().debug('Skipping AOT execution as per configuration');
			return;
		}
		try {
			executeAot();
		}
		catch (Exception ex) {
			throw new MojoExecutionException(ex.getMessage(), ex);
		}
	}
	protected abstract void executeAot() throws Exception;
	protected void generateAotAssets(URL[] classPath, String processorClassName, String... arguments) throws Exception {
		List<String> command = CommandLineBuilder.forMainClass(processorClassName)
			.withSystemProperties(this.systemPropertyVariables)
			.withJvmArguments(new RunArguments(this.jvmArguments).asArray())
			.withClasspath(classPath)
			.withArguments(arguments)
			.build();
		if (getLog().isDebugEnabled()) {
			getLog().debug('Generating AOT assets using command: ' + command);
		}
		JavaProcessExecutor processExecutor = new JavaProcessExecutor(this.session, this.toolchainManager);
		processExecutor.run(this.project.getBasedir(), command, Collections.emptyMap());
	}
	protected final void compileSourceFiles(URL[] classPath, File sourcesDirectory, File outputDirectory)
			throws Exception {
		List<Path> sourceFiles;
		try (Stream<Path> pathStream = Files.walk(sourcesDirectory.toPath())) {
			sourceFiles = pathStream.filter(Files::isRegularFile).toList();
		}
		if (sourceFiles.isEmpty()) {
			return;
		}
		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
		try (StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null)) {
			JavaCompilerPluginConfiguration compilerConfiguration = new JavaCompilerPluginConfiguration(this.project);
			List<String> options = new ArrayList<>();
			options.add('-cp');
			options.add(ClasspathBuilder.build(Arrays.asList(classPath)));
			options.add('-d');
			options.add(outputDirectory.toPath().toAbsolutePath().toString());
			String releaseVersion = compilerConfiguration.getReleaseVersion();
			if (releaseVersion != null) {
				options.add('--release');
				options.add(releaseVersion);
			}
			else {
				String source = compilerConfiguration.getSourceMajorVersion();
				if (source != null) {
					options.add('--source');
					options.add(source);
				}
				String target = compilerConfiguration.getTargetMajorVersion();
				if (target != null) {
					options.add('--target');
					options.add(target);
				}
			}
			options.addAll(new RunArguments(this.compilerArguments).getArgs());
			Iterable<? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromPaths(sourceFiles);
			Errors errors = new Errors();
			CompilationTask task = compiler.getTask(null, fileManager, errors, options, null, compilationUnits);
			boolean result = task.call();
			if (!result || errors.hasReportedErrors()) {
				throw new IllegalStateException('Unable to compile generated source' + errors);
			}
		}
	}
	protected final URL[] getClassPath(File[] directories, ArtifactsFilter... artifactFilters)
			throws MojoExecutionException {
		List<URL> urls = new ArrayList<>();
		Arrays.stream(directories).map(this::toURL).forEach(urls::add);
		urls.addAll(getDependencyURLs(artifactFilters));
		return urls.toArray(URL[]::new);
	}
	protected final void copyAll(Path from, Path to) throws IOException {
		if (!Files.exists(from)) {
			return;
		}
		List<Path> files;
		try (Stream<Path> pathStream = Files.walk(from)) {
			files = pathStream.filter(Files::isRegularFile).toList();
		}
		for (Path file : files) {
			String relativeFileName = file.subpath(from.getNameCount(), file.getNameCount()).toString();
			getLog().debug('Copying "' + relativeFileName + '" to ' + to);
			Path target = to.resolve(relativeFileName);
			Files.createDirectories(target.getParent());
			Files.copy(file, target, StandardCopyOption.REPLACE_EXISTING);
		}
	}
	/**
	 * {@link DiagnosticListener} used to collect errors.
	 */
	protected static class Errors implements DiagnosticListener<JavaFileObject> {
		private final StringBuilder message = new StringBuilder();
		@Override
		public void report(Diagnostic<? extends JavaFileObject> diagnostic) {
			if (diagnostic.getKind() == Diagnostic.Kind.ERROR) {
				this.message.append('\n');
				this.message.append(diagnostic.getMessage(Locale.getDefault()));
				if (diagnostic.getSource() != null) {
					this.message.append(' ');
					this.message.append(diagnostic.getSource().getName());
					this.message.append(' ');
					this.message.append(diagnostic.getLineNumber()).append(':').append(diagnostic.getColumnNumber());
				}
			}
		}
		boolean hasReportedErrors() {
			return !this.message.isEmpty();
		}
		@Override
		public String toString() {
			return this.message.toString();
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		Class<?> appContext = null;
		try {
			appContext = Class.forName('org.springframework.context.ApplicationContext');
		}
		catch (ClassNotFoundException e) {
			throw new IllegalStateException('Test dependencies not added to classpath', e);
		}
		System.out.println('I haz been run');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		if (!readContent('one.txt').contains('1')) {
			throw new IllegalArgumentException('Invalid content for one.txt');
		}
		if (!readContent('another/two.txt').contains('2')) {
			throw new IllegalArgumentException('Invalid content for another/two.txt');
		}
		System.out.println('I haz been run');
	}
	private static String readContent(String location) {
		InputStream in = SampleApplication.class.getClassLoader().getResourceAsStream(location);
		if (in == null) {
			throw new IllegalArgumentException('Not found: "' + location + '"');
		}
		try (Scanner scanner = new Scanner(in, StandardCharsets.UTF_8)) {
			return scanner.useDelimiter('\\A').next();
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		System.out.println('I haz been run from "' + new File('').getAbsolutePath() + '"');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		System.out.println('I haz been run');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package smoketest.layout;
public class SampleLayoutFactory implements LayoutFactory {
	private String name = 'sample';
	public SampleLayoutFactory() {
	}
	public SampleLayoutFactory(String name) {
		this.name = name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	@Override
	public Layout getLayout(File source) {
		return new SampleLayout(this.name);
	}
}
/*
package smoketest.layout;
/**
public class SampleLayout extends Layouts.Jar implements CustomLoaderLayout {
	private String name;
	public SampleLayout(String name) {
		this.name = name;
	}
	@Override
	public void writeLoadedClasses(LoaderClassesWriter writer) throws IOException {
		writer.writeEntry(this.name, new ByteArrayInputStream('test'.getBytes()));
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@Profile('abc')
class TestProfileConfiguration {
	@Bean
	public String abc() {
		return 'abc';
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@Import(TestProfileConfiguration.class)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		if (args.length < 2) {
			throw new IllegalArgumentException('Missing arguments ' + Arrays.toString(args));
		}
		if (!args[0].startsWith('--management.endpoints.web.exposure.include=')) {
			throw new IllegalArgumentException('Invalid argument ' + args[0]);
		}
		if (!args[1].startsWith('--spring.profiles.active=')) {
			throw new IllegalArgumentException('Invalid argument ' + args[1]);
		}
		String endpoints = args[0].split('=')[1];
		String profile = args[1].split('=')[1];
		System.out.println('I haz been run with profile(s) "' + profile + '" and endpoint(s) "' + endpoints + '"');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		String foo = System.getProperty('foo');
		if (!'value 1'.equals(foo)) {
			throw new IllegalStateException('foo system property mismatch (got [' + foo + ']');
		}
		String bar = System.getProperty('bar');
		if (!'value2'.equals(bar)) {
			throw new IllegalStateException('bar system property mismatch (got [' + bar + ']');
		}
		System.out.println('I haz been run');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		String workingDirectory =  System.getProperty('user.dir');
		System.out.println(String.format('I haz been run from %s', workingDirectory));
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@ImportRuntimeHints(SampleApplicationRuntimeHints.class)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
	static class SampleApplicationRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			// Force creation of at least one JDK proxy
			hints.proxies().registerJdkProxy(AopProxyUtils.completeJdkProxyInterfaces(Service.class));
		}
	}
}
/*
 package org.test;
@SpringJUnitConfig
class SampleApplicationTests {
	@Autowired
	private MyBean myBean;
	@Test
	void contextLoads() {
		assertThat(this.myBean).isNotNull();
	}
	@Configuration
	static class MyConfig {
		@Bean
		MyBean myBean() {
			return new MyBean();
		}
	}
	static class MyBean {
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
/**
public class SampleApplication {
	private static final Object lock = new Object();
	public static void main(String[] args) throws Exception {
		MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
		ObjectName name = new ObjectName(
				'org.springframework.boot:type=Admin,name=SpringApplication');
		SpringApplicationAdmin mbean = new SpringApplicationAdmin();
		mbs.registerMBean(mbean, name);
		// Flag the app as ready
		mbean.ready = true;
		int waitAttempts = 0;
		while (!mbean.shutdownInvoked) {
			if (waitAttempts > 30) {
				throw new IllegalStateException(
						'Shutdown should have been invoked by now');
			}
			synchronized (lock) {
				lock.wait(250);
			}
			waitAttempts++;
		}
	}
	public interface SpringApplicationAdminMXBean {
		boolean isReady();
		void shutdown();
	}
	static final class SpringApplicationAdmin implements SpringApplicationAdminMXBean {
		private boolean ready;
		private boolean shutdownInvoked;
		@Override
		public boolean isReady() {
			System.out.println('isReady: ' + this.ready);
			return this.ready;
		}
		@Override
		public void shutdown() {
			this.shutdownInvoked = true;
			System.out.println('Shutdown requested');
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
module sampleApp {
	requires spring.context;
	requires spring.boot;
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		if (isClassPresent('org.apache.log4j.Logger')) {
			throw new IllegalStateException('Log4j was present and should not');
		}
		if (isClassPresent('jakarta.servlet.Servlet')) {
			throw new IllegalStateException('servlet-api was present and should not');
		}
		System.out.println('I haz been run');
	}
	private static boolean isClassPresent(String className) {
		try {
			ClassLoader classLoader = SampleApplication.class.getClassLoader();
			Class.forName(className, false, classLoader);
			return true;
		}
		catch (ClassNotFoundException e) {
			return false;
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		if (args.length < 2) {
			throw new IllegalArgumentException('Missing arguments ' + Arrays.toString(args));
		}
		if (!args[0].startsWith('--management.endpoints.web.exposure.include=')) {
			throw new IllegalArgumentException('Invalid argument ' + args[0]);
		}
		if (!args[1].startsWith('--spring.profiles.active=')) {
			throw new IllegalArgumentException('Invalid argument ' + args[1]);
		}
		String endpoints = args[0].split('=')[1];
		String profile = args[1].split('=')[1];
		System.out.println('I haz been run with profile(s) "' + profile + '" and endpoint(s) "' + endpoints + '"');
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@Profile('abc')
class TestProfileConfiguration {
	@Bean
	public String abc() {
		return 'abc';
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@Import(TestProfileConfiguration.class)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		if (args.length < 1) {
			throw new IllegalArgumentException('Missing active profile argument ' + Arrays.toString(args));
		}
		String argument = args[0];
		if (!argument.startsWith('--spring.profiles.active=')) {
			throw new IllegalArgumentException('Invalid argument ' + argument);
		}
		int index = args[0].indexOf("=");
		String profile = argument.substring(index + 1);
		System.out.println('I haz been run with profile(s) "' + profile + '"');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		String foo = System.getProperty('foo');
		if (!'value-from-cmd'.equals(foo)) {
			throw new IllegalStateException('foo system property mismatch (got [' + foo + ']');
		}
		System.out.println('I haz been run');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		String foo = System.getProperty('foo');
		if (!'value 1'.equals(foo)) {
			throw new IllegalStateException('foo system property mismatch (got [' + foo + ']');
		}
		String bar = System.getProperty('bar');
		if (!'value2'.equals(bar)) {
			throw new IllegalStateException('bar system property mismatch (got [' + bar + ']');
		}
		String property1 = System.getProperty('property1');
		if (!'value1'.equals(property1)) {
			throw new IllegalStateException('property1 system property mismatch (got [' + property1 + ']');
		}
		String property2 = System.getProperty('property2');
		if (!''.equals(property2)) {
			throw new IllegalStateException('property2 system property mismatch (got [' + property2 + ']');
		}
		String property3 = System.getProperty('property3');
		if (!'run-jvmargs'.equals(property3)) {
			throw new IllegalStateException('property3 system property mismatch (got [' + property3 + ']');
		}
		System.out.println('I haz been run');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		throw new IllegalStateException('Should not be called!');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class TestSampleApplication {
	public static void main(String[] args) {
		System.out.println('Main class name = ' + TestSampleApplication.class.getName());
		int i = 1;
		for (String entry : ManagementFactory.getRuntimeMXBean().getClassPath().split(File.pathSeparator)) {
			System.out.println(i++ + '. ' + entry);
		}
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		System.out.println('I haz been run');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		if (!readContent('one.txt').contains('1')) {
			throw new IllegalArgumentException('Invalid content for one.txt');
		}
		if (!readContent('another/two.txt').contains('2')) {
			throw new IllegalArgumentException('Invalid content for another/two.txt');
		}
		System.out.println('I haz been run');
	}
	private static String readContent(String location) {
		InputStream in = SampleApplication.class.getClassLoader().getResourceAsStream(location);
		if (in == null) {
			throw new IllegalArgumentException('Not found: "' + location + '"');
		}
		try (Scanner scanner = new Scanner(in, StandardCharsets.UTF_8)) {
			return scanner.useDelimiter('\\A').next();
		}
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@ComponentScan
@EnableAsync
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}/*
package org.test;
@Component
public class SampleRunner {
	@Async
	public void run() {
	}
}
/*
package org.test;
class ResourceRegisteringAotProcessor implements BeanFactoryInitializationAotProcessor {
	@Override
	public BeanFactoryInitializationAotContribution processAheadOfTime(ConfigurableListableBeanFactory beanFactory) {
		return new BeanFactoryInitializationAotContribution() {
			@Override
			public void applyTo(GenerationContext generationContext,
					BeanFactoryInitializationCode beanFactoryInitializationCode) {
				generationContext.getGeneratedFiles().addResourceFile('generated-resource', 'content');
				generationContext.getGeneratedFiles().addResourceFile('nested/generated-resource', 'nested content');
			}
		};
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
/**
public class SampleApplication {
	public static void main(String[] args) throws Exception {
		System.out.println('Ooops, I haz been run');
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		assertEnvValue('ENV1', '5000');
		assertEnvValue('ENV2', 'Some Text');
		assertEnvValue('ENV3', '');
		assertEnvValue('ENV4', '');
		System.out.println('I haz been run');
	}
	private static void assertEnvValue(String envKey, String expectedValue) {
		String actual = System.getenv(envKey);
		if (!expectedValue.equals(actual)) {
			throw new IllegalStateException('env property [' + envKey + '] mismatch '
					+ '(got [' + actual + '], expected [' + expectedValue + ']');
		}
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@Profile('abc')
class TestProfileConfiguration {
	@Bean
	public String abc() {
		return 'abc';
	}
}
/*
package org.test;
@Configuration(proxyBeanMethods = false)
@Import(TestProfileConfiguration.class)
public class SampleApplication {
	public static void main(String[] args) {
		SpringApplication.run(SampleApplication.class, args);
	}
}
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
	}
}
/*
package org.springframework.boot.maven;
/**
class Versions {
	private final Map<String, String> versions;
	Versions() {
		this.versions = loadVersions();
	}
	private static Map<String, String> loadVersions() {
		try (InputStream input = Versions.class.getClassLoader().getResourceAsStream('extracted-versions.properties')) {
			Properties properties = new Properties();
			properties.load(input);
			Map<String, String> versions = new HashMap<>();
			properties.forEach((key, value) -> versions.put((String) key, (String) value));
			return versions;
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	String get(String name) {
		return this.versions.get(name);
	}
	Map<String, String> asMap() {
		return Collections.unmodifiableMap(this.versions);
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
class AotTests {
	@TestTemplate
	void whenAotRunsSourcesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('aot').goals('package').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/main');
			assertThat(collectRelativePaths(aotDirectory.resolve('sources')))
				.contains(Path.of('org', 'test', 'SampleApplication__ApplicationContextInitializer.java'));
		});
	}
	@TestTemplate
	void whenAotRunsResourcesAreGeneratedAndCopiedToTargetClasses(MavenBuild mavenBuild) {
		mavenBuild.project('aot-resource-generation').goals('package').execute((project) -> {
			Path targetClasses = project.toPath().resolve('target/classes');
			assertThat(collectRelativePaths(targetClasses)).contains(
					Path.of('META-INF', 'native-image', 'org.springframework.boot.maven.it', 'aot-resource-generation',
							'reflect-config.json'),
					Path.of('META-INF', 'native-image', 'org.springframework.boot.maven.it', 'aot-resource-generation',
							'resource-config.json'),
					Path.of('META-INF', 'native-image', 'org.springframework.boot.maven.it', 'aot-resource-generation',
							'native-image.properties'),
					Path.of('generated-resource'), Path.of('nested/generated-resource'));
		});
	}
	@TestTemplate
	void whenAotRunsWithJdkProxyResourcesIncludeProxyConfig(MavenBuild mavenBuild) {
		mavenBuild.project('aot-jdk-proxy').goals('package').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/main');
			assertThat(collectRelativePaths(aotDirectory.resolve('resources'))).contains(
					Path.of('META-INF', 'native-image', 'org.springframework.boot.maven.it', 'aot-jdk-proxy',
							'reflect-config.json'),
					Path.of('META-INF', 'native-image', 'org.springframework.boot.maven.it', 'aot-jdk-proxy',
							'resource-config.json'),
					Path.of('META-INF', 'native-image', 'org.springframework.boot.maven.it', 'aot-jdk-proxy',
							'proxy-config.json'),
					Path.of('META-INF', 'native-image', 'org.springframework.boot.maven.it', 'aot-jdk-proxy',
							'native-image.properties'));
		});
	}
	@TestTemplate
	void whenAotRunsWithClassProxyClassesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('aot-class-proxy').goals('package').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/main');
			assertThat(collectRelativePaths(aotDirectory.resolve('classes')))
				.contains(Path.of('org', 'test', 'SampleRunner$$SpringCGLIB$$0.class'));
		});
	}
	@TestTemplate
	void whenAotRunsWithProfilesSourcesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('aot-profile').goals('package').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/main');
			assertThat(collectRelativePaths(aotDirectory.resolve('sources')))
				.contains(Path.of('org', 'test', 'TestProfileConfiguration__BeanDefinitions.java'));
		});
	}
	@TestTemplate
	void whenAotRunsWithArgumentsSourcesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('aot-arguments').goals('package').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/main');
			assertThat(collectRelativePaths(aotDirectory.resolve('sources')))
				.contains(Path.of('org', 'test', 'TestProfileConfiguration__BeanDefinitions.java'));
		});
	}
	@TestTemplate
	void whenAotRunsWithJvmArgumentsSourcesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('aot-jvm-arguments').goals('package').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/main');
			assertThat(collectRelativePaths(aotDirectory.resolve('sources')))
				.contains(Path.of('org', 'test', 'TestProfileConfiguration__BeanDefinitions.java'));
		});
	}
	@TestTemplate
	void whenAotRunsWithReleaseSourcesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('aot-release').goals('package').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/main');
			assertThat(collectRelativePaths(aotDirectory.resolve('sources')))
				.contains(Path.of('org', 'test', 'SampleApplication__ApplicationContextInitializer.java'));
		});
	}
	@TestTemplate
	void whenAotRunsWithInvalidCompilerArgumentsCompileFails(MavenBuild mavenBuild) {
		mavenBuild.project('aot-compiler-arguments')
			.goals('package')
			.executeAndFail(
					(project) -> assertThat(buildLog(project)).contains('invalid flag: --invalid-compiler-arg'));
	}
	@TestTemplate
	void whenAotRunsSourcesAreCompiledAndMovedToTargetClasses(MavenBuild mavenBuild) {
		mavenBuild.project('aot').goals('package').execute((project) -> {
			Path classesDirectory = project.toPath().resolve('target/classes');
			assertThat(collectRelativePaths(classesDirectory))
				.contains(Path.of('org', 'test', 'SampleApplication__ApplicationContextInitializer.class'));
		});
	}
	@TestTemplate
	void whenAotRunsWithModuleInfoSourcesAreCompiledAndMovedToTargetClass(MavenBuild mavenBuild) {
		mavenBuild.project('aot-module-info').goals('package').execute((project) -> {
			Path classesDirectory = project.toPath().resolve('target/classes');
			assertThat(collectRelativePaths(classesDirectory))
				.contains(Path.of('org', 'test', 'SampleApplication__ApplicationContextInitializer.class'));
		});
	}
	@TestTemplate
	void whenAotRunsResourcesAreCopiedToTargetClasses(MavenBuild mavenBuild) {
		mavenBuild.project('aot-jdk-proxy').goals('package').execute((project) -> {
			Path classesDirectory = project.toPath().resolve('target/classes/META-INF/native-image');
			assertThat(collectRelativePaths(classesDirectory)).contains(
					Path.of('org.springframework.boot.maven.it', 'aot-jdk-proxy', 'reflect-config.json'),
					Path.of('org.springframework.boot.maven.it', 'aot-jdk-proxy', 'resource-config.json'),
					Path.of('org.springframework.boot.maven.it', 'aot-jdk-proxy', 'proxy-config.json'),
					Path.of('org.springframework.boot.maven.it', 'aot-jdk-proxy', 'native-image.properties'));
		});
	}
	@TestTemplate
	void whenAotRunsWithClassProxyClassesAreCopiedToTargetClasses(MavenBuild mavenBuild) {
		mavenBuild.project('aot-class-proxy').goals('package').execute((project) -> {
			Path classesDirectory = project.toPath().resolve('target/classes/');
			assertThat(collectRelativePaths(classesDirectory))
				.contains(Path.of('org', 'test', 'SampleRunner$$SpringCGLIB$$0.class'));
		});
	}
	@TestTemplate
	void whenAotTestRunsSourcesAndResourcesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('aot-test').goals('test').execute((project) -> {
			Path aotDirectory = project.toPath().resolve('target/spring-aot/test');
			assertThat(collectRelativePaths(aotDirectory.resolve('sources'))).contains(Path.of('org', 'test',
					'SampleApplicationTests__TestContext001_ApplicationContextInitializer.java'));
			Path testClassesDirectory = project.toPath().resolve('target/test-classes');
			assertThat(collectRelativePaths(testClassesDirectory)).contains(Path.of('META-INF', 'native-image',
					'org.springframework.boot.maven.it', 'aot-test', 'reflect-config.json'));
			assertThat(collectRelativePaths(testClassesDirectory)).contains(Path.of('org', 'test',
					'SampleApplicationTests__TestContext001_ApplicationContextInitializer.class'));
		});
	}
	List<Path> collectRelativePaths(Path sourceDirectory) {
		try (Stream<Path> pathStream = Files.walk(sourceDirectory)) {
			return pathStream.filter(Files::isRegularFile)
				.map((path) -> path.subpath(sourceDirectory.getNameCount(), path.getNameCount()))
				.toList();
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	protected String buildLog(File project) {
		return contentOf(new File(project, 'target/build.log'));
	}
}
/*
package org.springframework.boot.maven;
/**
abstract class AbstractArchiveIntegrationTests {
	protected String buildLog(File project) {
		return contentOf(new File(project, 'target/build.log'));
	}
	protected String launchScript(File jar) {
		String content = contentOf(jar);
		return content.substring(0, content.indexOf(new String(new byte[] { 0x50, 0x4b, 0x03, 0x04 })));
	}
	protected AssertProvider<JarAssert> jar(File file) {
		return new AssertProvider<>() {
			@Override
			@Deprecated(since = '2.3.0', forRemoval = false)
			public JarAssert assertThat() {
				return new JarAssert(file);
			}
		};
	}
	protected Map<String, List<String>> readLayerIndex(JarFile jarFile) throws IOException {
		if (getLayersIndexLocation() == null) {
			return Collections.emptyMap();
		}
		Map<String, List<String>> index = new LinkedHashMap<>();
		String layerPrefix = '- ';
		String entryPrefix = '  - ';
		ZipEntry indexEntry = jarFile.getEntry(getLayersIndexLocation());
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(jarFile.getInputStream(indexEntry)))) {
			String line = reader.readLine();
			String layer = null;
			while (line != null) {
				if (line.startsWith(layerPrefix)) {
					layer = line.substring(layerPrefix.length() + 1, line.length() - 2);
					index.put(layer, new ArrayList<>());
				}
				else if (line.startsWith(entryPrefix)) {
					index.computeIfAbsent(layer, (key) -> new ArrayList<>())
						.add(line.substring(entryPrefix.length() + 1, line.length() - 1));
				}
				line = reader.readLine();
			}
			return index;
		}
	}
	protected String getLayersIndexLocation() {
		return null;
	}
	protected List<String> readClasspathIndex(JarFile jarFile, String location) throws IOException {
		List<String> index = new ArrayList<>();
		String entryPrefix = '- ';
		ZipEntry indexEntry = jarFile.getEntry(location);
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(jarFile.getInputStream(indexEntry)))) {
			String line = reader.readLine();
			while (line != null) {
				if (line.startsWith(entryPrefix)) {
					index.add(line.substring(entryPrefix.length() + 1, line.length() - 1));
				}
				line = reader.readLine();
			}
		}
		return index;
	}
	static final class JarAssert extends AbstractAssert<JarAssert, File> {
		private JarAssert(File actual) {
			super(actual, JarAssert.class);
			assertThat(actual).exists();
		}
		JarAssert doesNotHaveEntryWithName(String name) {
			withJarFile((jarFile) -> {
				withEntries(jarFile, (entries) -> {
					Optional<JarEntry> match = entries.filter((entry) -> entry.getName().equals(name)).findFirst();
					assertThat(match).isNotPresent();
				});
			});
			return this;
		}
		JarAssert hasEntryWithName(String name) {
			withJarFile((jarFile) -> {
				withEntries(jarFile, (entries) -> {
					Optional<JarEntry> match = entries.filter((entry) -> entry.getName().equals(name)).findFirst();
					assertThat(match).hasValueSatisfying((entry) -> assertThat(entry.getComment()).isNull());
				});
			});
			return this;
		}
		JarAssert hasEntryWithNameStartingWith(String prefix) {
			withJarFile((jarFile) -> {
				withEntries(jarFile, (entries) -> {
					Optional<JarEntry> match = entries.filter((entry) -> entry.getName().startsWith(prefix))
						.findFirst();
					assertThat(match).hasValueSatisfying((entry) -> assertThat(entry.getComment()).isNull());
				});
			});
			return this;
		}
		JarAssert hasUnpackEntryWithNameStartingWith(String prefix) {
			withJarFile((jarFile) -> {
				withEntries(jarFile, (entries) -> {
					Optional<JarEntry> match = entries.filter((entry) -> entry.getName().startsWith(prefix))
						.findFirst();
					assertThat(match).as('Name starting with %s', prefix)
						.hasValueSatisfying((entry) -> assertThat(entry.getComment()).startsWith('UNPACK:'));
				});
			});
			return this;
		}
		JarAssert doesNotHaveEntryWithNameStartingWith(String prefix) {
			withJarFile((jarFile) -> {
				withEntries(jarFile, (entries) -> {
					Optional<JarEntry> match = entries.filter((entry) -> entry.getName().startsWith(prefix))
						.findFirst();
					assertThat(match).isNotPresent();
				});
			});
			return this;
		}
		ListAssert<String> entryNamesInPath(String path) {
			List<String> matches = new ArrayList<>();
			withJarFile((jarFile) -> withEntries(jarFile,
					(entries) -> matches.addAll(entries.map(ZipEntry::getName)
						.filter((name) -> name.startsWith(path) && name.length() > path.length())
						.toList())));
			return new ListAssert<>(matches);
		}
		JarAssert manifest(Consumer<ManifestAssert> consumer) {
			withJarFile((jarFile) -> {
				try {
					consumer.accept(new ManifestAssert(jarFile.getManifest()));
				}
				catch (IOException ex) {
					throw new RuntimeException(ex);
				}
			});
			return this;
		}
		void withJarFile(Consumer<JarFile> consumer) {
			try (JarFile jarFile = new JarFile(this.actual)) {
				consumer.accept(jarFile);
			}
			catch (Exception ex) {
				throw new RuntimeException(ex);
			}
		}
		void withEntries(JarFile jarFile, Consumer<Stream<JarEntry>> entries) {
			entries.accept(Collections.list(jarFile.entries()).stream());
		}
		static final class ManifestAssert extends AbstractAssert<ManifestAssert, Manifest> {
			private ManifestAssert(Manifest actual) {
				super(actual, ManifestAssert.class);
			}
			ManifestAssert hasStartClass(String expected) {
				assertThat(this.actual.getMainAttributes().getValue('Start-Class')).isEqualTo(expected);
				return this;
			}
			ManifestAssert hasMainClass(String expected) {
				assertThat(this.actual.getMainAttributes().getValue('Main-Class')).isEqualTo(expected);
				return this;
			}
			ManifestAssert hasAttribute(String name, String value) {
				assertThat(this.actual.getMainAttributes().getValue(name)).isEqualTo(value);
				return this;
			}
			ManifestAssert doesNotHaveAttribute(String name) {
				assertThat(this.actual.getMainAttributes().getValue(name)).isNull();
				return this;
			}
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
class TestRunIntegrationTests {
	@TestTemplate
	void whenTheTestRunGoalIsExecutedTheApplicationIsRunWithTestAndMainClassesAndTestClasspath(MavenBuild mavenBuild) {
		mavenBuild.project('test-run')
			.goals('spring-boot:test-run', '-X')
			.execute((project) -> assertThat(buildLog(project))
				.contains('Main class name = org.test.TestSampleApplication')
				.contains('1. ' + canonicalPathOf(project, 'target/test-classes'))
				.contains('2. ' + canonicalPathOf(project, 'target/classes'))
				.containsPattern('3\\. .*spring-core')
				.containsPattern('4\\. .*spring-jcl'));
	}
	private String canonicalPathOf(File project, String path) throws IOException {
		return new File(project, path).getCanonicalPath();
	}
	private String buildLog(File project) {
		return contentOf(new File(project, 'target/build.log'));
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
class RunIntegrationTests {
	@TestTemplate
	void whenTheRunGoalIsExecutedTheApplicationIsForkedWithOptimizedJvmArguments(MavenBuild mavenBuild) {
		mavenBuild.project('run').goals('spring-boot:run', '-X').execute((project) -> {
			String jvmArguments = 'JVM argument: -XX:TieredStopAtLevel=1';
			assertThat(buildLog(project)).contains('I haz been run').contains(jvmArguments);
		});
	}
	@TestTemplate
	void whenEnvironmentVariablesAreConfiguredTheyAreAvailableToTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-envargs')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenExclusionsAreConfiguredExcludedDependenciesDoNotAppearOnTheClasspath(MavenBuild mavenBuild) {
		mavenBuild.project('run-exclude')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenSystemPropertiesAndJvmArgumentsAreConfiguredTheyAreAvailableToTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-jvm-system-props')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenJvmArgumentsAreConfiguredTheyAreAvailableToTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-jvmargs')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenCommandLineSpecifiesJvmArgumentsTheyAreAvailableToTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-jvmargs-commandline')
			.goals('spring-boot:run')
			.systemProperty('spring-boot.run.jvmArguments', '-Dfoo=value-from-cmd')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenPomAndCommandLineSpecifyJvmArgumentsThenPomOverrides(MavenBuild mavenBuild) {
		mavenBuild.project('run-jvmargs')
			.goals('spring-boot:run')
			.systemProperty('spring-boot.run.jvmArguments', '-Dfoo=value-from-cmd')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenProfilesAreConfiguredTheyArePassedToTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-profiles')
			.goals('spring-boot:run', '-X')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run with profile(s) "foo,bar"'));
	}
	@TestTemplate
	void whenUseTestClasspathIsEnabledTheApplicationHasTestDependenciesOnItsClasspath(MavenBuild mavenBuild) {
		mavenBuild.project('run-use-test-classpath')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenAWorkingDirectoryIsConfiguredTheApplicationIsRunFromThatDirectory(MavenBuild mavenBuild) {
		mavenBuild.project('run-working-directory')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).containsPattern('I haz been run from.*src.main.java'));
	}
	@TestTemplate
	void whenAdditionalClasspathDirectoryIsConfiguredItsResourcesAreAvailableToTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-additional-classpath-directory')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	void whenAdditionalClasspathFileIsConfiguredItsContentIsAvailableToTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-additional-classpath-jar')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project)).contains('I haz been run'));
	}
	@TestTemplate
	@DisabledOnOs(OS.WINDOWS)
	void whenAToolchainIsConfiguredItIsUsedToRunTheApplication(MavenBuild mavenBuild) {
		mavenBuild.project('run-toolchains')
			.goals('verify', '-t', 'toolchains.xml')
			.execute((project) -> assertThat(buildLog(project)).contains('The Maven Toolchains is awesome!'));
	}
	@TestTemplate
	void whenPomSpecifiesRunArgumentsContainingCommasTheyArePassedToTheApplicationCorrectly(MavenBuild mavenBuild) {
		mavenBuild.project('run-arguments')
			.goals('spring-boot:run')
			.execute((project) -> assertThat(buildLog(project))
				.contains('I haz been run with profile(s) "foo,bar" and endpoint(s) "prometheus,info"'));
	}
	@TestTemplate
	void whenCommandLineSpecifiesRunArgumentsContainingCommasTheyArePassedToTheApplicationCorrectly(
			MavenBuild mavenBuild) {
		mavenBuild.project('run-arguments-commandline')
			.goals('spring-boot:run')
			.systemProperty('spring-boot.run.arguments',
					'--management.endpoints.web.exposure.include=prometheus,info,health,metrics --spring.profiles.active=foo,bar')
			.execute((project) -> assertThat(buildLog(project))
				.contains('I haz been run with profile(s) "foo,bar" and endpoint(s) "prometheus,info,health,metrics"'));
	}
	@TestTemplate
	void whenPomAndCommandLineSpecifyRunArgumentsThenPomOverrides(MavenBuild mavenBuild) {
		mavenBuild.project('run-arguments')
			.goals('spring-boot:run')
			.systemProperty('spring-boot.run.arguments',
					'--management.endpoints.web.exposure.include=one,two,three --spring.profiles.active=test')
			.execute((project) -> assertThat(buildLog(project))
				.contains('I haz been run with profile(s) "foo,bar" and endpoint(s) "prometheus,info"'));
	}
	private String buildLog(File project) {
		return contentOf(new File(project, 'target/build.log'));
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
class BuildInfoIntegrationTests {
	@TestTemplate
	void buildInfoPropertiesAreGenerated(MavenBuild mavenBuild) {
		mavenBuild.project('build-info')
			.execute(buildInfo((buildInfo) -> assertThat(buildInfo).hasBuildGroup('org.springframework.boot.maven.it')
				.hasBuildArtifact('build-info')
				.hasBuildName('Generate build info')
				.hasBuildVersion('0.0.1.BUILD-SNAPSHOT')
				.containsBuildTime()));
	}
	@TestTemplate
	void generatedBuildInfoIncludesAdditionalProperties(MavenBuild mavenBuild) {
		mavenBuild.project('build-info-additional-properties')
			.execute(buildInfo((buildInfo) -> assertThat(buildInfo).hasBuildGroup('org.springframework.boot.maven.it')
				.hasBuildArtifact('build-info-additional-properties')
				.hasBuildName('Generate build info with additional properties')
				.hasBuildVersion('0.0.1.BUILD-SNAPSHOT')
				.containsBuildTime()
				.containsEntry('build.foo', 'bar')
				.containsEntry('build.encoding', 'UTF-8')
				.containsEntry('build.java.source', '1.8')));
	}
	@TestTemplate
	void generatedBuildInfoUsesCustomBuildTime(MavenBuild mavenBuild) {
		mavenBuild.project('build-info-custom-build-time')
			.execute(buildInfo((buildInfo) -> assertThat(buildInfo).hasBuildGroup('org.springframework.boot.maven.it')
				.hasBuildArtifact('build-info-custom-build-time')
				.hasBuildName('Generate build info with custom build time')
				.hasBuildVersion('0.0.1.BUILD-SNAPSHOT')
				.hasBuildTime('2019-07-08T08:00:00Z')));
	}
	@TestTemplate
	void generatedBuildInfoReproducible(MavenBuild mavenBuild) {
		mavenBuild.project('build-info-reproducible')
			.execute(buildInfo((buildInfo) -> assertThat(buildInfo).hasBuildGroup('org.springframework.boot.maven.it')
				.hasBuildArtifact('build-reproducible')
				.hasBuildName('Generate build info with build time from project.build.outputTimestamp')
				.hasBuildVersion('0.0.1.BUILD-SNAPSHOT')
				.hasBuildTime('2021-04-21T11:22:33Z')));
	}
	@TestTemplate
	void buildInfoPropertiesAreGeneratedToCustomOutputLocation(MavenBuild mavenBuild) {
		mavenBuild.project('build-info-custom-file')
			.execute(buildInfo('target/build.info',
					(buildInfo) -> assertThat(buildInfo).hasBuildGroup('org.springframework.boot.maven.it')
						.hasBuildArtifact('build-info-custom-file')
						.hasBuildName('Generate custom build info')
						.hasBuildVersion('0.0.1.BUILD-SNAPSHOT')
						.containsBuildTime()));
	}
	@TestTemplate
	void whenBuildTimeIsDisabledIfDoesNotAppearInGeneratedBuildInfo(MavenBuild mavenBuild) {
		mavenBuild.project('build-info-disable-build-time')
			.execute(buildInfo((buildInfo) -> assertThat(buildInfo).hasBuildGroup('org.springframework.boot.maven.it')
				.hasBuildArtifact('build-info-disable-build-time')
				.hasBuildName('Generate build info with disabled build time')
				.hasBuildVersion('0.0.1.BUILD-SNAPSHOT')
				.doesNotContainBuildTime()));
	}
	@TestTemplate
	void whenBuildTimeIsExcludedIfDoesNotAppearInGeneratedBuildInfo(MavenBuild mavenBuild) {
		mavenBuild.project('build-info-exclude-build-time')
			.execute(buildInfo((buildInfo) -> assertThat(buildInfo).hasBuildGroup('org.springframework.boot.maven.it')
				.hasBuildArtifact('build-info-exclude-build-time')
				.hasBuildName('Generate build info with excluded build time')
				.hasBuildVersion('0.0.1.BUILD-SNAPSHOT')
				.doesNotContainBuildTime()));
	}
	@TestTemplate
	void whenBuildPropertiesAreExcludedTheyDoNotAppearInGeneratedBuildInfo(MavenBuild mavenBuild) {
		mavenBuild.project('build-info-exclude-build-properties')
			.execute(buildInfo((buildInfo) -> assertThat(buildInfo).doesNotContainBuildGroup()
				.doesNotContainBuildArtifact()
				.doesNotContainBuildName()
				.doesNotContainBuildVersion()
				.containsBuildTime()));
	}
	private ProjectCallback buildInfo(Consumer<AssertProvider<BuildInfoAssert>> buildInfo) {
		return buildInfo('target/classes/META-INF/build-info.properties', buildInfo);
	}
	private ProjectCallback buildInfo(String location, Consumer<AssertProvider<BuildInfoAssert>> buildInfo) {
		return (project) -> buildInfo.accept((buildInfo(project, location)));
	}
	private AssertProvider<BuildInfoAssert> buildInfo(File project, String buildInfo) {
		return new AssertProvider<>() {
			@Override
			@Deprecated(since = '2.3.0', forRemoval = false)
			public BuildInfoAssert assertThat() {
				return new BuildInfoAssert(new File(project, buildInfo));
			}
		};
	}
	private static final class BuildInfoAssert extends AbstractMapAssert<BuildInfoAssert, Properties, Object, Object> {
		private BuildInfoAssert(File actual) {
			super(loadProperties(actual), BuildInfoAssert.class);
		}
		private static Properties loadProperties(File file) {
			try (FileReader reader = new FileReader(file)) {
				Properties properties = new Properties();
				properties.load(reader);
				return properties;
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
		}
		BuildInfoAssert hasBuildGroup(String expected) {
			return containsEntry('build.group', expected);
		}
		BuildInfoAssert doesNotContainBuildGroup() {
			return doesNotContainKey('build.group');
		}
		BuildInfoAssert hasBuildArtifact(String expected) {
			return containsEntry('build.artifact', expected);
		}
		BuildInfoAssert doesNotContainBuildArtifact() {
			return doesNotContainKey('build.artifact');
		}
		BuildInfoAssert hasBuildName(String expected) {
			return containsEntry('build.name', expected);
		}
		BuildInfoAssert doesNotContainBuildName() {
			return doesNotContainKey('build.name');
		}
		BuildInfoAssert hasBuildVersion(String expected) {
			return containsEntry('build.version', expected);
		}
		BuildInfoAssert doesNotContainBuildVersion() {
			return doesNotContainKey('build.version');
		}
		BuildInfoAssert containsBuildTime() {
			return containsKey('build.time');
		}
		BuildInfoAssert doesNotContainBuildTime() {
			return doesNotContainKey('build.time');
		}
		BuildInfoAssert hasBuildTime(String expected) {
			return containsEntry('build.time', expected);
		}
	}
}
/*
package org.springframework.boot.maven;
/**
class MavenBuild {
	private final File home;
	private final File temp;
	private final Map<String, String> pomReplacements;
	private final List<String> goals = new ArrayList<>();
	private final Properties properties = new Properties();
	private ProjectCallback preparation;
	private File projectDir;
	MavenBuild(File home) {
		this.home = home;
		this.temp = createTempDirectory();
		this.pomReplacements = getPomReplacements();
	}
	private File createTempDirectory() {
		try {
			return Files.createTempDirectory('maven-build').toFile().getCanonicalFile();
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private Map<String, String> getPomReplacements() {
		Map<String, String> replacements = new HashMap<>();
		replacements.put('java.version', '17');
		replacements.put('project.groupId', 'org.springframework.boot');
		replacements.put('project.artifactId', 'spring-boot-maven-plugin');
		replacements.putAll(new Versions().asMap());
		return Collections.unmodifiableMap(replacements);
	}
	MavenBuild project(String project) {
		return project('intTest', project);
	}
	MavenBuild project(String root, String project) {
		this.projectDir = new File('src/' + root + '/projects/' + project);
		return this;
	}
	MavenBuild goals(String... goals) {
		this.goals.addAll(Arrays.asList(goals));
		return this;
	}
	MavenBuild systemProperty(String name, String value) {
		this.properties.setProperty(name, value);
		return this;
	}
	MavenBuild prepare(ProjectCallback callback) {
		this.preparation = callback;
		return this;
	}
	void execute(ProjectCallback callback) {
		execute(callback, 0);
	}
	void executeAndFail(ProjectCallback callback) {
		execute(callback, 1);
	}
	private void execute(ProjectCallback callback, int expectedExitCode) {
		Invoker invoker = new DefaultInvoker();
		invoker.setMavenHome(this.home);
		InvocationRequest request = new DefaultInvocationRequest();
		try {
			Path destination = this.temp.toPath();
			Path source = this.projectDir.toPath();
			Files.walkFileTree(source, new SimpleFileVisitor<>() {
				@Override
				public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
					Files.createDirectories(destination.resolve(source.relativize(dir)));
					return FileVisitResult.CONTINUE;
				}
				@Override
				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
					if (file.toFile().getName().equals('pom.xml')) {
						String pomXml = Files.readString(file);
						for (Entry<String, String> replacement : MavenBuild.this.pomReplacements.entrySet()) {
							pomXml = pomXml.replace('@' + replacement.getKey() + '@', replacement.getValue());
						}
						Files.writeString(destination.resolve(source.relativize(file)), pomXml,
								StandardOpenOption.CREATE_NEW);
					}
					else {
						Files.copy(file, destination.resolve(source.relativize(file)),
								StandardCopyOption.REPLACE_EXISTING);
					}
					return FileVisitResult.CONTINUE;
				}
			});
			String settingsXml = Files.readString(Paths.get('build', 'generated-resources', 'settings', 'settings.xml'))
				.replace('@localCentralUrl@', new File('build/test-maven-repository').toURI().toURL().toString())
				.replace('@localRepositoryPath@', new File('build/local-maven-repository').getAbsolutePath());
			Files.writeString(destination.resolve('settings.xml'), settingsXml, StandardOpenOption.CREATE_NEW);
			request.setBaseDirectory(this.temp);
			request.setJavaHome(new File(System.getProperty('java.home')));
			request.setProperties(this.properties);
			request.setGoals(this.goals.isEmpty() ? Collections.singletonList('package') : this.goals);
			request.setUserSettingsFile(new File(this.temp, 'settings.xml'));
			request.setUpdateSnapshots(true);
			request.setBatchMode(true);
			// request.setMavenOpts('-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=8000');
			File target = new File(this.temp, 'target');
			target.mkdirs();
			if (this.preparation != null) {
				this.preparation.doWith(this.temp);
			}
			File buildLogFile = new File(target, 'build.log');
			try (PrintWriter buildLog = new PrintWriter(new FileWriter(buildLogFile))) {
				request.setOutputHandler((line) -> {
					buildLog.println(line);
					buildLog.flush();
				});
				try {
					InvocationResult result = invoker.execute(request);
					assertThat(result.getExitCode()).as(contentOf(buildLogFile)).isEqualTo(expectedExitCode);
				}
				catch (MavenInvocationException ex) {
					throw new RuntimeException(ex);
				}
			}
			callback.doWith(this.temp);
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
		finally {
			FileSystemUtils.deleteRecursively(this.temp);
		}
	}
	/**
	 * Action to take on a maven project directory.
	 */
	@FunctionalInterface
	public interface ProjectCallback {
		/**
		 * Take the action on the given project.
		 * @param project the project directory
		 * @throws Exception on error
		 */
		void doWith(File project) throws Exception;
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
class StartStopIntegrationTests {
	@TestTemplate
	void startStopWaitsForApplicationToBeReadyAndThenRequestsShutdown(MavenBuild mavenBuild) {
		mavenBuild.project('start-stop')
			.goals('verify')
			.execute((project) -> assertThat(buildLog(project)).contains('isReady: true')
				.contains('Shutdown requested'));
	}
	@TestTemplate
	void whenSkipIsTrueStartAndStopAreSkipped(MavenBuild mavenBuild) {
		mavenBuild.project('start-stop-skip')
			.goals('verify')
			.execute((project) -> assertThat(buildLog(project)).doesNotContain('Ooops, I haz been run')
				.doesNotContain('Stopping application'));
	}
	private String buildLog(File project) {
		return contentOf(new File(project, 'target/build.log'));
	}
}
/*
package org.springframework.boot.maven;
/**
class MavenBuildExtension implements TestTemplateInvocationContextProvider {
	@Override
	public boolean supportsTestTemplate(ExtensionContext context) {
		return true;
	}
	@Override
	public Stream<TestTemplateInvocationContext> provideTestTemplateInvocationContexts(ExtensionContext context) {
		try {
			// Returning a stream which must be closed here is fine, as JUnit will take
			// care of closing it
			return Files.list(Paths.get('build/maven-binaries')).map(MavenVersionTestTemplateInvocationContext::new);
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	private static final class MavenVersionTestTemplateInvocationContext implements TestTemplateInvocationContext {
		private final Path mavenHome;
		private MavenVersionTestTemplateInvocationContext(Path mavenHome) {
			this.mavenHome = mavenHome;
		}
		@Override
		public String getDisplayName(int invocationIndex) {
			return this.mavenHome.getFileName().toString();
		}
		@Override
		public List<Extension> getAdditionalExtensions() {
			return Arrays.asList(new MavenBuildParameterResolver(this.mavenHome));
		}
	}
	private static final class MavenBuildParameterResolver implements ParameterResolver {
		private final Path mavenHome;
		private MavenBuildParameterResolver(Path mavenHome) {
			this.mavenHome = mavenHome;
		}
		@Override
		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			return parameterContext.getParameter().getType().equals(MavenBuild.class);
		}
		@Override
		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
			return new MavenBuild(this.mavenHome.toFile());
		}
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
class JarIntegrationTests extends AbstractArchiveIntegrationTests {
	@Override
	protected String getLayersIndexLocation() {
		return 'BOOT-INF/layers.idx';
	}
	@TestTemplate
	void whenJarIsRepackagedInPlaceOnlyRepackagedJarIsInstalled(MavenBuild mavenBuild) {
		mavenBuild.project('jar').goals('install').execute((project) -> {
			File original = new File(project, 'target/jar-0.0.1.BUILD-SNAPSHOT.jar.original');
			assertThat(original).isFile();
			File repackaged = new File(project, 'target/jar-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(launchScript(repackaged)).isEmpty();
			assertThat(jar(repackaged)).manifest((manifest) -> {
				manifest.hasMainClass('org.springframework.boot.loader.launch.JarLauncher');
				manifest.hasStartClass('some.random.Main');
				manifest.hasAttribute('Not-Used', 'Foo');
			})
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-context')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-core')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-jcl')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jakarta.servlet-api-6')
				.hasEntryWithName('BOOT-INF/classes/org/test/SampleApplication.class')
				.hasEntryWithName('org/springframework/boot/loader/launch/JarLauncher.class');
			assertThat(buildLog(project))
				.contains('Replacing main artifact ' + repackaged + ' with repackaged archive,')
				.contains('The original artifact has been renamed to ' + original)
				.contains('Installing ' + repackaged + ' to')
				.doesNotContain('Installing ' + original + ' to');
		});
	}
	@TestTemplate
	void whenJarWithClassicLoaderIsRepackagedInPlaceOnlyRepackagedJarIsInstalled(MavenBuild mavenBuild) {
		mavenBuild.project('jar-with-classic-loader').goals('install').execute((project) -> {
			File original = new File(project, 'target/jar-with-classic-loader-0.0.1.BUILD-SNAPSHOT.jar.original');
			assertThat(original).isFile();
			File repackaged = new File(project, 'target/jar-with-classic-loader-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(launchScript(repackaged)).isEmpty();
			assertThat(jar(repackaged)).manifest((manifest) -> {
				manifest.hasMainClass('org.springframework.boot.loader.launch.JarLauncher');
				manifest.hasStartClass('some.random.Main');
				manifest.hasAttribute('Not-Used', 'Foo');
			}).hasEntryWithName('org/springframework/boot/loader/launch/JarLauncher.class');
			assertThat(buildLog(project))
				.contains('Replacing main artifact ' + repackaged + ' with repackaged archive,')
				.contains('The original artifact has been renamed to ' + original)
				.contains('Installing ' + repackaged + ' to')
				.doesNotContain('Installing ' + original + ' to');
		});
	}
	@TestTemplate
	void whenAttachIsDisabledOnlyTheOriginalJarIsInstalled(MavenBuild mavenBuild) {
		mavenBuild.project('jar-attach-disabled').goals('install').execute((project) -> {
			File original = new File(project, 'target/jar-attach-disabled-0.0.1.BUILD-SNAPSHOT.jar.original');
			assertThat(original).isFile();
			File main = new File(project, 'target/jar-attach-disabled-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(main).isFile();
			assertThat(buildLog(project)).contains('Updating main artifact ' + main + ' to ' + original)
				.contains('Installing ' + original + ' to')
				.doesNotContain('Installing ' + main + ' to');
		});
	}
	@TestTemplate
	void whenAClassifierIsConfiguredTheRepackagedJarHasAClassifierAndBothItAndTheOriginalAreInstalled(
			MavenBuild mavenBuild) {
		mavenBuild.project('jar-classifier-main').goals('install').execute((project) -> {
			assertThat(new File(project, 'target/jar-classifier-main-0.0.1.BUILD-SNAPSHOT.jar.original'))
				.doesNotExist();
			File main = new File(project, 'target/jar-classifier-main-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(main).isFile();
			File repackaged = new File(project, 'target/jar-classifier-main-0.0.1.BUILD-SNAPSHOT-test.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/');
			assertThat(buildLog(project))
				.contains('Attaching repackaged archive ' + repackaged + ' with classifier test')
				.doesNotContain('Creating repackaged archive ' + repackaged + ' with classifier test')
				.contains('Installing ' + main + ' to')
				.contains('Installing ' + repackaged + ' to');
		});
	}
	@TestTemplate
	void whenBothJarsHaveTheSameClassifierRepackagingIsDoneInPlaceAndOnlyRepackagedJarIsInstalled(
			MavenBuild mavenBuild) {
		mavenBuild.project('jar-classifier-source').goals('install').execute((project) -> {
			File original = new File(project, 'target/jar-classifier-source-0.0.1.BUILD-SNAPSHOT-test.jar.original');
			assertThat(original).isFile();
			File repackaged = new File(project, 'target/jar-classifier-source-0.0.1.BUILD-SNAPSHOT-test.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/');
			assertThat(buildLog(project))
				.contains('Replacing artifact with classifier test ' + repackaged + ' with repackaged archive,')
				.contains('The original artifact has been renamed to ' + original)
				.doesNotContain('Installing ' + original + ' to')
				.contains('Installing ' + repackaged + ' to');
		});
	}
	@TestTemplate
	void whenBothJarsHaveTheSameClassifierAndAttachIsDisabledOnlyTheOriginalJarIsInstalled(MavenBuild mavenBuild) {
		mavenBuild.project('jar-classifier-source-attach-disabled').goals('install').execute((project) -> {
			File original = new File(project,
					'target/jar-classifier-source-attach-disabled-0.0.1.BUILD-SNAPSHOT-test.jar.original');
			assertThat(original).isFile();
			File repackaged = new File(project,
					'target/jar-classifier-source-attach-disabled-0.0.1.BUILD-SNAPSHOT-test.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/');
			assertThat(buildLog(project))
				.doesNotContain('Attaching repackaged archive ' + repackaged + ' with classifier test')
				.contains('Updating artifact with classifier test ' + repackaged + ' to ' + original)
				.contains('Installing ' + original + ' to')
				.doesNotContain('Installing ' + repackaged + ' to');
		});
	}
	@TestTemplate
	void whenAClassifierAndAnOutputDirectoryAreConfiguredTheRepackagedJarHasAClassifierAndIsWrittenToTheOutputDirectory(
			MavenBuild mavenBuild) {
		mavenBuild.project('jar-create-dir').goals('install').execute((project) -> {
			File repackaged = new File(project, 'target/foo/jar-create-dir-0.0.1.BUILD-SNAPSHOT-foo.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/');
			assertThat(buildLog(project)).contains('Installing ' + repackaged + ' to');
		});
	}
	@TestTemplate
	void whenAnOutputDirectoryIsConfiguredTheRepackagedJarIsWrittenToIt(MavenBuild mavenBuild) {
		mavenBuild.project('jar-custom-dir').goals('install').execute((project) -> {
			File repackaged = new File(project, 'target/foo/jar-custom-dir-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/');
			assertThat(buildLog(project)).contains('Installing ' + repackaged + ' to');
		});
	}
	@TestTemplate
	void whenACustomLaunchScriptIsConfiguredItAppearsInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar-custom-launcher').goals('install').execute((project) -> {
			File repackaged = new File(project, 'target/jar-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/');
			assertThat(launchScript(repackaged)).contains('Hello world');
		});
	}
	@TestTemplate
	void whenAnEntryIsExcludedItDoesNotAppearInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar-exclude-entry').goals('install').execute((project) -> {
			File repackaged = new File(project, 'target/jar-exclude-entry-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-context')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-core')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-jcl')
				.doesNotHaveEntryWithName('BOOT-INF/lib/servlet-api-2.5.jar');
		});
	}
	@TestTemplate
	void whenAnEntryIsExcludedWithPropertyItDoesNotAppearInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar')
			.systemProperty('spring-boot.excludes', 'jakarta.servlet:jakarta.servlet-api')
			.goals('install')
			.execute((project) -> {
				File repackaged = new File(project, 'target/jar-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
					.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-context')
					.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-core')
					.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-jcl')
					.doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/jakarta.servlet-api-');
			});
	}
	@TestTemplate
	void whenAnEntryIsIncludedOnlyIncludedEntriesAppearInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar-include-entry').goals('install').execute((project) -> {
			File repackaged = new File(project, 'target/jar-include-entry-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jakarta.servlet-api-')
				.doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/spring-context')
				.doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/spring-core')
				.doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/spring-jcl');
		});
	}
	@TestTemplate
	void whenAnIncludeIsSpecifiedAsAPropertyOnlyIncludedEntriesAppearInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar')
			.systemProperty('spring-boot.includes', 'jakarta.servlet:jakarta.servlet-api')
			.goals('install')
			.execute((project) -> {
				File repackaged = new File(project, 'target/jar-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
					.hasEntryWithNameStartingWith('BOOT-INF/lib/jakarta.servlet-api-')
					.doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/spring-context')
					.doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/spring-core')
					.doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/spring-jcl');
			});
	}
	@TestTemplate
	void whenAGroupIsExcludedNoEntriesInThatGroupAppearInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar-exclude-group').goals('install').execute((project) -> {
			File repackaged = new File(project, 'target/jar-exclude-group-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-context')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-core')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-jcl')
				.doesNotHaveEntryWithName('BOOT-INF/lib/log4j-api-2.4.1.jar');
		});
	}
	@TestTemplate
	void whenAJarIsExecutableItBeginsWithTheDefaultLaunchScript(MavenBuild mavenBuild) {
		mavenBuild.project('jar-executable').execute((project) -> {
			File repackaged = new File(project, 'target/jar-executable-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/');
			assertThat(launchScript(repackaged)).contains('Spring Boot Startup Script')
				.contains('MyFullyExecutableJarName')
				.contains('MyFullyExecutableJarDesc');
		});
	}
	@TestTemplate
	void whenAJarIsBuiltWithLibrariesWithConflictingNamesTheyAreMadeUniqueUsingTheirGroupIds(MavenBuild mavenBuild) {
		mavenBuild.project('jar-lib-name-conflict').execute((project) -> {
			File repackaged = new File(project, 'test-project/target/test-project-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithName('BOOT-INF/lib/org.springframework.boot.maven.it-acme-lib-0.0.1.BUILD-SNAPSHOT.jar')
				.hasEntryWithName(
						'BOOT-INF/lib/org.springframework.boot.maven.it.another-acme-lib-0.0.1.BUILD-SNAPSHOT.jar');
		});
	}
	@TestTemplate
	void whenAProjectUsesPomPackagingRepackagingIsSkipped(MavenBuild mavenBuild) {
		mavenBuild.project('jar-pom').execute((project) -> {
			File target = new File(project, 'target');
			assertThat(target.listFiles()).containsExactly(new File(target, 'build.log'));
		});
	}
	@TestTemplate
	void whenRepackagingIsSkippedTheJarIsNotRepackaged(MavenBuild mavenBuild) {
		mavenBuild.project('jar-skip').execute((project) -> {
			File main = new File(project, 'target/jar-skip-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(main)).doesNotHaveEntryWithNameStartingWith('org/springframework/boot');
			assertThat(new File(project, 'target/jar-skip-0.0.1.BUILD-SNAPSHOT.jar.original')).doesNotExist();
		});
	}
	@TestTemplate
	void whenADependencyHasSystemScopeAndInclusionOfSystemScopeDependenciesIsEnabledItIsIncludedInTheRepackagedJar(
			MavenBuild mavenBuild) {
		mavenBuild.project('jar-system-scope').execute((project) -> {
			File main = new File(project, 'target/jar-system-scope-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(main)).hasEntryWithName('BOOT-INF/lib/sample-1.0.0.jar');
		});
	}
	@TestTemplate
	void whenADependencyHasSystemScopeItIsNotIncludedInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar-system-scope-default').execute((project) -> {
			File main = new File(project, 'target/jar-system-scope-default-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(main)).doesNotHaveEntryWithName('BOOT-INF/lib/sample-1.0.0.jar');
		});
	}
	@TestTemplate
	void whenADependencyHasTestScopeItIsNotIncludedInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar-test-scope').execute((project) -> {
			File main = new File(project, 'target/jar-test-scope-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(main)).doesNotHaveEntryWithNameStartingWith('BOOT-INF/lib/log4j')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-');
		});
	}
	@TestTemplate
	void whenAProjectUsesKotlinItsModuleMetadataIsRepackagedIntoBootInfClasses(MavenBuild mavenBuild) {
		mavenBuild.project('jar-with-kotlin-module').execute((project) -> {
			File main = new File(project, 'target/jar-with-kotlin-module-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(main)).hasEntryWithName('BOOT-INF/classes/META-INF/jar-with-kotlin-module.kotlin_module');
		});
	}
	@TestTemplate
	void whenAProjectIsBuiltWithALayoutPropertyTheSpecifiedLayoutIsUsed(MavenBuild mavenBuild) {
		mavenBuild.project('jar-with-layout-property')
			.goals('package', '-Dspring-boot.repackage.layout=ZIP')
			.execute((project) -> {
				File main = new File(project, 'target/jar-with-layout-property-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(jar(main)).manifest(
						(manifest) -> manifest.hasMainClass('org.springframework.boot.loader.launch.PropertiesLauncher')
							.hasStartClass('org.test.SampleApplication'));
				assertThat(buildLog(project)).contains('Layout: ZIP');
			});
	}
	@TestTemplate
	void whenALayoutIsConfiguredTheSpecifiedLayoutIsUsed(MavenBuild mavenBuild) {
		mavenBuild.project('jar-with-zip-layout').execute((project) -> {
			File main = new File(project, 'target/jar-with-zip-layout-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(main)).manifest(
					(manifest) -> manifest.hasMainClass('org.springframework.boot.loader.launch.PropertiesLauncher')
						.hasStartClass('org.test.SampleApplication'));
			assertThat(buildLog(project)).contains('Layout: ZIP');
		});
	}
	@TestTemplate
	void whenRequiresUnpackConfigurationIsProvidedItIsReflectedInTheRepackagedJar(MavenBuild mavenBuild) {
		mavenBuild.project('jar-with-unpack').execute((project) -> {
			File main = new File(project, 'target/jar-with-unpack-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(main)).hasUnpackEntryWithNameStartingWith('BOOT-INF/lib/spring-core-')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/spring-context-');
		});
	}
	@TestTemplate
	void whenJarIsRepackagedWithACustomLayoutTheJarUsesTheLayout(MavenBuild mavenBuild) {
		mavenBuild.project('jar-custom-layout').execute((project) -> {
			assertThat(jar(new File(project, 'custom/target/custom-0.0.1.BUILD-SNAPSHOT.jar')))
				.hasEntryWithName('custom');
			assertThat(jar(new File(project, 'default/target/default-0.0.1.BUILD-SNAPSHOT.jar')))
				.hasEntryWithName('sample');
		});
	}
	@TestTemplate
	void repackagedJarContainsTheLayersIndexByDefault(MavenBuild mavenBuild) {
		mavenBuild.project('jar-layered').execute((project) -> {
			File repackaged = new File(project, 'jar/target/jar-layered-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-snapshot')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId());
			try (JarFile jarFile = new JarFile(repackaged)) {
				Map<String, List<String>> layerIndex = readLayerIndex(jarFile);
				assertThat(layerIndex.keySet()).containsExactly('dependencies', 'spring-boot-loader',
						'snapshot-dependencies', 'application');
				assertThat(layerIndex.get('application')).contains('BOOT-INF/lib/jar-release-0.0.1.RELEASE.jar',
						'BOOT-INF/lib/jar-snapshot-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(layerIndex.get('dependencies'))
					.anyMatch((dependency) -> dependency.startsWith('BOOT-INF/lib/log4j-api-2'));
			}
			catch (IOException ex) {
				// Ignore
			}
		});
	}
	@TestTemplate
	void whenJarIsRepackagedWithTheLayersDisabledDoesNotContainLayersIndex(MavenBuild mavenBuild) {
		mavenBuild.project('jar-layered-disabled').execute((project) -> {
			File repackaged = new File(project, 'jar/target/jar-layered-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-snapshot')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId())
				.doesNotHaveEntryWithName('BOOT-INF/layers.idx');
		});
	}
	@TestTemplate
	void whenJarIsRepackagedWithTheLayersEnabledAndLayerToolsExcluded(MavenBuild mavenBuild) {
		mavenBuild.project('jar-layered-no-layer-tools').execute((project) -> {
			File repackaged = new File(project, 'jar/target/jar-layered-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-snapshot')
				.hasEntryWithNameStartingWith('BOOT-INF/layers.idx')
				.doesNotHaveEntryWithNameStartingWith(
						'BOOT-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId());
		});
	}
	@TestTemplate
	void whenJarIsRepackagedWithToolsExclude(MavenBuild mavenBuild) {
		mavenBuild.project('jar-no-tools').execute((project) -> {
			File repackaged = new File(project, 'jar/target/jar-no-tools-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-snapshot')
				.doesNotHaveEntryWithNameStartingWith(
						'BOOT-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId());
		});
	}
	@TestTemplate
	void whenJarIsRepackagedWithTheCustomLayers(MavenBuild mavenBuild) {
		mavenBuild.project('jar-layered-custom').execute((project) -> {
			File repackaged = new File(project, 'jar/target/jar-layered-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('BOOT-INF/classes/')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('BOOT-INF/lib/jar-snapshot');
			try (JarFile jarFile = new JarFile(repackaged)) {
				Map<String, List<String>> layerIndex = readLayerIndex(jarFile);
				assertThat(layerIndex.keySet()).containsExactly('my-dependencies-name', 'snapshot-dependencies',
						'configuration', 'application');
				assertThat(layerIndex.get('application'))
					.contains('BOOT-INF/lib/jar-release-0.0.1.RELEASE.jar',
							'BOOT-INF/lib/jar-snapshot-0.0.1.BUILD-SNAPSHOT.jar',
							'BOOT-INF/lib/jar-classifier-0.0.1-bravo.jar')
					.doesNotContain('BOOT-INF/lib/jar-classifier-0.0.1-alpha.jar');
			}
		});
	}
	@TestTemplate
	void repackagedJarContainsClasspathIndex(MavenBuild mavenBuild) {
		mavenBuild.project('jar').execute((project) -> {
			File repackaged = new File(project, 'target/jar-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged))
				.manifest((manifest) -> manifest.hasAttribute('Spring-Boot-Classpath-Index', 'BOOT-INF/classpath.idx'));
			assertThat(jar(repackaged)).hasEntryWithName('BOOT-INF/classpath.idx');
			try (JarFile jarFile = new JarFile(repackaged)) {
				List<String> index = readClasspathIndex(jarFile, 'BOOT-INF/classpath.idx');
				assertThat(index).allMatch((entry) -> entry.startsWith('BOOT-INF/lib/'));
			}
		});
	}
	@TestTemplate
	void whenJarIsRepackagedWithOutputTimestampConfiguredThenJarIsReproducible(MavenBuild mavenBuild)
			throws InterruptedException {
		String firstHash = buildJarWithOutputTimestamp(mavenBuild);
		Thread.sleep(1500);
		String secondHash = buildJarWithOutputTimestamp(mavenBuild);
		assertThat(firstHash).isEqualTo(secondHash);
	}
	private String buildJarWithOutputTimestamp(MavenBuild mavenBuild) {
		AtomicReference<String> jarHash = new AtomicReference<>();
		mavenBuild.project('jar-output-timestamp').execute((project) -> {
			File repackaged = new File(project, 'target/jar-output-timestamp-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(repackaged).isFile();
			long expectedModified = 1584352800000L;
			long offsetExpectedModified = expectedModified - TimeZone.getDefault().getOffset(expectedModified);
			assertThat(repackaged.lastModified()).isEqualTo(expectedModified);
			try (JarFile jar = new JarFile(repackaged)) {
				List<String> unreproducibleEntries = jar.stream()
					.filter((entry) -> entry.getLastModifiedTime().toMillis() != offsetExpectedModified)
					.map((entry) -> entry.getName() + ': ' + entry.getLastModifiedTime())
					.toList();
				assertThat(unreproducibleEntries).isEmpty();
				jarHash.set(FileUtils.sha1Hash(repackaged));
				FileSystemUtils.deleteRecursively(project);
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
		});
		return jarHash.get();
	}
	@TestTemplate
	void whenJarIsRepackagedWithOutputTimestampConfiguredThenLibrariesAreSorted(MavenBuild mavenBuild) {
		mavenBuild.project('jar-output-timestamp').execute((project) -> {
			File repackaged = new File(project, 'target/jar-output-timestamp-0.0.1.BUILD-SNAPSHOT.jar');
			List<String> sortedLibs = Arrays.asList('BOOT-INF/lib/jakarta.servlet-api',
					'BOOT-INF/lib/micrometer-commons', 'BOOT-INF/lib/micrometer-observation', 'BOOT-INF/lib/spring-aop',
					'BOOT-INF/lib/spring-beans',
					'BOOT-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId(),
					'BOOT-INF/lib/spring-context', 'BOOT-INF/lib/spring-core', 'BOOT-INF/lib/spring-expression',
					'BOOT-INF/lib/spring-jcl');
			assertThat(jar(repackaged)).entryNamesInPath('BOOT-INF/lib/')
				.zipSatisfy(sortedLibs,
						(String jarLib, String expectedLib) -> assertThat(jarLib).startsWith(expectedLib));
		});
	}
	@TestTemplate
	void whenSigned(MavenBuild mavenBuild) {
		mavenBuild.project('jar-signed').execute((project) -> {
			File repackaged = new File(project, 'target/jar-signed-0.0.1.BUILD-SNAPSHOT.jar');
			assertThat(jar(repackaged)).hasEntryWithName('META-INF/BOOT.SF');
		});
	}
}
/*
package org.springframework.boot.maven;
/**
@ExtendWith(MavenBuildExtension.class)
class WarIntegrationTests extends AbstractArchiveIntegrationTests {
	@Override
	protected String getLayersIndexLocation() {
		return 'WEB-INF/layers.idx';
	}
	@TestTemplate
	void warRepackaging(MavenBuild mavenBuild) {
		mavenBuild.project('war')
			.execute((project) -> assertThat(jar(new File(project, 'target/war-0.0.1.BUILD-SNAPSHOT.war')))
				.hasEntryWithNameStartingWith('WEB-INF/lib/spring-context')
				.hasEntryWithNameStartingWith('WEB-INF/lib/spring-core')
				.hasEntryWithNameStartingWith('WEB-INF/lib/spring-jcl')
				.hasEntryWithNameStartingWith('WEB-INF/lib-provided/jakarta.servlet-api-6')
				.hasEntryWithName('org/springframework/boot/loader/launch/WarLauncher.class')
				.hasEntryWithName('WEB-INF/classes/org/test/SampleApplication.class')
				.hasEntryWithName('index.html')
				.manifest((manifest) -> manifest.hasMainClass('org.springframework.boot.loader.launch.WarLauncher')
					.hasStartClass('org.test.SampleApplication')
					.hasAttribute('Not-Used', 'Foo')));
	}
	@TestTemplate
	void jarDependencyWithCustomFinalNameBuiltInSameReactorIsPackagedUsingArtifactIdAndVersion(MavenBuild mavenBuild) {
		mavenBuild.project('war-reactor')
			.execute(((project) -> assertThat(jar(new File(project, 'war/target/war-0.0.1.BUILD-SNAPSHOT.war')))
				.hasEntryWithName('WEB-INF/lib/jar-0.0.1.BUILD-SNAPSHOT.jar')
				.doesNotHaveEntryWithName('WEB-INF/lib/jar.jar')));
	}
	@TestTemplate
	void whenRequiresUnpackConfigurationIsProvidedItIsReflectedInTheRepackagedWar(MavenBuild mavenBuild) {
		mavenBuild.project('war-with-unpack')
			.execute((project) -> assertThat(jar(new File(project, 'target/war-with-unpack-0.0.1.BUILD-SNAPSHOT.war')))
				.hasUnpackEntryWithNameStartingWith('WEB-INF/lib/spring-core-')
				.hasEntryWithNameStartingWith('WEB-INF/lib/spring-context-')
				.hasEntryWithNameStartingWith('WEB-INF/lib/spring-jcl-'));
	}
	@TestTemplate
	void whenWarIsRepackagedWithOutputTimestampConfiguredThenWarIsReproducible(MavenBuild mavenBuild)
			throws InterruptedException {
		String firstHash = buildWarWithOutputTimestamp(mavenBuild);
		Thread.sleep(1500);
		String secondHash = buildWarWithOutputTimestamp(mavenBuild);
		assertThat(firstHash).isEqualTo(secondHash);
	}
	private String buildWarWithOutputTimestamp(MavenBuild mavenBuild) {
		AtomicReference<String> warHash = new AtomicReference<>();
		mavenBuild.project('war-output-timestamp').execute((project) -> {
			File repackaged = new File(project, 'target/war-output-timestamp-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(repackaged).isFile();
			long expectedModified = 1584352800000L;
			assertThat(repackaged.lastModified()).isEqualTo(expectedModified);
			long offsetExpectedModified = expectedModified - TimeZone.getDefault().getOffset(expectedModified);
			try (JarFile jar = new JarFile(repackaged)) {
				List<String> unreproducibleEntries = jar.stream()
					.filter((entry) -> entry.getLastModifiedTime().toMillis() != offsetExpectedModified)
					.map((entry) -> entry.getName() + ': ' + entry.getLastModifiedTime())
					.toList();
				assertThat(unreproducibleEntries).isEmpty();
				warHash.set(FileUtils.sha1Hash(repackaged));
				FileSystemUtils.deleteRecursively(project);
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
		});
		return warHash.get();
	}
	@TestTemplate
	void whenWarIsRepackagedWithOutputTimestampConfiguredThenLibrariesAreSorted(MavenBuild mavenBuild) {
		mavenBuild.project('war-output-timestamp').execute((project) -> {
			File repackaged = new File(project, 'target/war-output-timestamp-0.0.1.BUILD-SNAPSHOT.war');
			List<String> sortedLibs = Arrays.asList(
					// these libraries are copied from the original war, sorted when
					// packaged by Maven
					'WEB-INF/lib/micrometer-commons', 'WEB-INF/lib/micrometer-observation', 'WEB-INF/lib/spring-aop',
					'WEB-INF/lib/spring-beans', 'WEB-INF/lib/spring-context', 'WEB-INF/lib/spring-core',
					'WEB-INF/lib/spring-expression', 'WEB-INF/lib/spring-jcl',
					// these libraries are contributed by Spring Boot repackaging, and
					// sorted separately
					'WEB-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId());
			assertThat(jar(repackaged)).entryNamesInPath('WEB-INF/lib/')
				.zipSatisfy(sortedLibs,
						(String jarLib, String expectedLib) -> assertThat(jarLib).startsWith(expectedLib));
		});
	}
	@TestTemplate
	void whenADependencyHasSystemScopeAndInclusionOfSystemScopeDependenciesIsEnabledItIsIncludedInTheRepackagedJar(
			MavenBuild mavenBuild) {
		mavenBuild.project('war-system-scope').execute((project) -> {
			File main = new File(project, 'target/war-system-scope-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(main)).hasEntryWithName('WEB-INF/lib-provided/sample-1.0.0.jar');
		});
	}
	@TestTemplate
	void repackagedWarContainsTheLayersIndexByDefault(MavenBuild mavenBuild) {
		mavenBuild.project('war-layered').execute((project) -> {
			File repackaged = new File(project, 'war/target/war-layered-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('WEB-INF/classes/')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-snapshot')
				.hasEntryWithNameStartingWith('WEB-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId());
			try (JarFile jarFile = new JarFile(repackaged)) {
				Map<String, List<String>> layerIndex = readLayerIndex(jarFile);
				assertThat(layerIndex.keySet()).containsExactly('dependencies', 'spring-boot-loader',
						'snapshot-dependencies', 'application');
				List<String> dependenciesAndSnapshotDependencies = new ArrayList<>();
				dependenciesAndSnapshotDependencies.addAll(layerIndex.get('dependencies'));
				dependenciesAndSnapshotDependencies.addAll(layerIndex.get('snapshot-dependencies'));
				assertThat(layerIndex.get('application')).contains('WEB-INF/lib/jar-release-0.0.1.RELEASE.jar',
						'WEB-INF/lib/jar-snapshot-0.0.1.BUILD-SNAPSHOT.jar');
				assertThat(dependenciesAndSnapshotDependencies)
					.anyMatch((dependency) -> dependency.startsWith('WEB-INF/lib/spring-context'));
				assertThat(layerIndex.get('dependencies'))
					.anyMatch((dependency) -> dependency.startsWith('WEB-INF/lib-provided/'));
			}
			catch (IOException ex) {
				// Ignore
			}
		});
	}
	@TestTemplate
	void whenWarIsRepackagedWithTheLayersDisabledDoesNotContainLayersIndex(MavenBuild mavenBuild) {
		mavenBuild.project('war-layered-disabled').execute((project) -> {
			File repackaged = new File(project, 'war/target/war-layered-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('WEB-INF/classes/')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-snapshot')
				.hasEntryWithNameStartingWith('WEB-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId())
				.doesNotHaveEntryWithName('WEB-INF/layers.idx');
		});
	}
	@TestTemplate
	void whenWarIsRepackagedWithTheLayersEnabledAndLayerToolsExcluded(MavenBuild mavenBuild) {
		mavenBuild.project('war-layered-no-layer-tools').execute((project) -> {
			File repackaged = new File(project, 'war/target/war-layered-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('WEB-INF/classes/')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-snapshot')
				.hasEntryWithNameStartingWith('WEB-INF/layers.idx')
				.doesNotHaveEntryWithNameStartingWith(
						'WEB-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId());
		});
	}
	@TestTemplate
	void whenWarIsRepackagedWithToolsExclude(MavenBuild mavenBuild) {
		mavenBuild.project('war-no-tools').execute((project) -> {
			File repackaged = new File(project, 'war/target/war-no-tools-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('WEB-INF/classes/')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-snapshot')
				.doesNotHaveEntryWithNameStartingWith(
						'WEB-INF/lib/' + JarModeLibrary.TOOLS.getCoordinates().getArtifactId());
		});
	}
	@TestTemplate
	void whenWarIsRepackagedWithTheCustomLayers(MavenBuild mavenBuild) {
		mavenBuild.project('war-layered-custom').execute((project) -> {
			File repackaged = new File(project, 'war/target/war-layered-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(repackaged)).hasEntryWithNameStartingWith('WEB-INF/classes/')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-release')
				.hasEntryWithNameStartingWith('WEB-INF/lib/jar-snapshot');
			try (JarFile jarFile = new JarFile(repackaged)) {
				Map<String, List<String>> layerIndex = readLayerIndex(jarFile);
				assertThat(layerIndex.keySet()).containsExactly('my-dependencies-name', 'snapshot-dependencies',
						'configuration', 'application');
				assertThat(layerIndex.get('application'))
					.contains('WEB-INF/lib/jar-release-0.0.1.RELEASE.jar',
							'WEB-INF/lib/jar-snapshot-0.0.1.BUILD-SNAPSHOT.jar',
							'WEB-INF/lib/jar-classifier-0.0.1-bravo.jar')
					.doesNotContain('WEB-INF/lib/jar-classifier-0.0.1-alpha.jar');
			}
		});
	}
	@TestTemplate
	void repackagedWarContainsClasspathIndex(MavenBuild mavenBuild) {
		mavenBuild.project('war').execute((project) -> {
			File repackaged = new File(project, 'target/war-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(repackaged))
				.manifest((manifest) -> manifest.hasAttribute('Spring-Boot-Classpath-Index', 'WEB-INF/classpath.idx'));
			assertThat(jar(repackaged)).hasEntryWithName('WEB-INF/classpath.idx');
			try (JarFile jarFile = new JarFile(repackaged)) {
				List<String> index = readClasspathIndex(jarFile, 'WEB-INF/classpath.idx');
				assertThat(index)
					.allMatch((entry) -> entry.startsWith('WEB-INF/lib/') || entry.startsWith('WEB-INF/lib-provided/'));
			}
		});
	}
	@TestTemplate
	void whenEntryIsExcludedItShouldNotBePresentInTheRepackagedWar(MavenBuild mavenBuild) {
		mavenBuild.project('war-exclude-entry').execute((project) -> {
			File war = new File(project, 'target/war-exclude-entry-0.0.1.BUILD-SNAPSHOT.war');
			assertThat(jar(war)).hasEntryWithNameStartingWith('WEB-INF/lib/spring-context')
				.doesNotHaveEntryWithNameStartingWith('WEB-INF/lib/spring-core');
		});
	}
}
/*
package org.springframework.boot.maven;
/**
class EclipseM2eIntegrationTests {
	@Test // gh-21992
	void pluginPomIncludesOptionalShadeDependency() throws Exception {
		String version = new Versions().get('project.version');
		File repository = new File('build/test-maven-repository');
		File pluginDirectory = new File(repository, 'org/springframework/boot/spring-boot-maven-plugin/' + version);
		File[] pomFiles = pluginDirectory.listFiles(this::isPomFile);
		Arrays.sort(pomFiles, Comparator.comparing(File::getName));
		File pomFile = pomFiles[pomFiles.length - 1];
		String pomContent = new String(FileCopyUtils.copyToByteArray(pomFile), StandardCharsets.UTF_8);
		assertThat(pomContent).contains('maven-shade-plugin');
	}
	private boolean isPomFile(File file) {
		return file.getName().endsWith('.pom');
	}
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
@Documented
public @interface TestAutoConfigureBefore {
	Class<?>[] value() default {};
	String[] name() default {};
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@TestAutoConfigureBefore(value = InputStream.class, name = { 'test.before1', 'test.before2' })
@TestAutoConfigureAfter(value = OutputStream.class, name = { 'test.after1', 'test.after2' })
@TestAutoConfiguration(before = ObjectInputStream.class, beforeName = { 'test.before3', 'test.before4' },
		after = ObjectOutputStream.class, afterName = { 'test.after3', 'test.after4' })
class TestMergedAutoConfigurationConfiguration {
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD, ElementType.FIELD })
@Documented
public @interface TestAutoConfigureOrder {
	int value() default Integer.MAX_VALUE;
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface TestConditionalOnWebApplication {
	Type type() default Type.ANY;
	enum Type {
		ANY, SERVLET, REACTIVE
	}
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@TestAutoConfigureBefore
@TestAutoConfigureAfter
public @interface TestAutoConfiguration {
	@AliasFor(annotation = TestAutoConfigureBefore.class, attribute = 'value')
	Class<?>[] before() default {};
	@AliasFor(annotation = TestAutoConfigureBefore.class, attribute = 'name')
	String[] beforeName() default {};
	@AliasFor(annotation = TestAutoConfigureAfter.class, attribute = 'value')
	Class<?>[] after() default {};
	@AliasFor(annotation = TestAutoConfigureAfter.class, attribute = 'name')
	String[] afterName() default {};
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@TestAutoConfiguration
class TestAutoConfigurationOnlyConfiguration {
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
@Documented
public @interface TestAutoConfigureAfter {
	Class<?>[] value() default {};
	String[] name() default {};
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
class AutoConfigureAnnotationProcessorTests {
	@Test
	void annotatedClass() {
		compile(TestClassConfiguration.class, (properties) -> {
			assertThat(properties).hasSize(7);
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestClassConfiguration.ConditionalOnClass',
					'java.io.InputStream,org.springframework.boot.autoconfigureprocessor.'
							+ 'TestClassConfiguration$Nested,org.springframework.foo');
			assertThat(properties)
				.containsKey('org.springframework.boot.autoconfigureprocessor.TestClassConfiguration');
			assertThat(properties)
				.containsKey('org.springframework.boot.autoconfigureprocessor.TestClassConfiguration$Nested');
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestClassConfiguration.ConditionalOnBean',
					'java.io.OutputStream');
			assertThat(properties).containsEntry('org.springframework.boot.autoconfigureprocessor.'
					+ 'TestClassConfiguration.ConditionalOnSingleCandidate', 'java.io.OutputStream');
			assertThat(properties).containsEntry('org.springframework.boot.autoconfigureprocessor.'
					+ 'TestClassConfiguration.ConditionalOnWebApplication', 'SERVLET');
		});
	}
	@Test
	void annotatedClassWithOnlyAutoConfiguration() {
		compile(TestAutoConfigurationOnlyConfiguration.class, (properties) -> {
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestAutoConfigurationOnlyConfiguration', '');
			assertThat(properties).doesNotContainEntry(
					'org.springframework.boot.autoconfigureprocessor.TestAutoConfigurationOnlyConfiguration.AutoConfigureAfter',
					'');
			assertThat(properties).doesNotContainEntry(
					'org.springframework.boot.autoconfigureprocessor.TestAutoConfigurationOnlyConfiguration.AutoConfigureBefore',
					'');
		});
	}
	@Test
	void annotatedClassWithOnBeanThatHasName() {
		compile(TestOnBeanWithNameClassConfiguration.class, (properties) -> {
			assertThat(properties).hasSize(2);
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestOnBeanWithNameClassConfiguration.ConditionalOnBean',
					'');
		});
	}
	@Test
	void annotatedMethod() {
		process(TestMethodConfiguration.class, (properties) -> assertThat(properties).isNull());
	}
	@Test
	void annotatedClassWithOrder() {
		compile(TestOrderedClassConfiguration.class, (properties) -> {
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestOrderedClassConfiguration.ConditionalOnClass',
					'java.io.InputStream,java.io.OutputStream');
			assertThat(properties).containsEntry('org.springframework.boot.autoconfigureprocessor.'
					+ 'TestOrderedClassConfiguration.AutoConfigureBefore', 'test.before1,test.before2');
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestOrderedClassConfiguration.AutoConfigureAfter',
					'java.io.ObjectInputStream');
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestOrderedClassConfiguration.AutoConfigureOrder',
					'123');
		});
	}
	@Test
	void annotatedClassWithAutoConfiguration() {
		compile(TestAutoConfigurationConfiguration.class, (properties) -> {
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestAutoConfigurationConfiguration', '');
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestAutoConfigurationConfiguration.AutoConfigureBefore',
					'java.io.InputStream,test.before1,test.before2');
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestAutoConfigurationConfiguration.AutoConfigureAfter',
					'java.io.OutputStream,test.after1,test.after2');
		});
	}
	@Test
	void annotatedClassWithAutoConfigurationMerged() {
		compile(TestMergedAutoConfigurationConfiguration.class, (properties) -> {
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestMergedAutoConfigurationConfiguration', '');
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestMergedAutoConfigurationConfiguration.AutoConfigureBefore',
					'java.io.InputStream,test.before1,test.before2,java.io.ObjectInputStream,test.before3,test.before4');
			assertThat(properties).containsEntry(
					'org.springframework.boot.autoconfigureprocessor.TestMergedAutoConfigurationConfiguration.AutoConfigureAfter',
					'java.io.OutputStream,test.after1,test.after2,java.io.ObjectOutputStream,test.after3,test.after4');
		});
	}
	@Test // gh-19370
	void propertiesAreFullRepeatable() {
		process(TestOrderedClassConfiguration.class, (firstFile) -> {
			String first = getFileContents(firstFile);
			process(TestOrderedClassConfiguration.class, (secondFile) -> {
				String second = getFileContents(secondFile);
				assertThat(first).isEqualTo(second).doesNotContain('#');
			});
		});
	}
	private void compile(Class<?> type, Consumer<Properties> consumer) {
		process(type, (writtenFile) -> consumer.accept(getWrittenProperties(writtenFile)));
	}
	private void process(Class<?> type, Consumer<InputStream> consumer) {
		TestAutoConfigureAnnotationProcessor processor = new TestAutoConfigureAnnotationProcessor();
		SourceFile sourceFile = SourceFile.forTestClass(type);
		TestCompiler compiler = TestCompiler.forSystem().withProcessors(processor).withSources(sourceFile);
		compiler.compile((compiled) -> {
			InputStream propertiesFile = compiled.getClassLoader()
				.getResourceAsStream(AutoConfigureAnnotationProcessor.PROPERTIES_PATH);
			consumer.accept(propertiesFile);
		});
	}
	private Properties getWrittenProperties(InputStream inputStream) {
		try {
			Properties properties = new Properties();
			properties.load(inputStream);
			return properties;
		}
		catch (IOException ex) {
			fail('Error reading properties', ex);
		}
		return null;
	}
	private String getFileContents(InputStream inputStream) {
		try {
			return new String(inputStream.readAllBytes());
		}
		catch (IOException ex) {
			fail('Error reading contents of properties file', ex);
		}
		return null;
	}
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@SupportedAnnotationTypes({ 'org.springframework.boot.autoconfigureprocessor.TestConditionalOnClass',
		'org.springframework.boot.autoconfigureprocessor.TestConditionalOnBean',
		'org.springframework.boot.autoconfigureprocessor.TestConditionalOnSingleCandidate',
		'org.springframework.boot.autoconfigureprocessor.TestConditionalOnWebApplication',
		'org.springframework.boot.autoconfigureprocessor.TestAutoConfigureBefore',
		'org.springframework.boot.autoconfigureprocessor.TestAutoConfigureAfter',
		'org.springframework.boot.autoconfigureprocessor.TestAutoConfigureOrder',
		'org.springframework.boot.autoconfigureprocessor.TestAutoConfiguration' })
public class TestAutoConfigureAnnotationProcessor extends AutoConfigureAnnotationProcessor {
	public TestAutoConfigureAnnotationProcessor() {
	}
	@Override
	protected List<PropertyGenerator> getPropertyGenerators() {
		List<PropertyGenerator> generators = new ArrayList<>();
		String annotationPackage = 'org.springframework.boot.autoconfigureprocessor';
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnClass')
			.withAnnotation('TestConditionalOnClass', new OnClassConditionValueExtractor()));
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnBean')
			.withAnnotation('TestConditionalOnBean', new OnBeanConditionValueExtractor()));
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnSingleCandidate')
			.withAnnotation('TestConditionalOnSingleCandidate', new OnBeanConditionValueExtractor()));
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnWebApplication')
			.withAnnotation('TestConditionalOnWebApplication', ValueExtractor.allFrom('type')));
		generators.add(PropertyGenerator.of(annotationPackage, 'AutoConfigureBefore', true)
			.withAnnotation('TestAutoConfigureBefore', ValueExtractor.allFrom('value', 'name'))
			.withAnnotation('TestAutoConfiguration', ValueExtractor.allFrom('before', 'beforeName')));
		generators.add(PropertyGenerator.of(annotationPackage, 'AutoConfigureAfter', true)
			.withAnnotation('TestAutoConfigureAfter', ValueExtractor.allFrom('value', 'name'))
			.withAnnotation('TestAutoConfiguration', ValueExtractor.allFrom('after', 'afterName')));
		generators.add(PropertyGenerator.of(annotationPackage, 'AutoConfigureOrder')
			.withAnnotation('TestAutoConfigureOrder', ValueExtractor.allFrom('value')));
		return generators;
	}
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@TestConditionalOnClass(name = { 'org.springframework.foo', 'java.io.InputStream' },
		value = TestClassConfiguration.Nested.class)
@TestConditionalOnBean(type = 'java.io.OutputStream')
@TestConditionalOnSingleCandidate(type = 'java.io.OutputStream')
@TestConditionalOnWebApplication(type = Type.SERVLET)
public class TestClassConfiguration {
	@TestAutoConfigureOrder
	static class Nested {
	}
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@TestAutoConfiguration(before = InputStream.class, beforeName = { 'test.before1', 'test.before2' },
		after = OutputStream.class, afterName = { 'test.after1', 'test.after2' })
class TestAutoConfigurationConfiguration {
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface TestConditionalOnClass {
	Class<?>[] value() default {};
	String[] name() default {};
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@TestConditionalOnBean(name = 'test', type = 'java.io.OutputStream')
public class TestOnBeanWithNameClassConfiguration {
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface TestConditionalOnSingleCandidate {
	Class<?> value() default Object.class;
	String type() default '';
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@TestAutoConfigureBefore(name = { 'test.before1', 'test.before2' })
@TestAutoConfigureAfter(ObjectInputStream.class)
@TestConditionalOnClass(name = 'java.io.InputStream', value = OutputStream.class)
@TestAutoConfigureOrder(123)
public class TestOrderedClassConfiguration {
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
public class TestMethodConfiguration {
	@TestConditionalOnClass(name = 'java.io.InputStream', value = OutputStream.class)
	public Object method() {
		return null;
	}
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface TestConditionalOnBean {
	Class<?>[] value() default {};
	String[] type() default {};
	Class<? extends Annotation>[] annotation() default {};
	String[] name() default {};
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
final class Elements {
	private Elements() {
	}
	static String getQualifiedName(Element element) {
		if (element != null) {
			TypeElement enclosingElement = getEnclosingTypeElement(element.asType());
			if (enclosingElement != null) {
				return getQualifiedName(enclosingElement) + '$'
						+ ((DeclaredType) element.asType()).asElement().getSimpleName().toString();
			}
			if (element instanceof TypeElement typeElement) {
				return typeElement.getQualifiedName().toString();
			}
		}
		return null;
	}
	private static TypeElement getEnclosingTypeElement(TypeMirror type) {
		if (type instanceof DeclaredType declaredType) {
			Element enclosingElement = declaredType.asElement().getEnclosingElement();
			if (enclosingElement instanceof TypeElement typeElement) {
				return typeElement;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.autoconfigureprocessor;
/**
@SupportedAnnotationTypes({ 'org.springframework.boot.autoconfigure.condition.ConditionalOnClass',
		'org.springframework.boot.autoconfigure.condition.ConditionalOnBean',
		'org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate',
		'org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication',
		'org.springframework.boot.autoconfigure.AutoConfigureBefore',
		'org.springframework.boot.autoconfigure.AutoConfigureAfter',
		'org.springframework.boot.autoconfigure.AutoConfigureOrder',
		'org.springframework.boot.autoconfigure.AutoConfiguration' })
public class AutoConfigureAnnotationProcessor extends AbstractProcessor {
	protected static final String PROPERTIES_PATH = 'META-INF/spring-autoconfigure-metadata.properties';
	private final Map<String, String> properties = new TreeMap<>();
	private final List<PropertyGenerator> propertyGenerators;
	public AutoConfigureAnnotationProcessor() {
		this.propertyGenerators = Collections.unmodifiableList(getPropertyGenerators());
	}
	protected List<PropertyGenerator> getPropertyGenerators() {
		List<PropertyGenerator> generators = new ArrayList<>();
		addConditionPropertyGenerators(generators);
		addAutoConfigurePropertyGenerators(generators);
		return generators;
	}
	private void addConditionPropertyGenerators(List<PropertyGenerator> generators) {
		String annotationPackage = 'org.springframework.boot.autoconfigure.condition';
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnClass')
			.withAnnotation(new OnClassConditionValueExtractor()));
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnBean')
			.withAnnotation(new OnBeanConditionValueExtractor()));
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnSingleCandidate')
			.withAnnotation(new OnBeanConditionValueExtractor()));
		generators.add(PropertyGenerator.of(annotationPackage, 'ConditionalOnWebApplication')
			.withAnnotation(ValueExtractor.allFrom('type')));
	}
	private void addAutoConfigurePropertyGenerators(List<PropertyGenerator> generators) {
		String annotationPackage = 'org.springframework.boot.autoconfigure';
		generators.add(PropertyGenerator.of(annotationPackage, 'AutoConfigureBefore', true)
			.withAnnotation(ValueExtractor.allFrom('value', 'name'))
			.withAnnotation('AutoConfiguration', ValueExtractor.allFrom('before', 'beforeName')));
		generators.add(PropertyGenerator.of(annotationPackage, 'AutoConfigureAfter', true)
			.withAnnotation(ValueExtractor.allFrom('value', 'name'))
			.withAnnotation('AutoConfiguration', ValueExtractor.allFrom('after', 'afterName')));
		generators.add(PropertyGenerator.of(annotationPackage, 'AutoConfigureOrder')
			.withAnnotation(ValueExtractor.allFrom('value')));
	}
	@Override
	public SourceVersion getSupportedSourceVersion() {
		return SourceVersion.latestSupported();
	}
	@Override
	public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
		for (PropertyGenerator generator : this.propertyGenerators) {
			process(roundEnv, generator);
		}
		if (roundEnv.processingOver()) {
			try {
				writeProperties();
			}
			catch (Exception ex) {
				throw new IllegalStateException('Failed to write metadata', ex);
			}
		}
		return false;
	}
	private void process(RoundEnvironment roundEnv, PropertyGenerator generator) {
		for (String annotationName : generator.getSupportedAnnotations()) {
			TypeElement annotationType = this.processingEnv.getElementUtils().getTypeElement(annotationName);
			if (annotationType != null) {
				for (Element element : roundEnv.getElementsAnnotatedWith(annotationType)) {
					processElement(element, generator, annotationName);
				}
			}
		}
	}
	private void processElement(Element element, PropertyGenerator generator, String annotationName) {
		try {
			String qualifiedName = Elements.getQualifiedName(element);
			AnnotationMirror annotation = getAnnotation(element, annotationName);
			if (qualifiedName != null && annotation != null) {
				List<Object> values = getValues(generator, annotationName, annotation);
				generator.applyToProperties(this.properties, qualifiedName, values);
				this.properties.put(qualifiedName, '');
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Error processing configuration meta-data on ' + element, ex);
		}
	}
	private AnnotationMirror getAnnotation(Element element, String type) {
		if (element != null) {
			for (AnnotationMirror annotation : element.getAnnotationMirrors()) {
				if (type.equals(annotation.getAnnotationType().toString())) {
					return annotation;
				}
			}
		}
		return null;
	}
	private List<Object> getValues(PropertyGenerator generator, String annotationName, AnnotationMirror annotation) {
		ValueExtractor extractor = generator.getValueExtractor(annotationName);
		if (extractor == null) {
			return Collections.emptyList();
		}
		return extractor.getValues(annotation);
	}
	private void writeProperties() throws IOException {
		if (!this.properties.isEmpty()) {
			Filer filer = this.processingEnv.getFiler();
			FileObject file = filer.createResource(StandardLocation.CLASS_OUTPUT, '', PROPERTIES_PATH);
			try (Writer writer = new OutputStreamWriter(file.openOutputStream(), StandardCharsets.UTF_8)) {
				for (Map.Entry<String, String> entry : this.properties.entrySet()) {
					writer.append(entry.getKey());
					writer.append('=');
					writer.append(entry.getValue());
					writer.append(System.lineSeparator());
				}
			}
		}
	}
	@FunctionalInterface
	interface ValueExtractor {
		List<Object> getValues(AnnotationMirror annotation);
		static ValueExtractor allFrom(String... names) {
			return new NamedValuesExtractor(names);
		}
	}
	private abstract static class AbstractValueExtractor implements ValueExtractor {
		@SuppressWarnings('unchecked')
		protected Stream<Object> extractValues(AnnotationValue annotationValue) {
			if (annotationValue == null) {
				return Stream.empty();
			}
			Object value = annotationValue.getValue();
			if (value instanceof List) {
				return ((List<AnnotationValue>) value).stream()
					.map((annotation) -> extractValue(annotation.getValue()));
			}
			return Stream.of(extractValue(value));
		}
		private Object extractValue(Object value) {
			if (value instanceof DeclaredType declaredType) {
				return Elements.getQualifiedName(declaredType.asElement());
			}
			return value;
		}
	}
	private static class NamedValuesExtractor extends AbstractValueExtractor {
		private final Set<String> names;
		NamedValuesExtractor(String... names) {
			this.names = new HashSet<>(Arrays.asList(names));
		}
		@Override
		public List<Object> getValues(AnnotationMirror annotation) {
			List<Object> result = new ArrayList<>();
			annotation.getElementValues().forEach((key, value) -> {
				if (this.names.contains(key.getSimpleName().toString())) {
					extractValues(value).forEach(result::add);
				}
			});
			return result;
		}
	}
	static class OnBeanConditionValueExtractor extends AbstractValueExtractor {
		@Override
		public List<Object> getValues(AnnotationMirror annotation) {
			Map<String, AnnotationValue> attributes = new LinkedHashMap<>();
			annotation.getElementValues()
				.forEach((key, value) -> attributes.put(key.getSimpleName().toString(), value));
			if (attributes.containsKey('name')) {
				return Collections.emptyList();
			}
			List<Object> result = new ArrayList<>();
			extractValues(attributes.get('value')).forEach(result::add);
			extractValues(attributes.get('type')).forEach(result::add);
			return result;
		}
	}
	static class OnClassConditionValueExtractor extends NamedValuesExtractor {
		OnClassConditionValueExtractor() {
			super('value', 'name');
		}
		@Override
		public List<Object> getValues(AnnotationMirror annotation) {
			List<Object> values = super.getValues(annotation);
			values.sort(this::compare);
			return values;
		}
		private int compare(Object o1, Object o2) {
			return Comparator.comparing(this::isSpringClass)
				.thenComparing(String.CASE_INSENSITIVE_ORDER)
				.compare(o1.toString(), o2.toString());
		}
		private boolean isSpringClass(String type) {
			return type.startsWith('org.springframework.');
		}
	}
	static final class PropertyGenerator {
		private final String annotationPackage;
		private final String propertyName;
		private final boolean omitEmptyValues;
		private final Map<String, ValueExtractor> valueExtractors;
		private PropertyGenerator(String annotationPackage, String propertyName, boolean omitEmptyValues,
				Map<String, ValueExtractor> valueExtractors) {
			this.annotationPackage = annotationPackage;
			this.propertyName = propertyName;
			this.omitEmptyValues = omitEmptyValues;
			this.valueExtractors = valueExtractors;
		}
		PropertyGenerator withAnnotation(ValueExtractor valueExtractor) {
			return withAnnotation(this.propertyName, valueExtractor);
		}
		PropertyGenerator withAnnotation(String name, ValueExtractor ValueExtractor) {
			Map<String, ValueExtractor> valueExtractors = new LinkedHashMap<>(this.valueExtractors);
			valueExtractors.put(this.annotationPackage + '.' + name, ValueExtractor);
			return new PropertyGenerator(this.annotationPackage, this.propertyName, this.omitEmptyValues,
					valueExtractors);
		}
		Set<String> getSupportedAnnotations() {
			return this.valueExtractors.keySet();
		}
		ValueExtractor getValueExtractor(String annotation) {
			return this.valueExtractors.get(annotation);
		}
		void applyToProperties(Map<String, String> properties, String className, List<Object> annotationValues) {
			if (this.omitEmptyValues && annotationValues.isEmpty()) {
				return;
			}
			mergeProperties(properties, className + '.' + this.propertyName, toCommaDelimitedString(annotationValues));
		}
		private void mergeProperties(Map<String, String> properties, String key, String value) {
			String existingKey = properties.get(key);
			if (existingKey == null || existingKey.isEmpty()) {
				properties.put(key, value);
			}
			else if (!value.isEmpty()) {
				properties.put(key, existingKey + ',' + value);
			}
		}
		private String toCommaDelimitedString(List<Object> list) {
			if (list.isEmpty()) {
				return '';
			}
			StringBuilder result = new StringBuilder();
			for (Object item : list) {
				result.append((!result.isEmpty()) ? ',' : '');
				result.append(item);
			}
			return result.toString();
		}
		static PropertyGenerator of(String annotationPackage, String propertyName) {
			return of(annotationPackage, propertyName, false);
		}
		static PropertyGenerator of(String annotationPackage, String propertyName, boolean omitEmptyValues) {
			return new PropertyGenerator(annotationPackage, propertyName, omitEmptyValues, Collections.emptyMap());
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigureprocessor;
/*
package org.springframework.boot.ant;
/**
public class ShareAntlibLoader extends Task {
	private String refid;
	public ShareAntlibLoader(Project project) {
		setProject(project);
	}
	@Override
	public void execute() throws BuildException {
		if (!StringUtils.hasText(this.refid)) {
			throw new BuildException('@refid has no text');
		}
		getProject().addReference(this.refid, getClass().getClassLoader());
	}
	public void setRefid(String refid) {
		this.refid = refid;
	}
}
/*
package org.springframework.boot.ant;
/**
public class FindMainClass extends Task {
	private static final String SPRING_BOOT_APPLICATION_CLASS_NAME = 'org.springframework.boot.autoconfigure.SpringBootApplication';
	private String mainClass;
	private File classesRoot;
	private String property;
	public FindMainClass(Project project) {
		setProject(project);
	}
	@Override
	public void execute() throws BuildException {
		String mainClass = this.mainClass;
		if (!StringUtils.hasText(mainClass)) {
			mainClass = findMainClass();
			if (!StringUtils.hasText(mainClass)) {
				throw new BuildException('Could not determine main class given @classesRoot ' + this.classesRoot);
			}
		}
		handle(mainClass);
	}
	private String findMainClass() {
		if (this.classesRoot == null) {
			throw new BuildException('one of @mainClass or @classesRoot must be specified');
		}
		if (!this.classesRoot.exists()) {
			throw new BuildException('@classesRoot ' + this.classesRoot + ' does not exist');
		}
		try {
			if (this.classesRoot.isDirectory()) {
				return MainClassFinder.findSingleMainClass(this.classesRoot, SPRING_BOOT_APPLICATION_CLASS_NAME);
			}
			return MainClassFinder.findSingleMainClass(new JarFile(this.classesRoot), '/',
					SPRING_BOOT_APPLICATION_CLASS_NAME);
		}
		catch (IOException ex) {
			throw new BuildException(ex);
		}
	}
	private void handle(String mainClass) {
		if (StringUtils.hasText(this.property)) {
			getProject().setProperty(this.property, mainClass);
		}
		else {
			log('Found main class ' + mainClass);
		}
	}
	/**
	 * Set the main class, which will cause the search to be bypassed.
	 * @param mainClass the main class name
	 */
	public void setMainClass(String mainClass) {
		this.mainClass = mainClass;
	}
	/**
	 * Set the root location of classes to be searched.
	 * @param classesRoot the root location
	 */
	public void setClassesRoot(File classesRoot) {
		this.classesRoot = classesRoot;
	}
	/**
	 * Set the ANT property to set (if left unset, result will be printed to the log).
	 * @param property the ANT property to set
	 */
	public void setProperty(String property) {
		this.property = property;
	}
}
/*
/**
package org.springframework.boot.ant;
/*
package org.test;
public class SampleApplication {
	public static void main(String[] args) {
		System.out.println(LocalDate.class.getSimpleName());
	}
}
/*
package org.springframework.boot.loader;
/**
class ClassPathIndexFileTests {
	@TempDir
	File temp;
	@Test
	void loadIfPossibleWhenRootIsNotFileReturnsNull() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ClassPathIndexFile.loadIfPossible(new URL('https://example.com/file'), 'test.idx'))
			.withMessage('URL does not reference a file');
	}
	@Test
	void loadIfPossibleWhenRootDoesNotExistReturnsNull() throws Exception {
		File root = new File(this.temp, 'missing');
		assertThat(ClassPathIndexFile.loadIfPossible(root.toURI().toURL(), 'test.idx')).isNull();
	}
	@Test
	void loadIfPossibleWhenRootIsDirectoryThrowsException() throws Exception {
		File root = new File(this.temp, 'directory');
		root.mkdirs();
		assertThat(ClassPathIndexFile.loadIfPossible(root.toURI().toURL(), 'test.idx')).isNull();
	}
	@Test
	void loadIfPossibleReturnsInstance() throws Exception {
		ClassPathIndexFile indexFile = copyAndLoadTestIndexFile();
		assertThat(indexFile).isNotNull();
	}
	@Test
	void sizeReturnsNumberOfLines() throws Exception {
		ClassPathIndexFile indexFile = copyAndLoadTestIndexFile();
		assertThat(indexFile.size()).isEqualTo(5);
	}
	@Test
	void getUrlsReturnsUrls() throws Exception {
		ClassPathIndexFile indexFile = copyAndLoadTestIndexFile();
		List<URL> urls = indexFile.getUrls();
		List<File> expected = new ArrayList<>();
		expected.add(new File(this.temp, 'BOOT-INF/layers/one/lib/a.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/one/lib/b.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/one/lib/c.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/two/lib/d.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/two/lib/e.jar'));
		assertThat(urls).containsExactly(expected.stream().map(this::toUrl).toArray(URL[]::new));
	}
	private URL toUrl(File file) {
		try {
			return file.toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private ClassPathIndexFile copyAndLoadTestIndexFile() throws IOException {
		copyTestIndexFile();
		ClassPathIndexFile indexFile = ClassPathIndexFile.loadIfPossible(this.temp.toURI().toURL(), 'test.idx');
		return indexFile;
	}
	private void copyTestIndexFile() throws IOException {
		Files.copy(getClass().getResourceAsStream('classpath-index-file.idx'),
				new File(this.temp, 'test.idx').toPath());
	}
}
/*
package org.springframework.boot.loader;
/**
public abstract class AbstractExecutableArchiveLauncherTests {
	@TempDir
	File tempDir;
	protected File createJarArchive(String name, String entryPrefix) throws IOException {
		return createJarArchive(name, entryPrefix, false, Collections.emptyList());
	}
	@SuppressWarnings('resource')
	protected File createJarArchive(String name, String entryPrefix, boolean indexed, List<String> extraLibs)
			throws IOException {
		return createJarArchive(name, null, entryPrefix, indexed, extraLibs);
	}
	@SuppressWarnings('resource')
	protected File createJarArchive(String name, Manifest manifest, String entryPrefix, boolean indexed,
			List<String> extraLibs) throws IOException {
		File archive = new File(this.tempDir, name);
		JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(archive));
		if (manifest != null) {
			jarOutputStream.putNextEntry(new JarEntry('META-INF/'));
			jarOutputStream.putNextEntry(new JarEntry('META-INF/MANIFEST.MF'));
			manifest.write(jarOutputStream);
			jarOutputStream.closeEntry();
		}
		jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/'));
		jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/classes/'));
		jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/lib/'));
		if (indexed) {
			jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/classpath.idx'));
			Writer writer = new OutputStreamWriter(jarOutputStream, StandardCharsets.UTF_8);
			writer.write('- \'' + entryPrefix + '/lib/foo.jar\'\n');
			writer.write('- \'' + entryPrefix + '/lib/bar.jar\'\n');
			writer.write('- \'' + entryPrefix + '/lib/baz.jar\'\n');
			writer.flush();
			jarOutputStream.closeEntry();
		}
		addNestedJars(entryPrefix, '/lib/foo.jar', jarOutputStream);
		addNestedJars(entryPrefix, '/lib/bar.jar', jarOutputStream);
		addNestedJars(entryPrefix, '/lib/baz.jar', jarOutputStream);
		for (String lib : extraLibs) {
			addNestedJars(entryPrefix, '/lib/' + lib, jarOutputStream);
		}
		jarOutputStream.close();
		return archive;
	}
	private void addNestedJars(String entryPrefix, String lib, JarOutputStream jarOutputStream) throws IOException {
		JarEntry libFoo = new JarEntry(entryPrefix + lib);
		libFoo.setMethod(ZipEntry.STORED);
		ByteArrayOutputStream fooJarStream = new ByteArrayOutputStream();
		new JarOutputStream(fooJarStream).close();
		libFoo.setSize(fooJarStream.size());
		CRC32 crc32 = new CRC32();
		crc32.update(fooJarStream.toByteArray());
		libFoo.setCrc(crc32.getValue());
		jarOutputStream.putNextEntry(libFoo);
		jarOutputStream.write(fooJarStream.toByteArray());
	}
	protected File explode(File archive) throws IOException {
		File exploded = new File(this.tempDir, 'exploded');
		exploded.mkdirs();
		JarFile jarFile = new JarFile(archive);
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			JarEntry entry = entries.nextElement();
			File entryFile = new File(exploded, entry.getName());
			if (entry.isDirectory()) {
				entryFile.mkdirs();
			}
			else {
				FileCopyUtils.copy(jarFile.getInputStream(entry), new FileOutputStream(entryFile));
			}
		}
		jarFile.close();
		return exploded;
	}
	protected Set<URL> getUrls(List<Archive> archives) throws MalformedURLException {
		Set<URL> urls = new LinkedHashSet<>(archives.size());
		for (Archive archive : archives) {
			urls.add(archive.getUrl());
		}
		return urls;
	}
	protected final URL toUrl(File file) {
		try {
			return file.toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.loader.jarmode;
/**
@ExtendWith(OutputCaptureExtension.class)
class LauncherJarModeTests {
	@BeforeEach
	void setup() {
		System.setProperty(JarModeLauncher.DISABLE_SYSTEM_EXIT, 'true');
	}
	@AfterEach
	void cleanup() {
		System.clearProperty('jarmode');
		System.clearProperty(JarModeLauncher.DISABLE_SYSTEM_EXIT);
	}
	@Test
	void launchWhenJarModePropertyIsSetLaunchesJarMode(CapturedOutput out) throws Exception {
		System.setProperty('jarmode', 'test');
		new TestLauncher().launch(new String[] { 'boot' });
		assertThat(out).contains('running in test jar mode [boot]');
	}
	@Test
	void launchWhenJarModePropertyIsNotAcceptedThrowsException(CapturedOutput out) throws Exception {
		System.setProperty('jarmode', 'idontexist');
		new TestLauncher().launch(new String[] { 'boot' });
		assertThat(out).contains('Unsupported jarmode "idontexist"');
	}
	private static final class TestLauncher extends Launcher {
		@Override
		protected String getMainClass() throws Exception {
			throw new IllegalStateException('Should not be called');
		}
		@Override
		protected Iterator<Archive> getClassPathArchivesIterator() throws Exception {
			return Collections.emptyIterator();
		}
		@Override
		protected void launch(String[] args) throws Exception {
			super.launch(args);
		}
	}
}
/*
package org.springframework.boot.loader;
/**
public abstract class TestJarCreator {
	private static final int BASE_VERSION = 8;
	private static final int RUNTIME_VERSION;
	static {
		int version;
		try {
			Object runtimeVersion = Runtime.class.getMethod('version').invoke(null);
			version = (int) runtimeVersion.getClass().getMethod('major').invoke(runtimeVersion);
		}
		catch (Throwable ex) {
			version = BASE_VERSION;
		}
		RUNTIME_VERSION = version;
	}
	public static void createTestJar(File file) throws Exception {
		createTestJar(file, false);
	}
	public static void createTestJar(File file, boolean unpackNested) throws Exception {
		FileOutputStream fileOutputStream = new FileOutputStream(file);
		try (JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream)) {
			jarOutputStream.setComment('outer');
			writeManifest(jarOutputStream, 'j1');
			writeEntry(jarOutputStream, '1.dat', 1);
			writeEntry(jarOutputStream, '2.dat', 2);
			writeDirEntry(jarOutputStream, 'd/');
			writeEntry(jarOutputStream, 'd/9.dat', 9);
			writeDirEntry(jarOutputStream, 'special/');
			writeEntry(jarOutputStream, 'special/\u00EB.dat', "\u00EB");
			writeNestedEntry('nested.jar', unpackNested, jarOutputStream);
			writeNestedEntry('another-nested.jar', unpackNested, jarOutputStream);
			writeNestedEntry('space nested.jar', unpackNested, jarOutputStream);
			writeNestedMultiReleaseEntry('multi-release.jar', unpackNested, jarOutputStream);
		}
	}
	private static void writeNestedEntry(String name, boolean unpackNested, JarOutputStream jarOutputStream)
			throws Exception {
		writeNestedEntry(name, unpackNested, jarOutputStream, false);
	}
	private static void writeNestedMultiReleaseEntry(String name, boolean unpackNested, JarOutputStream jarOutputStream)
			throws Exception {
		writeNestedEntry(name, unpackNested, jarOutputStream, true);
	}
	private static void writeNestedEntry(String name, boolean unpackNested, JarOutputStream jarOutputStream,
			boolean multiRelease) throws Exception {
		JarEntry nestedEntry = new JarEntry(name);
		byte[] nestedJarData = getNestedJarData(multiRelease);
		nestedEntry.setSize(nestedJarData.length);
		nestedEntry.setCompressedSize(nestedJarData.length);
		if (unpackNested) {
			nestedEntry.setComment('UNPACK:0000000000000000000000000000000000000000');
		}
		CRC32 crc32 = new CRC32();
		crc32.update(nestedJarData);
		nestedEntry.setCrc(crc32.getValue());
		nestedEntry.setMethod(ZipEntry.STORED);
		jarOutputStream.putNextEntry(nestedEntry);
		jarOutputStream.write(nestedJarData);
		jarOutputStream.closeEntry();
	}
	private static byte[] getNestedJarData(boolean multiRelease) throws Exception {
		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
		JarOutputStream jarOutputStream = new JarOutputStream(byteArrayOutputStream);
		jarOutputStream.setComment('nested');
		writeManifest(jarOutputStream, 'j2', multiRelease);
		if (multiRelease) {
			writeEntry(jarOutputStream, 'multi-release.dat', BASE_VERSION);
			writeEntry(jarOutputStream, String.format('META-INF/versions/%d/multi-release.dat', RUNTIME_VERSION),
					RUNTIME_VERSION);
		}
		else {
			writeEntry(jarOutputStream, '3.dat', 3);
			writeEntry(jarOutputStream, '4.dat', 4);
			writeEntry(jarOutputStream, '\u00E4.dat', "\u00E4");
		}
		jarOutputStream.close();
		return byteArrayOutputStream.toByteArray();
	}
	private static void writeManifest(JarOutputStream jarOutputStream, String name) throws Exception {
		writeManifest(jarOutputStream, name, false);
	}
	private static void writeManifest(JarOutputStream jarOutputStream, String name, boolean multiRelease)
			throws Exception {
		writeDirEntry(jarOutputStream, 'META-INF/');
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue('Built-By', name);
		manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, '1.0');
		if (multiRelease) {
			manifest.getMainAttributes().putValue('Multi-Release', Boolean.toString(true));
		}
		jarOutputStream.putNextEntry(new ZipEntry('META-INF/MANIFEST.MF'));
		manifest.write(jarOutputStream);
		jarOutputStream.closeEntry();
	}
	private static void writeDirEntry(JarOutputStream jarOutputStream, String name) throws IOException {
		jarOutputStream.putNextEntry(new JarEntry(name));
		jarOutputStream.closeEntry();
	}
	private static void writeEntry(JarOutputStream jarOutputStream, String name, int data) throws IOException {
		jarOutputStream.putNextEntry(new JarEntry(name));
		jarOutputStream.write(new byte[] { (byte) data });
		jarOutputStream.closeEntry();
	}
}
/*
package org.springframework.boot.loader.data;
/**
class RandomAccessDataFileTests {
	private static final byte[] BYTES;
	static {
		BYTES = new byte[256];
		for (int i = 0; i < BYTES.length; i++) {
			BYTES[i] = (byte) i;
		}
	}
	private File tempFile;
	private RandomAccessDataFile file;
	private InputStream inputStream;
	@BeforeEach
	void setup(@TempDir File tempDir) throws Exception {
		this.tempFile = new File(tempDir, 'tempFile');
		FileOutputStream outputStream = new FileOutputStream(this.tempFile);
		outputStream.write(BYTES);
		outputStream.close();
		this.file = new RandomAccessDataFile(this.tempFile);
		this.inputStream = this.file.getInputStream();
	}
	@AfterEach
	void cleanup() throws Exception {
		this.inputStream.close();
		this.file.close();
	}
	@Test
	void fileNotNull() {
		assertThatIllegalArgumentException().isThrownBy(() -> new RandomAccessDataFile(null))
			.withMessageContaining('File must not be null');
	}
	@Test
	void fileExists() {
		File file = new File('/does/not/exist');
		assertThatIllegalArgumentException().isThrownBy(() -> new RandomAccessDataFile(file))
			.withMessageContaining(String.format('File %s must exist', file.getAbsolutePath()));
	}
	@Test
	void readWithOffsetAndLengthShouldRead() throws Exception {
		byte[] read = this.file.read(2, 3);
		assertThat(read).isEqualTo(new byte[] { 2, 3, 4 });
	}
	@Test
	void readWhenOffsetIsBeyondEOFShouldThrowException() {
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> this.file.read(257, 0));
	}
	@Test
	void readWhenOffsetIsBeyondEndOfSubsectionShouldThrowException() {
		RandomAccessData subsection = this.file.getSubsection(0, 10);
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> subsection.read(11, 0));
	}
	@Test
	void readWhenOffsetPlusLengthGreaterThanEOFShouldThrowException() {
		assertThatExceptionOfType(EOFException.class).isThrownBy(() -> this.file.read(256, 1));
	}
	@Test
	void readWhenOffsetPlusLengthGreaterThanEndOfSubsectionShouldThrowException() {
		RandomAccessData subsection = this.file.getSubsection(0, 10);
		assertThatExceptionOfType(EOFException.class).isThrownBy(() -> subsection.read(10, 1));
	}
	@Test
	void inputStreamRead() throws Exception {
		for (int i = 0; i <= 255; i++) {
			assertThat(this.inputStream.read()).isEqualTo(i);
		}
	}
	@Test
	void inputStreamReadNullBytes() {
		assertThatNullPointerException().isThrownBy(() -> this.inputStream.read(null))
			.withMessage('Bytes must not be null');
	}
	@Test
	void inputStreamReadNullBytesWithOffset() {
		assertThatNullPointerException().isThrownBy(() -> this.inputStream.read(null, 0, 1))
			.withMessage('Bytes must not be null');
	}
	@Test
	void inputStreamReadBytes() throws Exception {
		byte[] b = new byte[256];
		int amountRead = this.inputStream.read(b);
		assertThat(b).isEqualTo(BYTES);
		assertThat(amountRead).isEqualTo(256);
	}
	@Test
	void inputStreamReadOffsetBytes() throws Exception {
		byte[] b = new byte[7];
		this.inputStream.skip(1);
		int amountRead = this.inputStream.read(b, 2, 3);
		assertThat(b).isEqualTo(new byte[] { 0, 0, 1, 2, 3, 0, 0 });
		assertThat(amountRead).isEqualTo(3);
	}
	@Test
	void inputStreamReadMoreBytesThanAvailable() throws Exception {
		byte[] b = new byte[257];
		int amountRead = this.inputStream.read(b);
		assertThat(b).startsWith(BYTES);
		assertThat(amountRead).isEqualTo(256);
	}
	@Test
	void inputStreamReadPastEnd() throws Exception {
		this.inputStream.skip(255);
		assertThat(this.inputStream.read()).isEqualTo(0xFF);
		assertThat(this.inputStream.read()).isEqualTo(-1);
		assertThat(this.inputStream.read()).isEqualTo(-1);
	}
	@Test
	void inputStreamReadZeroLength() throws Exception {
		byte[] b = new byte[] { 0x0F };
		int amountRead = this.inputStream.read(b, 0, 0);
		assertThat(b).isEqualTo(new byte[] { 0x0F });
		assertThat(amountRead).isZero();
		assertThat(this.inputStream.read()).isZero();
	}
	@Test
	void inputStreamSkip() throws Exception {
		long amountSkipped = this.inputStream.skip(4);
		assertThat(this.inputStream.read()).isEqualTo(4);
		assertThat(amountSkipped).isEqualTo(4L);
	}
	@Test
	void inputStreamSkipMoreThanAvailable() throws Exception {
		long amountSkipped = this.inputStream.skip(257);
		assertThat(this.inputStream.read()).isEqualTo(-1);
		assertThat(amountSkipped).isEqualTo(256L);
	}
	@Test
	void inputStreamSkipPastEnd() throws Exception {
		this.inputStream.skip(256);
		long amountSkipped = this.inputStream.skip(1);
		assertThat(amountSkipped).isZero();
	}
	@Test
	void inputStreamAvailable() throws Exception {
		assertThat(this.inputStream.available()).isEqualTo(256);
		this.inputStream.skip(56);
		assertThat(this.inputStream.available()).isEqualTo(200);
		this.inputStream.skip(200);
		assertThat(this.inputStream.available()).isZero();
	}
	@Test
	void subsectionNegativeOffset() {
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> this.file.getSubsection(-1, 1));
	}
	@Test
	void subsectionNegativeLength() {
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> this.file.getSubsection(0, -1));
	}
	@Test
	void subsectionZeroLength() throws Exception {
		RandomAccessData subsection = this.file.getSubsection(0, 0);
		assertThat(subsection.getInputStream().read()).isEqualTo(-1);
	}
	@Test
	void subsectionTooBig() {
		this.file.getSubsection(0, 256);
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> this.file.getSubsection(0, 257));
	}
	@Test
	void subsectionTooBigWithOffset() {
		this.file.getSubsection(1, 255);
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> this.file.getSubsection(1, 256));
	}
	@Test
	void subsection() throws Exception {
		RandomAccessData subsection = this.file.getSubsection(1, 1);
		assertThat(subsection.getInputStream().read()).isOne();
	}
	@Test
	void inputStreamReadPastSubsection() throws Exception {
		RandomAccessData subsection = this.file.getSubsection(1, 2);
		InputStream inputStream = subsection.getInputStream();
		assertThat(inputStream.read()).isOne();
		assertThat(inputStream.read()).isEqualTo(2);
		assertThat(inputStream.read()).isEqualTo(-1);
	}
	@Test
	void inputStreamReadBytesPastSubsection() throws Exception {
		RandomAccessData subsection = this.file.getSubsection(1, 2);
		InputStream inputStream = subsection.getInputStream();
		byte[] b = new byte[3];
		int amountRead = inputStream.read(b);
		assertThat(b).isEqualTo(new byte[] { 1, 2, 0 });
		assertThat(amountRead).isEqualTo(2);
	}
	@Test
	void inputStreamSkipPastSubsection() throws Exception {
		RandomAccessData subsection = this.file.getSubsection(1, 2);
		InputStream inputStream = subsection.getInputStream();
		assertThat(inputStream.skip(3)).isEqualTo(2L);
		assertThat(inputStream.read()).isEqualTo(-1);
	}
	@Test
	void inputStreamSkipNegative() throws Exception {
		assertThat(this.inputStream.skip(-1)).isZero();
	}
	@Test
	void getFile() {
		assertThat(this.file.getFile()).isEqualTo(this.tempFile);
	}
	@Test
	void concurrentReads() throws Exception {
		ExecutorService executorService = Executors.newFixedThreadPool(20);
		List<Future<Boolean>> results = new ArrayList<>();
		for (int i = 0; i < 100; i++) {
			results.add(executorService.submit(() -> {
				InputStream subsectionInputStream = RandomAccessDataFileTests.this.file.getSubsection(0, 256)
					.getInputStream();
				byte[] b = new byte[256];
				subsectionInputStream.read(b);
				return Arrays.equals(b, BYTES);
			}));
		}
		for (Future<Boolean> future : results) {
			assertThat(future.get()).isTrue();
		}
	}
}
/*
package org.springframework.boot.loader;
/**
class WarLauncherTests extends AbstractExecutableArchiveLauncherTests {
	@Test
	void explodedWarHasOnlyWebInfClassesAndContentsOfWebInfLibOnClasspath() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.war', 'WEB-INF'));
		WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot, true));
		List<Archive> archives = new ArrayList<>();
		launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(getUrls(archives)).containsExactlyInAnyOrder(getExpectedFileUrls(explodedRoot));
		for (Archive archive : archives) {
			archive.close();
		}
	}
	@Test
	void archivedWarHasOnlyWebInfClassesAndContentsOfWebInfLibOnClasspath() throws Exception {
		File jarRoot = createJarArchive('archive.war', 'WEB-INF');
		try (JarFileArchive archive = new JarFileArchive(jarRoot)) {
			WarLauncher launcher = new WarLauncher(archive);
			List<Archive> classPathArchives = new ArrayList<>();
			launcher.getClassPathArchivesIterator().forEachRemaining(classPathArchives::add);
			assertThat(getUrls(classPathArchives)).containsOnly(
					new URL('jar:' + jarRoot.toURI().toURL() + '!/WEB-INF/classes!/'),
					new URL('jar:' + jarRoot.toURI().toURL() + '!/WEB-INF/lib/foo.jar!/'),
					new URL('jar:' + jarRoot.toURI().toURL() + '!/WEB-INF/lib/bar.jar!/'),
					new URL('jar:' + jarRoot.toURI().toURL() + '!/WEB-INF/lib/baz.jar!/'));
			for (Archive classPathArchive : classPathArchives) {
				classPathArchive.close();
			}
		}
	}
	@Test
	void explodedWarShouldPreserveClasspathOrderWhenIndexPresent() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.war', 'WEB-INF', true, Collections.emptyList()));
		WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot, true));
		Iterator<Archive> archives = launcher.getClassPathArchivesIterator();
		URLClassLoader classLoader = (URLClassLoader) launcher.createClassLoader(archives);
		URL[] urls = classLoader.getURLs();
		assertThat(urls).containsExactly(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void warFilesPresentInWebInfLibsAndNotInClasspathIndexShouldBeAddedAfterWebInfClasses() throws Exception {
		ArrayList<String> extraLibs = new ArrayList<>(Arrays.asList('extra-1.jar', 'extra-2.jar'));
		File explodedRoot = explode(createJarArchive('archive.war', 'WEB-INF', true, extraLibs));
		WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot, true));
		Iterator<Archive> archives = launcher.getClassPathArchivesIterator();
		URLClassLoader classLoader = (URLClassLoader) launcher.createClassLoader(archives);
		URL[] urls = classLoader.getURLs();
		List<File> expectedFiles = getExpectedFilesWithExtraLibs(explodedRoot);
		URL[] expectedFileUrls = expectedFiles.stream().map(this::toUrl).toArray(URL[]::new);
		assertThat(urls).containsExactly(expectedFileUrls);
	}
	protected final URL[] getExpectedFileUrls(File explodedRoot) {
		return getExpectedFiles(explodedRoot).stream().map(this::toUrl).toArray(URL[]::new);
	}
	protected final List<File> getExpectedFiles(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'WEB-INF/classes'));
		expected.add(new File(parent, 'WEB-INF/lib/foo.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/bar.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/baz.jar'));
		return expected;
	}
	protected final List<File> getExpectedFilesWithExtraLibs(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'WEB-INF/classes'));
		expected.add(new File(parent, 'WEB-INF/lib/extra-1.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/extra-2.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/foo.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/bar.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/baz.jar'));
		return expected;
	}
}
/*
package org.springframework.boot.loader.util;
/**
class SystemPropertyUtilsTests {
	@BeforeEach
	void init() {
		System.setProperty('foo', 'bar');
	}
	@AfterEach
	void close() {
		System.clearProperty('foo');
	}
	@Test
	void testVanillaPlaceholder() {
		assertThat(SystemPropertyUtils.resolvePlaceholders('${foo}')).isEqualTo('bar');
	}
	@Test
	void testDefaultValue() {
		assertThat(SystemPropertyUtils.resolvePlaceholders('${bar:foo}')).isEqualTo('foo');
	}
	@Test
	void testNestedPlaceholder() {
		assertThat(SystemPropertyUtils.resolvePlaceholders('${bar:${spam:foo}}')).isEqualTo('foo');
	}
	@Test
	void testEnvVar() {
		assertThat(SystemPropertyUtils.getProperty('lang')).isEqualTo(System.getenv('LANG'));
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class StringSequenceTests {
	@Test
	void createWhenSourceIsNullShouldThrowException() {
		assertThatNullPointerException().isThrownBy(() -> new StringSequence(null))
			.withMessage('Source must not be null');
	}
	@Test
	void createWithIndexWhenSourceIsNullShouldThrowException() {
		assertThatNullPointerException().isThrownBy(() -> new StringSequence(null, 0, 0))
			.withMessage('Source must not be null');
	}
	@Test
	void createWhenStartIsLessThanZeroShouldThrowException() {
		assertThatExceptionOfType(StringIndexOutOfBoundsException.class)
			.isThrownBy(() -> new StringSequence('x', -1, 0));
	}
	@Test
	void createWhenEndIsGreaterThanLengthShouldThrowException() {
		assertThatExceptionOfType(StringIndexOutOfBoundsException.class)
			.isThrownBy(() -> new StringSequence('x', 0, 2));
	}
	@Test
	void createFromString() {
		assertThat(new StringSequence('test')).hasToString('test');
	}
	@Test
	void subSequenceWithJustStartShouldReturnSubSequence() {
		assertThat(new StringSequence('smiles').subSequence(1)).hasToString('miles');
	}
	@Test
	void subSequenceShouldReturnSubSequence() {
		assertThat(new StringSequence('hamburger').subSequence(4, 8)).hasToString('urge');
		assertThat(new StringSequence('smiles').subSequence(1, 5)).hasToString('mile');
	}
	@Test
	void subSequenceWhenCalledMultipleTimesShouldReturnSubSequence() {
		assertThat(new StringSequence('hamburger').subSequence(4, 8).subSequence(1, 3)).hasToString('rg');
	}
	@Test
	void subSequenceWhenEndPastExistingEndShouldThrowException() {
		StringSequence sequence = new StringSequence('abcde').subSequence(1, 4);
		assertThat(sequence).hasToString('bcd');
		assertThat(sequence.subSequence(2, 3)).hasToString('d');
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> sequence.subSequence(3, 4));
	}
	@Test
	void subSequenceWhenStartPastExistingEndShouldThrowException() {
		StringSequence sequence = new StringSequence('abcde').subSequence(1, 4);
		assertThat(sequence).hasToString('bcd');
		assertThat(sequence.subSequence(2, 3)).hasToString('d');
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> sequence.subSequence(4, 3));
	}
	@Test
	void isEmptyWhenEmptyShouldReturnTrue() {
		assertThat(new StringSequence('')).isEmpty();
	}
	@Test
	void isEmptyWhenNotEmptyShouldReturnFalse() {
		assertThat(new StringSequence('x')).isNotEmpty();
	}
	@Test
	void lengthShouldReturnLength() {
		StringSequence sequence = new StringSequence('hamburger');
		assertThat(sequence).hasSize(9);
		assertThat(sequence.subSequence(4, 8)).hasSize(4);
	}
	@Test
	void charAtShouldReturnChar() {
		StringSequence sequence = new StringSequence('hamburger');
		assertThat(sequence.charAt(0)).isEqualTo("h");
		assertThat(sequence.charAt(1)).isEqualTo("a");
		assertThat(sequence.subSequence(4, 8).charAt(0)).isEqualTo("u");
		assertThat(sequence.subSequence(4, 8).charAt(1)).isEqualTo("r");
	}
	@Test
	void indexOfCharShouldReturnIndexOf() {
		StringSequence sequence = new StringSequence('aabbaacc');
		assertThat(sequence.indexOf("a")).isZero();
		assertThat(sequence.indexOf("b")).isEqualTo(2);
		assertThat(sequence.subSequence(2).indexOf("a")).isEqualTo(2);
	}
	@Test
	void indexOfStringShouldReturnIndexOf() {
		StringSequence sequence = new StringSequence('aabbaacc');
		assertThat(sequence.indexOf("a")).isZero();
		assertThat(sequence.indexOf("b")).isEqualTo(2);
		assertThat(sequence.subSequence(2).indexOf("a")).isEqualTo(2);
	}
	@Test
	void indexOfStringFromIndexShouldReturnIndexOf() {
		StringSequence sequence = new StringSequence('aabbaacc');
		assertThat(sequence.indexOf('a', 2)).isEqualTo(4);
		assertThat(sequence.indexOf('b', 3)).isEqualTo(3);
		assertThat(sequence.subSequence(2).indexOf('a', 3)).isEqualTo(3);
	}
	@Test
	void hashCodeShouldBeSameAsString() {
		assertThat(new StringSequence('hamburger')).hasSameHashCodeAs('hamburger');
		assertThat(new StringSequence('hamburger').subSequence(4, 8)).hasSameHashCodeAs('urge');
	}
	@Test
	void equalsWhenSameContentShouldMatch() {
		StringSequence a = new StringSequence('hamburger').subSequence(4, 8);
		StringSequence b = new StringSequence('urge');
		StringSequence c = new StringSequence('urgh');
		assertThat(a).isEqualTo(b).isNotEqualTo(c);
	}
	@Test
	void notEqualsWhenSequencesOfDifferentLength() {
		StringSequence a = new StringSequence('abcd');
		StringSequence b = new StringSequence('ef');
		assertThat(a).isNotEqualTo(b);
	}
	@Test
	void startsWithWhenExactMatch() {
		assertThat(new StringSequence('abc').startsWith('abc')).isTrue();
	}
	@Test
	void startsWithWhenLongerAndStartsWith() {
		assertThat(new StringSequence('abcd').startsWith('abc')).isTrue();
	}
	@Test
	void startsWithWhenLongerAndDoesNotStartWith() {
		assertThat(new StringSequence('abcd').startsWith('abx')).isFalse();
	}
	@Test
	void startsWithWhenShorterAndDoesNotStartWith() {
		assertThat(new StringSequence('ab').startsWith('abc')).isFalse();
		assertThat(new StringSequence('ab').startsWith('c')).isFalse();
	}
	@Test
	void startsWithOffsetWhenExactMatch() {
		assertThat(new StringSequence('xabc').startsWith('abc', 1)).isTrue();
	}
	@Test
	void startsWithOffsetWhenLongerAndStartsWith() {
		assertThat(new StringSequence('xabcd').startsWith('abc', 1)).isTrue();
	}
	@Test
	void startsWithOffsetWhenLongerAndDoesNotStartWith() {
		assertThat(new StringSequence('xabcd').startsWith('abx', 1)).isFalse();
	}
	@Test
	void startsWithOffsetWhenShorterAndDoesNotStartWith() {
		assertThat(new StringSequence('xab').startsWith('abc', 1)).isFalse();
		assertThat(new StringSequence('xab').startsWith('c', 1)).isFalse();
	}
	@Test
	void startsWithOnSubstringTailWhenMatch() {
		StringSequence subSequence = new StringSequence('xabc').subSequence(1);
		assertThat(subSequence.startsWith('abc')).isTrue();
		assertThat(subSequence.startsWith('abcd')).isFalse();
	}
	@Test
	void startsWithOnSubstringMiddleWhenMatch() {
		StringSequence subSequence = new StringSequence('xabc').subSequence(1, 3);
		assertThat(subSequence.startsWith('ab')).isTrue();
		assertThat(subSequence.startsWith('abc')).isFalse();
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarUrlProtocolHandler implements BeforeEachCallback, AfterEachCallback {
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		JarFile.registerUrlProtocolHandler();
	}
	@Override
	@SuppressWarnings('unchecked')
	public void afterEach(ExtensionContext context) throws Exception {
		Map<File, JarFile> rootFileCache = ((SoftReference<Map<File, JarFile>>) ReflectionTestUtils
			.getField(Handler.class, 'rootFileCache')).get();
		if (rootFileCache != null) {
			for (JarFile rootJarFile : rootFileCache.values()) {
				rootJarFile.close();
			}
			rootFileCache.clear();
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class AsciiBytesTests {
	private static final char NO_SUFFIX = 0;
	@Test
	void createFromBytes() {
		AsciiBytes bytes = new AsciiBytes(new byte[] { 65, 66 });
		assertThat(bytes).hasToString('AB');
	}
	@Test
	void createFromBytesWithOffset() {
		AsciiBytes bytes = new AsciiBytes(new byte[] { 65, 66, 67, 68 }, 1, 2);
		assertThat(bytes).hasToString('BC');
	}
	@Test
	void createFromString() {
		AsciiBytes bytes = new AsciiBytes('AB');
		assertThat(bytes).hasToString('AB');
	}
	@Test
	void length() {
		AsciiBytes b1 = new AsciiBytes(new byte[] { 65, 66 });
		AsciiBytes b2 = new AsciiBytes(new byte[] { 65, 66, 67, 68 }, 1, 2);
		assertThat(b1.length()).isEqualTo(2);
		assertThat(b2.length()).isEqualTo(2);
	}
	@Test
	void startWith() {
		AsciiBytes abc = new AsciiBytes(new byte[] { 65, 66, 67 });
		AsciiBytes ab = new AsciiBytes(new byte[] { 65, 66 });
		AsciiBytes bc = new AsciiBytes(new byte[] { 65, 66, 67 }, 1, 2);
		AsciiBytes abcd = new AsciiBytes(new byte[] { 65, 66, 67, 68 });
		assertThat(abc.startsWith(abc)).isTrue();
		assertThat(abc.startsWith(ab)).isTrue();
		assertThat(abc.startsWith(bc)).isFalse();
		assertThat(abc.startsWith(abcd)).isFalse();
	}
	@Test
	void endsWith() {
		AsciiBytes abc = new AsciiBytes(new byte[] { 65, 66, 67 });
		AsciiBytes bc = new AsciiBytes(new byte[] { 65, 66, 67 }, 1, 2);
		AsciiBytes ab = new AsciiBytes(new byte[] { 65, 66 });
		AsciiBytes aabc = new AsciiBytes(new byte[] { 65, 65, 66, 67 });
		assertThat(abc.endsWith(abc)).isTrue();
		assertThat(abc.endsWith(bc)).isTrue();
		assertThat(abc.endsWith(ab)).isFalse();
		assertThat(abc.endsWith(aabc)).isFalse();
	}
	@Test
	void substringFromBeingIndex() {
		AsciiBytes abcd = new AsciiBytes(new byte[] { 65, 66, 67, 68 });
		assertThat(abcd.substring(0)).hasToString('ABCD');
		assertThat(abcd.substring(1)).hasToString('BCD');
		assertThat(abcd.substring(2)).hasToString('CD');
		assertThat(abcd.substring(3)).hasToString('D');
		assertThat(abcd.substring(4).toString()).isEmpty();
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> abcd.substring(5));
	}
	@Test
	void substring() {
		AsciiBytes abcd = new AsciiBytes(new byte[] { 65, 66, 67, 68 });
		assertThat(abcd.substring(0, 4)).hasToString('ABCD');
		assertThat(abcd.substring(1, 3)).hasToString('BC');
		assertThat(abcd.substring(3, 4)).hasToString('D');
		assertThat(abcd.substring(3, 3).toString()).isEmpty();
		assertThatExceptionOfType(IndexOutOfBoundsException.class).isThrownBy(() -> abcd.substring(3, 5));
	}
	@Test
	void hashCodeAndEquals() {
		AsciiBytes abcd = new AsciiBytes(new byte[] { 65, 66, 67, 68 });
		AsciiBytes bc = new AsciiBytes(new byte[] { 66, 67 });
		AsciiBytes bc_substring = new AsciiBytes(new byte[] { 65, 66, 67, 68 }).substring(1, 3);
		AsciiBytes bc_string = new AsciiBytes('BC');
		assertThat(bc).hasSameHashCodeAs(bc);
		assertThat(bc).hasSameHashCodeAs(bc_substring);
		assertThat(bc).hasSameHashCodeAs(bc_string);
		assertThat(bc).isEqualTo(bc);
		assertThat(bc).isEqualTo(bc_substring);
		assertThat(bc).isEqualTo(bc_string);
		assertThat(bc.hashCode()).isNotEqualTo(abcd.hashCode());
		assertThat(bc).isNotEqualTo(abcd);
	}
	@Test
	void hashCodeSameAsString() {
		hashCodeSameAsString('abcABC123xyz!');
	}
	@Test
	void hashCodeSameAsStringWithSpecial() {
		hashCodeSameAsString('special/\u00EB.dat');
	}
	@Test
	void hashCodeSameAsStringWithCyrillicCharacters() {
		hashCodeSameAsString('\u0432\u0435\u0441\u043D\u0430');
	}
	@Test
	void hashCodeSameAsStringWithEmoji() {
		hashCodeSameAsString('\ud83d\udca9');
	}
	private void hashCodeSameAsString(String input) {
		assertThat(new AsciiBytes(input)).hasSameHashCodeAs(input);
	}
	@Test
	void matchesSameAsString() {
		matchesSameAsString('abcABC123xyz!');
	}
	@Test
	void matchesSameAsStringWithSpecial() {
		matchesSameAsString('special/\u00EB.dat');
	}
	@Test
	void matchesSameAsStringWithCyrillicCharacters() {
		matchesSameAsString('\u0432\u0435\u0441\u043D\u0430');
	}
	@Test
	void matchesDifferentLengths() {
		assertThat(new AsciiBytes('abc').matches('ab', NO_SUFFIX)).isFalse();
		assertThat(new AsciiBytes('abc').matches('abcd', NO_SUFFIX)).isFalse();
		assertThat(new AsciiBytes('abc').matches('abc', NO_SUFFIX)).isTrue();
		assertThat(new AsciiBytes('abc').matches('a', "b")).isFalse();
		assertThat(new AsciiBytes('abc').matches('abc', "d")).isFalse();
		assertThat(new AsciiBytes('abc').matches('ab', "c")).isTrue();
	}
	@Test
	void matchesSuffix() {
		assertThat(new AsciiBytes('ab').matches('a', "b")).isTrue();
	}
	@Test
	void matchesSameAsStringWithEmoji() {
		matchesSameAsString('\ud83d\udca9');
	}
	@Test
	void hashCodeFromInstanceMatchesHashCodeFromString() {
		String name = 'fonts//simsun.ttf';
		assertThat(new AsciiBytes(name).hashCode()).isEqualTo(AsciiBytes.hashCode(name));
	}
	@Test
	void instanceCreatedFromCharSequenceMatchesSameCharSequence() {
		String name = 'fonts//simsun.ttf';
		assertThat(new AsciiBytes(name).matches(name, NO_SUFFIX)).isTrue();
	}
	private void matchesSameAsString(String input) {
		assertThat(new AsciiBytes(input).matches(input, NO_SUFFIX)).isTrue();
	}
}
/*
package org.springframework.boot.loader.jar;
/**
@ExtendWith(JarUrlProtocolHandler.class)
class HandlerTests {
	private final Handler handler = new Handler();
	@Test
	void parseUrlWithJarRootContextAndAbsoluteSpecThatUsesContext() throws MalformedURLException {
		String spec = '/entry.txt';
		URL context = createUrl('file:example.jar!/');
		this.handler.parseURL(context, spec, 0, spec.length());
		assertThat(context.toExternalForm()).isEqualTo('jar:file:example.jar!/entry.txt');
	}
	@Test
	void parseUrlWithDirectoryEntryContextAndAbsoluteSpecThatUsesContext() throws MalformedURLException {
		String spec = '/entry.txt';
		URL context = createUrl('file:example.jar!/dir/');
		this.handler.parseURL(context, spec, 0, spec.length());
		assertThat(context.toExternalForm()).isEqualTo('jar:file:example.jar!/entry.txt');
	}
	@Test
	void parseUrlWithJarRootContextAndRelativeSpecThatUsesContext() throws MalformedURLException {
		String spec = 'entry.txt';
		URL context = createUrl('file:example.jar!/');
		this.handler.parseURL(context, spec, 0, spec.length());
		assertThat(context.toExternalForm()).isEqualTo('jar:file:example.jar!/entry.txt');
	}
	@Test
	void parseUrlWithDirectoryEntryContextAndRelativeSpecThatUsesContext() throws MalformedURLException {
		String spec = 'entry.txt';
		URL context = createUrl('file:example.jar!/dir/');
		this.handler.parseURL(context, spec, 0, spec.length());
		assertThat(context.toExternalForm()).isEqualTo('jar:file:example.jar!/dir/entry.txt');
	}
	@Test
	void parseUrlWithFileEntryContextAndRelativeSpecThatUsesContext() throws MalformedURLException {
		String spec = 'entry.txt';
		URL context = createUrl('file:example.jar!/dir/file');
		this.handler.parseURL(context, spec, 0, spec.length());
		assertThat(context.toExternalForm()).isEqualTo('jar:file:example.jar!/dir/entry.txt');
	}
	@Test
	void parseUrlWithSpecThatIgnoresContext() throws MalformedURLException {
		JarFile.registerUrlProtocolHandler();
		String spec = 'jar:file:/other.jar!/nested!/entry.txt';
		URL context = createUrl('file:example.jar!/dir/file');
		this.handler.parseURL(context, spec, 0, spec.length());
		assertThat(context.toExternalForm()).isEqualTo('jar:jar:file:/other.jar!/nested!/entry.txt');
	}
	@Test
	void sameFileReturnsFalseForUrlsWithDifferentProtocols() throws MalformedURLException {
		assertThat(this.handler.sameFile(new URL('jar:file:foo.jar!/content.txt'), new URL('file:/foo.jar'))).isFalse();
	}
	@Test
	void sameFileReturnsFalseForDifferentFileInSameJar() throws MalformedURLException {
		assertThat(this.handler.sameFile(new URL('jar:file:foo.jar!/the/path/to/the/first/content.txt'),
				new URL('jar:file:/foo.jar!/content.txt')))
			.isFalse();
	}
	@Test
	void sameFileReturnsFalseForSameFileInDifferentJars() throws MalformedURLException {
		assertThat(this.handler.sameFile(new URL('jar:file:/the/path/to/the/first.jar!/content.txt'),
				new URL('jar:file:/second.jar!/content.txt')))
			.isFalse();
	}
	@Test
	void sameFileReturnsTrueForSameFileInSameJar() throws MalformedURLException {
		assertThat(this.handler.sameFile(new URL('jar:file:/the/path/to/the/first.jar!/content.txt'),
				new URL('jar:file:/the/path/to/the/first.jar!/content.txt')))
			.isTrue();
	}
	@Test
	void sameFileReturnsTrueForUrlsThatReferenceSameFileViaNestedArchiveAndFromRootOfJar()
			throws MalformedURLException {
		assertThat(this.handler.sameFile(new URL('jar:file:/test.jar!/BOOT-INF/classes!/foo.txt'),
				new URL('jar:file:/test.jar!/BOOT-INF/classes/foo.txt')))
			.isTrue();
	}
	@Test
	void hashCodesAreEqualForUrlsThatReferenceSameFileViaNestedArchiveAndFromRootOfJar() throws MalformedURLException {
		assertThat(this.handler.hashCode(new URL('jar:file:/test.jar!/BOOT-INF/classes!/foo.txt')))
			.isEqualTo(this.handler.hashCode(new URL('jar:file:/test.jar!/BOOT-INF/classes/foo.txt')));
	}
	@Test
	void urlWithSpecReferencingParentDirectory() throws MalformedURLException {
		assertStandardAndCustomHandlerUrlsAreEqual('file:/test.jar!/BOOT-INF/classes!/xsd/directoryA/a.xsd',
				'../directoryB/c/d/e.xsd');
	}
	@Test
	void urlWithSpecReferencingAncestorDirectoryOutsideJarStopsAtJarRoot() throws MalformedURLException {
		assertStandardAndCustomHandlerUrlsAreEqual('file:/test.jar!/BOOT-INF/classes!/xsd/directoryA/a.xsd',
				'../../../../../../directoryB/b.xsd');
	}
	@Test
	void urlWithSpecReferencingCurrentDirectory() throws MalformedURLException {
		assertStandardAndCustomHandlerUrlsAreEqual('file:/test.jar!/BOOT-INF/classes!/xsd/directoryA/a.xsd',
				'./directoryB/c/d/e.xsd');
	}
	@Test
	void urlWithRef() throws MalformedURLException {
		assertStandardAndCustomHandlerUrlsAreEqual('file:/test.jar!/BOOT-INF/classes', '!/foo.txt#alpha');
	}
	@Test
	void urlWithQuery() throws MalformedURLException {
		assertStandardAndCustomHandlerUrlsAreEqual('file:/test.jar!/BOOT-INF/classes', '!/foo.txt?alpha');
	}
	@Test
	void fallbackToJdksJarUrlStreamHandler(@TempDir File tempDir) throws Exception {
		File testJar = new File(tempDir, 'test.jar');
		TestJarCreator.createTestJar(testJar);
		URLConnection connection = new URL(null, 'jar:' + testJar.toURI().toURL() + '!/nested.jar!/', this.handler)
			.openConnection();
		assertThat(connection).isInstanceOf(JarURLConnection.class);
		((JarURLConnection) connection).getJarFile().close();
		URLConnection jdkConnection = new URL(null, 'jar:file:' + testJar.toURI().toURL() + '!/nested.jar!/',
				this.handler)
			.openConnection();
		assertThat(jdkConnection).isNotInstanceOf(JarURLConnection.class);
		assertThat(jdkConnection.getClass().getName()).endsWith('.JarURLConnection');
	}
	@Test
	void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception {
		File testJar = new File(tempDir, 't+e+s+t.jar');
		TestJarCreator.createTestJar(testJar);
		URL url = new URL(null, 'jar:' + testJar.toURI().toURL() + '!/nested.jar!/3.dat', this.handler);
		JarURLConnection connection = (JarURLConnection) url.openConnection();
		try (JarFile jarFile = JarFileWrapper.unwrap(connection.getJarFile())) {
			assertThat(jarFile.getRootJarFile().getFile()).isEqualTo(testJar);
		}
	}
	@Test
	void whenJarHasASpaceInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception {
		File testJar = new File(tempDir, 't e s t.jar');
		TestJarCreator.createTestJar(testJar);
		URL url = new URL(null, 'jar:' + testJar.toURI().toURL() + '!/nested.jar!/3.dat', this.handler);
		JarURLConnection connection = (JarURLConnection) url.openConnection();
		try (JarFile jarFile = JarFileWrapper.unwrap(connection.getJarFile())) {
			assertThat(jarFile.getRootJarFile().getFile()).isEqualTo(testJar);
		}
	}
	private void assertStandardAndCustomHandlerUrlsAreEqual(String context, String spec) throws MalformedURLException {
		URL standardUrl = new URL(new URL('jar:' + context), spec);
		URL customHandlerUrl = new URL(new URL('jar', null, -1, context, this.handler), spec);
		assertThat(customHandlerUrl).hasToString(standardUrl.toString());
		assertThat(customHandlerUrl.getFile()).isEqualTo(standardUrl.getFile());
		assertThat(customHandlerUrl.getPath()).isEqualTo(standardUrl.getPath());
		assertThat(customHandlerUrl.getQuery()).isEqualTo(standardUrl.getQuery());
		assertThat(customHandlerUrl.getRef()).isEqualTo(standardUrl.getRef());
	}
	private URL createUrl(String file) throws MalformedURLException {
		return new URL('jar', null, -1, file, this.handler);
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarURLConnectionTests {
	private File rootJarFile;
	private JarFile jarFile;
	@BeforeEach
	void setup(@TempDir File tempDir) throws Exception {
		this.rootJarFile = new File(tempDir, 'root.jar');
		TestJarCreator.createTestJar(this.rootJarFile);
		this.jarFile = new JarFile(this.rootJarFile);
	}
	@AfterEach
	void tearDown() throws Exception {
		this.jarFile.close();
	}
	@Test
	void connectionToRootUsingAbsoluteUrl() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/');
		Object content = JarURLConnection.get(url, this.jarFile).getContent();
		assertThat(JarFileWrapper.unwrap((java.util.jar.JarFile) content)).isSameAs(this.jarFile);
	}
	@Test
	void connectionToRootUsingRelativeUrl() throws Exception {
		URL url = new URL('jar:file:' + getRelativePath() + '!/');
		Object content = JarURLConnection.get(url, this.jarFile).getContent();
		assertThat(JarFileWrapper.unwrap((java.util.jar.JarFile) content)).isSameAs(this.jarFile);
	}
	@Test
	void connectionToEntryUsingAbsoluteUrl() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/1.dat');
		try (InputStream input = JarURLConnection.get(url, this.jarFile).getInputStream()) {
			assertThat(input).hasBinaryContent(new byte[] { 1 });
		}
	}
	@Test
	void connectionToEntryUsingRelativeUrl() throws Exception {
		URL url = new URL('jar:file:' + getRelativePath() + '!/1.dat');
		try (InputStream input = JarURLConnection.get(url, this.jarFile).getInputStream()) {
			assertThat(input).hasBinaryContent(new byte[] { 1 });
		}
	}
	@Test
	void connectionToEntryUsingAbsoluteUrlWithFileColonSlashSlashPrefix() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/1.dat');
		try (InputStream input = JarURLConnection.get(url, this.jarFile).getInputStream()) {
			assertThat(input).hasBinaryContent(new byte[] { 1 });
		}
	}
	@Test
	void connectionToEntryUsingAbsoluteUrlForNestedEntry() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/nested.jar!/3.dat');
		JarURLConnection connection = JarURLConnection.get(url, this.jarFile);
		try (InputStream input = connection.getInputStream()) {
			assertThat(input).hasBinaryContent(new byte[] { 3 });
		}
		connection.getJarFile().close();
	}
	@Test
	void connectionToEntryUsingRelativeUrlForNestedEntry() throws Exception {
		URL url = new URL('jar:file:' + getRelativePath() + '!/nested.jar!/3.dat');
		JarURLConnection connection = JarURLConnection.get(url, this.jarFile);
		try (InputStream input = connection.getInputStream()) {
			assertThat(input).hasBinaryContent(new byte[] { 3 });
		}
		connection.getJarFile().close();
	}
	@Test
	void connectionToEntryUsingAbsoluteUrlForEntryFromNestedJarFile() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/nested.jar!/3.dat');
		try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) {
				assertThat(input).hasBinaryContent(new byte[] { 3 });
			}
		}
	}
	@Test
	void connectionToEntryUsingRelativeUrlForEntryFromNestedJarFile() throws Exception {
		URL url = new URL('jar:file:' + getRelativePath() + '!/nested.jar!/3.dat');
		try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) {
				assertThat(input).hasBinaryContent(new byte[] { 3 });
			}
		}
	}
	@Test
	void connectionToEntryInNestedJarFromUrlThatUsesExistingUrlAsContext() throws Exception {
		URL url = new URL(new URL('jar', null, -1, this.rootJarFile.toURI().toURL() + '!/nested.jar!/', new Handler()),
				'/3.dat');
		try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) {
				assertThat(input).hasBinaryContent(new byte[] { 3 });
			}
		}
	}
	@Test
	void connectionToEntryWithSpaceNestedEntry() throws Exception {
		URL url = new URL('jar:file:' + getRelativePath() + '!/space nested.jar!/3.dat');
		JarURLConnection connection = JarURLConnection.get(url, this.jarFile);
		try (InputStream input = connection.getInputStream()) {
			assertThat(input).hasBinaryContent(new byte[] { 3 });
		}
		connection.getJarFile().close();
	}
	@Test
	void connectionToEntryWithEncodedSpaceNestedEntry() throws Exception {
		URL url = new URL('jar:file:' + getRelativePath() + '!/space%20nested.jar!/3.dat');
		JarURLConnection connection = JarURLConnection.get(url, this.jarFile);
		try (InputStream input = connection.getInputStream()) {
			assertThat(input).hasBinaryContent(new byte[] { 3 });
		}
		connection.getJarFile().close();
	}
	@Test
	void connectionToEntryUsingWrongAbsoluteUrlForEntryFromNestedJarFile() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/w.jar!/3.dat');
		try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			assertThatExceptionOfType(FileNotFoundException.class)
				.isThrownBy(JarURLConnection.get(url, nested)::getInputStream);
		}
	}
	@Test
	void getContentLengthReturnsLengthOfUnderlyingEntry() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/nested.jar!/3.dat');
		try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			JarURLConnection connection = JarURLConnection.get(url, nested);
			assertThat(connection.getContentLength()).isOne();
		}
	}
	@Test
	void getContentLengthLongReturnsLengthOfUnderlyingEntry() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/nested.jar!/3.dat');
		try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			JarURLConnection connection = JarURLConnection.get(url, nested);
			assertThat(connection.getContentLengthLong()).isOne();
		}
	}
	@Test
	void getLastModifiedReturnsLastModifiedTimeOfJarEntry() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/1.dat');
		JarURLConnection connection = JarURLConnection.get(url, this.jarFile);
		assertThat(connection.getLastModified()).isEqualTo(connection.getJarEntry().getTime());
	}
	@Test
	void entriesCanBeStreamedFromJarFileOfConnection() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/');
		JarURLConnection connection = JarURLConnection.get(url, this.jarFile);
		List<String> entryNames = connection.getJarFile().stream().map(JarEntry::getName).toList();
		assertThat(entryNames).hasSize(12);
	}
	@Test
	void jarEntryBasicName() {
		assertThat(new JarEntryName(new StringSequence('a/b/C.class'))).hasToString('a/b/C.class');
	}
	@Test
	void jarEntryNameWithSingleByteEncodedCharacters() {
		assertThat(new JarEntryName(new StringSequence('%61/%62/%43.class'))).hasToString('a/b/C.class');
	}
	@Test
	void jarEntryNameWithDoubleByteEncodedCharacters() {
		assertThat(new JarEntryName(new StringSequence('%c3%a1/b/C.class'))).hasToString('\u00e1/b/C.class');
	}
	@Test
	void jarEntryNameWithMixtureOfEncodedAndUnencodedDoubleByteCharacters() {
		assertThat(new JarEntryName(new StringSequence('%c3%a1/b/\u00c7.class'))).hasToString('\u00e1/b/\u00c7.class');
	}
	@Test
	void openConnectionCanBeClosedWithoutClosingSourceJar() throws Exception {
		URL url = new URL('jar:' + this.rootJarFile.toURI().toURL() + '!/');
		JarURLConnection connection = JarURLConnection.get(url, this.jarFile);
		java.util.jar.JarFile connectionJarFile = connection.getJarFile();
		connectionJarFile.close();
		assertThat(this.jarFile.isClosed()).isFalse();
	}
	private String getRelativePath() {
		return this.rootJarFile.getPath().replace("\\", "/");
	}
}
/*
package org.springframework.boot.loader.jar;
/**
@ExtendWith(JarUrlProtocolHandler.class)
class JarFileTests {
	private static final String PROTOCOL_HANDLER = 'java.protocol.handler.pkgs';
	private static final String HANDLERS_PACKAGE = 'org.springframework.boot.loader';
	@TempDir
	File tempDir;
	private File rootJarFile;
	private JarFile jarFile;
	@BeforeEach
	void setup() throws Exception {
		this.rootJarFile = new File(this.tempDir, 'root.jar');
		TestJarCreator.createTestJar(this.rootJarFile);
		this.jarFile = new JarFile(this.rootJarFile);
	}
	@AfterEach
	void tearDown() throws Exception {
		this.jarFile.close();
	}
	@Test
	void jdkJarFile() throws Exception {
		// Sanity checks to see how the default jar file operates
		java.util.jar.JarFile jarFile = new java.util.jar.JarFile(this.rootJarFile);
		assertThat(jarFile.getComment()).isEqualTo('outer');
		Enumeration<java.util.jar.JarEntry> entries = jarFile.entries();
		assertThat(entries.nextElement().getName()).isEqualTo('META-INF/');
		assertThat(entries.nextElement().getName()).isEqualTo('META-INF/MANIFEST.MF');
		assertThat(entries.nextElement().getName()).isEqualTo('1.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('2.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('d/');
		assertThat(entries.nextElement().getName()).isEqualTo('d/9.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('special/');
		assertThat(entries.nextElement().getName()).isEqualTo('special/\u00EB.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('nested.jar');
		assertThat(entries.nextElement().getName()).isEqualTo('another-nested.jar');
		assertThat(entries.nextElement().getName()).isEqualTo('space nested.jar');
		assertThat(entries.nextElement().getName()).isEqualTo('multi-release.jar');
		assertThat(entries.hasMoreElements()).isFalse();
		URL jarUrl = new URL('jar:' + this.rootJarFile.toURI() + '!/');
		URLClassLoader urlClassLoader = new URLClassLoader(new URL[] { jarUrl });
		assertThat(urlClassLoader.getResource('special/\u00EB.dat')).isNotNull();
		assertThat(urlClassLoader.getResource('d/9.dat')).isNotNull();
		urlClassLoader.close();
		jarFile.close();
	}
	@Test
	void createFromFile() throws Exception {
		JarFile jarFile = new JarFile(this.rootJarFile);
		assertThat(jarFile.getName()).isNotNull();
		jarFile.close();
	}
	@Test
	void getManifest() throws Exception {
		assertThat(this.jarFile.getManifest().getMainAttributes().getValue('Built-By')).isEqualTo('j1');
	}
	@Test
	void getManifestEntry() throws Exception {
		ZipEntry entry = this.jarFile.getJarEntry('META-INF/MANIFEST.MF');
		Manifest manifest = new Manifest(this.jarFile.getInputStream(entry));
		assertThat(manifest.getMainAttributes().getValue('Built-By')).isEqualTo('j1');
	}
	@Test
	void getEntries() {
		Enumeration<java.util.jar.JarEntry> entries = this.jarFile.entries();
		assertThat(entries.nextElement().getName()).isEqualTo('META-INF/');
		assertThat(entries.nextElement().getName()).isEqualTo('META-INF/MANIFEST.MF');
		assertThat(entries.nextElement().getName()).isEqualTo('1.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('2.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('d/');
		assertThat(entries.nextElement().getName()).isEqualTo('d/9.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('special/');
		assertThat(entries.nextElement().getName()).isEqualTo('special/\u00EB.dat');
		assertThat(entries.nextElement().getName()).isEqualTo('nested.jar');
		assertThat(entries.nextElement().getName()).isEqualTo('another-nested.jar');
		assertThat(entries.nextElement().getName()).isEqualTo('space nested.jar');
		assertThat(entries.nextElement().getName()).isEqualTo('multi-release.jar');
		assertThat(entries.hasMoreElements()).isFalse();
	}
	@Test
	void getSpecialResourceViaClassLoader() throws Exception {
		URLClassLoader urlClassLoader = new URLClassLoader(new URL[] { this.jarFile.getUrl() });
		assertThat(urlClassLoader.getResource('special/\u00EB.dat')).isNotNull();
		urlClassLoader.close();
	}
	@Test
	void getJarEntry() {
		java.util.jar.JarEntry entry = this.jarFile.getJarEntry('1.dat');
		assertThat(entry).isNotNull();
		assertThat(entry.getName()).isEqualTo('1.dat');
	}
	@Test
	void getJarEntryWhenClosed() throws Exception {
		this.jarFile.close();
		assertThatZipFileClosedIsThrownBy(() -> this.jarFile.getJarEntry('1.dat'));
	}
	@Test
	void getInputStream() throws Exception {
		InputStream inputStream = this.jarFile.getInputStream(this.jarFile.getEntry('1.dat'));
		assertThat(inputStream.available()).isOne();
		assertThat(inputStream.read()).isOne();
		assertThat(inputStream.available()).isZero();
		assertThat(inputStream.read()).isEqualTo(-1);
	}
	@Test
	void getInputStreamWhenClosed() throws Exception {
		ZipEntry entry = this.jarFile.getEntry('1.dat');
		this.jarFile.close();
		assertThatZipFileClosedIsThrownBy(() -> this.jarFile.getInputStream(entry));
	}
	@Test
	void getComment() {
		assertThat(this.jarFile.getComment()).isEqualTo('outer');
	}
	@Test
	void getCommentWhenClosed() throws Exception {
		this.jarFile.close();
		assertThatZipFileClosedIsThrownBy(() -> this.jarFile.getComment());
	}
	@Test
	void getName() {
		assertThat(this.jarFile.getName()).isEqualTo(this.rootJarFile.getPath());
	}
	@Test
	void size() throws Exception {
		try (ZipFile zip = new ZipFile(this.rootJarFile)) {
			assertThat(this.jarFile).hasSize(zip.size());
		}
	}
	@Test
	void sizeWhenClosed() throws Exception {
		this.jarFile.close();
		assertThatZipFileClosedIsThrownBy(() -> this.jarFile.size());
	}
	@Test
	void getEntryTime() throws Exception {
		java.util.jar.JarFile jdkJarFile = new java.util.jar.JarFile(this.rootJarFile);
		assertThat(this.jarFile.getEntry('META-INF/MANIFEST.MF').getTime())
			.isEqualTo(jdkJarFile.getEntry('META-INF/MANIFEST.MF').getTime());
		jdkJarFile.close();
	}
	@Test
	void close() throws Exception {
		RandomAccessDataFile randomAccessDataFile = spy(new RandomAccessDataFile(this.rootJarFile));
		JarFile jarFile = new JarFile(randomAccessDataFile);
		jarFile.close();
		then(randomAccessDataFile).should().close();
	}
	@Test
	void getUrl() throws Exception {
		URL url = this.jarFile.getUrl();
		assertThat(url).hasToString('jar:' + this.rootJarFile.toURI() + '!/');
		JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection();
		assertThat(JarFileWrapper.unwrap(jarURLConnection.getJarFile())).isSameAs(this.jarFile);
		assertThat(jarURLConnection.getJarEntry()).isNull();
		assertThat(jarURLConnection.getContentLength()).isGreaterThan(1);
		assertThat(JarFileWrapper.unwrap((java.util.jar.JarFile) jarURLConnection.getContent())).isSameAs(this.jarFile);
		assertThat(jarURLConnection.getContentType()).isEqualTo('x-java/jar');
		assertThat(jarURLConnection.getJarFileURL().toURI()).isEqualTo(this.rootJarFile.toURI());
	}
	@Test
	void createEntryUrl() throws Exception {
		URL url = new URL(this.jarFile.getUrl(), '1.dat');
		assertThat(url).hasToString('jar:' + this.rootJarFile.toURI() + '!/1.dat');
		JarURLConnection jarURLConnection = (JarURLConnection) url.openConnection();
		assertThat(JarFileWrapper.unwrap(jarURLConnection.getJarFile())).isSameAs(this.jarFile);
		assertThat(jarURLConnection.getJarEntry()).isSameAs(this.jarFile.getJarEntry('1.dat'));
		assertThat(jarURLConnection.getContentLength()).isOne();
		assertThat(jarURLConnection.getContent()).isInstanceOf(InputStream.class);
		assertThat(jarURLConnection.getContentType()).isEqualTo('content/unknown');
		assertThat(jarURLConnection.getPermission()).isInstanceOf(FilePermission.class);
		FilePermission permission = (FilePermission) jarURLConnection.getPermission();
		assertThat(permission.getActions()).isEqualTo('read');
		assertThat(permission.getName()).isEqualTo(this.rootJarFile.getPath());
	}
	@Test
	void getMissingEntryUrl() throws Exception {
		URL url = new URL(this.jarFile.getUrl(), 'missing.dat');
		assertThat(url).hasToString('jar:' + this.rootJarFile.toURI() + '!/missing.dat');
		assertThatExceptionOfType(FileNotFoundException.class)
			.isThrownBy(((JarURLConnection) url.openConnection())::getJarEntry);
	}
	@Test
	void getUrlStream() throws Exception {
		URL url = this.jarFile.getUrl();
		url.openConnection();
		assertThatIOException().isThrownBy(url::openStream);
	}
	@Test
	void getEntryUrlStream() throws Exception {
		URL url = new URL(this.jarFile.getUrl(), '1.dat');
		url.openConnection();
		try (InputStream stream = url.openStream()) {
			assertThat(stream.read()).isOne();
			assertThat(stream.read()).isEqualTo(-1);
		}
	}
	@Test
	void getNestedJarFile() throws Exception {
		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			assertThat(nestedJarFile.getComment()).isEqualTo('nested');
			Enumeration<java.util.jar.JarEntry> entries = nestedJarFile.entries();
			assertThat(entries.nextElement().getName()).isEqualTo('META-INF/');
			assertThat(entries.nextElement().getName()).isEqualTo('META-INF/MANIFEST.MF');
			assertThat(entries.nextElement().getName()).isEqualTo('3.dat');
			assertThat(entries.nextElement().getName()).isEqualTo('4.dat');
			assertThat(entries.nextElement().getName()).isEqualTo('\u00E4.dat');
			assertThat(entries.hasMoreElements()).isFalse();
			InputStream inputStream = nestedJarFile.getInputStream(nestedJarFile.getEntry('3.dat'));
			assertThat(inputStream.read()).isEqualTo(3);
			assertThat(inputStream.read()).isEqualTo(-1);
			URL url = nestedJarFile.getUrl();
			assertThat(url).hasToString('jar:' + this.rootJarFile.toURI() + '!/nested.jar!/');
			JarURLConnection conn = (JarURLConnection) url.openConnection();
			assertThat(JarFileWrapper.unwrap(conn.getJarFile())).isSameAs(nestedJarFile);
			assertThat(conn.getJarFileURL()).hasToString('jar:' + this.rootJarFile.toURI() + '!/nested.jar');
			assertThat(conn.getInputStream()).isNotNull();
			JarInputStream jarInputStream = new JarInputStream(conn.getInputStream());
			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo('3.dat');
			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo('4.dat');
			assertThat(jarInputStream.getNextJarEntry().getName()).isEqualTo('\u00E4.dat');
			jarInputStream.close();
			assertThat(conn.getPermission()).isInstanceOf(FilePermission.class);
			FilePermission permission = (FilePermission) conn.getPermission();
			assertThat(permission.getActions()).isEqualTo('read');
			assertThat(permission.getName()).isEqualTo(this.rootJarFile.getPath());
		}
	}
	@Test
	void getNestedJarDirectory() throws Exception {
		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry('d/'))) {
			Enumeration<java.util.jar.JarEntry> entries = nestedJarFile.entries();
			assertThat(entries.nextElement().getName()).isEqualTo('9.dat');
			assertThat(entries.hasMoreElements()).isFalse();
			try (InputStream inputStream = nestedJarFile.getInputStream(nestedJarFile.getEntry('9.dat'))) {
				assertThat(inputStream.read()).isEqualTo(9);
				assertThat(inputStream.read()).isEqualTo(-1);
			}
			URL url = nestedJarFile.getUrl();
			assertThat(url).hasToString('jar:' + this.rootJarFile.toURI() + '!/d!/');
			JarURLConnection connection = (JarURLConnection) url.openConnection();
			assertThat(JarFileWrapper.unwrap(connection.getJarFile())).isSameAs(nestedJarFile);
		}
	}
	@Test
	void getNestedJarEntryUrl() throws Exception {
		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			URL url = nestedJarFile.getJarEntry('3.dat').getUrl();
			assertThat(url).hasToString('jar:' + this.rootJarFile.toURI() + '!/nested.jar!/3.dat');
			try (InputStream inputStream = url.openStream()) {
				assertThat(inputStream).isNotNull();
				assertThat(inputStream.read()).isEqualTo(3);
			}
		}
	}
	@Test
	void createUrlFromString() throws Exception {
		String spec = 'jar:' + this.rootJarFile.toURI() + '!/nested.jar!/3.dat';
		URL url = new URL(spec);
		assertThat(url).hasToString(spec);
		JarURLConnection connection = (JarURLConnection) url.openConnection();
		try (InputStream inputStream = connection.getInputStream()) {
			assertThat(inputStream).isNotNull();
			assertThat(inputStream.read()).isEqualTo(3);
			assertThat(connection.getURL()).hasToString(spec);
			assertThat(connection.getJarFileURL()).hasToString('jar:' + this.rootJarFile.toURI() + '!/nested.jar');
			assertThat(connection.getEntryName()).isEqualTo('3.dat');
			connection.getJarFile().close();
		}
	}
	@Test
	void createNonNestedUrlFromString() throws Exception {
		nonNestedJarFileFromString('jar:' + this.rootJarFile.toURI() + '!/2.dat');
	}
	@Test
	void createNonNestedUrlFromPathString() throws Exception {
		nonNestedJarFileFromString('jar:' + this.rootJarFile.toPath().toUri() + '!/2.dat');
	}
	private void nonNestedJarFileFromString(String spec) throws Exception {
		JarFile.registerUrlProtocolHandler();
		URL url = new URL(spec);
		assertThat(url).hasToString(spec);
		JarURLConnection connection = (JarURLConnection) url.openConnection();
		try (InputStream inputStream = connection.getInputStream()) {
			assertThat(inputStream).isNotNull();
			assertThat(inputStream.read()).isEqualTo(2);
			assertThat(connection.getURL()).hasToString(spec);
			assertThat(connection.getJarFileURL().toURI()).isEqualTo(this.rootJarFile.toURI());
			assertThat(connection.getEntryName()).isEqualTo('2.dat');
		}
		connection.getJarFile().close();
	}
	@Test
	void getDirectoryInputStream() throws Exception {
		InputStream inputStream = this.jarFile.getInputStream(this.jarFile.getEntry('d/'));
		assertThat(inputStream).isNotNull();
		assertThat(inputStream.read()).isEqualTo(-1);
	}
	@Test
	void getDirectoryInputStreamWithoutSlash() throws Exception {
		InputStream inputStream = this.jarFile.getInputStream(this.jarFile.getEntry('d'));
		assertThat(inputStream).isNotNull();
		assertThat(inputStream.read()).isEqualTo(-1);
	}
	@Test
	void sensibleToString() throws Exception {
		assertThat(this.jarFile).hasToString(this.rootJarFile.getPath());
		try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			assertThat(nested).hasToString(this.rootJarFile.getPath() + '!/nested.jar');
		}
	}
	@Test
	void verifySignedJar() throws Exception {
		File signedJarFile = getSignedJarFile();
		assertThat(signedJarFile).exists();
		try (java.util.jar.JarFile expected = new java.util.jar.JarFile(signedJarFile)) {
			try (JarFile actual = new JarFile(signedJarFile)) {
				StopWatch stopWatch = new StopWatch();
				Enumeration<JarEntry> actualEntries = actual.entries();
				while (actualEntries.hasMoreElements()) {
					JarEntry actualEntry = actualEntries.nextElement();
					java.util.jar.JarEntry expectedEntry = expected.getJarEntry(actualEntry.getName());
					StreamUtils.drain(expected.getInputStream(expectedEntry));
					if (!actualEntry.getName().equals('META-INF/MANIFEST.MF')) {
						assertThat(actualEntry.getCertificates()).as(actualEntry.getName())
							.isEqualTo(expectedEntry.getCertificates());
						assertThat(actualEntry.getCodeSigners()).as(actualEntry.getName())
							.isEqualTo(expectedEntry.getCodeSigners());
					}
				}
				assertThat(stopWatch.getTotalTimeSeconds()).isLessThan(3.0);
			}
		}
	}
	private File getSignedJarFile() {
		String[] entries = System.getProperty('java.class.path').split(System.getProperty('path.separator'));
		for (String entry : entries) {
			if (entry.contains('bcprov')) {
				return new File(entry);
			}
		}
		return null;
	}
	@Test
	void jarFileWithScriptAtTheStart() throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		InputStream sourceJarContent = new FileInputStream(this.rootJarFile);
		FileOutputStream outputStream = new FileOutputStream(file);
		StreamUtils.copy('#/bin/bash', Charset.defaultCharset(), outputStream);
		FileCopyUtils.copy(sourceJarContent, outputStream);
		this.rootJarFile = file;
		this.jarFile.close();
		this.jarFile = new JarFile(file);
		// Call some other tests to verify
		getEntries();
		getNestedJarFile();
	}
	@Test
	void cannotLoadMissingJar() throws Exception {
		// relates to gh-1070
		try (JarFile nestedJarFile = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
			URL nestedUrl = nestedJarFile.getUrl();
			URL url = new URL(nestedUrl, nestedJarFile.getUrl() + 'missing.jar!/3.dat');
			assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(url.openConnection()::getInputStream);
		}
	}
	@Test
	void registerUrlProtocolHandlerWithNoExistingRegistration() {
		String original = System.getProperty(PROTOCOL_HANDLER);
		try {
			System.clearProperty(PROTOCOL_HANDLER);
			JarFile.registerUrlProtocolHandler();
			String protocolHandler = System.getProperty(PROTOCOL_HANDLER);
			assertThat(protocolHandler).isEqualTo(HANDLERS_PACKAGE);
		}
		finally {
			if (original == null) {
				System.clearProperty(PROTOCOL_HANDLER);
			}
			else {
				System.setProperty(PROTOCOL_HANDLER, original);
			}
		}
	}
	@Test
	void registerUrlProtocolHandlerAddsToExistingRegistration() {
		String original = System.getProperty(PROTOCOL_HANDLER);
		try {
			System.setProperty(PROTOCOL_HANDLER, 'com.example');
			JarFile.registerUrlProtocolHandler();
			String protocolHandler = System.getProperty(PROTOCOL_HANDLER);
			assertThat(protocolHandler).isEqualTo('com.example|' + HANDLERS_PACKAGE);
		}
		finally {
			if (original == null) {
				System.clearProperty(PROTOCOL_HANDLER);
			}
			else {
				System.setProperty(PROTOCOL_HANDLER, original);
			}
		}
	}
	@Test
	void jarFileCanBeDeletedOnceItHasBeenClosed() throws Exception {
		File jar = new File(this.tempDir, 'test.jar');
		TestJarCreator.createTestJar(jar);
		JarFile jf = new JarFile(jar);
		jf.close();
		assertThat(jar.delete()).isTrue();
	}
	@Test
	void createUrlFromStringWithContextWhenNotFound() throws Exception {
		// gh-12483
		JarURLConnection.setUseFastExceptions(true);
		try {
			try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry('nested.jar'))) {
				URL context = nested.getUrl();
				new URL(context, 'jar:' + this.rootJarFile.toURI() + '!/nested.jar!/3.dat').openConnection()
					.getInputStream()
					.close();
				assertThatExceptionOfType(FileNotFoundException.class)
					.isThrownBy(new URL(context, 'jar:' + this.rootJarFile.toURI() + '!/no.dat')
						.openConnection()::getInputStream);
			}
		}
		finally {
			JarURLConnection.setUseFastExceptions(false);
		}
	}
	@Test
	void multiReleaseEntry() throws Exception {
		try (JarFile multiRelease = this.jarFile.getNestedJarFile(this.jarFile.getEntry('multi-release.jar'))) {
			ZipEntry entry = multiRelease.getEntry('multi-release.dat');
			assertThat(entry.getName()).isEqualTo('multi-release.dat');
			InputStream inputStream = multiRelease.getInputStream(entry);
			assertThat(inputStream.available()).isOne();
			assertThat(inputStream.read()).isEqualTo(Runtime.version().feature());
		}
	}
	@Test
	void zip64JarThatExceedsZipEntryLimitCanBeRead() throws Exception {
		File zip64Jar = new File(this.tempDir, 'zip64.jar');
		FileCopyUtils.copy(zip64Jar(), zip64Jar);
		try (JarFile zip64JarFile = new JarFile(zip64Jar)) {
			List<JarEntry> entries = Collections.list(zip64JarFile.entries());
			assertThat(entries).hasSize(65537);
			for (int i = 0; i < entries.size(); i++) {
				JarEntry entry = entries.get(i);
				InputStream entryInput = zip64JarFile.getInputStream(entry);
				assertThat(entryInput).hasContent('Entry ' + (i + 1));
			}
		}
	}
	@Test
	void zip64JarThatExceedsZipSizeLimitCanBeRead() throws Exception {
		Assumptions.assumeTrue(this.tempDir.getFreeSpace() > 6L * 1024 * 1024 * 1024, 'Insufficient disk space');
		File zip64Jar = new File(this.tempDir, 'zip64.jar');
		File entry = new File(this.tempDir, 'entry.dat');
		CRC32 crc32 = new CRC32();
		try (FileOutputStream entryOut = new FileOutputStream(entry)) {
			byte[] data = new byte[1024 * 1024];
			new Random().nextBytes(data);
			for (int i = 0; i < 1024; i++) {
				entryOut.write(data);
				crc32.update(data);
			}
		}
		try (JarOutputStream jarOutput = new JarOutputStream(new FileOutputStream(zip64Jar))) {
			for (int i = 0; i < 6; i++) {
				JarEntry storedEntry = new JarEntry('huge-' + i);
				storedEntry.setSize(entry.length());
				storedEntry.setCompressedSize(entry.length());
				storedEntry.setCrc(crc32.getValue());
				storedEntry.setMethod(ZipEntry.STORED);
				jarOutput.putNextEntry(storedEntry);
				try (FileInputStream entryIn = new FileInputStream(entry)) {
					StreamUtils.copy(entryIn, jarOutput);
				}
				jarOutput.closeEntry();
			}
		}
		try (JarFile zip64JarFile = new JarFile(zip64Jar)) {
			assertThat(Collections.list(zip64JarFile.entries())).hasSize(6);
		}
	}
	@Test
	void nestedZip64JarCanBeRead() throws Exception {
		File outer = new File(this.tempDir, 'outer.jar');
		try (JarOutputStream jarOutput = new JarOutputStream(new FileOutputStream(outer))) {
			JarEntry nestedEntry = new JarEntry('nested-zip64.jar');
			byte[] contents = zip64Jar();
			nestedEntry.setSize(contents.length);
			nestedEntry.setCompressedSize(contents.length);
			CRC32 crc32 = new CRC32();
			crc32.update(contents);
			nestedEntry.setCrc(crc32.getValue());
			nestedEntry.setMethod(ZipEntry.STORED);
			jarOutput.putNextEntry(nestedEntry);
			jarOutput.write(contents);
			jarOutput.closeEntry();
		}
		try (JarFile outerJarFile = new JarFile(outer)) {
			try (JarFile nestedZip64JarFile = outerJarFile
				.getNestedJarFile(outerJarFile.getJarEntry('nested-zip64.jar'))) {
				List<JarEntry> entries = Collections.list(nestedZip64JarFile.entries());
				assertThat(entries).hasSize(65537);
				for (int i = 0; i < entries.size(); i++) {
					JarEntry entry = entries.get(i);
					InputStream entryInput = nestedZip64JarFile.getInputStream(entry);
					assertThat(entryInput).hasContent('Entry ' + (i + 1));
				}
			}
		}
	}
	private byte[] zip64Jar() throws IOException {
		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		JarOutputStream jarOutput = new JarOutputStream(bytes);
		for (int i = 0; i < 65537; i++) {
			jarOutput.putNextEntry(new JarEntry(i + '.dat'));
			jarOutput.write(('Entry ' + (i + 1)).getBytes(StandardCharsets.UTF_8));
			jarOutput.closeEntry();
		}
		jarOutput.close();
		return bytes.toByteArray();
	}
	@Test
	void jarFileEntryWithEpochTimeOfZeroShouldNotFail() throws Exception {
		File file = createJarFileWithEpochTimeOfZero();
		try (JarFile jar = new JarFile(file)) {
			Enumeration<java.util.jar.JarEntry> entries = jar.entries();
			JarEntry entry = entries.nextElement();
			assertThat(entry.getLastModifiedTime().toInstant()).isEqualTo(Instant.EPOCH);
			assertThat(entry.getName()).isEqualTo('1.dat');
		}
	}
	@Test
	void mismatchedStreamEntriesThrowsException() throws IOException {
		File mismatchJar = new File('src/test/resources/jars/mismatch.jar');
		IllegalStateException failure = null;
		try (JarFile jarFile = new JarFile(mismatchJar)) {
			JarFile nestedJarFile = jarFile.getNestedJarFile(jarFile.getJarEntry('inner.jar'));
			Enumeration<JarEntry> entries = nestedJarFile.entries();
			while (entries.hasMoreElements()) {
				try {
					entries.nextElement().getCodeSigners();
				}
				catch (IllegalStateException ex) {
					failure = (failure != null) ? failure : ex;
				}
			}
		}
		assertThat(failure)
			.hasMessage('Content mismatch when reading security info for entry "content" (content check)');
	}
	private File createJarFileWithEpochTimeOfZero() throws Exception {
		File jarFile = new File(this.tempDir, 'temp.jar');
		FileOutputStream fileOutputStream = new FileOutputStream(jarFile);
		String comment = 'outer';
		try (JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream)) {
			jarOutputStream.setComment(comment);
			JarEntry entry = new JarEntry('1.dat');
			entry.setLastModifiedTime(FileTime.from(Instant.EPOCH));
			jarOutputStream.putNextEntry(entry);
			jarOutputStream.write(new byte[] { (byte) 1 });
			jarOutputStream.closeEntry();
		}
		byte[] data = Files.readAllBytes(jarFile.toPath());
		int headerPosition = data.length - ZipFile.ENDHDR - comment.getBytes().length;
		int centralHeaderPosition = (int) Bytes.littleEndianValue(data, headerPosition + ZipFile.ENDOFF, 1);
		int localHeaderPosition = (int) Bytes.littleEndianValue(data, centralHeaderPosition + ZipFile.CENOFF, 1);
		writeTimeBlock(data, centralHeaderPosition + ZipFile.CENTIM, 0);
		writeTimeBlock(data, localHeaderPosition + ZipFile.LOCTIM, 0);
		File jar = new File(this.tempDir, 'zerotimed.jar');
		Files.write(jar.toPath(), data);
		return jar;
	}
	private static void writeTimeBlock(byte[] data, int pos, int value) {
		data[pos] = (byte) (value & 0xff);
		data[pos + 1] = (byte) ((value >> 8) & 0xff);
		data[pos + 2] = (byte) ((value >> 16) & 0xff);
		data[pos + 3] = (byte) ((value >> 24) & 0xff);
	}
	@Test
	void iterator() {
		Iterator<JarEntry> iterator = this.jarFile.iterator();
		List<String> names = new ArrayList<>();
		while (iterator.hasNext()) {
			names.add(iterator.next().getName());
		}
		assertThat(names).hasSize(12).contains('1.dat');
	}
	@Test
	void iteratorWhenClosed() throws IOException {
		this.jarFile.close();
		assertThatZipFileClosedIsThrownBy(() -> this.jarFile.iterator());
	}
	@Test
	void iteratorWhenClosedLater() throws IOException {
		Iterator<JarEntry> iterator = this.jarFile.iterator();
		iterator.next();
		this.jarFile.close();
		assertThatZipFileClosedIsThrownBy(iterator::hasNext);
	}
	@Test
	void stream() {
		Stream<String> stream = this.jarFile.stream().map(JarEntry::getName);
		assertThat(stream).hasSize(12).contains('1.dat');
	}
	private void assertThatZipFileClosedIsThrownBy(ThrowingCallable throwingCallable) {
		assertThatIllegalStateException().isThrownBy(throwingCallable).withMessage('zip file closed');
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarFileWrapperTests {
	private SpyJarFile parent;
	private JarFileWrapper wrapper;
	@BeforeEach
	void setup(@TempDir File temp) throws Exception {
		this.parent = new SpyJarFile(createTempJar(temp));
		this.wrapper = new JarFileWrapper(this.parent);
	}
	@AfterEach
	void cleanup() throws Exception {
		this.parent.close();
	}
	private File createTempJar(File temp) throws IOException {
		File file = new File(temp, 'temp.jar');
		new JarOutputStream(new FileOutputStream(file)).close();
		return file;
	}
	@Test
	void getUrlDelegatesToParent() throws MalformedURLException {
		this.wrapper.getUrl();
		this.parent.verify(Call.GET_URL);
	}
	@Test
	void getTypeDelegatesToParent() {
		this.wrapper.getType();
		this.parent.verify(Call.GET_TYPE);
	}
	@Test
	void getPermissionDelegatesToParent() {
		this.wrapper.getPermission();
		this.parent.verify(Call.GET_PERMISSION);
	}
	@Test
	void getManifestDelegatesToParent() throws IOException {
		this.wrapper.getManifest();
		this.parent.verify(Call.GET_MANIFEST);
	}
	@Test
	void entriesDelegatesToParent() {
		this.wrapper.entries();
		this.parent.verify(Call.ENTRIES);
	}
	@Test
	void getJarEntryDelegatesToParent() {
		this.wrapper.getJarEntry('test');
		this.parent.verify(Call.GET_JAR_ENTRY);
	}
	@Test
	void getEntryDelegatesToParent() {
		this.wrapper.getEntry('test');
		this.parent.verify(Call.GET_ENTRY);
	}
	@Test
	void getInputStreamDelegatesToParent() throws IOException {
		this.wrapper.getInputStream();
		this.parent.verify(Call.GET_INPUT_STREAM);
	}
	@Test
	void getEntryInputStreamDelegatesToParent() throws IOException {
		ZipEntry entry = new ZipEntry('test');
		this.wrapper.getInputStream(entry);
		this.parent.verify(Call.GET_ENTRY_INPUT_STREAM);
	}
	@Test
	void getCommentDelegatesToParent() {
		this.wrapper.getComment();
		this.parent.verify(Call.GET_COMMENT);
	}
	@Test
	void sizeDelegatesToParent() {
		this.wrapper.size();
		this.parent.verify(Call.SIZE);
	}
	@Test
	void toStringDelegatesToParent() {
		assertThat(this.wrapper.toString()).endsWith('temp.jar');
	}
	@Test // gh-22991
	void wrapperMustNotImplementClose() {
		// If the wrapper overrides close then on Java 11 a FinalizableResource
		// instance will be used to perform cleanup. This can result in a lot
		// of additional memory being used since cleanup only occurs when the
		// finalizer thread runs. See gh-22991
		assertThatExceptionOfType(NoSuchMethodException.class)
			.isThrownBy(() -> JarFileWrapper.class.getDeclaredMethod('close'));
	}
	@Test
	void streamDelegatesToParent() {
		this.wrapper.stream();
		this.parent.verify(Call.STREAM);
	}
	/**
	 * {@link JarFile} that we can spy (even on Java 11+)
	 */
	static class SpyJarFile extends JarFile {
		private final Set<Call> calls = EnumSet.noneOf(Call.class);
		SpyJarFile(File file) throws IOException {
			super(file);
		}
		@Override
		Permission getPermission() {
			mark(Call.GET_PERMISSION);
			return super.getPermission();
		}
		@Override
		public Manifest getManifest() throws IOException {
			mark(Call.GET_MANIFEST);
			return super.getManifest();
		}
		@Override
		public Enumeration<java.util.jar.JarEntry> entries() {
			mark(Call.ENTRIES);
			return super.entries();
		}
		@Override
		public Stream<java.util.jar.JarEntry> stream() {
			mark(Call.STREAM);
			return super.stream();
		}
		@Override
		public JarEntry getJarEntry(String name) {
			mark(Call.GET_JAR_ENTRY);
			return super.getJarEntry(name);
		}
		@Override
		public ZipEntry getEntry(String name) {
			mark(Call.GET_ENTRY);
			return super.getEntry(name);
		}
		@Override
		InputStream getInputStream() throws IOException {
			mark(Call.GET_INPUT_STREAM);
			return super.getInputStream();
		}
		@Override
		InputStream getInputStream(String name) throws IOException {
			mark(Call.GET_ENTRY_INPUT_STREAM);
			return super.getInputStream(name);
		}
		@Override
		public String getComment() {
			mark(Call.GET_COMMENT);
			return super.getComment();
		}
		@Override
		public int size() {
			mark(Call.SIZE);
			return super.size();
		}
		@Override
		public URL getUrl() throws MalformedURLException {
			mark(Call.GET_URL);
			return super.getUrl();
		}
		@Override
		JarFileType getType() {
			mark(Call.GET_TYPE);
			return super.getType();
		}
		private void mark(Call call) {
			this.calls.add(call);
		}
		void verify(Call call) {
			assertThat(call).matches(this.calls::contains);
		}
		enum Call {
			GET_URL,
			GET_TYPE,
			GET_PERMISSION,
			GET_MANIFEST,
			ENTRIES,
			GET_JAR_ENTRY,
			GET_ENTRY,
			GET_INPUT_STREAM,
			GET_ENTRY_INPUT_STREAM,
			GET_COMMENT,
			SIZE,
			STREAM
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class CentralDirectoryParserTests {
	private File jarFile;
	private RandomAccessDataFile jarData;
	@BeforeEach
	void setup(@TempDir File tempDir) throws Exception {
		this.jarFile = new File(tempDir, 'test.jar');
		TestJarCreator.createTestJar(this.jarFile);
		this.jarData = new RandomAccessDataFile(this.jarFile);
	}
	@AfterEach
	void tearDown() throws IOException {
		this.jarData.close();
	}
	@Test
	void visitsInOrder() throws Exception {
		MockCentralDirectoryVisitor visitor = new MockCentralDirectoryVisitor();
		CentralDirectoryParser parser = new CentralDirectoryParser();
		parser.addVisitor(visitor);
		parser.parse(this.jarData, false);
		List<String> invocations = visitor.getInvocations();
		assertThat(invocations).startsWith('visitStart').endsWith('visitEnd').contains('visitFileHeader');
	}
	@Test
	void visitRecords() throws Exception {
		Collector collector = new Collector();
		CentralDirectoryParser parser = new CentralDirectoryParser();
		parser.addVisitor(collector);
		parser.parse(this.jarData, false);
		Iterator<CentralDirectoryFileHeader> headers = collector.getHeaders().iterator();
		assertThat(headers.next().getName()).hasToString('META-INF/');
		assertThat(headers.next().getName()).hasToString('META-INF/MANIFEST.MF');
		assertThat(headers.next().getName()).hasToString('1.dat');
		assertThat(headers.next().getName()).hasToString('2.dat');
		assertThat(headers.next().getName()).hasToString('d/');
		assertThat(headers.next().getName()).hasToString('d/9.dat');
		assertThat(headers.next().getName()).hasToString('special/');
		assertThat(headers.next().getName()).hasToString('special/\u00EB.dat');
		assertThat(headers.next().getName()).hasToString('nested.jar');
		assertThat(headers.next().getName()).hasToString('another-nested.jar');
		assertThat(headers.next().getName()).hasToString('space nested.jar');
		assertThat(headers.next().getName()).hasToString('multi-release.jar');
		assertThat(headers.hasNext()).isFalse();
	}
	static class Collector implements CentralDirectoryVisitor {
		private final List<CentralDirectoryFileHeader> headers = new ArrayList<>();
		@Override
		public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {
		}
		@Override
		public void visitFileHeader(CentralDirectoryFileHeader fileHeader, long dataOffset) {
			this.headers.add(fileHeader.clone());
		}
		@Override
		public void visitEnd() {
		}
		List<CentralDirectoryFileHeader> getHeaders() {
			return this.headers;
		}
	}
	static class MockCentralDirectoryVisitor implements CentralDirectoryVisitor {
		private final List<String> invocations = new ArrayList<>();
		@Override
		public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {
			this.invocations.add('visitStart');
		}
		@Override
		public void visitFileHeader(CentralDirectoryFileHeader fileHeader, long dataOffset) {
			this.invocations.add('visitFileHeader');
		}
		@Override
		public void visitEnd() {
			this.invocations.add('visitEnd');
		}
		List<String> getInvocations() {
			return this.invocations;
		}
	}
}
/*
package org.springframework.boot.loader;
/**
class JarLauncherTests extends AbstractExecutableArchiveLauncherTests {
	@Test
	void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF'));
		JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot, true));
		List<Archive> archives = new ArrayList<>();
		launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(getUrls(archives)).containsExactlyInAnyOrder(getExpectedFileUrls(explodedRoot));
		for (Archive archive : archives) {
			archive.close();
		}
	}
	@Test
	void archivedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception {
		File jarRoot = createJarArchive('archive.jar', 'BOOT-INF');
		try (JarFileArchive archive = new JarFileArchive(jarRoot)) {
			JarLauncher launcher = new JarLauncher(archive);
			List<Archive> classPathArchives = new ArrayList<>();
			launcher.getClassPathArchivesIterator().forEachRemaining(classPathArchives::add);
			assertThat(classPathArchives).hasSize(4);
			assertThat(getUrls(classPathArchives)).containsOnly(
					new URL('jar:' + jarRoot.toURI().toURL() + '!/BOOT-INF/classes!/'),
					new URL('jar:' + jarRoot.toURI().toURL() + '!/BOOT-INF/lib/foo.jar!/'),
					new URL('jar:' + jarRoot.toURI().toURL() + '!/BOOT-INF/lib/bar.jar!/'),
					new URL('jar:' + jarRoot.toURI().toURL() + '!/BOOT-INF/lib/baz.jar!/'));
			for (Archive classPathArchive : classPathArchives) {
				classPathArchive.close();
			}
		}
	}
	@Test
	void explodedJarShouldPreserveClasspathOrderWhenIndexPresent() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF', true, Collections.emptyList()));
		JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot, true));
		Iterator<Archive> archives = launcher.getClassPathArchivesIterator();
		URLClassLoader classLoader = (URLClassLoader) launcher.createClassLoader(archives);
		URL[] urls = classLoader.getURLs();
		assertThat(urls).containsExactly(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void jarFilesPresentInBootInfLibsAndNotInClasspathIndexShouldBeAddedAfterBootInfClasses() throws Exception {
		ArrayList<String> extraLibs = new ArrayList<>(Arrays.asList('extra-1.jar', 'extra-2.jar'));
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF', true, extraLibs));
		JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot, true));
		Iterator<Archive> archives = launcher.getClassPathArchivesIterator();
		URLClassLoader classLoader = (URLClassLoader) launcher.createClassLoader(archives);
		URL[] urls = classLoader.getURLs();
		List<File> expectedFiles = getExpectedFilesWithExtraLibs(explodedRoot);
		URL[] expectedFileUrls = expectedFiles.stream().map(this::toUrl).toArray(URL[]::new);
		assertThat(urls).containsExactly(expectedFileUrls);
	}
	@Test
	void explodedJarDefinedPackagesIncludeManifestAttributes() {
		Manifest manifest = new Manifest();
		Attributes attributes = manifest.getMainAttributes();
		attributes.put(Name.MANIFEST_VERSION, '1.0');
		attributes.put(Name.IMPLEMENTATION_TITLE, 'test');
		SourceFile sourceFile = SourceFile.of('explodedsample/ExampleClass.java',
				new ClassPathResource('explodedsample/ExampleClass.txt'));
		TestCompiler.forSystem().compile(sourceFile, ThrowingConsumer.of((compiled) -> {
			File explodedRoot = explode(
					createJarArchive('archive.jar', manifest, 'BOOT-INF', true, Collections.emptyList()));
			File target = new File(explodedRoot, 'BOOT-INF/classes/explodedsample/ExampleClass.class');
			target.getParentFile().mkdirs();
			FileCopyUtils.copy(compiled.getClassLoader().getResourceAsStream('explodedsample/ExampleClass.class'),
					new FileOutputStream(target));
			JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot, true));
			Iterator<Archive> archives = launcher.getClassPathArchivesIterator();
			URLClassLoader classLoader = (URLClassLoader) launcher.createClassLoader(archives);
			Class<?> loaded = classLoader.loadClass('explodedsample.ExampleClass');
			assertThat(loaded.getPackage().getImplementationTitle()).isEqualTo('test');
		}));
	}
	protected final URL[] getExpectedFileUrls(File explodedRoot) {
		return getExpectedFiles(explodedRoot).stream().map(this::toUrl).toArray(URL[]::new);
	}
	protected final List<File> getExpectedFiles(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'BOOT-INF/classes'));
		expected.add(new File(parent, 'BOOT-INF/lib/foo.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/bar.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/baz.jar'));
		return expected;
	}
	protected final List<File> getExpectedFilesWithExtraLibs(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'BOOT-INF/classes'));
		expected.add(new File(parent, 'BOOT-INF/lib/extra-1.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/extra-2.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/foo.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/bar.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/baz.jar'));
		return expected;
	}
}
/*
package org.springframework.boot.loader;
/**
@ExtendWith(OutputCaptureExtension.class)
class PropertiesLauncherTests {
	@TempDir
	File tempDir;
	private PropertiesLauncher launcher;
	private ClassLoader contextClassLoader;
	private CapturedOutput output;
	@BeforeEach
	void setup(CapturedOutput capturedOutput) throws Exception {
		this.contextClassLoader = Thread.currentThread().getContextClassLoader();
		clearHandlerCache();
		System.setProperty('loader.home', new File('src/test/resources').getAbsolutePath());
		this.output = capturedOutput;
	}
	@AfterEach
	void close() throws Exception {
		Thread.currentThread().setContextClassLoader(this.contextClassLoader);
		System.clearProperty('loader.home');
		System.clearProperty('loader.path');
		System.clearProperty('loader.main');
		System.clearProperty('loader.config.name');
		System.clearProperty('loader.config.location');
		System.clearProperty('loader.system');
		System.clearProperty('loader.classLoader');
		clearHandlerCache();
		if (this.launcher != null) {
			this.launcher.close();
		}
	}
	@SuppressWarnings('unchecked')
	private void clearHandlerCache() throws Exception {
		Map<File, JarFile> rootFileCache = ((SoftReference<Map<File, JarFile>>) ReflectionTestUtils
			.getField(Handler.class, 'rootFileCache')).get();
		if (rootFileCache != null) {
			for (JarFile rootJarFile : rootFileCache.values()) {
				rootJarFile.close();
			}
			rootFileCache.clear();
		}
	}
	@Test
	void testDefaultHome() {
		System.clearProperty('loader.home');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getHomeDirectory()).isEqualTo(new File(System.getProperty('user.dir')));
	}
	@Test
	void testAlternateHome() throws Exception {
		System.setProperty('loader.home', 'src/test/resources/home');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getHomeDirectory()).isEqualTo(new File(System.getProperty('loader.home')));
		assertThat(this.launcher.getMainClass()).isEqualTo('demo.HomeApplication');
	}
	@Test
	void testNonExistentHome() {
		System.setProperty('loader.home', 'src/test/resources/nonexistent');
		assertThatIllegalStateException().isThrownBy(PropertiesLauncher::new)
			.withMessageContaining('Invalid source directory')
			.withCauseInstanceOf(IllegalArgumentException.class);
	}
	@Test
	void testUserSpecifiedMain() throws Exception {
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('demo.Application');
		assertThat(System.getProperty('loader.main')).isNull();
	}
	@Test
	void testUserSpecifiedConfigName() throws Exception {
		System.setProperty('loader.config.name', 'foo');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('my.Application');
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[etc/]');
	}
	@Test
	void testRootOfClasspathFirst() throws Exception {
		System.setProperty('loader.config.name', 'bar');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('my.BarApplication');
	}
	@Test
	void testUserSpecifiedDotPath() {
		System.setProperty('loader.path', '.');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[.]');
	}
	@Test
	void testUserSpecifiedSlashPath() throws Exception {
		System.setProperty('loader.path', 'jars/');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/]');
		List<Archive> archives = new ArrayList<>();
		this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(archives).areExactly(1, endingWith('app.jar'));
	}
	@Test
	void testUserSpecifiedWildcardPath() throws Exception {
		System.setProperty('loader.path', 'jars/*');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedJarPath() throws Exception {
		System.setProperty('loader.path', 'jars/app.jar');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedRootOfJarPath() throws Exception {
		System.setProperty('loader.path', 'jar:file:./src/test/resources/nested-jars/app.jar!/');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths'))
			.hasToString('[jar:file:./src/test/resources/nested-jars/app.jar!/]');
		List<Archive> archives = new ArrayList<>();
		this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(archives).areExactly(1, endingWith('foo.jar!/'));
		assertThat(archives).areExactly(1, endingWith('app.jar'));
	}
	@Test
	void testUserSpecifiedRootOfJarPathWithDot() throws Exception {
		System.setProperty('loader.path', 'nested-jars/app.jar!/./');
		this.launcher = new PropertiesLauncher();
		List<Archive> archives = new ArrayList<>();
		this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(archives).areExactly(1, endingWith('foo.jar!/'));
		assertThat(archives).areExactly(1, endingWith('app.jar'));
	}
	@Test
	void testUserSpecifiedRootOfJarPathWithDotAndJarPrefix() throws Exception {
		System.setProperty('loader.path', 'jar:file:./src/test/resources/nested-jars/app.jar!/./');
		this.launcher = new PropertiesLauncher();
		List<Archive> archives = new ArrayList<>();
		this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(archives).areExactly(1, endingWith('foo.jar!/'));
	}
	@Test
	void testUserSpecifiedJarFileWithNestedArchives() throws Exception {
		System.setProperty('loader.path', 'nested-jars/app.jar');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		List<Archive> archives = new ArrayList<>();
		this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(archives).areExactly(1, endingWith('foo.jar!/'));
		assertThat(archives).areExactly(1, endingWith('app.jar'));
	}
	@Test
	void testUserSpecifiedNestedJarPath() throws Exception {
		System.setProperty('loader.path', 'nested-jars/nested-jar-app.jar!/BOOT-INF/classes/');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths'))
			.hasToString('[nested-jars/nested-jar-app.jar!/BOOT-INF/classes/]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedDirectoryContainingJarFileWithNestedArchives() throws Exception {
		System.setProperty('loader.path', 'nested-jars');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedJarPathWithDot() throws Exception {
		System.setProperty('loader.path', './jars/app.jar');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedClassLoader() throws Exception {
		System.setProperty('loader.path', 'jars/app.jar');
		System.setProperty('loader.classLoader', URLClassLoader.class.getName());
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedClassPathOrder() throws Exception {
		System.setProperty('loader.path', 'more-jars/app.jar,jars/app.jar');
		System.setProperty('loader.classLoader', URLClassLoader.class.getName());
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths'))
			.hasToString('[more-jars/app.jar, jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello Other World');
	}
	@Test
	void testCustomClassLoaderCreation() throws Exception {
		System.setProperty('loader.classLoader', TestLoader.class.getName());
		this.launcher = new PropertiesLauncher();
		ClassLoader loader = this.launcher.createClassLoader(archives());
		assertThat(loader).isNotNull();
		assertThat(loader.getClass().getName()).isEqualTo(TestLoader.class.getName());
	}
	private Iterator<Archive> archives() throws Exception {
		List<Archive> archives = new ArrayList<>();
		String path = System.getProperty('java.class.path');
		for (String url : path.split(File.pathSeparator)) {
			Archive archive = archive(url);
			if (archive != null) {
				archives.add(archive);
			}
		}
		return archives.iterator();
	}
	private Archive archive(String url) throws IOException {
		File file = new FileSystemResource(url).getFile();
		if (!file.exists()) {
			return null;
		}
		if (url.endsWith('.jar')) {
			return new JarFileArchive(file);
		}
		return new ExplodedArchive(file);
	}
	@Test
	void testUserSpecifiedConfigPathWins() throws Exception {
		System.setProperty('loader.config.name', 'foo');
		System.setProperty('loader.config.location', 'classpath:bar.properties');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('my.BarApplication');
	}
	@Test
	void testSystemPropertySpecifiedMain() throws Exception {
		System.setProperty('loader.main', 'foo.Bar');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('foo.Bar');
	}
	@Test
	void testSystemPropertiesSet() {
		System.setProperty('loader.system', 'true');
		new PropertiesLauncher();
		assertThat(System.getProperty('loader.main')).isEqualTo('demo.Application');
	}
	@Test
	void testArgsEnhanced() throws Exception {
		System.setProperty('loader.args', 'foo');
		this.launcher = new PropertiesLauncher();
		assertThat(Arrays.asList(this.launcher.getArgs('bar'))).hasToString('[foo, bar]');
	}
	@SuppressWarnings('unchecked')
	@Test
	void testLoadPathCustomizedUsingManifest() throws Exception {
		System.setProperty('loader.home', this.tempDir.getAbsolutePath());
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, '1.0');
		manifest.getMainAttributes().putValue('Loader-Path', '/foo.jar, /bar');
		File manifestFile = new File(this.tempDir, 'META-INF/MANIFEST.MF');
		manifestFile.getParentFile().mkdirs();
		try (FileOutputStream manifestStream = new FileOutputStream(manifestFile)) {
			manifest.write(manifestStream);
		}
		this.launcher = new PropertiesLauncher();
		assertThat((List<String>) ReflectionTestUtils.getField(this.launcher, 'paths')).containsExactly('/foo.jar',
				'/bar/');
	}
	@Test
	void testManifestWithPlaceholders() throws Exception {
		System.setProperty('loader.home', 'src/test/resources/placeholders');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('demo.FooApplication');
	}
	@Test
	void encodedFileUrlLoaderPathIsHandledCorrectly() throws Exception {
		File loaderPath = new File(this.tempDir, 'loader path');
		loaderPath.mkdir();
		System.setProperty('loader.path', loaderPath.toURI().toURL().toString());
		this.launcher = new PropertiesLauncher();
		List<Archive> archives = new ArrayList<>();
		this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);
		assertThat(archives).hasSize(1);
		File archiveRoot = (File) ReflectionTestUtils.getField(archives.get(0), 'root');
		assertThat(archiveRoot).isEqualTo(loaderPath);
	}
	@Test // gh-21575
	void loadResourceFromJarFile() throws Exception {
		File jarFile = new File(this.tempDir, 'app.jar');
		TestJarCreator.createTestJar(jarFile);
		System.setProperty('loader.home', this.tempDir.getAbsolutePath());
		System.setProperty('loader.path', 'app.jar');
		this.launcher = new PropertiesLauncher();
		try {
			this.launcher.launch(new String[0]);
		}
		catch (Exception ex) {
			// Expected ClassNotFoundException
			LaunchedURLClassLoader classLoader = (LaunchedURLClassLoader) Thread.currentThread()
				.getContextClassLoader();
			classLoader.close();
		}
		URL resource = new URL('jar:' + jarFile.toURI() + '!/nested.jar!/3.dat');
		byte[] bytes = FileCopyUtils.copyToByteArray(resource.openStream());
		assertThat(bytes).isNotEmpty();
	}
	private void waitFor(String value) {
		Awaitility.waitAtMost(Duration.ofSeconds(5)).until(this.output::toString, containsString(value));
	}
	private Condition<Archive> endingWith(String value) {
		return new Condition<>() {
			@Override
			public boolean matches(Archive archive) {
				return archive.toString().endsWith(value);
			}
		};
	}
	static class TestLoader extends URLClassLoader {
		TestLoader(ClassLoader parent) {
			super(new URL[0], parent);
		}
		@Override
		protected Class<?> findClass(String name) throws ClassNotFoundException {
			return super.findClass(name);
		}
	}
}
/*
package org.springframework.boot.loader;
/**
@SuppressWarnings('resource')
class LaunchedURLClassLoaderTests {
	@TempDir
	File tempDir;
	@Test
	void resolveResourceFromArchive() throws Exception {
		LaunchedURLClassLoader loader = new LaunchedURLClassLoader(
				new URL[] { new URL('jar:file:src/test/resources/jars/app.jar!/') }, getClass().getClassLoader());
		assertThat(loader.getResource('demo/Application.java')).isNotNull();
	}
	@Test
	void resolveResourcesFromArchive() throws Exception {
		LaunchedURLClassLoader loader = new LaunchedURLClassLoader(
				new URL[] { new URL('jar:file:src/test/resources/jars/app.jar!/') }, getClass().getClassLoader());
		assertThat(loader.getResources('demo/Application.java').hasMoreElements()).isTrue();
	}
	@Test
	void resolveRootPathFromArchive() throws Exception {
		LaunchedURLClassLoader loader = new LaunchedURLClassLoader(
				new URL[] { new URL('jar:file:src/test/resources/jars/app.jar!/') }, getClass().getClassLoader());
		assertThat(loader.getResource('')).isNotNull();
	}
	@Test
	void resolveRootResourcesFromArchive() throws Exception {
		LaunchedURLClassLoader loader = new LaunchedURLClassLoader(
				new URL[] { new URL('jar:file:src/test/resources/jars/app.jar!/') }, getClass().getClassLoader());
		assertThat(loader.getResources('').hasMoreElements()).isTrue();
	}
	@Test
	void resolveFromNested() throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		TestJarCreator.createTestJar(file);
		try (JarFile jarFile = new JarFile(file)) {
			URL url = jarFile.getUrl();
			try (LaunchedURLClassLoader loader = new LaunchedURLClassLoader(new URL[] { url }, null)) {
				URL resource = loader.getResource('nested.jar!/3.dat');
				assertThat(resource).hasToString(url + 'nested.jar!/3.dat');
				try (InputStream input = resource.openConnection().getInputStream()) {
					assertThat(input.read()).isEqualTo(3);
				}
			}
		}
	}
	@Test
	void resolveFromNestedWhileThreadIsInterrupted() throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		TestJarCreator.createTestJar(file);
		try (JarFile jarFile = new JarFile(file)) {
			URL url = jarFile.getUrl();
			try (LaunchedURLClassLoader loader = new LaunchedURLClassLoader(new URL[] { url }, null)) {
				Thread.currentThread().interrupt();
				URL resource = loader.getResource('nested.jar!/3.dat');
				assertThat(resource).hasToString(url + 'nested.jar!/3.dat');
				URLConnection connection = resource.openConnection();
				try (InputStream input = connection.getInputStream()) {
					assertThat(input.read()).isEqualTo(3);
				}
				((JarURLConnection) connection).getJarFile().close();
			}
			finally {
				Thread.interrupted();
			}
		}
	}
}
/*
package org.springframework.boot.loader.archive;
/**
class JarFileArchiveTests {
	@TempDir
	File tempDir;
	private File rootJarFile;
	private JarFileArchive archive;
	private String rootJarFileUrl;
	@BeforeEach
	void setup() throws Exception {
		setup(false);
	}
	@AfterEach
	void tearDown() throws Exception {
		this.archive.close();
	}
	private void setup(boolean unpackNested) throws Exception {
		this.rootJarFile = new File(this.tempDir, 'root.jar');
		this.rootJarFileUrl = this.rootJarFile.toURI().toString();
		TestJarCreator.createTestJar(this.rootJarFile, unpackNested);
		if (this.archive != null) {
			this.archive.close();
		}
		this.archive = new JarFileArchive(this.rootJarFile);
	}
	@Test
	void getManifest() throws Exception {
		assertThat(this.archive.getManifest().getMainAttributes().getValue('Built-By')).isEqualTo('j1');
	}
	@Test
	void getEntries() {
		Map<String, Archive.Entry> entries = getEntriesMap(this.archive);
		assertThat(entries).hasSize(12);
	}
	@Test
	void getUrl() throws Exception {
		URL url = this.archive.getUrl();
		assertThat(url).hasToString(this.rootJarFileUrl);
	}
	@Test
	void getNestedArchive() throws Exception {
		Entry entry = getEntriesMap(this.archive).get('nested.jar');
		try (Archive nested = this.archive.getNestedArchive(entry)) {
			assertThat(nested.getUrl()).hasToString('jar:' + this.rootJarFileUrl + '!/nested.jar!/');
		}
	}
	@Test
	void getNestedUnpackedArchive() throws Exception {
		setup(true);
		Entry entry = getEntriesMap(this.archive).get('nested.jar');
		try (Archive nested = this.archive.getNestedArchive(entry)) {
			assertThat(nested.getUrl().toString()).startsWith('file:');
			assertThat(nested.getUrl().toString()).endsWith('/nested.jar');
		}
	}
	@Test
	void unpackedLocationsAreUniquePerArchive() throws Exception {
		setup(true);
		Entry entry = getEntriesMap(this.archive).get('nested.jar');
		URL firstNestedUrl;
		try (Archive firstNested = this.archive.getNestedArchive(entry)) {
			firstNestedUrl = firstNested.getUrl();
		}
		this.archive.close();
		setup(true);
		entry = getEntriesMap(this.archive).get('nested.jar');
		try (Archive secondNested = this.archive.getNestedArchive(entry)) {
			URL secondNestedUrl = secondNested.getUrl();
			assertThat(secondNestedUrl).isNotEqualTo(firstNestedUrl);
		}
	}
	@Test
	void unpackedLocationsFromSameArchiveShareSameParent() throws Exception {
		setup(true);
		try (Archive nestedArchive = this.archive.getNestedArchive(getEntriesMap(this.archive).get('nested.jar'));
				Archive anotherNestedArchive = this.archive
					.getNestedArchive(getEntriesMap(this.archive).get('another-nested.jar'))) {
			File nested = new File(nestedArchive.getUrl().toURI());
			File anotherNested = new File(anotherNestedArchive.getUrl().toURI());
			assertThat(nested).hasParent(anotherNested.getParent());
		}
	}
	@Test
	void filesInZip64ArchivesAreAllListed() throws IOException {
		File file = new File(this.tempDir, 'test.jar');
		FileCopyUtils.copy(writeZip64Jar(), file);
		try (JarFileArchive zip64Archive = new JarFileArchive(file)) {
			@SuppressWarnings('deprecation')
			Iterator<Entry> entries = zip64Archive.iterator();
			for (int i = 0; i < 65537; i++) {
				assertThat(entries.hasNext()).as(i + 'nth file is present').isTrue();
				entries.next();
			}
		}
	}
	@Test
	void nestedZip64ArchivesAreHandledGracefully() throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		try (JarOutputStream output = new JarOutputStream(new FileOutputStream(file))) {
			JarEntry zip64JarEntry = new JarEntry('nested/zip64.jar');
			output.putNextEntry(zip64JarEntry);
			byte[] zip64JarData = writeZip64Jar();
			zip64JarEntry.setSize(zip64JarData.length);
			zip64JarEntry.setCompressedSize(zip64JarData.length);
			zip64JarEntry.setMethod(ZipEntry.STORED);
			CRC32 crc32 = new CRC32();
			crc32.update(zip64JarData);
			zip64JarEntry.setCrc(crc32.getValue());
			output.write(zip64JarData);
			output.closeEntry();
		}
		try (JarFile jarFile = new JarFile(file)) {
			ZipEntry nestedEntry = jarFile.getEntry('nested/zip64.jar');
			try (JarFile nestedJarFile = jarFile.getNestedJarFile(nestedEntry)) {
				Iterator<JarEntry> iterator = nestedJarFile.iterator();
				for (int i = 0; i < 65537; i++) {
					assertThat(iterator.hasNext()).as(i + 'nth file is present').isTrue();
					iterator.next();
				}
			}
		}
	}
	private byte[] writeZip64Jar() throws IOException {
		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		try (JarOutputStream jarOutput = new JarOutputStream(bytes)) {
			for (int i = 0; i < 65537; i++) {
				jarOutput.putNextEntry(new JarEntry(i + '.dat'));
				jarOutput.closeEntry();
			}
		}
		return bytes.toByteArray();
	}
	private Map<String, Archive.Entry> getEntriesMap(Archive archive) {
		Map<String, Archive.Entry> entries = new HashMap<>();
		for (Archive.Entry entry : archive) {
			entries.put(entry.getName(), entry);
		}
		return entries;
	}
}
/*
package org.springframework.boot.loader.archive;
/**
class ExplodedArchiveTests {
	@TempDir
	File tempDir;
	private File rootDirectory;
	private ExplodedArchive archive;
	@BeforeEach
	void setup() throws Exception {
		createArchive();
	}
	@AfterEach
	void tearDown() throws Exception {
		if (this.archive != null) {
			this.archive.close();
		}
	}
	private void createArchive() throws Exception {
		createArchive(null);
	}
	private void createArchive(String directoryName) throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		TestJarCreator.createTestJar(file);
		this.rootDirectory = (StringUtils.hasText(directoryName) ? new File(this.tempDir, directoryName)
				: new File(this.tempDir, UUID.randomUUID().toString()));
		JarFile jarFile = new JarFile(file);
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			JarEntry entry = entries.nextElement();
			File destination = new File(this.rootDirectory.getAbsolutePath() + File.separator + entry.getName());
			destination.getParentFile().mkdirs();
			if (entry.isDirectory()) {
				destination.mkdir();
			}
			else {
				FileCopyUtils.copy(jarFile.getInputStream(entry), new FileOutputStream(destination));
			}
		}
		this.archive = new ExplodedArchive(this.rootDirectory);
		jarFile.close();
	}
	@Test
	void getManifest() throws Exception {
		assertThat(this.archive.getManifest().getMainAttributes().getValue('Built-By')).isEqualTo('j1');
	}
	@Test
	void getEntries() {
		Map<String, Archive.Entry> entries = getEntriesMap(this.archive);
		assertThat(entries).hasSize(12);
	}
	@Test
	void getUrl() throws Exception {
		assertThat(this.archive.getUrl()).isEqualTo(this.rootDirectory.toURI().toURL());
	}
	@Test
	void getUrlWithSpaceInPath() throws Exception {
		createArchive('spaces in the name');
		assertThat(this.archive.getUrl()).isEqualTo(this.rootDirectory.toURI().toURL());
	}
	@Test
	void getNestedArchive() throws Exception {
		Entry entry = getEntriesMap(this.archive).get('nested.jar');
		Archive nested = this.archive.getNestedArchive(entry);
		assertThat(nested.getUrl()).hasToString(this.rootDirectory.toURI() + 'nested.jar');
		nested.close();
	}
	@Test
	void nestedDirArchive() throws Exception {
		Entry entry = getEntriesMap(this.archive).get('d/');
		Archive nested = this.archive.getNestedArchive(entry);
		Map<String, Entry> nestedEntries = getEntriesMap(nested);
		assertThat(nestedEntries).hasSize(1);
		assertThat(nested.getUrl()).hasToString('file:' + this.rootDirectory.toURI().getPath() + 'd/');
	}
	@Test
	void getNonRecursiveEntriesForRoot() throws Exception {
		try (ExplodedArchive explodedArchive = new ExplodedArchive(new File('/'), false)) {
			Map<String, Archive.Entry> entries = getEntriesMap(explodedArchive);
			assertThat(entries).hasSizeGreaterThan(1);
		}
	}
	@Test
	void getNonRecursiveManifest() throws Exception {
		try (ExplodedArchive explodedArchive = new ExplodedArchive(new File('src/test/resources/root'))) {
			assertThat(explodedArchive.getManifest()).isNotNull();
			Map<String, Archive.Entry> entries = getEntriesMap(explodedArchive);
			assertThat(entries).hasSize(4);
		}
	}
	@Test
	void getNonRecursiveManifestEvenIfNonRecursive() throws Exception {
		try (ExplodedArchive explodedArchive = new ExplodedArchive(new File('src/test/resources/root'), false)) {
			assertThat(explodedArchive.getManifest()).isNotNull();
			Map<String, Archive.Entry> entries = getEntriesMap(explodedArchive);
			assertThat(entries).hasSize(3);
		}
	}
	@Test
	void getResourceAsStream() throws Exception {
		try (ExplodedArchive explodedArchive = new ExplodedArchive(new File('src/test/resources/root'))) {
			assertThat(explodedArchive.getManifest()).isNotNull();
			URLClassLoader loader = new URLClassLoader(new URL[] { explodedArchive.getUrl() });
			assertThat(loader.getResourceAsStream('META-INF/spring/application.xml')).isNotNull();
			loader.close();
		}
	}
	@Test
	void getResourceAsStreamNonRecursive() throws Exception {
		try (ExplodedArchive explodedArchive = new ExplodedArchive(new File('src/test/resources/root'), false)) {
			assertThat(explodedArchive.getManifest()).isNotNull();
			URLClassLoader loader = new URLClassLoader(new URL[] { explodedArchive.getUrl() });
			assertThat(loader.getResourceAsStream('META-INF/spring/application.xml')).isNotNull();
			loader.close();
		}
	}
	private Map<String, Archive.Entry> getEntriesMap(Archive archive) {
		Map<String, Archive.Entry> entries = new HashMap<>();
		for (Archive.Entry entry : archive) {
			entries.put(entry.getName(), entry);
		}
		return entries;
	}
}
/*
package org.springframework.boot.loader;
/**
public class JarLauncher extends ExecutableArchiveLauncher {
	static final EntryFilter NESTED_ARCHIVE_ENTRY_FILTER = (entry) -> {
		if (entry.isDirectory()) {
			return entry.getName().equals('BOOT-INF/classes/');
		}
		return entry.getName().startsWith('BOOT-INF/lib/');
	};
	public JarLauncher() {
	}
	protected JarLauncher(Archive archive) {
		super(archive);
	}
	@Override
	protected boolean isPostProcessingClassPathArchives() {
		return false;
	}
	@Override
	protected boolean isNestedArchive(Archive.Entry entry) {
		return NESTED_ARCHIVE_ENTRY_FILTER.matches(entry);
	}
	@Override
	protected String getArchiveEntryPathPrefix() {
		return 'BOOT-INF/';
	}
	public static void main(String[] args) throws Exception {
		new JarLauncher().launch(args);
	}
}
/*
package org.springframework.boot.loader;
/**
final class ClassPathIndexFile {
	private final File root;
	private final List<String> lines;
	private ClassPathIndexFile(File root, List<String> lines) {
		this.root = root;
		this.lines = lines.stream().map(this::extractName).toList();
	}
	private String extractName(String line) {
		if (line.startsWith('- \'') && line.endsWith('\'')) {
			return line.substring(3, line.length() - 1);
		}
		throw new IllegalStateException('Malformed classpath index line [' + line + ']');
	}
	int size() {
		return this.lines.size();
	}
	boolean containsEntry(String name) {
		if (name == null || name.isEmpty()) {
			return false;
		}
		return this.lines.contains(name);
	}
	List<URL> getUrls() {
		return this.lines.stream().map(this::asUrl).toList();
	}
	private URL asUrl(String line) {
		try {
			return new File(this.root, line).toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	static ClassPathIndexFile loadIfPossible(URL root, String location) throws IOException {
		return loadIfPossible(asFile(root), location);
	}
	private static ClassPathIndexFile loadIfPossible(File root, String location) throws IOException {
		return loadIfPossible(root, new File(root, location));
	}
	private static ClassPathIndexFile loadIfPossible(File root, File indexFile) throws IOException {
		if (indexFile.exists() && indexFile.isFile()) {
			try (InputStream inputStream = new FileInputStream(indexFile)) {
				return new ClassPathIndexFile(root, loadLines(inputStream));
			}
		}
		return null;
	}
	private static List<String> loadLines(InputStream inputStream) throws IOException {
		List<String> lines = new ArrayList<>();
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
		String line = reader.readLine();
		while (line != null) {
			if (!line.trim().isEmpty()) {
				lines.add(line);
			}
			line = reader.readLine();
		}
		return Collections.unmodifiableList(lines);
	}
	private static File asFile(URL url) {
		if (!'file'.equals(url.getProtocol())) {
			throw new IllegalArgumentException('URL does not reference a file');
		}
		try {
			return new File(url.toURI());
		}
		catch (URISyntaxException ex) {
			return new File(url.getPath());
		}
	}
}
/*
package org.springframework.boot.loader;
/**
public abstract class ExecutableArchiveLauncher extends Launcher {
	private static final String START_CLASS_ATTRIBUTE = 'Start-Class';
	protected static final String BOOT_CLASSPATH_INDEX_ATTRIBUTE = 'Spring-Boot-Classpath-Index';
	protected static final String DEFAULT_CLASSPATH_INDEX_FILE_NAME = 'classpath.idx';
	private final Archive archive;
	private final ClassPathIndexFile classPathIndex;
	public ExecutableArchiveLauncher() {
		try {
			this.archive = createArchive();
			this.classPathIndex = getClassPathIndex(this.archive);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	protected ExecutableArchiveLauncher(Archive archive) {
		try {
			this.archive = archive;
			this.classPathIndex = getClassPathIndex(this.archive);
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	protected ClassPathIndexFile getClassPathIndex(Archive archive) throws IOException {
		// Only needed for exploded archives, regular ones already have a defined order
		if (archive instanceof ExplodedArchive) {
			String location = getClassPathIndexFileLocation(archive);
			return ClassPathIndexFile.loadIfPossible(archive.getUrl(), location);
		}
		return null;
	}
	private String getClassPathIndexFileLocation(Archive archive) throws IOException {
		Manifest manifest = archive.getManifest();
		Attributes attributes = (manifest != null) ? manifest.getMainAttributes() : null;
		String location = (attributes != null) ? attributes.getValue(BOOT_CLASSPATH_INDEX_ATTRIBUTE) : null;
		return (location != null) ? location : getArchiveEntryPathPrefix() + DEFAULT_CLASSPATH_INDEX_FILE_NAME;
	}
	@Override
	protected String getMainClass() throws Exception {
		Manifest manifest = this.archive.getManifest();
		String mainClass = null;
		if (manifest != null) {
			mainClass = manifest.getMainAttributes().getValue(START_CLASS_ATTRIBUTE);
		}
		if (mainClass == null) {
			throw new IllegalStateException('No "Start-Class" manifest entry specified in ' + this);
		}
		return mainClass;
	}
	@Override
	protected ClassLoader createClassLoader(Iterator<Archive> archives) throws Exception {
		List<URL> urls = new ArrayList<>(guessClassPathSize());
		while (archives.hasNext()) {
			urls.add(archives.next().getUrl());
		}
		if (this.classPathIndex != null) {
			urls.addAll(this.classPathIndex.getUrls());
		}
		return createClassLoader(urls.toArray(new URL[0]));
	}
	private int guessClassPathSize() {
		if (this.classPathIndex != null) {
			return this.classPathIndex.size() + 10;
		}
		return 50;
	}
	@Override
	protected Iterator<Archive> getClassPathArchivesIterator() throws Exception {
		Archive.EntryFilter searchFilter = this::isSearchCandidate;
		Iterator<Archive> archives = this.archive.getNestedArchives(searchFilter,
				(entry) -> isNestedArchive(entry) && !isEntryIndexed(entry));
		if (isPostProcessingClassPathArchives()) {
			archives = applyClassPathArchivePostProcessing(archives);
		}
		return archives;
	}
	private boolean isEntryIndexed(Archive.Entry entry) {
		if (this.classPathIndex != null) {
			return this.classPathIndex.containsEntry(entry.getName());
		}
		return false;
	}
	private Iterator<Archive> applyClassPathArchivePostProcessing(Iterator<Archive> archives) throws Exception {
		List<Archive> list = new ArrayList<>();
		while (archives.hasNext()) {
			list.add(archives.next());
		}
		postProcessClassPathArchives(list);
		return list.iterator();
	}
	/**
	 * Determine if the specified entry is a candidate for further searching.
	 * @param entry the entry to check
	 * @return {@code true} if the entry is a candidate for further searching
	 * @since 2.3.0
	 */
	protected boolean isSearchCandidate(Archive.Entry entry) {
		if (getArchiveEntryPathPrefix() == null) {
			return true;
		}
		return entry.getName().startsWith(getArchiveEntryPathPrefix());
	}
	/**
	 * Determine if the specified entry is a nested item that should be added to the
	 * classpath.
	 * @param entry the entry to check
	 * @return {@code true} if the entry is a nested item (jar or directory)
	 */
	protected abstract boolean isNestedArchive(Archive.Entry entry);
	/**
	 * Return if post-processing needs to be applied to the archives. For back
	 * compatibility this method returns {@code true}, but subclasses that don"t override
	 * {@link #postProcessClassPathArchives(List)} should provide an implementation that
	 * returns {@code false}.
	 * @return if the {@link #postProcessClassPathArchives(List)} method is implemented
	 * @since 2.3.0
	 */
	protected boolean isPostProcessingClassPathArchives() {
		return true;
	}
	/**
	 * Called to post-process archive entries before they are used. Implementations can
	 * add and remove entries.
	 * @param archives the archives
	 * @throws Exception if the post-processing fails
	 * @see #isPostProcessingClassPathArchives()
	 */
	protected void postProcessClassPathArchives(List<Archive> archives) throws Exception {
	}
	/**
	 * Return the path prefix for entries in the archive.
	 * @return the path prefix
	 */
	protected String getArchiveEntryPathPrefix() {
		return null;
	}
	@Override
	protected boolean isExploded() {
		return this.archive.isExploded();
	}
	@Override
	protected final Archive getArchive() {
		return this.archive;
	}
}
/*
package org.springframework.boot.loader.jarmode;
/**
public interface JarMode {
	/**
	 * Returns if this accepts and can run the given mode.
	 * @param mode the mode to check
	 * @return if this instance accepts the mode
	 */
	boolean accepts(String mode);
	/**
	 * Run the jar in the given mode.
	 * @param mode the mode to use
	 * @param args any program arguments
	 */
	void run(String mode, String[] args);
}
/*
package org.springframework.boot.loader.jarmode;
/**
class TestJarMode implements JarMode {
	@Override
	public boolean accepts(String mode) {
		return 'test'.equals(mode);
	}
	@Override
	public void run(String mode, String[] args) {
		System.out.println('running in ' + mode + ' jar mode ' + Arrays.asList(args));
	}
}
/*
package org.springframework.boot.loader.jarmode;
/**
public final class JarModeLauncher {
	static final String DISABLE_SYSTEM_EXIT = JarModeLauncher.class.getName() + '.DISABLE_SYSTEM_EXIT';
	private JarModeLauncher() {
	}
	public static void main(String[] args) {
		String mode = System.getProperty('jarmode');
		List<JarMode> candidates = SpringFactoriesLoader.loadFactories(JarMode.class,
				ClassUtils.getDefaultClassLoader());
		for (JarMode candidate : candidates) {
			if (candidate.accepts(mode)) {
				candidate.run(mode, args);
				return;
			}
		}
		System.err.println('Unsupported jarmode "' + mode + '"');
		if (!Boolean.getBoolean(DISABLE_SYSTEM_EXIT)) {
			System.exit(1);
		}
	}
}
/*
/**
package org.springframework.boot.loader.jarmode;
/*
package org.springframework.boot.loader;
/**
public class MainMethodRunner {
	private final String mainClassName;
	private final String[] args;
	/**
	 * Create a new {@link MainMethodRunner} instance.
	 * @param mainClass the main class
	 * @param args incoming arguments
	 */
	public MainMethodRunner(String mainClass, String[] args) {
		this.mainClassName = mainClass;
		this.args = (args != null) ? args.clone() : null;
	}
	public void run() throws Exception {
		Class<?> mainClass = Class.forName(this.mainClassName, false, Thread.currentThread().getContextClassLoader());
		Method mainMethod = mainClass.getDeclaredMethod('main', String[].class);
		mainMethod.setAccessible(true);
		mainMethod.invoke(null, new Object[] { this.args });
	}
}
/*
package org.springframework.boot.loader;
/**
public abstract class Launcher {
	private static final String JAR_MODE_LAUNCHER = 'org.springframework.boot.loader.jarmode.JarModeLauncher';
	/**
	 * Launch the application. This method is the initial entry point that should be
	 * called by a subclass {@code public static void main(String[] args)} method.
	 * @param args the incoming arguments
	 * @throws Exception if the application fails to launch
	 */
	protected void launch(String[] args) throws Exception {
		if (!isExploded()) {
			JarFile.registerUrlProtocolHandler();
		}
		ClassLoader classLoader = createClassLoader(getClassPathArchivesIterator());
		String jarMode = System.getProperty('jarmode');
		String launchClass = (jarMode != null && !jarMode.isEmpty()) ? JAR_MODE_LAUNCHER : getMainClass();
		launch(args, launchClass, classLoader);
	}
	/**
	 * Create a classloader for the specified archives.
	 * @param archives the archives
	 * @return the classloader
	 * @throws Exception if the classloader cannot be created
	 * @since 2.3.0
	 */
	protected ClassLoader createClassLoader(Iterator<Archive> archives) throws Exception {
		List<URL> urls = new ArrayList<>(50);
		while (archives.hasNext()) {
			urls.add(archives.next().getUrl());
		}
		return createClassLoader(urls.toArray(new URL[0]));
	}
	/**
	 * Create a classloader for the specified URLs.
	 * @param urls the URLs
	 * @return the classloader
	 * @throws Exception if the classloader cannot be created
	 */
	protected ClassLoader createClassLoader(URL[] urls) throws Exception {
		return new LaunchedURLClassLoader(isExploded(), getArchive(), urls, getClass().getClassLoader());
	}
	/**
	 * Launch the application given the archive file and a fully configured classloader.
	 * @param args the incoming arguments
	 * @param launchClass the launch class to run
	 * @param classLoader the classloader
	 * @throws Exception if the launch fails
	 */
	protected void launch(String[] args, String launchClass, ClassLoader classLoader) throws Exception {
		Thread.currentThread().setContextClassLoader(classLoader);
		createMainMethodRunner(launchClass, args, classLoader).run();
	}
	/**
	 * Create the {@code MainMethodRunner} used to launch the application.
	 * @param mainClass the main class
	 * @param args the incoming arguments
	 * @param classLoader the classloader
	 * @return the main method runner
	 */
	protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args, ClassLoader classLoader) {
		return new MainMethodRunner(mainClass, args);
	}
	/**
	 * Returns the main class that should be launched.
	 * @return the name of the main class
	 * @throws Exception if the main class cannot be obtained
	 */
	protected abstract String getMainClass() throws Exception;
	/**
	 * Returns the archives that will be used to construct the class path.
	 * @return the class path archives
	 * @throws Exception if the class path archives cannot be obtained
	 * @since 2.3.0
	 */
	protected abstract Iterator<Archive> getClassPathArchivesIterator() throws Exception;
	protected final Archive createArchive() throws Exception {
		ProtectionDomain protectionDomain = getClass().getProtectionDomain();
		CodeSource codeSource = protectionDomain.getCodeSource();
		URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;
		String path = (location != null) ? location.getSchemeSpecificPart() : null;
		if (path == null) {
			throw new IllegalStateException('Unable to determine code source archive');
		}
		File root = new File(path);
		if (!root.exists()) {
			throw new IllegalStateException('Unable to determine code source archive from ' + root);
		}
		return (root.isDirectory() ? new ExplodedArchive(root) : new JarFileArchive(root));
	}
	/**
	 * Returns if the launcher is running in an exploded mode. If this method returns
	 * {@code true} then only regular JARs are supported and the additional URL and
	 * ClassLoader support infrastructure can be optimized.
	 * @return if the jar is exploded.
	 * @since 2.3.0
	 */
	protected boolean isExploded() {
		return false;
	}
	/**
	 * Return the root archive.
	 * @return the root archive
	 * @since 2.3.1
	 */
	protected Archive getArchive() {
		return null;
	}
}
/*
package org.springframework.boot.loader;
/**
public class PropertiesLauncher extends Launcher {
	private static final Class<?>[] PARENT_ONLY_PARAMS = new Class<?>[] { ClassLoader.class };
	private static final Class<?>[] URLS_AND_PARENT_PARAMS = new Class<?>[] { URL[].class, ClassLoader.class };
	private static final Class<?>[] NO_PARAMS = new Class<?>[] {};
	private static final URL[] NO_URLS = new URL[0];
	private static final String DEBUG = 'loader.debug';
	/**
	 * Properties key for main class. As a manifest entry can also be specified as
	 * {@code Start-Class}.
	 */
	public static final String MAIN = 'loader.main';
	/**
	 * Properties key for classpath entries (directories possibly containing jars or
	 * jars). Multiple entries can be specified using a comma-separated list. {@code
	 * BOOT-INF/classes,BOOT-INF/lib} in the application archive are always used.
	 */
	public static final String PATH = 'loader.path';
	/**
	 * Properties key for home directory. This is the location of external configuration
	 * if not on classpath, and also the base path for any relative paths in the
	 * {@link #PATH loader path}. Defaults to current working directory (
	 * <code>${user.dir}</code>).
	 */
	public static final String HOME = 'loader.home';
	/**
	 * Properties key for default command line arguments. These arguments (if present) are
	 * prepended to the main method arguments before launching.
	 */
	public static final String ARGS = 'loader.args';
	/**
	 * Properties key for name of external configuration file (excluding suffix). Defaults
	 * to 'application'. Ignored if {@link #CONFIG_LOCATION loader config location} is
	 * provided instead.
	 */
	public static final String CONFIG_NAME = 'loader.config.name';
	/**
	 * Properties key for config file location (including optional classpath:, file: or
	 * URL prefix).
	 */
	public static final String CONFIG_LOCATION = 'loader.config.location';
	/**
	 * Properties key for boolean flag (default false) which, if set, will cause the
	 * external configuration properties to be copied to System properties (assuming that
	 * is allowed by Java security).
	 */
	public static final String SET_SYSTEM_PROPERTIES = 'loader.system';
	private static final Pattern WORD_SEPARATOR = Pattern.compile('\\W+');
	private static final String NESTED_ARCHIVE_SEPARATOR = '!' + File.separator;
	private final File home;
	private List<String> paths = new ArrayList<>();
	private final Properties properties = new Properties();
	private final Archive parent;
	private volatile ClassPathArchives classPathArchives;
	public PropertiesLauncher() {
		try {
			this.home = getHomeDirectory();
			initializeProperties();
			initializePaths();
			this.parent = createArchive();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	protected File getHomeDirectory() {
		try {
			return new File(getPropertyWithDefault(HOME, '${user.dir}'));
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
	}
	private void initializeProperties() throws Exception {
		List<String> configs = new ArrayList<>();
		if (getProperty(CONFIG_LOCATION) != null) {
			configs.add(getProperty(CONFIG_LOCATION));
		}
		else {
			String[] names = getPropertyWithDefault(CONFIG_NAME, 'loader').split(',');
			for (String name : names) {
				configs.add('file:' + getHomeDirectory() + '/' + name + '.properties');
				configs.add('classpath:' + name + '.properties');
				configs.add('classpath:BOOT-INF/classes/' + name + '.properties');
			}
		}
		for (String config : configs) {
			try (InputStream resource = getResource(config)) {
				if (resource != null) {
					debug('Found: ' + config);
					loadResource(resource);
					// Load the first one we find
					return;
				}
				else {
					debug('Not found: ' + config);
				}
			}
		}
	}
	private void loadResource(InputStream resource) throws Exception {
		this.properties.load(resource);
		for (Object key : Collections.list(this.properties.propertyNames())) {
			String text = this.properties.getProperty((String) key);
			String value = SystemPropertyUtils.resolvePlaceholders(this.properties, text);
			if (value != null) {
				this.properties.put(key, value);
			}
		}
		if ('true'.equals(getProperty(SET_SYSTEM_PROPERTIES))) {
			debug('Adding resolved properties to System properties');
			for (Object key : Collections.list(this.properties.propertyNames())) {
				String value = this.properties.getProperty((String) key);
				System.setProperty((String) key, value);
			}
		}
	}
	private InputStream getResource(String config) throws Exception {
		if (config.startsWith('classpath:')) {
			return getClasspathResource(config.substring('classpath:'.length()));
		}
		config = handleUrl(config);
		if (isUrl(config)) {
			return getURLResource(config);
		}
		return getFileResource(config);
	}
	private String handleUrl(String path) {
		if (path.startsWith('jar:file:') || path.startsWith('file:')) {
			path = URLDecoder.decode(path, StandardCharsets.UTF_8);
			if (path.startsWith('file:')) {
				path = path.substring('file:'.length());
				if (path.startsWith('//')) {
					path = path.substring(2);
				}
			}
		}
		return path;
	}
	private boolean isUrl(String config) {
		return config.contains('://');
	}
	private InputStream getClasspathResource(String config) {
		while (config.startsWith('/')) {
			config = config.substring(1);
		}
		config = '/' + config;
		debug('Trying classpath: ' + config);
		return getClass().getResourceAsStream(config);
	}
	private InputStream getFileResource(String config) throws Exception {
		File file = new File(config);
		debug('Trying file: ' + config);
		if (file.canRead()) {
			return new FileInputStream(file);
		}
		return null;
	}
	private InputStream getURLResource(String config) throws Exception {
		URL url = new URL(config);
		if (exists(url)) {
			URLConnection con = url.openConnection();
			try {
				return con.getInputStream();
			}
			catch (IOException ex) {
				// Close the HTTP connection (if applicable).
				if (con instanceof HttpURLConnection httpURLConnection) {
					httpURLConnection.disconnect();
				}
				throw ex;
			}
		}
		return null;
	}
	private boolean exists(URL url) throws IOException {
		// Try a URL connection content-length header...
		URLConnection connection = url.openConnection();
		try {
			connection.setUseCaches(connection.getClass().getSimpleName().startsWith('JNLP'));
			if (connection instanceof HttpURLConnection httpConnection) {
				httpConnection.setRequestMethod('HEAD');
				int responseCode = httpConnection.getResponseCode();
				if (responseCode == HttpURLConnection.HTTP_OK) {
					return true;
				}
				else if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {
					return false;
				}
			}
			return (connection.getContentLength() >= 0);
		}
		finally {
			if (connection instanceof HttpURLConnection httpURLConnection) {
				httpURLConnection.disconnect();
			}
		}
	}
	private void initializePaths() throws Exception {
		String path = getProperty(PATH);
		if (path != null) {
			this.paths = parsePathsProperty(path);
		}
		debug('Nested archive paths: ' + this.paths);
	}
	private List<String> parsePathsProperty(String commaSeparatedPaths) {
		List<String> paths = new ArrayList<>();
		for (String path : commaSeparatedPaths.split(',')) {
			path = cleanupPath(path);
			// '' means the user wants root of archive but not current directory
			path = (path == null || path.isEmpty()) ? '/' : path;
			paths.add(path);
		}
		if (paths.isEmpty()) {
			paths.add('lib');
		}
		return paths;
	}
	protected String[] getArgs(String... args) throws Exception {
		String loaderArgs = getProperty(ARGS);
		if (loaderArgs != null) {
			String[] defaultArgs = loaderArgs.split('\\s+');
			String[] additionalArgs = args;
			args = new String[defaultArgs.length + additionalArgs.length];
			System.arraycopy(defaultArgs, 0, args, 0, defaultArgs.length);
			System.arraycopy(additionalArgs, 0, args, defaultArgs.length, additionalArgs.length);
		}
		return args;
	}
	@Override
	protected String getMainClass() throws Exception {
		String mainClass = getProperty(MAIN, 'Start-Class');
		if (mainClass == null) {
			throw new IllegalStateException('No "' + MAIN + '" or "Start-Class" specified');
		}
		return mainClass;
	}
	@Override
	protected ClassLoader createClassLoader(Iterator<Archive> archives) throws Exception {
		String customLoaderClassName = getProperty('loader.classLoader');
		if (customLoaderClassName == null) {
			return super.createClassLoader(archives);
		}
		Set<URL> urls = new LinkedHashSet<>();
		while (archives.hasNext()) {
			urls.add(archives.next().getUrl());
		}
		ClassLoader loader = new LaunchedURLClassLoader(urls.toArray(NO_URLS), getClass().getClassLoader());
		debug('Classpath for custom loader: ' + urls);
		loader = wrapWithCustomClassLoader(loader, customLoaderClassName);
		debug('Using custom class loader: ' + customLoaderClassName);
		return loader;
	}
	@SuppressWarnings('unchecked')
	private ClassLoader wrapWithCustomClassLoader(ClassLoader parent, String className) throws Exception {
		Class<ClassLoader> type = (Class<ClassLoader>) Class.forName(className, true, parent);
		ClassLoader classLoader = newClassLoader(type, PARENT_ONLY_PARAMS, parent);
		if (classLoader == null) {
			classLoader = newClassLoader(type, URLS_AND_PARENT_PARAMS, NO_URLS, parent);
		}
		if (classLoader == null) {
			classLoader = newClassLoader(type, NO_PARAMS);
		}
		if (classLoader == null) {
			throw new IllegalArgumentException('Unable to create class loader for ' + className);
		}
		return classLoader;
	}
	private ClassLoader newClassLoader(Class<ClassLoader> loaderClass, Class<?>[] parameterTypes, Object... initargs)
			throws Exception {
		try {
			Constructor<ClassLoader> constructor = loaderClass.getDeclaredConstructor(parameterTypes);
			constructor.setAccessible(true);
			return constructor.newInstance(initargs);
		}
		catch (NoSuchMethodException ex) {
			return null;
		}
	}
	private String getProperty(String propertyKey) throws Exception {
		return getProperty(propertyKey, null, null);
	}
	private String getProperty(String propertyKey, String manifestKey) throws Exception {
		return getProperty(propertyKey, manifestKey, null);
	}
	private String getPropertyWithDefault(String propertyKey, String defaultValue) throws Exception {
		return getProperty(propertyKey, null, defaultValue);
	}
	private String getProperty(String propertyKey, String manifestKey, String defaultValue) throws Exception {
		if (manifestKey == null) {
			manifestKey = propertyKey.replace(".", "-");
			manifestKey = toCamelCase(manifestKey);
		}
		String property = SystemPropertyUtils.getProperty(propertyKey);
		if (property != null) {
			String value = SystemPropertyUtils.resolvePlaceholders(this.properties, property);
			debug('Property "' + propertyKey + '" from environment: ' + value);
			return value;
		}
		if (this.properties.containsKey(propertyKey)) {
			String value = SystemPropertyUtils.resolvePlaceholders(this.properties,
					this.properties.getProperty(propertyKey));
			debug('Property "' + propertyKey + '" from properties: ' + value);
			return value;
		}
		try {
			if (this.home != null) {
				// Prefer home dir for MANIFEST if there is one
				try (ExplodedArchive archive = new ExplodedArchive(this.home, false)) {
					Manifest manifest = archive.getManifest();
					if (manifest != null) {
						String value = manifest.getMainAttributes().getValue(manifestKey);
						if (value != null) {
							debug('Property "' + manifestKey + '" from home directory manifest: ' + value);
							return SystemPropertyUtils.resolvePlaceholders(this.properties, value);
						}
					}
				}
			}
		}
		catch (IllegalStateException ex) {
			// Ignore
		}
		// Otherwise try the parent archive
		Manifest manifest = createArchive().getManifest();
		if (manifest != null) {
			String value = manifest.getMainAttributes().getValue(manifestKey);
			if (value != null) {
				debug('Property "' + manifestKey + '" from archive manifest: ' + value);
				return SystemPropertyUtils.resolvePlaceholders(this.properties, value);
			}
		}
		return (defaultValue != null) ? SystemPropertyUtils.resolvePlaceholders(this.properties, defaultValue)
				: defaultValue;
	}
	@Override
	protected Iterator<Archive> getClassPathArchivesIterator() throws Exception {
		ClassPathArchives classPathArchives = this.classPathArchives;
		if (classPathArchives == null) {
			classPathArchives = new ClassPathArchives();
			this.classPathArchives = classPathArchives;
		}
		return classPathArchives.iterator();
	}
	public static void main(String[] args) throws Exception {
		PropertiesLauncher launcher = new PropertiesLauncher();
		args = launcher.getArgs(args);
		launcher.launch(args);
	}
	public static String toCamelCase(CharSequence string) {
		if (string == null) {
			return null;
		}
		StringBuilder builder = new StringBuilder();
		Matcher matcher = WORD_SEPARATOR.matcher(string);
		int pos = 0;
		while (matcher.find()) {
			builder.append(capitalize(string.subSequence(pos, matcher.end()).toString()));
			pos = matcher.end();
		}
		builder.append(capitalize(string.subSequence(pos, string.length()).toString()));
		return builder.toString();
	}
	private static String capitalize(String str) {
		return Character.toUpperCase(str.charAt(0)) + str.substring(1);
	}
	private void debug(String message) {
		if (Boolean.getBoolean(DEBUG)) {
			System.out.println(message);
		}
	}
	private String cleanupPath(String path) {
		path = path.trim();
		// No need for current dir path
		if (path.startsWith('./')) {
			path = path.substring(2);
		}
		String lowerCasePath = path.toLowerCase(Locale.ENGLISH);
		if (lowerCasePath.endsWith('.jar') || lowerCasePath.endsWith('.zip')) {
			return path;
		}
		if (path.endsWith('/*')) {
			path = path.substring(0, path.length() - 1);
		}
		else {
			// It"s a directory
			if (!path.endsWith('/') && !path.equals('.')) {
				path = path + '/';
			}
		}
		return path;
	}
	void close() throws Exception {
		if (this.classPathArchives != null) {
			this.classPathArchives.close();
		}
		if (this.parent != null) {
			this.parent.close();
		}
	}
	/**
	 * An iterable collection of the classpath archives.
	 */
	private class ClassPathArchives implements Iterable<Archive> {
		private final List<Archive> classPathArchives;
		private final List<JarFileArchive> jarFileArchives = new ArrayList<>();
		ClassPathArchives() throws Exception {
			this.classPathArchives = new ArrayList<>();
			for (String path : PropertiesLauncher.this.paths) {
				for (Archive archive : getClassPathArchives(path)) {
					addClassPathArchive(archive);
				}
			}
			addNestedEntries();
		}
		private void addClassPathArchive(Archive archive) throws IOException {
			if (!(archive instanceof ExplodedArchive)) {
				this.classPathArchives.add(archive);
				return;
			}
			this.classPathArchives.add(archive);
			this.classPathArchives.addAll(asList(archive.getNestedArchives(null, new ArchiveEntryFilter())));
		}
		private List<Archive> getClassPathArchives(String path) throws Exception {
			String root = cleanupPath(handleUrl(path));
			List<Archive> lib = new ArrayList<>();
			File file = new File(root);
			if (!'/'.equals(root)) {
				if (!isAbsolutePath(root)) {
					file = new File(PropertiesLauncher.this.home, root);
				}
				if (file.isDirectory()) {
					debug('Adding classpath entries from ' + file);
					Archive archive = new ExplodedArchive(file, false);
					lib.add(archive);
				}
			}
			Archive archive = getArchive(file);
			if (archive != null) {
				debug('Adding classpath entries from archive ' + archive.getUrl() + root);
				lib.add(archive);
			}
			List<Archive> nestedArchives = getNestedArchives(root);
			if (nestedArchives != null) {
				debug('Adding classpath entries from nested ' + root);
				lib.addAll(nestedArchives);
			}
			return lib;
		}
		private boolean isAbsolutePath(String root) {
			// Windows contains ':' others start with '/'
			return root.contains(':') || root.startsWith('/');
		}
		private Archive getArchive(File file) throws IOException {
			if (isNestedArchivePath(file)) {
				return null;
			}
			String name = file.getName().toLowerCase(Locale.ENGLISH);
			if (name.endsWith('.jar') || name.endsWith('.zip')) {
				return getJarFileArchive(file);
			}
			return null;
		}
		private boolean isNestedArchivePath(File file) {
			return file.getPath().contains(NESTED_ARCHIVE_SEPARATOR);
		}
		private List<Archive> getNestedArchives(String path) throws Exception {
			Archive parent = PropertiesLauncher.this.parent;
			String root = path;
			if (!root.equals('/') && root.startsWith('/')
					|| parent.getUrl().toURI().equals(PropertiesLauncher.this.home.toURI())) {
				// If home dir is same as parent archive, no need to add it twice.
				return null;
			}
			int index = root.indexOf("!");
			if (index != -1) {
				File file = new File(PropertiesLauncher.this.home, root.substring(0, index));
				if (root.startsWith('jar:file:')) {
					file = new File(root.substring('jar:file:'.length(), index));
				}
				parent = getJarFileArchive(file);
				root = root.substring(index + 1);
				while (root.startsWith('/')) {
					root = root.substring(1);
				}
			}
			if (root.endsWith('.jar')) {
				File file = new File(PropertiesLauncher.this.home, root);
				if (file.exists()) {
					parent = getJarFileArchive(file);
					root = '';
				}
			}
			if (root.equals('/') || root.equals('./') || root.equals('.')) {
				// The prefix for nested jars is actually empty if it"s at the root
				root = '';
			}
			EntryFilter filter = new PrefixMatchingArchiveFilter(root);
			List<Archive> archives = asList(parent.getNestedArchives(null, filter));
			if ((root == null || root.isEmpty() || '.'.equals(root)) && !path.endsWith('.jar')
					&& parent != PropertiesLauncher.this.parent) {
				// You can"t find the root with an entry filter so it has to be added
				// explicitly. But don"t add the root of the parent archive.
				archives.add(parent);
			}
			return archives;
		}
		private void addNestedEntries() {
			// The parent archive might have 'BOOT-INF/lib/' and 'BOOT-INF/classes/'
			// directories, meaning we are running from an executable JAR. We add nested
			// entries from there with low priority (i.e. at end).
			try {
				Iterator<Archive> archives = PropertiesLauncher.this.parent.getNestedArchives(null,
						JarLauncher.NESTED_ARCHIVE_ENTRY_FILTER);
				while (archives.hasNext()) {
					this.classPathArchives.add(archives.next());
				}
			}
			catch (IOException ex) {
				// Ignore
			}
		}
		private List<Archive> asList(Iterator<Archive> iterator) {
			List<Archive> list = new ArrayList<>();
			while (iterator.hasNext()) {
				list.add(iterator.next());
			}
			return list;
		}
		private JarFileArchive getJarFileArchive(File file) throws IOException {
			JarFileArchive archive = new JarFileArchive(file);
			this.jarFileArchives.add(archive);
			return archive;
		}
		@Override
		public Iterator<Archive> iterator() {
			return this.classPathArchives.iterator();
		}
		void close() throws IOException {
			for (JarFileArchive archive : this.jarFileArchives) {
				archive.close();
			}
		}
	}
	/**
	 * Convenience class for finding nested archives that have a prefix in their file path
	 * (e.g. 'lib/').
	 */
	private static final class PrefixMatchingArchiveFilter implements EntryFilter {
		private final String prefix;
		private final ArchiveEntryFilter filter = new ArchiveEntryFilter();
		private PrefixMatchingArchiveFilter(String prefix) {
			this.prefix = prefix;
		}
		@Override
		public boolean matches(Entry entry) {
			if (entry.isDirectory()) {
				return entry.getName().equals(this.prefix);
			}
			return entry.getName().startsWith(this.prefix) && this.filter.matches(entry);
		}
	}
	/**
	 * Convenience class for finding nested archives (archive entries that can be
	 * classpath entries).
	 */
	private static final class ArchiveEntryFilter implements EntryFilter {
		private static final String DOT_JAR = '.jar';
		private static final String DOT_ZIP = '.zip';
		@Override
		public boolean matches(Entry entry) {
			return entry.getName().endsWith(DOT_JAR) || entry.getName().endsWith(DOT_ZIP);
		}
	}
}
/*
package org.springframework.boot.loader.data;
/**
public interface RandomAccessData {
	/**
	 * Returns an {@link InputStream} that can be used to read the underlying data. The
	 * caller is responsible close the underlying stream.
	 * @return a new input stream that can be used to read the underlying data.
	 * @throws IOException if the stream cannot be opened
	 */
	InputStream getInputStream() throws IOException;
	/**
	 * Returns a new {@link RandomAccessData} for a specific subsection of this data.
	 * @param offset the offset of the subsection
	 * @param length the length of the subsection
	 * @return the subsection data
	 */
	RandomAccessData getSubsection(long offset, long length);
	/**
	 * Reads all the data and returns it as a byte array.
	 * @return the data
	 * @throws IOException if the data cannot be read
	 */
	byte[] read() throws IOException;
	/**
	 * Reads the {@code length} bytes of data starting at the given {@code offset}.
	 * @param offset the offset from which data should be read
	 * @param length the number of bytes to be read
	 * @return the data
	 * @throws IOException if the data cannot be read
	 * @throws IndexOutOfBoundsException if offset is beyond the end of the file or
	 * subsection
	 * @throws EOFException if offset plus length is greater than the length of the file
	 * or subsection
	 */
	byte[] read(long offset, long length) throws IOException;
	/**
	 * Returns the size of the data.
	 * @return the size
	 */
	long getSize();
}
/*
package org.springframework.boot.loader.data;
/**
public class RandomAccessDataFile implements RandomAccessData {
	private final FileAccess fileAccess;
	private final long offset;
	private final long length;
	/**
	 * Create a new {@link RandomAccessDataFile} backed by the specified file.
	 * @param file the underlying file
	 * @throws IllegalArgumentException if the file is null or does not exist
	 */
	public RandomAccessDataFile(File file) {
		if (file == null) {
			throw new IllegalArgumentException('File must not be null');
		}
		this.fileAccess = new FileAccess(file);
		this.offset = 0L;
		this.length = file.length();
	}
	/**
	 * Private constructor used to create a {@link #getSubsection(long, long) subsection}.
	 * @param fileAccess provides access to the underlying file
	 * @param offset the offset of the section
	 * @param length the length of the section
	 */
	private RandomAccessDataFile(FileAccess fileAccess, long offset, long length) {
		this.fileAccess = fileAccess;
		this.offset = offset;
		this.length = length;
	}
	/**
	 * Returns the underlying File.
	 * @return the underlying file
	 */
	public File getFile() {
		return this.fileAccess.file;
	}
	@Override
	public InputStream getInputStream() throws IOException {
		return new DataInputStream();
	}
	@Override
	public RandomAccessData getSubsection(long offset, long length) {
		if (offset < 0 || length < 0 || offset + length > this.length) {
			throw new IndexOutOfBoundsException();
		}
		return new RandomAccessDataFile(this.fileAccess, this.offset + offset, length);
	}
	@Override
	public byte[] read() throws IOException {
		return read(0, this.length);
	}
	@Override
	public byte[] read(long offset, long length) throws IOException {
		if (offset > this.length) {
			throw new IndexOutOfBoundsException();
		}
		if (offset + length > this.length) {
			throw new EOFException();
		}
		byte[] bytes = new byte[(int) length];
		read(bytes, offset, 0, bytes.length);
		return bytes;
	}
	private int readByte(long position) throws IOException {
		if (position >= this.length) {
			return -1;
		}
		return this.fileAccess.readByte(this.offset + position);
	}
	private int read(byte[] bytes, long position, int offset, int length) throws IOException {
		if (position > this.length) {
			return -1;
		}
		return this.fileAccess.read(bytes, this.offset + position, offset, length);
	}
	@Override
	public long getSize() {
		return this.length;
	}
	public void close() throws IOException {
		this.fileAccess.close();
	}
	/**
	 * {@link InputStream} implementation for the {@link RandomAccessDataFile}.
	 */
	private final class DataInputStream extends InputStream {
		private int position;
		@Override
		public int read() throws IOException {
			int read = RandomAccessDataFile.this.readByte(this.position);
			if (read > -1) {
				moveOn(1);
			}
			return read;
		}
		@Override
		public int read(byte[] b) throws IOException {
			return read(b, 0, (b != null) ? b.length : 0);
		}
		@Override
		public int read(byte[] b, int off, int len) throws IOException {
			if (b == null) {
				throw new NullPointerException('Bytes must not be null');
			}
			return doRead(b, off, len);
		}
		/**
		 * Perform the actual read.
		 * @param b the bytes to read or {@code null} when reading a single byte
		 * @param off the offset of the byte array
		 * @param len the length of data to read
		 * @return the number of bytes read into {@code b} or the actual read byte if
		 * {@code b} is {@code null}. Returns -1 when the end of the stream is reached
		 * @throws IOException in case of I/O errors
		 */
		int doRead(byte[] b, int off, int len) throws IOException {
			if (len == 0) {
				return 0;
			}
			int cappedLen = cap(len);
			if (cappedLen <= 0) {
				return -1;
			}
			return (int) moveOn(RandomAccessDataFile.this.read(b, this.position, off, cappedLen));
		}
		@Override
		public long skip(long n) throws IOException {
			return (n <= 0) ? 0 : moveOn(cap(n));
		}
		@Override
		public int available() throws IOException {
			return (int) RandomAccessDataFile.this.length - this.position;
		}
		/**
		 * Cap the specified value such that it cannot exceed the number of bytes
		 * remaining.
		 * @param n the value to cap
		 * @return the capped value
		 */
		private int cap(long n) {
			return (int) Math.min(RandomAccessDataFile.this.length - this.position, n);
		}
		/**
		 * Move the stream position forwards the specified amount.
		 * @param amount the amount to move
		 * @return the amount moved
		 */
		private long moveOn(int amount) {
			this.position += amount;
			return amount;
		}
	}
	private static final class FileAccess {
		private final Object monitor = new Object();
		private final File file;
		private RandomAccessFile randomAccessFile;
		private FileAccess(File file) {
			this.file = file;
			openIfNecessary();
		}
		private int read(byte[] bytes, long position, int offset, int length) throws IOException {
			synchronized (this.monitor) {
				openIfNecessary();
				this.randomAccessFile.seek(position);
				return this.randomAccessFile.read(bytes, offset, length);
			}
		}
		private void openIfNecessary() {
			if (this.randomAccessFile == null) {
				try {
					this.randomAccessFile = new RandomAccessFile(this.file, 'r');
				}
				catch (FileNotFoundException ex) {
					throw new IllegalArgumentException(
							String.format('File %s must exist', this.file.getAbsolutePath()));
				}
			}
		}
		private void close() throws IOException {
			synchronized (this.monitor) {
				if (this.randomAccessFile != null) {
					this.randomAccessFile.close();
					this.randomAccessFile = null;
				}
			}
		}
		private int readByte(long position) throws IOException {
			synchronized (this.monitor) {
				openIfNecessary();
				this.randomAccessFile.seek(position);
				return this.randomAccessFile.read();
			}
		}
	}
}
/*
/**
package org.springframework.boot.loader.data;
/*
package org.springframework.boot.loader.launch;
/**
public final class JarLauncher {
	private JarLauncher() {
	}
	public static void main(String[] args) throws Exception {
		org.springframework.boot.loader.JarLauncher.main(args);
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public final class PropertiesLauncher {
	private PropertiesLauncher() {
	}
	public static void main(String[] args) throws Exception {
		org.springframework.boot.loader.PropertiesLauncher.main(args);
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public final class WarLauncher {
	private WarLauncher() {
	}
	public static void main(String[] args) throws Exception {
		org.springframework.boot.loader.WarLauncher.main(args);
	}
}
/*
/**
package org.springframework.boot.loader.launch;
/*
package org.springframework.boot.loader.util;
/**
public abstract class SystemPropertyUtils {
	/**
	 * Prefix for system property placeholders: '${'.
	 */
	public static final String '_PREFIX = '${';
	/**
	 * Suffix for system property placeholders: '}'.
	 */
	public static final String '_SUFFIX = '}';
	/**
	 * Value separator for system property placeholders: ':'.
	 */
	public static final String VALUE_SEPARATOR = ':';
	private static final String SIMPLE_PREFIX = '_PREFIX.substring(1);
	/**
	 * Resolve ${...} placeholders in the given text, replacing them with corresponding
	 * system property values.
	 * @param text the String to resolve
	 * @return the resolved String
	 * @throws IllegalArgumentException if there is an unresolvable placeholder
	 * @see #'_PREFIX
	 * @see #'_SUFFIX
	 */
	public static String resolvePlaceholders(String text) {
		if (text == null) {
			return text;
		}
		return parseStringValue(null, text, text, new HashSet<>());
	}
	/**
	 * Resolve ${...} placeholders in the given text, replacing them with corresponding
	 * system property values.
	 * @param properties a properties instance to use in addition to System
	 * @param text the String to resolve
	 * @return the resolved String
	 * @throws IllegalArgumentException if there is an unresolvable placeholder
	 * @see #'_PREFIX
	 * @see #'_SUFFIX
	 */
	public static String resolvePlaceholders(Properties properties, String text) {
		if (text == null) {
			return text;
		}
		return parseStringValue(properties, text, text, new HashSet<>());
	}
	private static String parseStringValue(Properties properties, String value, String current,
			Set<String> visitedPlaceholders) {
		StringBuilder buf = new StringBuilder(current);
		int startIndex = current.indexOf('_PREFIX);
		while (startIndex != -1) {
			int endIndex = findPlaceholderEndIndex(buf, startIndex);
			if (endIndex != -1) {
				String placeholder = buf.substring(startIndex + '_PREFIX.length(), endIndex);
				String originalPlaceholder = placeholder;
				if (!visitedPlaceholders.add(originalPlaceholder)) {
					throw new IllegalArgumentException(
							'Circular placeholder reference "' + originalPlaceholder + '" in property definitions');
				}
				// Recursive invocation, parsing placeholders contained in the
				// placeholder
				// key.
				placeholder = parseStringValue(properties, value, placeholder, visitedPlaceholders);
				// Now obtain the value for the fully resolved key...
				String propVal = resolvePlaceholder(properties, value, placeholder);
				if (propVal == null) {
					int separatorIndex = placeholder.indexOf(VALUE_SEPARATOR);
					if (separatorIndex != -1) {
						String actualPlaceholder = placeholder.substring(0, separatorIndex);
						String defaultValue = placeholder.substring(separatorIndex + VALUE_SEPARATOR.length());
						propVal = resolvePlaceholder(properties, value, actualPlaceholder);
						if (propVal == null) {
							propVal = defaultValue;
						}
					}
				}
				if (propVal != null) {
					// Recursive invocation, parsing placeholders contained in the
					// previously resolved placeholder value.
					propVal = parseStringValue(properties, value, propVal, visitedPlaceholders);
					buf.replace(startIndex, endIndex + '_SUFFIX.length(), propVal);
					startIndex = buf.indexOf('_PREFIX, startIndex + propVal.length());
				}
				else {
					// Proceed with unprocessed value.
					startIndex = buf.indexOf('_PREFIX, endIndex + '_SUFFIX.length());
				}
				visitedPlaceholders.remove(originalPlaceholder);
			}
			else {
				startIndex = -1;
			}
		}
		return buf.toString();
	}
	private static String resolvePlaceholder(Properties properties, String text, String placeholderName) {
		String propVal = getProperty(placeholderName, null, text);
		if (propVal != null) {
			return propVal;
		}
		return (properties != null) ? properties.getProperty(placeholderName) : null;
	}
	public static String getProperty(String key) {
		return getProperty(key, null, '');
	}
	public static String getProperty(String key, String defaultValue) {
		return getProperty(key, defaultValue, '');
	}
	/**
	 * Search the System properties and environment variables for a value with the
	 * provided key. Environment variables in {@code UPPER_CASE} style are allowed where
	 * System properties would normally be {@code lower.case}.
	 * @param key the key to resolve
	 * @param defaultValue the default value
	 * @param text optional extra context for an error message if the key resolution fails
	 * (e.g. if System properties are not accessible)
	 * @return a static property value or null of not found
	 */
	public static String getProperty(String key, String defaultValue, String text) {
		try {
			String propVal = System.getProperty(key);
			if (propVal == null) {
				// Fall back to searching the system environment.
				propVal = System.getenv(key);
			}
			if (propVal == null) {
				// Try with underscores.
				String name = key.replace(".", "_");
				propVal = System.getenv(name);
			}
			if (propVal == null) {
				// Try uppercase with underscores as well.
				String name = key.toUpperCase(Locale.ENGLISH).replace(".", "_");
				propVal = System.getenv(name);
			}
			if (propVal != null) {
				return propVal;
			}
		}
		catch (Throwable ex) {
			System.err.println('Could not resolve key "' + key + '" in "' + text
					+ '" as system property or in environment: ' + ex);
		}
		return defaultValue;
	}
	private static int findPlaceholderEndIndex(CharSequence buf, int startIndex) {
		int index = startIndex + '_PREFIX.length();
		int withinNestedPlaceholder = 0;
		while (index < buf.length()) {
			if (substringMatch(buf, index, '_SUFFIX)) {
				if (withinNestedPlaceholder > 0) {
					withinNestedPlaceholder--;
					index = index + '_SUFFIX.length();
				}
				else {
					return index;
				}
			}
			else if (substringMatch(buf, index, SIMPLE_PREFIX)) {
				withinNestedPlaceholder++;
				index = index + SIMPLE_PREFIX.length();
			}
			else {
				index++;
			}
		}
		return -1;
	}
	private static boolean substringMatch(CharSequence str, int index, CharSequence substring) {
		for (int j = 0; j < substring.length(); j++) {
			int i = index + j;
			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
				return false;
			}
		}
		return true;
	}
}
/*
/**
package org.springframework.boot.loader.util;
/*
package org.springframework.boot.loader;
/**
public class LaunchedURLClassLoader extends URLClassLoader {
	private static final int BUFFER_SIZE = 4096;
	static {
		ClassLoader.registerAsParallelCapable();
	}
	private final boolean exploded;
	private final Archive rootArchive;
	private final Object packageLock = new Object();
	private volatile DefinePackageCallType definePackageCallType;
	/**
	 * Create a new {@link LaunchedURLClassLoader} instance.
	 * @param urls the URLs from which to load classes and resources
	 * @param parent the parent class loader for delegation
	 */
	public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {
		this(false, urls, parent);
	}
	/**
	 * Create a new {@link LaunchedURLClassLoader} instance.
	 * @param exploded if the underlying archive is exploded
	 * @param urls the URLs from which to load classes and resources
	 * @param parent the parent class loader for delegation
	 */
	public LaunchedURLClassLoader(boolean exploded, URL[] urls, ClassLoader parent) {
		this(exploded, null, urls, parent);
	}
	/**
	 * Create a new {@link LaunchedURLClassLoader} instance.
	 * @param exploded if the underlying archive is exploded
	 * @param rootArchive the root archive or {@code null}
	 * @param urls the URLs from which to load classes and resources
	 * @param parent the parent class loader for delegation
	 * @since 2.3.1
	 */
	public LaunchedURLClassLoader(boolean exploded, Archive rootArchive, URL[] urls, ClassLoader parent) {
		super(urls, parent);
		this.exploded = exploded;
		this.rootArchive = rootArchive;
	}
	@Override
	public URL findResource(String name) {
		if (this.exploded) {
			return super.findResource(name);
		}
		Handler.setUseFastConnectionExceptions(true);
		try {
			return super.findResource(name);
		}
		finally {
			Handler.setUseFastConnectionExceptions(false);
		}
	}
	@Override
	public Enumeration<URL> findResources(String name) throws IOException {
		if (this.exploded) {
			return super.findResources(name);
		}
		Handler.setUseFastConnectionExceptions(true);
		try {
			return new UseFastConnectionExceptionsEnumeration(super.findResources(name));
		}
		finally {
			Handler.setUseFastConnectionExceptions(false);
		}
	}
	@Override
	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		if (name.startsWith('org.springframework.boot.loader.jarmode.')) {
			try {
				Class<?> result = loadClassInLaunchedClassLoader(name);
				if (resolve) {
					resolveClass(result);
				}
				return result;
			}
			catch (ClassNotFoundException ex) {
				// Ignore
			}
		}
		if (this.exploded) {
			return super.loadClass(name, resolve);
		}
		Handler.setUseFastConnectionExceptions(true);
		try {
			try {
				definePackageIfNecessary(name);
			}
			catch (IllegalArgumentException ex) {
				// Tolerate race condition due to being parallel capable
				if (getDefinedPackage(name) == null) {
					// This should never happen as the IllegalArgumentException indicates
					// that the package has already been defined and, therefore,
					// getDefinedPackage(name) should not return null.
					throw new AssertionError('Package ' + name + ' has already been defined but it could not be found');
				}
			}
			return super.loadClass(name, resolve);
		}
		finally {
			Handler.setUseFastConnectionExceptions(false);
		}
	}
	private Class<?> loadClassInLaunchedClassLoader(String name) throws ClassNotFoundException {
		String internalName = name.replace(".", "/") + '.class';
		InputStream inputStream = getParent().getResourceAsStream(internalName);
		if (inputStream == null) {
			throw new ClassNotFoundException(name);
		}
		try {
			try {
				ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
				byte[] buffer = new byte[BUFFER_SIZE];
				int bytesRead = -1;
				while ((bytesRead = inputStream.read(buffer)) != -1) {
					outputStream.write(buffer, 0, bytesRead);
				}
				inputStream.close();
				byte[] bytes = outputStream.toByteArray();
				Class<?> definedClass = defineClass(name, bytes, 0, bytes.length);
				definePackageIfNecessary(name);
				return definedClass;
			}
			finally {
				inputStream.close();
			}
		}
		catch (IOException ex) {
			throw new ClassNotFoundException('Cannot load resource for class [' + name + ']', ex);
		}
	}
	/**
	 * Define a package before a {@code findClass} call is made. This is necessary to
	 * ensure that the appropriate manifest for nested JARs is associated with the
	 * package.
	 * @param className the class name being found
	 */
	private void definePackageIfNecessary(String className) {
		int lastDot = className.lastIndexOf(".");
		if (lastDot >= 0) {
			String packageName = className.substring(0, lastDot);
			if (getDefinedPackage(packageName) == null) {
				try {
					definePackage(className, packageName);
				}
				catch (IllegalArgumentException ex) {
					// Tolerate race condition due to being parallel capable
					if (getDefinedPackage(packageName) == null) {
						// This should never happen as the IllegalArgumentException
						// indicates that the package has already been defined and,
						// therefore, getDefinedPackage(name) should not have returned
						// null.
						throw new AssertionError(
								'Package ' + packageName + ' has already been defined but it could not be found');
					}
				}
			}
		}
	}
	private void definePackage(String className, String packageName) {
		String packageEntryName = packageName.replace(".", "/") + '/';
		String classEntryName = className.replace(".", "/") + '.class';
		for (URL url : getURLs()) {
			try {
				URLConnection connection = url.openConnection();
				if (connection instanceof JarURLConnection jarURLConnection) {
					JarFile jarFile = jarURLConnection.getJarFile();
					if (jarFile.getEntry(classEntryName) != null && jarFile.getEntry(packageEntryName) != null
							&& jarFile.getManifest() != null) {
						definePackage(packageName, jarFile.getManifest(), url);
						return;
					}
				}
			}
			catch (IOException ex) {
				// Ignore
			}
		}
	}
	@Override
	protected Package definePackage(String name, Manifest man, URL url) throws IllegalArgumentException {
		if (!this.exploded) {
			return super.definePackage(name, man, url);
		}
		synchronized (this.packageLock) {
			return doDefinePackage(DefinePackageCallType.MANIFEST, () -> super.definePackage(name, man, url));
		}
	}
	@Override
	protected Package definePackage(String name, String specTitle, String specVersion, String specVendor,
			String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException {
		if (!this.exploded) {
			return super.definePackage(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor,
					sealBase);
		}
		synchronized (this.packageLock) {
			if (this.definePackageCallType == null) {
				// We"re not part of a call chain which means that the URLClassLoader
				// is trying to define a package for our exploded JAR. We use the
				// manifest version to ensure package attributes are set
				Manifest manifest = getManifest(this.rootArchive);
				if (manifest != null) {
					return definePackage(name, manifest, sealBase);
				}
			}
			return doDefinePackage(DefinePackageCallType.ATTRIBUTES, () -> super.definePackage(name, specTitle,
					specVersion, specVendor, implTitle, implVersion, implVendor, sealBase));
		}
	}
	private Manifest getManifest(Archive archive) {
		try {
			return (archive != null) ? archive.getManifest() : null;
		}
		catch (IOException ex) {
			return null;
		}
	}
	private <T> T doDefinePackage(DefinePackageCallType type, Supplier<T> call) {
		DefinePackageCallType existingType = this.definePackageCallType;
		try {
			this.definePackageCallType = type;
			return call.get();
		}
		finally {
			this.definePackageCallType = existingType;
		}
	}
	/**
	 * Clear URL caches.
	 */
	public void clearCache() {
		if (this.exploded) {
			return;
		}
		for (URL url : getURLs()) {
			try {
				URLConnection connection = url.openConnection();
				if (connection instanceof JarURLConnection) {
					clearCache(connection);
				}
			}
			catch (IOException ex) {
				// Ignore
			}
		}
	}
	private void clearCache(URLConnection connection) throws IOException {
		Object jarFile = ((JarURLConnection) connection).getJarFile();
		if (jarFile instanceof org.springframework.boot.loader.jar.JarFile) {
			((org.springframework.boot.loader.jar.JarFile) jarFile).clearCache();
		}
	}
	private static class UseFastConnectionExceptionsEnumeration implements Enumeration<URL> {
		private final Enumeration<URL> delegate;
		UseFastConnectionExceptionsEnumeration(Enumeration<URL> delegate) {
			this.delegate = delegate;
		}
		@Override
		public boolean hasMoreElements() {
			Handler.setUseFastConnectionExceptions(true);
			try {
				return this.delegate.hasMoreElements();
			}
			finally {
				Handler.setUseFastConnectionExceptions(false);
			}
		}
		@Override
		public URL nextElement() {
			Handler.setUseFastConnectionExceptions(true);
			try {
				return this.delegate.nextElement();
			}
			finally {
				Handler.setUseFastConnectionExceptions(false);
			}
		}
	}
	/**
	 * The different types of call made to define a package. We track these for exploded
	 * jars so that we can detect packages that should have manifest attributes applied.
	 */
	private enum DefinePackageCallType {
		/**
		 * A define package call from a resource that has a manifest.
		 */
		MANIFEST,
		/**
		 * A define package call with a direct set of attributes.
		 */
		ATTRIBUTES
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarFileWrapper extends AbstractJarFile {
	private final JarFile parent;
	JarFileWrapper(JarFile parent) throws IOException {
		super(parent.getRootJarFile().getFile());
		this.parent = parent;
		super.close();
	}
	@Override
	URL getUrl() throws MalformedURLException {
		return this.parent.getUrl();
	}
	@Override
	JarFileType getType() {
		return this.parent.getType();
	}
	@Override
	Permission getPermission() {
		return this.parent.getPermission();
	}
	@Override
	public Manifest getManifest() throws IOException {
		return this.parent.getManifest();
	}
	@Override
	public Enumeration<JarEntry> entries() {
		return this.parent.entries();
	}
	@Override
	public Stream<JarEntry> stream() {
		return this.parent.stream();
	}
	@Override
	public JarEntry getJarEntry(String name) {
		return this.parent.getJarEntry(name);
	}
	@Override
	public ZipEntry getEntry(String name) {
		return this.parent.getEntry(name);
	}
	@Override
	InputStream getInputStream() throws IOException {
		return this.parent.getInputStream();
	}
	@Override
	public synchronized InputStream getInputStream(ZipEntry ze) throws IOException {
		return this.parent.getInputStream(ze);
	}
	@Override
	public String getComment() {
		return this.parent.getComment();
	}
	@Override
	public int size() {
		return this.parent.size();
	}
	@Override
	public String toString() {
		return this.parent.toString();
	}
	@Override
	public String getName() {
		return this.parent.getName();
	}
	static JarFile unwrap(java.util.jar.JarFile jarFile) {
		if (jarFile instanceof JarFile file) {
			return file;
		}
		if (jarFile instanceof JarFileWrapper wrapper) {
			return unwrap(wrapper.parent);
		}
		throw new IllegalStateException('Not a JarFile or Wrapper');
	}
}
/*
package org.springframework.boot.loader.jar;
/**
final class StringSequence implements CharSequence {
	private final String source;
	private final int start;
	private final int end;
	private int hash;
	StringSequence(String source) {
		this(source, 0, (source != null) ? source.length() : -1);
	}
	StringSequence(String source, int start, int end) {
		Objects.requireNonNull(source, 'Source must not be null');
		if (start < 0) {
			throw new StringIndexOutOfBoundsException(start);
		}
		if (end > source.length()) {
			throw new StringIndexOutOfBoundsException(end);
		}
		this.source = source;
		this.start = start;
		this.end = end;
	}
	StringSequence subSequence(int start) {
		return subSequence(start, length());
	}
	@Override
	public StringSequence subSequence(int start, int end) {
		int subSequenceStart = this.start + start;
		int subSequenceEnd = this.start + end;
		if (subSequenceStart > this.end) {
			throw new StringIndexOutOfBoundsException(start);
		}
		if (subSequenceEnd > this.end) {
			throw new StringIndexOutOfBoundsException(end);
		}
		if (start == 0 && subSequenceEnd == this.end) {
			return this;
		}
		return new StringSequence(this.source, subSequenceStart, subSequenceEnd);
	}
	/**
	 * Returns {@code true} if the sequence is empty. Public to be compatible with JDK 15.
	 * @return {@code true} if {@link #length()} is {@code 0}, otherwise {@code false}
	 */
	public boolean isEmpty() {
		return length() == 0;
	}
	@Override
	public int length() {
		return this.end - this.start;
	}
	@Override
	public char charAt(int index) {
		return this.source.charAt(this.start + index);
	}
	int indexOf(char ch) {
		return this.source.indexOf(ch, this.start) - this.start;
	}
	int indexOf(String str) {
		return this.source.indexOf(str, this.start) - this.start;
	}
	int indexOf(String str, int fromIndex) {
		return this.source.indexOf(str, this.start + fromIndex) - this.start;
	}
	boolean startsWith(String prefix) {
		return startsWith(prefix, 0);
	}
	boolean startsWith(String prefix, int offset) {
		int prefixLength = prefix.length();
		int length = length();
		if (length - prefixLength - offset < 0) {
			return false;
		}
		return this.source.startsWith(prefix, this.start + offset);
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (!(obj instanceof CharSequence other)) {
			return false;
		}
		int n = length();
		if (n != other.length()) {
			return false;
		}
		int i = 0;
		while (n-- != 0) {
			if (charAt(i) != other.charAt(i)) {
				return false;
			}
			i++;
		}
		return true;
	}
	@Override
	public int hashCode() {
		int hash = this.hash;
		if (hash == 0 && length() > 0) {
			for (int i = this.start; i < this.end; i++) {
				hash = 31 * hash + this.source.charAt(i);
			}
			this.hash = hash;
		}
		return hash;
	}
	@Override
	public String toString() {
		return this.source.substring(this.start, this.end);
	}
}
/*
package org.springframework.boot.loader.jar;
/**
interface FileHeader {
	/**
	 * Returns {@code true} if the header has the given name.
	 * @param name the name to test
	 * @param suffix an additional suffix (or {@code 0})
	 * @return {@code true} if the header has the given name
	 */
	boolean hasName(CharSequence name, char suffix);
	/**
	 * Return the offset of the load file header within the archive data.
	 * @return the local header offset
	 */
	long getLocalHeaderOffset();
	/**
	 * Return the compressed size of the entry.
	 * @return the compressed size.
	 */
	long getCompressedSize();
	/**
	 * Return the uncompressed size of the entry.
	 * @return the uncompressed size.
	 */
	long getSize();
	/**
	 * Return the method used to compress the data.
	 * @return the zip compression method
	 * @see ZipEntry#STORED
	 * @see ZipEntry#DEFLATED
	 */
	int getMethod();
}
/*
package org.springframework.boot.loader.jar;
/**
class CentralDirectoryEndRecord {
	private static final int MINIMUM_SIZE = 22;
	private static final int MAXIMUM_COMMENT_LENGTH = 0xFFFF;
	private static final int MAXIMUM_SIZE = MINIMUM_SIZE + MAXIMUM_COMMENT_LENGTH;
	private static final int SIGNATURE = 0x06054b50;
	private static final int COMMENT_LENGTH_OFFSET = 20;
	private static final int READ_BLOCK_SIZE = 256;
	private final Zip64End zip64End;
	private byte[] block;
	private int offset;
	private int size;
	/**
	 * Create a new {@link CentralDirectoryEndRecord} instance from the specified
	 * {@link RandomAccessData}, searching backwards from the end until a valid block is
	 * located.
	 * @param data the source data
	 * @throws IOException in case of I/O errors
	 */
	CentralDirectoryEndRecord(RandomAccessData data) throws IOException {
		this.block = createBlockFromEndOfData(data, READ_BLOCK_SIZE);
		this.size = MINIMUM_SIZE;
		this.offset = this.block.length - this.size;
		while (!isValid()) {
			this.size++;
			if (this.size > this.block.length) {
				if (this.size >= MAXIMUM_SIZE || this.size > data.getSize()) {
					throw new IOException(
							'Unable to find ZIP central directory records after reading ' + this.size + ' bytes');
				}
				this.block = createBlockFromEndOfData(data, this.size + READ_BLOCK_SIZE);
			}
			this.offset = this.block.length - this.size;
		}
		long startOfCentralDirectoryEndRecord = data.getSize() - this.size;
		Zip64Locator zip64Locator = Zip64Locator.find(data, startOfCentralDirectoryEndRecord);
		this.zip64End = (zip64Locator != null) ? new Zip64End(data, zip64Locator) : null;
	}
	private byte[] createBlockFromEndOfData(RandomAccessData data, int size) throws IOException {
		int length = (int) Math.min(data.getSize(), size);
		return data.read(data.getSize() - length, length);
	}
	private boolean isValid() {
		if (this.block.length < MINIMUM_SIZE || Bytes.littleEndianValue(this.block, this.offset + 0, 4) != SIGNATURE) {
			return false;
		}
		// Total size must be the structure size + comment
		long commentLength = Bytes.littleEndianValue(this.block, this.offset + COMMENT_LENGTH_OFFSET, 2);
		return this.size == MINIMUM_SIZE + commentLength;
	}
	/**
	 * Returns the location in the data that the archive actually starts. For most files
	 * the archive data will start at 0, however, it is possible to have prefixed bytes
	 * (often used for startup scripts) at the beginning of the data.
	 * @param data the source data
	 * @return the offset within the data where the archive begins
	 */
	long getStartOfArchive(RandomAccessData data) {
		long length = Bytes.littleEndianValue(this.block, this.offset + 12, 4);
		long specifiedOffset = (this.zip64End != null) ? this.zip64End.centralDirectoryOffset
				: Bytes.littleEndianValue(this.block, this.offset + 16, 4);
		long zip64EndSize = (this.zip64End != null) ? this.zip64End.getSize() : 0L;
		int zip64LocSize = (this.zip64End != null) ? Zip64Locator.ZIP64_LOCSIZE : 0;
		long actualOffset = data.getSize() - this.size - length - zip64EndSize - zip64LocSize;
		return actualOffset - specifiedOffset;
	}
	/**
	 * Return the bytes of the 'Central directory' based on the offset indicated in this
	 * record.
	 * @param data the source data
	 * @return the central directory data
	 */
	RandomAccessData getCentralDirectory(RandomAccessData data) {
		if (this.zip64End != null) {
			return this.zip64End.getCentralDirectory(data);
		}
		long offset = Bytes.littleEndianValue(this.block, this.offset + 16, 4);
		long length = Bytes.littleEndianValue(this.block, this.offset + 12, 4);
		return data.getSubsection(offset, length);
	}
	/**
	 * Return the number of ZIP entries in the file.
	 * @return the number of records in the zip
	 */
	int getNumberOfRecords() {
		if (this.zip64End != null) {
			return this.zip64End.getNumberOfRecords();
		}
		long numberOfRecords = Bytes.littleEndianValue(this.block, this.offset + 10, 2);
		return (int) numberOfRecords;
	}
	String getComment() {
		int commentLength = (int) Bytes.littleEndianValue(this.block, this.offset + COMMENT_LENGTH_OFFSET, 2);
		AsciiBytes comment = new AsciiBytes(this.block, this.offset + COMMENT_LENGTH_OFFSET + 2, commentLength);
		return comment.toString();
	}
	boolean isZip64() {
		return this.zip64End != null;
	}
	/**
	 * A Zip64 end of central directory record.
	 *
	 * @see <a href='https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT'>Chapter
	 * 4.3.14 of Zip64 specification</a>
	 */
	private static final class Zip64End {
		private static final int ZIP64_ENDTOT = 32; // total number of entries
		private static final int ZIP64_ENDSIZ = 40; // central directory size in bytes
		private static final int ZIP64_ENDOFF = 48; // offset of first CEN header
		private final Zip64Locator locator;
		private final long centralDirectoryOffset;
		private final long centralDirectoryLength;
		private final int numberOfRecords;
		private Zip64End(RandomAccessData data, Zip64Locator locator) throws IOException {
			this.locator = locator;
			byte[] block = data.read(locator.getZip64EndOffset(), 56);
			this.centralDirectoryOffset = Bytes.littleEndianValue(block, ZIP64_ENDOFF, 8);
			this.centralDirectoryLength = Bytes.littleEndianValue(block, ZIP64_ENDSIZ, 8);
			this.numberOfRecords = (int) Bytes.littleEndianValue(block, ZIP64_ENDTOT, 8);
		}
		/**
		 * Return the size of this zip 64 end of central directory record.
		 * @return size of this zip 64 end of central directory record
		 */
		private long getSize() {
			return this.locator.getZip64EndSize();
		}
		/**
		 * Return the bytes of the 'Central directory' based on the offset indicated in
		 * this record.
		 * @param data the source data
		 * @return the central directory data
		 */
		private RandomAccessData getCentralDirectory(RandomAccessData data) {
			return data.getSubsection(this.centralDirectoryOffset, this.centralDirectoryLength);
		}
		/**
		 * Return the number of entries in the zip64 archive.
		 * @return the number of records in the zip
		 */
		private int getNumberOfRecords() {
			return this.numberOfRecords;
		}
	}
	/**
	 * A Zip64 end of central directory locator.
	 *
	 * @see <a href='https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT'>Chapter
	 * 4.3.15 of Zip64 specification</a>
	 */
	private static final class Zip64Locator {
		static final int SIGNATURE = 0x07064b50;
		static final int ZIP64_LOCSIZE = 20; // locator size
		static final int ZIP64_LOCOFF = 8; // offset of zip64 end
		private final long zip64EndOffset;
		private final long offset;
		private Zip64Locator(long offset, byte[] block) {
			this.offset = offset;
			this.zip64EndOffset = Bytes.littleEndianValue(block, ZIP64_LOCOFF, 8);
		}
		/**
		 * Return the size of the zip 64 end record located by this zip64 end locator.
		 * @return size of the zip 64 end record located by this zip64 end locator
		 */
		private long getZip64EndSize() {
			return this.offset - this.zip64EndOffset;
		}
		/**
		 * Return the offset to locate {@link Zip64End}.
		 * @return offset of the Zip64 end of central directory record
		 */
		private long getZip64EndOffset() {
			return this.zip64EndOffset;
		}
		private static Zip64Locator find(RandomAccessData data, long centralDirectoryEndOffset) throws IOException {
			long offset = centralDirectoryEndOffset - ZIP64_LOCSIZE;
			if (offset >= 0) {
				byte[] block = data.read(offset, ZIP64_LOCSIZE);
				if (Bytes.littleEndianValue(block, 0, 4) == SIGNATURE) {
					return new Zip64Locator(offset, block);
				}
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
final class AsciiBytes {
	private static final String EMPTY_STRING = '';
	private static final int[] INITIAL_BYTE_BITMASK = { 0x7F, 0x1F, 0x0F, 0x07 };
	private static final int SUBSEQUENT_BYTE_BITMASK = 0x3F;
	private final byte[] bytes;
	private final int offset;
	private final int length;
	private String string;
	private int hash;
	/**
	 * Create a new {@link AsciiBytes} from the specified String.
	 * @param string the source string
	 */
	AsciiBytes(String string) {
		this(string.getBytes(StandardCharsets.UTF_8));
		this.string = string;
	}
	/**
	 * Create a new {@link AsciiBytes} from the specified bytes. NOTE: underlying bytes
	 * are not expected to change.
	 * @param bytes the source bytes
	 */
	AsciiBytes(byte[] bytes) {
		this(bytes, 0, bytes.length);
	}
	/**
	 * Create a new {@link AsciiBytes} from the specified bytes. NOTE: underlying bytes
	 * are not expected to change.
	 * @param bytes the source bytes
	 * @param offset the offset
	 * @param length the length
	 */
	AsciiBytes(byte[] bytes, int offset, int length) {
		if (offset < 0 || length < 0 || (offset + length) > bytes.length) {
			throw new IndexOutOfBoundsException();
		}
		this.bytes = bytes;
		this.offset = offset;
		this.length = length;
	}
	int length() {
		return this.length;
	}
	boolean startsWith(AsciiBytes prefix) {
		if (this == prefix) {
			return true;
		}
		if (prefix.length > this.length) {
			return false;
		}
		for (int i = 0; i < prefix.length; i++) {
			if (this.bytes[i + this.offset] != prefix.bytes[i + prefix.offset]) {
				return false;
			}
		}
		return true;
	}
	boolean endsWith(AsciiBytes postfix) {
		if (this == postfix) {
			return true;
		}
		if (postfix.length > this.length) {
			return false;
		}
		for (int i = 0; i < postfix.length; i++) {
			if (this.bytes[this.offset + (this.length - 1) - i] != postfix.bytes[postfix.offset + (postfix.length - 1)
					- i]) {
				return false;
			}
		}
		return true;
	}
	AsciiBytes substring(int beginIndex) {
		return substring(beginIndex, this.length);
	}
	AsciiBytes substring(int beginIndex, int endIndex) {
		int length = endIndex - beginIndex;
		if (this.offset + length > this.bytes.length) {
			throw new IndexOutOfBoundsException();
		}
		return new AsciiBytes(this.bytes, this.offset + beginIndex, length);
	}
	boolean matches(CharSequence name, char suffix) {
		int charIndex = 0;
		int nameLen = name.length();
		int totalLen = nameLen + ((suffix != 0) ? 1 : 0);
		for (int i = this.offset; i < this.offset + this.length; i++) {
			int b = this.bytes[i];
			int remainingUtfBytes = getNumberOfUtfBytes(b) - 1;
			b &= INITIAL_BYTE_BITMASK[remainingUtfBytes];
			for (int j = 0; j < remainingUtfBytes; j++) {
				b = (b << 6) + (this.bytes[++i] & SUBSEQUENT_BYTE_BITMASK);
			}
			char c = getChar(name, suffix, charIndex++);
			if (b <= 0xFFFF) {
				if (c != b) {
					return false;
				}
			}
			else {
				if (c != ((b >> 0xA) + 0xD7C0)) {
					return false;
				}
				c = getChar(name, suffix, charIndex++);
				if (c != ((b & 0x3FF) + 0xDC00)) {
					return false;
				}
			}
		}
		return charIndex == totalLen;
	}
	private char getChar(CharSequence name, char suffix, int index) {
		if (index < name.length()) {
			return name.charAt(index);
		}
		if (index == name.length()) {
			return suffix;
		}
		return 0;
	}
	private int getNumberOfUtfBytes(int b) {
		if ((b & 0x80) == 0) {
			return 1;
		}
		int numberOfUtfBytes = 0;
		while ((b & 0x80) != 0) {
			b <<= 1;
			numberOfUtfBytes++;
		}
		return numberOfUtfBytes;
	}
	@Override
	public boolean equals(Object obj) {
		if (obj == null) {
			return false;
		}
		if (this == obj) {
			return true;
		}
		if (obj.getClass() == AsciiBytes.class) {
			AsciiBytes other = (AsciiBytes) obj;
			if (this.length == other.length) {
				for (int i = 0; i < this.length; i++) {
					if (this.bytes[this.offset + i] != other.bytes[other.offset + i]) {
						return false;
					}
				}
				return true;
			}
		}
		return false;
	}
	@Override
	public int hashCode() {
		int hash = this.hash;
		if (hash == 0 && this.bytes.length > 0) {
			for (int i = this.offset; i < this.offset + this.length; i++) {
				int b = this.bytes[i];
				int remainingUtfBytes = getNumberOfUtfBytes(b) - 1;
				b &= INITIAL_BYTE_BITMASK[remainingUtfBytes];
				for (int j = 0; j < remainingUtfBytes; j++) {
					b = (b << 6) + (this.bytes[++i] & SUBSEQUENT_BYTE_BITMASK);
				}
				if (b <= 0xFFFF) {
					hash = 31 * hash + b;
				}
				else {
					hash = 31 * hash + ((b >> 0xA) + 0xD7C0);
					hash = 31 * hash + ((b & 0x3FF) + 0xDC00);
				}
			}
			this.hash = hash;
		}
		return hash;
	}
	@Override
	public String toString() {
		if (this.string == null) {
			if (this.length == 0) {
				this.string = EMPTY_STRING;
			}
			else {
				this.string = new String(this.bytes, this.offset, this.length, StandardCharsets.UTF_8);
			}
		}
		return this.string;
	}
	static String toString(byte[] bytes) {
		return new String(bytes, StandardCharsets.UTF_8);
	}
	static int hashCode(CharSequence charSequence) {
		// We"re compatible with String"s hashCode()
		if (charSequence instanceof StringSequence) {
			// ... but save making an unnecessary String for StringSequence
			return charSequence.hashCode();
		}
		return charSequence.toString().hashCode();
	}
	static int hashCode(int hash, char suffix) {
		return (suffix != 0) ? (31 * hash + suffix) : hash;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarEntryCertification {
	static final JarEntryCertification NONE = new JarEntryCertification(null, null);
	private final Certificate[] certificates;
	private final CodeSigner[] codeSigners;
	JarEntryCertification(Certificate[] certificates, CodeSigner[] codeSigners) {
		this.certificates = certificates;
		this.codeSigners = codeSigners;
	}
	Certificate[] getCertificates() {
		return (this.certificates != null) ? this.certificates.clone() : null;
	}
	CodeSigner[] getCodeSigners() {
		return (this.codeSigners != null) ? this.codeSigners.clone() : null;
	}
	static JarEntryCertification from(java.util.jar.JarEntry certifiedEntry) {
		Certificate[] certificates = (certifiedEntry != null) ? certifiedEntry.getCertificates() : null;
		CodeSigner[] codeSigners = (certifiedEntry != null) ? certifiedEntry.getCodeSigners() : null;
		if (certificates == null && codeSigners == null) {
			return NONE;
		}
		return new JarEntryCertification(certificates, codeSigners);
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class ZipInflaterInputStream extends InflaterInputStream {
	private final boolean ownsInflator;
	private int available;
	private boolean extraBytesWritten;
	ZipInflaterInputStream(InputStream inputStream, int size) {
		this(inputStream, new Inflater(true), size, true);
	}
	ZipInflaterInputStream(InputStream inputStream, Inflater inflater, int size) {
		this(inputStream, inflater, size, false);
	}
	private ZipInflaterInputStream(InputStream inputStream, Inflater inflater, int size, boolean ownsInflator) {
		super(inputStream, inflater, getInflaterBufferSize(size));
		this.ownsInflator = ownsInflator;
		this.available = size;
	}
	@Override
	public int available() throws IOException {
		if (this.available < 0) {
			return super.available();
		}
		return this.available;
	}
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int result = super.read(b, off, len);
		if (result != -1) {
			this.available -= result;
		}
		return result;
	}
	@Override
	public void close() throws IOException {
		super.close();
		if (this.ownsInflator) {
			this.inf.end();
		}
	}
	@Override
	protected void fill() throws IOException {
		try {
			super.fill();
		}
		catch (EOFException ex) {
			if (this.extraBytesWritten) {
				throw ex;
			}
			this.len = 1;
			this.buf[0] = 0x0;
			this.extraBytesWritten = true;
			this.inf.setInput(this.buf, 0, this.len);
		}
	}
	private static int getInflaterBufferSize(long size) {
		size += 2; // inflater likes some space
		size = (size > 65536) ? 8192 : size;
		size = (size <= 0) ? 4096 : size;
		return (int) size;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
public class JarFile extends AbstractJarFile implements Iterable<java.util.jar.JarEntry> {
	private static final String MANIFEST_NAME = 'META-INF/MANIFEST.MF';
	private static final String PROTOCOL_HANDLER = 'java.protocol.handler.pkgs';
	private static final String HANDLERS_PACKAGE = 'org.springframework.boot.loader';
	private static final AsciiBytes META_INF = new AsciiBytes('META-INF/');
	private static final AsciiBytes SIGNATURE_FILE_EXTENSION = new AsciiBytes('.SF');
	private static final String READ_ACTION = 'read';
	private final RandomAccessDataFile rootFile;
	private final String pathFromRoot;
	private final RandomAccessData data;
	private final JarFileType type;
	private URL url;
	private String urlString;
	private final JarFileEntries entries;
	private final Supplier<Manifest> manifestSupplier;
	private SoftReference<Manifest> manifest;
	private boolean signed;
	private String comment;
	private volatile boolean closed;
	private volatile JarFileWrapper wrapper;
	/**
	 * Create a new {@link JarFile} backed by the specified file.
	 * @param file the root jar file
	 * @throws IOException if the file cannot be read
	 */
	public JarFile(File file) throws IOException {
		this(new RandomAccessDataFile(file));
	}
	/**
	 * Create a new {@link JarFile} backed by the specified file.
	 * @param file the root jar file
	 * @throws IOException if the file cannot be read
	 */
	JarFile(RandomAccessDataFile file) throws IOException {
		this(file, '', file, JarFileType.DIRECT);
	}
	/**
	 * Private constructor used to create a new {@link JarFile} either directly or from a
	 * nested entry.
	 * @param rootFile the root jar file
	 * @param pathFromRoot the name of this file
	 * @param data the underlying data
	 * @param type the type of the jar file
	 * @throws IOException if the file cannot be read
	 */
	private JarFile(RandomAccessDataFile rootFile, String pathFromRoot, RandomAccessData data, JarFileType type)
			throws IOException {
		this(rootFile, pathFromRoot, data, null, type, null);
	}
	private JarFile(RandomAccessDataFile rootFile, String pathFromRoot, RandomAccessData data, JarEntryFilter filter,
			JarFileType type, Supplier<Manifest> manifestSupplier) throws IOException {
		super(rootFile.getFile());
		super.close();
		this.rootFile = rootFile;
		this.pathFromRoot = pathFromRoot;
		CentralDirectoryParser parser = new CentralDirectoryParser();
		this.entries = parser.addVisitor(new JarFileEntries(this, filter));
		this.type = type;
		parser.addVisitor(centralDirectoryVisitor());
		try {
			this.data = parser.parse(data, filter == null);
		}
		catch (RuntimeException ex) {
			try {
				this.rootFile.close();
				super.close();
			}
			catch (IOException ioex) {
				// Ignore
			}
			throw ex;
		}
		this.manifestSupplier = (manifestSupplier != null) ? manifestSupplier : () -> {
			try (InputStream inputStream = getInputStream(MANIFEST_NAME)) {
				if (inputStream == null) {
					return null;
				}
				return new Manifest(inputStream);
			}
			catch (IOException ex) {
				throw new RuntimeException(ex);
			}
		};
	}
	private CentralDirectoryVisitor centralDirectoryVisitor() {
		return new CentralDirectoryVisitor() {
			@Override
			public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {
				JarFile.this.comment = endRecord.getComment();
			}
			@Override
			public void visitFileHeader(CentralDirectoryFileHeader fileHeader, long dataOffset) {
				AsciiBytes name = fileHeader.getName();
				if (name.startsWith(META_INF) && name.endsWith(SIGNATURE_FILE_EXTENSION)) {
					JarFile.this.signed = true;
				}
			}
			@Override
			public void visitEnd() {
			}
		};
	}
	JarFileWrapper getWrapper() throws IOException {
		JarFileWrapper wrapper = this.wrapper;
		if (wrapper == null) {
			wrapper = new JarFileWrapper(this);
			this.wrapper = wrapper;
		}
		return wrapper;
	}
	@Override
	Permission getPermission() {
		return new FilePermission(this.rootFile.getFile().getPath(), READ_ACTION);
	}
	protected final RandomAccessDataFile getRootJarFile() {
		return this.rootFile;
	}
	RandomAccessData getData() {
		return this.data;
	}
	@Override
	public Manifest getManifest() throws IOException {
		Manifest manifest = (this.manifest != null) ? this.manifest.get() : null;
		if (manifest == null) {
			try {
				manifest = this.manifestSupplier.get();
			}
			catch (RuntimeException ex) {
				throw new IOException(ex);
			}
			this.manifest = new SoftReference<>(manifest);
		}
		return manifest;
	}
	@Override
	public Enumeration<java.util.jar.JarEntry> entries() {
		return new JarEntryEnumeration(this.entries.iterator());
	}
	@Override
	public Stream<java.util.jar.JarEntry> stream() {
		Spliterator<java.util.jar.JarEntry> spliterator = Spliterators.spliterator(iterator(), size(),
				Spliterator.ORDERED | Spliterator.DISTINCT | Spliterator.IMMUTABLE | Spliterator.NONNULL);
		return StreamSupport.stream(spliterator, false);
	}
	/**
	 * Return an iterator for the contained entries.
	 * @since 2.3.0
	 * @see java.lang.Iterable#iterator()
	 */
	@Override
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	public Iterator<java.util.jar.JarEntry> iterator() {
		return (Iterator) this.entries.iterator(this::ensureOpen);
	}
	public JarEntry getJarEntry(CharSequence name) {
		return this.entries.getEntry(name);
	}
	@Override
	public JarEntry getJarEntry(String name) {
		return (JarEntry) getEntry(name);
	}
	public boolean containsEntry(String name) {
		return this.entries.containsEntry(name);
	}
	@Override
	public ZipEntry getEntry(String name) {
		ensureOpen();
		return this.entries.getEntry(name);
	}
	@Override
	InputStream getInputStream() throws IOException {
		return this.data.getInputStream();
	}
	@Override
	public synchronized InputStream getInputStream(ZipEntry entry) throws IOException {
		ensureOpen();
		if (entry instanceof JarEntry jarEntry) {
			return this.entries.getInputStream(jarEntry);
		}
		return getInputStream((entry != null) ? entry.getName() : null);
	}
	InputStream getInputStream(String name) throws IOException {
		return this.entries.getInputStream(name);
	}
	/**
	 * Return a nested {@link JarFile} loaded from the specified entry.
	 * @param entry the zip entry
	 * @return a {@link JarFile} for the entry
	 * @throws IOException if the nested jar file cannot be read
	 */
	public synchronized JarFile getNestedJarFile(ZipEntry entry) throws IOException {
		return getNestedJarFile((JarEntry) entry);
	}
	/**
	 * Return a nested {@link JarFile} loaded from the specified entry.
	 * @param entry the zip entry
	 * @return a {@link JarFile} for the entry
	 * @throws IOException if the nested jar file cannot be read
	 */
	public synchronized JarFile getNestedJarFile(JarEntry entry) throws IOException {
		try {
			return createJarFileFromEntry(entry);
		}
		catch (Exception ex) {
			throw new IOException('Unable to open nested jar file "' + entry.getName() + '"', ex);
		}
	}
	private JarFile createJarFileFromEntry(JarEntry entry) throws IOException {
		if (entry.isDirectory()) {
			return createJarFileFromDirectoryEntry(entry);
		}
		return createJarFileFromFileEntry(entry);
	}
	private JarFile createJarFileFromDirectoryEntry(JarEntry entry) throws IOException {
		AsciiBytes name = entry.getAsciiBytesName();
		JarEntryFilter filter = (candidate) -> {
			if (candidate.startsWith(name) && !candidate.equals(name)) {
				return candidate.substring(name.length());
			}
			return null;
		};
		return new JarFile(this.rootFile, this.pathFromRoot + '!/' + entry.getName().substring(0, name.length() - 1),
				this.data, filter, JarFileType.NESTED_DIRECTORY, this.manifestSupplier);
	}
	private JarFile createJarFileFromFileEntry(JarEntry entry) throws IOException {
		if (entry.getMethod() != ZipEntry.STORED) {
			throw new IllegalStateException(
					'Unable to open nested entry "' + entry.getName() + '". It has been compressed and nested '
							+ 'jar files must be stored without compression. Please check the '
							+ 'mechanism used to create your executable jar file');
		}
		RandomAccessData entryData = this.entries.getEntryData(entry.getName());
		return new JarFile(this.rootFile, this.pathFromRoot + '!/' + entry.getName(), entryData,
				JarFileType.NESTED_JAR);
	}
	@Override
	public String getComment() {
		ensureOpen();
		return this.comment;
	}
	@Override
	public int size() {
		ensureOpen();
		return this.entries.getSize();
	}
	@Override
	public void close() throws IOException {
		if (this.closed) {
			return;
		}
		super.close();
		if (this.type == JarFileType.DIRECT) {
			this.rootFile.close();
		}
		this.closed = true;
	}
	private void ensureOpen() {
		if (this.closed) {
			throw new IllegalStateException('zip file closed');
		}
	}
	boolean isClosed() {
		return this.closed;
	}
	String getUrlString() throws MalformedURLException {
		if (this.urlString == null) {
			this.urlString = getUrl().toString();
		}
		return this.urlString;
	}
	@Override
	public URL getUrl() throws MalformedURLException {
		if (this.url == null) {
			String file = this.rootFile.getFile().toURI() + this.pathFromRoot + '!/';
			file = file.replace('file:////', 'file://'); // Fix UNC paths
			this.url = new URL('jar', '', -1, file, new Handler(this));
		}
		return this.url;
	}
	@Override
	public String toString() {
		return getName();
	}
	@Override
	public String getName() {
		return this.rootFile.getFile() + this.pathFromRoot;
	}
	boolean isSigned() {
		return this.signed;
	}
	JarEntryCertification getCertification(JarEntry entry) {
		try {
			return this.entries.getCertification(entry);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	public void clearCache() {
		this.entries.clearCache();
	}
	protected String getPathFromRoot() {
		return this.pathFromRoot;
	}
	@Override
	JarFileType getType() {
		return this.type;
	}
	/**
	 * Register a {@literal "java.protocol.handler.pkgs"} property so that a
	 * {@link URLStreamHandler} will be located to deal with jar URLs.
	 */
	public static void registerUrlProtocolHandler() {
		Handler.captureJarContextUrl();
		String handlers = System.getProperty(PROTOCOL_HANDLER, '');
		System.setProperty(PROTOCOL_HANDLER,
				((handlers == null || handlers.isEmpty()) ? HANDLERS_PACKAGE : handlers + '|' + HANDLERS_PACKAGE));
		resetCachedUrlHandlers();
	}
	/**
	 * Reset any cached handlers just in case a jar protocol has already been used. We
	 * reset the handler by trying to set a null {@link URLStreamHandlerFactory} which
	 * should have no effect other than clearing the handlers cache.
	 */
	private static void resetCachedUrlHandlers() {
		try {
			URL.setURLStreamHandlerFactory(null);
		}
		catch (Error ex) {
			// Ignore
		}
	}
	/**
	 * An {@link Enumeration} on {@linkplain java.util.jar.JarEntry jar entries}.
	 */
	private static class JarEntryEnumeration implements Enumeration<java.util.jar.JarEntry> {
		private final Iterator<JarEntry> iterator;
		JarEntryEnumeration(Iterator<JarEntry> iterator) {
			this.iterator = iterator;
		}
		@Override
		public boolean hasMoreElements() {
			return this.iterator.hasNext();
		}
		@Override
		public java.util.jar.JarEntry nextElement() {
			return this.iterator.next();
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
final class Bytes {
	private Bytes() {
	}
	static long littleEndianValue(byte[] bytes, int offset, int length) {
		long value = 0;
		for (int i = length - 1; i >= 0; i--) {
			value = ((value << 8) | (bytes[offset + i] & 0xFF));
		}
		return value;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
final class CentralDirectoryFileHeader implements FileHeader {
	private static final AsciiBytes SLASH = new AsciiBytes('/');
	private static final byte[] NO_EXTRA = {};
	private static final AsciiBytes NO_COMMENT = new AsciiBytes('');
	private byte[] header;
	private int headerOffset;
	private AsciiBytes name;
	private byte[] extra;
	private AsciiBytes comment;
	private long localHeaderOffset;
	CentralDirectoryFileHeader() {
	}
	CentralDirectoryFileHeader(byte[] header, int headerOffset, AsciiBytes name, byte[] extra, AsciiBytes comment,
			long localHeaderOffset) {
		this.header = header;
		this.headerOffset = headerOffset;
		this.name = name;
		this.extra = extra;
		this.comment = comment;
		this.localHeaderOffset = localHeaderOffset;
	}
	void load(byte[] data, int dataOffset, RandomAccessData variableData, long variableOffset, JarEntryFilter filter)
			throws IOException {
		// Load fixed part
		this.header = data;
		this.headerOffset = dataOffset;
		long compressedSize = Bytes.littleEndianValue(data, dataOffset + 20, 4);
		long uncompressedSize = Bytes.littleEndianValue(data, dataOffset + 24, 4);
		long nameLength = Bytes.littleEndianValue(data, dataOffset + 28, 2);
		long extraLength = Bytes.littleEndianValue(data, dataOffset + 30, 2);
		long commentLength = Bytes.littleEndianValue(data, dataOffset + 32, 2);
		long localHeaderOffset = Bytes.littleEndianValue(data, dataOffset + 42, 4);
		// Load variable part
		dataOffset += 46;
		if (variableData != null) {
			data = variableData.read(variableOffset + 46, nameLength + extraLength + commentLength);
			dataOffset = 0;
		}
		this.name = new AsciiBytes(data, dataOffset, (int) nameLength);
		if (filter != null) {
			this.name = filter.apply(this.name);
		}
		this.extra = NO_EXTRA;
		this.comment = NO_COMMENT;
		if (extraLength > 0) {
			this.extra = new byte[(int) extraLength];
			System.arraycopy(data, (int) (dataOffset + nameLength), this.extra, 0, this.extra.length);
		}
		this.localHeaderOffset = getLocalHeaderOffset(compressedSize, uncompressedSize, localHeaderOffset, this.extra);
		if (commentLength > 0) {
			this.comment = new AsciiBytes(data, (int) (dataOffset + nameLength + extraLength), (int) commentLength);
		}
	}
	private long getLocalHeaderOffset(long compressedSize, long uncompressedSize, long localHeaderOffset, byte[] extra)
			throws IOException {
		if (localHeaderOffset != 0xFFFFFFFFL) {
			return localHeaderOffset;
		}
		int extraOffset = 0;
		while (extraOffset < extra.length - 2) {
			int id = (int) Bytes.littleEndianValue(extra, extraOffset, 2);
			int length = (int) Bytes.littleEndianValue(extra, extraOffset, 2);
			extraOffset += 4;
			if (id == 1) {
				int localHeaderExtraOffset = 0;
				if (compressedSize == 0xFFFFFFFFL) {
					localHeaderExtraOffset += 4;
				}
				if (uncompressedSize == 0xFFFFFFFFL) {
					localHeaderExtraOffset += 4;
				}
				return Bytes.littleEndianValue(extra, extraOffset + localHeaderExtraOffset, 8);
			}
			extraOffset += length;
		}
		throw new IOException('Zip64 Extended Information Extra Field not found');
	}
	AsciiBytes getName() {
		return this.name;
	}
	@Override
	public boolean hasName(CharSequence name, char suffix) {
		return this.name.matches(name, suffix);
	}
	boolean isDirectory() {
		return this.name.endsWith(SLASH);
	}
	@Override
	public int getMethod() {
		return (int) Bytes.littleEndianValue(this.header, this.headerOffset + 10, 2);
	}
	long getTime() {
		long datetime = Bytes.littleEndianValue(this.header, this.headerOffset + 12, 4);
		return decodeMsDosFormatDateTime(datetime);
	}
	/**
	 * Decode MS-DOS Date Time details. See <a href=
	 * 'https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-dosdatetimetofiletime'>
	 * Microsoft"s documentation</a> for more details of the format.
	 * @param datetime the date and time
	 * @return the date and time as milliseconds since the epoch
	 */
	private long decodeMsDosFormatDateTime(long datetime) {
		int year = getChronoValue(((datetime >> 25) & 0x7f) + 1980, ChronoField.YEAR);
		int month = getChronoValue((datetime >> 21) & 0x0f, ChronoField.MONTH_OF_YEAR);
		int day = getChronoValue((datetime >> 16) & 0x1f, ChronoField.DAY_OF_MONTH);
		int hour = getChronoValue((datetime >> 11) & 0x1f, ChronoField.HOUR_OF_DAY);
		int minute = getChronoValue((datetime >> 5) & 0x3f, ChronoField.MINUTE_OF_HOUR);
		int second = getChronoValue((datetime << 1) & 0x3e, ChronoField.SECOND_OF_MINUTE);
		return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault())
			.toInstant()
			.truncatedTo(ChronoUnit.SECONDS)
			.toEpochMilli();
	}
	long getCrc() {
		return Bytes.littleEndianValue(this.header, this.headerOffset + 16, 4);
	}
	@Override
	public long getCompressedSize() {
		return Bytes.littleEndianValue(this.header, this.headerOffset + 20, 4);
	}
	@Override
	public long getSize() {
		return Bytes.littleEndianValue(this.header, this.headerOffset + 24, 4);
	}
	byte[] getExtra() {
		return this.extra;
	}
	boolean hasExtra() {
		return this.extra.length > 0;
	}
	AsciiBytes getComment() {
		return this.comment;
	}
	@Override
	public long getLocalHeaderOffset() {
		return this.localHeaderOffset;
	}
	@Override
	public CentralDirectoryFileHeader clone() {
		byte[] header = new byte[46];
		System.arraycopy(this.header, this.headerOffset, header, 0, header.length);
		return new CentralDirectoryFileHeader(header, 0, this.name, header, this.comment, this.localHeaderOffset);
	}
	static CentralDirectoryFileHeader fromRandomAccessData(RandomAccessData data, long offset, JarEntryFilter filter)
			throws IOException {
		CentralDirectoryFileHeader fileHeader = new CentralDirectoryFileHeader();
		byte[] bytes = data.read(offset, 46);
		fileHeader.load(bytes, 0, data, offset, filter);
		return fileHeader;
	}
	private static int getChronoValue(long value, ChronoField field) {
		ValueRange range = field.range();
		return Math.toIntExact(Math.min(Math.max(value, range.getMinimum()), range.getMaximum()));
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarFileEntries implements CentralDirectoryVisitor, Iterable<JarEntry> {
	private static final Runnable NO_VALIDATION = () -> {
	};
	private static final String META_INF_PREFIX = 'META-INF/';
	private static final Name MULTI_RELEASE = new Name('Multi-Release');
	private static final int BASE_VERSION = 8;
	private static final int RUNTIME_VERSION = Runtime.version().feature();
	private static final long LOCAL_FILE_HEADER_SIZE = 30;
	private static final char SLASH = "/";
	private static final char NO_SUFFIX = 0;
	protected static final int ENTRY_CACHE_SIZE = 25;
	private final JarFile jarFile;
	private final JarEntryFilter filter;
	private RandomAccessData centralDirectoryData;
	private int size;
	private int[] hashCodes;
	private Offsets centralDirectoryOffsets;
	private int[] positions;
	private Boolean multiReleaseJar;
	private JarEntryCertification[] certifications;
	private final Map<Integer, FileHeader> entriesCache = Collections
		.synchronizedMap(new LinkedHashMap<>(16, 0.75f, true) {
			@Override
			protected boolean removeEldestEntry(Map.Entry<Integer, FileHeader> eldest) {
				return size() >= ENTRY_CACHE_SIZE;
			}
		});
	JarFileEntries(JarFile jarFile, JarEntryFilter filter) {
		this.jarFile = jarFile;
		this.filter = filter;
	}
	@Override
	public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {
		int maxSize = endRecord.getNumberOfRecords();
		this.centralDirectoryData = centralDirectoryData;
		this.hashCodes = new int[maxSize];
		this.centralDirectoryOffsets = Offsets.from(endRecord);
		this.positions = new int[maxSize];
	}
	@Override
	public void visitFileHeader(CentralDirectoryFileHeader fileHeader, long dataOffset) {
		AsciiBytes name = applyFilter(fileHeader.getName());
		if (name != null) {
			add(name, dataOffset);
		}
	}
	private void add(AsciiBytes name, long dataOffset) {
		this.hashCodes[this.size] = name.hashCode();
		this.centralDirectoryOffsets.set(this.size, dataOffset);
		this.positions[this.size] = this.size;
		this.size++;
	}
	@Override
	public void visitEnd() {
		sort(0, this.size - 1);
		int[] positions = this.positions;
		this.positions = new int[positions.length];
		for (int i = 0; i < this.size; i++) {
			this.positions[positions[i]] = i;
		}
	}
	int getSize() {
		return this.size;
	}
	private void sort(int left, int right) {
		// Quick sort algorithm, uses hashCodes as the source but sorts all arrays
		if (left < right) {
			int pivot = this.hashCodes[left + (right - left) / 2];
			int i = left;
			int j = right;
			while (i <= j) {
				while (this.hashCodes[i] < pivot) {
					i++;
				}
				while (this.hashCodes[j] > pivot) {
					j--;
				}
				if (i <= j) {
					swap(i, j);
					i++;
					j--;
				}
			}
			if (left < j) {
				sort(left, j);
			}
			if (right > i) {
				sort(i, right);
			}
		}
	}
	private void swap(int i, int j) {
		swap(this.hashCodes, i, j);
		this.centralDirectoryOffsets.swap(i, j);
		swap(this.positions, i, j);
	}
	@Override
	public Iterator<JarEntry> iterator() {
		return new EntryIterator(NO_VALIDATION);
	}
	Iterator<JarEntry> iterator(Runnable validator) {
		return new EntryIterator(validator);
	}
	boolean containsEntry(CharSequence name) {
		return getEntry(name, FileHeader.class, true) != null;
	}
	JarEntry getEntry(CharSequence name) {
		return getEntry(name, JarEntry.class, true);
	}
	InputStream getInputStream(String name) throws IOException {
		FileHeader entry = getEntry(name, FileHeader.class, false);
		return getInputStream(entry);
	}
	InputStream getInputStream(FileHeader entry) throws IOException {
		if (entry == null) {
			return null;
		}
		InputStream inputStream = getEntryData(entry).getInputStream();
		if (entry.getMethod() == ZipEntry.DEFLATED) {
			inputStream = new ZipInflaterInputStream(inputStream, (int) entry.getSize());
		}
		return inputStream;
	}
	RandomAccessData getEntryData(String name) throws IOException {
		FileHeader entry = getEntry(name, FileHeader.class, false);
		if (entry == null) {
			return null;
		}
		return getEntryData(entry);
	}
	private RandomAccessData getEntryData(FileHeader entry) throws IOException {
		// aspectjrt-1.7.4.jar has a different ext bytes length in the
		// local directory to the central directory. We need to re-read
		// here to skip them
		RandomAccessData data = this.jarFile.getData();
		byte[] localHeader = data.read(entry.getLocalHeaderOffset(), LOCAL_FILE_HEADER_SIZE);
		long nameLength = Bytes.littleEndianValue(localHeader, 26, 2);
		long extraLength = Bytes.littleEndianValue(localHeader, 28, 2);
		return data.getSubsection(entry.getLocalHeaderOffset() + LOCAL_FILE_HEADER_SIZE + nameLength + extraLength,
				entry.getCompressedSize());
	}
	private <T extends FileHeader> T getEntry(CharSequence name, Class<T> type, boolean cacheEntry) {
		T entry = doGetEntry(name, type, cacheEntry, null);
		if (!isMetaInfEntry(name) && isMultiReleaseJar()) {
			int version = RUNTIME_VERSION;
			AsciiBytes nameAlias = (entry instanceof JarEntry jarEntry) ? jarEntry.getAsciiBytesName()
					: new AsciiBytes(name.toString());
			while (version > BASE_VERSION) {
				T versionedEntry = doGetEntry('META-INF/versions/' + version + '/' + name, type, cacheEntry, nameAlias);
				if (versionedEntry != null) {
					return versionedEntry;
				}
				version--;
			}
		}
		return entry;
	}
	private boolean isMetaInfEntry(CharSequence name) {
		return name.toString().startsWith(META_INF_PREFIX);
	}
	private boolean isMultiReleaseJar() {
		Boolean multiRelease = this.multiReleaseJar;
		if (multiRelease != null) {
			return multiRelease;
		}
		try {
			Manifest manifest = this.jarFile.getManifest();
			if (manifest == null) {
				multiRelease = false;
			}
			else {
				Attributes attributes = manifest.getMainAttributes();
				multiRelease = attributes.containsKey(MULTI_RELEASE);
			}
		}
		catch (IOException ex) {
			multiRelease = false;
		}
		this.multiReleaseJar = multiRelease;
		return multiRelease;
	}
	private <T extends FileHeader> T doGetEntry(CharSequence name, Class<T> type, boolean cacheEntry,
			AsciiBytes nameAlias) {
		int hashCode = AsciiBytes.hashCode(name);
		T entry = getEntry(hashCode, name, NO_SUFFIX, type, cacheEntry, nameAlias);
		if (entry == null) {
			hashCode = AsciiBytes.hashCode(hashCode, SLASH);
			entry = getEntry(hashCode, name, SLASH, type, cacheEntry, nameAlias);
		}
		return entry;
	}
	private <T extends FileHeader> T getEntry(int hashCode, CharSequence name, char suffix, Class<T> type,
			boolean cacheEntry, AsciiBytes nameAlias) {
		int index = getFirstIndex(hashCode);
		while (index >= 0 && index < this.size && this.hashCodes[index] == hashCode) {
			T entry = getEntry(index, type, cacheEntry, nameAlias);
			if (entry.hasName(name, suffix)) {
				return entry;
			}
			index++;
		}
		return null;
	}
	@SuppressWarnings('unchecked')
	private <T extends FileHeader> T getEntry(int index, Class<T> type, boolean cacheEntry, AsciiBytes nameAlias) {
		try {
			long offset = this.centralDirectoryOffsets.get(index);
			FileHeader cached = this.entriesCache.get(index);
			FileHeader entry = (cached != null) ? cached
					: CentralDirectoryFileHeader.fromRandomAccessData(this.centralDirectoryData, offset, this.filter);
			if (CentralDirectoryFileHeader.class.equals(entry.getClass()) && type.equals(JarEntry.class)) {
				entry = new JarEntry(this.jarFile, index, (CentralDirectoryFileHeader) entry, nameAlias);
			}
			if (cacheEntry && cached != entry) {
				this.entriesCache.put(index, entry);
			}
			return (T) entry;
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private int getFirstIndex(int hashCode) {
		int index = Arrays.binarySearch(this.hashCodes, 0, this.size, hashCode);
		if (index < 0) {
			return -1;
		}
		while (index > 0 && this.hashCodes[index - 1] == hashCode) {
			index--;
		}
		return index;
	}
	void clearCache() {
		this.entriesCache.clear();
	}
	private AsciiBytes applyFilter(AsciiBytes name) {
		return (this.filter != null) ? this.filter.apply(name) : name;
	}
	JarEntryCertification getCertification(JarEntry entry) throws IOException {
		JarEntryCertification[] certifications = this.certifications;
		if (certifications == null) {
			certifications = getCertifications();
			this.certifications = certifications;
		}
		JarEntryCertification certification = certifications[entry.getIndex()];
		return (certification != null) ? certification : JarEntryCertification.NONE;
	}
	private JarEntryCertification[] getCertifications() throws IOException {
		JarEntryCertification[] certifications = new JarEntryCertification[this.size];
		try (JarEntriesStream entries = new JarEntriesStream(this.jarFile.getData().getInputStream())) {
			java.util.jar.JarEntry entry = entries.getNextEntry();
			while (entry != null) {
				JarEntry relatedEntry = this.doGetEntry(entry.getName(), JarEntry.class, false, null);
				if (relatedEntry != null && entries.matches(relatedEntry.isDirectory(), (int) relatedEntry.getSize(),
						relatedEntry.getMethod(), () -> getEntryData(relatedEntry).getInputStream())) {
					int index = relatedEntry.getIndex();
					if (index != -1) {
						certifications[index] = JarEntryCertification.from(entry);
					}
				}
				entry = entries.getNextEntry();
			}
		}
		return certifications;
	}
	private static void swap(int[] array, int i, int j) {
		int temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}
	private static void swap(long[] array, int i, int j) {
		long temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}
	/**
	 * Iterator for contained entries.
	 */
	private final class EntryIterator implements Iterator<JarEntry> {
		private final Runnable validator;
		private int index = 0;
		private EntryIterator(Runnable validator) {
			this.validator = validator;
			validator.run();
		}
		@Override
		public boolean hasNext() {
			this.validator.run();
			return this.index < JarFileEntries.this.size;
		}
		@Override
		public JarEntry next() {
			this.validator.run();
			if (!hasNext()) {
				throw new NoSuchElementException();
			}
			int entryIndex = JarFileEntries.this.positions[this.index];
			this.index++;
			return getEntry(entryIndex, JarEntry.class, false, null);
		}
	}
	/**
	 * Interface to manage offsets to central directory records. Regular zip files are
	 * backed by an {@code int[]} based implementation, Zip64 files are backed by a
	 * {@code long[]} and will consume more memory.
	 */
	private interface Offsets {
		void set(int index, long value);
		long get(int index);
		void swap(int i, int j);
		static Offsets from(CentralDirectoryEndRecord endRecord) {
			int size = endRecord.getNumberOfRecords();
			return endRecord.isZip64() ? new Zip64Offsets(size) : new ZipOffsets(size);
		}
	}
	/**
	 * {@link Offsets} implementation for regular zip files.
	 */
	private static final class ZipOffsets implements Offsets {
		private final int[] offsets;
		private ZipOffsets(int size) {
			this.offsets = new int[size];
		}
		@Override
		public void swap(int i, int j) {
			JarFileEntries.swap(this.offsets, i, j);
		}
		@Override
		public void set(int index, long value) {
			this.offsets[index] = (int) value;
		}
		@Override
		public long get(int index) {
			return this.offsets[index];
		}
	}
	/**
	 * {@link Offsets} implementation for zip64 files.
	 */
	private static final class Zip64Offsets implements Offsets {
		private final long[] offsets;
		private Zip64Offsets(int size) {
			this.offsets = new long[size];
		}
		@Override
		public void swap(int i, int j) {
			JarFileEntries.swap(this.offsets, i, j);
		}
		@Override
		public void set(int index, long value) {
			this.offsets[index] = value;
		}
		@Override
		public long get(int index) {
			return this.offsets[index];
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarEntriesStream implements Closeable {
	private static final int BUFFER_SIZE = 4 * 1024;
	private final JarInputStream in;
	private final byte[] inBuffer = new byte[BUFFER_SIZE];
	private final byte[] compareBuffer = new byte[BUFFER_SIZE];
	private final Inflater inflater = new Inflater(true);
	private JarEntry entry;
	JarEntriesStream(InputStream in) throws IOException {
		this.in = new JarInputStream(in);
	}
	JarEntry getNextEntry() throws IOException {
		this.entry = this.in.getNextJarEntry();
		if (this.entry != null) {
			this.entry.getSize();
		}
		this.inflater.reset();
		return this.entry;
	}
	boolean matches(boolean directory, int size, int compressionMethod, InputStreamSupplier streamSupplier)
			throws IOException {
		if (this.entry.isDirectory() != directory) {
			fail('directory');
		}
		if (this.entry.getMethod() != compressionMethod) {
			fail('compression method');
		}
		if (this.entry.isDirectory()) {
			this.in.closeEntry();
			return true;
		}
		try (DataInputStream expected = new DataInputStream(getInputStream(size, streamSupplier))) {
			assertSameContent(expected);
		}
		return true;
	}
	private InputStream getInputStream(int size, InputStreamSupplier streamSupplier) throws IOException {
		InputStream inputStream = streamSupplier.get();
		return (this.entry.getMethod() != ZipEntry.DEFLATED) ? inputStream
				: new ZipInflaterInputStream(inputStream, this.inflater, size);
	}
	private void assertSameContent(DataInputStream expected) throws IOException {
		int len;
		while ((len = this.in.read(this.inBuffer)) > 0) {
			try {
				expected.readFully(this.compareBuffer, 0, len);
				if (Arrays.equals(this.inBuffer, 0, len, this.compareBuffer, 0, len)) {
					continue;
				}
			}
			catch (EOFException ex) {
				// Continue and throw exception due to mismatched content length.
			}
			fail('content');
		}
		if (expected.read() != -1) {
			fail('content');
		}
	}
	private void fail(String check) {
		throw new IllegalStateException('Content mismatch when reading security info for entry "%s" (%s check)'
			.formatted(this.entry.getName(), check));
	}
	@Override
	public void close() throws IOException {
		this.inflater.end();
		this.in.close();
	}
	@FunctionalInterface
	interface InputStreamSupplier {
		InputStream get() throws IOException;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
abstract class AbstractJarFile extends java.util.jar.JarFile {
	/**
	 * Create a new {@link AbstractJarFile}.
	 * @param file the root jar file.
	 * @throws IOException on IO error
	 */
	AbstractJarFile(File file) throws IOException {
		super(file);
	}
	/**
	 * Return a URL that can be used to access this JAR file. NOTE: the specified URL
	 * cannot be serialized and or cloned.
	 * @return the URL
	 * @throws MalformedURLException if the URL is malformed
	 */
	abstract URL getUrl() throws MalformedURLException;
	/**
	 * Return the {@link JarFileType} of this instance.
	 * @return the jar file type
	 */
	abstract JarFileType getType();
	/**
	 * Return the security permission for this JAR.
	 * @return the security permission.
	 */
	abstract Permission getPermission();
	/**
	 * Return an {@link InputStream} for the entire jar contents.
	 * @return the contents input stream
	 * @throws IOException on IO error
	 */
	abstract InputStream getInputStream() throws IOException;
	/**
	 * The type of a {@link JarFile}.
	 */
	enum JarFileType {
		DIRECT, NESTED_DIRECTORY, NESTED_JAR
	}
}
/*
package org.springframework.boot.loader.jar;
/**
interface CentralDirectoryVisitor {
	void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData);
	void visitFileHeader(CentralDirectoryFileHeader fileHeader, long dataOffset);
	void visitEnd();
}
/*
package org.springframework.boot.loader.jar;
/**
class CentralDirectoryParser {
	private static final int CENTRAL_DIRECTORY_HEADER_BASE_SIZE = 46;
	private final List<CentralDirectoryVisitor> visitors = new ArrayList<>();
	<T extends CentralDirectoryVisitor> T addVisitor(T visitor) {
		this.visitors.add(visitor);
		return visitor;
	}
	/**
	 * Parse the source data, triggering {@link CentralDirectoryVisitor visitors}.
	 * @param data the source data
	 * @param skipPrefixBytes if prefix bytes should be skipped
	 * @return the actual archive data without any prefix bytes
	 * @throws IOException on error
	 */
	RandomAccessData parse(RandomAccessData data, boolean skipPrefixBytes) throws IOException {
		CentralDirectoryEndRecord endRecord = new CentralDirectoryEndRecord(data);
		if (skipPrefixBytes) {
			data = getArchiveData(endRecord, data);
		}
		RandomAccessData centralDirectoryData = endRecord.getCentralDirectory(data);
		visitStart(endRecord, centralDirectoryData);
		parseEntries(endRecord, centralDirectoryData);
		visitEnd();
		return data;
	}
	private void parseEntries(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData)
			throws IOException {
		byte[] bytes = centralDirectoryData.read(0, centralDirectoryData.getSize());
		CentralDirectoryFileHeader fileHeader = new CentralDirectoryFileHeader();
		int dataOffset = 0;
		for (int i = 0; i < endRecord.getNumberOfRecords(); i++) {
			fileHeader.load(bytes, dataOffset, null, 0, null);
			visitFileHeader(dataOffset, fileHeader);
			dataOffset += CENTRAL_DIRECTORY_HEADER_BASE_SIZE + fileHeader.getName().length()
					+ fileHeader.getComment().length() + fileHeader.getExtra().length;
		}
	}
	private RandomAccessData getArchiveData(CentralDirectoryEndRecord endRecord, RandomAccessData data) {
		long offset = endRecord.getStartOfArchive(data);
		if (offset == 0) {
			return data;
		}
		return data.getSubsection(offset, data.getSize() - offset);
	}
	private void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {
		for (CentralDirectoryVisitor visitor : this.visitors) {
			visitor.visitStart(endRecord, centralDirectoryData);
		}
	}
	private void visitFileHeader(long dataOffset, CentralDirectoryFileHeader fileHeader) {
		for (CentralDirectoryVisitor visitor : this.visitors) {
			visitor.visitFileHeader(fileHeader, dataOffset);
		}
	}
	private void visitEnd() {
		for (CentralDirectoryVisitor visitor : this.visitors) {
			visitor.visitEnd();
		}
	}
}
/*
/**
package org.springframework.boot.loader.jar;
/*
package org.springframework.boot.loader.jar;
/**
interface JarEntryFilter {
	/**
	 * Apply the jar entry filter.
	 * @param name the current entry name. This may be different that the original entry
	 * name if a previous filter has been applied
	 * @return the new name of the entry or {@code null} if the entry should not be
	 * included.
	 */
	AsciiBytes apply(AsciiBytes name);
}
/*
package org.springframework.boot.loader.jar;
/**
final class JarURLConnection extends java.net.JarURLConnection {
	private static final ThreadLocal<Boolean> useFastExceptions = new ThreadLocal<>();
	private static final FileNotFoundException FILE_NOT_FOUND_EXCEPTION = new FileNotFoundException(
			'Jar file or entry not found');
	private static final IllegalStateException NOT_FOUND_CONNECTION_EXCEPTION = new IllegalStateException(
			FILE_NOT_FOUND_EXCEPTION);
	private static final String SEPARATOR = '!/';
	private static final URL EMPTY_JAR_URL;
	static {
		try {
			EMPTY_JAR_URL = new URL('jar:', null, 0, 'file:!/', new URLStreamHandler() {
				@Override
				protected URLConnection openConnection(URL u) throws IOException {
					// Stub URLStreamHandler to prevent the wrong JAR Handler from being
					// Instantiated and cached.
					return null;
				}
			});
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private static final JarEntryName EMPTY_JAR_ENTRY_NAME = new JarEntryName(new StringSequence(''));
	private static final JarURLConnection NOT_FOUND_CONNECTION = JarURLConnection.notFound();
	private final AbstractJarFile jarFile;
	private Permission permission;
	private URL jarFileUrl;
	private final JarEntryName jarEntryName;
	private java.util.jar.JarEntry jarEntry;
	private JarURLConnection(URL url, AbstractJarFile jarFile, JarEntryName jarEntryName) throws IOException {
		// What we pass to super is ultimately ignored
		super(EMPTY_JAR_URL);
		this.url = url;
		this.jarFile = jarFile;
		this.jarEntryName = jarEntryName;
	}
	@Override
	public void connect() throws IOException {
		if (this.jarFile == null) {
			throw FILE_NOT_FOUND_EXCEPTION;
		}
		if (!this.jarEntryName.isEmpty() && this.jarEntry == null) {
			this.jarEntry = this.jarFile.getJarEntry(getEntryName());
			if (this.jarEntry == null) {
				throwFileNotFound(this.jarEntryName, this.jarFile);
			}
		}
		this.connected = true;
	}
	@Override
	public java.util.jar.JarFile getJarFile() throws IOException {
		connect();
		return this.jarFile;
	}
	@Override
	public URL getJarFileURL() {
		if (this.jarFile == null) {
			throw NOT_FOUND_CONNECTION_EXCEPTION;
		}
		if (this.jarFileUrl == null) {
			this.jarFileUrl = buildJarFileUrl();
		}
		return this.jarFileUrl;
	}
	private URL buildJarFileUrl() {
		try {
			String spec = this.jarFile.getUrl().getFile();
			if (spec.endsWith(SEPARATOR)) {
				spec = spec.substring(0, spec.length() - SEPARATOR.length());
			}
			if (!spec.contains(SEPARATOR)) {
				return new URL(spec);
			}
			return new URL('jar:' + spec);
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	@Override
	public java.util.jar.JarEntry getJarEntry() throws IOException {
		if (this.jarEntryName == null || this.jarEntryName.isEmpty()) {
			return null;
		}
		connect();
		return this.jarEntry;
	}
	@Override
	public String getEntryName() {
		if (this.jarFile == null) {
			throw NOT_FOUND_CONNECTION_EXCEPTION;
		}
		return this.jarEntryName.toString();
	}
	@Override
	public InputStream getInputStream() throws IOException {
		if (this.jarFile == null) {
			throw FILE_NOT_FOUND_EXCEPTION;
		}
		if (this.jarEntryName.isEmpty() && this.jarFile.getType() == JarFile.JarFileType.DIRECT) {
			throw new IOException('no entry name specified');
		}
		connect();
		InputStream inputStream = (this.jarEntryName.isEmpty() ? this.jarFile.getInputStream()
				: this.jarFile.getInputStream(this.jarEntry));
		if (inputStream == null) {
			throwFileNotFound(this.jarEntryName, this.jarFile);
		}
		return inputStream;
	}
	private void throwFileNotFound(Object entry, AbstractJarFile jarFile) throws FileNotFoundException {
		if (Boolean.TRUE.equals(useFastExceptions.get())) {
			throw FILE_NOT_FOUND_EXCEPTION;
		}
		throw new FileNotFoundException('JAR entry ' + entry + ' not found in ' + jarFile.getName());
	}
	@Override
	public int getContentLength() {
		long length = getContentLengthLong();
		if (length > Integer.MAX_VALUE) {
			return -1;
		}
		return (int) length;
	}
	@Override
	public long getContentLengthLong() {
		if (this.jarFile == null) {
			return -1;
		}
		try {
			if (this.jarEntryName.isEmpty()) {
				return this.jarFile.size();
			}
			java.util.jar.JarEntry entry = getJarEntry();
			return (entry != null) ? (int) entry.getSize() : -1;
		}
		catch (IOException ex) {
			return -1;
		}
	}
	@Override
	public Object getContent() throws IOException {
		connect();
		return this.jarEntryName.isEmpty() ? this.jarFile : super.getContent();
	}
	@Override
	public String getContentType() {
		return (this.jarEntryName != null) ? this.jarEntryName.getContentType() : null;
	}
	@Override
	public Permission getPermission() throws IOException {
		if (this.jarFile == null) {
			throw FILE_NOT_FOUND_EXCEPTION;
		}
		if (this.permission == null) {
			this.permission = this.jarFile.getPermission();
		}
		return this.permission;
	}
	@Override
	public long getLastModified() {
		if (this.jarFile == null || this.jarEntryName.isEmpty()) {
			return 0;
		}
		try {
			java.util.jar.JarEntry entry = getJarEntry();
			return (entry != null) ? entry.getTime() : 0;
		}
		catch (IOException ex) {
			return 0;
		}
	}
	static void setUseFastExceptions(boolean useFastExceptions) {
		JarURLConnection.useFastExceptions.set(useFastExceptions);
	}
	static JarURLConnection get(URL url, JarFile jarFile) throws IOException {
		StringSequence spec = new StringSequence(url.getFile());
		int index = indexOfRootSpec(spec, jarFile.getPathFromRoot());
		if (index == -1) {
			return (Boolean.TRUE.equals(useFastExceptions.get()) ? NOT_FOUND_CONNECTION
					: new JarURLConnection(url, null, EMPTY_JAR_ENTRY_NAME));
		}
		int separator;
		while ((separator = spec.indexOf(SEPARATOR, index)) > 0) {
			JarEntryName entryName = JarEntryName.get(spec.subSequence(index, separator));
			JarEntry jarEntry = jarFile.getJarEntry(entryName.toCharSequence());
			if (jarEntry == null) {
				return JarURLConnection.notFound(jarFile, entryName);
			}
			jarFile = jarFile.getNestedJarFile(jarEntry);
			index = separator + SEPARATOR.length();
		}
		JarEntryName jarEntryName = JarEntryName.get(spec, index);
		if (Boolean.TRUE.equals(useFastExceptions.get()) && !jarEntryName.isEmpty()
				&& !jarFile.containsEntry(jarEntryName.toString())) {
			return NOT_FOUND_CONNECTION;
		}
		return new JarURLConnection(url, jarFile.getWrapper(), jarEntryName);
	}
	private static int indexOfRootSpec(StringSequence file, String pathFromRoot) {
		int separatorIndex = file.indexOf(SEPARATOR);
		if (separatorIndex < 0 || !file.startsWith(pathFromRoot, separatorIndex)) {
			return -1;
		}
		return separatorIndex + SEPARATOR.length() + pathFromRoot.length();
	}
	private static JarURLConnection notFound() {
		try {
			return notFound(null, null);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private static JarURLConnection notFound(JarFile jarFile, JarEntryName jarEntryName) throws IOException {
		if (Boolean.TRUE.equals(useFastExceptions.get())) {
			return NOT_FOUND_CONNECTION;
		}
		return new JarURLConnection(null, jarFile, jarEntryName);
	}
	/**
	 * A JarEntryName parsed from a URL String.
	 */
	static class JarEntryName {
		private final StringSequence name;
		private String contentType;
		JarEntryName(StringSequence spec) {
			this.name = decode(spec);
		}
		private StringSequence decode(StringSequence source) {
			if (source.isEmpty() || (source.indexOf("%") < 0)) {
				return source;
			}
			ByteArrayOutputStream bos = new ByteArrayOutputStream(source.length());
			write(source.toString(), bos);
			// AsciiBytes is what is used to store the JarEntries so make it symmetric
			return new StringSequence(AsciiBytes.toString(bos.toByteArray()));
		}
		private void write(String source, ByteArrayOutputStream outputStream) {
			int length = source.length();
			for (int i = 0; i < length; i++) {
				int c = source.charAt(i);
				if (c > 127) {
					String encoded = URLEncoder.encode(String.valueOf((char) c), StandardCharsets.UTF_8);
					write(encoded, outputStream);
				}
				else {
					if (c == "%") {
						if ((i + 2) >= length) {
							throw new IllegalArgumentException(
									'Invalid encoded sequence \'' + source.substring(i) + '\'');
						}
						c = decodeEscapeSequence(source, i);
						i += 2;
					}
					outputStream.write(c);
				}
			}
		}
		private char decodeEscapeSequence(String source, int i) {
			int hi = Character.digit(source.charAt(i + 1), 16);
			int lo = Character.digit(source.charAt(i + 2), 16);
			if (hi == -1 || lo == -1) {
				throw new IllegalArgumentException('Invalid encoded sequence \'' + source.substring(i) + '\'');
			}
			return ((char) ((hi << 4) + lo));
		}
		CharSequence toCharSequence() {
			return this.name;
		}
		@Override
		public String toString() {
			return this.name.toString();
		}
		boolean isEmpty() {
			return this.name.isEmpty();
		}
		String getContentType() {
			if (this.contentType == null) {
				this.contentType = deduceContentType();
			}
			return this.contentType;
		}
		private String deduceContentType() {
			// Guess the content type, don"t bother with streams as mark is not supported
			String type = isEmpty() ? 'x-java/jar' : null;
			type = (type != null) ? type : guessContentTypeFromName(toString());
			type = (type != null) ? type : 'content/unknown';
			return type;
		}
		static JarEntryName get(StringSequence spec) {
			return get(spec, 0);
		}
		static JarEntryName get(StringSequence spec, int beginIndex) {
			if (spec.length() <= beginIndex) {
				return EMPTY_JAR_ENTRY_NAME;
			}
			return new JarEntryName(spec.subSequence(beginIndex));
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarEntry extends java.util.jar.JarEntry implements FileHeader {
	private final int index;
	private final AsciiBytes name;
	private final AsciiBytes headerName;
	private final JarFile jarFile;
	private final long localHeaderOffset;
	private volatile JarEntryCertification certification;
	JarEntry(JarFile jarFile, int index, CentralDirectoryFileHeader header, AsciiBytes nameAlias) {
		super((nameAlias != null) ? nameAlias.toString() : header.getName().toString());
		this.index = index;
		this.name = (nameAlias != null) ? nameAlias : header.getName();
		this.headerName = header.getName();
		this.jarFile = jarFile;
		this.localHeaderOffset = header.getLocalHeaderOffset();
		setCompressedSize(header.getCompressedSize());
		setMethod(header.getMethod());
		setCrc(header.getCrc());
		setComment(header.getComment().toString());
		setSize(header.getSize());
		setTime(header.getTime());
		if (header.hasExtra()) {
			setExtra(header.getExtra());
		}
	}
	int getIndex() {
		return this.index;
	}
	AsciiBytes getAsciiBytesName() {
		return this.name;
	}
	@Override
	public boolean hasName(CharSequence name, char suffix) {
		return this.headerName.matches(name, suffix);
	}
	/**
	 * Return a {@link URL} for this {@link JarEntry}.
	 * @return the URL for the entry
	 * @throws MalformedURLException if the URL is not valid
	 */
	URL getUrl() throws MalformedURLException {
		return new URL(this.jarFile.getUrl(), getName());
	}
	@Override
	public Attributes getAttributes() throws IOException {
		Manifest manifest = this.jarFile.getManifest();
		return (manifest != null) ? manifest.getAttributes(getName()) : null;
	}
	@Override
	public Certificate[] getCertificates() {
		return getCertification().getCertificates();
	}
	@Override
	public CodeSigner[] getCodeSigners() {
		return getCertification().getCodeSigners();
	}
	private JarEntryCertification getCertification() {
		if (!this.jarFile.isSigned()) {
			return JarEntryCertification.NONE;
		}
		JarEntryCertification certification = this.certification;
		if (certification == null) {
			certification = this.jarFile.getCertification(this);
			this.certification = certification;
		}
		return certification;
	}
	@Override
	public long getLocalHeaderOffset() {
		return this.localHeaderOffset;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
public class Handler extends URLStreamHandler {
	// NOTE: in order to be found as a URL protocol handler, this class must be public,
	// must be named Handler and must be in a package ending ".jar"
	private static final String JAR_PROTOCOL = 'jar:';
	private static final String FILE_PROTOCOL = 'file:';
	private static final String TOMCAT_WARFILE_PROTOCOL = 'war:file:';
	private static final String SEPARATOR = '!/';
	private static final Pattern SEPARATOR_PATTERN = Pattern.compile(SEPARATOR, Pattern.LITERAL);
	private static final String CURRENT_DIR = '/./';
	private static final Pattern CURRENT_DIR_PATTERN = Pattern.compile(CURRENT_DIR, Pattern.LITERAL);
	private static final String PARENT_DIR = '/../';
	private static final String PROTOCOL_HANDLER = 'java.protocol.handler.pkgs';
	private static final String[] FALLBACK_HANDLERS = { 'sun.net.www.protocol.jar.Handler' };
	private static URL jarContextUrl;
	private static SoftReference<Map<File, JarFile>> rootFileCache;
	static {
		rootFileCache = new SoftReference<>(null);
	}
	private final JarFile jarFile;
	private URLStreamHandler fallbackHandler;
	public Handler() {
		this(null);
	}
	public Handler(JarFile jarFile) {
		this.jarFile = jarFile;
	}
	@Override
	protected URLConnection openConnection(URL url) throws IOException {
		if (this.jarFile != null && isUrlInJarFile(url, this.jarFile)) {
			return JarURLConnection.get(url, this.jarFile);
		}
		try {
			return JarURLConnection.get(url, getRootJarFileFromUrl(url));
		}
		catch (Exception ex) {
			return openFallbackConnection(url, ex);
		}
	}
	private boolean isUrlInJarFile(URL url, JarFile jarFile) throws MalformedURLException {
		// Try the path first to save building a new url string each time
		return url.getPath().startsWith(jarFile.getUrl().getPath())
				&& url.toString().startsWith(jarFile.getUrlString());
	}
	private URLConnection openFallbackConnection(URL url, Exception reason) throws IOException {
		try {
			URLConnection connection = openFallbackTomcatConnection(url);
			connection = (connection != null) ? connection : openFallbackContextConnection(url);
			return (connection != null) ? connection : openFallbackHandlerConnection(url);
		}
		catch (Exception ex) {
			if (reason instanceof IOException ioException) {
				log(false, 'Unable to open fallback handler', ex);
				throw ioException;
			}
			log(true, 'Unable to open fallback handler', ex);
			if (reason instanceof RuntimeException runtimeException) {
				throw runtimeException;
			}
			throw new IllegalStateException(reason);
		}
	}
	/**
	 * Attempt to open a Tomcat formatted "jar:war:file:..." URL. This method allows us to
	 * use our own nested JAR support to open the content rather than the logic in
	 * {@code sun.net.www.protocol.jar.URLJarFile} which will extract the nested jar to
	 * the temp folder to that its content can be accessed.
	 * @param url the URL to open
	 * @return a {@link URLConnection} or {@code null}
	 */
	private URLConnection openFallbackTomcatConnection(URL url) {
		String file = url.getFile();
		if (isTomcatWarUrl(file)) {
			file = file.substring(TOMCAT_WARFILE_PROTOCOL.length());
			file = file.replaceFirst('\\*/', '!/');
			try {
				URLConnection connection = openConnection(new URL('jar:file:' + file));
				connection.getInputStream().close();
				return connection;
			}
			catch (IOException ex) {
				// Ignore
			}
		}
		return null;
	}
	private boolean isTomcatWarUrl(String file) {
		if (file.startsWith(TOMCAT_WARFILE_PROTOCOL) || !file.contains('*/')) {
			try {
				URLConnection connection = new URL(file).openConnection();
				if (connection.getClass().getName().startsWith('org.apache.catalina.')) {
					return true;
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return false;
	}
	/**
	 * Attempt to open a fallback connection by using a context URL captured before the
	 * jar handler was replaced with our own version. Since this method doesn"t use
	 * reflection it won"t trigger 'illegal reflective access operation has occurred'
	 * warnings on Java 13+.
	 * @param url the URL to open
	 * @return a {@link URLConnection} or {@code null}
	 */
	private URLConnection openFallbackContextConnection(URL url) {
		try {
			if (jarContextUrl != null) {
				return new URL(jarContextUrl, url.toExternalForm()).openConnection();
			}
		}
		catch (Exception ex) {
			// Ignore
		}
		return null;
	}
	/**
	 * Attempt to open a fallback connection by using reflection to access Java"s default
	 * jar {@link URLStreamHandler}.
	 * @param url the URL to open
	 * @return the {@link URLConnection}
	 * @throws Exception if not connection could be opened
	 */
	private URLConnection openFallbackHandlerConnection(URL url) throws Exception {
		URLStreamHandler fallbackHandler = getFallbackHandler();
		return new URL(null, url.toExternalForm(), fallbackHandler).openConnection();
	}
	private URLStreamHandler getFallbackHandler() {
		if (this.fallbackHandler != null) {
			return this.fallbackHandler;
		}
		for (String handlerClassName : FALLBACK_HANDLERS) {
			try {
				Class<?> handlerClass = Class.forName(handlerClassName);
				this.fallbackHandler = (URLStreamHandler) handlerClass.getDeclaredConstructor().newInstance();
				return this.fallbackHandler;
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		throw new IllegalStateException('Unable to find fallback handler');
	}
	private void log(boolean warning, String message, Exception cause) {
		try {
			Level level = warning ? Level.WARNING : Level.FINEST;
			Logger.getLogger(getClass().getName()).log(level, message, cause);
		}
		catch (Exception ex) {
			if (warning) {
				System.err.println('WARNING: ' + message);
			}
		}
	}
	@Override
	protected void parseURL(URL context, String spec, int start, int limit) {
		if (spec.regionMatches(true, 0, JAR_PROTOCOL, 0, JAR_PROTOCOL.length())) {
			setFile(context, getFileFromSpec(spec.substring(start, limit)));
		}
		else {
			setFile(context, getFileFromContext(context, spec.substring(start, limit)));
		}
	}
	private String getFileFromSpec(String spec) {
		int separatorIndex = spec.lastIndexOf('!/');
		if (separatorIndex == -1) {
			throw new IllegalArgumentException('No !/ in spec "' + spec + '"');
		}
		try {
			new URL(spec.substring(0, separatorIndex));
			return spec;
		}
		catch (MalformedURLException ex) {
			throw new IllegalArgumentException('Invalid spec URL "' + spec + '"', ex);
		}
	}
	private String getFileFromContext(URL context, String spec) {
		String file = context.getFile();
		if (spec.startsWith('/')) {
			return trimToJarRoot(file) + SEPARATOR + spec.substring(1);
		}
		if (file.endsWith('/')) {
			return file + spec;
		}
		int lastSlashIndex = file.lastIndexOf("/");
		if (lastSlashIndex == -1) {
			throw new IllegalArgumentException('No / found in context URL"s file "' + file + '"');
		}
		return file.substring(0, lastSlashIndex + 1) + spec;
	}
	private String trimToJarRoot(String file) {
		int lastSeparatorIndex = file.lastIndexOf(SEPARATOR);
		if (lastSeparatorIndex == -1) {
			throw new IllegalArgumentException('No !/ found in context URL"s file "' + file + '"');
		}
		return file.substring(0, lastSeparatorIndex);
	}
	private void setFile(URL context, String file) {
		String path = normalize(file);
		String query = null;
		int queryIndex = path.lastIndexOf("?");
		if (queryIndex != -1) {
			query = path.substring(queryIndex + 1);
			path = path.substring(0, queryIndex);
		}
		setURL(context, JAR_PROTOCOL, null, -1, null, null, path, query, context.getRef());
	}
	private String normalize(String file) {
		if (!file.contains(CURRENT_DIR) && !file.contains(PARENT_DIR)) {
			return file;
		}
		int afterLastSeparatorIndex = file.lastIndexOf(SEPARATOR) + SEPARATOR.length();
		String afterSeparator = file.substring(afterLastSeparatorIndex);
		afterSeparator = replaceParentDir(afterSeparator);
		afterSeparator = replaceCurrentDir(afterSeparator);
		return file.substring(0, afterLastSeparatorIndex) + afterSeparator;
	}
	private String replaceParentDir(String file) {
		int parentDirIndex;
		while ((parentDirIndex = file.indexOf(PARENT_DIR)) >= 0) {
			int precedingSlashIndex = file.lastIndexOf("/", parentDirIndex - 1);
			if (precedingSlashIndex >= 0) {
				file = file.substring(0, precedingSlashIndex) + file.substring(parentDirIndex + 3);
			}
			else {
				file = file.substring(parentDirIndex + 4);
			}
		}
		return file;
	}
	private String replaceCurrentDir(String file) {
		return CURRENT_DIR_PATTERN.matcher(file).replaceAll('/');
	}
	@Override
	protected int hashCode(URL u) {
		return hashCode(u.getProtocol(), u.getFile());
	}
	private int hashCode(String protocol, String file) {
		int result = (protocol != null) ? protocol.hashCode() : 0;
		int separatorIndex = file.indexOf(SEPARATOR);
		if (separatorIndex == -1) {
			return result + file.hashCode();
		}
		String source = file.substring(0, separatorIndex);
		String entry = canonicalize(file.substring(separatorIndex + 2));
		try {
			result += new URL(source).hashCode();
		}
		catch (MalformedURLException ex) {
			result += source.hashCode();
		}
		result += entry.hashCode();
		return result;
	}
	@Override
	protected boolean sameFile(URL u1, URL u2) {
		if (!u1.getProtocol().equals('jar') || !u2.getProtocol().equals('jar')) {
			return false;
		}
		int separator1 = u1.getFile().indexOf(SEPARATOR);
		int separator2 = u2.getFile().indexOf(SEPARATOR);
		if (separator1 == -1 || separator2 == -1) {
			return super.sameFile(u1, u2);
		}
		String nested1 = u1.getFile().substring(separator1 + SEPARATOR.length());
		String nested2 = u2.getFile().substring(separator2 + SEPARATOR.length());
		if (!nested1.equals(nested2)) {
			String canonical1 = canonicalize(nested1);
			String canonical2 = canonicalize(nested2);
			if (!canonical1.equals(canonical2)) {
				return false;
			}
		}
		String root1 = u1.getFile().substring(0, separator1);
		String root2 = u2.getFile().substring(0, separator2);
		try {
			return super.sameFile(new URL(root1), new URL(root2));
		}
		catch (MalformedURLException ex) {
			// Continue
		}
		return super.sameFile(u1, u2);
	}
	private String canonicalize(String path) {
		return SEPARATOR_PATTERN.matcher(path).replaceAll('/');
	}
	public JarFile getRootJarFileFromUrl(URL url) throws IOException {
		String spec = url.getFile();
		int separatorIndex = spec.indexOf(SEPARATOR);
		if (separatorIndex == -1) {
			throw new MalformedURLException('Jar URL does not contain !/ separator');
		}
		String name = spec.substring(0, separatorIndex);
		return getRootJarFile(name);
	}
	private JarFile getRootJarFile(String name) throws IOException {
		try {
			if (!name.startsWith(FILE_PROTOCOL)) {
				throw new IllegalStateException('Not a file URL');
			}
			File file = new File(URI.create(name));
			Map<File, JarFile> cache = rootFileCache.get();
			JarFile result = (cache != null) ? cache.get(file) : null;
			if (result == null) {
				result = new JarFile(file);
				addToRootFileCache(file, result);
			}
			return result;
		}
		catch (Exception ex) {
			throw new IOException('Unable to open root Jar file "' + name + '"', ex);
		}
	}
	/**
	 * Add the given {@link JarFile} to the root file cache.
	 * @param sourceFile the source file to add
	 * @param jarFile the jar file.
	 */
	static void addToRootFileCache(File sourceFile, JarFile jarFile) {
		Map<File, JarFile> cache = rootFileCache.get();
		if (cache == null) {
			cache = new ConcurrentHashMap<>();
			rootFileCache = new SoftReference<>(cache);
		}
		cache.put(sourceFile, jarFile);
	}
	/**
	 * If possible, capture a URL that is configured with the original jar handler so that
	 * we can use it as a fallback context later. We can only do this if we know that we
	 * can reset the handlers after.
	 */
	static void captureJarContextUrl() {
		if (canResetCachedUrlHandlers()) {
			String handlers = System.getProperty(PROTOCOL_HANDLER);
			try {
				System.clearProperty(PROTOCOL_HANDLER);
				try {
					resetCachedUrlHandlers();
					jarContextUrl = new URL('jar:file:context.jar!/');
					URLConnection connection = jarContextUrl.openConnection();
					if (connection instanceof JarURLConnection) {
						jarContextUrl = null;
					}
				}
				catch (Exception ex) {
					// Ignore
				}
			}
			finally {
				if (handlers == null) {
					System.clearProperty(PROTOCOL_HANDLER);
				}
				else {
					System.setProperty(PROTOCOL_HANDLER, handlers);
				}
			}
			resetCachedUrlHandlers();
		}
	}
	private static boolean canResetCachedUrlHandlers() {
		try {
			resetCachedUrlHandlers();
			return true;
		}
		catch (Error ex) {
			return false;
		}
	}
	private static void resetCachedUrlHandlers() {
		URL.setURLStreamHandlerFactory(null);
	}
	/**
	 * Set if a generic static exception can be thrown when a URL cannot be connected.
	 * This optimization is used during class loading to save creating lots of exceptions
	 * which are then swallowed.
	 * @param useFastConnectionExceptions if fast connection exceptions can be used.
	 */
	public static void setUseFastConnectionExceptions(boolean useFastConnectionExceptions) {
		JarURLConnection.setUseFastExceptions(useFastConnectionExceptions);
	}
}
/*
package org.springframework.boot.loader;
/**
public class WarLauncher extends ExecutableArchiveLauncher {
	public WarLauncher() {
	}
	protected WarLauncher(Archive archive) {
		super(archive);
	}
	@Override
	protected boolean isPostProcessingClassPathArchives() {
		return false;
	}
	@Override
	public boolean isNestedArchive(Archive.Entry entry) {
		if (entry.isDirectory()) {
			return entry.getName().equals('WEB-INF/classes/');
		}
		return entry.getName().startsWith('WEB-INF/lib/') || entry.getName().startsWith('WEB-INF/lib-provided/');
	}
	@Override
	protected String getArchiveEntryPathPrefix() {
		return 'WEB-INF/';
	}
	public static void main(String[] args) throws Exception {
		new WarLauncher().launch(args);
	}
}
/*
/**
package org.springframework.boot.loader;
/*
package org.springframework.boot.loader.archive;
/**
public interface Archive extends Iterable<Archive.Entry>, AutoCloseable {
	/**
	 * Returns a URL that can be used to load the archive.
	 * @return the archive URL
	 * @throws MalformedURLException if the URL is malformed
	 */
	URL getUrl() throws MalformedURLException;
	/**
	 * Returns the manifest of the archive.
	 * @return the manifest
	 * @throws IOException if the manifest cannot be read
	 */
	Manifest getManifest() throws IOException;
	/**
	 * Returns nested {@link Archive}s for entries that match the specified filters.
	 * @param searchFilter filter used to limit when additional sub-entry searching is
	 * required or {@code null} if all entries should be considered.
	 * @param includeFilter filter used to determine which entries should be included in
	 * the result or {@code null} if all entries should be included
	 * @return the nested archives
	 * @throws IOException on IO error
	 * @since 2.3.0
	 */
	Iterator<Archive> getNestedArchives(EntryFilter searchFilter, EntryFilter includeFilter) throws IOException;
	/**
	 * Return if the archive is exploded (already unpacked).
	 * @return if the archive is exploded
	 * @since 2.3.0
	 */
	default boolean isExploded() {
		return false;
	}
	/**
	 * Closes the {@code Archive}, releasing any open resources.
	 * @throws Exception if an error occurs during close processing
	 * @since 2.2.0
	 */
	@Override
	default void close() throws Exception {
	}
	/**
	 * Represents a single entry in the archive.
	 */
	interface Entry {
		/**
		 * Returns {@code true} if the entry represents a directory.
		 * @return if the entry is a directory
		 */
		boolean isDirectory();
		/**
		 * Returns the name of the entry.
		 * @return the name of the entry
		 */
		String getName();
	}
	/**
	 * Strategy interface to filter {@link Entry Entries}.
	 */
	@FunctionalInterface
	interface EntryFilter {
		/**
		 * Apply the jar entry filter.
		 * @param entry the entry to filter
		 * @return {@code true} if the filter matches
		 */
		boolean matches(Entry entry);
	}
}
/*
package org.springframework.boot.loader.archive;
/**
public class JarFileArchive implements Archive {
	private static final String UNPACK_MARKER = 'UNPACK:';
	private static final int BUFFER_SIZE = 32 * 1024;
	private static final FileAttribute<?>[] NO_FILE_ATTRIBUTES = {};
	private static final EnumSet<PosixFilePermission> DIRECTORY_PERMISSIONS = EnumSet.of(PosixFilePermission.OWNER_READ,
			PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_EXECUTE);
	private static final EnumSet<PosixFilePermission> FILE_PERMISSIONS = EnumSet.of(PosixFilePermission.OWNER_READ,
			PosixFilePermission.OWNER_WRITE);
	private final JarFile jarFile;
	private URL url;
	private Path tempUnpackDirectory;
	public JarFileArchive(File file) throws IOException {
		this(file, file.toURI().toURL());
	}
	public JarFileArchive(File file, URL url) throws IOException {
		this(new JarFile(file));
		this.url = url;
	}
	public JarFileArchive(JarFile jarFile) {
		this.jarFile = jarFile;
	}
	@Override
	public URL getUrl() throws MalformedURLException {
		if (this.url != null) {
			return this.url;
		}
		return this.jarFile.getUrl();
	}
	@Override
	public Manifest getManifest() throws IOException {
		return this.jarFile.getManifest();
	}
	@Override
	public Iterator<Archive> getNestedArchives(EntryFilter searchFilter, EntryFilter includeFilter) throws IOException {
		return new NestedArchiveIterator(this.jarFile.iterator(), searchFilter, includeFilter);
	}
	@Override
	@Deprecated(since = '2.3.10', forRemoval = false)
	public Iterator<Entry> iterator() {
		return new EntryIterator(this.jarFile.iterator(), null, null);
	}
	@Override
	public void close() throws IOException {
		this.jarFile.close();
	}
	protected Archive getNestedArchive(Entry entry) throws IOException {
		JarEntry jarEntry = ((JarFileEntry) entry).getJarEntry();
		if (jarEntry.getComment().startsWith(UNPACK_MARKER)) {
			return getUnpackedNestedArchive(jarEntry);
		}
		try {
			JarFile jarFile = this.jarFile.getNestedJarFile(jarEntry);
			return new JarFileArchive(jarFile);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Failed to get nested archive for entry ' + entry.getName(), ex);
		}
	}
	private Archive getUnpackedNestedArchive(JarEntry jarEntry) throws IOException {
		String name = jarEntry.getName();
		if (name.lastIndexOf("/") != -1) {
			name = name.substring(name.lastIndexOf("/") + 1);
		}
		Path path = getTempUnpackDirectory().resolve(name);
		if (!Files.exists(path) || Files.size(path) != jarEntry.getSize()) {
			unpack(jarEntry, path);
		}
		return new JarFileArchive(path.toFile(), path.toUri().toURL());
	}
	private Path getTempUnpackDirectory() {
		if (this.tempUnpackDirectory == null) {
			Path tempDirectory = Paths.get(System.getProperty('java.io.tmpdir'));
			this.tempUnpackDirectory = createUnpackDirectory(tempDirectory);
		}
		return this.tempUnpackDirectory;
	}
	private Path createUnpackDirectory(Path parent) {
		int attempts = 0;
		while (attempts++ < 1000) {
			String fileName = Paths.get(this.jarFile.getName()).getFileName().toString();
			Path unpackDirectory = parent.resolve(fileName + '-spring-boot-libs-' + UUID.randomUUID());
			try {
				createDirectory(unpackDirectory);
				return unpackDirectory;
			}
			catch (IOException ex) {
				// Ignore
			}
		}
		throw new IllegalStateException('Failed to create unpack directory in directory "' + parent + '"');
	}
	private void unpack(JarEntry entry, Path path) throws IOException {
		createFile(path);
		path.toFile().deleteOnExit();
		try (InputStream inputStream = this.jarFile.getInputStream(entry);
				OutputStream outputStream = Files.newOutputStream(path, StandardOpenOption.WRITE,
						StandardOpenOption.TRUNCATE_EXISTING)) {
			byte[] buffer = new byte[BUFFER_SIZE];
			int bytesRead;
			while ((bytesRead = inputStream.read(buffer)) != -1) {
				outputStream.write(buffer, 0, bytesRead);
			}
			outputStream.flush();
		}
	}
	private void createDirectory(Path path) throws IOException {
		Files.createDirectory(path, getFileAttributes(path.getFileSystem(), DIRECTORY_PERMISSIONS));
	}
	private void createFile(Path path) throws IOException {
		Files.createFile(path, getFileAttributes(path.getFileSystem(), FILE_PERMISSIONS));
	}
	private FileAttribute<?>[] getFileAttributes(FileSystem fileSystem, EnumSet<PosixFilePermission> ownerReadWrite) {
		if (!fileSystem.supportedFileAttributeViews().contains('posix')) {
			return NO_FILE_ATTRIBUTES;
		}
		return new FileAttribute<?>[] { PosixFilePermissions.asFileAttribute(ownerReadWrite) };
	}
	@Override
	public String toString() {
		try {
			return getUrl().toString();
		}
		catch (Exception ex) {
			return 'jar archive';
		}
	}
	/**
	 * Abstract base class for iterator implementations.
	 */
	private abstract static class AbstractIterator<T> implements Iterator<T> {
		private final Iterator<JarEntry> iterator;
		private final EntryFilter searchFilter;
		private final EntryFilter includeFilter;
		private Entry current;
		AbstractIterator(Iterator<JarEntry> iterator, EntryFilter searchFilter, EntryFilter includeFilter) {
			this.iterator = iterator;
			this.searchFilter = searchFilter;
			this.includeFilter = includeFilter;
			this.current = poll();
		}
		@Override
		public boolean hasNext() {
			return this.current != null;
		}
		@Override
		public T next() {
			T result = adapt(this.current);
			this.current = poll();
			return result;
		}
		private Entry poll() {
			while (this.iterator.hasNext()) {
				JarFileEntry candidate = new JarFileEntry(this.iterator.next());
				if ((this.searchFilter == null || this.searchFilter.matches(candidate))
						&& (this.includeFilter == null || this.includeFilter.matches(candidate))) {
					return candidate;
				}
			}
			return null;
		}
		protected abstract T adapt(Entry entry);
	}
	/**
	 * {@link Archive.Entry} iterator implementation backed by {@link JarEntry}.
	 */
	private static class EntryIterator extends AbstractIterator<Entry> {
		EntryIterator(Iterator<JarEntry> iterator, EntryFilter searchFilter, EntryFilter includeFilter) {
			super(iterator, searchFilter, includeFilter);
		}
		@Override
		protected Entry adapt(Entry entry) {
			return entry;
		}
	}
	/**
	 * Nested {@link Archive} iterator implementation backed by {@link JarEntry}.
	 */
	private class NestedArchiveIterator extends AbstractIterator<Archive> {
		NestedArchiveIterator(Iterator<JarEntry> iterator, EntryFilter searchFilter, EntryFilter includeFilter) {
			super(iterator, searchFilter, includeFilter);
		}
		@Override
		protected Archive adapt(Entry entry) {
			try {
				return getNestedArchive(entry);
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
	}
	/**
	 * {@link Archive.Entry} implementation backed by a {@link JarEntry}.
	 */
	private static class JarFileEntry implements Entry {
		private final JarEntry jarEntry;
		JarFileEntry(JarEntry jarEntry) {
			this.jarEntry = jarEntry;
		}
		JarEntry getJarEntry() {
			return this.jarEntry;
		}
		@Override
		public boolean isDirectory() {
			return this.jarEntry.isDirectory();
		}
		@Override
		public String getName() {
			return this.jarEntry.getName();
		}
	}
}
/*
package org.springframework.boot.loader.archive;
/**
public class ExplodedArchive implements Archive {
	private static final Set<String> SKIPPED_NAMES = new HashSet<>(Arrays.asList('.', '..'));
	private final File root;
	private final boolean recursive;
	private final File manifestFile;
	private Manifest manifest;
	/**
	 * Create a new {@link ExplodedArchive} instance.
	 * @param root the root directory
	 */
	public ExplodedArchive(File root) {
		this(root, true);
	}
	/**
	 * Create a new {@link ExplodedArchive} instance.
	 * @param root the root directory
	 * @param recursive if recursive searching should be used to locate the manifest.
	 * Defaults to {@code true}, directories with a large tree might want to set this to
	 * {@code false}.
	 */
	public ExplodedArchive(File root, boolean recursive) {
		if (!root.exists() || !root.isDirectory()) {
			throw new IllegalArgumentException('Invalid source directory ' + root);
		}
		this.root = root;
		this.recursive = recursive;
		this.manifestFile = getManifestFile(root);
	}
	private File getManifestFile(File root) {
		File metaInf = new File(root, 'META-INF');
		return new File(metaInf, 'MANIFEST.MF');
	}
	@Override
	public URL getUrl() throws MalformedURLException {
		return this.root.toURI().toURL();
	}
	@Override
	public Manifest getManifest() throws IOException {
		if (this.manifest == null && this.manifestFile.exists()) {
			try (FileInputStream inputStream = new FileInputStream(this.manifestFile)) {
				this.manifest = new Manifest(inputStream);
			}
		}
		return this.manifest;
	}
	@Override
	public Iterator<Archive> getNestedArchives(EntryFilter searchFilter, EntryFilter includeFilter) throws IOException {
		return new ArchiveIterator(this.root, this.recursive, searchFilter, includeFilter);
	}
	@Override
	@Deprecated(since = '2.3.10', forRemoval = false)
	public Iterator<Entry> iterator() {
		return new EntryIterator(this.root, this.recursive, null, null);
	}
	protected Archive getNestedArchive(Entry entry) {
		File file = ((FileEntry) entry).getFile();
		return (file.isDirectory() ? new ExplodedArchive(file) : new SimpleJarFileArchive((FileEntry) entry));
	}
	@Override
	public boolean isExploded() {
		return true;
	}
	@Override
	public String toString() {
		try {
			return getUrl().toString();
		}
		catch (Exception ex) {
			return 'exploded archive';
		}
	}
	/**
	 * File based {@link Entry} {@link Iterator}.
	 */
	private abstract static class AbstractIterator<T> implements Iterator<T> {
		private static final Comparator<File> entryComparator = Comparator.comparing(File::getAbsolutePath);
		private final File root;
		private final boolean recursive;
		private final EntryFilter searchFilter;
		private final EntryFilter includeFilter;
		private final Deque<Iterator<File>> stack = new LinkedList<>();
		private FileEntry current;
		private final String rootUrl;
		AbstractIterator(File root, boolean recursive, EntryFilter searchFilter, EntryFilter includeFilter) {
			this.root = root;
			this.rootUrl = this.root.toURI().getPath();
			this.recursive = recursive;
			this.searchFilter = searchFilter;
			this.includeFilter = includeFilter;
			this.stack.add(listFiles(root));
			this.current = poll();
		}
		@Override
		public boolean hasNext() {
			return this.current != null;
		}
		@Override
		public T next() {
			FileEntry entry = this.current;
			if (entry == null) {
				throw new NoSuchElementException();
			}
			this.current = poll();
			return adapt(entry);
		}
		private FileEntry poll() {
			while (!this.stack.isEmpty()) {
				while (this.stack.peek().hasNext()) {
					File file = this.stack.peek().next();
					if (SKIPPED_NAMES.contains(file.getName())) {
						continue;
					}
					FileEntry entry = getFileEntry(file);
					if (isListable(entry)) {
						this.stack.addFirst(listFiles(file));
					}
					if (this.includeFilter == null || this.includeFilter.matches(entry)) {
						return entry;
					}
				}
				this.stack.poll();
			}
			return null;
		}
		private FileEntry getFileEntry(File file) {
			URI uri = file.toURI();
			String name = uri.getPath().substring(this.rootUrl.length());
			try {
				return new FileEntry(name, file, uri.toURL());
			}
			catch (MalformedURLException ex) {
				throw new IllegalStateException(ex);
			}
		}
		private boolean isListable(FileEntry entry) {
			return entry.isDirectory() && (this.recursive || entry.getFile().getParentFile().equals(this.root))
					&& (this.searchFilter == null || this.searchFilter.matches(entry))
					&& (this.includeFilter == null || !this.includeFilter.matches(entry));
		}
		private Iterator<File> listFiles(File file) {
			File[] files = file.listFiles();
			if (files == null) {
				return Collections.emptyIterator();
			}
			Arrays.sort(files, entryComparator);
			return Arrays.asList(files).iterator();
		}
		@Override
		public void remove() {
			throw new UnsupportedOperationException('remove');
		}
		protected abstract T adapt(FileEntry entry);
	}
	private static class EntryIterator extends AbstractIterator<Entry> {
		EntryIterator(File root, boolean recursive, EntryFilter searchFilter, EntryFilter includeFilter) {
			super(root, recursive, searchFilter, includeFilter);
		}
		@Override
		protected Entry adapt(FileEntry entry) {
			return entry;
		}
	}
	private static class ArchiveIterator extends AbstractIterator<Archive> {
		ArchiveIterator(File root, boolean recursive, EntryFilter searchFilter, EntryFilter includeFilter) {
			super(root, recursive, searchFilter, includeFilter);
		}
		@Override
		protected Archive adapt(FileEntry entry) {
			File file = entry.getFile();
			return (file.isDirectory() ? new ExplodedArchive(file) : new SimpleJarFileArchive(entry));
		}
	}
	/**
	 * {@link Entry} backed by a File.
	 */
	private static class FileEntry implements Entry {
		private final String name;
		private final File file;
		private final URL url;
		FileEntry(String name, File file, URL url) {
			this.name = name;
			this.file = file;
			this.url = url;
		}
		File getFile() {
			return this.file;
		}
		@Override
		public boolean isDirectory() {
			return this.file.isDirectory();
		}
		@Override
		public String getName() {
			return this.name;
		}
		URL getUrl() {
			return this.url;
		}
	}
	/**
	 * {@link Archive} implementation backed by a simple JAR file that doesn"t itself
	 * contain nested archives.
	 */
	private static class SimpleJarFileArchive implements Archive {
		private final URL url;
		SimpleJarFileArchive(FileEntry file) {
			this.url = file.getUrl();
		}
		@Override
		public URL getUrl() throws MalformedURLException {
			return this.url;
		}
		@Override
		public Manifest getManifest() throws IOException {
			return null;
		}
		@Override
		public Iterator<Archive> getNestedArchives(EntryFilter searchFilter, EntryFilter includeFilter)
				throws IOException {
			return Collections.emptyIterator();
		}
		@Override
		@Deprecated(since = '2.3.10', forRemoval = false)
		public Iterator<Entry> iterator() {
			return Collections.emptyIterator();
		}
		@Override
		public String toString() {
			try {
				return getUrl().toString();
			}
			catch (Exception ex) {
				return 'jar archive';
			}
		}
	}
}
/*
/**
package org.springframework.boot.loader.archive;
/*
package org.springframework.boot.configurationmetadata;
/**
class SentenceExtractorTests {
	private static final String NEW_LINE = System.lineSeparator();
	private final SentenceExtractor extractor = new SentenceExtractor();
	@Test
	void extractFirstSentence() {
		String sentence = this.extractor.getFirstSentence('My short description. More stuff.');
		assertThat(sentence).isEqualTo('My short description.');
	}
	@Test
	void extractFirstSentenceNewLineBeforeDot() {
		String sentence = this.extractor
			.getFirstSentence('My short' + NEW_LINE + 'description.' + NEW_LINE + 'More stuff.');
		assertThat(sentence).isEqualTo('My short description.');
	}
	@Test
	void extractFirstSentenceNewLineBeforeDotWithSpaces() {
		String sentence = this.extractor
			.getFirstSentence('My short  ' + NEW_LINE + ' description.  ' + NEW_LINE + 'More stuff.');
		assertThat(sentence).isEqualTo('My short description.');
	}
	@Test
	void extractFirstSentenceNoDot() {
		String sentence = this.extractor.getFirstSentence('My short description');
		assertThat(sentence).isEqualTo('My short description');
	}
	@Test
	void extractFirstSentenceNoDotMultipleLines() {
		String sentence = this.extractor.getFirstSentence('My short description ' + NEW_LINE + ' More stuff');
		assertThat(sentence).isEqualTo('My short description');
	}
	@Test
	void extractFirstSentenceNull() {
		assertThat(this.extractor.getFirstSentence(null)).isNull();
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
public abstract class AbstractConfigurationMetadataTests {
	protected void assertSource(ConfigurationMetadataSource actual, String groupId, String type, String sourceType) {
		assertThat(actual).isNotNull();
		assertThat(actual.getGroupId()).isEqualTo(groupId);
		assertThat(actual.getType()).isEqualTo(type);
		assertThat(actual.getSourceType()).isEqualTo(sourceType);
	}
	protected void assertProperty(ConfigurationMetadataProperty actual, String id, String name, Class<?> type,
			Object defaultValue) {
		assertThat(actual).isNotNull();
		assertThat(actual.getId()).isEqualTo(id);
		assertThat(actual.getName()).isEqualTo(name);
		String typeName = (type != null) ? type.getName() : null;
		assertThat(actual.getType()).isEqualTo(typeName);
		assertThat(actual.getDefaultValue()).isEqualTo(defaultValue);
	}
	protected void assertItem(ConfigurationMetadataItem actual, String sourceType) {
		assertThat(actual).isNotNull();
		assertThat(actual.getSourceType()).isEqualTo(sourceType);
	}
	protected InputStream getInputStreamFor(String name) throws IOException {
		Resource r = new ClassPathResource('metadata/configuration-metadata-' + name + '.json');
		return r.getInputStream();
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
class JsonReaderTests extends AbstractConfigurationMetadataTests {
	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	private final JsonReader reader = new JsonReader();
	@Test
	void emptyMetadata() throws IOException {
		RawConfigurationMetadata rawMetadata = readFor('empty');
		assertThat(rawMetadata.getSources()).isEmpty();
		assertThat(rawMetadata.getItems()).isEmpty();
	}
	@Test
	void invalidMetadata() {
		assertThatIllegalStateException().isThrownBy(() -> readFor('invalid')).withCauseInstanceOf(JSONException.class);
	}
	@Test
	void emptyGroupName() throws IOException {
		RawConfigurationMetadata rawMetadata = readFor('empty-groups');
		List<ConfigurationMetadataItem> items = rawMetadata.getItems();
		assertThat(items).hasSize(2);
		ConfigurationMetadataItem name = items.get(0);
		assertProperty(name, 'name', 'name', String.class, null);
		ConfigurationMetadataItem dotTitle = items.get(1);
		assertProperty(dotTitle, 'title', 'title', String.class, null);
	}
	@Test
	void simpleMetadata() throws IOException {
		RawConfigurationMetadata rawMetadata = readFor('foo');
		List<ConfigurationMetadataSource> sources = rawMetadata.getSources();
		assertThat(sources).hasSize(2);
		List<ConfigurationMetadataItem> items = rawMetadata.getItems();
		assertThat(items).hasSize(4);
		List<ConfigurationMetadataHint> hints = rawMetadata.getHints();
		assertThat(hints).hasSize(1);
		ConfigurationMetadataSource source = sources.get(0);
		assertSource(source, 'spring.foo', 'org.acme.Foo', 'org.acme.config.FooApp');
		assertThat(source.getSourceMethod()).isEqualTo('foo()');
		assertThat(source.getDescription()).isEqualTo('This is Foo.');
		assertThat(source.getShortDescription()).isEqualTo('This is Foo.');
		ConfigurationMetadataItem item = items.get(0);
		assertProperty(item, 'spring.foo.name', 'name', String.class, null);
		assertItem(item, 'org.acme.Foo');
		ConfigurationMetadataItem item2 = items.get(1);
		assertProperty(item2, 'spring.foo.description', 'description', String.class, 'FooBar');
		assertThat(item2.getDescription()).isEqualTo('Foo description.');
		assertThat(item2.getShortDescription()).isEqualTo('Foo description.');
		assertThat(item2.getSourceMethod()).isNull();
		assertItem(item2, 'org.acme.Foo');
		ConfigurationMetadataHint hint = hints.get(0);
		assertThat(hint.getId()).isEqualTo('spring.foo.counter');
		assertThat(hint.getValueHints()).hasSize(1);
		ValueHint valueHint = hint.getValueHints().get(0);
		assertThat(valueHint.getValue()).isEqualTo(42);
		assertThat(valueHint.getDescription())
			.isEqualTo('Because that"s the answer to any question, choose it. \nReally.');
		assertThat(valueHint.getShortDescription()).isEqualTo('Because that"s the answer to any question, choose it.');
		assertThat(hint.getValueProviders()).hasSize(1);
		ValueProvider valueProvider = hint.getValueProviders().get(0);
		assertThat(valueProvider.getName()).isEqualTo('handle-as');
		assertThat(valueProvider.getParameters()).hasSize(1);
		assertThat(valueProvider.getParameters()).containsEntry('target', Integer.class.getName());
	}
	@Test
	void metadataHints() throws IOException {
		RawConfigurationMetadata rawMetadata = readFor('bar');
		List<ConfigurationMetadataHint> hints = rawMetadata.getHints();
		assertThat(hints).hasSize(1);
		ConfigurationMetadataHint hint = hints.get(0);
		assertThat(hint.getId()).isEqualTo('spring.bar.description');
		assertThat(hint.getValueHints()).hasSize(2);
		ValueHint valueHint = hint.getValueHints().get(0);
		assertThat(valueHint.getValue()).isEqualTo('one');
		assertThat(valueHint.getDescription()).isEqualTo('One.');
		ValueHint valueHint2 = hint.getValueHints().get(1);
		assertThat(valueHint2.getValue()).isEqualTo('two');
		assertThat(valueHint2.getDescription()).isNull();
		assertThat(hint.getValueProviders()).hasSize(2);
		ValueProvider valueProvider = hint.getValueProviders().get(0);
		assertThat(valueProvider.getName()).isEqualTo('handle-as');
		assertThat(valueProvider.getParameters()).hasSize(1);
		assertThat(valueProvider.getParameters()).containsEntry('target', String.class.getName());
		ValueProvider valueProvider2 = hint.getValueProviders().get(1);
		assertThat(valueProvider2.getName()).isEqualTo('any');
		assertThat(valueProvider2.getParameters()).isEmpty();
	}
	@Test
	void rootMetadata() throws IOException {
		RawConfigurationMetadata rawMetadata = readFor('root');
		List<ConfigurationMetadataSource> sources = rawMetadata.getSources();
		assertThat(sources).isEmpty();
		List<ConfigurationMetadataItem> items = rawMetadata.getItems();
		assertThat(items).hasSize(2);
		ConfigurationMetadataItem item = items.get(0);
		assertProperty(item, 'spring.root.name', 'spring.root.name', String.class, null);
	}
	@Test
	void deprecatedMetadata() throws IOException {
		RawConfigurationMetadata rawMetadata = readFor('deprecated');
		List<ConfigurationMetadataItem> items = rawMetadata.getItems();
		assertThat(items).hasSize(5);
		ConfigurationMetadataItem item = items.get(0);
		assertProperty(item, 'server.port', 'server.port', Integer.class, null);
		assertThat(item.isDeprecated()).isTrue();
		assertThat(item.getDeprecation().getReason()).isEqualTo('Server namespace has moved to spring.server');
		assertThat(item.getDeprecation().getShortReason()).isEqualTo('Server namespace has moved to spring.server');
		assertThat(item.getDeprecation().getReplacement()).isEqualTo('server.spring.port');
		assertThat(item.getDeprecation().getLevel()).isEqualTo(Deprecation.Level.WARNING);
		ConfigurationMetadataItem item2 = items.get(1);
		assertProperty(item2, 'server.cluster-name', 'server.cluster-name', String.class, null);
		assertThat(item2.isDeprecated()).isTrue();
		assertThat(item2.getDeprecation().getReason()).isNull();
		assertThat(item2.getDeprecation().getShortReason()).isNull();
		assertThat(item2.getDeprecation().getReplacement()).isNull();
		assertThat(item.getDeprecation().getLevel()).isEqualTo(Deprecation.Level.WARNING);
		ConfigurationMetadataItem item3 = items.get(2);
		assertProperty(item3, 'spring.server.name', 'spring.server.name', String.class, null);
		assertThat(item3.isDeprecated()).isFalse();
		assertThat(item3.getDeprecation()).isNull();
		ConfigurationMetadataItem item4 = items.get(3);
		assertProperty(item4, 'spring.server-name', 'spring.server-name', String.class, null);
		assertThat(item4.isDeprecated()).isTrue();
		assertThat(item4.getDeprecation().getReason()).isNull();
		assertThat(item2.getDeprecation().getShortReason()).isNull();
		assertThat(item4.getDeprecation().getReplacement()).isEqualTo('spring.server.name');
		assertThat(item4.getDeprecation().getLevel()).isEqualTo(Deprecation.Level.ERROR);
		ConfigurationMetadataItem item5 = items.get(4);
		assertProperty(item5, 'spring.server-name2', 'spring.server-name2', String.class, null);
		assertThat(item5.isDeprecated()).isTrue();
		assertThat(item5.getDeprecation().getReason()).isNull();
		assertThat(item2.getDeprecation().getShortReason()).isNull();
		assertThat(item5.getDeprecation().getReplacement()).isEqualTo('spring.server.name');
		assertThat(item5.getDeprecation().getLevel()).isEqualTo(Deprecation.Level.WARNING);
	}
	@Test
	void multiGroupsMetadata() throws IOException {
		RawConfigurationMetadata rawMetadata = readFor('multi-groups');
		List<ConfigurationMetadataItem> items = rawMetadata.getItems();
		assertThat(items).hasSize(3);
		ConfigurationMetadataItem item = items.get(0);
		assertThat(item.getName()).isEqualTo('enabled');
		assertThat(item.getSourceType()).isEqualTo('com.example.Retry');
		ConfigurationMetadataItem item2 = items.get(1);
		assertThat(item2.getName()).isEqualTo('enabled');
		assertThat(item2.getSourceType()).isEqualTo('com.example.Retry');
		ConfigurationMetadataItem item3 = items.get(2);
		assertThat(item3.getName()).isEqualTo('enabled');
		assertThat(item3.getSourceType()).isEqualTo('com.example.Retry');
	}
	RawConfigurationMetadata readFor(String path) throws IOException {
		return this.reader.read(getInputStreamFor(path), DEFAULT_CHARSET);
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
class ConfigurationMetadataRepositoryJsonBuilderTests extends AbstractConfigurationMetadataTests {
	@Test
	void nullResource() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> ConfigurationMetadataRepositoryJsonBuilder.create().withJsonResource(null));
	}
	@Test
	void simpleRepository() throws IOException {
		try (InputStream foo = getInputStreamFor('foo')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(foo).build();
			validateFoo(repo);
			assertThat(repo.getAllGroups()).hasSize(1);
			contains(repo.getAllProperties(), 'spring.foo.name', 'spring.foo.description', 'spring.foo.counter');
			assertThat(repo.getAllProperties()).hasSize(3);
		}
	}
	@Test
	void hintsOnMaps() throws IOException {
		try (InputStream map = getInputStreamFor('map')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(map).build();
			validateMap(repo);
			assertThat(repo.getAllGroups()).hasSize(1);
			contains(repo.getAllProperties(), 'spring.map.first', 'spring.map.second', 'spring.map.keys',
					'spring.map.values');
			assertThat(repo.getAllProperties()).hasSize(4);
		}
	}
	@Test
	void severalRepositoriesNoConflict() throws IOException {
		try (InputStream foo = getInputStreamFor('foo'); InputStream bar = getInputStreamFor('bar')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(foo, bar).build();
			validateFoo(repo);
			validateBar(repo);
			assertThat(repo.getAllGroups()).hasSize(2);
			contains(repo.getAllProperties(), 'spring.foo.name', 'spring.foo.description', 'spring.foo.counter',
					'spring.bar.name', 'spring.bar.description', 'spring.bar.counter');
			assertThat(repo.getAllProperties()).hasSize(6);
		}
	}
	@Test
	void repositoryWithRoot() throws IOException {
		try (InputStream foo = getInputStreamFor('foo'); InputStream root = getInputStreamFor('root')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(foo, root).build();
			validateFoo(repo);
			assertThat(repo.getAllGroups()).hasSize(2);
			contains(repo.getAllProperties(), 'spring.foo.name', 'spring.foo.description', 'spring.foo.counter',
					'spring.root.name', 'spring.root2.name');
			assertThat(repo.getAllProperties()).hasSize(5);
		}
	}
	@Test
	void severalRepositoriesIdenticalGroups() throws IOException {
		try (InputStream foo = getInputStreamFor('foo'); InputStream foo2 = getInputStreamFor('foo2')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(foo, foo2).build();
			Iterable<String> allKeys = Arrays.asList('spring.foo.name', 'spring.foo.description', 'spring.foo.counter',
					'spring.foo.enabled', 'spring.foo.type');
			assertThat(repo.getAllProperties()).containsOnlyKeys(allKeys);
			assertThat(repo.getAllGroups()).containsOnlyKeys('spring.foo');
			ConfigurationMetadataGroup group = repo.getAllGroups().get('spring.foo');
			assertThat(group.getProperties()).containsOnlyKeys(allKeys);
			assertThat(group.getSources()).containsOnlyKeys('org.acme.Foo', 'org.acme.Foo2',
					'org.springframework.boot.FooProperties');
			assertThat(group.getSources().get('org.acme.Foo').getProperties()).containsOnlyKeys('spring.foo.name',
					'spring.foo.description');
			assertThat(group.getSources().get('org.acme.Foo2').getProperties()).containsOnlyKeys('spring.foo.enabled',
					'spring.foo.type');
			assertThat(group.getSources().get('org.springframework.boot.FooProperties').getProperties())
				.containsOnlyKeys('spring.foo.name', 'spring.foo.counter');
		}
	}
	@Test
	void severalRepositoriesIdenticalGroupsWithSameType() throws IOException {
		try (InputStream foo = getInputStreamFor('foo'); InputStream foo3 = getInputStreamFor('foo3')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(foo, foo3).build();
			Iterable<String> allKeys = Arrays.asList('spring.foo.name', 'spring.foo.description', 'spring.foo.counter',
					'spring.foo.enabled', 'spring.foo.type');
			assertThat(repo.getAllProperties()).containsOnlyKeys(allKeys);
			assertThat(repo.getAllGroups()).containsOnlyKeys('spring.foo');
			ConfigurationMetadataGroup group = repo.getAllGroups().get('spring.foo');
			assertThat(group.getProperties()).containsOnlyKeys(allKeys);
			assertThat(group.getSources()).containsOnlyKeys('org.acme.Foo', 'org.springframework.boot.FooProperties');
			assertThat(group.getSources().get('org.acme.Foo').getProperties()).containsOnlyKeys('spring.foo.name',
					'spring.foo.description', 'spring.foo.enabled', 'spring.foo.type');
			assertThat(group.getSources().get('org.springframework.boot.FooProperties').getProperties())
				.containsOnlyKeys('spring.foo.name', 'spring.foo.counter');
		}
	}
	@Test
	void severalRepositoriesIdenticalGroupsWithSameTypeDoesNotOverrideSource() throws IOException {
		try (InputStream foo = getInputStreamFor('foo'); InputStream foo3 = getInputStreamFor('foo3')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(foo, foo3).build();
			ConfigurationMetadataGroup group = repo.getAllGroups().get('spring.foo');
			ConfigurationMetadataSource fooSource = group.getSources().get('org.acme.Foo');
			assertThat(fooSource.getSourceMethod()).isEqualTo('foo()');
			assertThat(fooSource.getDescription()).isEqualTo('This is Foo.');
		}
	}
	@Test
	void emptyGroups() throws IOException {
		try (InputStream in = getInputStreamFor('empty-groups')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(in).build();
			validateEmptyGroup(repo);
			assertThat(repo.getAllGroups()).hasSize(1);
			contains(repo.getAllProperties(), 'name', 'title');
			assertThat(repo.getAllProperties()).hasSize(2);
		}
	}
	@Test
	void multiGroups() throws IOException {
		try (InputStream in = getInputStreamFor('multi-groups')) {
			ConfigurationMetadataRepository repo = ConfigurationMetadataRepositoryJsonBuilder.create(in).build();
			assertThat(repo.getAllGroups()).containsOnlyKeys('test.group.one.retry', 'test.group.two.retry',
					'test.group.one.retry.specific');
			ConfigurationMetadataGroup one = repo.getAllGroups().get('test.group.one.retry');
			assertThat(one.getSources()).containsOnlyKeys('com.example.Retry');
			assertThat(one.getProperties()).containsOnlyKeys('test.group.one.retry.enabled');
			ConfigurationMetadataGroup two = repo.getAllGroups().get('test.group.two.retry');
			assertThat(two.getSources()).containsOnlyKeys('com.example.Retry');
			assertThat(two.getProperties()).containsOnlyKeys('test.group.two.retry.enabled');
			ConfigurationMetadataGroup oneSpecific = repo.getAllGroups().get('test.group.one.retry.specific');
			assertThat(oneSpecific.getSources()).containsOnlyKeys('com.example.Retry');
			assertThat(oneSpecific.getProperties()).containsOnlyKeys('test.group.one.retry.specific.enabled');
		}
	}
	@Test
	void builderInstancesAreIsolated() throws IOException {
		try (InputStream foo = getInputStreamFor('foo'); InputStream bar = getInputStreamFor('bar')) {
			ConfigurationMetadataRepositoryJsonBuilder builder = ConfigurationMetadataRepositoryJsonBuilder.create();
			ConfigurationMetadataRepository firstRepo = builder.withJsonResource(foo).build();
			validateFoo(firstRepo);
			ConfigurationMetadataRepository secondRepo = builder.withJsonResource(bar).build();
			validateFoo(secondRepo);
			validateBar(secondRepo);
			// first repo not impacted by second build
			assertThat(secondRepo).isNotEqualTo(firstRepo);
			assertThat(firstRepo.getAllGroups()).hasSize(1);
			assertThat(firstRepo.getAllProperties()).hasSize(3);
			assertThat(secondRepo.getAllGroups()).hasSize(2);
			assertThat(secondRepo.getAllProperties()).hasSize(6);
		}
	}
	private void validateFoo(ConfigurationMetadataRepository repo) {
		ConfigurationMetadataGroup group = repo.getAllGroups().get('spring.foo');
		contains(group.getSources(), 'org.acme.Foo', 'org.springframework.boot.FooProperties');
		ConfigurationMetadataSource source = group.getSources().get('org.acme.Foo');
		contains(source.getProperties(), 'spring.foo.name', 'spring.foo.description');
		assertThat(source.getProperties()).hasSize(2);
		ConfigurationMetadataSource source2 = group.getSources().get('org.springframework.boot.FooProperties');
		contains(source2.getProperties(), 'spring.foo.name', 'spring.foo.counter');
		assertThat(source2.getProperties()).hasSize(2);
		validatePropertyHints(repo.getAllProperties().get('spring.foo.name'), 0, 0);
		validatePropertyHints(repo.getAllProperties().get('spring.foo.description'), 0, 0);
		validatePropertyHints(repo.getAllProperties().get('spring.foo.counter'), 1, 1);
	}
	private void validateBar(ConfigurationMetadataRepository repo) {
		ConfigurationMetadataGroup group = repo.getAllGroups().get('spring.bar');
		contains(group.getSources(), 'org.acme.Bar', 'org.springframework.boot.BarProperties');
		ConfigurationMetadataSource source = group.getSources().get('org.acme.Bar');
		contains(source.getProperties(), 'spring.bar.name', 'spring.bar.description');
		assertThat(source.getProperties()).hasSize(2);
		ConfigurationMetadataSource source2 = group.getSources().get('org.springframework.boot.BarProperties');
		contains(source2.getProperties(), 'spring.bar.name', 'spring.bar.counter');
		assertThat(source2.getProperties()).hasSize(2);
		validatePropertyHints(repo.getAllProperties().get('spring.bar.name'), 0, 0);
		validatePropertyHints(repo.getAllProperties().get('spring.bar.description'), 2, 2);
		validatePropertyHints(repo.getAllProperties().get('spring.bar.counter'), 0, 0);
	}
	private void validateMap(ConfigurationMetadataRepository repo) {
		ConfigurationMetadataGroup group = repo.getAllGroups().get('spring.map');
		ConfigurationMetadataSource source = group.getSources().get('org.acme.Map');
		contains(source.getProperties(), 'spring.map.first', 'spring.map.second', 'spring.map.keys',
				'spring.map.values');
		assertThat(source.getProperties()).hasSize(4);
		ConfigurationMetadataProperty first = repo.getAllProperties().get('spring.map.first');
		assertThat(first.getHints().getKeyHints()).hasSize(2);
		assertThat(first.getHints().getValueProviders()).isEmpty();
		assertThat(first.getHints().getKeyHints().get(0).getValue()).isEqualTo('one');
		assertThat(first.getHints().getKeyHints().get(0).getDescription()).isEqualTo('First.');
		assertThat(first.getHints().getKeyHints().get(1).getValue()).isEqualTo('two');
		assertThat(first.getHints().getKeyHints().get(1).getDescription()).isEqualTo('Second.');
		ConfigurationMetadataProperty second = repo.getAllProperties().get('spring.map.second');
		assertThat(second.getHints().getValueHints()).hasSize(2);
		assertThat(second.getHints().getValueProviders()).isEmpty();
		assertThat(second.getHints().getValueHints().get(0).getValue()).isEqualTo('42');
		assertThat(second.getHints().getValueHints().get(0).getDescription()).isEqualTo('Choose me.');
		assertThat(second.getHints().getValueHints().get(1).getValue()).isEqualTo('24');
		assertThat(second.getHints().getValueHints().get(1).getDescription()).isNull();
		ConfigurationMetadataProperty keys = repo.getAllProperties().get('spring.map.keys');
		assertThat(keys.getHints().getValueHints()).isEmpty();
		assertThat(keys.getHints().getValueProviders()).hasSize(1);
		assertThat(keys.getHints().getValueProviders().get(0).getName()).isEqualTo('any');
		ConfigurationMetadataProperty values = repo.getAllProperties().get('spring.map.values');
		assertThat(values.getHints().getValueHints()).isEmpty();
		assertThat(values.getHints().getValueProviders()).hasSize(1);
		assertThat(values.getHints().getValueProviders().get(0).getName()).isEqualTo('handle-as');
		assertThat(values.getHints().getValueProviders().get(0).getParameters()).hasSize(1);
		assertThat(values.getHints().getValueProviders().get(0).getParameters()).containsEntry('target',
				'java.lang.Integer');
	}
	private void validateEmptyGroup(ConfigurationMetadataRepository repo) {
		ConfigurationMetadataGroup group = repo.getAllGroups().get('');
		contains(group.getSources(), 'org.acme.Foo', 'org.acme.Bar');
		ConfigurationMetadataSource source = group.getSources().get('org.acme.Foo');
		contains(source.getProperties(), 'name');
		assertThat(source.getProperties()).hasSize(1);
		ConfigurationMetadataSource source2 = group.getSources().get('org.acme.Bar');
		contains(source2.getProperties(), 'title');
		assertThat(source2.getProperties()).hasSize(1);
		validatePropertyHints(repo.getAllProperties().get('name'), 0, 0);
		validatePropertyHints(repo.getAllProperties().get('title'), 0, 0);
	}
	private void validatePropertyHints(ConfigurationMetadataProperty property, int valueHints, int valueProviders) {
		assertThat(property.getHints().getValueHints()).hasSize(valueHints);
		assertThat(property.getHints().getValueProviders()).hasSize(valueProviders);
	}
	private void contains(Map<String, ?> source, String... keys) {
		for (String key : keys) {
			assertThat(source).containsKey(key);
		}
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
class ConfigurationMetadataItem extends ConfigurationMetadataProperty {
	private String sourceType;
	private String sourceMethod;
	/**
	 * The class name of the source that contributed this property. For example, if the
	 * property was from a class annotated with {@code @ConfigurationProperties} this
	 * attribute would contain the fully qualified name of that class.
	 * @return the source type
	 */
	String getSourceType() {
		return this.sourceType;
	}
	void setSourceType(String sourceType) {
		this.sourceType = sourceType;
	}
	/**
	 * The full name of the method (including parenthesis and argument types) that
	 * contributed this property. For example, the name of a getter in a
	 * {@code @ConfigurationProperties} annotated class.
	 * @return the source method
	 */
	String getSourceMethod() {
		return this.sourceMethod;
	}
	void setSourceMethod(String sourceMethod) {
		this.sourceMethod = sourceMethod;
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
class SentenceExtractor {
	String getFirstSentence(String text) {
		if (text == null) {
			return null;
		}
		int dot = text.indexOf(".");
		if (dot != -1) {
			BreakIterator breakIterator = BreakIterator.getSentenceInstance(Locale.US);
			breakIterator.setText(text);
			String sentence = text.substring(breakIterator.first(), breakIterator.next());
			return removeSpaceBetweenLine(sentence.trim());
		}
		else {
			String[] lines = text.split(System.lineSeparator());
			return lines[0].trim();
		}
	}
	private String removeSpaceBetweenLine(String text) {
		String[] lines = text.split(System.lineSeparator());
		return Arrays.stream(lines).map(String::trim).collect(Collectors.joining(' '));
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
public interface ConfigurationMetadataRepository {
	/**
	 * Defines the name of the 'root' group, that is the group that gathers all the
	 * properties that aren"t attached to a specific group.
	 */
	String ROOT_GROUP = '_ROOT_GROUP_';
	/**
	 * Return the groups, indexed by id.
	 * @return all configuration meta-data groups
	 */
	Map<String, ConfigurationMetadataGroup> getAllGroups();
	/**
	 * Return the properties, indexed by id.
	 * @return all configuration meta-data properties
	 */
	Map<String, ConfigurationMetadataProperty> getAllProperties();
}
/*
package org.springframework.boot.configurationmetadata;
/**
@SuppressWarnings('serial')
public class ValueHint implements Serializable {
	private Object value;
	private String description;
	private String shortDescription;
	/**
	 * Return the hint value.
	 * @return the value
	 */
	public Object getValue() {
		return this.value;
	}
	public void setValue(Object value) {
		this.value = value;
	}
	/**
	 * A description of this value, if any. Can be multi-lines.
	 * @return the description
	 * @see #getShortDescription()
	 */
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	/**
	 * A single-line, single-sentence description of this hint, if any.
	 * @return the short description
	 * @see #getDescription()
	 */
	public String getShortDescription() {
		return this.shortDescription;
	}
	public void setShortDescription(String shortDescription) {
		this.shortDescription = shortDescription;
	}
	@Override
	public String toString() {
		return 'ValueHint{value=' + this.value + ', description="' + this.description + "\"" + "}";
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
class RawConfigurationMetadata {
	private final List<ConfigurationMetadataSource> sources;
	private final List<ConfigurationMetadataItem> items;
	private final List<ConfigurationMetadataHint> hints;
	RawConfigurationMetadata(List<ConfigurationMetadataSource> sources, List<ConfigurationMetadataItem> items,
			List<ConfigurationMetadataHint> hints) {
		this.sources = new ArrayList<>(sources);
		this.items = new ArrayList<>(items);
		this.hints = new ArrayList<>(hints);
		for (ConfigurationMetadataItem item : this.items) {
			resolveName(item);
		}
	}
	List<ConfigurationMetadataSource> getSources() {
		return this.sources;
	}
	ConfigurationMetadataSource getSource(ConfigurationMetadataItem item) {
		if (item.getSourceType() == null) {
			return null;
		}
		return this.sources.stream()
			.filter((candidate) -> item.getSourceType().equals(candidate.getType())
					&& item.getId().startsWith(candidate.getGroupId()))
			.max(Comparator.comparingInt((candidate) -> candidate.getGroupId().length()))
			.orElse(null);
	}
	List<ConfigurationMetadataItem> getItems() {
		return this.items;
	}
	List<ConfigurationMetadataHint> getHints() {
		return this.hints;
	}
	/**
	 * Resolve the name of an item against this instance.
	 * @param item the item to resolve
	 * @see ConfigurationMetadataProperty#setName(String)
	 */
	private void resolveName(ConfigurationMetadataItem item) {
		item.setName(item.getId()); // fallback
		ConfigurationMetadataSource source = getSource(item);
		if (source != null) {
			String groupId = source.getGroupId();
			String dottedPrefix = groupId + '.';
			String id = item.getId();
			if (hasLength(groupId) && id.startsWith(dottedPrefix)) {
				String name = id.substring(dottedPrefix.length());
				item.setName(name);
			}
		}
	}
	private static boolean hasLength(String string) {
		return (string != null && !string.isEmpty());
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
public class Hints {
	private final List<ValueHint> keyHints = new ArrayList<>();
	private final List<ValueProvider> keyProviders = new ArrayList<>();
	private final List<ValueHint> valueHints = new ArrayList<>();
	private final List<ValueProvider> valueProviders = new ArrayList<>();
	/**
	 * The list of well-defined keys, if any. Only applicable if the type of the related
	 * item is a {@link java.util.Map}. If no extra {@link ValueProvider provider} is
	 * specified, these values are to be considered a closed-set of the available keys for
	 * the map.
	 * @return the key hints
	 */
	public List<ValueHint> getKeyHints() {
		return this.keyHints;
	}
	/**
	 * The value providers that are applicable to the keys of this item. Only applicable
	 * if the type of the related item is a {@link java.util.Map}. Only one
	 * {@link ValueProvider} is enabled for a key: the first in the list that is supported
	 * should be used.
	 * @return the key providers
	 */
	public List<ValueProvider> getKeyProviders() {
		return this.keyProviders;
	}
	/**
	 * The list of well-defined values, if any. If no extra {@link ValueProvider provider}
	 * is specified, these values are to be considered a closed-set of the available
	 * values for this item.
	 * @return the value hints
	 */
	public List<ValueHint> getValueHints() {
		return this.valueHints;
	}
	/**
	 * The value providers that are applicable to this item. Only one
	 * {@link ValueProvider} is enabled for an item: the first in the list that is
	 * supported should be used.
	 * @return the value providers
	 */
	public List<ValueProvider> getValueProviders() {
		return this.valueProviders;
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
@SuppressWarnings('serial')
public class Deprecation implements Serializable {
	private Level level = Level.WARNING;
	private String reason;
	private String shortReason;
	private String replacement;
	/**
	 * Define the {@link Level} of deprecation.
	 * @return the deprecation level
	 */
	public Level getLevel() {
		return this.level;
	}
	public void setLevel(Level level) {
		this.level = level;
	}
	/**
	 * A reason why the related property is deprecated, if any. Can be multi-lines.
	 * @return the deprecation reason
	 * @see #getShortReason()
	 */
	public String getReason() {
		return this.reason;
	}
	public void setReason(String reason) {
		this.reason = reason;
	}
	/**
	 * A single-line, single-sentence reason why the related property is deprecated, if
	 * any.
	 * @return the short deprecation reason
	 * @see #getReason()
	 */
	public String getShortReason() {
		return this.shortReason;
	}
	public void setShortReason(String shortReason) {
		this.shortReason = shortReason;
	}
	/**
	 * The full name of the property that replaces the related deprecated property, if
	 * any.
	 * @return the replacement property name
	 */
	public String getReplacement() {
		return this.replacement;
	}
	public void setReplacement(String replacement) {
		this.replacement = replacement;
	}
	@Override
	public String toString() {
		return 'Deprecation{level="' + this.level + "\"" + ', reason="' + this.reason + "\"" + ', replacement="'
				+ this.replacement + "\"" + "}";
	}
	/**
	 * Define the deprecation level.
	 */
	public enum Level {
		/**
		 * The property is still bound.
		 */
		WARNING,
		/**
		 * The property has been removed and is no longer bound.
		 */
		ERROR
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
class JsonReader {
	private static final int BUFFER_SIZE = 4096;
	private final SentenceExtractor sentenceExtractor = new SentenceExtractor();
	RawConfigurationMetadata read(InputStream in, Charset charset) throws IOException {
		try {
			JSONObject json = readJson(in, charset);
			List<ConfigurationMetadataSource> groups = parseAllSources(json);
			List<ConfigurationMetadataItem> items = parseAllItems(json);
			List<ConfigurationMetadataHint> hints = parseAllHints(json);
			return new RawConfigurationMetadata(groups, items, hints);
		}
		catch (Exception ex) {
			if (ex instanceof IOException ioException) {
				throw ioException;
			}
			if (ex instanceof RuntimeException runtimeException) {
				throw runtimeException;
			}
			throw new IllegalStateException(ex);
		}
	}
	private List<ConfigurationMetadataSource> parseAllSources(JSONObject root) throws Exception {
		List<ConfigurationMetadataSource> result = new ArrayList<>();
		if (!root.has('groups')) {
			return result;
		}
		JSONArray sources = root.getJSONArray('groups');
		for (int i = 0; i < sources.length(); i++) {
			JSONObject source = sources.getJSONObject(i);
			result.add(parseSource(source));
		}
		return result;
	}
	private List<ConfigurationMetadataItem> parseAllItems(JSONObject root) throws Exception {
		List<ConfigurationMetadataItem> result = new ArrayList<>();
		if (!root.has('properties')) {
			return result;
		}
		JSONArray items = root.getJSONArray('properties');
		for (int i = 0; i < items.length(); i++) {
			JSONObject item = items.getJSONObject(i);
			result.add(parseItem(item));
		}
		return result;
	}
	private List<ConfigurationMetadataHint> parseAllHints(JSONObject root) throws Exception {
		List<ConfigurationMetadataHint> result = new ArrayList<>();
		if (!root.has('hints')) {
			return result;
		}
		JSONArray items = root.getJSONArray('hints');
		for (int i = 0; i < items.length(); i++) {
			JSONObject item = items.getJSONObject(i);
			result.add(parseHint(item));
		}
		return result;
	}
	private ConfigurationMetadataSource parseSource(JSONObject json) throws Exception {
		ConfigurationMetadataSource source = new ConfigurationMetadataSource();
		source.setGroupId(json.getString('name'));
		source.setType(json.optString('type', null));
		String description = json.optString('description', null);
		source.setDescription(description);
		source.setShortDescription(this.sentenceExtractor.getFirstSentence(description));
		source.setSourceType(json.optString('sourceType', null));
		source.setSourceMethod(json.optString('sourceMethod', null));
		return source;
	}
	private ConfigurationMetadataItem parseItem(JSONObject json) throws Exception {
		ConfigurationMetadataItem item = new ConfigurationMetadataItem();
		item.setId(json.getString('name'));
		item.setType(json.optString('type', null));
		String description = json.optString('description', null);
		item.setDescription(description);
		item.setShortDescription(this.sentenceExtractor.getFirstSentence(description));
		item.setDefaultValue(readItemValue(json.opt('defaultValue')));
		item.setDeprecation(parseDeprecation(json));
		item.setSourceType(json.optString('sourceType', null));
		item.setSourceMethod(json.optString('sourceMethod', null));
		return item;
	}
	private ConfigurationMetadataHint parseHint(JSONObject json) throws Exception {
		ConfigurationMetadataHint hint = new ConfigurationMetadataHint();
		hint.setId(json.getString('name'));
		if (json.has('values')) {
			JSONArray values = json.getJSONArray('values');
			for (int i = 0; i < values.length(); i++) {
				JSONObject value = values.getJSONObject(i);
				ValueHint valueHint = new ValueHint();
				valueHint.setValue(readItemValue(value.get('value')));
				String description = value.optString('description', null);
				valueHint.setDescription(description);
				valueHint.setShortDescription(this.sentenceExtractor.getFirstSentence(description));
				hint.getValueHints().add(valueHint);
			}
		}
		if (json.has('providers')) {
			JSONArray providers = json.getJSONArray('providers');
			for (int i = 0; i < providers.length(); i++) {
				JSONObject provider = providers.getJSONObject(i);
				ValueProvider valueProvider = new ValueProvider();
				valueProvider.setName(provider.getString('name'));
				if (provider.has('parameters')) {
					JSONObject parameters = provider.getJSONObject('parameters');
					Iterator<?> keys = parameters.keys();
					while (keys.hasNext()) {
						String key = (String) keys.next();
						valueProvider.getParameters().put(key, readItemValue(parameters.get(key)));
					}
				}
				hint.getValueProviders().add(valueProvider);
			}
		}
		return hint;
	}
	private Deprecation parseDeprecation(JSONObject object) throws Exception {
		if (object.has('deprecation')) {
			JSONObject deprecationJsonObject = object.getJSONObject('deprecation');
			Deprecation deprecation = new Deprecation();
			deprecation.setLevel(parseDeprecationLevel(deprecationJsonObject.optString('level', null)));
			String reason = deprecationJsonObject.optString('reason', null);
			deprecation.setReason(reason);
			deprecation.setShortReason(this.sentenceExtractor.getFirstSentence(reason));
			deprecation.setReplacement(deprecationJsonObject.optString('replacement', null));
			return deprecation;
		}
		return object.optBoolean('deprecated') ? new Deprecation() : null;
	}
	private Deprecation.Level parseDeprecationLevel(String value) {
		if (value != null) {
			try {
				return Deprecation.Level.valueOf(value.toUpperCase(Locale.ENGLISH));
			}
			catch (IllegalArgumentException ex) {
				// let"s use the default
			}
		}
		return Deprecation.Level.WARNING;
	}
	private Object readItemValue(Object value) throws Exception {
		if (value instanceof JSONArray array) {
			Object[] content = new Object[array.length()];
			for (int i = 0; i < array.length(); i++) {
				content[i] = array.get(i);
			}
			return content;
		}
		return value;
	}
	private JSONObject readJson(InputStream in, Charset charset) throws Exception {
		try (in) {
			StringBuilder out = new StringBuilder();
			InputStreamReader reader = new InputStreamReader(in, charset);
			char[] buffer = new char[BUFFER_SIZE];
			int bytesRead;
			while ((bytesRead = reader.read(buffer)) != -1) {
				out.append(buffer, 0, bytesRead);
			}
			return new JSONObject(out.toString());
		}
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
public final class ConfigurationMetadataRepositoryJsonBuilder {
	private Charset defaultCharset = StandardCharsets.UTF_8;
	private final JsonReader reader = new JsonReader();
	private final List<SimpleConfigurationMetadataRepository> repositories = new ArrayList<>();
	private ConfigurationMetadataRepositoryJsonBuilder(Charset defaultCharset) {
		this.defaultCharset = defaultCharset;
	}
	/**
	 * Add the content of a {@link ConfigurationMetadataRepository} defined by the
	 * specified {@link InputStream} json document using the default charset. If this
	 * metadata repository holds items that were loaded previously, these are ignored.
	 * <p>
	 * Leaves the stream open when done.
	 * @param inputStream the source input stream
	 * @return this builder
	 * @throws IOException in case of I/O errors
	 */
	public ConfigurationMetadataRepositoryJsonBuilder withJsonResource(InputStream inputStream) throws IOException {
		return withJsonResource(inputStream, this.defaultCharset);
	}
	/**
	 * Add the content of a {@link ConfigurationMetadataRepository} defined by the
	 * specified {@link InputStream} json document using the specified {@link Charset}. If
	 * this metadata repository holds items that were loaded previously, these are
	 * ignored.
	 * <p>
	 * Leaves the stream open when done.
	 * @param inputStream the source input stream
	 * @param charset the charset of the input
	 * @return this builder
	 * @throws IOException in case of I/O errors
	 */
	public ConfigurationMetadataRepositoryJsonBuilder withJsonResource(InputStream inputStream, Charset charset)
			throws IOException {
		if (inputStream == null) {
			throw new IllegalArgumentException('InputStream must not be null.');
		}
		this.repositories.add(add(inputStream, charset));
		return this;
	}
	/**
	 * Build a {@link ConfigurationMetadataRepository} with the current state of this
	 * builder.
	 * @return this builder
	 */
	public ConfigurationMetadataRepository build() {
		SimpleConfigurationMetadataRepository result = new SimpleConfigurationMetadataRepository();
		for (SimpleConfigurationMetadataRepository repository : this.repositories) {
			result.include(repository);
		}
		return result;
	}
	private SimpleConfigurationMetadataRepository add(InputStream in, Charset charset) {
		try {
			RawConfigurationMetadata metadata = this.reader.read(in, charset);
			return create(metadata);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Failed to read configuration metadata', ex);
		}
	}
	private SimpleConfigurationMetadataRepository create(RawConfigurationMetadata metadata) {
		SimpleConfigurationMetadataRepository repository = new SimpleConfigurationMetadataRepository();
		repository.add(metadata.getSources());
		for (ConfigurationMetadataItem item : metadata.getItems()) {
			ConfigurationMetadataSource source = metadata.getSource(item);
			repository.add(item, source);
		}
		Map<String, ConfigurationMetadataProperty> allProperties = repository.getAllProperties();
		for (ConfigurationMetadataHint hint : metadata.getHints()) {
			ConfigurationMetadataProperty property = allProperties.get(hint.getId());
			if (property != null) {
				addValueHints(property, hint);
			}
			else {
				String id = hint.resolveId();
				property = allProperties.get(id);
				if (property != null) {
					if (hint.isMapKeyHints()) {
						addMapHints(property, hint);
					}
					else {
						addValueHints(property, hint);
					}
				}
			}
		}
		return repository;
	}
	private void addValueHints(ConfigurationMetadataProperty property, ConfigurationMetadataHint hint) {
		property.getHints().getValueHints().addAll(hint.getValueHints());
		property.getHints().getValueProviders().addAll(hint.getValueProviders());
	}
	private void addMapHints(ConfigurationMetadataProperty property, ConfigurationMetadataHint hint) {
		property.getHints().getKeyHints().addAll(hint.getValueHints());
		property.getHints().getKeyProviders().addAll(hint.getValueProviders());
	}
	/**
	 * Create a new builder instance using {@link StandardCharsets#UTF_8} as the default
	 * charset and the specified json resource.
	 * @param inputStreams the source input streams
	 * @return a new {@link ConfigurationMetadataRepositoryJsonBuilder} instance.
	 * @throws IOException on error
	 */
	public static ConfigurationMetadataRepositoryJsonBuilder create(InputStream... inputStreams) throws IOException {
		ConfigurationMetadataRepositoryJsonBuilder builder = create();
		for (InputStream inputStream : inputStreams) {
			builder = builder.withJsonResource(inputStream);
		}
		return builder;
	}
	/**
	 * Create a new builder instance using {@link StandardCharsets#UTF_8} as the default
	 * charset.
	 * @return a new {@link ConfigurationMetadataRepositoryJsonBuilder} instance.
	 */
	public static ConfigurationMetadataRepositoryJsonBuilder create() {
		return create(StandardCharsets.UTF_8);
	}
	/**
	 * Create a new builder instance using the specified default {@link Charset}.
	 * @param defaultCharset the default charset to use
	 * @return a new {@link ConfigurationMetadataRepositoryJsonBuilder} instance.
	 */
	public static ConfigurationMetadataRepositoryJsonBuilder create(Charset defaultCharset) {
		return new ConfigurationMetadataRepositoryJsonBuilder(defaultCharset);
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
@SuppressWarnings('serial')
public class ConfigurationMetadataGroup implements Serializable {
	private final String id;
	private final Map<String, ConfigurationMetadataSource> sources = new HashMap<>();
	private final Map<String, ConfigurationMetadataProperty> properties = new HashMap<>();
	public ConfigurationMetadataGroup(String id) {
		this.id = id;
	}
	/**
	 * Return the id of the group, used as a common prefix for all properties associated
	 * to it.
	 * @return the id of the group
	 */
	public String getId() {
		return this.id;
	}
	/**
	 * Return the {@link ConfigurationMetadataSource sources} defining the properties of
	 * this group.
	 * @return the sources of the group
	 */
	public Map<String, ConfigurationMetadataSource> getSources() {
		return this.sources;
	}
	/**
	 * Return the {@link ConfigurationMetadataProperty properties} defined in this group.
	 * <p>
	 * A property may appear more than once for a given source, potentially with
	 * conflicting type or documentation. This is a 'merged' view of the properties of
	 * this group.
	 * @return the properties of the group
	 * @see ConfigurationMetadataSource#getProperties()
	 */
	public Map<String, ConfigurationMetadataProperty> getProperties() {
		return this.properties;
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
@SuppressWarnings('serial')
public class ValueProvider implements Serializable {
	private String name;
	private final Map<String, Object> parameters = new LinkedHashMap<>();
	/**
	 * Return the name of the provider.
	 * @return the name
	 */
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	/**
	 * Return the parameters.
	 * @return the parameters
	 */
	public Map<String, Object> getParameters() {
		return this.parameters;
	}
	@Override
	public String toString() {
		return 'ValueProvider{name="' + this.name + ', parameters=' + this.parameters + "}";
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
@SuppressWarnings('serial')
public class SimpleConfigurationMetadataRepository implements ConfigurationMetadataRepository, Serializable {
	private final Map<String, ConfigurationMetadataGroup> allGroups = new HashMap<>();
	@Override
	public Map<String, ConfigurationMetadataGroup> getAllGroups() {
		return Collections.unmodifiableMap(this.allGroups);
	}
	@Override
	public Map<String, ConfigurationMetadataProperty> getAllProperties() {
		Map<String, ConfigurationMetadataProperty> properties = new HashMap<>();
		for (ConfigurationMetadataGroup group : this.allGroups.values()) {
			properties.putAll(group.getProperties());
		}
		return properties;
	}
	/**
	 * Register the specified {@link ConfigurationMetadataSource sources}.
	 * @param sources the sources to add
	 */
	public void add(Collection<ConfigurationMetadataSource> sources) {
		for (ConfigurationMetadataSource source : sources) {
			String groupId = source.getGroupId();
			ConfigurationMetadataGroup group = this.allGroups.computeIfAbsent(groupId,
					(key) -> new ConfigurationMetadataGroup(groupId));
			String sourceType = source.getType();
			if (sourceType != null) {
				addOrMergeSource(group.getSources(), sourceType, source);
			}
		}
	}
	/**
	 * Add a {@link ConfigurationMetadataProperty} with the
	 * {@link ConfigurationMetadataSource source} that defines it, if any.
	 * @param property the property to add
	 * @param source the source
	 */
	public void add(ConfigurationMetadataProperty property, ConfigurationMetadataSource source) {
		if (source != null) {
			source.getProperties().putIfAbsent(property.getId(), property);
		}
		getGroup(source).getProperties().putIfAbsent(property.getId(), property);
	}
	/**
	 * Merge the content of the specified repository to this repository.
	 * @param repository the repository to include
	 */
	public void include(ConfigurationMetadataRepository repository) {
		for (ConfigurationMetadataGroup group : repository.getAllGroups().values()) {
			ConfigurationMetadataGroup existingGroup = this.allGroups.get(group.getId());
			if (existingGroup == null) {
				this.allGroups.put(group.getId(), group);
			}
			else {
				// Merge properties
				group.getProperties().forEach((name, value) -> existingGroup.getProperties().putIfAbsent(name, value));
				// Merge sources
				group.getSources().forEach((name, value) -> addOrMergeSource(existingGroup.getSources(), name, value));
			}
		}
	}
	private ConfigurationMetadataGroup getGroup(ConfigurationMetadataSource source) {
		if (source == null) {
			return this.allGroups.computeIfAbsent(ROOT_GROUP, (key) -> new ConfigurationMetadataGroup(ROOT_GROUP));
		}
		return this.allGroups.get(source.getGroupId());
	}
	private void addOrMergeSource(Map<String, ConfigurationMetadataSource> sources, String name,
			ConfigurationMetadataSource source) {
		ConfigurationMetadataSource existingSource = sources.get(name);
		if (existingSource == null) {
			sources.put(name, source);
		}
		else {
			source.getProperties().forEach((k, v) -> existingSource.getProperties().putIfAbsent(k, v));
		}
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
@SuppressWarnings('serial')
public class ConfigurationMetadataProperty implements Serializable {
	private String id;
	private String name;
	private String type;
	private String description;
	private String shortDescription;
	private Object defaultValue;
	private final Hints hints = new Hints();
	private Deprecation deprecation;
	/**
	 * The full identifier of the property, in lowercase dashed form (e.g.
	 * my.group.simple-property)
	 * @return the property id
	 */
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	/**
	 * The name of the property, in lowercase dashed form (e.g. simple-property). If this
	 * item does not belong to any group, the id is returned.
	 * @return the property name
	 */
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	/**
	 * The class name of the data type of the property. For example,
	 * {@code java.lang.String}.
	 * <p>
	 * For consistency, the type of a primitive is specified using its wrapper
	 * counterpart, i.e. {@code boolean} becomes {@code java.lang.Boolean}. If the type
	 * holds generic information, these are provided as well, i.e. a {@code HashMap} of
	 * String to Integer would be defined as {@code java.util.HashMap
	 * <java.lang.String,java.lang.Integer>}.
	 * <p>
	 * Note that this class may be a complex type that gets converted from a String as
	 * values are bound.
	 * @return the property type
	 */
	public String getType() {
		return this.type;
	}
	public void setType(String type) {
		this.type = type;
	}
	/**
	 * A description of the property, if any. Can be multi-lines.
	 * @return the property description
	 * @see #getShortDescription()
	 */
	public String getDescription() {
		return this.description;
	}
	public void setDescription(String description) {
		this.description = description;
	}
	/**
	 * A single-line, single-sentence description of this property, if any.
	 * @return the property short description
	 * @see #getDescription()
	 */
	public String getShortDescription() {
		return this.shortDescription;
	}
	public void setShortDescription(String shortDescription) {
		this.shortDescription = shortDescription;
	}
	/**
	 * The default value, if any.
	 * @return the default value
	 */
	public Object getDefaultValue() {
		return this.defaultValue;
	}
	public void setDefaultValue(Object defaultValue) {
		this.defaultValue = defaultValue;
	}
	/**
	 * Return the hints of this item.
	 * @return the hints
	 */
	public Hints getHints() {
		return this.hints;
	}
	/**
	 * The {@link Deprecation} for this property, if any.
	 * @return the deprecation
	 * @see #isDeprecated()
	 */
	public Deprecation getDeprecation() {
		return this.deprecation;
	}
	public void setDeprecation(Deprecation deprecation) {
		this.deprecation = deprecation;
	}
	/**
	 * Specify if the property is deprecated.
	 * @return if the property is deprecated
	 * @see #getDeprecation()
	 */
	public boolean isDeprecated() {
		return this.deprecation != null;
	}
}
/*
/**
package org.springframework.boot.configurationmetadata;
/*
package org.springframework.boot.configurationmetadata;
/**
@SuppressWarnings('serial')
public class ConfigurationMetadataSource implements Serializable {
	private String groupId;
	private String type;
	private String description;
	private String shortDescription;
	private String sourceType;
	private String sourceMethod;
	private final Map<String, ConfigurationMetadataProperty> properties = new HashMap<>();
	/**
	 * The identifier of the group to which this source is associated.
	 * @return the group id
	 */
	public String getGroupId() {
		return this.groupId;
	}
	void setGroupId(String groupId) {
		this.groupId = groupId;
	}
	/**
	 * The type of the source. Usually this is the fully qualified name of a class that
	 * defines configuration items. This class may or may not be available at runtime.
	 * @return the type
	 */
	public String getType() {
		return this.type;
	}
	void setType(String type) {
		this.type = type;
	}
	/**
	 * A description of this source, if any. Can be multi-lines.
	 * @return the description
	 * @see #getShortDescription()
	 */
	public String getDescription() {
		return this.description;
	}
	void setDescription(String description) {
		this.description = description;
	}
	/**
	 * A single-line, single-sentence description of this source, if any.
	 * @return the short description
	 * @see #getDescription()
	 */
	public String getShortDescription() {
		return this.shortDescription;
	}
	public void setShortDescription(String shortDescription) {
		this.shortDescription = shortDescription;
	}
	/**
	 * The type where this source is defined. This can be identical to the
	 * {@link #getType() type} if the source is self-defined.
	 * @return the source type
	 */
	public String getSourceType() {
		return this.sourceType;
	}
	void setSourceType(String sourceType) {
		this.sourceType = sourceType;
	}
	/**
	 * The method name that defines this source, if any.
	 * @return the source method
	 */
	public String getSourceMethod() {
		return this.sourceMethod;
	}
	void setSourceMethod(String sourceMethod) {
		this.sourceMethod = sourceMethod;
	}
	/**
	 * Return the properties defined by this source.
	 * @return the properties
	 */
	public Map<String, ConfigurationMetadataProperty> getProperties() {
		return this.properties;
	}
}
/*
package org.springframework.boot.configurationmetadata;
/**
class ConfigurationMetadataHint {
	private static final String KEY_SUFFIX = '.keys';
	private static final String VALUE_SUFFIX = '.values';
	private String id;
	private final List<ValueHint> valueHints = new ArrayList<>();
	private final List<ValueProvider> valueProviders = new ArrayList<>();
	boolean isMapKeyHints() {
		return (this.id != null && this.id.endsWith(KEY_SUFFIX));
	}
	boolean isMapValueHints() {
		return (this.id != null && this.id.endsWith(VALUE_SUFFIX));
	}
	String resolveId() {
		if (isMapKeyHints()) {
			return this.id.substring(0, this.id.length() - KEY_SUFFIX.length());
		}
		if (isMapValueHints()) {
			return this.id.substring(0, this.id.length() - VALUE_SUFFIX.length());
		}
		return this.id;
	}
	String getId() {
		return this.id;
	}
	void setId(String id) {
		this.id = id;
	}
	List<ValueHint> getValueHints() {
		return this.valueHints;
	}
	List<ValueProvider> getValueProviders() {
		return this.valueProviders;
	}
}
/*
package org.springframework.boot.testsupport.gradle.testkit;
/**
public class GradleBuildExtension implements BeforeEachCallback, AfterEachCallback {
	private static final Pattern GRADLE_VERSION_PATTERN = Pattern.compile('\\[Gradle .+]');
	private final Dsl dsl = Dsl.GROOVY;
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		GradleBuild gradleBuild = extractGradleBuild(context);
		gradleBuild.scriptProperty('parentRootDir', findParentRootDir().getAbsolutePath());
		URL scriptUrl = findDefaultScript(context);
		if (scriptUrl != null) {
			gradleBuild.script(scriptUrl.getFile());
		}
		URL settingsUrl = getSettings(context);
		if (settingsUrl != null) {
			gradleBuild.settings(settingsUrl.getFile());
		}
		gradleBuild.before();
	}
	private File findParentRootDir() {
		File dir = new File('').getAbsoluteFile();
		int depth = 0;
		while (dir != null && !hasGradleBuildFiles(dir)) {
			Assert.state(depth++ < 5, 'Unable to find parent root');
			dir = dir.getParentFile();
		}
		Assert.state(dir != null, 'Unable to find parent root');
		return dir;
	}
	private boolean hasGradleBuildFiles(File dir) {
		return new File(dir, 'settings.gradle').exists() && new File(dir, 'build.gradle').exists()
				&& new File(dir, 'gradle.properties').exists();
	}
	private GradleBuild extractGradleBuild(ExtensionContext context) throws Exception {
		Object testInstance = context.getRequiredTestInstance();
		Field gradleBuildField = ReflectionUtils.findField(testInstance.getClass(), 'gradleBuild');
		gradleBuildField.setAccessible(true);
		GradleBuild gradleBuild = (GradleBuild) gradleBuildField.get(testInstance);
		return gradleBuild;
	}
	private URL findDefaultScript(ExtensionContext context) {
		URL scriptUrl = getScriptForTestMethod(context);
		if (scriptUrl != null) {
			return scriptUrl;
		}
		return getScriptForTestClass(context.getRequiredTestClass());
	}
	private URL getScriptForTestMethod(ExtensionContext context) {
		Class<?> testClass = context.getRequiredTestClass();
		String name = testClass.getSimpleName() + '-' + removeGradleVersion(context.getRequiredTestMethod().getName())
				+ this.dsl.getExtension();
		return testClass.getResource(name);
	}
	private String removeGradleVersion(String methodName) {
		return GRADLE_VERSION_PATTERN.matcher(methodName).replaceAll('').trim();
	}
	private URL getScriptForTestClass(Class<?> testClass) {
		return testClass.getResource(testClass.getSimpleName() + this.dsl.getExtension());
	}
	private URL getSettings(ExtensionContext context) {
		Class<?> testClass = context.getRequiredTestClass();
		return testClass.getResource('settings.gradle');
	}
	@Override
	public void afterEach(ExtensionContext context) throws Exception {
		extractGradleBuild(context).after();
	}
}
/*
package org.springframework.boot.testsupport.gradle.testkit;
/**
public class GradleBuild {
	private final Dsl dsl;
	private File projectDir;
	private String script;
	private String settings;
	private String gradleVersion;
	private String springBootVersion = 'TEST-SNAPSHOT';
	private GradleVersion expectDeprecationWarnings;
	private final List<String> expectedDeprecationMessages = new ArrayList<>();
	private boolean configurationCache = false;
	private final Map<String, String> scriptProperties = new HashMap<>();
	public GradleBuild() {
		this(Dsl.GROOVY);
	}
	protected GradleBuild(Dsl dsl) {
		this.dsl = dsl;
	}
	public Dsl getDsl() {
		return this.dsl;
	}
	void before() throws IOException {
		this.projectDir = Files.createTempDirectory('gradle-').toFile();
	}
	void after() {
		this.script = null;
		FileSystemUtils.deleteRecursively(this.projectDir);
	}
	public GradleBuild script(String script) {
		this.script = script.endsWith(this.dsl.getExtension()) ? script : script + this.dsl.getExtension();
		return this;
	}
	public void settings(String settings) {
		this.settings = settings;
	}
	public GradleBuild expectDeprecationWarningsWithAtLeastVersion(String gradleVersion) {
		this.expectDeprecationWarnings = GradleVersion.version(gradleVersion);
		return this;
	}
	public GradleBuild expectDeprecationMessages(String... messages) {
		this.expectedDeprecationMessages.addAll(Arrays.asList(messages));
		return this;
	}
	public GradleBuild configurationCache() {
		this.configurationCache = true;
		return this;
	}
	public boolean isConfigurationCache() {
		return this.configurationCache;
	}
	public GradleBuild scriptProperty(String key, String value) {
		this.scriptProperties.put(key, value);
		return this;
	}
	public GradleBuild scriptPropertyFrom(File propertiesFile, String key) {
		this.scriptProperties.put(key, getProperty(propertiesFile, key));
		return this;
	}
	public boolean gradleVersionIsAtLeast(String version) {
		return GradleVersion.version(this.gradleVersion).compareTo(GradleVersion.version(version)) >= 0;
	}
	public BuildResult build(String... arguments) {
		try {
			BuildResult result = prepareRunner(arguments).build();
			if (this.expectDeprecationWarnings == null || (this.gradleVersion != null
					&& this.expectDeprecationWarnings.compareTo(GradleVersion.version(this.gradleVersion)) > 0)) {
				String buildOutput = result.getOutput();
				for (String message : this.expectedDeprecationMessages) {
					buildOutput = buildOutput.replaceAll(message, '');
				}
				assertThat(buildOutput).doesNotContainIgnoringCase('deprecated');
			}
			return result;
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	public BuildResult buildAndFail(String... arguments) {
		try {
			return prepareRunner(arguments).buildAndFail();
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	public GradleRunner prepareRunner(String... arguments) throws IOException {
		this.scriptProperties.put('bootVersion', getBootVersion());
		this.scriptProperties.put('dependencyManagementPluginVersion', getDependencyManagementPluginVersion());
		copyTransformedScript(this.script, new File(this.projectDir, 'build' + this.dsl.getExtension()));
		if (this.settings != null) {
			copyTransformedScript(this.settings, new File(this.projectDir, 'settings.gradle'));
		}
		File repository = new File('src/test/resources/repository');
		if (repository.exists()) {
			FileSystemUtils.copyRecursively(repository, new File(this.projectDir, 'repository'));
		}
		GradleRunner gradleRunner = GradleRunner.create().withProjectDir(this.projectDir);
		if (!this.configurationCache) {
			// See https://github.com/gradle/gradle/issues/14125
			gradleRunner.withDebug(true);
		}
		if (this.gradleVersion != null) {
			gradleRunner.withGradleVersion(this.gradleVersion);
		}
		gradleRunner.withTestKitDir(getTestKitDir());
		List<String> allArguments = new ArrayList<>();
		allArguments.add('-PbootVersion=' + getBootVersion());
		allArguments.add('--stacktrace');
		allArguments.addAll(Arrays.asList(arguments));
		allArguments.add('--warning-mode');
		allArguments.add('all');
		if (this.configurationCache) {
			allArguments.add('--configuration-cache');
		}
		return gradleRunner.withArguments(allArguments);
	}
	private void copyTransformedScript(String script, File destination) throws IOException {
		String scriptContent = FileCopyUtils.copyToString(new FileReader(script));
		for (Entry<String, String> property : this.scriptProperties.entrySet()) {
			scriptContent = scriptContent.replace('{' + property.getKey() + '}', property.getValue());
		}
		FileCopyUtils.copy(scriptContent, new FileWriter(destination));
	}
	private File getTestKitDir() {
		File temp = new File(System.getProperty('java.io.tmpdir'));
		String username = System.getProperty('user.name');
		String gradleVersion = (this.gradleVersion != null) ? this.gradleVersion : 'default';
		return new File(temp, '.gradle-test-kit-' + username + '-' + getBootVersion() + '-' + gradleVersion);
	}
	public File getProjectDir() {
		return this.projectDir;
	}
	public void setProjectDir(File projectDir) {
		this.projectDir = projectDir;
	}
	public GradleBuild gradleVersion(String version) {
		this.gradleVersion = version;
		return this;
	}
	public String getGradleVersion() {
		return this.gradleVersion;
	}
	public GradleBuild bootVersion(String version) {
		this.springBootVersion = version;
		return this;
	}
	private String getBootVersion() {
		return this.springBootVersion;
	}
	private static String getDependencyManagementPluginVersion() {
		try {
			URL location = DependencyManagementExtension.class.getProtectionDomain().getCodeSource().getLocation();
			try (JarFile jar = new JarFile(new File(location.toURI()))) {
				return jar.getManifest().getMainAttributes().getValue('Implementation-Version');
			}
		}
		catch (Exception ex) {
			throw new IllegalStateException('Failed to find dependency management plugin version', ex);
		}
	}
	private String getProperty(File propertiesFile, String key) {
		try {
			assertThat(propertiesFile)
				.withFailMessage('Expecting properties file to exist at path "%s"', propertiesFile.getCanonicalFile())
				.exists();
			Properties properties = new Properties();
			try (FileInputStream input = new FileInputStream(propertiesFile)) {
				properties.load(input);
				String value = properties.getProperty(key);
				assertThat(value)
					.withFailMessage('Expecting properties file "%s" to contain the key "%s"',
							propertiesFile.getCanonicalFile(), key)
					.isNotEmpty();
				return value;
			}
		}
		catch (IOException ex) {
			fail('Error reading properties file "' + propertiesFile + '"');
			return null;
		}
	}
}
/*
package org.springframework.boot.testsupport.gradle.testkit;
/**
public enum Dsl {
	/**
	 * Supported DSL variants.
	 */
	GROOVY('Groovy', '.gradle'), KOTLIN('Kotlin', '.gradle.kts');
	private final String name;
	private final String extension;
	Dsl(String name, String extension) {
		this.name = name;
		this.extension = extension;
	}
	public String getName() {
		return this.name;
	}
	String getExtension() {
		return this.extension;
	}
}
/*
/**
package org.springframework.boot.testsupport.gradle.testkit;
/*
package org.springframework.boot.testsupport.gradle.testkit;
/**
public final class GradleVersions {
	private GradleVersions() {
	}
	public static List<String> allCompatible() {
		if (isJavaVersion(JavaVersion.VERSION_23)) {
			return Arrays.asList(GradleVersion.current().getVersion());
		}
		if (isJavaVersion(JavaVersion.VERSION_22)) {
			return Arrays.asList('8.8', GradleVersion.current().getVersion());
		}
		if (isJavaVersion(JavaVersion.VERSION_21)) {
			return Arrays.asList('8.5', GradleVersion.current().getVersion());
		}
		return Arrays.asList('7.6.4', '8.4', GradleVersion.current().getVersion());
	}
	public static String minimumCompatible() {
		return allCompatible().get(0);
	}
	public static String maximumCompatible() {
		List<String> versions = allCompatible();
		return versions.get(versions.size() - 1);
	}
	private static boolean isJavaVersion(JavaVersion version) {
		return JavaVersion.current().isCompatibleWith(version);
	}
}
/*
package org.springframework.boot.context.properties.migrator;
/**
class PropertiesMigrationReporterTests {
	private final ConfigurableEnvironment environment = new MockEnvironment();
	@Test
	void reportIsNullWithNoMatchingKeys() {
		String report = createWarningReport(new SimpleConfigurationMetadataRepository());
		assertThat(report).isNull();
	}
	@Test
	void replacementKeysAreRemapped() throws IOException {
		MutablePropertySources propertySources = this.environment.getPropertySources();
		PropertySource<?> one = loadPropertySource('one', 'config/config-error.properties');
		PropertySource<?> two = loadPropertySource('two', 'config/config-warnings.properties');
		propertySources.addFirst(one);
		propertySources.addAfter('one', two);
		assertThat(propertySources).hasSize(3);
		createAnalyzer(loadRepository('metadata/sample-metadata.json')).getReport();
		assertThat(mapToNames(propertySources)).containsExactly('one', 'migrate-two', 'two', 'mockProperties');
		PropertySource<?> migrateTwo = propertySources.get('migrate-two');
		assertThat(migrateTwo).isNotNull();
		assertMappedProperty(migrateTwo, 'test.two', 'another', getOrigin(two, 'wrong.two'));
		assertMappedProperty(migrateTwo, 'custom.the-map-replacement.key', 'value',
				getOrigin(two, 'custom.map-with-replacement.key'));
	}
	@Test
	void warningReport() throws IOException {
		this.environment.getPropertySources().addFirst(loadPropertySource('test', 'config/config-warnings.properties'));
		this.environment.getPropertySources().addFirst(loadPropertySource('ignore', 'config/config-error.properties'));
		String report = createWarningReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).containsSubsequence('Property source "test"', 'Key: custom.map-with-replacement.key',
				'Line: 8', 'Replacement: custom.the-map-replacement.key', 'wrong.four.test', 'Line: 5',
				'test.four.test', 'wrong.two', 'Line: 2', 'test.two');
		assertThat(report).doesNotContain('wrong.one');
	}
	@Test
	void warningReportReplacedWithSameRelaxedName() throws IOException {
		this.environment.getPropertySources().addFirst(loadPropertySource('test', 'config/config-relaxed.properties'));
		String report = createWarningReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNull();
	}
	@Test
	void errorReport() throws IOException {
		this.environment.getPropertySources()
			.addFirst(loadPropertySource('test1', 'config/config-warnings.properties'));
		this.environment.getPropertySources().addFirst(loadPropertySource('test2', 'config/config-error.properties'));
		String report = createErrorReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).containsSubsequence('Property source "test2"', 'wrong.one', 'Line: 2',
				'This is no longer supported.');
		assertThat(report).doesNotContain('wrong.four.test').doesNotContain('wrong.two');
	}
	@Test
	void errorReportNoReplacement() throws IOException {
		this.environment.getPropertySources()
			.addFirst(loadPropertySource('first', 'config/config-error-no-replacement.properties'));
		this.environment.getPropertySources().addFirst(loadPropertySource('second', 'config/config-error.properties'));
		String report = createErrorReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).containsSubsequence('Property source "first"', 'wrong.three', 'Line: 6', 'none',
				'Property source "second"', 'wrong.one', 'Line: 2', 'This is no longer supported.');
		assertThat(report).doesNotContain('null').doesNotContain('server.port').doesNotContain('debug');
	}
	@Test
	void durationTypeIsHandledTransparently() {
		MutablePropertySources propertySources = this.environment.getPropertySources();
		Map<String, Object> content = new LinkedHashMap<>();
		content.put('test.cache-seconds', 50);
		content.put('test.time-to-live-ms', 1234L);
		content.put('test.ttl', 5678L);
		propertySources.addFirst(new MapPropertySource('test', content));
		assertThat(propertySources).hasSize(2);
		String report = createWarningReport(loadRepository('metadata/type-conversion-metadata.json'));
		assertThat(report).contains('Property source "test"', 'test.cache-seconds', 'test.cache',
				'test.time-to-live-ms', 'test.time-to-live', 'test.ttl', 'test.mapped.ttl');
		assertThat(mapToNames(propertySources)).containsExactly('migrate-test', 'test', 'mockProperties');
		PropertySource<?> propertySource = propertySources.get('migrate-test');
		assertThat(propertySource).isNotNull();
		assertMappedProperty(propertySource, 'test.cache', 50, null);
		assertMappedProperty(propertySource, 'test.time-to-live', 1234L, null);
		assertMappedProperty(propertySource, 'test.mapped.ttl', 5678L, null);
	}
	@Test
	void reasonIsProvidedIfPropertyCouldNotBeRenamed() throws IOException {
		this.environment.getPropertySources()
			.addFirst(loadPropertySource('test', 'config/config-error-no-compatible-type.properties'));
		String report = createErrorReport(loadRepository('metadata/type-conversion-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).containsSubsequence('Property source "test"', 'wrong.inconvertible', 'Line: 1',
				'Reason: Replacement key "test.inconvertible" uses an incompatible target type');
	}
	@Test
	void invalidReplacementHandled() throws IOException {
		this.environment.getPropertySources()
			.addFirst(loadPropertySource('first', 'config/config-error-invalid-replacement.properties'));
		String report = createErrorReport(loadRepository('metadata/sample-metadata-invalid-replacement.json'));
		assertThat(report).isNotNull();
		assertThat(report).containsSubsequence('Property source "first"', 'deprecated.six.test', 'Line: 1', 'Reason',
				'No metadata found for replacement key "does.not.exist"');
		assertThat(report).doesNotContain('null');
	}
	@Test
	void invalidNameHandledGracefully() {
		this.environment.getPropertySources()
			.addFirst(new MapPropertySource('first', Collections.singletonMap('invalid.property-name', 'value')));
		String report = createWarningReport(loadRepository('metadata/sample-metadata-invalid-name.json'));
		assertThat(report).isNotNull();
		assertThat(report).contains('Key: invalid.propertyname').contains('Replacement: valid.property-name');
	}
	@Test
	void mapPropertiesDeprecatedNoReplacement() {
		this.environment.getPropertySources()
			.addFirst(
					new MapPropertySource('first', Collections.singletonMap('custom.map-no-replacement.key', 'value')));
		String report = createErrorReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).contains('Key: custom.map-no-replacement.key')
			.contains('Reason: This is no longer supported.');
	}
	@Test
	void mapPropertiesDeprecatedWithReplacement() {
		this.environment.getPropertySources()
			.addFirst(new MapPropertySource('first',
					Collections.singletonMap('custom.map-with-replacement.key', 'value')));
		String report = createWarningReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).contains('Key: custom.map-with-replacement.key')
			.contains('Replacement: custom.the-map-replacement.key');
	}
	@Test
	void mapPropertiesDeprecatedWithReplacementRelaxedBindingUnderscore() {
		this.environment.getPropertySources()
			.addFirst(new MapPropertySource('first',
					Collections.singletonMap('custom.map_with_replacement.key', 'value')));
		String report = createWarningReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).contains('Key: custom.mapwithreplacement.key')
			.contains('Replacement: custom.the-map-replacement.key');
	}
	@Test
	void mapPropertiesDeprecatedWithReplacementRelaxedBindingCamelCase() {
		this.environment.getPropertySources()
			.addFirst(
					new MapPropertySource('first', Collections.singletonMap('custom.MapWithReplacement.key', 'value')));
		String report = createWarningReport(loadRepository('metadata/sample-metadata.json'));
		assertThat(report).isNotNull();
		assertThat(report).contains('Key: custom.mapwithreplacement.key')
			.contains('Replacement: custom.the-map-replacement.key');
	}
	@Test // gh-35919
	void directCircularReference() {
		this.environment.getPropertySources()
			.addFirst(new MapPropertySource('backcompat', Collections.singletonMap('wrong.two', '${test.two}')));
		createAnalyzer(loadRepository('metadata/sample-metadata.json')).getReport();
		assertThat(this.environment.getProperty('test.two')).isNull();
	}
	private List<String> mapToNames(PropertySources sources) {
		List<String> names = new ArrayList<>();
		for (PropertySource<?> source : sources) {
			names.add(source.getName());
		}
		return names;
	}
	@SuppressWarnings('unchecked')
	private Origin getOrigin(PropertySource<?> propertySource, String name) {
		return ((OriginLookup<String>) propertySource).getOrigin(name);
	}
	@SuppressWarnings('unchecked')
	private void assertMappedProperty(PropertySource<?> propertySource, String name, Object value, Origin origin) {
		assertThat(propertySource.containsProperty(name)).isTrue();
		assertThat(propertySource.getProperty(name)).isEqualTo(value);
		if (origin != null) {
			assertThat(propertySource).isInstanceOf(OriginLookup.class);
			Origin actualOrigin = ((OriginLookup<Object>) propertySource).getOrigin(name);
			if (actualOrigin instanceof PropertySourceOrigin propertySourceOrigin) {
				actualOrigin = propertySourceOrigin.getOrigin();
			}
			assertThat(actualOrigin).isEqualTo(origin);
		}
	}
	private PropertySource<?> loadPropertySource(String name, String path) throws IOException {
		ClassPathResource resource = new ClassPathResource(path);
		List<PropertySource<?>> propertySources = new PropertiesPropertySourceLoader().load(name, resource);
		assertThat(propertySources).isNotEmpty();
		return propertySources.get(0);
	}
	private ConfigurationMetadataRepository loadRepository(String... content) {
		try {
			ConfigurationMetadataRepositoryJsonBuilder builder = ConfigurationMetadataRepositoryJsonBuilder.create();
			for (String path : content) {
				Resource resource = new ClassPathResource(path);
				builder.withJsonResource(resource.getInputStream());
			}
			return builder.build();
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to load metadata', ex);
		}
	}
	private String createWarningReport(ConfigurationMetadataRepository repository) {
		return createAnalyzer(repository).getReport().getWarningReport();
	}
	private String createErrorReport(ConfigurationMetadataRepository repository) {
		return createAnalyzer(repository).getReport().getErrorReport();
	}
	private PropertiesMigrationReporter createAnalyzer(ConfigurationMetadataRepository repository) {
		return new PropertiesMigrationReporter(repository, this.environment);
	}
}
/*
package org.springframework.boot.context.properties.migrator;
/**
@ExtendWith(OutputCaptureExtension.class)
class PropertiesMigrationListenerTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void sampleReport(CapturedOutput output) {
		this.context = createSampleApplication().run('--logging.file=test.log');
		assertThat(output).contains('commandLineArgs')
			.contains('logging.file.name')
			.contains('Each configuration key has been temporarily mapped')
			.doesNotContain('Please refer to the release notes');
	}
	private SpringApplication createSampleApplication() {
		return new SpringApplication(TestApplication.class);
	}
	@Configuration(proxyBeanMethods = false)
	static class TestApplication {
	}
}
/*
package org.springframework.boot.context.properties.migrator;
/**
class PropertiesMigrationReporter {
	private final Map<String, ConfigurationMetadataProperty> allProperties;
	private final ConfigurableEnvironment environment;
	PropertiesMigrationReporter(ConfigurationMetadataRepository metadataRepository,
			ConfigurableEnvironment environment) {
		this.allProperties = Collections.unmodifiableMap(metadataRepository.getAllProperties());
		this.environment = environment;
	}
	/**
	 * Analyse the {@link ConfigurableEnvironment environment} and attempt to rename
	 * legacy properties if a replacement exists.
	 * @return a report of the migration
	 */
	PropertiesMigrationReport getReport() {
		PropertiesMigrationReport report = new PropertiesMigrationReport();
		Map<String, List<PropertyMigration>> properties = getPropertySourceMigrations(
				ConfigurationMetadataProperty::isDeprecated);
		if (properties.isEmpty()) {
			return report;
		}
		properties.forEach((name, candidates) -> {
			PropertySource<?> propertySource = mapPropertiesWithReplacement(report, name, candidates);
			if (propertySource != null) {
				this.environment.getPropertySources().addBefore(name, propertySource);
			}
		});
		return report;
	}
	private Map<String, List<PropertyMigration>> getPropertySourceMigrations(
			Predicate<ConfigurationMetadataProperty> filter) {
		return getPropertySourceMigrations(this.allProperties.values().stream().filter(filter).toList());
	}
	private Map<String, List<PropertyMigration>> getPropertySourceMigrations(
			List<ConfigurationMetadataProperty> metadataProperties) {
		MultiValueMap<String, PropertyMigration> result = new LinkedMultiValueMap<>();
		getPropertySourcesAsMap().forEach((propertySourceName, propertySource) -> {
			for (ConfigurationMetadataProperty metadataProperty : metadataProperties) {
				result.addAll(propertySourceName, getMigrations(propertySource, metadataProperty));
			}
		});
		return result;
	}
	private Map<String, ConfigurationPropertySource> getPropertySourcesAsMap() {
		Map<String, ConfigurationPropertySource> map = new LinkedHashMap<>();
		for (ConfigurationPropertySource source : ConfigurationPropertySources.get(this.environment)) {
			map.put(determinePropertySourceName(source), source);
		}
		return map;
	}
	private String determinePropertySourceName(ConfigurationPropertySource source) {
		if (source.getUnderlyingSource() instanceof PropertySource<?> underlyingSource) {
			return underlyingSource.getName();
		}
		return source.getUnderlyingSource().toString();
	}
	private List<PropertyMigration> getMigrations(ConfigurationPropertySource propertySource,
			ConfigurationMetadataProperty metadataProperty) {
		ConfigurationPropertyName propertyName = asConfigurationPropertyName(metadataProperty);
		List<PropertyMigration> migrations = new ArrayList<>();
		addMigration(propertySource, metadataProperty, propertyName, false, migrations);
		if (isMapType(metadataProperty) && propertySource instanceof IterableConfigurationPropertySource iterable) {
			iterable.stream()
				.filter(propertyName::isAncestorOf)
				.forEach((ancestorPropertyName) -> addMigration(propertySource, metadataProperty, ancestorPropertyName,
						true, migrations));
		}
		return migrations;
	}
	private ConfigurationPropertyName asConfigurationPropertyName(ConfigurationMetadataProperty metadataProperty) {
		return ConfigurationPropertyName.isValid(metadataProperty.getId())
				? ConfigurationPropertyName.of(metadataProperty.getId())
				: ConfigurationPropertyName.adapt(metadataProperty.getId(), ".");
	}
	private void addMigration(ConfigurationPropertySource propertySource,
			ConfigurationMetadataProperty metadataProperty, ConfigurationPropertyName propertyName,
			boolean mapMigration, List<PropertyMigration> migrations) {
		ConfigurationProperty property = propertySource.getConfigurationProperty(propertyName);
		if (property != null) {
			ConfigurationMetadataProperty replacement = determineReplacementMetadata(metadataProperty);
			if (replacement == null || !hasSameName(property, replacement)) {
				migrations.add(new PropertyMigration(property, metadataProperty, replacement, mapMigration));
			}
		}
	}
	private boolean hasSameName(ConfigurationProperty property, ConfigurationMetadataProperty replacement) {
		return (property.getOrigin() instanceof PropertySourceOrigin propertySourceOrigin)
				&& Objects.equals(propertySourceOrigin.getPropertyName(), replacement.getId());
	}
	private ConfigurationMetadataProperty determineReplacementMetadata(ConfigurationMetadataProperty metadata) {
		String replacementId = metadata.getDeprecation().getReplacement();
		if (StringUtils.hasText(replacementId)) {
			ConfigurationMetadataProperty replacement = this.allProperties.get(replacementId);
			if (replacement != null) {
				return replacement;
			}
			return detectMapValueReplacement(replacementId);
		}
		return null;
	}
	private ConfigurationMetadataProperty detectMapValueReplacement(String fullId) {
		int lastDot = fullId.lastIndexOf(".");
		if (lastDot == -1) {
			return null;
		}
		ConfigurationMetadataProperty metadata = this.allProperties.get(fullId.substring(0, lastDot));
		if (metadata != null && isMapType(metadata)) {
			return metadata;
		}
		return null;
	}
	private boolean isMapType(ConfigurationMetadataProperty property) {
		String type = property.getType();
		return type != null && type.startsWith(Map.class.getName());
	}
	private PropertySource<?> mapPropertiesWithReplacement(PropertiesMigrationReport report, String name,
			List<PropertyMigration> properties) {
		report.add(name, properties);
		List<PropertyMigration> renamed = properties.stream().filter(PropertyMigration::isCompatibleType).toList();
		if (renamed.isEmpty()) {
			return null;
		}
		NameTrackingPropertySource nameTrackingPropertySource = new NameTrackingPropertySource();
		this.environment.getPropertySources().addFirst(nameTrackingPropertySource);
		try {
			String target = 'migrate-' + name;
			Map<String, OriginTrackedValue> content = new LinkedHashMap<>();
			for (PropertyMigration candidate : renamed) {
				String newPropertyName = candidate.getNewPropertyName();
				Object value = candidate.getProperty().getValue();
				if (nameTrackingPropertySource.isPlaceholderThatAccessesName(value, newPropertyName)) {
					continue;
				}
				OriginTrackedValue originTrackedValue = OriginTrackedValue.of(value,
						candidate.getProperty().getOrigin());
				content.put(newPropertyName, originTrackedValue);
			}
			return new OriginTrackedMapPropertySource(target, content);
		}
		finally {
			this.environment.getPropertySources().remove(nameTrackingPropertySource.getName());
		}
	}
	/**
	 * {@link PropertySource} used to track accessed properties to protect against
	 * circular references.
	 */
	private class NameTrackingPropertySource extends PropertySource<Object> {
		private final Set<String> accessedNames = new HashSet<>();
		NameTrackingPropertySource() {
			super(NameTrackingPropertySource.class.getName());
		}
		boolean isPlaceholderThatAccessesName(Object value, String name) {
			if (value instanceof String) {
				this.accessedNames.clear();
				PropertiesMigrationReporter.this.environment.resolvePlaceholders((String) value);
				return this.accessedNames.contains(name);
			}
			return false;
		}
		@Override
		public Object getProperty(String name) {
			this.accessedNames.add(name);
			return null;
		}
	}
}
/*
package org.springframework.boot.context.properties.migrator;
/**
class PropertiesMigrationReport {
	private final Map<String, LegacyProperties> content = new LinkedHashMap<>();
	/**
	 * Return a report for all the properties that were automatically renamed. If no such
	 * properties were found, return {@code null}.
	 * @return a report with the configurations keys that should be renamed
	 */
	String getWarningReport() {
		Map<String, List<PropertyMigration>> content = getContent(LegacyProperties::getRenamed);
		if (content.isEmpty()) {
			return null;
		}
		StringBuilder report = new StringBuilder();
		report.append(String
			.format('%nThe use of configuration keys that have been renamed was found in the environment:%n%n'));
		append(report, content);
		report.append(String.format('%n'));
		report.append('Each configuration key has been temporarily mapped to its '
				+ 'replacement for your convenience. To silence this warning, please '
				+ 'update your configuration to use the new keys.');
		report.append(String.format('%n'));
		return report.toString();
	}
	/**
	 * Return a report for all the properties that are no longer supported. If no such
	 * properties were found, return {@code null}.
	 * @return a report with the configurations keys that are no longer supported
	 */
	String getErrorReport() {
		Map<String, List<PropertyMigration>> content = getContent(LegacyProperties::getUnsupported);
		if (content.isEmpty()) {
			return null;
		}
		StringBuilder report = new StringBuilder();
		report.append(String
			.format('%nThe use of configuration keys that are no longer supported was found in the environment:%n%n'));
		append(report, content);
		report.append(String.format('%n'));
		report.append('Please refer to the release notes or reference guide for potential alternatives.');
		report.append(String.format('%n'));
		return report.toString();
	}
	private Map<String, List<PropertyMigration>> getContent(
			Function<LegacyProperties, List<PropertyMigration>> extractor) {
		return this.content.entrySet()
			.stream()
			.filter((entry) -> !extractor.apply(entry.getValue()).isEmpty())
			.collect(
					Collectors.toMap(Map.Entry::getKey, (entry) -> new ArrayList<>(extractor.apply(entry.getValue()))));
	}
	private void append(StringBuilder report, Map<String, List<PropertyMigration>> content) {
		content.forEach((name, properties) -> {
			report.append(String.format('Property source "%s":%n', name));
			properties.sort(PropertyMigration.COMPARATOR);
			properties.forEach((property) -> {
				report.append(String.format('\tKey: %s%n', property.getProperty().getName()));
				if (property.getLineNumber() != null) {
					report.append(String.format('\t\tLine: %d%n', property.getLineNumber()));
				}
				report.append(String.format('\t\t%s%n', property.determineReason()));
			});
			report.append(String.format('%n'));
		});
	}
	/**
	 * Register a new property source.
	 * @param name the name of the property source
	 * @param properties the {@link PropertyMigration} instances
	 */
	void add(String name, List<PropertyMigration> properties) {
		this.content.put(name, new LegacyProperties(properties));
	}
	private static class LegacyProperties {
		private final List<PropertyMigration> properties;
		LegacyProperties(List<PropertyMigration> properties) {
			this.properties = new ArrayList<>(properties);
		}
		List<PropertyMigration> getRenamed() {
			return this.properties.stream().filter(PropertyMigration::isCompatibleType).toList();
		}
		List<PropertyMigration> getUnsupported() {
			return this.properties.stream().filter((property) -> !property.isCompatibleType()).toList();
		}
	}
}
/*
package org.springframework.boot.context.properties.migrator;
/**
class PropertiesMigrationListener implements ApplicationListener<SpringApplicationEvent> {
	private static final Log logger = LogFactory.getLog(PropertiesMigrationListener.class);
	private PropertiesMigrationReport report;
	private boolean reported;
	@Override
	public void onApplicationEvent(SpringApplicationEvent event) {
		if (event instanceof ApplicationPreparedEvent preparedEvent) {
			onApplicationPreparedEvent(preparedEvent);
		}
		if (event instanceof ApplicationReadyEvent || event instanceof ApplicationFailedEvent) {
			logLegacyPropertiesReport();
		}
	}
	private void onApplicationPreparedEvent(ApplicationPreparedEvent event) {
		ConfigurationMetadataRepository repository = loadRepository();
		PropertiesMigrationReporter reporter = new PropertiesMigrationReporter(repository,
				event.getApplicationContext().getEnvironment());
		this.report = reporter.getReport();
	}
	private ConfigurationMetadataRepository loadRepository() {
		try {
			return loadRepository(ConfigurationMetadataRepositoryJsonBuilder.create());
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to load metadata', ex);
		}
	}
	private ConfigurationMetadataRepository loadRepository(ConfigurationMetadataRepositoryJsonBuilder builder)
			throws IOException {
		Resource[] resources = new PathMatchingResourcePatternResolver()
			.getResources('classpath*:/META-INF/spring-configuration-metadata.json');
		for (Resource resource : resources) {
			try (InputStream inputStream = resource.getInputStream()) {
				builder.withJsonResource(inputStream);
			}
		}
		return builder.build();
	}
	private void logLegacyPropertiesReport() {
		if (this.report == null || this.reported) {
			return;
		}
		String warningReport = this.report.getWarningReport();
		if (warningReport != null) {
			logger.warn(warningReport);
		}
		String errorReport = this.report.getErrorReport();
		if (errorReport != null) {
			logger.error(errorReport);
		}
		this.reported = true;
	}
}
/*
/**
package org.springframework.boot.context.properties.migrator;
/*
package org.springframework.boot.context.properties.migrator;
/**
class PropertyMigration {
	public static final Comparator<PropertyMigration> COMPARATOR = Comparator
		.comparing((property) -> property.getMetadata().getId());
	private final ConfigurationProperty property;
	private final Integer lineNumber;
	private final ConfigurationMetadataProperty metadata;
	private final ConfigurationMetadataProperty replacementMetadata;
	/**
	 * Whether this migration happened from a map type.
	 */
	private final boolean mapMigration;
	private final boolean compatibleType;
	PropertyMigration(ConfigurationProperty property, ConfigurationMetadataProperty metadata,
			ConfigurationMetadataProperty replacementMetadata, boolean mapMigration) {
		this.property = property;
		this.lineNumber = determineLineNumber(property);
		this.metadata = metadata;
		this.replacementMetadata = replacementMetadata;
		this.mapMigration = mapMigration;
		this.compatibleType = determineCompatibleType(metadata, replacementMetadata);
	}
	private static Integer determineLineNumber(ConfigurationProperty property) {
		Origin origin = property.getOrigin();
		if (origin instanceof PropertySourceOrigin propertySourceOrigin) {
			origin = propertySourceOrigin.getOrigin();
		}
		if (origin instanceof TextResourceOrigin textOrigin) {
			if (textOrigin.getLocation() != null) {
				return textOrigin.getLocation().getLine() + 1;
			}
		}
		return null;
	}
	private static boolean determineCompatibleType(ConfigurationMetadataProperty metadata,
			ConfigurationMetadataProperty replacementMetadata) {
		String currentType = determineType(metadata);
		String replacementType = determineType(replacementMetadata);
		if (currentType == null || replacementType == null) {
			return false;
		}
		if (replacementType.equals(currentType)) {
			return true;
		}
		return replacementType.equals(Duration.class.getName())
				&& (currentType.equals(Long.class.getName()) || currentType.equals(Integer.class.getName()));
	}
	private static String determineType(ConfigurationMetadataProperty metadata) {
		if (metadata == null || metadata.getType() == null) {
			return null;
		}
		String candidate = metadata.getType();
		if (candidate.startsWith(Map.class.getName())) {
			int lastComma = candidate.lastIndexOf(",");
			if (lastComma != -1) {
				// Use Map value type
				return candidate.substring(lastComma + 1, candidate.length() - 1).trim();
			}
		}
		return candidate;
	}
	ConfigurationProperty getProperty() {
		return this.property;
	}
	Integer getLineNumber() {
		return this.lineNumber;
	}
	ConfigurationMetadataProperty getMetadata() {
		return this.metadata;
	}
	boolean isCompatibleType() {
		return this.compatibleType;
	}
	String getNewPropertyName() {
		if (this.mapMigration) {
			return getNewMapPropertyName(this.property, this.metadata, this.replacementMetadata).toString();
		}
		return this.metadata.getDeprecation().getReplacement();
	}
	String determineReason() {
		if (this.compatibleType) {
			return 'Replacement: ' + getNewPropertyName();
		}
		Deprecation deprecation = this.metadata.getDeprecation();
		if (StringUtils.hasText(deprecation.getShortReason())) {
			return 'Reason: ' + deprecation.getShortReason();
		}
		if (StringUtils.hasText(deprecation.getReplacement())) {
			if (this.replacementMetadata != null) {
				return String.format('Reason: Replacement key "%s" uses an incompatible target type',
						deprecation.getReplacement());
			}
			return String.format('Reason: No metadata found for replacement key "%s"', deprecation.getReplacement());
		}
		return 'Reason: none';
	}
	private static ConfigurationPropertyName getNewMapPropertyName(ConfigurationProperty property,
			ConfigurationMetadataProperty metadata, ConfigurationMetadataProperty replacement) {
		ConfigurationPropertyName oldName = property.getName();
		ConfigurationPropertyName oldPrefix = ConfigurationPropertyName.of(metadata.getId());
		Assert.state(oldPrefix.isAncestorOf(oldName),
				String.format('"%s" is not an ancestor of "%s"', oldPrefix, oldName));
		ConfigurationPropertyName newPrefix = ConfigurationPropertyName.of(replacement.getId());
		return newPrefix.append(oldName.subName(oldPrefix.getNumberOfElements()));
	}
}
/*
package org.springframework.boot.loader.tools.sample;
/**
@SomeApplication
public class AnnotatedClassWithMainMethod {
	public void run() {
		System.out.println('Hello World');
	}
	public static void main(String[] args) {
		new AnnotatedClassWithMainMethod().run();
	}
}
/*
package org.springframework.boot.loader.tools.sample;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface SomeApplication {
}
/*
package org.springframework.boot.loader.tools.sample;
/**
public class ClassWithMainMethod {
	public void run() {
		System.out.println('Hello World');
	}
	public static void main(String[] args) {
		new ClassWithMainMethod().run();
	}
}
/*
package org.springframework.boot.loader.tools.sample;
/**
public class ClassWithoutMainMethod {
}
/*
package org.springframework.boot.loader.tools;
/**
class DefaultTimeZoneOffsetTests {
	// gh-34424
	@Test
	void removeFromWithLongInDifferentTimeZonesReturnsSameValue() {
		long time = OffsetDateTime.of(2000, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).toInstant().toEpochMilli();
		TimeZone timeZone1 = TimeZone.getTimeZone('GMT');
		TimeZone timeZone2 = TimeZone.getTimeZone('GMT+8');
		TimeZone timeZone3 = TimeZone.getTimeZone('GMT-8');
		long result1 = new DefaultTimeZoneOffset(timeZone1).removeFrom(time);
		long result2 = new DefaultTimeZoneOffset(timeZone2).removeFrom(time);
		long result3 = new DefaultTimeZoneOffset(timeZone3).removeFrom(time);
		long dosTime1 = toDosTime(Calendar.getInstance(timeZone1), result1);
		long dosTime2 = toDosTime(Calendar.getInstance(timeZone2), result2);
		long dosTime3 = toDosTime(Calendar.getInstance(timeZone3), result3);
		assertThat(dosTime1).isEqualTo(dosTime2).isEqualTo(dosTime3);
	}
	@Test
	void removeFromWithFileTimeReturnsFileTime() {
		long time = OffsetDateTime.of(2000, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).toInstant().toEpochMilli();
		long result = new DefaultTimeZoneOffset(TimeZone.getTimeZone('GMT+8')).removeFrom(time);
		assertThat(result).isNotEqualTo(time).isEqualTo(946656000000L);
	}
	/**
	 * Identical functionality to package-private
	 * org.apache.commons.compress.archivers.zip.ZipUtil.toDosTime(Calendar, long, byte[],
	 * int) method used by {@link ZipArchiveOutputStream} to convert times.
	 * @param calendar the source calendar
	 * @param time the time to convert
	 * @return the DOS time
	 */
	private long toDosTime(Calendar calendar, long time) {
		calendar.setTimeInMillis(time);
		final int year = calendar.get(Calendar.YEAR);
		final int month = calendar.get(Calendar.MONTH) + 1;
		return ((year - 1980) << 25) | (month << 21) | (calendar.get(Calendar.DAY_OF_MONTH) << 16)
				| (calendar.get(Calendar.HOUR_OF_DAY) << 11) | (calendar.get(Calendar.MINUTE) << 5)
				| (calendar.get(Calendar.SECOND) >> 1);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
abstract class AbstractPackagerTests<P extends Packager> {
	protected static final Libraries NO_LIBRARIES = (callback) -> {
	};
	private static final long JAN_1_1980;
	static {
		Calendar calendar = Calendar.getInstance();
		calendar.set(1980, 0, 1, 0, 0, 0);
		calendar.set(Calendar.MILLISECOND, 0);
		JAN_1_1980 = calendar.getTime().getTime();
	}
	private static final long JAN_1_1985;
	static {
		Calendar calendar = Calendar.getInstance();
		calendar.set(1985, 0, 1, 0, 0, 0);
		calendar.set(Calendar.MILLISECOND, 0);
		JAN_1_1985 = calendar.getTime().getTime();
	}
	@TempDir
	File tempDir;
	protected TestJarFile testJarFile;
	@BeforeEach
	void setup() {
		this.testJarFile = new TestJarFile(this.tempDir);
	}
	@Test
	void specificMainClass() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		P packager = createPackager();
		packager.setMainClass('a.b.C');
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes().getValue('Main-Class'))
			.isEqualTo('org.springframework.boot.loader.launch.JarLauncher');
		assertThat(actualManifest.getMainAttributes().getValue('Start-Class')).isEqualTo('a.b.C');
		assertThat(hasPackagedLauncherClasses()).isTrue();
	}
	@Test
	void mainClassFromManifest() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue('Manifest-Version', '1.0');
		manifest.getMainAttributes().putValue('Main-Class', 'a.b.C');
		this.testJarFile.addManifest(manifest);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes().getValue('Main-Class'))
			.isEqualTo('org.springframework.boot.loader.launch.JarLauncher');
		assertThat(actualManifest.getMainAttributes().getValue('Start-Class')).isEqualTo('a.b.C');
		assertThat(hasPackagedLauncherClasses()).isTrue();
	}
	@Test
	void mainClassFound() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes().getValue('Main-Class'))
			.isEqualTo('org.springframework.boot.loader.launch.JarLauncher');
		assertThat(actualManifest.getMainAttributes().getValue('Start-Class')).isEqualTo('a.b.C');
		assertThat(hasPackagedLauncherClasses()).isTrue();
	}
	@Test
	void multipleMainClassFound() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/D.class', ClassWithMainMethod.class);
		P packager = createPackager();
		assertThatIllegalStateException().isThrownBy(() -> execute(packager, NO_LIBRARIES))
			.withMessageContaining('Unable to find a single main class from the following candidates [a.b.C, a.b.D]');
	}
	@Test
	void noMainClass() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		P packager = createPackager(this.testJarFile.getFile());
		assertThatIllegalStateException().isThrownBy(() -> execute(packager, NO_LIBRARIES))
			.withMessageContaining('Unable to find main class');
	}
	@Test
	void noMainClassAndLayoutIsNone() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		packager.setLayout(new Layouts.None());
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes().getValue('Main-Class')).isEqualTo('a.b.C');
		assertThat(hasPackagedLauncherClasses()).isFalse();
	}
	@Test
	void noMainClassAndLayoutIsNoneWithNoMain() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		P packager = createPackager();
		packager.setLayout(new Layouts.None());
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes().getValue('Main-Class')).isNull();
		assertThat(hasPackagedLauncherClasses()).isFalse();
	}
	@Test
	void nullLibraries() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		assertThatIllegalArgumentException().isThrownBy(() -> execute(packager, null))
			.withMessageContaining('Libraries must not be null');
	}
	@Test
	void libraries() throws Exception {
		TestJarFile libJar = new TestJarFile(this.tempDir);
		libJar.addClass('a/b/C.class', ClassWithoutMainMethod.class, JAN_1_1985);
		File libJarFile = libJar.getFile();
		File libJarFileToUnpack = libJar.getFile();
		File libNonJarFile = new File(this.tempDir, 'non-lib.jar');
		FileCopyUtils.copy(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 }, libNonJarFile);
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		this.testJarFile.addFile('BOOT-INF/lib/' + libJarFileToUnpack.getName(), libJarFileToUnpack);
		libJarFile.setLastModified(JAN_1_1980);
		P packager = createPackager();
		execute(packager, (callback) -> {
			callback.library(newLibrary(libJarFile, LibraryScope.COMPILE, false));
			callback.library(newLibrary(libJarFileToUnpack, LibraryScope.COMPILE, true));
			callback.library(newLibrary(libNonJarFile, LibraryScope.COMPILE, false));
		});
		assertThat(hasPackagedEntry('BOOT-INF/lib/' + libJarFile.getName())).isTrue();
		assertThat(hasPackagedEntry('BOOT-INF/lib/' + libJarFileToUnpack.getName())).isTrue();
		assertThat(hasPackagedEntry('BOOT-INF/lib/' + libNonJarFile.getName())).isFalse();
		ZipEntry entry = getPackagedEntry('BOOT-INF/lib/' + libJarFile.getName());
		assertThat(entry.getTime()).isEqualTo(JAN_1_1985);
		entry = getPackagedEntry('BOOT-INF/lib/' + libJarFileToUnpack.getName());
		assertThat(entry.getComment()).startsWith('UNPACK:');
		assertThat(entry.getComment()).hasSize(47);
	}
	@Test
	void classPathIndex() throws Exception {
		TestJarFile libJar1 = new TestJarFile(this.tempDir);
		libJar1.addClass('a/b/C.class', ClassWithoutMainMethod.class, JAN_1_1985);
		File libJarFile1 = libJar1.getFile();
		TestJarFile libJar2 = new TestJarFile(this.tempDir);
		libJar2.addClass('a/b/C.class', ClassWithoutMainMethod.class, JAN_1_1985);
		File libJarFile2 = libJar2.getFile();
		TestJarFile libJar3 = new TestJarFile(this.tempDir);
		libJar3.addClass('a/b/C.class', ClassWithoutMainMethod.class, JAN_1_1985);
		File libJarFile3 = libJar3.getFile();
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		File file = this.testJarFile.getFile();
		P packager = createPackager(file);
		packager.setIncludeRelevantJarModeJars(false);
		execute(packager, (callback) -> {
			callback.library(newLibrary(libJarFile1, LibraryScope.COMPILE, false));
			callback.library(newLibrary(libJarFile2, LibraryScope.COMPILE, false));
			callback.library(newLibrary(libJarFile3, LibraryScope.COMPILE, false));
		});
		assertThat(hasPackagedEntry('BOOT-INF/classpath.idx')).isTrue();
		String index = getPackagedEntryContent('BOOT-INF/classpath.idx');
		String[] libraries = index.split('\\r?\\n');
		List<String> expected = Stream.of(libJarFile1, libJarFile2, libJarFile3)
			.map((jar) -> '- \'BOOT-INF/lib/' + jar.getName() + '\'')
			.toList();
		assertThat(Arrays.asList(libraries)).containsExactlyElementsOf(expected);
	}
	@Test
	void layersIndex() throws Exception {
		TestJarFile libJar1 = new TestJarFile(this.tempDir);
		libJar1.addClass('a/b/C.class', ClassWithoutMainMethod.class, JAN_1_1985);
		File libJarFile1 = libJar1.getFile();
		TestJarFile libJar2 = new TestJarFile(this.tempDir);
		libJar2.addClass('a/b/C.class', ClassWithoutMainMethod.class, JAN_1_1985);
		File libJarFile2 = libJar2.getFile();
		TestJarFile libJar3 = new TestJarFile(this.tempDir);
		libJar3.addClass('a/b/C.class', ClassWithoutMainMethod.class, JAN_1_1985);
		File libJarFile3 = libJar3.getFile();
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		TestLayers layers = new TestLayers();
		layers.addLibrary(libJarFile1, '0001');
		layers.addLibrary(libJarFile2, '0002');
		layers.addLibrary(libJarFile3, '0003');
		packager.setLayers(layers);
		packager.setIncludeRelevantJarModeJars(false);
		execute(packager, (callback) -> {
			callback.library(newLibrary(libJarFile1, LibraryScope.COMPILE, false));
			callback.library(newLibrary(libJarFile2, LibraryScope.COMPILE, false));
			callback.library(newLibrary(libJarFile3, LibraryScope.COMPILE, false));
		});
		assertThat(hasPackagedEntry('BOOT-INF/classpath.idx')).isTrue();
		String classpathIndex = getPackagedEntryContent('BOOT-INF/classpath.idx');
		List<String> expectedClasspathIndex = Stream.of(libJarFile1, libJarFile2, libJarFile3)
			.map((file) -> '- \'BOOT-INF/lib/' + file.getName() + '\'')
			.toList();
		assertThat(Arrays.asList(classpathIndex.split('\\n'))).containsExactlyElementsOf(expectedClasspathIndex);
		assertThat(hasPackagedEntry('BOOT-INF/layers.idx')).isTrue();
		String layersIndex = getPackagedEntryContent('BOOT-INF/layers.idx');
		List<String> expectedLayers = new ArrayList<>();
		expectedLayers.add('- "default":');
		expectedLayers.add('  - "BOOT-INF/classes/"');
		expectedLayers.add('  - "BOOT-INF/classpath.idx"');
		expectedLayers.add('  - "BOOT-INF/layers.idx"');
		expectedLayers.add('  - "META-INF/"');
		expectedLayers.add('  - "org/"');
		expectedLayers.add('- "0001":');
		expectedLayers.add('  - "BOOT-INF/lib/' + libJarFile1.getName() + '"');
		expectedLayers.add('- "0002":');
		expectedLayers.add('  - "BOOT-INF/lib/' + libJarFile2.getName() + '"');
		expectedLayers.add('- "0003":');
		expectedLayers.add('  - "BOOT-INF/lib/' + libJarFile3.getName() + '"');
		assertThat(layersIndex.split('\\n'))
			.containsExactly(expectedLayers.stream().map((s) -> s.replace("\"", "'")).toArray(String[]::new));
	}
	@Test
	void layersEnabledAddJarModeJar() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		TestLayers layers = new TestLayers();
		packager.setLayers(layers);
		execute(packager, Libraries.NONE);
		assertThat(hasPackagedEntry('BOOT-INF/classpath.idx')).isTrue();
		String classpathIndex = getPackagedEntryContent('BOOT-INF/classpath.idx');
		assertThat(Arrays.asList(classpathIndex.split('\\n')))
			.containsExactly('- \'BOOT-INF/lib/spring-boot-jarmode-tools.jar\'');
		assertThat(hasPackagedEntry('BOOT-INF/layers.idx')).isTrue();
		String layersIndex = getPackagedEntryContent('BOOT-INF/layers.idx');
		List<String> expectedLayers = new ArrayList<>();
		expectedLayers.add('- "default":');
		expectedLayers.add('  - "BOOT-INF/"');
		expectedLayers.add('  - "META-INF/"');
		expectedLayers.add('  - "org/"');
		assertThat(layersIndex.split('\\n'))
			.containsExactly(expectedLayers.stream().map((s) -> s.replace("\"", "'")).toArray(String[]::new));
	}
	@Test
	void duplicateLibraries() throws Exception {
		TestJarFile libJar = new TestJarFile(this.tempDir);
		libJar.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		File libJarFile = libJar.getFile();
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		assertThatIllegalStateException().isThrownBy(() -> execute(packager, (callback) -> {
			callback.library(newLibrary(libJarFile, LibraryScope.COMPILE, false));
			callback.library(newLibrary(libJarFile, LibraryScope.COMPILE, false));
		})).withMessageContaining('Duplicate library');
	}
	@Test
	void customLayout() throws Exception {
		TestJarFile libJar = new TestJarFile(this.tempDir);
		libJar.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		File libJarFile = libJar.getFile();
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		Layout layout = mock(Layout.class);
		LibraryScope scope = mock(LibraryScope.class);
		given(layout.getLauncherClassName()).willReturn('testLauncher');
		given(layout.getLibraryLocation(anyString(), eq(scope))).willReturn('test/');
		given(layout.getLibraryLocation(anyString(), eq(LibraryScope.COMPILE))).willReturn('test-lib/');
		packager.setLayout(layout);
		execute(packager, (callback) -> callback.library(newLibrary(libJarFile, scope, false)));
		assertThat(hasPackagedEntry('test/' + libJarFile.getName())).isTrue();
		assertThat(getPackagedManifest().getMainAttributes().getValue('Spring-Boot-Lib')).isEqualTo('test-lib/');
		assertThat(getPackagedManifest().getMainAttributes().getValue('Main-Class')).isEqualTo('testLauncher');
	}
	@Test
	void customLayoutNoBootLib() throws Exception {
		TestJarFile libJar = new TestJarFile(this.tempDir);
		libJar.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		File libJarFile = libJar.getFile();
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		Layout layout = mock(Layout.class);
		LibraryScope scope = mock(LibraryScope.class);
		given(layout.getLauncherClassName()).willReturn('testLauncher');
		packager.setLayout(layout);
		execute(packager, (callback) -> callback.library(newLibrary(libJarFile, scope, false)));
		assertThat(getPackagedManifest().getMainAttributes().getValue('Spring-Boot-Lib')).isNull();
		assertThat(getPackagedManifest().getMainAttributes().getValue('Main-Class')).isEqualTo('testLauncher');
	}
	@Test
	void springBootVersion() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes()).containsKey(new Attributes.Name('Spring-Boot-Version'));
	}
	@Test
	void executableJarLayoutAttributes() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes()).containsEntry(new Attributes.Name('Spring-Boot-Lib'),
				'BOOT-INF/lib/');
		assertThat(actualManifest.getMainAttributes()).containsEntry(new Attributes.Name('Spring-Boot-Classes'),
				'BOOT-INF/classes/');
	}
	@Test
	void executableWarLayoutAttributes() throws Exception {
		this.testJarFile.addClass('WEB-INF/classes/a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager(this.testJarFile.getFile('war'));
		execute(packager, NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes()).containsEntry(new Attributes.Name('Spring-Boot-Lib'),
				'WEB-INF/lib/');
		assertThat(actualManifest.getMainAttributes()).containsEntry(new Attributes.Name('Spring-Boot-Classes'),
				'WEB-INF/classes/');
	}
	@Test
	void nullCustomLayout() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		Packager packager = createPackager();
		assertThatIllegalArgumentException().isThrownBy(() -> packager.setLayout(null))
			.withMessageContaining('Layout must not be null');
	}
	@Test
	void dontRecompressZips() throws Exception {
		TestJarFile nested = new TestJarFile(this.tempDir);
		nested.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		File nestedFile = nested.getFile();
		this.testJarFile.addFile('test/nested.jar', nestedFile);
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		P packager = createPackager();
		execute(packager, (callback) -> callback.library(newLibrary(nestedFile, LibraryScope.COMPILE, false)));
		assertThat(getPackagedEntry('BOOT-INF/lib/' + nestedFile.getName()).getMethod()).isZero();
		assertThat(getPackagedEntry('BOOT-INF/classes/test/nested.jar').getMethod()).isZero();
	}
	@Test
	void unpackLibrariesTakePrecedenceOverExistingSourceEntries() throws Exception {
		TestJarFile nested = new TestJarFile(this.tempDir);
		nested.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		File nestedFile = nested.getFile();
		String name = 'BOOT-INF/lib/' + nestedFile.getName();
		this.testJarFile.addFile(name, nested.getFile());
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		P packager = createPackager();
		execute(packager, (callback) -> callback.library(newLibrary(nestedFile, LibraryScope.COMPILE, true)));
		assertThat(getPackagedEntry(name).getComment()).startsWith('UNPACK:');
	}
	@Test
	void existingSourceEntriesTakePrecedenceOverStandardLibraries() throws Exception {
		TestJarFile nested = new TestJarFile(this.tempDir);
		nested.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		File nestedFile = nested.getFile();
		this.testJarFile.addFile('BOOT-INF/lib/' + nestedFile.getName(), nested.getFile());
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		P packager = createPackager();
		long sourceLength = nestedFile.length();
		execute(packager, (callback) -> {
			nestedFile.delete();
			File toZip = new File(this.tempDir, 'to-zip');
			toZip.createNewFile();
			ZipUtil.packEntry(toZip, nestedFile);
			callback.library(newLibrary(nestedFile, LibraryScope.COMPILE, false));
		});
		assertThat(getPackagedEntry('BOOT-INF/lib/' + nestedFile.getName()).getSize()).isEqualTo(sourceLength);
	}
	@Test
	void metaInfIndexListIsRemovedFromRepackagedJar() throws Exception {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		File indexList = new File(this.tempDir, 'INDEX.LIST');
		indexList.createNewFile();
		this.testJarFile.addFile('META-INF/INDEX.LIST', indexList);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedEntry('META-INF/INDEX.LIST')).isNull();
	}
	@Test
	void customLayoutFactoryWithoutLayout() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		packager.setLayoutFactory(new TestLayoutFactory());
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedEntry('test')).isNotNull();
	}
	@Test
	void customLayoutFactoryWithLayout() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		packager.setLayoutFactory(new TestLayoutFactory());
		packager.setLayout(new Layouts.Jar());
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedEntry('test')).isNull();
	}
	@Test
	void metaInfAopXmlIsMovedBeneathBootInfClassesWhenRepackaged() throws Exception {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		File aopXml = new File(this.tempDir, 'aop.xml');
		aopXml.createNewFile();
		this.testJarFile.addFile('META-INF/aop.xml', aopXml);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedEntry('META-INF/aop.xml')).isNull();
		assertThat(getPackagedEntry('BOOT-INF/classes/META-INF/aop.xml')).isNotNull();
	}
	@Test
	void metaInfServicesFilesAreMovedBeneathBootInfClassesWhenRepackaged() throws Exception {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		File service = new File(this.tempDir, 'com.example.Service');
		service.createNewFile();
		this.testJarFile.addFile('META-INF/services/com.example.Service', service);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedEntry('META-INF/services/com.example.Service')).isNull();
		assertThat(getPackagedEntry('BOOT-INF/classes/META-INF/services/com.example.Service')).isNotNull();
	}
	@Test
	void allEntriesUseUnixPlatformAndUtf8NameEncoding() throws IOException {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		for (ZipArchiveEntry entry : getAllPackagedEntries()) {
			assertThat(entry.getPlatform()).isEqualTo(ZipArchiveEntry.PLATFORM_UNIX);
			assertThat(entry.getGeneralPurposeBit().usesUTF8ForNames()).isTrue();
		}
	}
	@Test
	void loaderIsWrittenFirstThenApplicationClassesThenLibraries() throws IOException {
		this.testJarFile.addClass('com/example/Application.class', ClassWithMainMethod.class);
		File libraryOne = createLibraryJar();
		File libraryTwo = createLibraryJar();
		File libraryThree = createLibraryJar();
		P packager = createPackager();
		execute(packager, (callback) -> {
			callback.library(newLibrary(libraryOne, LibraryScope.COMPILE, false));
			callback.library(newLibrary(libraryTwo, LibraryScope.COMPILE, true));
			callback.library(newLibrary(libraryThree, LibraryScope.COMPILE, false));
		});
		assertThat(getPackagedEntryNames()).containsSubsequence('org/springframework/boot/loader/',
				'BOOT-INF/classes/com/example/Application.class', 'BOOT-INF/lib/' + libraryOne.getName(),
				'BOOT-INF/lib/' + libraryTwo.getName(), 'BOOT-INF/lib/' + libraryThree.getName());
	}
	@Test
	void existingEntryThatMatchesUnpackLibraryIsMarkedForUnpack() throws IOException {
		File library = createLibraryJar();
		this.testJarFile.addClass('WEB-INF/classes/com/example/Application.class', ClassWithMainMethod.class);
		this.testJarFile.addFile('WEB-INF/lib/' + library.getName(), library);
		P packager = createPackager(this.testJarFile.getFile('war'));
		packager.setLayout(new Layouts.War());
		execute(packager, (callback) -> callback.library(newLibrary(library, LibraryScope.COMPILE, true)));
		assertThat(getPackagedEntryNames()).containsSubsequence('org/springframework/boot/loader/',
				'WEB-INF/classes/com/example/Application.class', 'WEB-INF/lib/' + library.getName());
		ZipEntry unpackLibrary = getPackagedEntry('WEB-INF/lib/' + library.getName());
		assertThat(unpackLibrary.getComment()).startsWith('UNPACK:');
	}
	@Test
	void layoutCanOmitLibraries() throws IOException {
		TestJarFile libJar = new TestJarFile(this.tempDir);
		libJar.addClass('a/b/C.class', ClassWithoutMainMethod.class);
		File libJarFile = libJar.getFile();
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		P packager = createPackager();
		Layout layout = mock(Layout.class);
		LibraryScope scope = mock(LibraryScope.class);
		packager.setLayout(layout);
		execute(packager, (callback) -> callback.library(newLibrary(libJarFile, scope, false)));
		assertThat(getPackagedEntryNames()).containsExactly('META-INF/', 'META-INF/MANIFEST.MF', 'a/', 'a/b/',
				'a/b/C.class');
	}
	@Test
	void jarThatUsesCustomCompressionConfigurationCanBeRepackaged() throws IOException {
		File source = new File(this.tempDir, 'source.jar');
		ZipOutputStream output = new ZipOutputStream(new FileOutputStream(source)) {
			{
				this.def = new Deflater(Deflater.NO_COMPRESSION, true);
			}
		};
		byte[] data = new byte[1024 * 1024];
		new Random().nextBytes(data);
		ZipEntry entry = new ZipEntry('entry.dat');
		output.putNextEntry(entry);
		output.write(data);
		output.closeEntry();
		output.close();
		P packager = createPackager(source);
		packager.setMainClass('com.example.Main');
		execute(packager, NO_LIBRARIES);
	}
	@Test
	void moduleInfoClassRemainsInRootOfJarWhenRepackaged() throws Exception {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('module-info.class', ClassWithoutMainMethod.class);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedEntry('module-info.class')).isNotNull();
		assertThat(getPackagedEntry('BOOT-INF/classes/module-info.class')).isNull();
	}
	@Test
	void kotlinModuleMetadataMovesBeneathBootInfClassesWhenRepackaged() throws Exception {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		File kotlinModule = new File(this.tempDir, 'test.kotlin_module');
		kotlinModule.createNewFile();
		this.testJarFile.addFile('META-INF/test.kotlin_module', kotlinModule);
		P packager = createPackager();
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedEntry('META-INF/test.kotlin_module')).isNull();
		assertThat(getPackagedEntry('BOOT-INF/classes/META-INF/test.kotlin_module')).isNotNull();
	}
	@Test
	void entryFiltering() throws Exception {
		File webLibrary = createLibraryJar();
		File libraryOne = createLibraryJar();
		File libraryTwo = createLibraryJar();
		this.testJarFile.addClass('WEB-INF/classes/com/example/Application.class', ClassWithMainMethod.class);
		this.testJarFile.addFile('WEB-INF/lib/' + webLibrary.getName(), webLibrary);
		P packager = createPackager(this.testJarFile.getFile('war'));
		packager.setIncludeRelevantJarModeJars(false);
		packager.setLayout(new Layouts.War());
		execute(packager, (callback) -> {
			callback.library(newLibrary(webLibrary, LibraryScope.COMPILE, false, false));
			callback.library(newLibrary(libraryOne, LibraryScope.COMPILE, false, false));
			callback.library(newLibrary(libraryTwo, LibraryScope.COMPILE, false, true));
		});
		Collection<String> packagedEntryNames = getPackagedEntryNames();
		packagedEntryNames.removeIf((name) -> !name.endsWith('.jar'));
		assertThat(packagedEntryNames).containsExactly('WEB-INF/lib/' + libraryTwo.getName());
	}
	@Test
	void nativeImageArgFileWithExcludesIsWritten() throws Exception {
		this.testJarFile.addClass('com/example/Application.class', ClassWithMainMethod.class);
		File libraryOne = createLibraryJar();
		File libraryTwo = createLibraryJar();
		File libraryThree = createLibraryJar();
		File libraryFour = createLibraryJar();
		this.testJarFile.addFile('META-INF/native-image/com.example.one/lib-one/123/reachability-metadata.properties',
				new ByteArrayInputStream('override=true\n'.getBytes(StandardCharsets.ISO_8859_1)));
		this.testJarFile.addFile('META-INF/native-image/com.example.two/lib-two/123/reachability-metadata.properties',
				new ByteArrayInputStream('override=true\n'.getBytes(StandardCharsets.ISO_8859_1)));
		this.testJarFile.addFile(
				'META-INF/native-image/com.example.three/lib-three/123/reachability-metadata.properties',
				new ByteArrayInputStream('other=test\n'.getBytes(StandardCharsets.ISO_8859_1)));
		P packager = createPackager(this.testJarFile.getFile());
		execute(packager, (callback) -> {
			callback.library(new Library(null, libraryOne, LibraryScope.COMPILE,
					LibraryCoordinates.of('com.example.one', 'lib-one', '123'), false, false, true));
			callback.library(new Library(null, libraryTwo, LibraryScope.COMPILE,
					LibraryCoordinates.of('com.example.two', 'lib-two', '123'), false, false, true));
			callback.library(new Library(null, libraryThree, LibraryScope.COMPILE,
					LibraryCoordinates.of('com.example.three', 'lib-three', '123'), false, false, true));
			callback.library(new Library(null, libraryFour, LibraryScope.COMPILE,
					LibraryCoordinates.of('com.example.four', 'lib-four', '123'), false, false, true));
		});
		List<String> expected = new ArrayList<>();
		expected.add('--exclude-config');
		expected.add('\\Q' + libraryOne.getName() + '\\E');
		expected.add('^/META-INF/native-image/.*');
		expected.add('--exclude-config');
		expected.add('\\Q' + libraryTwo.getName() + '\\E');
		expected.add('^/META-INF/native-image/.*');
		assertThat(getPackagedEntryContent('META-INF/native-image/argfile'))
			.isEqualTo(String.join('\n', expected) + '\n');
	}
	@Test
	void sbomManifestEntriesAreWritten() throws IOException {
		this.testJarFile.addClass('com/example/Application.class', ClassWithMainMethod.class);
		this.testJarFile.addFile('META-INF/sbom/application.cdx.json', new ByteArrayInputStream(new byte[0]));
		P packager = createPackager(this.testJarFile.getFile());
		execute(packager, NO_LIBRARIES);
		assertThat(getPackagedManifest().getMainAttributes().getValue('Sbom-Format')).isEqualTo('CycloneDX');
		assertThat(getPackagedManifest().getMainAttributes().getValue('Sbom-Location'))
			.isEqualTo('META-INF/sbom/application.cdx.json');
	}
	private File createLibraryJar() throws IOException {
		TestJarFile library = new TestJarFile(this.tempDir);
		library.addClass('com/example/library/Library.class', ClassWithoutMainMethod.class);
		return library.getFile();
	}
	protected Library newLibrary(File file, LibraryScope scope, boolean unpackRequired) {
		return new Library(null, file, scope, null, unpackRequired, false, true);
	}
	private Library newLibrary(File file, LibraryScope scope, boolean unpackRequired, boolean included) {
		return new Library(null, file, scope, null, unpackRequired, false, included);
	}
	protected final P createPackager() {
		return createPackager(this.testJarFile.getFile());
	}
	protected abstract P createPackager(File source);
	protected abstract void execute(P packager, Libraries libraries) throws IOException;
	protected Collection<String> getPackagedEntryNames() throws IOException {
		return getAllPackagedEntries().stream()
			.map(ZipArchiveEntry::getName)
			.collect(Collectors.toCollection(ArrayList::new));
	}
	protected boolean hasPackagedLauncherClasses() throws IOException {
		return hasPackagedEntry('org/springframework/boot/')
				&& hasPackagedEntry('org/springframework/boot/loader/launch/JarLauncher.class');
	}
	protected boolean hasPackagedEntry(String name) throws IOException {
		return getPackagedEntry(name) != null;
	}
	protected ZipEntry getPackagedEntry(String name) throws IOException {
		return getAllPackagedEntries().stream()
			.filter((entry) -> name.equals(entry.getName()))
			.findFirst()
			.orElse(null);
	}
	protected abstract Collection<ZipArchiveEntry> getAllPackagedEntries() throws IOException;
	protected abstract Manifest getPackagedManifest() throws IOException;
	protected abstract String getPackagedEntryContent(String name) throws IOException;
	static class TestLayoutFactory implements LayoutFactory {
		@Override
		public Layout getLayout(File source) {
			return new TestLayout();
		}
	}
	static class TestLayout extends Layouts.Jar implements CustomLoaderLayout {
		@Override
		public void writeLoadedClasses(LoaderClassesWriter writer) throws IOException {
			writer.writeEntry('test', new ByteArrayInputStream('test'.getBytes()));
		}
	}
	static class TestLayers implements Layers {
		private static final Layer DEFAULT_LAYER = new Layer('default');
		private final Set<Layer> layers = new LinkedHashSet<>();
		private final Map<String, Layer> libraries = new HashMap<>();
		TestLayers() {
			this.layers.add(DEFAULT_LAYER);
		}
		void addLibrary(File jarFile, String layerName) {
			Layer layer = new Layer(layerName);
			this.layers.add(layer);
			this.libraries.put(jarFile.getName(), layer);
		}
		@Override
		public Iterator<Layer> iterator() {
			return this.layers.iterator();
		}
		@Override
		public Stream<Layer> stream() {
			return this.layers.stream();
		}
		@Override
		public Layer getLayer(String name) {
			return DEFAULT_LAYER;
		}
		@Override
		public Layer getLayer(Library library) {
			String name = new File(library.getName()).getName();
			return this.libraries.getOrDefault(name, DEFAULT_LAYER);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class ImagePackagerTests extends AbstractPackagerTests<ImagePackager> {
	private Map<ZipArchiveEntry, byte[]> entries;
	@Override
	protected ImagePackager createPackager(File source) {
		return new ImagePackager(source, null);
	}
	@Override
	protected void execute(ImagePackager packager, Libraries libraries) throws IOException {
		this.entries = new LinkedHashMap<>();
		packager.packageImage(libraries, this::save);
	}
	private void save(ZipEntry entry, EntryWriter writer) {
		try {
			this.entries.put((ZipArchiveEntry) entry, getContent(writer));
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private byte[] getContent(EntryWriter writer) throws IOException {
		if (writer == null) {
			return null;
		}
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		writer.write(outputStream);
		return outputStream.toByteArray();
	}
	@Override
	protected Collection<ZipArchiveEntry> getAllPackagedEntries() throws IOException {
		return this.entries.keySet();
	}
	@Override
	protected Manifest getPackagedManifest() throws IOException {
		byte[] bytes = getEntryBytes('META-INF/MANIFEST.MF');
		return (bytes != null) ? new Manifest(new ByteArrayInputStream(bytes)) : null;
	}
	@Override
	protected String getPackagedEntryContent(String name) throws IOException {
		byte[] bytes = getEntryBytes(name);
		return (bytes != null) ? new String(bytes, StandardCharsets.UTF_8) : null;
	}
	private byte[] getEntryBytes(String name) throws IOException {
		ZipEntry entry = getPackagedEntry(name);
		return (entry != null) ? this.entries.get(entry) : null;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class FileUtilsTests {
	@TempDir
	File tempDir;
	private File outputDirectory;
	private File originDirectory;
	@BeforeEach
	void init() {
		this.outputDirectory = new File(this.tempDir, 'remove');
		this.originDirectory = new File(this.tempDir, 'keep');
		this.outputDirectory.mkdirs();
		this.originDirectory.mkdirs();
	}
	@Test
	void simpleDuplicateFile() throws IOException {
		File file = new File(this.outputDirectory, 'logback.xml');
		file.createNewFile();
		new File(this.originDirectory, 'logback.xml').createNewFile();
		FileUtils.removeDuplicatesFromOutputDirectory(this.outputDirectory, this.originDirectory);
		assertThat(file).doesNotExist();
	}
	@Test
	void nestedDuplicateFile() throws IOException {
		assertThat(new File(this.outputDirectory, 'sub').mkdirs()).isTrue();
		assertThat(new File(this.originDirectory, 'sub').mkdirs()).isTrue();
		File file = new File(this.outputDirectory, 'sub/logback.xml');
		file.createNewFile();
		new File(this.originDirectory, 'sub/logback.xml').createNewFile();
		FileUtils.removeDuplicatesFromOutputDirectory(this.outputDirectory, this.originDirectory);
		assertThat(file).doesNotExist();
	}
	@Test
	void nestedNonDuplicateFile() throws IOException {
		assertThat(new File(this.outputDirectory, 'sub').mkdirs()).isTrue();
		assertThat(new File(this.originDirectory, 'sub').mkdirs()).isTrue();
		File file = new File(this.outputDirectory, 'sub/logback.xml');
		file.createNewFile();
		new File(this.originDirectory, 'sub/different.xml').createNewFile();
		FileUtils.removeDuplicatesFromOutputDirectory(this.outputDirectory, this.originDirectory);
		assertThat(file).exists();
	}
	@Test
	void nonDuplicateFile() throws IOException {
		File file = new File(this.outputDirectory, 'logback.xml');
		file.createNewFile();
		new File(this.originDirectory, 'different.xml').createNewFile();
		FileUtils.removeDuplicatesFromOutputDirectory(this.outputDirectory, this.originDirectory);
		assertThat(file).exists();
	}
	@Test
	void hash() throws Exception {
		File file = new File(this.tempDir, 'file');
		try (OutputStream outputStream = new FileOutputStream(file)) {
			outputStream.write(new byte[] { 1, 2, 3 });
		}
		assertThat(FileUtils.sha1Hash(file)).isEqualTo('7037807198c22a7d2b0807371d763779a84fdfcf');
	}
	@Test
	void isSignedJarFileWhenSignedReturnsTrue() throws IOException {
		Manifest manifest = new Manifest(getClass().getResourceAsStream('signed-manifest.mf'));
		File jarFile = new File(this.tempDir, 'test.jar');
		writeTestJar(manifest, jarFile);
		assertThat(FileUtils.isSignedJarFile(jarFile)).isTrue();
	}
	@Test
	void isSignedJarFileWhenNotSignedReturnsFalse() throws IOException {
		Manifest manifest = new Manifest();
		File jarFile = new File(this.tempDir, 'test.jar');
		writeTestJar(manifest, jarFile);
		assertThat(FileUtils.isSignedJarFile(jarFile)).isFalse();
	}
	private void writeTestJar(Manifest manifest, File jarFile) throws IOException, FileNotFoundException {
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(jarFile))) {
			out.putNextEntry(new ZipEntry('META-INF/MANIFEST.MF'));
			manifest.write(out);
			out.closeEntry();
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class RepackagerTests extends AbstractPackagerTests<Repackager> {
	private File destination;
	@Test
	void nullSource() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Repackager(null));
	}
	@Test
	void missingSource() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Repackager(new File('missing')));
	}
	@Test
	void directorySource() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Repackager(this.tempDir));
	}
	@Test
	void jarIsOnlyRepackagedOnce() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), false);
		repackager.repackage(NO_LIBRARIES);
		repackager.repackage(NO_LIBRARIES);
		Manifest actualManifest = getPackagedManifest();
		assertThat(actualManifest.getMainAttributes().getValue('Main-Class'))
			.isEqualTo('org.springframework.boot.loader.launch.JarLauncher');
		assertThat(actualManifest.getMainAttributes().getValue('Start-Class')).isEqualTo('a.b.C');
		assertThat(hasPackagedLauncherClasses()).isTrue();
	}
	@Test
	void sameSourceAndDestinationWithoutBackup() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		File file = this.testJarFile.getFile();
		Repackager repackager = createRepackager(file, false);
		repackager.setBackupSource(false);
		repackager.repackage(NO_LIBRARIES);
		assertThat(new File(file.getParent(), file.getName() + '.original')).doesNotExist();
		assertThat(hasPackagedLauncherClasses()).isTrue();
	}
	@Test
	void sameSourceAndDestinationWithBackup() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		File file = this.testJarFile.getFile();
		Repackager repackager = createRepackager(file, false);
		repackager.repackage(NO_LIBRARIES);
		assertThat(new File(file.getParent(), file.getName() + '.original')).exists();
		assertThat(hasPackagedLauncherClasses()).isTrue();
	}
	@Test
	void differentDestination() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		File source = this.testJarFile.getFile();
		Repackager repackager = createRepackager(source, true);
		execute(repackager, NO_LIBRARIES);
		assertThat(new File(source.getParent(), source.getName() + '.original')).doesNotExist();
		assertThat(hasLauncherClasses(source)).isFalse();
		assertThat(hasPackagedLauncherClasses()).isTrue();
	}
	@Test
	void nullDestination() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), true);
		assertThatIllegalArgumentException().isThrownBy(() -> repackager.repackage(null, NO_LIBRARIES))
			.withMessageContaining('Invalid destination');
	}
	@Test
	void destinationIsDirectory() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), true);
		assertThatIllegalArgumentException().isThrownBy(() -> repackager.repackage(this.tempDir, NO_LIBRARIES))
			.withMessageContaining('Invalid destination');
	}
	@Test
	void overwriteDestination() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), true);
		this.destination.createNewFile();
		repackager.repackage(this.destination, NO_LIBRARIES);
		assertThat(hasLauncherClasses(this.destination)).isTrue();
	}
	@Test
	void layoutFactoryGetsOriginalFile() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), false);
		repackager.setLayoutFactory(new TestLayoutFactory());
		repackager.repackage(this.destination, NO_LIBRARIES);
		assertThat(hasLauncherClasses(this.destination)).isTrue();
	}
	@Test
	void addLauncherScript() throws Exception {
		this.testJarFile.addClass('a/b/C.class', ClassWithMainMethod.class);
		File source = this.testJarFile.getFile();
		Repackager repackager = createRepackager(source, true);
		LaunchScript script = new MockLauncherScript('ABC');
		repackager.repackage(this.destination, NO_LIBRARIES, script);
		byte[] bytes = FileCopyUtils.copyToByteArray(this.destination);
		assertThat(new String(bytes)).startsWith('ABC');
		assertThat(hasLauncherClasses(source)).isFalse();
		assertThat(hasLauncherClasses(this.destination)).isTrue();
		try (ZipFile zipFile = new ZipFile(this.destination)) {
			assertThat(zipFile.getEntries().hasMoreElements()).isTrue();
		}
		try {
			assertThat(Files.getPosixFilePermissions(this.destination.toPath()))
				.contains(PosixFilePermission.OWNER_EXECUTE);
		}
		catch (UnsupportedOperationException ex) {
			// Probably running the test on Windows
		}
	}
	@Test
	void allLoaderDirectoriesAndFilesUseSameTimestamp() throws IOException {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), true);
		Long timestamp = null;
		repackager.repackage(this.destination, NO_LIBRARIES);
		for (ZipArchiveEntry entry : getAllPackagedEntries()) {
			if (entry.getName().startsWith('org/springframework/boot/loader')) {
				if (timestamp == null) {
					timestamp = entry.getTime();
				}
				else {
					assertThat(entry.getTime())
						.withFailMessage('Expected time %d to be equal to %d for entry %s', entry.getTime(), timestamp,
								entry.getName())
						.isEqualTo(timestamp);
				}
			}
		}
	}
	@Test
	void allEntriesUseProvidedTimestamp() throws IOException {
		this.testJarFile.addClass('A.class', ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), true);
		long timestamp = OffsetDateTime.of(2000, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC).toInstant().toEpochMilli();
		repackager.repackage(this.destination, NO_LIBRARIES, null, FileTime.fromMillis(timestamp));
		long offsetTimestamp = DefaultTimeZoneOffset.INSTANCE.removeFrom(timestamp);
		for (ZipArchiveEntry entry : getAllPackagedEntries()) {
			assertThat(entry.getTime()).isEqualTo(offsetTimestamp);
		}
	}
	@Test
	void repackagingDeeplyNestedPackageIsNotProhibitivelySlow() throws IOException {
		StopWatch stopWatch = new StopWatch();
		stopWatch.start();
		this.testJarFile.addClass('a/b/c/d/e/f/g/h/i/j/k/l/m/n/o/p/q/r/s/t/u/v/w/x/y/z/Some.class',
				ClassWithMainMethod.class);
		Repackager repackager = createRepackager(this.testJarFile.getFile(), true);
		repackager.repackage(this.destination, NO_LIBRARIES, null, null);
		stopWatch.stop();
		assertThat(stopWatch.getTotalTimeMillis()).isLessThan(5000);
	}
	@Test
	void signedJar() throws Exception {
		Repackager packager = createPackager();
		packager.setMainClass('a.b.C');
		Manifest manifest = new Manifest();
		Attributes attributes = new Attributes();
		attributes.putValue('SHA1-Digest', '0000');
		manifest.getEntries().put('a/b/C.class', attributes);
		TestJarFile libJar = new TestJarFile(this.tempDir);
		libJar.addManifest(manifest);
		execute(packager, (callback) -> callback.library(newLibrary(libJar.getFile(), LibraryScope.COMPILE, false)));
		assertThat(hasPackagedEntry('META-INF/BOOT.SF')).isTrue();
	}
	private boolean hasLauncherClasses(File file) throws IOException {
		return hasEntry(file, 'org/springframework/boot/')
				&& hasEntry(file, 'org/springframework/boot/loader/launch/JarLauncher.class');
	}
	private boolean hasEntry(File file, String name) throws IOException {
		return getEntry(file, name) != null;
	}
	private JarEntry getEntry(File file, String name) throws IOException {
		try (JarFile jarFile = new JarFile(file)) {
			return jarFile.getJarEntry(name);
		}
	}
	@Override
	protected Repackager createPackager(File source) {
		return createRepackager(source, true);
	}
	private Repackager createRepackager(File source, boolean differentDest) {
		String ext = StringUtils.getFilenameExtension(source.getName());
		this.destination = differentDest ? new File(this.tempDir, 'dest.' + ext) : source;
		return new Repackager(source);
	}
	@Override
	protected void execute(Repackager packager, Libraries libraries) throws IOException {
		packager.repackage(this.destination, libraries);
	}
	@Override
	protected Collection<ZipArchiveEntry> getAllPackagedEntries() throws IOException {
		List<ZipArchiveEntry> result = new ArrayList<>();
		try (ZipFile zip = new ZipFile(this.destination)) {
			Enumeration<ZipArchiveEntry> entries = zip.getEntries();
			while (entries.hasMoreElements()) {
				result.add(entries.nextElement());
			}
		}
		return result;
	}
	@Override
	protected Manifest getPackagedManifest() throws IOException {
		try (JarFile jarFile = new JarFile(this.destination)) {
			return jarFile.getManifest();
		}
	}
	@Override
	protected String getPackagedEntryContent(String name) throws IOException {
		try (ZipFile zip = new ZipFile(this.destination)) {
			ZipArchiveEntry entry = zip.getEntry(name);
			if (entry == null) {
				return null;
			}
			byte[] bytes = FileCopyUtils.copyToByteArray(zip.getInputStream(entry));
			return new String(bytes, StandardCharsets.UTF_8);
		}
	}
	static class MockLauncherScript implements LaunchScript {
		private final byte[] bytes;
		MockLauncherScript(String script) {
			this.bytes = script.getBytes();
		}
		@Override
		public byte[] toByteArray() {
			return this.bytes;
		}
	}
	static class TestLayoutFactory implements LayoutFactory {
		@Override
		public Layout getLayout(File source) {
			assertThat(source.length()).isGreaterThan(0);
			return new DefaultLayoutFactory().getLayout(source);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class LibraryCoordinatesTests {
	@Test
	void ofCreateLibraryCoordinates() {
		LibraryCoordinates coordinates = LibraryCoordinates.of('g', 'a', 'v');
		assertThat(coordinates.getGroupId()).isEqualTo('g');
		assertThat(coordinates.getArtifactId()).isEqualTo('a');
		assertThat(coordinates.getVersion()).isEqualTo('v');
		assertThat(coordinates).hasToString('g:a:v');
	}
	@Test
	void toStandardNotationStringWhenCoordinatesAreNull() {
		assertThat(LibraryCoordinates.toStandardNotationString(null)).isEqualTo('::');
	}
	@Test
	void toStandardNotationStringWhenCoordinatesElementsNull() {
		assertThat(LibraryCoordinates.toStandardNotationString(mock(LibraryCoordinates.class))).isEqualTo('::');
	}
	@Test
	void toStandardNotationString() {
		LibraryCoordinates coordinates = mock(LibraryCoordinates.class);
		given(coordinates.getGroupId()).willReturn('a');
		given(coordinates.getArtifactId()).willReturn('b');
		given(coordinates.getVersion()).willReturn('c');
		assertThat(LibraryCoordinates.toStandardNotationString(coordinates)).isEqualTo('a:b:c');
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class LayerTests {
	@Test
	void createWhenNameIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Layer(null)).withMessage('Name must not be empty');
	}
	@Test
	void createWhenNameIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Layer('')).withMessage('Name must not be empty');
	}
	@Test
	void createWhenNameContainsBadCharsThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Layer('bad!name'))
			.withMessage('Malformed layer name "bad!name"');
	}
	@Test
	void equalsAndHashCode() {
		Layer layer1 = new Layer('testa');
		Layer layer2 = new Layer('testa');
		Layer layer3 = new Layer('testb');
		assertThat(layer1).hasSameHashCodeAs(layer2);
		assertThat(layer1).isEqualTo(layer1).isEqualTo(layer2).isNotEqualTo(layer3);
	}
	@Test
	void toStringReturnsName() {
		assertThat(new Layer('test')).hasToString('test');
	}
	@Test
	void createWhenUsingReservedNameThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new Layer('ext'))
			.withMessage('Layer name "ext" is reserved');
		assertThatIllegalArgumentException().isThrownBy(() -> new Layer('ExT'))
			.withMessage('Layer name "ExT" is reserved');
		assertThatIllegalArgumentException().isThrownBy(() -> new Layer('springbootloader'))
			.withMessage('Layer name "springbootloader" is reserved');
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class NativeImageArgFileTests {
	@Test
	void writeIfNecessaryWhenHasExcludesWritesLines() {
		NativeImageArgFile argFile = new NativeImageArgFile(List.of('path/to/dependency-1.jar', 'dependency-2.jar'));
		List<String> lines = new ArrayList<>();
		argFile.writeIfNecessary(lines::addAll);
		assertThat(lines).containsExactly('--exclude-config', '\\Qdependency-1.jar\\E', '^/META-INF/native-image/.*',
				'--exclude-config', '\\Qdependency-2.jar\\E', '^/META-INF/native-image/.*');
	}
	@Test
	void writeIfNecessaryWhenHasNothingDoesNotCallConsumer() {
		NativeImageArgFile argFile = new NativeImageArgFile(Collections.emptyList());
		argFile.writeIfNecessary((lines) -> fail('Should not be called'));
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class SizeCalculatingEntryWriterTests {
	@Test
	void getWhenWithinThreshold() throws Exception {
		TestEntryWriter original = new TestEntryWriter(SizeCalculatingEntryWriter.THRESHOLD - 1);
		EntryWriter writer = SizeCalculatingEntryWriter.get(original);
		assertThat(writer.size()).isEqualTo(original.getBytes().length);
		assertThat(writeBytes(writer)).isEqualTo(original.getBytes());
		assertThat(writer).extracting('content').isNotInstanceOf(File.class);
	}
	@Test
	void getWhenExceedingThreshold() throws Exception {
		TestEntryWriter original = new TestEntryWriter(SizeCalculatingEntryWriter.THRESHOLD + 1);
		EntryWriter writer = SizeCalculatingEntryWriter.get(original);
		assertThat(writer.size()).isEqualTo(original.getBytes().length);
		assertThat(writeBytes(writer)).isEqualTo(original.getBytes());
		assertThat(writer).extracting('content').isInstanceOf(File.class);
	}
	private byte[] writeBytes(EntryWriter writer) throws IOException {
		ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
		writer.write(outputStream);
		outputStream.close();
		return outputStream.toByteArray();
	}
	private static class TestEntryWriter implements EntryWriter {
		private final byte[] bytes;
		TestEntryWriter(int size) {
			this.bytes = new byte[size];
			new Random().nextBytes(this.bytes);
		}
		byte[] getBytes() {
			return this.bytes;
		}
		@Override
		public void write(OutputStream outputStream) throws IOException {
			outputStream.write(this.bytes);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class ImplicitLayerResolverTests {
	private final Layers layers = Layers.IMPLICIT;
	@Test
	void iteratorReturnsLayers() {
		assertThat(this.layers).containsExactly(StandardLayers.DEPENDENCIES, StandardLayers.SPRING_BOOT_LOADER,
				StandardLayers.SNAPSHOT_DEPENDENCIES, StandardLayers.APPLICATION);
	}
	@Test
	void getLayerWhenNameInResourceLocationReturnsApplicationLayer() {
		assertThat(this.layers.getLayer('META-INF/resources/logo.gif')).isEqualTo(StandardLayers.APPLICATION);
		assertThat(this.layers.getLayer('resources/logo.gif')).isEqualTo(StandardLayers.APPLICATION);
		assertThat(this.layers.getLayer('static/logo.gif')).isEqualTo(StandardLayers.APPLICATION);
		assertThat(this.layers.getLayer('public/logo.gif')).isEqualTo(StandardLayers.APPLICATION);
	}
	@Test
	void getLayerWhenNameIsClassInResourceLocationReturnsApplicationLayer() {
		assertThat(this.layers.getLayer('META-INF/resources/Logo.class')).isEqualTo(StandardLayers.APPLICATION);
		assertThat(this.layers.getLayer('resources/Logo.class')).isEqualTo(StandardLayers.APPLICATION);
		assertThat(this.layers.getLayer('static/Logo.class')).isEqualTo(StandardLayers.APPLICATION);
		assertThat(this.layers.getLayer('public/Logo.class')).isEqualTo(StandardLayers.APPLICATION);
	}
	@Test
	void getLayerWhenNameNotInResourceLocationReturnsApplicationLayer() {
		assertThat(this.layers.getLayer('com/example/Application.class')).isEqualTo(StandardLayers.APPLICATION);
		assertThat(this.layers.getLayer('com/example/application.properties')).isEqualTo(StandardLayers.APPLICATION);
	}
	@Test
	void getLayerWhenLoaderClassReturnsLoaderLayer() {
		assertThat(this.layers.getLayer('org/springframework/boot/loader/Launcher.class'))
			.isEqualTo(StandardLayers.SPRING_BOOT_LOADER);
		assertThat(this.layers.getLayer('org/springframework/boot/loader/Utils.class'))
			.isEqualTo(StandardLayers.SPRING_BOOT_LOADER);
	}
	@Test
	void getLayerWhenLibraryIsSnapshotReturnsSnapshotLayer() {
		assertThat(this.layers.getLayer(mockLibrary('spring-boot.2.0.0.BUILD-SNAPSHOT.jar')))
			.isEqualTo(StandardLayers.SNAPSHOT_DEPENDENCIES);
		assertThat(this.layers.getLayer(mockLibrary('spring-boot.2.0.0-SNAPSHOT.jar')))
			.isEqualTo(StandardLayers.SNAPSHOT_DEPENDENCIES);
		assertThat(this.layers.getLayer(mockLibrary('spring-boot.2.0.0.SNAPSHOT.jar')))
			.isEqualTo(StandardLayers.SNAPSHOT_DEPENDENCIES);
	}
	@Test
	void getLayerWhenLibraryIsNotSnapshotReturnsDependenciesLayer() {
		assertThat(this.layers.getLayer(mockLibrary('spring-boot.2.0.0.jar'))).isEqualTo(StandardLayers.DEPENDENCIES);
		assertThat(this.layers.getLayer(mockLibrary('spring-boot.2.0.0-classified.jar')))
			.isEqualTo(StandardLayers.DEPENDENCIES);
	}
	private Library mockLibrary(String name) {
		Library library = mock(Library.class);
		given(library.getName()).willReturn(name);
		return library;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class TestJarFile {
	private final byte[] buffer = new byte[4096];
	private final File temporaryDirectory;
	private final File jarSource;
	private final List<ZipEntrySource> entries = new ArrayList<>();
	public TestJarFile(File temporaryDirectory) {
		this.temporaryDirectory = temporaryDirectory;
		this.jarSource = new File(temporaryDirectory, 'jar-source');
	}
	public void addClass(String filename, Class<?> classToCopy) throws IOException {
		addClass(filename, classToCopy, null);
	}
	public void addClass(String filename, Class<?> classToCopy, Long time) throws IOException {
		File file = getFilePath(filename);
		file.getParentFile().mkdirs();
		InputStream inputStream = getClass()
			.getResourceAsStream('/' + classToCopy.getName().replace(".", "/") + '.class');
		copyToFile(inputStream, file);
		if (time != null) {
			file.setLastModified(time);
		}
		this.entries.add(new FileSource(filename, file));
	}
	public void addFile(String filename, File fileToCopy) throws IOException {
		try (InputStream inputStream = new FileInputStream(fileToCopy)) {
			addFile(filename, inputStream);
		}
	}
	public void addFile(String filename, InputStream inputStream) throws IOException {
		File file = getFilePath(filename);
		file.getParentFile().mkdirs();
		copyToFile(inputStream, file);
		this.entries.add(new FileSource(filename, file));
	}
	public void addManifest(Manifest manifest) throws IOException {
		File manifestFile = new File(this.jarSource, 'META-INF/MANIFEST.MF');
		manifestFile.getParentFile().mkdirs();
		try (OutputStream outputStream = new FileOutputStream(manifestFile)) {
			manifest.write(outputStream);
		}
		this.entries.add(new FileSource('META-INF/MANIFEST.MF', manifestFile));
	}
	private File getFilePath(String filename) {
		String[] paths = filename.split('/');
		File file = this.jarSource;
		for (String path : paths) {
			file = new File(file, path);
		}
		return file;
	}
	private void copyToFile(InputStream inputStream, File file) throws IOException {
		try (OutputStream outputStream = new FileOutputStream(file)) {
			copy(inputStream, outputStream);
		}
	}
	private void copy(InputStream in, OutputStream out) throws IOException {
		int bytesRead;
		while ((bytesRead = in.read(this.buffer)) != -1) {
			out.write(this.buffer, 0, bytesRead);
		}
	}
	public JarFile getJarFile() throws IOException {
		return new JarFile(getFile());
	}
	public File getJarSource() {
		return this.jarSource;
	}
	public File getFile() {
		return getFile('jar');
	}
	public File getFile(String extension) {
		File file = new File(this.temporaryDirectory, UUID.randomUUID() + '.' + extension);
		ZipUtil.pack(this.entries.toArray(new ZipEntrySource[0]), file);
		return file;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class ZipHeaderPeekInputStreamTests {
	@Test
	void hasZipHeaderReturnsTrueWhenStreamStartsWithZipHeader() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(
				new ByteArrayInputStream(new byte[] { 0x50, 0x4b, 0x03, 0x04, 5, 6 }))) {
			assertThat(in.hasZipHeader()).isTrue();
		}
	}
	@Test
	void hasZipHeaderReturnsFalseWhenStreamDoesNotStartWithZipHeader() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(
				new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4, 5 }))) {
			assertThat(in.hasZipHeader()).isFalse();
		}
	}
	@Test
	void readIndividualBytes() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(
				new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4, 5 }))) {
			assertThat(in.read()).isZero();
			assertThat(in.read()).isOne();
			assertThat(in.read()).isEqualTo(2);
			assertThat(in.read()).isEqualTo(3);
			assertThat(in.read()).isEqualTo(4);
			assertThat(in.read()).isEqualTo(5);
		}
	}
	@Test
	void readMultipleBytes() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(
				new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4, 5 }))) {
			byte[] bytes = new byte[3];
			assertThat(in.read(bytes)).isEqualTo(3);
			assertThat(bytes).containsExactly(0, 1, 2);
			assertThat(in.read(bytes)).isEqualTo(3);
			assertThat(bytes).containsExactly(3, 4, 5);
			assertThat(in.read(bytes)).isEqualTo(-1);
		}
	}
	@Test
	void readingMoreThanEntireStreamReadsToEndOfStream() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(
				new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4, 5 }))) {
			byte[] bytes = new byte[8];
			assertThat(in.read(bytes)).isEqualTo(6);
			assertThat(bytes).containsExactly(0, 1, 2, 3, 4, 5, 0, 0);
			assertThat(in.read(bytes)).isEqualTo(-1);
		}
	}
	@Test
	void readOfSomeOfTheHeaderThenMoreThanEntireStreamReadsToEndOfStream() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(
				new ByteArrayInputStream(new byte[] { 0, 1, 2, 3, 4, 5 }))) {
			byte[] bytes = new byte[8];
			assertThat(in.read(bytes, 0, 3)).isEqualTo(3);
			assertThat(bytes).containsExactly(0, 1, 2, 0, 0, 0, 0, 0);
			assertThat(in.read(bytes, 3, 5)).isEqualTo(3);
			assertThat(bytes).containsExactly(0, 1, 2, 3, 4, 5, 0, 0);
		}
	}
	@Test
	void readMoreThanEntireStreamWhenStreamLengthIsLessThanZipHeaderLength() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(new ByteArrayInputStream(new byte[] { 10 }))) {
			byte[] bytes = new byte[8];
			assertThat(in.read(bytes)).isOne();
			assertThat(bytes).containsExactly(10, 0, 0, 0, 0, 0, 0, 0);
		}
	}
	@Test
	void readMoreThanEntireStreamWhenStreamLengthIsSameAsHeaderLength() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(
				new ByteArrayInputStream(new byte[] { 1, 2, 3, 4 }))) {
			byte[] bytes = new byte[8];
			assertThat(in.read(bytes)).isEqualTo(4);
			assertThat(bytes).containsExactly(1, 2, 3, 4, 0, 0, 0, 0);
		}
	}
	@Test
	void readMoreThanEntireStreamWhenStreamLengthIsZero() throws IOException {
		try (ZipHeaderPeekInputStream in = new ZipHeaderPeekInputStream(new ByteArrayInputStream(new byte[0]))) {
			byte[] bytes = new byte[8];
			assertThat(in.read(bytes)).isEqualTo(-1);
			assertThat(bytes).containsExactly(0, 0, 0, 0, 0, 0, 0, 0);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class ReachabilityMetadataPropertiesTests {
	@Test
	void shouldReadFromInputStream() throws IOException {
		String propertiesContent = 'override=true\n';
		ReachabilityMetadataProperties properties = ReachabilityMetadataProperties
			.fromInputStream(new ByteArrayInputStream(propertiesContent.getBytes(StandardCharsets.UTF_8)));
		assertThat(properties.isOverridden()).isTrue();
	}
	@Test
	void shouldFormatLocation() {
		String location = ReachabilityMetadataProperties
			.getLocation(LibraryCoordinates.of('group-id', 'artifact-id', '1.0.0'));
		assertThat(location)
			.isEqualTo('META-INF/native-image/group-id/artifact-id/1.0.0/reachability-metadata.properties');
	}
}
/*
package org.springframework.boot.loader.tools.layer;
/**
class ApplicationContentFilterTests {
	@Test
	void createWhenPatternIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ApplicationContentFilter(null))
			.withMessage('Pattern must not be empty');
	}
	@Test
	void createWhenPatternIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new ApplicationContentFilter(''))
			.withMessage('Pattern must not be empty');
	}
	@Test
	void matchesWhenWildcardPatternMatchesReturnsTrue() {
		ApplicationContentFilter filter = new ApplicationContentFilter('META-INF/**');
		assertThat(filter.matches('META-INF/resources/application.yml')).isTrue();
	}
	@Test
	void matchesWhenWildcardPatternDoesNotMatchReturnsFalse() {
		ApplicationContentFilter filter = new ApplicationContentFilter('META-INF/**');
		assertThat(filter.matches('src/main/resources/application.yml')).isFalse();
	}
}
/*
package org.springframework.boot.loader.tools.layer;
/**
class LibraryContentFilterTests {
	@Test
	void createWhenCoordinatesPatternIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LibraryContentFilter(null))
			.withMessage('CoordinatesPattern must not be empty');
	}
	@Test
	void createWhenCoordinatesPatternIsEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new LibraryContentFilter(''))
			.withMessage('CoordinatesPattern must not be empty');
	}
	@Test
	void matchesWhenGroupIdIsNullAndToMatchHasWildcardReturnsTrue() {
		LibraryContentFilter filter = new LibraryContentFilter('*:*');
		assertThat(filter.matches(mockLibrary(null, null, null))).isTrue();
	}
	@Test
	void matchesWhenArtifactIdIsNullAndToMatchHasWildcardReturnsTrue() {
		LibraryContentFilter filter = new LibraryContentFilter('org.acme:*');
		assertThat(filter.matches(mockLibrary('org.acme', null, null))).isTrue();
	}
	@Test
	void matchesWhenVersionIsNullAndToMatchHasWildcardReturnsTrue() {
		LibraryContentFilter filter = new LibraryContentFilter('org.acme:something:*');
		assertThat(filter.matches(mockLibrary('org.acme', 'something', null))).isTrue();
	}
	@Test
	void matchesWhenGroupIdDoesNotMatchReturnsFalse() {
		LibraryContentFilter filter = new LibraryContentFilter('org.acme:*');
		assertThat(filter.matches(mockLibrary('other.foo', null, null))).isFalse();
	}
	@Test
	void matchesWhenWhenArtifactIdDoesNotMatchReturnsFalse() {
		LibraryContentFilter filter = new LibraryContentFilter('org.acme:test:*');
		assertThat(filter.matches(mockLibrary('org.acme', 'other', null))).isFalse();
	}
	@Test
	void matchesWhenArtifactIdMatchesReturnsTrue() {
		LibraryContentFilter filter = new LibraryContentFilter('org.acme:test:*');
		assertThat(filter.matches(mockLibrary('org.acme', 'test', null))).isTrue();
	}
	@Test
	void matchesWhenVersionDoesNotMatchReturnsFalse() {
		LibraryContentFilter filter = new LibraryContentFilter('org.acme:test:*SNAPSHOT');
		assertThat(filter.matches(mockLibrary('org.acme', 'test', '1.0.0'))).isFalse();
	}
	@Test
	void matchesWhenVersionMatchesReturnsTrue() {
		LibraryContentFilter filter = new LibraryContentFilter('org.acme:test:*SNAPSHOT');
		assertThat(filter.matches(mockLibrary('org.acme', 'test', '1.0.0-SNAPSHOT'))).isTrue();
	}
	private Library mockLibrary(String groupId, String artifactId, String version) {
		return mockLibrary(LibraryCoordinates.of(groupId, artifactId, version));
	}
	private Library mockLibrary(LibraryCoordinates coordinates) {
		Library library = mock(Library.class);
		given(library.getCoordinates()).willReturn(coordinates);
		return library;
	}
}
/*
package org.springframework.boot.loader.tools.layer;
/**
class IncludeExcludeContentSelectorTests {
	private static final Layer LAYER = new Layer('test');
	@Test
	void createWhenLayerIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(
					() -> new IncludeExcludeContentSelector<>(null, Collections.emptyList(), Collections.emptyList()))
			.withMessage('Layer must not be null');
	}
	@Test
	void createWhenFactoryIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new IncludeExcludeContentSelector<>(LAYER, null, null, null))
			.withMessage('FilterFactory must not be null');
	}
	@Test
	void getLayerReturnsLayer() {
		IncludeExcludeContentSelector<?> selector = new IncludeExcludeContentSelector<>(LAYER, null, null);
		assertThat(selector.getLayer()).isEqualTo(LAYER);
	}
	@Test
	void containsWhenEmptyIncludesAndEmptyExcludesReturnsTrue() {
		List<String> includes = Arrays.asList();
		List<String> excludes = Arrays.asList();
		IncludeExcludeContentSelector<String> selector = new IncludeExcludeContentSelector<>(LAYER, includes, excludes,
				TestContentsFilter::new);
		assertThat(selector.contains('A')).isTrue();
	}
	@Test
	void containsWhenNullIncludesAndEmptyExcludesReturnsTrue() {
		List<String> includes = null;
		List<String> excludes = null;
		IncludeExcludeContentSelector<String> selector = new IncludeExcludeContentSelector<>(LAYER, includes, excludes,
				TestContentsFilter::new);
		assertThat(selector.contains('A')).isTrue();
	}
	@Test
	void containsWhenEmptyIncludesAndNotExcludedReturnsTrue() {
		List<String> includes = Arrays.asList();
		List<String> excludes = Arrays.asList('B');
		IncludeExcludeContentSelector<String> selector = new IncludeExcludeContentSelector<>(LAYER, includes, excludes,
				TestContentsFilter::new);
		assertThat(selector.contains('A')).isTrue();
	}
	@Test
	void containsWhenEmptyIncludesAndExcludedReturnsFalse() {
		List<String> includes = Arrays.asList();
		List<String> excludes = Arrays.asList('A');
		IncludeExcludeContentSelector<String> selector = new IncludeExcludeContentSelector<>(LAYER, includes, excludes,
				TestContentsFilter::new);
		assertThat(selector.contains('A')).isFalse();
	}
	@Test
	void containsWhenIncludedAndEmptyExcludesReturnsTrue() {
		List<String> includes = Arrays.asList('A', 'B');
		List<String> excludes = Arrays.asList();
		IncludeExcludeContentSelector<String> selector = new IncludeExcludeContentSelector<>(LAYER, includes, excludes,
				TestContentsFilter::new);
		assertThat(selector.contains('B')).isTrue();
	}
	@Test
	void containsWhenIncludedAndNotExcludedReturnsTrue() {
		List<String> includes = Arrays.asList('A', 'B');
		List<String> excludes = Arrays.asList('C', 'D');
		IncludeExcludeContentSelector<String> selector = new IncludeExcludeContentSelector<>(LAYER, includes, excludes,
				TestContentsFilter::new);
		assertThat(selector.contains('B')).isTrue();
	}
	@Test
	void containsWhenIncludedAndExcludedReturnsFalse() {
		List<String> includes = Arrays.asList('A', 'B');
		List<String> excludes = Arrays.asList('C', 'D');
		IncludeExcludeContentSelector<String> selector = new IncludeExcludeContentSelector<>(LAYER, includes, excludes,
				TestContentsFilter::new);
		assertThat(selector.contains('C')).isFalse();
	}
	/**
	 * {@link ContentFilter} used for testing.
	 */
	static class TestContentsFilter implements ContentFilter<String> {
		private final String match;
		TestContentsFilter(String match) {
			this.match = match;
		}
		@Override
		public boolean matches(String item) {
			return this.match.equals(item);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class LayoutsTests {
	@Test
	void jarFile() {
		assertThat(Layouts.forFile(new File('test.jar'))).isInstanceOf(Layouts.Jar.class);
		assertThat(Layouts.forFile(new File('test.JAR'))).isInstanceOf(Layouts.Jar.class);
		assertThat(Layouts.forFile(new File('test.jAr'))).isInstanceOf(Layouts.Jar.class);
		assertThat(Layouts.forFile(new File('te.st.jar'))).isInstanceOf(Layouts.Jar.class);
	}
	@Test
	void warFile() {
		assertThat(Layouts.forFile(new File('test.war'))).isInstanceOf(Layouts.War.class);
		assertThat(Layouts.forFile(new File('test.WAR'))).isInstanceOf(Layouts.War.class);
		assertThat(Layouts.forFile(new File('test.wAr'))).isInstanceOf(Layouts.War.class);
		assertThat(Layouts.forFile(new File('te.st.war'))).isInstanceOf(Layouts.War.class);
	}
	@Test
	void unknownFile() {
		assertThatIllegalStateException().isThrownBy(() -> Layouts.forFile(new File('test.txt')))
			.withMessageContaining('Unable to deduce layout for "test.txt"');
	}
	@Test
	void jarLayout() {
		Layout layout = new Layouts.Jar();
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.COMPILE)).isEqualTo('BOOT-INF/lib/');
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.CUSTOM)).isEqualTo('BOOT-INF/lib/');
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.PROVIDED)).isEqualTo('BOOT-INF/lib/');
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.RUNTIME)).isEqualTo('BOOT-INF/lib/');
	}
	@Test
	void warLayout() {
		Layout layout = new Layouts.War();
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.COMPILE)).isEqualTo('WEB-INF/lib/');
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.CUSTOM)).isEqualTo('WEB-INF/lib/');
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.PROVIDED)).isEqualTo('WEB-INF/lib-provided/');
		assertThat(layout.getLibraryLocation('lib.jar', LibraryScope.RUNTIME)).isEqualTo('WEB-INF/lib/');
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class LayersIndexTests {
	private static final Layer LAYER_A = new Layer('a');
	private static final Layer LAYER_B = new Layer('b');
	private static final Layer LAYER_C = new Layer('c');
	private String testMethodName;
	@BeforeEach
	void setup(TestInfo testInfo) {
		this.testMethodName = testInfo.getTestMethod().get().getName();
	}
	@Test
	void writeToWhenSimpleNamesSortsAlphabetically() {
		LayersIndex index = new LayersIndex(LAYER_A);
		index.add(LAYER_A, 'cat');
		index.add(LAYER_A, 'dog');
		index.add(LAYER_A, 'aardvark');
		index.add(LAYER_A, 'zerbra');
		index.add(LAYER_A, 'hamster');
		assertThatIndex(index).writesExpectedContent();
	}
	@Test
	void writeToWritesLayersInIteratorOrder() {
		LayersIndex index = new LayersIndex(LAYER_B, LAYER_A, LAYER_C);
		index.add(LAYER_A, 'a1');
		index.add(LAYER_A, 'a2');
		index.add(LAYER_B, 'b1');
		index.add(LAYER_B, 'b2');
		index.add(LAYER_C, 'c1');
		index.add(LAYER_C, 'c2');
		assertThatIndex(index).writesExpectedContent();
	}
	@Test
	void writeToWhenLayerNotUsedDoesNotSkipLayer() {
		LayersIndex index = new LayersIndex(LAYER_A, LAYER_B, LAYER_C);
		index.add(LAYER_A, 'a1');
		index.add(LAYER_A, 'a2');
		index.add(LAYER_C, 'c1');
		index.add(LAYER_C, 'c2');
		assertThatIndex(index).writesExpectedContent();
	}
	@Test
	void writeToWhenAllFilesInDirectoryAreInSameLayerUsesDirectory() {
		LayersIndex index = new LayersIndex(LAYER_A, LAYER_B, LAYER_C);
		index.add(LAYER_A, 'a1/b1/c1');
		index.add(LAYER_A, 'a1/b1/c2');
		index.add(LAYER_A, 'a1/b2/c1');
		index.add(LAYER_B, 'a2/b1');
		index.add(LAYER_B, 'a2/b2');
		assertThatIndex(index).writesExpectedContent();
	}
	@Test
	void writeToWhenAllFilesInDirectoryAreInNotInSameLayerUsesFiles() {
		LayersIndex index = new LayersIndex(LAYER_A, LAYER_B, LAYER_C);
		index.add(LAYER_A, 'a1/b1/c1');
		index.add(LAYER_B, 'a1/b1/c2');
		index.add(LAYER_C, 'a1/b2/c1');
		index.add(LAYER_A, 'a2/b1');
		index.add(LAYER_B, 'a2/b2');
		assertThatIndex(index).writesExpectedContent();
	}
	@Test
	void writeToWhenSpaceInFileName() {
		LayersIndex index = new LayersIndex(LAYER_A);
		index.add(LAYER_A, 'a b');
		index.add(LAYER_A, 'a b/c');
		index.add(LAYER_A, 'a b/d');
		assertThatIndex(index).writesExpectedContent();
	}
	private LayersIndexAssert assertThatIndex(LayersIndex index) {
		return new LayersIndexAssert(index);
	}
	private class LayersIndexAssert extends AbstractObjectAssert<LayersIndexAssert, LayersIndex> {
		LayersIndexAssert(LayersIndex actual) {
			super(actual, LayersIndexAssert.class);
		}
		void writesExpectedContent() {
			try {
				String actualContent = getContent();
				String name = 'LayersIndexTests-' + LayersIndexTests.this.testMethodName + '.txt';
				InputStream in = LayersIndexTests.class.getResourceAsStream(name);
				Assert.state(in != null, () -> 'Can"t read ' + name);
				String expectedContent = new String(FileCopyUtils.copyToByteArray(in), StandardCharsets.UTF_8);
				expectedContent = expectedContent.replace('\r', '');
				assertThat(actualContent).isEqualTo(expectedContent);
			}
			catch (IOException ex) {
				throw new IllegalStateException(ex);
			}
		}
		private String getContent() throws IOException {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			this.actual.writeTo(out);
			return out.toString(StandardCharsets.UTF_8);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class DefaultLaunchScriptTests {
	@TempDir
	File tempDir;
	@Test
	void loadsDefaultScript() throws Exception {
		DefaultLaunchScript script = new DefaultLaunchScript(null, null);
		String content = new String(script.toByteArray());
		assertThat(content).contains('Spring Boot Startup Script');
	}
	@Test
	void logFilenameCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('logFilename');
	}
	@Test
	void pidFilenameCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('pidFilename');
	}
	@Test
	void initInfoProvidesCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoProvides');
	}
	@Test
	void initInfoRequiredStartCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoRequiredStart');
	}
	@Test
	void initInfoRequiredStopCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoRequiredStop');
	}
	@Test
	void initInfoDefaultStartCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoDefaultStart');
	}
	@Test
	void initInfoDefaultStopCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoDefaultStop');
	}
	@Test
	void initInfoShortDescriptionCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoShortDescription');
	}
	@Test
	void initInfoDescriptionCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoDescription');
	}
	@Test
	void initInfoChkconfigCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('initInfoChkconfig');
	}
	@Test
	void modeCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('mode');
	}
	@Test
	void useStartStopDaemonCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('useStartStopDaemon');
	}
	@Test
	void logFolderCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('logFolder');
	}
	@Test
	void pidFolderCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('pidFolder');
	}
	@Test
	void confFolderCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('confFolder');
	}
	@Test
	void stopWaitTimeCanBeReplaced() throws Exception {
		assertThatPlaceholderCanBeReplaced('stopWaitTime');
	}
	@Test
	void inlinedConfScriptFileLoad() throws IOException {
		DefaultLaunchScript script = new DefaultLaunchScript(null,
				createProperties('inlinedConfScript:src/test/resources/example.script'));
		String content = new String(script.toByteArray());
		assertThat(content).contains('FOO=BAR');
	}
	@Test
	void defaultForUseStartStopDaemonIsTrue() throws Exception {
		DefaultLaunchScript script = new DefaultLaunchScript(null, null);
		String content = new String(script.toByteArray());
		assertThat(content).contains('USE_START_STOP_DAEMON=\'true\'');
	}
	@Test
	void defaultForModeIsAuto() throws Exception {
		DefaultLaunchScript script = new DefaultLaunchScript(null, null);
		String content = new String(script.toByteArray());
		assertThat(content).contains('MODE=\'auto\'');
	}
	@Test
	void defaultForStopWaitTimeIs60() throws Exception {
		DefaultLaunchScript script = new DefaultLaunchScript(null, null);
		String content = new String(script.toByteArray());
		assertThat(content).contains('STOP_WAIT_TIME=\'60\'');
	}
	@Test
	void loadFromFile() throws Exception {
		File file = new File(this.tempDir, 'script');
		FileCopyUtils.copy('ABC'.getBytes(), file);
		DefaultLaunchScript script = new DefaultLaunchScript(file, null);
		String content = new String(script.toByteArray());
		assertThat(content).isEqualTo('ABC');
	}
	@Test
	void expandVariables() throws Exception {
		File file = new File(this.tempDir, 'script');
		FileCopyUtils.copy('h{{a}}ll{{b}}'.getBytes(), file);
		DefaultLaunchScript script = new DefaultLaunchScript(file, createProperties('a:e', 'b:o'));
		String content = new String(script.toByteArray());
		assertThat(content).isEqualTo('hello');
	}
	@Test
	void expandVariablesMultiLine() throws Exception {
		File file = new File(this.tempDir, 'script');
		FileCopyUtils.copy('h{{a}}l\nl{{b}}'.getBytes(), file);
		DefaultLaunchScript script = new DefaultLaunchScript(file, createProperties('a:e', 'b:o'));
		String content = new String(script.toByteArray());
		assertThat(content).isEqualTo('hel\nlo');
	}
	@Test
	void expandVariablesWithDefaults() throws Exception {
		File file = new File(this.tempDir, 'script');
		FileCopyUtils.copy('h{{a:e}}ll{{b:o}}'.getBytes(), file);
		DefaultLaunchScript script = new DefaultLaunchScript(file, null);
		String content = new String(script.toByteArray());
		assertThat(content).isEqualTo('hello');
	}
	@Test
	void expandVariablesCanDefaultToBlank() throws Exception {
		File file = new File(this.tempDir, 'script');
		FileCopyUtils.copy('s{{p:}}{{r:}}ing'.getBytes(), file);
		DefaultLaunchScript script = new DefaultLaunchScript(file, null);
		String content = new String(script.toByteArray());
		assertThat(content).isEqualTo('sing');
	}
	@Test
	void expandVariablesWithDefaultsOverride() throws Exception {
		File file = new File(this.tempDir, 'script');
		FileCopyUtils.copy('h{{a:e}}ll{{b:o}}'.getBytes(), file);
		DefaultLaunchScript script = new DefaultLaunchScript(file, createProperties('a:a'));
		String content = new String(script.toByteArray());
		assertThat(content).isEqualTo('hallo');
	}
	@Test
	void expandVariablesMissingAreUnchanged() throws Exception {
		File file = new File(this.tempDir, 'script');
		FileCopyUtils.copy('h{{a}}ll{{b}}'.getBytes(), file);
		DefaultLaunchScript script = new DefaultLaunchScript(file, null);
		String content = new String(script.toByteArray());
		assertThat(content).isEqualTo('h{{a}}ll{{b}}');
	}
	private void assertThatPlaceholderCanBeReplaced(String placeholder) throws Exception {
		DefaultLaunchScript script = new DefaultLaunchScript(null, createProperties(placeholder + ':__test__'));
		String content = new String(script.toByteArray());
		assertThat(content).contains('__test__');
	}
	private Map<?, ?> createProperties(String... pairs) {
		Map<Object, Object> properties = new HashMap<>();
		for (String pair : pairs) {
			String[] keyValue = pair.split(':');
			properties.put(keyValue[0], keyValue[1]);
		}
		return properties;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class MainClassFinderTests {
	private TestJarFile testJarFile;
	@BeforeEach
	void setup(@TempDir File tempDir) {
		this.testJarFile = new TestJarFile(tempDir);
	}
	@Test
	void findMainClassInJar() throws Exception {
		this.testJarFile.addClass('B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('A.class', ClassWithoutMainMethod.class);
		try (JarFile jarFile = this.testJarFile.getJarFile()) {
			String actual = MainClassFinder.findMainClass(jarFile, '');
			assertThat(actual).isEqualTo('B');
		}
	}
	@Test
	void findMainClassInJarSubDirectory() throws Exception {
		this.testJarFile.addClass('a/b/c/D.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithoutMainMethod.class);
		this.testJarFile.addClass('a/b/F.class', ClassWithoutMainMethod.class);
		try (JarFile jarFile = this.testJarFile.getJarFile()) {
			String actual = MainClassFinder.findMainClass(jarFile, '');
			assertThat(actual).isEqualTo('a.b.c.D');
		}
	}
	@Test
	void usesBreadthFirstJarSearch() throws Exception {
		this.testJarFile.addClass('a/B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithMainMethod.class);
		try (JarFile jarFile = this.testJarFile.getJarFile()) {
			String actual = MainClassFinder.findMainClass(jarFile, '');
			assertThat(actual).isEqualTo('a.B');
		}
	}
	@Test
	void findSingleJarSearch() throws Exception {
		this.testJarFile.addClass('a/B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithMainMethod.class);
		try (JarFile jarFile = this.testJarFile.getJarFile()) {
			assertThatIllegalStateException().isThrownBy(() -> MainClassFinder.findSingleMainClass(jarFile, ''))
				.withMessageContaining(
						'Unable to find a single main class from the following candidates [a.B, a.b.c.E]');
		}
	}
	@Test
	void findSingleJarSearchPrefersAnnotatedMainClass() throws Exception {
		this.testJarFile.addClass('a/B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', AnnotatedClassWithMainMethod.class);
		try (JarFile jarFile = this.testJarFile.getJarFile()) {
			String mainClass = MainClassFinder.findSingleMainClass(jarFile, '',
					'org.springframework.boot.loader.tools.sample.SomeApplication');
			assertThat(mainClass).isEqualTo('a.b.c.E');
		}
	}
	@Test
	void findMainClassInJarSubLocation() throws Exception {
		this.testJarFile.addClass('a/B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithMainMethod.class);
		try (JarFile jarFile = this.testJarFile.getJarFile()) {
			String actual = MainClassFinder.findMainClass(jarFile, 'a/');
			assertThat(actual).isEqualTo('B');
		}
	}
	@Test
	void findMainClassInDirectory() throws Exception {
		this.testJarFile.addClass('B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('A.class', ClassWithoutMainMethod.class);
		String actual = MainClassFinder.findMainClass(this.testJarFile.getJarSource());
		assertThat(actual).isEqualTo('B');
	}
	@Test
	void findMainClassInSubDirectory() throws Exception {
		this.testJarFile.addClass('a/b/c/D.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithoutMainMethod.class);
		this.testJarFile.addClass('a/b/F.class', ClassWithoutMainMethod.class);
		String actual = MainClassFinder.findMainClass(this.testJarFile.getJarSource());
		assertThat(actual).isEqualTo('a.b.c.D');
	}
	@Test
	void usesBreadthFirstDirectorySearch() throws Exception {
		this.testJarFile.addClass('a/B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithMainMethod.class);
		String actual = MainClassFinder.findMainClass(this.testJarFile.getJarSource());
		assertThat(actual).isEqualTo('a.B');
	}
	@Test
	void findSingleDirectorySearch() throws Exception {
		this.testJarFile.addClass('a/B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithMainMethod.class);
		assertThatIllegalStateException()
			.isThrownBy(() -> MainClassFinder.findSingleMainClass(this.testJarFile.getJarSource()))
			.withMessageContaining('Unable to find a single main class from the following candidates [a.B, a.b.c.E]');
	}
	@Test
	void findSingleDirectorySearchPrefersAnnotatedMainClass() throws Exception {
		this.testJarFile.addClass('a/B.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', AnnotatedClassWithMainMethod.class);
		String mainClass = MainClassFinder.findSingleMainClass(this.testJarFile.getJarSource(),
				'org.springframework.boot.loader.tools.sample.SomeApplication');
		assertThat(mainClass).isEqualTo('a.b.c.E');
	}
	@Test
	void doWithDirectoryMainMethods() throws Exception {
		this.testJarFile.addClass('a/b/c/D.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithoutMainMethod.class);
		this.testJarFile.addClass('a/b/F.class', ClassWithoutMainMethod.class);
		this.testJarFile.addClass('a/b/G.class', ClassWithMainMethod.class);
		ClassNameCollector callback = new ClassNameCollector();
		MainClassFinder.doWithMainClasses(this.testJarFile.getJarSource(), callback);
		assertThat(callback.getClassNames()).hasToString('[a.b.G, a.b.c.D]');
	}
	@Test
	void doWithJarMainMethods() throws Exception {
		this.testJarFile.addClass('a/b/c/D.class', ClassWithMainMethod.class);
		this.testJarFile.addClass('a/b/c/E.class', ClassWithoutMainMethod.class);
		this.testJarFile.addClass('a/b/F.class', ClassWithoutMainMethod.class);
		this.testJarFile.addClass('a/b/G.class', ClassWithMainMethod.class);
		ClassNameCollector callback = new ClassNameCollector();
		try (JarFile jarFile = this.testJarFile.getJarFile()) {
			MainClassFinder.doWithMainClasses(jarFile, null, callback);
			assertThat(callback.getClassNames()).hasToString('[a.b.G, a.b.c.D]');
		}
	}
	static class ClassNameCollector implements MainClassCallback<Object> {
		private final List<String> classNames = new ArrayList<>();
		@Override
		public Object doWith(MainClass mainClass) {
			this.classNames.add(mainClass.getName());
			return null;
		}
		List<String> getClassNames() {
			return this.classNames;
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
@FunctionalInterface
public interface LibraryCallback {
	/**
	 * Callback for a single library backed by a {@link File}.
	 * @param library the library
	 * @throws IOException if the operation fails
	 */
	void library(Library library) throws IOException;
}
/*
package org.springframework.boot.loader.tools;
/**
public abstract class FileUtils {
	/**
	 * Utility to remove duplicate files from an 'output' directory if they already exist
	 * in an 'origin'. Recursively scans the origin directory looking for files (not
	 * directories) that exist in both places and deleting the copy.
	 * @param outputDirectory the output directory
	 * @param originDirectory the origin directory
	 */
	public static void removeDuplicatesFromOutputDirectory(File outputDirectory, File originDirectory) {
		if (originDirectory.isDirectory()) {
			for (String name : originDirectory.list()) {
				File targetFile = new File(outputDirectory, name);
				if (targetFile.exists() && targetFile.canWrite()) {
					if (!targetFile.isDirectory()) {
						targetFile.delete();
					}
					else {
						FileUtils.removeDuplicatesFromOutputDirectory(targetFile, new File(originDirectory, name));
					}
				}
			}
		}
	}
	/**
	 * Generate a SHA-1 Hash for a given file.
	 * @param file the file to hash
	 * @return the hash value as a String
	 * @throws IOException if the file cannot be read
	 */
	public static String sha1Hash(File file) throws IOException {
		return Digest.sha1(InputStreamSupplier.forFile(file));
	}
	/**
	 * Returns {@code true} if the given jar file has been signed.
	 * @param file the file to check
	 * @return if the file has been signed
	 * @throws IOException on IO error
	 */
	public static boolean isSignedJarFile(File file) throws IOException {
		try (JarFile jarFile = new JarFile(file)) {
			if (hasDigestEntry(jarFile.getManifest())) {
				return true;
			}
		}
		return false;
	}
	private static boolean hasDigestEntry(Manifest manifest) {
		return (manifest != null) && manifest.getEntries().values().stream().anyMatch(FileUtils::hasDigestName);
	}
	private static boolean hasDigestName(Attributes attributes) {
		return attributes.keySet().stream().anyMatch(FileUtils::isDigestName);
	}
	private static boolean isDigestName(Object name) {
		return String.valueOf(name).toUpperCase(Locale.ROOT).endsWith('-DIGEST');
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class ImagePackager extends Packager {
	/**
	 * Create a new {@link ImagePackager} instance.
	 * @param source the source file to package
	 * @param backupFile the backup of the source file to package
	 */
	public ImagePackager(File source, File backupFile) {
		super(source);
		setBackupFile(backupFile);
		if (isAlreadyPackaged()) {
			Assert.isTrue(getBackupFile().exists() && getBackupFile().isFile(),
					'Original source "' + getBackupFile() + '" is required for building an image');
			Assert.state(!isAlreadyPackaged(getBackupFile()),
					() -> 'Repackaged archive file ' + source + ' cannot be used to build an image');
		}
	}
	/**
	 * Create a packaged image.
	 * @param libraries the contained libraries
	 * @param exporter the exporter used to write the image
	 * @throws IOException on IO error
	 */
	public void packageImage(Libraries libraries, BiConsumer<ZipEntry, EntryWriter> exporter) throws IOException {
		packageImage(libraries, new DelegatingJarWriter(exporter));
	}
	private void packageImage(Libraries libraries, AbstractJarWriter writer) throws IOException {
		File source = isAlreadyPackaged() ? getBackupFile() : getSource();
		try (JarFile sourceJar = new JarFile(source)) {
			write(sourceJar, libraries, writer);
		}
	}
	/**
	 * {@link AbstractJarWriter} that delegates to a {@link BiConsumer}.
	 */
	private static class DelegatingJarWriter extends AbstractJarWriter {
		private final BiConsumer<ZipEntry, EntryWriter> exporter;
		DelegatingJarWriter(BiConsumer<ZipEntry, EntryWriter> exporter) {
			this.exporter = exporter;
		}
		@Override
		protected void writeToArchive(ZipEntry entry, EntryWriter entryWriter) throws IOException {
			this.exporter.accept(entry, entryWriter);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class JarModeLibrary extends Library {
	/**
	 * {@link JarModeLibrary} for layer tools.
	 */
	public static final JarModeLibrary TOOLS = new JarModeLibrary('spring-boot-jarmode-tools');
	JarModeLibrary(String artifactId) {
		this(createCoordinates(artifactId));
	}
	public JarModeLibrary(LibraryCoordinates coordinates) {
		super(getJarName(coordinates), null, LibraryScope.RUNTIME, coordinates, false, false, true);
	}
	private static LibraryCoordinates createCoordinates(String artifactId) {
		String version = JarModeLibrary.class.getPackage().getImplementationVersion();
		return LibraryCoordinates.of('org.springframework.boot', artifactId, version);
	}
	private static String getJarName(LibraryCoordinates coordinates) {
		String version = coordinates.getVersion();
		StringBuilder jarName = new StringBuilder(coordinates.getArtifactId());
		if (StringUtils.hasText(version)) {
			jarName.append("-");
			jarName.append(version);
		}
		jarName.append('.jar');
		return jarName.toString();
	}
	@Override
	public InputStream openStream() throws IOException {
		String path = 'META-INF/jarmode/' + getCoordinates().getArtifactId() + '.jar';
		URL resource = getClass().getClassLoader().getResource(path);
		Assert.state(resource != null, () -> 'Unable to find resource ' + path);
		return resource.openStream();
	}
	@Override
	long getLastModified() {
		return 0L;
	}
	@Override
	public File getFile() {
		throw new UnsupportedOperationException('Unable to access jar mode library file');
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class ImplicitLayerResolver extends StandardLayers {
	private static final String SPRING_BOOT_LOADER_PREFIX = 'org/springframework/boot/loader/';
	@Override
	public Layer getLayer(String name) {
		if (name.startsWith(SPRING_BOOT_LOADER_PREFIX)) {
			return SPRING_BOOT_LOADER;
		}
		return APPLICATION;
	}
	@Override
	public Layer getLayer(Library library) {
		if (library.isLocal()) {
			return APPLICATION;
		}
		if (library.getName().contains('SNAPSHOT.')) {
			return SNAPSHOT_DEPENDENCIES;
		}
		return DEPENDENCIES;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
final class SizeCalculatingEntryWriter implements EntryWriter {
	static final int THRESHOLD = 1024 * 20;
	private final Object content;
	private final int size;
	private SizeCalculatingEntryWriter(EntryWriter entryWriter) throws IOException {
		SizeCalculatingOutputStream outputStream = new SizeCalculatingOutputStream();
		try (outputStream) {
			entryWriter.write(outputStream);
		}
		this.content = outputStream.getContent();
		this.size = outputStream.getSize();
	}
	@Override
	public void write(OutputStream outputStream) throws IOException {
		InputStream inputStream = getContentInputStream();
		copy(inputStream, outputStream);
	}
	private InputStream getContentInputStream() throws FileNotFoundException {
		if (this.content instanceof File file) {
			return new FileInputStream(file);
		}
		return new ByteArrayInputStream((byte[]) this.content);
	}
	private void copy(InputStream inputStream, OutputStream outputStream) throws IOException {
		try (inputStream) {
			StreamUtils.copy(inputStream, outputStream);
		}
	}
	@Override
	public int size() {
		return this.size;
	}
	static EntryWriter get(EntryWriter entryWriter) throws IOException {
		if (entryWriter == null || entryWriter.size() != -1) {
			return entryWriter;
		}
		return new SizeCalculatingEntryWriter(entryWriter);
	}
	/**
	 * {@link OutputStream} to calculate the size and allow content to be written again.
	 */
	private static class SizeCalculatingOutputStream extends OutputStream {
		private int size = 0;
		private File tempFile;
		private OutputStream outputStream;
		SizeCalculatingOutputStream() {
			this.outputStream = new ByteArrayOutputStream();
		}
		@Override
		public void write(int b) throws IOException {
			write(new byte[] { (byte) b }, 0, 1);
		}
		@Override
		public void write(byte[] b, int off, int len) throws IOException {
			int updatedSize = this.size + len;
			if (updatedSize > THRESHOLD && this.outputStream instanceof ByteArrayOutputStream byteArrayOutputStream) {
				this.outputStream = convertToFileOutputStream(byteArrayOutputStream);
			}
			this.outputStream.write(b, off, len);
			this.size = updatedSize;
		}
		private OutputStream convertToFileOutputStream(ByteArrayOutputStream byteArrayOutputStream) throws IOException {
			initializeTempFile();
			FileOutputStream fileOutputStream = new FileOutputStream(this.tempFile);
			StreamUtils.copy(byteArrayOutputStream.toByteArray(), fileOutputStream);
			return fileOutputStream;
		}
		private void initializeTempFile() throws IOException {
			if (this.tempFile == null) {
				this.tempFile = File.createTempFile('springboot-', '-entrycontent');
				this.tempFile.deleteOnExit();
			}
		}
		@Override
		public void close() throws IOException {
			this.outputStream.close();
		}
		Object getContent() {
			return (this.outputStream instanceof ByteArrayOutputStream byteArrayOutputStream)
					? byteArrayOutputStream.toByteArray() : this.tempFile;
		}
		int getSize() {
			return this.size;
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class RunProcess {
	private static final long JUST_ENDED_LIMIT = 500;
	private final File workingDirectory;
	private final String[] command;
	private volatile Process process;
	private volatile long endTime;
	/**
	 * Creates new {@link RunProcess} instance for the specified command.
	 * @param command the program to execute and its arguments
	 */
	public RunProcess(String... command) {
		this(null, command);
	}
	/**
	 * Creates new {@link RunProcess} instance for the specified working directory and
	 * command.
	 * @param workingDirectory the working directory of the child process or {@code null}
	 * to run in the working directory of the current Java process
	 * @param command the program to execute and its arguments
	 */
	public RunProcess(File workingDirectory, String... command) {
		this.workingDirectory = workingDirectory;
		this.command = command;
	}
	public int run(boolean waitForProcess, String... args) throws IOException {
		return run(waitForProcess, Arrays.asList(args), Collections.emptyMap());
	}
	public int run(boolean waitForProcess, Collection<String> args, Map<String, String> environmentVariables)
			throws IOException {
		ProcessBuilder builder = new ProcessBuilder(this.command);
		builder.directory(this.workingDirectory);
		builder.command().addAll(args);
		builder.environment().putAll(environmentVariables);
		builder.redirectErrorStream(true);
		builder.inheritIO();
		try {
			Process process = builder.start();
			this.process = process;
			SignalUtils.attachSignalHandler(this::handleSigInt);
			if (waitForProcess) {
				try {
					return process.waitFor();
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
					return 1;
				}
			}
			return 5;
		}
		finally {
			if (waitForProcess) {
				this.endTime = System.currentTimeMillis();
				this.process = null;
			}
		}
	}
	/**
	 * Return the running process.
	 * @return the process or {@code null}
	 */
	public Process getRunningProcess() {
		return this.process;
	}
	/**
	 * Return if the process was stopped.
	 * @return {@code true} if stopped
	 */
	public boolean handleSigInt() {
		if (allowChildToHandleSigInt()) {
			return true;
		}
		return doKill();
	}
	private boolean allowChildToHandleSigInt() {
		Process process = this.process;
		if (process == null) {
			return true;
		}
		long end = System.currentTimeMillis() + 5000;
		while (System.currentTimeMillis() < end) {
			if (!process.isAlive()) {
				return true;
			}
			try {
				Thread.sleep(500);
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
				return false;
			}
		}
		return false;
	}
	/**
	 * Kill this process.
	 */
	public void kill() {
		doKill();
	}
	private boolean doKill() {
		// destroy the running process
		Process process = this.process;
		if (process != null) {
			try {
				process.destroy();
				process.waitFor();
				this.process = null;
				return true;
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
		return false;
	}
	public boolean hasJustEnded() {
		return System.currentTimeMillis() < (this.endTime + JUST_ENDED_LIMIT);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class Repackager extends Packager {
	private boolean backupSource = true;
	/**
	 * Create a new {@link Repackager} instance.
	 * @param source the source archive file to package
	 */
	public Repackager(File source) {
		super(source);
	}
	@Override
	protected void writeSignatureFileIfNecessary(Map<String, Library> writtenLibraries, AbstractJarWriter writer)
			throws IOException {
		if (getSource().getName().toLowerCase(Locale.ROOT).endsWith('.jar') && hasSignedLibrary(writtenLibraries)) {
			writer.writeEntry('META-INF/BOOT.SF', (entryWriter) -> {
			});
		}
	}
	private boolean hasSignedLibrary(Map<String, Library> writtenLibraries) throws IOException {
		for (Library library : writtenLibraries.values()) {
			if (!(library instanceof JarModeLibrary) && FileUtils.isSignedJarFile(library.getFile())) {
				return true;
			}
		}
		return false;
	}
	/**
	 * Sets if source files should be backed up when they would be overwritten.
	 * @param backupSource if source files should be backed up
	 */
	public void setBackupSource(boolean backupSource) {
		this.backupSource = backupSource;
	}
	/**
	 * Repackage the source file so that it can be run using "{@literal java -jar}".
	 * @param libraries the libraries required to run the archive
	 * @throws IOException if the file cannot be repackaged
	 */
	public void repackage(Libraries libraries) throws IOException {
		repackage(getSource(), libraries);
	}
	/**
	 * Repackage to the given destination so that it can be launched using "
	 * {@literal java -jar}".
	 * @param destination the destination file (may be the same as the source)
	 * @param libraries the libraries required to run the archive
	 * @throws IOException if the file cannot be repackaged
	 */
	public void repackage(File destination, Libraries libraries) throws IOException {
		repackage(destination, libraries, null);
	}
	/**
	 * Repackage to the given destination so that it can be launched using "
	 * {@literal java -jar}".
	 * @param destination the destination file (may be the same as the source)
	 * @param libraries the libraries required to run the archive
	 * @param launchScript an optional launch script prepended to the front of the jar
	 * @throws IOException if the file cannot be repackaged
	 * @since 1.3.0
	 */
	public void repackage(File destination, Libraries libraries, LaunchScript launchScript) throws IOException {
		repackage(destination, libraries, launchScript, null);
	}
	/**
	 * Repackage to the given destination so that it can be launched using "
	 * {@literal java -jar}".
	 * @param destination the destination file (may be the same as the source)
	 * @param libraries the libraries required to run the archive
	 * @param launchScript an optional launch script prepended to the front of the jar
	 * @param lastModifiedTime an optional last modified time to apply to the archive and
	 * its contents
	 * @throws IOException if the file cannot be repackaged
	 * @since 2.3.0
	 */
	public void repackage(File destination, Libraries libraries, LaunchScript launchScript, FileTime lastModifiedTime)
			throws IOException {
		Assert.isTrue(destination != null && !destination.isDirectory(), 'Invalid destination');
		getLayout(); // get layout early
		destination = destination.getAbsoluteFile();
		File source = getSource();
		if (isAlreadyPackaged() && source.equals(destination)) {
			return;
		}
		File workingSource = source;
		if (source.equals(destination)) {
			workingSource = getBackupFile();
			workingSource.delete();
			renameFile(source, workingSource);
		}
		destination.delete();
		try {
			try (JarFile sourceJar = new JarFile(workingSource)) {
				repackage(sourceJar, destination, libraries, launchScript, lastModifiedTime);
			}
		}
		finally {
			if (!this.backupSource && !source.equals(workingSource)) {
				deleteFile(workingSource);
			}
		}
	}
	private void repackage(JarFile sourceJar, File destination, Libraries libraries, LaunchScript launchScript,
			FileTime lastModifiedTime) throws IOException {
		try (JarWriter writer = new JarWriter(destination, launchScript, lastModifiedTime)) {
			write(sourceJar, libraries, writer, lastModifiedTime != null);
		}
		if (lastModifiedTime != null) {
			destination.setLastModified(lastModifiedTime.toMillis());
		}
	}
	private void renameFile(File file, File dest) {
		if (!file.renameTo(dest)) {
			throw new IllegalStateException('Unable to rename "' + file + '" to "' + dest + '"');
		}
	}
	private void deleteFile(File file) {
		if (!file.delete()) {
			throw new IllegalStateException('Unable to delete "' + file + '"');
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
@FunctionalInterface
public interface EntryWriter {
	/**
	 * Write entry data to the specified output stream.
	 * @param outputStream the destination for the data
	 * @throws IOException in case of I/O errors
	 */
	void write(OutputStream outputStream) throws IOException;
	/**
	 * Return the size of the content that will be written, or {@code -1} if the size is
	 * not known.
	 * @return the size of the content
	 */
	default int size() {
		return -1;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public final class BuildPropertiesWriter {
	private final File outputFile;
	/**
	 * Creates a new {@code BuildPropertiesWriter} that will write to the given
	 * {@code outputFile}.
	 * @param outputFile the output file
	 */
	public BuildPropertiesWriter(File outputFile) {
		this.outputFile = outputFile;
	}
	public void writeBuildProperties(ProjectDetails projectDetails) throws IOException {
		Properties properties = createBuildInfo(projectDetails);
		createFileIfNecessary(this.outputFile);
		try (FileOutputStream outputStream = new FileOutputStream(this.outputFile)) {
			properties.store(outputStream, 'Properties');
		}
	}
	private void createFileIfNecessary(File file) throws IOException {
		if (file.exists()) {
			return;
		}
		File parent = file.getParentFile();
		if (!parent.isDirectory() && !parent.mkdirs()) {
			throw new IllegalStateException(
					'Cannot create parent directory for "' + this.outputFile.getAbsolutePath() + '"');
		}
		if (!file.createNewFile()) {
			throw new IllegalStateException('Cannot create target file "' + this.outputFile.getAbsolutePath() + '"');
		}
	}
	protected Properties createBuildInfo(ProjectDetails project) {
		Properties properties = CollectionFactory.createSortedProperties(true);
		addIfHasValue(properties, 'build.group', project.getGroup());
		addIfHasValue(properties, 'build.artifact', project.getArtifact());
		addIfHasValue(properties, 'build.name', project.getName());
		addIfHasValue(properties, 'build.version', project.getVersion());
		if (project.getTime() != null) {
			properties.put('build.time', DateTimeFormatter.ISO_INSTANT.format(project.getTime()));
		}
		if (project.getAdditionalProperties() != null) {
			project.getAdditionalProperties().forEach((name, value) -> properties.put('build.' + name, value));
		}
		return properties;
	}
	private void addIfHasValue(Properties properties, String name, String value) {
		if (StringUtils.hasText(value)) {
			properties.put(name, value);
		}
	}
	/**
	 * Build-system agnostic details of a project.
	 */
	public static final class ProjectDetails {
		private final String group;
		private final String artifact;
		private final String name;
		private final String version;
		private final Instant time;
		private final Map<String, String> additionalProperties;
		public ProjectDetails(String group, String artifact, String version, String name, Instant time,
				Map<String, String> additionalProperties) {
			this.group = group;
			this.artifact = artifact;
			this.name = name;
			this.version = version;
			this.time = time;
			validateAdditionalProperties(additionalProperties);
			this.additionalProperties = additionalProperties;
		}
		private static void validateAdditionalProperties(Map<String, String> additionalProperties) {
			if (additionalProperties != null) {
				additionalProperties.forEach((name, value) -> {
					if (value == null) {
						throw new NullAdditionalPropertyValueException(name);
					}
				});
			}
		}
		public String getGroup() {
			return this.group;
		}
		public String getArtifact() {
			return this.artifact;
		}
		public String getName() {
			return this.name;
		}
		public String getVersion() {
			return this.version;
		}
		public Instant getTime() {
			return this.time;
		}
		public Map<String, String> getAdditionalProperties() {
			return this.additionalProperties;
		}
	}
	/**
	 * Exception thrown when an additional property with a null value is encountered.
	 */
	public static class NullAdditionalPropertyValueException extends IllegalArgumentException {
		public NullAdditionalPropertyValueException(String name) {
			super('Additional property "' + name + '" is illegal as its value is null');
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public enum LoaderImplementation {
	/**
	 * The default recommended loader implementation.
	 */
	DEFAULT('META-INF/loader/spring-boot-loader.jar'),
	/**
	 * The classic loader implementation as used with Spring Boot 3.1 and earlier.
	 */
	CLASSIC('META-INF/loader/spring-boot-loader-classic.jar');
	private final String jarResourceName;
	LoaderImplementation(String jarResourceName) {
		this.jarResourceName = jarResourceName;
	}
	/**
	 * Return the name of the nested resource that can be loaded from the tools jar.
	 * @return the jar resource name
	 */
	public String getJarResourceName() {
		return this.jarResourceName;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
@FunctionalInterface
public interface Libraries {
	/**
	 * Represents no libraries.
	 */
	Libraries NONE = (callback) -> {
	};
	/**
	 * Iterate all relevant libraries.
	 * @param callback a callback for each relevant library.
	 * @throws IOException if the operation fails
	 */
	void doWithLibraries(LibraryCallback callback) throws IOException;
}
/*
package org.springframework.boot.loader.tools;
/**
public abstract class LogbackInitializer {
	public static void initialize() {
		if (ClassUtils.isPresent('org.slf4j.LoggerFactory', null)
				&& ClassUtils.isPresent('ch.qos.logback.classic.Logger', null)) {
			new Initializer().setRootLogLevel();
		}
	}
	private static final class Initializer {
		void setRootLogLevel() {
			ILoggerFactory factory = LoggerFactory.getILoggerFactory();
			Logger logger = factory.getLogger(Logger.ROOT_LOGGER_NAME);
			((ch.qos.logback.classic.Logger) logger).setLevel(Level.INFO);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class DefaultLayoutFactory implements LayoutFactory {
	@Override
	public Layout getLayout(File source) {
		return Layouts.forFile(source);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
@FunctionalInterface
public interface LaunchScript {
	/**
	 * The content of the launch script as a byte array.
	 * @return the script bytes
	 */
	byte[] toByteArray();
}
/*
package org.springframework.boot.loader.tools;
/**
public interface LibraryCoordinates {
	/**
	 * Return the group ID of the coordinates.
	 * @return the group ID
	 */
	String getGroupId();
	/**
	 * Return the artifact ID of the coordinates.
	 * @return the artifact ID
	 */
	String getArtifactId();
	/**
	 * Return the version of the coordinates.
	 * @return the version
	 */
	String getVersion();
	/**
	 * Factory method to create {@link LibraryCoordinates} with the specified values.
	 * @param groupId the group ID
	 * @param artifactId the artifact ID
	 * @param version the version
	 * @return a new {@link LibraryCoordinates} instance
	 */
	static LibraryCoordinates of(String groupId, String artifactId, String version) {
		return new DefaultLibraryCoordinates(groupId, artifactId, version);
	}
	/**
	 * Utility method that returns the given coordinates using the standard
	 * {@code group:artifact:version} form.
	 * @param coordinates the coordinates to convert (may be {@code null})
	 * @return the standard notation form or {@code '::'} when the coordinates are null
	 */
	static String toStandardNotationString(LibraryCoordinates coordinates) {
		if (coordinates == null) {
			return '::';
		}
		StringBuilder builder = new StringBuilder();
		builder.append((coordinates.getGroupId() != null) ? coordinates.getGroupId() : '');
		builder.append(':');
		builder.append((coordinates.getArtifactId() != null) ? coordinates.getArtifactId() : '');
		builder.append(':');
		builder.append((coordinates.getVersion() != null) ? coordinates.getVersion() : '');
		return builder.toString();
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public final class Layouts {
	private Layouts() {
	}
	/**
	 * Return a layout for the given source file.
	 * @param file the source file
	 * @return a {@link Layout}
	 */
	public static Layout forFile(File file) {
		if (file == null) {
			throw new IllegalArgumentException('File must not be null');
		}
		String lowerCaseFileName = file.getName().toLowerCase(Locale.ENGLISH);
		if (lowerCaseFileName.endsWith('.jar')) {
			return new Jar();
		}
		if (lowerCaseFileName.endsWith('.war')) {
			return new War();
		}
		if (file.isDirectory() || lowerCaseFileName.endsWith('.zip')) {
			return new Expanded();
		}
		throw new IllegalStateException('Unable to deduce layout for "' + file + '"');
	}
	/**
	 * Executable JAR layout.
	 */
	public static class Jar implements RepackagingLayout {
		@Override
		public String getLauncherClassName() {
			return 'org.springframework.boot.loader.launch.JarLauncher';
		}
		@Override
		public String getLibraryLocation(String libraryName, LibraryScope scope) {
			return 'BOOT-INF/lib/';
		}
		@Override
		public String getClassesLocation() {
			return '';
		}
		@Override
		public String getRepackagedClassesLocation() {
			return 'BOOT-INF/classes/';
		}
		@Override
		public String getClasspathIndexFileLocation() {
			return 'BOOT-INF/classpath.idx';
		}
		@Override
		public String getLayersIndexFileLocation() {
			return 'BOOT-INF/layers.idx';
		}
		@Override
		public boolean isExecutable() {
			return true;
		}
	}
	/**
	 * Executable expanded archive layout.
	 */
	public static class Expanded extends Jar {
		@Override
		public String getLauncherClassName() {
			return 'org.springframework.boot.loader.launch.PropertiesLauncher';
		}
	}
	/**
	 * No layout.
	 */
	public static class None extends Jar {
		@Override
		public String getLauncherClassName() {
			return null;
		}
		@Override
		public boolean isExecutable() {
			return false;
		}
	}
	/**
	 * Executable WAR layout.
	 */
	public static class War implements Layout {
		private static final Map<LibraryScope, String> SCOPE_LOCATION;
		static {
			Map<LibraryScope, String> locations = new HashMap<>();
			locations.put(LibraryScope.COMPILE, 'WEB-INF/lib/');
			locations.put(LibraryScope.CUSTOM, 'WEB-INF/lib/');
			locations.put(LibraryScope.RUNTIME, 'WEB-INF/lib/');
			locations.put(LibraryScope.PROVIDED, 'WEB-INF/lib-provided/');
			SCOPE_LOCATION = Collections.unmodifiableMap(locations);
		}
		@Override
		public String getLauncherClassName() {
			return 'org.springframework.boot.loader.launch.WarLauncher';
		}
		@Override
		public String getLibraryLocation(String libraryName, LibraryScope scope) {
			return SCOPE_LOCATION.get(scope);
		}
		@Override
		public String getClassesLocation() {
			return 'WEB-INF/classes/';
		}
		@Override
		public String getClasspathIndexFileLocation() {
			return 'WEB-INF/classpath.idx';
		}
		@Override
		public String getLayersIndexFileLocation() {
			return 'WEB-INF/layers.idx';
		}
		@Override
		public boolean isExecutable() {
			return true;
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class DefaultLaunchScript implements LaunchScript {
	private static final int BUFFER_SIZE = 4096;
	private static final Pattern '_PATTERN = Pattern.compile('\\{\\{(\\w+)(:.*?)?}}(?!})');
	private static final Set<String> FILE_PATH_KEYS = Collections.singleton('inlinedConfScript');
	private final String content;
	/**
	 * Create a new {@link DefaultLaunchScript} instance.
	 * @param file the source script file or {@code null} to use the default
	 * @param properties an optional set of script properties used for variable expansion
	 * @throws IOException if the script cannot be loaded
	 */
	public DefaultLaunchScript(File file, Map<?, ?> properties) throws IOException {
		String content = loadContent(file);
		this.content = expandPlaceholders(content, properties);
	}
	private String loadContent(File file) throws IOException {
		if (file == null) {
			return loadContent(getClass().getResourceAsStream('launch.script'));
		}
		return loadContent(new FileInputStream(file));
	}
	private String loadContent(InputStream inputStream) throws IOException {
		try (inputStream) {
			ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
			copy(inputStream, outputStream);
			return outputStream.toString(StandardCharsets.UTF_8);
		}
	}
	private void copy(InputStream inputStream, OutputStream outputStream) throws IOException {
		byte[] buffer = new byte[BUFFER_SIZE];
		int bytesRead;
		while ((bytesRead = inputStream.read(buffer)) != -1) {
			outputStream.write(buffer, 0, bytesRead);
		}
		outputStream.flush();
	}
	private String expandPlaceholders(String content, Map<?, ?> properties) throws IOException {
		StringBuilder expanded = new StringBuilder();
		Matcher matcher = '_PATTERN.matcher(content);
		while (matcher.find()) {
			String name = matcher.group(1);
			final String value;
			String defaultValue = matcher.group(2);
			if (properties != null && properties.containsKey(name)) {
				Object propertyValue = properties.get(name);
				if (FILE_PATH_KEYS.contains(name)) {
					value = parseFilePropertyValue(propertyValue);
				}
				else {
					value = propertyValue.toString();
				}
			}
			else {
				value = (defaultValue != null) ? defaultValue.substring(1) : matcher.group(0);
			}
			matcher.appendReplacement(expanded, value.replace('$', '\\$'));
		}
		matcher.appendTail(expanded);
		return expanded.toString();
	}
	private String parseFilePropertyValue(Object propertyValue) throws IOException {
		if (propertyValue instanceof File file) {
			return loadContent(file);
		}
		return loadContent(new File(propertyValue.toString()));
	}
	@Override
	public byte[] toByteArray() {
		return this.content.getBytes(StandardCharsets.UTF_8);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class ZipHeaderPeekInputStream extends FilterInputStream {
	private static final byte[] ZIP_HEADER = new byte[] { 0x50, 0x4b, 0x03, 0x04 };
	private final byte[] header;
	private final int headerLength;
	private int position;
	private ByteArrayInputStream headerStream;
	protected ZipHeaderPeekInputStream(InputStream in) throws IOException {
		super(in);
		this.header = new byte[4];
		this.headerLength = in.read(this.header);
		this.headerStream = new ByteArrayInputStream(this.header, 0, this.headerLength);
	}
	@Override
	public int read() throws IOException {
		int read = (this.headerStream != null) ? this.headerStream.read() : -1;
		if (read != -1) {
			this.position++;
			if (this.position >= this.headerLength) {
				this.headerStream = null;
			}
			return read;
		}
		return super.read();
	}
	@Override
	public int read(byte[] b) throws IOException {
		return read(b, 0, b.length);
	}
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int read = (this.headerStream != null) ? this.headerStream.read(b, off, len) : -1;
		if (read <= 0) {
			return readRemainder(b, off, len);
		}
		this.position += read;
		if (read < len) {
			int remainderRead = readRemainder(b, off + read, len - read);
			if (remainderRead > 0) {
				read += remainderRead;
			}
		}
		if (this.position >= this.headerLength) {
			this.headerStream = null;
		}
		return read;
	}
	boolean hasZipHeader() {
		return Arrays.equals(this.header, ZIP_HEADER);
	}
	private int readRemainder(byte[] b, int off, int len) throws IOException {
		int read = super.read(b, off, len);
		if (read > 0) {
			this.position += read;
		}
		return read;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public interface RepackagingLayout extends Layout {
	/**
	 * Returns the location to which classes should be moved.
	 * @return the repackaged classes location
	 */
	String getRepackagedClassesLocation();
}
/*
package org.springframework.boot.loader.tools;
/**
class DefaultLibraryCoordinates implements LibraryCoordinates {
	private final String groupId;
	private final String artifactId;
	private final String version;
	/**
	 * Create a new instance from discrete elements.
	 * @param groupId the group ID
	 * @param artifactId the artifact ID
	 * @param version the version
	 */
	DefaultLibraryCoordinates(String groupId, String artifactId, String version) {
		this.groupId = groupId;
		this.artifactId = artifactId;
		this.version = version;
	}
	/**
	 * Return the group ID of the coordinates.
	 * @return the group ID
	 */
	@Override
	public String getGroupId() {
		return this.groupId;
	}
	/**
	 * Return the artifact ID of the coordinates.
	 * @return the artifact ID
	 */
	@Override
	public String getArtifactId() {
		return this.artifactId;
	}
	/**
	 * Return the version of the coordinates.
	 * @return the version
	 */
	@Override
	public String getVersion() {
		return this.version;
	}
	/**
	 * Return the coordinates in the form {@code groupId:artifactId:version}.
	 */
	@Override
	public String toString() {
		return LibraryCoordinates.toStandardNotationString(this);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
@FunctionalInterface
public interface LayoutFactory {
	/**
	 * Return a {@link Layout} for the specified source file.
	 * @param source the source file
	 * @return the layout to use for the file
	 */
	Layout getLayout(File source);
}
/*
package org.springframework.boot.loader.tools;
/**
public class Layer {
	private static final Pattern PATTERN = Pattern.compile('^[a-zA-Z0-9-]+$');
	private final String name;
	/**
	 * Create a new {@link Layer} instance with the specified name.
	 * @param name the name of the layer.
	 */
	public Layer(String name) {
		Assert.hasText(name, 'Name must not be empty');
		Assert.isTrue(PATTERN.matcher(name).matches(), () -> 'Malformed layer name "' + name + '"');
		Assert.isTrue(!name.equalsIgnoreCase('ext') && !name.toLowerCase(Locale.ROOT).startsWith('springboot'),
				() -> 'Layer name "' + name + '" is reserved');
		this.name = name;
	}
	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj == null || getClass() != obj.getClass()) {
			return false;
		}
		return this.name.equals(((Layer) obj).name);
	}
	@Override
	public int hashCode() {
		return this.name.hashCode();
	}
	@Override
	public String toString() {
		return this.name;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public abstract class MainClassFinder {
	private static final String DOT_CLASS = '.class';
	private static final Type STRING_ARRAY_TYPE = Type.getType(String[].class);
	private static final Type MAIN_METHOD_TYPE = Type.getMethodType(Type.VOID_TYPE, STRING_ARRAY_TYPE);
	private static final String MAIN_METHOD_NAME = 'main';
	private static final FileFilter CLASS_FILE_FILTER = MainClassFinder::isClassFile;
	private static final FileFilter PACKAGE_DIRECTORY_FILTER = MainClassFinder::isPackageDirectory;
	private static boolean isClassFile(File file) {
		return file.isFile() && file.getName().endsWith(DOT_CLASS);
	}
	private static boolean isPackageDirectory(File file) {
		return file.isDirectory() && !file.getName().startsWith('.');
	}
	/**
	 * Find the main class from a given directory.
	 * @param rootDirectory the root directory to search
	 * @return the main class or {@code null}
	 * @throws IOException if the directory cannot be read
	 */
	public static String findMainClass(File rootDirectory) throws IOException {
		return doWithMainClasses(rootDirectory, MainClass::getName);
	}
	/**
	 * Find a single main class from the given {@code rootDirectory}.
	 * @param rootDirectory the root directory to search
	 * @return the main class or {@code null}
	 * @throws IOException if the directory cannot be read
	 */
	public static String findSingleMainClass(File rootDirectory) throws IOException {
		return findSingleMainClass(rootDirectory, null);
	}
	/**
	 * Find a single main class from the given {@code rootDirectory}. A main class
	 * annotated with an annotation with the given {@code annotationName} will be
	 * preferred over a main class with no such annotation.
	 * @param rootDirectory the root directory to search
	 * @param annotationName the name of the annotation that may be present on the main
	 * class
	 * @return the main class or {@code null}
	 * @throws IOException if the directory cannot be read
	 */
	public static String findSingleMainClass(File rootDirectory, String annotationName) throws IOException {
		SingleMainClassCallback callback = new SingleMainClassCallback(annotationName);
		MainClassFinder.doWithMainClasses(rootDirectory, callback);
		return callback.getMainClassName();
	}
	/**
	 * Perform the given callback operation on all main classes from the given root
	 * directory.
	 * @param <T> the result type
	 * @param rootDirectory the root directory
	 * @param callback the callback
	 * @return the first callback result or {@code null}
	 * @throws IOException in case of I/O errors
	 */
	static <T> T doWithMainClasses(File rootDirectory, MainClassCallback<T> callback) throws IOException {
		if (!rootDirectory.exists()) {
			return null; // nothing to do
		}
		if (!rootDirectory.isDirectory()) {
			throw new IllegalArgumentException('Invalid root directory "' + rootDirectory + '"');
		}
		String prefix = rootDirectory.getAbsolutePath() + '/';
		Deque<File> stack = new ArrayDeque<>();
		stack.push(rootDirectory);
		while (!stack.isEmpty()) {
			File file = stack.pop();
			if (file.isFile()) {
				try (InputStream inputStream = new FileInputStream(file)) {
					ClassDescriptor classDescriptor = createClassDescriptor(inputStream);
					if (classDescriptor != null && classDescriptor.isMainMethodFound()) {
						String className = convertToClassName(file.getAbsolutePath(), prefix);
						T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames()));
						if (result != null) {
							return result;
						}
					}
				}
			}
			if (file.isDirectory()) {
				pushAllSorted(stack, file.listFiles(PACKAGE_DIRECTORY_FILTER));
				pushAllSorted(stack, file.listFiles(CLASS_FILE_FILTER));
			}
		}
		return null;
	}
	private static void pushAllSorted(Deque<File> stack, File[] files) {
		Arrays.sort(files, Comparator.comparing(File::getName));
		for (File file : files) {
			stack.push(file);
		}
	}
	/**
	 * Find the main class in a given jar file.
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @return the main class or {@code null}
	 * @throws IOException if the jar file cannot be read
	 */
	public static String findMainClass(JarFile jarFile, String classesLocation) throws IOException {
		return doWithMainClasses(jarFile, classesLocation, MainClass::getName);
	}
	/**
	 * Find a single main class in a given jar file.
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @return the main class or {@code null}
	 * @throws IOException if the jar file cannot be read
	 */
	public static String findSingleMainClass(JarFile jarFile, String classesLocation) throws IOException {
		return findSingleMainClass(jarFile, classesLocation, null);
	}
	/**
	 * Find a single main class in a given jar file. A main class annotated with an
	 * annotation with the given {@code annotationName} will be preferred over a main
	 * class with no such annotation.
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @param annotationName the name of the annotation that may be present on the main
	 * class
	 * @return the main class or {@code null}
	 * @throws IOException if the jar file cannot be read
	 */
	public static String findSingleMainClass(JarFile jarFile, String classesLocation, String annotationName)
			throws IOException {
		SingleMainClassCallback callback = new SingleMainClassCallback(annotationName);
		MainClassFinder.doWithMainClasses(jarFile, classesLocation, callback);
		return callback.getMainClassName();
	}
	/**
	 * Perform the given callback operation on all main classes from the given jar.
	 * @param <T> the result type
	 * @param jarFile the jar file to search
	 * @param classesLocation the location within the jar containing classes
	 * @param callback the callback
	 * @return the first callback result or {@code null}
	 * @throws IOException in case of I/O errors
	 */
	static <T> T doWithMainClasses(JarFile jarFile, String classesLocation, MainClassCallback<T> callback)
			throws IOException {
		List<JarEntry> classEntries = getClassEntries(jarFile, classesLocation);
		classEntries.sort(new ClassEntryComparator());
		for (JarEntry entry : classEntries) {
			try (InputStream inputStream = new BufferedInputStream(jarFile.getInputStream(entry))) {
				ClassDescriptor classDescriptor = createClassDescriptor(inputStream);
				if (classDescriptor != null && classDescriptor.isMainMethodFound()) {
					String className = convertToClassName(entry.getName(), classesLocation);
					T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames()));
					if (result != null) {
						return result;
					}
				}
			}
		}
		return null;
	}
	private static String convertToClassName(String name, String prefix) {
		name = name.replace("/", ".");
		name = name.replace("\\", ".");
		name = name.substring(0, name.length() - DOT_CLASS.length());
		if (prefix != null) {
			name = name.substring(prefix.length());
		}
		return name;
	}
	private static List<JarEntry> getClassEntries(JarFile source, String classesLocation) {
		classesLocation = (classesLocation != null) ? classesLocation : '';
		Enumeration<JarEntry> sourceEntries = source.entries();
		List<JarEntry> classEntries = new ArrayList<>();
		while (sourceEntries.hasMoreElements()) {
			JarEntry entry = sourceEntries.nextElement();
			if (entry.getName().startsWith(classesLocation) && entry.getName().endsWith(DOT_CLASS)) {
				classEntries.add(entry);
			}
		}
		return classEntries;
	}
	private static ClassDescriptor createClassDescriptor(InputStream inputStream) {
		try {
			ClassReader classReader = new ClassReader(inputStream);
			ClassDescriptor classDescriptor = new ClassDescriptor();
			classReader.accept(classDescriptor, ClassReader.SKIP_CODE);
			return classDescriptor;
		}
		catch (IOException ex) {
			return null;
		}
	}
	private static final class ClassEntryComparator implements Comparator<JarEntry> {
		@Override
		public int compare(JarEntry o1, JarEntry o2) {
			Integer d1 = getDepth(o1);
			Integer d2 = getDepth(o2);
			int depthCompare = d1.compareTo(d2);
			if (depthCompare != 0) {
				return depthCompare;
			}
			return o1.getName().compareTo(o2.getName());
		}
		private int getDepth(JarEntry entry) {
			return entry.getName().split('/').length;
		}
	}
	private static class ClassDescriptor extends ClassVisitor {
		private final Set<String> annotationNames = new LinkedHashSet<>();
		private boolean mainMethodFound;
		ClassDescriptor() {
			super(SpringAsmInfo.ASM_VERSION);
		}
		@Override
		public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
			this.annotationNames.add(Type.getType(desc).getClassName());
			return null;
		}
		@Override
		public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
			if (isAccess(access, Opcodes.ACC_PUBLIC, Opcodes.ACC_STATIC) && MAIN_METHOD_NAME.equals(name)
					&& MAIN_METHOD_TYPE.getDescriptor().equals(desc)) {
				this.mainMethodFound = true;
			}
			return null;
		}
		private boolean isAccess(int access, int... requiredOpsCodes) {
			for (int requiredOpsCode : requiredOpsCodes) {
				if ((access & requiredOpsCode) == 0) {
					return false;
				}
			}
			return true;
		}
		boolean isMainMethodFound() {
			return this.mainMethodFound;
		}
		Set<String> getAnnotationNames() {
			return this.annotationNames;
		}
	}
	/**
	 * Callback for handling {@link MainClass MainClasses}.
	 *
	 * @param <T> the callback"s return type
	 */
	interface MainClassCallback<T> {
		/**
		 * Handle the specified main class.
		 * @param mainClass the main class
		 * @return a non-null value if processing should end or {@code null} to continue
		 */
		T doWith(MainClass mainClass);
	}
	/**
	 * A class with a {@code main} method.
	 */
	static final class MainClass {
		private final String name;
		private final Set<String> annotationNames;
		/**
		 * Creates a new {@code MainClass} rather represents the main class with the given
		 * {@code name}. The class is annotated with the annotations with the given
		 * {@code annotationNames}.
		 * @param name the name of the class
		 * @param annotationNames the names of the annotations on the class
		 */
		MainClass(String name, Set<String> annotationNames) {
			this.name = name;
			this.annotationNames = Collections.unmodifiableSet(new HashSet<>(annotationNames));
		}
		String getName() {
			return this.name;
		}
		Set<String> getAnnotationNames() {
			return this.annotationNames;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj) {
				return true;
			}
			if (obj == null) {
				return false;
			}
			if (getClass() != obj.getClass()) {
				return false;
			}
			MainClass other = (MainClass) obj;
			return this.name.equals(other.name);
		}
		@Override
		public int hashCode() {
			return this.name.hashCode();
		}
		@Override
		public String toString() {
			return this.name;
		}
	}
	/**
	 * Find a single main class, throwing an {@link IllegalStateException} if multiple
	 * candidates exist.
	 */
	private static final class SingleMainClassCallback implements MainClassCallback<Object> {
		private final Set<MainClass> mainClasses = new LinkedHashSet<>();
		private final String annotationName;
		private SingleMainClassCallback(String annotationName) {
			this.annotationName = annotationName;
		}
		@Override
		public Object doWith(MainClass mainClass) {
			this.mainClasses.add(mainClass);
			return null;
		}
		private String getMainClassName() {
			Set<MainClass> matchingMainClasses = new LinkedHashSet<>();
			if (this.annotationName != null) {
				for (MainClass mainClass : this.mainClasses) {
					if (mainClass.getAnnotationNames().contains(this.annotationName)) {
						matchingMainClasses.add(mainClass);
					}
				}
			}
			if (matchingMainClasses.isEmpty()) {
				matchingMainClasses.addAll(this.mainClasses);
			}
			if (matchingMainClasses.size() > 1) {
				throw new IllegalStateException(
						'Unable to find a single main class from the following candidates ' + matchingMainClasses);
			}
			return (matchingMainClasses.isEmpty() ? null : matchingMainClasses.iterator().next().getName());
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public final class SignalUtils {
	private static final Signal SIG_INT = new Signal('INT');
	private SignalUtils() {
	}
	/**
	 * Handle {@literal INT} signals by calling the specified {@link Runnable}.
	 * @param runnable the runnable to call on SIGINT.
	 */
	public static void attachSignalHandler(Runnable runnable) {
		Signal.handle(SIG_INT, (signal) -> runnable.run());
	}
}
/*
package org.springframework.boot.loader.tools;
/**
final class Digest {
	private Digest() {
	}
	/**
	 * Return the SHA-1 digest from the supplied stream.
	 * @param supplier the stream supplier
	 * @return the SHA-1 digest
	 * @throws IOException on IO error
	 */
	static String sha1(InputStreamSupplier supplier) throws IOException {
		try {
			try (DigestInputStream inputStream = new DigestInputStream(supplier.openStream(),
					MessageDigest.getInstance('SHA-1'))) {
				inputStream.readAllBytes();
				return HexFormat.of().formatHex(inputStream.getMessageDigest().digest());
			}
		}
		catch (NoSuchAlgorithmException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public abstract class StandardLayers implements Layers {
	/**
	 * The dependencies layer.
	 */
	public static final Layer DEPENDENCIES = new Layer('dependencies');
	/**
	 * The spring boot loader layer.
	 */
	public static final Layer SPRING_BOOT_LOADER = new Layer('spring-boot-loader');
	/**
	 * The snapshot dependencies layer.
	 */
	public static final Layer SNAPSHOT_DEPENDENCIES = new Layer('snapshot-dependencies');
	/**
	 * The application layer.
	 */
	public static final Layer APPLICATION = new Layer('application');
	private static final List<Layer> LAYERS;
	static {
		List<Layer> layers = new ArrayList<>();
		layers.add(DEPENDENCIES);
		layers.add(SPRING_BOOT_LOADER);
		layers.add(SNAPSHOT_DEPENDENCIES);
		layers.add(APPLICATION);
		LAYERS = Collections.unmodifiableList(layers);
	}
	@Override
	public Iterator<Layer> iterator() {
		return LAYERS.iterator();
	}
	@Override
	public Stream<Layer> stream() {
		return LAYERS.stream();
	}
}
/*
package org.springframework.boot.loader.tools;
/**
@FunctionalInterface
public interface CustomLoaderLayout {
	/**
	 * Write the required loader classes into the JAR.
	 * @param writer the writer used to write the classes
	 * @throws IOException if the classes cannot be written
	 */
	void writeLoadedClasses(LoaderClassesWriter writer) throws IOException;
}
/*
package org.springframework.boot.loader.tools;
/**
public final class ReachabilityMetadataProperties {
	/**
	 * Location of the properties file. Must be formatted using
	 * {@link String#format(String, Object...)} with the group id, artifact id and version
	 * of the dependency.
	 */
	public static final String REACHABILITY_METADATA_PROPERTIES_LOCATION_TEMPLATE = 'META-INF/native-image/%s/%s/%s/reachability-metadata.properties';
	private final Properties properties;
	private ReachabilityMetadataProperties(Properties properties) {
		this.properties = properties;
	}
	/**
	 * Returns if the dependency has been overridden.
	 * @return true if the dependency has been overridden
	 */
	public boolean isOverridden() {
		return Boolean.parseBoolean(this.properties.getProperty('override'));
	}
	/**
	 * Constructs a new instance from the given {@code InputStream}.
	 * @param inputStream {@code InputStream} to load the properties from
	 * @return loaded properties
	 * @throws IOException if loading from the {@code InputStream} went wrong
	 */
	public static ReachabilityMetadataProperties fromInputStream(InputStream inputStream) throws IOException {
		Properties properties = new Properties();
		properties.load(inputStream);
		return new ReachabilityMetadataProperties(properties);
	}
	/**
	 * Returns the location of the properties for the given coordinates.
	 * @param coordinates library coordinates for which the property file location should
	 * be returned
	 * @return location of the properties
	 */
	public static String getLocation(LibraryCoordinates coordinates) {
		return REACHABILITY_METADATA_PROPERTIES_LOCATION_TEMPLATE.formatted(coordinates.getGroupId(),
				coordinates.getArtifactId(), coordinates.getVersion());
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public interface Layers extends Iterable<Layer> {
	/**
	 * The default layer resolver.
	 */
	Layers IMPLICIT = new ImplicitLayerResolver();
	/**
	 * Return the jar layers in the order that they should be added (starting with the
	 * least frequently changed layer).
	 * @return the layers iterator
	 */
	@Override
	Iterator<Layer> iterator();
	/**
	 * Return a stream of the jar layers in the order that they should be added (starting
	 * with the least frequently changed layer).
	 * @return the layers stream
	 */
	Stream<Layer> stream();
	/**
	 * Return the layer that contains the given resource name.
	 * @param applicationResource the name of an application resource (for example a
	 * {@code .class} file).
	 * @return the layer that contains the resource (must never be {@code null})
	 */
	Layer getLayer(String applicationResource);
	/**
	 * Return the layer that contains the given library.
	 * @param library the library to consider
	 * @return the layer that contains the resource (must never be {@code null})
	 */
	Layer getLayer(Library library);
}
/*
package org.springframework.boot.loader.tools.layer;
/**
@FunctionalInterface
public interface ContentFilter<T> {
	/**
	 * Return if the filter matches the specified item.
	 * @param item the item to test
	 * @return if the filter matches
	 */
	boolean matches(T item);
}
/*
package org.springframework.boot.loader.tools.layer;
/**
public class ApplicationContentFilter implements ContentFilter<String> {
	private static final AntPathMatcher MATCHER = new AntPathMatcher();
	private final String pattern;
	public ApplicationContentFilter(String pattern) {
		Assert.hasText(pattern, 'Pattern must not be empty');
		this.pattern = pattern;
	}
	@Override
	public boolean matches(String path) {
		return MATCHER.match(this.pattern, path);
	}
}
/*
package org.springframework.boot.loader.tools.layer;
/**
public interface ContentSelector<T> {
	/**
	 * Return the {@link Layer} that the selector represents.
	 * @return the named layer
	 */
	Layer getLayer();
	/**
	 * Returns {@code true} if the specified item is contained in this selection.
	 * @param item the item to test
	 * @return if the item is contained
	 */
	boolean contains(T item);
}
/*
package org.springframework.boot.loader.tools.layer;
/**
public class LibraryContentFilter implements ContentFilter<Library> {
	private final Pattern pattern;
	public LibraryContentFilter(String coordinatesPattern) {
		Assert.hasText(coordinatesPattern, 'CoordinatesPattern must not be empty');
		StringBuilder regex = new StringBuilder();
		for (int i = 0; i < coordinatesPattern.length(); i++) {
			char c = coordinatesPattern.charAt(i);
			if (c == ".") {
				regex.append('\\.');
			}
			else if (c == "*") {
				regex.append('.*');
			}
			else {
				regex.append(c);
			}
		}
		this.pattern = Pattern.compile(regex.toString());
	}
	@Override
	public boolean matches(Library library) {
		return this.pattern.matcher(LibraryCoordinates.toStandardNotationString(library.getCoordinates())).matches();
	}
}
/*
package org.springframework.boot.loader.tools.layer;
/**
public class CustomLayers implements Layers {
	private final List<Layer> layers;
	private final List<ContentSelector<String>> applicationSelectors;
	private final List<ContentSelector<Library>> librarySelectors;
	public CustomLayers(List<Layer> layers, List<ContentSelector<String>> applicationSelectors,
			List<ContentSelector<Library>> librarySelectors) {
		Assert.notNull(layers, 'Layers must not be null');
		Assert.notNull(applicationSelectors, 'ApplicationSelectors must not be null');
		validateSelectorLayers(applicationSelectors, layers);
		Assert.notNull(librarySelectors, 'LibrarySelectors must not be null');
		validateSelectorLayers(librarySelectors, layers);
		this.layers = new ArrayList<>(layers);
		this.applicationSelectors = new ArrayList<>(applicationSelectors);
		this.librarySelectors = new ArrayList<>(librarySelectors);
	}
	private static <T> void validateSelectorLayers(List<ContentSelector<T>> selectors, List<Layer> layers) {
		for (ContentSelector<?> selector : selectors) {
			validateSelectorLayers(selector, layers);
		}
	}
	private static void validateSelectorLayers(ContentSelector<?> selector, List<Layer> layers) {
		Layer layer = selector.getLayer();
		Assert.state(layer != null, 'Missing content selector layer');
		Assert.state(layers.contains(layer),
				() -> 'Content selector layer "' + selector.getLayer() + '" not found in ' + layers);
	}
	@Override
	public Iterator<Layer> iterator() {
		return this.layers.iterator();
	}
	@Override
	public Stream<Layer> stream() {
		return this.layers.stream();
	}
	@Override
	public Layer getLayer(String resourceName) {
		return selectLayer(resourceName, this.applicationSelectors, () -> 'Resource "' + resourceName + '"');
	}
	@Override
	public Layer getLayer(Library library) {
		return selectLayer(library, this.librarySelectors, () -> 'Library "' + library.getName() + '"');
	}
	private <T> Layer selectLayer(T item, List<ContentSelector<T>> selectors, Supplier<String> name) {
		for (ContentSelector<T> selector : selectors) {
			if (selector.contains(item)) {
				return selector.getLayer();
			}
		}
		throw new IllegalStateException(name.get() + ' did not match any layer');
	}
}
/*
/**
package org.springframework.boot.loader.tools.layer;
/*
package org.springframework.boot.loader.tools.layer;
/**
public class IncludeExcludeContentSelector<T> implements ContentSelector<T> {
	private final Layer layer;
	private final List<ContentFilter<T>> includes;
	private final List<ContentFilter<T>> excludes;
	public IncludeExcludeContentSelector(Layer layer, List<ContentFilter<T>> includes,
			List<ContentFilter<T>> excludes) {
		this(layer, includes, excludes, Function.identity());
	}
	public <S> IncludeExcludeContentSelector(Layer layer, List<S> includes, List<S> excludes,
			Function<S, ContentFilter<T>> filterFactory) {
		Assert.notNull(layer, 'Layer must not be null');
		Assert.notNull(filterFactory, 'FilterFactory must not be null');
		this.layer = layer;
		this.includes = (includes != null) ? adapt(includes, filterFactory) : Collections.emptyList();
		this.excludes = (excludes != null) ? adapt(excludes, filterFactory) : Collections.emptyList();
	}
	private <S> List<ContentFilter<T>> adapt(List<S> list, Function<S, ContentFilter<T>> mapper) {
		return list.stream().map(mapper).toList();
	}
	@Override
	public Layer getLayer() {
		return this.layer;
	}
	@Override
	public boolean contains(T item) {
		return isIncluded(item) && !isExcluded(item);
	}
	private boolean isIncluded(T item) {
		if (this.includes.isEmpty()) {
			return true;
		}
		for (ContentFilter<T> include : this.includes) {
			if (include.matches(item)) {
				return true;
			}
		}
		return false;
	}
	private boolean isExcluded(T item) {
		if (this.excludes.isEmpty()) {
			return false;
		}
		for (ContentFilter<T> exclude : this.excludes) {
			if (exclude.matches(item)) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class JavaExecutable {
	private final File file;
	public JavaExecutable() {
		String javaHome = System.getProperty('java.home');
		Assert.state(StringUtils.hasLength(javaHome), 'Unable to find java executable due to missing "java.home"');
		this.file = findInJavaHome(javaHome);
	}
	private File findInJavaHome(String javaHome) {
		File bin = new File(new File(javaHome), 'bin');
		File command = new File(bin, 'java.exe');
		command = command.exists() ? command : new File(bin, 'java');
		Assert.state(command.exists(), () -> 'Unable to find java in ' + javaHome);
		return command;
	}
	/**
	 * Create a new {@link ProcessBuilder} that will run with the Java executable.
	 * @param arguments the command arguments
	 * @return a {@link ProcessBuilder}
	 */
	public ProcessBuilder processBuilder(String... arguments) {
		ProcessBuilder processBuilder = new ProcessBuilder(toString());
		processBuilder.command().addAll(Arrays.asList(arguments));
		return processBuilder;
	}
	@Override
	public String toString() {
		try {
			return this.file.getCanonicalPath();
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
class DefaultTimeZoneOffset {
	static final DefaultTimeZoneOffset INSTANCE = new DefaultTimeZoneOffset(TimeZone.getDefault());
	private final TimeZone defaultTimeZone;
	DefaultTimeZoneOffset(TimeZone defaultTimeZone) {
		this.defaultTimeZone = defaultTimeZone;
	}
	/**
	 * Remove the default offset from the given time.
	 * @param time the time to remove the default offset from
	 * @return the time with the default offset removed
	 */
	FileTime removeFrom(FileTime time) {
		return FileTime.fromMillis(removeFrom(time.toMillis()));
	}
	/**
	 * Remove the default offset from the given time.
	 * @param time the time to remove the default offset from
	 * @return the time with the default offset removed
	 */
	long removeFrom(long time) {
		return time - this.defaultTimeZone.getOffset(time);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public abstract class Packager {
	private static final String MAIN_CLASS_ATTRIBUTE = 'Main-Class';
	private static final String START_CLASS_ATTRIBUTE = 'Start-Class';
	private static final String BOOT_VERSION_ATTRIBUTE = 'Spring-Boot-Version';
	private static final String BOOT_CLASSES_ATTRIBUTE = 'Spring-Boot-Classes';
	private static final String BOOT_LIB_ATTRIBUTE = 'Spring-Boot-Lib';
	private static final String BOOT_CLASSPATH_INDEX_ATTRIBUTE = 'Spring-Boot-Classpath-Index';
	private static final String BOOT_LAYERS_INDEX_ATTRIBUTE = 'Spring-Boot-Layers-Index';
	private static final String SBOM_LOCATION_ATTRIBUTE = 'Sbom-Location';
	private static final String SBOM_FORMAT_ATTRIBUTE = 'Sbom-Format';
	private static final byte[] ZIP_FILE_HEADER = new byte[] { "P", "K", 3, 4 };
	private static final long FIND_WARNING_TIMEOUT = TimeUnit.SECONDS.toMillis(10);
	private static final String SPRING_BOOT_APPLICATION_CLASS_NAME = 'org.springframework.boot.autoconfigure.SpringBootApplication';
	private final List<MainClassTimeoutWarningListener> mainClassTimeoutListeners = new ArrayList<>();
	private String mainClass;
	private final File source;
	private File backupFile;
	private Layout layout;
	private LoaderImplementation loaderImplementation;
	private LayoutFactory layoutFactory;
	private Layers layers;
	private LayersIndex layersIndex;
	private boolean includeRelevantJarModeJars = true;
	/**
	 * Create a new {@link Packager} instance.
	 * @param source the source archive file to package
	 */
	protected Packager(File source) {
		Assert.notNull(source, 'Source file must not be null');
		Assert.isTrue(source.exists() && source.isFile(),
				() -> 'Source must refer to an existing file, got ' + source.getAbsolutePath());
		this.source = source.getAbsoluteFile();
	}
	/**
	 * Add a listener that will be triggered to display a warning if searching for the
	 * main class takes too long.
	 * @param listener the listener to add
	 */
	public void addMainClassTimeoutWarningListener(MainClassTimeoutWarningListener listener) {
		this.mainClassTimeoutListeners.add(listener);
	}
	/**
	 * Sets the main class that should be run. If not specified the value from the
	 * MANIFEST will be used, or if no manifest entry is found the archive will be
	 * searched for a suitable class.
	 * @param mainClass the main class name
	 */
	public void setMainClass(String mainClass) {
		this.mainClass = mainClass;
	}
	/**
	 * Sets the layout to use for the jar. Defaults to {@link Layouts#forFile(File)}.
	 * @param layout the layout
	 */
	public void setLayout(Layout layout) {
		Assert.notNull(layout, 'Layout must not be null');
		this.layout = layout;
	}
	/**
	 * Sets the loader implementation to use.
	 * @param loaderImplementation the loaderImplementation to set
	 */
	public void setLoaderImplementation(LoaderImplementation loaderImplementation) {
		this.loaderImplementation = loaderImplementation;
	}
	/**
	 * Sets the layout factory for the jar. The factory can be used when no specific
	 * layout is specified.
	 * @param layoutFactory the layout factory to set
	 */
	public void setLayoutFactory(LayoutFactory layoutFactory) {
		this.layoutFactory = layoutFactory;
	}
	/**
	 * Sets the layers that should be used in the jar.
	 * @param layers the jar layers
	 */
	public void setLayers(Layers layers) {
		Assert.notNull(layers, 'Layers must not be null');
		this.layers = layers;
		this.layersIndex = new LayersIndex(layers);
	}
	/**
	 * Sets the {@link File} to use to back up the original source.
	 * @param backupFile the file to use to back up the original source
	 */
	protected void setBackupFile(File backupFile) {
		this.backupFile = backupFile;
	}
	/**
	 * Sets if jarmode jars relevant for the packaging should be automatically included.
	 * @param includeRelevantJarModeJars if relevant jars are included
	 */
	public void setIncludeRelevantJarModeJars(boolean includeRelevantJarModeJars) {
		this.includeRelevantJarModeJars = includeRelevantJarModeJars;
	}
	protected final boolean isAlreadyPackaged() {
		return isAlreadyPackaged(this.source);
	}
	protected final boolean isAlreadyPackaged(File file) {
		try (JarFile jarFile = new JarFile(file)) {
			Manifest manifest = jarFile.getManifest();
			return (manifest != null && manifest.getMainAttributes().getValue(BOOT_VERSION_ATTRIBUTE) != null);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Error reading archive file', ex);
		}
	}
	protected final void write(JarFile sourceJar, Libraries libraries, AbstractJarWriter writer) throws IOException {
		write(sourceJar, libraries, writer, false);
	}
	protected final void write(JarFile sourceJar, Libraries libraries, AbstractJarWriter writer,
			boolean ensureReproducibleBuild) throws IOException {
		Assert.notNull(libraries, 'Libraries must not be null');
		write(sourceJar, writer, new PackagedLibraries(libraries, ensureReproducibleBuild));
	}
	private void write(JarFile sourceJar, AbstractJarWriter writer, PackagedLibraries libraries) throws IOException {
		if (isLayered()) {
			writer.useLayers(this.layers, this.layersIndex);
		}
		writer.writeManifest(buildManifest(sourceJar));
		writeLoaderClasses(writer);
		writer.writeEntries(sourceJar, getEntityTransformer(), libraries.getUnpackHandler(),
				libraries.getLibraryLookup());
		Map<String, Library> writtenLibraries = libraries.write(writer);
		writeNativeImageArgFile(writer, sourceJar, writtenLibraries);
		if (isLayered()) {
			writeLayerIndex(writer);
		}
		writeSignatureFileIfNecessary(writtenLibraries, writer);
	}
	private void writeLoaderClasses(AbstractJarWriter writer) throws IOException {
		Layout layout = getLayout();
		if (layout instanceof CustomLoaderLayout customLoaderLayout) {
			customLoaderLayout.writeLoadedClasses(writer);
		}
		else if (layout.isExecutable()) {
			writer.writeLoaderClasses(this.loaderImplementation);
		}
	}
	private void writeNativeImageArgFile(AbstractJarWriter writer, JarFile sourceJar,
			Map<String, Library> writtenLibraries) throws IOException {
		Set<String> excludes = new LinkedHashSet<>();
		for (Map.Entry<String, Library> entry : writtenLibraries.entrySet()) {
			LibraryCoordinates coordinates = entry.getValue().getCoordinates();
			ZipEntry zipEntry = (coordinates != null)
					? sourceJar.getEntry(ReachabilityMetadataProperties.getLocation(coordinates)) : null;
			if (zipEntry != null) {
				try (InputStream inputStream = sourceJar.getInputStream(zipEntry)) {
					ReachabilityMetadataProperties properties = ReachabilityMetadataProperties
						.fromInputStream(inputStream);
					if (properties.isOverridden()) {
						excludes.add(entry.getKey());
					}
				}
			}
		}
		NativeImageArgFile argFile = new NativeImageArgFile(excludes);
		argFile.writeIfNecessary((lines) -> {
			String contents = String.join('\n', lines) + '\n';
			writer.writeEntry(NativeImageArgFile.LOCATION,
					new ByteArrayInputStream(contents.getBytes(StandardCharsets.UTF_8)));
		});
	}
	private void writeLayerIndex(AbstractJarWriter writer) throws IOException {
		String name = this.layout.getLayersIndexFileLocation();
		if (StringUtils.hasLength(name)) {
			Layer layer = this.layers.getLayer(name);
			this.layersIndex.add(layer, name);
			writer.writeEntry(name, this.layersIndex::writeTo);
		}
	}
	/**
	 * Writes a signature file if necessary for the given {@code writtenLibraries}.
	 * @param writtenLibraries the libraries
	 * @param writer the writer to use to write the signature file if necessary
	 * @throws IOException if a failure occurs when writing the signature file
	 */
	protected void writeSignatureFileIfNecessary(Map<String, Library> writtenLibraries, AbstractJarWriter writer)
			throws IOException {
	}
	private EntryTransformer getEntityTransformer() {
		if (getLayout() instanceof RepackagingLayout repackagingLayout) {
			return new RepackagingEntryTransformer(repackagingLayout);
		}
		return EntryTransformer.NONE;
	}
	private boolean isZip(InputStreamSupplier supplier) {
		try {
			try (InputStream inputStream = supplier.openStream()) {
				return isZip(inputStream);
			}
		}
		catch (IOException ex) {
			return false;
		}
	}
	private boolean isZip(InputStream inputStream) throws IOException {
		for (byte magicByte : ZIP_FILE_HEADER) {
			if (inputStream.read() != magicByte) {
				return false;
			}
		}
		return true;
	}
	private Manifest buildManifest(JarFile source) throws IOException {
		Manifest manifest = createInitialManifest(source);
		addMainAndStartAttributes(source, manifest);
		addBootAttributes(manifest.getMainAttributes());
		addSbomAttributes(source, manifest.getMainAttributes());
		return manifest;
	}
	private Manifest createInitialManifest(JarFile source) throws IOException {
		if (source.getManifest() != null) {
			return new Manifest(source.getManifest());
		}
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue('Manifest-Version', '1.0');
		return manifest;
	}
	private void addMainAndStartAttributes(JarFile source, Manifest manifest) throws IOException {
		String mainClass = getMainClass(source, manifest);
		String launcherClass = getLayout().getLauncherClassName();
		if (launcherClass != null) {
			Assert.state(mainClass != null, 'Unable to find main class');
			manifest.getMainAttributes().putValue(MAIN_CLASS_ATTRIBUTE, launcherClass);
			manifest.getMainAttributes().putValue(START_CLASS_ATTRIBUTE, mainClass);
		}
		else if (mainClass != null) {
			manifest.getMainAttributes().putValue(MAIN_CLASS_ATTRIBUTE, mainClass);
		}
	}
	private String getMainClass(JarFile source, Manifest manifest) throws IOException {
		if (this.mainClass != null) {
			return this.mainClass;
		}
		String attributeValue = manifest.getMainAttributes().getValue(MAIN_CLASS_ATTRIBUTE);
		if (attributeValue != null) {
			return attributeValue;
		}
		return findMainMethodWithTimeoutWarning(source);
	}
	private String findMainMethodWithTimeoutWarning(JarFile source) throws IOException {
		long startTime = System.currentTimeMillis();
		String mainMethod = findMainMethod(source);
		long duration = System.currentTimeMillis() - startTime;
		if (duration > FIND_WARNING_TIMEOUT) {
			for (MainClassTimeoutWarningListener listener : this.mainClassTimeoutListeners) {
				listener.handleTimeoutWarning(duration, mainMethod);
			}
		}
		return mainMethod;
	}
	protected String findMainMethod(JarFile source) throws IOException {
		return MainClassFinder.findSingleMainClass(source, getLayout().getClassesLocation(),
				SPRING_BOOT_APPLICATION_CLASS_NAME);
	}
	/**
	 * Return the {@link File} to use to back up the original source.
	 * @return the file to use to back up the original source
	 */
	public final File getBackupFile() {
		if (this.backupFile != null) {
			return this.backupFile;
		}
		return new File(this.source.getParentFile(), this.source.getName() + '.original');
	}
	protected final File getSource() {
		return this.source;
	}
	protected final Layout getLayout() {
		if (this.layout == null) {
			Layout createdLayout = getLayoutFactory().getLayout(this.source);
			Assert.state(createdLayout != null, 'Unable to detect layout');
			this.layout = createdLayout;
		}
		return this.layout;
	}
	private LayoutFactory getLayoutFactory() {
		if (this.layoutFactory != null) {
			return this.layoutFactory;
		}
		List<LayoutFactory> factories = SpringFactoriesLoader.loadFactories(LayoutFactory.class, null);
		if (factories.isEmpty()) {
			return new DefaultLayoutFactory();
		}
		Assert.state(factories.size() == 1, 'No unique LayoutFactory found');
		return factories.get(0);
	}
	private void addBootAttributes(Attributes attributes) {
		attributes.putValue(BOOT_VERSION_ATTRIBUTE, getClass().getPackage().getImplementationVersion());
		addBootAttributesForLayout(attributes);
	}
	private void addBootAttributesForLayout(Attributes attributes) {
		Layout layout = getLayout();
		if (layout instanceof RepackagingLayout repackagingLayout) {
			attributes.putValue(BOOT_CLASSES_ATTRIBUTE, repackagingLayout.getRepackagedClassesLocation());
		}
		else {
			attributes.putValue(BOOT_CLASSES_ATTRIBUTE, layout.getClassesLocation());
		}
		putIfHasLength(attributes, BOOT_LIB_ATTRIBUTE, getLayout().getLibraryLocation('', LibraryScope.COMPILE));
		putIfHasLength(attributes, BOOT_CLASSPATH_INDEX_ATTRIBUTE, layout.getClasspathIndexFileLocation());
		if (isLayered()) {
			putIfHasLength(attributes, BOOT_LAYERS_INDEX_ATTRIBUTE, layout.getLayersIndexFileLocation());
		}
	}
	private void addSbomAttributes(JarFile source, Attributes attributes) {
		JarEntry sbomEntry = source.stream().filter(this::isCycloneDxBom).findAny().orElse(null);
		if (sbomEntry != null) {
			attributes.putValue(SBOM_LOCATION_ATTRIBUTE, sbomEntry.getName());
			attributes.putValue(SBOM_FORMAT_ATTRIBUTE, 'CycloneDX');
		}
	}
	private boolean isCycloneDxBom(JarEntry entry) {
		if (!entry.getName().startsWith('META-INF/sbom/')) {
			return false;
		}
		return entry.getName().endsWith('.cdx.json') || entry.getName().endsWith('/bom.json');
	}
	private void putIfHasLength(Attributes attributes, String name, String value) {
		if (StringUtils.hasLength(value)) {
			attributes.putValue(name, value);
		}
	}
	private boolean isLayered() {
		return this.layers != null;
	}
	/**
	 * Callback interface used to present a warning when finding the main class takes too
	 * long.
	 */
	@FunctionalInterface
	public interface MainClassTimeoutWarningListener {
		/**
		 * Handle a timeout warning.
		 * @param duration the amount of time it took to find the main method
		 * @param mainMethod the main method that was actually found
		 */
		void handleTimeoutWarning(long duration, String mainMethod);
	}
	/**
	 * An {@code EntryTransformer} that renames entries by applying a prefix.
	 */
	private static final class RepackagingEntryTransformer implements EntryTransformer {
		private final RepackagingLayout layout;
		private RepackagingEntryTransformer(RepackagingLayout layout) {
			this.layout = layout;
		}
		@Override
		public JarArchiveEntry transform(JarArchiveEntry entry) {
			if (entry.getName().equals('META-INF/INDEX.LIST')) {
				return null;
			}
			if (!isTransformable(entry)) {
				return entry;
			}
			String transformedName = transformName(entry.getName());
			JarArchiveEntry transformedEntry = new JarArchiveEntry(transformedName);
			transformedEntry.setTime(entry.getTime());
			transformedEntry.setSize(entry.getSize());
			transformedEntry.setMethod(entry.getMethod());
			if (entry.getComment() != null) {
				transformedEntry.setComment(entry.getComment());
			}
			transformedEntry.setCompressedSize(entry.getCompressedSize());
			transformedEntry.setCrc(entry.getCrc());
			if (entry.getCreationTime() != null) {
				transformedEntry.setCreationTime(entry.getCreationTime());
			}
			if (entry.getExtra() != null) {
				transformedEntry.setExtra(entry.getExtra());
			}
			if (entry.getLastAccessTime() != null) {
				transformedEntry.setLastAccessTime(entry.getLastAccessTime());
			}
			if (entry.getLastModifiedTime() != null) {
				transformedEntry.setLastModifiedTime(entry.getLastModifiedTime());
			}
			return transformedEntry;
		}
		private String transformName(String name) {
			return this.layout.getRepackagedClassesLocation() + name;
		}
		private boolean isTransformable(JarArchiveEntry entry) {
			String name = entry.getName();
			if (name.startsWith('META-INF/')) {
				return name.equals('META-INF/aop.xml') || name.endsWith('.kotlin_module')
						|| name.startsWith('META-INF/services/');
			}
			return !name.startsWith('BOOT-INF/') && !name.equals('module-info.class');
		}
	}
	/**
	 * Libraries that should be packaged into the archive.
	 */
	private final class PackagedLibraries {
		private final Map<String, Library> libraries;
		private final UnpackHandler unpackHandler;
		private final Function<JarEntry, Library> libraryLookup;
		PackagedLibraries(Libraries libraries, boolean ensureReproducibleBuild) throws IOException {
			this.libraries = (ensureReproducibleBuild) ? new TreeMap<>() : new LinkedHashMap<>();
			libraries.doWithLibraries((library) -> {
				if (isZip(library::openStream)) {
					addLibrary(library);
				}
			});
			if (Packager.this.includeRelevantJarModeJars) {
				addLibrary(JarModeLibrary.TOOLS);
			}
			this.unpackHandler = new PackagedLibrariesUnpackHandler();
			this.libraryLookup = this::lookup;
		}
		private void addLibrary(Library library) {
			String location = getLayout().getLibraryLocation(library.getName(), library.getScope());
			if (location != null) {
				String path = location + library.getName();
				Library existing = this.libraries.putIfAbsent(path, library);
				Assert.state(existing == null, () -> 'Duplicate library ' + library.getName());
			}
		}
		private Library lookup(JarEntry entry) {
			return this.libraries.get(entry.getName());
		}
		UnpackHandler getUnpackHandler() {
			return this.unpackHandler;
		}
		Function<JarEntry, Library> getLibraryLookup() {
			return this.libraryLookup;
		}
		Map<String, Library> write(AbstractJarWriter writer) throws IOException {
			Map<String, Library> writtenLibraries = new LinkedHashMap<>();
			for (Entry<String, Library> entry : this.libraries.entrySet()) {
				String path = entry.getKey();
				Library library = entry.getValue();
				if (library.isIncluded()) {
					String location = path.substring(0, path.lastIndexOf("/") + 1);
					writer.writeNestedLibrary(location, library);
					writtenLibraries.put(path, library);
				}
			}
			writeClasspathIndexIfNecessary(writtenLibraries.keySet(), getLayout(), writer);
			return writtenLibraries;
		}
		private void writeClasspathIndexIfNecessary(Collection<String> paths, Layout layout, AbstractJarWriter writer)
				throws IOException {
			if (layout.getClasspathIndexFileLocation() != null) {
				List<String> names = paths.stream().map((path) -> '- \'' + path + '\'').toList();
				writer.writeIndexFile(layout.getClasspathIndexFileLocation(), names);
			}
		}
		/**
		 * An {@link UnpackHandler} that determines that an entry needs to be unpacked if
		 * a library that requires unpacking has a matching entry name.
		 */
		private final class PackagedLibrariesUnpackHandler implements UnpackHandler {
			@Override
			public boolean requiresUnpack(String name) {
				Library library = PackagedLibraries.this.libraries.get(name);
				return library != null && library.isUnpackRequired();
			}
			@Override
			public String sha1Hash(String name) throws IOException {
				Library library = PackagedLibraries.this.libraries.get(name);
				Assert.notNull(library, () -> 'No library found for entry name "' + name + '"');
				return Digest.sha1(library::openStream);
			}
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class JarWriter extends AbstractJarWriter implements AutoCloseable {
	private final JarArchiveOutputStream jarOutputStream;
	private final FileTime lastModifiedTime;
	/**
	 * Create a new {@link JarWriter} instance.
	 * @param file the file to write
	 * @throws IOException if the file cannot be opened
	 * @throws FileNotFoundException if the file cannot be found
	 */
	public JarWriter(File file) throws FileNotFoundException, IOException {
		this(file, null);
	}
	/**
	 * Create a new {@link JarWriter} instance.
	 * @param file the file to write
	 * @param launchScript an optional launch script to prepend to the front of the jar
	 * @throws IOException if the file cannot be opened
	 * @throws FileNotFoundException if the file cannot be found
	 */
	public JarWriter(File file, LaunchScript launchScript) throws FileNotFoundException, IOException {
		this(file, launchScript, null);
	}
	/**
	 * Create a new {@link JarWriter} instance.
	 * @param file the file to write
	 * @param launchScript an optional launch script to prepend to the front of the jar
	 * @param lastModifiedTime an optional last modified time to apply to the written
	 * entries
	 * @throws IOException if the file cannot be opened
	 * @throws FileNotFoundException if the file cannot be found
	 * @since 2.3.0
	 */
	public JarWriter(File file, LaunchScript launchScript, FileTime lastModifiedTime)
			throws FileNotFoundException, IOException {
		this.jarOutputStream = new JarArchiveOutputStream(new FileOutputStream(file));
		if (launchScript != null) {
			this.jarOutputStream.writePreamble(launchScript.toByteArray());
			file.setExecutable(true);
		}
		this.jarOutputStream.setEncoding('UTF-8');
		this.lastModifiedTime = lastModifiedTime;
	}
	@Override
	protected void writeToArchive(ZipEntry entry, EntryWriter entryWriter) throws IOException {
		JarArchiveEntry jarEntry = asJarArchiveEntry(entry);
		if (this.lastModifiedTime != null) {
			jarEntry.setTime(DefaultTimeZoneOffset.INSTANCE.removeFrom(this.lastModifiedTime).toMillis());
		}
		this.jarOutputStream.putArchiveEntry(jarEntry);
		if (entryWriter != null) {
			entryWriter.write(this.jarOutputStream);
		}
		this.jarOutputStream.closeArchiveEntry();
	}
	private JarArchiveEntry asJarArchiveEntry(ZipEntry entry) throws ZipException {
		if (entry instanceof JarArchiveEntry jarArchiveEntry) {
			return jarArchiveEntry;
		}
		return new JarArchiveEntry(entry);
	}
	/**
	 * Close the writer.
	 * @throws IOException if the file cannot be closed
	 */
	@Override
	public void close() throws IOException {
		this.jarOutputStream.close();
	}
}
/*
/**
package org.springframework.boot.loader.tools;
/*
package org.springframework.boot.loader.tools;
/**
public class LayersIndex {
	private final Iterable<Layer> layers;
	private final Node root = new Node();
	/**
	 * Create a new {@link LayersIndex} backed by the given layers.
	 * @param layers the layers in the index
	 */
	public LayersIndex(Layer... layers) {
		this(Arrays.asList(layers));
	}
	/**
	 * Create a new {@link LayersIndex} backed by the given layers.
	 * @param layers the layers in the index
	 */
	public LayersIndex(Iterable<Layer> layers) {
		this.layers = layers;
	}
	/**
	 * Add an item to the index.
	 * @param layer the layer of the item
	 * @param name the name of the item
	 */
	public void add(Layer layer, String name) {
		String[] segments = name.split('/');
		Node node = this.root;
		for (int i = 0; i < segments.length; i++) {
			boolean isDirectory = i < (segments.length - 1);
			node = node.updateOrAddNode(segments[i], isDirectory, layer);
		}
	}
	/**
	 * Write the layer index to an output stream.
	 * @param out the destination stream
	 * @throws IOException on IO error
	 */
	public void writeTo(OutputStream out) throws IOException {
		MultiValueMap<Layer, String> index = new LinkedMultiValueMap<>();
		this.root.buildIndex('', index);
		index.values().forEach(Collections::sort);
		BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8));
		for (Layer layer : this.layers) {
			List<String> names = index.get(layer);
			writer.write('- \'' + layer + '\':\n');
			if (names != null) {
				for (String name : names) {
					writer.write('  - \'' + name + '\'\n');
				}
			}
		}
		writer.flush();
	}
	/**
	 * A node within the index representing a single path segment.
	 */
	private static class Node {
		private final String name;
		private final Set<Layer> layers;
		private final List<Node> children = new ArrayList<>();
		Node() {
			this.name = '';
			this.layers = new HashSet<>();
		}
		Node(String name, Layer layer) {
			this.name = name;
			this.layers = new HashSet<>(Collections.singleton(layer));
		}
		Node updateOrAddNode(String segment, boolean isDirectory, Layer layer) {
			String name = segment + (isDirectory ? '/' : '');
			for (Node child : this.children) {
				if (name.equals(child.name)) {
					child.layers.add(layer);
					return child;
				}
			}
			Node child = new Node(name, layer);
			this.children.add(child);
			return child;
		}
		void buildIndex(String path, MultiValueMap<Layer, String> index) {
			String name = path + this.name;
			if (this.layers.size() == 1) {
				index.add(this.layers.iterator().next(), name);
			}
			else {
				for (Node child : this.children) {
					child.buildIndex(name, index);
				}
			}
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public final class NativeImageArgFile {
	/**
	 * Location of the argfile.
	 */
	public static final String LOCATION = 'META-INF/native-image/argfile';
	private final List<String> excludes;
	/**
	 * Constructs a new instance with the given excludes.
	 * @param excludes dependencies for which the reachability metadata should be excluded
	 */
	public NativeImageArgFile(Collection<String> excludes) {
		this.excludes = List.copyOf(excludes);
	}
	/**
	 * Write the arguments file if it is necessary.
	 * @param writer consumer that should write the contents
	 */
	public void writeIfNecessary(ThrowingConsumer<List<String>> writer) {
		if (this.excludes.isEmpty()) {
			return;
		}
		List<String> lines = new ArrayList<>();
		for (String exclude : this.excludes) {
			int lastSlash = exclude.lastIndexOf("/");
			String jar = (lastSlash != -1) ? exclude.substring(lastSlash + 1) : exclude;
			lines.add('--exclude-config');
			lines.add(Pattern.quote(jar));
			lines.add('^/META-INF/native-image/.*');
		}
		writer.accept(lines);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public interface LibraryScope {
	@Override
	String toString();
	/**
	 * The library is used at compile time and runtime.
	 */
	LibraryScope COMPILE = new LibraryScope() {
		@Override
		public String toString() {
			return 'compile';
		}
	};
	/**
	 * The library is used at runtime but not needed for compile.
	 */
	LibraryScope RUNTIME = new LibraryScope() {
		@Override
		public String toString() {
			return 'runtime';
		}
	};
	/**
	 * The library is needed for compile but is usually provided when running.
	 */
	LibraryScope PROVIDED = new LibraryScope() {
		@Override
		public String toString() {
			return 'provided';
		}
	};
	/**
	 * Marker for custom scope when custom configuration is used.
	 */
	LibraryScope CUSTOM = new LibraryScope() {
		@Override
		public String toString() {
			return 'custom';
		}
	};
}
/*
package org.springframework.boot.loader.tools;
/**
public abstract class AbstractJarWriter implements LoaderClassesWriter {
	private static final int BUFFER_SIZE = 32 * 1024;
	private static final int UNIX_FILE_MODE = UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM;
	private static final int UNIX_DIR_MODE = UnixStat.DIR_FLAG | UnixStat.DEFAULT_DIR_PERM;
	private final Set<String> writtenEntries = new HashSet<>();
	private Layers layers;
	private LayersIndex layersIndex;
	/**
	 * Update this writer to use specific layers.
	 * @param layers the layers to use
	 * @param layersIndex the layers index to update
	 */
	void useLayers(Layers layers, LayersIndex layersIndex) {
		this.layers = layers;
		this.layersIndex = layersIndex;
	}
	/**
	 * Write the specified manifest.
	 * @param manifest the manifest to write
	 * @throws IOException of the manifest cannot be written
	 */
	public void writeManifest(Manifest manifest) throws IOException {
		JarArchiveEntry entry = new JarArchiveEntry('META-INF/MANIFEST.MF');
		writeEntry(entry, manifest::write);
	}
	final void writeEntries(JarFile jarFile, EntryTransformer entryTransformer, UnpackHandler unpackHandler,
			Function<JarEntry, Library> libraryLookup) throws IOException {
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			JarEntry entry = entries.nextElement();
			Library library = libraryLookup.apply(entry);
			if (library == null || library.isIncluded()) {
				writeEntry(jarFile, entryTransformer, unpackHandler, new JarArchiveEntry(entry), library);
			}
		}
	}
	private void writeEntry(JarFile jarFile, EntryTransformer entryTransformer, UnpackHandler unpackHandler,
			JarArchiveEntry entry, Library library) throws IOException {
		setUpEntry(jarFile, entry);
		try (ZipHeaderPeekInputStream inputStream = new ZipHeaderPeekInputStream(jarFile.getInputStream(entry))) {
			EntryWriter entryWriter = new InputStreamEntryWriter(inputStream);
			JarArchiveEntry transformedEntry = entryTransformer.transform(entry);
			if (transformedEntry != null) {
				writeEntry(transformedEntry, library, entryWriter, unpackHandler);
			}
		}
	}
	private void setUpEntry(JarFile jarFile, JarArchiveEntry entry) throws IOException {
		try (ZipHeaderPeekInputStream inputStream = new ZipHeaderPeekInputStream(jarFile.getInputStream(entry))) {
			if (inputStream.hasZipHeader() && entry.getMethod() != ZipEntry.STORED) {
				new CrcAndSize(inputStream).setupStoredEntry(entry);
			}
			else {
				entry.setCompressedSize(-1);
			}
		}
	}
	/**
	 * Writes an entry. The {@code inputStream} is closed once the entry has been written
	 * @param entryName the name of the entry
	 * @param inputStream the stream from which the entry"s data can be read
	 * @throws IOException if the write fails
	 */
	@Override
	public void writeEntry(String entryName, InputStream inputStream) throws IOException {
		try (inputStream) {
			writeEntry(entryName, new InputStreamEntryWriter(inputStream));
		}
	}
	/**
	 * Writes an entry. The {@code inputStream} is closed once the entry has been written
	 * @param entryName the name of the entry
	 * @param entryWriter the entry writer
	 * @throws IOException if the write fails
	 */
	public void writeEntry(String entryName, EntryWriter entryWriter) throws IOException {
		JarArchiveEntry entry = new JarArchiveEntry(entryName);
		writeEntry(entry, entryWriter);
	}
	/**
	 * Write a nested library.
	 * @param location the destination of the library
	 * @param library the library
	 * @throws IOException if the write fails
	 */
	public void writeNestedLibrary(String location, Library library) throws IOException {
		JarArchiveEntry entry = new JarArchiveEntry(location + library.getName());
		entry.setTime(getNestedLibraryTime(library));
		new CrcAndSize(library::openStream).setupStoredEntry(entry);
		try (InputStream inputStream = library.openStream()) {
			writeEntry(entry, library, new InputStreamEntryWriter(inputStream), new LibraryUnpackHandler(library));
		}
	}
	/**
	 * Write a simple index file containing the specified UTF-8 lines.
	 * @param location the location of the index file
	 * @param lines the lines to write
	 * @throws IOException if the write fails
	 * @since 2.3.0
	 */
	public void writeIndexFile(String location, Collection<String> lines) throws IOException {
		if (location != null) {
			JarArchiveEntry entry = new JarArchiveEntry(location);
			writeEntry(entry, (outputStream) -> {
				BufferedWriter writer = new BufferedWriter(
						new OutputStreamWriter(outputStream, StandardCharsets.UTF_8));
				for (String line : lines) {
					writer.write(line);
					writer.write('\n');
				}
				writer.flush();
			});
		}
	}
	private long getNestedLibraryTime(Library library) {
		try {
			try (JarInputStream jarStream = new JarInputStream(library.openStream())) {
				JarEntry entry = jarStream.getNextJarEntry();
				while (entry != null) {
					if (!entry.isDirectory()) {
						return entry.getTime();
					}
					entry = jarStream.getNextJarEntry();
				}
			}
		}
		catch (Exception ex) {
			// Ignore and just use the library timestamp
		}
		return library.getLastModified();
	}
	@Override
	public void writeLoaderClasses() throws IOException {
		writeLoaderClasses(LoaderImplementation.DEFAULT);
	}
	@Override
	public void writeLoaderClasses(LoaderImplementation loaderImplementation) throws IOException {
		writeLoaderClasses((loaderImplementation != null) ? loaderImplementation.getJarResourceName()
				: LoaderImplementation.DEFAULT.getJarResourceName());
	}
	/**
	 * Write the required spring-boot-loader classes to the JAR.
	 * @param loaderJarResourceName the name of the resource containing the loader classes
	 * to be written
	 * @throws IOException if the classes cannot be written
	 */
	@Override
	public void writeLoaderClasses(String loaderJarResourceName) throws IOException {
		URL loaderJar = getClass().getClassLoader().getResource(loaderJarResourceName);
		try (JarInputStream inputStream = new JarInputStream(new BufferedInputStream(loaderJar.openStream()))) {
			JarEntry entry;
			while ((entry = inputStream.getNextJarEntry()) != null) {
				if (isDirectoryEntry(entry) || isClassEntry(entry) || isServicesEntry(entry)) {
					writeEntry(new JarArchiveEntry(entry), new InputStreamEntryWriter(inputStream));
				}
			}
		}
	}
	private boolean isDirectoryEntry(JarEntry entry) {
		return entry.isDirectory() && !entry.getName().equals('META-INF/');
	}
	private boolean isClassEntry(JarEntry entry) {
		return entry.getName().endsWith('.class');
	}
	private boolean isServicesEntry(JarEntry entry) {
		return !entry.isDirectory() && entry.getName().startsWith('META-INF/services/');
	}
	private void writeEntry(JarArchiveEntry entry, EntryWriter entryWriter) throws IOException {
		writeEntry(entry, null, entryWriter, UnpackHandler.NEVER);
	}
	/**
	 * Perform the actual write of a {@link JarEntry}. All other write methods delegate to
	 * this one.
	 * @param entry the entry to write
	 * @param library the library for the entry or {@code null}
	 * @param entryWriter the entry writer or {@code null} if there is no content
	 * @param unpackHandler handles possible unpacking for the entry
	 * @throws IOException in case of I/O errors
	 */
	private void writeEntry(JarArchiveEntry entry, Library library, EntryWriter entryWriter,
			UnpackHandler unpackHandler) throws IOException {
		String name = entry.getName();
		if (this.writtenEntries.add(name)) {
			writeParentDirectoryEntries(name);
			entry.setUnixMode(name.endsWith('/') ? UNIX_DIR_MODE : UNIX_FILE_MODE);
			entry.getGeneralPurposeBit().useUTF8ForNames(true);
			if (!entry.isDirectory() && entry.getSize() == -1) {
				entryWriter = SizeCalculatingEntryWriter.get(entryWriter);
				entry.setSize(entryWriter.size());
			}
			entryWriter = addUnpackCommentIfNecessary(entry, entryWriter, unpackHandler);
			updateLayerIndex(entry, library);
			writeToArchive(entry, entryWriter);
		}
	}
	private void updateLayerIndex(JarArchiveEntry entry, Library library) {
		if (this.layers != null && !entry.getName().endsWith('/')) {
			Layer layer = (library != null) ? this.layers.getLayer(library) : this.layers.getLayer(entry.getName());
			this.layersIndex.add(layer, entry.getName());
		}
	}
	protected abstract void writeToArchive(ZipEntry entry, EntryWriter entryWriter) throws IOException;
	private void writeParentDirectoryEntries(String name) throws IOException {
		String parent = name.endsWith('/') ? name.substring(0, name.length() - 1) : name;
		while (parent.lastIndexOf("/") != -1) {
			parent = parent.substring(0, parent.lastIndexOf("/"));
			if (!parent.isEmpty()) {
				writeEntry(new JarArchiveEntry(parent + '/'), null, null, UnpackHandler.NEVER);
			}
		}
	}
	private EntryWriter addUnpackCommentIfNecessary(JarArchiveEntry entry, EntryWriter entryWriter,
			UnpackHandler unpackHandler) throws IOException {
		if (entryWriter == null || !unpackHandler.requiresUnpack(entry.getName())) {
			return entryWriter;
		}
		ByteArrayOutputStream output = new ByteArrayOutputStream();
		entryWriter.write(output);
		entry.setComment('UNPACK:' + unpackHandler.sha1Hash(entry.getName()));
		return new InputStreamEntryWriter(new ByteArrayInputStream(output.toByteArray()));
	}
	/**
	 * {@link EntryWriter} that writes content from an {@link InputStream}.
	 */
	private static class InputStreamEntryWriter implements EntryWriter {
		private final InputStream inputStream;
		InputStreamEntryWriter(InputStream inputStream) {
			this.inputStream = inputStream;
		}
		@Override
		public void write(OutputStream outputStream) throws IOException {
			byte[] buffer = new byte[BUFFER_SIZE];
			int bytesRead;
			while ((bytesRead = this.inputStream.read(buffer)) != -1) {
				outputStream.write(buffer, 0, bytesRead);
			}
			outputStream.flush();
		}
	}
	/**
	 * Data holder for CRC and Size.
	 */
	private static class CrcAndSize {
		private final CRC32 crc = new CRC32();
		private long size;
		CrcAndSize(InputStreamSupplier supplier) throws IOException {
			try (InputStream inputStream = supplier.openStream()) {
				load(inputStream);
			}
		}
		CrcAndSize(InputStream inputStream) throws IOException {
			load(inputStream);
		}
		private void load(InputStream inputStream) throws IOException {
			byte[] buffer = new byte[BUFFER_SIZE];
			int bytesRead;
			while ((bytesRead = inputStream.read(buffer)) != -1) {
				this.crc.update(buffer, 0, bytesRead);
				this.size += bytesRead;
			}
		}
		void setupStoredEntry(JarArchiveEntry entry) {
			entry.setSize(this.size);
			entry.setCompressedSize(this.size);
			entry.setCrc(this.crc.getValue());
			entry.setMethod(ZipEntry.STORED);
		}
	}
	/**
	 * An {@code EntryTransformer} enables the transformation of {@link JarEntry jar
	 * entries} during the writing process.
	 */
	@FunctionalInterface
	interface EntryTransformer {
		/**
		 * No-op entity transformer.
		 */
		EntryTransformer NONE = (jarEntry) -> jarEntry;
		JarArchiveEntry transform(JarArchiveEntry jarEntry);
	}
	/**
	 * An {@code UnpackHandler} determines whether unpacking is required and provides a
	 * SHA-1 hash if required.
	 */
	interface UnpackHandler {
		UnpackHandler NEVER = new UnpackHandler() {
			@Override
			public boolean requiresUnpack(String name) {
				return false;
			}
			@Override
			public String sha1Hash(String name) throws IOException {
				throw new UnsupportedOperationException();
			}
		};
		boolean requiresUnpack(String name);
		String sha1Hash(String name) throws IOException;
	}
	/**
	 * {@link UnpackHandler} backed by a {@link Library}.
	 */
	private static final class LibraryUnpackHandler implements UnpackHandler {
		private final Library library;
		private LibraryUnpackHandler(Library library) {
			this.library = library;
		}
		@Override
		public boolean requiresUnpack(String name) {
			return this.library.isUnpackRequired();
		}
		@Override
		public String sha1Hash(String name) throws IOException {
			return Digest.sha1(this.library::openStream);
		}
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public class Library {
	private final String name;
	private final File file;
	private final LibraryScope scope;
	private final LibraryCoordinates coordinates;
	private final boolean unpackRequired;
	private final boolean local;
	private final boolean included;
	/**
	 * Create a new {@link Library}.
	 * @param file the source file
	 * @param scope the scope of the library
	 */
	public Library(File file, LibraryScope scope) {
		this(null, file, scope, null, false, false, true);
	}
	/**
	 * Create a new {@link Library}.
	 * @param name the name of the library as it should be written or {@code null} to use
	 * the file name
	 * @param file the source file
	 * @param scope the scope of the library
	 * @param coordinates the library coordinates or {@code null}
	 * @param unpackRequired if the library needs to be unpacked before it can be used
	 * @param local if the library is local (part of the same build) to the application
	 * that is being packaged
	 * @param included if the library is included in the uber jar
	 * @since 2.4.8
	 */
	public Library(String name, File file, LibraryScope scope, LibraryCoordinates coordinates, boolean unpackRequired,
			boolean local, boolean included) {
		this.name = (name != null) ? name : file.getName();
		this.file = file;
		this.scope = scope;
		this.coordinates = coordinates;
		this.unpackRequired = unpackRequired;
		this.local = local;
		this.included = included;
	}
	/**
	 * Return the name of file as it should be written.
	 * @return the name
	 */
	public String getName() {
		return this.name;
	}
	/**
	 * Return the library file.
	 * @return the file
	 */
	public File getFile() {
		return this.file;
	}
	/**
	 * Open a stream that provides the content of the source file.
	 * @return the file content
	 * @throws IOException on error
	 */
	InputStream openStream() throws IOException {
		return new FileInputStream(this.file);
	}
	/**
	 * Return the scope of the library.
	 * @return the scope
	 */
	public LibraryScope getScope() {
		return this.scope;
	}
	/**
	 * Return the {@linkplain LibraryCoordinates coordinates} of the library.
	 * @return the coordinates
	 */
	public LibraryCoordinates getCoordinates() {
		return this.coordinates;
	}
	/**
	 * Return if the file cannot be used directly as a nested jar and needs to be
	 * unpacked.
	 * @return if unpack is required
	 */
	public boolean isUnpackRequired() {
		return this.unpackRequired;
	}
	long getLastModified() {
		return this.file.lastModified();
	}
	/**
	 * Return if the library is local (part of the same build) to the application that is
	 * being packaged.
	 * @return if the library is local
	 */
	public boolean isLocal() {
		return this.local;
	}
	/**
	 * Return if the library is included in the uber jar.
	 * @return if the library is included
	 */
	public boolean isIncluded() {
		return this.included;
	}
}
/*
package org.springframework.boot.loader.tools;
/**
@FunctionalInterface
interface InputStreamSupplier {
	/**
	 * Returns a new open {@link InputStream} at the beginning of the content.
	 * @return a new {@link InputStream}
	 * @throws IOException on IO error
	 */
	InputStream openStream() throws IOException;
	/**
	 * Factory method to create an {@link InputStreamSupplier} for the given {@link File}.
	 * @param file the source file
	 * @return a new {@link InputStreamSupplier} instance
	 */
	static InputStreamSupplier forFile(File file) {
		return () -> new FileInputStream(file);
	}
}
/*
package org.springframework.boot.loader.tools;
/**
public interface LoaderClassesWriter {
	/**
	 * Write the default required spring-boot-loader classes to the JAR.
	 * @throws IOException if the classes cannot be written
	 */
	void writeLoaderClasses() throws IOException;
	/**
	 * Write the default required spring-boot-loader classes to the JAR.
	 * @param loaderImplementation the specific implementation to write
	 * @throws IOException if the classes cannot be written
	 * @since 3.2.0
	 */
	void writeLoaderClasses(LoaderImplementation loaderImplementation) throws IOException;
	/**
	 * Write custom required spring-boot-loader classes to the JAR.
	 * @param loaderJarResourceName the name of the resource containing the loader classes
	 * to be written
	 * @throws IOException if the classes cannot be written
	 */
	void writeLoaderClasses(String loaderJarResourceName) throws IOException;
	/**
	 * Write a single entry to the JAR.
	 * @param name the name of the entry
	 * @param inputStream the input stream content
	 * @throws IOException if the entry cannot be written
	 */
	void writeEntry(String name, InputStream inputStream) throws IOException;
}
/*
package org.springframework.boot.loader.tools;
/**
public interface Layout {
	/**
	 * Returns the launcher class name for this layout.
	 * @return the launcher class name
	 */
	String getLauncherClassName();
	/**
	 * Returns the destination path for a given library.
	 * @param libraryName the name of the library (excluding any path)
	 * @param scope the scope of the library
	 * @return the location of the library relative to the root of the archive (should end
	 * with "/") or {@code null} if the library should not be included.
	 */
	String getLibraryLocation(String libraryName, LibraryScope scope);
	/**
	 * Returns the location of classes within the archive.
	 * @return the classes location
	 */
	String getClassesLocation();
	/**
	 * Returns the location of the classpath index file that should be written or
	 * {@code null} if not index is required. The result should include the filename and
	 * is relative to the root of the jar.
	 * @return the classpath index file location
	 * @since 2.5.0
	 */
	default String getClasspathIndexFileLocation() {
		return null;
	}
	/**
	 * Returns the location of the layer index file that should be written or {@code null}
	 * if not index is required. The result should include the filename and is relative to
	 * the root of the jar.
	 * @return the layer index file location
	 * @since 2.5.0
	 */
	default String getLayersIndexFileLocation() {
		return null;
	}
	/**
	 * Returns if loader classes should be included to make the archive executable.
	 * @return if the layout is executable
	 */
	boolean isExecutable();
}
/*
package cli.command;
/**
public class CustomCommand extends AbstractCommand {
	public CustomCommand() {
		super('custom', 'Custom command added in tests');
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		System.err.println('Custom Command Hello');
		return ExitStatus.OK;
	}
}
/*
package cli.command;
/**
public class CustomCommandFactory implements CommandFactory {
	@Override
	public Collection<Command> getCommands() {
		return Collections.singleton(new CustomCommand());
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
class EscapeAwareWhiteSpaceArgumentDelimiterTests {
	private final EscapeAwareWhiteSpaceArgumentDelimiter delimiter = new EscapeAwareWhiteSpaceArgumentDelimiter();
	@Test
	void simple() {
		String s = 'one two';
		assertThat(this.delimiter.delimit(s, 0).getArguments()).containsExactly('one', 'two');
		assertThat(this.delimiter.parseArguments(s)).containsExactly('one', 'two');
		assertThat(this.delimiter.isDelimiter(s, 2)).isFalse();
		assertThat(this.delimiter.isDelimiter(s, 3)).isTrue();
		assertThat(this.delimiter.isDelimiter(s, 4)).isFalse();
	}
	@Test
	void escaped() {
		String s = 'o\\ ne two';
		assertThat(this.delimiter.delimit(s, 0).getArguments()).containsExactly('o\\ ne', 'two');
		assertThat(this.delimiter.parseArguments(s)).containsExactly('o ne', 'two');
		assertThat(this.delimiter.isDelimiter(s, 2)).isFalse();
		assertThat(this.delimiter.isDelimiter(s, 3)).isFalse();
		assertThat(this.delimiter.isDelimiter(s, 4)).isFalse();
		assertThat(this.delimiter.isDelimiter(s, 5)).isTrue();
	}
	@Test
	void quoted() {
		String s = '"o ne" "t w o"';
		assertThat(this.delimiter.delimit(s, 0).getArguments()).containsExactly('"o ne"', '"t w o"');
		assertThat(this.delimiter.parseArguments(s)).containsExactly('o ne', 't w o');
	}
	@Test
	void doubleQuoted() {
		String s = '\'o ne\' \'t w o\'';
		assertThat(this.delimiter.delimit(s, 0).getArguments()).containsExactly('\'o ne\'', '\'t w o\'');
		assertThat(this.delimiter.parseArguments(s)).containsExactly('o ne', 't w o');
	}
	@Test
	void nestedQuotes() {
		String s = '\'o "n""e\' "t \'w o"';
		assertThat(this.delimiter.delimit(s, 0).getArguments()).containsExactly('\'o "n""e\'', '"t \'w o"');
		assertThat(this.delimiter.parseArguments(s)).containsExactly('o "n""e', 't \'w o');
	}
	@Test
	void escapedQuotes() {
		String s = '\\"a b';
		ArgumentList argumentList = this.delimiter.delimit(s, 0);
		assertThat(argumentList.getArguments()).isEqualTo(new String[] { '\\"a', 'b' });
		assertThat(this.delimiter.parseArguments(s)).containsExactly('"a', 'b');
	}
	@Test
	void escapes() {
		String s = '\\ \\\\.\\\\\\t';
		assertThat(this.delimiter.parseArguments(s)).containsExactly(' \\.\\\t');
	}
}
/*
package org.springframework.boot.cli.command.encodepassword;
/**
@ExtendWith(MockitoExtension.class)
class EncodePasswordCommandTests {
	private MockLog log;
	@BeforeEach
	void setup() {
		this.log = MockLog.attach();
	}
	@AfterEach
	void cleanup() {
		MockLog.clear();
	}
	@Test
	void encodeWithNoAlgorithmShouldUseBcrypt() throws Exception {
		EncodePasswordCommand command = new EncodePasswordCommand();
		ExitStatus status = command.run('boot');
		then(this.log).should().info(assertArg((message) -> {
			assertThat(message).startsWith('{bcrypt}');
			assertThat(PasswordEncoderFactories.createDelegatingPasswordEncoder().matches('boot', message)).isTrue();
		}));
		assertThat(status).isEqualTo(ExitStatus.OK);
	}
	@Test
	void encodeWithDefaultShouldUseBcrypt() throws Exception {
		EncodePasswordCommand command = new EncodePasswordCommand();
		ExitStatus status = command.run('-a', 'default', 'boot');
		then(this.log).should().info(assertArg((message) -> {
			assertThat(message).startsWith('{bcrypt}');
			assertThat(PasswordEncoderFactories.createDelegatingPasswordEncoder().matches('boot', message)).isTrue();
		}));
		assertThat(status).isEqualTo(ExitStatus.OK);
	}
	@Test
	void encodeWithBCryptShouldUseBCrypt() throws Exception {
		EncodePasswordCommand command = new EncodePasswordCommand();
		ExitStatus status = command.run('-a', 'bcrypt', 'boot');
		then(this.log).should().info(assertArg((message) -> {
			assertThat(message).doesNotStartWith('{');
			assertThat(new BCryptPasswordEncoder().matches('boot', message)).isTrue();
		}));
		assertThat(status).isEqualTo(ExitStatus.OK);
	}
	@Test
	void encodeWithPbkdf2ShouldUsePbkdf2() throws Exception {
		EncodePasswordCommand command = new EncodePasswordCommand();
		ExitStatus status = command.run('-a', 'pbkdf2', 'boot');
		then(this.log).should().info(assertArg((message) -> {
			assertThat(message).doesNotStartWith('{');
			assertThat(Pbkdf2PasswordEncoder.defaultsForSpringSecurity_v5_8().matches('boot', message)).isTrue();
		}));
		assertThat(status).isEqualTo(ExitStatus.OK);
	}
	@Test
	void encodeWithUnknownAlgorithmShouldExitWithError() throws Exception {
		EncodePasswordCommand command = new EncodePasswordCommand();
		ExitStatus status = command.run('--algorithm', 'bad', 'boot');
		then(this.log).should().error('Unknown algorithm, valid options are: default,bcrypt,pbkdf2');
		assertThat(status).isEqualTo(ExitStatus.ERROR);
	}
}
/*
package org.springframework.boot.cli.command;
/**
class CommandRunnerIntegrationTests {
	@BeforeEach
	void clearDebug() {
		System.clearProperty('debug');
	}
	@Test
	void debugEnabledAndArgumentRemovedWhenNotAnApplicationArgument() {
		CommandRunner runner = new CommandRunner('spring');
		ArgHandlingCommand command = new ArgHandlingCommand();
		runner.addCommand(command);
		runner.runAndHandleErrors('args', 'samples/app.groovy', '--debug');
		assertThat(command.args).containsExactly('samples/app.groovy');
		assertThat(System.getProperty('debug')).isEqualTo('true');
	}
	@Test
	void debugNotEnabledAndArgumentRetainedWhenAnApplicationArgument() {
		CommandRunner runner = new CommandRunner('spring');
		ArgHandlingCommand command = new ArgHandlingCommand();
		runner.addCommand(command);
		runner.runAndHandleErrors('args', 'samples/app.groovy', '--', '--debug');
		assertThat(command.args).containsExactly('samples/app.groovy', '--', '--debug');
		assertThat(System.getProperty('debug')).isNull();
	}
	static class ArgHandlingCommand extends AbstractCommand {
		private String[] args;
		ArgHandlingCommand() {
			super('args', '');
		}
		@Override
		public ExitStatus run(String... args) throws Exception {
			this.args = args;
			return ExitStatus.OK;
		}
	}
}
/*
package org.springframework.boot.cli.command;
/**
@ExtendWith(MockitoExtension.class)
class CommandRunnerTests {
	private CommandRunner commandRunner;
	@Mock
	private Command regularCommand;
	@Mock
	private Command anotherCommand;
	private final Set<Call> calls = EnumSet.noneOf(Call.class);
	private ClassLoader loader;
	@AfterEach
	void close() {
		Thread.currentThread().setContextClassLoader(this.loader);
		System.clearProperty('debug');
	}
	@BeforeEach
	void setup() {
		this.loader = Thread.currentThread().getContextClassLoader();
		this.commandRunner = new CommandRunner('spring') {
			@Override
			protected void showUsage() {
				CommandRunnerTests.this.calls.add(Call.SHOW_USAGE);
				super.showUsage();
			}
			@Override
			protected boolean errorMessage(String message) {
				CommandRunnerTests.this.calls.add(Call.ERROR_MESSAGE);
				return super.errorMessage(message);
			}
			@Override
			protected void printStackTrace(Exception ex) {
				CommandRunnerTests.this.calls.add(Call.PRINT_STACK_TRACE);
				super.printStackTrace(ex);
			}
		};
		lenient().doReturn('another').when(this.anotherCommand).getName();
		lenient().doReturn('command').when(this.regularCommand).getName();
		lenient().doReturn('A regular command').when(this.regularCommand).getDescription();
		this.commandRunner.addCommand(this.regularCommand);
		this.commandRunner.addCommand(new HelpCommand(this.commandRunner));
		this.commandRunner.addCommand(new HintCommand(this.commandRunner));
	}
	@Test
	void runWithoutArguments() {
		assertThatExceptionOfType(NoArgumentsException.class).isThrownBy(this.commandRunner::run);
	}
	@Test
	void runCommand() throws Exception {
		this.commandRunner.run('command', '--arg1', 'arg2');
		then(this.regularCommand).should().run('--arg1', 'arg2');
	}
	@Test
	void missingCommand() {
		assertThatExceptionOfType(NoSuchCommandException.class).isThrownBy(() -> this.commandRunner.run('missing'));
	}
	@Test
	void appArguments() throws Exception {
		this.commandRunner.runAndHandleErrors('command', '--', '--debug', 'bar');
		then(this.regularCommand).should().run('--', '--debug', 'bar');
		// When handled by the command itself it shouldn"t cause the system property to be
		// set
		assertThat(System.getProperty('debug')).isNull();
	}
	@Test
	void handlesSuccess() {
		int status = this.commandRunner.runAndHandleErrors('command');
		assertThat(status).isZero();
		assertThat(this.calls).isEmpty();
	}
	@Test
	void handlesNoSuchCommand() {
		int status = this.commandRunner.runAndHandleErrors('missing');
		assertThat(status).isOne();
		assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE);
	}
	@Test
	void handlesRegularExceptionWithMessage() throws Exception {
		willThrow(new RuntimeException('With Message')).given(this.regularCommand).run();
		int status = this.commandRunner.runAndHandleErrors('command');
		assertThat(status).isOne();
		assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE);
	}
	@Test
	void handlesRegularExceptionWithoutMessage() throws Exception {
		willThrow(new RuntimeException()).given(this.regularCommand).run();
		int status = this.commandRunner.runAndHandleErrors('command');
		assertThat(status).isOne();
		assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE, Call.PRINT_STACK_TRACE);
	}
	@Test
	void handlesExceptionWithDashDashDebug() throws Exception {
		willThrow(new RuntimeException()).given(this.regularCommand).run();
		int status = this.commandRunner.runAndHandleErrors('command', '--debug');
		assertThat(System.getProperty('debug')).isEqualTo('true');
		assertThat(status).isOne();
		assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE, Call.PRINT_STACK_TRACE);
	}
	@Test
	void exceptionMessages() {
		assertThat(new NoSuchCommandException('name').getMessage())
			.isEqualTo('"name" is not a valid command. See "help".');
	}
	@Test
	void help() throws Exception {
		this.commandRunner.run('help', 'command');
		then(this.regularCommand).should().getHelp();
	}
	@Test
	void helpNoCommand() {
		assertThatExceptionOfType(NoHelpCommandArgumentsException.class)
			.isThrownBy(() -> this.commandRunner.run('help'));
	}
	@Test
	void helpUnknownCommand() {
		assertThatExceptionOfType(NoSuchCommandException.class)
			.isThrownBy(() -> this.commandRunner.run('help', 'missing'));
	}
	private enum Call {
		SHOW_USAGE, ERROR_MESSAGE, PRINT_STACK_TRACE
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class InitializrServiceMetadataTests {
	@Test
	void parseDefaults() throws Exception {
		InitializrServiceMetadata metadata = createInstance('2.0.0');
		assertThat(metadata.getDefaults()).containsEntry('bootVersion', '1.1.8.RELEASE');
		assertThat(metadata.getDefaults()).containsEntry('javaVersion', '1.7');
		assertThat(metadata.getDefaults()).containsEntry('groupId', 'org.test');
		assertThat(metadata.getDefaults()).containsEntry('name', 'demo');
		assertThat(metadata.getDefaults()).containsEntry('description', 'Demo project for Spring Boot');
		assertThat(metadata.getDefaults()).containsEntry('packaging', 'jar');
		assertThat(metadata.getDefaults()).containsEntry('language', 'java');
		assertThat(metadata.getDefaults()).containsEntry('artifactId', 'demo');
		assertThat(metadata.getDefaults()).containsEntry('packageName', 'demo');
		assertThat(metadata.getDefaults()).containsEntry('type', 'maven-project');
		assertThat(metadata.getDefaults()).containsEntry('version', '0.0.1-SNAPSHOT');
		assertThat(metadata.getDefaults()).as('Wrong number of defaults').hasSize(11);
	}
	@Test
	void parseDependencies() throws Exception {
		InitializrServiceMetadata metadata = createInstance('2.0.0');
		assertThat(metadata.getDependencies()).hasSize(5);
		// Security description
		assertThat(metadata.getDependency('aop').getName()).isEqualTo('AOP');
		assertThat(metadata.getDependency('security').getName()).isEqualTo('Security');
		assertThat(metadata.getDependency('security').getDescription()).isEqualTo('Security description');
		assertThat(metadata.getDependency('jdbc').getName()).isEqualTo('JDBC');
		assertThat(metadata.getDependency('data-jpa').getName()).isEqualTo('JPA');
		assertThat(metadata.getDependency('data-mongodb').getName()).isEqualTo('MongoDB');
	}
	@Test
	void parseTypes() throws Exception {
		InitializrServiceMetadata metadata = createInstance('2.0.0');
		ProjectType projectType = metadata.getProjectTypes().get('maven-project');
		assertThat(projectType).isNotNull();
		assertThat(projectType.getTags()).containsEntry('build', 'maven');
		assertThat(projectType.getTags()).containsEntry('format', 'project');
	}
	private static InitializrServiceMetadata createInstance(String version) throws JSONException {
		try {
			return new InitializrServiceMetadata(readJson(version));
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to read json', ex);
		}
	}
	private static JSONObject readJson(String version) throws IOException, JSONException {
		Resource resource = new ClassPathResource('metadata/service-metadata-' + version + '.json');
		try (InputStream stream = resource.getInputStream()) {
			return new JSONObject(StreamUtils.copyToString(stream, StandardCharsets.UTF_8));
		}
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class InitializrServiceTests extends AbstractHttpClientMockTests {
	private final InitializrService invoker = new InitializrService(this.http);
	@Test
	void loadMetadata() throws Exception {
		mockSuccessfulMetadataGet(false);
		InitializrServiceMetadata metadata = this.invoker.loadMetadata('https://foo/bar');
		assertThat(metadata).isNotNull();
	}
	@Test
	void generateSimpleProject() throws Exception {
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		MockHttpProjectGenerationRequest mockHttpRequest = new MockHttpProjectGenerationRequest('application/xml',
				'foo.zip');
		ProjectGenerationResponse entity = generateProject(request, mockHttpRequest);
		assertProjectEntity(entity, mockHttpRequest.contentType, mockHttpRequest.fileName);
	}
	@Test
	void generateProjectCustomTargetFilename() throws Exception {
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		request.setOutput('bar.zip');
		MockHttpProjectGenerationRequest mockHttpRequest = new MockHttpProjectGenerationRequest('application/xml',
				null);
		ProjectGenerationResponse entity = generateProject(request, mockHttpRequest);
		assertProjectEntity(entity, mockHttpRequest.contentType, null);
	}
	@Test
	void generateProjectNoDefaultFileName() throws Exception {
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		MockHttpProjectGenerationRequest mockHttpRequest = new MockHttpProjectGenerationRequest('application/xml',
				null);
		ProjectGenerationResponse entity = generateProject(request, mockHttpRequest);
		assertProjectEntity(entity, mockHttpRequest.contentType, null);
	}
	@Test
	void generateProjectBadRequest() throws Exception {
		String jsonMessage = 'Unknown dependency foo:bar';
		mockProjectGenerationError(400, jsonMessage);
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		request.getDependencies().add('foo:bar');
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.invoker.generate(request))
			.withMessageContaining(jsonMessage);
	}
	@Test
	void generateProjectBadRequestNoExtraMessage() throws Exception {
		mockProjectGenerationError(400, null);
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.invoker.generate(request))
			.withMessageContaining('unexpected 400 error');
	}
	@Test
	void generateProjectNoContent() throws Exception {
		mockSuccessfulMetadataGet(false);
		ClassicHttpResponse response = mock(ClassicHttpResponse.class);
		mockStatus(response, 500);
		given(this.http.executeOpen(any(HttpHost.class), isA(HttpGet.class), isNull())).willReturn(response);
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.invoker.generate(request))
			.withMessageContaining('No content received from server');
	}
	@Test
	void loadMetadataBadRequest() throws Exception {
		String jsonMessage = 'whatever error on the server';
		mockMetadataGetError(500, jsonMessage);
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.invoker.generate(request))
			.withMessageContaining(jsonMessage);
	}
	@Test
	void loadMetadataInvalidJson() throws Exception {
		ClassicHttpResponse response = mock(ClassicHttpResponse.class);
		mockHttpEntity(response, 'Foo-Bar-Not-JSON'.getBytes(), 'application/json');
		mockStatus(response, 200);
		given(this.http.executeOpen(any(HttpHost.class), isA(HttpGet.class), isNull())).willReturn(response);
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.invoker.generate(request))
			.withMessageContaining('Invalid content received from server');
	}
	@Test
	void loadMetadataNoContent() throws Exception {
		ClassicHttpResponse response = mock(ClassicHttpResponse.class);
		mockStatus(response, 500);
		given(this.http.executeOpen(any(HttpHost.class), isA(HttpGet.class), isNull())).willReturn(response);
		ProjectGenerationRequest request = new ProjectGenerationRequest();
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.invoker.generate(request))
			.withMessageContaining('No content received from server');
	}
	private ProjectGenerationResponse generateProject(ProjectGenerationRequest request,
			MockHttpProjectGenerationRequest mockRequest) throws Exception {
		mockSuccessfulProjectGeneration(mockRequest);
		ProjectGenerationResponse entity = this.invoker.generate(request);
		assertThat(entity.getContent()).as('wrong body content').isEqualTo(mockRequest.content);
		return entity;
	}
	private static void assertProjectEntity(ProjectGenerationResponse entity, String mimeType, String fileName) {
		if (mimeType == null) {
			assertThat(entity.getContentType()).isNull();
		}
		else {
			assertThat(entity.getContentType().getMimeType()).isEqualTo(mimeType);
		}
		assertThat(entity.getFileName()).isEqualTo(fileName);
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
@ExtendWith(MockitoExtension.class)
class InitCommandTests extends AbstractHttpClientMockTests {
	private final TestableInitCommandOptionHandler handler;
	private final InitCommand command;
	InitCommandTests() {
		InitializrService initializrService = new InitializrService(this.http);
		this.handler = new TestableInitCommandOptionHandler(initializrService);
		this.command = new InitCommand(this.handler);
	}
	@Test
	void listServiceCapabilitiesText() throws Exception {
		mockSuccessfulMetadataTextGet();
		this.command.run('--list', '--target=https://fake-service');
	}
	@Test
	void listServiceCapabilities() throws Exception {
		mockSuccessfulMetadataGet(true);
		this.command.run('--list', '--target=https://fake-service');
	}
	@Test
	void listServiceCapabilitiesV2() throws Exception {
		mockSuccessfulMetadataGetV2(true);
		this.command.run('--list', '--target=https://fake-service');
	}
	@Test
	void generateProject() throws Exception {
		String fileName = UUID.randomUUID() + '.zip';
		File file = new File(fileName);
		assertThat(file).as('file should not exist').doesNotExist();
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', fileName);
		mockSuccessfulProjectGeneration(request);
		try {
			assertThat(this.command.run()).isEqualTo(ExitStatus.OK);
			assertThat(file).as('file should have been created').exists();
		}
		finally {
			assertThat(file.delete()).as('failed to delete test file').isTrue();
		}
	}
	@Test
	void generateProjectNoFileNameAvailable() throws Exception {
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', null);
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run()).isEqualTo(ExitStatus.ERROR);
	}
	@Test
	void generateProjectAndExtract(@TempDir File tempDir) throws Exception {
		byte[] archive = createFakeZipArchive('test.txt', 'Fake content');
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', 'demo.zip',
				archive);
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run('--extract', tempDir.getAbsolutePath())).isEqualTo(ExitStatus.OK);
		File archiveFile = new File(tempDir, 'test.txt');
		assertThat(archiveFile).exists();
	}
	@Test
	void generateProjectAndExtractWillNotWriteEntriesOutsideOutputLocation(@TempDir File tempDir) throws Exception {
		byte[] archive = createFakeZipArchive('../outside.txt', 'Fake content');
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', 'demo.zip',
				archive);
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run('--extract', tempDir.getAbsolutePath())).isEqualTo(ExitStatus.ERROR);
		File archiveFile = new File(tempDir.getParentFile(), 'outside.txt');
		assertThat(archiveFile).doesNotExist();
	}
	@Test
	void generateProjectAndExtractWithConvention(@TempDir File tempDir) throws Exception {
		byte[] archive = createFakeZipArchive('test.txt', 'Fake content');
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', 'demo.zip',
				archive);
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run(tempDir.getAbsolutePath() + '/')).isEqualTo(ExitStatus.OK);
		File archiveFile = new File(tempDir, 'test.txt');
		assertThat(archiveFile).exists();
	}
	@Test
	void generateProjectArchiveExtractedByDefault() throws Exception {
		String fileName = UUID.randomUUID().toString();
		assertThat(fileName).as('No dot in filename').doesNotContain('.');
		byte[] archive = createFakeZipArchive('test.txt', 'Fake content');
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', 'demo.zip',
				archive);
		mockSuccessfulProjectGeneration(request);
		File file = new File(fileName);
		File archiveFile = new File(file, 'test.txt');
		try {
			assertThat(this.command.run(fileName)).isEqualTo(ExitStatus.OK);
			assertThat(archiveFile).exists();
		}
		finally {
			archiveFile.delete();
			file.delete();
		}
	}
	@Test
	void generateProjectFileSavedAsFileByDefault() throws Exception {
		String fileName = UUID.randomUUID().toString();
		String content = 'Fake Content';
		byte[] archive = content.getBytes();
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/octet-stream',
				'pom.xml', archive);
		mockSuccessfulProjectGeneration(request);
		File file = new File(fileName);
		try {
			assertThat(this.command.run(fileName)).isEqualTo(ExitStatus.OK);
			assertThat(file).as('File not saved properly').exists();
			assertThat(file).as('Should not be a directory').isFile();
		}
		finally {
			file.delete();
		}
	}
	@Test
	void generateProjectAndExtractUnsupportedArchive(@TempDir File tempDir) throws Exception {
		String fileName = UUID.randomUUID() + '.zip';
		File file = new File(fileName);
		assertThat(file).as('file should not exist').doesNotExist();
		try {
			byte[] archive = createFakeZipArchive('test.txt', 'Fake content');
			MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/foobar',
					fileName, archive);
			mockSuccessfulProjectGeneration(request);
			assertThat(this.command.run('--extract', tempDir.getAbsolutePath())).isEqualTo(ExitStatus.OK);
			assertThat(file).as('file should have been saved instead').exists();
		}
		finally {
			assertThat(file.delete()).as('failed to delete test file').isTrue();
		}
	}
	@Test
	void generateProjectAndExtractUnknownContentType(@TempDir File tempDir) {
		String fileName = UUID.randomUUID() + '.zip';
		File file = new File(fileName);
		assertThat(file).as('file should not exist').doesNotExist();
		try {
			byte[] archive = createFakeZipArchive('test.txt', 'Fake content');
			MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest(null, fileName, archive);
			mockSuccessfulProjectGeneration(request);
			assertThat(this.command.run('--extract', tempDir.getAbsolutePath())).isEqualTo(ExitStatus.OK);
			assertThat(file).as('file should have been saved instead').exists();
		}
		catch (Exception ex) {
			fail(null, ex);
		}
		finally {
			assertThat(file.delete()).as('failed to delete test file').isTrue();
		}
	}
	@Test
	void fileNotOverwrittenByDefault(@TempDir File tempDir) throws Exception {
		File file = new File(tempDir, 'test.file');
		file.createNewFile();
		long fileLength = file.length();
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip',
				file.getAbsolutePath());
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run()).as('Should have failed').isEqualTo(ExitStatus.ERROR);
		assertThat(file.length()).as('File should not have changed').isEqualTo(fileLength);
	}
	@Test
	void overwriteFile(@TempDir File tempDir) throws Exception {
		File file = new File(tempDir, 'test.file');
		file.createNewFile();
		long fileLength = file.length();
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip',
				file.getAbsolutePath());
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run('--force')).isEqualTo(ExitStatus.OK);
		assertThat(fileLength).as('File should have changed').isNotEqualTo(file.length());
	}
	@Test
	void fileInArchiveNotOverwrittenByDefault(@TempDir File tempDir) throws Exception {
		File conflict = new File(tempDir, 'test.txt');
		assertThat(conflict.createNewFile()).as('Should have been able to create file').isTrue();
		long fileLength = conflict.length();
		// also contains test.txt
		byte[] archive = createFakeZipArchive('test.txt', 'Fake content');
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', 'demo.zip',
				archive);
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run('--extract', tempDir.getAbsolutePath())).isEqualTo(ExitStatus.ERROR);
		assertThat(conflict.length()).as('File should not have changed').isEqualTo(fileLength);
	}
	@Test
	void parseProjectOptions() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('-g=org.demo', '-a=acme', '-v=1.2.3-SNAPSHOT', '-n=acme-sample',
				'--description=Acme sample project', '--package-name=demo.foo', '-t=ant-project', '--build=grunt',
				'--format=web', '-p=war', '-j=1.9', '-l=groovy', '-b=1.2.0.RELEASE', '-d=web,data-jpa');
		assertThat(this.handler.lastRequest.getGroupId()).isEqualTo('org.demo');
		assertThat(this.handler.lastRequest.getArtifactId()).isEqualTo('acme');
		assertThat(this.handler.lastRequest.getVersion()).isEqualTo('1.2.3-SNAPSHOT');
		assertThat(this.handler.lastRequest.getName()).isEqualTo('acme-sample');
		assertThat(this.handler.lastRequest.getDescription()).isEqualTo('Acme sample project');
		assertThat(this.handler.lastRequest.getPackageName()).isEqualTo('demo.foo');
		assertThat(this.handler.lastRequest.getType()).isEqualTo('ant-project');
		assertThat(this.handler.lastRequest.getBuild()).isEqualTo('grunt');
		assertThat(this.handler.lastRequest.getFormat()).isEqualTo('web');
		assertThat(this.handler.lastRequest.getPackaging()).isEqualTo('war');
		assertThat(this.handler.lastRequest.getJavaVersion()).isEqualTo('1.9');
		assertThat(this.handler.lastRequest.getLanguage()).isEqualTo('groovy');
		assertThat(this.handler.lastRequest.getBootVersion()).isEqualTo('1.2.0.RELEASE');
		List<String> dependencies = this.handler.lastRequest.getDependencies();
		assertThat(dependencies).hasSize(2);
		assertThat(dependencies).contains('web');
		assertThat(dependencies).contains('data-jpa');
	}
	@Test
	void parseProjectWithCamelCaseOptions() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('--groupId=org.demo', '--artifactId=acme', '--version=1.2.3-SNAPSHOT', '--name=acme-sample',
				'--description=Acme sample project', '--packageName=demo.foo', '--type=ant-project', '--build=grunt',
				'--format=web', '--packaging=war', '--javaVersion=1.9', '--language=groovy',
				'--bootVersion=1.2.0.RELEASE', '--dependencies=web,data-jpa');
		assertThat(this.handler.lastRequest.getGroupId()).isEqualTo('org.demo');
		assertThat(this.handler.lastRequest.getArtifactId()).isEqualTo('acme');
		assertThat(this.handler.lastRequest.getVersion()).isEqualTo('1.2.3-SNAPSHOT');
		assertThat(this.handler.lastRequest.getName()).isEqualTo('acme-sample');
		assertThat(this.handler.lastRequest.getDescription()).isEqualTo('Acme sample project');
		assertThat(this.handler.lastRequest.getPackageName()).isEqualTo('demo.foo');
		assertThat(this.handler.lastRequest.getType()).isEqualTo('ant-project');
		assertThat(this.handler.lastRequest.getBuild()).isEqualTo('grunt');
		assertThat(this.handler.lastRequest.getFormat()).isEqualTo('web');
		assertThat(this.handler.lastRequest.getPackaging()).isEqualTo('war');
		assertThat(this.handler.lastRequest.getJavaVersion()).isEqualTo('1.9');
		assertThat(this.handler.lastRequest.getLanguage()).isEqualTo('groovy');
		assertThat(this.handler.lastRequest.getBootVersion()).isEqualTo('1.2.0.RELEASE');
		List<String> dependencies = this.handler.lastRequest.getDependencies();
		assertThat(dependencies).hasSize(2);
		assertThat(dependencies).contains('web');
		assertThat(dependencies).contains('data-jpa');
	}
	@Test
	void parseProjectWithKebabCaseOptions() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('--group-id=org.demo', '--artifact-id=acme', '--version=1.2.3-SNAPSHOT', '--name=acme-sample',
				'--description=Acme sample project', '--package-name=demo.foo', '--type=ant-project', '--build=grunt',
				'--format=web', '--packaging=war', '--java-version=1.9', '--language=groovy',
				'--boot-version=1.2.0.RELEASE', '--dependencies=web,data-jpa');
		assertThat(this.handler.lastRequest.getGroupId()).isEqualTo('org.demo');
		assertThat(this.handler.lastRequest.getArtifactId()).isEqualTo('acme');
		assertThat(this.handler.lastRequest.getVersion()).isEqualTo('1.2.3-SNAPSHOT');
		assertThat(this.handler.lastRequest.getName()).isEqualTo('acme-sample');
		assertThat(this.handler.lastRequest.getDescription()).isEqualTo('Acme sample project');
		assertThat(this.handler.lastRequest.getPackageName()).isEqualTo('demo.foo');
		assertThat(this.handler.lastRequest.getType()).isEqualTo('ant-project');
		assertThat(this.handler.lastRequest.getBuild()).isEqualTo('grunt');
		assertThat(this.handler.lastRequest.getFormat()).isEqualTo('web');
		assertThat(this.handler.lastRequest.getPackaging()).isEqualTo('war');
		assertThat(this.handler.lastRequest.getJavaVersion()).isEqualTo('1.9');
		assertThat(this.handler.lastRequest.getLanguage()).isEqualTo('groovy');
		assertThat(this.handler.lastRequest.getBootVersion()).isEqualTo('1.2.0.RELEASE');
		List<String> dependencies = this.handler.lastRequest.getDependencies();
		assertThat(dependencies).hasSize(2);
		assertThat(dependencies).contains('web');
		assertThat(dependencies).contains('data-jpa');
	}
	@Test
	void overwriteFileInArchive(@TempDir File tempDir) throws Exception {
		File conflict = new File(tempDir, 'test.txt');
		assertThat(conflict.createNewFile()).as('Should have been able to create file').isTrue();
		long fileLength = conflict.length();
		// also contains test.txt
		byte[] archive = createFakeZipArchive('test.txt', 'Fake content');
		MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest('application/zip', 'demo.zip',
				archive);
		mockSuccessfulProjectGeneration(request);
		assertThat(this.command.run('--force', '--extract', tempDir.getAbsolutePath())).isEqualTo(ExitStatus.OK);
		assertThat(fileLength).as('File should have changed').isNotEqualTo(conflict.length());
	}
	@Test
	void parseTypeOnly() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('-t=ant-project');
		assertThat(this.handler.lastRequest.getBuild()).isEqualTo('gradle');
		assertThat(this.handler.lastRequest.getFormat()).isEqualTo('project');
		assertThat(this.handler.lastRequest.isDetectType()).isFalse();
		assertThat(this.handler.lastRequest.getType()).isEqualTo('ant-project');
	}
	@Test
	void parseBuildOnly() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('--build=ant');
		assertThat(this.handler.lastRequest.getBuild()).isEqualTo('ant');
		assertThat(this.handler.lastRequest.getFormat()).isEqualTo('project');
		assertThat(this.handler.lastRequest.isDetectType()).isTrue();
		assertThat(this.handler.lastRequest.getType()).isNull();
	}
	@Test
	void parseFormatOnly() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('--format=web');
		assertThat(this.handler.lastRequest.getBuild()).isEqualTo('gradle');
		assertThat(this.handler.lastRequest.getFormat()).isEqualTo('web');
		assertThat(this.handler.lastRequest.isDetectType()).isTrue();
		assertThat(this.handler.lastRequest.getType()).isNull();
	}
	@Test
	void parseLocation() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('foobar.zip');
		assertThat(this.handler.lastRequest.getOutput()).isEqualTo('foobar.zip');
	}
	@Test
	void parseLocationWithSlash() throws Exception {
		this.handler.disableProjectGeneration();
		this.command.run('foobar/');
		assertThat(this.handler.lastRequest.getOutput()).isEqualTo('foobar');
		assertThat(this.handler.lastRequest.isExtract()).isTrue();
	}
	@Test
	void parseMoreThanOneArg() throws Exception {
		this.handler.disableProjectGeneration();
		assertThat(this.command.run('foobar', 'barfoo')).isEqualTo(ExitStatus.ERROR);
	}
	@Test
	void userAgent() throws Exception {
		this.command.run('--list', '--target=https://fake-service');
		then(this.http).should()
			.executeOpen(any(HttpHost.class), assertArg((request) -> assertThat(
					request.getHeaders('User-Agent')[0].getValue().startsWith('SpringBootCli/'))), isNull());
	}
	private byte[] createFakeZipArchive(String fileName, String content) throws IOException {
		try (ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
			try (ZipOutputStream zos = new ZipOutputStream(bos)) {
				ZipEntry entry = new ZipEntry(fileName);
				zos.putNextEntry(entry);
				zos.write(content.getBytes());
				zos.closeEntry();
				return bos.toByteArray();
			}
		}
	}
	static class TestableInitCommandOptionHandler extends InitCommand.InitOptionHandler {
		private boolean disableProjectGeneration;
		private ProjectGenerationRequest lastRequest;
		TestableInitCommandOptionHandler(InitializrService initializrService) {
			super(initializrService);
		}
		void disableProjectGeneration() {
			this.disableProjectGeneration = true;
		}
		@Override
		protected void generateProject(OptionSet options) throws IOException {
			this.lastRequest = createProjectGenerationRequest(options);
			if (!this.disableProjectGeneration) {
				super.generateProject(options);
			}
		}
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
public abstract class AbstractHttpClientMockTests {
	protected final HttpClient http = mock(HttpClient.class);
	protected void mockSuccessfulMetadataTextGet() throws IOException {
		mockSuccessfulMetadataGet('metadata/service-metadata-2.1.0.txt', 'text/plain', true);
	}
	protected void mockSuccessfulMetadataGet(boolean serviceCapabilities) throws IOException {
		mockSuccessfulMetadataGet('metadata/service-metadata-2.1.0.json', 'application/vnd.initializr.v2.1+json',
				serviceCapabilities);
	}
	protected void mockSuccessfulMetadataGetV2(boolean serviceCapabilities) throws IOException {
		mockSuccessfulMetadataGet('metadata/service-metadata-2.0.0.json', 'application/vnd.initializr.v2+json',
				serviceCapabilities);
	}
	protected void mockSuccessfulMetadataGet(String contentPath, String contentType, boolean serviceCapabilities)
			throws IOException {
		ClassicHttpResponse response = mock(ClassicHttpResponse.class);
		byte[] content = readClasspathResource(contentPath);
		mockHttpEntity(response, content, contentType);
		mockStatus(response, 200);
		given(this.http.executeOpen(any(HttpHost.class), argThat(getForMetadata(serviceCapabilities)), isNull()))
			.willReturn(response);
	}
	protected byte[] readClasspathResource(String contentPath) throws IOException {
		Resource resource = new ClassPathResource(contentPath);
		return StreamUtils.copyToByteArray(resource.getInputStream());
	}
	protected void mockSuccessfulProjectGeneration(MockHttpProjectGenerationRequest request) throws IOException {
		// Required for project generation as the metadata is read first
		mockSuccessfulMetadataGet(false);
		ClassicHttpResponse response = mock(ClassicHttpResponse.class);
		mockHttpEntity(response, request.content, request.contentType);
		mockStatus(response, 200);
		String header = (request.fileName != null) ? contentDispositionValue(request.fileName) : null;
		mockHttpHeader(response, 'Content-Disposition', header);
		given(this.http.executeOpen(any(HttpHost.class), argThat(getForNonMetadata()), isNull())).willReturn(response);
	}
	protected void mockProjectGenerationError(int status, String message) throws IOException, JSONException {
		// Required for project generation as the metadata is read first
		mockSuccessfulMetadataGet(false);
		ClassicHttpResponse response = mock(ClassicHttpResponse.class);
		mockHttpEntity(response, createJsonError(status, message).getBytes(), 'application/json');
		mockStatus(response, status);
		given(this.http.executeOpen(any(HttpHost.class), isA(HttpGet.class), isNull())).willReturn(response);
	}
	protected void mockMetadataGetError(int status, String message) throws IOException, JSONException {
		ClassicHttpResponse response = mock(ClassicHttpResponse.class);
		mockHttpEntity(response, createJsonError(status, message).getBytes(), 'application/json');
		mockStatus(response, status);
		given(this.http.executeOpen(any(HttpHost.class), isA(HttpGet.class), isNull())).willReturn(response);
	}
	protected HttpEntity mockHttpEntity(ClassicHttpResponse response, byte[] content, String contentType) {
		try {
			HttpEntity entity = mock(HttpEntity.class);
			given(entity.getContent()).willReturn(new ByteArrayInputStream(content));
			Header contentTypeHeader = (contentType != null) ? new BasicHeader('Content-Type', contentType) : null;
			given(entity.getContentType())
				.willReturn((contentTypeHeader != null) ? contentTypeHeader.getValue() : null);
			given(response.getEntity()).willReturn(entity);
			return entity;
		}
		catch (IOException ex) {
			throw new IllegalStateException('Should not happen', ex);
		}
	}
	protected void mockStatus(ClassicHttpResponse response, int status) {
		given(response.getCode()).willReturn(status);
	}
	protected void mockHttpHeader(ClassicHttpResponse response, String headerName, String value) {
		Header header = (value != null) ? new BasicHeader(headerName, value) : null;
		given(response.getFirstHeader(headerName)).willReturn(header);
	}
	private ArgumentMatcher<HttpGet> getForMetadata(boolean serviceCapabilities) {
		if (!serviceCapabilities) {
			return new HasAcceptHeader(InitializrService.ACCEPT_META_DATA, true);
		}
		return new HasAcceptHeader(InitializrService.ACCEPT_SERVICE_CAPABILITIES, true);
	}
	private ArgumentMatcher<HttpGet> getForNonMetadata() {
		return new HasAcceptHeader(InitializrService.ACCEPT_META_DATA, false);
	}
	private String contentDispositionValue(String fileName) {
		return 'attachment; filename=\'' + fileName + '\'';
	}
	private String createJsonError(int status, String message) throws JSONException {
		JSONObject json = new JSONObject();
		json.put('status', status);
		if (message != null) {
			json.put('message', message);
		}
		return json.toString();
	}
	static class MockHttpProjectGenerationRequest {
		String contentType;
		String fileName;
		byte[] content = new byte[] { 0, 0, 0, 0 };
		MockHttpProjectGenerationRequest(String contentType, String fileName) {
			this(contentType, fileName, new byte[] { 0, 0, 0, 0 });
		}
		MockHttpProjectGenerationRequest(String contentType, String fileName, byte[] content) {
			this.contentType = (contentType != null) ? contentType : 'application/text';
			this.fileName = fileName;
			this.content = content;
		}
	}
	static class HasAcceptHeader implements ArgumentMatcher<HttpGet> {
		private final String value;
		private final boolean shouldMatch;
		HasAcceptHeader(String value, boolean shouldMatch) {
			this.value = value;
			this.shouldMatch = shouldMatch;
		}
		@Override
		public boolean matches(HttpGet get) {
			if (get == null) {
				return false;
			}
			Header acceptHeader = get.getFirstHeader(HttpHeaders.ACCEPT);
			if (this.shouldMatch) {
				return acceptHeader != null && this.value.equals(acceptHeader.getValue());
			}
			return acceptHeader == null || !this.value.equals(acceptHeader.getValue());
		}
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class ServiceCapabilitiesReportGeneratorTests extends AbstractHttpClientMockTests {
	private final ServiceCapabilitiesReportGenerator command = new ServiceCapabilitiesReportGenerator(
			new InitializrService(this.http));
	@Test
	void listMetadataFromServer() throws IOException {
		mockSuccessfulMetadataTextGet();
		String expected = new String(readClasspathResource('metadata/service-metadata-2.1.0.txt'));
		String content = this.command.generate('http://localhost');
		assertThat(content).isEqualTo(expected);
	}
	@Test
	void listMetadata() throws IOException {
		mockSuccessfulMetadataGet(true);
		doTestGenerateCapabilitiesFromJson();
	}
	@Test
	void listMetadataV2() throws IOException {
		mockSuccessfulMetadataGetV2(true);
		doTestGenerateCapabilitiesFromJson();
	}
	private void doTestGenerateCapabilitiesFromJson() throws IOException {
		String content = this.command.generate('http://localhost');
		assertThat(content).contains('aop - AOP');
		assertThat(content).contains('security - Security: Security description');
		assertThat(content).contains('type: maven-project');
		assertThat(content).contains('packaging: jar');
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class ProjectGenerationRequestTests {
	public static final Map<String, String> EMPTY_TAGS = Collections.emptyMap();
	private final ProjectGenerationRequest request = new ProjectGenerationRequest();
	@Test
	void defaultSettings() {
		assertThat(this.request.generateUrl(createDefaultMetadata())).isEqualTo(createDefaultUrl('?type=test-type'));
	}
	@Test
	void customServer() throws URISyntaxException {
		String customServerUrl = 'https://foo:8080/initializr';
		this.request.setServiceUrl(customServerUrl);
		this.request.getDependencies().add('security');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(new URI(customServerUrl + '/starter.zip?dependencies=security&type=test-type'));
	}
	@Test
	void customBootVersion() {
		this.request.setBootVersion('1.2.0.RELEASE');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?type=test-type&bootVersion=1.2.0.RELEASE'));
	}
	@Test
	void singleDependency() {
		this.request.getDependencies().add('web');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?dependencies=web&type=test-type'));
	}
	@Test
	void multipleDependencies() {
		this.request.getDependencies().add('web');
		this.request.getDependencies().add('data-jpa');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?dependencies=web%2Cdata-jpa&type=test-type'));
	}
	@Test
	void customJavaVersion() {
		this.request.setJavaVersion('1.8');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?type=test-type&javaVersion=1.8'));
	}
	@Test
	void customPackageName() {
		this.request.setPackageName('demo.foo');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?packageName=demo.foo&type=test-type'));
	}
	@Test
	void customType() throws URISyntaxException {
		ProjectType projectType = new ProjectType('custom', 'Custom Type', '/foo', true, EMPTY_TAGS);
		InitializrServiceMetadata metadata = new InitializrServiceMetadata(projectType);
		this.request.setType('custom');
		this.request.getDependencies().add('data-rest');
		assertThat(this.request.generateUrl(metadata)).isEqualTo(
				new URI(ProjectGenerationRequest.DEFAULT_SERVICE_URL + '/foo?dependencies=data-rest&type=custom'));
	}
	@Test
	void customPackaging() {
		this.request.setPackaging('war');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?type=test-type&packaging=war'));
	}
	@Test
	void customLanguage() {
		this.request.setLanguage('groovy');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?type=test-type&language=groovy'));
	}
	@Test
	void customProjectInfo() {
		this.request.setGroupId('org.acme');
		this.request.setArtifactId('sample');
		this.request.setVersion('1.0.1-SNAPSHOT');
		this.request.setDescription('Spring Boot Test');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?groupId=org.acme&artifactId=sample&version=1.0.1-SNAPSHOT'
					+ '&description=Spring%20Boot%20Test&type=test-type'));
	}
	@Test
	void outputCustomizeArtifactId() {
		this.request.setOutput('my-project');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?artifactId=my-project&type=test-type'));
	}
	@Test
	void outputArchiveCustomizeArtifactId() {
		this.request.setOutput('my-project.zip');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?artifactId=my-project&type=test-type'));
	}
	@Test
	void outputArchiveWithDotsCustomizeArtifactId() {
		this.request.setOutput('my.nice.project.zip');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?artifactId=my.nice.project&type=test-type'));
	}
	@Test
	void outputDoesNotOverrideCustomArtifactId() {
		this.request.setOutput('my-project');
		this.request.setArtifactId('my-id');
		assertThat(this.request.generateUrl(createDefaultMetadata()))
			.isEqualTo(createDefaultUrl('?artifactId=my-id&type=test-type'));
	}
	@Test
	void buildNoMatch() throws Exception {
		InitializrServiceMetadata metadata = readMetadata();
		setBuildAndFormat('does-not-exist', null);
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.request.generateUrl(metadata))
			.withMessageContaining('does-not-exist');
	}
	@Test
	void buildMultipleMatch() throws Exception {
		InitializrServiceMetadata metadata = readMetadata('types-conflict');
		setBuildAndFormat('gradle', null);
		assertThatExceptionOfType(ReportableException.class).isThrownBy(() -> this.request.generateUrl(metadata))
			.withMessageContaining('gradle-project')
			.withMessageContaining('gradle-project-2');
	}
	@Test
	void buildOneMatch() throws Exception {
		InitializrServiceMetadata metadata = readMetadata();
		setBuildAndFormat('gradle', null);
		assertThat(this.request.generateUrl(metadata)).isEqualTo(createDefaultUrl('?type=gradle-project'));
	}
	@Test
	void typeAndBuildAndFormat() throws Exception {
		InitializrServiceMetadata metadata = readMetadata();
		setBuildAndFormat('gradle', 'project');
		this.request.setType('maven-build');
		assertThat(this.request.generateUrl(metadata)).isEqualTo(createUrl('/pom.xml?type=maven-build'));
	}
	@Test
	void invalidType() {
		this.request.setType('does-not-exist');
		assertThatExceptionOfType(ReportableException.class)
			.isThrownBy(() -> this.request.generateUrl(createDefaultMetadata()));
	}
	@Test
	void noTypeAndNoDefault() {
		assertThatExceptionOfType(ReportableException.class)
			.isThrownBy(() -> this.request.generateUrl(readMetadata('types-conflict')))
			.withMessageContaining('no default is defined');
	}
	private static URI createUrl(String actionAndParam) {
		try {
			return new URI(ProjectGenerationRequest.DEFAULT_SERVICE_URL + actionAndParam);
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private static URI createDefaultUrl(String param) {
		return createUrl('/starter.zip' + param);
	}
	void setBuildAndFormat(String build, String format) {
		this.request.setBuild((build != null) ? build : 'maven');
		this.request.setFormat((format != null) ? format : 'project');
		this.request.setDetectType(true);
	}
	private static InitializrServiceMetadata createDefaultMetadata() {
		ProjectType projectType = new ProjectType('test-type', 'The test type', '/starter.zip', true, EMPTY_TAGS);
		return new InitializrServiceMetadata(projectType);
	}
	private static InitializrServiceMetadata readMetadata() throws JSONException {
		return readMetadata('2.0.0');
	}
	private static InitializrServiceMetadata readMetadata(String version) throws JSONException {
		try {
			Resource resource = new ClassPathResource('metadata/service-metadata-' + version + '.json');
			String content = StreamUtils.copyToString(resource.getInputStream(), StandardCharsets.UTF_8);
			JSONObject json = new JSONObject(content);
			return new InitializrServiceMetadata(json);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to read metadata', ex);
		}
	}
}
/*
package org.springframework.boot.cli.command;
/**
class OptionParsingCommandTests {
	@Test
	void optionHelp() {
		OptionHandler handler = new OptionHandler();
		handler.option('bar', 'Bar');
		OptionParsingCommand command = new TestOptionParsingCommand('foo', 'Foo', handler);
		assertThat(command.getHelp()).contains('--bar');
	}
	static class TestOptionParsingCommand extends OptionParsingCommand {
		TestOptionParsingCommand(String name, String description, OptionHandler handler) {
			super(name, description, handler);
		}
	}
}
/*
package org.springframework.boot.cli.util;
/**
public interface MockLog extends LogListener {
	static MockLog attach() {
		MockLog log = mock(MockLog.class);
		Log.setListener(log);
		return log;
	}
	static void clear() {
		Log.setListener(null);
	}
}
/*
package org.springframework.boot.cli;
/**
public class DefaultCommandFactory implements CommandFactory {
	private static final List<Command> DEFAULT_COMMANDS;
	static {
		List<Command> defaultCommands = new ArrayList<>();
		defaultCommands.add(new VersionCommand());
		defaultCommands.add(new InitCommand());
		defaultCommands.add(new EncodePasswordCommand());
		DEFAULT_COMMANDS = Collections.unmodifiableList(defaultCommands);
	}
	@Override
	public Collection<Command> getCommands() {
		return DEFAULT_COMMANDS;
	}
}
/*
package org.springframework.boot.cli;
/**
public final class SpringCli {
	private SpringCli() {
	}
	public static void main(String... args) {
		System.setProperty('java.awt.headless', Boolean.toString(true));
		LogbackInitializer.initialize();
		CommandRunner runner = new CommandRunner('spring');
		ClassUtils.overrideThreadContextClassLoader(createExtendedClassLoader(runner));
		runner.addCommand(new HelpCommand(runner));
		addServiceLoaderCommands(runner);
		runner.addCommand(new ShellCommand());
		runner.addCommand(new HintCommand(runner));
		runner.setOptionCommands(HelpCommand.class, VersionCommand.class);
		runner.setHiddenCommands(HintCommand.class);
		int exitCode = runner.runAndHandleErrors(args);
		if (exitCode != 0) {
			// If successful, leave it to run in case it"s a server app
			System.exit(exitCode);
		}
	}
	private static void addServiceLoaderCommands(CommandRunner runner) {
		ServiceLoader<CommandFactory> factories = ServiceLoader.load(CommandFactory.class);
		for (CommandFactory factory : factories) {
			runner.addCommands(factory.getCommands());
		}
	}
	private static URLClassLoader createExtendedClassLoader(CommandRunner runner) {
		return new URLClassLoader(getExtensionURLs(), runner.getClass().getClassLoader());
	}
	private static URL[] getExtensionURLs() {
		List<URL> urls = new ArrayList<>();
		String home = SystemPropertyUtils.resolvePlaceholders('${spring.home:${SPRING_HOME:.}}');
		File extDirectory = new File(new File(home, 'lib'), 'ext');
		if (extDirectory.isDirectory()) {
			for (File file : extDirectory.listFiles()) {
				if (file.getName().endsWith('.jar')) {
					try {
						urls.add(file.toURI().toURL());
					}
					catch (MalformedURLException ex) {
						throw new IllegalStateException(ex);
					}
				}
			}
		}
		return urls.toArray(new URL[0]);
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
class ClearCommand extends AbstractCommand {
	private final ConsoleReader consoleReader;
	ClearCommand(ConsoleReader consoleReader) {
		super('clear', 'Clear the screen');
		this.consoleReader = consoleReader;
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		this.consoleReader.setPrompt('');
		this.consoleReader.clearScreen();
		return ExitStatus.OK;
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
class ForkProcessCommand extends RunProcessCommand {
	private static final String MAIN_CLASS = 'org.springframework.boot.loader.launch.JarLauncher';
	private final Command command;
	ForkProcessCommand(Command command) {
		super(new JavaExecutable().toString());
		this.command = command;
	}
	@Override
	public String getName() {
		return this.command.getName();
	}
	@Override
	public String getDescription() {
		return this.command.getDescription();
	}
	@Override
	public String getUsageHelp() {
		return this.command.getUsageHelp();
	}
	@Override
	public String getHelp() {
		return this.command.getHelp();
	}
	@Override
	public Collection<OptionHelp> getOptionsHelp() {
		return this.command.getOptionsHelp();
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		List<String> fullArgs = new ArrayList<>();
		fullArgs.add('-cp');
		fullArgs.add(System.getProperty('java.class.path'));
		fullArgs.add(MAIN_CLASS);
		fullArgs.add(this.command.getName());
		fullArgs.addAll(Arrays.asList(args));
		run(fullArgs);
		return ExitStatus.OK;
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
class RunProcessCommand extends AbstractCommand {
	private final String[] command;
	private volatile RunProcess process;
	RunProcessCommand(String... command) {
		super(null, null);
		this.command = command;
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		return run(Arrays.asList(args));
	}
	protected ExitStatus run(Collection<String> args) throws IOException {
		this.process = new RunProcess(this.command);
		int code = this.process.run(true, StringUtils.toStringArray(args));
		if (code == 0) {
			return ExitStatus.OK;
		}
		else {
			return new ExitStatus(code, 'EXTERNAL_ERROR');
		}
	}
	boolean handleSigInt() {
		return this.process.handleSigInt();
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
public class PromptCommand extends AbstractCommand {
	private final ShellPrompts prompts;
	public PromptCommand(ShellPrompts shellPrompts) {
		super('prompt', 'Change the prompt used with the current "shell" command. '
				+ 'Execute with no arguments to return to the previous value.');
		this.prompts = shellPrompts;
	}
	@Override
	public ExitStatus run(String... strings) throws Exception {
		if (strings.length > 0) {
			for (String string : strings) {
				this.prompts.pushPrompt(string + ' ');
			}
		}
		else {
			this.prompts.popPrompt();
		}
		return ExitStatus.OK;
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
public class ShellExitException extends CommandException {
	private static final long serialVersionUID = 1L;
	public ShellExitException() {
		super(Option.RETHROW);
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
class EscapeAwareWhiteSpaceArgumentDelimiter extends WhitespaceArgumentDelimiter {
	@Override
	public boolean isEscaped(CharSequence buffer, int pos) {
		return (isEscapeChar(buffer, pos - 1));
	}
	private boolean isEscapeChar(CharSequence buffer, int pos) {
		if (pos >= 0) {
			for (char c : getEscapeChars()) {
				if (buffer.charAt(pos) == c) {
					return !isEscapeChar(buffer, pos - 1);
				}
			}
		}
		return false;
	}
	@Override
	public boolean isQuoted(CharSequence buffer, int pos) {
		int closingQuote = searchBackwards(buffer, pos - 1, getQuoteChars());
		if (closingQuote == -1) {
			return false;
		}
		int openingQuote = searchBackwards(buffer, closingQuote - 1, buffer.charAt(closingQuote));
		if (openingQuote == -1) {
			return true;
		}
		return isQuoted(buffer, openingQuote - 1);
	}
	private int searchBackwards(CharSequence buffer, int pos, char... chars) {
		while (pos >= 0) {
			for (char c : chars) {
				if (buffer.charAt(pos) == c && !isEscaped(buffer, pos)) {
					return pos;
				}
			}
			pos--;
		}
		return -1;
	}
	String[] parseArguments(String line) {
		ArgumentList delimit = delimit(line, 0);
		return cleanArguments(delimit.getArguments());
	}
	private String[] cleanArguments(String[] arguments) {
		String[] cleanArguments = new String[arguments.length];
		for (int i = 0; i < arguments.length; i++) {
			cleanArguments[i] = cleanArgument(arguments[i]);
		}
		return cleanArguments;
	}
	private String cleanArgument(String argument) {
		for (char c : getQuoteChars()) {
			String quote = String.valueOf(c);
			if (argument.startsWith(quote) && argument.endsWith(quote)) {
				return replaceEscapes(argument.substring(1, argument.length() - 1));
			}
		}
		return replaceEscapes(argument);
	}
	private String replaceEscapes(String string) {
		string = string.replace('\\ ', ' ');
		string = string.replace('\\\\', '\\');
		string = string.replace('\\t', '\t');
		string = string.replace('\\\'', '\'');
		string = string.replace('\\"', '"');
		return string;
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
class AnsiString {
	private final Terminal terminal;
	private final StringBuilder value = new StringBuilder();
	/**
	 * Create a new {@link AnsiString} for the given {@link Terminal}.
	 * @param terminal the terminal used to test if {@link Terminal#isAnsiSupported() ANSI
	 * is supported}.
	 */
	AnsiString(Terminal terminal) {
		this.terminal = terminal;
	}
	/**
	 * Append text with the given ANSI codes.
	 * @param text the text to append
	 * @param codes the ANSI codes
	 * @return this string
	 */
	AnsiString append(String text, Code... codes) {
		if (codes.length == 0 || !isAnsiSupported()) {
			this.value.append(text);
			return this;
		}
		Ansi ansi = Ansi.ansi();
		for (Code code : codes) {
			ansi = applyCode(ansi, code);
		}
		this.value.append(ansi.a(text).reset().toString());
		return this;
	}
	private Ansi applyCode(Ansi ansi, Code code) {
		if (code.isColor()) {
			if (code.isBackground()) {
				return ansi.bg(code.getColor());
			}
			return ansi.fg(code.getColor());
		}
		return ansi.a(code.getAttribute());
	}
	private boolean isAnsiSupported() {
		return this.terminal.isAnsiSupported();
	}
	@Override
	public String toString() {
		return this.value.toString();
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
class ExitCommand extends AbstractCommand {
	ExitCommand() {
		super('exit', 'Quit the embedded shell');
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		throw new ShellExitException();
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
public class ShellPrompts {
	private static final String DEFAULT_PROMPT = '$ ';
	private final Deque<String> prompts = new ArrayDeque<>();
	/**
	 * Push a new prompt to be used by the shell.
	 * @param prompt the prompt
	 * @see #popPrompt()
	 */
	public void pushPrompt(String prompt) {
		this.prompts.push(prompt);
	}
	/**
	 * Pop a previously pushed prompt, returning to the previous value.
	 * @see #pushPrompt(String)
	 */
	public void popPrompt() {
		if (!this.prompts.isEmpty()) {
			this.prompts.pop();
		}
	}
	/**
	 * Returns the current prompt.
	 * @return the current prompt
	 */
	public String getPrompt() {
		return this.prompts.isEmpty() ? DEFAULT_PROMPT : this.prompts.peek();
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
public class Shell {
	private static final Set<Class<?>> NON_FORKED_COMMANDS;
	static {
		Set<Class<?>> nonForked = new HashSet<>();
		nonForked.add(VersionCommand.class);
		NON_FORKED_COMMANDS = Collections.unmodifiableSet(nonForked);
	}
	private final ShellCommandRunner commandRunner;
	private final ConsoleReader consoleReader;
	private final EscapeAwareWhiteSpaceArgumentDelimiter argumentDelimiter = new EscapeAwareWhiteSpaceArgumentDelimiter();
	private final ShellPrompts prompts = new ShellPrompts();
	/**
	 * Create a new {@link Shell} instance.
	 * @throws IOException in case of I/O errors
	 */
	Shell() throws IOException {
		attachSignalHandler();
		this.consoleReader = new ConsoleReader();
		this.commandRunner = createCommandRunner();
		initializeConsoleReader();
	}
	private ShellCommandRunner createCommandRunner() {
		ShellCommandRunner runner = new ShellCommandRunner();
		runner.addCommand(new HelpCommand(runner));
		runner.addCommands(getCommands());
		runner.addAliases('exit', 'quit');
		runner.addAliases('help', '?');
		runner.addAliases('clear', 'cls');
		return runner;
	}
	private Iterable<Command> getCommands() {
		List<Command> commands = new ArrayList<>();
		ServiceLoader<CommandFactory> factories = ServiceLoader.load(CommandFactory.class, getClass().getClassLoader());
		for (CommandFactory factory : factories) {
			for (Command command : factory.getCommands()) {
				commands.add(convertToForkCommand(command));
			}
		}
		commands.add(new PromptCommand(this.prompts));
		commands.add(new ClearCommand(this.consoleReader));
		commands.add(new ExitCommand());
		return commands;
	}
	private Command convertToForkCommand(Command command) {
		for (Class<?> nonForked : NON_FORKED_COMMANDS) {
			if (nonForked.isInstance(command)) {
				return command;
			}
		}
		return new ForkProcessCommand(command);
	}
	private void initializeConsoleReader() {
		this.consoleReader.setHistoryEnabled(true);
		this.consoleReader.setBellEnabled(false);
		this.consoleReader.setExpandEvents(false);
		this.consoleReader
			.addCompleter(new CommandCompleter(this.consoleReader, this.argumentDelimiter, this.commandRunner));
		this.consoleReader.setCompletionHandler(new CandidateListCompletionHandler());
	}
	private void attachSignalHandler() {
		SignalUtils.attachSignalHandler(this::handleSigInt);
	}
	/**
	 * Run the shell until the user exists.
	 * @throws Exception on error
	 */
	public void run() throws Exception {
		printBanner();
		try {
			runInputLoop();
		}
		catch (Exception ex) {
			if (!(ex instanceof ShellExitException)) {
				throw ex;
			}
		}
	}
	private void printBanner() {
		String version = getClass().getPackage().getImplementationVersion();
		version = (version != null) ? ' (v' + version + ')' : '';
		System.out.println(ansi('Spring Boot', Code.BOLD).append(version, Code.FAINT));
		System.out.println(ansi('Hit TAB to complete. Type "help" and hit RETURN for help, and "exit" to quit.'));
	}
	private void runInputLoop() throws Exception {
		String line;
		while ((line = this.consoleReader.readLine(getPrompt())) != null) {
			while (line.endsWith('\\')) {
				line = line.substring(0, line.length() - 1);
				line += this.consoleReader.readLine('> ');
			}
			if (StringUtils.hasLength(line)) {
				String[] args = this.argumentDelimiter.parseArguments(line);
				this.commandRunner.runAndHandleErrors(args);
			}
		}
	}
	private String getPrompt() {
		String prompt = this.prompts.getPrompt();
		return ansi(prompt, Code.FG_BLUE).toString();
	}
	private AnsiString ansi(String text, Code... codes) {
		return new AnsiString(this.consoleReader.getTerminal()).append(text, codes);
	}
	/**
	 * Final handle an interrupt signal (CTRL-C).
	 */
	protected void handleSigInt() {
		if (this.commandRunner.handleSigInt()) {
			return;
		}
		System.out.println(String.format('%nThanks for using Spring Boot'));
		System.exit(1);
	}
	/**
	 * Extension of {@link CommandRunner} to deal with {@link RunProcessCommand}s and
	 * aliases.
	 */
	private class ShellCommandRunner extends CommandRunner {
		private volatile Command lastCommand;
		private final Map<String, String> aliases = new HashMap<>();
		ShellCommandRunner() {
			super(null);
		}
		void addAliases(String command, String... aliases) {
			for (String alias : aliases) {
				this.aliases.put(alias, command);
			}
		}
		@Override
		public Command findCommand(String name) {
			if (name.startsWith('!')) {
				return new RunProcessCommand(name.substring(1));
			}
			if (this.aliases.containsKey(name)) {
				name = this.aliases.get(name);
			}
			return super.findCommand(name);
		}
		@Override
		protected void beforeRun(Command command) {
			this.lastCommand = command;
		}
		@Override
		protected void afterRun(Command command) {
		}
		boolean handleSigInt() {
			Command command = this.lastCommand;
			if (command instanceof RunProcessCommand runProcessCommand) {
				return runProcessCommand.handleSigInt();
			}
			return false;
		}
	}
}
/*
package org.springframework.boot.cli.command.shell;
/**
public class CommandCompleter extends StringsCompleter {
	private final Map<String, Completer> commandCompleters = new HashMap<>();
	private final List<Command> commands = new ArrayList<>();
	private final ConsoleReader console;
	public CommandCompleter(ConsoleReader consoleReader, ArgumentDelimiter argumentDelimiter,
			Iterable<Command> commands) {
		this.console = consoleReader;
		List<String> names = new ArrayList<>();
		for (Command command : commands) {
			this.commands.add(command);
			names.add(command.getName());
			List<String> options = new ArrayList<>();
			for (OptionHelp optionHelp : command.getOptionsHelp()) {
				options.addAll(optionHelp.getOptions());
			}
			AggregateCompleter argumentCompleters = new AggregateCompleter(new StringsCompleter(options),
					new FileNameCompleter());
			ArgumentCompleter argumentCompleter = new ArgumentCompleter(argumentDelimiter, argumentCompleters);
			argumentCompleter.setStrict(false);
			this.commandCompleters.put(command.getName(), argumentCompleter);
		}
		getStrings().addAll(names);
	}
	@Override
	public int complete(String buffer, int cursor, List<CharSequence> candidates) {
		int completionIndex = super.complete(buffer, cursor, candidates);
		int spaceIndex = buffer.indexOf(" ");
		String commandName = ((spaceIndex != -1) ? buffer.substring(0, spaceIndex) : '');
		if (StringUtils.hasText(commandName)) {
			for (Command command : this.commands) {
				if (command.getName().equals(commandName)) {
					if (cursor == buffer.length() && buffer.endsWith(' ')) {
						printUsage(command);
						break;
					}
					Completer completer = this.commandCompleters.get(command.getName());
					if (completer != null) {
						completionIndex = completer.complete(buffer, cursor, candidates);
						break;
					}
				}
			}
		}
		return completionIndex;
	}
	private void printUsage(Command command) {
		try {
			int maxOptionsLength = 0;
			List<OptionHelpLine> optionHelpLines = new ArrayList<>();
			for (OptionHelp optionHelp : command.getOptionsHelp()) {
				OptionHelpLine optionHelpLine = new OptionHelpLine(optionHelp);
				optionHelpLines.add(optionHelpLine);
				maxOptionsLength = Math.max(maxOptionsLength, optionHelpLine.getOptions().length());
			}
			this.console.println();
			this.console.println('Usage:');
			this.console.println(command.getName() + ' ' + command.getUsageHelp());
			for (OptionHelpLine optionHelpLine : optionHelpLines) {
				this.console.println(String.format('\t%' + maxOptionsLength + 's: %s', optionHelpLine.getOptions(),
						optionHelpLine.getUsage()));
			}
			this.console.drawLine();
		}
		catch (IOException ex) {
			Log.error(ex.getMessage() + ' (' + ex.getClass().getName() + ')');
		}
	}
	/**
	 * Encapsulated options and usage help.
	 */
	private static class OptionHelpLine {
		private final String options;
		private final String usage;
		OptionHelpLine(OptionHelp optionHelp) {
			this.options = String.join(', ', optionHelp.getOptions());
			this.usage = optionHelp.getUsageHelp();
		}
		String getOptions() {
			return this.options;
		}
		String getUsage() {
			return this.usage;
		}
	}
}
/*
/**
package org.springframework.boot.cli.command.shell;
/*
package org.springframework.boot.cli.command.shell;
/**
public class ShellCommand extends AbstractCommand {
	public ShellCommand() {
		super('shell', 'Start a nested shell');
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		new Shell().run();
		return ExitStatus.OK;
	}
}
/*
package org.springframework.boot.cli.command.encodepassword;
/**
public class EncodePasswordCommand extends OptionParsingCommand {
	private static final Map<String, Supplier<PasswordEncoder>> ENCODERS;
	static {
		Map<String, Supplier<PasswordEncoder>> encoders = new LinkedHashMap<>();
		encoders.put('default', PasswordEncoderFactories::createDelegatingPasswordEncoder);
		encoders.put('bcrypt', BCryptPasswordEncoder::new);
		encoders.put('pbkdf2', Pbkdf2PasswordEncoder::defaultsForSpringSecurity_v5_8);
		ENCODERS = Collections.unmodifiableMap(encoders);
	}
	public EncodePasswordCommand() {
		super('encodepassword', 'Encode a password for use with Spring Security', new EncodePasswordOptionHandler());
	}
	@Override
	public String getUsageHelp() {
		return '[options] <password to encode>';
	}
	@Override
	public Collection<HelpExample> getExamples() {
		List<HelpExample> examples = new ArrayList<>();
		examples.add(new HelpExample('To encode a password with the default (bcrypt) encoder',
				'spring encodepassword mypassword'));
		examples.add(new HelpExample('To encode a password with pbkdf2', 'spring encodepassword -a pbkdf2 mypassword'));
		return examples;
	}
	private static final class EncodePasswordOptionHandler extends OptionHandler {
		private OptionSpec<String> algorithm;
		@Override
		protected void options() {
			this.algorithm = option(Arrays.asList('algorithm', 'a'),
					'The algorithm to use. Supported algorithms: '
							+ StringUtils.collectionToDelimitedString(ENCODERS.keySet(), ', ')
							+ '. The default algorithm uses bcrypt')
				.withRequiredArg()
				.defaultsTo('default');
		}
		@Override
		protected ExitStatus run(OptionSet options) {
			if (options.nonOptionArguments().size() != 1) {
				Log.error('A single password option must be provided');
				return ExitStatus.ERROR;
			}
			String algorithm = options.valueOf(this.algorithm);
			String password = (String) options.nonOptionArguments().get(0);
			Supplier<PasswordEncoder> encoder = ENCODERS.get(algorithm);
			if (encoder == null) {
				Log.error('Unknown algorithm, valid options are: '
						+ StringUtils.collectionToCommaDelimitedString(ENCODERS.keySet()));
				return ExitStatus.ERROR;
			}
			Log.info(encoder.get().encode(password));
			return ExitStatus.OK;
		}
	}
}
/*
/**
package org.springframework.boot.cli.command.encodepassword;
/*
package org.springframework.boot.cli.command;
/**
public abstract class AbstractCommand implements Command {
	private final String name;
	private final String description;
	/**
	 * Create a new {@link AbstractCommand} instance.
	 * @param name the name of the command
	 * @param description the command description
	 */
	protected AbstractCommand(String name, String description) {
		this.name = name;
		this.description = description;
	}
	@Override
	public String getName() {
		return this.name;
	}
	@Override
	public String getDescription() {
		return this.description;
	}
	@Override
	public String getUsageHelp() {
		return null;
	}
	@Override
	public String getHelp() {
		return null;
	}
	@Override
	public Collection<OptionHelp> getOptionsHelp() {
		return Collections.emptyList();
	}
	@Override
	public Collection<HelpExample> getExamples() {
		return null;
	}
}
/*
package org.springframework.boot.cli.command.options;
/**
public interface OptionHelp {
	/**
	 * Returns the set of options that are mutually synonymous.
	 * @return the options
	 */
	Set<String> getOptions();
	/**
	 * Returns usage help for the option.
	 * @return the usage help
	 */
	String getUsageHelp();
}
/*
package org.springframework.boot.cli.command.options;
/**
public class OptionHandler {
	private final Function<String, String> argumentProcessor;
	private OptionParser parser;
	private String help;
	private Collection<OptionHelp> optionHelp;
	/**
	 * Create a new {@link OptionHandler} instance.
	 */
	public OptionHandler() {
		this(Function.identity());
	}
	/**
	 * Create a new {@link OptionHandler} instance with an argument processor.
	 * @param argumentProcessor strategy that can be used to manipulate arguments before
	 * they are used.
	 */
	public OptionHandler(Function<String, String> argumentProcessor) {
		this.argumentProcessor = argumentProcessor;
	}
	public OptionSpecBuilder option(String name, String description) {
		return getParser().accepts(name, description);
	}
	public OptionSpecBuilder option(List<String> aliases, String description) {
		return getParser().acceptsAll(aliases, description);
	}
	public OptionParser getParser() {
		if (this.parser == null) {
			this.parser = new OptionParser();
			options();
		}
		return this.parser;
	}
	protected void options() {
	}
	public final ExitStatus run(String... args) throws Exception {
		String[] argsToUse = args.clone();
		for (int i = 0; i < argsToUse.length; i++) {
			if ('-cp'.equals(argsToUse[i])) {
				argsToUse[i] = '--cp';
			}
			argsToUse[i] = this.argumentProcessor.apply(argsToUse[i]);
		}
		OptionSet options = getParser().parse(argsToUse);
		return run(options);
	}
	/**
	 * Run the command using the specified parsed {@link OptionSet}.
	 * @param options the parsed option set
	 * @return an ExitStatus
	 * @throws Exception in case of errors
	 */
	protected ExitStatus run(OptionSet options) throws Exception {
		return ExitStatus.OK;
	}
	public String getHelp() {
		if (this.help == null) {
			getParser().formatHelpWith(new BuiltinHelpFormatter(80, 2));
			OutputStream out = new ByteArrayOutputStream();
			try {
				getParser().printHelpOn(out);
			}
			catch (IOException ex) {
				return 'Help not available';
			}
			this.help = out.toString().replace(' --cp ', ' -cp  ');
		}
		return this.help;
	}
	public Collection<OptionHelp> getOptionsHelp() {
		if (this.optionHelp == null) {
			OptionHelpFormatter formatter = new OptionHelpFormatter();
			getParser().formatHelpWith(formatter);
			try {
				getParser().printHelpOn(new ByteArrayOutputStream());
			}
			catch (Exception ex) {
				// Ignore and provide no hints
			}
			this.optionHelp = formatter.getOptionHelp();
		}
		return this.optionHelp;
	}
	private static final class OptionHelpFormatter implements HelpFormatter {
		private final List<OptionHelp> help = new ArrayList<>();
		@Override
		public String format(Map<String, ? extends OptionDescriptor> options) {
			Comparator<OptionDescriptor> comparator = Comparator
				.comparing((optionDescriptor) -> optionDescriptor.options().iterator().next());
			Set<OptionDescriptor> sorted = new TreeSet<>(comparator);
			sorted.addAll(options.values());
			for (OptionDescriptor descriptor : sorted) {
				if (!descriptor.representsNonOptions()) {
					this.help.add(new OptionHelpAdapter(descriptor));
				}
			}
			return '';
		}
		Collection<OptionHelp> getOptionHelp() {
			return Collections.unmodifiableList(this.help);
		}
	}
	private static class OptionHelpAdapter implements OptionHelp {
		private final Set<String> options;
		private final String description;
		OptionHelpAdapter(OptionDescriptor descriptor) {
			this.options = new LinkedHashSet<>();
			for (String option : descriptor.options()) {
				String prefix = (option.length() != 1) ? '--' : '-';
				this.options.add(prefix + option);
			}
			if (this.options.contains('--cp')) {
				this.options.remove('--cp');
				this.options.add('-cp');
			}
			this.description = descriptor.description();
		}
		@Override
		public Set<String> getOptions() {
			return this.options;
		}
		@Override
		public String getUsageHelp() {
			return this.description;
		}
	}
}
/*
/**
package org.springframework.boot.cli.command.options;
/*
package org.springframework.boot.cli.command;
/**
public class HelpExample {
	private final String description;
	private final String example;
	/**
	 * Create a new {@link HelpExample} instance.
	 * @param description the description (in the form 'to ....')
	 * @param example the example
	 */
	public HelpExample(String description, String example) {
		this.description = description;
		this.example = example;
	}
	public String getDescription() {
		return this.description;
	}
	public String getExample() {
		return this.example;
	}
}
/*
package org.springframework.boot.cli.command;
/**
public abstract class OptionParsingCommand extends AbstractCommand {
	private final OptionHandler handler;
	protected OptionParsingCommand(String name, String description, OptionHandler handler) {
		super(name, description);
		this.handler = handler;
	}
	@Override
	public String getHelp() {
		return this.handler.getHelp();
	}
	@Override
	public Collection<OptionHelp> getOptionsHelp() {
		return this.handler.getOptionsHelp();
	}
	@Override
	public final ExitStatus run(String... args) throws Exception {
		return this.handler.run(args);
	}
	protected OptionHandler getHandler() {
		return this.handler;
	}
}
/*
package org.springframework.boot.cli.command;
/**
class NoArgumentsException extends CommandException {
	private static final long serialVersionUID = 1L;
}
/*
package org.springframework.boot.cli.command;
/**
public class CommandRunner implements Iterable<Command> {
	private static final Set<CommandException.Option> NO_EXCEPTION_OPTIONS = EnumSet
		.noneOf(CommandException.Option.class);
	private final String name;
	private final List<Command> commands = new ArrayList<>();
	private Class<?>[] optionCommandClasses = {};
	private Class<?>[] hiddenCommandClasses = {};
	/**
	 * Create a new {@link CommandRunner} instance.
	 * @param name the name of the runner or {@code null}
	 */
	public CommandRunner(String name) {
		this.name = StringUtils.hasLength(name) ? name + ' ' : '';
	}
	/**
	 * Return the name of the runner or an empty string. Non-empty names will include a
	 * trailing space character so that they can be used as a prefix.
	 * @return the name of the runner
	 */
	public String getName() {
		return this.name;
	}
	/**
	 * Add the specified commands.
	 * @param commands the commands to add
	 */
	public void addCommands(Iterable<Command> commands) {
		Assert.notNull(commands, 'Commands must not be null');
		for (Command command : commands) {
			addCommand(command);
		}
	}
	/**
	 * Add the specified command.
	 * @param command the command to add.
	 */
	public void addCommand(Command command) {
		Assert.notNull(command, 'Command must not be null');
		this.commands.add(command);
	}
	/**
	 * Set the command classes which should be considered option commands. An option
	 * command is a special type of command that usually makes more sense to present as if
	 * it is an option. For example "--version".
	 * @param commandClasses the classes of option commands.
	 * @see #isOptionCommand(Command)
	 */
	public void setOptionCommands(Class<?>... commandClasses) {
		Assert.notNull(commandClasses, 'CommandClasses must not be null');
		this.optionCommandClasses = commandClasses;
	}
	/**
	 * Set the command classes which should be hidden (i.e. executed but not displayed in
	 * the available commands list).
	 * @param commandClasses the classes of hidden commands
	 */
	public void setHiddenCommands(Class<?>... commandClasses) {
		Assert.notNull(commandClasses, 'CommandClasses must not be null');
		this.hiddenCommandClasses = commandClasses;
	}
	/**
	 * Returns if the specified command is an option command.
	 * @param command the command to test
	 * @return {@code true} if the command is an option command
	 * @see #setOptionCommands(Class...)
	 */
	public boolean isOptionCommand(Command command) {
		return isCommandInstanceOf(command, this.optionCommandClasses);
	}
	private boolean isHiddenCommand(Command command) {
		return isCommandInstanceOf(command, this.hiddenCommandClasses);
	}
	private boolean isCommandInstanceOf(Command command, Class<?>[] commandClasses) {
		for (Class<?> commandClass : commandClasses) {
			if (commandClass.isInstance(command)) {
				return true;
			}
		}
		return false;
	}
	@Override
	public Iterator<Command> iterator() {
		return getCommands().iterator();
	}
	protected final List<Command> getCommands() {
		return Collections.unmodifiableList(this.commands);
	}
	/**
	 * Find a command by name.
	 * @param name the name of the command
	 * @return the command or {@code null} if not found
	 */
	public Command findCommand(String name) {
		for (Command candidate : this.commands) {
			String candidateName = candidate.getName();
			if (candidateName.equals(name) || (isOptionCommand(candidate) && ('--' + candidateName).equals(name))) {
				return candidate;
			}
		}
		return null;
	}
	/**
	 * Run the appropriate and handle and errors.
	 * @param args the input arguments
	 * @return a return status code (non boot is used to indicate an error)
	 */
	public int runAndHandleErrors(String... args) {
		String[] argsWithoutDebugFlags = removeDebugFlags(args);
		boolean debug = argsWithoutDebugFlags.length != args.length;
		if (debug) {
			System.setProperty('debug', 'true');
		}
		try {
			ExitStatus result = run(argsWithoutDebugFlags);
			// The caller will hang up if it gets a non-zero status
			if (result != null && result.isHangup()) {
				return (result.getCode() > 0) ? result.getCode() : 0;
			}
			return 0;
		}
		catch (NoArgumentsException ex) {
			showUsage();
			return 1;
		}
		catch (Exception ex) {
			return handleError(debug, ex);
		}
	}
	private String[] removeDebugFlags(String[] args) {
		List<String> rtn = new ArrayList<>(args.length);
		boolean appArgsDetected = false;
		for (String arg : args) {
			// Allow apps to have a --debug argument
			appArgsDetected |= '--'.equals(arg);
			if ('--debug'.equals(arg) && !appArgsDetected) {
				continue;
			}
			rtn.add(arg);
		}
		return StringUtils.toStringArray(rtn);
	}
	/**
	 * Parse the arguments and run a suitable command.
	 * @param args the arguments
	 * @return the outcome of the command
	 * @throws Exception if the command fails
	 */
	protected ExitStatus run(String... args) throws Exception {
		if (args.length == 0) {
			throw new NoArgumentsException();
		}
		String commandName = args[0];
		String[] commandArguments = Arrays.copyOfRange(args, 1, args.length);
		Command command = findCommand(commandName);
		if (command == null) {
			throw new NoSuchCommandException(commandName);
		}
		beforeRun(command);
		try {
			return command.run(commandArguments);
		}
		finally {
			afterRun(command);
		}
	}
	/**
	 * Subclass hook called before a command is run.
	 * @param command the command about to run
	 */
	protected void beforeRun(Command command) {
	}
	/**
	 * Subclass hook called after a command has run.
	 * @param command the command that has run
	 */
	protected void afterRun(Command command) {
	}
	private int handleError(boolean debug, Exception ex) {
		Set<CommandException.Option> options = NO_EXCEPTION_OPTIONS;
		if (ex instanceof CommandException commandException) {
			options = commandException.getOptions();
			if (options.contains(CommandException.Option.RETHROW)) {
				throw (CommandException) ex;
			}
		}
		boolean couldNotShowMessage = false;
		if (!options.contains(CommandException.Option.HIDE_MESSAGE)) {
			couldNotShowMessage = !errorMessage(ex.getMessage());
		}
		if (options.contains(CommandException.Option.SHOW_USAGE)) {
			showUsage();
		}
		if (debug || couldNotShowMessage || options.contains(CommandException.Option.STACK_TRACE)) {
			printStackTrace(ex);
		}
		return 1;
	}
	protected boolean errorMessage(String message) {
		Log.error((message != null) ? message : 'Unexpected error');
		return message != null;
	}
	protected void showUsage() {
		Log.infoPrint('usage: ' + this.name);
		for (Command command : this.commands) {
			if (isOptionCommand(command)) {
				Log.infoPrint('[--' + command.getName() + '] ');
			}
		}
		Log.info('');
		Log.info('       <command> [<args>]');
		Log.info('');
		Log.info('Available commands are:');
		for (Command command : this.commands) {
			if (!isOptionCommand(command) && !isHiddenCommand(command)) {
				String usageHelp = command.getUsageHelp();
				String description = command.getDescription();
				Log.info(String.format('%n  %1$s %2$-15s%n    %3$s', command.getName(),
						(usageHelp != null) ? usageHelp : '', (description != null) ? description : ''));
			}
		}
		Log.info('');
		Log.info('Common options:');
		Log.info(String.format('%n  %1$s %2$-15s%n    %3$s', '--debug', 'Verbose mode',
				'Print additional status information for the command you are running'));
		Log.info('');
		Log.info('');
		Log.info('See "' + this.name + 'help <command>" for more information on a specific command.');
	}
	protected void printStackTrace(Exception ex) {
		Log.error('');
		Log.error(ex);
		Log.error('');
	}
}
/*
package org.springframework.boot.cli.command;
/**
public class CommandException extends RuntimeException {
	private static final long serialVersionUID = 0L;
	private final EnumSet<Option> options;
	/**
	 * Create a new {@link CommandException} with the specified options.
	 * @param options the exception options
	 */
	public CommandException(Option... options) {
		this.options = asEnumSet(options);
	}
	/**
	 * Create a new {@link CommandException} with the specified options.
	 * @param message the exception message to display to the user
	 * @param options the exception options
	 */
	public CommandException(String message, Option... options) {
		super(message);
		this.options = asEnumSet(options);
	}
	/**
	 * Create a new {@link CommandException} with the specified options.
	 * @param message the exception message to display to the user
	 * @param cause the underlying cause
	 * @param options the exception options
	 */
	public CommandException(String message, Throwable cause, Option... options) {
		super(message, cause);
		this.options = asEnumSet(options);
	}
	/**
	 * Create a new {@link CommandException} with the specified options.
	 * @param cause the underlying cause
	 * @param options the exception options
	 */
	public CommandException(Throwable cause, Option... options) {
		super(cause);
		this.options = asEnumSet(options);
	}
	private EnumSet<Option> asEnumSet(Option[] options) {
		if (options == null || options.length == 0) {
			return EnumSet.noneOf(Option.class);
		}
		return EnumSet.copyOf(Arrays.asList(options));
	}
	/**
	 * Returns a set of options that are understood by the {@link CommandRunner}.
	 * @return the options understood by the runner
	 */
	public Set<Option> getOptions() {
		return Collections.unmodifiableSet(this.options);
	}
	/**
	 * Specific options understood by the {@link CommandRunner}.
	 */
	public enum Option {
		/**
		 * Hide the exception message.
		 */
		HIDE_MESSAGE,
		/**
		 * Print basic CLI usage information.
		 */
		SHOW_USAGE,
		/**
		 * Print the stack-trace of the exception.
		 */
		STACK_TRACE,
		/**
		 * Re-throw the exception rather than dealing with it.
		 */
		RETHROW
	}
}
/*
package org.springframework.boot.cli.command;
/**
public interface Command {
	/**
	 * Returns the name of the command.
	 * @return the command"s name
	 */
	String getName();
	/**
	 * Returns a description of the command.
	 * @return the command"s description
	 */
	String getDescription();
	/**
	 * Returns usage help for the command. This should be a simple one-line string
	 * describing basic usage. e.g. "[options] &lt;file&gt;". Do not include the name of
	 * the command in this string.
	 * @return the command"s usage help
	 */
	String getUsageHelp();
	/**
	 * Gets full help text for the command, e.g. a longer description and one line per
	 * option.
	 * @return the command"s help text
	 */
	String getHelp();
	/**
	 * Returns help for each supported option.
	 * @return help for each of the command"s options
	 */
	Collection<OptionHelp> getOptionsHelp();
	/**
	 * Return some examples for the command.
	 * @return the command"s examples
	 */
	Collection<HelpExample> getExamples();
	/**
	 * Run the command.
	 * @param args command arguments (this will not include the command itself)
	 * @return the outcome of the command
	 * @throws Exception if the command fails
	 */
	ExitStatus run(String... args) throws Exception;
}
/*
/**
package org.springframework.boot.cli.command;
/*
package org.springframework.boot.cli.command;
/**
public class NoHelpCommandArgumentsException extends CommandException {
	private static final long serialVersionUID = 1L;
	public NoHelpCommandArgumentsException() {
		super(Option.SHOW_USAGE, Option.HIDE_MESSAGE);
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class ProjectType {
	private final String id;
	private final String name;
	private final String action;
	private final boolean defaultType;
	private final Map<String, String> tags = new HashMap<>();
	ProjectType(String id, String name, String action, boolean defaultType, Map<String, String> tags) {
		this.id = id;
		this.name = name;
		this.action = action;
		this.defaultType = defaultType;
		if (tags != null) {
			this.tags.putAll(tags);
		}
	}
	String getId() {
		return this.id;
	}
	String getName() {
		return this.name;
	}
	String getAction() {
		return this.action;
	}
	boolean isDefaultType() {
		return this.defaultType;
	}
	Map<String, String> getTags() {
		return Collections.unmodifiableMap(this.tags);
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class InitializrService {
	private static final String FILENAME_HEADER_PREFIX = 'filename=\'';
	/**
	 * Accept header to use to retrieve the json meta-data.
	 */
	public static final String ACCEPT_META_DATA = 'application/vnd.initializr.v2.1+'
			+ 'json,application/vnd.initializr.v2+json';
	/**
	 * Accept header to use to retrieve the service capabilities of the service. If the
	 * service does not offer such feature, the json meta-data are retrieved instead.
	 */
	public static final String ACCEPT_SERVICE_CAPABILITIES = 'text/plain,' + ACCEPT_META_DATA;
	/**
	 * Late binding HTTP client.
	 */
	private HttpClient http;
	InitializrService() {
	}
	InitializrService(HttpClient http) {
		this.http = http;
	}
	protected HttpClient getHttp() {
		if (this.http == null) {
			this.http = HttpClientBuilder.create().useSystemProperties().build();
		}
		return this.http;
	}
	/**
	 * Generate a project based on the specified {@link ProjectGenerationRequest}.
	 * @param request the generation request
	 * @return an entity defining the project
	 * @throws IOException if generation fails
	 */
	ProjectGenerationResponse generate(ProjectGenerationRequest request) throws IOException {
		Log.info('Using service at ' + request.getServiceUrl());
		InitializrServiceMetadata metadata = loadMetadata(request.getServiceUrl());
		URI url = request.generateUrl(metadata);
		ClassicHttpResponse httpResponse = executeProjectGenerationRequest(url);
		HttpEntity httpEntity = httpResponse.getEntity();
		validateResponse(httpResponse, request.getServiceUrl());
		return createResponse(httpResponse, httpEntity);
	}
	/**
	 * Load the {@link InitializrServiceMetadata} at the specified url.
	 * @param serviceUrl to url of the initializer service
	 * @return the metadata describing the service
	 * @throws IOException if the service"s metadata cannot be loaded
	 */
	InitializrServiceMetadata loadMetadata(String serviceUrl) throws IOException {
		ClassicHttpResponse httpResponse = executeInitializrMetadataRetrieval(serviceUrl);
		validateResponse(httpResponse, serviceUrl);
		return parseJsonMetadata(httpResponse.getEntity());
	}
	/**
	 * Loads the service capabilities of the service at the specified URL. If the service
	 * supports generating a textual representation of the capabilities, it is returned,
	 * otherwise {@link InitializrServiceMetadata} is returned.
	 * @param serviceUrl to url of the initializer service
	 * @return the service capabilities (as a String) or the
	 * {@link InitializrServiceMetadata} describing the service
	 * @throws IOException if the service capabilities cannot be loaded
	 */
	Object loadServiceCapabilities(String serviceUrl) throws IOException {
		HttpGet request = new HttpGet(serviceUrl);
		request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_SERVICE_CAPABILITIES));
		ClassicHttpResponse httpResponse = execute(request, URI.create(serviceUrl), 'retrieve help');
		validateResponse(httpResponse, serviceUrl);
		HttpEntity httpEntity = httpResponse.getEntity();
		ContentType contentType = ContentType.create(httpEntity.getContentType());
		if (contentType.getMimeType().equals('text/plain')) {
			return getContent(httpEntity);
		}
		return parseJsonMetadata(httpEntity);
	}
	private InitializrServiceMetadata parseJsonMetadata(HttpEntity httpEntity) throws IOException {
		try {
			return new InitializrServiceMetadata(getContentAsJson(httpEntity));
		}
		catch (JSONException ex) {
			throw new ReportableException('Invalid content received from server (' + ex.getMessage() + ')', ex);
		}
	}
	private void validateResponse(ClassicHttpResponse httpResponse, String serviceUrl) {
		if (httpResponse.getEntity() == null) {
			throw new ReportableException('No content received from server "' + serviceUrl + '"');
		}
		if (httpResponse.getCode() != 200) {
			throw createException(serviceUrl, httpResponse);
		}
	}
	private ProjectGenerationResponse createResponse(ClassicHttpResponse httpResponse, HttpEntity httpEntity)
			throws IOException {
		ProjectGenerationResponse response = new ProjectGenerationResponse(
				ContentType.create(httpEntity.getContentType()));
		response.setContent(FileCopyUtils.copyToByteArray(httpEntity.getContent()));
		String fileName = extractFileName(httpResponse.getFirstHeader('Content-Disposition'));
		if (fileName != null) {
			response.setFileName(fileName);
		}
		return response;
	}
	/**
	 * Request the creation of the project using the specified URL.
	 * @param url the URL
	 * @return the response
	 */
	private ClassicHttpResponse executeProjectGenerationRequest(URI url) {
		return execute(new HttpGet(url), url, 'generate project');
	}
	/**
	 * Retrieves the meta-data of the service at the specified URL.
	 * @param url the URL
	 * @return the response
	 */
	private ClassicHttpResponse executeInitializrMetadataRetrieval(String url) {
		HttpGet request = new HttpGet(url);
		request.setHeader(new BasicHeader(HttpHeaders.ACCEPT, ACCEPT_META_DATA));
		return execute(request, URI.create(url), 'retrieve metadata');
	}
	private ClassicHttpResponse execute(HttpUriRequest request, URI url, String description) {
		try {
			HttpHost host = HttpHost.create(url);
			request.addHeader('User-Agent', 'SpringBootCli/' + getClass().getPackage().getImplementationVersion());
			return getHttp().executeOpen(host, request, null);
		}
		catch (IOException ex) {
			throw new ReportableException(
					'Failed to ' + description + ' from service at "' + url + '" (' + ex.getMessage() + ')');
		}
	}
	private ReportableException createException(String url, ClassicHttpResponse httpResponse) {
		StatusLine statusLine = new StatusLine(httpResponse);
		String message = 'Initializr service call failed using "' + url + '" - service returned '
				+ statusLine.getReasonPhrase();
		String error = extractMessage(httpResponse.getEntity());
		if (StringUtils.hasText(error)) {
			message += ': "' + error + '"';
		}
		else {
			int statusCode = statusLine.getStatusCode();
			message += ' (unexpected ' + statusCode + ' error)';
		}
		throw new ReportableException(message);
	}
	private String extractMessage(HttpEntity entity) {
		if (entity != null) {
			try {
				JSONObject error = getContentAsJson(entity);
				if (error.has('message')) {
					return error.getString('message');
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return null;
	}
	private JSONObject getContentAsJson(HttpEntity entity) throws IOException, JSONException {
		return new JSONObject(getContent(entity));
	}
	private String getContent(HttpEntity entity) throws IOException {
		ContentType contentType = ContentType.create(entity.getContentType());
		Charset charset = contentType.getCharset();
		charset = (charset != null) ? charset : StandardCharsets.UTF_8;
		byte[] content = FileCopyUtils.copyToByteArray(entity.getContent());
		return new String(content, charset);
	}
	private String extractFileName(Header header) {
		if (header != null) {
			String value = header.getValue();
			int start = value.indexOf(FILENAME_HEADER_PREFIX);
			if (start != -1) {
				value = value.substring(start + FILENAME_HEADER_PREFIX.length());
				int end = value.indexOf("\'");
				if (end != -1) {
					return value.substring(0, end);
				}
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class ServiceCapabilitiesReportGenerator {
	private static final String NEW_LINE = System.lineSeparator();
	private final InitializrService initializrService;
	/**
	 * Creates an instance using the specified {@link InitializrService}.
	 * @param initializrService the initializr service
	 */
	ServiceCapabilitiesReportGenerator(InitializrService initializrService) {
		this.initializrService = initializrService;
	}
	/**
	 * Generate a report for the specified service. The report contains the available
	 * capabilities as advertised by the root endpoint.
	 * @param url the url of the service
	 * @return the report that describes the service
	 * @throws IOException if the report cannot be generated
	 */
	String generate(String url) throws IOException {
		Object content = this.initializrService.loadServiceCapabilities(url);
		if (content instanceof InitializrServiceMetadata metadata) {
			return generateHelp(url, metadata);
		}
		return content.toString();
	}
	private String generateHelp(String url, InitializrServiceMetadata metadata) {
		String header = 'Capabilities of ' + url;
		StringBuilder report = new StringBuilder();
		report.append('='.repeat(header.length())).append(NEW_LINE);
		report.append(header).append(NEW_LINE);
		report.append('='.repeat(header.length())).append(NEW_LINE);
		report.append(NEW_LINE);
		reportAvailableDependencies(metadata, report);
		report.append(NEW_LINE);
		reportAvailableProjectTypes(metadata, report);
		report.append(NEW_LINE);
		reportDefaults(report, metadata);
		return report.toString();
	}
	private void reportAvailableDependencies(InitializrServiceMetadata metadata, StringBuilder report) {
		report.append('Available dependencies:').append(NEW_LINE);
		report.append('-----------------------').append(NEW_LINE);
		List<Dependency> dependencies = getSortedDependencies(metadata);
		for (Dependency dependency : dependencies) {
			report.append(dependency.getId()).append(' - ').append(dependency.getName());
			if (dependency.getDescription() != null) {
				report.append(': ').append(dependency.getDescription());
			}
			report.append(NEW_LINE);
		}
	}
	private List<Dependency> getSortedDependencies(InitializrServiceMetadata metadata) {
		List<Dependency> dependencies = new ArrayList<>(metadata.getDependencies());
		dependencies.sort(Comparator.comparing(Dependency::getId));
		return dependencies;
	}
	private void reportAvailableProjectTypes(InitializrServiceMetadata metadata, StringBuilder report) {
		report.append('Available project types:').append(NEW_LINE);
		report.append('------------------------').append(NEW_LINE);
		SortedSet<Entry<String, ProjectType>> entries = new TreeSet<>(Entry.comparingByKey());
		entries.addAll(metadata.getProjectTypes().entrySet());
		for (Entry<String, ProjectType> entry : entries) {
			ProjectType type = entry.getValue();
			report.append(entry.getKey()).append(' -  ').append(type.getName());
			if (!type.getTags().isEmpty()) {
				reportTags(report, type);
			}
			if (type.isDefaultType()) {
				report.append(' (default)');
			}
			report.append(NEW_LINE);
		}
	}
	private void reportTags(StringBuilder report, ProjectType type) {
		Map<String, String> tags = type.getTags();
		Iterator<Map.Entry<String, String>> iterator = tags.entrySet().iterator();
		report.append(' [');
		while (iterator.hasNext()) {
			Map.Entry<String, String> entry = iterator.next();
			report.append(entry.getKey()).append(':').append(entry.getValue());
			if (iterator.hasNext()) {
				report.append(', ');
			}
		}
		report.append(']');
	}
	private void reportDefaults(StringBuilder report, InitializrServiceMetadata metadata) {
		report.append('Defaults:').append(NEW_LINE);
		report.append('---------').append(NEW_LINE);
		List<String> defaultsKeys = new ArrayList<>(metadata.getDefaults().keySet());
		Collections.sort(defaultsKeys);
		for (String defaultsKey : defaultsKeys) {
			String defaultsValue = metadata.getDefaults().get(defaultsKey);
			report.append(defaultsKey).append(': ').append(defaultsValue).append(NEW_LINE);
		}
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
public class InitCommand extends OptionParsingCommand {
	public InitCommand() {
		this(new InitOptionHandler(new InitializrService()));
	}
	public InitCommand(InitOptionHandler handler) {
		super('init', 'Initialize a new project using Spring Initializr (start.spring.io)', handler);
	}
	@Override
	public String getUsageHelp() {
		return '[options] [location]';
	}
	@Override
	public Collection<HelpExample> getExamples() {
		List<HelpExample> examples = new ArrayList<>();
		examples.add(new HelpExample('To list all the capabilities of the service', 'spring init --list'));
		examples.add(new HelpExample('To creates a default project', 'spring init'));
		examples.add(new HelpExample('To create a web my-app.zip', 'spring init -d=web my-app.zip'));
		examples.add(new HelpExample('To create a web/data-jpa gradle project unpacked',
				'spring init -d=web,jpa --build=gradle my-dir'));
		return examples;
	}
	/**
	 * {@link OptionHandler} for {@link InitCommand}.
	 */
	static class InitOptionHandler extends OptionHandler {
		/**
		 * Mapping from camelCase options advertised by the service to our kebab-case
		 * options.
		 */
		private static final Map<String, String> CAMEL_CASE_OPTIONS;
		static {
			Map<String, String> options = new HashMap<>();
			options.put('--groupId', '--group-id');
			options.put('--artifactId', '--artifact-id');
			options.put('--packageName', '--package-name');
			options.put('--javaVersion', '--java-version');
			options.put('--bootVersion', '--boot-version');
			CAMEL_CASE_OPTIONS = Collections.unmodifiableMap(options);
		}
		private final ServiceCapabilitiesReportGenerator serviceCapabilitiesReport;
		private final ProjectGenerator projectGenerator;
		private OptionSpec<String> target;
		private OptionSpec<Void> listCapabilities;
		private OptionSpec<String> groupId;
		private OptionSpec<String> artifactId;
		private OptionSpec<String> version;
		private OptionSpec<String> name;
		private OptionSpec<String> description;
		private OptionSpec<String> packageName;
		private OptionSpec<String> type;
		private OptionSpec<String> packaging;
		private OptionSpec<String> build;
		private OptionSpec<String> format;
		private OptionSpec<String> javaVersion;
		private OptionSpec<String> language;
		private OptionSpec<String> bootVersion;
		private OptionSpec<String> dependencies;
		private OptionSpec<Void> extract;
		private OptionSpec<Void> force;
		InitOptionHandler(InitializrService initializrService) {
			super(InitOptionHandler::processArgument);
			this.serviceCapabilitiesReport = new ServiceCapabilitiesReportGenerator(initializrService);
			this.projectGenerator = new ProjectGenerator(initializrService);
		}
		@Override
		protected void options() {
			this.target = option(Arrays.asList('target'), 'URL of the service to use').withRequiredArg()
				.defaultsTo(ProjectGenerationRequest.DEFAULT_SERVICE_URL);
			this.listCapabilities = option(Arrays.asList('list'),
					'List the capabilities of the service. Use it to discover the '
							+ 'dependencies and the types that are available');
			projectGenerationOptions();
			otherOptions();
		}
		private void projectGenerationOptions() {
			this.groupId = option(Arrays.asList('group-id', 'g'), 'Project coordinates (for example "org.test")')
				.withRequiredArg();
			this.artifactId = option(Arrays.asList('artifact-id', 'a'),
					'Project coordinates; infer archive name (for example "test")')
				.withRequiredArg();
			this.version = option(Arrays.asList('version', 'v'), 'Project version (for example "0.0.1-SNAPSHOT")')
				.withRequiredArg();
			this.name = option(Arrays.asList('name', 'n'), 'Project name; infer application name').withRequiredArg();
			this.description = option('description', 'Project description').withRequiredArg();
			this.packageName = option(Arrays.asList('package-name'), 'Package name').withRequiredArg();
			this.type = option(Arrays.asList('type', 't'),
					'Project type. Not normally needed if you use --build '
							+ 'and/or --format. Check the capabilities of the service (--list) for more details')
				.withRequiredArg();
			this.packaging = option(Arrays.asList('packaging', 'p'), 'Project packaging (for example "jar")')
				.withRequiredArg();
			this.build = option('build', 'Build system to use (for example "maven" or "gradle")').withRequiredArg()
				.defaultsTo('gradle');
			this.format = option('format', 'Format of the generated content (for example "build" for a build file, '
					+ '"project" for a project archive)')
				.withRequiredArg()
				.defaultsTo('project');
			this.javaVersion = option(Arrays.asList('java-version', 'j'), 'Language level (for example "1.8")')
				.withRequiredArg();
			this.language = option(Arrays.asList('language', 'l'), 'Programming language  (for example "java")')
				.withRequiredArg();
			this.bootVersion = option(Arrays.asList('boot-version', 'b'),
					'Spring Boot version (for example "1.2.0.RELEASE")')
				.withRequiredArg();
			this.dependencies = option(Arrays.asList('dependencies', 'd'),
					'Comma-separated list of dependency identifiers to include in the generated project')
				.withRequiredArg();
		}
		private void otherOptions() {
			this.extract = option(Arrays.asList('extract', 'x'),
					'Extract the project archive. Inferred if a location is specified without an extension');
			this.force = option(Arrays.asList('force', 'f'), 'Force overwrite of existing files');
		}
		@Override
		protected ExitStatus run(OptionSet options) throws Exception {
			try {
				if (options.has(this.listCapabilities)) {
					generateReport(options);
				}
				else {
					generateProject(options);
				}
				return ExitStatus.OK;
			}
			catch (ReportableException ex) {
				Log.error(ex.getMessage());
				return ExitStatus.ERROR;
			}
			catch (Exception ex) {
				Log.error(ex);
				return ExitStatus.ERROR;
			}
		}
		private void generateReport(OptionSet options) throws IOException {
			Log.info(this.serviceCapabilitiesReport.generate(options.valueOf(this.target)));
		}
		protected void generateProject(OptionSet options) throws IOException {
			ProjectGenerationRequest request = createProjectGenerationRequest(options);
			this.projectGenerator.generateProject(request, options.has(this.force));
		}
		protected ProjectGenerationRequest createProjectGenerationRequest(OptionSet options) {
			List<?> nonOptionArguments = new ArrayList<Object>(options.nonOptionArguments());
			Assert.isTrue(nonOptionArguments.size() <= 1, 'Only the target location may be specified');
			ProjectGenerationRequest request = new ProjectGenerationRequest();
			request.setServiceUrl(options.valueOf(this.target));
			if (options.has(this.bootVersion)) {
				request.setBootVersion(options.valueOf(this.bootVersion));
			}
			if (options.has(this.dependencies)) {
				for (String dep : options.valueOf(this.dependencies).split(',')) {
					request.getDependencies().add(dep.trim());
				}
			}
			if (options.has(this.javaVersion)) {
				request.setJavaVersion(options.valueOf(this.javaVersion));
			}
			if (options.has(this.packageName)) {
				request.setPackageName(options.valueOf(this.packageName));
			}
			request.setBuild(options.valueOf(this.build));
			request.setFormat(options.valueOf(this.format));
			request.setDetectType(options.has(this.build) || options.has(this.format));
			if (options.has(this.type)) {
				request.setType(options.valueOf(this.type));
			}
			if (options.has(this.packaging)) {
				request.setPackaging(options.valueOf(this.packaging));
			}
			if (options.has(this.language)) {
				request.setLanguage(options.valueOf(this.language));
			}
			if (options.has(this.groupId)) {
				request.setGroupId(options.valueOf(this.groupId));
			}
			if (options.has(this.artifactId)) {
				request.setArtifactId(options.valueOf(this.artifactId));
			}
			if (options.has(this.name)) {
				request.setName(options.valueOf(this.name));
			}
			if (options.has(this.version)) {
				request.setVersion(options.valueOf(this.version));
			}
			if (options.has(this.description)) {
				request.setDescription(options.valueOf(this.description));
			}
			request.setExtract(options.has(this.extract));
			if (nonOptionArguments.size() == 1) {
				String output = (String) nonOptionArguments.get(0);
				request.setOutput(output);
			}
			return request;
		}
		private static String processArgument(String argument) {
			for (Map.Entry<String, String> entry : CAMEL_CASE_OPTIONS.entrySet()) {
				String name = entry.getKey();
				if (argument.startsWith(name + ' ') || argument.startsWith(name + '=')) {
					return entry.getValue() + argument.substring(name.length());
				}
			}
			return argument;
		}
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class InitializrServiceMetadata {
	private static final String DEPENDENCIES_EL = 'dependencies';
	private static final String TYPE_EL = 'type';
	private static final String VALUES_EL = 'values';
	private static final String NAME_ATTRIBUTE = 'name';
	private static final String ID_ATTRIBUTE = 'id';
	private static final String DESCRIPTION_ATTRIBUTE = 'description';
	private static final String ACTION_ATTRIBUTE = 'action';
	private static final String DEFAULT_ATTRIBUTE = 'default';
	private final Map<String, Dependency> dependencies;
	private final MetadataHolder<String, ProjectType> projectTypes;
	private final Map<String, String> defaults;
	/**
	 * Creates a new instance using the specified root {@link JSONObject}.
	 * @param root the root JSONObject
	 * @throws JSONException on JSON parsing failure
	 */
	InitializrServiceMetadata(JSONObject root) throws JSONException {
		this.dependencies = parseDependencies(root);
		this.projectTypes = parseProjectTypes(root);
		this.defaults = Collections.unmodifiableMap(parseDefaults(root));
	}
	InitializrServiceMetadata(ProjectType defaultProjectType) {
		this.dependencies = new HashMap<>();
		this.projectTypes = new MetadataHolder<>();
		this.projectTypes.getContent().put(defaultProjectType.getId(), defaultProjectType);
		this.projectTypes.setDefaultItem(defaultProjectType);
		this.defaults = new HashMap<>();
	}
	/**
	 * Return the dependencies supported by the service.
	 * @return the supported dependencies
	 */
	Collection<Dependency> getDependencies() {
		return this.dependencies.values();
	}
	/**
	 * Return the dependency with the specified id or {@code null} if no such dependency
	 * exists.
	 * @param id the id
	 * @return the dependency or {@code null}
	 */
	Dependency getDependency(String id) {
		return this.dependencies.get(id);
	}
	/**
	 * Return the project types supported by the service.
	 * @return the supported project types
	 */
	Map<String, ProjectType> getProjectTypes() {
		return this.projectTypes.getContent();
	}
	/**
	 * Return the default type to use or {@code null} if the metadata does not define any
	 * default.
	 * @return the default project type or {@code null}
	 */
	ProjectType getDefaultType() {
		if (this.projectTypes.getDefaultItem() != null) {
			return this.projectTypes.getDefaultItem();
		}
		String defaultTypeId = getDefaults().get('type');
		if (defaultTypeId != null) {
			return this.projectTypes.getContent().get(defaultTypeId);
		}
		return null;
	}
	/**
	 * Returns the defaults applicable to the service.
	 * @return the defaults of the service
	 */
	Map<String, String> getDefaults() {
		return this.defaults;
	}
	private Map<String, Dependency> parseDependencies(JSONObject root) throws JSONException {
		Map<String, Dependency> result = new HashMap<>();
		if (!root.has(DEPENDENCIES_EL)) {
			return result;
		}
		JSONObject dependencies = root.getJSONObject(DEPENDENCIES_EL);
		JSONArray array = dependencies.getJSONArray(VALUES_EL);
		for (int i = 0; i < array.length(); i++) {
			JSONObject group = array.getJSONObject(i);
			parseGroup(group, result);
		}
		return result;
	}
	private MetadataHolder<String, ProjectType> parseProjectTypes(JSONObject root) throws JSONException {
		MetadataHolder<String, ProjectType> result = new MetadataHolder<>();
		if (!root.has(TYPE_EL)) {
			return result;
		}
		JSONObject type = root.getJSONObject(TYPE_EL);
		JSONArray array = type.getJSONArray(VALUES_EL);
		String defaultType = (type.has(DEFAULT_ATTRIBUTE) ? type.getString(DEFAULT_ATTRIBUTE) : null);
		for (int i = 0; i < array.length(); i++) {
			JSONObject typeJson = array.getJSONObject(i);
			ProjectType projectType = parseType(typeJson, defaultType);
			result.getContent().put(projectType.getId(), projectType);
			if (projectType.isDefaultType()) {
				result.setDefaultItem(projectType);
			}
		}
		return result;
	}
	private Map<String, String> parseDefaults(JSONObject root) throws JSONException {
		Map<String, String> result = new HashMap<>();
		Iterator<?> keys = root.keys();
		while (keys.hasNext()) {
			String key = (String) keys.next();
			Object o = root.get(key);
			if (o instanceof JSONObject child) {
				if (child.has(DEFAULT_ATTRIBUTE)) {
					result.put(key, child.getString(DEFAULT_ATTRIBUTE));
				}
			}
		}
		return result;
	}
	private void parseGroup(JSONObject group, Map<String, Dependency> dependencies) throws JSONException {
		if (group.has(VALUES_EL)) {
			JSONArray content = group.getJSONArray(VALUES_EL);
			for (int i = 0; i < content.length(); i++) {
				Dependency dependency = parseDependency(content.getJSONObject(i));
				dependencies.put(dependency.getId(), dependency);
			}
		}
	}
	private Dependency parseDependency(JSONObject object) throws JSONException {
		String id = getStringValue(object, ID_ATTRIBUTE, null);
		String name = getStringValue(object, NAME_ATTRIBUTE, null);
		String description = getStringValue(object, DESCRIPTION_ATTRIBUTE, null);
		return new Dependency(id, name, description);
	}
	private ProjectType parseType(JSONObject object, String defaultId) throws JSONException {
		String id = getStringValue(object, ID_ATTRIBUTE, null);
		String name = getStringValue(object, NAME_ATTRIBUTE, null);
		String action = getStringValue(object, ACTION_ATTRIBUTE, null);
		boolean defaultType = id.equals(defaultId);
		Map<String, String> tags = new HashMap<>();
		if (object.has('tags')) {
			JSONObject jsonTags = object.getJSONObject('tags');
			tags.putAll(parseStringItems(jsonTags));
		}
		return new ProjectType(id, name, action, defaultType, tags);
	}
	private String getStringValue(JSONObject object, String name, String defaultValue) throws JSONException {
		return object.has(name) ? object.getString(name) : defaultValue;
	}
	private Map<String, String> parseStringItems(JSONObject json) throws JSONException {
		Map<String, String> result = new HashMap<>();
		for (Iterator<?> iterator = json.keys(); iterator.hasNext();) {
			String key = (String) iterator.next();
			Object value = json.get(key);
			if (value instanceof String string) {
				result.put(key, string);
			}
		}
		return result;
	}
	private static final class MetadataHolder<K, T> {
		private final Map<K, T> content;
		private T defaultItem;
		private MetadataHolder() {
			this.content = new HashMap<>();
		}
		Map<K, T> getContent() {
			return this.content;
		}
		T getDefaultItem() {
			return this.defaultItem;
		}
		void setDefaultItem(T defaultItem) {
			this.defaultItem = defaultItem;
		}
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class ProjectGenerator {
	private static final String ZIP_MIME_TYPE = 'application/zip';
	private final InitializrService initializrService;
	ProjectGenerator(InitializrService initializrService) {
		this.initializrService = initializrService;
	}
	void generateProject(ProjectGenerationRequest request, boolean force) throws IOException {
		ProjectGenerationResponse response = this.initializrService.generate(request);
		String fileName = (request.getOutput() != null) ? request.getOutput() : response.getFileName();
		if (shouldExtract(request, response)) {
			if (isZipArchive(response)) {
				extractProject(response, request.getOutput(), force);
				return;
			}
			else {
				Log.info('Could not extract "' + response.getContentType() + '"');
				// Use value from the server since we can"t extract it
				fileName = response.getFileName();
			}
		}
		if (fileName == null) {
			throw new ReportableException('Could not save the project, the server did not set a preferred '
					+ 'file name and no location was set. Specify the output location for the project.');
		}
		writeProject(response, fileName, force);
	}
	/**
	 * Detect if the project should be extracted.
	 * @param request the generation request
	 * @param response the generation response
	 * @return if the project should be extracted
	 */
	private boolean shouldExtract(ProjectGenerationRequest request, ProjectGenerationResponse response) {
		if (request.isExtract()) {
			return true;
		}
		// explicit name hasn"t been provided for an archive and there is no extension
		return isZipArchive(response) && request.getOutput() != null && !request.getOutput().contains('.');
	}
	private boolean isZipArchive(ProjectGenerationResponse entity) {
		if (entity.getContentType() != null) {
			try {
				return ZIP_MIME_TYPE.equals(entity.getContentType().getMimeType());
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return false;
	}
	private void extractProject(ProjectGenerationResponse entity, String output, boolean overwrite) throws IOException {
		File outputDirectory = (output != null) ? new File(output) : new File(System.getProperty('user.dir'));
		if (!outputDirectory.exists()) {
			outputDirectory.mkdirs();
		}
		try (ZipInputStream zipStream = new ZipInputStream(new ByteArrayInputStream(entity.getContent()))) {
			extractFromStream(zipStream, overwrite, outputDirectory);
			fixExecutableFlag(outputDirectory, 'mvnw');
			fixExecutableFlag(outputDirectory, 'gradlew');
			Log.info('Project extracted to "' + outputDirectory.getAbsolutePath() + '"');
		}
	}
	private void extractFromStream(ZipInputStream zipStream, boolean overwrite, File outputDirectory)
			throws IOException {
		ZipEntry entry = zipStream.getNextEntry();
		String canonicalOutputPath = outputDirectory.getCanonicalPath() + File.separator;
		while (entry != null) {
			File file = new File(outputDirectory, entry.getName());
			String canonicalEntryPath = file.getCanonicalPath();
			if (!canonicalEntryPath.startsWith(canonicalOutputPath)) {
				throw new ReportableException('Entry "' + entry.getName() + '" would be written to "'
						+ canonicalEntryPath + '". This is outside the output location of "' + canonicalOutputPath
						+ '". Verify your target server configuration.');
			}
			if (file.exists() && !overwrite) {
				throw new ReportableException((file.isDirectory() ? 'Directory' : 'File') + ' "' + file.getName()
						+ '" already exists. Use --force if you want to overwrite or '
						+ 'specify an alternate location.');
			}
			if (!entry.isDirectory()) {
				FileCopyUtils.copy(StreamUtils.nonClosing(zipStream), new FileOutputStream(file));
			}
			else {
				file.mkdir();
			}
			zipStream.closeEntry();
			entry = zipStream.getNextEntry();
		}
	}
	private void writeProject(ProjectGenerationResponse entity, String output, boolean overwrite) throws IOException {
		File outputFile = new File(output);
		if (outputFile.exists()) {
			if (!overwrite) {
				throw new ReportableException(
						'File "' + outputFile.getName() + '" already exists. Use --force if you want to '
								+ 'overwrite or specify an alternate location.');
			}
			if (!outputFile.delete()) {
				throw new ReportableException('Failed to delete existing file ' + outputFile.getPath());
			}
		}
		FileCopyUtils.copy(entity.getContent(), outputFile);
		Log.info('Content saved to "' + output + '"');
	}
	private void fixExecutableFlag(File dir, String fileName) {
		File f = new File(dir, fileName);
		if (f.exists()) {
			f.setExecutable(true, false);
		}
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
public class ReportableException extends RuntimeException {
	public ReportableException(String message) {
		super(message);
	}
	public ReportableException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
final class Dependency {
	private final String id;
	private final String name;
	private final String description;
	Dependency(String id, String name, String description) {
		this.id = id;
		this.name = name;
		this.description = description;
	}
	String getId() {
		return this.id;
	}
	String getName() {
		return this.name;
	}
	String getDescription() {
		return this.description;
	}
}
/*
/**
package org.springframework.boot.cli.command.init;
/*
package org.springframework.boot.cli.command.init;
/**
class ProjectGenerationRequest {
	public static final String DEFAULT_SERVICE_URL = 'https://start.spring.io';
	private String serviceUrl = DEFAULT_SERVICE_URL;
	private String output;
	private boolean extract;
	private String groupId;
	private String artifactId;
	private String version;
	private String name;
	private String description;
	private String packageName;
	private String type;
	private String packaging;
	private String build;
	private String format;
	private boolean detectType;
	private String javaVersion;
	private String language;
	private String bootVersion;
	private final List<String> dependencies = new ArrayList<>();
	/**
	 * The URL of the service to use.
	 * @return the service URL
	 * @see #DEFAULT_SERVICE_URL
	 */
	String getServiceUrl() {
		return this.serviceUrl;
	}
	void setServiceUrl(String serviceUrl) {
		this.serviceUrl = serviceUrl;
	}
	/**
	 * The location of the generated project.
	 * @return the location of the generated project
	 */
	String getOutput() {
		return this.output;
	}
	void setOutput(String output) {
		if (output != null && output.endsWith('/')) {
			this.output = output.substring(0, output.length() - 1);
			this.extract = true;
		}
		else {
			this.output = output;
		}
	}
	/**
	 * Whether the project archive should be extracted in the output location. If the
	 * {@link #getOutput() output} ends with '/', the project is extracted automatically.
	 * @return {@code true} if the archive should be extracted, otherwise {@code false}
	 */
	boolean isExtract() {
		return this.extract;
	}
	void setExtract(boolean extract) {
		this.extract = extract;
	}
	/**
	 * The groupId to use or {@code null} if it should not be customized.
	 * @return the groupId or {@code null}
	 */
	String getGroupId() {
		return this.groupId;
	}
	void setGroupId(String groupId) {
		this.groupId = groupId;
	}
	/**
	 * The artifactId to use or {@code null} if it should not be customized.
	 * @return the artifactId or {@code null}
	 */
	String getArtifactId() {
		return this.artifactId;
	}
	void setArtifactId(String artifactId) {
		this.artifactId = artifactId;
	}
	/**
	 * The artifact version to use or {@code null} if it should not be customized.
	 * @return the artifact version or {@code null}
	 */
	String getVersion() {
		return this.version;
	}
	void setVersion(String version) {
		this.version = version;
	}
	/**
	 * The name to use or {@code null} if it should not be customized.
	 * @return the name or {@code null}
	 */
	String getName() {
		return this.name;
	}
	void setName(String name) {
		this.name = name;
	}
	/**
	 * The description to use or {@code null} if it should not be customized.
	 * @return the description or {@code null}
	 */
	String getDescription() {
		return this.description;
	}
	void setDescription(String description) {
		this.description = description;
	}
	/**
	 * Return the package name or {@code null} if it should not be customized.
	 * @return the package name or {@code null}
	 */
	String getPackageName() {
		return this.packageName;
	}
	void setPackageName(String packageName) {
		this.packageName = packageName;
	}
	/**
	 * The type of project to generate. Should match one of the advertised type that the
	 * service supports. If not set, the default is retrieved from the service metadata.
	 * @return the project type
	 */
	String getType() {
		return this.type;
	}
	void setType(String type) {
		this.type = type;
	}
	/**
	 * The packaging type or {@code null} if it should not be customized.
	 * @return the packaging type or {@code null}
	 */
	String getPackaging() {
		return this.packaging;
	}
	void setPackaging(String packaging) {
		this.packaging = packaging;
	}
	/**
	 * The build type to use. Ignored if a type is set. Can be used alongside the
	 * {@link #getFormat() format} to identify the type to use.
	 * @return the build type
	 */
	String getBuild() {
		return this.build;
	}
	void setBuild(String build) {
		this.build = build;
	}
	/**
	 * The project format to use. Ignored if a type is set. Can be used alongside the
	 * {@link #getBuild() build} to identify the type to use.
	 * @return the project format
	 */
	String getFormat() {
		return this.format;
	}
	void setFormat(String format) {
		this.format = format;
	}
	/**
	 * Whether the type should be detected based on the build and format value.
	 * @return {@code true} if type detection will be performed, otherwise {@code false}
	 */
	boolean isDetectType() {
		return this.detectType;
	}
	void setDetectType(boolean detectType) {
		this.detectType = detectType;
	}
	/**
	 * The Java version to use or {@code null} if it should not be customized.
	 * @return the Java version or {@code null}
	 */
	String getJavaVersion() {
		return this.javaVersion;
	}
	void setJavaVersion(String javaVersion) {
		this.javaVersion = javaVersion;
	}
	/**
	 * The programming language to use or {@code null} if it should not be customized.
	 * @return the programming language or {@code null}
	 */
	String getLanguage() {
		return this.language;
	}
	void setLanguage(String language) {
		this.language = language;
	}
	/**
	 * The Spring Boot version to use or {@code null} if it should not be customized.
	 * @return the Spring Boot version or {@code null}
	 */
	String getBootVersion() {
		return this.bootVersion;
	}
	void setBootVersion(String bootVersion) {
		this.bootVersion = bootVersion;
	}
	/**
	 * The identifiers of the dependencies to include in the project.
	 * @return the dependency identifiers
	 */
	List<String> getDependencies() {
		return this.dependencies;
	}
	/**
	 * Generates the URI to use to generate a project represented by this request.
	 * @param metadata the metadata that describes the service
	 * @return the project generation URI
	 */
	URI generateUrl(InitializrServiceMetadata metadata) {
		try {
			URIBuilder builder = new URIBuilder(this.serviceUrl);
			StringBuilder sb = new StringBuilder();
			if (builder.getPath() != null) {
				sb.append(builder.getPath());
			}
			ProjectType projectType = determineProjectType(metadata);
			this.type = projectType.getId();
			sb.append(projectType.getAction());
			builder.setPath(sb.toString());
			if (!this.dependencies.isEmpty()) {
				builder.setParameter('dependencies', StringUtils.collectionToCommaDelimitedString(this.dependencies));
			}
			if (this.groupId != null) {
				builder.setParameter('groupId', this.groupId);
			}
			String resolvedArtifactId = resolveArtifactId();
			if (resolvedArtifactId != null) {
				builder.setParameter('artifactId', resolvedArtifactId);
			}
			if (this.version != null) {
				builder.setParameter('version', this.version);
			}
			if (this.name != null) {
				builder.setParameter('name', this.name);
			}
			if (this.description != null) {
				builder.setParameter('description', this.description);
			}
			if (this.packageName != null) {
				builder.setParameter('packageName', this.packageName);
			}
			if (this.type != null) {
				builder.setParameter('type', projectType.getId());
			}
			if (this.packaging != null) {
				builder.setParameter('packaging', this.packaging);
			}
			if (this.javaVersion != null) {
				builder.setParameter('javaVersion', this.javaVersion);
			}
			if (this.language != null) {
				builder.setParameter('language', this.language);
			}
			if (this.bootVersion != null) {
				builder.setParameter('bootVersion', this.bootVersion);
			}
			return builder.build();
		}
		catch (URISyntaxException ex) {
			throw new ReportableException('Invalid service URL (' + ex.getMessage() + ')');
		}
	}
	protected ProjectType determineProjectType(InitializrServiceMetadata metadata) {
		if (this.type != null) {
			ProjectType result = metadata.getProjectTypes().get(this.type);
			if (result == null) {
				throw new ReportableException(
						('No project type with id "' + this.type + '" - check the service capabilities (--list)'));
			}
			return result;
		}
		else if (isDetectType()) {
			Map<String, ProjectType> types = new HashMap<>(metadata.getProjectTypes());
			if (this.build != null) {
				filter(types, 'build', this.build);
			}
			if (this.format != null) {
				filter(types, 'format', this.format);
			}
			if (types.size() == 1) {
				return types.values().iterator().next();
			}
			else if (types.isEmpty()) {
				throw new ReportableException('No type found with build "' + this.build + '" and format "' + this.format
						+ '" check the service capabilities (--list)');
			}
			else {
				throw new ReportableException('Multiple types found with build "' + this.build + '" and format "'
						+ this.format + '" use --type with a more specific value ' + types.keySet());
			}
		}
		else {
			ProjectType defaultType = metadata.getDefaultType();
			if (defaultType == null) {
				throw new ReportableException(('No project type is set and no default is defined. '
						+ 'Check the service capabilities (--list)'));
			}
			return defaultType;
		}
	}
	/**
	 * Resolve the artifactId to use or {@code null} if it should not be customized.
	 * @return the artifactId
	 */
	protected String resolveArtifactId() {
		if (this.artifactId != null) {
			return this.artifactId;
		}
		if (this.output != null) {
			int i = this.output.lastIndexOf(".");
			return (i != -1) ? this.output.substring(0, i) : this.output;
		}
		return null;
	}
	private static void filter(Map<String, ProjectType> projects, String tag, String tagValue) {
		projects.entrySet().removeIf((entry) -> !tagValue.equals(entry.getValue().getTags().get(tag)));
	}
}
/*
package org.springframework.boot.cli.command.init;
/**
class ProjectGenerationResponse {
	private final ContentType contentType;
	private byte[] content;
	private String fileName;
	ProjectGenerationResponse(ContentType contentType) {
		this.contentType = contentType;
	}
	/**
	 * Return the {@link ContentType} of this instance.
	 * @return the content type
	 */
	ContentType getContentType() {
		return this.contentType;
	}
	/**
	 * The generated project archive or file.
	 * @return the content
	 */
	byte[] getContent() {
		return this.content;
	}
	void setContent(byte[] content) {
		this.content = content;
	}
	/**
	 * The preferred file name to use to store the entity on disk or {@code null} if no
	 * preferred value has been set.
	 * @return the file name, or {@code null}
	 */
	String getFileName() {
		return this.fileName;
	}
	void setFileName(String fileName) {
		this.fileName = fileName;
	}
}
/*
package org.springframework.boot.cli.command;
/**
@FunctionalInterface
public interface CommandFactory {
	/**
	 * Returns the CLI {@link Command}s.
	 * @return the commands
	 */
	Collection<Command> getCommands();
}
/*
package org.springframework.boot.cli.command;
/**
public class NoSuchCommandException extends CommandException {
	private static final long serialVersionUID = 1L;
	public NoSuchCommandException(String name) {
		super(String.format('"%1$s" is not a valid command. See "help".', name));
	}
}
/*
package org.springframework.boot.cli.command.status;
/**
public final class ExitStatus {
	/**
	 * Generic 'OK' exit status with zero exit code and {@literal hangup=false}.
	 */
	public static final ExitStatus OK = new ExitStatus(0, 'OK');
	/**
	 * Generic 'not OK' exit status with non-zero exit code and {@literal hangup=true}.
	 */
	public static final ExitStatus ERROR = new ExitStatus(-1, 'ERROR', true);
	private final int code;
	private final String name;
	private final boolean hangup;
	/**
	 * Create a new {@link ExitStatus} instance.
	 * @param code the exit code
	 * @param name the name
	 */
	public ExitStatus(int code, String name) {
		this(code, name, false);
	}
	/**
	 * Create a new {@link ExitStatus} instance.
	 * @param code the exit code
	 * @param name the name
	 * @param hangup true if it is OK for the caller to hangup
	 */
	public ExitStatus(int code, String name, boolean hangup) {
		this.code = code;
		this.name = name;
		this.hangup = hangup;
	}
	/**
	 * An exit code appropriate for use in {@code System.exit()}.
	 * @return an exit code
	 */
	public int getCode() {
		return this.code;
	}
	/**
	 * A name describing the outcome.
	 * @return a name
	 */
	public String getName() {
		return this.name;
	}
	/**
	 * Flag to signal that the caller can (or should) hangup. A server process with
	 * non-daemon threads should set this to false.
	 * @return the flag
	 */
	public boolean isHangup() {
		return this.hangup;
	}
	/**
	 * Convert the existing code to a hangup.
	 * @return a new ExitStatus with hangup=true
	 */
	public ExitStatus hangup() {
		return new ExitStatus(this.code, this.name, true);
	}
	@Override
	public String toString() {
		return getName() + ':' + getCode();
	}
}
/*
/**
package org.springframework.boot.cli.command.status;
/*
package org.springframework.boot.cli.command.core;
/**
public class HelpCommand extends AbstractCommand {
	private final CommandRunner commandRunner;
	public HelpCommand(CommandRunner commandRunner) {
		super('help', 'Get help on commands');
		this.commandRunner = commandRunner;
	}
	@Override
	public String getUsageHelp() {
		return 'command';
	}
	@Override
	public String getHelp() {
		return null;
	}
	@Override
	public Collection<OptionHelp> getOptionsHelp() {
		List<OptionHelp> help = new ArrayList<>();
		for (Command command : this.commandRunner) {
			if (isHelpShown(command)) {
				help.add(new OptionHelp() {
					@Override
					public Set<String> getOptions() {
						return Collections.singleton(command.getName());
					}
					@Override
					public String getUsageHelp() {
						return command.getDescription();
					}
				});
			}
		}
		return help;
	}
	private boolean isHelpShown(Command command) {
		return !(command instanceof HelpCommand) && !(command instanceof HintCommand);
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		if (args.length == 0) {
			throw new NoHelpCommandArgumentsException();
		}
		String commandName = args[0];
		for (Command command : this.commandRunner) {
			if (command.getName().equals(commandName)) {
				Log.info(this.commandRunner.getName() + command.getName() + ' - ' + command.getDescription());
				Log.info('');
				if (command.getUsageHelp() != null) {
					Log.info('usage: ' + this.commandRunner.getName() + command.getName() + ' '
							+ command.getUsageHelp());
					Log.info('');
				}
				if (command.getHelp() != null) {
					Log.info(command.getHelp());
				}
				Collection<HelpExample> examples = command.getExamples();
				if (examples != null) {
					Log.info((examples.size() != 1) ? 'examples:' : 'example:');
					Log.info('');
					for (HelpExample example : examples) {
						Log.info('    ' + example.getDescription() + ':');
						Log.info('        $ ' + example.getExample());
						Log.info('');
					}
					Log.info('');
				}
				return ExitStatus.OK;
			}
		}
		throw new NoSuchCommandException(commandName);
	}
}
/*
package org.springframework.boot.cli.command.core;
/**
public class VersionCommand extends AbstractCommand {
	public VersionCommand() {
		super('version', 'Show the version');
	}
	@Override
	public ExitStatus run(String... args) {
		Log.info('Spring CLI v' + getClass().getPackage().getImplementationVersion());
		return ExitStatus.OK;
	}
}
/*
package org.springframework.boot.cli.command.core;
/**
public class HintCommand extends AbstractCommand {
	private final CommandRunner commandRunner;
	public HintCommand(CommandRunner commandRunner) {
		super('hint', 'Provides hints for shell auto-completion');
		this.commandRunner = commandRunner;
	}
	@Override
	public ExitStatus run(String... args) throws Exception {
		try {
			int index = (args.length != 0) ? Integer.parseInt(args[0]) - 1 : 0;
			List<String> arguments = new ArrayList<>(args.length);
			for (int i = 2; i < args.length; i++) {
				arguments.add(args[i]);
			}
			String starting = '';
			if (index < arguments.size()) {
				starting = arguments.remove(index);
			}
			if (index == 0) {
				showCommandHints(starting);
			}
			else if (!arguments.isEmpty() && !starting.isEmpty()) {
				String command = arguments.remove(0);
				showCommandOptionHints(command, Collections.unmodifiableList(arguments), starting);
			}
		}
		catch (Exception ex) {
			// Swallow and provide no hints
			return ExitStatus.ERROR;
		}
		return ExitStatus.OK;
	}
	private void showCommandHints(String starting) {
		for (Command command : this.commandRunner) {
			if (isHintMatch(command, starting)) {
				Log.info(command.getName() + ' ' + command.getDescription());
			}
		}
	}
	private boolean isHintMatch(Command command, String starting) {
		if (command instanceof HintCommand) {
			return false;
		}
		return command.getName().startsWith(starting)
				|| (this.commandRunner.isOptionCommand(command) && ('--' + command.getName()).startsWith(starting));
	}
	private void showCommandOptionHints(String commandName, List<String> specifiedArguments, String starting) {
		Command command = this.commandRunner.findCommand(commandName);
		if (command != null) {
			for (OptionHelp help : command.getOptionsHelp()) {
				if (!alreadyUsed(help, specifiedArguments)) {
					for (String option : help.getOptions()) {
						if (option.startsWith(starting)) {
							Log.info(option + ' ' + help.getUsageHelp());
						}
					}
				}
			}
		}
	}
	private boolean alreadyUsed(OptionHelp help, List<String> specifiedArguments) {
		for (String argument : specifiedArguments) {
			if (help.getOptions().contains(argument)) {
				return true;
			}
		}
		return false;
	}
}
/*
/**
package org.springframework.boot.cli.command.core;
/*
package org.springframework.boot.cli.util;
/**
public abstract class Log {
	private static LogListener listener;
	public static void info(String message) {
		System.out.println(message);
		if (listener != null) {
			listener.info(message);
		}
	}
	public static void infoPrint(String message) {
		System.out.print(message);
		if (listener != null) {
			listener.infoPrint(message);
		}
	}
	public static void error(String message) {
		System.err.println(message);
		if (listener != null) {
			listener.error(message);
		}
	}
	public static void error(Exception ex) {
		ex.printStackTrace(System.err);
		if (listener != null) {
			listener.error(ex);
		}
	}
	static void setListener(LogListener listener) {
		Log.listener = listener;
	}
}
/*
package org.springframework.boot.cli.util;
/**
interface LogListener {
	void info(String message);
	void infoPrint(String message);
	void error(String message);
	void error(Exception ex);
}
/*
/**
package org.springframework.boot.cli.util;
/*
/**
package org.springframework.boot.cli;
/*
package org.springframework.boot.cli.infrastructure;
/**
final class Versions {
	private Versions() {
	}
	static String getBootVersion() {
		Properties gradleProperties = new Properties();
		try (FileInputStream input = new FileInputStream('../../../gradle.properties')) {
			gradleProperties.load(input);
			return gradleProperties.getProperty('version');
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
}
/*
package org.springframework.boot.cli.infrastructure;
/**
public final class CommandLineInvoker {
	private final File workingDirectory;
	private final File temp;
	public CommandLineInvoker(File temp) {
		this(new File('.'), temp);
	}
	public CommandLineInvoker(File workingDirectory, File temp) {
		this.workingDirectory = workingDirectory;
		this.temp = temp;
	}
	public Invocation invoke(String... args) throws IOException {
		return new Invocation(runCliProcess(args));
	}
	private Process runCliProcess(String... args) throws IOException {
		Path m2 = this.temp.toPath().resolve('.m2');
		Files.createDirectories(m2);
		Files.copy(Paths.get('src', 'intTest', 'resources', 'settings.xml'), m2.resolve('settings.xml'),
				StandardCopyOption.REPLACE_EXISTING);
		List<String> command = new ArrayList<>();
		command.add(findLaunchScript().getAbsolutePath());
		command.addAll(Arrays.asList(args));
		ProcessBuilder processBuilder = new ProcessBuilder(command).directory(this.workingDirectory);
		processBuilder.environment().put('JAVA_OPTS', '-Duser.home=' + this.temp);
		processBuilder.environment().put('JAVA_HOME', System.getProperty('java.home'));
		return processBuilder.start();
	}
	private File findLaunchScript() throws IOException {
		File unpacked = new File(this.temp, 'unpacked-cli');
		if (!unpacked.isDirectory()) {
			File zip = new File(new BuildOutput(getClass()).getRootLocation(),
					'distributions/spring-boot-cli-' + Versions.getBootVersion() + '-bin.zip');
			try (ZipInputStream input = new ZipInputStream(new FileInputStream(zip))) {
				ZipEntry entry;
				while ((entry = input.getNextEntry()) != null) {
					File file = new File(unpacked, entry.getName());
					if (entry.isDirectory()) {
						file.mkdirs();
					}
					else {
						file.getParentFile().mkdirs();
						try (FileOutputStream output = new FileOutputStream(file)) {
							StreamUtils.copy(input, output);
							if (entry.getName().endsWith('/bin/spring')) {
								file.setExecutable(true);
							}
						}
					}
				}
			}
		}
		File bin = new File(unpacked.listFiles()[0], 'bin');
		File launchScript = new File(bin, isWindows() ? 'spring.bat' : 'spring');
		Assert.state(launchScript.exists() && launchScript.isFile(),
				() -> 'Could not find CLI launch script ' + launchScript.getAbsolutePath());
		return launchScript;
	}
	private boolean isWindows() {
		return File.separatorChar == "\\";
	}
	/**
	 * An ongoing Process invocation.
	 */
	public static final class Invocation {
		private final StringBuffer err = new StringBuffer();
		private final StringBuffer out = new StringBuffer();
		private final StringBuffer combined = new StringBuffer();
		private final Process process;
		private final List<Thread> streamReaders = new ArrayList<>();
		public Invocation(Process process) {
			this.process = process;
			this.streamReaders
				.add(new Thread(new StreamReadingRunnable(this.process.getErrorStream(), this.err, this.combined)));
			this.streamReaders
				.add(new Thread(new StreamReadingRunnable(this.process.getInputStream(), this.out, this.combined)));
			for (Thread streamReader : this.streamReaders) {
				streamReader.start();
			}
		}
		public String getOutput() {
			return postProcessLines(getLines(this.combined));
		}
		public String getErrorOutput() {
			return postProcessLines(getLines(this.err));
		}
		public String getStandardOutput() {
			return postProcessLines(getStandardOutputLines());
		}
		public List<String> getStandardOutputLines() {
			return getLines(this.out);
		}
		private String postProcessLines(List<String> lines) {
			StringWriter out = new StringWriter();
			PrintWriter printOut = new PrintWriter(out);
			for (String line : lines) {
				if (!line.startsWith('Maven settings decryption failed')) {
					printOut.println(line);
				}
			}
			return out.toString();
		}
		private List<String> getLines(StringBuffer buffer) {
			BufferedReader reader = new BufferedReader(new StringReader(buffer.toString()));
			return reader.lines().filter((line) -> !line.startsWith('Picked up ')).toList();
		}
		public int await() throws InterruptedException {
			for (Thread streamReader : this.streamReaders) {
				streamReader.join();
			}
			return this.process.waitFor();
		}
		/**
		 * {@link Runnable} to copy stream output.
		 */
		private final class StreamReadingRunnable implements Runnable {
			private final InputStream stream;
			private final StringBuffer[] outputs;
			private final byte[] buffer = new byte[4096];
			private StreamReadingRunnable(InputStream stream, StringBuffer... outputs) {
				this.stream = stream;
				this.outputs = outputs;
			}
			@Override
			public void run() {
				int read;
				try {
					while ((read = this.stream.read(this.buffer)) > 0) {
						for (StringBuffer output : this.outputs) {
							output.append(new String(this.buffer, 0, read));
						}
					}
				}
				catch (IOException ex) {
					// Allow thread to die
				}
			}
		}
	}
}
/*
package org.springframework.boot.cli;
/**
class CommandLineIT {
	private CommandLineInvoker cli;
	@BeforeEach
	void setup(@TempDir File tempDir) {
		this.cli = new CommandLineInvoker(tempDir);
	}
	@Test
	void hintProducesListOfValidCommands() throws IOException, InterruptedException {
		Invocation cli = this.cli.invoke('hint');
		assertThat(cli.await()).isEqualTo(0);
		assertThat(cli.getErrorOutput()).isEmpty();
		assertThat(cli.getStandardOutputLines()).hasSize(5);
	}
	@Test
	void invokingWithNoArgumentsDisplaysHelp() throws IOException, InterruptedException {
		Invocation cli = this.cli.invoke();
		assertThat(cli.await()).isEqualTo(1);
		assertThat(cli.getErrorOutput()).isEmpty();
		assertThat(cli.getStandardOutput()).startsWith('usage:');
	}
	@Test
	void unrecognizedCommandsAreHandledGracefully() throws IOException, InterruptedException {
		Invocation cli = this.cli.invoke('not-a-real-command');
		assertThat(cli.await()).isEqualTo(1);
		assertThat(cli.getErrorOutput()).contains('"not-a-real-command" is not a valid command');
		assertThat(cli.getStandardOutput()).isEmpty();
	}
	@Test
	void version() throws IOException, InterruptedException {
		Invocation cli = this.cli.invoke('version');
		assertThat(cli.await()).isEqualTo(0);
		assertThat(cli.getErrorOutput()).isEmpty();
		assertThat(cli.getStandardOutput()).startsWith('Spring CLI v');
	}
	@Test
	void help() throws IOException, InterruptedException {
		Invocation cli = this.cli.invoke('help');
		assertThat(cli.await()).isEqualTo(1);
		assertThat(cli.getErrorOutput()).isEmpty();
		assertThat(cli.getStandardOutput()).startsWith('usage:');
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ExtendWith(DisabledIfDockerUnavailableCondition.class)
public @interface DisabledIfDockerUnavailable {
}
/*
package org.springframework.boot.testsupport.container;
/**
public enum TestImage {
	/**
	 * A container image suitable for testing ActiveMQ.
	 */
	ACTIVE_MQ('symptoma/activemq', '5.18.3', () -> SymptomaActiveMQContainer.class),
	/**
	 * A container image suitable for testing ActiveMQ classic.
	 */
	ACTIVE_MQ_CLASSIC('apache/activemq-classic', '5.18.3', () -> ActiveMQContainer.class),
	/**
	 * A container image suitable for testing Apache Kafka.
	 */
	APACHE_KAFKA('apache/kafka', '3.7.0', () -> org.testcontainers.kafka.KafkaContainer.class),
	/**
	 * A container image suitable for testing Artemis.
	 */
	ARTEMIS('apache/activemq-artemis', '2.34.0', () -> ArtemisContainer.class),
	/**
	 * A container image suitable for testing Cassandra.
	 */
	CASSANDRA('cassandra', '3.11.10', () -> CassandraContainer.class,
			(container) -> ((CassandraContainer) container).withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing Cassandra using the deprecated
	 * {@link org.testcontainers.containers.CassandraContainer}.
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of {@link #CASSANDRA}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	CASSANDRA_DEPRECATED('cassandra', '3.11.10', () -> org.testcontainers.containers.CassandraContainer.class,
			(container) -> ((org.testcontainers.containers.CassandraContainer<?>) container)
				.withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing ClickHouse.
	 */
	CLICKHOUSE('clickhouse/clickhouse-server', '24.3'),
	/**
	 * A container image suitable for testing Couchbase.
	 */
	COUCHBASE('couchbase/server', '7.1.4', () -> CouchbaseContainer.class,
			(container) -> ((CouchbaseContainer) container).withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing Elasticsearch 7.
	 */
	ELASTICSEARCH('docker.elastic.co/elasticsearch/elasticsearch', '7.17.5', () -> ElasticsearchContainer.class,
			(container) -> ((ElasticsearchContainer) container).withEnv('ES_JAVA_OPTS', '-Xms32m -Xmx512m')
				.withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing Elasticsearch 8.
	 */
	ELASTICSEARCH_8('elasticsearch', '8.6.1'),
	/**
	 * A container image suitable for testing Grafana OTel LGTM.
	 */
	GRAFANA_OTEL_LGTM('grafana/otel-lgtm', '0.6.0', () -> LgtmStackContainer.class,
			(container) -> ((LgtmStackContainer) container).withStartupTimeout(Duration.ofMinutes(2))),
	/**
	 * A container image suitable for testing Hazelcast.
	 */
	HAZELCAST('hazelcast/hazelcast', '5.5.0-slim', () -> HazelcastContainer.class),
	/**
	 * A container image suitable for testing Confluent"s distribution of Kafka.
	 */
	CONFLUENT_KAFKA('confluentinc/cp-kafka', '7.4.0', () -> ConfluentKafkaContainer.class),
	/**
	 * A container image suitable for testing Confluent"s distribution of Kafka using the
	 * deprecated {@link org.testcontainers.containers.KafkaContainer}.
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of {@link #CONFLUENT_KAFKA}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	CONFLUENT_KAFKA_DEPRECATED('confluentinc/cp-kafka', '7.4.0',
			() -> org.testcontainers.containers.KafkaContainer.class),
	/**
	 * A container image suitable for testing OpenLDAP.
	 */
	OPEN_LDAP('osixia/openldap', '1.5.0', () -> OpenLdapContainer.class),
	/**
	 * A container image suitable for testing SMTP.
	 */
	MAILPIT('axllent/mailpit', 'v1.19.0', () -> MailpitContainer.class),
	/**
	 * A container image suitable for testing MariaDB.
	 */
	MARIADB('mariadb', '10.10'),
	/**
	 * A container image suitable for testing MongoDB.
	 */
	MONGODB('mongo', '5.0.17', () -> MongoDBContainer.class,
			(container) -> ((MongoDBContainer) container).withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(5))),
	/**
	 * A container image suitable for testing MySQL.
	 */
	MYSQL('mysql', '8.0'),
	/**
	 * A container image suitable for testing Neo4j.
	 */
	NEO4J('neo4j', '4.4.11', () -> Neo4jContainer.class,
			(container) -> ((Neo4jContainer<?>) container).withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing Oracle Free.
	 */
	ORACLE_FREE('gvenzl/oracle-free', '23.3-slim', () -> org.testcontainers.oracle.OracleContainer.class,
			(container) -> ((org.testcontainers.oracle.OracleContainer) container)
				.withStartupTimeout(Duration.ofMinutes(2))),
	/**
	 * A container image suitable for testing Oracle XA.
	 */
	ORACLE_XE('gvenzl/oracle-xe', '18.4.0-slim', () -> org.testcontainers.containers.OracleContainer.class,
			(container) -> ((org.testcontainers.containers.OracleContainer) container)
				.withStartupTimeout(Duration.ofMinutes(2))),
	/**
	 * A container image suitable for testing Opentelemetry.
	 */
	OPENTELEMETRY('otel/opentelemetry-collector-contrib', '0.75.0'),
	/**
	 * A container image suitable for testing Postgres.
	 */
	POSTGRESQL('postgres', '14.0', () -> PostgreSQLContainer.class),
	/**
	 * A container image suitable for testing Pulsar.
	 */
	PULSAR('apachepulsar/pulsar', '3.2.4', () -> PulsarContainer.class,
			(container) -> ((PulsarContainer) container).withStartupAttempts(2)
				.withStartupTimeout(Duration.ofMinutes(3))),
	/**
	 * A container image suitable for testing RabbitMQ.
	 */
	RABBITMQ('rabbitmq', '3.11-alpine', () -> RabbitMQContainer.class,
			(container) -> ((RabbitMQContainer) container).withStartupTimeout(Duration.ofMinutes(4))),
	/**
	 * A container image suitable for testing Redis.
	 */
	REDIS('redis', '7.0.11', () -> RedisContainer.class,
			(container) -> ((RedisContainer) container).withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing Redis Stack.
	 */
	REDIS_STACK('redis/redis-stack', '7.2.0-v11', () -> RedisStackContainer.class,
			(container) -> ((RedisStackContainer) container).withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing Redis Stack Server.
	 */
	REDIS_STACK_SERVER('redis/redis-stack-server', '7.2.0-v11', () -> RedisStackServerContainer.class,
			(container) -> ((RedisStackServerContainer) container).withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(10))),
	/**
	 * A container image suitable for testing Redpanda.
	 */
	REDPANDA('redpandadata/redpanda', 'v23.1.2', () -> RedpandaContainer.class,
			(container) -> ((RedpandaContainer) container).withStartupTimeout(Duration.ofMinutes(5))),
	/**
	 * A container image suitable for testing Docker Registry.
	 */
	REGISTRY('registry', '2.7.1', () -> RegistryContainer.class,
			(container) -> ((RegistryContainer) container).withStartupAttempts(5)
				.withStartupTimeout(Duration.ofMinutes(3))),
	/**
	 * A container image suitable for testing MS SQL Server.
	 */
	SQL_SERVER('mcr.microsoft.com/mssql/server'),
	/**
	 * A container image suitable for testing Zipkin.
	 */
	ZIPKIN('openzipkin/zipkin', '3.0.6', () -> ZipkinContainer.class),
	/**
	 * A container image suitable for testing Cassandra via Bitnami.
	 */
	BITNAMI_CASSANDRA('bitnami/cassandra', '4.1.3'),
	/**
	 * A container image suitable for testing ClickHouse via Bitnami.
	 */
	BITNAMI_CLICKHOUSE('bitnami/clickhouse', '24.3'),
	/**
	 * A container image suitable for testing Elasticsearch via Bitnami.
	 */
	BITNAMI_ELASTICSEARCH('bitnami/elasticsearch', '8.12.1'),
	/**
	 * A container image suitable for testing MariaDB via Bitnami.
	 */
	BITNAMI_MARIADB('bitnami/mariadb', '11.2.3'),
	/**
	 * A container image suitable for testing MongoDB via Bitnami.
	 */
	BITNAMI_MONGODB('bitnami/mongodb', '7.0.5'),
	/**
	 * A container image suitable for testing MySQL via Bitnami.
	 */
	BITNAMI_MYSQL('bitnami/mysql', '8.0.36'),
	/**
	 * A container image suitable for testing Neo4j via Bitnami.
	 */
	BITNAMI_NEO4J('bitnami/neo4j', '5.16.0'),
	/**
	 * A container image suitable for testing Postgres via Bitnami.
	 */
	BITNAMI_POSTGRESQL('bitnami/postgresql', '16.2.0'),
	/**
	 * A container image suitable for testing RabbitMQ via Bitnami.
	 */
	BITNAMI_RABBITMQ('bitnami/rabbitmq', '3.11.28'),
	/**
	 * A container image suitable for testing Redis via Bitnami.
	 */
	BITNAMI_REDIS('bitnami/redis', '7.2.4');
	private final String name;
	private final String tag;
	private final Class<?> containerClass;
	private final Consumer<?> containerSetup;
	TestImage(String name) {
		this(name, null);
	}
	TestImage(String name, String tag) {
		this(name, tag, null, null);
	}
	TestImage(String name, String tag, Supplier<Class<?>> containerClass) {
		this(name, tag, containerClass, null);
	}
	TestImage(String name, String tag, Consumer<?> containerSetup) {
		this(name, tag, null, containerSetup);
	}
	TestImage(String name, String tag, Supplier<Class<?>> containerClass, Consumer<?> containerSetup) {
		this.name = name;
		this.tag = tag;
		this.containerClass = getIfPossible(containerClass);
		this.containerSetup = containerSetup;
	}
	static Class<?> getIfPossible(Supplier<Class<?>> supplier) {
		try {
			return (supplier != null) ? supplier.get() : null;
		}
		catch (NoClassDefFoundError ex) {
			return null;
		}
	}
	private boolean matchesContainerClass(Class<?> containerClass) {
		return this.containerClass != null && this.containerClass.isAssignableFrom(containerClass);
	}
	/**
	 * Create a {@link GenericContainer} for the given {@link TestImage}.
	 * @return a generic container for the test image
	 */
	public GenericContainer<?> genericContainer() {
		return createContainer(GenericContainer.class);
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private <C extends Container<?>> C createContainer(Class<C> containerClass) {
		DockerImageName dockerImageName = DockerImageName.parse(toString());
		try {
			Constructor<C> constructor = containerClass.getDeclaredConstructor(DockerImageName.class);
			constructor.setAccessible(true);
			C container = constructor.newInstance(dockerImageName);
			if (this.containerSetup != null) {
				((Consumer) this.containerSetup).accept(container);
			}
			return container;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to create container ' + containerClass, ex);
		}
	}
	public String getTag() {
		return this.tag;
	}
	@Override
	public String toString() {
		return (this.tag != null) ? this.name + ':' + this.tag : this.name;
	}
	/**
	 * Factory method to create and configure a {@link Container} using a deduced
	 * {@link TestImage}.
	 * @param <C> the container type
	 * @param containerClass the container type
	 * @return a container instance
	 */
	public static <C extends Container<?>> C container(Class<C> containerClass) {
		return forContainerClass(containerClass).createContainer(containerClass);
	}
	private static TestImage forContainerClass(Class<?> containerClass) {
		List<TestImage> images = Arrays.stream(values())
			.filter((image) -> image.matchesContainerClass(containerClass))
			.toList();
		Assert.state(!images.isEmpty(), () -> 'Unknown container class ' + containerClass);
		Assert.state(images.size() == 1, () -> 'Multiple test images match container class ' + containerClass);
		return images.get(0);
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
public class OpenLdapContainer extends GenericContainer<OpenLdapContainer> {
	private static final int DEFAULT_LDAP_PORT = 389;
	public OpenLdapContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		addExposedPorts(DEFAULT_LDAP_PORT);
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
public class ZipkinContainer extends GenericContainer<ZipkinContainer> {
	public ZipkinContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		withExposedPorts(9411);
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
public class RedisStackServerContainer extends GenericContainer<RedisStackServerContainer> {
	public RedisStackServerContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		addExposedPorts(6379);
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
public final class HazelcastContainer extends GenericContainer<HazelcastContainer> {
	private static final int DEFAULT_PORT = 5701;
	public HazelcastContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		addExposedPorts(DEFAULT_PORT);
	}
	/**
	 * Sets the cluster name.
	 * @param clusterName the cluster name
	 * @return this instance
	 */
	public HazelcastContainer withClusterName(String clusterName) {
		return withEnv('HZ_CLUSTERNAME', clusterName);
	}
}
/*
/**
package org.springframework.boot.testsupport.container;
/*
package org.springframework.boot.testsupport.container;
/**
public final class SymptomaActiveMQContainer extends GenericContainer<SymptomaActiveMQContainer> {
	private static final int DEFAULT_PORT = 61616;
	public SymptomaActiveMQContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		addExposedPorts(DEFAULT_PORT);
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
public class RegistryContainer extends GenericContainer<RegistryContainer> {
	public RegistryContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		addExposedPorts(5000);
		addEnv('SERVER_NAME', 'localhost');
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
public class MailpitContainer extends GenericContainer<MailpitContainer> {
	private static final int DEFAULT_SMTP_PORT = 1025;
	private static final int DEFAULT_POP3_PORT = 1110;
	public MailpitContainer(DockerImageName dockerImageName) {
		super(dockerImageName);
		addExposedPorts(DEFAULT_SMTP_PORT, DEFAULT_POP3_PORT);
	}
	public int getSmtpPort() {
		return getMappedPort(DEFAULT_SMTP_PORT);
	}
	public int getPop3Port() {
		return getMappedPort(DEFAULT_POP3_PORT);
	}
	public MailpitContainer withSmtpTlsCert(MountableFile cert) {
		this.withCopyFileToContainer(cert, '/tmp/ssl/public.crt');
		this.withEnv('MP_SMTP_TLS_CERT', '/tmp/ssl/public.crt');
		return this.self();
	}
	public MailpitContainer withSmtpTlsKey(MountableFile key) {
		this.withCopyFileToContainer(key, '/tmp/ssl/private.key');
		this.withEnv('MP_SMTP_TLS_KEY', '/tmp/ssl/private.key');
		return this.self();
	}
	public MailpitContainer withSmtpRequireTls(boolean requireTls) {
		if (requireTls) {
			this.withEnv('MP_SMTP_REQUIRE_TLS', 'true');
		}
		return this.self();
	}
	public MailpitContainer withSmtpRequireStarttls(boolean requireStarttls) {
		if (requireStarttls) {
			this.withEnv('MP_SMTP_REQUIRE_STARTTLS', 'true');
		}
		return this.self();
	}
	public MailpitContainer withPop3Auth(String... auths) {
		this.withEnv('MP_POP3_AUTH', String.join(' ', auths));
		return this.self();
	}
}
/*
package org.springframework.boot.testsupport.container;
/**
class DisabledIfDockerUnavailableCondition implements ExecutionCondition {
	private static final String SILENCE_PROPERTY = 'visibleassertions.silence';
	private static final ConditionEvaluationResult ENABLED = ConditionEvaluationResult.enabled('Docker available');
	@Override
	public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {
		String originalSilenceValue = System.getProperty(SILENCE_PROPERTY);
		try {
			DockerClientFactory.instance().client();
			return ENABLED;
		}
		catch (Throwable ex) {
			return ConditionEvaluationResult.disabled('Docker unavailable', ex.getMessage());
		}
		finally {
			if (originalSilenceValue != null) {
				System.setProperty(SILENCE_PROPERTY, originalSilenceValue);
			}
			else {
				System.clearProperty(SILENCE_PROPERTY);
			}
		}
	}
}
/*
package org.springframework.boot.loader.jarmode;
/**
class TestJarMode implements JarMode {
	@Override
	public boolean accepts(String mode) {
		return 'test'.equals(mode);
	}
	@Override
	public void run(String mode, String[] args) {
		System.out.println('running in ' + mode + ' jar mode ' + Arrays.asList(args));
	}
}
/*
package org.springframework.boot.loader.testsupport;
/**
public abstract class TestJar {
	public static final int MULTI_JAR_VERSION = Runtime.version().feature();
	private static final int BASE_VERSION = 8;
	public static void create(File file) throws Exception {
		create(file, false);
	}
	public static void create(File file, boolean unpackNested) throws Exception {
		create(file, unpackNested, false);
	}
	public static void create(File file, boolean unpackNested, boolean addSignatureFile) throws Exception {
		FileOutputStream fileOutputStream = new FileOutputStream(file);
		try (JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream)) {
			jarOutputStream.setComment('outer');
			writeManifest(jarOutputStream, 'j1');
			if (addSignatureFile) {
				writeEntry(jarOutputStream, 'META-INF/some.DSA', 0);
			}
			writeEntry(jarOutputStream, '1.dat', 1);
			writeEntry(jarOutputStream, '2.dat', 2);
			writeDirEntry(jarOutputStream, 'd/');
			writeEntry(jarOutputStream, 'd/9.dat', 9);
			writeDirEntry(jarOutputStream, 'special/');
			writeEntry(jarOutputStream, 'special/\u00EB.dat', "\u00EB");
			writeNestedEntry('nested.jar', unpackNested, jarOutputStream);
			writeNestedEntry('another-nested.jar', unpackNested, jarOutputStream);
			writeNestedEntry('space nested.jar', unpackNested, jarOutputStream);
			writeNestedMultiReleaseEntry('multi-release.jar', unpackNested, jarOutputStream);
		}
	}
	public static List<String> expectedEntries() {
		return List.of('META-INF/', 'META-INF/MANIFEST.MF', '1.dat', '2.dat', 'd/', 'd/9.dat', 'special/',
				'special/\u00EB.dat', 'nested.jar', 'another-nested.jar', 'space nested.jar', 'multi-release.jar');
	}
	private static void writeNestedEntry(String name, boolean unpackNested, JarOutputStream jarOutputStream)
			throws Exception {
		writeNestedEntry(name, unpackNested, jarOutputStream, false);
	}
	private static void writeNestedMultiReleaseEntry(String name, boolean unpackNested, JarOutputStream jarOutputStream)
			throws Exception {
		writeNestedEntry(name, unpackNested, jarOutputStream, true);
	}
	private static void writeNestedEntry(String name, boolean unpackNested, JarOutputStream jarOutputStream,
			boolean multiRelease) throws Exception {
		JarEntry nestedEntry = new JarEntry(name);
		byte[] nestedJarData = getNestedJarData(multiRelease);
		nestedEntry.setSize(nestedJarData.length);
		nestedEntry.setCompressedSize(nestedJarData.length);
		if (unpackNested) {
			nestedEntry.setComment('UNPACK:0000000000000000000000000000000000000000');
		}
		CRC32 crc32 = new CRC32();
		crc32.update(nestedJarData);
		nestedEntry.setCrc(crc32.getValue());
		nestedEntry.setMethod(ZipEntry.STORED);
		jarOutputStream.putNextEntry(nestedEntry);
		jarOutputStream.write(nestedJarData);
		jarOutputStream.closeEntry();
	}
	private static byte[] getNestedJarData(boolean multiRelease) throws Exception {
		ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
		JarOutputStream jarOutputStream = new JarOutputStream(byteArrayOutputStream);
		jarOutputStream.setComment('nested');
		writeManifest(jarOutputStream, 'j2', multiRelease);
		if (multiRelease) {
			writeEntry(jarOutputStream, 'multi-release.dat', BASE_VERSION);
			writeEntry(jarOutputStream, String.format('META-INF/versions/%d/multi-release.dat', MULTI_JAR_VERSION),
					MULTI_JAR_VERSION);
		}
		else {
			writeEntry(jarOutputStream, '3.dat', 3);
			writeEntry(jarOutputStream, '4.dat', 4);
			writeEntry(jarOutputStream, '\u00E4.dat', "\u00E4");
		}
		jarOutputStream.close();
		return byteArrayOutputStream.toByteArray();
	}
	private static void writeManifest(JarOutputStream jarOutputStream, String name) throws Exception {
		writeManifest(jarOutputStream, name, false);
	}
	private static void writeManifest(JarOutputStream jarOutputStream, String name, boolean multiRelease)
			throws Exception {
		writeDirEntry(jarOutputStream, 'META-INF/');
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().putValue('Built-By', name);
		manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, '1.0');
		if (multiRelease) {
			manifest.getMainAttributes().putValue('Multi-Release', Boolean.toString(true));
		}
		jarOutputStream.putNextEntry(new ZipEntry('META-INF/MANIFEST.MF'));
		manifest.write(jarOutputStream);
		jarOutputStream.closeEntry();
	}
	private static void writeDirEntry(JarOutputStream jarOutputStream, String name) throws IOException {
		jarOutputStream.putNextEntry(new JarEntry(name));
		jarOutputStream.closeEntry();
	}
	private static void writeEntry(JarOutputStream jarOutputStream, String name, int data) throws IOException {
		jarOutputStream.putNextEntry(new JarEntry(name));
		jarOutputStream.write(new byte[] { (byte) data });
		jarOutputStream.closeEntry();
	}
	public static File getSigned() {
		String[] entries = System.getProperty('java.class.path').split(System.getProperty('path.separator'));
		for (String entry : entries) {
			if (entry.contains('bcprov')) {
				return new File(entry);
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.loader.launch;
/**
class ClassPathIndexFileTests {
	@TempDir
	File temp;
	@Test
	void loadIfPossibleWhenRootDoesNotExistReturnsNull() throws Exception {
		File root = new File(this.temp, 'missing');
		assertThat(ClassPathIndexFile.loadIfPossible(root, 'test.idx')).isNull();
	}
	@Test
	void loadIfPossibleWhenRootIsDirectoryThrowsException() throws Exception {
		File root = new File(this.temp, 'directory');
		root.mkdirs();
		assertThat(ClassPathIndexFile.loadIfPossible(root, 'test.idx')).isNull();
	}
	@Test
	void loadIfPossibleReturnsInstance() throws Exception {
		ClassPathIndexFile indexFile = copyAndLoadTestIndexFile();
		assertThat(indexFile).isNotNull();
	}
	@Test
	void sizeReturnsNumberOfLines() throws Exception {
		ClassPathIndexFile indexFile = copyAndLoadTestIndexFile();
		assertThat(indexFile.size()).isEqualTo(5);
	}
	@Test
	void getUrlsReturnsUrls() throws Exception {
		ClassPathIndexFile indexFile = copyAndLoadTestIndexFile();
		List<URL> urls = indexFile.getUrls();
		List<File> expected = new ArrayList<>();
		expected.add(new File(this.temp, 'BOOT-INF/layers/one/lib/a.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/one/lib/b.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/one/lib/c.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/two/lib/d.jar'));
		expected.add(new File(this.temp, 'BOOT-INF/layers/two/lib/e.jar'));
		assertThat(urls).containsExactly(expected.stream().map(this::toUrl).toArray(URL[]::new));
	}
	private URL toUrl(File file) {
		try {
			return file.toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private ClassPathIndexFile copyAndLoadTestIndexFile() throws IOException {
		copyTestIndexFile();
		ClassPathIndexFile indexFile = ClassPathIndexFile.loadIfPossible(this.temp, 'test.idx');
		return indexFile;
	}
	private void copyTestIndexFile() throws IOException {
		Files.copy(getClass().getResourceAsStream('classpath-index-file.idx'),
				new File(this.temp, 'test.idx').toPath());
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@ExtendWith(OutputCaptureExtension.class)
@AssertFileChannelDataBlocksClosed
class LauncherTests {
	/**
	 * Jar Mode tests.
	 */
	@Nested
	class JarMode {
		@BeforeEach
		void setup() {
			System.setProperty(JarModeRunner.DISABLE_SYSTEM_EXIT, 'true');
		}
		@AfterEach
		void cleanup() {
			System.clearProperty('jarmode');
			System.clearProperty(JarModeRunner.DISABLE_SYSTEM_EXIT);
		}
		@Test
		void launchWhenJarModePropertyIsSetLaunchesJarMode(CapturedOutput out) throws Exception {
			System.setProperty('jarmode', 'test');
			new TestLauncher().launch(new String[] { 'boot' });
			assertThat(out).contains('running in test jar mode [boot]');
		}
		@Test
		void launchWhenJarModePropertyIsNotAcceptedThrowsException(CapturedOutput out) throws Exception {
			System.setProperty('jarmode', 'idontexist');
			new TestLauncher().launch(new String[] { 'boot' });
			assertThat(out).contains('Unsupported jarmode "idontexist"');
		}
	}
	private static final class TestLauncher extends Launcher {
		@Override
		protected String getMainClass() throws Exception {
			throw new IllegalStateException('Should not be called');
		}
		@Override
		protected Archive getArchive() {
			return null;
		}
		@Override
		protected Set<URL> getClassPathUrls() throws Exception {
			return Collections.emptySet();
		}
		@Override
		protected void launch(String[] args) throws Exception {
			super.launch(args);
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@AssertFileChannelDataBlocksClosed
class ArchiveTests {
	@TempDir
	File temp;
	@Test
	void getClassPathUrlsWithOnlyIncludeFilterSearchesAllDirectories() throws Exception {
		Archive archive = mock(Archive.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));
		Predicate<Entry> includeFilter = (entry) -> false;
		archive.getClassPathUrls(includeFilter);
		then(archive).should().getClassPathUrls(includeFilter, Archive.ALL_ENTRIES);
	}
	@Test
	void isExplodedWhenHasRootDirectoryReturnsTrue() {
		Archive archive = mock(Archive.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));
		given(archive.getRootDirectory()).willReturn(this.temp);
		assertThat(archive.isExploded()).isTrue();
	}
	@Test
	void isExplodedWhenHasNoRootDirectoryReturnsFalse() {
		Archive archive = mock(Archive.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));
		given(archive.getRootDirectory()).willReturn(null);
		assertThat(archive.isExploded()).isFalse();
	}
	@Test
	void createFromProtectionDomainCreatesJarArchive() throws Exception {
		File jarFile = new File(this.temp, 'test.jar');
		TestJar.create(jarFile);
		ProtectionDomain protectionDomain = mock(ProtectionDomain.class);
		CodeSource codeSource = mock(CodeSource.class);
		given(protectionDomain.getCodeSource()).willReturn(codeSource);
		given(codeSource.getLocation()).willReturn(jarFile.toURI().toURL());
		try (Archive archive = Archive.create(protectionDomain)) {
			assertThat(archive).isInstanceOf(JarFileArchive.class);
		}
	}
	@Test
	void createFromProtectionDomainWhenNoLocationThrowsException() throws Exception {
		File jarFile = new File(this.temp, 'test.jar');
		TestJar.create(jarFile);
		ProtectionDomain protectionDomain = mock(ProtectionDomain.class);
		assertThatIllegalStateException().isThrownBy(() -> Archive.create(protectionDomain))
			.withMessage('Unable to determine code source archive');
	}
	@Test
	void createFromFileWhenFileDoesNotExistThrowsException() {
		File target = new File(this.temp, 'missing');
		assertThatIllegalStateException().isThrownBy(() -> Archive.create(target))
			.withMessageContaining('Unable to determine code source archive');
	}
	@Test
	void createFromFileWhenJarFileReturnsJarFileArchive() throws Exception {
		File target = new File(this.temp, 'missing');
		TestJar.create(target);
		try (Archive archive = Archive.create(target)) {
			assertThat(archive).isInstanceOf(JarFileArchive.class);
		}
	}
	@Test
	void createFromFileWhenDirectoryReturnsExplodedFileArchive() throws Exception {
		File target = this.temp;
		try (Archive archive = Archive.create(target)) {
			assertThat(archive).isInstanceOf(ExplodedArchive.class);
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@AssertFileChannelDataBlocksClosed
class LaunchedClassLoaderTests {
	@Test
	void loadClassWhenJarModeClassLoadsInLaunchedClassLoader() throws Exception {
		try (LaunchedClassLoader classLoader = new LaunchedClassLoader(false, new URL[] {},
				getClass().getClassLoader())) {
			Class<?> jarModeClass = classLoader.loadClass(JarMode.class.getName());
			Class<?> jarModeRunnerClass = classLoader.loadClass(JarModeRunner.class.getName());
			assertThat(jarModeClass.getClassLoader()).isSameAs(classLoader);
			assertThat(jarModeRunnerClass.getClassLoader()).isSameAs(classLoader);
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@AssertFileChannelDataBlocksClosed
class JarFileArchiveTests {
	@TempDir
	File tempDir;
	private File file;
	private JarFileArchive archive;
	@BeforeEach
	void setup() throws Exception {
		createTestJarArchive(false);
	}
	@AfterEach
	void tearDown() throws Exception {
		this.archive.close();
	}
	@Test
	void isExplodedReturnsFalse() {
		assertThat(this.archive.isExploded()).isFalse();
	}
	@Test
	void getRootDirectoryReturnsNull() {
		assertThat(this.archive.getRootDirectory()).isNull();
	}
	@Test
	void getManifestReturnsManifest() throws Exception {
		assertThat(this.archive.getManifest().getMainAttributes().getValue('Built-By')).isEqualTo('j1');
	}
	@Test
	void getClassPathUrlsWhenNoPredicatesReturnsUrls() throws Exception {
		Set<URL> urls = this.archive.getClassPathUrls(Archive.ALL_ENTRIES);
		URL[] expected = TestJar.expectedEntries()
			.stream()
			.map((name) -> JarUrl.create(this.file, name))
			.toArray(URL[]::new);
		assertThat(urls).containsExactly(expected);
	}
	@Test
	void getClassPathUrlsWhenHasIncludeFilterReturnsUrls() throws Exception {
		Set<URL> urls = this.archive.getClassPathUrls(this::entryNameIsNestedJar);
		assertThat(urls).containsOnly(JarUrl.create(this.file, 'nested.jar'));
	}
	@Test
	void getClassPathUrlsWhenHasSearchFilterAllUrlsSinceSearchFilterIsNotUsed() throws Exception {
		Set<URL> urls = this.archive.getClassPathUrls(Archive.ALL_ENTRIES, (entry) -> false);
		URL[] expected = TestJar.expectedEntries()
			.stream()
			.map((name) -> JarUrl.create(this.file, name))
			.toArray(URL[]::new);
		assertThat(urls).containsExactly(expected);
	}
	@Test
	void getClassPathUrlsWhenHasUnpackCommentUnpacksAndReturnsUrls() throws Exception {
		createTestJarArchive(true);
		Set<URL> urls = this.archive.getClassPathUrls(this::entryNameIsNestedJar);
		assertThat(urls).hasSize(1);
		URL url = urls.iterator().next();
		assertThat(url).isNotEqualTo(JarUrl.create(this.file, 'nested.jar'));
		// The unpack URL must be a raw file URL (see gh-38833)
		assertThat(url.toString()).startsWith('file:').endsWith('/nested.jar');
	}
	@Test
	void getClassPathUrlsWhenHasUnpackCommentUnpacksToUniqueLocationsPerArchive() throws Exception {
		createTestJarArchive(true);
		URL firstNestedUrl = this.archive.getClassPathUrls(this::entryNameIsNestedJar).iterator().next();
		createTestJarArchive(true);
		URL secondNestedUrl = this.archive.getClassPathUrls(this::entryNameIsNestedJar).iterator().next();
		assertThat(secondNestedUrl).isNotEqualTo(firstNestedUrl);
	}
	@Test
	void getClassPathUrlsWhenHasUnpackCommentUnpacksAndShareSameParent() throws Exception {
		createTestJarArchive(true);
		URL nestedUrl = this.archive.getClassPathUrls(this::entryNameIsNestedJar).iterator().next();
		URL anotherNestedUrl = this.archive.getClassPathUrls((entry) -> entry.name().equals('another-nested.jar'))
			.iterator()
			.next();
		assertThat(nestedUrl.toString())
			.isEqualTo(anotherNestedUrl.toString().replace('another-nested.jar', 'nested.jar'));
	}
	@Test
	void getClassPathUrlsWhenZip64ListsAllEntries() throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		FileCopyUtils.copy(writeZip64Jar(), file);
		try (Archive jarArchive = new JarFileArchive(file)) {
			Set<URL> urls = jarArchive.getClassPathUrls(Archive.ALL_ENTRIES);
			assertThat(urls).hasSize(65537);
		}
	}
	private byte[] writeZip64Jar() throws IOException {
		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		try (JarOutputStream jarOutput = new JarOutputStream(bytes)) {
			for (int i = 0; i < 65537; i++) {
				jarOutput.putNextEntry(new JarEntry(i + '.dat'));
				jarOutput.closeEntry();
			}
		}
		return bytes.toByteArray();
	}
	private void createTestJarArchive(boolean unpackNested) throws Exception {
		if (this.archive != null) {
			this.archive.close();
		}
		this.file = new File(this.tempDir, 'root.jar');
		TestJar.create(this.file, unpackNested);
		this.archive = new JarFileArchive(this.file);
	}
	private boolean entryNameIsNestedJar(Entry entry) {
		return entry.name().equals('nested.jar');
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@AssertFileChannelDataBlocksClosed
class WarLauncherTests extends AbstractLauncherTests {
	@Test
	void explodedWarHasOnlyWebInfClassesAndContentsOfWebInfLibOnClasspath() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.war', 'WEB-INF'));
		WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot));
		Set<URL> urls = launcher.getClassPathUrls();
		assertThat(urls).containsExactlyInAnyOrder(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void archivedWarHasOnlyWebInfClassesAndContentsOfWebInfLibOnClasspath() throws Exception {
		File file = createJarArchive('archive.war', 'WEB-INF');
		try (JarFileArchive archive = new JarFileArchive(file)) {
			WarLauncher launcher = new WarLauncher(archive);
			Set<URL> urls = launcher.getClassPathUrls();
			List<URL> expected = new ArrayList<>();
			expected.add(JarUrl.create(file, 'WEB-INF/classes/'));
			expected.add(JarUrl.create(file, 'WEB-INF/lib/foo.jar'));
			expected.add(JarUrl.create(file, 'WEB-INF/lib/bar.jar'));
			expected.add(JarUrl.create(file, 'WEB-INF/lib/baz.jar'));
			assertThat(urls).containsOnly(expected.toArray(URL[]::new));
		}
	}
	@Test
	void explodedWarShouldPreserveClasspathOrderWhenIndexPresent() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.war', 'WEB-INF', true, Collections.emptyList()));
		WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot));
		URLClassLoader classLoader = createClassLoader(launcher);
		URL[] urls = classLoader.getURLs();
		assertThat(urls).containsExactly(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void warFilesPresentInWebInfLibsAndNotInClasspathIndexShouldBeAddedAfterWebInfClasses() throws Exception {
		ArrayList<String> extraLibs = new ArrayList<>(Arrays.asList('extra-1.jar', 'extra-2.jar'));
		File explodedRoot = explode(createJarArchive('archive.war', 'WEB-INF', true, extraLibs));
		WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot));
		URLClassLoader classLoader = createClassLoader(launcher);
		URL[] urls = classLoader.getURLs();
		List<File> expectedFiles = getExpectedFilesWithExtraLibs(explodedRoot);
		URL[] expectedFileUrls = expectedFiles.stream().map(this::toUrl).toArray(URL[]::new);
		assertThat(urls).containsExactly(expectedFileUrls);
	}
	private URL[] getExpectedFileUrls(File explodedRoot) {
		return getExpectedFiles(explodedRoot).stream().map(this::toUrl).toArray(URL[]::new);
	}
	private List<File> getExpectedFiles(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'WEB-INF/classes'));
		expected.add(new File(parent, 'WEB-INF/lib/foo.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/bar.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/baz.jar'));
		return expected;
	}
	private List<File> getExpectedFilesWithExtraLibs(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'WEB-INF/classes'));
		expected.add(new File(parent, 'WEB-INF/lib/extra-1.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/extra-2.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/foo.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/bar.jar'));
		expected.add(new File(parent, 'WEB-INF/lib/baz.jar'));
		return expected;
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@AssertFileChannelDataBlocksClosed
class JarLauncherTests extends AbstractLauncherTests {
	@Test
	void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF'));
		JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot));
		Set<URL> urls = launcher.getClassPathUrls();
		assertThat(urls).containsExactlyInAnyOrder(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void archivedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception {
		File jarRoot = createJarArchive('archive.jar', 'BOOT-INF');
		try (JarFileArchive archive = new JarFileArchive(jarRoot)) {
			JarLauncher launcher = new JarLauncher(archive);
			Set<URL> urls = launcher.getClassPathUrls();
			List<URL> expectedUrls = new ArrayList<>();
			expectedUrls.add(JarUrl.create(jarRoot, 'BOOT-INF/classes/'));
			expectedUrls.add(JarUrl.create(jarRoot, 'BOOT-INF/lib/foo.jar'));
			expectedUrls.add(JarUrl.create(jarRoot, 'BOOT-INF/lib/bar.jar'));
			expectedUrls.add(JarUrl.create(jarRoot, 'BOOT-INF/lib/baz.jar'));
			assertThat(urls).containsOnlyOnceElementsOf(expectedUrls);
		}
	}
	@Test
	void explodedJarShouldPreserveClasspathOrderWhenIndexPresent() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF', true, Collections.emptyList()));
		JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot));
		URLClassLoader classLoader = createClassLoader(launcher);
		assertThat(classLoader.getURLs()).containsExactly(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void jarFilesPresentInBootInfLibsAndNotInClasspathIndexShouldBeAddedAfterBootInfClasses() throws Exception {
		ArrayList<String> extraLibs = new ArrayList<>(Arrays.asList('extra-1.jar', 'extra-2.jar'));
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF', true, extraLibs));
		JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot));
		URLClassLoader classLoader = createClassLoader(launcher);
		List<File> expectedFiles = getExpectedFilesWithExtraLibs(explodedRoot);
		URL[] expectedFileUrls = expectedFiles.stream().map(this::toUrl).toArray(URL[]::new);
		assertThat(classLoader.getURLs()).containsExactly(expectedFileUrls);
	}
	@Test
	void explodedJarDefinedPackagesIncludeManifestAttributes() {
		Manifest manifest = new Manifest();
		Attributes attributes = manifest.getMainAttributes();
		attributes.put(Name.MANIFEST_VERSION, '1.0');
		attributes.put(Name.IMPLEMENTATION_TITLE, 'test');
		SourceFile sourceFile = SourceFile.of('explodedsample/ExampleClass.java',
				new ClassPathResource('explodedsample/ExampleClass.txt'));
		TestCompiler.forSystem().compile(sourceFile, ThrowingConsumer.of((compiled) -> {
			File explodedRoot = explode(
					createJarArchive('archive.jar', manifest, 'BOOT-INF', true, Collections.emptyList()));
			File target = new File(explodedRoot, 'BOOT-INF/classes/explodedsample/ExampleClass.class');
			target.getParentFile().mkdirs();
			FileCopyUtils.copy(compiled.getClassLoader().getResourceAsStream('explodedsample/ExampleClass.class'),
					new FileOutputStream(target));
			JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot));
			URLClassLoader classLoader = createClassLoader(launcher);
			Class<?> loaded = classLoader.loadClass('explodedsample.ExampleClass');
			assertThat(loaded.getPackage().getImplementationTitle()).isEqualTo('test');
		}));
	}
	private URL[] getExpectedFileUrls(File explodedRoot) {
		return getExpectedFiles(explodedRoot).stream().map(this::toUrl).toArray(URL[]::new);
	}
	private List<File> getExpectedFiles(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'BOOT-INF/classes'));
		expected.add(new File(parent, 'BOOT-INF/lib/foo.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/bar.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/baz.jar'));
		return expected;
	}
	private List<File> getExpectedFilesWithExtraLibs(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'BOOT-INF/classes'));
		expected.add(new File(parent, 'BOOT-INF/lib/extra-1.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/extra-2.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/foo.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/bar.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/baz.jar'));
		return expected;
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@ExtendWith(OutputCaptureExtension.class)
@AssertFileChannelDataBlocksClosed
class PropertiesLauncherTests extends AbstractLauncherTests {
	private PropertiesLauncher launcher;
	private ClassLoader contextClassLoader;
	private CapturedOutput output;
	@BeforeEach
	void setup(CapturedOutput capturedOutput) {
		this.contextClassLoader = Thread.currentThread().getContextClassLoader();
		System.setProperty('loader.home', new File('src/test/resources').getAbsolutePath());
		this.output = capturedOutput;
	}
	@AfterEach
	void close() throws Exception {
		Thread.currentThread().setContextClassLoader(this.contextClassLoader);
		System.clearProperty('loader.home');
		System.clearProperty('loader.path');
		System.clearProperty('loader.main');
		System.clearProperty('loader.config.name');
		System.clearProperty('loader.config.location');
		System.clearProperty('loader.system');
		System.clearProperty('loader.classLoader');
		if (this.launcher != null) {
			this.launcher.close();
		}
	}
	@Test
	void testDefaultHome() throws Exception {
		System.clearProperty('loader.home');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getHomeDirectory()).isEqualTo(new File(System.getProperty('user.dir')));
	}
	@Test
	void testAlternateHome() throws Exception {
		System.setProperty('loader.home', 'src/test/resources/home');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getHomeDirectory()).isEqualTo(new File(System.getProperty('loader.home')));
		assertThat(this.launcher.getMainClass()).isEqualTo('demo.HomeApplication');
	}
	@Test
	void testNonExistentHome() {
		System.setProperty('loader.home', 'src/test/resources/nonexistent');
		assertThatIllegalArgumentException().isThrownBy(PropertiesLauncher::new)
			.withMessageContaining('Invalid source directory');
	}
	@Test
	void testUserSpecifiedMain() throws Exception {
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('demo.Application');
		assertThat(System.getProperty('loader.main')).isNull();
	}
	@Test
	void testUserSpecifiedConfigName() throws Exception {
		System.setProperty('loader.config.name', 'foo');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('my.Application');
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[etc/]');
	}
	@Test
	void testRootOfClasspathFirst() throws Exception {
		System.setProperty('loader.config.name', 'bar');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('my.BarApplication');
	}
	@Test
	void testUserSpecifiedDotPath() throws Exception {
		System.setProperty('loader.path', '.');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[.]');
	}
	@Test
	void testUserSpecifiedSlashPath() throws Exception {
		System.setProperty('loader.path', 'jars/');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/]');
		Set<URL> urls = this.launcher.getClassPathUrls();
		assertThat(urls).areExactly(1, endingWith('app.jar'));
	}
	@Test
	void testUserSpecifiedWildcardPath() throws Exception {
		System.setProperty('loader.path', 'jars/*');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedJarPath() throws Exception {
		System.setProperty('loader.path', 'jars/app.jar');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedRootOfJarPath() throws Exception {
		System.setProperty('loader.path', 'jar:file:./src/test/resources/nested-jars/app.jar!/');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths'))
			.hasToString('[jar:file:./src/test/resources/nested-jars/app.jar!/]');
		Set<URL> urls = this.launcher.getClassPathUrls();
		assertThat(urls).areExactly(1, endingWith('foo.jar!/'));
		assertThat(urls).areExactly(1, endingWith('app.jar!/'));
	}
	@Test
	void testUserSpecifiedRootOfJarPathWithDot() throws Exception {
		System.setProperty('loader.path', 'nested-jars/app.jar!/./');
		this.launcher = new PropertiesLauncher();
		Set<URL> urls = this.launcher.getClassPathUrls();
		assertThat(urls).areExactly(1, endingWith('foo.jar!/'));
		assertThat(urls).areExactly(1, endingWith('app.jar!/'));
	}
	@Test
	void testUserSpecifiedRootOfJarPathWithDotAndJarPrefix() throws Exception {
		System.setProperty('loader.path', 'jar:file:./src/test/resources/nested-jars/app.jar!/./');
		this.launcher = new PropertiesLauncher();
		Set<URL> urls = this.launcher.getClassPathUrls();
		assertThat(urls).areExactly(1, endingWith('foo.jar!/'));
	}
	@Test
	void testUserSpecifiedJarFileWithNestedArchives() throws Exception {
		System.setProperty('loader.path', 'nested-jars/app.jar');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		Set<URL> urls = this.launcher.getClassPathUrls();
		assertThat(urls).areExactly(1, endingWith('foo.jar!/'));
		assertThat(urls).areExactly(1, endingWith('app.jar'));
	}
	@Test
	void testUserSpecifiedNestedJarPath() throws Exception {
		System.setProperty('loader.path', 'nested-jars/nested-jar-app.jar!/BOOT-INF/classes/');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths'))
			.hasToString('[nested-jars/nested-jar-app.jar!/BOOT-INF/classes/]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedDirectoryContainingJarFileWithNestedArchives() throws Exception {
		System.setProperty('loader.path', 'nested-jars');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedJarPathWithDot() throws Exception {
		System.setProperty('loader.path', './jars/app.jar');
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedClassLoader() throws Exception {
		System.setProperty('loader.path', 'jars/app.jar');
		System.setProperty('loader.classLoader', URLClassLoader.class.getName());
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths')).hasToString('[jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void testUserSpecifiedClassPathOrder() throws Exception {
		System.setProperty('loader.path', 'more-jars/app.jar,jars/app.jar');
		System.setProperty('loader.classLoader', URLClassLoader.class.getName());
		this.launcher = new PropertiesLauncher();
		assertThat(ReflectionTestUtils.getField(this.launcher, 'paths'))
			.hasToString('[more-jars/app.jar, jars/app.jar]');
		this.launcher.launch(new String[0]);
		waitFor('Hello Other World');
	}
	@Test
	void testCustomClassLoaderCreation() throws Exception {
		System.setProperty('loader.classLoader', TestLoader.class.getName());
		this.launcher = new PropertiesLauncher();
		ClassLoader loader = this.launcher.createClassLoader(classPathUrls());
		assertThat(loader).isNotNull();
		assertThat(loader.getClass().getName()).isEqualTo(TestLoader.class.getName());
	}
	private Set<URL> classPathUrls() throws Exception {
		Set<URL> urls = new LinkedHashSet<>();
		String classPath = System.getProperty('java.class.path');
		for (String path : classPath.split(File.pathSeparator)) {
			File file = new FileSystemResource(path).getFile();
			if (file.exists()) {
				urls.add(file.toURI().toURL());
			}
		}
		return urls;
	}
	@Test
	void testUserSpecifiedConfigPathWins() throws Exception {
		System.setProperty('loader.config.name', 'foo');
		System.setProperty('loader.config.location', 'classpath:bar.properties');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('my.BarApplication');
	}
	@Test
	void testSystemPropertySpecifiedMain() throws Exception {
		System.setProperty('loader.main', 'foo.Bar');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('foo.Bar');
	}
	@Test
	void testSystemPropertiesSet() throws Exception {
		System.setProperty('loader.system', 'true');
		new PropertiesLauncher();
		assertThat(System.getProperty('loader.main')).isEqualTo('demo.Application');
	}
	@Test
	void testArgsEnhanced() throws Exception {
		System.setProperty('loader.args', 'foo');
		this.launcher = new PropertiesLauncher();
		assertThat(Arrays.asList(this.launcher.getArgs('bar'))).hasToString('[foo, bar]');
	}
	@Test
	@SuppressWarnings('unchecked')
	void testLoadPathCustomizedUsingManifest() throws Exception {
		System.setProperty('loader.home', this.tempDir.getAbsolutePath());
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, '1.0');
		manifest.getMainAttributes().putValue('Loader-Path', '/foo.jar, /bar');
		File manifestFile = new File(this.tempDir, 'META-INF/MANIFEST.MF');
		manifestFile.getParentFile().mkdirs();
		try (FileOutputStream manifestStream = new FileOutputStream(manifestFile)) {
			manifest.write(manifestStream);
		}
		this.launcher = new PropertiesLauncher();
		assertThat((List<String>) ReflectionTestUtils.getField(this.launcher, 'paths')).containsExactly('/foo.jar',
				'/bar/');
	}
	@Test
	void testManifestWithPlaceholders() throws Exception {
		System.setProperty('loader.home', 'src/test/resources/placeholders');
		this.launcher = new PropertiesLauncher();
		assertThat(this.launcher.getMainClass()).isEqualTo('demo.FooApplication');
	}
	@Test
	void encodedFileUrlLoaderPathIsHandledCorrectly() throws Exception {
		File loaderPath = new File(this.tempDir, 'loader path');
		loaderPath.mkdir();
		System.setProperty('loader.path', loaderPath.toURI().toURL().toString());
		this.launcher = new PropertiesLauncher();
		Set<URL> urls = this.launcher.getClassPathUrls();
		assertThat(urls).hasSize(1);
		assertThat(urls.iterator().next()).isEqualTo(loaderPath.toURI().toURL());
	}
	@Test // gh-21575
	void loadResourceFromJarFile() throws Exception {
		File file = new File(this.tempDir, 'app.jar');
		TestJar.create(file);
		System.setProperty('loader.home', this.tempDir.getAbsolutePath());
		System.setProperty('loader.path', 'app.jar');
		this.launcher = new PropertiesLauncher();
		try {
			this.launcher.launch(new String[0]);
		}
		catch (Exception ex) {
			// Expected ClassNotFoundException
			LaunchedClassLoader classLoader = (LaunchedClassLoader) Thread.currentThread().getContextClassLoader();
			classLoader.close();
		}
		URL resource = JarUrl.create(file, 'nested.jar', '3.dat');
		byte[] bytes = FileCopyUtils.copyToByteArray(resource.openStream());
		assertThat(bytes).isNotEmpty();
	}
	@Test // gh-37992
	void classPathWithoutLoaderPathDefaultsToJarLauncherIncludes() throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(file))) {
			try (JarFile in = new JarFile(new File('src/test/resources/jars/app.jar'))) {
				out.putNextEntry(new ZipEntry('BOOT-INF/'));
				out.putNextEntry(new ZipEntry('BOOT-INF/classes/'));
				out.putNextEntry(new ZipEntry('BOOT-INF/classes/demo/'));
				out.putNextEntry(new ZipEntry('BOOT-INF/classes/demo/Application.class'));
				try (InputStream classIn = in.getInputStream(in.getEntry('demo/Application.class'))) {
					classIn.transferTo(out);
				}
				out.closeEntry();
			}
		}
		Archive archive = new JarFileArchive(file);
		System.setProperty('loader.main', 'demo.Application');
		this.launcher = new PropertiesLauncher(archive);
		this.launcher.launch(new String[0]);
		waitFor('Hello World');
	}
	@Test
	void explodedJarShouldPreserveClasspathOrderWhenIndexPresent() throws Exception {
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF', true, Collections.emptyList()));
		PropertiesLauncher launcher = new PropertiesLauncher(new ExplodedArchive(explodedRoot));
		URLClassLoader classLoader = createClassLoader(launcher);
		assertThat(classLoader.getURLs()).containsExactly(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void customClassLoaderAndExplodedJarAndShouldPreserveClasspathOrderWhenIndexPresent() throws Exception {
		System.setProperty('loader.classLoader', URLClassLoader.class.getName());
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF', true, Collections.emptyList()));
		PropertiesLauncher launcher = new PropertiesLauncher(new ExplodedArchive(explodedRoot));
		URLClassLoader classLoader = createClassLoader(launcher);
		assertThat(classLoader.getParent()).isInstanceOf(URLClassLoader.class);
		assertThat(((URLClassLoader) classLoader.getParent()).getURLs())
			.containsExactly(getExpectedFileUrls(explodedRoot));
	}
	@Test
	void jarFilesPresentInBootInfLibsAndNotInClasspathIndexShouldBeAddedAfterBootInfClasses() throws Exception {
		ArrayList<String> extraLibs = new ArrayList<>(Arrays.asList('extra-1.jar', 'extra-2.jar'));
		File explodedRoot = explode(createJarArchive('archive.jar', 'BOOT-INF', true, extraLibs));
		PropertiesLauncher launcher = new PropertiesLauncher(new ExplodedArchive(explodedRoot));
		URLClassLoader classLoader = createClassLoader(launcher);
		List<File> expectedFiles = getExpectedFilesWithExtraLibs(explodedRoot);
		URL[] expectedFileUrls = expectedFiles.stream().map(this::toUrl).toArray(URL[]::new);
		assertThat(classLoader.getURLs()).containsExactly(expectedFileUrls);
	}
	private void waitFor(String value) {
		Awaitility.waitAtMost(Duration.ofSeconds(5)).until(this.output::toString, containsString(value));
	}
	private URL[] getExpectedFileUrls(File explodedRoot) {
		return getExpectedFiles(explodedRoot).stream().map(this::toUrl).toArray(URL[]::new);
	}
	private List<File> getExpectedFiles(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'BOOT-INF/classes'));
		expected.add(new File(parent, 'BOOT-INF/lib/foo.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/bar.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/baz.jar'));
		return expected;
	}
	private List<File> getExpectedFilesWithExtraLibs(File parent) {
		List<File> expected = new ArrayList<>();
		expected.add(new File(parent, 'BOOT-INF/classes'));
		expected.add(new File(parent, 'BOOT-INF/lib/extra-1.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/extra-2.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/foo.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/bar.jar'));
		expected.add(new File(parent, 'BOOT-INF/lib/baz.jar'));
		return expected;
	}
	private Condition<URL> endingWith(String value) {
		return new Condition<>() {
			@Override
			public boolean matches(URL archive) {
				return archive.toString().endsWith(value);
			}
		};
	}
	static class TestLoader extends URLClassLoader {
		TestLoader(ClassLoader parent) {
			super(new URL[0], parent);
		}
		@Override
		protected Class<?> findClass(String name) throws ClassNotFoundException {
			return super.findClass(name);
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
abstract class AbstractLauncherTests {
	@TempDir
	File tempDir;
	protected File createJarArchive(String name, String entryPrefix) throws IOException {
		return createJarArchive(name, entryPrefix, false, Collections.emptyList());
	}
	protected File createJarArchive(String name, String entryPrefix, boolean indexed, List<String> extraLibs)
			throws IOException {
		return createJarArchive(name, null, entryPrefix, indexed, extraLibs);
	}
	protected File createJarArchive(String name, Manifest manifest, String entryPrefix, boolean indexed,
			List<String> extraLibs) throws IOException {
		File archive = new File(this.tempDir, name);
		JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(archive));
		if (manifest != null) {
			jarOutputStream.putNextEntry(new JarEntry('META-INF/'));
			jarOutputStream.putNextEntry(new JarEntry('META-INF/MANIFEST.MF'));
			manifest.write(jarOutputStream);
			jarOutputStream.closeEntry();
		}
		jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/'));
		jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/classes/'));
		jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/lib/'));
		if (indexed) {
			jarOutputStream.putNextEntry(new JarEntry(entryPrefix + '/classpath.idx'));
			Writer writer = new OutputStreamWriter(jarOutputStream, StandardCharsets.UTF_8);
			writer.write('- \'' + entryPrefix + '/lib/foo.jar\'\n');
			writer.write('- \'' + entryPrefix + '/lib/bar.jar\'\n');
			writer.write('- \'' + entryPrefix + '/lib/baz.jar\'\n');
			writer.flush();
			jarOutputStream.closeEntry();
		}
		addNestedJars(entryPrefix, '/lib/foo.jar', jarOutputStream);
		addNestedJars(entryPrefix, '/lib/bar.jar', jarOutputStream);
		addNestedJars(entryPrefix, '/lib/baz.jar', jarOutputStream);
		for (String lib : extraLibs) {
			addNestedJars(entryPrefix, '/lib/' + lib, jarOutputStream);
		}
		jarOutputStream.close();
		return archive;
	}
	private void addNestedJars(String entryPrefix, String lib, JarOutputStream jarOutputStream) throws IOException {
		JarEntry libFoo = new JarEntry(entryPrefix + lib);
		libFoo.setMethod(ZipEntry.STORED);
		ByteArrayOutputStream fooJarStream = new ByteArrayOutputStream();
		new JarOutputStream(fooJarStream).close();
		libFoo.setSize(fooJarStream.size());
		CRC32 crc32 = new CRC32();
		crc32.update(fooJarStream.toByteArray());
		libFoo.setCrc(crc32.getValue());
		jarOutputStream.putNextEntry(libFoo);
		jarOutputStream.write(fooJarStream.toByteArray());
	}
	protected File explode(File archive) throws IOException {
		File exploded = new File(this.tempDir, 'exploded');
		exploded.mkdirs();
		JarFile jarFile = new JarFile(archive);
		Enumeration<JarEntry> entries = jarFile.entries();
		while (entries.hasMoreElements()) {
			JarEntry entry = entries.nextElement();
			File entryFile = new File(exploded, entry.getName());
			if (entry.isDirectory()) {
				entryFile.mkdirs();
			}
			else {
				FileCopyUtils.copy(jarFile.getInputStream(entry), new FileOutputStream(entryFile));
			}
		}
		jarFile.close();
		return exploded;
	}
	protected final URL toUrl(File file) {
		try {
			return file.toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	protected URLClassLoader createClassLoader(Launcher launcher) throws Exception {
		return (URLClassLoader) launcher.createClassLoader(launcher.getClassPathUrls());
	}
}
/*
package org.springframework.boot.loader.launch;
/**
@AssertFileChannelDataBlocksClosed
class ExplodedArchiveTests {
	@TempDir
	File tempDir;
	private File rootDirectory;
	private ExplodedArchive archive;
	@BeforeEach
	void setup() throws Exception {
		createArchive();
	}
	@AfterEach
	void tearDown() throws Exception {
		if (this.archive != null) {
			this.archive.close();
		}
	}
	@Test
	void isExplodedReturnsTrue() {
		assertThat(this.archive.isExploded()).isTrue();
	}
	@Test
	void getRootDirectoryReturnsRootDirectory() {
		assertThat(this.archive.getRootDirectory()).isEqualTo(this.rootDirectory);
	}
	@Test
	void getManifestReturnsManifest() throws Exception {
		assertThat(this.archive.getManifest().getMainAttributes().getValue('Built-By')).isEqualTo('j1');
	}
	@Test
	void getClassPathUrlsWhenNoPredicatesReturnsUrls() throws Exception {
		Set<URL> urls = this.archive.getClassPathUrls(Archive.ALL_ENTRIES);
		URL[] expectedUrls = TestJar.expectedEntries().stream().map(this::toUrl).toArray(URL[]::new);
		assertThat(urls).containsExactlyInAnyOrder(expectedUrls);
	}
	@Test
	void getClassPathUrlsWhenHasIncludeFilterReturnsUrls() throws Exception {
		Set<URL> urls = this.archive.getClassPathUrls(this::entryNameIsNestedJar);
		assertThat(urls).containsOnly(toUrl('nested.jar'));
	}
	@Test
	void getClassPathUrlsWhenHasIncludeFilterAndSpaceInRootNameReturnsUrls() throws Exception {
		createArchive('spaces in the name');
		Set<URL> urls = this.archive.getClassPathUrls(this::entryNameIsNestedJar);
		assertThat(urls).containsOnly(toUrl('nested.jar'));
	}
	@Test
	void getClassPathUrlsWhenHasSearchFilterReturnsUrls() throws Exception {
		Set<URL> urls = this.archive.getClassPathUrls(Archive.ALL_ENTRIES, (entry) -> !entry.name().equals('d/'));
		assertThat(urls).contains(toUrl('nested.jar')).doesNotContain(toUrl('d/9.dat'));
	}
	private void createArchive() throws Exception {
		createArchive(null);
	}
	private void createArchive(String directoryName) throws Exception {
		File file = new File(this.tempDir, 'test.jar');
		TestJar.create(file);
		this.rootDirectory = (StringUtils.hasText(directoryName) ? new File(this.tempDir, directoryName)
				: new File(this.tempDir, UUID.randomUUID().toString()));
		try (JarFile jarFile = new JarFile(file)) {
			Enumeration<JarEntry> entries = jarFile.entries();
			while (entries.hasMoreElements()) {
				JarEntry entry = entries.nextElement();
				File destination = new File(this.rootDirectory, entry.getName());
				destination.getParentFile().mkdirs();
				if (entry.isDirectory()) {
					destination.mkdir();
				}
				else {
					try (InputStream in = jarFile.getInputStream(entry);
							OutputStream out = new FileOutputStream(destination)) {
						in.transferTo(out);
					}
				}
			}
			this.archive = new ExplodedArchive(this.rootDirectory);
		}
	}
	private URL toUrl(String name) {
		return toUrl(new File(this.rootDirectory, name));
	}
	private URL toUrl(File file) {
		try {
			return file.toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private boolean entryNameIsNestedJar(Entry entry) {
		return entry.name().equals('nested.jar');
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class ZipDataDescriptorRecordTests {
	private static final short S0 = 0;
	@Test
	void loadWhenHasSignatureLoadsData() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x50, 0x4b, 0x07, 0x08, //
				0x01, 0x00, 0x00, 0x00, //
				0x02, 0x00, 0x00, 0x00, //
				0x03, 0x00, 0x00, 0x00 }); //
		ZipDataDescriptorRecord record = ZipDataDescriptorRecord.load(dataBlock, 0);
		assertThat(record.includeSignature()).isTrue();
		assertThat(record.crc32()).isEqualTo(1);
		assertThat(record.compressedSize()).isEqualTo(2);
		assertThat(record.uncompressedSize()).isEqualTo(3);
	}
	@Test
	void loadWhenHasNoSignatureLoadsData() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x01, 0x00, 0x00, 0x00, //
				0x02, 0x00, 0x00, 0x00, //
				0x03, 0x00, 0x00, 0x00 }); //
		ZipDataDescriptorRecord record = ZipDataDescriptorRecord.load(dataBlock, 0);
		assertThat(record.includeSignature()).isFalse();
		assertThat(record.crc32()).isEqualTo(1);
		assertThat(record.compressedSize()).isEqualTo(2);
		assertThat(record.uncompressedSize()).isEqualTo(3);
	}
	@Test
	void sizeWhenIncludeSignatureReturnsSize() {
		ZipDataDescriptorRecord record = new ZipDataDescriptorRecord(true, 0, 0, 0);
		assertThat(record.size()).isEqualTo(16);
	}
	@Test
	void sizeWhenNotIncludeSignatureReturnsSize() {
		ZipDataDescriptorRecord record = new ZipDataDescriptorRecord(false, 0, 0, 0);
		assertThat(record.size()).isEqualTo(12);
	}
	@Test
	void asByteArrayWhenIncludeSignatureReturnsByteArray() throws Exception {
		byte[] bytes = new byte[] { //
				0x50, 0x4b, 0x07, 0x08, //
				0x01, 0x00, 0x00, 0x00, //
				0x02, 0x00, 0x00, 0x00, //
				0x03, 0x00, 0x00, 0x00 }; //
		ZipDataDescriptorRecord record = ZipDataDescriptorRecord.load(new ByteArrayDataBlock(bytes), 0);
		assertThat(record.asByteArray()).isEqualTo(bytes);
	}
	@Test
	void asByteArrayWhenNotIncludeSignatureReturnsByteArray() throws Exception {
		byte[] bytes = new byte[] { //
				0x01, 0x00, 0x00, 0x00, //
				0x02, 0x00, 0x00, 0x00, //
				0x03, 0x00, 0x00, 0x00 }; //
		ZipDataDescriptorRecord record = ZipDataDescriptorRecord.load(new ByteArrayDataBlock(bytes), 0);
		assertThat(record.asByteArray()).isEqualTo(bytes);
	}
	@Test
	void isPresentBasedOnFlagWhenPresentReturnsTrue() {
		testIsPresentBasedOnFlag((short) 0x8, true);
	}
	@Test
	void isPresentBasedOnFlagWhenNotPresentReturnsFalse() {
		testIsPresentBasedOnFlag((short) 0x0, false);
	}
	private void testIsPresentBasedOnFlag(short flag, boolean expected) {
		ZipCentralDirectoryFileHeaderRecord centralRecord = new ZipCentralDirectoryFileHeaderRecord(S0, S0, flag, S0,
				S0, S0, S0, S0, S0, S0, S0, S0, S0, S0, S0, S0);
		ZipLocalFileHeaderRecord localRecord = new ZipLocalFileHeaderRecord(S0, flag, S0, S0, S0, S0, S0, S0, S0, S0);
		assertThat(ZipDataDescriptorRecord.isPresentBasedOnFlag(flag)).isEqualTo(expected);
		assertThat(ZipDataDescriptorRecord.isPresentBasedOnFlag(centralRecord)).isEqualTo(expected);
		assertThat(ZipDataDescriptorRecord.isPresentBasedOnFlag(localRecord)).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class Zip64EndOfCentralDirectoryLocatorTests {
	@Test
	void findReturnsRecord() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x50, 0x4b, 0x06, 0x07, //
				0x01, 0x00, 0x00, 0x00, //
				0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x03, 0x00, 0x00, 0x00 }); //
		Zip64EndOfCentralDirectoryLocator eocd = Zip64EndOfCentralDirectoryLocator.find(dataBlock, 20);
		assertThat(eocd.pos()).isEqualTo(0);
		assertThat(eocd.numberOfThisDisk()).isEqualTo(1);
		assertThat(eocd.offsetToZip64EndOfCentralDirectoryRecord()).isEqualTo(2);
		assertThat(eocd.totalNumberOfDisks()).isEqualTo(3);
	}
	@Test
	void findWhenSignatureDoesNotMatchReturnsNull() throws IOException {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x51, 0x4b, 0x06, 0x07, //
				0x01, 0x00, 0x00, 0x00, //
				0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x03, 0x00, 0x00, 0x00 }); //
		Zip64EndOfCentralDirectoryLocator eocd = Zip64EndOfCentralDirectoryLocator.find(dataBlock, 20);
		assertThat(eocd).isNull();
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class ZipStringTests {
	@ParameterizedTest
	@EnumSource
	void hashGeneratesCorrectHashCode(HashSourceType sourceType) throws Exception {
		testHash(sourceType, true, 'abcABC123xyz!');
		testHash(sourceType, false, 'abcABC123xyz!');
	}
	@ParameterizedTest
	@EnumSource
	void hashWhenHasSpecialCharsGeneratesCorrectHashCode(HashSourceType sourceType) throws Exception {
		testHash(sourceType, true, 'special/\u00EB.dat');
	}
	@ParameterizedTest
	@EnumSource
	void hashWhenHasCyrillicCharsGeneratesCorrectHashCode(HashSourceType sourceType) throws Exception {
		testHash(sourceType, true, '\u0432\u0435\u0441\u043D\u0430');
	}
	@ParameterizedTest
	@EnumSource
	void hashWhenHasEmojiGeneratesCorrectHashCode(HashSourceType sourceType) throws Exception {
		testHash(sourceType, true, '\ud83d\udca9');
	}
	@ParameterizedTest
	@EnumSource
	void hashWhenOnlyDifferenceIsEndSlashGeneratesSameHashCode(HashSourceType sourceType) throws Exception {
		testHash(sourceType, '', true, '/'.hashCode());
		testHash(sourceType, '/', true, '/'.hashCode());
		testHash(sourceType, 'a/b', true, 'a/b/'.hashCode());
		testHash(sourceType, 'a/b/', true, 'a/b/'.hashCode());
	}
	void testHash(HashSourceType sourceType, boolean addSlash, String source) throws Exception {
		String expected = (addSlash && !source.endsWith('/')) ? source + '/' : source;
		testHash(sourceType, source, addSlash, expected.hashCode());
	}
	void testHash(HashSourceType sourceType, String source, boolean addEndSlash, int expected) throws Exception {
		switch (sourceType) {
			case STRING -> {
				assertThat(ZipString.hash(source, addEndSlash)).isEqualTo(expected);
			}
			case CHAR_SEQUENCE -> {
				CharSequence charSequence = new StringBuilder(source);
				assertThat(ZipString.hash(charSequence, addEndSlash)).isEqualTo(expected);
			}
			case DATA_BLOCK -> {
				ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(source.getBytes(StandardCharsets.UTF_8));
				assertThat(ZipString.hash(null, dataBlock, 0, (int) dataBlock.size(), addEndSlash)).isEqualTo(expected);
			}
			case SINGLE_BYTE_READ_DATA_BLOCK -> {
				ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(source.getBytes(StandardCharsets.UTF_8), 1);
				assertThat(ZipString.hash(null, dataBlock, 0, (int) dataBlock.size(), addEndSlash)).isEqualTo(expected);
			}
		}
	}
	@Test
	void matchesWhenExactMatchReturnsTrue() throws Exception {
		assertMatches('one/two/three', 'one/two/three', false).isTrue();
	}
	@Test
	void matchesWhenNotMatchWithSameLengthReturnsFalse() throws Exception {
		assertMatches('one/two/three', 'one/too/three', false).isFalse();
	}
	@Test
	void matchesWhenExactMatchWithSpecialCharsReturnsTrue() throws Exception {
		assertMatches('special/\u00EB.dat', 'special/\u00EB.dat', false).isTrue();
	}
	@Test
	void matchesWhenExactMatchWithCyrillicCharsReturnsTrue() throws Exception {
		assertMatches('\u0432\u0435\u0441\u043D\u0430', '\u0432\u0435\u0441\u043D\u0430', false).isTrue();
	}
	@Test
	void matchesWhenNoMatchWithCyrillicCharsReturnsFalse() throws Exception {
		assertMatches('\u0432\u0435\u0441\u043D\u0430', '\u0432\u0435\u0441\u043D\u043D', false).isFalse();
	}
	@Test
	void matchesWhenExactMatchWithEmojiCharsReturnsTrue() throws Exception {
		assertMatches('\ud83d\udca9', '\ud83d\udca9', false).isTrue();
	}
	@Test
	void matchesWithAddSlash() throws Exception {
		assertMatches('META-INF/MANFIFEST.MF', 'META-INF/MANFIFEST.MF', true).isTrue();
		assertMatches('one/two/three/', 'one/two/three', true).isTrue();
		assertMatches('one/two/three', 'one/two/three/', true).isFalse();
		assertMatches('one/two/three/', 'one/too/three', true).isFalse();
		assertMatches('one/two/three', 'one/too/three/', true).isFalse();
		assertMatches('one/two/three//', 'one/two/three', true).isFalse();
		assertMatches('one/two/three', 'one/two/three//', true).isFalse();
	}
	@Test
	void matchesWhenDataBlockShorterThenCharSequenceReturnsFalse() throws Exception {
		assertMatches('one/two/thre', 'one/two/three', false).isFalse();
	}
	@Test
	void matchesWhenCharSequenceShorterThanDataBlockReturnsFalse() throws Exception {
		assertMatches('one/two/three', 'one/two/thre', false).isFalse();
	}
	@Test
	void startsWithWhenStartsWith() throws Exception {
		assertStartsWith('one/two', 'one/').isEqualTo(4);
	}
	@Test
	void startsWithWhenExact() throws Exception {
		assertStartsWith('one/', 'one/').isEqualTo(4);
	}
	@Test
	void startsWithWhenTooShort() throws Exception {
		assertStartsWith('one/two', 'one/two/three/').isEqualTo(-1);
	}
	@Test
	void startsWithWhenDoesNotStartWith() throws Exception {
		assertStartsWith('one/three/', 'one/two/').isEqualTo(-1);
	}
	@Test
	void zipStringWhenMultiCodePointAtBufferBoundary() throws Exception {
		StringBuilder source = new StringBuilder();
		source.append('A'.repeat(ZipString.BUFFER_SIZE - 1));
		source.append('\u1EFF');
		String charSequence = source.toString();
		source.append('suffix');
		assertStartsWith(source.toString(), charSequence);
	}
	private AbstractBooleanAssert<?> assertMatches(String source, CharSequence charSequence, boolean addSlash)
			throws Exception {
		ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(source.getBytes(StandardCharsets.UTF_8));
		return assertThat(ZipString.matches(null, dataBlock, 0, (int) dataBlock.size(), charSequence, addSlash));
	}
	private AbstractIntegerAssert<?> assertStartsWith(String source, CharSequence charSequence) throws IOException {
		ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(source.getBytes(StandardCharsets.UTF_8));
		return assertThat(ZipString.startsWith(null, dataBlock, 0, (int) dataBlock.size(), charSequence));
	}
	enum HashSourceType {
		STRING, CHAR_SEQUENCE, DATA_BLOCK, SINGLE_BYTE_READ_DATA_BLOCK
	}
}
/*
package org.springframework.boot.loader.zip;
/**
@AssertFileChannelDataBlocksClosed
class VirtualZipDataBlockTests {
	@TempDir
	File tempDir;
	private File file;
	@BeforeEach
	void setup() throws Exception {
		this.file = new File(this.tempDir, 'test.jar');
		TestJar.create(this.file);
	}
	@Test
	void createContainsValidZipContent() throws IOException {
		FileDataBlock data = new FileDataBlock(this.file.toPath());
		data.open();
		List<ZipCentralDirectoryFileHeaderRecord> centralRecords = new ArrayList<>();
		List<Long> centralRecordPositions = new ArrayList<>();
		ZipEndOfCentralDirectoryRecord eocd = ZipEndOfCentralDirectoryRecord.load(data).endOfCentralDirectoryRecord();
		long pos = eocd.offsetToStartOfCentralDirectory();
		for (int i = 0; i < eocd.totalNumberOfCentralDirectoryEntries(); i++) {
			ZipCentralDirectoryFileHeaderRecord centralRecord = ZipCentralDirectoryFileHeaderRecord.load(data, pos);
			String name = ZipString.readString(data, pos + ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET,
					centralRecord.fileNameLength());
			if (name.endsWith('.jar')) {
				centralRecords.add(centralRecord);
				centralRecordPositions.add(pos);
			}
			pos += centralRecord.size();
		}
		NameOffsetLookups nameOffsetLookups = new NameOffsetLookups(2, centralRecords.size());
		for (int i = 0; i < centralRecords.size(); i++) {
			nameOffsetLookups.enable(i, true);
		}
		nameOffsetLookups.enable(0, true);
		File outputFile = new File(this.tempDir, 'out.jar');
		try (VirtualZipDataBlock block = new VirtualZipDataBlock(data, nameOffsetLookups,
				centralRecords.toArray(ZipCentralDirectoryFileHeaderRecord[]::new),
				centralRecordPositions.stream().mapToLong(Long::longValue).toArray())) {
			try (FileOutputStream out = new FileOutputStream(outputFile)) {
				block.asInputStream().transferTo(out);
			}
		}
		try (FileSystem fileSystem = FileSystems.newFileSystem(outputFile.toPath())) {
			assertThatExceptionOfType(NoSuchFileException.class)
				.isThrownBy(() -> Files.size(fileSystem.getPath('nessted.jar')));
			assertThat(Files.size(fileSystem.getPath('sted.jar'))).isGreaterThan(0);
			assertThat(Files.size(fileSystem.getPath('other-nested.jar'))).isGreaterThan(0);
			assertThat(Files.size(fileSystem.getPath('ace nested.jar'))).isGreaterThan(0);
			assertThat(Files.size(fileSystem.getPath('lti-release.jar'))).isGreaterThan(0);
		}
	}
	@Test // gh-38063
	void createWithDescriptorRecordContainsValidZipContent() throws Exception {
		try (ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(this.file))) {
			ZipEntry entry = new ZipEntry('META-INF/');
			entry.setMethod(ZipEntry.DEFLATED);
			zip.putNextEntry(entry);
			zip.write(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 });
			zip.closeEntry();
		}
		byte[] bytes = Files.readAllBytes(this.file.toPath());
		CloseableDataBlock data = new ByteArrayDataBlock(bytes);
		List<ZipCentralDirectoryFileHeaderRecord> centralRecords = new ArrayList<>();
		List<Long> centralRecordPositions = new ArrayList<>();
		ZipEndOfCentralDirectoryRecord eocd = ZipEndOfCentralDirectoryRecord.load(data).endOfCentralDirectoryRecord();
		long pos = eocd.offsetToStartOfCentralDirectory();
		for (int i = 0; i < eocd.totalNumberOfCentralDirectoryEntries(); i++) {
			ZipCentralDirectoryFileHeaderRecord centralRecord = ZipCentralDirectoryFileHeaderRecord.load(data, pos);
			centralRecords.add(centralRecord);
			centralRecordPositions.add(pos);
			pos += centralRecord.size();
		}
		NameOffsetLookups nameOffsetLookups = new NameOffsetLookups(0, centralRecords.size());
		for (int i = 0; i < centralRecords.size(); i++) {
			nameOffsetLookups.enable(i, true);
		}
		nameOffsetLookups.enable(0, true);
		File outputFile = new File(this.tempDir, 'out.jar');
		try (VirtualZipDataBlock block = new VirtualZipDataBlock(data, nameOffsetLookups,
				centralRecords.toArray(ZipCentralDirectoryFileHeaderRecord[]::new),
				centralRecordPositions.stream().mapToLong(Long::longValue).toArray())) {
			try (FileOutputStream out = new FileOutputStream(outputFile)) {
				block.asInputStream().transferTo(out);
			}
		}
		byte[] virtualBytes = Files.readAllBytes(outputFile.toPath());
		assertThat(bytes).isEqualTo(virtualBytes);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
public final class FileChannelDataBlockManagedFileChannel {
	private FileChannelDataBlockManagedFileChannel() {
	}
	public static int BUFFER_SIZE = FileDataBlock.FileAccess.BUFFER_SIZE;
}
/*
package org.springframework.boot.loader.zip;
/**
class ZipEndOfCentralDirectoryRecordTests {
	@Test
	void loadLocatesAndLoadsData() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x50, 0x4b, 0x05, 0x06, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, 0x00, 0x00, //
				0x06, 0x00, 0x00, 0x00, //
				0x07, 0x00 }); //
		ZipEndOfCentralDirectoryRecord.Located located = ZipEndOfCentralDirectoryRecord.load(dataBlock);
		assertThat(located.pos()).isEqualTo(0L);
		ZipEndOfCentralDirectoryRecord record = located.endOfCentralDirectoryRecord();
		assertThat(record.numberOfThisDisk()).isEqualTo((short) 1);
		assertThat(record.diskWhereCentralDirectoryStarts()).isEqualTo((short) 2);
		assertThat(record.numberOfCentralDirectoryEntriesOnThisDisk()).isEqualTo((short) 3);
		assertThat(record.totalNumberOfCentralDirectoryEntries()).isEqualTo((short) 4);
		assertThat(record.sizeOfCentralDirectory()).isEqualTo(5);
		assertThat(record.offsetToStartOfCentralDirectory()).isEqualTo(6);
		assertThat(record.commentLength()).isEqualTo((short) 7);
	}
	@Test
	void loadWhenMultipleBuffersBackLoadsData() throws Exception {
		byte[] bytes = new byte[ZipEndOfCentralDirectoryRecord.BUFFER_SIZE * 4];
		byte[] data = new byte[] { //
				0x50, 0x4b, 0x05, 0x06, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, 0x00, 0x00, //
				0x06, 0x00, 0x00, 0x00, //
				0x07, 0x00 }; //
		System.arraycopy(data, 0, bytes, 4, data.length);
		ZipEndOfCentralDirectoryRecord.Located located = ZipEndOfCentralDirectoryRecord
			.load(new ByteArrayDataBlock(bytes));
		assertThat(located.pos()).isEqualTo(4L);
	}
	@Test
	void loadWhenSignatureDoesNotMatchThrowsException() {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x51, 0x4b, 0x05, 0x06, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, 0x00, 0x00, //
				0x06, 0x00, 0x00, 0x00, //
				0x07, 0x00 }); //
		assertThatIOException().isThrownBy(() -> ZipEndOfCentralDirectoryRecord.load(dataBlock))
			.withMessageContaining('"End Of Central Directory Record" not found');
	}
	@Test
	void asByteArrayReturnsByteArray() throws Exception {
		byte[] bytes = new byte[] { //
				0x50, 0x4b, 0x05, 0x06, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, 0x00, 0x00, //
				0x06, 0x00, 0x00, 0x00, //
				0x07, 0x00 }; //
		ZipEndOfCentralDirectoryRecord.Located located = ZipEndOfCentralDirectoryRecord
			.load(new ByteArrayDataBlock(bytes));
		assertThat(located.endOfCentralDirectoryRecord().asByteArray()).isEqualTo(bytes);
	}
	@Test
	void sizeReturnsSize() {
		ZipEndOfCentralDirectoryRecord record = new ZipEndOfCentralDirectoryRecord((short) 1, (short) 2, (short) 3,
				(short) 4, 5, 6, (short) 7);
		assertThat(record.size()).isEqualTo(29L);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class VirtualDataBlockTests {
	private VirtualDataBlock virtualDataBlock;
	@BeforeEach
	void setup() throws IOException {
		List<DataBlock> subsections = new ArrayList<>();
		subsections.add(new ByteArrayDataBlock('abc'.getBytes(StandardCharsets.UTF_8)));
		subsections.add(new ByteArrayDataBlock('defg'.getBytes(StandardCharsets.UTF_8)));
		subsections.add(new ByteArrayDataBlock('h'.getBytes(StandardCharsets.UTF_8)));
		this.virtualDataBlock = new VirtualDataBlock(subsections);
	}
	@Test
	void sizeReturnsSize() throws IOException {
		assertThat(this.virtualDataBlock.size()).isEqualTo(8);
	}
	@Test
	void readFullyReadsAllBlocks() throws IOException {
		ByteBuffer dst = ByteBuffer.allocate((int) this.virtualDataBlock.size());
		this.virtualDataBlock.readFully(dst, 0);
		assertThat(dst.array()).containsExactly('abcdefgh'.getBytes(StandardCharsets.UTF_8));
	}
	@Test
	void readWithShortBlock() throws IOException {
		ByteBuffer dst = ByteBuffer.allocate(2);
		assertThat(this.virtualDataBlock.read(dst, 1)).isEqualTo(2);
		assertThat(dst.array()).containsExactly('bc'.getBytes(StandardCharsets.UTF_8));
	}
	@Test
	void readWithShortBlockAcrossSubsections() throws IOException {
		ByteBuffer dst = ByteBuffer.allocate(3);
		assertThat(this.virtualDataBlock.read(dst, 2)).isEqualTo(3);
		assertThat(dst.array()).containsExactly('cde'.getBytes(StandardCharsets.UTF_8));
	}
	@Test
	void readWithBigBlock() throws IOException {
		ByteBuffer dst = ByteBuffer.allocate(16);
		assertThat(this.virtualDataBlock.read(dst, 1)).isEqualTo(7);
		assertThat(dst.array()).startsWith('bcdefgh'.getBytes(StandardCharsets.UTF_8));
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class ByteArrayDataBlockTests {
	private final byte[] BYTES = { 0, 1, 2, 3, 4, 5, 6, 7 };
	@Test
	void sizeReturnsByteArrayLength() throws Exception {
		try (ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(this.BYTES)) {
			assertThat(dataBlock.size()).isEqualTo(this.BYTES.length);
		}
	}
	@Test
	void readPutsBytes() throws Exception {
		try (ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(this.BYTES)) {
			ByteBuffer dst = ByteBuffer.allocate(8);
			int result = dataBlock.read(dst, 0);
			assertThat(result).isEqualTo(8);
			assertThat(dst.array()).containsExactly(this.BYTES);
		}
	}
	@Test
	void readWhenLessBytesThanRemainingInBufferPutsBytes() throws Exception {
		try (ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(this.BYTES)) {
			ByteBuffer dst = ByteBuffer.allocate(9);
			int result = dataBlock.read(dst, 0);
			assertThat(result).isEqualTo(8);
			assertThat(dst.array()).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 0);
		}
	}
	@Test
	void readWhenLessRemainingInBufferThanLengthPutsBytes() throws Exception {
		try (ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(this.BYTES)) {
			ByteBuffer dst = ByteBuffer.allocate(7);
			int result = dataBlock.read(dst, 0);
			assertThat(result).isEqualTo(7);
			assertThat(dst.array()).containsExactly(0, 1, 2, 3, 4, 5, 6);
		}
	}
	@Test
	void readWhenHasPosOffsetReadsBytes() throws Exception {
		try (ByteArrayDataBlock dataBlock = new ByteArrayDataBlock(this.BYTES)) {
			ByteBuffer dst = ByteBuffer.allocate(3);
			int result = dataBlock.read(dst, 4);
			assertThat(result).isEqualTo(3);
			assertThat(dst.array()).containsExactly(4, 5, 6);
		}
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class AssertFileChannelDataBlocksClosedExtension implements BeforeEachCallback, AfterEachCallback {
	private static OpenFilesTracker tracker = new OpenFilesTracker();
	@Override
	public void beforeEach(ExtensionContext context) throws Exception {
		tracker.clear();
		FileDataBlock.tracker = tracker;
		DefaultCleanerTracking.set(tracker::addedCleanable);
	}
	@Override
	public void afterEach(ExtensionContext context) throws Exception {
		tracker.assertAllClosed();
		FileDataBlock.tracker = Tracker.NONE;
	}
	private static final class OpenFilesTracker implements Tracker {
		private final Set<Path> paths = new LinkedHashSet<>();
		private final List<Cleanable> clean = new ArrayList<>();
		private final List<Closeable> close = new ArrayList<>();
		@Override
		public void openedFileChannel(Path path) {
			this.paths.add(path);
		}
		@Override
		public void closedFileChannel(Path path) {
			this.paths.remove(path);
		}
		void clear() {
			this.paths.clear();
			this.clean.clear();
		}
		void assertAllClosed() throws IOException {
			for (Closeable closeable : this.close) {
				closeable.close();
			}
			this.clean.forEach(Cleanable::clean);
			assertThat(this.paths).as('open paths').isEmpty();
		}
		private void addedCleanable(Object obj, Cleanable cleanable) {
			if (cleanable != null) {
				this.clean.add(cleanable);
			}
			if (obj instanceof Closeable closeable) {
				this.close.add(closeable);
			}
		}
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class ZipCentralDirectoryFileHeaderRecordTests {
	@Test
	void loadLoadsData() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x50, 0x4b, 0x01, 0x02, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, //
				0x06, 0x00, //
				0x07, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, //
				0x09, 0x00, 0x00, 0x00, //
				0x0A, 0x00, //
				0x0B, 0x00, //
				0x0C, 0x00, //
				0x0D, 0x00, //
				0x0E, 0x00, //
				0x0F, 0x00, 0x00, 0x00, //
				0x10, 0x00, 0x00, 0x00 }); //
		ZipCentralDirectoryFileHeaderRecord record = ZipCentralDirectoryFileHeaderRecord.load(dataBlock, 0);
		assertThat(record.versionMadeBy()).isEqualTo((short) 1);
		assertThat(record.versionNeededToExtract()).isEqualTo((short) 2);
		assertThat(record.generalPurposeBitFlag()).isEqualTo((short) 3);
		assertThat(record.compressionMethod()).isEqualTo((short) 4);
		assertThat(record.lastModFileTime()).isEqualTo((short) 5);
		assertThat(record.lastModFileDate()).isEqualTo((short) 6);
		assertThat(record.crc32()).isEqualTo(7);
		assertThat(record.compressedSize()).isEqualTo(8);
		assertThat(record.uncompressedSize()).isEqualTo(9);
		assertThat(record.fileNameLength()).isEqualTo((short) 10);
		assertThat(record.extraFieldLength()).isEqualTo((short) 11);
		assertThat(record.fileCommentLength()).isEqualTo((short) 12);
		assertThat(record.diskNumberStart()).isEqualTo((short) 13);
		assertThat(record.internalFileAttributes()).isEqualTo((short) 14);
		assertThat(record.externalFileAttributes()).isEqualTo(15);
		assertThat(record.offsetToLocalHeader()).isEqualTo(16);
	}
	@Test
	void loadWhenSignatureDoesNotMatchThrowsException() {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x51, 0x4b, 0x01, 0x02, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, //
				0x06, 0x00, //
				0x07, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, //
				0x09, 0x00, 0x00, 0x00, //
				0x0A, 0x00, //
				0x0B, 0x00, //
				0x0C, 0x00, //
				0x0D, 0x00, //
				0x0E, 0x00, //
				0x0F, 0x00, 0x00, 0x00, //
				0x10, 0x00, 0x00, 0x00 }); //
		assertThatIOException().isThrownBy(() -> ZipCentralDirectoryFileHeaderRecord.load(dataBlock, 0))
			.withMessageContaining('"Central Directory File Header Record" not found');
	}
	@Test
	void sizeReturnsSize() {
		ZipCentralDirectoryFileHeaderRecord record = new ZipCentralDirectoryFileHeaderRecord((short) 1, (short) 2,
				(short) 3, (short) 4, (short) 5, (short) 6, 7, 8, 9, (short) 10, (short) 11, (short) 12, (short) 13,
				(short) 14, 15, 16);
		assertThat(record.size()).isEqualTo(79L);
	}
	@Test
	void copyToCopiesDataToZipEntry() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x50, 0x4b, 0x01, 0x02, //
				0x00, 0x00, //
				0x00, 0x00, //
				0x00, 0x00, //
				0x08, 0x00, //
				0x23, 0x74, //
				0x58, 0x36, //
				(byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, //
				0x01, 0x00, 0x00, 0x00, //
				0x02, 0x00, 0x00, 0x00, //
				0x01, 0x00, //
				0x01, 0x00, //
				0x01, 0x00, //
				0x00, 0x00, //
				0x00, 0x00, //
				0x00, 0x00, 0x00, 0x00, //
				0x00, 0x00, 0x00, 0x00, //
				0x61, //
				0x62, //
				0x63 }); //
		ZipCentralDirectoryFileHeaderRecord record = ZipCentralDirectoryFileHeaderRecord.load(dataBlock, 0);
		ZipEntry entry = new ZipEntry('');
		record.copyTo(dataBlock, 0, entry);
		assertThat(entry.getMethod()).isEqualTo(ZipEntry.DEFLATED);
		assertThat(entry.getTimeLocal()).hasYear(2007);
		ZonedDateTime expectedTime = ZonedDateTime.of(2007, 02, 24, 14, 33, 06, 0, ZoneId.systemDefault());
		assertThat(entry.getTime()).isEqualTo(expectedTime.toEpochSecond() * 1000);
		assertThat(entry.getCrc()).isEqualTo(0xFFFFFFFFL);
		assertThat(entry.getCompressedSize()).isEqualTo(1);
		assertThat(entry.getSize()).isEqualTo(2);
		assertThat(entry.getExtra()).containsExactly(0x62);
		assertThat(entry.getComment()).isEqualTo('c');
	}
	@Test
	void withFileNameLengthReturnsUpdatedInstance() {
		ZipCentralDirectoryFileHeaderRecord record = new ZipCentralDirectoryFileHeaderRecord((short) 1, (short) 2,
				(short) 3, (short) 4, (short) 5, (short) 6, 7, 8, 9, (short) 10, (short) 11, (short) 12, (short) 13,
				(short) 14, 15, 16)
			.withFileNameLength((short) 100);
		assertThat(record.versionMadeBy()).isEqualTo((short) 1);
		assertThat(record.versionNeededToExtract()).isEqualTo((short) 2);
		assertThat(record.generalPurposeBitFlag()).isEqualTo((short) 3);
		assertThat(record.compressionMethod()).isEqualTo((short) 4);
		assertThat(record.lastModFileTime()).isEqualTo((short) 5);
		assertThat(record.lastModFileDate()).isEqualTo((short) 6);
		assertThat(record.crc32()).isEqualTo(7);
		assertThat(record.compressedSize()).isEqualTo(8);
		assertThat(record.uncompressedSize()).isEqualTo(9);
		assertThat(record.fileNameLength()).isEqualTo((short) 100);
		assertThat(record.extraFieldLength()).isEqualTo((short) 11);
		assertThat(record.fileCommentLength()).isEqualTo((short) 12);
		assertThat(record.diskNumberStart()).isEqualTo((short) 13);
		assertThat(record.internalFileAttributes()).isEqualTo((short) 14);
		assertThat(record.externalFileAttributes()).isEqualTo(15);
		assertThat(record.offsetToLocalHeader()).isEqualTo(16);
	}
	@Test
	void withOffsetToLocalHeaderReturnsUpdatedInstance() {
		ZipCentralDirectoryFileHeaderRecord record = new ZipCentralDirectoryFileHeaderRecord((short) 1, (short) 2,
				(short) 3, (short) 4, (short) 5, (short) 6, 7, 8, 9, (short) 10, (short) 11, (short) 12, (short) 13,
				(short) 14, 15, 16)
			.withOffsetToLocalHeader(100);
		assertThat(record.versionMadeBy()).isEqualTo((short) 1);
		assertThat(record.versionNeededToExtract()).isEqualTo((short) 2);
		assertThat(record.generalPurposeBitFlag()).isEqualTo((short) 3);
		assertThat(record.compressionMethod()).isEqualTo((short) 4);
		assertThat(record.lastModFileTime()).isEqualTo((short) 5);
		assertThat(record.lastModFileDate()).isEqualTo((short) 6);
		assertThat(record.crc32()).isEqualTo(7);
		assertThat(record.compressedSize()).isEqualTo(8);
		assertThat(record.uncompressedSize()).isEqualTo(9);
		assertThat(record.fileNameLength()).isEqualTo((short) 10);
		assertThat(record.extraFieldLength()).isEqualTo((short) 11);
		assertThat(record.fileCommentLength()).isEqualTo((short) 12);
		assertThat(record.diskNumberStart()).isEqualTo((short) 13);
		assertThat(record.internalFileAttributes()).isEqualTo((short) 14);
		assertThat(record.externalFileAttributes()).isEqualTo(15);
		assertThat(record.offsetToLocalHeader()).isEqualTo(100);
	}
	@Test
	void asByteArrayReturnsByteArray() throws Exception {
		byte[] bytes = new byte[] { //
				0x50, 0x4b, 0x01, 0x02, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, //
				0x06, 0x00, //
				0x07, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, //
				0x09, 0x00, 0x00, 0x00, //
				0x0A, 0x00, //
				0x0B, 0x00, //
				0x0C, 0x00, //
				0x0D, 0x00, //
				0x0E, 0x00, //
				0x0F, 0x00, 0x00, 0x00, //
				0x10, 0x00, 0x00, 0x00 };
		DataBlock dataBlock = new ByteArrayDataBlock(bytes);
		ZipCentralDirectoryFileHeaderRecord record = ZipCentralDirectoryFileHeaderRecord.load(dataBlock, 0);
		assertThat(record.asByteArray()).containsExactly(bytes);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
@Disabled('Only used for manual testing')
class VirtualZipPerformanceTests {
	@TempDir
	Path temp;
	@Test
	void sequentialReadPerformace() throws IOException {
		File file = createZipWithLargeEntries();
		long start = System.nanoTime();
		try (ZipContent zipContent = ZipContent.open(file.toPath(), 'test/')) {
			try (InputStream in = zipContent.openRawZipData().asInputStream()) {
				ZipInputStream zip = new ZipInputStream(in);
				ZipEntry entry = zip.getNextEntry();
				while (entry != null) {
					entry = zip.getNextEntry();
				}
			}
		}
		System.out.println(TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
	}
	private File createZipWithLargeEntries() throws IOException {
		byte[] bytes = new byte[1024 * 1024];
		new Random().nextBytes(bytes);
		File file = this.temp.resolve('test.zip').toFile();
		try (ZipOutputStream out = new ZipOutputStream(new FileOutputStream(file))) {
			out.putNextEntry(new ZipEntry('test/'));
			out.closeEntry();
			for (int i = 0; i < 50; i++) {
				out.putNextEntry(new ZipEntry('test/' + i + '.dat'));
				out.write(bytes);
				out.closeEntry();
			}
		}
		return file;
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class DataBlockInputStreamTests {
	private ByteArrayDataBlock dataBlock;
	private InputStream inputStream;
	@BeforeEach
	void setup() throws Exception {
		this.dataBlock = new ByteArrayDataBlock(new byte[] { 0, 1, 2 });
		this.inputStream = this.dataBlock.asInputStream();
	}
	@Test
	void readSingleByteReadsByte() throws Exception {
		assertThat(this.inputStream.read()).isEqualTo(0);
		assertThat(this.inputStream.read()).isEqualTo(1);
		assertThat(this.inputStream.read()).isEqualTo(2);
		assertThat(this.inputStream.read()).isEqualTo(-1);
	}
	@Test
	void readByteArrayWhenNotOpenThrowsException() throws Exception {
		byte[] bytes = new byte[10];
		this.inputStream.close();
		assertThatIOException().isThrownBy(() -> this.inputStream.read(bytes)).withMessage('InputStream closed');
	}
	@Test
	void readByteArrayWhenReadingMultipleTimesReadsBytes() throws Exception {
		byte[] bytes = new byte[3];
		assertThat(this.inputStream.read(bytes, 0, 2)).isEqualTo(2);
		assertThat(this.inputStream.read(bytes, 2, 1)).isEqualTo(1);
		assertThat(bytes).containsExactly(0, 1, 2);
	}
	@Test
	void readByteArrayWhenReadingMoreThanAvailableReadsRemainingBytes() throws Exception {
		byte[] bytes = new byte[5];
		assertThat(this.inputStream.read(bytes, 0, 5)).isEqualTo(3);
		assertThat(bytes).containsExactly(0, 1, 2, 0, 0);
	}
	@Test
	void skipSkipsBytes() throws Exception {
		assertThat(this.inputStream.skip(2)).isEqualTo(2);
		assertThat(this.inputStream.read()).isEqualTo(2);
		assertThat(this.inputStream.read()).isEqualTo(-1);
	}
	@Test
	void skipWhenSkippingMoreThanRemainingSkipsBytes() throws Exception {
		assertThat(this.inputStream.skip(100)).isEqualTo(3);
		assertThat(this.inputStream.read()).isEqualTo(-1);
	}
	@Test
	void skipBackwardsSkipsBytes() throws IOException {
		assertThat(this.inputStream.skip(2)).isEqualTo(2);
		assertThat(this.inputStream.skip(-1)).isEqualTo(-1);
		assertThat(this.inputStream.read()).isEqualTo(1);
	}
	@Test
	void skipBackwardsPastBeginningSkipsBytes() throws Exception {
		assertThat(this.inputStream.skip(1)).isEqualTo(1);
		assertThat(this.inputStream.skip(-100)).isEqualTo(-1);
		assertThat(this.inputStream.read()).isEqualTo(0);
	}
	@Test
	void availableReturnsRemainingBytes() throws IOException {
		assertThat(this.inputStream.available()).isEqualTo(3);
		this.inputStream.read();
		assertThat(this.inputStream.available()).isEqualTo(2);
		this.inputStream.skip(1);
		assertThat(this.inputStream.available()).isEqualTo(1);
	}
	@Test
	void availableWhenClosedReturnsZero() throws IOException {
		this.inputStream.close();
		assertThat(this.inputStream.available()).isZero();
	}
	@Test
	void closeClosesDataBlock() throws Exception {
		this.dataBlock = spy(new ByteArrayDataBlock(new byte[] { 0, 1, 2 }));
		this.inputStream = this.dataBlock.asInputStream();
		this.inputStream.close();
		then(this.dataBlock).should().close();
	}
	@Test
	void closeMultipleTimesClosesDataBlockOnce() throws Exception {
		this.dataBlock = spy(new ByteArrayDataBlock(new byte[] { 0, 1, 2 }));
		this.inputStream = this.dataBlock.asInputStream();
		this.inputStream.close();
		this.inputStream.close();
		then(this.dataBlock).should(times(1)).close();
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class DataBlockTests {
	@Test
	void readFullyReadsAllBytesByCallingReadMultipleTimes() throws IOException {
		DataBlock dataBlock = mock(DataBlock.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));
		given(dataBlock.read(any(), anyLong()))
			.will(putBytes(new byte[] { 0, 1 }, new byte[] { 2 }, new byte[] { 3, 4, 5 }));
		ByteBuffer dst = ByteBuffer.allocate(6);
		dataBlock.readFully(dst, 0);
		assertThat(dst.array()).containsExactly(0, 1, 2, 3, 4, 5);
	}
	private Answer<?> putBytes(byte[]... bytes) {
		AtomicInteger count = new AtomicInteger();
		return (invocation) -> {
			int index = count.getAndIncrement();
			invocation.getArgument(0, ByteBuffer.class).put(bytes[index]);
			return bytes.length;
		};
	}
	@Test
	void readFullyWhenReadReturnsNegativeResultThrowsException() throws Exception {
		DataBlock dataBlock = mock(DataBlock.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));
		given(dataBlock.read(any(), anyLong())).willReturn(-1);
		ByteBuffer dst = ByteBuffer.allocate(8);
		assertThatExceptionOfType(EOFException.class).isThrownBy(() -> dataBlock.readFully(dst, 0));
	}
	@Test
	void asInputStreamReturnsDataBlockInputStream() throws Exception {
		DataBlock dataBlock = mock(DataBlock.class, withSettings().defaultAnswer(CALLS_REAL_METHODS));
		assertThat(dataBlock.asInputStream()).isInstanceOf(DataBlockInputStream.class);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class Zip64EndOfCentralDirectoryRecordTests {
	@Test
	void loadLoadsData() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x50, 0x4b, 0x06, 0x06, //
				0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, 0x00, 0x00, //
				0x05, 0x00, 0x00, 0x00, //
				0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }); //
		Zip64EndOfCentralDirectoryLocator locator = new Zip64EndOfCentralDirectoryLocator(56, 0, 0, 0);
		Zip64EndOfCentralDirectoryRecord eocd = Zip64EndOfCentralDirectoryRecord.load(dataBlock, locator);
		assertThat(eocd.size()).isEqualTo(56);
		assertThat(eocd.sizeOfZip64EndOfCentralDirectoryRecord()).isEqualTo(1);
		assertThat(eocd.versionMadeBy()).isEqualTo((short) 2);
		assertThat(eocd.versionNeededToExtract()).isEqualTo((short) 3);
		assertThat(eocd.numberOfThisDisk()).isEqualTo(4);
		assertThat(eocd.diskWhereCentralDirectoryStarts()).isEqualTo(5);
		assertThat(eocd.numberOfCentralDirectoryEntriesOnThisDisk()).isEqualTo(6);
		assertThat(eocd.totalNumberOfCentralDirectoryEntries()).isEqualTo(7);
		assertThat(eocd.sizeOfCentralDirectory()).isEqualTo(8);
		assertThat(eocd.offsetToStartOfCentralDirectory());
	}
	@Test
	void loadWhenSignatureDoesNotMatchThrowsException() {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x51, 0x4b, 0x06, 0x06, //
				0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, 0x00, 0x00, //
				0x05, 0x00, 0x00, 0x00, //
				0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //
				0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }); //
		Zip64EndOfCentralDirectoryLocator locator = new Zip64EndOfCentralDirectoryLocator(56, 0, 0, 0);
		assertThatIOException().isThrownBy(() -> Zip64EndOfCentralDirectoryRecord.load(dataBlock, locator))
			.withMessageContaining('Zip64 "End Of Central Directory Record" not found at position');
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class FileDataBlockTests {
	private static final byte[] CONTENT = new byte[] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05 };
	@TempDir
	File tempDir;
	File tempFile;
	@BeforeEach
	void writeTempFile() throws IOException {
		this.tempFile = new File(this.tempDir, 'content');
		Files.write(this.tempFile.toPath(), CONTENT);
	}
	@AfterEach
	void resetTracker() {
		FileDataBlock.tracker = Tracker.NONE;
	}
	@Test
	void sizeReturnsFileSize() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			assertThat(block.size()).isEqualTo(CONTENT.length);
		}
	}
	@Test
	void readReadsFile() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			ByteBuffer buffer = ByteBuffer.allocate(CONTENT.length);
			assertThat(block.read(buffer, 0)).isEqualTo(6);
			assertThat(buffer.array()).containsExactly(CONTENT);
		}
	}
	@Test
	void readReadsFileWhenThreadHasBeenInterrupted() throws IOException {
		Files.write(this.tempFile.toPath(), CONTENT);
		try (FileDataBlock block = createAndOpenBlock()) {
			ByteBuffer buffer = ByteBuffer.allocate(CONTENT.length);
			Thread.currentThread().interrupt();
			assertThat(block.read(buffer, 0)).isEqualTo(6);
			assertThat(buffer.array()).containsExactly(CONTENT);
		}
		finally {
			Thread.interrupted();
		}
	}
	@Test
	void readDoesNotReadPastEndOfFile() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			ByteBuffer buffer = ByteBuffer.allocate(CONTENT.length);
			assertThat(block.read(buffer, 2)).isEqualTo(4);
			assertThat(buffer.array()).containsExactly(0x02, 0x03, 0x04, 0x05, 0x0, 0x0);
		}
	}
	@Test
	void readWhenPosAtSizeReturnsMinusOne() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			ByteBuffer buffer = ByteBuffer.allocate(CONTENT.length);
			assertThat(block.read(buffer, 6)).isEqualTo(-1);
		}
	}
	@Test
	void readWhenPosOverSizeReturnsMinusOne() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			ByteBuffer buffer = ByteBuffer.allocate(CONTENT.length);
			assertThat(block.read(buffer, 7)).isEqualTo(-1);
		}
	}
	@Test
	void readWhenPosIsNegativeThrowsException() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			ByteBuffer buffer = ByteBuffer.allocate(CONTENT.length);
			assertThatIllegalArgumentException().isThrownBy(() -> block.read(buffer, -1));
		}
	}
	@Test
	void sliceWhenOffsetIsNegativeThrowsException() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			assertThatIllegalArgumentException().isThrownBy(() -> block.slice(-1, 0))
				.withMessage('Offset must not be negative');
		}
	}
	@Test
	void sliceWhenSizeIsNegativeThrowsException() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			assertThatIllegalArgumentException().isThrownBy(() -> block.slice(0, -1))
				.withMessage('Size must not be negative and must be within bounds');
		}
	}
	@Test
	void sliceWhenSizeIsOutOfBoundsThrowsException() throws IOException {
		try (FileDataBlock block = createAndOpenBlock()) {
			assertThatIllegalArgumentException().isThrownBy(() -> block.slice(2, 5))
				.withMessage('Size must not be negative and must be within bounds');
		}
	}
	@Test
	void sliceReturnsSlice() throws IOException {
		try (FileDataBlock slice = createAndOpenBlock().slice(1, 4)) {
			assertThat(slice.size()).isEqualTo(4);
			ByteBuffer buffer = ByteBuffer.allocate(4);
			assertThat(slice.read(buffer, 0)).isEqualTo(4);
			assertThat(buffer.array()).containsExactly(0x01, 0x02, 0x03, 0x04);
		}
	}
	@Test
	void openAndCloseHandleReferenceCounting() throws IOException {
		TestTracker tracker = new TestTracker();
		FileDataBlock.tracker = tracker;
		FileDataBlock block = createBlock();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(0);
		tracker.assertOpenCloseCounts(0, 0);
		block.open();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(1);
		tracker.assertOpenCloseCounts(1, 0);
		block.open();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(2);
		tracker.assertOpenCloseCounts(1, 0);
		block.close();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(1);
		tracker.assertOpenCloseCounts(1, 0);
		block.close();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(0);
		tracker.assertOpenCloseCounts(1, 1);
		block.open();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(1);
		tracker.assertOpenCloseCounts(2, 1);
		block.close();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(0);
		tracker.assertOpenCloseCounts(2, 2);
	}
	@Test
	void openAndCloseSliceHandleReferenceCounting() throws IOException {
		TestTracker tracker = new TestTracker();
		FileDataBlock.tracker = tracker;
		FileDataBlock block = createBlock();
		FileDataBlock slice = block.slice(1, 4);
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(0);
		tracker.assertOpenCloseCounts(0, 0);
		block.open();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(1);
		tracker.assertOpenCloseCounts(1, 0);
		slice.open();
		assertThat(slice).extracting('fileAccess.referenceCount').isEqualTo(2);
		tracker.assertOpenCloseCounts(1, 0);
		slice.open();
		assertThat(slice).extracting('fileAccess.referenceCount').isEqualTo(3);
		tracker.assertOpenCloseCounts(1, 0);
		slice.close();
		assertThat(slice).extracting('fileAccess.referenceCount').isEqualTo(2);
		tracker.assertOpenCloseCounts(1, 0);
		slice.close();
		assertThat(slice).extracting('fileAccess.referenceCount').isEqualTo(1);
		tracker.assertOpenCloseCounts(1, 0);
		block.close();
		assertThat(block).extracting('fileAccess.referenceCount').isEqualTo(0);
		tracker.assertOpenCloseCounts(1, 1);
		slice.open();
		assertThat(slice).extracting('fileAccess.referenceCount').isEqualTo(1);
		tracker.assertOpenCloseCounts(2, 1);
		slice.close();
		assertThat(slice).extracting('fileAccess.referenceCount').isEqualTo(0);
		tracker.assertOpenCloseCounts(2, 2);
	}
	private FileDataBlock createAndOpenBlock() throws IOException {
		FileDataBlock block = createBlock();
		block.open();
		return block;
	}
	private FileDataBlock createBlock() throws IOException {
		return new FileDataBlock(this.tempFile.toPath());
	}
	static class TestTracker implements Tracker {
		private int openCount;
		private int closeCount;
		@Override
		public void openedFileChannel(Path path) {
			this.openCount++;
		}
		@Override
		public void closedFileChannel(Path path) {
			this.closeCount++;
		}
		void assertOpenCloseCounts(int expectedOpenCount, int expectedCloseCount) {
			assertThat(this.openCount).as('openCount').isEqualTo(expectedOpenCount);
			assertThat(this.closeCount).as('closeCount').isEqualTo(expectedCloseCount);
		}
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class ZipLocalFileHeaderRecordTests {
	@Test
	void loadLoadsData() throws Exception {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x50, 0x4b, 0x03, 0x04, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, //
				0x06, 0x00, 0x00, 0x00, //
				0x07, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, //
				0x09, 0x00, //
				0x0A, 0x00 }); //
		ZipLocalFileHeaderRecord record = ZipLocalFileHeaderRecord.load(dataBlock, 0);
		assertThat(record.versionNeededToExtract()).isEqualTo((short) 1);
		assertThat(record.generalPurposeBitFlag()).isEqualTo((short) 2);
		assertThat(record.compressionMethod()).isEqualTo((short) 3);
		assertThat(record.lastModFileTime()).isEqualTo((short) 4);
		assertThat(record.lastModFileDate()).isEqualTo((short) 5);
		assertThat(record.crc32()).isEqualTo(6);
		assertThat(record.compressedSize()).isEqualTo(7);
		assertThat(record.uncompressedSize()).isEqualTo(8);
		assertThat(record.fileNameLength()).isEqualTo((short) 9);
		assertThat(record.extraFieldLength()).isEqualTo((short) 10);
	}
	@Test
	void loadWhenSignatureDoesNotMatchThrowsException() {
		DataBlock dataBlock = new ByteArrayDataBlock(new byte[] { //
				0x51, 0x4b, 0x03, 0x04, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, //
				0x06, 0x00, 0x00, 0x00, //
				0x07, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, //
				0x09, 0x00, //
				0x0A, 0x00 }); //
		assertThatIOException().isThrownBy(() -> ZipLocalFileHeaderRecord.load(dataBlock, 0))
			.withMessageContaining('"Local File Header Record" not found');
	}
	@Test
	void sizeReturnsSize() {
		ZipLocalFileHeaderRecord record = new ZipLocalFileHeaderRecord((short) 1, (short) 2, (short) 3, (short) 4,
				(short) 5, 6, 7, 8, (short) 9, (short) 10);
		assertThat(record.size()).isEqualTo(49L);
	}
	@Test
	void withExtraFieldLengthReturnsUpdatedInstance() {
		ZipLocalFileHeaderRecord record = new ZipLocalFileHeaderRecord((short) 1, (short) 2, (short) 3, (short) 4,
				(short) 5, 6, 7, 8, (short) 9, (short) 10)
			.withExtraFieldLength((short) 100);
		assertThat(record.extraFieldLength()).isEqualTo((short) 100);
	}
	@Test
	void withFileNameLengthReturnsUpdatedInstance() {
		ZipLocalFileHeaderRecord record = new ZipLocalFileHeaderRecord((short) 1, (short) 2, (short) 3, (short) 4,
				(short) 5, 6, 7, 8, (short) 9, (short) 10)
			.withFileNameLength((short) 100);
		assertThat(record.fileNameLength()).isEqualTo((short) 100);
	}
	@Test
	void asByteArrayReturnsByteArray() throws Exception {
		byte[] bytes = new byte[] { //
				0x50, 0x4b, 0x03, 0x04, //
				0x01, 0x00, //
				0x02, 0x00, //
				0x03, 0x00, //
				0x04, 0x00, //
				0x05, 0x00, //
				0x06, 0x00, 0x00, 0x00, //
				0x07, 0x00, 0x00, 0x00, //
				0x08, 0x00, 0x00, 0x00, //
				0x09, 0x00, //
				0x0A, 0x00 }; //
		ZipLocalFileHeaderRecord record = ZipLocalFileHeaderRecord.load(new ByteArrayDataBlock(bytes), 0);
		assertThat(record.asByteArray()).isEqualTo(bytes);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class ZipContentTests {
	@TempDir
	File tempDir;
	private File file;
	private ZipContent zipContent;
	@BeforeEach
	void setup() throws Exception {
		this.file = new File(this.tempDir, 'test.jar');
		TestJar.create(this.file);
		this.zipContent = ZipContent.open(this.file.toPath());
	}
	@AfterEach
	void tearDown() throws Exception {
		if (this.zipContent != null) {
			try {
				this.zipContent.close();
			}
			catch (IllegalStateException ex) {
				// Ignore
			}
		}
	}
	@Test
	void getCommentReturnsComment() {
		assertThat(this.zipContent.getComment()).isEqualTo('outer');
	}
	@Test
	void getCommentWhenClosedThrowsException() throws IOException {
		this.zipContent.close();
		assertThatIllegalStateException().isThrownBy(() -> this.zipContent.getComment())
			.withMessage('Zip content closed');
	}
	@Test
	void getEntryWhenPresentReturnsEntry() {
		Entry entry = this.zipContent.getEntry('1.dat');
		assertThat(entry).isNotNull();
		assertThat(entry.getName()).isEqualTo('1.dat');
	}
	@Test
	void getEntryWhenMissingReturnsNull() {
		assertThat(this.zipContent.getEntry('missing.dat')).isNull();
	}
	@Test
	void getEntryWithPrefixWhenPresentReturnsEntry() {
		Entry entry = this.zipContent.getEntry('1', '.dat');
		assertThat(entry).isNotNull();
		assertThat(entry.getName()).isEqualTo('1.dat');
	}
	@Test
	void getEntryWithLongPrefixWhenNameIsShorterReturnsNull() {
		Entry entry = this.zipContent.getEntry('iamaverylongprefixandiwontfindanything', '1.dat');
		assertThat(entry).isNull();
	}
	@Test
	void getEntryWithPrefixWhenMissingReturnsNull() {
		assertThat(this.zipContent.getEntry('miss', 'ing.dat')).isNull();
	}
	@Test
	void getEntryWhenUsingSlashesIsCompatibleWithZipFile() throws IOException {
		try (ZipFile zipFile = new ZipFile(this.file)) {
			assertThat(zipFile.getEntry('META-INF').getName()).isEqualTo('META-INF/');
			assertThat(this.zipContent.getEntry('META-INF').getName()).isEqualTo('META-INF/');
			assertThat(zipFile.getEntry('META-INF/').getName()).isEqualTo('META-INF/');
			assertThat(this.zipContent.getEntry('META-INF/').getName()).isEqualTo('META-INF/');
			assertThat(zipFile.getEntry('d/9.dat').getName()).isEqualTo('d/9.dat');
			assertThat(this.zipContent.getEntry('d/9.dat').getName()).isEqualTo('d/9.dat');
			assertThat(zipFile.getEntry('d/9.dat/')).isNull();
			assertThat(this.zipContent.getEntry('d/9.dat/')).isNull();
		}
	}
	@Test
	void getManifestEntry() throws Exception {
		Entry entry = this.zipContent.getEntry('META-INF/MANIFEST.MF');
		try (CloseableDataBlock dataBlock = entry.openContent()) {
			Manifest manifest = new Manifest(asInflaterInputStream(dataBlock));
			assertThat(manifest.getMainAttributes().getValue('Built-By')).isEqualTo('j1');
		}
	}
	@Test
	void getEntryAsCreatesCompatibleEntries() throws IOException {
		try (ZipFile zipFile = new ZipFile(this.file)) {
			Iterator<? extends ZipEntry> expected = zipFile.entries().asIterator();
			int i = 0;
			while (expected.hasNext()) {
				Entry actual = this.zipContent.getEntry(i++);
				assertThatFieldsAreEqual(actual.as(ZipEntry::new), expected.next());
			}
		}
	}
	@Test
	void getKindWhenZipReturnsZip() {
		assertThat(this.zipContent.getKind()).isEqualTo(Kind.ZIP);
	}
	@Test
	void getKindWhenNestedZipReturnsNestedZip() throws IOException {
		try (ZipContent nested = ZipContent.open(this.file.toPath(), 'nested.jar')) {
			assertThat(nested.getKind()).isEqualTo(Kind.NESTED_ZIP);
		}
	}
	@Test
	void getKindWhenNestedDirectoryReturnsNestedDirectory() throws IOException {
		try (ZipContent nested = ZipContent.open(this.file.toPath(), 'd/')) {
			assertThat(nested.getKind()).isEqualTo(Kind.NESTED_DIRECTORY);
		}
	}
	private void assertThatFieldsAreEqual(ZipEntry actual, ZipEntry expected) {
		assertThat(actual.getName()).isEqualTo(expected.getName());
		assertThat(actual.getTime()).isEqualTo(expected.getTime());
		assertThat(actual.getLastModifiedTime()).isEqualTo(expected.getLastModifiedTime());
		assertThat(actual.getLastAccessTime()).isEqualTo(expected.getLastAccessTime());
		assertThat(actual.getCreationTime()).isEqualTo(expected.getCreationTime());
		assertThat(actual.getSize()).isEqualTo(expected.getSize());
		assertThat(actual.getCompressedSize()).isEqualTo(expected.getCompressedSize());
		assertThat(actual.getCrc()).isEqualTo(expected.getCrc());
		assertThat(actual.getMethod()).isEqualTo(expected.getMethod());
		assertThat(actual.getExtra()).isEqualTo(expected.getExtra());
		assertThat(actual.getComment()).isEqualTo(expected.getComment());
	}
	@Test
	void sizeReturnsNumberOfEntries() {
		assertThat(this.zipContent.size()).isEqualTo(12);
	}
	@Test
	void nestedJarFileReturnsNestedJar() throws IOException {
		try (ZipContent nested = ZipContent.open(this.file.toPath(), 'nested.jar')) {
			assertThat(nested.size()).isEqualTo(5);
			assertThat(nested.getComment()).isEqualTo('nested');
			assertThat(nested.size()).isEqualTo(5);
			assertThat(nested.getEntry(0).getName()).isEqualTo('META-INF/');
			assertThat(nested.getEntry(1).getName()).isEqualTo('META-INF/MANIFEST.MF');
			assertThat(nested.getEntry(2).getName()).isEqualTo('3.dat');
			assertThat(nested.getEntry(3).getName()).isEqualTo('4.dat');
			assertThat(nested.getEntry(4).getName()).isEqualTo('\u00E4.dat');
		}
	}
	@Test
	void nestedJarFileWhenNameEndsInSlashThrowsException() {
		assertThatIOException().isThrownBy(() -> ZipContent.open(this.file.toPath(), 'nested.jar/'))
			.withMessageStartingWith('Nested entry "nested.jar/" not found in container zip');
	}
	@Test
	void nestedDirectoryReturnsNestedJar() throws IOException {
		try (ZipContent nested = ZipContent.open(this.file.toPath(), 'd/')) {
			assertThat(nested.size()).isEqualTo(1);
			assertThat(nested.getEntry('9.dat')).isNotNull();
			assertThat(nested.getEntry(0).getName()).isEqualTo('9.dat');
		}
	}
	@Test
	void nestedDirectoryWhenNotEndingInSlashThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> ZipContent.open(this.file.toPath(), 'd'))
			.withMessage('Nested entry name must end with "/"');
	}
	@Test
	void getDataWhenNestedDirectoryReturnsVirtualZipDataBlock() throws IOException {
		try (ZipContent nested = ZipContent.open(this.file.toPath(), 'd/')) {
			File file = new File(this.tempDir, 'included.zip');
			write(file, nested.openRawZipData());
			try (ZipFile loadedZipFile = new ZipFile(file)) {
				assertThat(loadedZipFile.size()).isEqualTo(1);
				assertThat(loadedZipFile.stream().map(ZipEntry::getName)).containsExactly('9.dat');
				assertThat(loadedZipFile.getEntry('9.dat')).isNotNull();
				try (InputStream in = loadedZipFile.getInputStream(loadedZipFile.getEntry('9.dat'))) {
					ByteArrayOutputStream out = new ByteArrayOutputStream();
					in.transferTo(out);
					assertThat(out.toByteArray()).containsExactly(0x09);
				}
			}
		}
	}
	@Test
	void loadWhenHasFrontMatterOpensZip() throws IOException {
		File fileWithFrontMatter = new File(this.tempDir, 'withfrontmatter.jar');
		FileOutputStream outputStream = new FileOutputStream(fileWithFrontMatter);
		StreamUtils.copy('#/bin/bash', Charset.defaultCharset(), outputStream);
		FileCopyUtils.copy(new FileInputStream(this.file), outputStream);
		try (ZipContent zip = ZipContent.open(fileWithFrontMatter.toPath())) {
			assertThat(zip.size()).isEqualTo(12);
			assertThat(zip.getEntry(0).getName()).isEqualTo('META-INF/');
			assertThat(zip.getEntry(1).getName()).isEqualTo('META-INF/MANIFEST.MF');
			assertThat(zip.getEntry(2).getName()).isEqualTo('1.dat');
			assertThat(zip.getEntry(3).getName()).isEqualTo('2.dat');
			assertThat(zip.getEntry(4).getName()).isEqualTo('d/');
			assertThat(zip.getEntry(5).getName()).isEqualTo('d/9.dat');
			assertThat(zip.getEntry(6).getName()).isEqualTo('special/');
			assertThat(zip.getEntry(7).getName()).isEqualTo('special/\u00EB.dat');
			assertThat(zip.getEntry(8).getName()).isEqualTo('nested.jar');
			assertThat(zip.getEntry(9).getName()).isEqualTo('another-nested.jar');
			assertThat(zip.getEntry(10).getName()).isEqualTo('space nested.jar');
			assertThat(zip.getEntry(11).getName()).isEqualTo('multi-release.jar');
		}
	}
	@Test
	void openWhenZip64ThatExceedsZipEntryLimitOpensZip() throws Exception {
		File zip64File = new File(this.tempDir, 'zip64.zip');
		FileCopyUtils.copy(zip64Bytes(), zip64File);
		try (ZipContent zip64Content = ZipContent.open(zip64File.toPath())) {
			assertThat(zip64Content.size()).isEqualTo(65537);
			for (int i = 0; i < zip64Content.size(); i++) {
				Entry entry = zip64Content.getEntry(i);
				try (CloseableDataBlock dataBlock = entry.openContent()) {
					assertThat(asInflaterInputStream(dataBlock)).hasContent('Entry ' + (i + 1));
				}
			}
		}
	}
	@Test
	void openWhenZip64ThatExceedsZipSizeLimitOpensZip() throws Exception {
		Assumptions.assumeTrue(this.tempDir.getFreeSpace() > 6L * 1024 * 1024 * 1024, 'Insufficient disk space');
		File zip64File = new File(this.tempDir, 'zip64.zip');
		File entryFile = new File(this.tempDir, 'entry.dat');
		CRC32 crc32 = new CRC32();
		try (FileOutputStream entryOut = new FileOutputStream(entryFile)) {
			byte[] data = new byte[1024 * 1024];
			new Random().nextBytes(data);
			for (int i = 0; i < 1024; i++) {
				entryOut.write(data);
				crc32.update(data);
			}
		}
		try (ZipOutputStream zipOutput = new ZipOutputStream(new FileOutputStream(zip64File))) {
			for (int i = 0; i < 6; i++) {
				ZipEntry storedEntry = new ZipEntry('huge-' + i);
				storedEntry.setSize(entryFile.length());
				storedEntry.setCompressedSize(entryFile.length());
				storedEntry.setCrc(crc32.getValue());
				storedEntry.setMethod(ZipEntry.STORED);
				zipOutput.putNextEntry(storedEntry);
				try (FileInputStream entryIn = new FileInputStream(entryFile)) {
					StreamUtils.copy(entryIn, zipOutput);
				}
				zipOutput.closeEntry();
			}
		}
		try (ZipContent zip64Content = ZipContent.open(zip64File.toPath())) {
			assertThat(zip64Content.size()).isEqualTo(6);
		}
	}
	@Test
	void nestedZip64CanBeRead() throws Exception {
		File containerFile = new File(this.tempDir, 'outer.zip');
		try (ZipOutputStream jarOutput = new ZipOutputStream(new FileOutputStream(containerFile))) {
			ZipEntry nestedEntry = new ZipEntry('nested-zip64.zip');
			byte[] contents = zip64Bytes();
			nestedEntry.setSize(contents.length);
			nestedEntry.setCompressedSize(contents.length);
			CRC32 crc32 = new CRC32();
			crc32.update(contents);
			nestedEntry.setCrc(crc32.getValue());
			nestedEntry.setMethod(ZipEntry.STORED);
			jarOutput.putNextEntry(nestedEntry);
			jarOutput.write(contents);
			jarOutput.closeEntry();
		}
		try (ZipContent nestedZip = ZipContent.open(containerFile.toPath(), 'nested-zip64.zip')) {
			assertThat(nestedZip.size()).isEqualTo(65537);
			for (int i = 0; i < nestedZip.size(); i++) {
				Entry entry = nestedZip.getEntry(i);
				try (CloseableDataBlock content = entry.openContent()) {
					assertThat(asInflaterInputStream(content)).hasContent('Entry ' + (i + 1));
				}
			}
		}
	}
	private byte[] zip64Bytes() throws IOException {
		ByteArrayOutputStream bytes = new ByteArrayOutputStream();
		ZipOutputStream zipOutput = new ZipOutputStream(bytes);
		for (int i = 0; i < 65537; i++) {
			zipOutput.putNextEntry(new ZipEntry(i + '.dat'));
			zipOutput.write(('Entry ' + (i + 1)).getBytes(StandardCharsets.UTF_8));
			zipOutput.closeEntry();
		}
		zipOutput.close();
		return bytes.toByteArray();
	}
	@Test
	void entryWithEpochTimeOfZeroShouldNotFail() throws Exception {
		File file = createZipFileWithEpochTimeOfZero();
		try (ZipContent zip = ZipContent.open(file.toPath())) {
			ZipEntry entry = zip.getEntry(0).as(ZipEntry::new);
			assertThat(entry.getLastModifiedTime().toInstant()).isEqualTo(Instant.EPOCH);
			assertThat(entry.getName()).isEqualTo('1.dat');
		}
	}
	private File createZipFileWithEpochTimeOfZero() throws Exception {
		File file = new File(this.tempDir, 'temp.zip');
		String comment = 'outer';
		try (ZipOutputStream zipOutput = new ZipOutputStream(new FileOutputStream(file))) {
			zipOutput.setComment(comment);
			ZipEntry entry = new ZipEntry('1.dat');
			entry.setLastModifiedTime(FileTime.from(Instant.EPOCH));
			zipOutput.putNextEntry(entry);
			zipOutput.write(new byte[] { (byte) 1 });
			zipOutput.closeEntry();
		}
		ByteBuffer data = ByteBuffer.wrap(Files.readAllBytes(file.toPath()));
		data.order(ByteOrder.LITTLE_ENDIAN);
		int endOfCentralDirectoryRecordPos = data.remaining() - ZipFile.ENDHDR - comment.getBytes().length;
		data.position(endOfCentralDirectoryRecordPos + ZipFile.ENDOFF);
		int startOfCentralDirectoryOffset = data.getInt();
		data.position(startOfCentralDirectoryOffset + ZipFile.CENOFF);
		int localHeaderPosition = data.getInt();
		writeTimeBlock(data.array(), startOfCentralDirectoryOffset + ZipFile.CENTIM, 0);
		writeTimeBlock(data.array(), localHeaderPosition + ZipFile.LOCTIM, 0);
		File zerotimedFile = new File(this.tempDir, 'zerotimed.zip');
		Files.write(zerotimedFile.toPath(), data.array());
		return zerotimedFile;
	}
	@Test
	void getInfoReturnsComputedInfo() {
		ZipInfo info = this.zipContent.getInfo(ZipInfo.class, ZipInfo::get);
		assertThat(info.size()).isEqualTo(12);
	}
	private static void writeTimeBlock(byte[] data, int pos, int value) {
		data[pos] = (byte) (value & 0xff);
		data[pos + 1] = (byte) ((value >> 8) & 0xff);
		data[pos + 2] = (byte) ((value >> 16) & 0xff);
		data[pos + 3] = (byte) ((value >> 24) & 0xff);
	}
	private InputStream asInflaterInputStream(DataBlock dataBlock) throws IOException {
		ByteBuffer buffer = ByteBuffer.allocate((int) dataBlock.size() + 1);
		buffer.limit(buffer.limit() - 1);
		dataBlock.readFully(buffer, 0);
		ByteArrayInputStream in = new ByteArrayInputStream(buffer.array());
		return new InflaterInputStream(in, new Inflater(true));
	}
	private void write(File file, CloseableDataBlock dataBlock) throws IOException {
		ByteBuffer buffer = ByteBuffer.allocate((int) dataBlock.size());
		dataBlock.readFully(buffer, 0);
		Files.write(file.toPath(), buffer.array());
		dataBlock.close();
	}
	private static class ZipInfo {
		private int size;
		ZipInfo(int size) {
			this.size = size;
		}
		int size() {
			return this.size;
		}
		static ZipInfo get(ZipContent content) {
			return new ZipInfo(content.size());
		}
	}
}
/*
package org.springframework.boot.loader.zip;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ExtendWith(AssertFileChannelDataBlocksClosedExtension.class)
public @interface AssertFileChannelDataBlocksClosed {
}
/*
package org.springframework.boot.loader.jar;
/**
class MetaInfVersionsInfoTests {
	@Test
	void getParsesVersionsAndEntries() {
		List<ZipContent.Entry> entries = new ArrayList<>();
		entries.add(mockEntry('META-INF/'));
		entries.add(mockEntry('META-INF/MANIFEST.MF'));
		entries.add(mockEntry('META-INF/versions/'));
		entries.add(mockEntry('META-INF/versions/9/'));
		entries.add(mockEntry('META-INF/versions/9/Foo.class'));
		entries.add(mockEntry('META-INF/versions/11/'));
		entries.add(mockEntry('META-INF/versions/11/Foo.class'));
		entries.add(mockEntry('META-INF/versions/10/'));
		entries.add(mockEntry('META-INF/versions/10/Foo.class'));
		MetaInfVersionsInfo info = MetaInfVersionsInfo.get(entries.size(), entries::get);
		assertThat(info.versions()).containsExactly(9, 10, 11);
		assertThat(info.directories()).containsExactly('META-INF/versions/9/', 'META-INF/versions/10/',
				'META-INF/versions/11/');
	}
	@Test
	void getWhenHasBadEntryParsesGoodVersionsAndEntries() {
		List<ZipContent.Entry> entries = new ArrayList<>();
		entries.add(mockEntry('META-INF/versions/9/Foo.class'));
		entries.add(mockEntry('META-INF/versions/0x11/Foo.class'));
		MetaInfVersionsInfo info = MetaInfVersionsInfo.get(entries.size(), entries::get);
		assertThat(info.versions()).containsExactly(9);
		assertThat(info.directories()).containsExactly('META-INF/versions/9/');
	}
	@Test
	void getWhenHasNoEntriesReturnsNone() {
		List<ZipContent.Entry> entries = new ArrayList<>();
		MetaInfVersionsInfo info = MetaInfVersionsInfo.get(entries.size(), entries::get);
		assertThat(info.versions()).isEmpty();
		assertThat(info.directories()).isEmpty();
		assertThat(info).isSameAs(MetaInfVersionsInfo.NONE);
	}
	@Test
	void toleratesUnexpectedFileEntryInMetaInfVersions() {
		List<ZipContent.Entry> entries = new ArrayList<>();
		entries.add(mockEntry('META-INF/'));
		entries.add(mockEntry('META-INF/MANIFEST.MF'));
		entries.add(mockEntry('META-INF/versions/'));
		entries.add(mockEntry('META-INF/versions/unexpected'));
		entries.add(mockEntry('META-INF/versions/9/'));
		entries.add(mockEntry('META-INF/versions/9/Foo.class'));
		MetaInfVersionsInfo info = MetaInfVersionsInfo.get(entries.size(), entries::get);
		assertThat(info.versions()).containsExactly(9);
		assertThat(info.directories()).containsExactly('META-INF/versions/9/');
	}
	private ZipContent.Entry mockEntry(String name) {
		ZipContent.Entry entry = mock(ZipContent.Entry.class);
		given(entry.getName()).willReturn(name);
		given(entry.hasNameStartingWith(any()))
			.willAnswer((invocation) -> name.startsWith(invocation.getArgument(0, CharSequence.class).toString()));
		given(entry.isDirectory()).willAnswer((invocation) -> name.endsWith('/'));
		return entry;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class ManifestInfoTests {
	@Test
	void noneReturnsNoDetails() {
		assertThat(ManifestInfo.NONE.getManifest()).isNull();
		assertThat(ManifestInfo.NONE.isMultiRelease()).isFalse();
	}
	@Test
	void getManifestReturnsManifest() {
		Manifest manifest = new Manifest();
		ManifestInfo info = new ManifestInfo(manifest);
		assertThat(info.getManifest()).isSameAs(manifest);
	}
	@Test
	void isMultiReleaseWhenHasMultiReleaseAttributeReturnsTrue() {
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().put(new Name('Multi-Release'), 'true');
		ManifestInfo info = new ManifestInfo(manifest);
		assertThat(info.isMultiRelease()).isTrue();
	}
	@Test
	void isMultiReleaseWhenHasNoMultiReleaseAttributeReturnsFalse() {
		Manifest manifest = new Manifest();
		manifest.getMainAttributes().put(new Name('Random-Release'), 'true');
		ManifestInfo info = new ManifestInfo(manifest);
		assertThat(info.isMultiRelease()).isFalse();
	}
}
/*
package org.springframework.boot.loader.jar;
/**
@AssertFileChannelDataBlocksClosed
class SecurityInfoTests {
	@TempDir
	File temp;
	@Test
	void getWhenNoSignatureFileReturnsNone() throws Exception {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		try (ZipContent content = ZipContent.open(file.toPath())) {
			SecurityInfo info = SecurityInfo.get(content);
			assertThat(info).isSameAs(SecurityInfo.NONE);
			for (int i = 0; i < content.size(); i++) {
				Entry entry = content.getEntry(i);
				assertThat(info.getCertificates(entry)).isNull();
				assertThat(info.getCodeSigners(entry)).isNull();
			}
		}
	}
	@Test
	void getWhenHasSignatureFileButNoSecurityMaterialReturnsNone() throws Exception {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file, false, true);
		try (ZipContent content = ZipContent.open(file.toPath())) {
			assertThat(content.hasJarSignatureFile()).isTrue();
			SecurityInfo info = SecurityInfo.get(content);
			assertThat(info).isSameAs(SecurityInfo.NONE);
		}
	}
	@Test
	void getWhenJarIsSigned() throws Exception {
		File file = TestJar.getSigned();
		try (ZipContent content = ZipContent.open(file.toPath())) {
			assertThat(content.hasJarSignatureFile()).isTrue();
			SecurityInfo info = SecurityInfo.get(content);
			for (int i = 0; i < content.size(); i++) {
				Entry entry = content.getEntry(i);
				if (entry.getName().endsWith('.class')) {
					assertThat(info.getCertificates(entry)).isNotNull();
					assertThat(info.getCodeSigners(entry)).isNotNull();
				}
			}
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
@AssertFileChannelDataBlocksClosed
class NestedJarFileTests {
	@TempDir
	File tempDir;
	private File file;
	@BeforeEach
	void setup() throws Exception {
		this.file = new File(this.tempDir, 'test.jar');
		TestJar.create(this.file);
	}
	@Test
	void createOpensJar() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			try (JarFile jdkJar = new JarFile(this.file)) {
				assertThat(jar.size()).isEqualTo(jdkJar.size());
				assertThat(jar.getComment()).isEqualTo(jdkJar.getComment());
				Enumeration<JarEntry> entries = jar.entries();
				Enumeration<JarEntry> jdkEntries = jdkJar.entries();
				while (entries.hasMoreElements()) {
					assertThat(entries.nextElement().getName()).isEqualTo(jdkEntries.nextElement().getName());
				}
				assertThat(jdkEntries.hasMoreElements()).isFalse();
				try (InputStream in = jar.getInputStream(jar.getEntry('1.dat'))) {
					assertThat(in.readAllBytes()).containsExactly(new byte[] { 1 });
				}
			}
		}
	}
	@Test
	void createWhenNestedJarFileOpensJar() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file, 'nested.jar')) {
			assertThat(jar.size()).isEqualTo(5);
			assertThat(jar.stream().map(JarEntry::getName)).containsExactly('META-INF/', 'META-INF/MANIFEST.MF',
					'3.dat', '4.dat', '\u00E4.dat');
		}
	}
	@Test
	void createWhenNestedJarDirectoryOpensJar() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file, 'd/')) {
			assertThat(jar.getName()).isEqualTo(this.file.getAbsolutePath() + '!/d/');
			assertThat(jar.size()).isEqualTo(1);
			assertThat(jar.stream().map(JarEntry::getName)).containsExactly('9.dat');
		}
	}
	@Test
	void getManifestWhenNestedJarReturnsManifestOfNestedJar() throws Exception {
		try (JarFile jar = new JarFile(this.file)) {
			try (NestedJarFile nestedJar = new NestedJarFile(this.file, 'nested.jar')) {
				Manifest manifest = nestedJar.getManifest();
				assertThat(manifest).isNotEqualTo(jar.getManifest());
				assertThat(manifest.getMainAttributes().getValue('Built-By')).isEqualTo('j2');
			}
		}
	}
	@Test
	void getManifestWhenNestedJarDirectoryReturnsManifestOfParent() throws Exception {
		try (JarFile jar = new JarFile(this.file)) {
			try (NestedJarFile nestedJar = new NestedJarFile(this.file, 'd/')) {
				assertThat(nestedJar.getManifest()).isEqualTo(jar.getManifest());
			}
		}
	}
	@Test
	void createWhenJarHasFrontMatterOpensJar() throws IOException {
		File file = new File(this.tempDir, 'frontmatter.jar');
		InputStream sourceJarContent = new FileInputStream(this.file);
		FileOutputStream outputStream = new FileOutputStream(file);
		StreamUtils.copy('#/bin/bash', Charset.defaultCharset(), outputStream);
		FileCopyUtils.copy(sourceJarContent, outputStream);
		try (NestedJarFile jar = new NestedJarFile(file)) {
			assertThat(jar.size()).isEqualTo(12);
		}
		try (NestedJarFile jar = new NestedJarFile(this.file, 'nested.jar')) {
			assertThat(jar.size()).isEqualTo(5);
		}
	}
	@Test
	void getEntryReturnsEntry() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			JarEntry entry = jar.getEntry('1.dat');
			assertEntryOne(entry);
		}
	}
	@Test
	void getEntryWhenClosedThrowsException() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			jar.close();
			assertThatIllegalStateException().isThrownBy(() -> jar.getEntry('1.dat')).withMessage('Zip file closed');
		}
	}
	@Test
	void getJarEntryReturnsEntry() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			JarEntry entry = jar.getJarEntry('1.dat');
			assertEntryOne(entry);
		}
	}
	@Test
	void getJarEntryWhenClosedThrowsException() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			jar.close();
			assertThatIllegalStateException().isThrownBy(() -> jar.getJarEntry('1.dat')).withMessage('Zip file closed');
		}
	}
	private void assertEntryOne(JarEntry entry) {
		assertThat(entry.getName()).isEqualTo('1.dat');
		assertThat(entry.getRealName()).isEqualTo('1.dat');
		assertThat(entry.getSize()).isEqualTo(1);
		assertThat(entry.getCompressedSize()).isEqualTo(3);
		assertThat(entry.getCrc()).isEqualTo(2768625435L);
		assertThat(entry.getMethod()).isEqualTo(8);
	}
	@Test
	void getEntryWhenMultiReleaseEntryReturnsEntry() throws IOException {
		File multiReleaseFile = new File(this.tempDir, 'mutli.zip');
		try (ZipContent zip = ZipContent.open(this.file.toPath(), 'multi-release.jar')) {
			try (InputStream in = zip.openRawZipData().asInputStream()) {
				try (FileOutputStream out = new FileOutputStream(multiReleaseFile)) {
					in.transferTo(out);
				}
			}
		}
		try (NestedJarFile jar = new NestedJarFile(this.file, 'multi-release.jar', JarFile.runtimeVersion())) {
			try (JarFile jdkJar = new JarFile(multiReleaseFile, true, ZipFile.OPEN_READ, JarFile.runtimeVersion())) {
				JarEntry entry = jar.getJarEntry('multi-release.dat');
				JarEntry jdkEntry = jdkJar.getJarEntry('multi-release.dat');
				assertThat(entry.getName()).isEqualTo(jdkEntry.getName());
				assertThat(entry.getRealName()).isEqualTo(jdkEntry.getRealName());
				try (InputStream inputStream = jdkJar.getInputStream(entry)) {
					assertThat(inputStream.available()).isOne();
					assertThat(inputStream.read()).isEqualTo(Runtime.version().feature());
				}
				try (InputStream inputStream = jar.getInputStream(entry)) {
					assertThat(inputStream.available()).isOne();
					assertThat(inputStream.read()).isEqualTo(Runtime.version().feature());
				}
			}
		}
	}
	@Test
	void getManifestReturnsManifest() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			Manifest manifest = jar.getManifest();
			assertThat(manifest).isNotNull();
			assertThat(manifest.getEntries()).isEmpty();
			assertThat(manifest.getMainAttributes().getValue('Manifest-Version')).isEqualTo('1.0');
		}
	}
	@Test
	void getCommentReturnsComment() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			assertThat(jar.getComment()).isEqualTo('outer');
		}
	}
	@Test
	void getCommentWhenClosedThrowsException() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			jar.close();
			assertThatIllegalStateException().isThrownBy(jar::getComment).withMessage('Zip file closed');
		}
	}
	@Test
	void getNameReturnsName() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			assertThat(jar.getName()).isEqualTo(this.file.getAbsolutePath());
		}
	}
	@Test
	void getNameWhenNestedReturnsName() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file, 'nested.jar')) {
			assertThat(jar.getName()).isEqualTo(this.file.getAbsolutePath() + '!/nested.jar');
		}
	}
	@Test
	void sizeReturnsSize() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			assertThat(jar.size()).isEqualByComparingTo(12);
		}
	}
	@Test
	void sizeWhenClosedThrowsException() throws Exception {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			jar.close();
			assertThatIllegalStateException().isThrownBy(jar::size).withMessage('Zip file closed');
		}
	}
	@Test
	void getEntryTime() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			try (JarFile jdkJar = new JarFile(this.file)) {
				assertThat(jar.getEntry('META-INF/MANIFEST.MF').getTime())
					.isEqualTo(jar.getEntry('META-INF/MANIFEST.MF').getTime());
			}
		}
	}
	@Test
	void closeTriggersCleanupOnlyOnce() throws IOException {
		Cleaner cleaner = mock(Cleaner.class);
		ArgumentCaptor<Runnable> action = ArgumentCaptor.forClass(Runnable.class);
		Cleanable cleanable = mock(Cleanable.class);
		given(cleaner.register(any(), action.capture())).willReturn(cleanable);
		NestedJarFile jar = new NestedJarFile(this.file, null, null, false, cleaner);
		jar.close();
		jar.close();
		then(cleanable).should(atMostOnce()).clean();
		action.getValue().run();
	}
	@Test
	void cleanupFromReleasesResources() throws IOException {
		Cleaner cleaner = mock(Cleaner.class);
		ArgumentCaptor<Runnable> action = ArgumentCaptor.forClass(Runnable.class);
		Cleanable cleanable = mock(Cleanable.class);
		given(cleaner.register(any(), action.capture())).willReturn(cleanable);
		try (NestedJarFile jar = new NestedJarFile(this.file, null, null, false, cleaner)) {
			Object channel = Extractors.byName('resources.zipContent.data.fileAccess').apply(jar);
			assertThat(channel).extracting('referenceCount').isEqualTo(1);
			action.getValue().run();
			assertThat(channel).extracting('referenceCount').isEqualTo(0);
		}
	}
	@Test
	void getInputStreamReturnsInputStream() throws IOException {
		try (NestedJarFile jarFile = new NestedJarFile(this.file)) {
			JarEntry entry = jarFile.getJarEntry('2.dat');
			try (InputStream in = jarFile.getInputStream(entry)) {
				assertThat(in).hasBinaryContent(new byte[] { 0x02 });
			}
		}
	}
	@Test
	void getInputStreamWhenIsDirectory() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			try (InputStream inputStream = jar.getInputStream(jar.getEntry('d/'))) {
				assertThat(inputStream).isNotNull();
				assertThat(inputStream.read()).isEqualTo(-1);
			}
		}
	}
	@Test
	void getInputStreamWhenNameWithoutSlashAndIsDirectory() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file)) {
			try (InputStream inputStream = jar.getInputStream(jar.getEntry('d'))) {
				assertThat(inputStream).isNotNull();
				assertThat(inputStream.read()).isEqualTo(-1);
			}
		}
	}
	@Test
	void verifySignedJar() throws Exception {
		File signedJarFile = TestJar.getSigned();
		assertThat(signedJarFile).exists();
		try (JarFile expected = new JarFile(signedJarFile)) {
			try (NestedJarFile actual = new NestedJarFile(signedJarFile)) {
				StopWatch stopWatch = new StopWatch();
				Enumeration<JarEntry> actualEntries = actual.entries();
				while (actualEntries.hasMoreElements()) {
					JarEntry actualEntry = actualEntries.nextElement();
					JarEntry expectedEntry = expected.getJarEntry(actualEntry.getName());
					StreamUtils.drain(expected.getInputStream(expectedEntry));
					if (!actualEntry.getName().equals('META-INF/MANIFEST.MF')) {
						assertThat(actualEntry.getCertificates()).as(actualEntry.getName())
							.isEqualTo(expectedEntry.getCertificates());
						assertThat(actualEntry.getCodeSigners()).as(actualEntry.getName())
							.isEqualTo(expectedEntry.getCodeSigners());
					}
				}
				assertThat(stopWatch.getTotalTimeSeconds()).isLessThan(3.0);
			}
		}
	}
	@Test
	void closeAllowsFileToBeDeleted() throws Exception {
		new NestedJarFile(this.file).close();
		assertThat(this.file.delete()).isTrue();
	}
	@Test
	void streamStreamsEntries() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file, 'multi-release.jar')) {
			assertThat(jar.stream().map((entry) -> entry.getName() + ':' + entry.getRealName())).containsExactly(
					'META-INF/:META-INF/', 'META-INF/MANIFEST.MF:META-INF/MANIFEST.MF',
					'multi-release.dat:multi-release.dat',
					'META-INF/versions/%1$d/multi-release.dat:META-INF/versions/%1$d/multi-release.dat'
						.formatted(TestJar.MULTI_JAR_VERSION));
		}
	}
	@Test
	void versionedStreamStreamsEntries() throws IOException {
		try (NestedJarFile jar = new NestedJarFile(this.file, 'multi-release.jar', Runtime.version())) {
			assertThat(jar.versionedStream().map((entry) -> entry.getName() + ':' + entry.getRealName()))
				.containsExactly('META-INF/:META-INF/', 'META-INF/MANIFEST.MF:META-INF/MANIFEST.MF',
						'multi-release.dat:META-INF/versions/%1$d/multi-release.dat'
							.formatted(TestJar.MULTI_JAR_VERSION));
		}
	}
	@Test // gh-39166
	void getCommentAlignsWithJdkJar() throws Exception {
		File file = new File(this.tempDir, 'testcomments.jar');
		try (JarOutputStream jar = new JarOutputStream(new FileOutputStream(file))) {
			jar.putNextEntry(new ZipEntry('BOOT-INF/'));
			jar.closeEntry();
			jar.putNextEntry(new ZipEntry('BOOT-INF/classes/'));
			jar.closeEntry();
			for (int i = 0; i < 5; i++) {
				ZipEntry entry = new ZipEntry('BOOT-INF/classes/T' + i + '.class');
				entry.setComment('T' + i);
				jar.putNextEntry(entry);
				jar.write(UUID.randomUUID().toString().getBytes());
				jar.closeEntry();
			}
		}
		List<String> jdk = collectComments(new JarFile(file));
		List<String> nested = collectComments(new NestedJarFile(file, 'BOOT-INF/classes/'));
		assertThat(nested).isEqualTo(jdk);
	}
	@Test
	void mismatchedStreamEntriesThrowsException() throws IOException {
		File mismatchJar = new File('src/test/resources/jars/mismatch.jar');
		IllegalStateException failure = null;
		try (NestedJarFile innerJar = new NestedJarFile(mismatchJar, 'inner.jar')) {
			Enumeration<JarEntry> entries = innerJar.entries();
			while (entries.hasMoreElements()) {
				try {
					entries.nextElement().getCodeSigners();
				}
				catch (IllegalStateException ex) {
					failure = (failure != null) ? failure : ex;
				}
			}
		}
		assertThat(failure)
			.hasMessage('Content mismatch when reading security info for entry "content" (content check)');
	}
	private List<String> collectComments(JarFile jarFile) throws IOException {
		try (jarFile) {
			List<String> comments = new ArrayList<>();
			Enumeration<JarEntry> entries = jarFile.entries();
			while (entries.hasMoreElements()) {
				String comment = entries.nextElement().getComment();
				if (comment != null) {
					comments.add(comment);
				}
			}
			return comments;
		}
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlJarEntryTests {
	@Test
	void ofWhenEntryIsNullReturnsNull() {
		assertThat(UrlJarEntry.of(null, null)).isNull();
	}
	@Test
	void ofReturnsUrlJarEntry() {
		JarEntry entry = new JarEntry('test');
		assertThat(UrlJarEntry.of(entry, null)).isNotNull();
	}
	@Test
	void getAttributesDelegatesToUrlJarManifest() throws Exception {
		JarEntry entry = new JarEntry('test');
		UrlJarManifest manifest = mock(UrlJarManifest.class);
		Attributes attributes = mock(Attributes.class);
		given(manifest.getEntryAttributes(any())).willReturn(attributes);
		assertThat(UrlJarEntry.of(entry, manifest).getAttributes()).isSameAs(attributes);
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
@AssertFileChannelDataBlocksClosed
class HandlerTests {
	private final Handler handler = new Handler();
	@Test
	void indexOfSeparator() {
		String spec = 'jar:nested:foo!bar!/some/entry#foo';
		assertThat(Handler.indexOfSeparator(spec, 0, spec.indexOf("#"))).isEqualTo(spec.lastIndexOf('!/'));
	}
	@Test
	void indexOfSeparatorWhenHasStartAndLimit() {
		String spec = 'a!/jar:nested:foo!bar!/some/entry#foo!/b';
		int beginIndex = 3;
		int endIndex = spec.length() - 4;
		String substring = spec.substring(beginIndex, endIndex);
		assertThat(Handler.indexOfSeparator(spec, 0, spec.indexOf("#")))
			.isEqualTo(substring.lastIndexOf('!/') + beginIndex);
	}
	@Test
	void parseUrlWhenAbsoluteParses() throws MalformedURLException {
		URL url = createJarUrl('');
		String spec = 'jar:file:example.jar!/entry.txt';
		this.handler.parseURL(url, spec, 4, spec.length());
		assertThat(url.toExternalForm()).isEqualTo(spec);
	}
	@Test
	void parseUrlWhenAbsoluteWithAnchorParses() throws MalformedURLException {
		URL url = createJarUrl('');
		String spec = 'jar:file:example.jar!/entry.txt';
		this.handler.parseURL(url, spec + '#foo', 4, spec.length());
		assertThat(url.toExternalForm()).isEqualTo(spec + '#foo');
	}
	@Test
	void parseUrlWhenAbsoluteWithNoSeparatorThrowsException() throws MalformedURLException {
		URL url = createJarUrl('');
		String spec = 'jar:file:example.jar!\\entry.txt';
		assertThatIllegalStateException().isThrownBy(() -> this.handler.parseURL(url, spec, 4, spec.length()))
			.withMessage('no !/ in spec');
	}
	@Test
	void parseUrlWhenAbsoluteWithMalformedInnerUrlThrowsException() throws MalformedURLException {
		URL url = createJarUrl('');
		String spec = 'jar:example.jar!/entry.txt';
		assertThatIllegalStateException().isThrownBy(() -> this.handler.parseURL(url, spec, 4, spec.length()))
			.withMessage(
					'invalid url: jar:example.jar!/entry.txt (java.net.MalformedURLException: no protocol: example.jar)');
	}
	@Test
	void parseUrlWhenRelativeWithLeadingSlashParses() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar!/entry.txt');
		String spec = '/other.txt';
		this.handler.parseURL(url, spec, 0, spec.length());
		assertThat(url.toExternalForm()).isEqualTo('jar:file:example.jar!/other.txt');
	}
	@Test
	void parseUrlWhenRelativeWithLeadingSlashAndAnchorParses() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar!/entry.txt');
		String spec = '/other.txt';
		this.handler.parseURL(url, spec + '#relative', 0, spec.length());
		assertThat(url.toExternalForm()).isEqualTo('jar:file:example.jar!/other.txt#relative');
	}
	@Test
	void parseUrlWhenRelativeWithLeadingSlashAndNoSeparator() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar/entry.txt');
		String spec = '/other.txt';
		assertThatIllegalStateException().isThrownBy(() -> this.handler.parseURL(url, spec, 0, spec.length()))
			.withMessage('malformed context url:jar:file:example.jar/entry.txt: no !/');
	}
	@Test
	void parseUrlWhenRelativeWithoutLeadingSlashParses() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar!/foo/');
		String spec = 'bar.txt';
		this.handler.parseURL(url, spec, 0, spec.length());
		assertThat(url.toExternalForm()).isEqualTo('jar:file:example.jar!/foo/bar.txt');
	}
	@Test
	void parseUrlWhenRelativeWithoutLeadingSlashAndWithoutTrailingSlashParses() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar!/foo/baz');
		String spec = 'bar.txt';
		this.handler.parseURL(url, spec, 0, spec.length());
		assertThat(url.toExternalForm()).isEqualTo('jar:file:example.jar!/foo/bar.txt');
	}
	@Test
	void parseUrlWhenRelativeWithoutLeadingSlashAndWithoutContextSlashThrowsException() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar');
		String spec = 'bar.txt';
		assertThatIllegalStateException().isThrownBy(() -> this.handler.parseURL(url, spec, 0, spec.length()))
			.withMessage('malformed context url:jar:file:example.jar');
	}
	@Test
	void parseUrlWhenAnchorOnly() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar!/entry.txt');
		String spec = '#runtime';
		this.handler.parseURL(url, spec, 0, 0);
		assertThat(url.toExternalForm()).isEqualTo('jar:file:example.jar!/entry.txt#runtime');
	}
	@Test // gh-38524
	void parseUrlWhenSpecIsEmpty() throws MalformedURLException {
		URL url = createJarUrl('nested:gh-38524.jar/!BOOT-INF/classes/!/');
		String spec = '';
		this.handler.parseURL(url, spec, 0, 0);
		assertThat(url.toExternalForm()).isEqualTo('jar:nested:gh-38524.jar/!BOOT-INF/classes/!/');
	}
	@Test
	void hashCodeGeneratesHashCode() throws MalformedURLException {
		URL url = createJarUrl('file:example.jar!/entry.txt');
		assertThat(this.handler.hashCode(url)).isEqualTo(1873709601);
	}
	@Test
	void hashCodeWhenMalformedInnerUrlGeneratesHashCode() throws MalformedURLException {
		URL url = createJarUrl('example.jar!/entry.txt');
		assertThat(this.handler.hashCode(url)).isEqualTo(1870566566);
	}
	@Test
	void sameFileWhenSameReturnsTrue() throws MalformedURLException {
		URL url1 = createJarUrl('file:example.jar!/entry.txt');
		URL url2 = createJarUrl('file:example.jar!/entry.txt');
		assertThat(this.handler.sameFile(url1, url2)).isTrue();
	}
	@Test
	void sameFileWhenMissingSeparatorReturnsFalse() throws MalformedURLException {
		URL url1 = createJarUrl('file:example.jar!/entry.txt');
		URL url2 = createJarUrl('file:example.jar/entry.txt');
		assertThat(this.handler.sameFile(url1, url2)).isFalse();
	}
	@Test
	void sameFileWhenDifferentEntryReturnsFalse() throws MalformedURLException {
		URL url1 = createJarUrl('file:example.jar!/entry1.txt');
		URL url2 = createJarUrl('file:example.jar!/entry2.txt');
		assertThat(this.handler.sameFile(url1, url2)).isFalse();
	}
	@Test
	void sameFileWhenDifferentInnerUrlReturnsFalse() throws MalformedURLException {
		URL url1 = createJarUrl('file:example1.jar!/entry.txt');
		URL url2 = createJarUrl('file:example2.jar!/entry.txt');
		assertThat(this.handler.sameFile(url1, url2)).isFalse();
	}
	@Test
	void sameFileWhenSameMalformedInnerUrlReturnsTrue() throws MalformedURLException {
		URL url1 = createJarUrl('example.jar!/entry.txt');
		URL url2 = createJarUrl('example.jar!/entry.txt');
		assertThat(this.handler.sameFile(url1, url2)).isTrue();
	}
	@Test
	void sameFileWhenDifferentMalformedInnerUrlReturnsFalse() throws MalformedURLException {
		URL url1 = createJarUrl('example1.jar!/entry.txt');
		URL url2 = createJarUrl('example2.jar!/entry.txt');
		assertThat(this.handler.sameFile(url1, url2)).isFalse();
	}
	private URL createJarUrl(String file) throws MalformedURLException {
		return new URL('jar', null, -1, file, this.handler);
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
@AssertFileChannelDataBlocksClosed
class JarUrlConnectionTests {
	@TempDir
	File temp;
	private File file;
	private URL url;
	@BeforeAll
	static void registerHandlers() {
		Handlers.register();
	}
	@BeforeEach
	@AfterEach
	void reset() {
		JarUrlConnection.clearCache();
		Optimizations.disable();
	}
	@BeforeEach
	void setup() throws Exception {
		this.file = new File(this.temp, 'test.jar');
		TestJar.create(this.file);
		this.url = JarUrl.create(this.file, 'nested.jar');
	}
	@Test
	void getJarFileReturnsJarFile() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		JarFile jarFile = connection.getJarFile();
		assertThat(jarFile).isNotNull();
		assertThat(jarFile.getEntry('3.dat')).isNotNull();
	}
	@Test
	void getJarEntryReturnsJarEntry() throws Exception {
		URL url = JarUrl.create(this.file, 'nested.jar', '3.dat');
		JarUrlConnection connection = JarUrlConnection.open(url);
		JarEntry entry = connection.getJarEntry();
		assertThat(entry).isNotNull();
		assertThat(entry.getName()).isEqualTo('3.dat');
	}
	@Test
	void getJarEntryWhenHasNoEntryNameReturnsNull() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		JarEntry entry = connection.getJarEntry();
		assertThat(entry).isNull();
	}
	@Test
	void getContentLengthReturnsContentLength() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		try (ZipContent content = ZipContent.open(this.file.toPath())) {
			int expected = content.getEntry('nested.jar').getUncompressedSize();
			assertThat(connection.getContentLength()).isEqualTo(expected);
		}
	}
	@Test
	void getContentLengthWhenLengthIsLargerThanMaxIntReturnsMinusOne() {
		JarUrlConnection connection = mock(JarUrlConnection.class);
		given(connection.getContentLength()).willCallRealMethod();
		given(connection.getContentLengthLong()).willReturn((long) Integer.MAX_VALUE + 1);
		assertThat(connection.getContentLength()).isEqualTo(-1);
	}
	@Test
	void getContentLengthLongWhenHasNoEntryReturnsSizeOfJar() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		try (ZipContent content = ZipContent.open(this.file.toPath())) {
			int expected = content.getEntry('nested.jar').getUncompressedSize();
			assertThat(connection.getContentLengthLong()).isEqualTo(expected);
		}
	}
	@Test
	void getContentLengthLongWhenHasEntryReturnsEntrySize() throws Exception {
		URL url = JarUrl.create(this.file, 'nested.jar', '3.dat');
		JarUrlConnection connection = JarUrlConnection.open(url);
		assertThat(connection.getContentLengthLong()).isEqualTo(1);
	}
	@Test
	void getContentLengthLongWhenCannotConnectReturnsMinusOne() throws IOException {
		JarUrlConnection connection = mock(JarUrlConnection.class);
		willThrow(IOException.class).given(connection).connect();
		given(connection.getContentLengthLong()).willCallRealMethod();
		assertThat(connection.getContentLengthLong()).isEqualTo(-1);
	}
	@Test
	void getContentTypeWhenHasNoEntryReturnsJavaJar() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		assertThat(connection.getContentType()).isEqualTo('x-java/jar');
	}
	@Test
	void getContentTypeWhenHasKnownStreamReturnsDeducedType() throws Exception {
		String content = '<?xml version=\'1.0\' encoding=\'UTF-8\'?><ok></ok>';
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(this.file))) {
			out.putNextEntry(new ZipEntry('test.dat'));
			out.write(content.getBytes(StandardCharsets.UTF_8));
			out.closeEntry();
		}
		JarUrlConnection connection = JarUrlConnection
			.open(new URL('jar:file:' + this.file.getAbsolutePath() + '!/test.dat'));
		assertThat(connection.getContentType()).isEqualTo('application/xml');
	}
	@Test
	void getContentTypeWhenNotKnownInStreamButKnownNameReturnsDeducedType() throws Exception {
		String content = 'nothinguseful';
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(this.file))) {
			out.putNextEntry(new ZipEntry('test.xml'));
			out.write(content.getBytes(StandardCharsets.UTF_8));
			out.closeEntry();
		}
		JarUrlConnection connection = JarUrlConnection
			.open(new URL('jar:file:' + this.file.getAbsolutePath() + '!/test.xml'));
		assertThat(connection.getContentType()).isEqualTo('application/xml');
	}
	@Test
	void getContentTypeWhenCannotBeDeducedReturnsContentUnknown() throws Exception {
		String content = 'nothinguseful';
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(this.file))) {
			out.putNextEntry(new ZipEntry('test.dat'));
			out.write(content.getBytes(StandardCharsets.UTF_8));
			out.closeEntry();
		}
		JarUrlConnection connection = JarUrlConnection
			.open(new URL('jar:file:' + this.file.getAbsolutePath() + '!/test.dat'));
		assertThat(connection.getContentType()).isEqualTo('content/unknown');
	}
	@Test
	void getHeaderFieldDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		given(jarFileConnection.getHeaderField('test')).willReturn('test');
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		assertThat(connection.getHeaderField('test')).isEqualTo('test');
	}
	@Test
	void getContentWhenHasEntryReturnsContentFromEntry() throws Exception {
		String content = 'hello';
		try (JarOutputStream out = new JarOutputStream(new FileOutputStream(this.file))) {
			out.putNextEntry(new ZipEntry('test.txt'));
			out.write(content.getBytes(StandardCharsets.UTF_8));
			out.closeEntry();
		}
		JarUrlConnection connection = JarUrlConnection
			.open(new URL('jar:file:' + this.file.getAbsolutePath() + '!/test.txt'));
		assertThat(connection.getContent()).isInstanceOf(FilterInputStream.class);
	}
	@Test
	void getContentWhenHasNoEntryReturnsJarFile() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		assertThat(connection.getContent()).isInstanceOf(JarFile.class);
	}
	@Test
	void getPermissionReturnJarConnectionPermission() throws IOException {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		Permission permission = mock(Permission.class);
		given(jarFileConnection.getPermission()).willReturn(permission);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		assertThat(connection.getPermission()).isSameAs(permission);
	}
	@Test
	void getInputStreamWhenNotNestedAndHasNoEntryThrowsException() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file));
		assertThatIOException().isThrownBy(connection::getInputStream).withMessage('no entry name specified');
	}
	@Test
	void getInputStreamWhenOptimizedWithoutReadAndHasCachedJarWithEntryReturnsEmptyInputStream() throws Exception {
		JarUrlConnection setupConnection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar'));
		setupConnection.connect();
		assertThat(JarUrlConnection.jarFiles.getCached(setupConnection.getJarFileURL())).isNotNull();
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', '3.dat'));
		connection.setUseCaches(false);
		Optimizations.enable(false);
		assertThat(connection.getInputStream()).isSameAs(JarUrlConnection.emptyInputStream);
	}
	@Test
	void getInputStreamWhenNoEntryAndOptimizedThrowsException() throws Exception {
		JarUrlConnection setupConnection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar'));
		setupConnection.connect();
		assertThat(JarUrlConnection.jarFiles.getCached(setupConnection.getJarFileURL())).isNotNull();
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', 'missing.dat'));
		Optimizations.enable(false);
		assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(connection::getInputStream)
			.isSameAs(JarUrlConnection.FILE_NOT_FOUND_EXCEPTION);
	}
	@Test
	void getInputStreamWhenNoEntryAndNotOptimizedThrowsException() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', 'missing.dat'));
		assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(connection::getInputStream)
			.withMessageContaining('JAR entry missing.dat not found in');
	}
	@Test // gh-38047
	void getInputStreamWhenNoEntryAndNestedReturnsFullJarInputStream() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar'));
		File outFile = new File(this.temp, 'out.zip');
		try (OutputStream out = new FileOutputStream(outFile)) {
			connection.getInputStream().transferTo(out);
		}
		try (JarFile outJar = new JarFile(outFile)) {
			assertThat(outJar.getEntry('3.dat')).isNotNull();
		}
	}
	@Test
	void getInputStreamReturnsInputStream() throws IOException {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', '3.dat'));
		try (InputStream in = connection.getInputStream()) {
			assertThat(in).hasBinaryContent(new byte[] { 3 });
		}
	}
	@Test
	void getInputStreamWhenNoCachedClosesJarFileOnClose() throws IOException {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', '3.dat'));
		connection.setUseCaches(false);
		InputStream in = connection.getInputStream();
		JarFile jarFile = (JarFile) ReflectionTestUtils.getField(connection, 'jarFile');
		jarFile = spy(jarFile);
		ReflectionTestUtils.setField(connection, 'jarFile', jarFile);
		in.close();
		then(jarFile).should().close();
	}
	@Test
	void getAllowUserInteractionDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		given(jarFileConnection.getAllowUserInteraction()).willReturn(true);
		assertThat(connection.getAllowUserInteraction()).isTrue();
		then(jarFileConnection).should().getAllowUserInteraction();
	}
	@Test
	void setAllowUserInteractionDelegatesToJarFileConnection() throws IOException {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		connection.setAllowUserInteraction(true);
		then(jarFileConnection).should().setAllowUserInteraction(true);
	}
	@Test
	void getUseCachesDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		given(jarFileConnection.getUseCaches()).willReturn(true);
		assertThat(connection.getUseCaches()).isTrue();
		then(jarFileConnection).should().getUseCaches();
	}
	@Test
	void setUseCachesDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		connection.setUseCaches(true);
		then(jarFileConnection).should().setUseCaches(true);
	}
	@Test
	void getDefaultUseCachesDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		given(jarFileConnection.getDefaultUseCaches()).willReturn(true);
		assertThat(connection.getDefaultUseCaches()).isTrue();
		then(jarFileConnection).should().getDefaultUseCaches();
	}
	@Test
	void setDefaultUseCachesDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		connection.setDefaultUseCaches(true);
		then(jarFileConnection).should().setDefaultUseCaches(true);
	}
	@Test
	void setIfModifiedSinceDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		connection.setIfModifiedSince(123L);
		then(jarFileConnection).should().setIfModifiedSince(123L);
	}
	@Test
	void getRequestPropertyDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		given(jarFileConnection.getRequestProperty('test')).willReturn('test');
		assertThat(connection.getRequestProperty('test')).isEqualTo('test');
		then(jarFileConnection).should().getRequestProperty('test');
	}
	@Test
	void setRequestPropertyDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		connection.setRequestProperty('test', 'testvalue');
		then(jarFileConnection).should().setRequestProperty('test', 'testvalue');
	}
	@Test
	void addRequestPropertyDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		connection.addRequestProperty('test', 'testvalue');
		then(jarFileConnection).should().addRequestProperty('test', 'testvalue');
	}
	@Test
	void getRequestPropertiesDelegatesToJarFileConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection jarFileConnection = mock(URLConnection.class);
		ReflectionTestUtils.setField(connection, 'jarFileConnection', jarFileConnection);
		Map<String, List<String>> properties = Map.of('test', List.of('testvalue'));
		given(jarFileConnection.getRequestProperties()).willReturn(properties);
		assertThat(connection.getRequestProperties()).isEqualTo(properties);
		then(jarFileConnection).should().getRequestProperties();
	}
	@Test
	void connectWhenConnectedDoesNotReconnect() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		connection.connect();
		ReflectionTestUtils.setField(connection, 'jarFile', null);
		connection.connect();
		assertThat(ReflectionTestUtils.getField(connection, 'jarFile')).isNull();
	}
	@Test
	void connectWhenHasNotFoundSupplierThrowsException() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', 'missing.dat'));
		assertThat(connection).extracting('notFound').isNotNull();
		assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(connection::connect)
			.withMessageContaining('JAR entry missing.dat not found in');
	}
	@Test
	void connectWhenOptimizationsEnabledAndHasCachedJarWithoutEntryThrowsException() throws Exception {
		JarUrlConnection setupConnection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar'));
		setupConnection.connect();
		assertThat(JarUrlConnection.jarFiles.getCached(setupConnection.getJarFileURL())).isNotNull();
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', 'missing.dat'));
		Optimizations.enable(true);
		assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(connection::connect)
			.isSameAs(JarUrlConnection.FILE_NOT_FOUND_EXCEPTION);
	}
	@Test
	void connectWhenHasNoEntryConnects() throws Exception {
		JarUrlConnection setupConnection = JarUrlConnection.open(this.url);
		setupConnection.connect();
		assertThat(setupConnection.getJarFile()).isNotNull();
	}
	@Test
	void connectWhenEntryDoesNotExistAndOptimizationsEnabledThrowsException() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', 'missing.dat'));
		Optimizations.enable(true);
		assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(connection::connect)
			.isSameAs(JarUrlConnection.FILE_NOT_FOUND_EXCEPTION);
	}
	@Test
	void connectWhenEntryDoesNotExistAndNoOptimizationsEnabledThrowsException() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', 'missing.dat'));
		assertThatExceptionOfType(FileNotFoundException.class).isThrownBy(connection::connect)
			.withMessageContaining('JAR entry missing.dat not found in');
	}
	@Test
	void connectWhenEntryExists() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', '3.dat'));
		connection.connect();
		assertThat(connection.getJarEntry()).isNotNull();
	}
	@Test
	void connectWhenAddedToCacheReconnects() throws IOException {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		Object originalConnection = ReflectionTestUtils.getField(connection, 'jarFileConnection');
		connection.connect();
		assertThat(connection).extracting('jarFileConnection').isNotSameAs(originalConnection);
	}
	@Test
	void openWhenNestedAndInCachedWithoutEntryAndOptimizationsEnabledReturnsNoFoundConnection() throws Exception {
		JarUrlConnection setupConnection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar'));
		setupConnection.connect();
		assertThat(JarUrlConnection.jarFiles.getCached(setupConnection.getJarFileURL())).isNotNull();
		Optimizations.enable(true);
		JarUrlConnection connection = JarUrlConnection.open(JarUrl.create(this.file, 'nested.jar', 'missing.dat'));
		assertThat(connection).isSameAs(JarUrlConnection.NOT_FOUND_CONNECTION);
	}
	@Test
	void openReturnsConnection() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		assertThat(connection).isNotNull();
	}
	@Test // gh-38204
	void getLastModifiedReturnsFileModifiedTime() throws Exception {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		assertThat(connection.getLastModified()).isEqualTo(this.file.lastModified());
	}
	@Test // gh-38204
	void getLastModifiedHeaderReturnsFileModifiedTime() throws IOException {
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		URLConnection fileConnection = this.file.toURI().toURL().openConnection();
		try {
			assertThat(connection.getHeaderFieldDate('last-modified', 0))
				.isEqualTo(withoutNanos(this.file.lastModified()))
				.isEqualTo(fileConnection.getHeaderFieldDate('last-modified', 0));
		}
		finally {
			fileConnection.getInputStream().close();
		}
	}
	@Test
	void getJarFileWhenInFolderWithEncodedCharsReturnsJarFile() throws Exception {
		this.temp = new File(this.temp, 'te#st');
		this.temp.mkdirs();
		this.file = new File(this.temp, 'test.jar');
		this.url = JarUrl.create(this.file, 'nested.jar');
		assertThat(this.url.toString()).contains('te%23st');
		TestJar.create(this.file);
		JarUrlConnection connection = JarUrlConnection.open(this.url);
		JarFile jarFile = connection.getJarFile();
		assertThat(jarFile).isNotNull();
		assertThat(jarFile.getEntry('3.dat')).isNotNull();
	}
	private long withoutNanos(long epochMilli) {
		return Instant.ofEpochMilli(epochMilli).with(ChronoField.NANO_OF_SECOND, 0).toEpochMilli();
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
@AssertFileChannelDataBlocksClosed
class UrlJarFileTests {
	@TempDir
	File temp;
	private UrlJarFile jarFile;
	@Mock
	private Consumer<JarFile> closeAction;
	@BeforeEach
	void setup() throws Exception {
		MockitoAnnotations.openMocks(this);
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		this.jarFile = new UrlJarFile(file, Runtime.version(), this.closeAction);
	}
	@AfterEach
	void cleanup() throws Exception {
		this.jarFile.close();
	}
	@Test
	void getEntryWhenNotfoundReturnsNull() {
		assertThat(this.jarFile.getEntry('missing')).isNull();
	}
	@Test
	void getEntryWhenFoundReturnsUrlJarEntry() {
		assertThat(this.jarFile.getEntry('1.dat')).isInstanceOf(UrlJarEntry.class);
	}
	@Test
	void getManifestReturnsNewCopy() throws Exception {
		Manifest manifest1 = this.jarFile.getManifest();
		Manifest manifest2 = this.jarFile.getManifest();
		assertThat(manifest1).isNotSameAs(manifest2);
	}
	@Test
	void closeCallsCloseAction() throws Exception {
		this.jarFile.close();
		then(this.closeAction).should().accept(this.jarFile);
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlNestedJarFileTests {
	@TempDir
	File temp;
	private UrlNestedJarFile jarFile;
	@Mock
	private Consumer<JarFile> closeAction;
	@BeforeEach
	void setup() throws Exception {
		MockitoAnnotations.openMocks(this);
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		this.jarFile = new UrlNestedJarFile(file, 'multi-release.jar', Runtime.version(), this.closeAction);
	}
	@AfterEach
	void cleanup() throws Exception {
		this.jarFile.close();
	}
	@Test
	void getEntryWhenNotfoundReturnsNull() {
		assertThat(this.jarFile.getEntry('missing')).isNull();
	}
	@Test
	void getEntryWhenFoundReturnsUrlJarEntry() {
		assertThat(this.jarFile.getEntry('multi-release.dat')).isInstanceOf(UrlJarEntry.class);
	}
	@Test
	void getManifestReturnsNewCopy() throws Exception {
		Manifest manifest1 = this.jarFile.getManifest();
		Manifest manifest2 = this.jarFile.getManifest();
		assertThat(manifest1).isNotSameAs(manifest2);
	}
	@Test
	void closeCallsCloseAction() throws Exception {
		this.jarFile.close();
		then(this.closeAction).should().accept(this.jarFile);
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlJarManifestTests {
	@Test
	void getWhenSuppliedManifestIsNullReturnsNull() throws Exception {
		UrlJarManifest urlJarManifest = new UrlJarManifest(() -> null);
		assertThat(urlJarManifest.get()).isNull();
	}
	@Test
	void getAlwaysReturnsDeepCopy() throws Exception {
		Manifest manifest = new Manifest();
		UrlJarManifest urlJarManifest = new UrlJarManifest(() -> manifest);
		manifest.getMainAttributes().putValue('test', 'one');
		manifest.getEntries().put('spring', new Attributes());
		Manifest copy = urlJarManifest.get();
		assertThat(copy).isNotSameAs(manifest);
		manifest.getMainAttributes().clear();
		manifest.getEntries().clear();
		assertThat(copy.getMainAttributes()).isNotEmpty();
		assertThat(copy.getAttributes('spring')).isNotNull();
	}
	@Test
	void getEntryAttributesWhenSuppliedManifestIsNullReturnsNull() throws Exception {
		UrlJarManifest urlJarManifest = new UrlJarManifest(() -> null);
		assertThat(urlJarManifest.getEntryAttributes(new JarEntry('test'))).isNull();
	}
	@Test
	void getEntryAttributesReturnsDeepCopy() throws Exception {
		Manifest manifest = new Manifest();
		UrlJarManifest urlJarManifest = new UrlJarManifest(() -> manifest);
		Attributes attributes = new Attributes();
		attributes.putValue('test', 'test');
		manifest.getEntries().put('spring', attributes);
		Attributes copy = urlJarManifest.getEntryAttributes(new JarEntry('spring'));
		assertThat(copy).isNotSameAs(attributes);
		attributes.clear();
		assertThat(copy.getValue('test')).isNotNull();
	}
	@Test
	void supplierIsOnlyCalledOnce() throws IOException {
		ManifestSupplier supplier = mock(ManifestSupplier.class);
		UrlJarManifest urlJarManifest = new UrlJarManifest(supplier);
		urlJarManifest.get();
		urlJarManifest.get();
		then(supplier).should(times(1)).getManifest();
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class LazyDelegatingInputStreamTests {
	private InputStream delegate = mock(InputStream.class);
	private TestLazyDelegatingInputStream inputStream = new TestLazyDelegatingInputStream();
	@Test
	void noOperationsDoesNotGetDelegateInputStream() {
		then(this.delegate).shouldHaveNoInteractions();
	}
	@Test
	void readDelegatesToInputStream() throws Exception {
		this.inputStream.read();
		then(this.delegate).should().read();
	}
	@Test
	void readWithByteArrayDelegatesToInputStream() throws Exception {
		byte[] bytes = new byte[1];
		this.inputStream.read(bytes);
		then(this.delegate).should().read(bytes);
	}
	@Test
	void readWithByteArrayAndOffsetAndLenDelegatesToInputStream() throws Exception {
		byte[] bytes = new byte[1];
		this.inputStream.read(bytes, 0, 1);
		then(this.delegate).should().read(bytes, 0, 1);
	}
	@Test
	void skipDelegatesToInputStream() throws Exception {
		this.inputStream.skip(10);
		then(this.delegate).should().skip(10);
	}
	@Test
	void availableDelegatesToInputStream() throws Exception {
		this.inputStream.available();
		then(this.delegate).should().available();
	}
	@Test
	void markSupportedDelegatesToInputStream() {
		this.inputStream.markSupported();
		then(this.delegate).should().markSupported();
	}
	@Test
	void markDelegatesToInputStream() {
		this.inputStream.mark(10);
		then(this.delegate).should().mark(10);
	}
	@Test
	void resetDelegatesToInputStream() throws Exception {
		this.inputStream.reset();
		then(this.delegate).should().reset();
	}
	@Test
	void closeWhenDelegateNotCreatedDoesNothing() throws Exception {
		this.inputStream.close();
		then(this.delegate).shouldHaveNoInteractions();
	}
	@Test
	void closeDelegatesToInputStream() throws Exception {
		this.inputStream.available();
		this.inputStream.close();
		then(this.delegate).should().close();
	}
	@Test
	void getDelegateInputStreamIsOnlyCalledOnce() throws Exception {
		this.inputStream.available();
		this.inputStream.mark(10);
		this.inputStream.read();
		assertThat(this.inputStream.count).isOne();
	}
	private final class TestLazyDelegatingInputStream extends LazyDelegatingInputStream {
		private int count;
		@Override
		protected InputStream getDelegateInputStream() throws IOException {
			this.count++;
			return LazyDelegatingInputStreamTests.this.delegate;
		}
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
@AssertFileChannelDataBlocksClosed
class UrlJarFileFactoryTests {
	@TempDir
	File temp;
	private final UrlJarFileFactory factory = new UrlJarFileFactory();
	@Mock
	private Consumer<JarFile> closeAction;
	@BeforeAll
	static void registerHandlers() {
		Handlers.register();
	}
	@BeforeEach
	void setup() {
		MockitoAnnotations.openMocks(this);
	}
	@Test
	void createJarFileWhenLocalFile() throws Throwable {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		URL url = file.toURI().toURL();
		JarFile jarFile = this.factory.createJarFile(url, this.closeAction);
		assertThat(jarFile).isInstanceOf(UrlJarFile.class);
		assertThat(jarFile).hasFieldOrPropertyWithValue('closeAction', this.closeAction);
	}
	@Test
	void createJarFileWhenNested() throws Throwable {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		URL url = new URL('nested:' + file.getPath() + '/!nested.jar');
		JarFile jarFile = this.factory.createJarFile(url, this.closeAction);
		assertThat(jarFile).isInstanceOf(UrlNestedJarFile.class);
		assertThat(jarFile).hasFieldOrPropertyWithValue('closeAction', this.closeAction);
	}
	@Test
	void createJarFileWhenStream() throws Exception {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		HttpServer server = HttpServer.create(new InetSocketAddress(0), 0);
		server.createContext('/test', (exchange) -> {
			exchange.sendResponseHeaders(200, file.length());
			try (InputStream in = new FileInputStream(file)) {
				in.transferTo(exchange.getResponseBody());
			}
			exchange.close();
		});
		server.start();
		try {
			URL url = new URL('http://localhost:' + server.getAddress().getPort() + '/test');
			JarFile jarFile = this.factory.createJarFile(url, this.closeAction);
			assertThat(jarFile).isInstanceOf(UrlJarFile.class);
			assertThat(jarFile).hasFieldOrPropertyWithValue('closeAction', this.closeAction);
		}
		finally {
			server.stop(0);
		}
	}
	@Test
	void createWhenHasRuntimeRef() {
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class JarUrlTests {
	@TempDir
	File temp;
	File jarFile;
	String jarFileUrlPath;
	@BeforeEach
	void setup() throws MalformedURLException {
		this.jarFile = new File(this.temp, 'my.jar');
		this.jarFileUrlPath = this.jarFile.toURI().toURL().toString().substring('file:'.length()).replace('!', '%21');
	}
	@Test
	void createWithFileReturnsUrl() {
		URL url = JarUrl.create(this.jarFile);
		assertThat(url).hasToString('jar:file:%s!/'.formatted(this.jarFileUrlPath));
	}
	@Test
	void createWithFileAndEntryReturnsUrl() {
		JarEntry entry = new JarEntry('lib.jar');
		URL url = JarUrl.create(this.jarFile, entry);
		assertThat(url).hasToString('jar:nested:%s/!lib.jar!/'.formatted(this.jarFileUrlPath));
	}
	@Test
	void createWithFileAndNullEntryReturnsUrl() {
		URL url = JarUrl.create(this.jarFile, (JarEntry) null);
		assertThat(url).hasToString('jar:file:%s!/'.formatted(this.jarFileUrlPath));
	}
	@Test
	void createWithFileAndNameReturnsUrl() {
		URL url = JarUrl.create(this.jarFile, 'lib.jar');
		assertThat(url).hasToString('jar:nested:%s/!lib.jar!/'.formatted(this.jarFileUrlPath));
	}
	@Test
	void createWithFileAndNullNameReturnsUrl() {
		URL url = JarUrl.create(this.jarFile, (String) null);
		assertThat(url).hasToString('jar:file:%s!/'.formatted(this.jarFileUrlPath));
	}
	@Test
	void createWithFileNameAndPathReturnsUrl() {
		URL url = JarUrl.create(this.jarFile, 'lib.jar', 'com/example/My.class');
		assertThat(url).hasToString('jar:nested:%s/!lib.jar!/com/example/My.class'.formatted(this.jarFileUrlPath));
	}
	@Test
	void createWithReservedCharsInName() throws Exception {
		String badFolderName = 'foo#bar!/baz/!oof';
		this.temp = new File(this.temp, badFolderName);
		setup();
		URL url = JarUrl.create(this.jarFile, 'lib.jar', 'com/example/My.class');
		assertThat(url).hasToString('jar:nested:%s/!lib.jar!/com/example/My.class'.formatted(this.jarFileUrlPath));
		assertThat(UrlDecoder.decode(url.toString())).contains(badFolderName);
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class OptimizationsTests {
	@AfterEach
	void reset() {
		Optimizations.disable();
	}
	@Test
	void defaultIsNotEnabled() {
		assertThat(Optimizations.isEnabled()).isFalse();
		assertThat(Optimizations.isEnabled(true)).isFalse();
		assertThat(Optimizations.isEnabled(false)).isFalse();
	}
	@Test
	void enableWithReadContentsEnables() {
		Optimizations.enable(true);
		assertThat(Optimizations.isEnabled()).isTrue();
		assertThat(Optimizations.isEnabled(true)).isTrue();
		assertThat(Optimizations.isEnabled(false)).isFalse();
	}
	@Test
	void enableWithoutReadContentsEnables() {
		Optimizations.enable(false);
		assertThat(Optimizations.isEnabled()).isTrue();
		assertThat(Optimizations.isEnabled(true)).isFalse();
		assertThat(Optimizations.isEnabled(false)).isTrue();
	}
	@Test
	void enableIsByThread() throws InterruptedException {
		Optimizations.enable(true);
		boolean[] enabled = new boolean[1];
		Thread thread = new Thread(() -> enabled[0] = Optimizations.isEnabled());
		thread.start();
		thread.join();
		assertThat(enabled[0]).isFalse();
	}
	@Test
	void disableDisables() {
		Optimizations.enable(true);
		Optimizations.disable();
		assertThat(Optimizations.isEnabled()).isFalse();
		assertThat(Optimizations.isEnabled(true)).isFalse();
		assertThat(Optimizations.isEnabled(false)).isFalse();
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class JarFileUrlKeyTests {
	@BeforeAll
	static void setup() {
		Handlers.register();
	}
	@Test
	void getCreatesKey() throws Exception {
		URL url = new URL('jar:nested:/my.jar/!mynested.jar!/my/path');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('jar:nested:/my.jar/!mynested.jar!/my/path');
	}
	@Test
	void getWhenUppercaseProtocolCreatesKey() throws Exception {
		URL url = new URL('JAR:nested:/my.jar/!mynested.jar!/my/path');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('jar:nested:/my.jar/!mynested.jar!/my/path');
	}
	@Test
	void getWhenHasHostAndPortCreatesKey() throws Exception {
		URL url = new URL('https://example.com:1234/test');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('https:example.com:1234/test');
	}
	@Test
	void getWhenHasUppercaseHostCreatesKey() throws Exception {
		URL url = new URL('https://EXAMPLE.com:1234/test');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('https:example.com:1234/test');
	}
	@Test
	void getWhenHasNoPortCreatesKeyWithDefaultPort() throws Exception {
		URL url = new URL('https://EXAMPLE.com/test');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('https:example.com:443/test');
	}
	@Test
	void getWhenHasNoFileCreatesKey() throws Exception {
		URL url = new URL('https://EXAMPLE.com');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('https:example.com:443');
	}
	@Test
	void getWhenHasRuntimeRefCreatesKey() throws Exception {
		URL url = new URL('jar:nested:/my.jar/!mynested.jar!/my/path#runtime');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('jar:nested:/my.jar/!mynested.jar!/my/path#runtime');
	}
	@Test
	void getWhenHasOtherRefCreatesKeyWithoutRef() throws Exception {
		URL url = new URL('jar:nested:/my.jar/!mynested.jar!/my/path#example');
		assertThat(JarFileUrlKey.get(url)).isEqualTo('jar:nested:/my.jar/!mynested.jar!/my/path');
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
@AssertFileChannelDataBlocksClosed
class UrlJarFilesTests {
	@TempDir
	File temp;
	private UrlJarFileFactory factory = mock(UrlJarFileFactory.class);
	private final UrlJarFiles jarFiles = new UrlJarFiles(this.factory);
	private File file;
	private URL url;
	@BeforeAll
	static void registerHandlers() {
		Handlers.register();
	}
	@BeforeEach
	void setup() throws Exception {
		this.file = new File(this.temp, 'test.jar');
		this.url = new URL('nested:' + this.file.getAbsolutePath() + '/!nested.jar');
		TestJar.create(this.file);
	}
	@Test
	void getOrCreateWhenNotUsingCachesAlwaysCreatesNewJarFile() throws Exception {
		given(this.factory.createJarFile(any(), any())).willCallRealMethod();
		JarFile jarFile1 = this.jarFiles.getOrCreate(false, this.url);
		JarFile jarFile2 = this.jarFiles.getOrCreate(false, this.url);
		JarFile jarFile3 = this.jarFiles.getOrCreate(false, this.url);
		assertThat(jarFile1).isNotSameAs(jarFile2).isNotSameAs(jarFile3);
	}
	@Test
	void getOrCreateWhenUsingCachingReturnsCachedWhenAvailable() throws Exception {
		given(this.factory.createJarFile(any(), any())).willCallRealMethod();
		JarFile jarFile1 = this.jarFiles.getOrCreate(true, this.url);
		this.jarFiles.cacheIfAbsent(true, this.url, jarFile1);
		JarFile jarFile2 = this.jarFiles.getOrCreate(true, this.url);
		JarFile jarFile3 = this.jarFiles.getOrCreate(true, this.url);
		assertThat(jarFile1).isSameAs(jarFile2).isSameAs(jarFile3);
	}
	@Test
	void getCachedWhenNotCachedReturnsNull() {
		assertThat(this.jarFiles.getCached(this.url)).isNull();
	}
	@Test
	void getCachedWhenCachedReturnsCachedJar() throws Exception {
		given(this.factory.createJarFile(any(), any())).willCallRealMethod();
		JarFile jarFile = this.factory.createJarFile(this.url, null);
		this.jarFiles.cacheIfAbsent(true, this.url, jarFile);
		assertThat(this.jarFiles.getCached(this.url)).isSameAs(jarFile);
	}
	@Test
	void cacheIfAbsentWhenNotUsingCachesDoesNotCacheAndReturnsFalse() throws Exception {
		given(this.factory.createJarFile(any(), any())).willCallRealMethod();
		JarFile jarFile = this.factory.createJarFile(this.url, null);
		this.jarFiles.cacheIfAbsent(false, this.url, jarFile);
		assertThat(this.jarFiles.getCached(this.url)).isNull();
	}
	@Test
	void cacheIfAbsentWhenUsingCachingAndNotAlreadyCachedCachesAndReturnsTrue() throws Exception {
		given(this.factory.createJarFile(any(), any())).willCallRealMethod();
		JarFile jarFile = this.factory.createJarFile(this.url, null);
		assertThat(this.jarFiles.cacheIfAbsent(true, this.url, jarFile)).isTrue();
		assertThat(this.jarFiles.getCached(this.url)).isSameAs(jarFile);
	}
	@Test
	void cacheIfAbsentWhenUsingCachingAndAlreadyCachedLeavesCacheAndReturnsFalse() throws Exception {
		given(this.factory.createJarFile(any(), any())).willCallRealMethod();
		JarFile jarFile1 = this.factory.createJarFile(this.url, null);
		JarFile jarFile2 = this.factory.createJarFile(this.url, null);
		assertThat(this.jarFiles.cacheIfAbsent(true, this.url, jarFile1)).isTrue();
		assertThat(this.jarFiles.cacheIfAbsent(true, this.url, jarFile2)).isFalse();
		assertThat(this.jarFiles.getCached(this.url)).isSameAs(jarFile1);
	}
	@Test
	void closeIfNotCachedWhenNotCachedClosesJarFile() throws Exception {
		JarFile jarFile = mock(JarFile.class);
		this.jarFiles.closeIfNotCached(this.url, jarFile);
		then(jarFile).should().close();
	}
	@Test
	void closeIfNotCachedWhenCachedDoesNotCloseJarFile() throws Exception {
		JarFile jarFile = mock(JarFile.class);
		this.jarFiles.cacheIfAbsent(true, this.url, jarFile);
		this.jarFiles.closeIfNotCached(this.url, jarFile);
		then(jarFile).should(never()).close();
	}
	@Test
	void reconnectReconnectsAndAppliesUseCaches() throws Exception {
		JarFile jarFile = mock(JarFile.class);
		this.jarFiles.cacheIfAbsent(true, this.url, jarFile);
		URLConnection existingConnection = mock(URLConnection.class);
		given(existingConnection.getUseCaches()).willReturn(true);
		URLConnection connection = this.jarFiles.reconnect(jarFile, existingConnection);
		assertThat(connection).isNotSameAs(existingConnection);
		assertThat(connection.getUseCaches()).isTrue();
	}
	@Test
	void reconnectWhenExistingConnectionIsNullReconnects() throws Exception {
		JarFile jarFile = mock(JarFile.class);
		this.jarFiles.cacheIfAbsent(true, this.url, jarFile);
		URLConnection connection = this.jarFiles.reconnect(jarFile, null);
		assertThat(connection).isNotNull();
		assertThat(connection.getUseCaches()).isTrue();
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class CanonicalizerTests {
	@Test
	void canonicalizeAfterOnlyChangesAfterPos() {
		String prefix = '/foo/.././bar/.!/foo/.././bar/.';
		String canonicalized = Canonicalizer.canonicalizeAfter(prefix, prefix.indexOf('!/'));
		assertThat(canonicalized).isEqualTo('/foo/.././bar/.!/bar/');
	}
	@Test
	void canonicalizeWhenHasEmbeddedSlashDotDotSlash() {
		assertThat(Canonicalizer.canonicalize('/foo/../bar/bif/bam/../../baz')).isEqualTo('/bar/baz');
	}
	@Test
	void canonicalizeWhenHasEmbeddedSlashDotSlash() {
		assertThat(Canonicalizer.canonicalize('/foo/./bar/bif/bam/././baz')).isEqualTo('/foo/bar/bif/bam/baz');
	}
	@Test
	void canonicalizeWhenHasTrailingSlashDotDot() {
		assertThat(Canonicalizer.canonicalize('/foo/bar/baz/../..')).isEqualTo('/foo/');
	}
	@Test
	void canonicalizeWhenHasTrailingSlashDot() {
		assertThat(Canonicalizer.canonicalize('/foo/bar/baz/./.')).isEqualTo('/foo/bar/baz/');
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
@AssertFileChannelDataBlocksClosed
class JarUrlClassLoaderTests {
	private static final URL APP_JAR;
	static {
		try {
			APP_JAR = new URL('jar:file:src/test/resources/jars/app.jar!/');
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	@TempDir
	File tempDir;
	@BeforeAll
	static void setup() {
		Handlers.register();
	}
	@Test
	void resolveResourceFromArchive() throws Exception {
		try (JarUrlClassLoader loader = new TestJarUrlClassLoader(APP_JAR)) {
			assertThat(loader.getResource('demo/Application.java')).isNotNull();
		}
	}
	@Test
	void resolveResourcesFromArchive() throws Exception {
		try (JarUrlClassLoader loader = new TestJarUrlClassLoader(APP_JAR)) {
			assertThat(loader.getResources('demo/Application.java').hasMoreElements()).isTrue();
		}
	}
	@Test
	void resolveRootPathFromArchive() throws Exception {
		try (JarUrlClassLoader loader = new TestJarUrlClassLoader(APP_JAR)) {
			assertThat(loader.getResource('')).isNotNull();
		}
	}
	@Test
	void resolveRootResourcesFromArchive() throws Exception {
		try (JarUrlClassLoader loader = new TestJarUrlClassLoader(APP_JAR)) {
			assertThat(loader.getResources('').hasMoreElements()).isTrue();
		}
	}
	@Test
	void resolveFromNested() throws Exception {
		File jarFile = new File(this.tempDir, 'test.jar');
		TestJar.create(jarFile);
		URL url = JarUrl.create(jarFile, 'nested.jar');
		try (JarUrlClassLoader loader = new TestJarUrlClassLoader(url)) {
			URL resource = loader.getResource('3.dat');
			assertThat(resource).hasToString(url + '3.dat');
			try (InputStream input = resource.openConnection().getInputStream()) {
				assertThat(input.read()).isEqualTo(3);
			}
		}
	}
	@Test
	void loadClass() throws Exception {
		try (JarUrlClassLoader loader = new TestJarUrlClassLoader(APP_JAR)) {
			assertThat(loader.loadClass('demo.Application')).isNotNull().hasToString('class demo.Application');
		}
	}
	@Test
	void loadClassFromNested() throws Exception {
		File appJar = new File('src/test/resources/jars/app.jar');
		File jarFile = new File(this.tempDir, 'test.jar');
		FileOutputStream fileOutputStream = new FileOutputStream(jarFile);
		try (JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream)) {
			JarEntry nestedEntry = new JarEntry('app.jar');
			byte[] nestedJarData = Files.readAllBytes(appJar.toPath());
			nestedEntry.setSize(nestedJarData.length);
			nestedEntry.setCompressedSize(nestedJarData.length);
			CRC32 crc32 = new CRC32();
			crc32.update(nestedJarData);
			nestedEntry.setCrc(crc32.getValue());
			nestedEntry.setMethod(ZipEntry.STORED);
			jarOutputStream.putNextEntry(nestedEntry);
			jarOutputStream.write(nestedJarData);
			jarOutputStream.closeEntry();
		}
		URL url = JarUrl.create(jarFile, 'app.jar');
		try (JarUrlClassLoader loader = new TestJarUrlClassLoader(url)) {
			assertThat(loader.loadClass('demo.Application')).isNotNull().hasToString('class demo.Application');
		}
	}
	static class TestJarUrlClassLoader extends JarUrlClassLoader {
		TestJarUrlClassLoader(URL... urls) {
			super(urls, JarUrlClassLoaderTests.class.getClassLoader());
		}
	}
}
/*
package org.springframework.boot.loader.net.protocol.nested;
/**
class HandlerTests {
	@TempDir
	File temp;
	@BeforeAll
	static void registerHandlers() {
		Handlers.register();
	}
	@Test
	void openConnectionReturnsNestedUrlConnection() throws Exception {
		URL url = new URL('nested:' + this.temp.getAbsolutePath() + '/!nested.jar');
		assertThat(url.openConnection()).isInstanceOf(NestedUrlConnection.class);
	}
	@Test
	void assertUrlIsNotMalformedWhenUrlIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Handler.assertUrlIsNotMalformed(null))
			.withMessageContaining('"url" must not be null');
	}
	@Test
	void assertUrlIsNotMalformedWhenUrlIsNotNestedThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> Handler.assertUrlIsNotMalformed('file:'))
			.withMessageContaining('must use "nested"');
	}
	@Test
	void assertUrlIsNotMalformedWhenUrlIsValidDoesNotThrowException() {
		String url = 'nested:' + this.temp.getAbsolutePath() + '/!nested.jar';
		assertThatNoException().isThrownBy(() -> Handler.assertUrlIsNotMalformed(url));
	}
}
/*
package org.springframework.boot.loader.net.protocol.nested;
/**
@AssertFileChannelDataBlocksClosed
class NestedUrlConnectionTests {
	@TempDir
	File temp;
	private File jarFile;
	private URL url;
	@BeforeAll
	static void registerHandlers() {
		Handlers.register();
	}
	@BeforeEach
	void setup() throws Exception {
		this.jarFile = new File(this.temp, 'test.jar');
		TestJar.create(this.jarFile);
		this.url = new URL('nested:' + this.jarFile.getAbsolutePath() + '/!nested.jar');
	}
	@Test
	void getContentLengthWhenContentLengthMoreThanMaxIntReturnsMinusOne() {
		NestedUrlConnection connection = mock(NestedUrlConnection.class);
		given(connection.getContentLength()).willCallRealMethod();
		given(connection.getContentLengthLong()).willReturn((long) Integer.MAX_VALUE + 1);
		assertThat(connection.getContentLength()).isEqualTo(-1);
	}
	@Test
	void getContentLengthGetsContentLength() throws Exception {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		try (ZipContent zipContent = ZipContent.open(this.jarFile.toPath())) {
			int expectedSize = zipContent.getEntry('nested.jar').getUncompressedSize();
			assertThat(connection.getContentLength()).isEqualTo(expectedSize);
		}
	}
	@Test
	void getContentLengthLongReturnsContentLength() throws Exception {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		try (ZipContent zipContent = ZipContent.open(this.jarFile.toPath())) {
			int expectedSize = zipContent.getEntry('nested.jar').getUncompressedSize();
			assertThat(connection.getContentLengthLong()).isEqualTo(expectedSize);
		}
	}
	@Test
	void getContentTypeReturnsJavaJar() throws Exception {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		assertThat(connection.getContentType()).isEqualTo('x-java/jar');
	}
	@Test
	void getLastModifiedReturnsFileLastModified() throws Exception {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		assertThat(connection.getLastModified()).isEqualTo(this.jarFile.lastModified());
	}
	@Test
	void getPermissionReturnsFilePermission() throws Exception {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		Permission permission = connection.getPermission();
		assertThat(permission).isInstanceOf(FilePermission.class);
		assertThat(permission.getName()).isEqualTo(this.jarFile.getCanonicalPath());
	}
	@Test
	void getInputStreamReturnsContentOfNestedJar() throws Exception {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		assertHasSameContentAsNestedJar(connection);
	}
	@Test
	void inputStreamCloseCleansResource() throws Exception {
		Cleaner cleaner = mock(Cleaner.class);
		Cleanable cleanable = mock(Cleanable.class);
		given(cleaner.register(any(), any())).willReturn(cleanable);
		NestedUrlConnection connection = new NestedUrlConnection(this.url, cleaner);
		connection.getInputStream().close();
		then(cleanable).should().clean();
		ArgumentCaptor<Runnable> actionCaptor = ArgumentCaptor.forClass(Runnable.class);
		then(cleaner).should().register(any(), actionCaptor.capture());
		actionCaptor.getValue().run();
	}
	@Test // gh-38204
	void getLastModifiedReturnsFileModifiedTime() throws Exception {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		assertThat(connection.getLastModified()).isEqualTo(this.jarFile.lastModified());
	}
	@Test // gh-38204
	void getLastModifiedHeaderReturnsFileModifiedTime() throws IOException {
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		URLConnection fileConnection = this.jarFile.toURI().toURL().openConnection();
		try {
			assertThat(connection.getHeaderFieldDate('last-modified', 0))
				.isEqualTo(withoutNanos(this.jarFile.lastModified()))
				.isEqualTo(fileConnection.getHeaderFieldDate('last-modified', 0));
		}
		finally {
			fileConnection.getInputStream().close();
		}
	}
	@Test
	void createDecodesUrlPath() throws Exception {
		File withSpace = new File(this.temp, 'te st');
		withSpace.mkdirs();
		this.jarFile = new File(withSpace, 'test.jar');
		TestJar.create(this.jarFile);
		this.url = new URL('nested:' + this.jarFile.toURI().getRawPath() + '/!nested.jar');
		assertThat(this.url.toString()).contains('%20');
		NestedUrlConnection connection = new NestedUrlConnection(this.url);
		assertHasSameContentAsNestedJar(connection);
		assertThat(connection.getLastModified()).isEqualTo(this.jarFile.lastModified());
	}
	private void assertHasSameContentAsNestedJar(NestedUrlConnection connection) throws IOException {
		try (InputStream actual = connection.getInputStream()) {
			try (ZipContent zipContent = ZipContent.open(this.jarFile.toPath())) {
				try (InputStream expected = zipContent.getEntry('nested.jar').openContent().asInputStream()) {
					assertThat(actual).hasSameContentAs(expected);
				}
			}
		}
	}
	private long withoutNanos(long epochMilli) {
		return Instant.ofEpochMilli(epochMilli).with(ChronoField.NANO_OF_SECOND, 0).toEpochMilli();
	}
}
/*
package org.springframework.boot.loader.net.protocol.nested;
/**
class NestedLocationTests {
	@TempDir
	File temp;
	@BeforeAll
	static void registerHandlers() {
		Handlers.register();
	}
	@Test
	void createWhenPathIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new NestedLocation(null, 'nested.jar'))
			.withMessageContaining('"path" must not be null');
	}
	@Test
	void createWhenNestedEntryNameIsNull() {
		NestedLocation location = new NestedLocation(Path.of('test.jar'), null);
		assertThat(location.path().toString()).contains('test.jar');
		assertThat(location.nestedEntryName()).isNull();
	}
	@Test
	void createWhenNestedEntryNameIsEmpty() {
		NestedLocation location = new NestedLocation(Path.of('test.jar'), '');
		assertThat(location.path().toString()).contains('test.jar');
		assertThat(location.nestedEntryName()).isNull();
	}
	@Test
	void fromUrlWhenUrlIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> NestedLocation.fromUrl(null))
			.withMessageContaining('"url" must not be null');
	}
	@Test
	void fromUrlWhenNotNestedProtocolThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> NestedLocation.fromUrl(new URL('file://test.jar')))
			.withMessageContaining('must use "nested" protocol');
	}
	@Test
	void fromUrlWhenNoPathThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> NestedLocation.fromUrl(new URL('nested:')))
			.withMessageContaining('"location" must not be empty');
	}
	@Test
	void fromUrlWhenNoSeparator() throws Exception {
		File file = new File(this.temp, 'test.jar');
		NestedLocation location = NestedLocation.fromUrl(new URL('nested:' + file.getAbsolutePath() + '/'));
		assertThat(location.path()).isEqualTo(file.toPath());
		assertThat(location.nestedEntryName()).isNull();
	}
	@Test
	void fromUrlReturnsNestedLocation() throws Exception {
		File file = new File(this.temp, 'test.jar');
		NestedLocation location = NestedLocation
			.fromUrl(new URL('nested:' + file.getAbsolutePath() + '/!lib/nested.jar'));
		assertThat(location.path()).isEqualTo(file.toPath());
		assertThat(location.nestedEntryName()).isEqualTo('lib/nested.jar');
	}
	@Test
	void fromUriWhenUrlIsNullThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> NestedLocation.fromUri(null))
			.withMessageContaining('"uri" must not be null');
	}
	@Test
	void fromUriWhenNotNestedProtocolThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> NestedLocation.fromUri(new URI('file://test.jar')))
			.withMessageContaining('must use "nested" scheme');
	}
	@Test
	@Disabled
	void fromUriWhenNoSeparator() throws Exception {
		NestedLocation location = NestedLocation.fromUri(new URI('nested:test.jar!nested.jar'));
		assertThat(location.path().toString()).contains('test.jar!nested.jar');
		assertThat(location.nestedEntryName()).isNull();
	}
	@Test
	void fromUriReturnsNestedLocation() throws Exception {
		File file = new File(this.temp, 'test.jar');
		NestedLocation location = NestedLocation
			.fromUri(new URI('nested:' + file.getAbsoluteFile().toURI().getPath() + '/!lib/nested.jar'));
		assertThat(location.path()).isEqualTo(file.toPath());
		assertThat(location.nestedEntryName()).isEqualTo('lib/nested.jar');
	}
	@Test
	@EnabledOnOs(OS.WINDOWS)
	void windowsUncPathIsHandledCorrectly() throws MalformedURLException {
		NestedLocation location = NestedLocation.fromUrl(
				new URL('nested://localhost/c$/dev/temp/demo/build/libs/demo-0.0.1-SNAPSHOT.jar/!BOOT-INF/classes/'));
		assertThat(location.path()).asString()
			.isEqualTo('\\\\localhost\\c$\\dev\\temp\\demo\\build\\libs\\demo-0.0.1-SNAPSHOT.jar');
	}
}
/*
package org.springframework.boot.loader.net.util;
/**
class UrlDecoderTests {
	@Test
	void decodeWhenBasicString() {
		assertThat(UrlDecoder.decode('a/b/C.class')).isEqualTo('a/b/C.class');
	}
	@Test
	void decodeWhenHasSingleByteEncodedCharacters() {
		assertThat(UrlDecoder.decode('%61/%62/%43.class')).isEqualTo('a/b/C.class');
	}
	@Test
	void decodeWhenHasDoubleByteEncodedCharacters() {
		assertThat(UrlDecoder.decode('%c3%a1/b/C.class')).isEqualTo('\u00e1/b/C.class');
	}
	@Test
	void decodeWhenHasMixtureOfEncodedAndUnencodedDoubleByteCharacters() {
		assertThat(UrlDecoder.decode('%c3%a1/b/\u00c7.class')).isEqualTo('\u00e1/b/\u00c7.class');
	}
}
/*
package org.springframework.boot.loader.ref;
/**
public final class DefaultCleanerTracking {
	private DefaultCleanerTracking() {
	}
	public static void set(BiConsumer<Object, Cleanable> tracker) {
		DefaultCleaner.tracker = tracker;
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
class NestedFileStoreTests {
	@TempDir
	File temp;
	private NestedFileSystemProvider provider;
	private Path jarPath;
	private NestedFileSystem fileSystem;
	private TestNestedFileStore fileStore;
	@BeforeEach
	void setup() {
		this.provider = new NestedFileSystemProvider();
		this.jarPath = new File(this.temp, 'test.jar').toPath();
		this.fileSystem = new NestedFileSystem(this.provider, this.jarPath);
		this.fileStore = new TestNestedFileStore(this.fileSystem);
	}
	@Test
	void nameReturnsName() {
		assertThat(this.fileStore.name()).isEqualTo(this.jarPath.toAbsolutePath().toString());
	}
	@Test
	void typeReturnsNestedFs() {
		assertThat(this.fileStore.type()).isEqualTo('nestedfs');
	}
	@Test
	void isReadOnlyReturnsTrue() {
		assertThat(this.fileStore.isReadOnly()).isTrue();
	}
	@Test
	void getTotalSpaceReturnsZero() throws Exception {
		assertThat(this.fileStore.getTotalSpace()).isZero();
	}
	@Test
	void getUsableSpaceReturnsZero() throws Exception {
		assertThat(this.fileStore.getUsableSpace()).isZero();
	}
	@Test
	void getUnallocatedSpaceReturnsZero() throws Exception {
		assertThat(this.fileStore.getUnallocatedSpace()).isZero();
	}
	@Test
	void supportsFileAttributeViewWithClassDelegatesToJarPathFileStore() {
		FileStore jarFileStore = mock(FileStore.class);
		given(jarFileStore.supportsFileAttributeView(BasicFileAttributeView.class)).willReturn(true);
		this.fileStore.setJarPathFileStore(jarFileStore);
		assertThat(this.fileStore.supportsFileAttributeView(BasicFileAttributeView.class)).isTrue();
		then(jarFileStore).should().supportsFileAttributeView(BasicFileAttributeView.class);
	}
	@Test
	void supportsFileAttributeViewWithStringDelegatesToJarPathFileStore() {
		FileStore jarFileStore = mock(FileStore.class);
		given(jarFileStore.supportsFileAttributeView('basic')).willReturn(true);
		this.fileStore.setJarPathFileStore(jarFileStore);
		assertThat(this.fileStore.supportsFileAttributeView('basic')).isTrue();
		then(jarFileStore).should().supportsFileAttributeView('basic');
	}
	@Test
	void getFileStoreAttributeViewDelegatesToJarPathFileStore() {
		FileStore jarFileStore = mock(FileStore.class);
		TestFileStoreAttributeView attributeView = mock(TestFileStoreAttributeView.class);
		given(jarFileStore.getFileStoreAttributeView(TestFileStoreAttributeView.class)).willReturn(attributeView);
		this.fileStore.setJarPathFileStore(jarFileStore);
		assertThat(this.fileStore.getFileStoreAttributeView(TestFileStoreAttributeView.class)).isEqualTo(attributeView);
		then(jarFileStore).should().getFileStoreAttributeView(TestFileStoreAttributeView.class);
	}
	@Test
	void getAttributeDelegatesToJarPathFileStore() throws Exception {
		FileStore jarFileStore = mock(FileStore.class);
		given(jarFileStore.getAttribute('test')).willReturn('spring');
		this.fileStore.setJarPathFileStore(jarFileStore);
		assertThat(this.fileStore.getAttribute('test')).isEqualTo('spring');
		then(jarFileStore).should().getAttribute('test');
	}
	static class TestNestedFileStore extends NestedFileStore {
		TestNestedFileStore(NestedFileSystem fileSystem) {
			super(fileSystem);
		}
		private FileStore jarPathFileStore;
		void setJarPathFileStore(FileStore jarPathFileStore) {
			this.jarPathFileStore = jarPathFileStore;
		}
		@Override
		protected FileStore getJarPathFileStore() {
			return (this.jarPathFileStore != null) ? this.jarPathFileStore : super.getJarPathFileStore();
		}
	}
	abstract static class TestFileStoreAttributeView implements FileStoreAttributeView {
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
@AssertFileChannelDataBlocksClosed
class NestedFileSystemZipFileSystemIntegrationTests {
	@TempDir
	File temp;
	@Test
	void zip() throws Exception {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		URI uri = JarUrl.create(file).toURI();
		try (FileSystem fs = FileSystems.newFileSystem(uri, Collections.emptyMap())) {
			assertThat(Files.readAllBytes(fs.getPath('1.dat'))).containsExactly(0x1);
		}
	}
	@Test
	void nestedZip() throws Exception {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		URI uri = JarUrl.create(file, 'nested.jar').toURI();
		try (FileSystem fs = FileSystems.newFileSystem(uri, Collections.emptyMap())) {
			assertThat(Files.readAllBytes(fs.getPath('3.dat'))).containsExactly(0x3);
		}
	}
	@Test
	void nestedZipWithoutNewFileSystem() throws Exception {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		URI uri = JarUrl.create(file, 'nested.jar', '3.dat').toURI();
		Path path = Path.of(uri);
		assertThat(Files.readAllBytes(path)).containsExactly(0x3);
	}
	@Test // gh-38592
	void nestedZipSplitAndRestore() throws Exception {
		File file = new File(this.temp, 'test.jar');
		TestJar.create(file);
		URI uri = JarUrl.create(file, 'nested.jar', '3.dat').toURI();
		String[] components = uri.toString().split('!');
		System.out.println(List.of(components));
		try (FileSystem rootFs = FileSystems.newFileSystem(URI.create(components[0]), Collections.emptyMap())) {
			Path childPath = rootFs.getPath(components[1]);
			try (FileSystem childFs = FileSystems.newFileSystem(childPath)) {
				Path nestedRoot = childFs.getPath('/');
				assertThat(Files.list(nestedRoot)).hasSize(4);
				Path path = childFs.getPath(components[2]);
				assertThat(Files.readAllBytes(path)).containsExactly(0x3);
			}
		}
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
class NestedPathTests {
	@TempDir
	File temp;
	private NestedFileSystem fileSystem;
	private NestedFileSystemProvider provider;
	private Path jarPath;
	private NestedPath path;
	@BeforeEach
	void setup() {
		this.jarPath = new File(this.temp, 'test.jar').toPath();
		this.provider = new NestedFileSystemProvider();
		this.fileSystem = new NestedFileSystem(this.provider, this.jarPath);
		this.path = new NestedPath(this.fileSystem, 'nested.jar');
	}
	@Test
	void getJarPathReturnsJarPath() {
		assertThat(this.path.getJarPath()).isEqualTo(this.jarPath);
	}
	@Test
	void getNestedEntryNameReturnsNestedEntryName() {
		assertThat(this.path.getNestedEntryName()).isEqualTo('nested.jar');
	}
	@Test
	void getFileSystemReturnsFileSystem() {
		assertThat(this.path.getFileSystem()).isSameAs(this.fileSystem);
	}
	@Test
	void isAbsoluteReturnsTrue() {
		assertThat(this.path.isAbsolute()).isTrue();
	}
	@Test
	void getRootReturnsNull() {
		assertThat(this.path.getRoot()).isNull();
	}
	@Test
	void getFileNameReturnsPath() {
		assertThat(this.path.getFileName()).isSameAs(this.path);
	}
	@Test
	void getParentReturnsNull() {
		assertThat(this.path.getParent()).isNull();
	}
	@Test
	void getNameCountReturnsOne() {
		assertThat(this.path.getNameCount()).isEqualTo(1);
	}
	@Test
	void subPathWhenBeginZeroEndOneReturnsPath() {
		assertThat(this.path.subpath(0, 1)).isSameAs(this.path);
	}
	@Test
	void subPathWhenBeginIndexNotZeroThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.path.subpath(1, 1))
			.withMessage('Nested paths only have a single element');
	}
	@Test
	void subPathThenEndIndexNotOneThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.path.subpath(0, 2))
			.withMessage('Nested paths only have a single element');
	}
	@Test
	void startsWithWhenStartsWithReturnsTrue() {
		NestedPath otherPath = new NestedPath(this.fileSystem, 'nested.jar');
		assertThat(this.path.startsWith(otherPath)).isTrue();
	}
	@Test
	void startsWithWhenNotStartsWithReturnsFalse() {
		NestedPath otherPath = new NestedPath(this.fileSystem, 'other.jar');
		assertThat(this.path.startsWith(otherPath)).isFalse();
	}
	@Test
	void endsWithWhenEndsWithReturnsTrue() {
		NestedPath otherPath = new NestedPath(this.fileSystem, 'nested.jar');
		assertThat(this.path.endsWith(otherPath)).isTrue();
	}
	@Test
	void endsWithWhenNotEndsWithReturnsFalse() {
		NestedPath otherPath = new NestedPath(this.fileSystem, 'other.jar');
		assertThat(this.path.endsWith(otherPath)).isFalse();
	}
	@Test
	void normalizeReturnsPath() {
		assertThat(this.path.normalize()).isSameAs(this.path);
	}
	@Test
	void resolveThrowsException() {
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.path.resolve(this.path))
			.withMessage('Unable to resolve nested path');
	}
	@Test
	void relativizeThrowsException() {
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.path.relativize(this.path))
			.withMessage('Unable to relativize nested path');
	}
	@Test
	void toUriReturnsUri() throws Exception {
		assertThat(this.path.toUri())
			.isEqualTo(new URI('nested:' + this.jarPath.toUri().getRawPath() + '/!nested.jar'));
	}
	@Test
	void toUriWhenHasSpecialCharsReturnsEncodedUri() throws Exception {
		this.jarPath = new File(this.temp, 'te st.jar').toPath();
		this.provider = new NestedFileSystemProvider();
		this.fileSystem = new NestedFileSystem(this.provider, this.jarPath);
		this.path = new NestedPath(this.fileSystem, 'ne sted.jar');
		assertThat(this.path.toUri())
			.isEqualTo(new URI('nested:' + this.jarPath.toUri().getRawPath() + '/!ne%20sted.jar'));
	}
	@Test
	void toAbsolutePathReturnsPath() {
		assertThat(this.path.toAbsolutePath()).isSameAs(this.path);
	}
	@Test
	void toRealPathReturnsPath() throws Exception {
		assertThat(this.path.toRealPath()).isSameAs(this.path);
	}
	@Test
	void registerThrowsException() {
		WatchService watcher = mock(WatchService.class);
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> this.path.register(watcher))
			.withMessage('Nested paths cannot be watched');
	}
	@Test
	void compareToComparesOnNestedEntryName() {
		NestedPath a = new NestedPath(this.fileSystem, 'a.jar');
		NestedPath b = new NestedPath(this.fileSystem, 'b.jar');
		NestedPath c = new NestedPath(this.fileSystem, 'c.jar');
		assertThat(new TreeSet<>(Set.of(c, a, b))).containsExactly(a, b, c);
	}
	@Test
	void hashCodeAndEquals() {
		NestedFileSystem fs2 = new NestedFileSystem(this.provider, new File(this.temp, 'test2.jar').toPath());
		NestedPath p1 = new NestedPath(this.fileSystem, 'a.jar');
		NestedPath p2 = new NestedPath(this.fileSystem, 'a.jar');
		NestedPath p3 = new NestedPath(this.fileSystem, 'c.jar');
		NestedPath p4 = new NestedPath(fs2, 'c.jar');
		assertThat(p1.hashCode()).isEqualTo(p2.hashCode());
		assertThat(p1).isEqualTo(p1).isEqualTo(p2).isNotEqualTo(p3).isNotEqualTo(p4);
	}
	@Test
	void toStringReturnsString() {
		assertThat(this.path).hasToString(this.jarPath.toString() + '/!nested.jar');
	}
	@Test
	void assertExistsWhenExists() throws Exception {
		TestJar.create(this.jarPath.toFile());
		this.path.assertExists();
	}
	@Test
	void assertExistsWhenDoesNotExistThrowsException() {
		assertThatExceptionOfType(NoSuchFileException.class).isThrownBy(this.path::assertExists);
	}
	@Test
	void castWhenNestedPathReturnsNestedPath() {
		assertThat(NestedPath.cast(this.path)).isSameAs(this.path);
	}
	@Test
	void castWhenNullThrowsException() {
		assertThatExceptionOfType(ProviderMismatchException.class).isThrownBy(() -> NestedPath.cast(null));
	}
	@Test
	void castWhenNotNestedPathThrowsException() {
		assertThatExceptionOfType(ProviderMismatchException.class).isThrownBy(() -> NestedPath.cast(this.jarPath));
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
@AssertFileChannelDataBlocksClosed
class NestedByteChannelTests {
	@TempDir
	File temp;
	private File file;
	private NestedByteChannel channel;
	@BeforeEach
	void setup() throws Exception {
		this.file = new File(this.temp, 'test.jar');
		TestJar.create(this.file);
		this.channel = new NestedByteChannel(this.file.toPath(), 'nested.jar');
	}
	@AfterEach
	void cleanup() throws Exception {
		this.channel.close();
	}
	@Test
	void isOpenWhenOpenReturnsTrue() {
		assertThat(this.channel.isOpen()).isTrue();
	}
	@Test
	void isOpenWhenClosedReturnsFalse() throws Exception {
		this.channel.close();
		assertThat(this.channel.isOpen()).isFalse();
	}
	@Test
	void closeCleansResources() throws Exception {
		Cleaner cleaner = mock(Cleaner.class);
		Cleanable cleanable = mock(Cleanable.class);
		given(cleaner.register(any(), any())).willReturn(cleanable);
		NestedByteChannel channel = new NestedByteChannel(this.file.toPath(), 'nested.jar', cleaner);
		channel.close();
		then(cleanable).should().clean();
		ArgumentCaptor<Runnable> actionCaptor = ArgumentCaptor.forClass(Runnable.class);
		then(cleaner).should().register(any(), actionCaptor.capture());
		actionCaptor.getValue().run();
	}
	@Test
	void closeWhenAlreadyClosedDoesNothing() throws IOException {
		Cleaner cleaner = mock(Cleaner.class);
		Cleanable cleanable = mock(Cleanable.class);
		given(cleaner.register(any(), any())).willReturn(cleanable);
		NestedByteChannel channel = new NestedByteChannel(this.file.toPath(), 'nested.jar', cleaner);
		channel.close();
		then(cleanable).should().clean();
		ArgumentCaptor<Runnable> actionCaptor = ArgumentCaptor.forClass(Runnable.class);
		then(cleaner).should().register(any(), actionCaptor.capture());
		actionCaptor.getValue().run();
		channel.close();
		then(cleaner).shouldHaveNoMoreInteractions();
	}
	@Test
	void readReadsBytesAndIncrementsPosition() throws IOException {
		ByteBuffer dst = ByteBuffer.allocate(10);
		assertThat(this.channel.position()).isZero();
		this.channel.read(dst);
		assertThat(this.channel.position()).isEqualTo(10L);
		assertThat(dst.array()).isNotEqualTo(ByteBuffer.allocate(10).array());
	}
	@Test // gh-38592
	void readReadsAsManyBytesAsPossible() throws Exception {
		// ZipFileSystem checks that the number of bytes read matches an expected value
		// ...if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR)
		// but the readFullyAt assumes that all remaining bytes are attempted to be read
		// This doesn"t seem to exactly match the contract of ReadableByteChannel.read
		// which states 'A read operation might not fill the buffer, and in fact it might
		// not read any bytes at all', but we need to match ZipFileSystem"s expectations
		int size = FileChannelDataBlockManagedFileChannel.BUFFER_SIZE * 2;
		byte[] data = new byte[size];
		this.file = new File(this.temp, 'testread.jar');
		FileOutputStream fileOutputStream = new FileOutputStream(this.file);
		try (JarOutputStream jarOutputStream = new JarOutputStream(fileOutputStream)) {
			JarEntry nestedEntry = new JarEntry('data');
			nestedEntry.setSize(size);
			nestedEntry.setCompressedSize(size);
			CRC32 crc32 = new CRC32();
			crc32.update(data);
			nestedEntry.setCrc(crc32.getValue());
			nestedEntry.setMethod(ZipEntry.STORED);
			jarOutputStream.putNextEntry(nestedEntry);
			jarOutputStream.write(data);
			jarOutputStream.closeEntry();
		}
		this.channel = new NestedByteChannel(this.file.toPath(), null);
		ByteBuffer buffer = ByteBuffer.allocate((int) this.file.length());
		assertThat(this.channel.read(buffer)).isEqualTo(buffer.capacity());
		assertThat(this.file).binaryContent().isEqualTo(buffer.array());
	}
	@Test
	void writeThrowsException() {
		assertThatExceptionOfType(NonWritableChannelException.class)
			.isThrownBy(() -> this.channel.write(ByteBuffer.allocate(10)));
	}
	@Test
	void positionWhenClosedThrowsException() throws Exception {
		this.channel.close();
		assertThatExceptionOfType(ClosedChannelException.class).isThrownBy(() -> this.channel.position());
	}
	@Test
	void positionWhenOpenReturnsPosition() throws Exception {
		assertThat(this.channel.position()).isEqualTo(0L);
	}
	@Test
	void positionWithLongWhenClosedThrowsException() throws Exception {
		this.channel.close();
		assertThatExceptionOfType(ClosedChannelException.class).isThrownBy(() -> this.channel.position(0L));
	}
	@Test
	void positionWithLongWhenLessThanZeroThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.channel.position(-1));
	}
	@Test
	void positionWithLongWhenEqualToSizeThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.channel.position(this.channel.size()));
	}
	@Test
	void positionWithLongWhenOpenUpdatesPosition() throws Exception {
		ByteBuffer dst1 = ByteBuffer.allocate(10);
		ByteBuffer dst2 = ByteBuffer.allocate(10);
		dst2.position(1);
		this.channel.read(dst1);
		this.channel.position(1);
		this.channel.read(dst2);
		dst2.array()[0] = dst1.array()[0];
		assertThat(dst1.array()).isEqualTo(dst2.array());
	}
	@Test
	void sizeWhenClosedThrowsException() throws Exception {
		this.channel.close();
		assertThatExceptionOfType(ClosedChannelException.class).isThrownBy(() -> this.channel.size());
	}
	@Test
	void sizeWhenOpenReturnsSize() throws IOException {
		try (ZipContent content = ZipContent.open(this.file.toPath())) {
			assertThat(this.channel.size()).isEqualTo(content.getEntry('nested.jar').getUncompressedSize());
		}
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
class NestedFileSystemTests {
	@TempDir
	File temp;
	private NestedFileSystemProvider provider;
	private Path jarPath;
	private NestedFileSystem fileSystem;
	@BeforeEach
	void setup() {
		this.provider = new NestedFileSystemProvider();
		this.jarPath = new File(this.temp, 'test.jar').toPath();
		this.fileSystem = new NestedFileSystem(this.provider, this.jarPath);
	}
	@Test
	void providerReturnsProvider() {
		assertThat(this.fileSystem.provider()).isSameAs(this.provider);
	}
	@Test
	void getJarPathReturnsJarPath() {
		assertThat(this.fileSystem.getJarPath()).isSameAs(this.jarPath);
	}
	@Test
	void closeClosesFileSystem() throws Exception {
		this.fileSystem.close();
		assertThat(this.fileSystem.isOpen()).isFalse();
	}
	@Test
	void closeWhenAlreadyClosedDoesNothing() throws Exception {
		this.fileSystem.close();
		this.fileSystem.close();
		assertThat(this.fileSystem.isOpen()).isFalse();
	}
	@Test
	void isOpenWhenOpenReturnsTrue() {
		assertThat(this.fileSystem.isOpen()).isTrue();
	}
	@Test
	void isOpenWhenClosedReturnsFalse() throws Exception {
		this.fileSystem.close();
		assertThat(this.fileSystem.isOpen()).isFalse();
	}
	@Test
	void isReadOnlyReturnsTrue() {
		assertThat(this.fileSystem.isReadOnly()).isTrue();
	}
	@Test
	void getSeparatorReturnsSeparator() {
		assertThat(this.fileSystem.getSeparator()).isEqualTo('/!');
	}
	@Test
	void getRootDirectoryWhenOpenReturnsEmptyIterable() {
		assertThat(this.fileSystem.getRootDirectories()).isEmpty();
	}
	@Test
	void getRootDirectoryWhenClosedThrowsException() throws Exception {
		this.fileSystem.close();
		assertThatExceptionOfType(ClosedFileSystemException.class)
			.isThrownBy(() -> this.fileSystem.getRootDirectories());
	}
	@Test
	void supportedFileAttributeViewsWhenOpenReturnsBasic() {
		assertThat(this.fileSystem.supportedFileAttributeViews()).containsExactly('basic');
	}
	@Test
	void supportedFileAttributeViewsWhenClosedThrowsException() throws Exception {
		this.fileSystem.close();
		assertThatExceptionOfType(ClosedFileSystemException.class)
			.isThrownBy(() -> this.fileSystem.supportedFileAttributeViews());
	}
	@Test
	void getPathWhenClosedThrowsException() throws Exception {
		this.fileSystem.close();
		assertThatExceptionOfType(ClosedFileSystemException.class)
			.isThrownBy(() -> this.fileSystem.getPath('nested.jar'));
	}
	@Test
	void getPathWhenFirstIsNull() {
		Path path = this.fileSystem.getPath(null);
		assertThat(path.toString()).endsWith(File.separator + 'test.jar');
	}
	@Test
	void getPathWhenFirstIsBlank() {
		Path path = this.fileSystem.getPath('');
		assertThat(path.toString()).endsWith(File.separator + 'test.jar');
	}
	@Test
	void getPathWhenMoreIsNotEmptyThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.fileSystem.getPath('nested.jar', 'another.jar'))
			.withMessage('Nested paths must contain a single element');
	}
	@Test
	void getPathReturnsPath() {
		assertThat(this.fileSystem.getPath('nested.jar')).isInstanceOf(NestedPath.class);
	}
	@Test
	void getPathMatchThrowsException() {
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> this.fileSystem.getPathMatcher('*'))
			.withMessage('Nested paths do not support path matchers');
	}
	@Test
	void getUserPrincipalLookupServiceThrowsException() {
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> this.fileSystem.getUserPrincipalLookupService())
			.withMessage('Nested paths do not have a user principal lookup service');
	}
	@Test
	void newWatchServiceThrowsException() {
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> this.fileSystem.newWatchService())
			.withMessage('Nested paths do not support the WatchService');
	}
	@Test
	void toStringReturnsString() {
		assertThat(this.fileSystem).hasToString(this.jarPath.toAbsolutePath().toString());
	}
	@Test
	void equalsAndHashCode() {
		Path jp1 = new File(this.temp, 'test1.jar').toPath();
		Path jp2 = new File(this.temp, 'test1.jar').toPath();
		Path jp3 = new File(this.temp, 'test2.jar').toPath();
		NestedFileSystem f1 = new NestedFileSystem(this.provider, jp1);
		NestedFileSystem f2 = new NestedFileSystem(this.provider, jp1);
		NestedFileSystem f3 = new NestedFileSystem(this.provider, jp2);
		NestedFileSystem f4 = new NestedFileSystem(this.provider, jp3);
		assertThat(f1.hashCode()).isEqualTo(f2.hashCode());
		assertThat(f1).isEqualTo(f1).isEqualTo(f2).isEqualTo(f3).isNotEqualTo(f4);
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
class UriPathEncoderTests {
	@Test
	void encodePath() {
		assertThat(UriPathEncoder.encode('/foo/bar')).isEqualTo('/foo/bar');
		assertThat(UriPathEncoder.encode('/foo bar')).isEqualTo('/foo%20bar');
		assertThat(UriPathEncoder.encode('/Z\u00fcrich')).isEqualTo('/Z%C3%BCrich');
	}
	@Test
	void encodePathWhenNoEncodingIsRequiredReturnsSameInstance() {
		String path = '/foo/bar';
		assertThat(UriPathEncoder.encode(path)).isSameAs(path);
	}
}
/*
package org.springframework.boot.loader.nio.file;
/**
@AssertFileChannelDataBlocksClosed
class NestedFileSystemProviderTests {
	@TempDir
	File temp;
	private File file;
	private TestNestedFileSystemProvider provider = new TestNestedFileSystemProvider();
	private String uriPrefix;
	@BeforeEach
	void setup() throws Exception {
		this.file = new File(this.temp, 'test.jar');
		TestJar.create(this.file);
		this.uriPrefix = 'nested:' + this.file.toURI().getPath() + '/!';
	}
	@Test
	void getSchemeReturnsScheme() {
		assertThat(this.provider.getScheme()).isEqualTo('nested');
	}
	@Test
	void newFilesSystemWhenBadUrlThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.provider.newFileSystem(new URI('bad:notreal'), Collections.emptyMap()))
			.withMessageContaining('must use "nested" scheme');
	}
	@Test
	void newFileSystemWhenAlreadyExistsThrowsException() throws Exception {
		this.provider.newFileSystem(new URI(this.uriPrefix + 'nested.jar'), null);
		assertThatExceptionOfType(FileSystemAlreadyExistsException.class)
			.isThrownBy(() -> this.provider.newFileSystem(new URI(this.uriPrefix + 'other.jar'), null));
	}
	@Test
	void newFileSystemReturnsFileSystem() throws Exception {
		FileSystem fileSystem = this.provider.newFileSystem(new URI(this.uriPrefix + 'nested.jar'), null);
		assertThat(fileSystem).isInstanceOf(NestedFileSystem.class);
	}
	@Test
	void getFileSystemWhenBadUrlThrowsException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.provider.getFileSystem(new URI('bad:notreal')))
			.withMessageContaining('must use "nested" scheme');
	}
	@Test
	void getFileSystemWhenNotCreatedThrowsException() {
		assertThatExceptionOfType(FileSystemNotFoundException.class)
			.isThrownBy(() -> this.provider.getFileSystem(new URI(this.uriPrefix + 'nested.jar')));
	}
	@Test
	void getFileSystemReturnsFileSystem() throws Exception {
		FileSystem expected = this.provider.newFileSystem(new URI(this.uriPrefix + 'nested.jar'), null);
		assertThat(this.provider.getFileSystem(new URI(this.uriPrefix + 'nested.jar'))).isSameAs(expected);
	}
	@Test
	void getPathWhenFileSystemExistsReturnsPath() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		this.provider.newFileSystem(uri, null);
		assertThat(this.provider.getPath(uri)).isInstanceOf(NestedPath.class);
	}
	@Test
	void getPathWhenFileSystemDoesNtExistReturnsPath() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		assertThat(this.provider.getPath(uri)).isInstanceOf(NestedPath.class);
	}
	@Test
	void newByteChannelReturnsByteChannel() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		Path path = this.provider.getPath(uri);
		try (SeekableByteChannel byteChannel = this.provider.newByteChannel(path, Set.of(StandardOpenOption.READ))) {
			assertThat(byteChannel).isInstanceOf(NestedByteChannel.class);
		}
	}
	@Test
	void newDirectoryStreamThrowsException() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		Path path = this.provider.getPath(uri);
		assertThatExceptionOfType(NotDirectoryException.class)
			.isThrownBy(() -> this.provider.newDirectoryStream(path, null));
	}
	@Test
	void createDirectoryThrowsException() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		Path path = this.provider.getPath(uri);
		assertThatExceptionOfType(ReadOnlyFileSystemException.class)
			.isThrownBy(() -> this.provider.createDirectory(path));
	}
	@Test
	void deleteThrowsException() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		Path path = this.provider.getPath(uri);
		assertThatExceptionOfType(ReadOnlyFileSystemException.class).isThrownBy(() -> this.provider.delete(path));
	}
	@Test
	void copyThrowsException() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		Path path = this.provider.getPath(uri);
		assertThatExceptionOfType(ReadOnlyFileSystemException.class).isThrownBy(() -> this.provider.copy(path, path));
	}
	@Test
	void moveThrowsException() throws Exception {
		URI uri = new URI(this.uriPrefix + 'nested.jar');
		Path path = this.provider.getPath(uri);
		assertThatExceptionOfType(ReadOnlyFileSystemException.class).isThrownBy(() -> this.provider.move(path, path));
	}
	@Test
	void isSameFileWhenSameReturnsTrue() throws Exception {
		Path p1 = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		Path p2 = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		assertThat(this.provider.isSameFile(p1, p1)).isTrue();
		assertThat(this.provider.isSameFile(p1, p2)).isTrue();
	}
	@Test
	void isSameFileWhenDifferentReturnsFalse() throws Exception {
		Path p1 = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		Path p2 = this.provider.getPath(new URI(this.uriPrefix + 'other.jar'));
		assertThat(this.provider.isSameFile(p1, p2)).isFalse();
	}
	@Test
	void isHiddenReturnsFalse() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		assertThat(this.provider.isHidden(path)).isFalse();
	}
	@Test
	void getFileStoreWhenFileDoesNotExistThrowsException() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'missing.jar'));
		assertThatExceptionOfType(NoSuchFileException.class).isThrownBy(() -> this.provider.getFileStore(path));
	}
	@Test
	void getFileStoreReturnsFileStore() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		assertThat(this.provider.getFileStore(path)).isInstanceOf(NestedFileStore.class);
	}
	@Test
	void checkAccessDelegatesToJarPath() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		Path jarPath = mockJarPath();
		this.provider.setMockJarPath(jarPath);
		this.provider.checkAccess(path);
		then(jarPath.getFileSystem().provider()).should().checkAccess(jarPath);
	}
	@Test
	void getFileAttributeViewDelegatesToJarPath() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		Path jarPath = mockJarPath();
		this.provider.setMockJarPath(jarPath);
		this.provider.getFileAttributeView(path, BasicFileAttributeView.class);
		then(jarPath.getFileSystem().provider()).should().getFileAttributeView(jarPath, BasicFileAttributeView.class);
	}
	@Test
	void readAttributesWithTypeDelegatesToJarPath() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		Path jarPath = mockJarPath();
		this.provider.setMockJarPath(jarPath);
		this.provider.readAttributes(path, BasicFileAttributes.class);
		then(jarPath.getFileSystem().provider()).should().readAttributes(jarPath, BasicFileAttributes.class);
	}
	@Test
	void readAttributesWithNameDelegatesToJarPath() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		Path jarPath = mockJarPath();
		this.provider.setMockJarPath(jarPath);
		this.provider.readAttributes(path, 'basic');
		then(jarPath.getFileSystem().provider()).should().readAttributes(jarPath, 'basic');
	}
	@Test
	void setAttributeThrowsException() throws Exception {
		Path path = this.provider.getPath(new URI(this.uriPrefix + 'nested.jar'));
		assertThatExceptionOfType(ReadOnlyFileSystemException.class)
			.isThrownBy(() -> this.provider.setAttribute(path, 'test', 'test'));
	}
	private Path mockJarPath() {
		Path path = mock(Path.class);
		FileSystem fileSystem = mock(FileSystem.class);
		given(path.getFileSystem()).willReturn(fileSystem);
		FileSystemProvider provider = mock(FileSystemProvider.class);
		given(fileSystem.provider()).willReturn(provider);
		return path;
	}
	static class TestNestedFileSystemProvider extends NestedFileSystemProvider {
		private Path mockJarPath;
		@Override
		protected Path getJarPath(Path path) {
			return (this.mockJarPath != null) ? this.mockJarPath : super.getJarPath(path);
		}
		void setMockJarPath(Path mockJarPath) {
			this.mockJarPath = mockJarPath;
		}
	}
}
/*
package org.springframework.boot.loader.jarmode;
/**
public interface JarMode {
	/**
	 * Returns if this accepts and can run the given mode.
	 * @param mode the mode to check
	 * @return if this instance accepts the mode
	 */
	boolean accepts(String mode);
	/**
	 * Run the jar in the given mode.
	 * @param mode the mode to use
	 * @param args any program arguments
	 */
	void run(String mode, String[] args);
}
/*
/**
package org.springframework.boot.loader.jarmode;
/*
/**
package org.springframework.boot.loader.log;
/*
package org.springframework.boot.loader.log;
/**
public abstract sealed class DebugLogger {
	private static final String ENABLED_PROPERTY = 'loader.debug';
	private static final DebugLogger disabled;
	static {
		disabled = Boolean.getBoolean(ENABLED_PROPERTY) ? null : new DisabledDebugLogger();
	}
	/**
	 * Log a message.
	 * @param message the message to log
	 */
	public abstract void log(String message);
	/**
	 * Log a formatted message.
	 * @param message the message to log
	 * @param arg1 the first format argument
	 */
	public abstract void log(String message, Object arg1);
	/**
	 * Log a formatted message.
	 * @param message the message to log
	 * @param arg1 the first format argument
	 * @param arg2 the second format argument
	 */
	public abstract void log(String message, Object arg1, Object arg2);
	/**
	 * Log a formatted message.
	 * @param message the message to log
	 * @param arg1 the first format argument
	 * @param arg2 the second format argument
	 * @param arg3 the third format argument
	 */
	public abstract void log(String message, Object arg1, Object arg2, Object arg3);
	/**
	 * Log a formatted message.
	 * @param message the message to log
	 * @param arg1 the first format argument
	 * @param arg2 the second format argument
	 * @param arg3 the third format argument
	 * @param arg4 the fourth format argument
	 */
	public abstract void log(String message, Object arg1, Object arg2, Object arg3, Object arg4);
	/**
	 * Get a {@link DebugLogger} to log messages for the given source class.
	 * @param sourceClass the source class
	 * @return a {@link DebugLogger} instance
	 */
	public static DebugLogger get(Class<?> sourceClass) {
		return (disabled != null) ? disabled : new SystemErrDebugLogger(sourceClass);
	}
	/**
	 * {@link DebugLogger} used for disabled logging that does nothing.
	 */
	private static final class DisabledDebugLogger extends DebugLogger {
		@Override
		public void log(String message) {
		}
		@Override
		public void log(String message, Object arg1) {
		}
		@Override
		public void log(String message, Object arg1, Object arg2) {
		}
		@Override
		public void log(String message, Object arg1, Object arg2, Object arg3) {
		}
		@Override
		public void log(String message, Object arg1, Object arg2, Object arg3, Object arg4) {
		}
	}
	/**
	 * {@link DebugLogger} that prints messages to {@link System#err}.
	 */
	private static final class SystemErrDebugLogger extends DebugLogger {
		private final String prefix;
		SystemErrDebugLogger(Class<?> sourceClass) {
			this.prefix = 'LOADER: ' + sourceClass + ' : ';
		}
		@Override
		public void log(String message) {
			print(message);
		}
		@Override
		public void log(String message, Object arg1) {
			print(message.formatted(arg1));
		}
		@Override
		public void log(String message, Object arg1, Object arg2) {
			print(message.formatted(arg1, arg2));
		}
		@Override
		public void log(String message, Object arg1, Object arg2, Object arg3) {
			print(message.formatted(arg1, arg2, arg3));
		}
		@Override
		public void log(String message, Object arg1, Object arg2, Object arg3, Object arg4) {
			print(message.formatted(arg1, arg2, arg3, arg4));
		}
		private void print(String message) {
			System.err.println(this.prefix + message);
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public interface Archive extends AutoCloseable {
	/**
	 * Predicate that accepts all entries.
	 */
	Predicate<Entry> ALL_ENTRIES = (entry) -> true;
	/**
	 * Returns the manifest of the archive.
	 * @return the manifest or {@code null}
	 * @throws IOException if the manifest cannot be read
	 */
	Manifest getManifest() throws IOException;
	/**
	 * Returns classpath URLs for the archive that match the specified filter.
	 * @param includeFilter filter used to determine which entries should be included.
	 * @return the classpath URLs
	 * @throws IOException on IO error
	 */
	default Set<URL> getClassPathUrls(Predicate<Entry> includeFilter) throws IOException {
		return getClassPathUrls(includeFilter, ALL_ENTRIES);
	}
	/**
	 * Returns classpath URLs for the archive that match the specified filters.
	 * @param includeFilter filter used to determine which entries should be included
	 * @param directorySearchFilter filter used to optimize tree walking for exploded
	 * archives by determining if a directory needs to be searched or not
	 * @return the classpath URLs
	 * @throws IOException on IO error
	 */
	Set<URL> getClassPathUrls(Predicate<Entry> includeFilter, Predicate<Entry> directorySearchFilter)
			throws IOException;
	/**
	 * Returns if this archive is backed by an exploded archive directory.
	 * @return if the archive is exploded
	 */
	default boolean isExploded() {
		return getRootDirectory() != null;
	}
	/**
	 * Returns the root directory of this archive or {@code null} if the archive is not
	 * backed by a directory.
	 * @return the root directory
	 */
	default File getRootDirectory() {
		return null;
	}
	/**
	 * Closes the {@code Archive}, releasing any open resources.
	 * @throws Exception if an error occurs during close processing
	 */
	@Override
	default void close() throws Exception {
	}
	/**
	 * Factory method to create an appropriate {@link Archive} from the given
	 * {@link Class} target.
	 * @param target a target class that will be used to find the archive code source
	 * @return an new {@link Archive} instance
	 * @throws Exception if the archive cannot be created
	 */
	static Archive create(Class<?> target) throws Exception {
		return create(target.getProtectionDomain());
	}
	static Archive create(ProtectionDomain protectionDomain) throws Exception {
		CodeSource codeSource = protectionDomain.getCodeSource();
		URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;
		if (location == null) {
			throw new IllegalStateException('Unable to determine code source archive');
		}
		return create(Path.of(location).toFile());
	}
	/**
	 * Factory method to create an {@link Archive} from the given {@link File} target.
	 * @param target a target {@link File} used to create the archive. May be a directory
	 * or a jar file.
	 * @return a new {@link Archive} instance.
	 * @throws Exception if the archive cannot be created
	 */
	static Archive create(File target) throws Exception {
		if (!target.exists()) {
			throw new IllegalStateException('Unable to determine code source archive from ' + target);
		}
		return (target.isDirectory() ? new ExplodedArchive(target) : new JarFileArchive(target));
	}
	/**
	 * Represents a single entry in the archive.
	 */
	interface Entry {
		/**
		 * Returns the name of the entry.
		 * @return the name of the entry
		 */
		String name();
		/**
		 * Returns {@code true} if the entry represents a directory.
		 * @return if the entry is a directory
		 */
		boolean isDirectory();
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public class JarLauncher extends ExecutableArchiveLauncher {
	public JarLauncher() throws Exception {
	}
	protected JarLauncher(Archive archive) throws Exception {
		super(archive);
	}
	public static void main(String[] args) throws Exception {
		new JarLauncher().launch(args);
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public class LaunchedClassLoader extends JarUrlClassLoader {
	private static final String JAR_MODE_PACKAGE_PREFIX = 'org.springframework.boot.loader.jarmode.';
	private static final String JAR_MODE_RUNNER_CLASS_NAME = JarModeRunner.class.getName();
	static {
		ClassLoader.registerAsParallelCapable();
	}
	private final boolean exploded;
	private final Archive rootArchive;
	private final Object definePackageLock = new Object();
	private volatile DefinePackageCallType definePackageCallType;
	/**
	 * Create a new {@link LaunchedClassLoader} instance.
	 * @param exploded if the underlying archive is exploded
	 * @param urls the URLs from which to load classes and resources
	 * @param parent the parent class loader for delegation
	 */
	public LaunchedClassLoader(boolean exploded, URL[] urls, ClassLoader parent) {
		this(exploded, null, urls, parent);
	}
	/**
	 * Create a new {@link LaunchedClassLoader} instance.
	 * @param exploded if the underlying archive is exploded
	 * @param rootArchive the root archive or {@code null}
	 * @param urls the URLs from which to load classes and resources
	 * @param parent the parent class loader for delegation
	 */
	public LaunchedClassLoader(boolean exploded, Archive rootArchive, URL[] urls, ClassLoader parent) {
		super(urls, parent);
		this.exploded = exploded;
		this.rootArchive = rootArchive;
	}
	@Override
	protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
		if (name.startsWith(JAR_MODE_PACKAGE_PREFIX) || name.equals(JAR_MODE_RUNNER_CLASS_NAME)) {
			try {
				Class<?> result = loadClassInLaunchedClassLoader(name);
				if (resolve) {
					resolveClass(result);
				}
				return result;
			}
			catch (ClassNotFoundException ex) {
				// Ignore
			}
		}
		return super.loadClass(name, resolve);
	}
	private Class<?> loadClassInLaunchedClassLoader(String name) throws ClassNotFoundException {
		try {
			String internalName = name.replace(".", "/") + '.class';
			try (InputStream inputStream = getParent().getResourceAsStream(internalName);
					ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
				if (inputStream == null) {
					throw new ClassNotFoundException(name);
				}
				inputStream.transferTo(outputStream);
				byte[] bytes = outputStream.toByteArray();
				Class<?> definedClass = defineClass(name, bytes, 0, bytes.length);
				definePackageIfNecessary(name);
				return definedClass;
			}
		}
		catch (IOException ex) {
			throw new ClassNotFoundException('Cannot load resource for class [' + name + ']', ex);
		}
	}
	@Override
	protected Package definePackage(String name, Manifest man, URL url) throws IllegalArgumentException {
		return (!this.exploded) ? super.definePackage(name, man, url) : definePackageForExploded(name, man, url);
	}
	private Package definePackageForExploded(String name, Manifest man, URL url) {
		synchronized (this.definePackageLock) {
			return definePackage(DefinePackageCallType.MANIFEST, () -> super.definePackage(name, man, url));
		}
	}
	@Override
	protected Package definePackage(String name, String specTitle, String specVersion, String specVendor,
			String implTitle, String implVersion, String implVendor, URL sealBase) throws IllegalArgumentException {
		if (!this.exploded) {
			return super.definePackage(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor,
					sealBase);
		}
		return definePackageForExploded(name, sealBase, () -> super.definePackage(name, specTitle, specVersion,
				specVendor, implTitle, implVersion, implVendor, sealBase));
	}
	private Package definePackageForExploded(String name, URL sealBase, Supplier<Package> call) {
		synchronized (this.definePackageLock) {
			if (this.definePackageCallType == null) {
				// We"re not part of a call chain which means that the URLClassLoader
				// is trying to define a package for our exploded JAR. We use the
				// manifest version to ensure package attributes are set
				Manifest manifest = getManifest(this.rootArchive);
				if (manifest != null) {
					return definePackage(name, manifest, sealBase);
				}
			}
			return definePackage(DefinePackageCallType.ATTRIBUTES, call);
		}
	}
	private <T> T definePackage(DefinePackageCallType type, Supplier<T> call) {
		DefinePackageCallType existingType = this.definePackageCallType;
		try {
			this.definePackageCallType = type;
			return call.get();
		}
		finally {
			this.definePackageCallType = existingType;
		}
	}
	private Manifest getManifest(Archive archive) {
		try {
			return (archive != null) ? archive.getManifest() : null;
		}
		catch (IOException ex) {
			return null;
		}
	}
	/**
	 * The different types of call made to define a package. We track these for exploded
	 * jars so that we can detect packages that should have manifest attributes applied.
	 */
	private enum DefinePackageCallType {
		/**
		 * A define package call from a resource that has a manifest.
		 */
		MANIFEST,
		/**
		 * A define package call with a direct set of attributes.
		 */
		ATTRIBUTES
	}
}
/*
package org.springframework.boot.loader.launch;
/**
final class ClassPathIndexFile {
	private final File root;
	private final Set<String> lines;
	private ClassPathIndexFile(File root, List<String> lines) {
		this.root = root;
		this.lines = lines.stream().map(this::extractName).collect(Collectors.toCollection(LinkedHashSet::new));
	}
	private String extractName(String line) {
		if (line.startsWith('- \'') && line.endsWith('\'')) {
			return line.substring(3, line.length() - 1);
		}
		throw new IllegalStateException('Malformed classpath index line [' + line + ']');
	}
	int size() {
		return this.lines.size();
	}
	boolean containsEntry(String name) {
		if (name == null || name.isEmpty()) {
			return false;
		}
		return this.lines.contains(name);
	}
	List<URL> getUrls() {
		return this.lines.stream().map(this::asUrl).toList();
	}
	private URL asUrl(String line) {
		try {
			return new File(this.root, line).toURI().toURL();
		}
		catch (MalformedURLException ex) {
			throw new IllegalStateException(ex);
		}
	}
	static ClassPathIndexFile loadIfPossible(File root, String location) throws IOException {
		return loadIfPossible(root, new File(root, location));
	}
	private static ClassPathIndexFile loadIfPossible(File root, File indexFile) throws IOException {
		if (indexFile.exists() && indexFile.isFile()) {
			List<String> lines = Files.readAllLines(indexFile.toPath())
				.stream()
				.filter(ClassPathIndexFile::lineHasText)
				.toList();
			return new ClassPathIndexFile(root, lines);
		}
		return null;
	}
	private static boolean lineHasText(String line) {
		return !line.trim().isEmpty();
	}
}
/*
package org.springframework.boot.loader.launch;
/**
class JarFileArchive implements Archive {
	private static final String UNPACK_MARKER = 'UNPACK:';
	private static final FileAttribute<?>[] NO_FILE_ATTRIBUTES = {};
	private static final FileAttribute<?>[] DIRECTORY_PERMISSION_ATTRIBUTES = asFileAttributes(
			PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_EXECUTE);
	private static final FileAttribute<?>[] FILE_PERMISSION_ATTRIBUTES = asFileAttributes(
			PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE);
	private static final Path TEMP = Paths.get(System.getProperty('java.io.tmpdir'));
	private final File file;
	private final JarFile jarFile;
	private volatile Path tempUnpackDirectory;
	JarFileArchive(File file) throws IOException {
		this(file, new JarFile(file));
	}
	private JarFileArchive(File file, JarFile jarFile) {
		this.file = file;
		this.jarFile = jarFile;
	}
	@Override
	public Manifest getManifest() throws IOException {
		return this.jarFile.getManifest();
	}
	@Override
	public Set<URL> getClassPathUrls(Predicate<Entry> includeFilter, Predicate<Entry> directorySearchFilter)
			throws IOException {
		return this.jarFile.stream()
			.map(JarArchiveEntry::new)
			.filter(includeFilter)
			.map(this::getNestedJarUrl)
			.collect(Collectors.toCollection(LinkedHashSet::new));
	}
	private URL getNestedJarUrl(JarArchiveEntry archiveEntry) {
		try {
			JarEntry jarEntry = archiveEntry.jarEntry();
			String comment = jarEntry.getComment();
			if (comment != null && comment.startsWith(UNPACK_MARKER)) {
				return getUnpackedNestedJarUrl(jarEntry);
			}
			return JarUrl.create(this.file, jarEntry);
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private URL getUnpackedNestedJarUrl(JarEntry jarEntry) throws IOException {
		String name = jarEntry.getName();
		if (name.lastIndexOf("/") != -1) {
			name = name.substring(name.lastIndexOf("/") + 1);
		}
		Path path = getTempUnpackDirectory().resolve(name);
		if (!Files.exists(path) || Files.size(path) != jarEntry.getSize()) {
			unpack(jarEntry, path);
		}
		return path.toUri().toURL();
	}
	private Path getTempUnpackDirectory() {
		Path tempUnpackDirectory = this.tempUnpackDirectory;
		if (tempUnpackDirectory != null) {
			return tempUnpackDirectory;
		}
		synchronized (TEMP) {
			tempUnpackDirectory = this.tempUnpackDirectory;
			if (tempUnpackDirectory == null) {
				tempUnpackDirectory = createUnpackDirectory(TEMP);
				this.tempUnpackDirectory = tempUnpackDirectory;
			}
		}
		return tempUnpackDirectory;
	}
	private Path createUnpackDirectory(Path parent) {
		int attempts = 0;
		String fileName = Paths.get(this.jarFile.getName()).getFileName().toString();
		while (attempts++ < 100) {
			Path unpackDirectory = parent.resolve(fileName + '-spring-boot-libs-' + UUID.randomUUID());
			try {
				createDirectory(unpackDirectory);
				return unpackDirectory;
			}
			catch (IOException ex) {
				// Ignore
			}
		}
		throw new IllegalStateException('Failed to create unpack directory in directory "' + parent + '"');
	}
	private void createDirectory(Path path) throws IOException {
		Files.createDirectory(path, getFileAttributes(path, DIRECTORY_PERMISSION_ATTRIBUTES));
	}
	private void unpack(JarEntry entry, Path path) throws IOException {
		createFile(path);
		path.toFile().deleteOnExit();
		try (InputStream in = this.jarFile.getInputStream(entry)) {
			Files.copy(in, path, StandardCopyOption.REPLACE_EXISTING);
		}
	}
	private void createFile(Path path) throws IOException {
		Files.createFile(path, getFileAttributes(path, FILE_PERMISSION_ATTRIBUTES));
	}
	private FileAttribute<?>[] getFileAttributes(Path path, FileAttribute<?>[] permissionAttributes) {
		return (!supportsPosix(path.getFileSystem())) ? NO_FILE_ATTRIBUTES : permissionAttributes;
	}
	private boolean supportsPosix(FileSystem fileSystem) {
		return fileSystem.supportedFileAttributeViews().contains('posix');
	}
	@Override
	public void close() throws IOException {
		this.jarFile.close();
	}
	@Override
	public String toString() {
		return this.file.toString();
	}
	private static FileAttribute<?>[] asFileAttributes(PosixFilePermission... permissions) {
		return new FileAttribute<?>[] { PosixFilePermissions.asFileAttribute(Set.of(permissions)) };
	}
	/**
	 * {@link Entry} implementation backed by a {@link JarEntry}.
	 */
	private record JarArchiveEntry(JarEntry jarEntry) implements Entry {
		@Override
		public String name() {
			return this.jarEntry.getName();
		}
		@Override
		public boolean isDirectory() {
			return this.jarEntry.isDirectory();
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public abstract class ExecutableArchiveLauncher extends Launcher {
	private static final String START_CLASS_ATTRIBUTE = 'Start-Class';
	private final Archive archive;
	public ExecutableArchiveLauncher() throws Exception {
		this(Archive.create(Launcher.class));
	}
	protected ExecutableArchiveLauncher(Archive archive) throws Exception {
		this.archive = archive;
		this.classPathIndex = getClassPathIndex(this.archive);
	}
	@Override
	protected ClassLoader createClassLoader(Collection<URL> urls) throws Exception {
		if (this.classPathIndex != null) {
			urls = new ArrayList<>(urls);
			urls.addAll(this.classPathIndex.getUrls());
		}
		return super.createClassLoader(urls);
	}
	@Override
	protected final Archive getArchive() {
		return this.archive;
	}
	@Override
	protected String getMainClass() throws Exception {
		Manifest manifest = this.archive.getManifest();
		String mainClass = (manifest != null) ? manifest.getMainAttributes().getValue(START_CLASS_ATTRIBUTE) : null;
		if (mainClass == null) {
			throw new IllegalStateException('No "Start-Class" manifest entry specified in ' + this);
		}
		return mainClass;
	}
	@Override
	protected Set<URL> getClassPathUrls() throws Exception {
		return this.archive.getClassPathUrls(this::isIncludedOnClassPathAndNotIndexed, this::isSearchedDirectory);
	}
	/**
	 * Determine if the specified directory entry is a candidate for further searching.
	 * @param entry the entry to check
	 * @return {@code true} if the entry is a candidate for further searching
	 */
	protected boolean isSearchedDirectory(Archive.Entry entry) {
		return ((getEntryPathPrefix() == null) || entry.name().startsWith(getEntryPathPrefix()))
				&& !isIncludedOnClassPath(entry);
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public abstract class Launcher {
	private static final String JAR_MODE_RUNNER_CLASS_NAME = JarModeRunner.class.getName();
	protected static final String BOOT_CLASSPATH_INDEX_ATTRIBUTE = 'Spring-Boot-Classpath-Index';
	protected static final String DEFAULT_CLASSPATH_INDEX_FILE_NAME = 'classpath.idx';
	protected ClassPathIndexFile classPathIndex;
	/**
	 * Launch the application. This method is the initial entry point that should be
	 * called by a subclass {@code public static void main(String[] args)} method.
	 * @param args the incoming arguments
	 * @throws Exception if the application fails to launch
	 */
	protected void launch(String[] args) throws Exception {
		if (!isExploded()) {
			Handlers.register();
		}
		try {
			ClassLoader classLoader = createClassLoader(getClassPathUrls());
			String jarMode = System.getProperty('jarmode');
			String mainClassName = hasLength(jarMode) ? JAR_MODE_RUNNER_CLASS_NAME : getMainClass();
			launch(classLoader, mainClassName, args);
		}
		catch (UncheckedIOException ex) {
			throw ex.getCause();
		}
	}
	private boolean hasLength(String jarMode) {
		return (jarMode != null) && !jarMode.isEmpty();
	}
	/**
	 * Create a classloader for the specified archives.
	 * @param urls the classpath URLs
	 * @return the classloader
	 * @throws Exception if the classloader cannot be created
	 */
	protected ClassLoader createClassLoader(Collection<URL> urls) throws Exception {
		return createClassLoader(urls.toArray(new URL[0]));
	}
	private ClassLoader createClassLoader(URL[] urls) {
		ClassLoader parent = getClass().getClassLoader();
		return new LaunchedClassLoader(isExploded(), getArchive(), urls, parent);
	}
	/**
	 * Launch the application given the archive file and a fully configured classloader.
	 * @param classLoader the classloader
	 * @param mainClassName the main class to run
	 * @param args the incoming arguments
	 * @throws Exception if the launch fails
	 */
	protected void launch(ClassLoader classLoader, String mainClassName, String[] args) throws Exception {
		Thread.currentThread().setContextClassLoader(classLoader);
		Class<?> mainClass = Class.forName(mainClassName, false, classLoader);
		Method mainMethod = mainClass.getDeclaredMethod('main', String[].class);
		mainMethod.setAccessible(true);
		mainMethod.invoke(null, new Object[] { args });
	}
	/**
	 * Returns if the launcher is running in an exploded mode. If this method returns
	 * {@code true} then only regular JARs are supported and the additional URL and
	 * ClassLoader support infrastructure can be optimized.
	 * @return if the jar is exploded.
	 */
	protected boolean isExploded() {
		Archive archive = getArchive();
		return (archive != null) && archive.isExploded();
	}
	ClassPathIndexFile getClassPathIndex(Archive archive) throws IOException {
		if (!archive.isExploded()) {
			return null; // Regular archives already have a defined order
		}
		String location = getClassPathIndexFileLocation(archive);
		return ClassPathIndexFile.loadIfPossible(archive.getRootDirectory(), location);
	}
	private String getClassPathIndexFileLocation(Archive archive) throws IOException {
		Manifest manifest = archive.getManifest();
		Attributes attributes = (manifest != null) ? manifest.getMainAttributes() : null;
		String location = (attributes != null) ? attributes.getValue(BOOT_CLASSPATH_INDEX_ATTRIBUTE) : null;
		return (location != null) ? location : getEntryPathPrefix() + DEFAULT_CLASSPATH_INDEX_FILE_NAME;
	}
	/**
	 * Return the archive being launched or {@code null} if there is no archive.
	 * @return the launched archive
	 */
	protected abstract Archive getArchive();
	/**
	 * Returns the main class that should be launched.
	 * @return the name of the main class
	 * @throws Exception if the main class cannot be obtained
	 */
	protected abstract String getMainClass() throws Exception;
	/**
	 * Returns the archives that will be used to construct the class path.
	 * @return the class path archives
	 * @throws Exception if the class path archives cannot be obtained
	 */
	protected abstract Set<URL> getClassPathUrls() throws Exception;
	/**
	 * Return the path prefix for relevant entries in the archive.
	 * @return the entry path prefix
	 */
	protected String getEntryPathPrefix() {
		return 'BOOT-INF/';
	}
	/**
	 * Determine if the specified entry is a nested item that should be added to the
	 * classpath.
	 * @param entry the entry to check
	 * @return {@code true} if the entry is a nested item (jar or directory)
	 */
	protected boolean isIncludedOnClassPath(Archive.Entry entry) {
		return isLibraryFileOrClassesDirectory(entry);
	}
	protected boolean isLibraryFileOrClassesDirectory(Archive.Entry entry) {
		String name = entry.name();
		if (entry.isDirectory()) {
			return name.equals('BOOT-INF/classes/');
		}
		return name.startsWith('BOOT-INF/lib/');
	}
	protected boolean isIncludedOnClassPathAndNotIndexed(Entry entry) {
		if (!isIncludedOnClassPath(entry)) {
			return false;
		}
		return (this.classPathIndex == null) || !this.classPathIndex.containsEntry(entry.name());
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public class PropertiesLauncher extends Launcher {
	/**
	 * Properties key for main class. As a manifest entry can also be specified as
	 * {@code Start-Class}.
	 */
	public static final String MAIN = 'loader.main';
	/**
	 * Properties key for classpath entries (directories possibly containing jars or
	 * jars). Multiple entries can be specified using a comma-separated list. {@code
	 * BOOT-INF/classes,BOOT-INF/lib} in the application archive are always used.
	 */
	public static final String PATH = 'loader.path';
	/**
	 * Properties key for home directory. This is the location of external configuration
	 * if not on classpath, and also the base path for any relative paths in the
	 * {@link #PATH loader path}. Defaults to current working directory (
	 * <code>${user.dir}</code>).
	 */
	public static final String HOME = 'loader.home';
	/**
	 * Properties key for default command line arguments. These arguments (if present) are
	 * prepended to the main method arguments before launching.
	 */
	public static final String ARGS = 'loader.args';
	/**
	 * Properties key for name of external configuration file (excluding suffix). Defaults
	 * to 'application'. Ignored if {@link #CONFIG_LOCATION loader config location} is
	 * provided instead.
	 */
	public static final String CONFIG_NAME = 'loader.config.name';
	/**
	 * Properties key for config file location (including optional classpath:, file: or
	 * URL prefix).
	 */
	public static final String CONFIG_LOCATION = 'loader.config.location';
	/**
	 * Properties key for boolean flag (default false) which, if set, will cause the
	 * external configuration properties to be copied to System properties (assuming that
	 * is allowed by Java security).
	 */
	public static final String SET_SYSTEM_PROPERTIES = 'loader.system';
	private static final URL[] NO_URLS = new URL[0];
	private static final Pattern WORD_SEPARATOR = Pattern.compile('\\W+');
	private static final String NESTED_ARCHIVE_SEPARATOR = '!' + File.separator;
	private static final String JAR_FILE_PREFIX = 'jar:file:';
	private static final DebugLogger debug = DebugLogger.get(PropertiesLauncher.class);
	private final Archive archive;
	private final File homeDirectory;
	private final List<String> paths;
	private final Properties properties = new Properties();
	public PropertiesLauncher() throws Exception {
		this(Archive.create(Launcher.class));
	}
	PropertiesLauncher(Archive archive) throws Exception {
		this.archive = archive;
		this.homeDirectory = getHomeDirectory();
		initializeProperties();
		this.paths = getPaths();
		this.classPathIndex = getClassPathIndex(this.archive);
	}
	protected File getHomeDirectory() throws Exception {
		return new File(getPropertyWithDefault(HOME, '${user.dir}'));
	}
	private void initializeProperties() throws Exception {
		List<String> configs = new ArrayList<>();
		if (getProperty(CONFIG_LOCATION) != null) {
			configs.add(getProperty(CONFIG_LOCATION));
		}
		else {
			String[] names = getPropertyWithDefault(CONFIG_NAME, 'loader').split(',');
			for (String name : names) {
				String propertiesFile = name + '.properties';
				configs.add('file:' + this.homeDirectory + '/' + propertiesFile);
				configs.add('classpath:' + propertiesFile);
				configs.add('classpath:BOOT-INF/classes/' + propertiesFile);
			}
		}
		for (String config : configs) {
			try (InputStream resource = getResource(config)) {
				if (resource == null) {
					debug.log('Not found: %s', config);
					continue;
				}
				debug.log('Found: %s', config);
				loadResource(resource);
				return; // Load the first one we find
			}
		}
	}
	private InputStream getResource(String config) throws Exception {
		if (config.startsWith('classpath:')) {
			return getClasspathResource(config.substring('classpath:'.length()));
		}
		config = handleUrl(config);
		if (isUrl(config)) {
			return getURLResource(config);
		}
		return getFileResource(config);
	}
	private InputStream getClasspathResource(String config) {
		config = stripLeadingSlashes(config);
		config = '/' + config;
		debug.log('Trying classpath: %s', config);
		return getClass().getResourceAsStream(config);
	}
	private String handleUrl(String path) {
		if (path.startsWith('jar:file:') || path.startsWith('file:')) {
			path = URLDecoder.decode(path, StandardCharsets.UTF_8);
			if (path.startsWith('file:')) {
				path = path.substring('file:'.length());
				if (path.startsWith('//')) {
					path = path.substring(2);
				}
			}
		}
		return path;
	}
	private boolean isUrl(String config) {
		return config.contains('://');
	}
	private InputStream getURLResource(String config) throws Exception {
		URL url = new URL(config);
		if (exists(url)) {
			URLConnection connection = url.openConnection();
			try {
				return connection.getInputStream();
			}
			catch (IOException ex) {
				disconnect(connection);
				throw ex;
			}
		}
		return null;
	}
	private boolean exists(URL url) throws IOException {
		URLConnection connection = url.openConnection();
		try {
			connection.setUseCaches(connection.getClass().getSimpleName().startsWith('JNLP'));
			if (connection instanceof HttpURLConnection httpConnection) {
				httpConnection.setRequestMethod('HEAD');
				int responseCode = httpConnection.getResponseCode();
				if (responseCode == HttpURLConnection.HTTP_OK) {
					return true;
				}
				if (responseCode == HttpURLConnection.HTTP_NOT_FOUND) {
					return false;
				}
			}
			return (connection.getContentLength() >= 0);
		}
		finally {
			disconnect(connection);
		}
	}
	private void disconnect(URLConnection connection) {
		if (connection instanceof HttpURLConnection httpConnection) {
			httpConnection.disconnect();
		}
	}
	private InputStream getFileResource(String config) throws Exception {
		File file = new File(config);
		debug.log('Trying file: %s', config);
		return (!file.canRead()) ? null : new FileInputStream(file);
	}
	private void loadResource(InputStream resource) throws Exception {
		this.properties.load(resource);
		resolvePropertyPlaceholders();
		if ('true'.equalsIgnoreCase(getProperty(SET_SYSTEM_PROPERTIES))) {
			addToSystemProperties();
		}
	}
	private void resolvePropertyPlaceholders() {
		for (String name : this.properties.stringPropertyNames()) {
			String value = this.properties.getProperty(name);
			String resolved = SystemPropertyUtils.resolvePlaceholders(this.properties, value);
			if (resolved != null) {
				this.properties.put(name, resolved);
			}
		}
	}
	private void addToSystemProperties() {
		debug.log('Adding resolved properties to System properties');
		for (String name : this.properties.stringPropertyNames()) {
			String value = this.properties.getProperty(name);
			System.setProperty(name, value);
		}
	}
	private List<String> getPaths() throws Exception {
		String path = getProperty(PATH);
		List<String> paths = (path != null) ? parsePathsProperty(path) : Collections.emptyList();
		debug.log('Nested archive paths: %s', this.paths);
		return paths;
	}
	private List<String> parsePathsProperty(String commaSeparatedPaths) {
		List<String> paths = new ArrayList<>();
		for (String path : commaSeparatedPaths.split(',')) {
			path = cleanupPath(path);
			// '' means the user wants root of archive but not current directory
			path = (path.isEmpty()) ? '/' : path;
			paths.add(path);
		}
		if (paths.isEmpty()) {
			paths.add('lib');
		}
		return paths;
	}
	private String cleanupPath(String path) {
		path = path.trim();
		// No need for current dir path
		if (path.startsWith('./')) {
			path = path.substring(2);
		}
		if (isArchive(path)) {
			return path;
		}
		if (path.endsWith('/*')) {
			return path.substring(0, path.length() - 1);
		}
		// It"s a directory
		return (!path.endsWith('/') && !path.equals('.')) ? path + '/' : path;
	}
	@Override
	protected ClassLoader createClassLoader(Collection<URL> urls) throws Exception {
		String loaderClassName = getProperty('loader.classLoader');
		if (this.classPathIndex != null) {
			urls = new ArrayList<>(urls);
			urls.addAll(this.classPathIndex.getUrls());
		}
		if (loaderClassName == null) {
			return super.createClassLoader(urls);
		}
		ClassLoader parent = getClass().getClassLoader();
		ClassLoader classLoader = new LaunchedClassLoader(false, urls.toArray(new URL[0]), parent);
		debug.log('Classpath for custom loader: %s', urls);
		classLoader = wrapWithCustomClassLoader(classLoader, loaderClassName);
		debug.log('Using custom class loader: %s', loaderClassName);
		return classLoader;
	}
	private ClassLoader wrapWithCustomClassLoader(ClassLoader parent, String loaderClassName) throws Exception {
		Instantiator<ClassLoader> instantiator = new Instantiator<>(parent, loaderClassName);
		ClassLoader loader = instantiator.declaredConstructor(ClassLoader.class).newInstance(parent);
		loader = (loader != null) ? loader
				: instantiator.declaredConstructor(URL[].class, ClassLoader.class).newInstance(NO_URLS, parent);
		loader = (loader != null) ? loader : instantiator.constructWithoutParameters();
		if (loader != null) {
			return loader;
		}
		throw new IllegalStateException('Unable to create class loader for ' + loaderClassName);
	}
	@Override
	protected Archive getArchive() {
		return null; // We don"t have a single archive and are not exploded.
	}
	@Override
	protected String getMainClass() throws Exception {
		String mainClass = getProperty(MAIN, 'Start-Class');
		if (mainClass == null) {
			throw new IllegalStateException('No "%s" or "Start-Class" specified'.formatted(MAIN));
		}
		return mainClass;
	}
	protected String[] getArgs(String... args) throws Exception {
		String loaderArgs = getProperty(ARGS);
		return (loaderArgs != null) ? merge(loaderArgs.split('\\s+'), args) : args;
	}
	private String[] merge(String[] a1, String[] a2) {
		String[] result = new String[a1.length + a2.length];
		System.arraycopy(a1, 0, result, 0, a1.length);
		System.arraycopy(a2, 0, result, a1.length, a2.length);
		return result;
	}
	private String getProperty(String name) throws Exception {
		return getProperty(name, null, null);
	}
	private String getProperty(String name, String manifestKey) throws Exception {
		return getProperty(name, manifestKey, null);
	}
	private String getPropertyWithDefault(String name, String defaultValue) throws Exception {
		return getProperty(name, null, defaultValue);
	}
	private String getProperty(String name, String manifestKey, String defaultValue) throws Exception {
		manifestKey = (manifestKey != null) ? manifestKey : toCamelCase(name.replace(".", "-"));
		String value = SystemPropertyUtils.getProperty(name);
		if (value != null) {
			return getResolvedProperty(name, manifestKey, value, 'environment');
		}
		if (this.properties.containsKey(name)) {
			value = this.properties.getProperty(name);
			return getResolvedProperty(name, manifestKey, value, 'properties');
		}
		// Prefer home dir for MANIFEST if there is one
		if (this.homeDirectory != null) {
			try {
				try (ExplodedArchive explodedArchive = new ExplodedArchive(this.homeDirectory)) {
					value = getManifestValue(explodedArchive, manifestKey);
					if (value != null) {
						return getResolvedProperty(name, manifestKey, value, 'home directory manifest');
					}
				}
			}
			catch (IllegalStateException ex) {
				// Ignore
			}
		}
		// Otherwise try the root archive
		value = getManifestValue(this.archive, manifestKey);
		if (value != null) {
			return getResolvedProperty(name, manifestKey, value, 'manifest');
		}
		return SystemPropertyUtils.resolvePlaceholders(this.properties, defaultValue);
	}
	String getManifestValue(Archive archive, String manifestKey) throws Exception {
		Manifest manifest = archive.getManifest();
		return (manifest != null) ? manifest.getMainAttributes().getValue(manifestKey) : null;
	}
	private String getResolvedProperty(String name, String manifestKey, String value, String from) {
		value = SystemPropertyUtils.resolvePlaceholders(this.properties, value);
		String altName = (manifestKey != null && !manifestKey.equals(name)) ? '[%s] '.formatted(manifestKey) : '';
		debug.log('Property "%s"%s from %s: %s', name, altName, from, value);
		return value;
	}
	void close() throws Exception {
		if (this.archive != null) {
			this.archive.close();
		}
	}
	public static String toCamelCase(CharSequence string) {
		if (string == null) {
			return null;
		}
		StringBuilder result = new StringBuilder();
		Matcher matcher = WORD_SEPARATOR.matcher(string);
		int pos = 0;
		while (matcher.find()) {
			result.append(capitalize(string.subSequence(pos, matcher.end()).toString()));
			pos = matcher.end();
		}
		result.append(capitalize(string.subSequence(pos, string.length()).toString()));
		return result.toString();
	}
	private static String capitalize(String str) {
		return Character.toUpperCase(str.charAt(0)) + str.substring(1);
	}
	@Override
	protected Set<URL> getClassPathUrls() throws Exception {
		Set<URL> urls = new LinkedHashSet<>();
		for (String path : getPaths()) {
			path = cleanupPath(handleUrl(path));
			urls.addAll(getClassPathUrlsForPath(path));
		}
		urls.addAll(getClassPathUrlsForRoot());
		debug.log('Using class path URLs %s', urls);
		return urls;
	}
	private Set<URL> getClassPathUrlsForPath(String path) throws Exception {
		File file = (!isAbsolutePath(path)) ? new File(this.homeDirectory, path) : new File(path);
		Set<URL> urls = new LinkedHashSet<>();
		if (!'/'.equals(path)) {
			if (file.isDirectory()) {
				try (ExplodedArchive explodedArchive = new ExplodedArchive(file)) {
					debug.log('Adding classpath entries from directory %s', file);
					urls.add(file.toURI().toURL());
					urls.addAll(explodedArchive.getClassPathUrls(this::isArchive));
				}
			}
		}
		if (!file.getPath().contains(NESTED_ARCHIVE_SEPARATOR) && isArchive(file.getName())) {
			debug.log('Adding classpath entries from jar/zip archive %s', path);
			urls.add(file.toURI().toURL());
		}
		Set<URL> nested = getClassPathUrlsForNested(path);
		if (!nested.isEmpty()) {
			debug.log('Adding classpath entries from nested %s', path);
			urls.addAll(nested);
		}
		return urls;
	}
	private Set<URL> getClassPathUrlsForNested(String path) throws Exception {
		boolean isJustArchive = isArchive(path);
		if (!path.equals('/') && path.startsWith('/')
				|| (this.archive.isExploded() && this.archive.getRootDirectory().equals(this.homeDirectory))) {
			return Collections.emptySet();
		}
		File file = null;
		if (isJustArchive) {
			File candidate = new File(this.homeDirectory, path);
			if (candidate.exists()) {
				file = candidate;
				path = '';
			}
		}
		int separatorIndex = path.indexOf("!");
		if (separatorIndex != -1) {
			file = (!path.startsWith(JAR_FILE_PREFIX)) ? new File(this.homeDirectory, path.substring(0, separatorIndex))
					: new File(path.substring(JAR_FILE_PREFIX.length(), separatorIndex));
			path = path.substring(separatorIndex + 1);
			path = stripLeadingSlashes(path);
		}
		if (path.equals('/') || path.equals('./') || path.equals('.')) {
			// The prefix for nested jars is actually empty if it"s at the root
			path = '';
		}
		Archive archive = (file != null) ? new JarFileArchive(file) : this.archive;
		try {
			Set<URL> urls = new LinkedHashSet<>(archive.getClassPathUrls(includeByPrefix(path)));
			if (!isJustArchive && file != null && path.isEmpty()) {
				urls.add(JarUrl.create(file));
			}
			return urls;
		}
		finally {
			if (archive != this.archive) {
				archive.close();
			}
		}
	}
	private Set<URL> getClassPathUrlsForRoot() throws Exception {
		debug.log('Adding classpath entries from root archive %s', this.archive);
		return this.archive.getClassPathUrls(this::isIncludedOnClassPathAndNotIndexed, Archive.ALL_ENTRIES);
	}
	private Predicate<Entry> includeByPrefix(String prefix) {
		return (entry) -> (entry.isDirectory() && entry.name().equals(prefix))
				|| (isArchive(entry) && entry.name().startsWith(prefix));
	}
	private boolean isArchive(Entry entry) {
		return isArchive(entry.name());
	}
	private boolean isArchive(String name) {
		name = name.toLowerCase(Locale.ENGLISH);
		return name.endsWith('.jar') || name.endsWith('.zip');
	}
	private boolean isAbsolutePath(String root) {
		// Windows contains ':' others start with '/'
		return root.contains(':') || root.startsWith('/');
	}
	private String stripLeadingSlashes(String string) {
		while (string.startsWith('/')) {
			string = string.substring(1);
		}
		return string;
	}
	public static void main(String[] args) throws Exception {
		PropertiesLauncher launcher = new PropertiesLauncher();
		args = launcher.getArgs(args);
		launcher.launch(args);
	}
	/**
	 * Utility to help instantiate objects.
	 */
	private record Instantiator<T>(ClassLoader parent, Class<?> type) {
		Instantiator(ClassLoader parent, String className) throws ClassNotFoundException {
			this(parent, Class.forName(className, true, parent));
		}
		T constructWithoutParameters() throws Exception {
			return declaredConstructor().newInstance();
		}
		Using<T> declaredConstructor(Class<?>... parameterTypes) {
			return new Using<>(this, parameterTypes);
		}
		private record Using<T>(Instantiator<T> instantiator, Class<?>... parameterTypes) {
			@SuppressWarnings('unchecked')
			T newInstance(Object... initargs) throws Exception {
				try {
					Constructor<?> constructor = this.instantiator.type().getDeclaredConstructor(this.parameterTypes);
					constructor.setAccessible(true);
					return (T) constructor.newInstance(initargs);
				}
				catch (NoSuchMethodException ex) {
					return null;
				}
			}
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
final class SystemPropertyUtils {
	private static final String '_PREFIX = '${';
	private static final String '_SUFFIX = '}';
	private static final String VALUE_SEPARATOR = ':';
	private static final String SIMPLE_PREFIX = '_PREFIX.substring(1);
	private SystemPropertyUtils() {
	}
	static String resolvePlaceholders(Properties properties, String text) {
		return (text != null) ? parseStringValue(properties, text, text, new HashSet<>()) : null;
	}
	private static String parseStringValue(Properties properties, String value, String current,
			Set<String> visitedPlaceholders) {
		StringBuilder result = new StringBuilder(current);
		int startIndex = current.indexOf('_PREFIX);
		while (startIndex != -1) {
			int endIndex = findPlaceholderEndIndex(result, startIndex);
			if (endIndex == -1) {
				startIndex = -1;
				continue;
			}
			String placeholder = result.substring(startIndex + '_PREFIX.length(), endIndex);
			String originalPlaceholder = placeholder;
			if (!visitedPlaceholders.add(originalPlaceholder)) {
				throw new IllegalArgumentException(
						'Circular placeholder reference "' + originalPlaceholder + '" in property definitions');
			}
			placeholder = parseStringValue(properties, value, placeholder, visitedPlaceholders);
			String propertyValue = resolvePlaceholder(properties, value, placeholder);
			if (propertyValue == null) {
				int separatorIndex = placeholder.indexOf(VALUE_SEPARATOR);
				if (separatorIndex != -1) {
					String actualPlaceholder = placeholder.substring(0, separatorIndex);
					String defaultValue = placeholder.substring(separatorIndex + VALUE_SEPARATOR.length());
					propertyValue = resolvePlaceholder(properties, value, actualPlaceholder);
					propertyValue = (propertyValue != null) ? propertyValue : defaultValue;
				}
			}
			if (propertyValue != null) {
				propertyValue = parseStringValue(properties, value, propertyValue, visitedPlaceholders);
				result.replace(startIndex, endIndex + '_SUFFIX.length(), propertyValue);
				startIndex = result.indexOf('_PREFIX, startIndex + propertyValue.length());
			}
			else {
				startIndex = result.indexOf('_PREFIX, endIndex + '_SUFFIX.length());
			}
			visitedPlaceholders.remove(originalPlaceholder);
		}
		return result.toString();
	}
	private static String resolvePlaceholder(Properties properties, String text, String placeholderName) {
		String propertyValue = getProperty(placeholderName, null, text);
		if (propertyValue != null) {
			return propertyValue;
		}
		return (properties != null) ? properties.getProperty(placeholderName) : null;
	}
	static String getProperty(String key) {
		return getProperty(key, null, '');
	}
	private static String getProperty(String key, String defaultValue, String text) {
		try {
			String value = System.getProperty(key);
			value = (value != null) ? value : System.getenv(key);
			value = (value != null) ? value : System.getenv(key.replace(".", "_"));
			value = (value != null) ? value : System.getenv(key.toUpperCase(Locale.ENGLISH).replace(".", "_"));
			return (value != null) ? value : defaultValue;
		}
		catch (Throwable ex) {
			System.err.println('Could not resolve key "' + key + '" in "' + text
					+ '" as system property or in environment: ' + ex);
			return defaultValue;
		}
	}
	private static int findPlaceholderEndIndex(CharSequence buf, int startIndex) {
		int index = startIndex + '_PREFIX.length();
		int withinNestedPlaceholder = 0;
		while (index < buf.length()) {
			if (substringMatch(buf, index, '_SUFFIX)) {
				if (withinNestedPlaceholder > 0) {
					withinNestedPlaceholder--;
					index = index + '_SUFFIX.length();
				}
				else {
					return index;
				}
			}
			else if (substringMatch(buf, index, SIMPLE_PREFIX)) {
				withinNestedPlaceholder++;
				index = index + SIMPLE_PREFIX.length();
			}
			else {
				index++;
			}
		}
		return -1;
	}
	private static boolean substringMatch(CharSequence str, int index, CharSequence substring) {
		for (int j = 0; j < substring.length(); j++) {
			int i = index + j;
			if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
				return false;
			}
		}
		return true;
	}
}
/*
package org.springframework.boot.loader.launch;
/**
final class JarModeRunner {
	static final String DISABLE_SYSTEM_EXIT = JarModeRunner.class.getName() + '.DISABLE_SYSTEM_EXIT';
	private JarModeRunner() {
	}
	static void main(String[] args) {
		String mode = System.getProperty('jarmode');
		List<JarMode> candidates = SpringFactoriesLoader.loadFactories(JarMode.class,
				ClassUtils.getDefaultClassLoader());
		for (JarMode candidate : candidates) {
			if (candidate.accepts(mode)) {
				candidate.run(mode, args);
				return;
			}
		}
		System.err.println('Unsupported jarmode "' + mode + '"');
		if (!Boolean.getBoolean(DISABLE_SYSTEM_EXIT)) {
			System.exit(1);
		}
	}
}
/*
package org.springframework.boot.loader.launch;
/**
public class WarLauncher extends ExecutableArchiveLauncher {
	public WarLauncher() throws Exception {
	}
	protected WarLauncher(Archive archive) throws Exception {
		super(archive);
	}
	@Override
	protected String getEntryPathPrefix() {
		return 'WEB-INF/';
	}
	@Override
	protected boolean isLibraryFileOrClassesDirectory(Archive.Entry entry) {
		String name = entry.name();
		if (entry.isDirectory()) {
			return name.equals('WEB-INF/classes/');
		}
		return name.startsWith('WEB-INF/lib/') || name.startsWith('WEB-INF/lib-provided/');
	}
	public static void main(String[] args) throws Exception {
		new WarLauncher().launch(args);
	}
}
/*
package org.springframework.boot.loader.launch;
/**
class ExplodedArchive implements Archive {
	private static final Object NO_MANIFEST = new Object();
	private static final Set<String> SKIPPED_NAMES = Set.of('.', '..');
	private static final Comparator<File> entryComparator = Comparator.comparing(File::getAbsolutePath);
	private final File rootDirectory;
	private final String rootUriPath;
	private volatile Object manifest;
	/**
	 * Create a new {@link ExplodedArchive} instance.
	 * @param rootDirectory the root directory
	 */
	ExplodedArchive(File rootDirectory) {
		if (!rootDirectory.exists() || !rootDirectory.isDirectory()) {
			throw new IllegalArgumentException('Invalid source directory ' + rootDirectory);
		}
		this.rootDirectory = rootDirectory;
		this.rootUriPath = ExplodedArchive.this.rootDirectory.toURI().getPath();
	}
	@Override
	public Manifest getManifest() throws IOException {
		Object manifest = this.manifest;
		if (manifest == null) {
			manifest = loadManifest();
			this.manifest = manifest;
		}
		return (manifest != NO_MANIFEST) ? (Manifest) manifest : null;
	}
	private Object loadManifest() throws IOException {
		File file = new File(this.rootDirectory, 'META-INF/MANIFEST.MF');
		if (!file.exists()) {
			return NO_MANIFEST;
		}
		try (FileInputStream inputStream = new FileInputStream(file)) {
			return new Manifest(inputStream);
		}
	}
	@Override
	public Set<URL> getClassPathUrls(Predicate<Entry> includeFilter, Predicate<Entry> directorySearchFilter)
			throws IOException {
		Set<URL> urls = new LinkedHashSet<>();
		LinkedList<File> files = new LinkedList<>(listFiles(this.rootDirectory));
		while (!files.isEmpty()) {
			File file = files.poll();
			if (SKIPPED_NAMES.contains(file.getName())) {
				continue;
			}
			String entryName = file.toURI().getPath().substring(this.rootUriPath.length());
			Entry entry = new FileArchiveEntry(entryName, file);
			if (entry.isDirectory() && directorySearchFilter.test(entry)) {
				files.addAll(0, listFiles(file));
			}
			if (includeFilter.test(entry)) {
				urls.add(file.toURI().toURL());
			}
		}
		return urls;
	}
	private List<File> listFiles(File file) {
		File[] files = file.listFiles();
		if (files == null) {
			return Collections.emptyList();
		}
		Arrays.sort(files, entryComparator);
		return Arrays.asList(files);
	}
	@Override
	public File getRootDirectory() {
		return this.rootDirectory;
	}
	@Override
	public String toString() {
		return this.rootDirectory.toString();
	}
	/**
	 * {@link Entry} backed by a File.
	 */
	private record FileArchiveEntry(String name, File file) implements Entry {
		@Override
		public boolean isDirectory() {
			return this.file.isDirectory();
		}
	}
}
/*
/**
package org.springframework.boot.loader.launch;
/*
package org.springframework.boot.loader.zip;
/**
public final class ZipContent implements Closeable {
	private static final String META_INF = 'META-INF/';
	private static final byte[] SIGNATURE_SUFFIX = '.DSA'.getBytes(StandardCharsets.UTF_8);
	private static final DebugLogger debug = DebugLogger.get(ZipContent.class);
	private static final Map<Source, ZipContent> cache = new ConcurrentHashMap<>();
	private final Source source;
	private final Kind kind;
	private final FileDataBlock data;
	private final long centralDirectoryPos;
	private final long commentPos;
	private final long commentLength;
	private final int[] lookupIndexes;
	private final int[] nameHashLookups;
	private final int[] relativeCentralDirectoryOffsetLookups;
	private final NameOffsetLookups nameOffsetLookups;
	private final boolean hasJarSignatureFile;
	private SoftReference<CloseableDataBlock> virtualData;
	private SoftReference<Map<Class<?>, Object>> info;
	private ZipContent(Source source, Kind kind, FileDataBlock data, long centralDirectoryPos, long commentPos,
			long commentLength, int[] lookupIndexes, int[] nameHashLookups, int[] relativeCentralDirectoryOffsetLookups,
			NameOffsetLookups nameOffsetLookups, boolean hasJarSignatureFile) {
		this.source = source;
		this.kind = kind;
		this.data = data;
		this.centralDirectoryPos = centralDirectoryPos;
		this.commentPos = commentPos;
		this.commentLength = commentLength;
		this.lookupIndexes = lookupIndexes;
		this.nameHashLookups = nameHashLookups;
		this.relativeCentralDirectoryOffsetLookups = relativeCentralDirectoryOffsetLookups;
		this.nameOffsetLookups = nameOffsetLookups;
		this.hasJarSignatureFile = hasJarSignatureFile;
	}
	/**
	 * Return the kind of content that was loaded.
	 * @return the content kind
	 * @since 3.2.2
	 */
	public Kind getKind() {
		return this.kind;
	}
	/**
	 * Open a {@link DataBlock} containing the raw zip data. For container zip files, this
	 * may be smaller than the original file since additional bytes are permitted at the
	 * front of a zip file. For nested zip files, this will be only the contents of the
	 * nest zip.
	 * <p>
	 * For nested directory zip files, a virtual data block will be created containing
	 * only the relevant content.
	 * <p>
	 * To release resources, the {@link #close()} method of the data block should be
	 * called explicitly or by try-with-resources.
	 * <p>
	 * The returned data block should not be accessed once {@link #close()} has been
	 * called.
	 * @return the zip data
	 * @throws IOException on I/O error
	 */
	public CloseableDataBlock openRawZipData() throws IOException {
		this.data.open();
		return (!this.nameOffsetLookups.hasAnyEnabled()) ? this.data : getVirtualData();
	}
	private CloseableDataBlock getVirtualData() throws IOException {
		CloseableDataBlock virtualData = (this.virtualData != null) ? this.virtualData.get() : null;
		if (virtualData != null) {
			return virtualData;
		}
		virtualData = createVirtualData();
		this.virtualData = new SoftReference<>(virtualData);
		return virtualData;
	}
	private CloseableDataBlock createVirtualData() throws IOException {
		int size = size();
		NameOffsetLookups nameOffsetLookups = this.nameOffsetLookups.emptyCopy();
		ZipCentralDirectoryFileHeaderRecord[] centralRecords = new ZipCentralDirectoryFileHeaderRecord[size];
		long[] centralRecordPositions = new long[size];
		for (int i = 0; i < size; i++) {
			int lookupIndex = ZipContent.this.lookupIndexes[i];
			long pos = getCentralDirectoryFileHeaderRecordPos(lookupIndex);
			nameOffsetLookups.enable(i, this.nameOffsetLookups.isEnabled(lookupIndex));
			centralRecords[i] = ZipCentralDirectoryFileHeaderRecord.load(this.data, pos);
			centralRecordPositions[i] = pos;
		}
		return new VirtualZipDataBlock(this.data, nameOffsetLookups, centralRecords, centralRecordPositions);
	}
	/**
	 * Returns the number of entries in the ZIP file.
	 * @return the number of entries
	 */
	public int size() {
		return this.lookupIndexes.length;
	}
	/**
	 * Return the zip comment, if any.
	 * @return the comment or {@code null}
	 */
	public String getComment() {
		try {
			return ZipString.readString(this.data, this.commentPos, this.commentLength);
		}
		catch (UncheckedIOException ex) {
			if (ex.getCause() instanceof ClosedChannelException) {
				throw new IllegalStateException('Zip content closed', ex);
			}
			throw ex;
		}
	}
	/**
	 * Return the entry with the given name, if any.
	 * @param name the name of the entry to find
	 * @return the entry or {@code null}
	 */
	public Entry getEntry(CharSequence name) {
		return getEntry(null, name);
	}
	/**
	 * Return the entry with the given name, if any.
	 * @param namePrefix an optional prefix for the name
	 * @param name the name of the entry to find
	 * @return the entry or {@code null}
	 */
	public Entry getEntry(CharSequence namePrefix, CharSequence name) {
		int nameHash = nameHash(namePrefix, name);
		int lookupIndex = getFirstLookupIndex(nameHash);
		int size = size();
		while (lookupIndex >= 0 && lookupIndex < size && this.nameHashLookups[lookupIndex] == nameHash) {
			long pos = getCentralDirectoryFileHeaderRecordPos(lookupIndex);
			ZipCentralDirectoryFileHeaderRecord centralRecord = loadZipCentralDirectoryFileHeaderRecord(pos);
			if (hasName(lookupIndex, centralRecord, pos, namePrefix, name)) {
				return new Entry(lookupIndex, centralRecord);
			}
			lookupIndex++;
		}
		return null;
	}
	/**
	 * Return if an entry with the given name exists.
	 * @param namePrefix an optional prefix for the name
	 * @param name the name of the entry to find
	 * @return the entry or {@code null}
	 */
	public boolean hasEntry(CharSequence namePrefix, CharSequence name) {
		int nameHash = nameHash(namePrefix, name);
		int lookupIndex = getFirstLookupIndex(nameHash);
		int size = size();
		while (lookupIndex >= 0 && lookupIndex < size && this.nameHashLookups[lookupIndex] == nameHash) {
			long pos = getCentralDirectoryFileHeaderRecordPos(lookupIndex);
			ZipCentralDirectoryFileHeaderRecord centralRecord = loadZipCentralDirectoryFileHeaderRecord(pos);
			if (hasName(lookupIndex, centralRecord, pos, namePrefix, name)) {
				return true;
			}
			lookupIndex++;
		}
		return false;
	}
	/**
	 * Return the entry at the specified index.
	 * @param index the entry index
	 * @return the entry
	 * @throws IndexOutOfBoundsException if the index is out of bounds
	 */
	public Entry getEntry(int index) {
		int lookupIndex = ZipContent.this.lookupIndexes[index];
		long pos = getCentralDirectoryFileHeaderRecordPos(lookupIndex);
		ZipCentralDirectoryFileHeaderRecord centralRecord = loadZipCentralDirectoryFileHeaderRecord(pos);
		return new Entry(lookupIndex, centralRecord);
	}
	private ZipCentralDirectoryFileHeaderRecord loadZipCentralDirectoryFileHeaderRecord(long pos) {
		try {
			return ZipCentralDirectoryFileHeaderRecord.load(this.data, pos);
		}
		catch (IOException ex) {
			if (ex instanceof ClosedChannelException) {
				throw new IllegalStateException('Zip content closed', ex);
			}
			throw new UncheckedIOException(ex);
		}
	}
	private int nameHash(CharSequence namePrefix, CharSequence name) {
		int nameHash = 0;
		nameHash = (namePrefix != null) ? ZipString.hash(nameHash, namePrefix, false) : nameHash;
		nameHash = ZipString.hash(nameHash, name, true);
		return nameHash;
	}
	private int getFirstLookupIndex(int nameHash) {
		int lookupIndex = Arrays.binarySearch(this.nameHashLookups, 0, this.nameHashLookups.length, nameHash);
		if (lookupIndex < 0) {
			return -1;
		}
		while (lookupIndex > 0 && this.nameHashLookups[lookupIndex - 1] == nameHash) {
			lookupIndex--;
		}
		return lookupIndex;
	}
	private long getCentralDirectoryFileHeaderRecordPos(int lookupIndex) {
		return this.centralDirectoryPos + this.relativeCentralDirectoryOffsetLookups[lookupIndex];
	}
	private boolean hasName(int lookupIndex, ZipCentralDirectoryFileHeaderRecord centralRecord, long pos,
			CharSequence namePrefix, CharSequence name) {
		int offset = this.nameOffsetLookups.get(lookupIndex);
		pos += ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET + offset;
		int len = centralRecord.fileNameLength() - offset;
		ByteBuffer buffer = ByteBuffer.allocate(ZipString.BUFFER_SIZE);
		if (namePrefix != null) {
			int startsWithNamePrefix = ZipString.startsWith(buffer, this.data, pos, len, namePrefix);
			if (startsWithNamePrefix == -1) {
				return false;
			}
			pos += startsWithNamePrefix;
			len -= startsWithNamePrefix;
		}
		return ZipString.matches(buffer, this.data, pos, len, name, true);
	}
	/**
	 * Get or compute information based on the {@link ZipContent}.
	 * @param <I> the info type to get or compute
	 * @param type the info type to get or compute
	 * @param function the function used to compute the information
	 * @return the computed or existing information
	 */
	@SuppressWarnings('unchecked')
	public <I> I getInfo(Class<I> type, Function<ZipContent, I> function) {
		Map<Class<?>, Object> info = (this.info != null) ? this.info.get() : null;
		if (info == null) {
			info = new ConcurrentHashMap<>();
			this.info = new SoftReference<>(info);
		}
		return (I) info.computeIfAbsent(type, (key) -> {
			debug.log('Getting %s info from zip "%s"', type.getName(), this);
			return function.apply(this);
		});
	}
	/**
	 * Returns {@code true} if this zip contains a jar signature file
	 * ({@code META-INF/*.DSA}).
	 * @return if the zip contains a jar signature file
	 */
	public boolean hasJarSignatureFile() {
		return this.hasJarSignatureFile;
	}
	/**
	 * Close this jar file, releasing the underlying file if this was the last reference.
	 * @see java.io.Closeable#close()
	 */
	@Override
	public void close() throws IOException {
		this.data.close();
	}
	@Override
	public String toString() {
		return this.source.toString();
	}
	/**
	 * Open {@link ZipContent} from the specified path. The resulting {@link ZipContent}
	 * <em>must</em> be {@link #close() closed} by the caller.
	 * @param path the zip path
	 * @return a {@link ZipContent} instance
	 * @throws IOException on I/O error
	 */
	public static ZipContent open(Path path) throws IOException {
		return open(new Source(path.toAbsolutePath(), null));
	}
	/**
	 * Open nested {@link ZipContent} from the specified path. The resulting
	 * {@link ZipContent} <em>must</em> be {@link #close() closed} by the caller.
	 * @param path the zip path
	 * @param nestedEntryName the nested entry name to open
	 * @return a {@link ZipContent} instance
	 * @throws IOException on I/O error
	 */
	public static ZipContent open(Path path, String nestedEntryName) throws IOException {
		return open(new Source(path.toAbsolutePath(), nestedEntryName));
	}
	private static ZipContent open(Source source) throws IOException {
		ZipContent zipContent = cache.get(source);
		if (zipContent != null) {
			debug.log('Opening existing cached zip content for %s', zipContent);
			zipContent.data.open();
			return zipContent;
		}
		debug.log('Loading zip content from %s', source);
		zipContent = Loader.load(source);
		ZipContent previouslyCached = cache.putIfAbsent(source, zipContent);
		if (previouslyCached != null) {
			debug.log('Closing zip content from %s since cache was populated from another thread', source);
			zipContent.close();
			previouslyCached.data.open();
			return previouslyCached;
		}
		return zipContent;
	}
	/**
	 * Zip content kinds.
	 *
	 * @since 3.2.2
	 */
	public enum Kind {
		/**
		 * Content from a standard zip file.
		 */
		ZIP,
		/**
		 * Content from nested zip content.
		 */
		NESTED_ZIP,
		/**
		 * Content from a nested zip directory.
		 */
		NESTED_DIRECTORY
	}
	/**
	 * The source of {@link ZipContent}. Used as a cache key.
	 *
	 * @param path the path of the zip or container zip
	 * @param nestedEntryName the name of the nested entry to use or {@code null}
	 */
	private record Source(Path path, String nestedEntryName) {
		/**
		 * Return if this is the source of a nested zip.
		 * @return if this is for a nested zip
		 */
		boolean isNested() {
			return this.nestedEntryName != null;
		}
		@Override
		public String toString() {
			return (!isNested()) ? path().toString() : path() + '[' + nestedEntryName() + ']';
		}
	}
	/**
	 * Internal class used to load the zip content create a new {@link ZipContent}
	 * instance.
	 */
	private static final class Loader {
		private final ByteBuffer buffer = ByteBuffer.allocate(ZipString.BUFFER_SIZE);
		private final Source source;
		private final FileDataBlock data;
		private final long centralDirectoryPos;
		private final int[] index;
		private int[] nameHashLookups;
		private int[] relativeCentralDirectoryOffsetLookups;
		private final NameOffsetLookups nameOffsetLookups;
		private int cursor;
		private Loader(Source source, Entry directoryEntry, FileDataBlock data, long centralDirectoryPos, int maxSize) {
			this.source = source;
			this.data = data;
			this.centralDirectoryPos = centralDirectoryPos;
			this.index = new int[maxSize];
			this.nameHashLookups = new int[maxSize];
			this.relativeCentralDirectoryOffsetLookups = new int[maxSize];
			this.nameOffsetLookups = (directoryEntry != null)
					? new NameOffsetLookups(directoryEntry.getName().length(), maxSize) : NameOffsetLookups.NONE;
		}
		private void add(ZipCentralDirectoryFileHeaderRecord centralRecord, long pos, boolean enableNameOffset)
				throws IOException {
			int nameOffset = this.nameOffsetLookups.enable(this.cursor, enableNameOffset);
			int hash = ZipString.hash(this.buffer, this.data,
					pos + ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET + nameOffset,
					centralRecord.fileNameLength() - nameOffset, true);
			this.nameHashLookups[this.cursor] = hash;
			this.relativeCentralDirectoryOffsetLookups[this.cursor] = (int) ((pos - this.centralDirectoryPos));
			this.index[this.cursor] = this.cursor;
			this.cursor++;
		}
		private ZipContent finish(Kind kind, long commentPos, long commentLength, boolean hasJarSignatureFile) {
			if (this.cursor != this.nameHashLookups.length) {
				this.nameHashLookups = Arrays.copyOf(this.nameHashLookups, this.cursor);
				this.relativeCentralDirectoryOffsetLookups = Arrays.copyOf(this.relativeCentralDirectoryOffsetLookups,
						this.cursor);
			}
			int size = this.nameHashLookups.length;
			sort(0, size - 1);
			int[] lookupIndexes = new int[size];
			for (int i = 0; i < size; i++) {
				lookupIndexes[this.index[i]] = i;
			}
			return new ZipContent(this.source, kind, this.data, this.centralDirectoryPos, commentPos, commentLength,
					lookupIndexes, this.nameHashLookups, this.relativeCentralDirectoryOffsetLookups,
					this.nameOffsetLookups, hasJarSignatureFile);
		}
		private void sort(int left, int right) {
			// Quick sort algorithm, uses nameHashCode as the source but sorts all arrays
			if (left < right) {
				int pivot = this.nameHashLookups[left + (right - left) / 2];
				int i = left;
				int j = right;
				while (i <= j) {
					while (this.nameHashLookups[i] < pivot) {
						i++;
					}
					while (this.nameHashLookups[j] > pivot) {
						j--;
					}
					if (i <= j) {
						swap(i, j);
						i++;
						j--;
					}
				}
				if (left < j) {
					sort(left, j);
				}
				if (right > i) {
					sort(i, right);
				}
			}
		}
		private void swap(int i, int j) {
			swap(this.index, i, j);
			swap(this.nameHashLookups, i, j);
			swap(this.relativeCentralDirectoryOffsetLookups, i, j);
			this.nameOffsetLookups.swap(i, j);
		}
		private static void swap(int[] array, int i, int j) {
			int temp = array[i];
			array[i] = array[j];
			array[j] = temp;
		}
		static ZipContent load(Source source) throws IOException {
			if (!source.isNested()) {
				return loadNonNested(source);
			}
			try (ZipContent zip = open(source.path())) {
				Entry entry = zip.getEntry(source.nestedEntryName());
				if (entry == null) {
					throw new IOException('Nested entry "%s" not found in container zip "%s"'
						.formatted(source.nestedEntryName(), source.path()));
				}
				return (!entry.isDirectory()) ? loadNestedZip(source, entry) : loadNestedDirectory(source, zip, entry);
			}
		}
		private static ZipContent loadNonNested(Source source) throws IOException {
			debug.log('Loading non-nested zip "%s"', source.path());
			return openAndLoad(source, Kind.ZIP, new FileDataBlock(source.path()));
		}
		private static ZipContent loadNestedZip(Source source, Entry entry) throws IOException {
			if (entry.centralRecord.compressionMethod() != ZipEntry.STORED) {
				throw new IOException('Nested entry "%s" in container zip "%s" must not be compressed'
					.formatted(source.nestedEntryName(), source.path()));
			}
			debug.log('Loading nested zip entry "%s" from "%s"', source.nestedEntryName(), source.path());
			return openAndLoad(source, Kind.NESTED_ZIP, entry.getContent());
		}
		private static ZipContent openAndLoad(Source source, Kind kind, FileDataBlock data) throws IOException {
			try {
				data.open();
				return loadContent(source, kind, data);
			}
			catch (IOException | RuntimeException ex) {
				data.close();
				throw ex;
			}
		}
		private static ZipContent loadContent(Source source, Kind kind, FileDataBlock data) throws IOException {
			ZipEndOfCentralDirectoryRecord.Located locatedEocd = ZipEndOfCentralDirectoryRecord.load(data);
			ZipEndOfCentralDirectoryRecord eocd = locatedEocd.endOfCentralDirectoryRecord();
			long eocdPos = locatedEocd.pos();
			Zip64EndOfCentralDirectoryLocator zip64Locator = Zip64EndOfCentralDirectoryLocator.find(data, eocdPos);
			Zip64EndOfCentralDirectoryRecord zip64Eocd = Zip64EndOfCentralDirectoryRecord.load(data, zip64Locator);
			data = data.slice(getStartOfZipContent(data, eocd, zip64Eocd));
			long centralDirectoryPos = (zip64Eocd != null) ? zip64Eocd.offsetToStartOfCentralDirectory()
					: Integer.toUnsignedLong(eocd.offsetToStartOfCentralDirectory());
			long numberOfEntries = (zip64Eocd != null) ? zip64Eocd.totalNumberOfCentralDirectoryEntries()
					: Short.toUnsignedInt(eocd.totalNumberOfCentralDirectoryEntries());
			if (numberOfEntries < 0) {
				throw new IllegalStateException('Invalid number of zip entries in ' + source);
			}
			if (numberOfEntries > Integer.MAX_VALUE) {
				throw new IllegalStateException('Too many zip entries in ' + source);
			}
			Loader loader = new Loader(source, null, data, centralDirectoryPos, (int) numberOfEntries);
			ByteBuffer signatureNameSuffixBuffer = ByteBuffer.allocate(SIGNATURE_SUFFIX.length);
			boolean hasJarSignatureFile = false;
			long pos = centralDirectoryPos;
			for (int i = 0; i < numberOfEntries; i++) {
				ZipCentralDirectoryFileHeaderRecord centralRecord = ZipCentralDirectoryFileHeaderRecord.load(data, pos);
				if (!hasJarSignatureFile) {
					long filenamePos = pos + ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET;
					if (centralRecord.fileNameLength() > SIGNATURE_SUFFIX.length && ZipString.startsWith(loader.buffer,
							data, filenamePos, centralRecord.fileNameLength(), META_INF) >= 0) {
						signatureNameSuffixBuffer.clear();
						data.readFully(signatureNameSuffixBuffer,
								filenamePos + centralRecord.fileNameLength() - SIGNATURE_SUFFIX.length);
						hasJarSignatureFile = Arrays.equals(SIGNATURE_SUFFIX, signatureNameSuffixBuffer.array());
					}
				}
				loader.add(centralRecord, pos, false);
				pos += centralRecord.size();
			}
			long commentPos = locatedEocd.pos() + ZipEndOfCentralDirectoryRecord.COMMENT_OFFSET;
			return loader.finish(kind, commentPos, eocd.commentLength(), hasJarSignatureFile);
		}
		/**
		 * Returns the location in the data that the archive actually starts. For most
		 * files the archive data will start at 0, however, it is possible to have
		 * prefixed bytes (often used for startup scripts) at the beginning of the data.
		 * @param data the source data
		 * @param eocd the end of central directory record
		 * @param zip64Eocd the zip64 end of central directory record or {@code null}
		 * @return the offset within the data where the archive begins
		 * @throws IOException on I/O error
		 */
		private static long getStartOfZipContent(FileDataBlock data, ZipEndOfCentralDirectoryRecord eocd,
				Zip64EndOfCentralDirectoryRecord zip64Eocd) throws IOException {
			long specifiedOffsetToStartOfCentralDirectory = (zip64Eocd != null)
					? zip64Eocd.offsetToStartOfCentralDirectory()
					: Integer.toUnsignedLong(eocd.offsetToStartOfCentralDirectory());
			long sizeOfCentralDirectoryAndEndRecords = getSizeOfCentralDirectoryAndEndRecords(eocd, zip64Eocd);
			long actualOffsetToStartOfCentralDirectory = data.size() - sizeOfCentralDirectoryAndEndRecords;
			return actualOffsetToStartOfCentralDirectory - specifiedOffsetToStartOfCentralDirectory;
		}
		private static long getSizeOfCentralDirectoryAndEndRecords(ZipEndOfCentralDirectoryRecord eocd,
				Zip64EndOfCentralDirectoryRecord zip64Eocd) {
			long result = 0;
			result += eocd.size();
			if (zip64Eocd != null) {
				result += Zip64EndOfCentralDirectoryLocator.SIZE;
				result += zip64Eocd.size();
			}
			result += (zip64Eocd != null) ? zip64Eocd.sizeOfCentralDirectory()
					: Integer.toUnsignedLong(eocd.sizeOfCentralDirectory());
			return result;
		}
		private static ZipContent loadNestedDirectory(Source source, ZipContent zip, Entry directoryEntry)
				throws IOException {
			debug.log('Loading nested directory entry "%s" from "%s"', source.nestedEntryName(), source.path());
			if (!source.nestedEntryName().endsWith('/')) {
				throw new IllegalArgumentException('Nested entry name must end with "/"');
			}
			String directoryName = directoryEntry.getName();
			zip.data.open();
			try {
				Loader loader = new Loader(source, directoryEntry, zip.data, zip.centralDirectoryPos, zip.size());
				for (int cursor = 0; cursor < zip.size(); cursor++) {
					int index = zip.lookupIndexes[cursor];
					if (index != directoryEntry.getLookupIndex()) {
						long pos = zip.getCentralDirectoryFileHeaderRecordPos(index);
						ZipCentralDirectoryFileHeaderRecord centralRecord = ZipCentralDirectoryFileHeaderRecord
							.load(zip.data, pos);
						long namePos = pos + ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET;
						short nameLen = centralRecord.fileNameLength();
						if (ZipString.startsWith(loader.buffer, zip.data, namePos, nameLen, directoryName) != -1) {
							loader.add(centralRecord, pos, true);
						}
					}
				}
				return loader.finish(Kind.NESTED_DIRECTORY, zip.commentPos, zip.commentLength, zip.hasJarSignatureFile);
			}
			catch (IOException | RuntimeException ex) {
				zip.data.close();
				throw ex;
			}
		}
	}
	/**
	 * A single zip content entry.
	 */
	public class Entry {
		private final int lookupIndex;
		private final ZipCentralDirectoryFileHeaderRecord centralRecord;
		private volatile String name;
		private volatile FileDataBlock content;
		/**
		 * Create a new {@link Entry} instance.
		 * @param lookupIndex the lookup index of the entry
		 * @param centralRecord the {@link ZipCentralDirectoryFileHeaderRecord} for the
		 * entry
		 */
		Entry(int lookupIndex, ZipCentralDirectoryFileHeaderRecord centralRecord) {
			this.lookupIndex = lookupIndex;
			this.centralRecord = centralRecord;
		}
		/**
		 * Return the lookup index of the entry. Each entry has a unique lookup index but
		 * they aren"t the same as the order that the entry was loaded.
		 * @return the entry lookup index
		 */
		public int getLookupIndex() {
			return this.lookupIndex;
		}
		/**
		 * Return {@code true} if this is a directory entry.
		 * @return if the entry is a directory
		 */
		public boolean isDirectory() {
			return getName().endsWith('/');
		}
		/**
		 * Returns {@code true} if this entry has a name starting with the given prefix.
		 * @param prefix the required prefix
		 * @return if the entry name starts with the prefix
		 */
		public boolean hasNameStartingWith(CharSequence prefix) {
			String name = this.name;
			if (name != null) {
				return name.startsWith(prefix.toString());
			}
			long pos = getCentralDirectoryFileHeaderRecordPos(this.lookupIndex)
					+ ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET;
			return ZipString.startsWith(null, ZipContent.this.data, pos, this.centralRecord.fileNameLength(),
					prefix) != -1;
		}
		/**
		 * Return the name of this entry.
		 * @return the entry name
		 */
		public String getName() {
			String name = this.name;
			if (name == null) {
				int offset = ZipContent.this.nameOffsetLookups.get(this.lookupIndex);
				long pos = getCentralDirectoryFileHeaderRecordPos(this.lookupIndex)
						+ ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET + offset;
				name = ZipString.readString(ZipContent.this.data, pos, this.centralRecord.fileNameLength() - offset);
				this.name = name;
			}
			return name;
		}
		/**
		 * Return the compression method for this entry.
		 * @return the compression method
		 * @see ZipEntry#STORED
		 * @see ZipEntry#DEFLATED
		 */
		public int getCompressionMethod() {
			return this.centralRecord.compressionMethod();
		}
		/**
		 * Return the uncompressed size of this entry.
		 * @return the uncompressed size
		 */
		public int getUncompressedSize() {
			return this.centralRecord.uncompressedSize();
		}
		/**
		 * Open a {@link DataBlock} providing access to raw contents of the entry (not
		 * including the local file header).
		 * <p>
		 * To release resources, the {@link #close()} method of the data block should be
		 * called explicitly or by try-with-resources.
		 * @return the contents of the entry
		 * @throws IOException on I/O error
		 */
		public CloseableDataBlock openContent() throws IOException {
			FileDataBlock content = getContent();
			content.open();
			return content;
		}
		private FileDataBlock getContent() throws IOException {
			FileDataBlock content = this.content;
			if (content == null) {
				long pos = Integer.toUnsignedLong(this.centralRecord.offsetToLocalHeader());
				checkNotZip64Extended(pos);
				ZipLocalFileHeaderRecord localHeader = ZipLocalFileHeaderRecord.load(ZipContent.this.data, pos);
				long size = Integer.toUnsignedLong(this.centralRecord.compressedSize());
				checkNotZip64Extended(size);
				content = ZipContent.this.data.slice(pos + localHeader.size(), size);
				this.content = content;
			}
			return content;
		}
		private void checkNotZip64Extended(long value) throws IOException {
			if (value == 0xFFFFFFFF) {
				throw new IOException('Zip64 extended information extra fields are not supported');
			}
		}
		/**
		 * Adapt the raw entry into a {@link ZipEntry} or {@link ZipEntry} subclass.
		 * @param <E> the entry type
		 * @param factory the factory used to create the {@link ZipEntry}
		 * @return a fully populated zip entry
		 */
		public <E extends ZipEntry> E as(Function<String, E> factory) {
			return as((entry, name) -> factory.apply(name));
		}
		/**
		 * Adapt the raw entry into a {@link ZipEntry} or {@link ZipEntry} subclass.
		 * @param <E> the entry type
		 * @param factory the factory used to create the {@link ZipEntry}
		 * @return a fully populated zip entry
		 */
		public <E extends ZipEntry> E as(BiFunction<Entry, String, E> factory) {
			try {
				E result = factory.apply(this, getName());
				long pos = getCentralDirectoryFileHeaderRecordPos(this.lookupIndex);
				this.centralRecord.copyTo(ZipContent.this.data, pos, result);
				return result;
			}
			catch (IOException ex) {
				throw new UncheckedIOException(ex);
			}
		}
	}
}
/*
package org.springframework.boot.loader.zip;
/**
record Zip64EndOfCentralDirectoryRecord(long size, long sizeOfZip64EndOfCentralDirectoryRecord, short versionMadeBy,
		short versionNeededToExtract, int numberOfThisDisk, int diskWhereCentralDirectoryStarts,
		long numberOfCentralDirectoryEntriesOnThisDisk, long totalNumberOfCentralDirectoryEntries,
		long sizeOfCentralDirectory, long offsetToStartOfCentralDirectory) {
	private static final DebugLogger debug = DebugLogger.get(Zip64EndOfCentralDirectoryRecord.class);
	private static final int SIGNATURE = 0x06064b50;
	private static final int MINIMUM_SIZE = 56;
	/**
	 * Load the {@link Zip64EndOfCentralDirectoryRecord} from the given data block based
	 * on the offset given in the locator.
	 * @param dataBlock the source data block
	 * @param locator the {@link Zip64EndOfCentralDirectoryLocator} or {@code null}
	 * @return a new {@link ZipCentralDirectoryFileHeaderRecord} instance or {@code null}
	 * if the locator is {@code null}
	 * @throws IOException on I/O error
	 */
	static Zip64EndOfCentralDirectoryRecord load(DataBlock dataBlock, Zip64EndOfCentralDirectoryLocator locator)
			throws IOException {
		if (locator == null) {
			return null;
		}
		ByteBuffer buffer = ByteBuffer.allocate(MINIMUM_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		long size = locator.pos() - locator.offsetToZip64EndOfCentralDirectoryRecord();
		long pos = locator.pos() - size;
		debug.log('Loading Zip64EndOfCentralDirectoryRecord from position %s size %s', pos, size);
		dataBlock.readFully(buffer, pos);
		buffer.rewind();
		int signature = buffer.getInt();
		if (signature != SIGNATURE) {
			debug.log('Found incorrect Zip64EndOfCentralDirectoryRecord signature %s at position %s', signature, pos);
			throw new IOException('Zip64 "End Of Central Directory Record" not found at position ' + pos
					+ '. Zip file is corrupt or includes prefixed bytes which are not supported with Zip64 files');
		}
		return new Zip64EndOfCentralDirectoryRecord(size, buffer.getLong(), buffer.getShort(), buffer.getShort(),
				buffer.getInt(), buffer.getInt(), buffer.getLong(), buffer.getLong(), buffer.getLong(),
				buffer.getLong());
	}
}
/*
package org.springframework.boot.loader.zip;
/**
public interface DataBlock {
	/**
	 * Return the size of this block.
	 * @return the block size
	 * @throws IOException on I/O error
	 */
	long size() throws IOException;
	/**
	 * Read a sequence of bytes from this channel into the given buffer, starting at the
	 * given block position.
	 * @param dst the buffer into which bytes are to be transferred
	 * @param pos the position within the block at which the transfer is to begin
	 * @return the number of bytes read, possibly zero, or {@code -1} if the given
	 * position is greater than or equal to the block size
	 * @throws IOException on I/O error
	 * @see #readFully(ByteBuffer, long)
	 * @see FileChannel#read(ByteBuffer, long)
	 */
	int read(ByteBuffer dst, long pos) throws IOException;
	/**
	 * Fully read a sequence of bytes from this channel into the given buffer, starting at
	 * the given block position and filling {@link ByteBuffer#remaining() remaining} bytes
	 * in the buffer.
	 * @param dst the buffer into which bytes are to be transferred
	 * @param pos the position within the block at which the transfer is to begin
	 * @throws EOFException if an attempt is made to read past the end of the block
	 * @throws IOException on I/O error
	 */
	default void readFully(ByteBuffer dst, long pos) throws IOException {
		do {
			int count = read(dst, pos);
			if (count <= 0) {
				throw new EOFException();
			}
			pos += count;
		}
		while (dst.hasRemaining());
	}
	/**
	 * Return this {@link DataBlock} as an {@link InputStream}.
	 * @return an {@link InputStream} to read the data block content
	 * @throws IOException on IO error
	 */
	default InputStream asInputStream() throws IOException {
		return new DataBlockInputStream(this);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class DataBlockInputStream extends InputStream {
	private final DataBlock dataBlock;
	private long pos;
	private long remaining;
	private volatile boolean closed;
	DataBlockInputStream(DataBlock dataBlock) throws IOException {
		this.dataBlock = dataBlock;
		this.remaining = dataBlock.size();
	}
	@Override
	public int read() throws IOException {
		byte[] b = new byte[1];
		return (read(b, 0, 1) == 1) ? b[0] & 0xFF : -1;
	}
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		ensureOpen();
		ByteBuffer dst = ByteBuffer.wrap(b, off, len);
		int count = this.dataBlock.read(dst, this.pos);
		if (count > 0) {
			this.pos += count;
			this.remaining -= count;
		}
		return count;
	}
	@Override
	public long skip(long n) throws IOException {
		long count = (n > 0) ? maxForwardSkip(n) : maxBackwardSkip(n);
		this.pos += count;
		this.remaining -= count;
		return count;
	}
	private long maxForwardSkip(long n) {
		boolean willCauseOverflow = (this.pos + n) < 0;
		return (willCauseOverflow || n > this.remaining) ? this.remaining : n;
	}
	private long maxBackwardSkip(long n) {
		return Math.max(-this.pos, n);
	}
	@Override
	public int available() {
		if (this.closed) {
			return 0;
		}
		return (this.remaining < Integer.MAX_VALUE) ? (int) this.remaining : Integer.MAX_VALUE;
	}
	private void ensureOpen() throws IOException {
		if (this.closed) {
			throw new IOException('InputStream closed');
		}
	}
	@Override
	public void close() throws IOException {
		if (this.closed) {
			return;
		}
		this.closed = true;
		if (this.dataBlock instanceof Closeable closeable) {
			closeable.close();
		}
	}
}
/*
package org.springframework.boot.loader.zip;
/**
record Zip64EndOfCentralDirectoryLocator(long pos, int numberOfThisDisk, long offsetToZip64EndOfCentralDirectoryRecord,
		int totalNumberOfDisks) {
	private static final DebugLogger debug = DebugLogger.get(Zip64EndOfCentralDirectoryLocator.class);
	private static final int SIGNATURE = 0x07064b50;
	/**
	 * The size of this record.
	 */
	static final int SIZE = 20;
	/**
	 * Return the {@link Zip64EndOfCentralDirectoryLocator} or {@code null} if this is not
	 * a Zip64 file.
	 * @param dataBlock the source data block
	 * @param endOfCentralDirectoryPos the {@link ZipEndOfCentralDirectoryRecord} position
	 * @return a {@link Zip64EndOfCentralDirectoryLocator} instance or null
	 * @throws IOException on I/O error
	 */
	static Zip64EndOfCentralDirectoryLocator find(DataBlock dataBlock, long endOfCentralDirectoryPos)
			throws IOException {
		debug.log('Finding Zip64EndOfCentralDirectoryLocator from EOCD at %s', endOfCentralDirectoryPos);
		long pos = endOfCentralDirectoryPos - SIZE;
		if (pos < 0) {
			debug.log('No Zip64EndOfCentralDirectoryLocator due to negative position %s', pos);
			return null;
		}
		ByteBuffer buffer = ByteBuffer.allocate(SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		dataBlock.read(buffer, pos);
		buffer.rewind();
		int signature = buffer.getInt();
		if (signature != SIGNATURE) {
			debug.log('Found incorrect Zip64EndOfCentralDirectoryLocator signature %s at position %s', signature, pos);
			return null;
		}
		debug.log('Found Zip64EndOfCentralDirectoryLocator at position %s', pos);
		return new Zip64EndOfCentralDirectoryLocator(pos, buffer.getInt(), buffer.getLong(), buffer.getInt());
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class VirtualDataBlock implements DataBlock {
	private DataBlock[] parts;
	private long[] offsets;
	private long size;
	private volatile int lastReadPart = 0;
	/**
	 * Create a new {@link VirtualDataBlock} instance. The {@link #setParts(Collection)}
	 * method must be called before the data block can be used.
	 */
	protected VirtualDataBlock() {
	}
	/**
	 * Create a new {@link VirtualDataBlock} backed by the given parts.
	 * @param parts the parts that make up the virtual data block
	 * @throws IOException in I/O error
	 */
	VirtualDataBlock(Collection<? extends DataBlock> parts) throws IOException {
		setParts(parts);
	}
	/**
	 * Set the parts that make up the virtual data block.
	 * @param parts the data block parts
	 * @throws IOException on I/O error
	 */
	protected void setParts(Collection<? extends DataBlock> parts) throws IOException {
		this.parts = parts.toArray(DataBlock[]::new);
		this.offsets = new long[parts.size()];
		long size = 0;
		int i = 0;
		for (DataBlock part : parts) {
			this.offsets[i++] = size;
			size += part.size();
		}
		this.size = size;
	}
	@Override
	public long size() throws IOException {
		return this.size;
	}
	@Override
	public int read(ByteBuffer dst, long pos) throws IOException {
		if (pos < 0 || pos >= this.size) {
			return -1;
		}
		int lastReadPart = this.lastReadPart;
		int partIndex = 0;
		long offset = 0;
		int result = 0;
		if (pos >= this.offsets[lastReadPart]) {
			partIndex = lastReadPart;
			offset = this.offsets[lastReadPart];
		}
		while (partIndex < this.parts.length) {
			DataBlock part = this.parts[partIndex];
			while (pos >= offset && pos < offset + part.size()) {
				int count = part.read(dst, pos - offset);
				result += Math.max(count, 0);
				if (count <= 0 || !dst.hasRemaining()) {
					this.lastReadPart = partIndex;
					return result;
				}
				pos += count;
			}
			offset += part.size();
			partIndex++;
		}
		return result;
	}
}
/*
package org.springframework.boot.loader.zip;
/**
record ZipEndOfCentralDirectoryRecord(short numberOfThisDisk, short diskWhereCentralDirectoryStarts,
		short numberOfCentralDirectoryEntriesOnThisDisk, short totalNumberOfCentralDirectoryEntries,
		int sizeOfCentralDirectory, int offsetToStartOfCentralDirectory, short commentLength) {
	ZipEndOfCentralDirectoryRecord(short totalNumberOfCentralDirectoryEntries, int sizeOfCentralDirectory,
			int offsetToStartOfCentralDirectory) {
		this((short) 0, (short) 0, totalNumberOfCentralDirectoryEntries, totalNumberOfCentralDirectoryEntries,
				sizeOfCentralDirectory, offsetToStartOfCentralDirectory, (short) 0);
	}
	private static final DebugLogger debug = DebugLogger.get(ZipEndOfCentralDirectoryRecord.class);
	private static final int SIGNATURE = 0x06054b50;
	private static final int MAXIMUM_COMMENT_LENGTH = 0xFFFF;
	private static final int MINIMUM_SIZE = 22;
	private static final int MAXIMUM_SIZE = MINIMUM_SIZE + MAXIMUM_COMMENT_LENGTH;
	static final int BUFFER_SIZE = 256;
	/**
	 * The offset of the file comment relative to the record start position.
	 */
	static final int COMMENT_OFFSET = MINIMUM_SIZE;
	/**
	 * Return the size of this record.
	 * @return the record size
	 */
	long size() {
		return MINIMUM_SIZE + this.commentLength;
	}
	/**
	 * Return the contents of this record as a byte array suitable for writing to a zip.
	 * @return the record as a byte array
	 */
	byte[] asByteArray() {
		ByteBuffer buffer = ByteBuffer.allocate(MINIMUM_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		buffer.putInt(SIGNATURE);
		buffer.putShort(this.numberOfThisDisk);
		buffer.putShort(this.diskWhereCentralDirectoryStarts);
		buffer.putShort(this.numberOfCentralDirectoryEntriesOnThisDisk);
		buffer.putShort(this.totalNumberOfCentralDirectoryEntries);
		buffer.putInt(this.sizeOfCentralDirectory);
		buffer.putInt(this.offsetToStartOfCentralDirectory);
		buffer.putShort(this.commentLength);
		return buffer.array();
	}
	/**
	 * Create a new {@link ZipEndOfCentralDirectoryRecord} instance from the specified
	 * {@link DataBlock} by searching backwards from the end until a valid record is
	 * located.
	 * @param dataBlock the source data block
	 * @return the {@link Located located} {@link ZipEndOfCentralDirectoryRecord}
	 * @throws IOException if the {@link ZipEndOfCentralDirectoryRecord} cannot be read
	 */
	static Located load(DataBlock dataBlock) throws IOException {
		ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		long pos = locate(dataBlock, buffer);
		return new Located(pos, new ZipEndOfCentralDirectoryRecord(buffer.getShort(), buffer.getShort(),
				buffer.getShort(), buffer.getShort(), buffer.getInt(), buffer.getInt(), buffer.getShort()));
	}
	private static long locate(DataBlock dataBlock, ByteBuffer buffer) throws IOException {
		long endPos = dataBlock.size();
		debug.log('Finding EndOfCentralDirectoryRecord starting at end position %s', endPos);
		while (endPos > 0) {
			buffer.clear();
			long totalRead = dataBlock.size() - endPos;
			if (totalRead > MAXIMUM_SIZE) {
				throw new IOException(
						'Zip "End Of Central Directory Record" not found after reading ' + totalRead + ' bytes');
			}
			long startPos = endPos - buffer.limit();
			if (startPos < 0) {
				buffer.limit((int) startPos + buffer.limit());
				startPos = 0;
			}
			debug.log('Finding EndOfCentralDirectoryRecord from %s with limit %s', startPos, buffer.limit());
			dataBlock.readFully(buffer, startPos);
			int offset = findInBuffer(buffer);
			if (offset >= 0) {
				debug.log('Found EndOfCentralDirectoryRecord at %s + %s', startPos, offset);
				return startPos + offset;
			}
			endPos = endPos - BUFFER_SIZE + MINIMUM_SIZE;
		}
		throw new IOException('Zip "End Of Central Directory Record" not found after reading entire data block');
	}
	private static int findInBuffer(ByteBuffer buffer) {
		for (int pos = buffer.limit() - 4; pos >= 0; pos--) {
			buffer.position(pos);
			if (buffer.getInt() == SIGNATURE) {
				return pos;
			}
		}
		return -1;
	}
	/**
	 * A located {@link ZipEndOfCentralDirectoryRecord}.
	 *
	 * @param pos the position of the record
	 * @param endOfCentralDirectoryRecord the located end of central directory record
	 */
	record Located(long pos, ZipEndOfCentralDirectoryRecord endOfCentralDirectoryRecord) {
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class FileDataBlock implements CloseableDataBlock {
	private static final DebugLogger debug = DebugLogger.get(FileDataBlock.class);
	static Tracker tracker = Tracker.NONE;
	private final FileAccess fileAccess;
	private final long offset;
	private final long size;
	FileDataBlock(Path path) throws IOException {
		this.fileAccess = new FileAccess(path);
		this.offset = 0;
		this.size = Files.size(path);
	}
	FileDataBlock(FileAccess fileAccess, long offset, long size) {
		this.fileAccess = fileAccess;
		this.offset = offset;
		this.size = size;
	}
	@Override
	public long size() throws IOException {
		return this.size;
	}
	@Override
	public int read(ByteBuffer dst, long pos) throws IOException {
		if (pos < 0) {
			throw new IllegalArgumentException('Position must not be negative');
		}
		ensureOpen(ClosedChannelException::new);
		long remaining = this.size - pos;
		if (remaining <= 0) {
			return -1;
		}
		int originalDestinationLimit = -1;
		if (dst.remaining() > remaining) {
			originalDestinationLimit = dst.limit();
			long updatedLimit = dst.position() + remaining;
			dst.limit((updatedLimit > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) updatedLimit);
		}
		int result = this.fileAccess.read(dst, this.offset + pos);
		if (originalDestinationLimit != -1) {
			dst.limit(originalDestinationLimit);
		}
		return result;
	}
	/**
	 * Open a connection to this block, increasing the reference count and re-opening the
	 * underlying file channel if necessary.
	 * @throws IOException on I/O error
	 */
	void open() throws IOException {
		this.fileAccess.open();
	}
	/**
	 * Close a connection to this block, decreasing the reference count and closing the
	 * underlying file channel if necessary.
	 * @throws IOException on I/O error
	 */
	@Override
	public void close() throws IOException {
		this.fileAccess.close();
	}
	/**
	 * Ensure that the underlying file channel is currently open.
	 * @param exceptionSupplier a supplier providing the exception to throw
	 * @param <E> the exception type
	 * @throws E if the channel is closed
	 */
	<E extends Exception> void ensureOpen(Supplier<E> exceptionSupplier) throws E {
		this.fileAccess.ensureOpen(exceptionSupplier);
	}
	/**
	 * Return a new {@link FileDataBlock} slice providing access to a subset of the data.
	 * The caller is responsible for calling {@link #open()} and {@link #close()} on the
	 * returned block.
	 * @param offset the start offset for the slice relative to this block
	 * @return a new {@link FileDataBlock} instance
	 * @throws IOException on I/O error
	 */
	FileDataBlock slice(long offset) throws IOException {
		return slice(offset, this.size - offset);
	}
	/**
	 * Return a new {@link FileDataBlock} slice providing access to a subset of the data.
	 * The caller is responsible for calling {@link #open()} and {@link #close()} on the
	 * returned block.
	 * @param offset the start offset for the slice relative to this block
	 * @param size the size of the new slice
	 * @return a new {@link FileDataBlock} instance
	 */
	FileDataBlock slice(long offset, long size) {
		if (offset == 0 && size == this.size) {
			return this;
		}
		if (offset < 0) {
			throw new IllegalArgumentException('Offset must not be negative');
		}
		if (size < 0 || offset + size > this.size) {
			throw new IllegalArgumentException('Size must not be negative and must be within bounds');
		}
		debug.log('Slicing %s at %s with size %s', this.fileAccess, offset, size);
		return new FileDataBlock(this.fileAccess, this.offset + offset, size);
	}
	/**
	 * Manages access to underlying {@link FileChannel}.
	 */
	static class FileAccess {
		static final int BUFFER_SIZE = 1024 * 10;
		private final Path path;
		private int referenceCount;
		private FileChannel fileChannel;
		private boolean fileChannelInterrupted;
		private RandomAccessFile randomAccessFile;
		private ByteBuffer buffer;
		private long bufferPosition = -1;
		private int bufferSize;
		private final Object lock = new Object();
		FileAccess(Path path) {
			if (!Files.isRegularFile(path)) {
				throw new IllegalArgumentException(path + ' must be a regular file');
			}
			this.path = path;
		}
		int read(ByteBuffer dst, long position) throws IOException {
			synchronized (this.lock) {
				if (position < this.bufferPosition || position >= this.bufferPosition + this.bufferSize) {
					fillBuffer(position);
				}
				if (this.bufferSize <= 0) {
					return this.bufferSize;
				}
				int offset = (int) (position - this.bufferPosition);
				int length = Math.min(this.bufferSize - offset, dst.remaining());
				dst.put(dst.position(), this.buffer, offset, length);
				dst.position(dst.position() + length);
				return length;
			}
		}
		private void fillBuffer(long position) throws IOException {
			if (Thread.currentThread().isInterrupted()) {
				fillBufferUsingRandomAccessFile(position);
				return;
			}
			try {
				if (this.fileChannelInterrupted) {
					repairFileChannel();
					this.fileChannelInterrupted = false;
				}
				this.buffer.clear();
				this.bufferSize = this.fileChannel.read(this.buffer, position);
				this.bufferPosition = position;
			}
			catch (ClosedByInterruptException ex) {
				this.fileChannelInterrupted = true;
				fillBufferUsingRandomAccessFile(position);
			}
		}
		private void fillBufferUsingRandomAccessFile(long position) throws IOException {
			if (this.randomAccessFile == null) {
				this.randomAccessFile = new RandomAccessFile(this.path.toFile(), 'r');
				tracker.openedFileChannel(this.path);
			}
			byte[] bytes = new byte[BUFFER_SIZE];
			this.randomAccessFile.seek(position);
			int len = this.randomAccessFile.read(bytes);
			this.buffer.clear();
			if (len > 0) {
				this.buffer.put(bytes, 0, len);
			}
			this.bufferSize = len;
			this.bufferPosition = position;
		}
		private void repairFileChannel() throws IOException {
			tracker.closedFileChannel(this.path);
			this.fileChannel = FileChannel.open(this.path, StandardOpenOption.READ);
			tracker.openedFileChannel(this.path);
		}
		void open() throws IOException {
			synchronized (this.lock) {
				if (this.referenceCount == 0) {
					debug.log('Opening "%s"', this.path);
					this.fileChannel = FileChannel.open(this.path, StandardOpenOption.READ);
					this.buffer = ByteBuffer.allocateDirect(BUFFER_SIZE);
					tracker.openedFileChannel(this.path);
				}
				this.referenceCount++;
				debug.log('Reference count for "%s" incremented to %s', this.path, this.referenceCount);
			}
		}
		void close() throws IOException {
			synchronized (this.lock) {
				if (this.referenceCount == 0) {
					return;
				}
				this.referenceCount--;
				if (this.referenceCount == 0) {
					debug.log('Closing "%s"', this.path);
					this.buffer = null;
					this.bufferPosition = -1;
					this.bufferSize = 0;
					this.fileChannel.close();
					tracker.closedFileChannel(this.path);
					this.fileChannel = null;
					if (this.randomAccessFile != null) {
						this.randomAccessFile.close();
						tracker.closedFileChannel(this.path);
						this.randomAccessFile = null;
					}
				}
				debug.log('Reference count for "%s" decremented to %s', this.path, this.referenceCount);
			}
		}
		<E extends Exception> void ensureOpen(Supplier<E> exceptionSupplier) throws E {
			synchronized (this.lock) {
				if (this.referenceCount == 0) {
					throw exceptionSupplier.get();
				}
			}
		}
		@Override
		public String toString() {
			return this.path.toString();
		}
	}
	/**
	 * Internal tracker used to check open and closing of files in tests.
	 */
	interface Tracker {
		Tracker NONE = new Tracker() {
			@Override
			public void openedFileChannel(Path path) {
			}
			@Override
			public void closedFileChannel(Path path) {
			}
		};
		void openedFileChannel(Path path);
		void closedFileChannel(Path path);
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class VirtualZipDataBlock extends VirtualDataBlock implements CloseableDataBlock {
	private final CloseableDataBlock data;
	/**
	 * Create a new {@link VirtualZipDataBlock} for the given entries.
	 * @param data the source zip data
	 * @param nameOffsetLookups the name offsets to apply
	 * @param centralRecords the records that should be copied to the virtual zip
	 * @param centralRecordPositions the record positions in the data block.
	 * @throws IOException on I/O error
	 */
	VirtualZipDataBlock(CloseableDataBlock data, NameOffsetLookups nameOffsetLookups,
			ZipCentralDirectoryFileHeaderRecord[] centralRecords, long[] centralRecordPositions) throws IOException {
		this.data = data;
		List<DataBlock> parts = new ArrayList<>();
		List<DataBlock> centralParts = new ArrayList<>();
		long offset = 0;
		long sizeOfCentralDirectory = 0;
		for (int i = 0; i < centralRecords.length; i++) {
			ZipCentralDirectoryFileHeaderRecord centralRecord = centralRecords[i];
			int nameOffset = nameOffsetLookups.get(i);
			long centralRecordPos = centralRecordPositions[i];
			DataBlock name = new DataPart(
					centralRecordPos + ZipCentralDirectoryFileHeaderRecord.FILE_NAME_OFFSET + nameOffset,
					Short.toUnsignedLong(centralRecord.fileNameLength()) - nameOffset);
			long localRecordPos = Integer.toUnsignedLong(centralRecord.offsetToLocalHeader());
			ZipLocalFileHeaderRecord localRecord = ZipLocalFileHeaderRecord.load(this.data, localRecordPos);
			DataBlock content = new DataPart(localRecordPos + localRecord.size(), centralRecord.compressedSize());
			boolean hasDescriptorRecord = ZipDataDescriptorRecord.isPresentBasedOnFlag(centralRecord);
			ZipDataDescriptorRecord dataDescriptorRecord = (!hasDescriptorRecord) ? null
					: ZipDataDescriptorRecord.load(data, localRecordPos + localRecord.size() + content.size());
			sizeOfCentralDirectory += addToCentral(centralParts, centralRecord, centralRecordPos, name, (int) offset);
			offset += addToLocal(parts, centralRecord, localRecord, dataDescriptorRecord, name, content);
		}
		parts.addAll(centralParts);
		ZipEndOfCentralDirectoryRecord eocd = new ZipEndOfCentralDirectoryRecord((short) centralRecords.length,
				(int) sizeOfCentralDirectory, (int) offset);
		parts.add(new ByteArrayDataBlock(eocd.asByteArray()));
		setParts(parts);
	}
	private long addToCentral(List<DataBlock> parts, ZipCentralDirectoryFileHeaderRecord originalRecord,
			long originalRecordPos, DataBlock name, int offsetToLocalHeader) throws IOException {
		ZipCentralDirectoryFileHeaderRecord record = originalRecord.withFileNameLength((short) (name.size() & 0xFFFF))
			.withOffsetToLocalHeader(offsetToLocalHeader);
		int originalExtraFieldLength = Short.toUnsignedInt(originalRecord.extraFieldLength());
		int originalFileCommentLength = Short.toUnsignedInt(originalRecord.fileCommentLength());
		int extraFieldAndCommentSize = originalExtraFieldLength + originalFileCommentLength;
		parts.add(new ByteArrayDataBlock(record.asByteArray()));
		parts.add(name);
		if (extraFieldAndCommentSize > 0) {
			parts.add(new DataPart(originalRecordPos + originalRecord.size() - extraFieldAndCommentSize,
					extraFieldAndCommentSize));
		}
		return record.size();
	}
	private long addToLocal(List<DataBlock> parts, ZipCentralDirectoryFileHeaderRecord centralRecord,
			ZipLocalFileHeaderRecord originalRecord, ZipDataDescriptorRecord dataDescriptorRecord, DataBlock name,
			DataBlock content) throws IOException {
		ZipLocalFileHeaderRecord record = originalRecord.withFileNameLength((short) (name.size() & 0xFFFF));
		long originalRecordPos = Integer.toUnsignedLong(centralRecord.offsetToLocalHeader());
		int extraFieldLength = Short.toUnsignedInt(originalRecord.extraFieldLength());
		parts.add(new ByteArrayDataBlock(record.asByteArray()));
		parts.add(name);
		if (extraFieldLength > 0) {
			parts.add(new DataPart(originalRecordPos + originalRecord.size() - extraFieldLength, extraFieldLength));
		}
		parts.add(content);
		if (dataDescriptorRecord != null) {
			parts.add(new ByteArrayDataBlock(dataDescriptorRecord.asByteArray()));
		}
		return record.size() + content.size() + ((dataDescriptorRecord != null) ? dataDescriptorRecord.size() : 0);
	}
	@Override
	public void close() throws IOException {
		this.data.close();
	}
	/**
	 * {@link DataBlock} that points to part of the original data block.
	 */
	final class DataPart implements DataBlock {
		private final long offset;
		private final long size;
		DataPart(long offset, long size) {
			this.offset = offset;
			this.size = size;
		}
		@Override
		public long size() throws IOException {
			return this.size;
		}
		@Override
		public int read(ByteBuffer dst, long pos) throws IOException {
			int remaining = (int) (this.size - pos);
			if (remaining <= 0) {
				return -1;
			}
			int originalLimit = -1;
			if (dst.remaining() > remaining) {
				originalLimit = dst.limit();
				dst.limit(dst.position() + remaining);
			}
			int result = VirtualZipDataBlock.this.data.read(dst, this.offset + pos);
			if (originalLimit != -1) {
				dst.limit(originalLimit);
			}
			return result;
		}
	}
}
/*
package org.springframework.boot.loader.zip;
/**
record ZipCentralDirectoryFileHeaderRecord(short versionMadeBy, short versionNeededToExtract,
		short generalPurposeBitFlag, short compressionMethod, short lastModFileTime, short lastModFileDate, int crc32,
		int compressedSize, int uncompressedSize, short fileNameLength, short extraFieldLength, short fileCommentLength,
		short diskNumberStart, short internalFileAttributes, int externalFileAttributes, int offsetToLocalHeader) {
	private static final DebugLogger debug = DebugLogger.get(ZipCentralDirectoryFileHeaderRecord.class);
	private static final int SIGNATURE = 0x02014b50;
	private static final int MINIMUM_SIZE = 46;
	/**
	 * The offset of the file name relative to the record start position.
	 */
	static final int FILE_NAME_OFFSET = MINIMUM_SIZE;
	/**
	 * Return the size of this record.
	 * @return the record size
	 */
	long size() {
		return MINIMUM_SIZE + fileNameLength() + extraFieldLength() + fileCommentLength();
	}
	/**
	 * Copy values from this block to the given {@link ZipEntry}.
	 * @param dataBlock the source data block
	 * @param pos the position of this {@link ZipCentralDirectoryFileHeaderRecord}
	 * @param zipEntry the destination zip entry
	 * @throws IOException on I/O error
	 */
	void copyTo(DataBlock dataBlock, long pos, ZipEntry zipEntry) throws IOException {
		int fileNameLength = Short.toUnsignedInt(fileNameLength());
		int extraLength = Short.toUnsignedInt(extraFieldLength());
		int commentLength = Short.toUnsignedInt(fileCommentLength());
		zipEntry.setMethod(Short.toUnsignedInt(compressionMethod()));
		zipEntry.setTime(decodeMsDosFormatDateTime(lastModFileDate(), lastModFileTime()));
		zipEntry.setCrc(Integer.toUnsignedLong(crc32()));
		zipEntry.setCompressedSize(Integer.toUnsignedLong(compressedSize()));
		zipEntry.setSize(Integer.toUnsignedLong(uncompressedSize()));
		if (extraLength > 0) {
			long extraPos = pos + MINIMUM_SIZE + fileNameLength;
			ByteBuffer buffer = ByteBuffer.allocate(extraLength);
			dataBlock.readFully(buffer, extraPos);
			zipEntry.setExtra(buffer.array());
		}
		if (commentLength > 0) {
			long commentPos = pos + MINIMUM_SIZE + fileNameLength + extraLength;
			zipEntry.setComment(ZipString.readString(dataBlock, commentPos, commentLength));
		}
	}
	/**
	 * Decode MS-DOS Date Time details. See <a href=
	 * 'https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-dosdatetimetofiletime'>
	 * Microsoft"s documentation</a> for more details of the format.
	 * @param date the date
	 * @param time the time
	 * @return the date and time as milliseconds since the epoch
	 */
	private long decodeMsDosFormatDateTime(short date, short time) {
		int year = getChronoValue(((date >> 9) & 0x7f) + 1980, ChronoField.YEAR);
		int month = getChronoValue((date >> 5) & 0x0f, ChronoField.MONTH_OF_YEAR);
		int day = getChronoValue(date & 0x1f, ChronoField.DAY_OF_MONTH);
		int hour = getChronoValue((time >> 11) & 0x1f, ChronoField.HOUR_OF_DAY);
		int minute = getChronoValue((time >> 5) & 0x3f, ChronoField.MINUTE_OF_HOUR);
		int second = getChronoValue((time << 1) & 0x3e, ChronoField.SECOND_OF_MINUTE);
		return ZonedDateTime.of(year, month, day, hour, minute, second, 0, ZoneId.systemDefault())
			.toInstant()
			.truncatedTo(ChronoUnit.SECONDS)
			.toEpochMilli();
	}
	private static int getChronoValue(long value, ChronoField field) {
		ValueRange range = field.range();
		return Math.toIntExact(Math.min(Math.max(value, range.getMinimum()), range.getMaximum()));
	}
	/**
	 * Return a new {@link ZipCentralDirectoryFileHeaderRecord} with a new
	 * {@link #fileNameLength()}.
	 * @param fileNameLength the new file name length
	 * @return a new {@link ZipCentralDirectoryFileHeaderRecord} instance
	 */
	ZipCentralDirectoryFileHeaderRecord withFileNameLength(short fileNameLength) {
		return (this.fileNameLength != fileNameLength) ? new ZipCentralDirectoryFileHeaderRecord(this.versionMadeBy,
				this.versionNeededToExtract, this.generalPurposeBitFlag, this.compressionMethod, this.lastModFileTime,
				this.lastModFileDate, this.crc32, this.compressedSize, this.uncompressedSize, fileNameLength,
				this.extraFieldLength, this.fileCommentLength, this.diskNumberStart, this.internalFileAttributes,
				this.externalFileAttributes, this.offsetToLocalHeader) : this;
	}
	/**
	 * Return a new {@link ZipCentralDirectoryFileHeaderRecord} with a new
	 * {@link #offsetToLocalHeader()}.
	 * @param offsetToLocalHeader the new offset to local header
	 * @return a new {@link ZipCentralDirectoryFileHeaderRecord} instance
	 */
	ZipCentralDirectoryFileHeaderRecord withOffsetToLocalHeader(int offsetToLocalHeader) {
		return (this.offsetToLocalHeader != offsetToLocalHeader) ? new ZipCentralDirectoryFileHeaderRecord(
				this.versionMadeBy, this.versionNeededToExtract, this.generalPurposeBitFlag, this.compressionMethod,
				this.lastModFileTime, this.lastModFileDate, this.crc32, this.compressedSize, this.uncompressedSize,
				this.fileNameLength, this.extraFieldLength, this.fileCommentLength, this.diskNumberStart,
				this.internalFileAttributes, this.externalFileAttributes, offsetToLocalHeader) : this;
	}
	/**
	 * Return the contents of this record as a byte array suitable for writing to a zip.
	 * @return the record as a byte array
	 */
	byte[] asByteArray() {
		ByteBuffer buffer = ByteBuffer.allocate(MINIMUM_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		buffer.putInt(SIGNATURE);
		buffer.putShort(this.versionMadeBy);
		buffer.putShort(this.versionNeededToExtract);
		buffer.putShort(this.generalPurposeBitFlag);
		buffer.putShort(this.compressionMethod);
		buffer.putShort(this.lastModFileTime);
		buffer.putShort(this.lastModFileDate);
		buffer.putInt(this.crc32);
		buffer.putInt(this.compressedSize);
		buffer.putInt(this.uncompressedSize);
		buffer.putShort(this.fileNameLength);
		buffer.putShort(this.extraFieldLength);
		buffer.putShort(this.fileCommentLength);
		buffer.putShort(this.diskNumberStart);
		buffer.putShort(this.internalFileAttributes);
		buffer.putInt(this.externalFileAttributes);
		buffer.putInt(this.offsetToLocalHeader);
		return buffer.array();
	}
	/**
	 * Load the {@link ZipCentralDirectoryFileHeaderRecord} from the given data block.
	 * @param dataBlock the source data block
	 * @param pos the position of the record
	 * @return a new {@link ZipCentralDirectoryFileHeaderRecord} instance
	 * @throws IOException on I/O error
	 */
	static ZipCentralDirectoryFileHeaderRecord load(DataBlock dataBlock, long pos) throws IOException {
		debug.log('Loading CentralDirectoryFileHeaderRecord from position %s', pos);
		ByteBuffer buffer = ByteBuffer.allocate(MINIMUM_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		dataBlock.readFully(buffer, pos);
		buffer.rewind();
		int signature = buffer.getInt();
		if (signature != SIGNATURE) {
			debug.log('Found incorrect CentralDirectoryFileHeaderRecord signature %s at position %s', signature, pos);
			throw new IOException('Zip "Central Directory File Header Record" not found at position ' + pos);
		}
		return new ZipCentralDirectoryFileHeaderRecord(buffer.getShort(), buffer.getShort(), buffer.getShort(),
				buffer.getShort(), buffer.getShort(), buffer.getShort(), buffer.getInt(), buffer.getInt(),
				buffer.getInt(), buffer.getShort(), buffer.getShort(), buffer.getShort(), buffer.getShort(),
				buffer.getShort(), buffer.getInt(), buffer.getInt());
	}
}
/*
package org.springframework.boot.loader.zip;
/**
public interface CloseableDataBlock extends DataBlock, Closeable {
}
/*
/**
package org.springframework.boot.loader.zip;
/*
package org.springframework.boot.loader.zip;
/**
class NameOffsetLookups {
	public static final NameOffsetLookups NONE = new NameOffsetLookups(0, 0);
	private final int offset;
	private final BitSet enabled;
	NameOffsetLookups(int offset, int size) {
		this.offset = offset;
		this.enabled = (size != 0) ? new BitSet(size) : null;
	}
	void swap(int i, int j) {
		if (this.enabled != null) {
			boolean temp = this.enabled.get(i);
			this.enabled.set(i, this.enabled.get(j));
			this.enabled.set(j, temp);
		}
	}
	int get(int index) {
		return isEnabled(index) ? this.offset : 0;
	}
	int enable(int index, boolean enable) {
		if (this.enabled != null) {
			this.enabled.set(index, enable);
		}
		return (!enable) ? 0 : this.offset;
	}
	boolean isEnabled(int index) {
		return (this.enabled != null && this.enabled.get(index));
	}
	boolean hasAnyEnabled() {
		return this.enabled != null && this.enabled.cardinality() > 0;
	}
	NameOffsetLookups emptyCopy() {
		return new NameOffsetLookups(this.offset, this.enabled.size());
	}
}
/*
package org.springframework.boot.loader.zip;
/**
final class ZipString {
	private static final DebugLogger debug = DebugLogger.get(ZipString.class);
	static final int BUFFER_SIZE = 256;
	private static final int[] INITIAL_BYTE_BITMASK = { 0x7F, 0x1F, 0x0F, 0x07 };
	private static final int SUBSEQUENT_BYTE_BITMASK = 0x3F;
	private static final int EMPTY_HASH = ''.hashCode();
	private static final int EMPTY_SLASH_HASH = '/'.hashCode();
	private ZipString() {
	}
	/**
	 * Return a hash for a char sequence, optionally appending "/".
	 * @param charSequence the source char sequence
	 * @param addEndSlash if slash should be added to the string if it"s not already
	 * present
	 * @return the hash
	 */
	static int hash(CharSequence charSequence, boolean addEndSlash) {
		return hash(0, charSequence, addEndSlash);
	}
	/**
	 * Return a hash for a char sequence, optionally appending "/".
	 * @param initialHash the initial hash value
	 * @param charSequence the source char sequence
	 * @param addEndSlash if slash should be added to the string if it"s not already
	 * present
	 * @return the hash
	 */
	static int hash(int initialHash, CharSequence charSequence, boolean addEndSlash) {
		if (charSequence == null || charSequence.isEmpty()) {
			return (!addEndSlash) ? EMPTY_HASH : EMPTY_SLASH_HASH;
		}
		boolean endsWithSlash = charSequence.charAt(charSequence.length() - 1) == "/";
		int hash = initialHash;
		if (charSequence instanceof String && initialHash == 0) {
			// We"re compatible with String.hashCode and it might be already calculated
			hash = charSequence.hashCode();
		}
		else {
			for (int i = 0; i < charSequence.length(); i++) {
				char ch = charSequence.charAt(i);
				hash = 31 * hash + ch;
			}
		}
		hash = (addEndSlash && !endsWithSlash) ? 31 * hash + "/" : hash;
		debug.log('%s calculated for charsequence "%s" (addEndSlash=%s)', hash, charSequence, endsWithSlash);
		return hash;
	}
	/**
	 * Return a hash for bytes read from a {@link DataBlock}, optionally appending "/".
	 * @param buffer the buffer to use or {@code null}
	 * @param dataBlock the source data block
	 * @param pos the position in the data block where the string starts
	 * @param len the number of bytes to read from the block
	 * @param addEndSlash if slash should be added to the string if it"s not already
	 * present
	 * @return the hash
	 * @throws IOException on I/O error
	 */
	static int hash(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, boolean addEndSlash) throws IOException {
		if (len == 0) {
			return (!addEndSlash) ? EMPTY_HASH : EMPTY_SLASH_HASH;
		}
		buffer = (buffer != null) ? buffer : ByteBuffer.allocate(BUFFER_SIZE);
		byte[] bytes = buffer.array();
		int hash = 0;
		char lastChar = 0;
		int codePointSize = 1;
		while (len > 0) {
			int count = readInBuffer(dataBlock, pos, buffer, len, codePointSize);
			for (int byteIndex = 0; byteIndex < count;) {
				codePointSize = getCodePointSize(bytes, byteIndex);
				if (!hasEnoughBytes(byteIndex, codePointSize, count)) {
					break;
				}
				int codePoint = getCodePoint(bytes, byteIndex, codePointSize);
				if (codePoint <= 0xFFFF) {
					lastChar = (char) (codePoint & 0xFFFF);
					hash = 31 * hash + lastChar;
				}
				else {
					lastChar = 0;
					hash = 31 * hash + Character.highSurrogate(codePoint);
					hash = 31 * hash + Character.lowSurrogate(codePoint);
				}
				byteIndex += codePointSize;
				pos += codePointSize;
				len -= codePointSize;
				codePointSize = 1;
			}
		}
		hash = (addEndSlash && lastChar != "/") ? 31 * hash + "/" : hash;
		debug.log('%08X calculated for datablock position %s size %s (addEndSlash=%s)', hash, pos, len, addEndSlash);
		return hash;
	}
	/**
	 * Return if the bytes read from a {@link DataBlock} matches the give
	 * {@link CharSequence}.
	 * @param buffer the buffer to use or {@code null}
	 * @param dataBlock the source data block
	 * @param pos the position in the data block where the string starts
	 * @param len the number of bytes to read from the block
	 * @param charSequence the char sequence with which to compare
	 * @param addSlash also accept {@code charSequence + "/"} when it doesn"t already end
	 * with one
	 * @return true if the contents are considered equal
	 */
	static boolean matches(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, CharSequence charSequence,
			boolean addSlash) {
		if (charSequence.isEmpty()) {
			return true;
		}
		buffer = (buffer != null) ? buffer : ByteBuffer.allocate(BUFFER_SIZE);
		try {
			return compare(buffer, dataBlock, pos, len, charSequence,
					(!addSlash) ? CompareType.MATCHES : CompareType.MATCHES_ADDING_SLASH) != -1;
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	/**
	 * Returns if the bytes read from a {@link DataBlock} starts with the given
	 * {@link CharSequence}.
	 * @param buffer the buffer to use or {@code null}
	 * @param dataBlock the source data block
	 * @param pos the position in the data block where the string starts
	 * @param len the number of bytes to read from the block
	 * @param charSequence the required starting chars
	 * @return {@code -1} if the data block does not start with the char sequence, or a
	 * positive number indicating the number of bytes that contain the starting chars
	 */
	static int startsWith(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, CharSequence charSequence) {
		if (charSequence.isEmpty()) {
			return 0;
		}
		buffer = (buffer != null) ? buffer : ByteBuffer.allocate(BUFFER_SIZE);
		try {
			return compare(buffer, dataBlock, pos, len, charSequence, CompareType.STARTS_WITH);
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private static int compare(ByteBuffer buffer, DataBlock dataBlock, long pos, int len, CharSequence charSequence,
			CompareType compareType) throws IOException {
		if (charSequence.isEmpty()) {
			return 0;
		}
		boolean addSlash = compareType == CompareType.MATCHES_ADDING_SLASH && !endsWith(charSequence, "/");
		int charSequenceIndex = 0;
		int maxCharSequenceLength = (!addSlash) ? charSequence.length() : charSequence.length() + 1;
		int result = 0;
		byte[] bytes = buffer.array();
		int codePointSize = 1;
		while (len > 0) {
			int count = readInBuffer(dataBlock, pos, buffer, len, codePointSize);
			for (int byteIndex = 0; byteIndex < count;) {
				codePointSize = getCodePointSize(bytes, byteIndex);
				if (!hasEnoughBytes(byteIndex, codePointSize, count)) {
					break;
				}
				int codePoint = getCodePoint(bytes, byteIndex, codePointSize);
				if (codePoint <= 0xFFFF) {
					char ch = (char) (codePoint & 0xFFFF);
					if (charSequenceIndex >= maxCharSequenceLength
							|| getChar(charSequence, charSequenceIndex++) != ch) {
						return -1;
					}
				}
				else {
					char ch = Character.highSurrogate(codePoint);
					if (charSequenceIndex >= maxCharSequenceLength
							|| getChar(charSequence, charSequenceIndex++) != ch) {
						return -1;
					}
					ch = Character.lowSurrogate(codePoint);
					if (charSequenceIndex >= charSequence.length()
							|| getChar(charSequence, charSequenceIndex++) != ch) {
						return -1;
					}
				}
				byteIndex += codePointSize;
				pos += codePointSize;
				len -= codePointSize;
				result += codePointSize;
				codePointSize = 1;
				if (compareType == CompareType.STARTS_WITH && charSequenceIndex >= charSequence.length()) {
					return result;
				}
			}
		}
		return (charSequenceIndex >= charSequence.length()) ? result : -1;
	}
	private static boolean hasEnoughBytes(int byteIndex, int codePointSize, int count) {
		return (byteIndex + codePointSize - 1) < count;
	}
	private static boolean endsWith(CharSequence charSequence, char ch) {
		return !charSequence.isEmpty() && charSequence.charAt(charSequence.length() - 1) == ch;
	}
	private static char getChar(CharSequence charSequence, int index) {
		return (index != charSequence.length()) ? charSequence.charAt(index) : "/";
	}
	/**
	 * Read a string value from the given data block.
	 * @param data the source data
	 * @param pos the position to read from
	 * @param len the number of bytes to read
	 * @return the contents as a string
	 */
	static String readString(DataBlock data, long pos, long len) {
		try {
			if (len > Integer.MAX_VALUE) {
				throw new IllegalStateException('String is too long to read');
			}
			ByteBuffer buffer = ByteBuffer.allocate((int) len);
			buffer.order(ByteOrder.LITTLE_ENDIAN);
			data.readFully(buffer, pos);
			return new String(buffer.array(), StandardCharsets.UTF_8);
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private static int readInBuffer(DataBlock dataBlock, long pos, ByteBuffer buffer, int maxLen, int minLen)
			throws IOException {
		buffer.clear();
		if (buffer.remaining() > maxLen) {
			buffer.limit(maxLen);
		}
		int result = 0;
		while (result < minLen) {
			int count = dataBlock.read(buffer, pos);
			if (count <= 0) {
				throw new EOFException();
			}
			result += count;
			pos += count;
		}
		return result;
	}
	private static int getCodePointSize(byte[] bytes, int i) {
		int b = Byte.toUnsignedInt(bytes[i]);
		if ((b & 0b1_0000000) == 0b0_0000000) {
			return 1;
		}
		if ((b & 0b111_00000) == 0b110_00000) {
			return 2;
		}
		if ((b & 0b1111_0000) == 0b1110_0000) {
			return 3;
		}
		return 4;
	}
	private static int getCodePoint(byte[] bytes, int i, int codePointSize) {
		int codePoint = Byte.toUnsignedInt(bytes[i]);
		codePoint &= INITIAL_BYTE_BITMASK[codePointSize - 1];
		for (int j = 1; j < codePointSize; j++) {
			codePoint = (codePoint << 6) + (bytes[i + j] & SUBSEQUENT_BYTE_BITMASK);
		}
		return codePoint;
	}
	/**
	 * Supported compare types.
	 */
	private enum CompareType {
		MATCHES, MATCHES_ADDING_SLASH, STARTS_WITH
	}
}
/*
package org.springframework.boot.loader.zip;
/**
class ByteArrayDataBlock implements CloseableDataBlock {
	private final byte[] bytes;
	private final int maxReadSize;
	/**
	 * Create a new {@link ByteArrayDataBlock} backed by the given bytes.
	 * @param bytes the bytes to use
	 */
	ByteArrayDataBlock(byte... bytes) {
		this(bytes, -1);
	}
	ByteArrayDataBlock(byte[] bytes, int maxReadSize) {
		this.bytes = bytes;
		this.maxReadSize = maxReadSize;
	}
	@Override
	public long size() throws IOException {
		return this.bytes.length;
	}
	@Override
	public int read(ByteBuffer dst, long pos) throws IOException {
		return read(dst, (int) pos);
	}
	private int read(ByteBuffer dst, int pos) {
		int remaining = dst.remaining();
		int length = Math.min(this.bytes.length - pos, remaining);
		if (this.maxReadSize > 0 && length > this.maxReadSize) {
			length = this.maxReadSize;
		}
		dst.put(this.bytes, pos, length);
		return length;
	}
	@Override
	public void close() throws IOException {
	}
}
/*
package org.springframework.boot.loader.zip;
/**
record ZipDataDescriptorRecord(boolean includeSignature, int crc32, int compressedSize, int uncompressedSize) {
	private static final DebugLogger debug = DebugLogger.get(ZipDataDescriptorRecord.class);
	private static final int SIGNATURE = 0x08074b50;
	private static final int DATA_SIZE = 12;
	private static final int SIGNATURE_SIZE = 4;
	long size() {
		return (!includeSignature()) ? DATA_SIZE : DATA_SIZE + SIGNATURE_SIZE;
	}
	/**
	 * Return the contents of this record as a byte array suitable for writing to a zip.
	 * @return the record as a byte array
	 */
	byte[] asByteArray() {
		ByteBuffer buffer = ByteBuffer.allocate((int) size());
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		if (this.includeSignature) {
			buffer.putInt(SIGNATURE);
		}
		buffer.putInt(this.crc32);
		buffer.putInt(this.compressedSize);
		buffer.putInt(this.uncompressedSize);
		return buffer.array();
	}
	/**
	 * Load the {@link ZipDataDescriptorRecord} from the given data block.
	 * @param dataBlock the source data block
	 * @param pos the position of the record
	 * @return a new {@link ZipLocalFileHeaderRecord} instance
	 * @throws IOException on I/O error
	 */
	static ZipDataDescriptorRecord load(DataBlock dataBlock, long pos) throws IOException {
		debug.log('Loading ZipDataDescriptorRecord from position %s', pos);
		ByteBuffer buffer = ByteBuffer.allocate(SIGNATURE_SIZE + DATA_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		buffer.limit(SIGNATURE_SIZE);
		dataBlock.readFully(buffer, pos);
		buffer.rewind();
		int signatureOrCrc = buffer.getInt();
		boolean hasSignature = (signatureOrCrc == SIGNATURE);
		buffer.rewind();
		buffer.limit((!hasSignature) ? DATA_SIZE - SIGNATURE_SIZE : DATA_SIZE);
		dataBlock.readFully(buffer, pos + SIGNATURE_SIZE);
		buffer.rewind();
		return new ZipDataDescriptorRecord(hasSignature, (!hasSignature) ? signatureOrCrc : buffer.getInt(),
				buffer.getInt(), buffer.getInt());
	}
	/**
	 * Return if the {@link ZipDataDescriptorRecord} is present based on the general
	 * purpose bit flag in the given {@link ZipLocalFileHeaderRecord}.
	 * @param localRecord the local record to check
	 * @return if the bit flag is set
	 */
	static boolean isPresentBasedOnFlag(ZipLocalFileHeaderRecord localRecord) {
		return isPresentBasedOnFlag(localRecord.generalPurposeBitFlag());
	}
	/**
	 * Return if the {@link ZipDataDescriptorRecord} is present based on the general
	 * purpose bit flag in the given {@link ZipCentralDirectoryFileHeaderRecord}.
	 * @param centralRecord the central record to check
	 * @return if the bit flag is set
	 */
	static boolean isPresentBasedOnFlag(ZipCentralDirectoryFileHeaderRecord centralRecord) {
		return isPresentBasedOnFlag(centralRecord.generalPurposeBitFlag());
	}
	/**
	 * Return if the {@link ZipDataDescriptorRecord} is present based on the given general
	 * purpose bit flag.
	 * @param generalPurposeBitFlag the general purpose bit flag to check
	 * @return if the bit flag is set
	 */
	static boolean isPresentBasedOnFlag(int generalPurposeBitFlag) {
		return (generalPurposeBitFlag & 0b0000_1000) != 0;
	}
}
/*
package org.springframework.boot.loader.zip;
/**
record ZipLocalFileHeaderRecord(short versionNeededToExtract, short generalPurposeBitFlag, short compressionMethod,
		short lastModFileTime, short lastModFileDate, int crc32, int compressedSize, int uncompressedSize,
		short fileNameLength, short extraFieldLength) {
	private static final DebugLogger debug = DebugLogger.get(ZipLocalFileHeaderRecord.class);
	private static final int SIGNATURE = 0x04034b50;
	private static final int MINIMUM_SIZE = 30;
	/**
	 * Return the size of this record.
	 * @return the record size
	 */
	long size() {
		return MINIMUM_SIZE + fileNameLength() + extraFieldLength();
	}
	/**
	 * Return a new {@link ZipLocalFileHeaderRecord} with a new
	 * {@link #extraFieldLength()}.
	 * @param extraFieldLength the new extra field length
	 * @return a new {@link ZipLocalFileHeaderRecord} instance
	 */
	ZipLocalFileHeaderRecord withExtraFieldLength(short extraFieldLength) {
		return new ZipLocalFileHeaderRecord(this.versionNeededToExtract, this.generalPurposeBitFlag,
				this.compressionMethod, this.lastModFileTime, this.lastModFileDate, this.crc32, this.compressedSize,
				this.uncompressedSize, this.fileNameLength, extraFieldLength);
	}
	/**
	 * Return a new {@link ZipLocalFileHeaderRecord} with a new {@link #fileNameLength()}.
	 * @param fileNameLength the new file name length
	 * @return a new {@link ZipLocalFileHeaderRecord} instance
	 */
	ZipLocalFileHeaderRecord withFileNameLength(short fileNameLength) {
		return new ZipLocalFileHeaderRecord(this.versionNeededToExtract, this.generalPurposeBitFlag,
				this.compressionMethod, this.lastModFileTime, this.lastModFileDate, this.crc32, this.compressedSize,
				this.uncompressedSize, fileNameLength, this.extraFieldLength);
	}
	/**
	 * Return the contents of this record as a byte array suitable for writing to a zip.
	 * @return the record as a byte array
	 */
	byte[] asByteArray() {
		ByteBuffer buffer = ByteBuffer.allocate(MINIMUM_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		buffer.putInt(SIGNATURE);
		buffer.putShort(this.versionNeededToExtract);
		buffer.putShort(this.generalPurposeBitFlag);
		buffer.putShort(this.compressionMethod);
		buffer.putShort(this.lastModFileTime);
		buffer.putShort(this.lastModFileDate);
		buffer.putInt(this.crc32);
		buffer.putInt(this.compressedSize);
		buffer.putInt(this.uncompressedSize);
		buffer.putShort(this.fileNameLength);
		buffer.putShort(this.extraFieldLength);
		return buffer.array();
	}
	/**
	 * Load the {@link ZipLocalFileHeaderRecord} from the given data block.
	 * @param dataBlock the source data block
	 * @param pos the position of the record
	 * @return a new {@link ZipLocalFileHeaderRecord} instance
	 * @throws IOException on I/O error
	 */
	static ZipLocalFileHeaderRecord load(DataBlock dataBlock, long pos) throws IOException {
		debug.log('Loading LocalFileHeaderRecord from position %s', pos);
		ByteBuffer buffer = ByteBuffer.allocate(MINIMUM_SIZE);
		buffer.order(ByteOrder.LITTLE_ENDIAN);
		dataBlock.readFully(buffer, pos);
		buffer.rewind();
		if (buffer.getInt() != SIGNATURE) {
			throw new IOException('Zip "Local File Header Record" not found at position ' + pos);
		}
		return new ZipLocalFileHeaderRecord(buffer.getShort(), buffer.getShort(), buffer.getShort(), buffer.getShort(),
				buffer.getShort(), buffer.getInt(), buffer.getInt(), buffer.getInt(), buffer.getShort(),
				buffer.getShort());
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class ZipInflaterInputStream extends InflaterInputStream {
	private int available;
	private boolean extraBytesWritten;
	ZipInflaterInputStream(InputStream inputStream, Inflater inflater, int size) {
		super(inputStream, inflater, getInflaterBufferSize(size));
		this.available = size;
	}
	private static int getInflaterBufferSize(long size) {
		size += 2; // inflater likes some space
		size = (size > 65536) ? 8192 : size;
		size = (size <= 0) ? 4096 : size;
		return (int) size;
	}
	@Override
	public int available() throws IOException {
		return (this.available >= 0) ? this.available : super.available();
	}
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		int result = super.read(b, off, len);
		if (result != -1) {
			this.available -= result;
		}
		return result;
	}
	@Override
	protected void fill() throws IOException {
		try {
			super.fill();
		}
		catch (EOFException ex) {
			if (this.extraBytesWritten) {
				throw ex;
			}
			this.len = 1;
			this.buf[0] = 0x0;
			this.extraBytesWritten = true;
			this.inf.setInput(this.buf, 0, this.len);
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
public class NestedJarFile extends JarFile {
	private static final int DECIMAL = 10;
	private static final String META_INF = 'META-INF/';
	static final String META_INF_VERSIONS = META_INF + 'versions/';
	static final int BASE_VERSION = baseVersion().feature();
	private static final DebugLogger debug = DebugLogger.get(NestedJarFile.class);
	private final Cleaner cleaner;
	private final NestedJarFileResources resources;
	private final Cleanable cleanup;
	private final String name;
	private final int version;
	private volatile NestedJarEntry lastEntry;
	private volatile boolean closed;
	private volatile ManifestInfo manifestInfo;
	private volatile MetaInfVersionsInfo metaInfVersionsInfo;
	/**
	 * Creates a new {@link NestedJarFile} instance to read from the specific
	 * {@code File}.
	 * @param file the jar file to be opened for reading
	 * @throws IOException on I/O error
	 */
	NestedJarFile(File file) throws IOException {
		this(file, null, null, false, Cleaner.instance);
	}
	/**
	 * Creates a new {@link NestedJarFile} instance to read from the specific
	 * {@code File}.
	 * @param file the jar file to be opened for reading
	 * @param nestedEntryName the nested entry name to open
	 * @throws IOException on I/O error
	 * @throws IllegalArgumentException if {@code nestedEntryName} is {@code null} or
	 * empty
	 */
	public NestedJarFile(File file, String nestedEntryName) throws IOException {
		this(file, nestedEntryName, null, true, Cleaner.instance);
	}
	/**
	 * Creates a new {@link NestedJarFile} instance to read from the specific
	 * {@code File}.
	 * @param file the jar file to be opened for reading
	 * @param nestedEntryName the nested entry name to open
	 * @param version the release version to use when opening a multi-release jar
	 * @throws IOException on I/O error
	 * @throws IllegalArgumentException if {@code nestedEntryName} is {@code null} or
	 * empty
	 */
	public NestedJarFile(File file, String nestedEntryName, Runtime.Version version) throws IOException {
		this(file, nestedEntryName, version, true, Cleaner.instance);
	}
	/**
	 * Creates a new {@link NestedJarFile} instance to read from the specific
	 * {@code File}.
	 * @param file the jar file to be opened for reading
	 * @param nestedEntryName the nested entry name to open
	 * @param version the release version to use when opening a multi-release jar
	 * @param onlyNestedJars if <em>only</em> nested jars should be opened
	 * @param cleaner the cleaner used to release resources
	 * @throws IOException on I/O error
	 * @throws IllegalArgumentException if {@code nestedEntryName} is {@code null} or
	 * empty
	 */
	NestedJarFile(File file, String nestedEntryName, Runtime.Version version, boolean onlyNestedJars, Cleaner cleaner)
			throws IOException {
		super(file);
		if (onlyNestedJars && (nestedEntryName == null || nestedEntryName.isEmpty())) {
			throw new IllegalArgumentException('nestedEntryName must not be empty');
		}
		debug.log('Created nested jar file (%s, %s, %s)', file, nestedEntryName, version);
		this.cleaner = cleaner;
		this.resources = new NestedJarFileResources(file, nestedEntryName);
		this.cleanup = cleaner.register(this, this.resources);
		this.name = file.getPath() + ((nestedEntryName != null) ? '!/' + nestedEntryName : '');
		this.version = (version != null) ? version.feature() : baseVersion().feature();
	}
	public InputStream getRawZipDataInputStream() throws IOException {
		RawZipDataInputStream inputStream = new RawZipDataInputStream(
				this.resources.zipContent().openRawZipData().asInputStream());
		this.resources.addInputStream(inputStream);
		return inputStream;
	}
	@Override
	public Manifest getManifest() throws IOException {
		try {
			return this.resources.zipContentForManifest()
				.getInfo(ManifestInfo.class, this::getManifestInfo)
				.getManifest();
		}
		catch (UncheckedIOException ex) {
			throw ex.getCause();
		}
	}
	@Override
	public Enumeration<JarEntry> entries() {
		synchronized (this) {
			ensureOpen();
			return new JarEntriesEnumeration(this.resources.zipContent());
		}
	}
	@Override
	public Stream<JarEntry> stream() {
		synchronized (this) {
			ensureOpen();
			return streamContentEntries().map(NestedJarEntry::new);
		}
	}
	@Override
	public Stream<JarEntry> versionedStream() {
		synchronized (this) {
			ensureOpen();
			return streamContentEntries().map(this::getBaseName)
				.filter(Objects::nonNull)
				.distinct()
				.map(this::getJarEntry)
				.filter(Objects::nonNull);
		}
	}
	private Stream<ZipContent.Entry> streamContentEntries() {
		ZipContentEntriesSpliterator spliterator = new ZipContentEntriesSpliterator(this.resources.zipContent());
		return StreamSupport.stream(spliterator, false);
	}
	private String getBaseName(ZipContent.Entry contentEntry) {
		String name = contentEntry.getName();
		if (!name.startsWith(META_INF_VERSIONS)) {
			return name;
		}
		int versionNumberStartIndex = META_INF_VERSIONS.length();
		int versionNumberEndIndex = (versionNumberStartIndex != -1) ? name.indexOf("/", versionNumberStartIndex) : -1;
		if (versionNumberEndIndex == -1 || versionNumberEndIndex == (name.length() - 1)) {
			return null;
		}
		try {
			int versionNumber = Integer.parseInt(name, versionNumberStartIndex, versionNumberEndIndex, DECIMAL);
			if (versionNumber > this.version) {
				return null;
			}
		}
		catch (NumberFormatException ex) {
			return null;
		}
		return name.substring(versionNumberEndIndex + 1);
	}
	@Override
	public JarEntry getJarEntry(String name) {
		return getNestedJarEntry(name);
	}
	@Override
	public JarEntry getEntry(String name) {
		return getNestedJarEntry(name);
	}
	/**
	 * Return if an entry with the given name exists.
	 * @param name the name to check
	 * @return if the entry exists
	 */
	public boolean hasEntry(String name) {
		NestedJarEntry lastEntry = this.lastEntry;
		if (lastEntry != null && name.equals(lastEntry.getName())) {
			return true;
		}
		ZipContent.Entry entry = getVersionedContentEntry(name);
		if (entry != null) {
			return true;
		}
		synchronized (this) {
			ensureOpen();
			return this.resources.zipContent().hasEntry(null, name);
		}
	}
	private NestedJarEntry getNestedJarEntry(String name) {
		Objects.requireNonNull(name, 'name');
		NestedJarEntry lastEntry = this.lastEntry;
		if (lastEntry != null && name.equals(lastEntry.getName())) {
			return lastEntry;
		}
		ZipContent.Entry entry = getVersionedContentEntry(name);
		entry = (entry != null) ? entry : getContentEntry(null, name);
		if (entry == null) {
			return null;
		}
		NestedJarEntry nestedJarEntry = new NestedJarEntry(entry, name);
		this.lastEntry = nestedJarEntry;
		return nestedJarEntry;
	}
	private ZipContent.Entry getVersionedContentEntry(String name) {
		// NOTE: we can"t call isMultiRelease() directly because it"s a final method and
		// it inspects the container jar. We use ManifestInfo instead.
		if (BASE_VERSION >= this.version || name.startsWith(META_INF) || !getManifestInfo().isMultiRelease()) {
			return null;
		}
		MetaInfVersionsInfo metaInfVersionsInfo = getMetaInfVersionsInfo();
		int[] versions = metaInfVersionsInfo.versions();
		String[] directories = metaInfVersionsInfo.directories();
		for (int i = versions.length - 1; i >= 0; i--) {
			if (versions[i] <= this.version) {
				ZipContent.Entry entry = getContentEntry(directories[i], name);
				if (entry != null) {
					return entry;
				}
			}
		}
		return null;
	}
	private ZipContent.Entry getContentEntry(String namePrefix, String name) {
		synchronized (this) {
			ensureOpen();
			return this.resources.zipContent().getEntry(namePrefix, name);
		}
	}
	private ManifestInfo getManifestInfo() {
		ManifestInfo manifestInfo = this.manifestInfo;
		if (manifestInfo != null) {
			return manifestInfo;
		}
		synchronized (this) {
			ensureOpen();
			manifestInfo = this.resources.zipContent().getInfo(ManifestInfo.class, this::getManifestInfo);
		}
		this.manifestInfo = manifestInfo;
		return manifestInfo;
	}
	private ManifestInfo getManifestInfo(ZipContent zipContent) {
		ZipContent.Entry contentEntry = zipContent.getEntry(MANIFEST_NAME);
		if (contentEntry == null) {
			return ManifestInfo.NONE;
		}
		try {
			try (InputStream inputStream = getInputStream(contentEntry)) {
				Manifest manifest = new Manifest(inputStream);
				return new ManifestInfo(manifest);
			}
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	private MetaInfVersionsInfo getMetaInfVersionsInfo() {
		MetaInfVersionsInfo metaInfVersionsInfo = this.metaInfVersionsInfo;
		if (metaInfVersionsInfo != null) {
			return metaInfVersionsInfo;
		}
		synchronized (this) {
			ensureOpen();
			metaInfVersionsInfo = this.resources.zipContent()
				.getInfo(MetaInfVersionsInfo.class, MetaInfVersionsInfo::get);
		}
		this.metaInfVersionsInfo = metaInfVersionsInfo;
		return metaInfVersionsInfo;
	}
	@Override
	public InputStream getInputStream(ZipEntry entry) throws IOException {
		Objects.requireNonNull(entry, 'entry');
		if (entry instanceof NestedJarEntry nestedJarEntry && nestedJarEntry.isOwnedBy(this)) {
			return getInputStream(nestedJarEntry.contentEntry());
		}
		return getInputStream(getNestedJarEntry(entry.getName()).contentEntry());
	}
	private InputStream getInputStream(ZipContent.Entry contentEntry) throws IOException {
		int compression = contentEntry.getCompressionMethod();
		if (compression != ZipEntry.STORED && compression != ZipEntry.DEFLATED) {
			throw new ZipException('invalid compression method');
		}
		synchronized (this) {
			ensureOpen();
			InputStream inputStream = new JarEntryInputStream(contentEntry);
			try {
				if (compression == ZipEntry.DEFLATED) {
					inputStream = new JarEntryInflaterInputStream((JarEntryInputStream) inputStream, this.resources);
				}
				this.resources.addInputStream(inputStream);
				return inputStream;
			}
			catch (RuntimeException ex) {
				inputStream.close();
				throw ex;
			}
		}
	}
	@Override
	public String getComment() {
		synchronized (this) {
			ensureOpen();
			return this.resources.zipContent().getComment();
		}
	}
	@Override
	public int size() {
		synchronized (this) {
			ensureOpen();
			return this.resources.zipContent().size();
		}
	}
	@Override
	public void close() throws IOException {
		super.close();
		if (this.closed) {
			return;
		}
		this.closed = true;
		synchronized (this) {
			try {
				this.cleanup.clean();
			}
			catch (UncheckedIOException ex) {
				throw ex.getCause();
			}
		}
	}
	@Override
	public String getName() {
		return this.name;
	}
	private void ensureOpen() {
		if (this.closed) {
			throw new IllegalStateException('Zip file closed');
		}
		if (this.resources.zipContent() == null) {
			throw new IllegalStateException('The object is not initialized.');
		}
	}
	/**
	 * Clear any internal caches.
	 */
	public void clearCache() {
		synchronized (this) {
			this.lastEntry = null;
		}
	}
	/**
	 * An individual entry from a {@link NestedJarFile}.
	 */
	private class NestedJarEntry extends java.util.jar.JarEntry {
		private static final IllegalStateException CANNOT_BE_MODIFIED_EXCEPTION = new IllegalStateException(
				'Neste jar entries cannot be modified');
		private final ZipContent.Entry contentEntry;
		private final String name;
		private volatile boolean populated;
		NestedJarEntry(Entry contentEntry) {
			this(contentEntry, contentEntry.getName());
		}
		NestedJarEntry(ZipContent.Entry contentEntry, String name) {
			super(contentEntry.getName());
			this.contentEntry = contentEntry;
			this.name = name;
		}
		@Override
		public long getTime() {
			populate();
			return super.getTime();
		}
		@Override
		public LocalDateTime getTimeLocal() {
			populate();
			return super.getTimeLocal();
		}
		@Override
		public void setTime(long time) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public void setTimeLocal(LocalDateTime time) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public FileTime getLastModifiedTime() {
			populate();
			return super.getLastModifiedTime();
		}
		@Override
		public ZipEntry setLastModifiedTime(FileTime time) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public FileTime getLastAccessTime() {
			populate();
			return super.getLastAccessTime();
		}
		@Override
		public ZipEntry setLastAccessTime(FileTime time) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public FileTime getCreationTime() {
			populate();
			return super.getCreationTime();
		}
		@Override
		public ZipEntry setCreationTime(FileTime time) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public long getSize() {
			return this.contentEntry.getUncompressedSize() & 0xFFFFFFFFL;
		}
		@Override
		public void setSize(long size) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public long getCompressedSize() {
			populate();
			return super.getCompressedSize();
		}
		@Override
		public void setCompressedSize(long csize) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public long getCrc() {
			populate();
			return super.getCrc();
		}
		@Override
		public void setCrc(long crc) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public int getMethod() {
			populate();
			return super.getMethod();
		}
		@Override
		public void setMethod(int method) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public byte[] getExtra() {
			populate();
			return super.getExtra();
		}
		@Override
		public void setExtra(byte[] extra) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		@Override
		public String getComment() {
			populate();
			return super.getComment();
		}
		@Override
		public void setComment(String comment) {
			throw CANNOT_BE_MODIFIED_EXCEPTION;
		}
		boolean isOwnedBy(NestedJarFile nestedJarFile) {
			return NestedJarFile.this == nestedJarFile;
		}
		@Override
		public String getRealName() {
			return super.getName();
		}
		@Override
		public String getName() {
			return this.name;
		}
		@Override
		public Attributes getAttributes() throws IOException {
			Manifest manifest = getManifest();
			return (manifest != null) ? manifest.getAttributes(getName()) : null;
		}
		@Override
		public Certificate[] getCertificates() {
			return getSecurityInfo().getCertificates(contentEntry());
		}
		@Override
		public CodeSigner[] getCodeSigners() {
			return getSecurityInfo().getCodeSigners(contentEntry());
		}
		private SecurityInfo getSecurityInfo() {
			return NestedJarFile.this.resources.zipContent().getInfo(SecurityInfo.class, SecurityInfo::get);
		}
		ZipContent.Entry contentEntry() {
			return this.contentEntry;
		}
		private void populate() {
			boolean populated = this.populated;
			if (!populated) {
				ZipEntry entry = this.contentEntry.as(ZipEntry::new);
				super.setMethod(entry.getMethod());
				super.setTime(entry.getTime());
				super.setCrc(entry.getCrc());
				super.setCompressedSize(entry.getCompressedSize());
				super.setSize(entry.getSize());
				super.setExtra(entry.getExtra());
				super.setComment(entry.getComment());
				this.populated = true;
			}
		}
	}
	/**
	 * {@link Enumeration} of {@link NestedJarEntry} instances.
	 */
	private class JarEntriesEnumeration implements Enumeration<JarEntry> {
		private final ZipContent zipContent;
		private int cursor;
		JarEntriesEnumeration(ZipContent zipContent) {
			this.zipContent = zipContent;
		}
		@Override
		public boolean hasMoreElements() {
			return this.cursor < this.zipContent.size();
		}
		@Override
		public NestedJarEntry nextElement() {
			if (!hasMoreElements()) {
				throw new NoSuchElementException();
			}
			synchronized (NestedJarFile.this) {
				ensureOpen();
				return new NestedJarEntry(this.zipContent.getEntry(this.cursor++));
			}
		}
	}
	/**
	 * {@link Spliterator} for {@link ZipContent.Entry} instances.
	 */
	private class ZipContentEntriesSpliterator extends AbstractSpliterator<ZipContent.Entry> {
		private static final int ADDITIONAL_CHARACTERISTICS = Spliterator.ORDERED | Spliterator.DISTINCT
				| Spliterator.IMMUTABLE | Spliterator.NONNULL;
		private final ZipContent zipContent;
		private int cursor;
		ZipContentEntriesSpliterator(ZipContent zipContent) {
			super(zipContent.size(), ADDITIONAL_CHARACTERISTICS);
			this.zipContent = zipContent;
		}
		@Override
		public boolean tryAdvance(Consumer<? super ZipContent.Entry> action) {
			if (this.cursor < this.zipContent.size()) {
				synchronized (NestedJarFile.this) {
					ensureOpen();
					action.accept(this.zipContent.getEntry(this.cursor++));
				}
				return true;
			}
			return false;
		}
	}
	/**
	 * {@link InputStream} to read jar entry content.
	 */
	private class JarEntryInputStream extends InputStream {
		private final int uncompressedSize;
		private final CloseableDataBlock content;
		private long pos;
		private long remaining;
		private volatile boolean closed;
		JarEntryInputStream(ZipContent.Entry entry) throws IOException {
			this.uncompressedSize = entry.getUncompressedSize();
			this.content = entry.openContent();
		}
		@Override
		public int read() throws IOException {
			byte[] b = new byte[1];
			return (read(b, 0, 1) == 1) ? b[0] & 0xFF : -1;
		}
		@Override
		public int read(byte[] b, int off, int len) throws IOException {
			int result;
			synchronized (NestedJarFile.this) {
				ensureOpen();
				ByteBuffer dst = ByteBuffer.wrap(b, off, len);
				int count = this.content.read(dst, this.pos);
				if (count > 0) {
					this.pos += count;
					this.remaining -= count;
				}
				result = count;
			}
			if (this.remaining == 0) {
				close();
			}
			return result;
		}
		@Override
		public long skip(long n) throws IOException {
			long result;
			synchronized (NestedJarFile.this) {
				result = (n > 0) ? maxForwardSkip(n) : maxBackwardSkip(n);
				this.pos += result;
				this.remaining -= result;
			}
			if (this.remaining == 0) {
				close();
			}
			return result;
		}
		private long maxForwardSkip(long n) {
			boolean willCauseOverflow = (this.pos + n) < 0;
			return (willCauseOverflow || n > this.remaining) ? this.remaining : n;
		}
		private long maxBackwardSkip(long n) {
			return Math.max(-this.pos, n);
		}
		@Override
		public int available() {
			return (this.remaining < Integer.MAX_VALUE) ? (int) this.remaining : Integer.MAX_VALUE;
		}
		private void ensureOpen() throws ZipException {
			if (NestedJarFile.this.closed || this.closed) {
				throw new ZipException('ZipFile closed');
			}
		}
		@Override
		public void close() throws IOException {
			if (this.closed) {
				return;
			}
			this.closed = true;
			this.content.close();
			NestedJarFile.this.resources.removeInputStream(this);
		}
		int getUncompressedSize() {
			return this.uncompressedSize;
		}
	}
	/**
	 * {@link ZipInflaterInputStream} to read and inflate jar entry content.
	 */
	private class JarEntryInflaterInputStream extends ZipInflaterInputStream {
		private final Cleanable cleanup;
		private volatile boolean closed;
		JarEntryInflaterInputStream(JarEntryInputStream inputStream, NestedJarFileResources resources) {
			this(inputStream, resources, resources.getOrCreateInflater());
		}
		private JarEntryInflaterInputStream(JarEntryInputStream inputStream, NestedJarFileResources resources,
				Inflater inflater) {
			super(inputStream, inflater, inputStream.getUncompressedSize());
			this.cleanup = NestedJarFile.this.cleaner.register(this, resources.createInflatorCleanupAction(inflater));
		}
		@Override
		public void close() throws IOException {
			if (this.closed) {
				return;
			}
			this.closed = true;
			super.close();
			NestedJarFile.this.resources.removeInputStream(this);
			this.cleanup.clean();
		}
	}
	/**
	 * {@link InputStream} for raw zip data.
	 */
	private class RawZipDataInputStream extends FilterInputStream {
		private volatile boolean closed;
		RawZipDataInputStream(InputStream in) {
			super(in);
		}
		@Override
		public void close() throws IOException {
			if (this.closed) {
				return;
			}
			this.closed = true;
			super.close();
			NestedJarFile.this.resources.removeInputStream(this);
		}
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class NestedJarFileResources implements Runnable {
	private static final int INFLATER_CACHE_LIMIT = 20;
	private ZipContent zipContent;
	private ZipContent zipContentForManifest;
	private final Set<InputStream> inputStreams = Collections.newSetFromMap(new WeakHashMap<>());
	private Deque<Inflater> inflaterCache = new ArrayDeque<>();
	/**
	 * Create a new {@link NestedJarFileResources} instance.
	 * @param file the source zip file
	 * @param nestedEntryName the nested entry or {@code null}
	 * @throws IOException on I/O error
	 */
	NestedJarFileResources(File file, String nestedEntryName) throws IOException {
		this.zipContent = ZipContent.open(file.toPath(), nestedEntryName);
		this.zipContentForManifest = (this.zipContent.getKind() != Kind.NESTED_DIRECTORY) ? null
				: ZipContent.open(file.toPath());
	}
	/**
	 * Return the underling {@link ZipContent}.
	 * @return the zip content
	 */
	ZipContent zipContent() {
		return this.zipContent;
	}
	/**
	 * Return the underlying {@link ZipContent} that should be used to load manifest
	 * content.
	 * @return the zip content to use when loading the manifest
	 */
	ZipContent zipContentForManifest() {
		return (this.zipContentForManifest != null) ? this.zipContentForManifest : this.zipContent;
	}
	/**
	 * Add a managed input stream resource.
	 * @param inputStream the input stream
	 */
	void addInputStream(InputStream inputStream) {
		synchronized (this.inputStreams) {
			this.inputStreams.add(inputStream);
		}
	}
	/**
	 * Remove a managed input stream resource.
	 * @param inputStream the input stream
	 */
	void removeInputStream(InputStream inputStream) {
		synchronized (this.inputStreams) {
			this.inputStreams.remove(inputStream);
		}
	}
	/**
	 * Create a {@link Runnable} action to cleanup the given inflater.
	 * @param inflater the inflater to cleanup
	 * @return the cleanup action
	 */
	Runnable createInflatorCleanupAction(Inflater inflater) {
		return () -> endOrCacheInflater(inflater);
	}
	/**
	 * Get previously used {@link Inflater} from the cache, or create a new one.
	 * @return a usable {@link Inflater}
	 */
	Inflater getOrCreateInflater() {
		Deque<Inflater> inflaterCache = this.inflaterCache;
		if (inflaterCache != null) {
			synchronized (inflaterCache) {
				Inflater inflater = this.inflaterCache.poll();
				if (inflater != null) {
					return inflater;
				}
			}
		}
		return new Inflater(true);
	}
	/**
	 * Either release the given {@link Inflater} by calling {@link Inflater#end()} or add
	 * it to the cache for later reuse.
	 * @param inflater the inflater to end or cache
	 */
	private void endOrCacheInflater(Inflater inflater) {
		Deque<Inflater> inflaterCache = this.inflaterCache;
		if (inflaterCache != null) {
			synchronized (inflaterCache) {
				if (this.inflaterCache == inflaterCache && inflaterCache.size() < INFLATER_CACHE_LIMIT) {
					inflater.reset();
					this.inflaterCache.add(inflater);
					return;
				}
			}
		}
		inflater.end();
	}
	/**
	 * Called by the {@link Cleaner} to free resources.
	 * @see java.lang.Runnable#run()
	 */
	@Override
	public void run() {
		releaseAll();
	}
	private void releaseAll() {
		IOException exceptionChain = null;
		exceptionChain = releaseInflators(exceptionChain);
		exceptionChain = releaseInputStreams(exceptionChain);
		exceptionChain = releaseZipContent(exceptionChain);
		exceptionChain = releaseZipContentForManifest(exceptionChain);
		if (exceptionChain != null) {
			throw new UncheckedIOException(exceptionChain);
		}
	}
	private IOException releaseInflators(IOException exceptionChain) {
		Deque<Inflater> inflaterCache = this.inflaterCache;
		if (inflaterCache != null) {
			try {
				synchronized (inflaterCache) {
					inflaterCache.forEach(Inflater::end);
				}
			}
			finally {
				this.inflaterCache = null;
			}
		}
		return exceptionChain;
	}
	private IOException releaseInputStreams(IOException exceptionChain) {
		synchronized (this.inputStreams) {
			for (InputStream inputStream : List.copyOf(this.inputStreams)) {
				try {
					inputStream.close();
				}
				catch (IOException ex) {
					exceptionChain = addToExceptionChain(exceptionChain, ex);
				}
			}
			this.inputStreams.clear();
		}
		return exceptionChain;
	}
	private IOException releaseZipContent(IOException exceptionChain) {
		ZipContent zipContent = this.zipContent;
		if (zipContent != null) {
			try {
				zipContent.close();
			}
			catch (IOException ex) {
				exceptionChain = addToExceptionChain(exceptionChain, ex);
			}
			finally {
				this.zipContent = null;
			}
		}
		return exceptionChain;
	}
	private IOException releaseZipContentForManifest(IOException exceptionChain) {
		ZipContent zipContentForManifest = this.zipContentForManifest;
		if (zipContentForManifest != null) {
			try {
				zipContentForManifest.close();
			}
			catch (IOException ex) {
				exceptionChain = addToExceptionChain(exceptionChain, ex);
			}
			finally {
				this.zipContentForManifest = null;
			}
		}
		return exceptionChain;
	}
	private IOException addToExceptionChain(IOException exceptionChain, IOException ex) {
		if (exceptionChain != null) {
			exceptionChain.addSuppressed(ex);
			return exceptionChain;
		}
		return ex;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class JarEntriesStream implements Closeable {
	private static final int BUFFER_SIZE = 4 * 1024;
	private final JarInputStream in;
	private final byte[] inBuffer = new byte[BUFFER_SIZE];
	private final byte[] compareBuffer = new byte[BUFFER_SIZE];
	private final Inflater inflater = new Inflater(true);
	private JarEntry entry;
	JarEntriesStream(InputStream in) throws IOException {
		this.in = new JarInputStream(in);
	}
	JarEntry getNextEntry() throws IOException {
		this.entry = this.in.getNextJarEntry();
		this.inflater.reset();
		return this.entry;
	}
	boolean matches(boolean directory, int size, int compressionMethod, InputStreamSupplier streamSupplier)
			throws IOException {
		if (this.entry.isDirectory() != directory) {
			fail('directory');
		}
		if (this.entry.getMethod() != compressionMethod) {
			fail('compression method');
		}
		if (this.entry.isDirectory()) {
			this.in.closeEntry();
			return true;
		}
		try (DataInputStream expected = new DataInputStream(getInputStream(size, streamSupplier))) {
			assertSameContent(expected);
		}
		return true;
	}
	private InputStream getInputStream(int size, InputStreamSupplier streamSupplier) throws IOException {
		InputStream inputStream = streamSupplier.get();
		return (this.entry.getMethod() != ZipEntry.DEFLATED) ? inputStream
				: new ZipInflaterInputStream(inputStream, this.inflater, size);
	}
	private void assertSameContent(DataInputStream expected) throws IOException {
		int len;
		while ((len = this.in.read(this.inBuffer)) > 0) {
			try {
				expected.readFully(this.compareBuffer, 0, len);
				if (Arrays.equals(this.inBuffer, 0, len, this.compareBuffer, 0, len)) {
					continue;
				}
			}
			catch (EOFException ex) {
				// Continue and throw exception due to mismatched content length.
			}
			fail('content');
		}
		if (expected.read() != -1) {
			fail('content');
		}
	}
	private void fail(String check) {
		throw new IllegalStateException('Content mismatch when reading security info for entry "%s" (%s check)'
			.formatted(this.entry.getName(), check));
	}
	@Override
	public void close() throws IOException {
		this.inflater.end();
		this.in.close();
	}
	@FunctionalInterface
	interface InputStreamSupplier {
		InputStream get() throws IOException;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
final class MetaInfVersionsInfo {
	static final MetaInfVersionsInfo NONE = new MetaInfVersionsInfo(Collections.emptySet());
	private static final String META_INF_VERSIONS = NestedJarFile.META_INF_VERSIONS;
	private final int[] versions;
	private final String[] directories;
	private MetaInfVersionsInfo(Set<Integer> versions) {
		this.versions = versions.stream().mapToInt(Integer::intValue).toArray();
		this.directories = versions.stream().map((version) -> META_INF_VERSIONS + version + '/').toArray(String[]::new);
	}
	/**
	 * Return the versions listed under {@code META-INF/versions/} in ascending order.
	 * @return the versions
	 */
	int[] versions() {
		return this.versions;
	}
	/**
	 * Return the version directories in the same order as {@link #versions()}.
	 * @return the version directories
	 */
	String[] directories() {
		return this.directories;
	}
	/**
	 * Get {@link MetaInfVersionsInfo} for the given {@link ZipContent}.
	 * @param zipContent the zip content
	 * @return the {@link MetaInfVersionsInfo}.
	 */
	static MetaInfVersionsInfo get(ZipContent zipContent) {
		return get(zipContent.size(), zipContent::getEntry);
	}
	/**
	 * Get {@link MetaInfVersionsInfo} for the given details.
	 * @param size the number of entries
	 * @param entries a function to get an entry from an index
	 * @return the {@link MetaInfVersionsInfo}.
	 */
	static MetaInfVersionsInfo get(int size, IntFunction<ZipContent.Entry> entries) {
		Set<Integer> versions = new TreeSet<>();
		for (int i = 0; i < size; i++) {
			ZipContent.Entry contentEntry = entries.apply(i);
			if (contentEntry.hasNameStartingWith(META_INF_VERSIONS) && !contentEntry.isDirectory()) {
				String name = contentEntry.getName();
				int slash = name.indexOf("/", META_INF_VERSIONS.length());
				if (slash > -1) {
					String version = name.substring(META_INF_VERSIONS.length(), slash);
					try {
						int versionNumber = Integer.parseInt(version);
						if (versionNumber >= NestedJarFile.BASE_VERSION) {
							versions.add(versionNumber);
						}
					}
					catch (NumberFormatException ex) {
						// Ignore
					}
				}
			}
		}
		return (!versions.isEmpty()) ? new MetaInfVersionsInfo(versions) : NONE;
	}
}
/*
package org.springframework.boot.loader.jar;
/**
class ManifestInfo {
	private static final Name MULTI_RELEASE = new Name('Multi-Release');
	static final ManifestInfo NONE = new ManifestInfo(null, false);
	private final Manifest manifest;
	private volatile Boolean multiRelease;
	/**
	 * Create a new {@link ManifestInfo} instance.
	 * @param manifest the jar manifest
	 */
	ManifestInfo(Manifest manifest) {
		this(manifest, null);
	}
	private ManifestInfo(Manifest manifest, Boolean multiRelease) {
		this.manifest = manifest;
		this.multiRelease = multiRelease;
	}
	/**
	 * Return the manifest, if any.
	 * @return the manifest or {@code null}
	 */
	Manifest getManifest() {
		return this.manifest;
	}
	/**
	 * Return if this is a multi-release jar.
	 * @return if the jar is multi-release
	 */
	boolean isMultiRelease() {
		if (this.manifest == null) {
			return false;
		}
		Boolean multiRelease = this.multiRelease;
		if (multiRelease != null) {
			return multiRelease;
		}
		Attributes attributes = this.manifest.getMainAttributes();
		multiRelease = attributes.containsKey(MULTI_RELEASE);
		this.multiRelease = multiRelease;
		return multiRelease;
	}
}
/*
/**
package org.springframework.boot.loader.jar;
/*
package org.springframework.boot.loader.jar;
/**
final class SecurityInfo {
	static final SecurityInfo NONE = new SecurityInfo(null, null);
	private final Certificate[][] certificateLookups;
	private final CodeSigner[][] codeSignerLookups;
	private SecurityInfo(Certificate[][] entryCertificates, CodeSigner[][] entryCodeSigners) {
		this.certificateLookups = entryCertificates;
		this.codeSignerLookups = entryCodeSigners;
	}
	Certificate[] getCertificates(ZipContent.Entry contentEntry) {
		return (this.certificateLookups != null) ? clone(this.certificateLookups[contentEntry.getLookupIndex()]) : null;
	}
	CodeSigner[] getCodeSigners(ZipContent.Entry contentEntry) {
		return (this.codeSignerLookups != null) ? clone(this.codeSignerLookups[contentEntry.getLookupIndex()]) : null;
	}
	private <T> T[] clone(T[] array) {
		return (array != null) ? array.clone() : null;
	}
	/**
	 * Get the {@link SecurityInfo} for the given {@link ZipContent}.
	 * @param content the zip content
	 * @return the security info
	 */
	static SecurityInfo get(ZipContent content) {
		if (!content.hasJarSignatureFile()) {
			return NONE;
		}
		try {
			return load(content);
		}
		catch (IOException ex) {
			throw new UncheckedIOException(ex);
		}
	}
	/**
	 * Load security info from the jar file. We need to use {@link JarInputStream} to
	 * obtain the security info since we don"t have an actual real file to read. This
	 * isn"t that fast, but hopefully doesn"t happen too often and the result is cached.
	 * @param content the zip content
	 * @return the security info
	 * @throws IOException on I/O error
	 */
	@SuppressWarnings('resource')
	private static SecurityInfo load(ZipContent content) throws IOException {
		int size = content.size();
		boolean hasSecurityInfo = false;
		Certificate[][] entryCertificates = new Certificate[size][];
		CodeSigner[][] entryCodeSigners = new CodeSigner[size][];
		try (JarEntriesStream entries = new JarEntriesStream(content.openRawZipData().asInputStream())) {
			JarEntry entry = entries.getNextEntry();
			while (entry != null) {
				ZipContent.Entry relatedEntry = content.getEntry(entry.getName());
				if (relatedEntry != null && entries.matches(relatedEntry.isDirectory(),
						relatedEntry.getUncompressedSize(), relatedEntry.getCompressionMethod(),
						() -> relatedEntry.openContent().asInputStream())) {
					Certificate[] certificates = entry.getCertificates();
					CodeSigner[] codeSigners = entry.getCodeSigners();
					if (certificates != null || codeSigners != null) {
						hasSecurityInfo = true;
						entryCertificates[relatedEntry.getLookupIndex()] = certificates;
						entryCodeSigners[relatedEntry.getLookupIndex()] = codeSigners;
					}
				}
				entry = entries.getNextEntry();
			}
		}
		return (!hasSecurityInfo) ? NONE : new SecurityInfo(entryCertificates, entryCodeSigners);
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
class UrlJarFiles {
	private final UrlJarFileFactory factory;
	private final Cache cache = new Cache();
	/**
	 * Create a new {@link UrlJarFiles} instance.
	 */
	UrlJarFiles() {
		this(new UrlJarFileFactory());
	}
	/**
	 * Create a new {@link UrlJarFiles} instance.
	 * @param factory the {@link UrlJarFileFactory} to use.
	 */
	UrlJarFiles(UrlJarFileFactory factory) {
		this.factory = factory;
	}
	/**
	 * Get an existing {@link JarFile} instance from the cache, or create a new
	 * {@link JarFile} instance that can be {@link #cacheIfAbsent(boolean, URL, JarFile)
	 * cached later}.
	 * @param useCaches if caches can be used
	 * @param jarFileUrl the jar file URL
	 * @return a new or existing {@link JarFile} instance
	 * @throws IOException on I/O error
	 */
	JarFile getOrCreate(boolean useCaches, URL jarFileUrl) throws IOException {
		if (useCaches) {
			JarFile cached = getCached(jarFileUrl);
			if (cached != null) {
				return cached;
			}
		}
		return this.factory.createJarFile(jarFileUrl, this::onClose);
	}
	/**
	 * Return the cached {@link JarFile} if available.
	 * @param jarFileUrl the jar file URL
	 * @return the cached jar or {@code null}
	 */
	JarFile getCached(URL jarFileUrl) {
		return this.cache.get(jarFileUrl);
	}
	/**
	 * Cache the given {@link JarFile} if caching can be used and there is no existing
	 * entry.
	 * @param useCaches if caches can be used
	 * @param jarFileUrl the jar file URL
	 * @param jarFile the jar file
	 * @return {@code true} if that file was added to the cache
	 */
	boolean cacheIfAbsent(boolean useCaches, URL jarFileUrl, JarFile jarFile) {
		if (!useCaches) {
			return false;
		}
		return this.cache.putIfAbsent(jarFileUrl, jarFile);
	}
	/**
	 * Close the given {@link JarFile} only if it is not contained in the cache.
	 * @param jarFileUrl the jar file URL
	 * @param jarFile the jar file
	 * @throws IOException on I/O error
	 */
	void closeIfNotCached(URL jarFileUrl, JarFile jarFile) throws IOException {
		JarFile cached = getCached(jarFileUrl);
		if (cached != jarFile) {
			jarFile.close();
		}
	}
	/**
	 * Reconnect to the {@link JarFile}, returning a replacement {@link URLConnection}.
	 * @param jarFile the jar file
	 * @param existingConnection the existing connection
	 * @return a newly opened connection inhering the same {@code useCaches} value as the
	 * existing connection
	 * @throws IOException on I/O error
	 */
	URLConnection reconnect(JarFile jarFile, URLConnection existingConnection) throws IOException {
		Boolean useCaches = (existingConnection != null) ? existingConnection.getUseCaches() : null;
		URLConnection connection = openConnection(jarFile);
		if (useCaches != null && connection != null) {
			connection.setUseCaches(useCaches);
		}
		return connection;
	}
	private URLConnection openConnection(JarFile jarFile) throws IOException {
		URL url = this.cache.get(jarFile);
		return (url != null) ? url.openConnection() : null;
	}
	private void onClose(JarFile jarFile) {
		this.cache.remove(jarFile);
	}
	void clearCache() {
		this.cache.clear();
	}
	/**
	 * Internal cache.
	 */
	private static final class Cache {
		private final Map<String, JarFile> jarFileUrlToJarFile = new HashMap<>();
		private final Map<JarFile, URL> jarFileToJarFileUrl = new HashMap<>();
		/**
		 * Get a {@link JarFile} from the cache given a jar file URL.
		 * @param jarFileUrl the jar file URL
		 * @return the cached {@link JarFile} or {@code null}
		 */
		JarFile get(URL jarFileUrl) {
			String urlKey = JarFileUrlKey.get(jarFileUrl);
			synchronized (this) {
				return this.jarFileUrlToJarFile.get(urlKey);
			}
		}
		/**
		 * Get a jar file URL from the cache given a jar file.
		 * @param jarFile the jar file
		 * @return the cached {@link URL} or {@code null}
		 */
		URL get(JarFile jarFile) {
			synchronized (this) {
				return this.jarFileToJarFileUrl.get(jarFile);
			}
		}
		/**
		 * Put the given jar file URL and jar file into the cache if they aren"t already
		 * there.
		 * @param jarFileUrl the jar file URL
		 * @param jarFile the jar file
		 * @return {@code true} if the items were added to the cache or {@code false} if
		 * they were already there
		 */
		boolean putIfAbsent(URL jarFileUrl, JarFile jarFile) {
			String urlKey = JarFileUrlKey.get(jarFileUrl);
			synchronized (this) {
				JarFile cached = this.jarFileUrlToJarFile.get(urlKey);
				if (cached == null) {
					this.jarFileUrlToJarFile.put(urlKey, jarFile);
					this.jarFileToJarFileUrl.put(jarFile, jarFileUrl);
					return true;
				}
				return false;
			}
		}
		/**
		 * Remove the given jar and any related URL file from the cache.
		 * @param jarFile the jar file to remove
		 */
		void remove(JarFile jarFile) {
			synchronized (this) {
				URL removedUrl = this.jarFileToJarFileUrl.remove(jarFile);
				if (removedUrl != null) {
					this.jarFileUrlToJarFile.remove(JarFileUrlKey.get(removedUrl));
				}
			}
		}
		void clear() {
			synchronized (this) {
				this.jarFileToJarFileUrl.clear();
				this.jarFileUrlToJarFile.clear();
			}
		}
	}
}
/*
package org.springframework.boot.loader.net.protocol.jar;
/**
final class JarUrlConnection extends java.net.JarURLConnection {
	static final UrlJarFiles jarFiles = new UrlJarFiles();
	static final InputStream emptyInputStream = new ByteArrayInputStream(new byte[0]);
	static final FileNotFoundException FILE_NOT_FOUND_EXCEPTION = new FileNotFoundException(
			'Jar file or entry not found');
	private static final URL NOT_FOUND_URL;
	static final JarUrlConnection NOT_FOUND_CONNECTION;
	static {
		try {
			NOT_FOUND_URL = new URL('jar:', null, 0, 'nested:!/', new EmptyUrlStreamHandler());
			NOT_FOUND_CONNECTION = new JarUrlConnection(() -> FILE_NOT_FOUND_EXCEPTION);
		}
		catch (IOException ex) {
			throw new IllegalStateException(ex);
		}
	}
	private final String entryName;
	private final Supplier<FileNotFoundException> notFound;
	private JarFile jarFile;
	private URLConnection jarFileConnection;
	private JarEntry jarEntry;
	private String contentType;
	private JarUrlConnection(URL url) throws IOException {
		super(url);
		this.entryName = getEntryName();
		this.notFound = null;
		this.jarFileConnection = getJarFileURL().openConnection();
		this.jarFileConnection.setUseCaches(this.useCaches);
	}
	private JarUrlConnection(Supplier<FileNotFoundException> notFound) throws IOException {
		super(NOT_FOUND_URL);
		this.entryName = null;
		this.notFound = notFound;
	}
	@Override
	public JarFile getJarFile() throws IOException {
		connect();
		return this.jarFile;
	}
	@Override
	public JarEntry getJarEntry() throws IOException {
		connect();
		return this.jarEntry;
	}
	@Override
	public int getContentLength() {
		long contentLength = getContentLengthLong();
		return (contentLength <= Integer.MAX_VALUE) ? (int) contentLength : -1;
	}
	@Override
	public long getContentLengthLong() {
		try {
			connect();
			return (this.jarEntry != null) ? this.jarEntry.getSize() : this.jarFileConnection.getContentLengthLong();
		}
		catch (IOException ex) {
			return -1;
		}
	}
	@Override
	public String getContentType() {
		if (this.contentType == null) {
			this.contentType = deduceContentType();
		}
		return this.contentType;
	}
	private String deduceContentType() {
		String type = (this.entryName != null) ? null : 'x-java/jar';
		type = (type != null) ? type : deduceContentTypeFromStream();
		type = (type != null) ? type : deduceContentTypeFromEntryName();
		return (type != null) ? type : 'content/unknown';
	}
	private String deduceContentTypeFromStream() {
		try {
			connect();
			try (InputStream in = this.jarFile.getInputStream(this.jarEntry)) {
				return guessContentTypeFromStream(new BufferedInputStream(in));
			}
		}
		catch (IOException ex) {
			return null;
		}
	}
	private String deduceContentTypeFromEntryName() {
		return guessContentTypeFromName(this.entryName);
	}
	@Override
	public long getLastModified() {
		return (this.jarFileConnection != null) ? this.jarFileConnection.getLastModified() : super.getLastModified();
	}
	@Override
	public String getHeade