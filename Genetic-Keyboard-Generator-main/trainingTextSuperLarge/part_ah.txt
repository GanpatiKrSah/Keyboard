Double getValue(Meter.Type meterType) {
		return this.value.getValue(meterType);
	}
	/**
	 * Return a new {@link ServiceLevelObjectiveBoundary} instance for the given double
	 * value.
	 * @param value the source value
	 * @return a {@link ServiceLevelObjectiveBoundary} instance
	 */
	public static ServiceLevelObjectiveBoundary valueOf(double value) {
		return new ServiceLevelObjectiveBoundary(MeterValue.valueOf(value));
	}
	/**
	 * Return a new {@link ServiceLevelObjectiveBoundary} instance for the given String
	 * value.
	 * @param value the source value
	 * @return a {@link ServiceLevelObjectiveBoundary} instance
	 */
	public static ServiceLevelObjectiveBoundary valueOf(String value) {
		return new ServiceLevelObjectiveBoundary(MeterValue.valueOf(value));
	}
	static class ServiceLevelObjectiveBoundaryHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection().registerType(ServiceLevelObjectiveBoundary.class, MemberCategory.INVOKE_PUBLIC_METHODS);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@Configuration(proxyBeanMethods = false)
@Conditional(MultipleNonPrimaryMeterRegistriesCondition.class)
class CompositeMeterRegistryConfiguration {
	@Bean
	@Primary
	AutoConfiguredCompositeMeterRegistry compositeMeterRegistry(Clock clock, List<MeterRegistry> registries) {
		return new AutoConfiguredCompositeMeterRegistry(clock, registries);
	}
	static class MultipleNonPrimaryMeterRegistriesCondition extends NoneNestedConditions {
		MultipleNonPrimaryMeterRegistriesCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnMissingBean(MeterRegistry.class)
		static class NoMeterRegistryCondition {
		}
		@ConditionalOnSingleCandidate(MeterRegistry.class)
		static class SingleInjectableMeterRegistry {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass({ MeterRegistry.class, LoggerContext.class, LoggerFactory.class })
@ConditionalOnBean(MeterRegistry.class)
@Conditional(LogbackLoggingCondition.class)
public class LogbackMetricsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public LogbackMetrics logbackMetrics() {
		return new LogbackMetrics();
	}
	static class LogbackLoggingCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ILoggerFactory loggerFactory = LoggerFactory.getILoggerFactory();
			ConditionMessage.Builder message = ConditionMessage.forCondition('LogbackLoggingCondition');
			if (loggerFactory instanceof LoggerContext) {
				return ConditionOutcome.match(message.because('ILoggerFactory is a Logback LoggerContext'));
			}
			return ConditionOutcome.noMatch(
					message.because('ILoggerFactory is an instance of ' + loggerFactory.getClass().getCanonicalName()));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(before = CompositeMeterRegistryAutoConfiguration.class)
@ConditionalOnClass(Timed.class)
@EnableConfigurationProperties(MetricsProperties.class)
public class MetricsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public Clock micrometerClock() {
		return Clock.SYSTEM;
	}
	@Bean
	public static MeterRegistryPostProcessor meterRegistryPostProcessor(ApplicationContext applicationContext,
			ObjectProvider<MetricsProperties> metricsProperties,
			ObjectProvider<MeterRegistryCustomizer<?>> meterRegistryCustomizers,
			ObjectProvider<MeterFilter> meterFilters, ObjectProvider<MeterBinder> meterBinders) {
		return new MeterRegistryPostProcessor(applicationContext, metricsProperties, meterRegistryCustomizers,
				meterFilters, meterBinders);
	}
	@Bean
	@Order(0)
	public PropertiesMeterFilter propertiesMeterFilter(MetricsProperties properties) {
		return new PropertiesMeterFilter(properties);
	}
	@Bean
	MeterRegistryCloser meterRegistryCloser(ObjectProvider<MeterRegistry> meterRegistries) {
		return new MeterRegistryCloser(meterRegistries.orderedStream().toList());
	}
	/**
	 * Ensures that {@link MeterRegistry meter registries} are closed early in the
	 * shutdown process.
	 */
	static class MeterRegistryCloser implements ApplicationListener<ContextClosedEvent> {
		private final List<MeterRegistry> meterRegistries;
		MeterRegistryCloser(List<MeterRegistry> meterRegistries) {
			this.meterRegistries = meterRegistries;
		}
		@Override
		public void onApplicationEvent(ContextClosedEvent event) {
			for (MeterRegistry meterRegistry : this.meterRegistries) {
				if (!meterRegistry.isClosed()) {
					meterRegistry.close();
				}
			}
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class MeterRegistryPostProcessor implements BeanPostProcessor, SmartInitializingSingleton {
	private final CompositeMeterRegistries compositeMeterRegistries;
	private final ObjectProvider<MetricsProperties> properties;
	private final ObjectProvider<MeterRegistryCustomizer<?>> customizers;
	private final ObjectProvider<MeterFilter> filters;
	private final ObjectProvider<MeterBinder> binders;
	private volatile boolean deferBinding = true;
	private final Set<MeterRegistry> deferredBindings = new LinkedHashSet<>();
	MeterRegistryPostProcessor(ApplicationContext applicationContext,
			ObjectProvider<MetricsProperties> metricsProperties, ObjectProvider<MeterRegistryCustomizer<?>> customizers,
			ObjectProvider<MeterFilter> filters, ObjectProvider<MeterBinder> binders) {
		this(CompositeMeterRegistries.of(applicationContext), metricsProperties, customizers, filters, binders);
	}
	MeterRegistryPostProcessor(CompositeMeterRegistries compositeMeterRegistries,
			ObjectProvider<MetricsProperties> properties, ObjectProvider<MeterRegistryCustomizer<?>> customizers,
			ObjectProvider<MeterFilter> filters, ObjectProvider<MeterBinder> binders) {
		this.compositeMeterRegistries = compositeMeterRegistries;
		this.properties = properties;
		this.customizers = customizers;
		this.filters = filters;
		this.binders = binders;
	}
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof MeterRegistry meterRegistry) {
			postProcessMeterRegistry(meterRegistry);
		}
		return bean;
	}
	@Override
	public void afterSingletonsInstantiated() {
		synchronized (this.deferredBindings) {
			this.deferBinding = false;
			this.deferredBindings.forEach(this::applyBinders);
		}
	}
	private void postProcessMeterRegistry(MeterRegistry meterRegistry) {
		// Customizers must be applied before binders, as they may add custom tags or
		// alter timer or summary configuration.
		applyCustomizers(meterRegistry);
		applyFilters(meterRegistry);
		addToGlobalRegistryIfNecessary(meterRegistry);
		if (isBindable(meterRegistry)) {
			applyBinders(meterRegistry);
		}
	}
	@SuppressWarnings('unchecked')
	private void applyCustomizers(MeterRegistry meterRegistry) {
		List<MeterRegistryCustomizer<?>> customizers = this.customizers.orderedStream().toList();
		LambdaSafe.callbacks(MeterRegistryCustomizer.class, customizers, meterRegistry)
			.withLogger(MeterRegistryPostProcessor.class)
			.invoke((customizer) -> customizer.customize(meterRegistry));
	}
	private void applyFilters(MeterRegistry meterRegistry) {
		if (meterRegistry instanceof AutoConfiguredCompositeMeterRegistry) {
			return;
		}
		this.filters.orderedStream().forEach(meterRegistry.config()::meterFilter);
	}
	private void addToGlobalRegistryIfNecessary(MeterRegistry meterRegistry) {
		if (this.properties.getObject().isUseGlobalRegistry() && !isGlobalRegistry(meterRegistry)) {
			Metrics.addRegistry(meterRegistry);
		}
	}
	private boolean isGlobalRegistry(MeterRegistry meterRegistry) {
		return meterRegistry == Metrics.globalRegistry;
	}
	private boolean isBindable(MeterRegistry meterRegistry) {
		return isAutoConfiguredComposite(meterRegistry) || isCompositeWithOnlyUserDefinedComposites(meterRegistry)
				|| noCompositeMeterRegistries();
	}
	private boolean isAutoConfiguredComposite(MeterRegistry meterRegistry) {
		return meterRegistry instanceof AutoConfiguredCompositeMeterRegistry;
	}
	private boolean isCompositeWithOnlyUserDefinedComposites(MeterRegistry meterRegistry) {
		return this.compositeMeterRegistries == CompositeMeterRegistries.ONLY_USER_DEFINED
				&& meterRegistry instanceof CompositeMeterRegistry;
	}
	private boolean noCompositeMeterRegistries() {
		return this.compositeMeterRegistries == CompositeMeterRegistries.NONE;
	}
	void applyBinders(MeterRegistry meterRegistry) {
		if (this.deferBinding) {
			synchronized (this.deferredBindings) {
				if (this.deferBinding) {
					this.deferredBindings.add(meterRegistry);
					return;
				}
			}
		}
		this.binders.orderedStream().forEach((binder) -> binder.bindTo(meterRegistry));
	}
	enum CompositeMeterRegistries {
		NONE, AUTO_CONFIGURED, ONLY_USER_DEFINED;
		private static CompositeMeterRegistries of(ApplicationContext context) {
			if (hasBeansOfType(AutoConfiguredCompositeMeterRegistry.class, context)) {
				return AUTO_CONFIGURED;
			}
			return hasBeansOfType(CompositeMeterRegistry.class, context) ? ONLY_USER_DEFINED : NONE;
		}
		private static boolean hasBeansOfType(Class<?> type, ApplicationContext context) {
			return context.getBeanNamesForType(type, false, false).length > 0;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration
@Import({ NoOpMeterRegistryConfiguration.class, CompositeMeterRegistryConfiguration.class })
@ConditionalOnClass(CompositeMeterRegistry.class)
public class CompositeMeterRegistryAutoConfiguration {
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass(MeterRegistry.class)
@ConditionalOnBean(MeterRegistry.class)
public class JvmMetricsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public JvmGcMetrics jvmGcMetrics() {
		return new JvmGcMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public JvmHeapPressureMetrics jvmHeapPressureMetrics() {
		return new JvmHeapPressureMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public JvmMemoryMetrics jvmMemoryMetrics() {
		return new JvmMemoryMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public JvmThreadMetrics jvmThreadMetrics() {
		return new JvmThreadMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public ClassLoaderMetrics classLoaderMetrics() {
		return new ClassLoaderMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public JvmInfoMetrics jvmInfoMetrics() {
		return new JvmInfoMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public JvmCompilationMetrics jvmCompilationMetrics() {
		return new JvmCompilationMetrics();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.jersey;
/**
@AutoConfiguration(after = { ObservationAutoConfiguration.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass({ ResourceConfig.class, ObservationApplicationEventListener.class })
@ConditionalOnBean({ ResourceConfig.class, ObservationRegistry.class })
@EnableConfigurationProperties({ MetricsProperties.class, ObservationProperties.class })
public class JerseyServerMetricsAutoConfiguration {
	private final ObservationProperties observationProperties;
	public JerseyServerMetricsAutoConfiguration(ObservationProperties observationProperties) {
		this.observationProperties = observationProperties;
	}
	@Bean
	ResourceConfigCustomizer jerseyServerObservationResourceConfigCustomizer(ObservationRegistry observationRegistry,
			ObjectProvider<JerseyObservationConvention> jerseyObservationConvention) {
		String metricName = this.observationProperties.getHttp().getServer().getRequests().getName();
		return (config) -> config.register(new ObservationApplicationEventListener(observationRegistry, metricName,
				jerseyObservationConvention.getIfAvailable()));
	}
	@Bean
	@Order(0)
	public MeterFilter jerseyMetricsUriTagFilter(MetricsProperties metricsProperties) {
		String metricName = this.observationProperties.getHttp().getServer().getRequests().getName();
		MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(
				() -> String.format('Reached the maximum number of URI tags for "%s".', metricName));
		return MeterFilter.maximumAllowableTags(metricName, 'uri',
				metricsProperties.getWeb().getServer().getMaxUriTags(), filter);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.jersey;
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(before = KafkaAutoConfiguration.class,
		after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass({ KafkaClientMetrics.class, ProducerFactory.class })
@ConditionalOnBean(MeterRegistry.class)
public class KafkaMetricsAutoConfiguration {
	@Bean
	public DefaultKafkaProducerFactoryCustomizer kafkaProducerMetrics(MeterRegistry meterRegistry) {
		return (producerFactory) -> addListener(producerFactory, meterRegistry);
	}
	@Bean
	public DefaultKafkaConsumerFactoryCustomizer kafkaConsumerMetrics(MeterRegistry meterRegistry) {
		return (consumerFactory) -> addListener(consumerFactory, meterRegistry);
	}
	private <K, V> void addListener(DefaultKafkaConsumerFactory<K, V> factory, MeterRegistry meterRegistry) {
		factory.addListener(new MicrometerConsumerListener<>(meterRegistry));
	}
	private <K, V> void addListener(DefaultKafkaProducerFactory<K, V> factory, MeterRegistry meterRegistry) {
		factory.addListener(new MicrometerProducerListener<>(meterRegistry));
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ KafkaStreamsMetrics.class, StreamsBuilderFactoryBean.class })
	static class KafkaStreamsMetricsConfiguration {
		@Bean
		StreamsBuilderFactoryBeanCustomizer kafkaStreamsMetrics(MeterRegistry meterRegistry) {
			return (factoryBean) -> factoryBean.addListener(new KafkaStreamsMicrometerListener(meterRegistry));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
class ValidationFailureAnalyzer extends AbstractFailureAnalyzer<ValidationException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, ValidationException cause) {
		StringBuilder description = new StringBuilder(String.format('Invalid Micrometer configuration detected:%n'));
		for (Invalid<?> failure : cause.getValidation().failures()) {
			description.append(String.format('%n  - %s was "%s" but it %s', failure.getProperty(), failure.getValue(),
					failure.getMessage()));
		}
		return new FailureAnalysis(description.toString(),
				'Update your application to correct the invalid configuration.', cause);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.data;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class,
		SimpleMetricsExportAutoConfiguration.class })
@ConditionalOnClass(org.springframework.data.repository.Repository.class)
@ConditionalOnBean(MeterRegistry.class)
@EnableConfigurationProperties(MetricsProperties.class)
public class RepositoryMetricsAutoConfiguration {
	private final MetricsProperties properties;
	public RepositoryMetricsAutoConfiguration(MetricsProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean(RepositoryTagsProvider.class)
	public DefaultRepositoryTagsProvider repositoryTagsProvider() {
		return new DefaultRepositoryTagsProvider();
	}
	@Bean
	@ConditionalOnMissingBean
	public MetricsRepositoryMethodInvocationListener metricsRepositoryMethodInvocationListener(
			ObjectProvider<MeterRegistry> registry, RepositoryTagsProvider tagsProvider) {
		Repository properties = this.properties.getData().getRepository();
		return new MetricsRepositoryMethodInvocationListener(registry::getObject, tagsProvider,
				properties.getMetricName(), new PropertiesAutoTimer(properties.getAutotime()));
	}
	@Bean
	public static MetricsRepositoryMethodInvocationListenerBeanPostProcessor metricsRepositoryMethodInvocationListenerBeanPostProcessor(
			ObjectProvider<MetricsRepositoryMethodInvocationListener> metricsRepositoryMethodInvocationListener) {
		return new MetricsRepositoryMethodInvocationListenerBeanPostProcessor(
				SingletonSupplier.of(metricsRepositoryMethodInvocationListener::getObject));
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.data;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.data;
/**
class MetricsRepositoryMethodInvocationListenerBeanPostProcessor implements BeanPostProcessor {
	private final RepositoryFactoryCustomizer customizer;
	MetricsRepositoryMethodInvocationListenerBeanPostProcessor(
			SingletonSupplier<MetricsRepositoryMethodInvocationListener> listener) {
		this.customizer = new MetricsRepositoryFactoryCustomizer(listener);
	}
	@Override
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof RepositoryFactoryBeanSupport) {
			((RepositoryFactoryBeanSupport<?, ?, ?>) bean).addRepositoryFactoryCustomizer(this.customizer);
		}
		return bean;
	}
	private static final class MetricsRepositoryFactoryCustomizer implements RepositoryFactoryCustomizer {
		private final SingletonSupplier<MetricsRepositoryMethodInvocationListener> listenerSupplier;
		private MetricsRepositoryFactoryCustomizer(
				SingletonSupplier<MetricsRepositoryMethodInvocationListener> listenerSupplier) {
			this.listenerSupplier = listenerSupplier;
		}
		@Override
		public void customize(RepositoryFactorySupport repositoryFactory) {
			repositoryFactory.addInvocationListener(this.listenerSupplier.get());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
public class PropertiesAutoTimer implements AutoTimer {
	private final AutoTimeProperties properties;
	/**
	 * Create a new {@link PropertiesAutoTimer} configured using the given
	 * {@code properties}.
	 * @param properties the properties to configure auto-timing
	 */
	public PropertiesAutoTimer(AutoTimeProperties properties) {
		this.properties = properties;
	}
	@Override
	public void apply(Builder builder) {
		builder.publishPercentileHistogram(this.properties.isPercentilesHistogram())
			.publishPercentiles(this.properties.getPercentiles());
	}
	@Override
	public boolean isEnabled() {
		return this.properties.isEnabled();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
public final class AutoTimeProperties {
	/**
	 * Whether to enable auto-timing.
	 */
	private boolean enabled = true;
	/**
	 * Whether to publish percentile histograms.
	 */
	private boolean percentilesHistogram;
	/**
	 * Percentiles for which additional time series should be published.
	 */
	private double[] percentiles;
	/**
	 * Create an instance that automatically time requests with no percentiles.
	 */
	public AutoTimeProperties() {
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public boolean isPercentilesHistogram() {
		return this.percentilesHistogram;
	}
	public void setPercentilesHistogram(boolean percentilesHistogram) {
		this.percentilesHistogram = percentilesHistogram;
	}
	public double[] getPercentiles() {
		return this.percentiles;
	}
	public void setPercentiles(double[] percentiles) {
		this.percentiles = percentiles;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean(Clock.class)
@ConditionalOnMissingBean(MeterRegistry.class)
class NoOpMeterRegistryConfiguration {
	@Bean
	CompositeMeterRegistry noOpMeterRegistry(Clock clock) {
		return new CompositeMeterRegistry(clock);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@ConfigurationProperties('management.metrics')
public class MetricsProperties {
	/**
	 * Whether auto-configured MeterRegistry implementations should be bound to the global
	 * static registry on Metrics. For testing, set this to "false" to maximize test
	 * independence.
	 */
	private boolean useGlobalRegistry = true;
	/**
	 * Whether meter IDs starting with the specified name should be enabled. The longest
	 * match wins, the key "all" can also be used to configure all meters.
	 */
	private final Map<String, Boolean> enable = new LinkedHashMap<>();
	/**
	 * Common tags that are applied to every meter.
	 */
	private final Map<String, String> tags = new LinkedHashMap<>();
	private final Web web = new Web();
	private final Data data = new Data();
	private final System system = new System();
	private final Distribution distribution = new Distribution();
	public boolean isUseGlobalRegistry() {
		return this.useGlobalRegistry;
	}
	public void setUseGlobalRegistry(boolean useGlobalRegistry) {
		this.useGlobalRegistry = useGlobalRegistry;
	}
	public Map<String, Boolean> getEnable() {
		return this.enable;
	}
	public Map<String, String> getTags() {
		return this.tags;
	}
	public Web getWeb() {
		return this.web;
	}
	public Data getData() {
		return this.data;
	}
	public System getSystem() {
		return this.system;
	}
	public Distribution getDistribution() {
		return this.distribution;
	}
	public static class Web {
		private final Client client = new Client();
		private final Server server = new Server();
		public Client getClient() {
			return this.client;
		}
		public Server getServer() {
			return this.server;
		}
		public static class Client {
			/**
			 * Maximum number of unique URI tag values allowed. After the max number of
			 * tag values is reached, metrics with additional tag values are denied by
			 * filter.
			 */
			private int maxUriTags = 100;
			public int getMaxUriTags() {
				return this.maxUriTags;
			}
			public void setMaxUriTags(int maxUriTags) {
				this.maxUriTags = maxUriTags;
			}
		}
		public static class Server {
			/**
			 * Maximum number of unique URI tag values allowed. After the max number of
			 * tag values is reached, metrics with additional tag values are denied by
			 * filter.
			 */
			private int maxUriTags = 100;
			public int getMaxUriTags() {
				return this.maxUriTags;
			}
			public void setMaxUriTags(int maxUriTags) {
				this.maxUriTags = maxUriTags;
			}
		}
	}
	public static class Data {
		private final Repository repository = new Repository();
		public Repository getRepository() {
			return this.repository;
		}
		public static class Repository {
			/**
			 * Name of the metric for sent requests.
			 */
			private String metricName = 'spring.data.repository.invocations';
			/**
			 * Auto-timed request settings.
			 */
			@NestedConfigurationProperty
			private final AutoTimeProperties autotime = new AutoTimeProperties();
			public String getMetricName() {
				return this.metricName;
			}
			public void setMetricName(String metricName) {
				this.metricName = metricName;
			}
			public AutoTimeProperties getAutotime() {
				return this.autotime;
			}
		}
	}
	public static class System {
		private final Diskspace diskspace = new Diskspace();
		public Diskspace getDiskspace() {
			return this.diskspace;
		}
		public static class Diskspace {
			/**
			 * List of paths to report disk metrics for.
			 */
			private List<File> paths = new ArrayList<>(Collections.singletonList(new File('.')));
			public List<File> getPaths() {
				return this.paths;
			}
			public void setPaths(List<File> paths) {
				this.paths = paths;
			}
		}
	}
	public static class Distribution {
		/**
		 * Whether meter IDs starting with the specified name should publish percentile
		 * histograms. For monitoring systems that support aggregable percentile
		 * calculation based on a histogram, this can be set to true. For other systems,
		 * this has no effect. The longest match wins, the key "all" can also be used to
		 * configure all meters.
		 */
		private final Map<String, Boolean> percentilesHistogram = new LinkedHashMap<>();
		/**
		 * Specific computed non-aggregable percentiles to ship to the backend for meter
		 * IDs starting-with the specified name. The longest match wins, the key "all" can
		 * also be used to configure all meters.
		 */
		private final Map<String, double[]> percentiles = new LinkedHashMap<>();
		/**
		 * Specific service-level objective boundaries for meter IDs starting with the
		 * specified name. The longest match wins. Counters will be published for each
		 * specified boundary. Values can be specified as a double or as a Duration value
		 * (for timer meters, defaulting to ms if no unit specified).
		 */
		private final Map<String, ServiceLevelObjectiveBoundary[]> slo = new LinkedHashMap<>();
		/**
		 * Minimum value that meter IDs starting with the specified name are expected to
		 * observe. The longest match wins. Values can be specified as a double or as a
		 * Duration value (for timer meters, defaulting to ms if no unit specified).
		 */
		private final Map<String, String> minimumExpectedValue = new LinkedHashMap<>();
		/**
		 * Maximum value that meter IDs starting with the specified name are expected to
		 * observe. The longest match wins. Values can be specified as a double or as a
		 * Duration value (for timer meters, defaulting to ms if no unit specified).
		 */
		private final Map<String, String> maximumExpectedValue = new LinkedHashMap<>();
		/**
		 * Maximum amount of time that samples for meter IDs starting with the specified
		 * name are accumulated to decaying distribution statistics before they are reset
		 * and rotated. The longest match wins, the key `all` can also be used to
		 * configure all meters.
		 */
		private final Map<String, Duration> expiry = new LinkedHashMap<>();
		/**
		 * Number of histograms for meter IDs starting with the specified name to keep in
		 * the ring buffer. The longest match wins, the key `all` can also be used to
		 * configure all meters.
		 */
		private final Map<String, Integer> bufferLength = new LinkedHashMap<>();
		public Map<String, Boolean> getPercentilesHistogram() {
			return this.percentilesHistogram;
		}
		public Map<String, double[]> getPercentiles() {
			return this.percentiles;
		}
		public Map<String, ServiceLevelObjectiveBoundary[]> getSlo() {
			return this.slo;
		}
		public Map<String, String> getMinimumExpectedValue() {
			return this.minimumExpectedValue;
		}
		public Map<String, String> getMaximumExpectedValue() {
			return this.maximumExpectedValue;
		}
		public Map<String, Duration> getExpiry() {
			return this.expiry;
		}
		public Map<String, Integer> getBufferLength() {
			return this.bufferLength;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass(MeterRegistry.class)
@ConditionalOnBean(MeterRegistry.class)
@EnableConfigurationProperties(MetricsProperties.class)
public class SystemMetricsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public UptimeMetrics uptimeMetrics() {
		return new UptimeMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public ProcessorMetrics processorMetrics() {
		return new ProcessorMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public FileDescriptorMetrics fileDescriptorMetrics() {
		return new FileDescriptorMetrics();
	}
	@Bean
	@ConditionalOnMissingBean
	public DiskSpaceMetricsBinder diskSpaceMetrics(MetricsProperties properties) {
		List<File> paths = properties.getSystem().getDiskspace().getPaths();
		return new DiskSpaceMetricsBinder(paths, Tags.empty());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
public final class OnlyOnceLoggingDenyMeterFilter implements MeterFilter {
	private static final Log logger = LogFactory.getLog(OnlyOnceLoggingDenyMeterFilter.class);
	private final AtomicBoolean alreadyWarned = new AtomicBoolean();
	private final Supplier<String> message;
	public OnlyOnceLoggingDenyMeterFilter(Supplier<String> message) {
		Assert.notNull(message, 'Message must not be null');
		this.message = message;
	}
	@Override
	public MeterFilterReply accept(Id id) {
		if (logger.isWarnEnabled() && this.alreadyWarned.compareAndSet(false, true)) {
			logger.warn(this.message.get());
		}
		return MeterFilterReply.DENY;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.amqp;
/**
class RabbitConnectionFactoryMetricsPostProcessor implements BeanPostProcessor, Ordered {
	private static final String CONNECTION_FACTORY_SUFFIX = 'connectionFactory';
	private final ApplicationContext context;
	private volatile MeterRegistry meterRegistry;
	RabbitConnectionFactoryMetricsPostProcessor(ApplicationContext context) {
		this.context = context;
	}
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) {
		if (bean instanceof AbstractConnectionFactory connectionFactory) {
			bindConnectionFactoryToRegistry(getMeterRegistry(), beanName, connectionFactory);
		}
		return bean;
	}
	private void bindConnectionFactoryToRegistry(MeterRegistry registry, String beanName,
			AbstractConnectionFactory connectionFactory) {
		ConnectionFactory rabbitConnectionFactory = connectionFactory.getRabbitConnectionFactory();
		String connectionFactoryName = getConnectionFactoryName(beanName);
		new RabbitMetrics(rabbitConnectionFactory, Tags.of('name', connectionFactoryName)).bindTo(registry);
	}
	/**
	 * Get the name of a ConnectionFactory based on its {@code beanName}.
	 * @param beanName the name of the connection factory bean
	 * @return a name for the given connection factory
	 */
	private String getConnectionFactoryName(String beanName) {
		if (beanName.length() > CONNECTION_FACTORY_SUFFIX.length()
				&& StringUtils.endsWithIgnoreCase(beanName, CONNECTION_FACTORY_SUFFIX)) {
			return beanName.substring(0, beanName.length() - CONNECTION_FACTORY_SUFFIX.length());
		}
		return beanName;
	}
	private MeterRegistry getMeterRegistry() {
		if (this.meterRegistry == null) {
			this.meterRegistry = this.context.getBean(MeterRegistry.class);
		}
		return this.meterRegistry;
	}
	@Override
	public int getOrder() {
		return Ordered.HIGHEST_PRECEDENCE;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.amqp;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, RabbitAutoConfiguration.class,
		SimpleMetricsExportAutoConfiguration.class })
@ConditionalOnClass({ ConnectionFactory.class, AbstractConnectionFactory.class })
@ConditionalOnBean({ org.springframework.amqp.rabbit.connection.ConnectionFactory.class, MeterRegistry.class })
public class RabbitMetricsAutoConfiguration {
	@Bean
	public static RabbitConnectionFactoryMetricsPostProcessor rabbitConnectionFactoryMetricsPostProcessor(
			ApplicationContext applicationContext) {
		return new RabbitConnectionFactoryMetricsPostProcessor(applicationContext);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.amqp;
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass(value = { Log4j2Metrics.class, LogManager.class },
		name = 'org.apache.logging.log4j.core.LoggerContext')
@ConditionalOnBean(MeterRegistry.class)
@Conditional(Log4JCoreLoggerContextCondition.class)
public class Log4J2MetricsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public Log4j2Metrics log4j2Metrics() {
		return new Log4j2Metrics();
	}
	static class Log4JCoreLoggerContextCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			LoggerContext loggerContext = LogManager.getContext(false);
			try {
				if (Class.forName('org.apache.logging.log4j.core.LoggerContext').isInstance(loggerContext)) {
					return ConditionOutcome
						.match('LoggerContext was an instance of org.apache.logging.log4j.core.LoggerContext');
				}
			}
			catch (Throwable ex) {
				// Continue with no match
			}
			return ConditionOutcome
				.noMatch('Logger context was not an instance of org.apache.logging.log4j.core.LoggerContext');
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.redis;
/**
@AutoConfiguration(before = RedisAutoConfiguration.class,
		after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass({ RedisClient.class, MicrometerCommandLatencyRecorder.class })
@ConditionalOnBean(MeterRegistry.class)
public class LettuceMetricsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	MicrometerOptions micrometerOptions() {
		return MicrometerOptions.create();
	}
	@Bean
	ClientResourcesBuilderCustomizer lettuceMetrics(MeterRegistry meterRegistry, MicrometerOptions options) {
		return (client) -> client.commandLatencyRecorder(new MicrometerCommandLatencyRecorder(meterRegistry, options));
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.redis;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.startup;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass(MeterRegistry.class)
@ConditionalOnBean(MeterRegistry.class)
public class StartupTimeMetricsListenerAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public StartupTimeMetricsListener startupTimeMetrics(MeterRegistry meterRegistry) {
		return new StartupTimeMetricsListener(meterRegistry);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.startup;
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass({ MeterRegistry.class, Advice.class })
@Conditional(ObservationAnnotationsEnabledCondition.class)
@ConditionalOnBean(MeterRegistry.class)
public class MetricsAspectsAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	CountedAspect countedAspect(MeterRegistry registry) {
		return new CountedAspect(registry);
	}
	@Bean
	@ConditionalOnMissingBean
	TimedAspect timedAspect(MeterRegistry registry,
			ObjectProvider<MeterTagAnnotationHandler> meterTagAnnotationHandler) {
		TimedAspect timedAspect = new TimedAspect(registry);
		meterTagAnnotationHandler.ifAvailable(timedAspect::setMeterTagAnnotationHandler);
		return timedAspect;
	}
	static final class ObservationAnnotationsEnabledCondition extends AnyNestedCondition {
		ObservationAnnotationsEnabledCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty(prefix = 'micrometer.observations.annotations', name = 'enabled', havingValue = 'true')
		static class MicrometerObservationsEnabledCondition {
		}
		@ConditionalOnProperty(prefix = 'management.observations.annotations', name = 'enabled', havingValue = 'true')
		static class ManagementObservationsEnabledCondition {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass(Timed.class)
@ConditionalOnAvailableEndpoint(MetricsEndpoint.class)
public class MetricsEndpointAutoConfiguration {
	@Bean
	@ConditionalOnBean(MeterRegistry.class)
	@ConditionalOnMissingBean
	public MetricsEndpoint metricsEndpoint(MeterRegistry registry) {
		return new MetricsEndpoint(registry);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.r2dbc;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, SimpleMetricsExportAutoConfiguration.class,
		R2dbcAutoConfiguration.class })
@ConditionalOnClass({ ConnectionPool.class, MeterRegistry.class })
@ConditionalOnBean({ ConnectionFactory.class, MeterRegistry.class })
public class ConnectionPoolMetricsAutoConfiguration {
	@Autowired
	public void bindConnectionPoolsToRegistry(Map<String, ConnectionFactory> connectionFactories,
			MeterRegistry registry) {
		connectionFactories.forEach((beanName, connectionFactory) -> {
			ConnectionPool pool = extractPool(connectionFactory);
			if (pool != null) {
				new ConnectionPoolMetrics(pool, beanName, Tags.empty()).bindTo(registry);
			}
		});
	}
	private ConnectionPool extractPool(Object candidate) {
		if (candidate instanceof ConnectionPool connectionPool) {
			return connectionPool;
		}
		if (candidate instanceof Wrapped) {
			return extractPool(((Wrapped<?>) candidate).unwrap());
		}
		return null;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.r2dbc;
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics;
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
public class PropertiesMeterFilter implements MeterFilter {
	private final MetricsProperties properties;
	private final MeterFilter mapFilter;
	public PropertiesMeterFilter(MetricsProperties properties) {
		Assert.notNull(properties, 'Properties must not be null');
		this.properties = properties;
		this.mapFilter = createMapFilter(properties.getTags());
	}
	private static MeterFilter createMapFilter(Map<String, String> tags) {
		if (tags.isEmpty()) {
			return new MeterFilter() {
			};
		}
		Tags commonTags = Tags.of(tags.entrySet().stream().map(PropertiesMeterFilter::asTag).toList());
		return MeterFilter.commonTags(commonTags);
	}
	private static Tag asTag(Entry<String, String> entry) {
		return Tag.of(entry.getKey(), entry.getValue());
	}
	@Override
	public MeterFilterReply accept(Meter.Id id) {
		boolean enabled = lookupWithFallbackToAll(this.properties.getEnable(), id, true);
		return enabled ? MeterFilterReply.NEUTRAL : MeterFilterReply.DENY;
	}
	@Override
	public Id map(Id id) {
		return this.mapFilter.map(id);
	}
	@Override
	public DistributionStatisticConfig configure(Meter.Id id, DistributionStatisticConfig config) {
		Distribution distribution = this.properties.getDistribution();
		return DistributionStatisticConfig.builder()
			.percentilesHistogram(lookupWithFallbackToAll(distribution.getPercentilesHistogram(), id, null))
			.percentiles(lookupWithFallbackToAll(distribution.getPercentiles(), id, null))
			.serviceLevelObjectives(
					convertServiceLevelObjectives(id.getType(), lookup(distribution.getSlo(), id, null)))
			.minimumExpectedValue(
					convertMeterValue(id.getType(), lookup(distribution.getMinimumExpectedValue(), id, null)))
			.maximumExpectedValue(
					convertMeterValue(id.getType(), lookup(distribution.getMaximumExpectedValue(), id, null)))
			.expiry(lookupWithFallbackToAll(distribution.getExpiry(), id, null))
			.bufferLength(lookupWithFallbackToAll(distribution.getBufferLength(), id, null))
			.build()
			.merge(config);
	}
	private double[] convertServiceLevelObjectives(Meter.Type meterType, ServiceLevelObjectiveBoundary[] slo) {
		if (slo == null) {
			return null;
		}
		double[] converted = Arrays.stream(slo)
			.map((candidate) -> candidate.getValue(meterType))
			.filter(Objects::nonNull)
			.mapToDouble(Double::doubleValue)
			.toArray();
		return (converted.length != 0) ? converted : null;
	}
	private Double convertMeterValue(Meter.Type meterType, String value) {
		return (value != null) ? MeterValue.valueOf(value).getValue(meterType) : null;
	}
	private <T> T lookup(Map<String, T> values, Id id, T defaultValue) {
		if (values.isEmpty()) {
			return defaultValue;
		}
		return doLookup(values, id, () -> defaultValue);
	}
	private <T> T lookupWithFallbackToAll(Map<String, T> values, Id id, T defaultValue) {
		if (values.isEmpty()) {
			return defaultValue;
		}
		return doLookup(values, id, () -> values.getOrDefault('all', defaultValue));
	}
	private <T> T doLookup(Map<String, T> values, Id id, Supplier<T> defaultValue) {
		String name = id.getName();
		while (StringUtils.hasLength(name)) {
			T result = values.get(name);
			if (result != null) {
				return result;
			}
			int lastDot = name.lastIndexOf(".");
			name = (lastDot != -1) ? name.substring(0, lastDot) : '';
		}
		return defaultValue.get();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.metrics.mongo;
/**
@AutoConfiguration(before = MongoAutoConfiguration.class,
		after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class })
@ConditionalOnClass(MongoClientSettings.class)
@ConditionalOnBean(MeterRegistry.class)
public class MongoMetricsAutoConfiguration {
	@ConditionalOnClass(MongoMetricsCommandListener.class)
	@ConditionalOnProperty(name = 'management.metrics.mongo.command.enabled', havingValue = 'true',
			matchIfMissing = true)
	static class MongoCommandMetricsConfiguration {
		@Bean
		@ConditionalOnMissingBean
		MongoMetricsCommandListener mongoMetricsCommandListener(MeterRegistry meterRegistry,
				MongoCommandTagsProvider mongoCommandTagsProvider) {
			return new MongoMetricsCommandListener(meterRegistry, mongoCommandTagsProvider);
		}
		@Bean
		@ConditionalOnMissingBean
		MongoCommandTagsProvider mongoCommandTagsProvider() {
			return new DefaultMongoCommandTagsProvider();
		}
		@Bean
		MongoClientSettingsBuilderCustomizer mongoMetricsCommandListenerClientSettingsBuilderCustomizer(
				MongoMetricsCommandListener mongoMetricsCommandListener) {
			return (clientSettingsBuilder) -> clientSettingsBuilder.addCommandListener(mongoMetricsCommandListener);
		}
	}
	@ConditionalOnClass(MongoMetricsConnectionPoolListener.class)
	@ConditionalOnProperty(name = 'management.metrics.mongo.connectionpool.enabled', havingValue = 'true',
			matchIfMissing = true)
	static class MongoConnectionPoolMetricsConfiguration {
		@Bean
		@ConditionalOnMissingBean
		MongoMetricsConnectionPoolListener mongoMetricsConnectionPoolListener(MeterRegistry meterRegistry,
				MongoConnectionPoolTagsProvider mongoConnectionPoolTagsProvider) {
			return new MongoMetricsConnectionPoolListener(meterRegistry, mongoConnectionPoolTagsProvider);
		}
		@Bean
		@ConditionalOnMissingBean
		MongoConnectionPoolTagsProvider mongoConnectionPoolTagsProvider() {
			return new DefaultMongoConnectionPoolTagsProvider();
		}
		@Bean
		MongoClientSettingsBuilderCustomizer mongoMetricsConnectionPoolListenerClientSettingsBuilderCustomizer(
				MongoMetricsConnectionPoolListener mongoMetricsConnectionPoolListener) {
			return (clientSettingsBuilder) -> clientSettingsBuilder
				.applyToConnectionPoolSettings((connectionPoolSettingsBuilder) -> connectionPoolSettingsBuilder
					.addConnectionPoolListener(mongoMetricsConnectionPoolListener));
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.mongo;
/*
package org.springframework.boot.actuate.autoconfigure.metrics.orm.jpa;
/**
@Configuration(proxyBeanMethods = false)
@AutoConfigureAfter({ MetricsAutoConfiguration.class, HibernateJpaAutoConfiguration.class,
		SimpleMetricsExportAutoConfiguration.class })
@ConditionalOnClass({ EntityManagerFactory.class, SessionFactory.class, HibernateMetrics.class, MeterRegistry.class })
@ConditionalOnBean({ EntityManagerFactory.class, MeterRegistry.class })
public class HibernateMetricsAutoConfiguration implements SmartInitializingSingleton {
	private static final String ENTITY_MANAGER_FACTORY_SUFFIX = 'entityManagerFactory';
	private final Map<String, EntityManagerFactory> entityManagerFactories;
	private final MeterRegistry meterRegistry;
	public HibernateMetricsAutoConfiguration(Map<String, EntityManagerFactory> entityManagerFactories,
			MeterRegistry meterRegistry) {
		this.entityManagerFactories = entityManagerFactories;
		this.meterRegistry = meterRegistry;
	}
	@Override
	public void afterSingletonsInstantiated() {
		bindEntityManagerFactoriesToRegistry(this.entityManagerFactories, this.meterRegistry);
	}
	public void bindEntityManagerFactoriesToRegistry(Map<String, EntityManagerFactory> entityManagerFactories,
			MeterRegistry registry) {
		entityManagerFactories.forEach((name, factory) -> bindEntityManagerFactoryToRegistry(name, factory, registry));
	}
	private void bindEntityManagerFactoryToRegistry(String beanName, EntityManagerFactory entityManagerFactory,
			MeterRegistry registry) {
		String entityManagerFactoryName = getEntityManagerFactoryName(beanName);
		try {
			new HibernateMetrics(entityManagerFactory.unwrap(SessionFactory.class), entityManagerFactoryName,
					Collections.emptyList())
				.bindTo(registry);
		}
		catch (PersistenceException ex) {
			// Continue
		}
	}
	/**
	 * Get the name of an {@link EntityManagerFactory} based on its {@code beanName}.
	 * @param beanName the name of the {@link EntityManagerFactory} bean
	 * @return a name for the given entity manager factory
	 */
	private String getEntityManagerFactoryName(String beanName) {
		if (beanName.length() > ENTITY_MANAGER_FACTORY_SUFFIX.length()
				&& StringUtils.endsWithIgnoreCase(beanName, ENTITY_MANAGER_FACTORY_SUFFIX)) {
			return beanName.substring(0, beanName.length() - ENTITY_MANAGER_FACTORY_SUFFIX.length());
		}
		return beanName;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.metrics.orm.jpa;
/*
package org.springframework.boot.actuate.autoconfigure.metrics;
/**
public final class MeterValue {
	private final Object value;
	MeterValue(double value) {
		this.value = value;
	}
	MeterValue(Duration value) {
		this.value = value;
	}
	/**
	 * Return the underlying value in form suitable to apply to the given meter type.
	 * @param meterType the meter type
	 * @return the value or {@code null} if the value cannot be applied
	 */
	public Double getValue(Type meterType) {
		if (meterType == Type.DISTRIBUTION_SUMMARY) {
			return getDistributionSummaryValue();
		}
		if (meterType == Type.TIMER) {
			Long timerValue = getTimerValue();
			if (timerValue != null) {
				return timerValue.doubleValue();
			}
		}
		return null;
	}
	private Double getDistributionSummaryValue() {
		if (this.value instanceof Double doubleValue) {
			return doubleValue;
		}
		return null;
	}
	private Long getTimerValue() {
		if (this.value instanceof Double doubleValue) {
			return TimeUnit.MILLISECONDS.toNanos(doubleValue.longValue());
		}
		if (this.value instanceof Duration duration) {
			return duration.toNanos();
		}
		return null;
	}
	/**
	 * Return a new {@link MeterValue} instance for the given String value. The value may
	 * contain a simple number, or a {@link DurationStyle duration style string}.
	 * @param value the source value
	 * @return a {@link MeterValue} instance
	 */
	public static MeterValue valueOf(String value) {
		Duration duration = safeParseDuration(value);
		if (duration != null) {
			return new MeterValue(duration);
		}
		return new MeterValue(Double.parseDouble(value));
	}
	/**
	 * Return a new {@link MeterValue} instance for the given double value.
	 * @param value the source value
	 * @return a {@link MeterValue} instance
	 * @since 2.3.0
	 */
	public static MeterValue valueOf(double value) {
		return new MeterValue(value);
	}
	private static Duration safeParseDuration(String value) {
		try {
			return DurationStyle.detectAndParse(value);
		}
		catch (IllegalArgumentException ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cassandra;
/**
@AutoConfiguration(after = { CassandraAutoConfiguration.class, CassandraDataAutoConfiguration.class,
		CassandraReactiveHealthContributorAutoConfiguration.class })
@ConditionalOnClass(CqlSession.class)
@ConditionalOnEnabledHealthIndicator('cassandra')
@Import(CassandraDriverConfiguration.class)
public class CassandraHealthContributorAutoConfiguration {
}
/*
package org.springframework.boot.actuate.autoconfigure.cassandra;
/**
class CassandraHealthContributorConfigurations {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(CqlSession.class)
	static class CassandraDriverConfiguration
			extends CompositeHealthContributorConfiguration<CassandraDriverHealthIndicator, CqlSession> {
		CassandraDriverConfiguration() {
			super(CassandraDriverHealthIndicator::new);
		}
		@Bean
		@ConditionalOnMissingBean(name = { 'cassandraHealthIndicator', 'cassandraHealthContributor' })
		HealthContributor cassandraHealthContributor(Map<String, CqlSession> sessions) {
			return createContributor(sessions);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(CqlSession.class)
	static class CassandraReactiveDriverConfiguration extends
			CompositeReactiveHealthContributorConfiguration<CassandraDriverReactiveHealthIndicator, CqlSession> {
		CassandraReactiveDriverConfiguration() {
			super(CassandraDriverReactiveHealthIndicator::new);
		}
		@Bean
		@ConditionalOnMissingBean(name = { 'cassandraHealthIndicator', 'cassandraHealthContributor' })
		ReactiveHealthContributor cassandraHealthContributor(Map<String, CqlSession> sessions) {
			return createContributor(sessions);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cassandra;
/**
@AutoConfiguration(after = CassandraReactiveDataAutoConfiguration.class)
@ConditionalOnClass({ CqlSession.class, Flux.class })
@ConditionalOnEnabledHealthIndicator('cassandra')
@Import(CassandraReactiveDriverConfiguration.class)
public class CassandraReactiveHealthContributorAutoConfiguration {
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.cassandra;
/*
package org.springframework.boot.actuate.autoconfigure.audit;
/**
@AutoConfiguration(after = AuditAutoConfiguration.class)
@ConditionalOnAvailableEndpoint(AuditEventsEndpoint.class)
public class AuditEventsEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(AuditEventRepository.class)
	public AuditEventsEndpoint auditEventsEndpoint(AuditEventRepository auditEventRepository) {
		return new AuditEventsEndpoint(auditEventRepository);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.audit;
/*
package org.springframework.boot.actuate.autoconfigure.audit;
/**
@AutoConfiguration
@ConditionalOnBean(AuditEventRepository.class)
@ConditionalOnProperty(prefix = 'management.auditevents', name = 'enabled', matchIfMissing = true)
public class AuditAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(AbstractAuditListener.class)
	public AuditListener auditListener(AuditEventRepository auditEventRepository) {
		return new AuditListener(auditEventRepository);
	}
	@Bean
	@ConditionalOnClass(name = 'org.springframework.security.authentication.event.AbstractAuthenticationEvent')
	@ConditionalOnMissingBean(AbstractAuthenticationAuditListener.class)
	public AuthenticationAuditListener authenticationAuditListener() {
		return new AuthenticationAuditListener();
	}
	@Bean
	@ConditionalOnClass(name = 'org.springframework.security.access.event.AbstractAuthorizationEvent')
	@ConditionalOnMissingBean(AbstractAuthorizationAuditListener.class)
	public AuthorizationAuditListener authorizationAuditListener() {
		return new AuthorizationAuditListener();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
@Order(Ordered.LOWEST_PRECEDENCE)
class AvailabilityProbesHealthEndpointGroupsPostProcessor implements HealthEndpointGroupsPostProcessor {
	private final boolean addAdditionalPaths;
	AvailabilityProbesHealthEndpointGroupsPostProcessor(Environment environment) {
		this.addAdditionalPaths = 'true'
			.equalsIgnoreCase(environment.getProperty('management.endpoint.health.probes.add-additional-paths'));
	}
	@Override
	public HealthEndpointGroups postProcessHealthEndpointGroups(HealthEndpointGroups groups) {
		return new AvailabilityProbesHealthEndpointGroups(groups, this.addAdditionalPaths);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class DelegatingAvailabilityProbesHealthEndpointGroup implements HealthEndpointGroup {
	private final HealthEndpointGroup delegate;
	private final AdditionalHealthEndpointPath additionalPath;
	DelegatingAvailabilityProbesHealthEndpointGroup(HealthEndpointGroup delegate,
			AdditionalHealthEndpointPath additionalPath) {
		Assert.notNull(delegate, 'Delegate must not be null');
		this.delegate = delegate;
		this.additionalPath = additionalPath;
	}
	@Override
	public boolean isMember(String name) {
		return this.delegate.isMember(name);
	}
	@Override
	public boolean showComponents(SecurityContext securityContext) {
		return this.delegate.showComponents(securityContext);
	}
	@Override
	public boolean showDetails(SecurityContext securityContext) {
		return this.delegate.showDetails(securityContext);
	}
	@Override
	public StatusAggregator getStatusAggregator() {
		return this.delegate.getStatusAggregator();
	}
	@Override
	public HttpCodeStatusMapper getHttpCodeStatusMapper() {
		return this.delegate.getHttpCodeStatusMapper();
	}
	@Override
	public AdditionalHealthEndpointPath getAdditionalPath() {
		return this.additionalPath;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class AvailabilityProbesHealthEndpointGroups implements HealthEndpointGroups {
	private final HealthEndpointGroups groups;
	private final Map<String, HealthEndpointGroup> probeGroups;
	private final Set<String> names;
	private static final String LIVENESS = 'liveness';
	private static final String READINESS = 'readiness';
	AvailabilityProbesHealthEndpointGroups(HealthEndpointGroups groups, boolean addAdditionalPaths) {
		Assert.notNull(groups, 'Groups must not be null');
		this.groups = groups;
		this.probeGroups = createProbeGroups(addAdditionalPaths);
		Set<String> names = new LinkedHashSet<>(groups.getNames());
		names.addAll(this.probeGroups.keySet());
		this.names = Collections.unmodifiableSet(names);
	}
	private Map<String, HealthEndpointGroup> createProbeGroups(boolean addAdditionalPaths) {
		Map<String, HealthEndpointGroup> probeGroups = new LinkedHashMap<>();
		probeGroups.put(LIVENESS, getOrCreateProbeGroup(addAdditionalPaths, LIVENESS, '/livez', 'livenessState'));
		probeGroups.put(READINESS, getOrCreateProbeGroup(addAdditionalPaths, READINESS, '/readyz', 'readinessState'));
		return Collections.unmodifiableMap(probeGroups);
	}
	private HealthEndpointGroup getOrCreateProbeGroup(boolean addAdditionalPath, String name, String path,
			String members) {
		HealthEndpointGroup group = this.groups.get(name);
		if (group != null) {
			return determineAdditionalPathForExistingGroup(addAdditionalPath, path, group);
		}
		AdditionalHealthEndpointPath additionalPath = (!addAdditionalPath) ? null
				: AdditionalHealthEndpointPath.of(WebServerNamespace.SERVER, path);
		return new AvailabilityProbesHealthEndpointGroup(additionalPath, members);
	}
	private HealthEndpointGroup determineAdditionalPathForExistingGroup(boolean addAdditionalPath, String path,
			HealthEndpointGroup group) {
		if (addAdditionalPath && group.getAdditionalPath() == null) {
			AdditionalHealthEndpointPath additionalPath = AdditionalHealthEndpointPath.of(WebServerNamespace.SERVER,
					path);
			return new DelegatingAvailabilityProbesHealthEndpointGroup(group, additionalPath);
		}
		return group;
	}
	@Override
	public HealthEndpointGroup getPrimary() {
		return this.groups.getPrimary();
	}
	@Override
	public Set<String> getNames() {
		return this.names;
	}
	@Override
	public HealthEndpointGroup get(String name) {
		HealthEndpointGroup group = this.groups.get(name);
		if (group == null || isProbeGroup(name)) {
			group = this.probeGroups.get(name);
		}
		return group;
	}
	private boolean isProbeGroup(String name) {
		return name.equals(LIVENESS) || name.equals(READINESS);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
@AutoConfiguration(after = { AvailabilityHealthContributorAutoConfiguration.class,
		ApplicationAvailabilityAutoConfiguration.class })
@Conditional(AvailabilityProbesAutoConfiguration.ProbesCondition.class)
public class AvailabilityProbesAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(name = 'livenessStateHealthIndicator')
	public LivenessStateHealthIndicator livenessStateHealthIndicator(ApplicationAvailability applicationAvailability) {
		return new LivenessStateHealthIndicator(applicationAvailability);
	}
	@Bean
	@ConditionalOnMissingBean(name = 'readinessStateHealthIndicator')
	public ReadinessStateHealthIndicator readinessStateHealthIndicator(
			ApplicationAvailability applicationAvailability) {
		return new ReadinessStateHealthIndicator(applicationAvailability);
	}
	@Bean
	public AvailabilityProbesHealthEndpointGroupsPostProcessor availabilityProbesHealthEndpointGroupsPostProcessor(
			Environment environment) {
		return new AvailabilityProbesHealthEndpointGroupsPostProcessor(environment);
	}
	/**
	 * {@link SpringBootCondition} to enable or disable probes.
	 * <p>
	 * Probes are enabled if the dedicated configuration property is enabled or if the
	 * Kubernetes cloud environment is detected/enforced.
	 */
	static class ProbesCondition extends SpringBootCondition {
		private static final String ENABLED_PROPERTY = 'management.endpoint.health.probes.enabled';
		private static final String DEPRECATED_ENABLED_PROPERTY = 'management.health.probes.enabled';
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			Environment environment = context.getEnvironment();
			ConditionMessage.Builder message = ConditionMessage.forCondition('Probes availability');
			ConditionOutcome outcome = onProperty(environment, message, ENABLED_PROPERTY);
			if (outcome != null) {
				return outcome;
			}
			outcome = onProperty(environment, message, DEPRECATED_ENABLED_PROPERTY);
			if (outcome != null) {
				return outcome;
			}
			if (CloudPlatform.getActive(environment) == CloudPlatform.KUBERNETES) {
				return ConditionOutcome.match(message.because('running on Kubernetes'));
			}
			if (CloudPlatform.getActive(environment) == CloudPlatform.CLOUD_FOUNDRY) {
				return ConditionOutcome.match(message.because('running on Cloud Foundry'));
			}
			return ConditionOutcome.noMatch(message.because('not running on a supported cloud platform'));
		}
		private ConditionOutcome onProperty(Environment environment, ConditionMessage.Builder message,
				String propertyName) {
			String enabled = environment.getProperty(propertyName);
			if (enabled != null) {
				boolean match = !'false'.equalsIgnoreCase(enabled);
				return new ConditionOutcome(match, message.because('"' + propertyName + '" set to "' + enabled + '"'));
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
class AvailabilityProbesHealthEndpointGroup implements HealthEndpointGroup {
	private final Set<String> members;
	private final AdditionalHealthEndpointPath additionalPath;
	AvailabilityProbesHealthEndpointGroup(AdditionalHealthEndpointPath additionalPath, String... members) {
		this.members = new HashSet<>(Arrays.asList(members));
		this.additionalPath = additionalPath;
	}
	@Override
	public boolean isMember(String name) {
		return this.members.contains(name);
	}
	@Override
	public boolean showComponents(SecurityContext securityContext) {
		return false;
	}
	@Override
	public boolean showDetails(SecurityContext securityContext) {
		return false;
	}
	@Override
	public StatusAggregator getStatusAggregator() {
		return StatusAggregator.getDefault();
	}
	@Override
	public HttpCodeStatusMapper getHttpCodeStatusMapper() {
		return HttpCodeStatusMapper.DEFAULT;
	}
	@Override
	public AdditionalHealthEndpointPath getAdditionalPath() {
		return this.additionalPath;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.availability;
/**
@AutoConfiguration(after = ApplicationAvailabilityAutoConfiguration.class)
public class AvailabilityHealthContributorAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(name = 'livenessStateHealthIndicator')
	@ConditionalOnProperty(prefix = 'management.health.livenessstate', name = 'enabled', havingValue = 'true')
	public LivenessStateHealthIndicator livenessStateHealthIndicator(ApplicationAvailability applicationAvailability) {
		return new LivenessStateHealthIndicator(applicationAvailability);
	}
	@Bean
	@ConditionalOnMissingBean(name = 'readinessStateHealthIndicator')
	@ConditionalOnProperty(prefix = 'management.health.readinessstate', name = 'enabled', havingValue = 'true')
	public ReadinessStateHealthIndicator readinessStateHealthIndicator(
			ApplicationAvailability applicationAvailability) {
		return new ReadinessStateHealthIndicator(applicationAvailability);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.availability;
/*
package org.springframework.boot.actuate.autoconfigure.mail;
/**
@AutoConfiguration(after = MailSenderAutoConfiguration.class)
@ConditionalOnClass(JavaMailSenderImpl.class)
@ConditionalOnBean(JavaMailSenderImpl.class)
@ConditionalOnEnabledHealthIndicator('mail')
public class MailHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<MailHealthIndicator, JavaMailSenderImpl> {
	public MailHealthContributorAutoConfiguration() {
		super(MailHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'mailHealthIndicator', 'mailHealthContributor' })
	public HealthContributor mailHealthContributor(Map<String, JavaMailSenderImpl> mailSenders) {
		return createContributor(mailSenders);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.mail;
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
@ManagementContextConfiguration(proxyBeanMethods = false)
@ConditionalOnClass({ RequestMatcher.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
public class SecurityRequestMatchersManagementContextConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(DispatcherServlet.class)
	@ConditionalOnBean(DispatcherServletPath.class)
	public static class MvcRequestMatcherConfiguration {
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnClass(DispatcherServlet.class)
		public RequestMatcherProvider requestMatcherProvider(DispatcherServletPath servletPath) {
			return new AntPathRequestMatcherProvider(servletPath::getRelativePath);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ResourceConfig.class)
	@ConditionalOnMissingClass('org.springframework.web.servlet.DispatcherServlet')
	@ConditionalOnBean(JerseyApplicationPath.class)
	public static class JerseyRequestMatcherConfiguration {
		@Bean
		public RequestMatcherProvider requestMatcherProvider(JerseyApplicationPath applicationPath) {
			return new AntPathRequestMatcherProvider(applicationPath::getRelativePath);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
@AutoConfiguration(before = SecurityAutoConfiguration.class,
		after = { HealthEndpointAutoConfiguration.class, InfoEndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, OAuth2ClientAutoConfiguration.class,
				OAuth2ResourceServerAutoConfiguration.class, Saml2RelyingPartyAutoConfiguration.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnDefaultWebSecurity
public class ManagementWebSecurityAutoConfiguration {
	@Bean
	@Order(SecurityProperties.BASIC_AUTH_ORDER)
	SecurityFilterChain managementSecurityFilterChain(Environment environment, HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> {
			requests.requestMatchers(healthMatcher(), additionalHealthPathsMatcher()).permitAll();
			requests.anyRequest().authenticated();
		});
		if (ClassUtils.isPresent('org.springframework.web.servlet.DispatcherServlet', null)) {
			http.cors(withDefaults());
		}
		http.formLogin(withDefaults());
		http.httpBasic(withDefaults());
		return http.build();
	}
	private RequestMatcher healthMatcher() {
		return EndpointRequest.to(HealthEndpoint.class);
	}
	private RequestMatcher additionalHealthPathsMatcher() {
		return EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, HealthEndpoint.class);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/**
public final class EndpointRequest {
	private static final RequestMatcher EMPTY_MATCHER = (request) -> false;
	private EndpointRequest() {
	}
	/**
	 * Returns a matcher that includes all {@link Endpoint actuator endpoints}. It also
	 * includes the links endpoint which is present at the base path of the actuator
	 * endpoints. The {@link EndpointRequestMatcher#excluding(Class...) excluding} method
	 * can be used to further remove specific endpoints if required. For example:
	 * <pre class='code'>
	 * EndpointRequest.toAnyEndpoint().excluding(ShutdownEndpoint.class)
	 * </pre>
	 * @return the configured {@link RequestMatcher}
	 */
	public static EndpointRequestMatcher toAnyEndpoint() {
		return new EndpointRequestMatcher(true);
	}
	/**
	 * Returns a matcher that includes the specified {@link Endpoint actuator endpoints}.
	 * For example: <pre class='code'>
	 * EndpointRequest.to(ShutdownEndpoint.class, HealthEndpoint.class)
	 * </pre>
	 * @param endpoints the endpoints to include
	 * @return the configured {@link RequestMatcher}
	 */
	public static EndpointRequestMatcher to(Class<?>... endpoints) {
		return new EndpointRequestMatcher(endpoints, false);
	}
	/**
	 * Returns a matcher that includes the specified {@link Endpoint actuator endpoints}.
	 * For example: <pre class='code'>
	 * EndpointRequest.to('shutdown', 'health')
	 * </pre>
	 * @param endpoints the endpoints to include
	 * @return the configured {@link RequestMatcher}
	 */
	public static EndpointRequestMatcher to(String... endpoints) {
		return new EndpointRequestMatcher(endpoints, false);
	}
	/**
	 * Returns a matcher that matches only on the links endpoint. It can be used when
	 * security configuration for the links endpoint is different from the other
	 * {@link Endpoint actuator endpoints}. The
	 * {@link EndpointRequestMatcher#excludingLinks() excludingLinks} method can be used
	 * in combination with this to remove the links endpoint from
	 * {@link EndpointRequest#toAnyEndpoint() toAnyEndpoint}. For example:
	 * <pre class='code'>
	 * EndpointRequest.toLinks()
	 * </pre>
	 * @return the configured {@link RequestMatcher}
	 */
	public static LinksRequestMatcher toLinks() {
		return new LinksRequestMatcher();
	}
	/**
	 * Returns a matcher that includes additional paths under a {@link WebServerNamespace}
	 * for the specified {@link Endpoint actuator endpoints}. For example:
	 * <pre class='code'>
	 * EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, 'health')
	 * </pre>
	 * @param webServerNamespace the web server namespace
	 * @param endpoints the endpoints to include
	 * @return the configured {@link RequestMatcher}
	 * @since 3.4.0
	 */
	public static AdditionalPathsEndpointRequestMatcher toAdditionalPaths(WebServerNamespace webServerNamespace,
			Class<?>... endpoints) {
		return new AdditionalPathsEndpointRequestMatcher(webServerNamespace, endpoints);
	}
	/**
	 * Returns a matcher that includes additional paths under a {@link WebServerNamespace}
	 * for the specified {@link Endpoint actuator endpoints}. For example:
	 * <pre class='code'>
	 * EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, HealthEndpoint.class)
	 * </pre>
	 * @param webServerNamespace the web server namespace
	 * @param endpoints the endpoints to include
	 * @return the configured {@link RequestMatcher}
	 * @since 3.4.0
	 */
	public static AdditionalPathsEndpointRequestMatcher toAdditionalPaths(WebServerNamespace webServerNamespace,
			String... endpoints) {
		return new AdditionalPathsEndpointRequestMatcher(webServerNamespace, endpoints);
	}
	/**
	 * Base class for supported request matchers.
	 */
	private abstract static class AbstractRequestMatcher
			extends ApplicationContextRequestMatcher<WebApplicationContext> {
		private volatile RequestMatcher delegate;
		private volatile ManagementPortType managementPortType;
		AbstractRequestMatcher() {
			super(WebApplicationContext.class);
		}
		@Override
		protected boolean ignoreApplicationContext(WebApplicationContext applicationContext) {
			ManagementPortType managementPortType = this.managementPortType;
			if (managementPortType == null) {
				managementPortType = ManagementPortType.get(applicationContext.getEnvironment());
				this.managementPortType = managementPortType;
			}
			return ignoreApplicationContext(applicationContext, managementPortType);
		}
		protected boolean ignoreApplicationContext(WebApplicationContext applicationContext,
				ManagementPortType managementPortType) {
			return managementPortType == ManagementPortType.DIFFERENT
					&& !hasWebServerNamespace(applicationContext, WebServerNamespace.MANAGEMENT);
		}
		protected final boolean hasWebServerNamespace(ApplicationContext applicationContext,
				WebServerNamespace webServerNamespace) {
			return WebServerApplicationContext.hasServerNamespace(applicationContext, webServerNamespace.getValue())
					|| (webServerNamespace.equals(WebServerNamespace.SERVER)
							&& !(applicationContext instanceof WebServerApplicationContext));
		}
		@Override
		protected final void initialized(Supplier<WebApplicationContext> context) {
			this.delegate = createDelegate(context.get());
		}
		@Override
		protected final boolean matches(HttpServletRequest request, Supplier<WebApplicationContext> context) {
			return this.delegate.matches(request);
		}
		private RequestMatcher createDelegate(WebApplicationContext context) {
			try {
				return createDelegate(context, new RequestMatcherFactory());
			}
			catch (NoSuchBeanDefinitionException ex) {
				return EMPTY_MATCHER;
			}
		}
		protected abstract RequestMatcher createDelegate(WebApplicationContext context,
				RequestMatcherFactory requestMatcherFactory);
		protected final List<RequestMatcher> getDelegateMatchers(RequestMatcherFactory requestMatcherFactory,
				RequestMatcherProvider matcherProvider, Set<String> paths) {
			return paths.stream()
				.map((path) -> requestMatcherFactory.antPath(matcherProvider, path, '/**'))
				.collect(Collectors.toCollection(ArrayList::new));
		}
		protected List<RequestMatcher> getLinksMatchers(RequestMatcherFactory requestMatcherFactory,
				RequestMatcherProvider matcherProvider, String basePath) {
			List<RequestMatcher> linksMatchers = new ArrayList<>();
			linksMatchers.add(requestMatcherFactory.antPath(matcherProvider, basePath));
			linksMatchers.add(requestMatcherFactory.antPath(matcherProvider, basePath, '/'));
			return linksMatchers;
		}
		protected RequestMatcherProvider getRequestMatcherProvider(WebApplicationContext context) {
			try {
				return context.getBean(RequestMatcherProvider.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				return AntPathRequestMatcher::new;
			}
		}
		protected final String toString(List<Object> endpoints, String emptyValue) {
			return (!endpoints.isEmpty()) ? endpoints.stream()
				.map(this::getEndpointId)
				.map(Object::toString)
				.collect(Collectors.joining(', ', '[', ']')) : emptyValue;
		}
		protected final EndpointId getEndpointId(Object source) {
			if (source instanceof EndpointId endpointId) {
				return endpointId;
			}
			if (source instanceof String string) {
				return EndpointId.of(string);
			}
			if (source instanceof Class<?> sourceClass) {
				return getEndpointId(sourceClass);
			}
			throw new IllegalStateException('Unsupported source ' + source);
		}
		private EndpointId getEndpointId(Class<?> source) {
			MergedAnnotation<Endpoint> annotation = MergedAnnotations.from(source).get(Endpoint.class);
			Assert.state(annotation.isPresent(), () -> 'Class ' + source + ' is not annotated with @Endpoint');
			return EndpointId.of(annotation.getString('id'));
		}
	}
	/**
	 * The request matcher used to match against {@link Endpoint actuator endpoints}.
	 */
	public static final class EndpointRequestMatcher extends AbstractRequestMatcher {
		private final List<Object> includes;
		private final List<Object> excludes;
		private final boolean includeLinks;
		private EndpointRequestMatcher(boolean includeLinks) {
			this(Collections.emptyList(), Collections.emptyList(), includeLinks);
		}
		private EndpointRequestMatcher(Class<?>[] endpoints, boolean includeLinks) {
			this(Arrays.asList((Object[]) endpoints), Collections.emptyList(), includeLinks);
		}
		private EndpointRequestMatcher(String[] endpoints, boolean includeLinks) {
			this(Arrays.asList((Object[]) endpoints), Collections.emptyList(), includeLinks);
		}
		private EndpointRequestMatcher(List<Object> includes, List<Object> excludes, boolean includeLinks) {
			this.includes = includes;
			this.excludes = excludes;
			this.includeLinks = includeLinks;
		}
		public EndpointRequestMatcher excluding(Class<?>... endpoints) {
			List<Object> excludes = new ArrayList<>(this.excludes);
			excludes.addAll(Arrays.asList((Object[]) endpoints));
			return new EndpointRequestMatcher(this.includes, excludes, this.includeLinks);
		}
		public EndpointRequestMatcher excluding(String... endpoints) {
			List<Object> excludes = new ArrayList<>(this.excludes);
			excludes.addAll(Arrays.asList((Object[]) endpoints));
			return new EndpointRequestMatcher(this.includes, excludes, this.includeLinks);
		}
		public EndpointRequestMatcher excludingLinks() {
			return new EndpointRequestMatcher(this.includes, this.excludes, false);
		}
		@Override
		protected RequestMatcher createDelegate(WebApplicationContext context,
				RequestMatcherFactory requestMatcherFactory) {
			PathMappedEndpoints endpoints = context.getBean(PathMappedEndpoints.class);
			RequestMatcherProvider matcherProvider = getRequestMatcherProvider(context);
			Set<String> paths = new LinkedHashSet<>();
			if (this.includes.isEmpty()) {
				paths.addAll(endpoints.getAllPaths());
			}
			streamPaths(this.includes, endpoints).forEach(paths::add);
			streamPaths(this.excludes, endpoints).forEach(paths::remove);
			List<RequestMatcher> delegateMatchers = getDelegateMatchers(requestMatcherFactory, matcherProvider, paths);
			String basePath = endpoints.getBasePath();
			if (this.includeLinks && StringUtils.hasText(basePath)) {
				delegateMatchers.addAll(getLinksMatchers(requestMatcherFactory, matcherProvider, basePath));
			}
			return new OrRequestMatcher(delegateMatchers);
		}
		private Stream<String> streamPaths(List<Object> source, PathMappedEndpoints endpoints) {
			return source.stream().filter(Objects::nonNull).map(this::getEndpointId).map(endpoints::getPath);
		}
		@Override
		public String toString() {
			return String.format('EndpointRequestMatcher includes=%s, excludes=%s, includeLinks=%s',
					toString(this.includes, '[*]'), toString(this.excludes, '[]'), this.includeLinks);
		}
	}
	/**
	 * The request matcher used to match against the links endpoint.
	 */
	public static final class LinksRequestMatcher extends AbstractRequestMatcher {
		@Override
		protected RequestMatcher createDelegate(WebApplicationContext context,
				RequestMatcherFactory requestMatcherFactory) {
			WebEndpointProperties properties = context.getBean(WebEndpointProperties.class);
			String basePath = properties.getBasePath();
			if (StringUtils.hasText(basePath)) {
				return new OrRequestMatcher(
						getLinksMatchers(requestMatcherFactory, getRequestMatcherProvider(context), basePath));
			}
			return EMPTY_MATCHER;
		}
		@Override
		public String toString() {
			return String.format('LinksRequestMatcher');
		}
	}
	/**
	 * The request matcher used to match against additional paths for {@link Endpoint
	 * actuator endpoints}.
	 */
	public static class AdditionalPathsEndpointRequestMatcher extends AbstractRequestMatcher {
		private final WebServerNamespace webServerNamespace;
		private final List<Object> endpoints;
		AdditionalPathsEndpointRequestMatcher(WebServerNamespace webServerNamespace, String... endpoints) {
			this(webServerNamespace, Arrays.asList((Object[]) endpoints));
		}
		AdditionalPathsEndpointRequestMatcher(WebServerNamespace webServerNamespace, Class<?>... endpoints) {
			this(webServerNamespace, Arrays.asList((Object[]) endpoints));
		}
		private AdditionalPathsEndpointRequestMatcher(WebServerNamespace webServerNamespace, List<Object> endpoints) {
			Assert.notNull(webServerNamespace, '"webServerNamespace" must not be null');
			Assert.notNull(endpoints, '"endpoints" must not be null');
			Assert.notEmpty(endpoints, '"endpoints" must not be empty');
			this.webServerNamespace = webServerNamespace;
			this.endpoints = endpoints;
		}
		@Override
		protected boolean ignoreApplicationContext(WebApplicationContext applicationContext,
				ManagementPortType managementPortType) {
			return !hasWebServerNamespace(applicationContext, this.webServerNamespace);
		}
		@Override
		protected RequestMatcher createDelegate(WebApplicationContext context,
				RequestMatcherFactory requestMatcherFactory) {
			PathMappedEndpoints endpoints = context.getBean(PathMappedEndpoints.class);
			RequestMatcherProvider matcherProvider = getRequestMatcherProvider(context);
			Set<String> paths = this.endpoints.stream()
				.filter(Objects::nonNull)
				.map(this::getEndpointId)
				.flatMap((endpointId) -> streamAdditionalPaths(endpoints, endpointId))
				.collect(Collectors.toCollection(LinkedHashSet::new));
			List<RequestMatcher> delegateMatchers = getDelegateMatchers(requestMatcherFactory, matcherProvider, paths);
			return (!CollectionUtils.isEmpty(delegateMatchers)) ? new OrRequestMatcher(delegateMatchers)
					: EMPTY_MATCHER;
		}
		private Stream<String> streamAdditionalPaths(PathMappedEndpoints pathMappedEndpoints, EndpointId endpointId) {
			return pathMappedEndpoints.getAdditionalPaths(this.webServerNamespace, endpointId).stream();
		}
		@Override
		public String toString() {
			return String.format('AdditionalPathsEndpointRequestMatcher endpoints=%s, webServerNamespace=%s',
					toString(this.endpoints, ''), this.webServerNamespace);
		}
	}
	/**
	 * Factory used to create a {@link RequestMatcher}.
	 */
	private static final class RequestMatcherFactory {
		RequestMatcher antPath(RequestMatcherProvider matcherProvider, String... parts) {
			StringBuilder pattern = new StringBuilder();
			for (String part : parts) {
				pattern.append(part);
			}
			return matcherProvider.getRequestMatcher(pattern.toString());
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.security.servlet;
/*
package org.springframework.boot.actuate.autoconfigure.security.reactive;
/**
@AutoConfiguration(before = ReactiveSecurityAutoConfiguration.class,
		after = { HealthEndpointAutoConfiguration.class, InfoEndpointAutoConfiguration.class,
				WebEndpointAutoConfiguration.class, ReactiveOAuth2ClientAutoConfiguration.class,
				ReactiveOAuth2ResourceServerAutoConfiguration.class,
				ReactiveUserDetailsServiceAutoConfiguration.class })
@ConditionalOnClass({ EnableWebFluxSecurity.class, WebFilterChainProxy.class })
@ConditionalOnMissingBean({ SecurityWebFilterChain.class, WebFilterChainProxy.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
public class ReactiveManagementWebSecurityAutoConfiguration {
	@Bean
	public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, PreFlightRequestHandler handler) {
		http.authorizeExchange((exchanges) -> {
			exchanges.matchers(healthMatcher(), additionalHealthPathsMatcher()).permitAll();
			exchanges.anyExchange().authenticated();
		});
		PreFlightRequestWebFilter filter = new PreFlightRequestWebFilter(handler);
		http.addFilterAt(filter, SecurityWebFiltersOrder.CORS);
		http.httpBasic(withDefaults());
		http.formLogin(withDefaults());
		return http.build();
	}
	private ServerWebExchangeMatcher healthMatcher() {
		return EndpointRequest.to(HealthEndpoint.class);
	}
	private ServerWebExchangeMatcher additionalHealthPathsMatcher() {
		return EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, HealthEndpoint.class);
	}
	@Bean
	@ConditionalOnMissingBean({ ReactiveAuthenticationManager.class, ReactiveUserDetailsService.class })
	ReactiveAuthenticationManager denyAllAuthenticationManager() {
		return (authentication) -> Mono.error(new UsernameNotFoundException(authentication.getName()));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.security.reactive;
/**
public final class EndpointRequest {
	private static final ServerWebExchangeMatcher EMPTY_MATCHER = (request) -> MatchResult.notMatch();
	private EndpointRequest() {
	}
	/**
	 * Returns a matcher that includes all {@link Endpoint actuator endpoints}. It also
	 * includes the links endpoint which is present at the base path of the actuator
	 * endpoints. The {@link EndpointServerWebExchangeMatcher#excluding(Class...)
	 * excluding} method can be used to further remove specific endpoints if required. For
	 * example: <pre class='code'>
	 * EndpointRequest.toAnyEndpoint().excluding(ShutdownEndpoint.class)
	 * </pre>
	 * @return the configured {@link ServerWebExchangeMatcher}
	 */
	public static EndpointServerWebExchangeMatcher toAnyEndpoint() {
		return new EndpointServerWebExchangeMatcher(true);
	}
	/**
	 * Returns a matcher that includes the specified {@link Endpoint actuator endpoints}.
	 * For example: <pre class='code'>
	 * EndpointRequest.to(ShutdownEndpoint.class, HealthEndpoint.class)
	 * </pre>
	 * @param endpoints the endpoints to include
	 * @return the configured {@link ServerWebExchangeMatcher}
	 */
	public static EndpointServerWebExchangeMatcher to(Class<?>... endpoints) {
		return new EndpointServerWebExchangeMatcher(endpoints, false);
	}
	/**
	 * Returns a matcher that includes the specified {@link Endpoint actuator endpoints}.
	 * For example: <pre class='code'>
	 * EndpointRequest.to('shutdown', 'health')
	 * </pre>
	 * @param endpoints the endpoints to include
	 * @return the configured {@link ServerWebExchangeMatcher}
	 */
	public static EndpointServerWebExchangeMatcher to(String... endpoints) {
		return new EndpointServerWebExchangeMatcher(endpoints, false);
	}
	/**
	 * Returns a matcher that matches only on the links endpoint. It can be used when
	 * security configuration for the links endpoint is different from the other
	 * {@link Endpoint actuator endpoints}. The
	 * {@link EndpointServerWebExchangeMatcher#excludingLinks() excludingLinks} method can
	 * be used in combination with this to remove the links endpoint from
	 * {@link EndpointRequest#toAnyEndpoint() toAnyEndpoint}. For example:
	 * <pre class='code'>
	 * EndpointRequest.toLinks()
	 * </pre>
	 * @return the configured {@link ServerWebExchangeMatcher}
	 */
	public static LinksServerWebExchangeMatcher toLinks() {
		return new LinksServerWebExchangeMatcher();
	}
	/**
	 * Returns a matcher that includes additional paths under a {@link WebServerNamespace}
	 * for the specified {@link Endpoint actuator endpoints}. For example:
	 * <pre class='code'>
	 * EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, 'health')
	 * </pre>
	 * @param webServerNamespace the web server namespace
	 * @param endpoints the endpoints to include
	 * @return the configured {@link RequestMatcher}
	 * @since 3.4.0
	 */
	public static AdditionalPathsEndpointServerWebExchangeMatcher toAdditionalPaths(
			WebServerNamespace webServerNamespace, Class<?>... endpoints) {
		return new AdditionalPathsEndpointServerWebExchangeMatcher(webServerNamespace, endpoints);
	}
	/**
	 * Returns a matcher that includes additional paths under a {@link WebServerNamespace}
	 * for the specified {@link Endpoint actuator endpoints}. For example:
	 * <pre class='code'>
	 * EndpointRequest.toAdditionalPaths(WebServerNamespace.SERVER, HealthEndpoint.class)
	 * </pre>
	 * @param webServerNamespace the web server namespace
	 * @param endpoints the endpoints to include
	 * @return the configured {@link RequestMatcher}
	 * @since 3.4.0
	 */
	public static AdditionalPathsEndpointServerWebExchangeMatcher toAdditionalPaths(
			WebServerNamespace webServerNamespace, String... endpoints) {
		return new AdditionalPathsEndpointServerWebExchangeMatcher(webServerNamespace, endpoints);
	}
	/**
	 * Base class for supported request matchers.
	 */
	private abstract static class AbstractWebExchangeMatcher<C> extends ApplicationContextServerWebExchangeMatcher<C> {
		private volatile ServerWebExchangeMatcher delegate;
		private volatile ManagementPortType managementPortType;
		AbstractWebExchangeMatcher(Class<? extends C> contextClass) {
			super(contextClass);
		}
		@Override
		protected void initialized(Supplier<C> supplier) {
			this.delegate = createDelegate(supplier);
		}
		private ServerWebExchangeMatcher createDelegate(Supplier<C> context) {
			try {
				return createDelegate(context.get());
			}
			catch (NoSuchBeanDefinitionException ex) {
				return EMPTY_MATCHER;
			}
		}
		protected abstract ServerWebExchangeMatcher createDelegate(C context);
		protected final List<ServerWebExchangeMatcher> getDelegateMatchers(Set<String> paths) {
			return paths.stream().map(this::getDelegateMatcher).collect(Collectors.toCollection(ArrayList::new));
		}
		private PathPatternParserServerWebExchangeMatcher getDelegateMatcher(String path) {
			return new PathPatternParserServerWebExchangeMatcher(path + '/**');
		}
		@Override
		protected Mono<MatchResult> matches(ServerWebExchange exchange, Supplier<C> context) {
			return this.delegate.matches(exchange);
		}
		@Override
		protected boolean ignoreApplicationContext(ApplicationContext applicationContext) {
			ManagementPortType managementPortType = this.managementPortType;
			if (managementPortType == null) {
				managementPortType = ManagementPortType.get(applicationContext.getEnvironment());
				this.managementPortType = managementPortType;
			}
			return ignoreApplicationContext(applicationContext, managementPortType);
		}
		protected boolean ignoreApplicationContext(ApplicationContext applicationContext,
				ManagementPortType managementPortType) {
			return managementPortType == ManagementPortType.DIFFERENT
					&& !hasWebServerNamespace(applicationContext, WebServerNamespace.MANAGEMENT);
		}
		protected final boolean hasWebServerNamespace(ApplicationContext applicationContext,
				WebServerNamespace webServerNamespace) {
			if (applicationContext.getParent() == null) {
				return WebServerNamespace.SERVER.equals(webServerNamespace);
			}
			String parentContextId = applicationContext.getParent().getId();
			return applicationContext.getId().equals(parentContextId + ':' + webServerNamespace);
		}
		protected final String toString(List<Object> endpoints, String emptyValue) {
			return (!endpoints.isEmpty()) ? endpoints.stream()
				.map(this::getEndpointId)
				.map(Object::toString)
				.collect(Collectors.joining(', ', '[', ']')) : emptyValue;
		}
		protected final EndpointId getEndpointId(Object source) {
			if (source instanceof EndpointId endpointId) {
				return endpointId;
			}
			if (source instanceof String string) {
				return EndpointId.of(string);
			}
			if (source instanceof Class) {
				return getEndpointId((Class<?>) source);
			}
			throw new IllegalStateException('Unsupported source ' + source);
		}
		private EndpointId getEndpointId(Class<?> source) {
			MergedAnnotation<Endpoint> annotation = MergedAnnotations.from(source).get(Endpoint.class);
			Assert.state(annotation.isPresent(), () -> 'Class ' + source + ' is not annotated with @Endpoint');
			return EndpointId.of(annotation.getString('id'));
		}
	}
	/**
	 * The {@link ServerWebExchangeMatcher} used to match against {@link Endpoint actuator
	 * endpoints}.
	 */
	public static final class EndpointServerWebExchangeMatcher extends AbstractWebExchangeMatcher<PathMappedEndpoints> {
		private final List<Object> includes;
		private final List<Object> excludes;
		private final boolean includeLinks;
		private EndpointServerWebExchangeMatcher(boolean includeLinks) {
			this(Collections.emptyList(), Collections.emptyList(), includeLinks);
		}
		private EndpointServerWebExchangeMatcher(Class<?>[] endpoints, boolean includeLinks) {
			this(Arrays.asList((Object[]) endpoints), Collections.emptyList(), includeLinks);
		}
		private EndpointServerWebExchangeMatcher(String[] endpoints, boolean includeLinks) {
			this(Arrays.asList((Object[]) endpoints), Collections.emptyList(), includeLinks);
		}
		private EndpointServerWebExchangeMatcher(List<Object> includes, List<Object> excludes, boolean includeLinks) {
			super(PathMappedEndpoints.class);
			this.includes = includes;
			this.excludes = excludes;
			this.includeLinks = includeLinks;
		}
		public EndpointServerWebExchangeMatcher excluding(Class<?>... endpoints) {
			List<Object> excludes = new ArrayList<>(this.excludes);
			excludes.addAll(Arrays.asList((Object[]) endpoints));
			return new EndpointServerWebExchangeMatcher(this.includes, excludes, this.includeLinks);
		}
		public EndpointServerWebExchangeMatcher excluding(String... endpoints) {
			List<Object> excludes = new ArrayList<>(this.excludes);
			excludes.addAll(Arrays.asList((Object[]) endpoints));
			return new EndpointServerWebExchangeMatcher(this.includes, excludes, this.includeLinks);
		}
		public EndpointServerWebExchangeMatcher excludingLinks() {
			return new EndpointServerWebExchangeMatcher(this.includes, this.excludes, false);
		}
		@Override
		protected ServerWebExchangeMatcher createDelegate(PathMappedEndpoints endpoints) {
			Set<String> paths = new LinkedHashSet<>();
			if (this.includes.isEmpty()) {
				paths.addAll(endpoints.getAllPaths());
			}
			streamPaths(this.includes, endpoints).forEach(paths::add);
			streamPaths(this.excludes, endpoints).forEach(paths::remove);
			List<ServerWebExchangeMatcher> delegateMatchers = getDelegateMatchers(paths);
			if (this.includeLinks && StringUtils.hasText(endpoints.getBasePath())) {
				delegateMatchers.add(new LinksServerWebExchangeMatcher());
			}
			return new OrServerWebExchangeMatcher(delegateMatchers);
		}
		private Stream<String> streamPaths(List<Object> source, PathMappedEndpoints endpoints) {
			return source.stream().filter(Objects::nonNull).map(this::getEndpointId).map(endpoints::getPath);
		}
		@Override
		public String toString() {
			return String.format('EndpointRequestMatcher includes=%s, excludes=%s, includeLinks=%s',
					toString(this.includes, '[*]'), toString(this.excludes, '[]'), this.includeLinks);
		}
	}
	/**
	 * The {@link ServerWebExchangeMatcher} used to match against the links endpoint.
	 */
	public static final class LinksServerWebExchangeMatcher extends AbstractWebExchangeMatcher<WebEndpointProperties> {
		private LinksServerWebExchangeMatcher() {
			super(WebEndpointProperties.class);
		}
		@Override
		protected ServerWebExchangeMatcher createDelegate(WebEndpointProperties properties) {
			if (StringUtils.hasText(properties.getBasePath())) {
				return new OrServerWebExchangeMatcher(
						new PathPatternParserServerWebExchangeMatcher(properties.getBasePath()),
						new PathPatternParserServerWebExchangeMatcher(properties.getBasePath() + '/'));
			}
			return EMPTY_MATCHER;
		}
		@Override
		public String toString() {
			return String.format('LinksServerWebExchangeMatcher');
		}
	}
	/**
	 * The {@link ServerWebExchangeMatcher} used to match against additional paths for
	 * {@link Endpoint actuator endpoints}.
	 */
	public static class AdditionalPathsEndpointServerWebExchangeMatcher
			extends AbstractWebExchangeMatcher<PathMappedEndpoints> {
		private final WebServerNamespace webServerNamespace;
		private final List<Object> endpoints;
		AdditionalPathsEndpointServerWebExchangeMatcher(WebServerNamespace webServerNamespace, String... endpoints) {
			this(webServerNamespace, Arrays.asList((Object[]) endpoints));
		}
		AdditionalPathsEndpointServerWebExchangeMatcher(WebServerNamespace webServerNamespace, Class<?>... endpoints) {
			this(webServerNamespace, Arrays.asList((Object[]) endpoints));
		}
		private AdditionalPathsEndpointServerWebExchangeMatcher(WebServerNamespace webServerNamespace,
				List<Object> endpoints) {
			super(PathMappedEndpoints.class);
			Assert.notNull(webServerNamespace, '"webServerNamespace" must not be null');
			Assert.notNull(endpoints, '"endpoints" must not be null');
			Assert.notEmpty(endpoints, '"endpoints" must not be empty');
			this.webServerNamespace = webServerNamespace;
			this.endpoints = endpoints;
		}
		@Override
		protected boolean ignoreApplicationContext(ApplicationContext applicationContext,
				ManagementPortType managementPortType) {
			return !hasWebServerNamespace(applicationContext, this.webServerNamespace);
		}
		@Override
		protected ServerWebExchangeMatcher createDelegate(PathMappedEndpoints endpoints) {
			Set<String> paths = this.endpoints.stream()
				.filter(Objects::nonNull)
				.map(this::getEndpointId)
				.flatMap((endpointId) -> streamAdditionalPaths(endpoints, endpointId))
				.collect(Collectors.toCollection(LinkedHashSet::new));
			List<ServerWebExchangeMatcher> delegateMatchers = getDelegateMatchers(paths);
			return (!CollectionUtils.isEmpty(delegateMatchers)) ? new OrServerWebExchangeMatcher(delegateMatchers)
					: EMPTY_MATCHER;
		}
		private Stream<String> streamAdditionalPaths(PathMappedEndpoints pathMappedEndpoints, EndpointId endpointId) {
			return pathMappedEndpoints.getAdditionalPaths(this.webServerNamespace, endpointId).stream();
		}
		@Override
		public String toString() {
			return String.format('AdditionalPathsEndpointServerWebExchangeMatcher endpoints=%s, webServerNamespace=%s',
					toString(this.endpoints, ''), this.webServerNamespace);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.security.reactive;
/*
package org.springframework.boot.actuate.autoconfigure.couchbase;
/**
@AutoConfiguration(
		after = { CouchbaseAutoConfiguration.class, CouchbaseReactiveHealthContributorAutoConfiguration.class })
@ConditionalOnClass(Cluster.class)
@ConditionalOnBean(Cluster.class)
@ConditionalOnEnabledHealthIndicator('couchbase')
public class CouchbaseHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<CouchbaseHealthIndicator, Cluster> {
	public CouchbaseHealthContributorAutoConfiguration() {
		super(CouchbaseHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'couchbaseHealthIndicator', 'couchbaseHealthContributor' })
	public HealthContributor couchbaseHealthContributor(Map<String, Cluster> clusters) {
		return createContributor(clusters);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.couchbase;
/**
@AutoConfiguration(after = CouchbaseAutoConfiguration.class)
@ConditionalOnClass({ Cluster.class, Flux.class })
@ConditionalOnBean(Cluster.class)
@ConditionalOnEnabledHealthIndicator('couchbase')
public class CouchbaseReactiveHealthContributorAutoConfiguration
		extends CompositeReactiveHealthContributorConfiguration<CouchbaseReactiveHealthIndicator, Cluster> {
	public CouchbaseReactiveHealthContributorAutoConfiguration() {
		super(CouchbaseReactiveHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'couchbaseHealthIndicator', 'couchbaseHealthContributor' })
	public ReactiveHealthContributor couchbaseHealthContributor(Map<String, Cluster> clusters) {
		return createContributor(clusters);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.couchbase;
/*
package org.springframework.boot.actuate.autoconfigure.session;
/**
@AutoConfiguration(after = SessionAutoConfiguration.class)
@ConditionalOnClass(Session.class)
@ConditionalOnAvailableEndpoint(SessionsEndpoint.class)
public class SessionsEndpointAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	@ConditionalOnBean(SessionRepository.class)
	static class ServletSessionEndpointConfiguration {
		@Bean
		@ConditionalOnMissingBean
		SessionsEndpoint sessionEndpoint(SessionRepository<?> sessionRepository,
				ObjectProvider<FindByIndexNameSessionRepository<?>> indexedSessionRepository) {
			return new SessionsEndpoint(sessionRepository, indexedSessionRepository.getIfAvailable());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	@ConditionalOnBean(ReactiveSessionRepository.class)
	static class ReactiveSessionEndpointConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ReactiveSessionsEndpoint sessionsEndpoint(ReactiveSessionRepository<?> sessionRepository,
				ObjectProvider<ReactiveFindByIndexNameSessionRepository<?>> indexedSessionRepository) {
			return new ReactiveSessionsEndpoint(sessionRepository, indexedSessionRepository.getIfAvailable());
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.session;
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@EndpointExtension(filter = CloudFoundryEndpointFilter.class)
public @interface EndpointCloudFoundryExtension {
	/**
	 * The class of the endpoint to provide a Cloud Foundry specific extension for.
	 * @return the class of the endpoint to extend
	 */
	@AliasFor(annotation = EndpointExtension.class, attribute = 'endpoint')
	Class<?> endpoint();
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
class CloudFoundryEndpointExposureOutcomeContributor implements EndpointExposureOutcomeContributor {
	private static final String PROPERTY = 'management.endpoints.cloud-foundry.exposure';
	private final IncludeExcludeEndpointFilter<?> filter;
	CloudFoundryEndpointExposureOutcomeContributor(Environment environment) {
		this.filter = (!CloudPlatform.CLOUD_FOUNDRY.isActive(environment)) ? null
				: new IncludeExcludeEndpointFilter<>(ExposableEndpoint.class, environment, PROPERTY, '*');
	}
	@Override
	public ConditionOutcome getExposureOutcome(EndpointId endpointId, Set<EndpointExposure> exposures,
			Builder message) {
		if (exposures.contains(EndpointExposure.WEB) && this.filter != null && this.filter.match(endpointId)) {
			return ConditionOutcome.match(message.because('marked as exposed by a "' + PROPERTY + '" property'));
		}
		return null;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
class CloudFoundryEndpointFilter extends DiscovererEndpointFilter {
	protected CloudFoundryEndpointFilter() {
		super(CloudFoundryWebEndpointDiscoverer.class);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
public class SecurityResponse {
	private final HttpStatus status;
	private final String message;
	public SecurityResponse(HttpStatus status) {
		this(status, null);
	}
	public SecurityResponse(HttpStatus status, String message) {
		this.status = status;
		this.message = message;
	}
	public HttpStatus getStatus() {
		return this.status;
	}
	public String getMessage() {
		return this.message;
	}
	public static SecurityResponse success() {
		return new SecurityResponse(HttpStatus.OK);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
@EndpointCloudFoundryExtension(endpoint = InfoEndpoint.class)
public class CloudFoundryInfoEndpointWebExtension {
	private final InfoEndpoint delegate;
	public CloudFoundryInfoEndpointWebExtension(InfoEndpoint delegate) {
		this.delegate = delegate;
	}
	@ReadOperation
	public Map<String, Object> info() {
		return this.delegate.info();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
@AutoConfiguration(after = { ServletManagementContextAutoConfiguration.class, HealthEndpointAutoConfiguration.class,
		InfoEndpointAutoConfiguration.class })
@ConditionalOnProperty(prefix = 'management.cloudfoundry', name = 'enabled', matchIfMissing = true)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(DispatcherServlet.class)
@ConditionalOnBean(DispatcherServlet.class)
@ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)
public class CloudFoundryActuatorAutoConfiguration {
	private static final String BASE_PATH = '/cloudfoundryapplication';
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnAvailableEndpoint
	@ConditionalOnBean({ HealthEndpoint.class, HealthEndpointWebExtension.class })
	public CloudFoundryHealthEndpointWebExtension cloudFoundryHealthEndpointWebExtension(
			HealthEndpointWebExtension healthEndpointWebExtension) {
		return new CloudFoundryHealthEndpointWebExtension(healthEndpointWebExtension);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnAvailableEndpoint
	@ConditionalOnBean({ InfoEndpoint.class, GitProperties.class })
	public CloudFoundryInfoEndpointWebExtension cloudFoundryInfoEndpointWebExtension(GitProperties properties,
			ObjectProvider<InfoContributor> infoContributors) {
		List<InfoContributor> contributors = infoContributors.orderedStream()
			.map((infoContributor) -> (infoContributor instanceof GitInfoContributor)
					? new GitInfoContributor(properties, InfoPropertiesInfoContributor.Mode.FULL) : infoContributor)
			.toList();
		return new CloudFoundryInfoEndpointWebExtension(new InfoEndpoint(contributors));
	}
	@Bean
	@SuppressWarnings('removal')
	public CloudFoundryWebEndpointServletHandlerMapping cloudFoundryWebEndpointServletHandlerMapping(
			ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes,
			RestTemplateBuilder restTemplateBuilder,
			org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier servletEndpointsSupplier,
			org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier controllerEndpointsSupplier,
			ApplicationContext applicationContext) {
		CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer(applicationContext,
				parameterMapper, endpointMediaTypes, null, Collections.emptyList(), Collections.emptyList(),
				Collections.emptyList());
		CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor(restTemplateBuilder,
				applicationContext.getEnvironment());
		Collection<ExposableWebEndpoint> webEndpoints = discoverer.getEndpoints();
		List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>();
		allEndpoints.addAll(webEndpoints);
		allEndpoints.addAll(servletEndpointsSupplier.getEndpoints());
		allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints());
		return new CloudFoundryWebEndpointServletHandlerMapping(new EndpointMapping(BASE_PATH), webEndpoints,
				endpointMediaTypes, getCorsConfiguration(), securityInterceptor, allEndpoints);
	}
	private CloudFoundrySecurityInterceptor getSecurityInterceptor(RestTemplateBuilder restTemplateBuilder,
			Environment environment) {
		CloudFoundrySecurityService cloudfoundrySecurityService = getCloudFoundrySecurityService(restTemplateBuilder,
				environment);
		TokenValidator tokenValidator = new TokenValidator(cloudfoundrySecurityService);
		return new CloudFoundrySecurityInterceptor(tokenValidator, cloudfoundrySecurityService,
				environment.getProperty('vcap.application.application_id'));
	}
	private CloudFoundrySecurityService getCloudFoundrySecurityService(RestTemplateBuilder restTemplateBuilder,
			Environment environment) {
		String cloudControllerUrl = environment.getProperty('vcap.application.cf_api');
		boolean skipSslValidation = environment.getProperty('management.cloudfoundry.skip-ssl-validation',
				Boolean.class, false);
		return (cloudControllerUrl != null)
				? new CloudFoundrySecurityService(restTemplateBuilder, cloudControllerUrl, skipSslValidation) : null;
	}
	private CorsConfiguration getCorsConfiguration() {
		CorsConfiguration corsConfiguration = new CorsConfiguration();
		corsConfiguration.addAllowedOrigin(CorsConfiguration.ALL);
		corsConfiguration.setAllowedMethods(Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name()));
		corsConfiguration
			.setAllowedHeaders(Arrays.asList(HttpHeaders.AUTHORIZATION, 'X-Cf-App-Instance', HttpHeaders.CONTENT_TYPE));
		return corsConfiguration;
	}
	/**
	 * {@link WebSecurityConfigurer} to tell Spring Security to ignore cloudfoundry
	 * specific paths. The Cloud foundry endpoints are protected by their own security
	 * interceptor.
	 */
	@ConditionalOnClass({ WebSecurityCustomizer.class, WebSecurity.class })
	@Configuration(proxyBeanMethods = false)
	public static class IgnoredCloudFoundryPathsWebSecurityConfiguration {
		@Bean
		IgnoredCloudFoundryPathsWebSecurityCustomizer ignoreCloudFoundryPathsWebSecurityCustomizer(
				CloudFoundryWebEndpointServletHandlerMapping handlerMapping) {
			return new IgnoredCloudFoundryPathsWebSecurityCustomizer(handlerMapping);
		}
	}
	@Order(SecurityProperties.IGNORED_ORDER)
	static class IgnoredCloudFoundryPathsWebSecurityCustomizer implements WebSecurityCustomizer {
		private final PathMappedEndpoints pathMappedEndpoints;
		IgnoredCloudFoundryPathsWebSecurityCustomizer(CloudFoundryWebEndpointServletHandlerMapping handlerMapping) {
			this.pathMappedEndpoints = new PathMappedEndpoints(BASE_PATH, handlerMapping::getAllEndpoints);
		}
		@Override
		public void customize(WebSecurity web) {
			List<RequestMatcher> requestMatchers = new ArrayList<>();
			this.pathMappedEndpoints.getAllPaths()
				.forEach((path) -> requestMatchers.add(new AntPathRequestMatcher(path + '/**')));
			requestMatchers.add(new AntPathRequestMatcher(BASE_PATH));
			requestMatchers.add(new AntPathRequestMatcher(BASE_PATH + '/'));
			web.ignoring().requestMatchers(new OrRequestMatcher(requestMatchers));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
@EndpointCloudFoundryExtension(endpoint = HealthEndpoint.class)
public class CloudFoundryHealthEndpointWebExtension {
	private final HealthEndpointWebExtension delegate;
	public CloudFoundryHealthEndpointWebExtension(HealthEndpointWebExtension delegate) {
		this.delegate = delegate;
	}
	@ReadOperation
	public WebEndpointResponse<HealthComponent> health(ApiVersion apiVersion) {
		return this.delegate.health(apiVersion, null, SecurityContext.NONE, true);
	}
	@ReadOperation
	public WebEndpointResponse<HealthComponent> health(ApiVersion apiVersion,
			@Selector(match = Match.ALL_REMAINING) String... path) {
		return this.delegate.health(apiVersion, null, SecurityContext.NONE, true, path);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class SkipSslVerificationHttpRequestFactory extends SimpleClientHttpRequestFactory {
	@Override
	protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException {
		if (connection instanceof HttpsURLConnection httpsURLConnection) {
			prepareHttpsConnection(httpsURLConnection);
		}
		super.prepareConnection(connection, httpMethod);
	}
	private void prepareHttpsConnection(HttpsURLConnection connection) {
		connection.setHostnameVerifier(new SkipHostnameVerifier());
		try {
			connection.setSSLSocketFactory(createSslSocketFactory());
		}
		catch (Exception ex) {
			// Ignore
		}
	}
	private SSLSocketFactory createSslSocketFactory() throws Exception {
		SSLContext context = SSLContext.getInstance('TLS');
		context.init(null, new TrustManager[] { new SkipX509TrustManager() }, new SecureRandom());
		return context.getSocketFactory();
	}
	private static final class SkipHostnameVerifier implements HostnameVerifier {
		@Override
		public boolean verify(String s, SSLSession sslSession) {
			return true;
		}
	}
	private static final class SkipX509TrustManager implements X509TrustManager {
		@Override
		public X509Certificate[] getAcceptedIssuers() {
			return new X509Certificate[0];
		}
		@Override
		public void checkClientTrusted(X509Certificate[] chain, String authType) {
		}
		@Override
		public void checkServerTrusted(X509Certificate[] chain, String authType) {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class TokenValidator {
	private final CloudFoundrySecurityService securityService;
	private Map<String, String> tokenKeys;
	TokenValidator(CloudFoundrySecurityService cloudFoundrySecurityService) {
		this.securityService = cloudFoundrySecurityService;
	}
	void validate(Token token) {
		validateAlgorithm(token);
		validateKeyIdAndSignature(token);
		validateExpiry(token);
		validateIssuer(token);
		validateAudience(token);
	}
	private void validateAlgorithm(Token token) {
		String algorithm = token.getSignatureAlgorithm();
		if (algorithm == null) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE, 'Signing algorithm cannot be null');
		}
		if (!algorithm.equals('RS256')) {
			throw new CloudFoundryAuthorizationException(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM,
					'Signing algorithm ' + algorithm + ' not supported');
		}
	}
	private void validateKeyIdAndSignature(Token token) {
		String keyId = token.getKeyId();
		if (this.tokenKeys == null || !hasValidKeyId(keyId)) {
			this.tokenKeys = this.securityService.fetchTokenKeys();
			if (!hasValidKeyId(keyId)) {
				throw new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID,
						'Key Id present in token header does not match');
			}
		}
		if (!hasValidSignature(token, this.tokenKeys.get(keyId))) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE,
					'RSA Signature did not match content');
		}
	}
	private boolean hasValidKeyId(String tokenKey) {
		return this.tokenKeys.containsKey(tokenKey);
	}
	private boolean hasValidSignature(Token token, String key) {
		try {
			PublicKey publicKey = getPublicKey(key);
			Signature signature = Signature.getInstance('SHA256withRSA');
			signature.initVerify(publicKey);
			signature.update(token.getContent());
			return signature.verify(token.getSignature());
		}
		catch (GeneralSecurityException ex) {
			return false;
		}
	}
	private PublicKey getPublicKey(String key) throws NoSuchAlgorithmException, InvalidKeySpecException {
		key = key.replace('-----BEGIN PUBLIC KEY-----\n', '');
		key = key.replace('-----END PUBLIC KEY-----', '');
		key = key.trim().replace('\n', '');
		byte[] bytes = Base64.getDecoder().decode(key);
		X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes);
		return KeyFactory.getInstance('RSA').generatePublic(keySpec);
	}
	private void validateExpiry(Token token) {
		long currentTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());
		if (currentTime > token.getExpiry()) {
			throw new CloudFoundryAuthorizationException(Reason.TOKEN_EXPIRED, 'Token expired');
		}
	}
	private void validateIssuer(Token token) {
		String uaaUrl = this.securityService.getUaaUrl();
		String issuerUri = String.format('%s/oauth/token', uaaUrl);
		if (!issuerUri.equals(token.getIssuer())) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_ISSUER,
					'Token issuer does not match ' + uaaUrl + '/oauth/token');
		}
	}
	private void validateAudience(Token token) {
		if (!token.getScope().contains('actuator.read')) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_AUDIENCE,
					'Token does not have audience actuator');
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundrySecurityService {
	private final RestTemplate restTemplate;
	private final String cloudControllerUrl;
	private String uaaUrl;
	CloudFoundrySecurityService(RestTemplateBuilder restTemplateBuilder, String cloudControllerUrl,
			boolean skipSslValidation) {
		Assert.notNull(restTemplateBuilder, 'RestTemplateBuilder must not be null');
		Assert.notNull(cloudControllerUrl, 'CloudControllerUrl must not be null');
		if (skipSslValidation) {
			restTemplateBuilder = restTemplateBuilder.requestFactory(SkipSslVerificationHttpRequestFactory.class);
		}
		this.restTemplate = restTemplateBuilder.build();
		this.cloudControllerUrl = cloudControllerUrl;
	}
	/**
	 * Return the access level that should be granted to the given token.
	 * @param token the token
	 * @param applicationId the cloud foundry application ID
	 * @return the access level that should be granted
	 * @throws CloudFoundryAuthorizationException if the token is not authorized
	 */
	AccessLevel getAccessLevel(String token, String applicationId) throws CloudFoundryAuthorizationException {
		try {
			URI uri = getPermissionsUri(applicationId);
			RequestEntity<?> request = RequestEntity.get(uri).header('Authorization', 'bearer ' + token).build();
			Map<?, ?> body = this.restTemplate.exchange(request, Map.class).getBody();
			if (Boolean.TRUE.equals(body.get('read_sensitive_data'))) {
				return AccessLevel.FULL;
			}
			return AccessLevel.RESTRICTED;
		}
		catch (HttpClientErrorException ex) {
			if (ex.getStatusCode().equals(HttpStatus.FORBIDDEN)) {
				throw new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED, 'Access denied');
			}
			throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN, 'Invalid token', ex);
		}
		catch (HttpServerErrorException ex) {
			throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, 'Cloud controller not reachable');
		}
	}
	private URI getPermissionsUri(String applicationId) {
		try {
			return new URI(this.cloudControllerUrl + '/v2/apps/' + applicationId + '/permissions');
		}
		catch (URISyntaxException ex) {
			throw new IllegalStateException(ex);
		}
	}
	/**
	 * Return all token keys known by the UAA.
	 * @return a list of token keys
	 */
	Map<String, String> fetchTokenKeys() {
		try {
			return extractTokenKeys(this.restTemplate.getForObject(getUaaUrl() + '/token_keys', Map.class));
		}
		catch (HttpStatusCodeException ex) {
			throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, 'UAA not reachable');
		}
	}
	private Map<String, String> extractTokenKeys(Map<?, ?> response) {
		Map<String, String> tokenKeys = new HashMap<>();
		for (Object key : (List<?>) response.get('keys')) {
			Map<?, ?> tokenKey = (Map<?, ?>) key;
			tokenKeys.put((String) tokenKey.get('kid'), (String) tokenKey.get('value'));
		}
		return tokenKeys;
	}
	/**
	 * Return the URL of the UAA.
	 * @return the UAA url
	 */
	String getUaaUrl() {
		if (this.uaaUrl == null) {
			try {
				Map<?, ?> response = this.restTemplate.getForObject(this.cloudControllerUrl + '/info', Map.class);
				this.uaaUrl = (String) response.get('token_endpoint');
			}
			catch (HttpStatusCodeException ex) {
				throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE,
						'Unable to fetch token keys from UAA');
			}
		}
		return this.uaaUrl;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
class CloudFoundrySecurityInterceptor {
	private static final Log logger = LogFactory.getLog(CloudFoundrySecurityInterceptor.class);
	private final TokenValidator tokenValidator;
	private final CloudFoundrySecurityService cloudFoundrySecurityService;
	private final String applicationId;
	private static final SecurityResponse SUCCESS = SecurityResponse.success();
	CloudFoundrySecurityInterceptor(TokenValidator tokenValidator,
			CloudFoundrySecurityService cloudFoundrySecurityService, String applicationId) {
		this.tokenValidator = tokenValidator;
		this.cloudFoundrySecurityService = cloudFoundrySecurityService;
		this.applicationId = applicationId;
	}
	SecurityResponse preHandle(HttpServletRequest request, EndpointId endpointId) {
		if (CorsUtils.isPreFlightRequest(request)) {
			return SecurityResponse.success();
		}
		try {
			if (!StringUtils.hasText(this.applicationId)) {
				throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE,
						'Application id is not available');
			}
			if (this.cloudFoundrySecurityService == null) {
				throw new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE,
						'Cloud controller URL is not available');
			}
			if (HttpMethod.OPTIONS.matches(request.getMethod())) {
				return SUCCESS;
			}
			check(request, endpointId);
		}
		catch (Exception ex) {
			logger.error(ex);
			if (ex instanceof CloudFoundryAuthorizationException cfException) {
				return new SecurityResponse(cfException.getStatusCode(),
						'{\'security_error\':\'' + cfException.getMessage() + '\'}');
			}
			return new SecurityResponse(HttpStatus.INTERNAL_SERVER_ERROR, ex.getMessage());
		}
		return SecurityResponse.success();
	}
	private void check(HttpServletRequest request, EndpointId endpointId) {
		Token token = getToken(request);
		this.tokenValidator.validate(token);
		AccessLevel accessLevel = this.cloudFoundrySecurityService.getAccessLevel(token.toString(), this.applicationId);
		if (!accessLevel.isAccessAllowed((endpointId != null) ? endpointId.toLowerCaseString() : '')) {
			throw new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED, 'Access denied');
		}
		request.setAttribute(AccessLevel.REQUEST_ATTRIBUTE, accessLevel);
	}
	private Token getToken(HttpServletRequest request) {
		String authorization = request.getHeader('Authorization');
		String bearerPrefix = 'bearer ';
		if (authorization == null || !authorization.toLowerCase(Locale.ENGLISH).startsWith(bearerPrefix)) {
			throw new CloudFoundryAuthorizationException(Reason.MISSING_AUTHORIZATION,
					'Authorization header is missing or invalid');
		}
		return new Token(authorization.substring(bearerPrefix.length()));
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.servlet;
/**
@ImportRuntimeHints(CloudFoundryWebEndpointServletHandlerMappingRuntimeHints.class)
class CloudFoundryWebEndpointServletHandlerMapping extends AbstractWebMvcEndpointHandlerMapping {
	private static final Log logger = LogFactory.getLog(CloudFoundryWebEndpointServletHandlerMapping.class);
	private final CloudFoundrySecurityInterceptor securityInterceptor;
	private final EndpointLinksResolver linksResolver;
	private final Collection<ExposableEndpoint<?>> allEndpoints;
	CloudFoundryWebEndpointServletHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableWebEndpoint> endpoints, EndpointMediaTypes endpointMediaTypes,
			CorsConfiguration corsConfiguration, CloudFoundrySecurityInterceptor securityInterceptor,
			Collection<ExposableEndpoint<?>> allEndpoints) {
		super(endpointMapping, endpoints, endpointMediaTypes, corsConfiguration, true);
		this.securityInterceptor = securityInterceptor;
		this.linksResolver = new EndpointLinksResolver(allEndpoints);
		this.allEndpoints = allEndpoints;
	}
	@Override
	protected ServletWebOperation wrapServletWebOperation(ExposableWebEndpoint endpoint, WebOperation operation,
			ServletWebOperation servletWebOperation) {
		return new SecureServletWebOperation(servletWebOperation, this.securityInterceptor, endpoint.getEndpointId());
	}
	@Override
	protected LinksHandler getLinksHandler() {
		return new CloudFoundryLinksHandler();
	}
	Collection<ExposableEndpoint<?>> getAllEndpoints() {
		return this.allEndpoints;
	}
	class CloudFoundryLinksHandler implements LinksHandler {
		@Override
		@ResponseBody
		@Reflective
		public Map<String, Map<String, Link>> links(HttpServletRequest request, HttpServletResponse response) {
			SecurityResponse securityResponse = CloudFoundryWebEndpointServletHandlerMapping.this.securityInterceptor
				.preHandle(request, null);
			if (!securityResponse.getStatus().equals(HttpStatus.OK)) {
				sendFailureResponse(response, securityResponse);
			}
			AccessLevel accessLevel = (AccessLevel) request.getAttribute(AccessLevel.REQUEST_ATTRIBUTE);
			Map<String, Link> filteredLinks = new LinkedHashMap<>();
			if (accessLevel == null) {
				return Collections.singletonMap('_links', filteredLinks);
			}
			Map<String, Link> links = CloudFoundryWebEndpointServletHandlerMapping.this.linksResolver
				.resolveLinks(request.getRequestURL().toString());
			filteredLinks = links.entrySet()
				.stream()
				.filter((e) -> e.getKey().equals('self') || accessLevel.isAccessAllowed(e.getKey()))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
			return Collections.singletonMap('_links', filteredLinks);
		}
		@Override
		public String toString() {
			return 'Actuator root web endpoint';
		}
		private void sendFailureResponse(HttpServletResponse response, SecurityResponse securityResponse) {
			try {
				response.sendError(securityResponse.getStatus().value(), securityResponse.getMessage());
			}
			catch (Exception ex) {
				logger.debug('Failed to send error response', ex);
			}
		}
	}
	/**
	 * {@link ServletWebOperation} wrapper to add security.
	 */
	private static class SecureServletWebOperation implements ServletWebOperation {
		private final ServletWebOperation delegate;
		private final CloudFoundrySecurityInterceptor securityInterceptor;
		private final EndpointId endpointId;
		SecureServletWebOperation(ServletWebOperation delegate, CloudFoundrySecurityInterceptor securityInterceptor,
				EndpointId endpointId) {
			this.delegate = delegate;
			this.securityInterceptor = securityInterceptor;
			this.endpointId = endpointId;
		}
		@Override
		public Object handle(HttpServletRequest request, Map<String, String> body) {
			SecurityResponse securityResponse = this.securityInterceptor.preHandle(request, this.endpointId);
			if (!securityResponse.getStatus().equals(HttpStatus.OK)) {
				return new ResponseEntity<Object>(securityResponse.getMessage(), securityResponse.getStatus());
			}
			return this.delegate.handle(request, body);
		}
	}
	static class CloudFoundryWebEndpointServletHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {
		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.reflectiveRegistrar.registerRuntimeHints(hints, CloudFoundryLinksHandler.class);
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), Link.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
public class Token {
	private final String encoded;
	private final String signature;
	private final Map<String, Object> header;
	private final Map<String, Object> claims;
	public Token(String encoded) {
		this.encoded = encoded;
		int firstPeriod = encoded.indexOf(".");
		int lastPeriod = encoded.lastIndexOf(".");
		if (firstPeriod <= 0 || lastPeriod <= firstPeriod) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN,
					'JWT must have header, body and signature');
		}
		this.header = parseJson(encoded.substring(0, firstPeriod));
		this.claims = parseJson(encoded.substring(firstPeriod + 1, lastPeriod));
		this.signature = encoded.substring(lastPeriod + 1);
		if (!StringUtils.hasLength(this.signature)) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN,
					'Token must have non-empty crypto segment');
		}
	}
	private Map<String, Object> parseJson(String base64) {
		try {
			byte[] bytes = Base64.getUrlDecoder().decode(base64);
			return JsonParserFactory.getJsonParser().parseMap(new String(bytes, StandardCharsets.UTF_8));
		}
		catch (RuntimeException ex) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN, 'Token could not be parsed', ex);
		}
	}
	public byte[] getContent() {
		return this.encoded.substring(0, this.encoded.lastIndexOf(".")).getBytes();
	}
	public byte[] getSignature() {
		return Base64.getUrlDecoder().decode(this.signature);
	}
	public String getSignatureAlgorithm() {
		return getRequired(this.header, 'alg', String.class);
	}
	public String getIssuer() {
		return getRequired(this.claims, 'iss', String.class);
	}
	public long getExpiry() {
		return getRequired(this.claims, 'exp', Integer.class).longValue();
	}
	@SuppressWarnings('unchecked')
	public List<String> getScope() {
		return getRequired(this.claims, 'scope', List.class);
	}
	public String getKeyId() {
		return getRequired(this.header, 'kid', String.class);
	}
	@SuppressWarnings('unchecked')
	private <T> T getRequired(Map<String, Object> map, String key, Class<T> type) {
		Object value = map.get(key);
		if (value == null) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN, 'Unable to get value from key ' + key);
		}
		if (!type.isInstance(value)) {
			throw new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN,
					'Unexpected value type from key ' + key + ' value ' + value);
		}
		return (T) value;
	}
	@Override
	public String toString() {
		return this.encoded;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
public enum AccessLevel {
	/**
	 * Restricted access to a limited set of endpoints.
	 */
	RESTRICTED('', 'health', 'info'),
	/**
	 * Full access to all endpoints.
	 */
	FULL;
	/**
	 * The request attribute used to store the {@link AccessLevel}.
	 */
	public static final String REQUEST_ATTRIBUTE = 'cloudFoundryAccessLevel';
	private final List<String> ids;
	AccessLevel(String... ids) {
		this.ids = Arrays.asList(ids);
	}
	/**
	 * Returns if the access level should allow access to the specified ID.
	 * @param id the ID to check
	 * @return {@code true} if access is allowed
	 */
	public boolean isAccessAllowed(String id) {
		return this.ids.isEmpty() || this.ids.contains(id);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
@ImportRuntimeHints(CloudFoundryWebEndpointDiscovererRuntimeHints.class)
public class CloudFoundryWebEndpointDiscoverer extends WebEndpointDiscoverer {
	/**
	 * Create a new {@link WebEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param endpointMediaTypes the endpoint media types
	 * @param endpointPathMappers the endpoint path mappers
	 * @param invokerAdvisors invoker advisors to apply
	 * @param endpointFilters endpoint filters to apply
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of
	 * {@link #CloudFoundryWebEndpointDiscoverer(ApplicationContext, ParameterValueMapper, EndpointMediaTypes, List, Collection, Collection, Collection)}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	public CloudFoundryWebEndpointDiscoverer(ApplicationContext applicationContext,
			ParameterValueMapper parameterValueMapper, EndpointMediaTypes endpointMediaTypes,
			List<PathMapper> endpointPathMappers, Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<ExposableWebEndpoint>> endpointFilters) {
		this(applicationContext, parameterValueMapper, endpointMediaTypes, endpointPathMappers, invokerAdvisors,
				endpointFilters, Collections.emptyList());
	}
	/**
	 * Create a new {@link WebEndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param endpointMediaTypes the endpoint media types
	 * @param endpointPathMappers the endpoint path mappers
	 * @param invokerAdvisors invoker advisors to apply
	 * @param endpointFilters endpoint filters to apply
	 * @param operationFilters operation filters to apply
	 * @since 3.4.0
	 */
	public CloudFoundryWebEndpointDiscoverer(ApplicationContext applicationContext,
			ParameterValueMapper parameterValueMapper, EndpointMediaTypes endpointMediaTypes,
			List<PathMapper> endpointPathMappers, Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<ExposableWebEndpoint>> endpointFilters,
			Collection<OperationFilter<WebOperation>> operationFilters) {
		super(applicationContext, parameterValueMapper, endpointMediaTypes, endpointPathMappers, null, invokerAdvisors,
				endpointFilters, operationFilters);
	}
	@Override
	protected boolean isExtensionTypeExposed(Class<?> extensionBeanType) {
		// Filter regular health endpoint extensions so a CF version can replace them
		return !isHealthEndpointExtension(extensionBeanType)
				|| isCloudFoundryHealthEndpointExtension(extensionBeanType);
	}
	private boolean isHealthEndpointExtension(Class<?> extensionBeanType) {
		return MergedAnnotations.from(extensionBeanType)
			.get(EndpointWebExtension.class)
			.getValue('endpoint', Class.class)
			.map(HealthEndpoint.class::isAssignableFrom)
			.orElse(false);
	}
	private boolean isCloudFoundryHealthEndpointExtension(Class<?> extensionBeanType) {
		return MergedAnnotations.from(extensionBeanType).isPresent(EndpointCloudFoundryExtension.class);
	}
	static class CloudFoundryWebEndpointDiscovererRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection()
				.registerType(CloudFoundryEndpointFilter.class, MemberCategory.INVOKE_DECLARED_CONSTRUCTORS);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
@ImportRuntimeHints(CloudFoundryWebFluxEndpointHandlerMappingRuntimeHints.class)
class CloudFoundryWebFluxEndpointHandlerMapping extends AbstractWebFluxEndpointHandlerMapping {
	private final CloudFoundrySecurityInterceptor securityInterceptor;
	private final EndpointLinksResolver linksResolver;
	private final Collection<ExposableEndpoint<?>> allEndpoints;
	CloudFoundryWebFluxEndpointHandlerMapping(EndpointMapping endpointMapping,
			Collection<ExposableWebEndpoint> endpoints, EndpointMediaTypes endpointMediaTypes,
			CorsConfiguration corsConfiguration, CloudFoundrySecurityInterceptor securityInterceptor,
			Collection<ExposableEndpoint<?>> allEndpoints) {
		super(endpointMapping, endpoints, endpointMediaTypes, corsConfiguration, true);
		this.linksResolver = new EndpointLinksResolver(allEndpoints);
		this.allEndpoints = allEndpoints;
		this.securityInterceptor = securityInterceptor;
	}
	@Override
	protected ReactiveWebOperation wrapReactiveWebOperation(ExposableWebEndpoint endpoint, WebOperation operation,
			ReactiveWebOperation reactiveWebOperation) {
		return new SecureReactiveWebOperation(reactiveWebOperation, this.securityInterceptor, endpoint.getEndpointId());
	}
	@Override
	protected LinksHandler getLinksHandler() {
		return new CloudFoundryLinksHandler();
	}
	Collection<ExposableEndpoint<?>> getAllEndpoints() {
		return this.allEndpoints;
	}
	class CloudFoundryLinksHandler implements LinksHandler {
		@Override
		@Reflective
		public Publisher<ResponseEntity<Object>> links(ServerWebExchange exchange) {
			ServerHttpRequest request = exchange.getRequest();
			return CloudFoundryWebFluxEndpointHandlerMapping.this.securityInterceptor.preHandle(exchange, '')
				.map((securityResponse) -> {
					if (!securityResponse.getStatus().equals(HttpStatus.OK)) {
						return new ResponseEntity<>(securityResponse.getStatus());
					}
					AccessLevel accessLevel = exchange.getAttribute(AccessLevel.REQUEST_ATTRIBUTE);
					Map<String, Link> links = CloudFoundryWebFluxEndpointHandlerMapping.this.linksResolver
						.resolveLinks(request.getURI().toString());
					return new ResponseEntity<>(
							Collections.singletonMap('_links', getAccessibleLinks(accessLevel, links)), HttpStatus.OK);
				});
		}
		private Map<String, Link> getAccessibleLinks(AccessLevel accessLevel, Map<String, Link> links) {
			if (accessLevel == null) {
				return new LinkedHashMap<>();
			}
			return links.entrySet()
				.stream()
				.filter((entry) -> entry.getKey().equals('self') || accessLevel.isAccessAllowed(entry.getKey()))
				.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
		}
		@Override
		public String toString() {
			return 'Actuator root web endpoint';
		}
	}
	/**
	 * {@link ReactiveWebOperation} wrapper to add security.
	 */
	private static class SecureReactiveWebOperation implements ReactiveWebOperation {
		private final ReactiveWebOperation delegate;
		private final CloudFoundrySecurityInterceptor securityInterceptor;
		private final EndpointId endpointId;
		SecureReactiveWebOperation(ReactiveWebOperation delegate, CloudFoundrySecurityInterceptor securityInterceptor,
				EndpointId endpointId) {
			this.delegate = delegate;
			this.securityInterceptor = securityInterceptor;
			this.endpointId = endpointId;
		}
		@Override
		public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body) {
			return this.securityInterceptor.preHandle(exchange, this.endpointId.toLowerCaseString())
				.flatMap((securityResponse) -> flatMapResponse(exchange, body, securityResponse));
		}
		private Mono<ResponseEntity<Object>> flatMapResponse(ServerWebExchange exchange, Map<String, String> body,
				SecurityResponse securityResponse) {
			if (!securityResponse.getStatus().equals(HttpStatus.OK)) {
				return Mono.just(new ResponseEntity<>(securityResponse.getStatus()));
			}
			return this.delegate.handle(exchange, body);
		}
	}
	static class CloudFoundryWebFluxEndpointHandlerMappingRuntimeHints implements RuntimeHintsRegistrar {
		private final ReflectiveRuntimeHintsRegistrar reflectiveRegistrar = new ReflectiveRuntimeHintsRegistrar();
		private final BindingReflectionHintsRegistrar bindingRegistrar = new BindingReflectionHintsRegistrar();
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			this.reflectiveRegistrar.registerRuntimeHints(hints, CloudFoundryLinksHandler.class);
			this.bindingRegistrar.registerReflectionHints(hints.reflection(), Link.class);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class ReactiveTokenValidator {
	private final ReactiveCloudFoundrySecurityService securityService;
	private volatile Map<String, String> cachedTokenKeys = Collections.emptyMap();
	ReactiveTokenValidator(ReactiveCloudFoundrySecurityService securityService) {
		this.securityService = securityService;
	}
	Mono<Void> validate(Token token) {
		return validateAlgorithm(token).then(validateKeyIdAndSignature(token))
			.then(validateExpiry(token))
			.then(validateIssuer(token))
			.then(validateAudience(token));
	}
	private Mono<Void> validateAlgorithm(Token token) {
		String algorithm = token.getSignatureAlgorithm();
		if (algorithm == null) {
			return Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE,
					'Signing algorithm cannot be null'));
		}
		if (!algorithm.equals('RS256')) {
			return Mono.error(new CloudFoundryAuthorizationException(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM,
					'Signing algorithm ' + algorithm + ' not supported'));
		}
		return Mono.empty();
	}
	private Mono<Void> validateKeyIdAndSignature(Token token) {
		return getTokenKey(token).filter((tokenKey) -> hasValidSignature(token, tokenKey))
			.switchIfEmpty(Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE,
					'RSA Signature did not match content')))
			.then();
	}
	private Mono<String> getTokenKey(Token token) {
		String keyId = token.getKeyId();
		String cached = this.cachedTokenKeys.get(keyId);
		if (cached != null) {
			return Mono.just(cached);
		}
		return this.securityService.fetchTokenKeys()
			.doOnSuccess(this::cacheTokenKeys)
			.filter((tokenKeys) -> tokenKeys.containsKey(keyId))
			.map((tokenKeys) -> tokenKeys.get(keyId))
			.switchIfEmpty(Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID,
					'Key Id present in token header does not match')));
	}
	private void cacheTokenKeys(Map<String, String> tokenKeys) {
		this.cachedTokenKeys = Map.copyOf(tokenKeys);
	}
	private boolean hasValidSignature(Token token, String key) {
		try {
			PublicKey publicKey = getPublicKey(key);
			Signature signature = Signature.getInstance('SHA256withRSA');
			signature.initVerify(publicKey);
			signature.update(token.getContent());
			return signature.verify(token.getSignature());
		}
		catch (GeneralSecurityException ex) {
			return false;
		}
	}
	private PublicKey getPublicKey(String key) throws NoSuchAlgorithmException, InvalidKeySpecException {
		key = key.replace('-----BEGIN PUBLIC KEY-----\n', '');
		key = key.replace('-----END PUBLIC KEY-----', '');
		key = key.trim().replace('\n', '');
		byte[] bytes = Base64.getDecoder().decode(key);
		X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes);
		return KeyFactory.getInstance('RSA').generatePublic(keySpec);
	}
	private Mono<Void> validateExpiry(Token token) {
		long currentTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis());
		if (currentTime > token.getExpiry()) {
			return Mono.error(new CloudFoundryAuthorizationException(Reason.TOKEN_EXPIRED, 'Token expired'));
		}
		return Mono.empty();
	}
	private Mono<Void> validateIssuer(Token token) {
		return this.securityService.getUaaUrl()
			.map((uaaUrl) -> String.format('%s/oauth/token', uaaUrl))
			.filter((issuerUri) -> issuerUri.equals(token.getIssuer()))
			.switchIfEmpty(Mono
				.error(new CloudFoundryAuthorizationException(Reason.INVALID_ISSUER, 'Token issuer does not match')))
			.then();
	}
	private Mono<Void> validateAudience(Token token) {
		if (!token.getScope().contains('actuator.read')) {
			return Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_AUDIENCE,
					'Token does not have audience actuator'));
		}
		return Mono.empty();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class ReactiveCloudFoundrySecurityService {
	private static final ParameterizedTypeReference<Map<String, Object>> STRING_OBJECT_MAP = new ParameterizedTypeReference<>() {
	};
	private final WebClient webClient;
	private final String cloudControllerUrl;
	ReactiveCloudFoundrySecurityService(WebClient.Builder webClientBuilder, String cloudControllerUrl,
			boolean skipSslValidation) {
		Assert.notNull(webClientBuilder, 'WebClient must not be null');
		Assert.notNull(cloudControllerUrl, 'CloudControllerUrl must not be null');
		if (skipSslValidation) {
			webClientBuilder.clientConnector(buildTrustAllSslConnector());
		}
		this.webClient = webClientBuilder.build();
		this.cloudControllerUrl = cloudControllerUrl;
	}
	protected ReactorClientHttpConnector buildTrustAllSslConnector() {
		HttpClient client = HttpClient.create().secure((spec) -> spec.sslContext(createSslContextSpec()));
		return new ReactorClientHttpConnector(client);
	}
	private GenericSslContextSpec<?> createSslContextSpec() {
		return Http11SslContextSpec.forClient()
			.configure((builder) -> builder.sslProvider(SslProvider.JDK)
				.trustManager(InsecureTrustManagerFactory.INSTANCE));
	}
	/**
	 * Return a Mono of the access level that should be granted to the given token.
	 * @param token the token
	 * @param applicationId the cloud foundry application ID
	 * @return a Mono of the access level that should be granted
	 * @throws CloudFoundryAuthorizationException if the token is not authorized
	 */
	Mono<AccessLevel> getAccessLevel(String token, String applicationId) throws CloudFoundryAuthorizationException {
		String uri = getPermissionsUri(applicationId);
		return this.webClient.get()
			.uri(uri)
			.header('Authorization', 'bearer ' + token)
			.retrieve()
			.bodyToMono(Map.class)
			.map(this::getAccessLevel)
			.onErrorMap(this::mapError);
	}
	private Throwable mapError(Throwable throwable) {
		if (throwable instanceof WebClientResponseException webClientResponseException) {
			HttpStatusCode statusCode = webClientResponseException.getStatusCode();
			if (statusCode.equals(HttpStatus.FORBIDDEN)) {
				return new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED, 'Access denied');
			}
			if (statusCode.is4xxClientError()) {
				return new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN, 'Invalid token', throwable);
			}
		}
		return new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, 'Cloud controller not reachable');
	}
	private AccessLevel getAccessLevel(Map<?, ?> body) {
		if (Boolean.TRUE.equals(body.get('read_sensitive_data'))) {
			return AccessLevel.FULL;
		}
		return AccessLevel.RESTRICTED;
	}
	private String getPermissionsUri(String applicationId) {
		return this.cloudControllerUrl + '/v2/apps/' + applicationId + '/permissions';
	}
	/**
	 * Return a Mono of all token keys known by the UAA.
	 * @return a Mono of token keys
	 */
	Mono<Map<String, String>> fetchTokenKeys() {
		return getUaaUrl().flatMap(this::fetchTokenKeys);
	}
	private Mono<? extends Map<String, String>> fetchTokenKeys(String url) {
		RequestHeadersSpec<?> uri = this.webClient.get().uri(url + '/token_keys');
		return uri.retrieve()
			.bodyToMono(STRING_OBJECT_MAP)
			.map(this::extractTokenKeys)
			.onErrorMap(((ex) -> new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, ex.getMessage())));
	}
	private Map<String, String> extractTokenKeys(Map<String, Object> response) {
		Map<String, String> tokenKeys = new HashMap<>();
		for (Object key : (List<?>) response.get('keys')) {
			Map<?, ?> tokenKey = (Map<?, ?>) key;
			tokenKeys.put((String) tokenKey.get('kid'), (String) tokenKey.get('value'));
		}
		return tokenKeys;
	}
	/**
	 * Return a Mono of URL of the UAA.
	 * @return the UAA url Mono
	 */
	Mono<String> getUaaUrl() {
		return this.webClient.get()
			.uri(this.cloudControllerUrl + '/info')
			.retrieve()
			.bodyToMono(Map.class)
			.map((response) -> (String) response.get('token_endpoint'))
			.cache()
			.onErrorMap((ex) -> new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE,
					'Unable to fetch token keys from UAA.'));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
@EndpointCloudFoundryExtension(endpoint = HealthEndpoint.class)
public class CloudFoundryReactiveHealthEndpointWebExtension {
	private final ReactiveHealthEndpointWebExtension delegate;
	public CloudFoundryReactiveHealthEndpointWebExtension(ReactiveHealthEndpointWebExtension delegate) {
		this.delegate = delegate;
	}
	@ReadOperation
	public Mono<WebEndpointResponse<? extends HealthComponent>> health(ApiVersion apiVersion) {
		return this.delegate.health(apiVersion, null, SecurityContext.NONE, true);
	}
	@ReadOperation
	public Mono<WebEndpointResponse<? extends HealthComponent>> health(ApiVersion apiVersion,
			@Selector(match = Match.ALL_REMAINING) String... path) {
		return this.delegate.health(apiVersion, null, SecurityContext.NONE, true, path);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
@AutoConfiguration(after = { HealthEndpointAutoConfiguration.class, InfoEndpointAutoConfiguration.class })
@ConditionalOnProperty(prefix = 'management.cloudfoundry', name = 'enabled', matchIfMissing = true)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)
public class ReactiveCloudFoundryActuatorAutoConfiguration {
	private static final String BASE_PATH = '/cloudfoundryapplication';
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnAvailableEndpoint
	@ConditionalOnBean({ HealthEndpoint.class, ReactiveHealthEndpointWebExtension.class })
	public CloudFoundryReactiveHealthEndpointWebExtension cloudFoundryReactiveHealthEndpointWebExtension(
			ReactiveHealthEndpointWebExtension reactiveHealthEndpointWebExtension) {
		return new CloudFoundryReactiveHealthEndpointWebExtension(reactiveHealthEndpointWebExtension);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnAvailableEndpoint
	@ConditionalOnBean({ InfoEndpoint.class, GitProperties.class })
	public CloudFoundryInfoEndpointWebExtension cloudFoundryInfoEndpointWebExtension(GitProperties properties,
			ObjectProvider<InfoContributor> infoContributors) {
		List<InfoContributor> contributors = infoContributors.orderedStream()
			.map((infoContributor) -> (infoContributor instanceof GitInfoContributor)
					? new GitInfoContributor(properties, InfoPropertiesInfoContributor.Mode.FULL) : infoContributor)
			.toList();
		return new CloudFoundryInfoEndpointWebExtension(new InfoEndpoint(contributors));
	}
	@Bean
	@SuppressWarnings('removal')
	public CloudFoundryWebFluxEndpointHandlerMapping cloudFoundryWebFluxEndpointHandlerMapping(
			ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes,
			WebClient.Builder webClientBuilder,
			org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier controllerEndpointsSupplier,
			ApplicationContext applicationContext) {
		CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer(applicationContext,
				parameterMapper, endpointMediaTypes, null, Collections.emptyList(), Collections.emptyList(),
				Collections.emptyList());
		CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor(webClientBuilder,
				applicationContext.getEnvironment());
		Collection<ExposableWebEndpoint> webEndpoints = endpointDiscoverer.getEndpoints();
		List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>();
		allEndpoints.addAll(webEndpoints);
		allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints());
		return new CloudFoundryWebFluxEndpointHandlerMapping(new EndpointMapping(BASE_PATH), webEndpoints,
				endpointMediaTypes, getCorsConfiguration(), securityInterceptor, allEndpoints);
	}
	private CloudFoundrySecurityInterceptor getSecurityInterceptor(WebClient.Builder webClientBuilder,
			Environment environment) {
		ReactiveCloudFoundrySecurityService cloudfoundrySecurityService = getCloudFoundrySecurityService(
				webClientBuilder, environment);
		ReactiveTokenValidator tokenValidator = new ReactiveTokenValidator(cloudfoundrySecurityService);
		return new CloudFoundrySecurityInterceptor(tokenValidator, cloudfoundrySecurityService,
				environment.getProperty('vcap.application.application_id'));
	}
	private ReactiveCloudFoundrySecurityService getCloudFoundrySecurityService(WebClient.Builder webClientBuilder,
			Environment environment) {
		String cloudControllerUrl = environment.getProperty('vcap.application.cf_api');
		boolean skipSslValidation = environment.getProperty('management.cloudfoundry.skip-ssl-validation',
				Boolean.class, false);
		return (cloudControllerUrl != null)
				? new ReactiveCloudFoundrySecurityService(webClientBuilder, cloudControllerUrl, skipSslValidation)
				: null;
	}
	private CorsConfiguration getCorsConfiguration() {
		CorsConfiguration corsConfiguration = new CorsConfiguration();
		corsConfiguration.addAllowedOrigin(CorsConfiguration.ALL);
		corsConfiguration.setAllowedMethods(Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name()));
		corsConfiguration
			.setAllowedHeaders(Arrays.asList(HttpHeaders.AUTHORIZATION, 'X-Cf-App-Instance', HttpHeaders.CONTENT_TYPE));
		return corsConfiguration;
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(MatcherSecurityWebFilterChain.class)
	static class IgnoredPathsSecurityConfiguration {
		@Bean
		static WebFilterChainPostProcessor webFilterChainPostProcessor(
				ObjectProvider<CloudFoundryWebFluxEndpointHandlerMapping> handlerMapping) {
			return new WebFilterChainPostProcessor(handlerMapping);
		}
	}
	static class WebFilterChainPostProcessor implements BeanPostProcessor {
		private final Supplier<PathMappedEndpoints> pathMappedEndpoints;
		WebFilterChainPostProcessor(ObjectProvider<CloudFoundryWebFluxEndpointHandlerMapping> handlerMapping) {
			this.pathMappedEndpoints = SingletonSupplier
				.of(() -> new PathMappedEndpoints(BASE_PATH, () -> handlerMapping.getObject().getAllEndpoints()));
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			if (bean instanceof WebFilterChainProxy webFilterChainProxy) {
				return postProcess(webFilterChainProxy);
			}
			return bean;
		}
		private WebFilterChainProxy postProcess(WebFilterChainProxy existing) {
			List<String> paths = getPaths(this.pathMappedEndpoints.get());
			ServerWebExchangeMatcher cloudFoundryRequestMatcher = ServerWebExchangeMatchers
				.pathMatchers(paths.toArray(new String[] {}));
			WebFilter noOpFilter = (exchange, chain) -> chain.filter(exchange);
			MatcherSecurityWebFilterChain ignoredRequestFilterChain = new MatcherSecurityWebFilterChain(
					cloudFoundryRequestMatcher, Collections.singletonList(noOpFilter));
			MatcherSecurityWebFilterChain allRequestsFilterChain = new MatcherSecurityWebFilterChain(
					ServerWebExchangeMatchers.anyExchange(), Collections.singletonList(existing));
			return new WebFilterChainProxy(ignoredRequestFilterChain, allRequestsFilterChain);
		}
		private static List<String> getPaths(PathMappedEndpoints pathMappedEndpoints) {
			List<String> paths = new ArrayList<>();
			pathMappedEndpoints.getAllPaths().forEach((path) -> paths.add(path + '/**'));
			paths.add(BASE_PATH);
			paths.add(BASE_PATH + '/');
			return paths;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/**
class CloudFoundrySecurityInterceptor {
	private static final Log logger = LogFactory.getLog(CloudFoundrySecurityInterceptor.class);
	private final ReactiveTokenValidator tokenValidator;
	private final ReactiveCloudFoundrySecurityService cloudFoundrySecurityService;
	private final String applicationId;
	private static final Mono<SecurityResponse> SUCCESS = Mono.just(SecurityResponse.success());
	CloudFoundrySecurityInterceptor(ReactiveTokenValidator tokenValidator,
			ReactiveCloudFoundrySecurityService cloudFoundrySecurityService, String applicationId) {
		this.tokenValidator = tokenValidator;
		this.cloudFoundrySecurityService = cloudFoundrySecurityService;
		this.applicationId = applicationId;
	}
	Mono<SecurityResponse> preHandle(ServerWebExchange exchange, String id) {
		ServerHttpRequest request = exchange.getRequest();
		if (CorsUtils.isPreFlightRequest(request)) {
			return SUCCESS;
		}
		if (!StringUtils.hasText(this.applicationId)) {
			return Mono.error(new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE,
					'Application id is not available'));
		}
		if (this.cloudFoundrySecurityService == null) {
			return Mono.error(new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE,
					'Cloud controller URL is not available'));
		}
		return check(exchange, id).then(SUCCESS).doOnError(this::logError).onErrorResume(this::getErrorResponse);
	}
	private void logError(Throwable ex) {
		logger.error(ex.getMessage(), ex);
	}
	private Mono<Void> check(ServerWebExchange exchange, String id) {
		try {
			Token token = getToken(exchange.getRequest());
			return this.tokenValidator.validate(token)
				.then(this.cloudFoundrySecurityService.getAccessLevel(token.toString(), this.applicationId))
				.filter((accessLevel) -> accessLevel.isAccessAllowed(id))
				.switchIfEmpty(
						Mono.error(new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED, 'Access denied')))
				.doOnSuccess((accessLevel) -> exchange.getAttributes().put('cloudFoundryAccessLevel', accessLevel))
				.then();
		}
		catch (CloudFoundryAuthorizationException ex) {
			return Mono.error(ex);
		}
	}
	private Mono<SecurityResponse> getErrorResponse(Throwable throwable) {
		if (throwable instanceof CloudFoundryAuthorizationException cfException) {
			return Mono.just(new SecurityResponse(cfException.getStatusCode(),
					'{\'security_error\':\'' + cfException.getMessage() + '\'}'));
		}
		return Mono.just(new SecurityResponse(HttpStatus.INTERNAL_SERVER_ERROR, throwable.getMessage()));
	}
	private Token getToken(ServerHttpRequest request) {
		String authorization = request.getHeaders().getFirst('Authorization');
		String bearerPrefix = 'bearer ';
		if (authorization == null || !authorization.toLowerCase(Locale.ENGLISH).startsWith(bearerPrefix)) {
			throw new CloudFoundryAuthorizationException(Reason.MISSING_AUTHORIZATION,
					'Authorization header is missing or invalid');
		}
		return new Token(authorization.substring(bearerPrefix.length()));
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.cloudfoundry.reactive;
/*
package org.springframework.boot.actuate.autoconfigure.cloudfoundry;
/**
public class CloudFoundryAuthorizationException extends RuntimeException {
	private final Reason reason;
	public CloudFoundryAuthorizationException(Reason reason, String message) {
		this(reason, message, null);
	}
	public CloudFoundryAuthorizationException(Reason reason, String message, Throwable cause) {
		super(message, cause);
		this.reason = reason;
	}
	/**
	 * Return the status code that should be returned to the client.
	 * @return the HTTP status code
	 */
	public HttpStatus getStatusCode() {
		return getReason().getStatus();
	}
	/**
	 * Return the reason why the authorization exception was thrown.
	 * @return the reason
	 */
	public Reason getReason() {
		return this.reason;
	}
	/**
	 * Reasons why the exception can be thrown.
	 */
	public enum Reason {
		/**
		 * Access Denied.
		 */
		ACCESS_DENIED(HttpStatus.FORBIDDEN),
		/**
		 * Invalid Audience.
		 */
		INVALID_AUDIENCE(HttpStatus.UNAUTHORIZED),
		/**
		 * Invalid Issuer.
		 */
		INVALID_ISSUER(HttpStatus.UNAUTHORIZED),
		/**
		 * Invalid Key ID.
		 */
		INVALID_KEY_ID(HttpStatus.UNAUTHORIZED),
		/**
		 * Invalid Signature.
		 */
		INVALID_SIGNATURE(HttpStatus.UNAUTHORIZED),
		/**
		 * Invalid Token.
		 */
		INVALID_TOKEN(HttpStatus.UNAUTHORIZED),
		/**
		 * Missing Authorization.
		 */
		MISSING_AUTHORIZATION(HttpStatus.UNAUTHORIZED),
		/**
		 * Token Expired.
		 */
		TOKEN_EXPIRED(HttpStatus.UNAUTHORIZED),
		/**
		 * Unsupported Token Signing Algorithm.
		 */
		UNSUPPORTED_TOKEN_SIGNING_ALGORITHM(HttpStatus.UNAUTHORIZED),
		/**
		 * Service Unavailable.
		 */
		SERVICE_UNAVAILABLE(HttpStatus.SERVICE_UNAVAILABLE);
		private final HttpStatus status;
		Reason(HttpStatus status) {
			this.status = status;
		}
		public HttpStatus getStatus() {
			return this.status;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.data.elasticsearch;
/*
package org.springframework.boot.actuate.autoconfigure.data.elasticsearch;
/**
@AutoConfiguration(after = ReactiveElasticsearchClientAutoConfiguration.class)
@ConditionalOnClass({ ReactiveElasticsearchClient.class, Flux.class })
@ConditionalOnBean(ReactiveElasticsearchClient.class)
@ConditionalOnEnabledHealthIndicator('elasticsearch')
public class ElasticsearchReactiveHealthContributorAutoConfiguration extends
		CompositeReactiveHealthContributorConfiguration<ElasticsearchReactiveHealthIndicator, ReactiveElasticsearchClient> {
	public ElasticsearchReactiveHealthContributorAutoConfiguration() {
		super(ElasticsearchReactiveHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'elasticsearchHealthIndicator', 'elasticsearchHealthContributor' })
	public ReactiveHealthContributor elasticsearchHealthContributor(Map<String, ReactiveElasticsearchClient> clients) {
		return createContributor(clients);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.data.redis;
/**
@AutoConfiguration(after = { RedisAutoConfiguration.class, RedisReactiveHealthContributorAutoConfiguration.class })
@ConditionalOnClass(RedisConnectionFactory.class)
@ConditionalOnBean(RedisConnectionFactory.class)
@ConditionalOnEnabledHealthIndicator('redis')
public class RedisHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<RedisHealthIndicator, RedisConnectionFactory> {
	RedisHealthContributorAutoConfiguration() {
		super(RedisHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'redisHealthIndicator', 'redisHealthContributor' })
	public HealthContributor redisHealthContributor(Map<String, RedisConnectionFactory> redisConnectionFactories) {
		return createContributor(redisConnectionFactories);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.data.redis;
/*
package org.springframework.boot.actuate.autoconfigure.data.redis;
/**
@AutoConfiguration(after = RedisReactiveAutoConfiguration.class)
@ConditionalOnClass({ ReactiveRedisConnectionFactory.class, Flux.class })
@ConditionalOnBean(ReactiveRedisConnectionFactory.class)
@ConditionalOnEnabledHealthIndicator('redis')
public class RedisReactiveHealthContributorAutoConfiguration extends
		CompositeReactiveHealthContributorConfiguration<RedisReactiveHealthIndicator, ReactiveRedisConnectionFactory> {
	private final Map<String, ReactiveRedisConnectionFactory> redisConnectionFactories;
	RedisReactiveHealthContributorAutoConfiguration(
			Map<String, ReactiveRedisConnectionFactory> redisConnectionFactories) {
		super(RedisReactiveHealthIndicator::new);
		this.redisConnectionFactories = redisConnectionFactories;
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'redisHealthIndicator', 'redisHealthContributor' })
	public ReactiveHealthContributor redisHealthContributor() {
		return createContributor(this.redisConnectionFactories);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.data;
/*
package org.springframework.boot.actuate.autoconfigure.data.mongo;
/**
@AutoConfiguration(after = { MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
		MongoReactiveHealthContributorAutoConfiguration.class })
@ConditionalOnClass(MongoTemplate.class)
@ConditionalOnBean(MongoTemplate.class)
@ConditionalOnEnabledHealthIndicator('mongo')
public class MongoHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<MongoHealthIndicator, MongoTemplate> {
	public MongoHealthContributorAutoConfiguration() {
		super(MongoHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'mongoHealthIndicator', 'mongoHealthContributor' })
	public HealthContributor mongoHealthContributor(Map<String, MongoTemplate> mongoTemplates) {
		return createContributor(mongoTemplates);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.data.mongo;
/**
@AutoConfiguration(after = MongoReactiveDataAutoConfiguration.class)
@ConditionalOnClass({ ReactiveMongoTemplate.class, Flux.class })
@ConditionalOnBean(ReactiveMongoTemplate.class)
@ConditionalOnEnabledHealthIndicator('mongo')
public class MongoReactiveHealthContributorAutoConfiguration
		extends CompositeReactiveHealthContributorConfiguration<MongoReactiveHealthIndicator, ReactiveMongoTemplate> {
	public MongoReactiveHealthContributorAutoConfiguration() {
		super(MongoReactiveHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'mongoHealthIndicator', 'mongoHealthContributor' })
	public ReactiveHealthContributor mongoHealthContributor(Map<String, ReactiveMongoTemplate> reactiveMongoTemplates) {
		return createContributor(reactiveMongoTemplates);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.data.mongo;
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
@AutoConfiguration
@ConditionalOnClass({ SdkLoggerProvider.class, OpenTelemetry.class })
public class OpenTelemetryLoggingAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	BatchLogRecordProcessor batchLogRecordProcessor(ObjectProvider<LogRecordExporter> logRecordExporters) {
		return BatchLogRecordProcessor.builder(LogRecordExporter.composite(logRecordExporters.orderedStream().toList()))
			.build();
	}
	@Bean
	@ConditionalOnMissingBean
	SdkLoggerProvider otelSdkLoggerProvider(Resource resource, ObjectProvider<LogRecordProcessor> logRecordProcessors,
			ObjectProvider<SdkLoggerProviderBuilderCustomizer> customizers) {
		SdkLoggerProviderBuilder builder = SdkLoggerProvider.builder().setResource(resource);
		logRecordProcessors.orderedStream().forEach(builder::addLogRecordProcessor);
		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(LoggersEndpoint.class)
public class LoggersEndpointAutoConfiguration {
	@Bean
	@ConditionalOnBean(LoggingSystem.class)
	@Conditional(OnEnabledLoggingSystemCondition.class)
	@ConditionalOnMissingBean
	public LoggersEndpoint loggersEndpoint(LoggingSystem loggingSystem,
			ObjectProvider<LoggerGroups> springBootLoggerGroups) {
		return new LoggersEndpoint(loggingSystem, springBootLoggerGroups.getIfAvailable(LoggerGroups::new));
	}
	static class OnEnabledLoggingSystemCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('Logging System');
			String loggingSystem = System.getProperty(LoggingSystem.SYSTEM_PROPERTY);
			if (LoggingSystem.NONE.equals(loggingSystem)) {
				return ConditionOutcome
					.noMatch(message.because('system property ' + LoggingSystem.SYSTEM_PROPERTY + ' is set to none'));
			}
			return ConditionOutcome.match(message.because('enabled'));
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
class OnEnabledLoggingExportCondition extends SpringBootCondition {
	private static final String GLOBAL_PROPERTY = 'management.logging.export.enabled';
	private static final String EXPORTER_PROPERTY = 'management.%s.logging.export.enabled';
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		String loggingExporter = getExporterName(metadata);
		if (StringUtils.hasLength(loggingExporter)) {
			Boolean exporterLoggingEnabled = context.getEnvironment()
				.getProperty(EXPORTER_PROPERTY.formatted(loggingExporter), Boolean.class);
			if (exporterLoggingEnabled != null) {
				return new ConditionOutcome(exporterLoggingEnabled,
						ConditionMessage.forCondition(ConditionalOnEnabledLoggingExport.class)
							.because(EXPORTER_PROPERTY.formatted(loggingExporter) + ' is ' + exporterLoggingEnabled));
			}
		}
		Boolean globalLoggingEnabled = context.getEnvironment().getProperty(GLOBAL_PROPERTY, Boolean.class);
		if (globalLoggingEnabled != null) {
			return new ConditionOutcome(globalLoggingEnabled,
					ConditionMessage.forCondition(ConditionalOnEnabledLoggingExport.class)
						.because(GLOBAL_PROPERTY + ' is ' + globalLoggingEnabled));
		}
		return ConditionOutcome.match(ConditionMessage.forCondition(ConditionalOnEnabledLoggingExport.class)
			.because('is enabled by default'));
	}
	private static String getExporterName(AnnotatedTypeMetadata metadata) {
		Map<String, Object> attributes = metadata
			.getAnnotationAttributes(ConditionalOnEnabledLoggingExport.class.getName());
		if (attributes == null) {
			return null;
		}
		return (String) attributes.get('value');
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnEnabledLoggingExportCondition.class)
public @interface ConditionalOnEnabledLoggingExport {
	/**
	 * Name of the logging exporter.
	 * @return the name of the logging exporter
	 */
	String value() default '';
}
/*
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/**
@AutoConfiguration
@ConditionalOnClass({ SdkLoggerProvider.class, OpenTelemetry.class, OtlpHttpLogRecordExporter.class })
@EnableConfigurationProperties(OtlpLoggingProperties.class)
@Import({ OtlpLoggingConfigurations.ConnectionDetails.class, OtlpLoggingConfigurations.Exporters.class })
public class OtlpLoggingAutoConfiguration {
}
/*
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/**
@ConfigurationProperties('management.otlp.logging')
public class OtlpLoggingProperties {
	/**
	 * URL to the OTel collector"s HTTP API.
	 */
	private String endpoint;
	/**
	 * Call timeout for the OTel Collector to process an exported batch of data. This
	 * timeout spans the entire call: resolving DNS, connecting, writing the request body,
	 * server processing, and reading the response body. If the call requires redirects or
	 * retries all must complete within one timeout period.
	 */
	private Duration timeout = Duration.ofSeconds(10);
	/**
	 * Connect timeout for the OTel collector connection.
	 */
	private Duration connectTimeout = Duration.ofSeconds(10);
	/**
	 * Transport used to send the spans.
	 */
	private Transport transport = Transport.HTTP;
	/**
	 * Method used to compress the payload.
	 */
	private Compression compression = Compression.NONE;
	/**
	 * Custom HTTP headers you want to pass to the collector, for example auth headers.
	 */
	private final Map<String, String> headers = new HashMap<>();
	public String getEndpoint() {
		return this.endpoint;
	}
	public void setEndpoint(String endpoint) {
		this.endpoint = endpoint;
	}
	public Duration getTimeout() {
		return this.timeout;
	}
	public void setTimeout(Duration timeout) {
		this.timeout = timeout;
	}
	public Duration getConnectTimeout() {
		return this.connectTimeout;
	}
	public void setConnectTimeout(Duration connectTimeout) {
		this.connectTimeout = connectTimeout;
	}
	public Transport getTransport() {
		return this.transport;
	}
	public void setTransport(Transport transport) {
		this.transport = transport;
	}
	public Compression getCompression() {
		return this.compression;
	}
	public void setCompression(Compression compression) {
		this.compression = compression;
	}
	public Map<String, String> getHeaders() {
		return this.headers;
	}
	public enum Compression {
		/**
		 * Gzip compression.
		 */
		GZIP,
		/**
		 * No compression.
		 */
		NONE
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/**
final class OtlpLoggingConfigurations {
	private OtlpLoggingConfigurations() {
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetails {
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnProperty(prefix = 'management.otlp.logging', name = 'endpoint')
		OtlpLoggingConnectionDetails otlpLoggingConnectionDetails(OtlpLoggingProperties properties) {
			return new PropertiesOtlpLoggingConnectionDetails(properties);
		}
		/**
		 * Adapts {@link OtlpLoggingProperties} to {@link OtlpLoggingConnectionDetails}.
		 */
		static class PropertiesOtlpLoggingConnectionDetails implements OtlpLoggingConnectionDetails {
			private final OtlpLoggingProperties properties;
			PropertiesOtlpLoggingConnectionDetails(OtlpLoggingProperties properties) {
				this.properties = properties;
			}
			@Override
			public String getUrl(Transport transport) {
				Assert.state(transport == this.properties.getTransport(),
						'Requested transport %s doesn"t match configured transport %s'.formatted(transport,
								this.properties.getTransport()));
				return this.properties.getEndpoint();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean({ OtlpGrpcLogRecordExporter.class, OtlpHttpLogRecordExporter.class })
	@ConditionalOnBean(OtlpLoggingConnectionDetails.class)
	@ConditionalOnEnabledLoggingExport('otlp')
	static class Exporters {
		@Bean
		@ConditionalOnProperty(prefix = 'management.otlp.logging', name = 'transport', havingValue = 'http',
				matchIfMissing = true)
		OtlpHttpLogRecordExporter otlpHttpLogRecordExporter(OtlpLoggingProperties properties,
				OtlpLoggingConnectionDetails connectionDetails) {
			OtlpHttpLogRecordExporterBuilder builder = OtlpHttpLogRecordExporter.builder()
				.setEndpoint(connectionDetails.getUrl(Transport.HTTP))
				.setTimeout(properties.getTimeout())
				.setConnectTimeout(properties.getConnectTimeout())
				.setCompression(properties.getCompression().name().toLowerCase(Locale.US));
			properties.getHeaders().forEach(builder::addHeader);
			return builder.build();
		}
		@Bean
		@ConditionalOnProperty(prefix = 'management.otlp.logging', name = 'transport', havingValue = 'grpc')
		OtlpGrpcLogRecordExporter otlpGrpcLogRecordExporter(OtlpLoggingProperties properties,
				OtlpLoggingConnectionDetails connectionDetails) {
			OtlpGrpcLogRecordExporterBuilder builder = OtlpGrpcLogRecordExporter.builder()
				.setEndpoint(connectionDetails.getUrl(Transport.GRPC))
				.setTimeout(properties.getTimeout())
				.setConnectTimeout(properties.getConnectTimeout())
				.setCompression(properties.getCompression().name().toLowerCase(Locale.US));
			properties.getHeaders().forEach(builder::addHeader);
			return builder.build();
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/**
public enum Transport {
	/**
	 * HTTP transport.
	 */
	HTTP,
	/**
	 * gRPC transport.
	 */
	GRPC
}
/*
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/**
public interface OtlpLoggingConnectionDetails extends ConnectionDetails {
	/**
	 * Address to where logs will be published.
	 * @param transport the transport to use
	 * @return the address to where logs will be published
	 */
	String getUrl(Transport transport);
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.logging.otlp;
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
@ConfigurationProperties(prefix = 'management.endpoint.logfile')
public class LogFileWebEndpointProperties {
	/**
	 * External Logfile to be accessed. Can be used if the logfile is written by output
	 * redirect and not by the logging system itself.
	 */
	private File externalFile;
	public File getExternalFile() {
		return this.externalFile;
	}
	public void setExternalFile(File externalFile) {
		this.externalFile = externalFile;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(LogFileWebEndpoint.class)
@EnableConfigurationProperties(LogFileWebEndpointProperties.class)
public class LogFileWebEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@Conditional(LogFileCondition.class)
	public LogFileWebEndpoint logFileWebEndpoint(ObjectProvider<LogFile> logFile,
			LogFileWebEndpointProperties properties) {
		return new LogFileWebEndpoint(logFile.getIfAvailable(), properties.getExternalFile());
	}
	private static final class LogFileCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			Environment environment = context.getEnvironment();
			String config = getLogFileConfig(environment, LogFile.FILE_NAME_PROPERTY);
			ConditionMessage.Builder message = ConditionMessage.forCondition('Log File');
			if (StringUtils.hasText(config)) {
				return ConditionOutcome.match(message.found(LogFile.FILE_NAME_PROPERTY).items(config));
			}
			config = getLogFileConfig(environment, LogFile.FILE_PATH_PROPERTY);
			if (StringUtils.hasText(config)) {
				return ConditionOutcome.match(message.found(LogFile.FILE_PATH_PROPERTY).items(config));
			}
			config = environment.getProperty('management.endpoint.logfile.external-file');
			if (StringUtils.hasText(config)) {
				return ConditionOutcome.match(message.found('management.endpoint.logfile.external-file').items(config));
			}
			return ConditionOutcome.noMatch(message.didNotFind('logging file').atAll());
		}
		private String getLogFileConfig(Environment environment, String configName) {
			return environment.resolvePlaceholders('${' + configName + ':}');
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.logging;
/*
package org.springframework.boot.actuate.autoconfigure.logging;
/**
@FunctionalInterface
public interface SdkLoggerProviderBuilderCustomizer {
	/**
	 * Customize the given {@code builder}.
	 * @param builder the builder to customize
	 */
	void customize(SdkLoggerProviderBuilder builder);
}
/*
package org.springframework.boot.actuate.autoconfigure.opentelemetry;
/**
@AutoConfiguration
@ConditionalOnClass(OpenTelemetrySdk.class)
@EnableConfigurationProperties(OpenTelemetryProperties.class)
public class OpenTelemetryAutoConfiguration {
	/**
	 * Default value for application name if {@code spring.application.name} is not set.
	 */
	private static final String DEFAULT_APPLICATION_NAME = 'unknown_service';
	private static final AttributeKey<String> ATTRIBUTE_KEY_SERVICE_NAME = AttributeKey.stringKey('service.name');
	private static final AttributeKey<String> ATTRIBUTE_KEY_SERVICE_GROUP = AttributeKey.stringKey('service.group');
	@Bean
	@ConditionalOnMissingBean(OpenTelemetry.class)
	OpenTelemetrySdk openTelemetry(ObjectProvider<SdkTracerProvider> tracerProvider,
			ObjectProvider<ContextPropagators> propagators, ObjectProvider<SdkLoggerProvider> loggerProvider,
			ObjectProvider<SdkMeterProvider> meterProvider) {
		OpenTelemetrySdkBuilder builder = OpenTelemetrySdk.builder();
		tracerProvider.ifAvailable(builder::setTracerProvider);
		propagators.ifAvailable(builder::setPropagators);
		loggerProvider.ifAvailable(builder::setLoggerProvider);
		meterProvider.ifAvailable(builder::setMeterProvider);
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	Resource openTelemetryResource(Environment environment, OpenTelemetryProperties properties) {
		String applicationName = environment.getProperty('spring.application.name', DEFAULT_APPLICATION_NAME);
		String applicationGroup = environment.getProperty('spring.application.group');
		Resource resource = Resource.getDefault()
			.merge(Resource.create(Attributes.of(ATTRIBUTE_KEY_SERVICE_NAME, applicationName)));
		if (StringUtils.hasLength(applicationGroup)) {
			resource = resource.merge(Resource.create(Attributes.of(ATTRIBUTE_KEY_SERVICE_GROUP, applicationGroup)));
		}
		return resource.merge(toResource(properties));
	}
	private static Resource toResource(OpenTelemetryProperties properties) {
		ResourceBuilder builder = Resource.builder();
		properties.getResourceAttributes().forEach(builder::put);
		return builder.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.opentelemetry;
/**
@ConfigurationProperties(prefix = 'management.opentelemetry')
public class OpenTelemetryProperties {
	/**
	 * Resource attributes.
	 */
	private Map<String, String> resourceAttributes = new HashMap<>();
	public Map<String, String> getResourceAttributes() {
		return this.resourceAttributes;
	}
	public void setResourceAttributes(Map<String, String> resourceAttributes) {
		this.resourceAttributes = resourceAttributes;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.opentelemetry;
/*
package org.springframework.boot.actuate.autoconfigure.hazelcast;
/**
@AutoConfiguration(after = HazelcastAutoConfiguration.class)
@ConditionalOnClass(HazelcastInstance.class)
@ConditionalOnBean(HazelcastInstance.class)
@ConditionalOnEnabledHealthIndicator('hazelcast')
public class HazelcastHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<HazelcastHealthIndicator, HazelcastInstance> {
	public HazelcastHealthContributorAutoConfiguration() {
		super(HazelcastHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'hazelcastHealthIndicator', 'hazelcastHealthContributor' })
	public HealthContributor hazelcastHealthContributor(Map<String, HazelcastInstance> hazelcastInstances) {
		return createContributor(hazelcastInstances);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.hazelcast;
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
class OnEnabledInfoContributorCondition extends OnEndpointElementCondition {
	OnEnabledInfoContributorCondition() {
		super('management.info.', ConditionalOnEnabledInfoContributor.class);
	}
	@Override
	protected ConditionOutcome getDefaultOutcome(ConditionContext context, AnnotationAttributes annotationAttributes) {
		InfoContributorFallback fallback = annotationAttributes.getEnum('fallback');
		if (fallback == InfoContributorFallback.DISABLE) {
			return new ConditionOutcome(false, ConditionMessage.forCondition(ConditionalOnEnabledInfoContributor.class)
				.because('management.info.' + annotationAttributes.getString('value') + '.enabled is not true'));
		}
		return super.getDefaultOutcome(context, annotationAttributes);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
public enum InfoContributorFallback {
	/**
	 * Fall back to the {@code management.info.defaults.enabled} property, matching if it
	 * is {@code true} or if it is not configured.
	 */
	USE_DEFAULTS_PROPERTY,
	/**
	 * Do not fall back, thereby disabling the info contributor.
	 */
	DISABLE
}
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
@AutoConfiguration(after = InfoContributorAutoConfiguration.class)
@ConditionalOnAvailableEndpoint(InfoEndpoint.class)
public class InfoEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public InfoEndpoint infoEndpoint(ObjectProvider<InfoContributor> infoContributors) {
		return new InfoEndpoint(infoContributors.orderedStream().toList());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE, ElementType.METHOD })
@Documented
@Conditional(OnEnabledInfoContributorCondition.class)
public @interface ConditionalOnEnabledInfoContributor {
	/**
	 * The name of the info contributor.
	 * @return the name of the info contributor
	 */
	String value();
	/**
	 * Fallback behavior when {@code management.info.<name>.enabled} has not been set.
	 * @return the fallback behavior
	 */
	InfoContributorFallback fallback() default InfoContributorFallback.USE_DEFAULTS_PROPERTY;
}
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
@AutoConfiguration(after = ProjectInfoAutoConfiguration.class)
@EnableConfigurationProperties({ InfoContributorProperties.class, SslHealthIndicatorProperties.class })
public class InfoContributorAutoConfiguration {
	/**
	 * The default order for the core {@link InfoContributor} beans.
	 */
	public static final int DEFAULT_ORDER = Ordered.HIGHEST_PRECEDENCE + 10;
	@Bean
	@ConditionalOnEnabledInfoContributor(value = 'env', fallback = InfoContributorFallback.DISABLE)
	@Order(DEFAULT_ORDER)
	public EnvironmentInfoContributor envInfoContributor(ConfigurableEnvironment environment) {
		return new EnvironmentInfoContributor(environment);
	}
	@Bean
	@ConditionalOnEnabledInfoContributor('git')
	@ConditionalOnSingleCandidate(GitProperties.class)
	@ConditionalOnMissingBean
	@Order(DEFAULT_ORDER)
	public GitInfoContributor gitInfoContributor(GitProperties gitProperties,
			InfoContributorProperties infoContributorProperties) {
		return new GitInfoContributor(gitProperties, infoContributorProperties.getGit().getMode());
	}
	@Bean
	@ConditionalOnEnabledInfoContributor('build')
	@ConditionalOnSingleCandidate(BuildProperties.class)
	@Order(DEFAULT_ORDER)
	public InfoContributor buildInfoContributor(BuildProperties buildProperties) {
		return new BuildInfoContributor(buildProperties);
	}
	@Bean
	@ConditionalOnEnabledInfoContributor(value = 'java', fallback = InfoContributorFallback.DISABLE)
	@Order(DEFAULT_ORDER)
	public JavaInfoContributor javaInfoContributor() {
		return new JavaInfoContributor();
	}
	@Bean
	@ConditionalOnEnabledInfoContributor(value = 'os', fallback = InfoContributorFallback.DISABLE)
	@Order(DEFAULT_ORDER)
	public OsInfoContributor osInfoContributor() {
		return new OsInfoContributor();
	}
	@Bean
	@ConditionalOnEnabledInfoContributor(value = 'process', fallback = InfoContributorFallback.DISABLE)
	@Order(DEFAULT_ORDER)
	public ProcessInfoContributor processInfoContributor() {
		return new ProcessInfoContributor();
	}
	@Bean
	@ConditionalOnEnabledInfoContributor(value = 'ssl', fallback = InfoContributorFallback.DISABLE)
	@Order(DEFAULT_ORDER)
	SslInfoContributor sslInfoContributor(SslInfo sslInfo) {
		return new SslInfoContributor(sslInfo);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnEnabledInfoContributor(value = 'ssl', fallback = InfoContributorFallback.DISABLE)
	SslInfo sslInfo(SslBundles sslBundles, SslHealthIndicatorProperties sslHealthIndicatorProperties) {
		return new SslInfo(sslBundles, sslHealthIndicatorProperties.getCertificateValidityWarningThreshold());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.info;
/**
@ConfigurationProperties('management.info')
public class InfoContributorProperties {
	private final Git git = new Git();
	public Git getGit() {
		return this.git;
	}
	public static class Git {
		/**
		 * Mode to use to expose git information.
		 */
		private GitInfoContributor.Mode mode = GitInfoContributor.Mode.SIMPLE;
		public GitInfoContributor.Mode getMode() {
			return this.mode;
		}
		public void setMode(GitInfoContributor.Mode mode) {
			this.mode = mode;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.info;
/*
package org.springframework.boot.actuate.autoconfigure.system;
/**
@ConfigurationProperties(prefix = 'management.health.diskspace')
public class DiskSpaceHealthIndicatorProperties {
	/**
	 * Path used to compute the available disk space.
	 */
	private File path = new File('.');
	/**
	 * Minimum disk space that should be available.
	 */
	private DataSize threshold = DataSize.ofMegabytes(10);
	public File getPath() {
		return this.path;
	}
	public void setPath(File path) {
		this.path = path;
	}
	public DataSize getThreshold() {
		return this.threshold;
	}
	public void setThreshold(DataSize threshold) {
		Assert.isTrue(!threshold.isNegative(), 'threshold must be greater than or equal to 0');
		this.threshold = threshold;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.system;
/*
package org.springframework.boot.actuate.autoconfigure.system;
/**
@AutoConfiguration(before = HealthContributorAutoConfiguration.class)
@ConditionalOnEnabledHealthIndicator('diskspace')
@EnableConfigurationProperties(DiskSpaceHealthIndicatorProperties.class)
public class DiskSpaceHealthContributorAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(name = 'diskSpaceHealthIndicator')
	public DiskSpaceHealthIndicator diskSpaceHealthIndicator(DiskSpaceHealthIndicatorProperties properties) {
		return new DiskSpaceHealthIndicator(properties.getPath(), properties.getThreshold());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.neo4j;
/**
class Neo4jHealthContributorConfigurations {
	@Configuration(proxyBeanMethods = false)
	static class Neo4jConfiguration extends CompositeHealthContributorConfiguration<Neo4jHealthIndicator, Driver> {
		Neo4jConfiguration() {
			super(Neo4jHealthIndicator::new);
		}
		@Bean
		@ConditionalOnMissingBean(name = { 'neo4jHealthIndicator', 'neo4jHealthContributor' })
		HealthContributor neo4jHealthContributor(Map<String, Driver> drivers) {
			return createContributor(drivers);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Flux.class)
	static class Neo4jReactiveConfiguration
			extends CompositeReactiveHealthContributorConfiguration<Neo4jReactiveHealthIndicator, Driver> {
		Neo4jReactiveConfiguration() {
			super(Neo4jReactiveHealthIndicator::new);
		}
		@Bean
		@ConditionalOnMissingBean(name = { 'neo4jHealthIndicator', 'neo4jHealthContributor' })
		ReactiveHealthContributor neo4jHealthContributor(Map<String, Driver> drivers) {
			return createContributor(drivers);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.neo4j;
/*
package org.springframework.boot.actuate.autoconfigure.neo4j;
/**
@AutoConfiguration(after = Neo4jAutoConfiguration.class)
@ConditionalOnClass(Driver.class)
@ConditionalOnBean(Driver.class)
@ConditionalOnEnabledHealthIndicator('neo4j')
@Import({ Neo4jReactiveConfiguration.class, Neo4jConfiguration.class })
public class Neo4jHealthContributorAutoConfiguration {
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.amqp;
/*
package org.springframework.boot.actuate.autoconfigure.amqp;
/**
@AutoConfiguration(after = RabbitAutoConfiguration.class)
@ConditionalOnClass(RabbitTemplate.class)
@ConditionalOnBean(RabbitTemplate.class)
@ConditionalOnEnabledHealthIndicator('rabbit')
public class RabbitHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<RabbitHealthIndicator, RabbitTemplate> {
	public RabbitHealthContributorAutoConfiguration() {
		super(RabbitHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'rabbitHealthIndicator', 'rabbitHealthContributor' })
	public HealthContributor rabbitHealthContributor(Map<String, RabbitTemplate> rabbitTemplates) {
		return createContributor(rabbitTemplates);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.jmx;
/**
@AutoConfiguration(after = { JmxAutoConfiguration.class, EndpointAutoConfiguration.class })
@EnableConfigurationProperties({ JmxEndpointProperties.class, JmxProperties.class })
@ConditionalOnProperty(prefix = 'spring.jmx', name = 'enabled', havingValue = 'true')
public class JmxEndpointAutoConfiguration {
	private final ApplicationContext applicationContext;
	private final JmxEndpointProperties properties;
	private final JmxProperties jmxProperties;
	public JmxEndpointAutoConfiguration(ApplicationContext applicationContext, JmxEndpointProperties properties,
			JmxProperties jmxProperties) {
		this.applicationContext = applicationContext;
		this.properties = properties;
		this.jmxProperties = jmxProperties;
	}
	@Bean
	@ConditionalOnMissingBean(JmxEndpointsSupplier.class)
	public JmxEndpointDiscoverer jmxAnnotationEndpointDiscoverer(ParameterValueMapper parameterValueMapper,
			ObjectProvider<OperationInvokerAdvisor> invokerAdvisors,
			ObjectProvider<EndpointFilter<ExposableJmxEndpoint>> endpointFilters,
			ObjectProvider<OperationFilter<JmxOperation>> operationFilters) {
		return new JmxEndpointDiscoverer(this.applicationContext, parameterValueMapper,
				invokerAdvisors.orderedStream().toList(), endpointFilters.orderedStream().toList(),
				operationFilters.orderedStream().toList());
	}
	@Bean
	@ConditionalOnMissingBean(value = EndpointObjectNameFactory.class, search = SearchStrategy.CURRENT)
	public DefaultEndpointObjectNameFactory endpointObjectNameFactory(MBeanServer mBeanServer) {
		String contextId = ObjectUtils.getIdentityHexString(this.applicationContext);
		return new DefaultEndpointObjectNameFactory(this.properties, this.jmxProperties, mBeanServer, contextId);
	}
	@Bean
	@ConditionalOnSingleCandidate(MBeanServer.class)
	public JmxEndpointExporter jmxMBeanExporter(MBeanServer mBeanServer,
			EndpointObjectNameFactory endpointObjectNameFactory, ObjectProvider<ObjectMapper> objectMapper,
			JmxEndpointsSupplier jmxEndpointsSupplier) {
		JmxOperationResponseMapper responseMapper = new JacksonJmxOperationResponseMapper(
				objectMapper.getIfAvailable());
		return new JmxEndpointExporter(mBeanServer, endpointObjectNameFactory, responseMapper,
				jmxEndpointsSupplier.getEndpoints());
	}
	@Bean
	public IncludeExcludeEndpointFilter<ExposableJmxEndpoint> jmxIncludeExcludePropertyEndpointFilter() {
		JmxEndpointProperties.Exposure exposure = this.properties.getExposure();
		return new IncludeExcludeEndpointFilter<>(ExposableJmxEndpoint.class, exposure.getInclude(),
				exposure.getExclude(), EndpointExposure.JMX.getDefaultIncludes());
	}
	@Bean
	static LazyInitializationExcludeFilter eagerlyInitializeJmxEndpointExporter() {
		return LazyInitializationExcludeFilter.forBeanTypes(JmxEndpointExporter.class);
	}
	@Bean
	OperationFilter<JmxOperation> jmxAccessPropertiesOperationFilter(EndpointAccessResolver endpointAccessResolver) {
		return OperationFilter.byAccess(endpointAccessResolver);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.jmx;
/**
@ConfigurationProperties('management.endpoints.jmx')
public class JmxEndpointProperties {
	private final Exposure exposure = new Exposure();
	/**
	 * Endpoints JMX domain name. Fallback to "spring.jmx.default-domain" if set.
	 */
	private String domain;
	/**
	 * Additional static properties to append to all ObjectNames of MBeans representing
	 * Endpoints.
	 */
	private final Properties staticNames = new Properties();
	public Exposure getExposure() {
		return this.exposure;
	}
	public String getDomain() {
		return this.domain;
	}
	public void setDomain(String domain) {
		this.domain = domain;
	}
	public Properties getStaticNames() {
		return this.staticNames;
	}
	public static class Exposure {
		/**
		 * Endpoint IDs that should be included or "*" for all.
		 */
		private Set<String> include = new LinkedHashSet<>();
		/**
		 * Endpoint IDs that should be excluded or "*" for all.
		 */
		private Set<String> exclude = new LinkedHashSet<>();
		public Set<String> getInclude() {
			return this.include;
		}
		public void setInclude(Set<String> include) {
			this.include = include;
		}
		public Set<String> getExclude() {
			return this.exclude;
		}
		public void setExclude(Set<String> exclude) {
			this.exclude = exclude;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.jmx;
/**
class DefaultEndpointObjectNameFactory implements EndpointObjectNameFactory {
	private final JmxEndpointProperties properties;
	private final JmxProperties jmxProperties;
	private final MBeanServer mBeanServer;
	private final String contextId;
	DefaultEndpointObjectNameFactory(JmxEndpointProperties properties, JmxProperties jmxProperties,
			MBeanServer mBeanServer, String contextId) {
		this.properties = properties;
		this.jmxProperties = jmxProperties;
		this.mBeanServer = mBeanServer;
		this.contextId = contextId;
	}
	@Override
	public ObjectName getObjectName(ExposableJmxEndpoint endpoint) throws MalformedObjectNameException {
		StringBuilder builder = new StringBuilder(determineDomain());
		builder.append(':type=Endpoint');
		builder.append(',name=').append(StringUtils.capitalize(endpoint.getEndpointId().toString()));
		String baseName = builder.toString();
		if (this.mBeanServer != null && hasMBean(baseName)) {
			builder.append(',context=').append(this.contextId);
		}
		if (this.jmxProperties.isUniqueNames()) {
			String identity = ObjectUtils.getIdentityHexString(endpoint);
			builder.append(',identity=').append(identity);
		}
		builder.append(getStaticNames());
		return ObjectNameManager.getInstance(builder.toString());
	}
	private String determineDomain() {
		if (StringUtils.hasText(this.properties.getDomain())) {
			return this.properties.getDomain();
		}
		if (StringUtils.hasText(this.jmxProperties.getDefaultDomain())) {
			return this.jmxProperties.getDefaultDomain();
		}
		return 'org.springframework.boot';
	}
	private boolean hasMBean(String baseObjectName) throws MalformedObjectNameException {
		ObjectName query = new ObjectName(baseObjectName + ',*');
		return !this.mBeanServer.queryNames(query, null).isEmpty();
	}
	private String getStaticNames() {
		if (this.properties.getStaticNames().isEmpty()) {
			return '';
		}
		StringBuilder builder = new StringBuilder();
		this.properties.getStaticNames()
			.forEach((name, value) -> builder.append(',').append(name).append('=').append(value));
		return builder.toString();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.jmx;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
@ConfigurationProperties(prefix = 'management.endpoints.web.cors')
public class CorsEndpointProperties {
	/**
	 * List of origins to allow. "*" allows all origins. When credentials are allowed, "*"
	 * cannot be used and origin patterns should be configured instead. When no allowed
	 * origins or allowed origin patterns are set, CORS support is disabled.
	 */
	private List<String> allowedOrigins = new ArrayList<>();
	/**
	 * List of origin patterns to allow. Unlike allowed origins which only supports "*",
	 * origin patterns are more flexible (for example "https://*.example.com") and can be
	 * used when credentials are allowed. When no allowed origin patterns or allowed
	 * origins are set, CORS support is disabled.
	 */
	private List<String> allowedOriginPatterns = new ArrayList<>();
	/**
	 * List of methods to allow. "*" allows all methods. When not set, defaults to GET.
	 */
	private List<String> allowedMethods = new ArrayList<>();
	/**
	 * List of headers to allow in a request. "*" allows all headers.
	 */
	private List<String> allowedHeaders = new ArrayList<>();
	/**
	 * List of headers to include in a response.
	 */
	private List<String> exposedHeaders = new ArrayList<>();
	/**
	 * Whether credentials are supported. When not set, credentials are not supported.
	 */
	private Boolean allowCredentials;
	/**
	 * How long the response from a pre-flight request can be cached by clients. If a
	 * duration suffix is not specified, seconds will be used.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration maxAge = Duration.ofSeconds(1800);
	public List<String> getAllowedOrigins() {
		return this.allowedOrigins;
	}
	public void setAllowedOrigins(List<String> allowedOrigins) {
		this.allowedOrigins = allowedOrigins;
	}
	public List<String> getAllowedOriginPatterns() {
		return this.allowedOriginPatterns;
	}
	public void setAllowedOriginPatterns(List<String> allowedOriginPatterns) {
		this.allowedOriginPatterns = allowedOriginPatterns;
	}
	public List<String> getAllowedMethods() {
		return this.allowedMethods;
	}
	public void setAllowedMethods(List<String> allowedMethods) {
		this.allowedMethods = allowedMethods;
	}
	public List<String> getAllowedHeaders() {
		return this.allowedHeaders;
	}
	public void setAllowedHeaders(List<String> allowedHeaders) {
		this.allowedHeaders = allowedHeaders;
	}
	public List<String> getExposedHeaders() {
		return this.exposedHeaders;
	}
	public void setExposedHeaders(List<String> exposedHeaders) {
		this.exposedHeaders = exposedHeaders;
	}
	public Boolean getAllowCredentials() {
		return this.allowCredentials;
	}
	public void setAllowCredentials(Boolean allowCredentials) {
		this.allowCredentials = allowCredentials;
	}
	public Duration getMaxAge() {
		return this.maxAge;
	}
	public void setMaxAge(Duration maxAge) {
		this.maxAge = maxAge;
	}
	public CorsConfiguration toCorsConfiguration() {
		if (CollectionUtils.isEmpty(this.allowedOrigins) && CollectionUtils.isEmpty(this.allowedOriginPatterns)) {
			return null;
		}
		PropertyMapper map = PropertyMapper.get();
		CorsConfiguration configuration = new CorsConfiguration();
		map.from(this::getAllowedOrigins).to(configuration::setAllowedOrigins);
		map.from(this::getAllowedOriginPatterns).to(configuration::setAllowedOriginPatterns);
		map.from(this::getAllowedHeaders).whenNot(CollectionUtils::isEmpty).to(configuration::setAllowedHeaders);
		map.from(this::getAllowedMethods).whenNot(CollectionUtils::isEmpty).to(configuration::setAllowedMethods);
		map.from(this::getExposedHeaders).whenNot(CollectionUtils::isEmpty).to(configuration::setExposedHeaders);
		map.from(this::getMaxAge).whenNonNull().as(Duration::getSeconds).to(configuration::setMaxAge);
		map.from(this::getAllowCredentials).whenNonNull().to(configuration::setAllowCredentials);
		return configuration;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
@Order(Ordered.HIGHEST_PRECEDENCE)
class MappingWebEndpointPathMapper implements PathMapper {
	private final Map<EndpointId, String> pathMapping;
	MappingWebEndpointPathMapper(Map<String, String> pathMapping) {
		this.pathMapping = new HashMap<>();
		pathMapping.forEach((id, path) -> this.pathMapping.put(EndpointId.fromPropertyValue(id), path));
	}
	@Override
	public String getRootPath(EndpointId endpointId) {
		String path = this.pathMapping.get(endpointId);
		return StringUtils.hasText(path) ? path : null;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.jersey;
/**
@ManagementContextConfiguration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(ResourceConfig.class)
@ConditionalOnBean(WebEndpointsSupplier.class)
@ConditionalOnMissingBean(type = 'org.springframework.web.servlet.DispatcherServlet')
class JerseyWebEndpointManagementContextConfiguration {
	private static final EndpointId HEALTH_ENDPOINT_ID = EndpointId.of('health');
	@Bean
	@SuppressWarnings('removal')
	JerseyWebEndpointsResourcesRegistrar jerseyWebEndpointsResourcesRegistrar(Environment environment,
			WebEndpointsSupplier webEndpointsSupplier,
			org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier servletEndpointsSupplier,
			EndpointMediaTypes endpointMediaTypes, WebEndpointProperties webEndpointProperties) {
		String basePath = webEndpointProperties.getBasePath();
		boolean shouldRegisterLinks = shouldRegisterLinksMapping(webEndpointProperties, environment, basePath);
		return new JerseyWebEndpointsResourcesRegistrar(webEndpointsSupplier, servletEndpointsSupplier,
				endpointMediaTypes, basePath, shouldRegisterLinks);
	}
	@Bean
	@ConditionalOnManagementPort(ManagementPortType.DIFFERENT)
	@ConditionalOnBean(HealthEndpoint.class)
	@ConditionalOnAvailableEndpoint(endpoint = HealthEndpoint.class, exposure = EndpointExposure.WEB)
	JerseyAdditionalHealthEndpointPathsManagementResourcesRegistrar jerseyDifferentPortAdditionalHealthEndpointPathsResourcesRegistrar(
			WebEndpointsSupplier webEndpointsSupplier, HealthEndpointGroups healthEndpointGroups) {
		Collection<ExposableWebEndpoint> webEndpoints = webEndpointsSupplier.getEndpoints();
		ExposableWebEndpoint healthEndpoint = webEndpoints.stream()
			.filter((endpoint) -> endpoint.getEndpointId().equals(HEALTH_ENDPOINT_ID))
			.findFirst()
			.orElse(null);
		return new JerseyAdditionalHealthEndpointPathsManagementResourcesRegistrar(healthEndpoint,
				healthEndpointGroups);
	}
	@Bean
	@ConditionalOnBean(EndpointObjectMapper.class)
	ResourceConfigCustomizer endpointObjectMapperResourceConfigCustomizer(EndpointObjectMapper endpointObjectMapper) {
		return (config) -> config.register(new EndpointObjectMapperContextResolver(endpointObjectMapper),
				ContextResolver.class);
	}
	private boolean shouldRegisterLinksMapping(WebEndpointProperties properties, Environment environment,
			String basePath) {
		return properties.getDiscovery().isEnabled() && (StringUtils.hasText(basePath)
				|| ManagementPortType.get(environment).equals(ManagementPortType.DIFFERENT));
	}
	/**
	 * Register endpoints with the {@link ResourceConfig} for the management context.
	 */
	@SuppressWarnings('removal')
	static class JerseyWebEndpointsResourcesRegistrar implements ManagementContextResourceConfigCustomizer {
		private final WebEndpointsSupplier webEndpointsSupplier;
		private final org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier servletEndpointsSupplier;
		private final EndpointMediaTypes mediaTypes;
		private final String basePath;
		private final boolean shouldRegisterLinks;
		JerseyWebEndpointsResourcesRegistrar(WebEndpointsSupplier webEndpointsSupplier,
				org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier servletEndpointsSupplier,
				EndpointMediaTypes endpointMediaTypes, String basePath, boolean shouldRegisterLinks) {
			this.webEndpointsSupplier = webEndpointsSupplier;
			this.servletEndpointsSupplier = servletEndpointsSupplier;
			this.mediaTypes = endpointMediaTypes;
			this.basePath = basePath;
			this.shouldRegisterLinks = shouldRegisterLinks;
		}
		@Override
		public void customize(ResourceConfig config) {
			register(config);
		}
		private void register(ResourceConfig config) {
			Collection<ExposableWebEndpoint> webEndpoints = this.webEndpointsSupplier.getEndpoints();
			Collection<org.springframework.boot.actuate.endpoint.web.ExposableServletEndpoint> servletEndpoints = this.servletEndpointsSupplier
				.getEndpoints();
			EndpointLinksResolver linksResolver = getLinksResolver(webEndpoints, servletEndpoints);
			EndpointMapping mapping = new EndpointMapping(this.basePath);
			Collection<Resource> endpointResources = new JerseyEndpointResourceFactory().createEndpointResources(
					mapping, webEndpoints, this.mediaTypes, linksResolver, this.shouldRegisterLinks);
			register(endpointResources, config);
		}
		private EndpointLinksResolver getLinksResolver(Collection<ExposableWebEndpoint> webEndpoints,
				Collection<org.springframework.boot.actuate.endpoint.web.ExposableServletEndpoint> servletEndpoints) {
			List<ExposableEndpoint<?>> endpoints = new ArrayList<>(webEndpoints.size() + servletEndpoints.size());
			endpoints.addAll(webEndpoints);
			endpoints.addAll(servletEndpoints);
			return new EndpointLinksResolver(endpoints, this.basePath);
		}
		private void register(Collection<Resource> resources, ResourceConfig config) {
			config.registerResources(new HashSet<>(resources));
		}
	}
	class JerseyAdditionalHealthEndpointPathsManagementResourcesRegistrar
			implements ManagementContextResourceConfigCustomizer {
		private final ExposableWebEndpoint healthEndpoint;
		private final HealthEndpointGroups groups;
		JerseyAdditionalHealthEndpointPathsManagementResourcesRegistrar(ExposableWebEndpoint healthEndpoint,
				HealthEndpointGroups groups) {
			this.healthEndpoint = healthEndpoint;
			this.groups = groups;
		}
		@Override
		public void customize(ResourceConfig config) {
			if (this.healthEndpoint != null) {
				register(config);
			}
		}
		private void register(ResourceConfig config) {
			EndpointMapping mapping = new EndpointMapping('');
			JerseyHealthEndpointAdditionalPathResourceFactory resourceFactory = new JerseyHealthEndpointAdditionalPathResourceFactory(
					WebServerNamespace.MANAGEMENT, this.groups);
			Collection<Resource> endpointResources = resourceFactory
				.createEndpointResources(mapping, Collections.singletonList(this.healthEndpoint))
				.stream()
				.filter(Objects::nonNull)
				.toList();
			register(endpointResources, config);
		}
		private void register(Collection<Resource> resources, ResourceConfig config) {
			config.registerResources(new HashSet<>(resources));
		}
	}
	/**
	 * {@link ContextResolver} used to obtain the {@link ObjectMapper} that should be used
	 * for {@link OperationResponseBody} instances.
	 */
	@Priority(Priorities.USER - 100)
	private static final class EndpointObjectMapperContextResolver implements ContextResolver<ObjectMapper> {
		private final EndpointObjectMapper endpointObjectMapper;
		private EndpointObjectMapperContextResolver(EndpointObjectMapper endpointObjectMapper) {
			this.endpointObjectMapper = endpointObjectMapper;
		}
		@Override
		public ObjectMapper getContext(Class<?> type) {
			return OperationResponseBody.class.isAssignableFrom(type) ? this.endpointObjectMapper.get() : null;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.web.jersey;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.servlet;
/**
@ManagementContextConfiguration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(DispatcherServlet.class)
@ConditionalOnBean({ DispatcherServlet.class, WebEndpointsSupplier.class })
@EnableConfigurationProperties(CorsEndpointProperties.class)
public class WebMvcEndpointManagementContextConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@SuppressWarnings('removal')
	public WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping(WebEndpointsSupplier webEndpointsSupplier,
			org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier servletEndpointsSupplier,
			org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier controllerEndpointsSupplier,
			EndpointMediaTypes endpointMediaTypes, CorsEndpointProperties corsProperties,
			WebEndpointProperties webEndpointProperties, Environment environment) {
		List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>();
		Collection<ExposableWebEndpoint> webEndpoints = webEndpointsSupplier.getEndpoints();
		allEndpoints.addAll(webEndpoints);
		allEndpoints.addAll(servletEndpointsSupplier.getEndpoints());
		allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints());
		String basePath = webEndpointProperties.getBasePath();
		EndpointMapping endpointMapping = new EndpointMapping(basePath);
		boolean shouldRegisterLinksMapping = shouldRegisterLinksMapping(webEndpointProperties, environment, basePath);
		return new WebMvcEndpointHandlerMapping(endpointMapping, webEndpoints, endpointMediaTypes,
				corsProperties.toCorsConfiguration(), new EndpointLinksResolver(allEndpoints, basePath),
				shouldRegisterLinksMapping);
	}
	private boolean shouldRegisterLinksMapping(WebEndpointProperties webEndpointProperties, Environment environment,
			String basePath) {
		return webEndpointProperties.getDiscovery().isEnabled() && (StringUtils.hasText(basePath)
				|| ManagementPortType.get(environment).equals(ManagementPortType.DIFFERENT));
	}
	@Bean
	@ConditionalOnManagementPort(ManagementPortType.DIFFERENT)
	@ConditionalOnBean(HealthEndpoint.class)
	@ConditionalOnAvailableEndpoint(endpoint = HealthEndpoint.class, exposure = EndpointExposure.WEB)
	public AdditionalHealthEndpointPathsWebMvcHandlerMapping managementHealthEndpointWebMvcHandlerMapping(
			WebEndpointsSupplier webEndpointsSupplier, HealthEndpointGroups groups) {
		Collection<ExposableWebEndpoint> webEndpoints = webEndpointsSupplier.getEndpoints();
		ExposableWebEndpoint healthEndpoint = webEndpoints.stream()
			.filter(this::isHealthEndpoint)
			.findFirst()
			.orElse(null);
		return new AdditionalHealthEndpointPathsWebMvcHandlerMapping(healthEndpoint,
				groups.getAllWithAdditionalPath(WebServerNamespace.MANAGEMENT));
	}
	private boolean isHealthEndpoint(ExposableWebEndpoint endpoint) {
		return endpoint.getEndpointId().equals(HealthEndpoint.ID);
	}
	@Bean
	@ConditionalOnMissingBean
	@SuppressWarnings('removal')
	@Deprecated(since = '3.3.5', forRemoval = true)
	public org.springframework.boot.actuate.endpoint.web.servlet.ControllerEndpointHandlerMapping controllerEndpointHandlerMapping(
			org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier controllerEndpointsSupplier,
			CorsEndpointProperties corsProperties, WebEndpointProperties webEndpointProperties,
			EndpointAccessResolver endpointAccessResolver) {
		EndpointMapping endpointMapping = new EndpointMapping(webEndpointProperties.getBasePath());
		return new org.springframework.boot.actuate.endpoint.web.servlet.ControllerEndpointHandlerMapping(
				endpointMapping, controllerEndpointsSupplier.getEndpoints(), corsProperties.toCorsConfiguration(),
				endpointAccessResolver);
	}
	@Bean
	@ConditionalOnBean(EndpointObjectMapper.class)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	static EndpointObjectMapperWebMvcConfigurer endpointObjectMapperWebMvcConfigurer(
			EndpointObjectMapper endpointObjectMapper) {
		return new EndpointObjectMapperWebMvcConfigurer(endpointObjectMapper);
	}
	/**
	 * {@link WebMvcConfigurer} to apply {@link EndpointObjectMapper} for
	 * {@link OperationResponseBody} to {@link MappingJackson2HttpMessageConverter}
	 * instances.
	 */
	static class EndpointObjectMapperWebMvcConfigurer implements WebMvcConfigurer {
		private static final List<MediaType> MEDIA_TYPES = Collections
			.unmodifiableList(Arrays.asList(MediaType.APPLICATION_JSON, new MediaType('application', '*+json')));
		private final EndpointObjectMapper endpointObjectMapper;
		EndpointObjectMapperWebMvcConfigurer(EndpointObjectMapper endpointObjectMapper) {
			this.endpointObjectMapper = endpointObjectMapper;
		}
		@Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			for (HttpMessageConverter<?> converter : converters) {
				if (converter instanceof MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter) {
					configure(mappingJackson2HttpMessageConverter);
				}
			}
		}
		private void configure(MappingJackson2HttpMessageConverter converter) {
			converter.registerObjectMappersForType(OperationResponseBody.class, (associations) -> {
				ObjectMapper objectMapper = this.endpointObjectMapper.get();
				MEDIA_TYPES.forEach((mimeType) -> associations.put(mimeType, objectMapper));
			});
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.web.servlet;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
@ManagementContextConfiguration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
public class ServletEndpointManagementContextConfiguration {
	@Bean
	@SuppressWarnings('removal')
	public IncludeExcludeEndpointFilter<org.springframework.boot.actuate.endpoint.web.ExposableServletEndpoint> servletExposeExcludePropertyEndpointFilter(
			WebEndpointProperties properties) {
		WebEndpointProperties.Exposure exposure = properties.getExposure();
		return new IncludeExcludeEndpointFilter<>(
				org.springframework.boot.actuate.endpoint.web.ExposableServletEndpoint.class, exposure.getInclude(),
				exposure.getExclude());
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(DispatcherServlet.class)
	public static class WebMvcServletEndpointManagementContextConfiguration {
		@Bean
		@SuppressWarnings({ 'deprecation', 'removal' })
		public org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar servletEndpointRegistrar(
				WebEndpointProperties properties,
				org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier servletEndpointsSupplier,
				DispatcherServletPath dispatcherServletPath, EndpointAccessResolver endpointAccessResolver) {
			return new org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar(
					dispatcherServletPath.getRelativePath(properties.getBasePath()),
					servletEndpointsSupplier.getEndpoints(), endpointAccessResolver);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ResourceConfig.class)
	@ConditionalOnMissingClass('org.springframework.web.servlet.DispatcherServlet')
	public static class JerseyServletEndpointManagementContextConfiguration {
		@Bean
		@SuppressWarnings({ 'deprecation', 'removal' })
		public org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar servletEndpointRegistrar(
				WebEndpointProperties properties,
				org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier servletEndpointsSupplier,
				JerseyApplicationPath jerseyApplicationPath, EndpointAccessResolver endpointAccessResolver) {
			return new org.springframework.boot.actuate.endpoint.web.ServletEndpointRegistrar(
					jerseyApplicationPath.getRelativePath(properties.getBasePath()),
					servletEndpointsSupplier.getEndpoints(), endpointAccessResolver);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
@ConfigurationProperties(prefix = 'management.endpoints.web')
public class WebEndpointProperties {
	private final Exposure exposure = new Exposure();
	/**
	 * Base path for Web endpoints. Relative to the servlet context path
	 * (server.servlet.context-path) or WebFlux base path (spring.webflux.base-path) when
	 * the management server is sharing the main server port. Relative to the management
	 * server base path (management.server.base-path) when a separate management server
	 * port (management.server.port) is configured.
	 */
	private String basePath = '/actuator';
	/**
	 * Mapping between endpoint IDs and the path that should expose them.
	 */
	private final Map<String, String> pathMapping = new LinkedHashMap<>();
	private final Discovery discovery = new Discovery();
	public Exposure getExposure() {
		return this.exposure;
	}
	public String getBasePath() {
		return this.basePath;
	}
	public void setBasePath(String basePath) {
		Assert.isTrue(basePath.isEmpty() || basePath.startsWith('/'), 'Base path must start with "/" or be empty');
		this.basePath = cleanBasePath(basePath);
	}
	private String cleanBasePath(String basePath) {
		if (StringUtils.hasText(basePath) && basePath.endsWith('/')) {
			return basePath.substring(0, basePath.length() - 1);
		}
		return basePath;
	}
	public Map<String, String> getPathMapping() {
		return this.pathMapping;
	}
	public Discovery getDiscovery() {
		return this.discovery;
	}
	public static class Exposure {
		/**
		 * Endpoint IDs that should be included or "*" for all.
		 */
		private Set<String> include = new LinkedHashSet<>();
		/**
		 * Endpoint IDs that should be excluded or "*" for all.
		 */
		private Set<String> exclude = new LinkedHashSet<>();
		public Set<String> getInclude() {
			return this.include;
		}
		public void setInclude(Set<String> include) {
			this.include = include;
		}
		public Set<String> getExclude() {
			return this.exclude;
		}
		public void setExclude(Set<String> exclude) {
			this.exclude = exclude;
		}
	}
	public static class Discovery {
		/**
		 * Whether the discovery page is enabled.
		 */
		private boolean enabled = true;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web;
/**
@AutoConfiguration(after = EndpointAutoConfiguration.class)
@ConditionalOnWebApplication
@EnableConfigurationProperties(WebEndpointProperties.class)
public class WebEndpointAutoConfiguration {
	private final ApplicationContext applicationContext;
	private final WebEndpointProperties properties;
	public WebEndpointAutoConfiguration(ApplicationContext applicationContext, WebEndpointProperties properties) {
		this.applicationContext = applicationContext;
		this.properties = properties;
	}
	@Bean
	public PathMapper webEndpointPathMapper() {
		return new MappingWebEndpointPathMapper(this.properties.getPathMapping());
	}
	@Bean
	@ConditionalOnMissingBean
	public EndpointMediaTypes endpointMediaTypes() {
		return EndpointMediaTypes.DEFAULT;
	}
	@Bean
	@ConditionalOnMissingBean(WebEndpointsSupplier.class)
	public WebEndpointDiscoverer webEndpointDiscoverer(ParameterValueMapper parameterValueMapper,
			EndpointMediaTypes endpointMediaTypes, ObjectProvider<PathMapper> endpointPathMappers,
			ObjectProvider<AdditionalPathsMapper> additionalPathsMappers,
			ObjectProvider<OperationInvokerAdvisor> invokerAdvisors,
			ObjectProvider<EndpointFilter<ExposableWebEndpoint>> endpointFilters,
			ObjectProvider<OperationFilter<WebOperation>> operationFilters) {
		return new WebEndpointDiscoverer(this.applicationContext, parameterValueMapper, endpointMediaTypes,
				endpointPathMappers.orderedStream().toList(), additionalPathsMappers.orderedStream().toList(),
				invokerAdvisors.orderedStream().toList(), endpointFilters.orderedStream().toList(),
				operationFilters.orderedStream().toList());
	}
	@Bean
	@ConditionalOnMissingBean(org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier.class)
	@SuppressWarnings({ 'deprecation', 'removal' })
	public org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointDiscoverer controllerEndpointDiscoverer(
			ObjectProvider<PathMapper> endpointPathMappers,
			ObjectProvider<Collection<EndpointFilter<org.springframework.boot.actuate.endpoint.web.annotation.ExposableControllerEndpoint>>> filters) {
		return new org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointDiscoverer(
				this.applicationContext, endpointPathMappers.orderedStream().toList(),
				filters.getIfAvailable(Collections::emptyList));
	}
	@Bean
	@ConditionalOnMissingBean
	public PathMappedEndpoints pathMappedEndpoints(Collection<EndpointsSupplier<?>> endpointSuppliers) {
		return new PathMappedEndpoints(this.properties.getBasePath(), endpointSuppliers);
	}
	@Bean
	public IncludeExcludeEndpointFilter<ExposableWebEndpoint> webExposeExcludePropertyEndpointFilter() {
		WebEndpointProperties.Exposure exposure = this.properties.getExposure();
		return new IncludeExcludeEndpointFilter<>(ExposableWebEndpoint.class, exposure.getInclude(),
				exposure.getExclude(), EndpointExposure.WEB.getDefaultIncludes());
	}
	@Bean
	@SuppressWarnings('removal')
	public IncludeExcludeEndpointFilter<org.springframework.boot.actuate.endpoint.web.annotation.ExposableControllerEndpoint> controllerExposeExcludePropertyEndpointFilter() {
		WebEndpointProperties.Exposure exposure = this.properties.getExposure();
		return new IncludeExcludeEndpointFilter<>(
				org.springframework.boot.actuate.endpoint.web.annotation.ExposableControllerEndpoint.class,
				exposure.getInclude(), exposure.getExclude());
	}
	@Bean
	OperationFilter<WebOperation> webAccessPropertiesOperationFilter(EndpointAccessResolver endpointAccessResolver) {
		return OperationFilter.byAccess(endpointAccessResolver);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	static class WebEndpointServletConfiguration {
		@Bean
		@SuppressWarnings({ 'deprecation', 'removal' })
		@ConditionalOnMissingBean(org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointsSupplier.class)
		org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointDiscoverer servletEndpointDiscoverer(
				ApplicationContext applicationContext, ObjectProvider<PathMapper> endpointPathMappers,
				ObjectProvider<EndpointFilter<org.springframework.boot.actuate.endpoint.web.ExposableServletEndpoint>> filters) {
			return new org.springframework.boot.actuate.endpoint.web.annotation.ServletEndpointDiscoverer(
					applicationContext, endpointPathMappers.orderedStream().toList(), filters.orderedStream().toList());
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.web.reactive;
/**
@ManagementContextConfiguration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.REACTIVE)
@ConditionalOnClass({ DispatcherHandler.class, HttpHandler.class })
@ConditionalOnBean(WebEndpointsSupplier.class)
@EnableConfigurationProperties(CorsEndpointProperties.class)
public class WebFluxEndpointManagementContextConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@SuppressWarnings('removal')
	public WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping(WebEndpointsSupplier webEndpointsSupplier,
			org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier controllerEndpointsSupplier,
			EndpointMediaTypes endpointMediaTypes, CorsEndpointProperties corsProperties,
			WebEndpointProperties webEndpointProperties, Environment environment) {
		String basePath = webEndpointProperties.getBasePath();
		EndpointMapping endpointMapping = new EndpointMapping(basePath);
		Collection<ExposableWebEndpoint> endpoints = webEndpointsSupplier.getEndpoints();
		List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>();
		allEndpoints.addAll(endpoints);
		allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints());
		return new WebFluxEndpointHandlerMapping(endpointMapping, endpoints, endpointMediaTypes,
				corsProperties.toCorsConfiguration(), new EndpointLinksResolver(allEndpoints, basePath),
				shouldRegisterLinksMapping(webEndpointProperties, environment, basePath));
	}
	private boolean shouldRegisterLinksMapping(WebEndpointProperties properties, Environment environment,
			String basePath) {
		return properties.getDiscovery().isEnabled() && (StringUtils.hasText(basePath)
				|| ManagementPortType.get(environment) == ManagementPortType.DIFFERENT);
	}
	@Bean
	@ConditionalOnManagementPort(ManagementPortType.DIFFERENT)
	@ConditionalOnAvailableEndpoint(endpoint = HealthEndpoint.class, exposure = EndpointExposure.WEB)
	@ConditionalOnBean(HealthEndpoint.class)
	public AdditionalHealthEndpointPathsWebFluxHandlerMapping managementHealthEndpointWebFluxHandlerMapping(
			WebEndpointsSupplier webEndpointsSupplier, HealthEndpointGroups groups) {
		Collection<ExposableWebEndpoint> webEndpoints = webEndpointsSupplier.getEndpoints();
		ExposableWebEndpoint healthEndpoint = webEndpoints.stream()
			.filter((endpoint) -> endpoint.getEndpointId().equals(HealthEndpoint.ID))
			.findFirst()
			.orElse(null);
		return new AdditionalHealthEndpointPathsWebFluxHandlerMapping(new EndpointMapping(''), healthEndpoint,
				groups.getAllWithAdditionalPath(WebServerNamespace.MANAGEMENT));
	}
	@Bean
	@ConditionalOnMissingBean
	@SuppressWarnings('removal')
	@Deprecated(since = '3.3.5', forRemoval = true)
	public org.springframework.boot.actuate.endpoint.web.reactive.ControllerEndpointHandlerMapping controllerEndpointHandlerMapping(
			org.springframework.boot.actuate.endpoint.web.annotation.ControllerEndpointsSupplier controllerEndpointsSupplier,
			CorsEndpointProperties corsProperties, WebEndpointProperties webEndpointProperties,
			EndpointAccessResolver endpointAccessResolver) {
		EndpointMapping endpointMapping = new EndpointMapping(webEndpointProperties.getBasePath());
		return new org.springframework.boot.actuate.endpoint.web.reactive.ControllerEndpointHandlerMapping(
				endpointMapping, controllerEndpointsSupplier.getEndpoints(), corsProperties.toCorsConfiguration(),
				endpointAccessResolver);
	}
	@Bean
	@ConditionalOnBean(EndpointObjectMapper.class)
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	static ServerCodecConfigurerEndpointObjectMapperBeanPostProcessor serverCodecConfigurerEndpointObjectMapperBeanPostProcessor(
			ObjectProvider<EndpointObjectMapper> endpointObjectMapper) {
		return new ServerCodecConfigurerEndpointObjectMapperBeanPostProcessor(
				SingletonSupplier.of(endpointObjectMapper::getObject));
	}
	/**
	 * {@link BeanPostProcessor} to apply {@link EndpointObjectMapper} for
	 * {@link OperationResponseBody} to {@link Jackson2JsonEncoder} instances.
	 */
	static class ServerCodecConfigurerEndpointObjectMapperBeanPostProcessor implements BeanPostProcessor {
		private static final List<MediaType> MEDIA_TYPES = Collections
			.unmodifiableList(Arrays.asList(MediaType.APPLICATION_JSON, new MediaType('application', '*+json')));
		private final Supplier<EndpointObjectMapper> endpointObjectMapper;
		ServerCodecConfigurerEndpointObjectMapperBeanPostProcessor(
				Supplier<EndpointObjectMapper> endpointObjectMapper) {
			this.endpointObjectMapper = endpointObjectMapper;
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			if (bean instanceof ServerCodecConfigurer serverCodecConfigurer) {
				process(serverCodecConfigurer);
			}
			return bean;
		}
		private void process(ServerCodecConfigurer configurer) {
			for (HttpMessageWriter<?> writer : configurer.getWriters()) {
				if (writer instanceof EncoderHttpMessageWriter<?> encoderHttpMessageWriter) {
					process((encoderHttpMessageWriter).getEncoder());
				}
			}
		}
		private void process(Encoder<?> encoder) {
			if (encoder instanceof Jackson2JsonEncoder jackson2JsonEncoder) {
				jackson2JsonEncoder.registerObjectMappersForType(OperationResponseBody.class, (associations) -> {
					ObjectMapper objectMapper = this.endpointObjectMapper.get().get();
					MEDIA_TYPES.forEach((mimeType) -> associations.put(mimeType, objectMapper));
				});
			}
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.web.reactive;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint;
/**
class EndpointIdTimeToLivePropertyFunction implements Function<EndpointId, Long> {
	private static final Bindable<Duration> DURATION = Bindable.of(Duration.class);
	private final Environment environment;
	/**
	 * Create a new instance with the {@link PropertyResolver} to use.
	 * @param environment the environment
	 */
	EndpointIdTimeToLivePropertyFunction(Environment environment) {
		this.environment = environment;
	}
	@Override
	public Long apply(EndpointId endpointId) {
		String name = String.format('management.endpoint.%s.cache.time-to-live', endpointId.toLowerCaseString());
		BindResult<Duration> duration = Binder.get(this.environment).bind(name, DURATION);
		return duration.map(Duration::toMillis).orElse(null);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint;
/**
public class PropertiesEndpointAccessResolver implements EndpointAccessResolver {
	private static final String DEFAULT_ACCESS_KEY = 'management.endpoints.access.default';
	private static final String ENABLED_BY_DEFAULT_KEY = 'management.endpoints.enabled-by-default';
	private final PropertyResolver properties;
	private final Access endpointsDefaultAccess;
	private final Access maxPermittedAccess;
	private final Map<EndpointId, Access> accessCache = new ConcurrentHashMap<>();
	public PropertiesEndpointAccessResolver(PropertyResolver properties) {
		this.properties = properties;
		this.endpointsDefaultAccess = determineDefaultAccess(properties);
		this.maxPermittedAccess = properties.getProperty('management.endpoints.access.max-permitted', Access.class,
				Access.UNRESTRICTED);
	}
	private static Access determineDefaultAccess(PropertyResolver properties) {
		Access defaultAccess = properties.getProperty(DEFAULT_ACCESS_KEY, Access.class);
		Boolean endpointsEnabledByDefault = properties.getProperty(ENABLED_BY_DEFAULT_KEY, Boolean.class);
		MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
			entries.put(DEFAULT_ACCESS_KEY, defaultAccess);
			entries.put(ENABLED_BY_DEFAULT_KEY, endpointsEnabledByDefault);
		});
		if (defaultAccess != null) {
			return defaultAccess;
		}
		if (endpointsEnabledByDefault != null) {
			return endpointsEnabledByDefault ? org.springframework.boot.actuate.endpoint.Access.UNRESTRICTED
					: org.springframework.boot.actuate.endpoint.Access.NONE;
		}
		return null;
	}
	@Override
	public Access accessFor(EndpointId endpointId, Access defaultAccess) {
		return this.accessCache.computeIfAbsent(endpointId,
				(key) -> resolveAccess(endpointId, defaultAccess).cap(this.maxPermittedAccess));
	}
	private Access resolveAccess(EndpointId endpointId, Access defaultAccess) {
		String accessKey = 'management.endpoint.%s.access'.formatted(endpointId);
		String enabledKey = 'management.endpoint.%s.enabled'.formatted(endpointId);
		Access access = this.properties.getProperty(accessKey, Access.class);
		Boolean enabled = this.properties.getProperty(enabledKey, Boolean.class);
		MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
			entries.put(accessKey, access);
			entries.put(enabledKey, enabled);
		});
		if (access != null) {
			return access;
		}
		if (enabled != null) {
			return (enabled) ? Access.UNRESTRICTED : Access.NONE;
		}
		return (this.endpointsDefaultAccess != null) ? this.endpointsDefaultAccess : defaultAccess;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.condition;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.METHOD, ElementType.TYPE })
@Documented
@Conditional(OnAvailableEndpointCondition.class)
public @interface ConditionalOnAvailableEndpoint {
	/**
	 * Alias for {@link #endpoint()}.
	 * @return the endpoint type to check
	 * @since 3.4.0
	 */
	@AliasFor(attribute = 'endpoint')
	Class<?> value() default Void.class;
	/**
	 * The endpoint type that should be checked. Inferred when the return type of the
	 * {@code @Bean} method is either an {@link Endpoint @Endpoint} or an
	 * {@link EndpointExtension @EndpointExtension}.
	 * @return the endpoint type to check
	 */
	@AliasFor(attribute = 'value')
	Class<?> endpoint() default Void.class;
	/**
	 * Technologies to check the exposure of the endpoint on while considering it to be
	 * available.
	 * @return the technologies to check
	 * @since 2.6.0
	 */
	EndpointExposure[] exposure() default {};
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.condition;
/**
public interface EndpointExposureOutcomeContributor {
	/**
	 * Return if the given endpoint is exposed for the given set of exposure technologies.
	 * @param endpointId the endpoint ID
	 * @param exposures the exposure technologies to check
	 * @param message the condition message builder
	 * @return a {@link ConditionOutcome#isMatch() matching} {@link ConditionOutcome} if
	 * the endpoint is exposed or {@code null} if the contributor should not apply
	 */
	ConditionOutcome getExposureOutcome(EndpointId endpointId, Set<EndpointExposure> exposures,
			ConditionMessage.Builder message);
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.condition;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.condition;
/**
class OnAvailableEndpointCondition extends SpringBootCondition {
	private static final String JMX_ENABLED_KEY = 'spring.jmx.enabled';
	private static final Map<Environment, EndpointAccessResolver> accessResolversCache = new ConcurrentReferenceHashMap<>();
	private static final Map<Environment, Set<EndpointExposureOutcomeContributor>> exposureOutcomeContributorsCache = new ConcurrentReferenceHashMap<>();
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		Environment environment = context.getEnvironment();
		MergedAnnotation<ConditionalOnAvailableEndpoint> conditionAnnotation = metadata.getAnnotations()
			.get(ConditionalOnAvailableEndpoint.class);
		Class<?> target = getTarget(context, metadata, conditionAnnotation);
		MergedAnnotation<Endpoint> endpointAnnotation = getEndpointAnnotation(target);
		return getMatchOutcome(environment, conditionAnnotation, endpointAnnotation);
	}
	private Class<?> getTarget(ConditionContext context, AnnotatedTypeMetadata metadata,
			MergedAnnotation<ConditionalOnAvailableEndpoint> condition) {
		Class<?> target = condition.getClass('endpoint');
		if (target != Void.class) {
			return target;
		}
		Assert.state(metadata instanceof MethodMetadata && metadata.isAnnotated(Bean.class.getName()),
				'EndpointCondition must be used on @Bean methods when the endpoint is not specified');
		MethodMetadata methodMetadata = (MethodMetadata) metadata;
		try {
			return ClassUtils.forName(methodMetadata.getReturnTypeName(), context.getClassLoader());
		}
		catch (Throwable ex) {
			throw new IllegalStateException('Failed to extract endpoint id for '
					+ methodMetadata.getDeclaringClassName() + '.' + methodMetadata.getMethodName(), ex);
		}
	}
	protected MergedAnnotation<Endpoint> getEndpointAnnotation(Class<?> target) {
		MergedAnnotations annotations = MergedAnnotations.from(target, SearchStrategy.TYPE_HIERARCHY);
		MergedAnnotation<Endpoint> endpoint = annotations.get(Endpoint.class);
		if (endpoint.isPresent()) {
			return endpoint;
		}
		MergedAnnotation<EndpointExtension> extension = annotations.get(EndpointExtension.class);
		Assert.state(extension.isPresent(), 'No endpoint is specified and the return type of the @Bean method is '
				+ 'neither an @Endpoint, nor an @EndpointExtension');
		return getEndpointAnnotation(extension.getClass('endpoint'));
	}
	private ConditionOutcome getMatchOutcome(Environment environment,
			MergedAnnotation<ConditionalOnAvailableEndpoint> conditionAnnotation,
			MergedAnnotation<Endpoint> endpointAnnotation) {
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnAvailableEndpoint.class);
		EndpointId endpointId = EndpointId.of(environment, endpointAnnotation.getString('id'));
		ConditionOutcome accessOutcome = getAccessOutcome(environment, endpointAnnotation, endpointId, message);
		if (!accessOutcome.isMatch()) {
			return accessOutcome;
		}
		ConditionOutcome exposureOutcome = getExposureOutcome(environment, conditionAnnotation, endpointAnnotation,
				endpointId, message);
		return (exposureOutcome != null) ? exposureOutcome : ConditionOutcome.noMatch(message.because('not exposed'));
	}
	private ConditionOutcome getAccessOutcome(Environment environment, MergedAnnotation<Endpoint> endpointAnnotation,
			EndpointId endpointId, ConditionMessage.Builder message) {
		Access defaultAccess = endpointAnnotation.getEnum('defaultAccess', Access.class);
		boolean enableByDefault = endpointAnnotation.getBoolean('enableByDefault');
		Access access = getAccess(environment, endpointId, (enableByDefault) ? defaultAccess : Access.NONE);
		return new ConditionOutcome(access != Access.NONE,
				message.because('the configured access for endpoint "%s" is %s'.formatted(endpointId, access)));
	}
	private Access getAccess(Environment environment, EndpointId endpointId, Access defaultAccess) {
		return accessResolversCache.computeIfAbsent(environment, PropertiesEndpointAccessResolver::new)
			.accessFor(endpointId, defaultAccess);
	}
	private ConditionOutcome getExposureOutcome(Environment environment,
			MergedAnnotation<ConditionalOnAvailableEndpoint> conditionAnnotation,
			MergedAnnotation<Endpoint> endpointAnnotation, EndpointId endpointId, Builder message) {
		Set<EndpointExposure> exposures = getExposures(conditionAnnotation);
		Set<EndpointExposureOutcomeContributor> outcomeContributors = getExposureOutcomeContributors(environment);
		for (EndpointExposureOutcomeContributor outcomeContributor : outcomeContributors) {
			ConditionOutcome outcome = outcomeContributor.getExposureOutcome(endpointId, exposures, message);
			if (outcome != null && outcome.isMatch()) {
				return outcome;
			}
		}
		return null;
	}
	private Set<EndpointExposure> getExposures(MergedAnnotation<ConditionalOnAvailableEndpoint> conditionAnnotation) {
		EndpointExposure[] exposures = conditionAnnotation.getEnumArray('exposure', EndpointExposure.class);
		return replaceCloudFoundryExposure(
				(exposures.length == 0) ? EnumSet.allOf(EndpointExposure.class) : Arrays.asList(exposures));
	}
	@SuppressWarnings('removal')
	private Set<EndpointExposure> replaceCloudFoundryExposure(Collection<EndpointExposure> exposures) {
		Set<EndpointExposure> result = EnumSet.copyOf(exposures);
		if (result.remove(EndpointExposure.CLOUD_FOUNDRY)) {
			result.add(EndpointExposure.WEB);
		}
		return result;
	}
	private Set<EndpointExposureOutcomeContributor> getExposureOutcomeContributors(Environment environment) {
		Set<EndpointExposureOutcomeContributor> contributors = exposureOutcomeContributorsCache.get(environment);
		if (contributors == null) {
			contributors = new LinkedHashSet<>();
			contributors.add(new StandardExposureOutcomeContributor(environment, EndpointExposure.WEB));
			if (environment.getProperty(JMX_ENABLED_KEY, Boolean.class, false)) {
				contributors.add(new StandardExposureOutcomeContributor(environment, EndpointExposure.JMX));
			}
			contributors.addAll(loadExposureOutcomeContributors(environment));
			exposureOutcomeContributorsCache.put(environment, contributors);
		}
		return contributors;
	}
	private List<EndpointExposureOutcomeContributor> loadExposureOutcomeContributors(Environment environment) {
		ArgumentResolver argumentResolver = ArgumentResolver.of(Environment.class, environment);
		return SpringFactoriesLoader.forDefaultResourceLocation()
			.load(EndpointExposureOutcomeContributor.class, argumentResolver);
	}
	/**
	 * Standard {@link EndpointExposureOutcomeContributor}.
	 */
	private static class StandardExposureOutcomeContributor implements EndpointExposureOutcomeContributor {
		private final EndpointExposure exposure;
		private final String property;
		private final IncludeExcludeEndpointFilter<?> filter;
		StandardExposureOutcomeContributor(Environment environment, EndpointExposure exposure) {
			this.exposure = exposure;
			String name = exposure.name().toLowerCase(Locale.ROOT).replace("_", "-");
			this.property = 'management.endpoints.' + name + '.exposure';
			this.filter = new IncludeExcludeEndpointFilter<>(ExposableEndpoint.class, environment, this.property,
					exposure.getDefaultIncludes());
		}
		@Override
		public ConditionOutcome getExposureOutcome(EndpointId endpointId, Set<EndpointExposure> exposures,
				ConditionMessage.Builder message) {
			if (exposures.contains(this.exposure) && this.filter.match(endpointId)) {
				return ConditionOutcome
					.match(message.because('marked as exposed by a "' + this.property + '" property'));
			}
			return null;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.jackson;
/**
@Configuration(proxyBeanMethods = false)
@AutoConfigureAfter(JacksonAutoConfiguration.class)
public class JacksonEndpointAutoConfiguration {
	@Bean
	@ConditionalOnProperty(name = 'management.endpoints.jackson.isolated-object-mapper', matchIfMissing = true)
	@ConditionalOnClass({ ObjectMapper.class, Jackson2ObjectMapperBuilder.class })
	public EndpointObjectMapper endpointObjectMapper() {
		ObjectMapper objectMapper = Jackson2ObjectMapperBuilder.json()
			.featuresToDisable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,
					SerializationFeature.WRITE_DURATIONS_AS_TIMESTAMPS)
			.serializationInclusion(Include.NON_NULL)
			.build();
		return () -> objectMapper;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.jackson;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.expose;
/**
public enum EndpointExposure {
	/**
	 * Exposed over a JMX endpoint.
	 */
	JMX('health'),
	/**
	 * Exposed over a web endpoint.
	 */
	WEB('health'),
	/**
	 * Exposed on Cloud Foundry over `/cloudfoundryapplication`.
	 * @since 2.6.4
	 * @deprecated since 3.4.0 for removal in 3.6.0 in favor of using
	 * {@link EndpointExposure#WEB}
	 */
	@Deprecated(since = '3.4.0', forRemoval = true)
	CLOUD_FOUNDRY('*');
	private final String[] defaultIncludes;
	EndpointExposure(String... defaultIncludes) {
		this.defaultIncludes = defaultIncludes;
	}
	/**
	 * Return the default set of include patterns.
	 * @return the default includes
	 */
	public String[] getDefaultIncludes() {
		return this.defaultIncludes;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.endpoint.expose;
/*
package org.springframework.boot.actuate.autoconfigure.endpoint.expose;
/**
public class IncludeExcludeEndpointFilter<E extends ExposableEndpoint<?>> implements EndpointFilter<E> {
	private final Class<E> endpointType;
	private final EndpointPatterns include;
	private final EndpointPatterns defaultIncludes;
	private final EndpointPatterns exclude;
	/**
	 * Create a new {@link IncludeExcludeEndpointFilter} with include/exclude rules bound
	 * from the {@link Environment}.
	 * @param endpointType the endpoint type that should be considered (other types always
	 * match)
	 * @param environment the environment containing the properties
	 * @param prefix the property prefix to bind
	 * @param defaultIncludes the default {@code includes} to use when none are specified.
	 */
	public IncludeExcludeEndpointFilter(Class<E> endpointType, Environment environment, String prefix,
			String... defaultIncludes) {
		this(endpointType, environment, prefix, new EndpointPatterns(defaultIncludes));
	}
	/**
	 * Create a new {@link IncludeExcludeEndpointFilter} with specific include/exclude
	 * rules.
	 * @param endpointType the endpoint type that should be considered (other types always
	 * match)
	 * @param include the include patterns
	 * @param exclude the exclude patterns
	 * @param defaultIncludes the default {@code includes} to use when none are specified.
	 */
	public IncludeExcludeEndpointFilter(Class<E> endpointType, Collection<String> include, Collection<String> exclude,
			String... defaultIncludes) {
		this(endpointType, include, exclude, new EndpointPatterns(defaultIncludes));
	}
	private IncludeExcludeEndpointFilter(Class<E> endpointType, Environment environment, String prefix,
			EndpointPatterns defaultIncludes) {
		Assert.notNull(endpointType, 'EndpointType must not be null');
		Assert.notNull(environment, 'Environment must not be null');
		Assert.hasText(prefix, 'Prefix must not be empty');
		Assert.notNull(defaultIncludes, 'DefaultIncludes must not be null');
		Binder binder = Binder.get(environment);
		this.endpointType = endpointType;
		this.include = new EndpointPatterns(bind(binder, prefix + '.include'));
		this.defaultIncludes = defaultIncludes;
		this.exclude = new EndpointPatterns(bind(binder, prefix + '.exclude'));
	}
	private IncludeExcludeEndpointFilter(Class<E> endpointType, Collection<String> include, Collection<String> exclude,
			EndpointPatterns defaultIncludes) {
		Assert.notNull(endpointType, 'EndpointType Type must not be null');
		Assert.notNull(defaultIncludes, 'DefaultIncludes must not be null');
		this.endpointType = endpointType;
		this.include = new EndpointPatterns(include);
		this.defaultIncludes = defaultIncludes;
		this.exclude = new EndpointPatterns(exclude);
	}
	private List<String> bind(Binder binder, String name) {
		return binder.bind(name, Bindable.listOf(String.class)).orElseGet(ArrayList::new);
	}
	@Override
	public boolean match(E endpoint) {
		if (!this.endpointType.isInstance(endpoint)) {
			// Leave non-matching types for other filters
			return true;
		}
		return match(endpoint.getEndpointId());
	}
	/**
	 * Return {@code true} if the filter matches.
	 * @param endpointId the endpoint ID to check
	 * @return {@code true} if the filter matches
	 * @since 2.6.0
	 */
	public final boolean match(EndpointId endpointId) {
		return isIncluded(endpointId) && !isExcluded(endpointId);
	}
	private boolean isIncluded(EndpointId endpointId) {
		if (this.include.isEmpty()) {
			return this.defaultIncludes.matches(endpointId);
		}
		return this.include.matches(endpointId);
	}
	private boolean isExcluded(EndpointId endpointId) {
		if (this.exclude.isEmpty()) {
			return false;
		}
		return this.exclude.matches(endpointId);
	}
	/**
	 * A set of endpoint patterns used to match IDs.
	 */
	private static class EndpointPatterns {
		private final boolean empty;
		private final boolean matchesAll;
		private final Set<EndpointId> endpointIds;
		EndpointPatterns(String[] patterns) {
			this((patterns != null) ? Arrays.asList(patterns) : null);
		}
		EndpointPatterns(Collection<String> patterns) {
			patterns = (patterns != null) ? patterns : Collections.emptySet();
			boolean matchesAll = false;
			Set<EndpointId> endpointIds = new LinkedHashSet<>();
			for (String pattern : patterns) {
				if ('*'.equals(pattern)) {
					matchesAll = true;
				}
				else {
					endpointIds.add(EndpointId.fromPropertyValue(pattern));
				}
			}
			this.empty = patterns.isEmpty();
			this.matchesAll = matchesAll;
			this.endpointIds = endpointIds;
		}
		boolean isEmpty() {
			return this.empty;
		}
		boolean matches(EndpointId endpointId) {
			return this.matchesAll || this.endpointIds.contains(endpointId);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.endpoint;
/**
@AutoConfiguration
public class EndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ParameterValueMapper endpointOperationParameterMapper(
			@EndpointConverter ObjectProvider<Converter<?, ?>> converters,
			@EndpointConverter ObjectProvider<GenericConverter> genericConverters) {
		ConversionService conversionService = createConversionService(converters.orderedStream().toList(),
				genericConverters.orderedStream().toList());
		return new ConversionServiceParameterValueMapper(conversionService);
	}
	private ConversionService createConversionService(List<Converter<?, ?>> converters,
			List<GenericConverter> genericConverters) {
		if (genericConverters.isEmpty() && converters.isEmpty()) {
			return ApplicationConversionService.getSharedInstance();
		}
		ApplicationConversionService conversionService = new ApplicationConversionService();
		converters.forEach(conversionService::addConverter);
		genericConverters.forEach(conversionService::addConverter);
		return conversionService;
	}
	@Bean
	@ConditionalOnMissingBean
	public CachingOperationInvokerAdvisor endpointCachingOperationInvokerAdvisor(Environment environment) {
		return new CachingOperationInvokerAdvisor(new EndpointIdTimeToLivePropertyFunction(environment));
	}
	@Bean
	@ConditionalOnMissingBean(EndpointAccessResolver.class)
	PropertiesEndpointAccessResolver propertiesEndpointAccessResolver(Environment environment) {
		return new PropertiesEndpointAccessResolver(environment);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.elasticsearch;
/*
package org.springframework.boot.actuate.autoconfigure.elasticsearch;
/**
@AutoConfiguration(after = ElasticsearchRestClientAutoConfiguration.class)
@ConditionalOnClass(RestClient.class)
@ConditionalOnBean(RestClient.class)
@ConditionalOnEnabledHealthIndicator('elasticsearch')
public class ElasticsearchRestHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<ElasticsearchRestClientHealthIndicator, RestClient> {
	public ElasticsearchRestHealthContributorAutoConfiguration() {
		super(ElasticsearchRestClientHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'elasticsearchHealthIndicator', 'elasticsearchHealthContributor' })
	public HealthContributor elasticsearchHealthContributor(Map<String, RestClient> clients) {
		return createContributor(clients);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.condition;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(ConditionsReportEndpoint.class)
public class ConditionsReportEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(search = SearchStrategy.CURRENT)
	public ConditionsReportEndpoint conditionsReportEndpoint(ConfigurableApplicationContext context) {
		return new ConditionsReportEndpoint(context);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.condition;
/**
@Endpoint(id = 'conditions')
public class ConditionsReportEndpoint {
	private final ConfigurableApplicationContext context;
	public ConditionsReportEndpoint(ConfigurableApplicationContext context) {
		this.context = context;
	}
	@ReadOperation
	public ConditionsDescriptor conditions() {
		Map<String, ContextConditionsDescriptor> contextConditionEvaluations = new HashMap<>();
		ConfigurableApplicationContext target = this.context;
		while (target != null) {
			contextConditionEvaluations.put(target.getId(), new ContextConditionsDescriptor(target));
			target = getConfigurableParent(target);
		}
		return new ConditionsDescriptor(contextConditionEvaluations);
	}
	private ConfigurableApplicationContext getConfigurableParent(ConfigurableApplicationContext context) {
		ApplicationContext parent = context.getParent();
		if (parent instanceof ConfigurableApplicationContext configurableParent) {
			return configurableParent;
		}
		return null;
	}
	/**
	 * A description of an application"s condition evaluation.
	 */
	public static final class ConditionsDescriptor implements OperationResponseBody {
		private final Map<String, ContextConditionsDescriptor> contexts;
		private ConditionsDescriptor(Map<String, ContextConditionsDescriptor> contexts) {
			this.contexts = contexts;
		}
		public Map<String, ContextConditionsDescriptor> getContexts() {
			return this.contexts;
		}
	}
	/**
	 * A description of an application context"s condition evaluation, primarily intended
	 * for serialization to JSON.
	 */
	@JsonInclude(Include.NON_EMPTY)
	public static final class ContextConditionsDescriptor {
		private final MultiValueMap<String, MessageAndConditionDescriptor> positiveMatches;
		private final Map<String, MessageAndConditionsDescriptor> negativeMatches;
		private final List<String> exclusions;
		private final Set<String> unconditionalClasses;
		private final String parentId;
		public ContextConditionsDescriptor(ConfigurableApplicationContext context) {
			ConditionEvaluationReport report = ConditionEvaluationReport.get(context.getBeanFactory());
			this.positiveMatches = new LinkedMultiValueMap<>();
			this.negativeMatches = new LinkedHashMap<>();
			this.exclusions = report.getExclusions();
			this.unconditionalClasses = report.getUnconditionalClasses();
			report.getConditionAndOutcomesBySource().forEach(this::add);
			this.parentId = (context.getParent() != null) ? context.getParent().getId() : null;
		}
		private void add(String source, ConditionAndOutcomes conditionAndOutcomes) {
			String name = ClassUtils.getShortName(source);
			if (conditionAndOutcomes.isFullMatch()) {
				conditionAndOutcomes.forEach((conditionAndOutcome) -> this.positiveMatches.add(name,
						new MessageAndConditionDescriptor(conditionAndOutcome)));
			}
			else {
				this.negativeMatches.put(name, new MessageAndConditionsDescriptor(conditionAndOutcomes));
			}
		}
		public Map<String, List<MessageAndConditionDescriptor>> getPositiveMatches() {
			return this.positiveMatches;
		}
		public Map<String, MessageAndConditionsDescriptor> getNegativeMatches() {
			return this.negativeMatches;
		}
		public List<String> getExclusions() {
			return this.exclusions;
		}
		public Set<String> getUnconditionalClasses() {
			return this.unconditionalClasses;
		}
		public String getParentId() {
			return this.parentId;
		}
	}
	/**
	 * Adapts {@link ConditionAndOutcomes} to a JSON friendly structure.
	 */
	@JsonPropertyOrder({ 'notMatched', 'matched' })
	public static class MessageAndConditionsDescriptor {
		private final List<MessageAndConditionDescriptor> notMatched = new ArrayList<>();
		private final List<MessageAndConditionDescriptor> matched = new ArrayList<>();
		public MessageAndConditionsDescriptor(ConditionAndOutcomes conditionAndOutcomes) {
			for (ConditionAndOutcome conditionAndOutcome : conditionAndOutcomes) {
				List<MessageAndConditionDescriptor> target = (conditionAndOutcome.getOutcome().isMatch() ? this.matched
						: this.notMatched);
				target.add(new MessageAndConditionDescriptor(conditionAndOutcome));
			}
		}
		public List<MessageAndConditionDescriptor> getNotMatched() {
			return this.notMatched;
		}
		public List<MessageAndConditionDescriptor> getMatched() {
			return this.matched;
		}
	}
	/**
	 * Adapts {@link ConditionAndOutcome} to a JSON friendly structure.
	 */
	@JsonPropertyOrder({ 'condition', 'message' })
	public static class MessageAndConditionDescriptor {
		private final String condition;
		private final String message;
		public MessageAndConditionDescriptor(ConditionAndOutcome conditionAndOutcome) {
			Condition condition = conditionAndOutcome.getCondition();
			ConditionOutcome outcome = conditionAndOutcome.getOutcome();
			this.condition = ClassUtils.getShortName(condition.getClass());
			if (StringUtils.hasLength(outcome.getMessage())) {
				this.message = outcome.getMessage();
			}
			else {
				this.message = outcome.isMatch() ? 'matched' : 'did not match';
			}
		}
		public String getCondition() {
			return this.condition;
		}
		public String getMessage() {
			return this.message;
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.condition;
/*
package org.springframework.boot.actuate.autoconfigure.startup;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(StartupEndpoint.class)
@Conditional(StartupEndpointAutoConfiguration.ApplicationStartupCondition.class)
public class StartupEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public StartupEndpoint startupEndpoint(BufferingApplicationStartup applicationStartup) {
		return new StartupEndpoint(applicationStartup);
	}
	/**
	 * {@link SpringBootCondition} checking the configured
	 * {@link org.springframework.core.metrics.ApplicationStartup}.
	 * <p>
	 * Endpoint is enabled only if the configured implementation is
	 * {@link BufferingApplicationStartup}.
	 */
	static class ApplicationStartupCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('ApplicationStartup');
			ApplicationStartup applicationStartup = context.getBeanFactory().getApplicationStartup();
			if (applicationStartup instanceof BufferingApplicationStartup) {
				return ConditionOutcome
					.match(message.because('configured applicationStartup is of type BufferingApplicationStartup.'));
			}
			return ConditionOutcome.noMatch(message.because('configured applicationStartup is of type '
					+ applicationStartup.getClass() + ', expected BufferingApplicationStartup.'));
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.startup;
/*
package org.springframework.boot.actuate.autoconfigure.wavefront;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(WavefrontSender.class)
@EnableConfigurationProperties(WavefrontProperties.class)
public class WavefrontSenderConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@Conditional(WavefrontTracingOrMetricsCondition.class)
	public WavefrontSender wavefrontSender(WavefrontProperties properties) {
		Builder builder = new Builder(properties.getEffectiveUri().toString(), properties.getWavefrontApiTokenType(),
				properties.getApiTokenOrThrow());
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		WavefrontProperties.Sender sender = properties.getSender();
		map.from(sender.getMaxQueueSize()).to(builder::maxQueueSize);
		map.from(sender.getFlushInterval()).asInt(Duration::getSeconds).to(builder::flushIntervalSeconds);
		map.from(sender.getMessageSize()).asInt(DataSize::toBytes).to(builder::messageSizeBytes);
		map.from(sender.getBatchSize()).to(builder::batchSize);
		return builder.build();
	}
	static final class WavefrontTracingOrMetricsCondition extends AnyNestedCondition {
		WavefrontTracingOrMetricsCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnEnabledTracing('wavefront')
		static class TracingCondition {
		}
		@ConditionalOnEnabledMetricsExport('wavefront')
		static class MetricsCondition {
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.wavefront;
/**
@AutoConfiguration
@ConditionalOnClass({ ApplicationTags.class, WavefrontSender.class })
@EnableConfigurationProperties(WavefrontProperties.class)
public class WavefrontAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ApplicationTags wavefrontApplicationTags(Environment environment, WavefrontProperties properties) {
		Application application = properties.getApplication();
		String serviceName = application.getServiceName();
		serviceName = (StringUtils.hasText(serviceName)) ? serviceName
				: environment.getProperty('spring.application.name', 'unnamed_service');
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		ApplicationTags.Builder builder = new ApplicationTags.Builder(application.getName(), serviceName);
		map.from(application::getClusterName).to(builder::cluster);
		map.from(application::getShardName).to(builder::shard);
		map.from(application::getCustomTags).to(builder::customTags);
		return builder.build();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.wavefront;
/**
@ConfigurationProperties(prefix = 'management.wavefront')
public class WavefrontProperties {
	/**
	 * URI to ship metrics and traces to.
	 */
	private URI uri = URI.create('https://longboard.wavefront.com');
	/**
	 * Unique identifier for the app instance that is the source of metrics and traces
	 * being published to Wavefront. Defaults to the local host name.
	 */
	private String source;
	/**
	 * API token used when publishing metrics and traces directly to the Wavefront API
	 * host.
	 */
	private String apiToken;
	/**
	 * Type of the API token.
	 */
	private TokenType apiTokenType;
	/**
	 * Application configuration.
	 */
	private final Application application = new Application();
	/**
	 * Sender configuration.
	 */
	private final Sender sender = new Sender();
	/**
	 * Metrics configuration.
	 */
	private final Metrics metrics = new Metrics();
	/**
	 * Customized span tags for RED metrics.
	 */
	private Set<String> traceDerivedCustomTagKeys = new HashSet<>();
	public Application getApplication() {
		return this.application;
	}
	public Sender getSender() {
		return this.sender;
	}
	public Metrics getMetrics() {
		return this.metrics;
	}
	public URI getUri() {
		return this.uri;
	}
	public void setUri(URI uri) {
		this.uri = uri;
	}
	public String getSource() {
		return this.source;
	}
	public void setSource(String source) {
		this.source = source;
	}
	public String getApiToken() {
		return this.apiToken;
	}
	public void setApiToken(String apiToken) {
		this.apiToken = apiToken;
	}
	/**
	 * Returns the effective URI of the wavefront instance. This will not be the same URI
	 * given through {@link #setUri(URI)} when a proxy is used.
	 * @return the effective URI of the wavefront instance
	 */
	public URI getEffectiveUri() {
		if (usesProxy()) {
			// See io.micrometer.wavefront.WavefrontMeterRegistry.getWavefrontReportingUri
			return URI.create(this.uri.toString().replace('proxy://', 'http://'));
		}
		return this.uri;
	}
	/**
	 * Returns the API token or throws an exception if the API token is mandatory. If a
	 * proxy is used, the API token is optional.
	 * @return the API token
	 */
	public String getApiTokenOrThrow() {
		if (this.apiTokenType != TokenType.NO_TOKEN && this.apiToken == null && !usesProxy()) {
			throw new InvalidConfigurationPropertyValueException('management.wavefront.api-token', null,
					'This property is mandatory whenever publishing directly to the Wavefront API');
		}
		return this.apiToken;
	}
	public String getSourceOrDefault() {
		if (this.source != null) {
			return this.source;
		}
		return getSourceDefault();
	}
	private String getSourceDefault() {
		try {
			return InetAddress.getLocalHost().getHostName();
		}
		catch (UnknownHostException ex) {
			return 'unknown';
		}
	}
	private boolean usesProxy() {
		return 'proxy'.equals(this.uri.getScheme());
	}
	public Set<String> getTraceDerivedCustomTagKeys() {
		return this.traceDerivedCustomTagKeys;
	}
	public void setTraceDerivedCustomTagKeys(Set<String> traceDerivedCustomTagKeys) {
		this.traceDerivedCustomTagKeys = traceDerivedCustomTagKeys;
	}
	public TokenType getApiTokenType() {
		return this.apiTokenType;
	}
	public void setApiTokenType(TokenType apiTokenType) {
		this.apiTokenType = apiTokenType;
	}
	/**
	 * Returns the {@link Type Wavefront token type}.
	 * @return the Wavefront token type
	 * @since 3.2.0
	 */
	public Type getWavefrontApiTokenType() {
		if (this.apiTokenType == null) {
			return usesProxy() ? Type.NO_TOKEN : Type.WAVEFRONT_API_TOKEN;
		}
		return switch (this.apiTokenType) {
			case NO_TOKEN -> Type.NO_TOKEN;
			case WAVEFRONT_API_TOKEN -> Type.WAVEFRONT_API_TOKEN;
			case CSP_API_TOKEN -> Type.CSP_API_TOKEN;
			case CSP_CLIENT_CREDENTIALS -> Type.CSP_CLIENT_CREDENTIALS;
		};
	}
	public static class Application {
		/**
		 * Wavefront "Application" name used in ApplicationTags.
		 */
		private String name = 'unnamed_application';
		/**
		 * Wavefront "Service" name used in ApplicationTags, falling back to
		 * "spring.application.name". If both are unset it defaults to "unnamed_service".
		 */
		private String serviceName;
		/**
		 * Wavefront Cluster name used in ApplicationTags.
		 */
		private String clusterName;
		/**
		 * Wavefront Shard name used in ApplicationTags.
		 */
		private String shardName;
		/**
		 * Wavefront custom tags used in ApplicationTags.
		 */
		private Map<String, String> customTags = new HashMap<>();
		public String getServiceName() {
			return this.serviceName;
		}
		public void setServiceName(String serviceName) {
			this.serviceName = serviceName;
		}
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public String getClusterName() {
			return this.clusterName;
		}
		public void setClusterName(String clusterName) {
			this.clusterName = clusterName;
		}
		public String getShardName() {
			return this.shardName;
		}
		public void setShardName(String shardName) {
			this.shardName = shardName;
		}
		public Map<String, String> getCustomTags() {
			return this.customTags;
		}
		public void setCustomTags(Map<String, String> customTags) {
			this.customTags = customTags;
		}
	}
	public static class Sender {
		/**
		 * Maximum size of queued messages.
		 */
		private int maxQueueSize = 50000;
		/**
		 * Flush interval to send queued messages.
		 */
		private Duration flushInterval = Duration.ofSeconds(1);
		/**
		 * Maximum size of a message.
		 */
		private DataSize messageSize = DataSize.ofBytes(Integer.MAX_VALUE);
		/**
		 * Number of measurements per request to use for Wavefront. If more measurements
		 * are found, then multiple requests will be made.
		 */
		private int batchSize = 10000;
		public int getMaxQueueSize() {
			return this.maxQueueSize;
		}
		public void setMaxQueueSize(int maxQueueSize) {
			this.maxQueueSize = maxQueueSize;
		}
		public Duration getFlushInterval() {
			return this.flushInterval;
		}
		public void setFlushInterval(Duration flushInterval) {
			this.flushInterval = flushInterval;
		}
		public DataSize getMessageSize() {
			return this.messageSize;
		}
		public void setMessageSize(DataSize messageSize) {
			this.messageSize = messageSize;
		}
		public int getBatchSize() {
			return this.batchSize;
		}
		public void setBatchSize(int batchSize) {
			this.batchSize = batchSize;
		}
	}
	public static class Metrics {
		/**
		 * Export configuration.
		 */
		private Export export = new Export();
		public Export getExport() {
			return this.export;
		}
		public void setExport(Export export) {
			this.export = export;
		}
		public static class Export extends PushRegistryProperties {
			/**
			 * Global prefix to separate metrics originating from this app"s
			 * instrumentation from those originating from other Wavefront integrations
			 * when viewed in the Wavefront UI.
			 */
			private String globalPrefix;
			/**
			 * Whether to report histogram distributions aggregated into minute intervals.
			 */
			private boolean reportMinuteDistribution = true;
			/**
			 * Whether to report histogram distributions aggregated into hour intervals.
			 */
			private boolean reportHourDistribution;
			/**
			 * Whether to report histogram distributions aggregated into day intervals.
			 */
			private boolean reportDayDistribution;
			public String getGlobalPrefix() {
				return this.globalPrefix;
			}
			public void setGlobalPrefix(String globalPrefix) {
				this.globalPrefix = globalPrefix;
			}
			/**
			 * See {@link PushRegistryProperties#getBatchSize()}.
			 */
			@Override
			public Integer getBatchSize() {
				throw new UnsupportedOperationException('Use Sender.getBatchSize() instead');
			}
			/**
			 * See {@link PushRegistryProperties#setBatchSize(Integer)}.
			 */
			@Override
			public void setBatchSize(Integer batchSize) {
				throw new UnsupportedOperationException('Use Sender.setBatchSize(int) instead');
			}
			public boolean isReportMinuteDistribution() {
				return this.reportMinuteDistribution;
			}
			public void setReportMinuteDistribution(boolean reportMinuteDistribution) {
				this.reportMinuteDistribution = reportMinuteDistribution;
			}
			public boolean isReportHourDistribution() {
				return this.reportHourDistribution;
			}
			public void setReportHourDistribution(boolean reportHourDistribution) {
				this.reportHourDistribution = reportHourDistribution;
			}
			public boolean isReportDayDistribution() {
				return this.reportDayDistribution;
			}
			public void setReportDayDistribution(boolean reportDayDistribution) {
				this.reportDayDistribution = reportDayDistribution;
			}
		}
	}
	/**
	 * Wavefront token type.
	 *
	 * @since 3.2.0
	 */
	public enum TokenType {
		/**
		 * No token.
		 */
		NO_TOKEN,
		/**
		 * Wavefront API token.
		 */
		WAVEFRONT_API_TOKEN,
		/**
		 * CSP API token.
		 */
		CSP_API_TOKEN,
		/**
		 * CSP client credentials.
		 */
		CSP_CLIENT_CREDENTIALS
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.wavefront;
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
class PropertiesObservationFilterPredicate implements ObservationFilter, ObservationPredicate {
	private final ObservationFilter commonKeyValuesFilter;
	private final ObservationProperties properties;
	PropertiesObservationFilterPredicate(ObservationProperties properties) {
		this.properties = properties;
		this.commonKeyValuesFilter = createCommonKeyValuesFilter(properties);
	}
	@Override
	public Context map(Context context) {
		return this.commonKeyValuesFilter.map(context);
	}
	@Override
	public boolean test(String name, Context context) {
		return lookupWithFallbackToAll(this.properties.getEnable(), name, true);
	}
	private static <T> T lookupWithFallbackToAll(Map<String, T> values, String name, T defaultValue) {
		if (values.isEmpty()) {
			return defaultValue;
		}
		return doLookup(values, name, () -> values.getOrDefault('all', defaultValue));
	}
	private static <T> T doLookup(Map<String, T> values, String name, Supplier<T> defaultValue) {
		while (StringUtils.hasLength(name)) {
			T result = values.get(name);
			if (result != null) {
				return result;
			}
			int lastDot = name.lastIndexOf(".");
			name = (lastDot != -1) ? name.substring(0, lastDot) : '';
		}
		return defaultValue.get();
	}
	private static ObservationFilter createCommonKeyValuesFilter(ObservationProperties properties) {
		if (properties.getKeyValues().isEmpty()) {
			return (context) -> context;
		}
		KeyValues keyValues = KeyValues.of(properties.getKeyValues().entrySet(), Entry::getKey, Entry::getValue);
		return (context) -> context.addLowCardinalityKeyValues(keyValues);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@AutoConfiguration(after = { ObservationAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class,
		RestTemplateAutoConfiguration.class, WebClientAutoConfiguration.class, RestClientAutoConfiguration.class })
@ConditionalOnClass(Observation.class)
@ConditionalOnBean(ObservationRegistry.class)
@Import({ RestTemplateObservationConfiguration.class, WebClientObservationConfiguration.class,
		RestClientObservationConfiguration.class })
@EnableConfigurationProperties({ MetricsProperties.class, ObservationProperties.class })
public class HttpClientObservationsAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(MeterRegistry.class)
	@ConditionalOnBean(MeterRegistry.class)
	static class MeterFilterConfiguration {
		@Bean
		@Order(0)
		MeterFilter metricsHttpClientUriTagFilter(ObservationProperties observationProperties,
				MetricsProperties metricsProperties) {
			Client clientProperties = metricsProperties.getWeb().getClient();
			String name = observationProperties.getHttp().getClient().getRequests().getName();
			MeterFilter denyFilter = new OnlyOnceLoggingDenyMeterFilter(
					() -> 'Reached the maximum number of URI tags for "%s". Are you using "uriVariables"?'
						.formatted(name));
			return MeterFilter.maximumAllowableTags(name, 'uri', clientProperties.getMaxUriTags(), denyFilter);
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(WebClient.class)
class WebClientObservationConfiguration {
	@Bean
	ObservationWebClientCustomizer observationWebClientCustomizer(ObservationRegistry observationRegistry,
			ObjectProvider<ClientRequestObservationConvention> customConvention,
			ObservationProperties observationProperties, MetricsProperties metricsProperties) {
		String name = observationProperties.getHttp().getClient().getRequests().getName();
		ClientRequestObservationConvention observationConvention = customConvention
			.getIfAvailable(() -> new DefaultClientRequestObservationConvention(name));
		return new ObservationWebClientCustomizer(observationRegistry, observationConvention);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RestTemplate.class)
@ConditionalOnBean(RestTemplateBuilder.class)
class RestTemplateObservationConfiguration {
	@Bean
	ObservationRestTemplateCustomizer observationRestTemplateCustomizer(ObservationRegistry observationRegistry,
			ObjectProvider<ClientRequestObservationConvention> customConvention,
			ObservationProperties observationProperties) {
		String name = observationProperties.getHttp().getClient().getRequests().getName();
		ClientRequestObservationConvention observationConvention = customConvention
			.getIfAvailable(() -> new DefaultClientRequestObservationConvention(name));
		return new ObservationRestTemplateCustomizer(observationRegistry, observationConvention);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.client;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RestClient.class)
@ConditionalOnBean(RestClient.Builder.class)
class RestClientObservationConfiguration {
	@Bean
	RestClientCustomizer observationRestClientCustomizer(ObservationRegistry observationRegistry,
			ObjectProvider<ClientRequestObservationConvention> customConvention,
			ObservationProperties observationProperties) {
		String name = observationProperties.getHttp().getClient().getRequests().getName();
		ClientRequestObservationConvention observationConvention = customConvention
			.getIfAvailable(() -> new DefaultClientRequestObservationConvention(name));
		return new ObservationRestClientCustomizer(observationRegistry, observationConvention);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.servlet;
/**
@AutoConfiguration(after = { MetricsAutoConfiguration.class, CompositeMeterRegistryAutoConfiguration.class,
		SimpleMetricsExportAutoConfiguration.class, ObservationAutoConfiguration.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass({ DispatcherServlet.class, Observation.class })
@ConditionalOnBean(ObservationRegistry.class)
@EnableConfigurationProperties({ MetricsProperties.class, ObservationProperties.class })
public class WebMvcObservationAutoConfiguration {
	@Bean
	@ConditionalOnMissingFilterBean
	public FilterRegistrationBean<ServerHttpObservationFilter> webMvcObservationFilter(ObservationRegistry registry,
			ObjectProvider<ServerRequestObservationConvention> customConvention,
			ObservationProperties observationProperties) {
		String name = observationProperties.getHttp().getServer().getRequests().getName();
		ServerRequestObservationConvention convention = customConvention
			.getIfAvailable(() -> new DefaultServerRequestObservationConvention(name));
		ServerHttpObservationFilter filter = new ServerHttpObservationFilter(registry, convention);
		FilterRegistrationBean<ServerHttpObservationFilter> registration = new FilterRegistrationBean<>(filter);
		registration.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);
		registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC);
		return registration;
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(MeterRegistry.class)
	@ConditionalOnBean(MeterRegistry.class)
	static class MeterFilterConfiguration {
		@Bean
		@Order(0)
		MeterFilter metricsHttpServerUriTagFilter(ObservationProperties observationProperties,
				MetricsProperties metricsProperties) {
			String name = observationProperties.getHttp().getServer().getRequests().getName();
			MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(
					() -> String.format('Reached the maximum number of URI tags for "%s".', name));
			return MeterFilter.maximumAllowableTags(name, 'uri', metricsProperties.getWeb().getServer().getMaxUriTags(),
					filter);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.observation.web.servlet;
/*
package org.springframework.boot.actuate.autoconfigure.observation.web.reactive;
/**
@AutoConfiguration(after = { SimpleMetricsExportAutoConfiguration.class, ObservationAutoConfiguration.class })
@ConditionalOnClass({ Observation.class, MeterRegistry.class })
@ConditionalOnBean({ ObservationRegistry.class, MeterRegistry.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@EnableConfigurationProperties({ MetricsProperties.class, ObservationProperties.class })
public class WebFluxObservationAutoConfiguration {
	private final ObservationProperties observationProperties;
	WebFluxObservationAutoConfiguration(ObservationProperties observationProperties) {
		this.observationProperties = observationProperties;
	}
	@Bean
	@Order(0)
	MeterFilter metricsHttpServerUriTagFilter(MetricsProperties metricsProperties) {
		String name = this.observationProperties.getHttp().getServer().getRequests().getName();
		MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(
				() -> 'Reached the maximum number of URI tags for "%s".'.formatted(name));
		return MeterFilter.maximumAllowableTags(name, 'uri', metricsProperties.getWeb().getServer().getMaxUriTags(),
				filter);
	}
	@Bean
	@ConditionalOnMissingBean(ServerRequestObservationConvention.class)
	DefaultServerRequestObservationConvention defaultServerRequestObservationConvention() {
		return new DefaultServerRequestObservationConvention(
				this.observationProperties.getHttp().getServer().getRequests().getName());
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.observation.web.reactive;
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
class ObservationRegistryPostProcessor implements BeanPostProcessor {
	private final ObjectProvider<ObservationRegistryCustomizer<?>> observationRegistryCustomizers;
	private final ObjectProvider<ObservationPredicate> observationPredicates;
	private final ObjectProvider<GlobalObservationConvention<?>> observationConventions;
	private final ObjectProvider<ObservationHandler<?>> observationHandlers;
	private final ObjectProvider<ObservationHandlerGrouping> observationHandlerGrouping;
	private final ObjectProvider<ObservationFilter> observationFilters;
	private volatile ObservationRegistryConfigurer configurer;
	ObservationRegistryPostProcessor(ObjectProvider<ObservationRegistryCustomizer<?>> observationRegistryCustomizers,
			ObjectProvider<ObservationPredicate> observationPredicates,
			ObjectProvider<GlobalObservationConvention<?>> observationConventions,
			ObjectProvider<ObservationHandler<?>> observationHandlers,
			ObjectProvider<ObservationHandlerGrouping> observationHandlerGrouping,
			ObjectProvider<ObservationFilter> observationFilters) {
		this.observationRegistryCustomizers = observationRegistryCustomizers;
		this.observationPredicates = observationPredicates;
		this.observationConventions = observationConventions;
		this.observationHandlers = observationHandlers;
		this.observationHandlerGrouping = observationHandlerGrouping;
		this.observationFilters = observationFilters;
	}
	@Override
	public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
		if (bean instanceof ObservationRegistry registry) {
			getConfigurer().configure(registry);
		}
		return bean;
	}
	private ObservationRegistryConfigurer getConfigurer() {
		if (this.configurer == null) {
			this.configurer = new ObservationRegistryConfigurer(this.observationRegistryCustomizers,
					this.observationPredicates, this.observationConventions, this.observationHandlers,
					this.observationHandlerGrouping, this.observationFilters);
		}
		return this.configurer;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
@SuppressWarnings('rawtypes')
class ObservationHandlerGrouping {
	private final List<Class<? extends ObservationHandler>> categories;
	ObservationHandlerGrouping(Class<? extends ObservationHandler> category) {
		this(List.of(category));
	}
	ObservationHandlerGrouping(List<Class<? extends ObservationHandler>> categories) {
		this.categories = categories;
	}
	void apply(List<ObservationHandler<?>> handlers, ObservationConfig config) {
		MultiValueMap<Class<? extends ObservationHandler>, ObservationHandler<?>> groupings = new LinkedMultiValueMap<>();
		List<ObservationHandler<?>> handlersWithoutCategory = new ArrayList<>();
		for (ObservationHandler<?> handler : handlers) {
			Class<? extends ObservationHandler> category = findCategory(handler);
			if (category != null) {
				groupings.add(category, handler);
			}
			else {
				handlersWithoutCategory.add(handler);
			}
		}
		for (Class<? extends ObservationHandler> category : this.categories) {
			List<ObservationHandler<?>> handlerGroup = groupings.get(category);
			if (!CollectionUtils.isEmpty(handlerGroup)) {
				config.observationHandler(new FirstMatchingCompositeObservationHandler(handlerGroup));
			}
		}
		for (ObservationHandler<?> observationHandler : handlersWithoutCategory) {
			config.observationHandler(observationHandler);
		}
	}
	private Class<? extends ObservationHandler> findCategory(ObservationHandler<?> handler) {
		for (Class<? extends ObservationHandler> category : this.categories) {
			if (category.isInstance(handler)) {
				return category;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
@AutoConfiguration(after = { CompositeMeterRegistryAutoConfiguration.class, MicrometerTracingAutoConfiguration.class })
@ConditionalOnClass(ObservationRegistry.class)
@EnableConfigurationProperties(ObservationProperties.class)
public class ObservationAutoConfiguration {
	@Bean
	static ObservationRegistryPostProcessor observationRegistryPostProcessor(
			ObjectProvider<ObservationRegistryCustomizer<?>> observationRegistryCustomizers,
			ObjectProvider<ObservationPredicate> observationPredicates,
			ObjectProvider<GlobalObservationConvention<?>> observationConventions,
			ObjectProvider<ObservationHandler<?>> observationHandlers,
			ObjectProvider<ObservationHandlerGrouping> observationHandlerGrouping,
			ObjectProvider<ObservationFilter> observationFilters) {
		return new ObservationRegistryPostProcessor(observationRegistryCustomizers, observationPredicates,
				observationConventions, observationHandlers, observationHandlerGrouping, observationFilters);
	}
	@Bean
	@ConditionalOnMissingBean
	ObservationRegistry observationRegistry() {
		return ObservationRegistry.create();
	}
	@Bean
	@Order(0)
	PropertiesObservationFilterPredicate propertiesObservationFilter(ObservationProperties properties) {
		return new PropertiesObservationFilterPredicate(properties);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(MeterRegistry.class)
	@ConditionalOnMissingClass('io.micrometer.tracing.Tracer')
	static class OnlyMetricsConfiguration {
		@Bean
		ObservationHandlerGrouping metricsObservationHandlerGrouping() {
			return new ObservationHandlerGrouping(MeterObservationHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Tracer.class)
	@ConditionalOnMissingClass('io.micrometer.core.instrument.MeterRegistry')
	static class OnlyTracingConfiguration {
		@Bean
		ObservationHandlerGrouping tracingObservationHandlerGrouping() {
			return new ObservationHandlerGrouping(TracingObservationHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ MeterRegistry.class, Tracer.class })
	static class MetricsWithTracingConfiguration {
		@Bean
		ObservationHandlerGrouping metricsAndTracingObservationHandlerGrouping() {
			return new ObservationHandlerGrouping(
					List.of(TracingObservationHandler.class, MeterObservationHandler.class));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(MeterRegistry.class)
	@ConditionalOnMissingBean(MeterObservationHandler.class)
	static class MeterObservationHandlerConfiguration {
		@ConditionalOnMissingBean(type = 'io.micrometer.tracing.Tracer')
		@Configuration(proxyBeanMethods = false)
		static class OnlyMetricsMeterObservationHandlerConfiguration {
			@Bean
			DefaultMeterObservationHandler defaultMeterObservationHandler(MeterRegistry meterRegistry,
					ObservationProperties properties) {
				return properties.getLongTaskTimer().isEnabled() ? new DefaultMeterObservationHandler(meterRegistry)
						: new DefaultMeterObservationHandler(meterRegistry, IgnoredMeters.LONG_TASK_TIMER);
			}
		}
		@ConditionalOnBean(Tracer.class)
		@Configuration(proxyBeanMethods = false)
		static class TracingAndMetricsObservationHandlerConfiguration {
			@Bean
			TracingAwareMeterObservationHandler<Observation.Context> tracingAwareMeterObservationHandler(
					MeterRegistry meterRegistry, Tracer tracer, ObservationProperties properties) {
				DefaultMeterObservationHandler delegate = properties.getLongTaskTimer().isEnabled()
						? new DefaultMeterObservationHandler(meterRegistry)
						: new DefaultMeterObservationHandler(meterRegistry, IgnoredMeters.LONG_TASK_TIMER);
				return new TracingAwareMeterObservationHandler<>(delegate, tracer);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Advice.class)
	static class ObservedAspectConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ObservedAspect observedAspect(ObservationRegistry observationRegistry) {
			return new ObservedAspect(observationRegistry);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.observation.batch;
/*
package org.springframework.boot.actuate.autoconfigure.observation.batch;
/**
@AutoConfiguration(after = ObservationAutoConfiguration.class)
@ConditionalOnBean(ObservationRegistry.class)
@ConditionalOnClass({ ObservationRegistry.class, BatchObservabilityBeanPostProcessor.class })
public class BatchObservationAutoConfiguration {
	@ConditionalOnMissingBean
	@Bean
	public static BatchObservabilityBeanPostProcessor batchObservabilityBeanPostProcessor() {
		return new BatchObservabilityBeanPostProcessor();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.observation;
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
class ObservationRegistryConfigurer {
	private final ObjectProvider<ObservationRegistryCustomizer<?>> customizers;
	private final ObjectProvider<ObservationPredicate> observationPredicates;
	private final ObjectProvider<GlobalObservationConvention<?>> observationConventions;
	private final ObjectProvider<ObservationHandler<?>> observationHandlers;
	private final ObjectProvider<ObservationHandlerGrouping> observationHandlerGrouping;
	private final ObjectProvider<ObservationFilter> observationFilters;
	ObservationRegistryConfigurer(ObjectProvider<ObservationRegistryCustomizer<?>> customizers,
			ObjectProvider<ObservationPredicate> observationPredicates,
			ObjectProvider<GlobalObservationConvention<?>> observationConventions,
			ObjectProvider<ObservationHandler<?>> observationHandlers,
			ObjectProvider<ObservationHandlerGrouping> observationHandlerGrouping,
			ObjectProvider<ObservationFilter> observationFilters) {
		this.customizers = customizers;
		this.observationPredicates = observationPredicates;
		this.observationConventions = observationConventions;
		this.observationHandlers = observationHandlers;
		this.observationHandlerGrouping = observationHandlerGrouping;
		this.observationFilters = observationFilters;
	}
	void configure(ObservationRegistry registry) {
		registerObservationPredicates(registry);
		registerGlobalObservationConventions(registry);
		registerHandlers(registry);
		registerFilters(registry);
		customize(registry);
	}
	private void registerHandlers(ObservationRegistry registry) {
		this.observationHandlerGrouping.ifAvailable(
				(grouping) -> grouping.apply(asOrderedList(this.observationHandlers), registry.observationConfig()));
	}
	private void registerObservationPredicates(ObservationRegistry registry) {
		this.observationPredicates.orderedStream().forEach(registry.observationConfig()::observationPredicate);
	}
	private void registerGlobalObservationConventions(ObservationRegistry registry) {
		this.observationConventions.orderedStream().forEach(registry.observationConfig()::observationConvention);
	}
	private void registerFilters(ObservationRegistry registry) {
		this.observationFilters.orderedStream().forEach(registry.observationConfig()::observationFilter);
	}
	@SuppressWarnings('unchecked')
	private void customize(ObservationRegistry registry) {
		LambdaSafe.callbacks(ObservationRegistryCustomizer.class, asOrderedList(this.customizers), registry)
			.withLogger(ObservationRegistryConfigurer.class)
			.invoke((customizer) -> customizer.customize(registry));
	}
	private <T> List<T> asOrderedList(ObjectProvider<T> provider) {
		return provider.orderedStream().toList();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
@FunctionalInterface
public interface ObservationRegistryCustomizer<T extends ObservationRegistry> {
	/**
	 * Customize the given {@code registry}.
	 * @param registry the registry to customize
	 */
	void customize(T registry);
}
/*
package org.springframework.boot.actuate.autoconfigure.observation;
/**
@ConfigurationProperties('management.observations')
public class ObservationProperties {
	private final Http http = new Http();
	/**
	 * Common key-values that are applied to every observation.
	 */
	private Map<String, String> keyValues = new LinkedHashMap<>();
	/**
	 * Whether observations starting with the specified name should be enabled. The
	 * longest match wins, the key "all" can also be used to configure all observations.
	 */
	private Map<String, Boolean> enable = new LinkedHashMap<>();
	private final LongTaskTimer longTaskTimer = new LongTaskTimer();
	public Map<String, Boolean> getEnable() {
		return this.enable;
	}
	public void setEnable(Map<String, Boolean> enable) {
		this.enable = enable;
	}
	public Http getHttp() {
		return this.http;
	}
	public Map<String, String> getKeyValues() {
		return this.keyValues;
	}
	public void setKeyValues(Map<String, String> keyValues) {
		this.keyValues = keyValues;
	}
	public LongTaskTimer getLongTaskTimer() {
		return this.longTaskTimer;
	}
	public static class Http {
		private final Client client = new Client();
		private final Server server = new Server();
		public Client getClient() {
			return this.client;
		}
		public Server getServer() {
			return this.server;
		}
		public static class Client {
			private final ClientRequests requests = new ClientRequests();
			public ClientRequests getRequests() {
				return this.requests;
			}
			public static class ClientRequests {
				/**
				 * Name of the observation for client requests.
				 */
				private String name = 'http.client.requests';
				public String getName() {
					return this.name;
				}
				public void setName(String name) {
					this.name = name;
				}
			}
		}
		public static class Server {
			private final ServerRequests requests = new ServerRequests();
			public ServerRequests getRequests() {
				return this.requests;
			}
			public static class ServerRequests {
				/**
				 * Name of the observation for server requests.
				 */
				private String name = 'http.server.requests';
				public String getName() {
					return this.name;
				}
				public void setName(String name) {
					this.name = name;
				}
			}
		}
	}
	public static class LongTaskTimer {
		/**
		 * Whether to create a LongTaskTimer for every observation.
		 */
		private boolean enabled = true;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.observation.graphql;
/**
@AutoConfiguration(after = ObservationAutoConfiguration.class)
@ConditionalOnBean(ObservationRegistry.class)
@ConditionalOnClass({ GraphQL.class, GraphQlSource.class, Observation.class })
public class GraphQlObservationAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public GraphQlObservationInstrumentation graphQlObservationInstrumentation(ObservationRegistry observationRegistry,
			ObjectProvider<ExecutionRequestObservationConvention> executionConvention,
			ObjectProvider<DataFetcherObservationConvention> dataFetcherConvention) {
		return new GraphQlObservationInstrumentation(observationRegistry, executionConvention.getIfAvailable(),
				dataFetcherConvention.getIfAvailable());
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.observation.graphql;
/*
package org.springframework.boot.actuate.autoconfigure.r2dbc;
/**
@ConfigurationProperties('management.observations.r2dbc')
public class R2dbcObservationProperties {
	/**
	 * Whether to tag actual query parameter values.
	 */
	private boolean includeParameterValues;
	public boolean isIncludeParameterValues() {
		return this.includeParameterValues;
	}
	public void setIncludeParameterValues(boolean includeParameterValues) {
		this.includeParameterValues = includeParameterValues;
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.r2dbc;
/**
@AutoConfiguration(after = ObservationAutoConfiguration.class)
@ConditionalOnClass({ ConnectionFactory.class, ProxyConnectionFactory.class })
@EnableConfigurationProperties(R2dbcObservationProperties.class)
public class R2dbcObservationAutoConfiguration {
	/**
	 * {@code @Order} value of the observation customizer.
	 * @since 3.4.0
	 */
	public static final int R2DBC_PROXY_OBSERVATION_CUSTOMIZER_ORDER = 0;
	@Bean
	@Order(R2DBC_PROXY_OBSERVATION_CUSTOMIZER_ORDER)
	@ConditionalOnBean(ObservationRegistry.class)
	ProxyConnectionFactoryCustomizer observationProxyConnectionFactoryCustomizer(R2dbcObservationProperties properties,
			ObservationRegistry observationRegistry,
			ObjectProvider<QueryObservationConvention> queryObservationConvention,
			ObjectProvider<QueryParametersTagProvider> queryParametersTagProvider) {
		return (builder) -> {
			ConnectionFactory connectionFactory = builder.getConnectionFactory();
			HostAndPort hostAndPort = extractHostAndPort(connectionFactory);
			ObservationProxyExecutionListener listener = new ObservationProxyExecutionListener(observationRegistry,
					connectionFactory, hostAndPort.host(), hostAndPort.port());
			listener.setIncludeParameterValues(properties.isIncludeParameterValues());
			queryObservationConvention.ifAvailable(listener::setQueryObservationConvention);
			queryParametersTagProvider.ifAvailable(listener::setQueryParametersTagProvider);
			builder.listener(listener);
		};
	}
	private HostAndPort extractHostAndPort(ConnectionFactory connectionFactory) {
		OptionsCapableConnectionFactory optionsCapableConnectionFactory = OptionsCapableConnectionFactory
			.unwrapFrom(connectionFactory);
		if (optionsCapableConnectionFactory == null) {
			return HostAndPort.empty();
		}
		ConnectionFactoryOptions options = optionsCapableConnectionFactory.getOptions();
		Object host = options.getValue(ConnectionFactoryOptions.HOST);
		Object port = options.getValue(ConnectionFactoryOptions.PORT);
		if (!(host instanceof String hostAsString) || !(port instanceof Integer portAsInt)) {
			return HostAndPort.empty();
		}
		return new HostAndPort(hostAsString, portAsInt);
	}
	private record HostAndPort(String host, Integer port) {
		static HostAndPort empty() {
			return new HostAndPort(null, null);
		}
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.r2dbc;
/*
package org.springframework.boot.actuate.autoconfigure.r2dbc;
/**
@AutoConfiguration(after = R2dbcAutoConfiguration.class)
@ConditionalOnClass(ConnectionFactory.class)
@ConditionalOnBean(ConnectionFactory.class)
@ConditionalOnEnabledHealthIndicator('r2dbc')
public class ConnectionFactoryHealthContributorAutoConfiguration
		extends CompositeReactiveHealthContributorConfiguration<ConnectionFactoryHealthIndicator, ConnectionFactory> {
	private final Map<String, ConnectionFactory> connectionFactory;
	ConnectionFactoryHealthContributorAutoConfiguration(Map<String, ConnectionFactory> connectionFactory) {
		super(ConnectionFactoryHealthIndicator::new);
		this.connectionFactory = connectionFactory;
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'r2dbcHealthIndicator', 'r2dbcHealthContributor' })
	public ReactiveHealthContributor r2dbcHealthContributor() {
		return createContributor(this.connectionFactory);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure;
/*
package org.springframework.boot.actuate.autoconfigure.liquibase;
/**
@AutoConfiguration(after = LiquibaseAutoConfiguration.class)
@ConditionalOnClass(SpringLiquibase.class)
@ConditionalOnAvailableEndpoint(LiquibaseEndpoint.class)
public class LiquibaseEndpointAutoConfiguration {
	@Bean
	@ConditionalOnBean(SpringLiquibase.class)
	@ConditionalOnMissingBean
	public LiquibaseEndpoint liquibaseEndpoint(ApplicationContext context) {
		return new LiquibaseEndpoint(context);
	}
	@Bean
	@ConditionalOnBean(SpringLiquibase.class)
	public static BeanPostProcessor preventDataSourceCloseBeanPostProcessor() {
		return new BeanPostProcessor() {
			@Override
			public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
				if (bean instanceof DataSourceClosingSpringLiquibase dataSource) {
					dataSource.setCloseDataSourceOnceMigrated(false);
				}
				return bean;
			}
			@Override
			public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
				return bean;
			}
		};
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.liquibase;
/*
/**
package org.springframework.boot.actuate.autoconfigure.flyway;
/*
package org.springframework.boot.actuate.autoconfigure.flyway;
/**
@AutoConfiguration(after = FlywayAutoConfiguration.class)
@ConditionalOnClass(Flyway.class)
@ConditionalOnAvailableEndpoint(FlywayEndpoint.class)
public class FlywayEndpointAutoConfiguration {
	@Bean
	@ConditionalOnBean(Flyway.class)
	@ConditionalOnMissingBean
	public FlywayEndpoint flywayEndpoint(ApplicationContext context) {
		return new FlywayEndpoint(context);
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.sbom;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(SbomEndpoint.class)
@EnableConfigurationProperties(SbomProperties.class)
public class SbomEndpointAutoConfiguration {
	private final SbomProperties properties;
	SbomEndpointAutoConfiguration(SbomProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	SbomEndpoint sbomEndpoint(ResourceLoader resourceLoader) {
		return new SbomEndpoint(this.properties, resourceLoader);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(SbomEndpoint.class)
	@ConditionalOnAvailableEndpoint(exposure = EndpointExposure.WEB)
	SbomEndpointWebExtension sbomEndpointWebExtension(SbomEndpoint sbomEndpoint) {
		return new SbomEndpointWebExtension(sbomEndpoint, this.properties);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.sbom;
/*
package org.springframework.boot.actuate.autoconfigure.management;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(ThreadDumpEndpoint.class)
public class ThreadDumpEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public ThreadDumpEndpoint dumpEndpoint() {
		return new ThreadDumpEndpoint();
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.management;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(HeapDumpWebEndpoint.class)
public class HeapDumpWebEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public HeapDumpWebEndpoint heapDumpWebEndpoint() {
		return new HeapDumpWebEndpoint();
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.management;
/*
package org.springframework.boot.actuate.autoconfigure.ldap;
/**
@AutoConfiguration(after = LdapAutoConfiguration.class)
@ConditionalOnClass(LdapOperations.class)
@ConditionalOnBean(LdapOperations.class)
@ConditionalOnEnabledHealthIndicator('ldap')
public class LdapHealthContributorAutoConfiguration
		extends CompositeHealthContributorConfiguration<LdapHealthIndicator, LdapOperations> {
	public LdapHealthContributorAutoConfiguration() {
		super(LdapHealthIndicator::new);
	}
	@Bean
	@ConditionalOnMissingBean(name = { 'ldapHealthIndicator', 'ldapHealthContributor' })
	public HealthContributor ldapHealthContributor(Map<String, LdapOperations> ldapOperations) {
		return createContributor(ldapOperations);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.ldap;
/*
package org.springframework.boot.actuate.autoconfigure;
/**
public abstract class OnEndpointElementCondition extends SpringBootCondition {
	private final String prefix;
	private final Class<? extends Annotation> annotationType;
	protected OnEndpointElementCondition(String prefix, Class<? extends Annotation> annotationType) {
		this.prefix = prefix;
		this.annotationType = annotationType;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		AnnotationAttributes annotationAttributes = AnnotationAttributes
			.fromMap(metadata.getAnnotationAttributes(this.annotationType.getName()));
		String endpointName = annotationAttributes.getString('value');
		ConditionOutcome outcome = getEndpointOutcome(context, endpointName);
		if (outcome != null) {
			return outcome;
		}
		return getDefaultOutcome(context, annotationAttributes);
	}
	protected ConditionOutcome getEndpointOutcome(ConditionContext context, String endpointName) {
		Environment environment = context.getEnvironment();
		String enabledProperty = this.prefix + endpointName + '.enabled';
		if (environment.containsProperty(enabledProperty)) {
			boolean match = environment.getProperty(enabledProperty, Boolean.class, true);
			return new ConditionOutcome(match, ConditionMessage.forCondition(this.annotationType)
				.because(this.prefix + endpointName + '.enabled is ' + match));
		}
		return null;
	}
	/**
	 * Return the default outcome that should be used if property is not set. By default
	 * this method will use the {@code <prefix>.defaults.enabled} property, matching if it
	 * is {@code true} or if it is not configured.
	 * @param context the condition context
	 * @param annotationAttributes the annotation attributes
	 * @return the default outcome
	 * @since 2.6.0
	 */
	protected ConditionOutcome getDefaultOutcome(ConditionContext context, AnnotationAttributes annotationAttributes) {
		boolean match = Boolean
			.parseBoolean(context.getEnvironment().getProperty(this.prefix + 'defaults.enabled', 'true'));
		return new ConditionOutcome(match, ConditionMessage.forCondition(this.annotationType)
			.because(this.prefix + 'defaults.enabled is considered ' + match));
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.env;
/**
@ConfigurationProperties('management.endpoint.env')
public class EnvironmentEndpointProperties {
	/**
	 * When to show unsanitized values.
	 */
	private Show showValues = Show.NEVER;
	/**
	 * Roles used to determine whether a user is authorized to be shown unsanitized
	 * values. When empty, all authenticated users are authorized.
	 */
	private final Set<String> roles = new HashSet<>();
	public Show getShowValues() {
		return this.showValues;
	}
	public void setShowValues(Show showValues) {
		this.showValues = showValues;
	}
	public Set<String> getRoles() {
		return this.roles;
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.env;
/*
package org.springframework.boot.actuate.autoconfigure.env;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(EnvironmentEndpoint.class)
@EnableConfigurationProperties(EnvironmentEndpointProperties.class)
public class EnvironmentEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public EnvironmentEndpoint environmentEndpoint(Environment environment, EnvironmentEndpointProperties properties,
			ObjectProvider<SanitizingFunction> sanitizingFunctions) {
		return new EnvironmentEndpoint(environment, sanitizingFunctions.orderedStream().toList(),
				properties.getShowValues());
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnBean(EnvironmentEndpoint.class)
	@ConditionalOnAvailableEndpoint(exposure = EndpointExposure.WEB)
	public EnvironmentEndpointWebExtension environmentEndpointWebExtension(EnvironmentEndpoint environmentEndpoint,
			EnvironmentEndpointProperties properties) {
		return new EnvironmentEndpointWebExtension(environmentEndpoint, properties.getShowValues(),
				properties.getRoles());
	}
}
/*
package org.springframework.boot.actuate.autoconfigure.beans;
/**
@AutoConfiguration
@ConditionalOnAvailableEndpoint(BeansEndpoint.class)
public class BeansEndpointAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public BeansEndpoint beansEndpoint(ConfigurableApplicationContext applicationContext) {
		return new BeansEndpoint(applicationContext);
	}
}
/*
/**
package org.springframework.boot.actuate.autoconfigure.beans;
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
@Testcontainers(disabledWithoutDocker = true)
class CassandraAutoConfigurationIntegrationTests {
	@Container
	static final CassandraContainer cassandra = TestImage.container(CassandraContainer.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CassandraAutoConfiguration.class))
		.withPropertyValues(
				'spring.cassandra.contact-points:' + cassandra.getHost() + ':' + cassandra.getFirstMappedPort(),
				'spring.cassandra.local-datacenter=datacenter1', 'spring.cassandra.connection.connect-timeout=60s',
				'spring.cassandra.connection.init-query-timeout=60s', 'spring.cassandra.request.timeout=60s');
	@Test
	void whenTheContextIsClosedThenTheDriverConfigLoaderIsClosed() {
		this.contextRunner.withUserConfiguration(DriverConfigLoaderSpyConfiguration.class).run((context) -> {
			assertThat(((BeanDefinitionRegistry) context.getSourceApplicationContext())
				.getBeanDefinition('cassandraDriverConfigLoader')
				.getDestroyMethodName()).isEmpty();
			// Initialize lazy bean
			context.getBean(CqlSession.class);
			DriverConfigLoader driverConfigLoader = context.getBean(DriverConfigLoader.class);
			context.close();
			then(driverConfigLoader).should().close();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class DriverConfigLoaderSpyConfiguration {
		@Bean
		static BeanPostProcessor driverConfigLoaderSpy() {
			return new BeanPostProcessor() {
				@Override
				public Object postProcessAfterInitialization(Object bean, String beanName) {
					if (bean instanceof DriverConfigLoader) {
						return spy(bean);
					}
					return bean;
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
@Testcontainers(disabledWithoutDocker = true)
class CassandraAutoConfigurationWithPasswordAuthenticationIntegrationTests {
	@Container
	static final CassandraContainer cassandra = TestImage.container(PasswordAuthenticatorCassandraContainer.class)
		.withStartupAttempts(5)
		.waitingFor(new CassandraWaitStrategy());
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CassandraAutoConfiguration.class))
		.withPropertyValues(
				'spring.cassandra.contact-points:' + cassandra.getHost() + ':' + cassandra.getFirstMappedPort(),
				'spring.cassandra.local-datacenter=datacenter1', 'spring.cassandra.connection.connect-timeout=60s',
				'spring.cassandra.connection.init-query-timeout=60s', 'spring.cassandra.request.timeout=60s');
	@Test
	void authenticationWithValidUsernameAndPassword() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.username=cassandra', 'spring.cassandra.password=cassandra')
			.run((context) -> {
				SimpleStatement select = SimpleStatement.newInstance('SELECT release_version FROM system.local')
					.setConsistencyLevel(ConsistencyLevel.LOCAL_ONE);
				assertThat(context.getBean(CqlSession.class).execute(select).one()).isNotNull();
			});
	}
	@Test
	void authenticationWithInvalidCredentials() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.username=not-a-user', 'spring.cassandra.password=invalid-password')
			.run((context) -> assertThatExceptionOfType(BeanCreationException.class)
				.isThrownBy(() -> context.getBean(CqlSession.class))
				.withMessageContaining('Authentication error'));
	}
	static final class PasswordAuthenticatorCassandraContainer extends CassandraContainer {
		PasswordAuthenticatorCassandraContainer(DockerImageName dockerImageName) {
			super(dockerImageName);
		}
		@Override
		protected void containerIsCreated(String containerId) {
			String config = copyFileFromContainer('/etc/cassandra/cassandra.yaml',
					(stream) -> StreamUtils.copyToString(stream, StandardCharsets.UTF_8));
			String updatedConfig = config.replace('authenticator: AllowAllAuthenticator',
					'authenticator: PasswordAuthenticator');
			copyFileToContainer(Transferable.of(updatedConfig.getBytes(StandardCharsets.UTF_8)),
					'/etc/cassandra/cassandra.yaml');
		}
	}
	static final class CassandraWaitStrategy extends AbstractWaitStrategy {
		@Override
		protected void waitUntilReady() {
			try {
				Unreliables.retryUntilSuccess((int) this.startupTimeout.getSeconds(), TimeUnit.SECONDS, () -> {
					getRateLimiter().doWhenReady(() -> cqlSessionBuilder().build());
					return true;
				});
			}
			catch (TimeoutException ex) {
				throw new ContainerLaunchException(
						'Timed out waiting for Cassandra to be accessible for query execution');
			}
		}
		private CqlSessionBuilder cqlSessionBuilder() {
			return CqlSession.builder()
				.addContactPoint(new InetSocketAddress(this.waitStrategyTarget.getHost(),
						this.waitStrategyTarget.getFirstMappedPort()))
				.withLocalDatacenter('datacenter1')
				.withAuthCredentials('cassandra', 'cassandra');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mail;
/**
@Testcontainers(disabledWithoutDocker = true)
class MailSenderAutoConfigurationIntegrationTests {
	private SimpleMailMessage createMessage(String subject) {
		SimpleMailMessage msg = new SimpleMailMessage();
		msg.setFrom('from@example.com');
		msg.setTo('to@example.com');
		msg.setSubject(subject);
		msg.setText('Subject: ' + subject);
		return msg;
	}
	private String getSubject(Message message) {
		try {
			return message.getSubject();
		}
		catch (MessagingException ex) {
			throw new RuntimeException('Failed to get message subject', ex);
		}
	}
	private void assertMessagesContainSubject(Session session, String subject) throws MessagingException {
		try (Store store = session.getStore('pop3')) {
			String host = session.getProperty('mail.pop3.host');
			int port = Integer.parseInt(session.getProperty('mail.pop3.port'));
			store.connect(host, port, 'user', 'pass');
			try (Folder folder = store.getFolder('inbox')) {
				folder.open(Folder.READ_ONLY);
				Awaitility.await()
					.atMost(Duration.ofSeconds(5))
					.ignoreExceptions()
					.untilAsserted(() -> assertThat(Arrays.stream(folder.getMessages()).map(this::getSubject))
						.contains(subject));
			}
		}
	}
	@Nested
	class ImplicitTlsTests {
		@Container
		private static final MailpitContainer mailpit = TestImage.container(MailpitContainer.class)
			.withSmtpRequireTls(true)
			.withSmtpTlsCert(MountableFile
				.forClasspathResource('/org/springframework/boot/autoconfigure/mail/ssl/test-server.crt'))
			.withSmtpTlsKey(MountableFile
				.forClasspathResource('/org/springframework/boot/autoconfigure/mail/ssl/test-server.key'))
			.withPop3Auth('user:pass');
		private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(MailSenderAutoConfiguration.class, SslAutoConfiguration.class));
		@Test
		void sendEmailWithSslEnabledAndCert() {
			this.contextRunner.withPropertyValues('spring.mail.host:' + mailpit.getHost(),
					'spring.mail.port:' + mailpit.getSmtpPort(), 'spring.mail.ssl.enabled:true',
					'spring.mail.ssl.bundle:test-bundle',
					'spring.ssl.bundle.pem.test-bundle.truststore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-ca.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.private-key=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.key',
					'spring.mail.properties.mail.pop3.host:' + mailpit.getHost(),
					'spring.mail.properties.mail.pop3.port:' + mailpit.getPop3Port())
				.run((context) -> {
					JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
					mailSender.send(createMessage('Hello World!'));
					assertMessagesContainSubject(mailSender.getSession(), 'Hello World!');
				});
		}
		@Test
		void sendEmailWithSslEnabledWithoutCert() {
			this.contextRunner
				.withPropertyValues('spring.mail.host:' + mailpit.getHost(),
						'spring.mail.port:' + mailpit.getSmtpPort(), 'spring.mail.ssl.enabled:true')
				.run((context) -> {
					JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
					assertThatException().isThrownBy(() -> mailSender.send(createMessage('Should fail')))
						.withRootCauseInstanceOf(CertPathBuilderException.class);
				});
		}
		@Test
		void sendEmailWithoutSslWithCert() {
			this.contextRunner.withPropertyValues('spring.mail.host:' + mailpit.getHost(),
					'spring.mail.port:' + mailpit.getSmtpPort(), 'spring.mail.properties.mail.smtp.timeout:1000',
					'spring.mail.ssl.bundle:test-bundle',
					'spring.ssl.bundle.pem.test-bundle.truststore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-ca.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.private-key=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.key')
				.run((context) -> {
					JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
					assertThatException().isThrownBy(() -> mailSender.send(createMessage('Should fail')))
						.withRootCauseInstanceOf(SocketTimeoutException.class);
				});
		}
	}
	@Nested
	class StarttlsTests {
		@Container
		private static final MailpitContainer mailpit = TestImage.container(MailpitContainer.class)
			.withSmtpRequireStarttls(true)
			.withSmtpTlsCert(MountableFile
				.forClasspathResource('/org/springframework/boot/autoconfigure/mail/ssl/test-server.crt'))
			.withSmtpTlsKey(MountableFile
				.forClasspathResource('/org/springframework/boot/autoconfigure/mail/ssl/test-server.key'))
			.withPop3Auth('user:pass');
		final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(MailSenderAutoConfiguration.class, SslAutoConfiguration.class));
		@Test
		void sendEmailWithStarttlsAndCertAndSslDisabled() {
			this.contextRunner.withPropertyValues('spring.mail.host:' + mailpit.getHost(),
					'spring.mail.port:' + mailpit.getSmtpPort(),
					'spring.mail.properties.mail.smtp.starttls.enable:true',
					'spring.mail.properties.mail.smtp.starttls.required:true', 'spring.mail.ssl.bundle:test-bundle',
					'spring.ssl.bundle.pem.test-bundle.truststore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-ca.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.private-key=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.key',
					'spring.mail.properties.mail.pop3.host:' + mailpit.getHost(),
					'spring.mail.properties.mail.pop3.port:' + mailpit.getPop3Port())
				.run((context) -> {
					JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
					mailSender.send(createMessage('Sent with STARTTLS'));
					assertMessagesContainSubject(mailSender.getSession(), 'Sent with STARTTLS');
				});
		}
		@Test
		void sendEmailWithStarttlsAndCertAndSslEnabled() {
			this.contextRunner.withPropertyValues('spring.mail.host:' + mailpit.getHost(),
					'spring.mail.port:' + mailpit.getSmtpPort(), 'spring.mail.ssl.enabled:true',
					'spring.mail.properties.mail.smtp.starttls.enable:true',
					'spring.mail.properties.mail.smtp.starttls.required:true', 'spring.mail.ssl.bundle:test-bundle',
					'spring.ssl.bundle.pem.test-bundle.truststore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-ca.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.certificate=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.crt',
					'spring.ssl.bundle.pem.test-bundle.keystore.private-key=classpath:org/springframework/boot/autoconfigure/mail/ssl/test-client.key',
					'spring.mail.properties.mail.pop3.host:' + mailpit.getHost(),
					'spring.mail.properties.mail.pop3.port:' + mailpit.getPop3Port())
				.run((context) -> {
					JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
					assertThatException().isThrownBy(() -> mailSender.send(createMessage('Should fail')))
						.withRootCauseInstanceOf(SSLException.class);
				});
		}
		@Test
		void sendEmailWithStarttlsWithoutCert() {
			this.contextRunner
				.withPropertyValues('spring.mail.host:' + mailpit.getHost(),
						'spring.mail.port:' + mailpit.getSmtpPort(),
						'spring.mail.properties.mail.smtp.starttls.enable:true',
						'spring.mail.properties.mail.smtp.starttls.required:true')
				.run((context) -> {
					JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
					assertThatException().isThrownBy(() -> mailSender.send(createMessage('Should fail')))
						.withRootCauseInstanceOf(CertPathBuilderException.class);
				});
		}
	}
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
@Testcontainers(disabledWithoutDocker = true)
class CouchbaseAutoConfigurationIntegrationTests {
	private static final String BUCKET_NAME = 'cbbucket';
	@Container
	static final CouchbaseContainer couchbase = TestImage.container(CouchbaseContainer.class)
		.withEnabledServices(CouchbaseService.KV)
		.withCredentials('spring', 'password')
		.withBucket(new BucketDefinition(BUCKET_NAME).withPrimaryIndex(false));
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class))
		.withPropertyValues('spring.couchbase.connection-string: ' + couchbase.getConnectionString(),
				'spring.couchbase.username:spring', 'spring.couchbase.password:password',
				'spring.couchbase.bucket.name:' + BUCKET_NAME, 'spring.couchbase.env.timeouts.connect=2m',
				'spring.couchbase.env.timeouts.key-value=1m');
	@Test
	void defaultConfiguration() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Cluster.class).hasSingleBean(ClusterEnvironment.class);
			Cluster cluster = context.getBean(Cluster.class);
			Bucket bucket = cluster.bucket(BUCKET_NAME);
			bucket.waitUntilReady(Duration.ofMinutes(5));
			DiagnosticsResult diagnostics = cluster.diagnostics();
			assertThat(diagnostics.state()).isEqualTo(ClusterState.ONLINE);
		});
	}
	@Test
	void whenCouchbaseIsUsingCustomObjectMapperThenJsonCanBeRoundTripped() {
		this.contextRunner.withBean(ObjectMapper.class, ObjectMapper::new).run((context) -> {
			Cluster cluster = context.getBean(Cluster.class);
			Bucket bucket = cluster.bucket(BUCKET_NAME);
			bucket.waitUntilReady(Duration.ofMinutes(5));
			Collection collection = bucket.defaultCollection();
			collection.insert('test-document', JsonObject.create().put('a', 'alpha'));
			assertThat(collection.get('test-document').contentAsObject().get('a')).isEqualTo('alpha');
		});
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Testcontainers(disabledWithoutDocker = true)
class ReactiveSessionAutoConfigurationMongoTests extends AbstractSessionAutoConfigurationTests {
	@Container
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader(ReactiveRedisSessionRepository.class))
		.withConfiguration(AutoConfigurations.of(SessionAutoConfiguration.class, MongoAutoConfiguration.class,
				MongoDataAutoConfiguration.class, MongoReactiveAutoConfiguration.class,
				MongoReactiveDataAutoConfiguration.class));
	@Test
	void defaultConfig() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=' + mongoDb.getReplicaSetUrl())
			.run(validateSpringSessionUsesMongo('sessions'));
	}
	@Test
	void defaultConfigWithCustomTimeout() {
		this.contextRunner
			.withPropertyValues('spring.session.timeout=1m', 'spring.data.mongodb.uri=' + mongoDb.getReplicaSetUrl())
			.run((context) -> {
				ReactiveMongoSessionRepository repository = validateSessionRepository(context,
						ReactiveMongoSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', Duration.ofMinutes(1));
			});
	}
	@Test
	void defaultConfigWithCustomSessionTimeout() {
		this.contextRunner
			.withPropertyValues('server.reactive.session.timeout=1m',
					'spring.data.mongodb.uri=' + mongoDb.getReplicaSetUrl())
			.run((context) -> {
				ReactiveMongoSessionRepository repository = validateSessionRepository(context,
						ReactiveMongoSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', Duration.ofMinutes(1));
			});
	}
	@Test
	void mongoSessionStoreWithCustomizations() {
		this.contextRunner
			.withPropertyValues('spring.session.mongodb.collection-name=foo',
					'spring.data.mongodb.uri=' + mongoDb.getReplicaSetUrl())
			.run(validateSpringSessionUsesMongo('foo'));
	}
	@Test
	void sessionCookieConfigurationIsAppliedToAutoConfiguredWebSessionIdResolver() {
		AutoConfigurations autoConfigurations = AutoConfigurations.of(SessionAutoConfiguration.class,
				MongoAutoConfiguration.class, MongoDataAutoConfiguration.class, MongoReactiveAutoConfiguration.class,
				MongoReactiveDataAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class);
		new ReactiveWebApplicationContextRunner().withConfiguration(autoConfigurations)
			.withUserConfiguration(Config.class)
			.withClassLoader(new FilteredClassLoader(ReactiveRedisSessionRepository.class))
			.withPropertyValues('server.reactive.session.cookie.name:JSESSIONID',
					'server.reactive.session.cookie.domain:.example.com',
					'server.reactive.session.cookie.path:/example', 'server.reactive.session.cookie.max-age:60',
					'server.reactive.session.cookie.http-only:false', 'server.reactive.session.cookie.secure:false',
					'server.reactive.session.cookie.same-site:strict',
					'spring.data.mongodb.uri=' + mongoDb.getReplicaSetUrl())
			.run(assertExchangeWithSession((exchange) -> {
				List<ResponseCookie> cookies = exchange.getResponse().getCookies().get('JSESSIONID');
				assertThat(cookies).isNotEmpty();
				assertThat(cookies).allMatch((cookie) -> cookie.getDomain().equals('.example.com'));
				assertThat(cookies).allMatch((cookie) -> cookie.getPath().equals('/example'));
				assertThat(cookies).allMatch((cookie) -> cookie.getMaxAge().equals(Duration.ofSeconds(60)));
				assertThat(cookies).allMatch((cookie) -> !cookie.isHttpOnly());
				assertThat(cookies).allMatch((cookie) -> !cookie.isSecure());
				assertThat(cookies).allMatch((cookie) -> cookie.getSameSite().equals('Strict'));
			}));
	}
	private ContextConsumer<AssertableReactiveWebApplicationContext> validateSpringSessionUsesMongo(
			String collectionName) {
		return (context) -> {
			ReactiveMongoSessionRepository repository = validateSessionRepository(context,
					ReactiveMongoSessionRepository.class);
			assertThat(repository.getCollectionName()).isEqualTo(collectionName);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval',
					MapSession.DEFAULT_MAX_INACTIVE_INTERVAL);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Testcontainers(disabledWithoutDocker = true)
class SessionAutoConfigurationMongoTests extends AbstractSessionAutoConfigurationTests {
	@Container
	static final MongoDBContainer mongoDb = TestImage.container(MongoDBContainer.class);
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader(HazelcastIndexedSessionRepository.class,
				JdbcIndexedSessionRepository.class, RedisIndexedSessionRepository.class))
		.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
				SessionAutoConfiguration.class))
		.withPropertyValues('spring.data.mongodb.uri=' + mongoDb.getReplicaSetUrl());
	@Test
	void defaultConfig() {
		this.contextRunner.run(validateSpringSessionUsesMongo('sessions'));
	}
	@Test
	void defaultConfigWithCustomTimeout() {
		this.contextRunner.withPropertyValues('spring.session.timeout=1m')
			.run(validateSpringSessionUsesMongo('sessions', Duration.ofMinutes(1)));
	}
	@Test
	void mongoSessionStoreWithCustomizations() {
		this.contextRunner.withPropertyValues('spring.session.mongodb.collection-name=foo')
			.run(validateSpringSessionUsesMongo('foo'));
	}
	@Test
	void whenTheUserDefinesTheirOwnSessionRepositoryCustomizerThenDefaultConfigurationIsOverwritten() {
		this.contextRunner.withUserConfiguration(CustomizerConfiguration.class)
			.withPropertyValues('spring.session.mongodb.collection-name=foo')
			.run(validateSpringSessionUsesMongo('customized'));
	}
	private ContextConsumer<AssertableWebApplicationContext> validateSpringSessionUsesMongo(String collectionName) {
		return validateSpringSessionUsesMongo(collectionName,
				new ServerProperties().getServlet().getSession().getTimeout());
	}
	private ContextConsumer<AssertableWebApplicationContext> validateSpringSessionUsesMongo(String collectionName,
			Duration timeout) {
		return (context) -> {
			MongoIndexedSessionRepository repository = validateSessionRepository(context,
					MongoIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('collectionName', collectionName);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', timeout);
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		SessionRepositoryCustomizer<MongoIndexedSessionRepository> sessionRepositoryCustomizer() {
			return (repository) -> repository.setCollectionName('customized');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Testcontainers(disabledWithoutDocker = true)
class SessionAutoConfigurationRedisTests extends AbstractSessionAutoConfigurationTests {
	@Container
	public static RedisContainer redis = TestImage.container(RedisContainer.class);
	protected final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader(HazelcastIndexedSessionRepository.class,
				JdbcIndexedSessionRepository.class, MongoIndexedSessionRepository.class))
		.withConfiguration(AutoConfigurations.of(SessionAutoConfiguration.class));
	@Test
	void defaultConfig() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.run(validateSpringSessionUsesDefaultRedis('spring:session:', FlushMode.ON_SAVE,
					SaveMode.ON_SET_ATTRIBUTE));
	}
	@Test
	void invalidConfigurationPropertyValueWhenDefaultConfigIsUsedWithCustomCronCleanup() {
		this.contextRunner.withPropertyValues('spring.data.redis.host=' + redis.getHost(),
				'spring.data.redis.port=' + redis.getFirstMappedPort(), 'spring.session.redis.cleanup-cron=0 0 * * * *')
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure())
					.hasRootCauseExactlyInstanceOf(InvalidConfigurationPropertyValueException.class);
			});
	}
	@Test
	void redisTakesPrecedenceMultipleImplementations() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateSpringSessionUsesDefaultRedis('spring:session:', FlushMode.ON_SAVE,
					SaveMode.ON_SET_ATTRIBUTE));
	}
	@Test
	void defaultConfigWithCustomTimeout() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort(), 'spring.session.timeout=1m')
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.run((context) -> {
				RedisSessionRepository repository = validateSessionRepository(context, RedisSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', Duration.ofMinutes(1));
			});
	}
	@Test
	void defaultRedisSessionStoreWithCustomizations() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.session.redis.namespace=foo', 'spring.session.redis.flush-mode=immediate',
					'spring.session.redis.save-mode=on-get-attribute', 'spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateSpringSessionUsesDefaultRedis('foo:', FlushMode.IMMEDIATE, SaveMode.ON_GET_ATTRIBUTE));
	}
	@Test
	void indexedRedisSessionDefaultConfig() {
		this.contextRunner
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.run(validateSpringSessionUsesIndexedRedis('spring:session:', FlushMode.ON_SAVE, SaveMode.ON_SET_ATTRIBUTE,
					'0 * * * * *'));
	}
	@Test
	void indexedRedisSessionStoreWithCustomizations() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.session.redis.repository-type=indexed', 'spring.session.redis.namespace=foo',
					'spring.session.redis.flush-mode=immediate', 'spring.session.redis.save-mode=on-get-attribute',
					'spring.session.redis.cleanup-cron=0 0 12 * * *', 'spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateSpringSessionUsesIndexedRedis('foo:', FlushMode.IMMEDIATE, SaveMode.ON_GET_ATTRIBUTE,
					'0 0 12 * * *'));
	}
	@Test
	void indexedRedisSessionWithConfigureActionNone() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.session.redis.configure-action=none', 'spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateStrategy(ConfigureRedisAction.NO_OP.getClass()));
	}
	@Test
	void indexedRedisSessionWithDefaultConfigureActionNone() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateStrategy(ConfigureNotifyKeyspaceEventsAction.class, entry('notify-keyspace-events', 'gxE')));
	}
	@Test
	void indexedRedisSessionWithCustomConfigureRedisActionBean() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withUserConfiguration(MaxEntriesRedisAction.class)
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateStrategy(MaxEntriesRedisAction.class, entry('set-max-intset-entries', '1024')));
	}
	@Test
	void whenTheUserDefinesTheirOwnSessionRepositoryCustomizerThenDefaultConfigurationIsOverwritten() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withUserConfiguration(CustomizerConfiguration.class)
			.withPropertyValues('spring.session.redis.flush-mode=immediate',
					'spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run((context) -> {
				RedisSessionRepository repository = validateSessionRepository(context, RedisSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('flushMode', FlushMode.ON_SAVE);
			});
	}
	@Test
	void whenIndexedAndTheUserDefinesTheirOwnSessionRepositoryCustomizerThenDefaultConfigurationIsOverwritten() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withUserConfiguration(IndexedCustomizerConfiguration.class)
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.session.redis.flush-mode=immediate', 'spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run((context) -> {
				RedisIndexedSessionRepository repository = validateSessionRepository(context,
						RedisIndexedSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('flushMode', FlushMode.ON_SAVE);
			});
	}
	private ContextConsumer<AssertableWebApplicationContext> validateSpringSessionUsesDefaultRedis(String keyNamespace,
			FlushMode flushMode, SaveMode saveMode) {
		return (context) -> {
			RedisSessionRepository repository = validateSessionRepository(context, RedisSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval',
					new ServerProperties().getServlet().getSession().getTimeout());
			assertThat(repository).hasFieldOrPropertyWithValue('keyNamespace', keyNamespace);
			assertThat(repository).hasFieldOrPropertyWithValue('flushMode', flushMode);
			assertThat(repository).hasFieldOrPropertyWithValue('saveMode', saveMode);
		};
	}
	private ContextConsumer<AssertableWebApplicationContext> validateSpringSessionUsesIndexedRedis(String keyNamespace,
			FlushMode flushMode, SaveMode saveMode, String cleanupCron) {
		return (context) -> {
			RedisIndexedSessionRepository repository = validateSessionRepository(context,
					RedisIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval',
					new ServerProperties().getServlet().getSession().getTimeout());
			assertThat(repository).hasFieldOrPropertyWithValue('namespace', keyNamespace);
			assertThat(repository).hasFieldOrPropertyWithValue('flushMode', flushMode);
			assertThat(repository).hasFieldOrPropertyWithValue('saveMode', saveMode);
			assertThat(repository).hasFieldOrPropertyWithValue('cleanupCron', cleanupCron);
		};
	}
	private ContextConsumer<AssertableWebApplicationContext> validateStrategy(
			Class<? extends ConfigureRedisAction> expectedConfigureRedisActionType, Map.Entry<?, ?>... expectedConfig) {
		return (context) -> {
			assertThat(context).hasSingleBean(ConfigureRedisAction.class);
			assertThat(context).hasSingleBean(RedisConnectionFactory.class);
			assertThat(context.getBean(ConfigureRedisAction.class)).isInstanceOf(expectedConfigureRedisActionType);
			RedisConnection connection = context.getBean(RedisConnectionFactory.class).getConnection();
			if (expectedConfig.length > 0) {
				assertThat(connection.serverCommands().getConfig('*')).contains(expectedConfig);
			}
		};
	}
	static class MaxEntriesRedisAction implements ConfigureRedisAction {
		@Override
		public void configure(RedisConnection connection) {
			connection.serverCommands().setConfig('set-max-intset-entries', '1024');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		SessionRepositoryCustomizer<RedisSessionRepository> sessionRepositoryCustomizer() {
			return (repository) -> repository.setFlushMode(FlushMode.ON_SAVE);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class IndexedCustomizerConfiguration {
		@Bean
		SessionRepositoryCustomizer<RedisIndexedSessionRepository> sessionRepositoryCustomizer() {
			return (repository) -> repository.setFlushMode(FlushMode.ON_SAVE);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Testcontainers(disabledWithoutDocker = true)
class ReactiveSessionAutoConfigurationRedisTests extends AbstractSessionAutoConfigurationTests {
	@Container
	public static RedisContainer redis = TestImage.container(RedisContainer.class);
	protected final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader(ReactiveMongoSessionRepository.class))
		.withConfiguration(
				AutoConfigurations.of(SessionAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class,
						RedisAutoConfiguration.class, RedisReactiveAutoConfiguration.class));
	@Test
	void defaultConfig() {
		this.contextRunner.run(validateSpringSessionUsesRedis('spring:session:', SaveMode.ON_SET_ATTRIBUTE));
	}
	@Test
	void redisTakesPrecedenceMultipleImplementations() {
		ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner().withConfiguration(
				AutoConfigurations.of(SessionAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class,
						RedisAutoConfiguration.class, RedisReactiveAutoConfiguration.class));
		contextRunner.run(validateSpringSessionUsesRedis('spring:session:', SaveMode.ON_SET_ATTRIBUTE));
	}
	@Test
	void defaultConfigWithCustomTimeout() {
		this.contextRunner.withPropertyValues('spring.session.timeout=1m').run((context) -> {
			ReactiveRedisSessionRepository repository = validateSessionRepository(context,
					ReactiveRedisSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', Duration.ofMinutes(1));
		});
	}
	@Test
	void defaultConfigWithCustomWebFluxTimeout() {
		this.contextRunner.withPropertyValues('server.reactive.session.timeout=1m').run((context) -> {
			ReactiveRedisSessionRepository repository = validateSessionRepository(context,
					ReactiveRedisSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', Duration.ofMinutes(1));
		});
	}
	@Test
	void redisSessionStoreWithCustomizations() {
		this.contextRunner
			.withPropertyValues('spring.session.redis.namespace=foo', 'spring.session.redis.save-mode=on-get-attribute')
			.run(validateSpringSessionUsesRedis('foo:', SaveMode.ON_GET_ATTRIBUTE));
	}
	@Test
	void sessionCookieConfigurationIsAppliedToAutoConfiguredWebSessionIdResolver() {
		this.contextRunner.withUserConfiguration(Config.class)
			.withPropertyValues('spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort(),
					'server.reactive.session.cookie.name:JSESSIONID',
					'server.reactive.session.cookie.domain:.example.com',
					'server.reactive.session.cookie.path:/example', 'server.reactive.session.cookie.max-age:60',
					'server.reactive.session.cookie.http-only:false', 'server.reactive.session.cookie.secure:false',
					'server.reactive.session.cookie.same-site:strict')
			.run(assertExchangeWithSession((exchange) -> {
				List<ResponseCookie> cookies = exchange.getResponse().getCookies().get('JSESSIONID');
				assertThat(cookies).isNotEmpty();
				assertThat(cookies).allMatch((cookie) -> cookie.getDomain().equals('.example.com'));
				assertThat(cookies).allMatch((cookie) -> cookie.getPath().equals('/example'));
				assertThat(cookies).allMatch((cookie) -> cookie.getMaxAge().equals(Duration.ofSeconds(60)));
				assertThat(cookies).allMatch((cookie) -> !cookie.isHttpOnly());
				assertThat(cookies).allMatch((cookie) -> !cookie.isSecure());
				assertThat(cookies).allMatch((cookie) -> cookie.getSameSite().equals('Strict'));
			}));
	}
	@Test
	void indexedRedisSessionDefaultConfig() {
		this.contextRunner
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.run(validateSpringSessionUsesIndexedRedis('spring:session:', SaveMode.ON_SET_ATTRIBUTE));
	}
	@Test
	void indexedRedisSessionStoreWithCustomizations() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.session.redis.repository-type=indexed', 'spring.session.redis.namespace=foo',
					'spring.session.redis.save-mode=on-get-attribute', 'spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateSpringSessionUsesIndexedRedis('foo:', SaveMode.ON_GET_ATTRIBUTE));
	}
	@Test
	void indexedRedisSessionWithConfigureActionNone() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.session.redis.configure-action=none', 'spring.data.redis.host=' + redis.getHost(),
					'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateStrategy(ConfigureReactiveRedisAction.NO_OP.getClass()));
	}
	@Test
	void indexedRedisSessionWithDefaultConfigureActionNone() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateStrategy(ConfigureNotifyKeyspaceEventsReactiveAction.class,
					entry('notify-keyspace-events', 'gxE')));
	}
	@Test
	void indexedRedisSessionWithCustomConfigureReactiveRedisActionBean() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class))
			.withUserConfiguration(MaxEntriesReactiveRedisAction.class)
			.withPropertyValues('spring.session.redis.repository-type=indexed',
					'spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.run(validateStrategy(MaxEntriesReactiveRedisAction.class, entry('set-max-intset-entries', '1024')));
	}
	private ContextConsumer<AssertableReactiveWebApplicationContext> validateSpringSessionUsesRedis(String namespace,
			SaveMode saveMode) {
		return (context) -> {
			ReactiveRedisSessionRepository repository = validateSessionRepository(context,
					ReactiveRedisSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval',
					MapSession.DEFAULT_MAX_INACTIVE_INTERVAL);
			assertThat(repository).hasFieldOrPropertyWithValue('namespace', namespace);
			assertThat(repository).hasFieldOrPropertyWithValue('saveMode', saveMode);
		};
	}
	private ContextConsumer<AssertableReactiveWebApplicationContext> validateSpringSessionUsesIndexedRedis(
			String keyNamespace, SaveMode saveMode) {
		return (context) -> {
			ReactiveRedisIndexedSessionRepository repository = validateSessionRepository(context,
					ReactiveRedisIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval',
					new ServerProperties().getReactive().getSession().getTimeout());
			assertThat(repository).hasFieldOrPropertyWithValue('namespace', keyNamespace);
			assertThat(repository).hasFieldOrPropertyWithValue('saveMode', saveMode);
		};
	}
	private ContextConsumer<AssertableReactiveWebApplicationContext> validateStrategy(
			Class<? extends ConfigureReactiveRedisAction> expectedConfigureReactiveRedisActionType,
			Map.Entry<?, ?>... expectedConfig) {
		return (context) -> {
			assertThat(context).hasSingleBean(ConfigureReactiveRedisAction.class);
			assertThat(context).hasSingleBean(RedisConnectionFactory.class);
			assertThat(context.getBean(ConfigureReactiveRedisAction.class))
				.isInstanceOf(expectedConfigureReactiveRedisActionType);
			ReactiveRedisConnection connection = context.getBean(ReactiveRedisConnectionFactory.class)
				.getReactiveConnection();
			if (expectedConfig.length > 0) {
				assertThat(connection.serverCommands().getConfig('*').block(Duration.ofSeconds(30)))
					.contains(expectedConfig);
			}
		};
	}
	static class MaxEntriesReactiveRedisAction implements ConfigureReactiveRedisAction {
		@Override
		public Mono<Void> configure(ReactiveRedisConnection connection) {
			return Mono.when(connection.serverCommands().setConfig('set-max-intset-entries', '1024'));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@Testcontainers(disabledWithoutDocker = true)
class PulsarAutoConfigurationIntegrationTests {
	@Container
	static final PulsarContainer pulsar = TestImage.container(PulsarContainer.class);
	private static final CountDownLatch listenLatch = new CountDownLatch(1);
	private static final String TOPIC = 'pacit-hello-topic';
	@DynamicPropertySource
	static void pulsarProperties(DynamicPropertyRegistry registry) {
		registry.add('spring.pulsar.client.service-url', pulsar::getPulsarBrokerUrl);
		registry.add('spring.pulsar.admin.service-url', pulsar::getHttpServiceUrl);
	}
	@Test
	void appStartsWithAutoConfiguredSpringPulsarComponents(
			@Autowired(required = false) PulsarTemplate<String> pulsarTemplate) {
		assertThat(pulsarTemplate).isNotNull();
	}
	@Test
	void templateCanBeAccessedDuringWebRequest(@Autowired TestRestTemplate restTemplate) throws InterruptedException {
		assertThat(restTemplate.getForObject('/hello', String.class)).startsWith('Hello World -> ');
		assertThat(listenLatch.await(5, TimeUnit.SECONDS)).isTrue();
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ DispatcherServletAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class,
			WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class, JacksonAutoConfiguration.class,
			PulsarAutoConfiguration.class, PulsarReactiveAutoConfiguration.class })
	@Import(TestWebController.class)
	static class TestConfiguration {
		@PulsarListener(subscriptionName = TOPIC + '-sub', topics = TOPIC)
		void listen(String ignored) {
			listenLatch.countDown();
		}
	}
	@RestController
	static class TestWebController {
		private final PulsarTemplate<String> pulsarTemplate;
		TestWebController(PulsarTemplate<String> pulsarTemplate) {
			this.pulsarTemplate = pulsarTemplate;
		}
		@GetMapping('/hello')
		String sayHello() {
			return 'Hello World -> ' + this.pulsarTemplate.send(TOPIC, 'hello');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
@Testcontainers(disabledWithoutDocker = true)
class CassandraDataAutoConfigurationIntegrationTests {
	@Container
	static final CassandraContainer cassandra = TestImage.container(CassandraContainer.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(CassandraAutoConfiguration.class, CassandraDataAutoConfiguration.class))
		.withPropertyValues(
				'spring.cassandra.contact-points:' + cassandra.getHost() + ':' + cassandra.getFirstMappedPort(),
				'spring.cassandra.local-datacenter=datacenter1', 'spring.cassandra.connection.connect-timeout=60s',
				'spring.cassandra.connection.init-query-timeout=60s', 'spring.cassandra.request.timeout=60s')
		.withInitializer((context) -> AutoConfigurationPackages.register((BeanDefinitionRegistry) context,
				City.class.getPackage().getName()));
	@Test
	void hasDefaultSchemaActionSet() {
		this.contextRunner.run((context) -> assertThat(context.getBean(SessionFactoryFactoryBean.class))
			.hasFieldOrPropertyWithValue('schemaAction', SchemaAction.NONE));
	}
	@Test
	void hasRecreateSchemaActionSet() {
		this.contextRunner.withUserConfiguration(KeyspaceTestConfiguration.class)
			.withPropertyValues('spring.cassandra.schemaAction=recreate_drop_unused')
			.run((context) -> assertThat(context.getBean(SessionFactoryFactoryBean.class))
				.hasFieldOrPropertyWithValue('schemaAction', SchemaAction.RECREATE_DROP_UNUSED));
	}
	@Configuration(proxyBeanMethods = false)
	static class KeyspaceTestConfiguration {
		@Bean
		CqlSession cqlSession(CqlSessionBuilder cqlSessionBuilder) {
			try (CqlSession session = cqlSessionBuilder.build()) {
				session.execute('CREATE KEYSPACE IF NOT EXISTS boot_test'
						+ ' WITH REPLICATION = { "class" : "SimpleStrategy", "replication_factor" : 1 };');
			}
			return cqlSessionBuilder.withKeyspace('boot_test').build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
@SpringBootTest
@Testcontainers(disabledWithoutDocker = true)
class Neo4jRepositoriesAutoConfigurationIntegrationTests {
	@Container
	static final Neo4jContainer<?> neo4j = TestImage.container(Neo4jContainer.class);
	@DynamicPropertySource
	static void neo4jProperties(DynamicPropertyRegistry registry) {
		registry.add('spring.neo4j.uri', neo4j::getBoltUrl);
		registry.add('spring.neo4j.authentication.username', () -> 'neo4j');
		registry.add('spring.neo4j.authentication.password', neo4j::getAdminPassword);
	}
	@Autowired
	private CountryRepository countryRepository;
	@Test
	void ensureRepositoryIsReady() {
		assertThat(this.countryRepository.count()).isZero();
	}
	@Configuration
	@EnableNeo4jRepositories(basePackageClasses = CountryRepository.class)
	@ImportAutoConfiguration({ Neo4jAutoConfiguration.class, Neo4jDataAutoConfiguration.class,
			Neo4jRepositoriesAutoConfiguration.class })
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
@Testcontainers(disabledWithoutDocker = true)
class ElasticsearchRepositoriesAutoConfigurationTests {
	@Container
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticsearchRestClientAutoConfiguration.class,
				ElasticsearchClientAutoConfiguration.class, ElasticsearchRepositoriesAutoConfiguration.class,
				ElasticsearchDataAutoConfiguration.class))
		.withPropertyValues('spring.elasticsearch.uris=' + elasticsearch.getHttpHostAddress());
	@Test
	void testDefaultRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CityRepository.class)
				.hasSingleBean(ElasticsearchTemplate.class));
	}
	@Test
	void testNoRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ElasticsearchTemplate.class));
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.contextRunner.withUserConfiguration(CustomizedConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CityElasticsearchDbRepository.class));
	}
	@Test
	void testAuditingConfiguration() {
		this.contextRunner.withUserConfiguration(AuditingConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ElasticsearchTemplate.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(ElasticsearchRepositoriesAutoConfigurationTests.class)
	@EnableElasticsearchRepositories(basePackageClasses = CityElasticsearchDbRepository.class)
	static class CustomizedConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(ElasticsearchRepositoriesAutoConfigurationTests.class)
	@EnableElasticsearchRepositories
	@EnableElasticsearchAuditing
	static class AuditingConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
@Testcontainers(disabledWithoutDocker = true)
class ReactiveElasticsearchRepositoriesAutoConfigurationTests {
	@Container
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticsearchClientAutoConfiguration.class,
				ElasticsearchRestClientAutoConfiguration.class,
				ReactiveElasticsearchRepositoriesAutoConfiguration.class, ElasticsearchDataAutoConfiguration.class,
				ReactiveElasticsearchClientAutoConfiguration.class))
		.withPropertyValues(
				'spring.elasticsearch.uris=' + elasticsearch.getHost() + ':' + elasticsearch.getFirstMappedPort(),
				'spring.elasticsearch.socket-timeout=30s');
	@Test
	void backsOffWithoutReactor() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withClassLoader(new FilteredClassLoader(Mono.class))
			.run((context) -> assertThat(context)
				.doesNotHaveBean(ReactiveElasticsearchRepositoriesAutoConfiguration.class));
	}
	@Test
	void testDefaultRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveCityRepository.class)
				.hasSingleBean(ReactiveElasticsearchTemplate.class));
	}
	@Test
	void testNoRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveElasticsearchTemplate.class));
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.contextRunner.withUserConfiguration(CustomizedConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CityReactiveElasticsearchDbRepository.class));
	}
	@Test
	void testAuditingConfiguration() {
		this.contextRunner.withUserConfiguration(AuditingConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveElasticsearchTemplate.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(ReactiveElasticsearchRepositoriesAutoConfigurationTests.class)
	@EnableReactiveElasticsearchRepositories(basePackageClasses = CityReactiveElasticsearchDbRepository.class)
	static class CustomizedConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(ElasticsearchRepositoriesAutoConfigurationTests.class)
	@EnableReactiveElasticsearchRepositories
	@EnableElasticsearchAuditing
	static class AuditingConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@Testcontainers(disabledWithoutDocker = true)
class RedisRepositoriesAutoConfigurationTests {
	@Container
	public static RedisContainer redis = TestImage.container(RedisContainer.class);
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@BeforeEach
	void setUp() {
		TestPropertyValues
			.of('spring.data.redis.host=' + redis.getHost(), 'spring.data.redis.port=' + redis.getFirstMappedPort())
			.applyTo(this.context.getEnvironment());
	}
	@AfterEach
	void close() {
		this.context.close();
	}
	@Test
	void testDefaultRepositoryConfiguration() {
		this.context.register(TestConfiguration.class, RedisAutoConfiguration.class,
				RedisRepositoriesAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Test
	void testNoRepositoryConfiguration() {
		this.context.register(EmptyConfiguration.class, RedisAutoConfiguration.class,
				RedisRepositoriesAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean('redisTemplate')).isNotNull();
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.context.register(CustomizedConfiguration.class, RedisAutoConfiguration.class,
				RedisRepositoriesAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CityRedisRepository.class)).isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(RedisRepositoriesAutoConfigurationTests.class)
	@EnableRedisRepositories(basePackageClasses = CityRedisRepository.class)
	static class CustomizedConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
@Testcontainers(disabledWithoutDocker = true)
class Neo4jAutoConfigurationIntegrationTests {
	@Container
	private static final Neo4jContainer<?> neo4j = TestImage.container(Neo4jContainer.class);
	@SpringBootTest
	@Nested
	class DriverWithDefaultAuthToken {
		@DynamicPropertySource
		static void neo4jProperties(DynamicPropertyRegistry registry) {
			registry.add('spring.neo4j.uri', neo4j::getBoltUrl);
			registry.add('spring.neo4j.authentication.username', () -> 'neo4j');
			registry.add('spring.neo4j.authentication.password', neo4j::getAdminPassword);
		}
		@Autowired
		private Driver driver;
		@Test
		void driverCanHandleRequest() {
			try (Session session = this.driver.session(); Transaction tx = session.beginTransaction()) {
				Result statementResult = tx.run('MATCH (n:Thing) RETURN n LIMIT 1');
				assertThat(statementResult.hasNext()).isFalse();
				tx.commit();
			}
		}
		@Configuration(proxyBeanMethods = false)
		@ImportAutoConfiguration(Neo4jAutoConfiguration.class)
		static class TestConfiguration {
		}
	}
	@SpringBootTest
	@Nested
	class DriverWithDynamicAuthToken {
		@DynamicPropertySource
		static void neo4jProperties(DynamicPropertyRegistry registry) {
			registry.add('spring.neo4j.uri', neo4j::getBoltUrl);
			registry.add('spring.neo4j.authentication.username', () -> 'wrong');
			registry.add('spring.neo4j.authentication.password', () -> 'alsowrong');
		}
		@Autowired
		private Driver driver;
		@Test
		void driverCanHandleRequest() {
			try (Session session = this.driver.session(); Transaction tx = session.beginTransaction()) {
				Result statementResult = tx.run('MATCH (n:Thing) RETURN n LIMIT 1');
				assertThat(statementResult.hasNext()).isFalse();
				tx.commit();
			}
		}
		@Configuration(proxyBeanMethods = false)
		@ImportAutoConfiguration(Neo4jAutoConfiguration.class)
		static class TestConfiguration {
			@Bean
			AuthTokenManager authTokenManager() {
				return AuthTokenManagers.bearer(() -> AuthTokens.basic('neo4j', neo4j.getAdminPassword())
					.expiringAt(System.currentTimeMillis() + 5_000));
			}
		}
	}
	@SpringBootTest
	@Nested
	class DriverWithCustomConnectionDetailsIgnoresAuthTokenManager {
		@DynamicPropertySource
		static void neo4jProperties(DynamicPropertyRegistry registry) {
			registry.add('spring.neo4j.uri', neo4j::getBoltUrl);
			registry.add('spring.neo4j.authentication.username', () -> 'wrong');
			registry.add('spring.neo4j.authentication.password', () -> 'alsowrong');
		}
		@Autowired
		private Driver driver;
		@Test
		void driverCanHandleRequest() {
			try (Session session = this.driver.session(); Transaction tx = session.beginTransaction()) {
				Result statementResult = tx.run('MATCH (n:Thing) RETURN n LIMIT 1');
				assertThat(statementResult.hasNext()).isFalse();
				tx.commit();
			}
		}
		@Configuration(proxyBeanMethods = false)
		@ImportAutoConfiguration(Neo4jAutoConfiguration.class)
		static class TestConfiguration {
			@Bean
			AuthTokenManager authTokenManager() {
				return AuthTokenManagers.bearer(() -> AuthTokens.basic('wrongagain', 'stillwrong')
					.expiringAt(System.currentTimeMillis() + 5_000));
			}
			@Bean
			Neo4jConnectionDetails connectionDetails() {
				return new Neo4jConnectionDetails() {
					@Override
					public URI getUri() {
						return URI.create(neo4j.getBoltUrl());
					}
					@Override
					public AuthToken getAuthToken() {
						return AuthTokens.basic('neo4j', neo4j.getAdminPassword());
					}
				};
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@Testcontainers(disabledWithoutDocker = true)
class ElasticsearchClientAutoConfigurationIntegrationTests {
	@Container
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class,
				ElasticsearchRestClientAutoConfiguration.class, ElasticsearchClientAutoConfiguration.class));
	@Test
	void reactiveClientCanQueryElasticsearchNode() {
		this.contextRunner
			.withPropertyValues('spring.elasticsearch.uris=' + elasticsearch.getHttpHostAddress(),
					'spring.elasticsearch.connection-timeout=120s', 'spring.elasticsearch.socket-timeout=120s')
			.run((context) -> {
				ElasticsearchClient client = context.getBean(ElasticsearchClient.class);
				client.index((b) -> b.index('foo').id('1').document(Map.of('a', 'alpha', 'b', 'bravo')));
				GetResponse<Object> response = client.get((b) -> b.index('foo').id('1'), Object.class);
				assertThat(response).isNotNull();
				assertThat(response.found()).isTrue();
			});
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@Testcontainers(disabledWithoutDocker = true)
class ElasticsearchRestClientAutoConfigurationIntegrationTests {
	@Container
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticsearchRestClientAutoConfiguration.class));
	@Test
	void restClientCanQueryElasticsearchNode() {
		this.contextRunner
			.withPropertyValues('spring.elasticsearch.uris=' + elasticsearch.getHttpHostAddress(),
					'spring.elasticsearch.connection-timeout=120s', 'spring.elasticsearch.socket-timeout=120s')
			.run((context) -> {
				RestClient client = context.getBean(RestClient.class);
				Request index = new Request('PUT', '/test/_doc/2');
				index.setJsonEntity('{' + '  \'a\': \'alpha\',' + '  \'b\': \'bravo\'' + '}');
				client.performRequest(index);
				Request getRequest = new Request('GET', '/test/_doc/2');
				Response response = client.performRequest(getRequest);
				try (InputStream input = response.getEntity().getContent()) {
					JsonNode result = new ObjectMapper().readTree(input);
					assertThat(result.path('found').asBoolean()).isTrue();
				}
			});
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
@Testcontainers(disabledWithoutDocker = true)
class ReactiveElasticsearchClientAutoConfigurationIntegrationTests {
	@Container
	static final ElasticsearchContainer elasticsearch = TestImage.container(ElasticsearchContainer.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class,
				ElasticsearchRestClientAutoConfiguration.class, ReactiveElasticsearchClientAutoConfiguration.class));
	@Test
	void reactiveClientCanQueryElasticsearchNode() {
		this.contextRunner
			.withPropertyValues('spring.elasticsearch.uris=' + elasticsearch.getHttpHostAddress(),
					'spring.elasticsearch.connection-timeout=120s', 'spring.elasticsearch.socket-timeout=120s')
			.run((context) -> {
				ReactiveElasticsearchClient client = context.getBean(ReactiveElasticsearchClient.class);
				Mono<IndexResponse> index = client
					.index((b) -> b.index('foo').id('1').document(Map.of('a', 'alpha', 'b', 'bravo')));
				index.block();
				Mono<GetResponse<Object>> get = client.get((b) -> b.index('foo').id('1'), Object.class);
				GetResponse<Object> response = get.block();
				assertThat(response).isNotNull();
				assertThat(response.found()).isTrue();
			});
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class PropertiesSslBundleTests {
	private static final char[] EMPTY_KEY_PASSWORD = new char[] {};
	@Test
	void pemPropertiesAreMappedToSslBundle() throws Exception {
		PemSslBundleProperties properties = new PemSslBundleProperties();
		properties.getKey().setAlias('alias');
		properties.getKey().setPassword('secret');
		properties.getOptions().setCiphers(Set.of('cipher1', 'cipher2', 'cipher3'));
		properties.getOptions().setEnabledProtocols(Set.of('protocol1', 'protocol2'));
		properties.getKeystore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/rsa-cert.pem');
		properties.getKeystore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/rsa-key.pem');
		properties.getKeystore().setPrivateKeyPassword(null);
		properties.getKeystore().setType('PKCS12');
		properties.getTruststore()
			.setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-cert.pem');
		properties.getTruststore()
			.setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-key.pem');
		properties.getTruststore().setPrivateKeyPassword('secret');
		properties.getTruststore().setType('PKCS12');
		SslBundle sslBundle = PropertiesSslBundle.get(properties);
		assertThat(sslBundle.getKey().getAlias()).isEqualTo('alias');
		assertThat(sslBundle.getKey().getPassword()).isEqualTo('secret');
		assertThat(sslBundle.getOptions().getCiphers()).containsExactlyInAnyOrder('cipher1', 'cipher2', 'cipher3');
		assertThat(sslBundle.getOptions().getEnabledProtocols()).containsExactlyInAnyOrder('protocol1', 'protocol2');
		assertThat(sslBundle.getStores()).isNotNull();
		Certificate certificate = sslBundle.getStores().getKeyStore().getCertificate('alias');
		assertThat(certificate).isNotNull();
		assertThat(certificate.getType()).isEqualTo('X.509');
		Key key = sslBundle.getStores().getKeyStore().getKey('alias', 'secret'.toCharArray());
		assertThat(key).isNotNull();
		assertThat(key.getAlgorithm()).isEqualTo('RSA');
		certificate = sslBundle.getStores().getTrustStore().getCertificate('ssl');
		assertThat(certificate).isNotNull();
		assertThat(certificate.getType()).isEqualTo('X.509');
	}
	@Test
	void jksPropertiesAreMappedToSslBundle() {
		JksSslBundleProperties properties = new JksSslBundleProperties();
		properties.getKey().setAlias('alias');
		properties.getKey().setPassword('secret');
		properties.getOptions().setCiphers(Set.of('cipher1', 'cipher2', 'cipher3'));
		properties.getOptions().setEnabledProtocols(Set.of('protocol1', 'protocol2'));
		properties.getKeystore().setPassword('secret');
		properties.getKeystore().setProvider('SUN');
		properties.getKeystore().setType('JKS');
		properties.getKeystore().setLocation('classpath:org/springframework/boot/autoconfigure/ssl/keystore.jks');
		properties.getTruststore().setPassword('secret');
		properties.getTruststore().setProvider('SUN');
		properties.getTruststore().setType('PKCS12');
		properties.getTruststore().setLocation('classpath:org/springframework/boot/autoconfigure/ssl/keystore.pkcs12');
		SslBundle sslBundle = PropertiesSslBundle.get(properties);
		assertThat(sslBundle.getKey().getAlias()).isEqualTo('alias');
		assertThat(sslBundle.getKey().getPassword()).isEqualTo('secret');
		assertThat(sslBundle.getOptions().getCiphers()).containsExactlyInAnyOrder('cipher1', 'cipher2', 'cipher3');
		assertThat(sslBundle.getOptions().getEnabledProtocols()).containsExactlyInAnyOrder('protocol1', 'protocol2');
		assertThat(sslBundle.getStores()).isNotNull();
		assertThat(sslBundle.getStores()).extracting('keyStoreDetails')
			.extracting('location', 'password', 'provider', 'type')
			.containsExactly('classpath:org/springframework/boot/autoconfigure/ssl/keystore.jks', 'secret', 'SUN',
					'JKS');
		KeyStore trustStore = sslBundle.getStores().getTrustStore();
		assertThat(trustStore.getType()).isEqualTo('PKCS12');
		assertThat(trustStore.getProvider().getName()).isEqualTo('SUN');
	}
	@Test
	void getWithPemSslBundlePropertiesWhenVerifyKeyStoreAgainstSingleCertificateWithMatchCreatesBundle() {
		PemSslBundleProperties properties = new PemSslBundleProperties();
		properties.getKeystore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/key1.crt');
		properties.getKeystore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/key1.pem');
		properties.getKeystore().setVerifyKeys(true);
		properties.getKey().setAlias('test-alias');
		SslBundle bundle = PropertiesSslBundle.get(properties);
		assertThat(bundle.getStores().getKeyStore()).satisfies(storeContainingCertAndKey('test-alias'));
	}
	@Test
	void getWithPemSslBundlePropertiesWhenVerifyKeyStoreAgainstCertificateChainWithMatchCreatesBundle() {
		PemSslBundleProperties properties = new PemSslBundleProperties();
		properties.getKeystore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/key2-chain.crt');
		properties.getKeystore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/key2.pem');
		properties.getKeystore().setVerifyKeys(true);
		properties.getKey().setAlias('test-alias');
		SslBundle bundle = PropertiesSslBundle.get(properties);
		assertThat(bundle.getStores().getKeyStore()).satisfies(storeContainingCertAndKey('test-alias'));
	}
	@Test
	void getWithPemSslBundlePropertiesWhenVerifyKeyStoreWithNoMatchThrowsException() {
		PemSslBundleProperties properties = new PemSslBundleProperties();
		properties.getKeystore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/key2.crt');
		properties.getKeystore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/key1.pem');
		properties.getKeystore().setVerifyKeys(true);
		properties.getKey().setAlias('test-alias');
		assertThatIllegalStateException().isThrownBy(() -> PropertiesSslBundle.get(properties))
			.withMessageContaining('Private key in keystore matches none of the certificates');
	}
	@Test
	void getWithResourceLoader() {
		PemSslBundleProperties properties = new PemSslBundleProperties();
		properties.getKeystore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/key2-chain.crt');
		properties.getKeystore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/key2.pem');
		properties.getKeystore().setVerifyKeys(true);
		properties.getKey().setAlias('test-alias');
		ResourceLoader resourceLoader = spy(new DefaultResourceLoader());
		SslBundle bundle = PropertiesSslBundle.get(properties, resourceLoader);
		assertThat(bundle.getStores().getKeyStore()).satisfies(storeContainingCertAndKey('test-alias'));
		then(resourceLoader).should(atLeastOnce())
			.getResource('classpath:org/springframework/boot/autoconfigure/ssl/key2-chain.crt');
		then(resourceLoader).should(atLeastOnce())
			.getResource('classpath:org/springframework/boot/autoconfigure/ssl/key2.pem');
	}
	private Consumer<KeyStore> storeContainingCertAndKey(String keyAlias) {
		return ThrowingConsumer.of((keyStore) -> {
			assertThat(keyStore).isNotNull();
			assertThat(keyStore.getType()).isEqualTo(KeyStore.getDefaultType());
			assertThat(keyStore.containsAlias(keyAlias)).isTrue();
			assertThat(keyStore.getCertificate(keyAlias)).isNotNull();
			assertThat(keyStore.getKey(keyAlias, EMPTY_KEY_PASSWORD)).isNotNull();
		});
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class SslPropertiesBundleRegistrarTests {
	private SslPropertiesBundleRegistrar registrar;
	private FileWatcher fileWatcher;
	private DefaultResourceLoader resourceLoader;
	private SslProperties properties;
	private SslBundleRegistry registry;
	@BeforeEach
	void setUp() {
		this.properties = new SslProperties();
		this.fileWatcher = Mockito.mock(FileWatcher.class);
		this.resourceLoader = spy(new DefaultResourceLoader());
		this.registrar = new SslPropertiesBundleRegistrar(this.properties, this.fileWatcher, this.resourceLoader);
		this.registry = Mockito.mock(SslBundleRegistry.class);
	}
	@Test
	void shouldWatchJksBundles() {
		JksSslBundleProperties jks = new JksSslBundleProperties();
		jks.setReloadOnUpdate(true);
		jks.getKeystore().setLocation('classpath:test.jks');
		jks.getKeystore().setPassword('secret');
		jks.getTruststore().setLocation('classpath:test.jks');
		jks.getTruststore().setPassword('secret');
		this.properties.getBundle().getJks().put('bundle1', jks);
		this.registrar.registerBundles(this.registry);
		then(this.registry).should(times(1)).registerBundle(eq('bundle1'), any());
		then(this.fileWatcher).should().watch(assertArg((set) -> pathEndingWith(set, 'test.jks')), any());
	}
	@Test
	void shouldWatchPemBundles() {
		PemSslBundleProperties pem = new PemSslBundleProperties();
		pem.setReloadOnUpdate(true);
		pem.getKeystore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/rsa-cert.pem');
		pem.getKeystore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/rsa-key.pem');
		pem.getTruststore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-cert.pem');
		pem.getTruststore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-key.pem');
		this.properties.getBundle().getPem().put('bundle1', pem);
		this.registrar.registerBundles(this.registry);
		then(this.registry).should(times(1)).registerBundle(eq('bundle1'), any());
		then(this.fileWatcher).should()
			.watch(assertArg((set) -> pathEndingWith(set, 'rsa-cert.pem', 'rsa-key.pem')), any());
	}
	@Test
	void shouldUseResourceLoader() {
		PemSslBundleProperties pem = new PemSslBundleProperties();
		pem.getTruststore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-cert.pem');
		pem.getTruststore().setPrivateKey('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-key.pem');
		this.properties.getBundle().getPem().put('bundle1', pem);
		DefaultSslBundleRegistry registry = new DefaultSslBundleRegistry();
		this.registrar.registerBundles(registry);
		registry.getBundle('bundle1').createSslContext();
		then(this.resourceLoader).should(atLeastOnce())
			.getResource('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-cert.pem');
		then(this.resourceLoader).should(atLeastOnce())
			.getResource('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-key.pem');
	}
	@Test
	void shouldFailIfPemKeystoreCertificateIsEmbedded() {
		PemSslBundleProperties pem = new PemSslBundleProperties();
		pem.setReloadOnUpdate(true);
		pem.getKeystore().setCertificate('''
				-----BEGIN CERTIFICATE-----
				MIICCzCCAb2gAwIBAgIUZbDi7G5czH+Yi0k2EMWxdf00XagwBQYDK2VwMHsxCzAJ
				BgNVBAYTAlhYMRIwEAYDVQQIDAlTdGF0ZU5hbWUxETAPBgNVBAcMCENpdHlOYW1l
				MRQwEgYDVQQKDAtDb21wYW55TmFtZTEbMBkGA1UECwwSQ29tcGFueVNlY3Rpb25O
				YW1lMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjMwOTExMTIxNDMwWhcNMzMwOTA4
				MTIxNDMwWjB7MQswCQYDVQQGEwJYWDESMBAGA1UECAwJU3RhdGVOYW1lMREwDwYD
				VQQHDAhDaXR5TmFtZTEUMBIGA1UECgwLQ29tcGFueU5hbWUxGzAZBgNVBAsMEkNv
				bXBhbnlTZWN0aW9uTmFtZTESMBAGA1UEAwwJbG9jYWxob3N0MCowBQYDK2VwAyEA
				Q/DDA4BSgZ+Hx0DUxtIRjVjN+OcxXVURwAWc3Gt9GUyjUzBRMB0GA1UdDgQWBBSv
				EdpoaBMBoxgO96GFbf03k07DSTAfBgNVHSMEGDAWgBSvEdpoaBMBoxgO96GFbf03
				k07DSTAPBgNVHRMBAf8EBTADAQH/MAUGAytlcANBAHMXDkGd57d4F4cRk/8UjhxD
				7OtRBZfdfznSvlhJIMNfH5q0zbC2eO3hWCB3Hrn/vIeswGP8Ov4AJ6eXeX44BQM=
				-----END CERTIFICATE-----
				'''.strip());
		this.properties.getBundle().getPem().put('bundle1', pem);
		assertThatIllegalStateException().isThrownBy(() -> this.registrar.registerBundles(this.registry))
			.withMessageContaining('Unable to register SSL bundle "bundle1"')
			.havingCause()
			.withMessage('Unable to watch for reload on update');
	}
	@Test
	void shouldFailIfPemKeystorePrivateKeyIsEmbedded() {
		PemSslBundleProperties pem = new PemSslBundleProperties();
		pem.setReloadOnUpdate(true);
		pem.getKeystore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-cert.pem');
		pem.getKeystore().setPrivateKey('''
				-----BEGIN PRIVATE KEY-----
				MC4CAQAwBQYDK2VwBCIEIC29RnMVTcyqXEAIO1b/6p7RdbM6TiqvnztVQ4IxYxUh
				-----END PRIVATE KEY-----
				'''.strip());
		this.properties.getBundle().getPem().put('bundle1', pem);
		assertThatIllegalStateException().isThrownBy(() -> this.registrar.registerBundles(this.registry))
			.withMessageContaining('Unable to register SSL bundle "bundle1"')
			.havingCause()
			.withMessage('Unable to watch for reload on update');
	}
	@Test
	void shouldFailIfPemTruststoreCertificateIsEmbedded() {
		PemSslBundleProperties pem = new PemSslBundleProperties();
		pem.setReloadOnUpdate(true);
		pem.getTruststore().setCertificate('''
				-----BEGIN CERTIFICATE-----
				MIICCzCCAb2gAwIBAgIUZbDi7G5czH+Yi0k2EMWxdf00XagwBQYDK2VwMHsxCzAJ
				BgNVBAYTAlhYMRIwEAYDVQQIDAlTdGF0ZU5hbWUxETAPBgNVBAcMCENpdHlOYW1l
				MRQwEgYDVQQKDAtDb21wYW55TmFtZTEbMBkGA1UECwwSQ29tcGFueVNlY3Rpb25O
				YW1lMRIwEAYDVQQDDAlsb2NhbGhvc3QwHhcNMjMwOTExMTIxNDMwWhcNMzMwOTA4
				MTIxNDMwWjB7MQswCQYDVQQGEwJYWDESMBAGA1UECAwJU3RhdGVOYW1lMREwDwYD
				VQQHDAhDaXR5TmFtZTEUMBIGA1UECgwLQ29tcGFueU5hbWUxGzAZBgNVBAsMEkNv
				bXBhbnlTZWN0aW9uTmFtZTESMBAGA1UEAwwJbG9jYWxob3N0MCowBQYDK2VwAyEA
				Q/DDA4BSgZ+Hx0DUxtIRjVjN+OcxXVURwAWc3Gt9GUyjUzBRMB0GA1UdDgQWBBSv
				EdpoaBMBoxgO96GFbf03k07DSTAfBgNVHSMEGDAWgBSvEdpoaBMBoxgO96GFbf03
				k07DSTAPBgNVHRMBAf8EBTADAQH/MAUGAytlcANBAHMXDkGd57d4F4cRk/8UjhxD
				7OtRBZfdfznSvlhJIMNfH5q0zbC2eO3hWCB3Hrn/vIeswGP8Ov4AJ6eXeX44BQM=
				-----END CERTIFICATE-----
				'''.strip());
		this.properties.getBundle().getPem().put('bundle1', pem);
		assertThatIllegalStateException().isThrownBy(() -> this.registrar.registerBundles(this.registry))
			.withMessageContaining('Unable to register SSL bundle "bundle1"')
			.havingCause()
			.withMessage('Unable to watch for reload on update');
	}
	@Test
	void shouldFailIfPemTruststorePrivateKeyIsEmbedded() {
		PemSslBundleProperties pem = new PemSslBundleProperties();
		pem.setReloadOnUpdate(true);
		pem.getTruststore().setCertificate('classpath:org/springframework/boot/autoconfigure/ssl/ed25519-cert.pem');
		pem.getTruststore().setPrivateKey('''
				-----BEGIN PRIVATE KEY-----
				MC4CAQAwBQYDK2VwBCIEIC29RnMVTcyqXEAIO1b/6p7RdbM6TiqvnztVQ4IxYxUh
				-----END PRIVATE KEY-----
				'''.strip());
		this.properties.getBundle().getPem().put('bundle1', pem);
		assertThatIllegalStateException().isThrownBy(() -> this.registrar.registerBundles(this.registry))
			.withMessageContaining('Unable to register SSL bundle "bundle1"')
			.havingCause()
			.withMessage('Unable to watch for reload on update');
	}
	private void pathEndingWith(Set<Path> paths, String... suffixes) {
		for (String suffix : suffixes) {
			assertThat(paths).anyMatch((path) -> path.getFileName().toString().endsWith(suffix));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class BundleContentPropertyTests {
	private static final String PEM_TEXT = '''
			-----BEGIN CERTIFICATE-----
			-----END CERTIFICATE-----
			''';
	@Test
	void isPemContentWhenValueIsPemTextReturnsTrue() {
		BundleContentProperty property = new BundleContentProperty('name', PEM_TEXT);
		assertThat(property.isPemContent()).isTrue();
	}
	@Test
	void isPemContentWhenValueIsNotPemTextReturnsFalse() {
		BundleContentProperty property = new BundleContentProperty('name', 'file.pem');
		assertThat(property.isPemContent()).isFalse();
	}
	@Test
	void hasValueWhenHasValueReturnsTrue() {
		BundleContentProperty property = new BundleContentProperty('name', 'file.pem');
		assertThat(property.hasValue()).isTrue();
	}
	@Test
	void hasValueWhenHasNullValueReturnsFalse() {
		BundleContentProperty property = new BundleContentProperty('name', null);
		assertThat(property.hasValue()).isFalse();
	}
	@Test
	void hasValueWhenHasEmptyValueReturnsFalse() {
		BundleContentProperty property = new BundleContentProperty('name', '');
		assertThat(property.hasValue()).isFalse();
	}
	@Test
	void toWatchPathWhenNotPathThrowsException() {
		BundleContentProperty property = new BundleContentProperty('name', PEM_TEXT);
		assertThatIllegalStateException().isThrownBy(() -> property.toWatchPath(ApplicationResourceLoader.get()))
			.withMessage('Unable to convert value of property "name" to a path');
	}
	@Test
	void toWatchPathWhenPathReturnsPath() throws URISyntaxException {
		URL resource = getClass().getResource('keystore.jks');
		Path file = Path.of(resource.toURI()).toAbsolutePath();
		BundleContentProperty property = new BundleContentProperty('name', file.toString());
		assertThat(property.toWatchPath(ApplicationResourceLoader.get())).isEqualTo(file);
	}
	@Test
	void toWatchPathUsesResourceLoader() throws URISyntaxException {
		URL resource = getClass().getResource('keystore.jks');
		Path file = Path.of(resource.toURI()).toAbsolutePath();
		BundleContentProperty property = new BundleContentProperty('name', file.toString());
		ResourceLoader resourceLoader = spy(ApplicationResourceLoader.get());
		assertThat(property.toWatchPath(resourceLoader)).isEqualTo(file);
		then(resourceLoader).should(atLeastOnce()).getResource(file.toString());
	}
	@Test
	void shouldThrowBundleContentNotWatchableExceptionIfContentIsNotWatchable() {
		BundleContentProperty property = new BundleContentProperty('name', 'https://example.com/');
		assertThatExceptionOfType(BundleContentNotWatchableException.class)
			.isThrownBy(() -> property.toWatchPath(ApplicationResourceLoader.get()))
			.withMessageContaining('Only "file:" resources are watchable');
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class SslAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SslAutoConfiguration.class));
	@Test
	void sslBundlesCreatedWithNoConfiguration() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(SslBundleRegistry.class));
	}
	@Test
	void sslBundlesCreatedWithCertificates() {
		List<String> propertyValues = new ArrayList<>();
		String location = 'classpath:org/springframework/boot/autoconfigure/ssl/';
		propertyValues.add('spring.ssl.bundle.pem.first.key.alias=alias1');
		propertyValues.add('spring.ssl.bundle.pem.first.key.password=secret1');
		propertyValues.add('spring.ssl.bundle.pem.first.keystore.certificate=' + location + 'rsa-cert.pem');
		propertyValues.add('spring.ssl.bundle.pem.first.keystore.private-key=' + location + 'rsa-key.pem');
		propertyValues.add('spring.ssl.bundle.pem.first.keystore.type=PKCS12');
		propertyValues.add('spring.ssl.bundle.pem.first.truststore.type=PKCS12');
		propertyValues.add('spring.ssl.bundle.pem.first.truststore.certificate=' + location + 'rsa-cert.pem');
		propertyValues.add('spring.ssl.bundle.pem.first.truststore.private-key=' + location + 'rsa-key.pem');
		propertyValues.add('spring.ssl.bundle.pem.second.key.alias=alias2');
		propertyValues.add('spring.ssl.bundle.pem.second.key.password=secret2');
		propertyValues.add('spring.ssl.bundle.pem.second.keystore.certificate=' + location + 'ed25519-cert.pem');
		propertyValues.add('spring.ssl.bundle.pem.second.keystore.private-key=' + location + 'ed25519-key.pem');
		propertyValues.add('spring.ssl.bundle.pem.second.keystore.type=PKCS12');
		propertyValues.add('spring.ssl.bundle.pem.second.truststore.certificate=' + location + 'ed25519-cert.pem');
		propertyValues.add('spring.ssl.bundle.pem.second.truststore.private-key=' + location + 'ed25519-key.pem');
		propertyValues.add('spring.ssl.bundle.pem.second.truststore.type=PKCS12');
		this.contextRunner.withPropertyValues(propertyValues.toArray(String[]::new)).run((context) -> {
			assertThat(context).hasSingleBean(SslBundles.class);
			SslBundles bundles = context.getBean(SslBundles.class);
			SslBundle first = bundles.getBundle('first');
			assertThat(first).isNotNull();
			assertThat(first.getStores()).isNotNull();
			assertThat(first.getManagers()).isNotNull();
			assertThat(first.getKey().getAlias()).isEqualTo('alias1');
			assertThat(first.getKey().getPassword()).isEqualTo('secret1');
			assertThat(first.getStores().getKeyStore().getType()).isEqualTo('PKCS12');
			assertThat(first.getStores().getTrustStore().getType()).isEqualTo('PKCS12');
			SslBundle second = bundles.getBundle('second');
			assertThat(second).isNotNull();
			assertThat(second.getStores()).isNotNull();
			assertThat(second.getManagers()).isNotNull();
			assertThat(second.getKey().getAlias()).isEqualTo('alias2');
			assertThat(second.getKey().getPassword()).isEqualTo('secret2');
			assertThat(second.getStores().getKeyStore().getType()).isEqualTo('PKCS12');
			assertThat(second.getStores().getTrustStore().getType()).isEqualTo('PKCS12');
		});
	}
	@Test
	void sslBundlesCreatedWithCustomSslBundle() {
		List<String> propertyValues = new ArrayList<>();
		String location = 'classpath:org/springframework/boot/autoconfigure/ssl/';
		propertyValues.add('custom.ssl.key.alias=alias1');
		propertyValues.add('custom.ssl.key.password=secret1');
		propertyValues.add('custom.ssl.keystore.certificate=' + location + 'rsa-cert.pem');
		propertyValues.add('custom.ssl.keystore.keystore.private-key=' + location + 'rsa-key.pem');
		propertyValues.add('custom.ssl.truststore.certificate=' + location + 'rsa-cert.pem');
		propertyValues.add('custom.ssl.keystore.type=PKCS12');
		propertyValues.add('custom.ssl.truststore.type=PKCS12');
		this.contextRunner.withUserConfiguration(CustomSslBundleConfiguration.class)
			.withPropertyValues(propertyValues.toArray(String[]::new))
			.run((context) -> {
				assertThat(context).hasSingleBean(SslBundles.class);
				SslBundles bundles = context.getBean(SslBundles.class);
				SslBundle first = bundles.getBundle('custom');
				assertThat(first).isNotNull();
				assertThat(first.getStores()).isNotNull();
				assertThat(first.getManagers()).isNotNull();
				assertThat(first.getKey().getAlias()).isEqualTo('alias1');
				assertThat(first.getKey().getPassword()).isEqualTo('secret1');
				assertThat(first.getStores().getKeyStore().getType()).isEqualTo('PKCS12');
				assertThat(first.getStores().getTrustStore().getType()).isEqualTo('PKCS12');
			});
	}
	@Configuration
	@EnableConfigurationProperties(CustomSslProperties.class)
	public static class CustomSslBundleConfiguration {
		@Bean
		public SslBundleRegistrar customSslBundlesRegistrar(CustomSslProperties properties) {
			return new CustomSslBundlesRegistrar(properties);
		}
	}
	@ConfigurationProperties('custom.ssl')
	static class CustomSslProperties extends PemSslBundleProperties {
	}
	static class CustomSslBundlesRegistrar implements SslBundleRegistrar {
		private final CustomSslProperties properties;
		CustomSslBundlesRegistrar(CustomSslProperties properties) {
			this.properties = properties;
		}
		@Override
		public void registerBundles(SslBundleRegistry registry) {
			registry.registerBundle('custom', PropertiesSslBundle.get(this.properties));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class FileWatcherTests {
	private FileWatcher fileWatcher;
	@BeforeEach
	void setUp() {
		this.fileWatcher = new FileWatcher(Duration.ofMillis(10));
	}
	@AfterEach
	void tearDown() throws IOException {
		this.fileWatcher.close();
	}
	@Test
	void shouldTriggerOnFileCreation(@TempDir Path tempDir) throws Exception {
		Path newFile = tempDir.resolve('new-file.txt');
		WaitingCallback callback = new WaitingCallback();
		this.fileWatcher.watch(Set.of(tempDir), callback);
		Files.createFile(newFile);
		callback.expectChanges();
	}
	@Test
	void shouldTriggerOnFileDeletion(@TempDir Path tempDir) throws Exception {
		Path deletedFile = tempDir.resolve('deleted-file.txt');
		Files.createFile(deletedFile);
		WaitingCallback callback = new WaitingCallback();
		this.fileWatcher.watch(Set.of(tempDir), callback);
		Files.delete(deletedFile);
		callback.expectChanges();
	}
	@Test
	void shouldTriggerOnFileModification(@TempDir Path tempDir) throws Exception {
		Path deletedFile = tempDir.resolve('modified-file.txt');
		Files.createFile(deletedFile);
		WaitingCallback callback = new WaitingCallback();
		this.fileWatcher.watch(Set.of(tempDir), callback);
		Files.writeString(deletedFile, 'Some content');
		callback.expectChanges();
	}
	@Test
	void shouldWatchFile(@TempDir Path tempDir) throws Exception {
		Path watchedFile = tempDir.resolve('watched.txt');
		Files.createFile(watchedFile);
		WaitingCallback callback = new WaitingCallback();
		this.fileWatcher.watch(Set.of(watchedFile), callback);
		Files.writeString(watchedFile, 'Some content');
		callback.expectChanges();
	}
	@Test
	void shouldIgnoreNotWatchedFiles(@TempDir Path tempDir) throws Exception {
		Path watchedFile = tempDir.resolve('watched.txt');
		Path notWatchedFile = tempDir.resolve('not-watched.txt');
		Files.createFile(watchedFile);
		Files.createFile(notWatchedFile);
		WaitingCallback callback = new WaitingCallback();
		this.fileWatcher.watch(Set.of(watchedFile), callback);
		Files.writeString(notWatchedFile, 'Some content');
		callback.expectNoChanges();
	}
	@Test
	void shouldFailIfDirectoryOrFileDoesNotExist(@TempDir Path tempDir) {
		Path directory = tempDir.resolve('dir1');
		assertThatExceptionOfType(UncheckedIOException.class)
			.isThrownBy(() -> this.fileWatcher.watch(Set.of(directory), new WaitingCallback()))
			.withMessage('Failed to register paths for watching: [%s]'.formatted(directory));
	}
	@Test
	void shouldNotFailIfDirectoryIsRegisteredMultipleTimes(@TempDir Path tempDir) {
		WaitingCallback callback = new WaitingCallback();
		assertThatCode(() -> {
			this.fileWatcher.watch(Set.of(tempDir), callback);
			this.fileWatcher.watch(Set.of(tempDir), callback);
		}).doesNotThrowAnyException();
	}
	@Test
	void shouldNotFailIfStoppedMultipleTimes(@TempDir Path tempDir) {
		WaitingCallback callback = new WaitingCallback();
		this.fileWatcher.watch(Set.of(tempDir), callback);
		assertThatCode(() -> {
			this.fileWatcher.close();
			this.fileWatcher.close();
		}).doesNotThrowAnyException();
	}
	@Test
	void testRelativeFiles() throws Exception {
		Path watchedFile = Path.of(UUID.randomUUID() + '.txt');
		Files.createFile(watchedFile);
		try {
			WaitingCallback callback = new WaitingCallback();
			this.fileWatcher.watch(Set.of(watchedFile), callback);
			Files.delete(watchedFile);
			callback.expectChanges();
		}
		finally {
			Files.deleteIfExists(watchedFile);
		}
	}
	@Test
	void testRelativeDirectories() throws Exception {
		Path watchedDirectory = Path.of(UUID.randomUUID() + '/');
		Path file = watchedDirectory.resolve('file.txt');
		Files.createDirectory(watchedDirectory);
		try {
			WaitingCallback callback = new WaitingCallback();
			this.fileWatcher.watch(Set.of(watchedDirectory), callback);
			Files.createFile(file);
			callback.expectChanges();
		}
		finally {
			Files.deleteIfExists(file);
			Files.deleteIfExists(watchedDirectory);
		}
	}
	private static final class WaitingCallback implements Runnable {
		private final CountDownLatch latch = new CountDownLatch(1);
		volatile boolean changed = false;
		@Override
		public void run() {
			this.changed = true;
			this.latch.countDown();
		}
		void expectChanges() throws InterruptedException {
			waitForChanges(true);
			assertThat(this.changed).as('changed').isTrue();
		}
		void expectNoChanges() throws InterruptedException {
			waitForChanges(false);
			assertThat(this.changed).as('changed').isFalse();
		}
		void waitForChanges(boolean fail) throws InterruptedException {
			if (!this.latch.await(5, TimeUnit.SECONDS)) {
				if (fail) {
					fail('Timeout while waiting for changes');
				}
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class CertificateMatcherTests {
	@CertificateMatchingTest
	void matchesWhenMatchReturnsTrue(CertificateMatchingTestSource source) {
		CertificateMatcher matcher = new CertificateMatcher(source.privateKey());
		assertThat(matcher.matches(source.matchingCertificate())).isTrue();
	}
	@CertificateMatchingTest
	void matchesWhenNoMatchReturnsFalse(CertificateMatchingTestSource source) {
		CertificateMatcher matcher = new CertificateMatcher(source.privateKey());
		for (Certificate nonMatchingCertificate : source.nonMatchingCertificates()) {
			assertThat(matcher.matches(nonMatchingCertificate)).isFalse();
		}
	}
	@CertificateMatchingTest
	void matchesAnyWhenNoneMatchReturnsFalse(CertificateMatchingTestSource source) {
		CertificateMatcher matcher = new CertificateMatcher(source.privateKey());
		assertThat(matcher.matchesAny(source.nonMatchingCertificates())).isFalse();
	}
	@CertificateMatchingTest
	void matchesAnyWhenOneMatchesReturnsTrue(CertificateMatchingTestSource source) {
		CertificateMatcher matcher = new CertificateMatcher(source.privateKey());
		List<Certificate> certificates = new ArrayList<>(source.nonMatchingCertificates());
		certificates.add(source.matchingCertificate());
		assertThat(matcher.matchesAny(certificates)).isTrue();
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
@Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ParameterizedTest(name = '{0}')
@MethodSource('org.springframework.boot.autoconfigure.ssl.CertificateMatchingTestSource#create')
public @interface CertificateMatchingTest {
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class BundleContentNotWatchableFailureAnalyzerTests {
	@Test
	void shouldAnalyze() {
		FailureAnalysis failureAnalysis = performAnalysis(null);
		assertThat(failureAnalysis.getDescription()).isEqualTo(
				'The content of "name" is not watchable. Only "file:" resources are watchable, but "classpath:resource.pem" has been set');
		assertThat(failureAnalysis.getAction())
			.isEqualTo('Update your application to correct the invalid configuration:\n'
					+ 'Either use a watchable resource, or disable bundle reloading by setting reload-on-update = false on the bundle.');
	}
	@Test
	void shouldAnalyzeWithBundle() {
		FailureAnalysis failureAnalysis = performAnalysis('bundle-1');
		assertThat(failureAnalysis.getDescription()).isEqualTo(
				'The content of "name" from bundle "bundle-1" is not watchable". Only "file:" resources are watchable, but "classpath:resource.pem" has been set');
	}
	private FailureAnalysis performAnalysis(String bundle) {
		BundleContentNotWatchableException failure = new BundleContentNotWatchableException(
				new BundleContentProperty('name', 'classpath:resource.pem'));
		if (bundle != null) {
			failure = failure.withBundleName(bundle);
		}
		return new BundleContentNotWatchableFailureAnalyzer().analyze(failure);
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
record CertificateMatchingTestSource(CertificateMatchingTestSource.Algorithm algorithm, PrivateKey privateKey,
		X509Certificate matchingCertificate, List<X509Certificate> nonMatchingCertificates,
		List<PrivateKey> nonMatchingPrivateKeys) {
	private static final List<Algorithm> ALGORITHMS;
	static {
		List<Algorithm> algorithms = new ArrayList<>();
		Stream.of('RSA', 'DSA', 'ed25519', 'ed448').map(Algorithm::of).forEach(algorithms::add);
		Stream.of('secp256r1', 'secp521r1').map(Algorithm::ec).forEach(algorithms::add);
		ALGORITHMS = List.copyOf(algorithms);
	}
	CertificateMatchingTestSource(Algorithm algorithm, KeyPair matchingKeyPair, List<KeyPair> nonMatchingKeyPairs) {
		this(algorithm, matchingKeyPair.getPrivate(), asCertificate(matchingKeyPair),
				nonMatchingKeyPairs.stream().map(CertificateMatchingTestSource::asCertificate).toList(),
				nonMatchingKeyPairs.stream().map(KeyPair::getPrivate).toList());
	}
	private static X509Certificate asCertificate(KeyPair keyPair) {
		X509Certificate certificate = mock(X509Certificate.class);
		given(certificate.getPublicKey()).willReturn(keyPair.getPublic());
		return certificate;
	}
	@Override
	public String toString() {
		return this.algorithm.toString();
	}
	static List<CertificateMatchingTestSource> create()
			throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {
		Map<Algorithm, KeyPair> keyPairs = new LinkedHashMap<>();
		for (Algorithm algorithm : ALGORITHMS) {
			keyPairs.put(algorithm, algorithm.generateKeyPair());
		}
		List<CertificateMatchingTestSource> parameters = new ArrayList<>();
		keyPairs.forEach((algorithm, matchingKeyPair) -> {
			List<KeyPair> nonMatchingKeyPairs = new ArrayList<>(keyPairs.values());
			nonMatchingKeyPairs.remove(matchingKeyPair);
			parameters.add(new CertificateMatchingTestSource(algorithm, matchingKeyPair, nonMatchingKeyPairs));
		});
		return List.copyOf(parameters);
	}
	/**
	 * An individual algorithm.
	 *
	 * @param name the algorithm name
	 * @param spec the algorithm spec or {@code null}
	 */
	record Algorithm(String name, AlgorithmParameterSpec spec) {
		KeyPair generateKeyPair() throws NoSuchAlgorithmException, InvalidAlgorithmParameterException {
			KeyPairGenerator generator = KeyPairGenerator.getInstance(this.name);
			if (this.spec != null) {
				generator.initialize(this.spec);
			}
			return generator.generateKeyPair();
		}
		@Override
		public String toString() {
			String spec = (this.spec instanceof NamedParameterSpec namedSpec) ? namedSpec.getName() : '';
			return this.name + ((!spec.isEmpty()) ? ':' + spec : '');
		}
		static Algorithm of(String name) {
			return new Algorithm(name, null);
		}
		static Algorithm ec(String curve) {
			return new Algorithm('EC', new ECGenParameterSpec(curve));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.groovy.template;
/**
class GroovyTemplateAutoConfigurationTests {
	private final BuildOutput buildOutput = new BuildOutput(getClass());
	private final AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext();
	@BeforeEach
	void setupContext() {
		this.context.setServletContext(new MockServletContext());
	}
	@AfterEach
	void close() {
		LocaleContextHolder.resetLocaleContext();
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void defaultConfiguration() {
		registerAndRefreshContext();
		assertThat(this.context.getBean(GroovyMarkupViewResolver.class)).isNotNull();
	}
	@Test
	void emptyTemplateLocation() {
		new File(this.buildOutput.getTestResourcesLocation(), 'empty-templates/empty-directory').mkdirs();
		registerAndRefreshContext('spring.groovy.template.resource-loader-path:classpath:/templates/empty-directory/');
	}
	@Test
	void defaultViewResolution() throws Exception {
		registerAndRefreshContext();
		MockHttpServletResponse response = render('home');
		String result = response.getContentAsString();
		assertThat(result).contains('home');
		assertThat(response.getContentType()).isEqualTo('text/html;charset=UTF-8');
	}
	@Test
	void includesViewResolution() throws Exception {
		registerAndRefreshContext();
		MockHttpServletResponse response = render('includes');
		String result = response.getContentAsString();
		assertThat(result).contains('here');
		assertThat(response.getContentType()).isEqualTo('text/html;charset=UTF-8');
	}
	@Test
	void disableViewResolution() {
		TestPropertyValues.of('spring.groovy.template.enabled:false').applyTo(this.context);
		registerAndRefreshContext();
		assertThat(this.context.getBeanNamesForType(ViewResolver.class)).isEmpty();
	}
	@Test
	void localeViewResolution() throws Exception {
		registerAndRefreshContext();
		MockHttpServletResponse response = render('includes', Locale.FRENCH);
		String result = response.getContentAsString();
		assertThat(result).contains('voila');
		assertThat(response.getContentType()).isEqualTo('text/html;charset=UTF-8');
	}
	@Test
	void customContentType() throws Exception {
		registerAndRefreshContext('spring.groovy.template.contentType:application/json');
		MockHttpServletResponse response = render('home');
		String result = response.getContentAsString();
		assertThat(result).contains('home');
		assertThat(response.getContentType()).isEqualTo('application/json;charset=UTF-8');
	}
	@Test
	void customPrefix() throws Exception {
		registerAndRefreshContext('spring.groovy.template.prefix:prefix/');
		MockHttpServletResponse response = render('prefixed');
		String result = response.getContentAsString();
		assertThat(result).contains('prefixed');
	}
	@Test
	void customSuffix() throws Exception {
		registerAndRefreshContext('spring.groovy.template.suffix:.groovytemplate');
		MockHttpServletResponse response = render('suffixed');
		String result = response.getContentAsString();
		assertThat(result).contains('suffixed');
	}
	@Test
	void customTemplateLoaderPath() throws Exception {
		registerAndRefreshContext('spring.groovy.template.resource-loader-path:classpath:/custom-templates/');
		MockHttpServletResponse response = render('custom');
		String result = response.getContentAsString();
		assertThat(result).contains('custom');
	}
	@Test
	void disableCache() {
		registerAndRefreshContext('spring.groovy.template.cache:false');
		assertThat(this.context.getBean(GroovyMarkupViewResolver.class).getCacheLimit()).isZero();
	}
	@Test
	void renderTemplate() throws Exception {
		registerAndRefreshContext();
		GroovyMarkupConfig config = this.context.getBean(GroovyMarkupConfig.class);
		MarkupTemplateEngine engine = config.getTemplateEngine();
		Writer writer = new StringWriter();
		engine.createTemplate(new ClassPathResource('templates/message.tpl').getFile())
			.make(new HashMap<String, Object>(Collections.singletonMap('greeting', 'Hello World')))
			.writeTo(writer);
		assertThat(writer.toString()).contains('Hello World');
	}
	@Test
	void customConfiguration() {
		registerAndRefreshContext('spring.groovy.template.configuration.auto-indent:true');
		assertThat(this.context.getBean(GroovyMarkupConfigurer.class).isAutoIndent()).isTrue();
	}
	private void registerAndRefreshContext(String... env) {
		TestPropertyValues.of(env).applyTo(this.context);
		this.context.register(GroovyTemplateAutoConfiguration.class);
		this.context.refresh();
	}
	private MockHttpServletResponse render(String viewName) throws Exception {
		return render(viewName, Locale.UK);
	}
	private MockHttpServletResponse render(String viewName, Locale locale) throws Exception {
		LocaleContextHolder.setLocale(locale);
		GroovyMarkupViewResolver resolver = this.context.getBean(GroovyMarkupViewResolver.class);
		View view = resolver.resolveViewName(viewName, locale);
		assertThat(view).isNotNull();
		HttpServletRequest request = new MockHttpServletRequest();
		request.setAttribute(RequestContext.WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
		MockHttpServletResponse response = new MockHttpServletResponse();
		view.render(null, request, response);
		return response;
	}
}
/*
package org.springframework.boot.autoconfigure.groovy.template;
/**
class GroovyTemplateAvailabilityProviderTests {
	private final TemplateAvailabilityProvider provider = new GroovyTemplateAvailabilityProvider();
	private final ResourceLoader resourceLoader = new DefaultResourceLoader();
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void availabilityOfTemplateInDefaultLocation() {
		assertThat(this.provider.isTemplateAvailable('home', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateThatDoesNotExist() {
		assertThat(this.provider.isTemplateAvailable('whatever', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isFalse();
	}
	@Test
	void availabilityOfTemplateWithCustomLoaderPath() {
		this.environment.setProperty('spring.groovy.template.resource-loader-path', 'classpath:/custom-templates/');
		assertThat(this.provider.isTemplateAvailable('custom', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomLoaderPathConfiguredAsAList() {
		this.environment.setProperty('spring.groovy.template.resource-loader-path[0]', 'classpath:/custom-templates/');
		assertThat(this.provider.isTemplateAvailable('custom', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomPrefix() {
		this.environment.setProperty('spring.groovy.template.prefix', 'prefix/');
		assertThat(this.provider.isTemplateAvailable('prefixed', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomSuffix() {
		this.environment.setProperty('spring.groovy.template.suffix', '.groovytemplate');
		assertThat(this.provider.isTemplateAvailable('suffixed', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void shouldRegisterGroovyTemplateAvailabilityPropertiesRuntimeHints() {
		assertThat(AotServices.factories().load(RuntimeHintsRegistrar.class))
			.hasAtLeastOneElementOfType(GroovyTemplateAvailabilityRuntimeHints.class);
		RuntimeHints hints = new RuntimeHints();
		new GroovyTemplateAvailabilityRuntimeHints().registerHints(hints, getClass().getClassLoader());
		TypeHint typeHint = hints.reflection().getTypeHint(GroovyTemplateAvailabilityProperties.class);
		assertThat(typeHint).isNotNull();
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationImportSelectorIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void singleSelectorWithNoImports() {
		this.contextRunner.withUserConfiguration(NoConfig.class)
			.run((context) -> assertThat(getImportedConfigBeans(context)).isEmpty());
	}
	@Test
	void singleSelector() {
		this.contextRunner.withUserConfiguration(SingleConfig.class)
			.run((context) -> assertThat(getImportedConfigBeans(context)).containsExactly('ConfigC'));
	}
	@Test
	void multipleSelectorsShouldMergeAndSortCorrectly() {
		this.contextRunner.withUserConfiguration(Config.class, AnotherConfig.class)
			.run((context) -> assertThat(getImportedConfigBeans(context)).containsExactly('ConfigA', 'ConfigB',
					'ConfigC', 'ConfigD'));
	}
	@Test
	void multipleSelectorsWithRedundantImportsShouldMergeAndSortCorrectly() {
		this.contextRunner.withUserConfiguration(SingleConfig.class, Config.class, AnotherConfig.class)
			.run((context) -> assertThat(getImportedConfigBeans(context)).containsExactly('ConfigA', 'ConfigB',
					'ConfigC', 'ConfigD'));
	}
	private List<String> getImportedConfigBeans(AssertableApplicationContext context) {
		String shortName = ClassUtils.getShortName(AutoConfigurationImportSelectorIntegrationTests.class);
		int beginIndex = shortName.length() + 1;
		List<String> orderedConfigBeans = new ArrayList<>();
		for (String bean : context.getBeanDefinitionNames()) {
			if (bean.contains('$Config')) {
				String shortBeanName = ClassUtils.getShortName(bean);
				orderedConfigBeans.add(shortBeanName.substring(beginIndex));
			}
		}
		return orderedConfigBeans;
	}
	@ImportAutoConfiguration
	static class NoConfig {
	}
	@ImportAutoConfiguration(ConfigC.class)
	static class SingleConfig {
	}
	@ImportAutoConfiguration({ ConfigD.class, ConfigB.class })
	static class Config {
	}
	@ImportAutoConfiguration({ ConfigC.class, ConfigA.class })
	static class AnotherConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigA {
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigureAfter(ConfigA.class)
	@AutoConfigureBefore(ConfigC.class)
	static class ConfigB {
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigC {
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigureAfter(ConfigC.class)
	static class ConfigD {
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class SpringBootApplicationTests {
	@Test
	void proxyBeanMethodsIsEnabledByDefault() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(DefaultSpringBootApplication.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', true);
	}
	@Test
	void proxyBeanMethodsCanBeDisabled() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(NoBeanMethodProxyingSpringBootApplication.class, Configuration.class);
		assertThat(attributes).containsEntry('proxyBeanMethods', false);
	}
	@Test
	void nameGeneratorDefaultToBeanNameGenerator() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(DefaultSpringBootApplication.class, ComponentScan.class);
		assertThat(attributes).containsEntry('nameGenerator', BeanNameGenerator.class);
	}
	@Test
	void nameGeneratorCanBeSpecified() {
		AnnotationAttributes attributes = AnnotatedElementUtils
			.getMergedAnnotationAttributes(CustomNameGeneratorConfiguration.class, ComponentScan.class);
		assertThat(attributes).containsEntry('nameGenerator', TestBeanNameGenerator.class);
	}
	@SpringBootApplication
	static class DefaultSpringBootApplication {
	}
	@SpringBootApplication(proxyBeanMethods = false)
	static class NoBeanMethodProxyingSpringBootApplication {
	}
	@SpringBootApplication(nameGenerator = TestBeanNameGenerator.class)
	static class CustomNameGeneratorConfiguration {
	}
	static class TestBeanNameGenerator extends DefaultBeanNameGenerator {
	}
}
/*
package org.springframework.boot.autoconfigure.jmx;
/**
class ParentAwareNamingStrategyTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void objectNameMatchesManagedResourceByDefault() {
		this.contextRunner.withBean('testManagedResource', TestManagedResource.class).run((context) -> {
			ParentAwareNamingStrategy strategy = new ParentAwareNamingStrategy(new AnnotationJmxAttributeSource());
			strategy.setApplicationContext(context);
			assertThat(strategy.getObjectName(context.getBean('testManagedResource'), 'testManagedResource')
				.getKeyPropertyListString()).isEqualTo('type=something,name1=def,name2=ghi');
		});
	}
	@Test
	void uniqueObjectNameAddsIdentityProperty() {
		this.contextRunner.withBean('testManagedResource', TestManagedResource.class).run((context) -> {
			ParentAwareNamingStrategy strategy = new ParentAwareNamingStrategy(new AnnotationJmxAttributeSource());
			strategy.setApplicationContext(context);
			strategy.setEnsureUniqueRuntimeObjectNames(true);
			Object resource = context.getBean('testManagedResource');
			ObjectName objectName = strategy.getObjectName(resource, 'testManagedResource');
			assertThat(objectName.getDomain()).isEqualTo('ABC');
			assertThat(objectName.getCanonicalKeyPropertyListString()).isEqualTo(
					'identity=' + ObjectUtils.getIdentityHexString(resource) + ',name1=def,name2=ghi,type=something');
		});
	}
	@Test
	void sameBeanInParentContextAddsContextProperty() {
		this.contextRunner.withBean('testManagedResource', TestManagedResource.class)
			.run((parent) -> this.contextRunner.withBean('testManagedResource', TestManagedResource.class)
				.withParent(parent)
				.run((context) -> {
					ParentAwareNamingStrategy strategy = new ParentAwareNamingStrategy(
							new AnnotationJmxAttributeSource());
					strategy.setApplicationContext(context);
					Object resource = context.getBean('testManagedResource');
					ObjectName objectName = strategy.getObjectName(resource, 'testManagedResource');
					assertThat(objectName.getDomain()).isEqualTo('ABC');
					assertThat(objectName.getCanonicalKeyPropertyListString()).isEqualTo('context='
							+ ObjectUtils.getIdentityHexString(context) + ',name1=def,name2=ghi,type=something');
				}));
	}
	@Test
	void uniqueObjectNameAndSameBeanInParentContextOnlyAddsIdentityProperty() {
		this.contextRunner.withBean('testManagedResource', TestManagedResource.class)
			.run((parent) -> this.contextRunner.withBean('testManagedResource', TestManagedResource.class)
				.withParent(parent)
				.run((context) -> {
					ParentAwareNamingStrategy strategy = new ParentAwareNamingStrategy(
							new AnnotationJmxAttributeSource());
					strategy.setApplicationContext(context);
					strategy.setEnsureUniqueRuntimeObjectNames(true);
					Object resource = context.getBean('testManagedResource');
					ObjectName objectName = strategy.getObjectName(resource, 'testManagedResource');
					assertThat(objectName.getDomain()).isEqualTo('ABC');
					assertThat(objectName.getCanonicalKeyPropertyListString()).isEqualTo('identity='
							+ ObjectUtils.getIdentityHexString(resource) + ',name1=def,name2=ghi,type=something');
				}));
	}
	@ManagedResource(objectName = 'ABC:type=something,name1=def,name2=ghi')
	public static class TestManagedResource {
	}
}
/*
package org.springframework.boot.autoconfigure.jmx;
/**
class JmxAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JmxAutoConfiguration.class));
	@Test
	void testDefaultMBeanExport() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(MBeanExporter.class);
			assertThat(context).doesNotHaveBean(ObjectNamingStrategy.class);
		});
	}
	@Test
	void testDisabledMBeanExport() {
		this.contextRunner.withPropertyValues('spring.jmx.enabled=false').run((context) -> {
			assertThat(context).doesNotHaveBean(MBeanExporter.class);
			assertThat(context).doesNotHaveBean(ObjectNamingStrategy.class);
		});
	}
	@Test
	void testEnabledMBeanExport() {
		this.contextRunner.withPropertyValues('spring.jmx.enabled=true').run((context) -> {
			assertThat(context).hasSingleBean(MBeanExporter.class);
			assertThat(context).hasSingleBean(ParentAwareNamingStrategy.class);
			MBeanExporter exporter = context.getBean(MBeanExporter.class);
			assertThat(exporter).hasFieldOrPropertyWithValue('ensureUniqueRuntimeObjectNames', false);
			assertThat(exporter).hasFieldOrPropertyWithValue('registrationPolicy', RegistrationPolicy.FAIL_ON_EXISTING);
			MetadataNamingStrategy naming = (MetadataNamingStrategy) ReflectionTestUtils.getField(exporter,
					'namingStrategy');
			assertThat(naming).hasFieldOrPropertyWithValue('ensureUniqueRuntimeObjectNames', false);
		});
	}
	@Test
	void testDefaultDomainConfiguredOnMBeanExport() {
		this.contextRunner
			.withPropertyValues('spring.jmx.enabled=true', 'spring.jmx.default-domain=my-test-domain',
					'spring.jmx.unique-names=true', 'spring.jmx.registration-policy=IGNORE_EXISTING')
			.run((context) -> {
				assertThat(context).hasSingleBean(MBeanExporter.class);
				MBeanExporter exporter = context.getBean(MBeanExporter.class);
				assertThat(exporter).hasFieldOrPropertyWithValue('ensureUniqueRuntimeObjectNames', true);
				assertThat(exporter).hasFieldOrPropertyWithValue('registrationPolicy',
						RegistrationPolicy.IGNORE_EXISTING);
				MetadataNamingStrategy naming = (MetadataNamingStrategy) ReflectionTestUtils.getField(exporter,
						'namingStrategy');
				assertThat(naming).hasFieldOrPropertyWithValue('defaultDomain', 'my-test-domain');
				assertThat(naming).hasFieldOrPropertyWithValue('ensureUniqueRuntimeObjectNames', true);
			});
	}
	@Test
	void testBasicParentContext() {
		try (AnnotationConfigApplicationContext parent = new AnnotationConfigApplicationContext()) {
			parent.register(JmxAutoConfiguration.class);
			parent.refresh();
			this.contextRunner.withParent(parent).run((context) -> assertThat(context.isRunning()));
		}
	}
	@Test
	void testParentContext() {
		try (AnnotationConfigApplicationContext parent = new AnnotationConfigApplicationContext()) {
			parent.register(JmxAutoConfiguration.class, TestConfiguration.class);
			parent.refresh();
			this.contextRunner.withParent(parent)
				.withConfiguration(UserConfigurations.of(TestConfiguration.class))
				.run((context) -> assertThat(context.isRunning()));
		}
	}
	@Test
	void customJmxDomain() {
		this.contextRunner.withConfiguration(UserConfigurations.of(CustomJmxDomainConfiguration.class))
			.withConfiguration(AutoConfigurations.of(JmxAutoConfiguration.class, IntegrationAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(IntegrationMBeanExporter.class);
				IntegrationMBeanExporter exporter = context.getBean(IntegrationMBeanExporter.class);
				assertThat(exporter).hasFieldOrPropertyWithValue('domain', 'foo.my');
			});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableIntegrationMBeanExport(defaultDomain = 'foo.my')
	static class CustomJmxDomainConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		Counter counter() {
			return new Counter();
		}
	}
	@ManagedResource
	public static class Counter {
		private int counter = 0;
		@ManagedAttribute
		public int get() {
			return this.counter;
		}
		@ManagedOperation
		public void increment() {
			this.counter++;
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class ImportAutoConfigurationImportSelectorTests {
	private final ImportAutoConfigurationImportSelector importSelector = new TestImportAutoConfigurationImportSelector();
	private final ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	private final MockEnvironment environment = new MockEnvironment();
	@BeforeEach
	void setup() {
		this.importSelector.setBeanFactory(this.beanFactory);
		this.importSelector.setEnvironment(this.environment);
		this.importSelector.setResourceLoader(new DefaultResourceLoader());
	}
	@Test
	void importsAreSelected() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(ImportFreeMarker.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsExactly(FreeMarkerAutoConfiguration.class.getName());
	}
	@Test
	void importsAreSelectedUsingClassesAttribute() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(ImportFreeMarkerUsingClassesAttribute.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsExactly(FreeMarkerAutoConfiguration.class.getName());
	}
	@Test
	void importsAreSelectedFromImportsFile() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(FromImportsFile.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsExactly(
				'org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration',
				'org.springframework.boot.autoconfigure.missing.MissingAutoConfiguration');
	}
	@Test
	void importsSelectedFromImportsFileIgnoreMissingOptionalClasses() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(
				FromImportsFileIgnoresMissingOptionalClasses.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsExactly(
				'org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration',
				'org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration');
	}
	@Test
	void propertyExclusionsAreApplied() throws IOException {
		this.environment.setProperty('spring.autoconfigure.exclude', FreeMarkerAutoConfiguration.class.getName());
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(MultipleImports.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsExactly(ThymeleafAutoConfiguration.class.getName());
	}
	@Test
	void multipleImportsAreFound() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(MultipleImports.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsOnly(FreeMarkerAutoConfiguration.class.getName(),
				ThymeleafAutoConfiguration.class.getName());
	}
	@Test
	void selfAnnotatingAnnotationDoesNotCauseStackOverflow() throws IOException {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(ImportWithSelfAnnotatingAnnotation.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsOnly(ThymeleafAutoConfiguration.class.getName());
	}
	@Test
	void exclusionsAreApplied() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(MultipleImportsWithExclusion.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsOnly(FreeMarkerAutoConfiguration.class.getName());
	}
	@Test
	void exclusionsWithoutImport() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(ExclusionWithoutImport.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).containsOnly(FreeMarkerAutoConfiguration.class.getName());
	}
	@Test
	void exclusionsAliasesAreApplied() throws Exception {
		AnnotationMetadata annotationMetadata = getAnnotationMetadata(ImportWithSelfAnnotatingAnnotationExclude.class);
		String[] imports = this.importSelector.selectImports(annotationMetadata);
		assertThat(imports).isEmpty();
	}
	@Test
	void determineImportsWhenUsingMetaWithoutClassesShouldBeEqual() throws Exception {
		Set<Object> set1 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportMetaAutoConfigurationWithUnrelatedOne.class));
		Set<Object> set2 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportMetaAutoConfigurationWithUnrelatedTwo.class));
		assertThat(set1).isEqualTo(set2);
		assertThat(set1).hasSameHashCodeAs(set2);
	}
	@Test
	void determineImportsWhenUsingNonMetaWithoutClassesShouldBeSame() throws Exception {
		Set<Object> set1 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportAutoConfigurationWithUnrelatedOne.class));
		Set<Object> set2 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportAutoConfigurationWithUnrelatedTwo.class));
		assertThat(set1).isEqualTo(set2);
	}
	@Test
	void determineImportsWhenUsingNonMetaWithClassesShouldBeSame() throws Exception {
		Set<Object> set1 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportAutoConfigurationWithItemsOne.class));
		Set<Object> set2 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportAutoConfigurationWithItemsTwo.class));
		assertThat(set1).isEqualTo(set2);
	}
	@Test
	void determineImportsWhenUsingMetaExcludeWithoutClassesShouldBeEqual() throws Exception {
		Set<Object> set1 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportMetaAutoConfigurationExcludeWithUnrelatedOne.class));
		Set<Object> set2 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportMetaAutoConfigurationExcludeWithUnrelatedTwo.class));
		assertThat(set1).isEqualTo(set2);
		assertThat(set1).hasSameHashCodeAs(set2);
	}
	@Test
	void determineImportsWhenUsingMetaDifferentExcludeWithoutClassesShouldBeDifferent() throws Exception {
		Set<Object> set1 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportMetaAutoConfigurationExcludeWithUnrelatedOne.class));
		Set<Object> set2 = this.importSelector
			.determineImports(getAnnotationMetadata(ImportMetaAutoConfigurationWithUnrelatedTwo.class));
		assertThat(set1).isNotEqualTo(set2);
	}
	@Test
	void determineImportsShouldNotSetPackageImport() throws Exception {
		Class<?> packageImportsClass = ClassUtils
			.resolveClassName('org.springframework.boot.autoconfigure.AutoConfigurationPackages.PackageImports', null);
		Set<Object> selectedImports = this.importSelector
			.determineImports(getAnnotationMetadata(ImportMetaAutoConfigurationExcludeWithUnrelatedOne.class));
		for (Object selectedImport : selectedImports) {
			assertThat(selectedImport).isNotInstanceOf(packageImportsClass);
		}
	}
	private AnnotationMetadata getAnnotationMetadata(Class<?> source) throws IOException {
		return new SimpleMetadataReaderFactory().getMetadataReader(source.getName()).getAnnotationMetadata();
	}
	@ImportAutoConfiguration(FreeMarkerAutoConfiguration.class)
	static class ImportFreeMarker {
	}
	@ImportAutoConfiguration(classes = FreeMarkerAutoConfiguration.class)
	static class ImportFreeMarkerUsingClassesAttribute {
	}
	@ImportOne
	@ImportTwo
	static class MultipleImports {
	}
	@ImportOne
	@ImportTwo
	@ImportAutoConfiguration(exclude = ThymeleafAutoConfiguration.class)
	static class MultipleImportsWithExclusion {
	}
	@ImportOne
	@ImportAutoConfiguration(exclude = ThymeleafAutoConfiguration.class)
	static class ExclusionWithoutImport {
	}
	@SelfAnnotating
	static class ImportWithSelfAnnotatingAnnotation {
	}
	@SelfAnnotating(excludeAutoConfiguration = ThymeleafAutoConfiguration.class)
	static class ImportWithSelfAnnotatingAnnotationExclude {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@ImportAutoConfiguration(FreeMarkerAutoConfiguration.class)
	@interface ImportOne {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@ImportAutoConfiguration(ThymeleafAutoConfiguration.class)
	@interface ImportTwo {
	}
	@MetaImportAutoConfiguration
	@UnrelatedOne
	static class ImportMetaAutoConfigurationWithUnrelatedOne {
	}
	@MetaImportAutoConfiguration
	@UnrelatedTwo
	static class ImportMetaAutoConfigurationWithUnrelatedTwo {
	}
	@ImportAutoConfiguration
	@UnrelatedOne
	static class ImportAutoConfigurationWithUnrelatedOne {
	}
	@ImportAutoConfiguration
	@UnrelatedTwo
	static class ImportAutoConfigurationWithUnrelatedTwo {
	}
	@ImportAutoConfiguration(classes = ThymeleafAutoConfiguration.class)
	@UnrelatedOne
	static class ImportAutoConfigurationWithItemsOne {
	}
	@ImportAutoConfiguration(classes = ThymeleafAutoConfiguration.class)
	@UnrelatedTwo
	static class ImportAutoConfigurationWithItemsTwo {
	}
	@MetaImportAutoConfiguration(exclude = ThymeleafAutoConfiguration.class)
	@UnrelatedOne
	static class ImportMetaAutoConfigurationExcludeWithUnrelatedOne {
	}
	@MetaImportAutoConfiguration(exclude = ThymeleafAutoConfiguration.class)
	@UnrelatedTwo
	static class ImportMetaAutoConfigurationExcludeWithUnrelatedTwo {
	}
	@ImportAutoConfiguration
	@Retention(RetentionPolicy.RUNTIME)
	@interface MetaImportAutoConfiguration {
		@AliasFor(annotation = ImportAutoConfiguration.class)
		Class<?>[] exclude() default {
		};
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface UnrelatedOne {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@interface UnrelatedTwo {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@ImportAutoConfiguration(ThymeleafAutoConfiguration.class)
	@SelfAnnotating
	@interface SelfAnnotating {
		@AliasFor(annotation = ImportAutoConfiguration.class, attribute = 'exclude')
		Class<?>[] excludeAutoConfiguration() default {
		};
	}
	@Retention(RetentionPolicy.RUNTIME)
	@ImportAutoConfiguration
	@interface FromImportsFile {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@ImportAutoConfiguration
	@interface FromImportsFileIgnoresMissingOptionalClasses {
	}
	static class TestImportAutoConfigurationImportSelector extends ImportAutoConfigurationImportSelector {
		@Override
		protected Collection<String> loadFactoryNames(Class<?> source) {
			if (source == MetaImportAutoConfiguration.class) {
				return Arrays.asList(ThymeleafAutoConfiguration.class.getName(),
						FreeMarkerAutoConfiguration.class.getName());
			}
			return super.loadFactoryNames(source);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.webservices.client;
/**
class WebServiceTemplateAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(WebServiceTemplateAutoConfiguration.class, HttpClientAutoConfiguration.class));
	@Test
	void autoConfiguredBuilderShouldNotHaveMarshallerAndUnmarshaller() {
		this.contextRunner.run(assertWebServiceTemplateBuilder((builder) -> {
			WebServiceTemplate webServiceTemplate = builder.build();
			assertThat(webServiceTemplate.getUnmarshaller()).isNull();
			assertThat(webServiceTemplate.getMarshaller()).isNull();
		}));
	}
	@Test
	void autoConfiguredBuilderShouldHaveHttpMessageSenderByDefault() {
		this.contextRunner.run(assertWebServiceTemplateBuilder((builder) -> {
			WebServiceTemplate webServiceTemplate = builder.build();
			assertThat(webServiceTemplate.getMessageSenders()).hasSize(1);
			WebServiceMessageSender messageSender = webServiceTemplate.getMessageSenders()[0];
			assertThat(messageSender).isInstanceOf(ClientHttpRequestMessageSender.class);
		}));
	}
	@Test
	void webServiceTemplateWhenHasCustomBuilderShouldUseCustomBuilder() {
		this.contextRunner.withUserConfiguration(CustomWebServiceTemplateBuilderConfig.class)
			.run(assertWebServiceTemplateBuilder((builder) -> {
				WebServiceTemplate webServiceTemplate = builder.build();
				assertThat(webServiceTemplate.getMarshaller())
					.isSameAs(CustomWebServiceTemplateBuilderConfig.marshaller);
			}));
	}
	@Test
	void webServiceTemplateShouldApplyCustomizer() {
		this.contextRunner.withUserConfiguration(WebServiceTemplateCustomizerConfig.class)
			.run(assertWebServiceTemplateBuilder((builder) -> {
				WebServiceTemplate webServiceTemplate = builder.build();
				assertThat(webServiceTemplate.getUnmarshaller())
					.isSameAs(WebServiceTemplateCustomizerConfig.unmarshaller);
			}));
	}
	@Test
	void builderShouldBeFreshForEachUse() {
		this.contextRunner.withUserConfiguration(DirtyWebServiceTemplateConfig.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void whenHasFactoryProperty() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withPropertyValues('spring.http.client.factory=simple')
			.run(assertWebServiceTemplateBuilder((builder) -> {
				WebServiceTemplate webServiceTemplate = builder.build();
				assertThat(webServiceTemplate.getMessageSenders()).hasSize(1);
				ClientHttpRequestMessageSender messageSender = (ClientHttpRequestMessageSender) webServiceTemplate
					.getMessageSenders()[0];
				assertThat(messageSender.getRequestFactory()).isInstanceOf(SimpleClientHttpRequestFactory.class);
			}));
	}
	private ContextConsumer<AssertableApplicationContext> assertWebServiceTemplateBuilder(
			Consumer<WebServiceTemplateBuilder> builder) {
		return (context) -> {
			assertThat(context).hasSingleBean(WebServiceTemplateBuilder.class);
			builder.accept(context.getBean(WebServiceTemplateBuilder.class));
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class DirtyWebServiceTemplateConfig {
		@Bean
		WebServiceTemplate webServiceTemplateOne(WebServiceTemplateBuilder builder) {
			try {
				return builder.build();
			}
			finally {
				breakBuilderOnNextCall(builder);
			}
		}
		@Bean
		WebServiceTemplate webServiceTemplateTwo(WebServiceTemplateBuilder builder) {
			try {
				return builder.build();
			}
			finally {
				breakBuilderOnNextCall(builder);
			}
		}
		private void breakBuilderOnNextCall(WebServiceTemplateBuilder builder) {
			builder.additionalCustomizers((webServiceTemplate) -> {
				throw new IllegalStateException();
			});
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebServiceTemplateBuilderConfig {
		private static final Marshaller marshaller = new Jaxb2Marshaller();
		@Bean
		WebServiceTemplateBuilder webServiceTemplateBuilder() {
			return new WebServiceTemplateBuilder().setMarshaller(marshaller);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServiceTemplateCustomizerConfig {
		private static final Unmarshaller unmarshaller = new Jaxb2Marshaller();
		@Bean
		WebServiceTemplateCustomizer webServiceTemplateCustomizer() {
			return (ws) -> ws.setUnmarshaller(unmarshaller);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.webservices;
/**
class OnWsdlLocationsConditionTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(TestConfig.class);
	@Test
	void wsdlLocationsNotDefined() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean('foo'));
	}
	@Test
	void wsdlLocationsDefinedAsCommaSeparated() {
		this.contextRunner.withPropertyValues('spring.webservices.wsdl-locations=value1')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Test
	void wsdlLocationsDefinedAsList() {
		this.contextRunner.withPropertyValues('spring.webservices.wsdl-locations[0]=value1')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(OnWsdlLocationsCondition.class)
	static class TestConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.webservices;
/**
class WebServicesPropertiesTests {
	private WebServicesProperties properties;
	@Test
	void pathMustNotBeEmpty() {
		this.properties = new WebServicesProperties();
		assertThatIllegalArgumentException().isThrownBy(() -> this.properties.setPath(''))
			.withMessageContaining('Path must have length greater than 1');
	}
	@Test
	void pathMustHaveLengthGreaterThanOne() {
		this.properties = new WebServicesProperties();
		assertThatIllegalArgumentException().isThrownBy(() -> this.properties.setPath('/'))
			.withMessageContaining('Path must have length greater than 1');
	}
	@Test
	void customPathMustBeginWithASlash() {
		this.properties = new WebServicesProperties();
		assertThatIllegalArgumentException().isThrownBy(() -> this.properties.setPath('custom'))
			.withMessageContaining('Path must start with "/"');
	}
}
/*
package org.springframework.boot.autoconfigure.webservices;
/**
class WebServicesAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(WebServicesAutoConfiguration.class));
	@Test
	void defaultConfiguration() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ServletRegistrationBean.class));
	}
	@Test
	void customPathMustBeginWithASlash() {
		this.contextRunner.withPropertyValues('spring.webservices.path=invalid')
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.rootCause()
				.hasMessageContaining('Path must start with "/"'));
	}
	@Test
	void customPath() {
		this.contextRunner.withPropertyValues('spring.webservices.path=/valid')
			.run((context) -> assertThat(getUrlMappings(context)).contains('/valid/*'));
	}
	@Test
	void customPathWithTrailingSlash() {
		this.contextRunner.withPropertyValues('spring.webservices.path=/valid/')
			.run((context) -> assertThat(getUrlMappings(context)).contains('/valid/*'));
	}
	@Test
	void customLoadOnStartup() {
		this.contextRunner.withPropertyValues('spring.webservices.servlet.load-on-startup=1').run((context) -> {
			ServletRegistrationBean<?> registrationBean = context.getBean(ServletRegistrationBean.class);
			assertThat(registrationBean).extracting('loadOnStartup').isEqualTo(1);
		});
	}
	@Test
	void customInitParameters() {
		this.contextRunner
			.withPropertyValues('spring.webservices.servlet.init.key1=value1',
					'spring.webservices.servlet.init.key2=value2')
			.run((context) -> assertThat(getServletRegistrationBean(context).getInitParameters())
				.containsEntry('key1', 'value1')
				.containsEntry('key2', 'value2'));
	}
	@Test
	void withWsdlBeans() {
		this.contextRunner.withPropertyValues('spring.webservices.wsdl-locations=classpath:/wsdl').run((context) -> {
			assertThat(context.getBeansOfType(SimpleWsdl11Definition.class)).containsOnlyKeys('service');
			assertThat(context.getBeansOfType(SimpleXsdSchema.class)).containsOnlyKeys('types');
		});
	}
	@Test
	void withWsdlBeansAsList() {
		this.contextRunner.withPropertyValues('spring.webservices.wsdl-locations[0]=classpath:/wsdl').run((context) -> {
			assertThat(context.getBeansOfType(SimpleWsdl11Definition.class)).containsOnlyKeys('service');
			assertThat(context.getBeansOfType(SimpleXsdSchema.class)).containsOnlyKeys('types');
		});
	}
	private Collection<String> getUrlMappings(ApplicationContext context) {
		return getServletRegistrationBean(context).getUrlMappings();
	}
	private ServletRegistrationBean<?> getServletRegistrationBean(ApplicationContext loaded) {
		return loaded.getBean(ServletRegistrationBean.class);
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class Dbcp2JdbcConnectionDetailsBeanPostProcessorTests {
	@Test
	void setUsernamePasswordUrlAndDriverClassName() {
		BasicDataSource dataSource = new BasicDataSource();
		dataSource.setUrl('will-be-overwritten');
		dataSource.setUsername('will-be-overwritten');
		dataSource.setPassword('will-be-overwritten');
		dataSource.setDriverClassName('will-be-overwritten');
		new Dbcp2JdbcConnectionDetailsBeanPostProcessor(null).processDataSource(dataSource,
				new TestJdbcConnectionDetails());
		assertThat(dataSource.getUrl()).isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
		assertThat(dataSource.getUserName()).isEqualTo('user-1');
		assertThat(dataSource).extracting('password').isEqualTo('password-1');
		assertThat(dataSource.getDriverClassName()).isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class EmbeddedDataSourceConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void defaultEmbeddedDatabase() {
		this.context = load();
		assertThat(this.context.getBean(DataSource.class)).isNotNull();
	}
	@Test
	void generateUniqueName() throws Exception {
		this.context = load('spring.datasource.generate-unique-name=true');
		try (AnnotationConfigApplicationContext context2 = load('spring.datasource.generate-unique-name=true')) {
			DataSource dataSource = this.context.getBean(DataSource.class);
			DataSource dataSource2 = context2.getBean(DataSource.class);
			assertThat(getDatabaseName(dataSource)).isNotEqualTo(getDatabaseName(dataSource2));
		}
	}
	private String getDatabaseName(DataSource dataSource) throws SQLException {
		try (Connection connection = dataSource.getConnection()) {
			ResultSet catalogs = connection.getMetaData().getCatalogs();
			if (catalogs.next()) {
				return catalogs.getString(1);
			}
			else {
				throw new IllegalStateException('Unable to get database name');
			}
		}
	}
	private AnnotationConfigApplicationContext load(String... environment) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(environment).applyTo(ctx);
		ctx.register(EmbeddedDataSourceConfiguration.class);
		ctx.refresh();
		return ctx;
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class HikariDriverConfigurationFailureAnalyzerTests {
	@Test
	void failureAnalysisIsPerformed() {
		FailureAnalysis failureAnalysis = performAnalysis(TestConfiguration.class);
		assertThat(failureAnalysis).isNotNull();
		assertThat(failureAnalysis.getDescription())
			.isEqualTo('Configuration of the Hikari connection pool failed: "dataSourceClassName" is not supported.');
		assertThat(failureAnalysis.getAction()).contains('Spring Boot auto-configures only a driver');
	}
	@Test
	void unrelatedIllegalStateExceptionIsSkipped() {
		FailureAnalysis failureAnalysis = new HikariDriverConfigurationFailureAnalyzer()
			.analyze(new RuntimeException('foo', new IllegalStateException('bar')));
		assertThat(failureAnalysis).isNull();
	}
	private FailureAnalysis performAnalysis(Class<?> configuration) {
		BeanCreationException failure = createFailure(configuration);
		assertThat(failure).isNotNull();
		return new HikariDriverConfigurationFailureAnalyzer().analyze(failure);
	}
	private BeanCreationException createFailure(Class<?> configuration) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues
			.of('spring.datasource.type=' + HikariDataSource.class.getName(),
					'spring.datasource.hikari.data-source-class-name=com.example.Foo', 'spring.sql.init.mode=always')
			.applyTo(context);
		context.register(configuration);
		try {
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ DataSourceAutoConfiguration.class, SqlInitializationAutoConfiguration.class })
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
public class TestDataSource extends SimpleDriverDataSource {
	/**
	 * Create an in-memory database with a random name.
	 */
	public TestDataSource() {
		this(false);
	}
	/**
	 * Create an in-memory database with a random name.
	 * @param addTestUser if a test user should be added
	 */
	public TestDataSource(boolean addTestUser) {
		this(UUID.randomUUID().toString(), addTestUser);
	}
	/**
	 * Create an in-memory database with the specified name.
	 * @param name the name of the database
	 * @param addTestUser if a test user should be added
	 */
	public TestDataSource(String name, boolean addTestUser) {
		setDriverClass(org.hsqldb.jdbc.JDBCDriver.class);
		setUrl('jdbc:hsqldb:mem:' + name);
		setUsername('sa');
		setupDatabase(addTestUser);
		setUrl(getUrl() + ';create=false');
	}
	private void setupDatabase(boolean addTestUser) {
		try (Connection connection = getConnection()) {
			if (addTestUser) {
				connection.prepareStatement('CREATE USER \'test\' password \'secret\' ADMIN').execute();
			}
		}
		catch (SQLException ex) {
			throw new IllegalStateException(ex);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class TestJdbcConnectionDetails implements JdbcConnectionDetails {
	@Override
	public String getJdbcUrl() {
		return 'jdbc:customdb://customdb.example.com:12345/database-1';
	}
	@Override
	public String getUsername() {
		return 'user-1';
	}
	@Override
	public String getPassword() {
		return 'password-1';
	}
	@Override
	public String getDriverClassName() {
		return DatabaseDriver.POSTGRESQL.getDriverClassName();
	}
	@Override
	public String getXaDataSourceClassName() {
		return DatabaseDriver.POSTGRESQL.getXaDataSourceClassName();
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@Configuration(proxyBeanMethods = false)
class MultiDataSourceConfiguration {
	@Bean
	DataSource test1DataSource() {
		return new TestDataSource('test1', false);
	}
	@Bean
	DataSource test2DataSource() {
		return new TestDataSource('test2', false);
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class DataSourcePropertiesTests {
	@Test
	void determineDriver() {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUrl('jdbc:mysql://mydb');
		assertThat(properties.getDriverClassName()).isNull();
		assertThat(properties.determineDriverClassName()).isEqualTo('com.mysql.cj.jdbc.Driver');
	}
	@Test
	void determineDriverWithExplicitConfig() {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUrl('jdbc:mysql://mydb');
		properties.setDriverClassName('org.hsqldb.jdbcDriver');
		assertThat(properties.getDriverClassName()).isEqualTo('org.hsqldb.jdbcDriver');
		assertThat(properties.determineDriverClassName()).isEqualTo('org.hsqldb.jdbcDriver');
	}
	@Test
	void determineUrlWithoutGenerateUniqueName() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setGenerateUniqueName(false);
		properties.afterPropertiesSet();
		assertThat(properties.getUrl()).isNull();
		assertThat(properties.determineUrl()).isEqualTo(EmbeddedDatabaseConnection.H2.getUrl('testdb'));
	}
	@Test
	void determineUrlWithNoEmbeddedSupport() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setBeanClassLoader(new FilteredClassLoader('org.h2', 'org.apache.derby', 'org.hsqldb'));
		properties.afterPropertiesSet();
		assertThatExceptionOfType(DataSourceProperties.DataSourceBeanCreationException.class)
			.isThrownBy(properties::determineUrl)
			.withMessageContaining('Failed to determine suitable jdbc url');
	}
	@Test
	void determineUrlWithSpecificEmbeddedConnection() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setGenerateUniqueName(false);
		properties.setEmbeddedDatabaseConnection(EmbeddedDatabaseConnection.HSQLDB);
		properties.afterPropertiesSet();
		assertThat(properties.determineUrl()).isEqualTo(EmbeddedDatabaseConnection.HSQLDB.getUrl('testdb'));
	}
	@Test
	void whenEmbeddedConnectionIsNoneAndNoUrlIsConfiguredThenDetermineUrlThrows() {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setGenerateUniqueName(false);
		properties.setEmbeddedDatabaseConnection(EmbeddedDatabaseConnection.NONE);
		assertThatExceptionOfType(DataSourceProperties.DataSourceBeanCreationException.class)
			.isThrownBy(properties::determineUrl)
			.withMessageContaining('Failed to determine suitable jdbc url');
	}
	@Test
	void determineUrlWithExplicitConfig() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUrl('jdbc:mysql://mydb');
		properties.afterPropertiesSet();
		assertThat(properties.getUrl()).isEqualTo('jdbc:mysql://mydb');
		assertThat(properties.determineUrl()).isEqualTo('jdbc:mysql://mydb');
	}
	@Test
	void determineUrlWithGenerateUniqueName() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.afterPropertiesSet();
		assertThat(properties.determineUrl()).isEqualTo(properties.determineUrl());
		DataSourceProperties properties2 = new DataSourceProperties();
		properties2.setGenerateUniqueName(true);
		properties2.afterPropertiesSet();
		assertThat(properties.determineUrl()).isNotEqualTo(properties2.determineUrl());
	}
	@Test
	void determineUsername() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.afterPropertiesSet();
		assertThat(properties.getUsername()).isNull();
		assertThat(properties.determineUsername()).isEqualTo('sa');
	}
	@Test
	void determineUsernameWhenEmpty() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUsername('');
		properties.afterPropertiesSet();
		assertThat(properties.getUsername()).isEmpty();
		assertThat(properties.determineUsername()).isEqualTo('sa');
	}
	@Test
	void determineUsernameWhenNull() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUsername(null);
		properties.afterPropertiesSet();
		assertThat(properties.getUsername()).isNull();
		assertThat(properties.determineUsername()).isEqualTo('sa');
	}
	@Test
	void determineUsernameWithExplicitConfig() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUsername('foo');
		properties.afterPropertiesSet();
		assertThat(properties.getUsername()).isEqualTo('foo');
		assertThat(properties.determineUsername()).isEqualTo('foo');
	}
	@Test
	void determineUsernameWithNonEmbeddedUrl() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUrl('jdbc:h2:~/test');
		properties.afterPropertiesSet();
		assertThat(properties.getPassword()).isNull();
		assertThat(properties.determineUsername()).isNull();
	}
	@Test
	void determinePassword() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.afterPropertiesSet();
		assertThat(properties.getPassword()).isNull();
		assertThat(properties.determinePassword()).isEmpty();
	}
	@Test
	void determinePasswordWithExplicitConfig() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setPassword('bar');
		properties.afterPropertiesSet();
		assertThat(properties.getPassword()).isEqualTo('bar');
		assertThat(properties.determinePassword()).isEqualTo('bar');
	}
	@Test
	void determinePasswordWithNonEmbeddedUrl() throws Exception {
		DataSourceProperties properties = new DataSourceProperties();
		properties.setUrl('jdbc:h2:~/test');
		properties.afterPropertiesSet();
		assertThat(properties.getPassword()).isNull();
		assertThat(properties.determinePassword()).isNull();
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class DataSourceTransactionManagerAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(TransactionAutoConfiguration.class,
				TransactionManagerCustomizationAutoConfiguration.class,
				DataSourceTransactionManagerAutoConfiguration.class))
		.withPropertyValues('spring.datasource.url:jdbc:hsqldb:mem:test-' + UUID.randomUUID());
	@Test
	void transactionManagerWithoutDataSourceIsNotConfigured() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(TransactionManager.class));
	}
	@Test
	void transactionManagerWithExistingDataSourceIsConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(TransactionManager.class).hasSingleBean(JdbcTransactionManager.class);
				assertThat(context.getBean(JdbcTransactionManager.class).getDataSource())
					.isSameAs(context.getBean(DataSource.class));
			});
	}
	@Test
	void transactionManagerWithCustomizationIsConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('spring.transaction.default-timeout=1m',
					'spring.transaction.rollback-on-commit-failure=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(TransactionManager.class).hasSingleBean(JdbcTransactionManager.class);
				JdbcTransactionManager transactionManager = context.getBean(JdbcTransactionManager.class);
				assertThat(transactionManager.getDefaultTimeout()).isEqualTo(60);
				assertThat(transactionManager.isRollbackOnCommitFailure()).isTrue();
			});
	}
	@Test
	void transactionManagerWithExistingTransactionManagerIsNotOverridden() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withBean('myTransactionManager', TransactionManager.class, () -> mock(TransactionManager.class))
			.run((context) -> assertThat(context).hasSingleBean(DataSource.class)
				.hasSingleBean(TransactionManager.class)
				.hasBean('myTransactionManager'));
	}
	@Test // gh-24321
	void transactionManagerWithDaoExceptionTranslationDisabled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('spring.dao.exceptiontranslation.enabled=false')
			.run((context) -> assertThat(context.getBean(TransactionManager.class))
				.isExactlyInstanceOf(DataSourceTransactionManager.class));
	}
	@Test // gh-24321
	void transactionManagerWithDaoExceptionTranslationEnabled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('spring.dao.exceptiontranslation.enabled=true')
			.run((context) -> assertThat(context.getBean(TransactionManager.class))
				.isExactlyInstanceOf(JdbcTransactionManager.class));
	}
	@Test // gh-24321
	void transactionManagerWithDaoExceptionTranslationDefault() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> assertThat(context.getBean(TransactionManager.class))
				.isExactlyInstanceOf(JdbcTransactionManager.class));
	}
	@Test
	void transactionWithMultipleDataSourcesIsNotConfigured() {
		this.contextRunner.withUserConfiguration(MultiDataSourceConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(TransactionManager.class));
	}
	@Test
	void transactionWithMultipleDataSourcesAndPrimaryCandidateIsConfigured() {
		this.contextRunner.withUserConfiguration(MultiDataSourceUsingPrimaryConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(TransactionManager.class).hasSingleBean(JdbcTransactionManager.class);
			assertThat(context.getBean(JdbcTransactionManager.class).getDataSource())
				.isSameAs(context.getBean('test1DataSource'));
		});
	}
	@Test
	void shouldNotUseDataSourcePropertiesIfDataSourceIsNotOnTheClasspath() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(DataSource.class))
			.run((context) -> assertThat(context).doesNotHaveBean(DataSourceProperties.class));
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@ClassPathExclusions({ 'h2-*.jar', 'hsqldb-*.jar' })
class DataSourceBeanCreationFailureAnalyzerTests {
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void failureAnalysisIsPerformed() {
		FailureAnalysis failureAnalysis = performAnalysis(TestConfiguration.class);
		assertThat(failureAnalysis.getDescription()).contains('"url" attribute is not specified',
				'no embedded datasource could be configured', 'Failed to determine a suitable driver class');
		assertThat(failureAnalysis.getAction()).contains(
				'If you want an embedded database (H2, HSQL or Derby), please put it on the classpath',
				'If you have database settings to be loaded from a particular profile you may need to activate it',
				'(no profiles are currently active)');
	}
	@Test
	void failureAnalysisIsPerformedWithActiveProfiles() {
		this.environment.setActiveProfiles('first', 'second');
		FailureAnalysis failureAnalysis = performAnalysis(TestConfiguration.class);
		assertThat(failureAnalysis.getAction()).contains('(the profiles first,second are currently active)');
	}
	private FailureAnalysis performAnalysis(Class<?> configuration) {
		BeanCreationException failure = createFailure(configuration);
		assertThat(failure).isNotNull();
		DataSourceBeanCreationFailureAnalyzer failureAnalyzer = new DataSourceBeanCreationFailureAnalyzer(
				this.environment);
		return failureAnalyzer.analyze(failure);
	}
	private BeanCreationException createFailure(Class<?> configuration) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			context.setEnvironment(this.environment);
			context.register(configuration);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(DataSourceAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class HikariJdbcConnectionDetailsBeanPostProcessorTests {
	@Test
	void setUsernamePasswordAndUrl() {
		HikariDataSource dataSource = new HikariDataSource();
		dataSource.setJdbcUrl('will-be-overwritten');
		dataSource.setUsername('will-be-overwritten');
		dataSource.setPassword('will-be-overwritten');
		dataSource.setDriverClassName(DatabaseDriver.H2.getDriverClassName());
		new HikariJdbcConnectionDetailsBeanPostProcessor(null).processDataSource(dataSource,
				new TestJdbcConnectionDetails());
		assertThat(dataSource.getJdbcUrl()).isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
		assertThat(dataSource.getUsername()).isEqualTo('user-1');
		assertThat(dataSource.getPassword()).isEqualTo('password-1');
		assertThat(dataSource.getDriverClassName()).isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class JdbcTemplateAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.datasource.generate-unique-name=true')
		.withConfiguration(
				AutoConfigurations.of(DataSourceAutoConfiguration.class, JdbcTemplateAutoConfiguration.class));
	@Test
	void testJdbcTemplateExists() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(JdbcOperations.class);
			JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);
			assertThat(jdbcTemplate.getDataSource()).isEqualTo(context.getBean(DataSource.class));
			assertThat(jdbcTemplate.getFetchSize()).isEqualTo(-1);
			assertThat(jdbcTemplate.getQueryTimeout()).isEqualTo(-1);
			assertThat(jdbcTemplate.getMaxRows()).isEqualTo(-1);
		});
	}
	@Test
	void testJdbcTemplateWithCustomProperties() {
		this.contextRunner
			.withPropertyValues('spring.jdbc.template.fetch-size:100', 'spring.jdbc.template.query-timeout:60',
					'spring.jdbc.template.max-rows:1000')
			.run((context) -> {
				assertThat(context).hasSingleBean(JdbcOperations.class);
				JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);
				assertThat(jdbcTemplate.getDataSource()).isNotNull();
				assertThat(jdbcTemplate.getFetchSize()).isEqualTo(100);
				assertThat(jdbcTemplate.getQueryTimeout()).isEqualTo(60);
				assertThat(jdbcTemplate.getMaxRows()).isEqualTo(1000);
			});
	}
	@Test
	void testJdbcTemplateExistsWithCustomDataSource() {
		this.contextRunner.withUserConfiguration(TestDataSourceConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(JdbcOperations.class);
			JdbcTemplate jdbcTemplate = context.getBean(JdbcTemplate.class);
			assertThat(jdbcTemplate.getDataSource()).isEqualTo(context.getBean('customDataSource'));
		});
	}
	@Test
	void testNamedParameterJdbcTemplateExists() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(NamedParameterJdbcOperations.class);
			NamedParameterJdbcTemplate namedParameterJdbcTemplate = context.getBean(NamedParameterJdbcTemplate.class);
			assertThat(namedParameterJdbcTemplate.getJdbcOperations()).isEqualTo(context.getBean(JdbcOperations.class));
		});
	}
	@Test
	void testMultiDataSource() {
		this.contextRunner.withUserConfiguration(MultiDataSourceConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(JdbcOperations.class);
			assertThat(context).doesNotHaveBean(NamedParameterJdbcOperations.class);
		});
	}
	@Test
	void testMultiJdbcTemplate() {
		this.contextRunner.withUserConfiguration(MultiJdbcTemplateConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(NamedParameterJdbcOperations.class));
	}
	@Test
	void testMultiDataSourceUsingPrimary() {
		this.contextRunner.withUserConfiguration(MultiDataSourceUsingPrimaryConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(JdbcOperations.class);
			assertThat(context).hasSingleBean(NamedParameterJdbcOperations.class);
			assertThat(context.getBean(JdbcTemplate.class).getDataSource())
				.isEqualTo(context.getBean('test1DataSource'));
		});
	}
	@Test
	void testMultiJdbcTemplateUsingPrimary() {
		this.contextRunner.withUserConfiguration(MultiJdbcTemplateUsingPrimaryConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(NamedParameterJdbcOperations.class);
			assertThat(context.getBean(NamedParameterJdbcTemplate.class).getJdbcOperations())
				.isEqualTo(context.getBean('test1Template'));
		});
	}
	@Test
	void testExistingCustomJdbcTemplate() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(JdbcOperations.class);
			assertThat(context.getBean(JdbcOperations.class)).isEqualTo(context.getBean('customJdbcOperations'));
		});
	}
	@Test
	void testExistingCustomNamedParameterJdbcTemplate() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(NamedParameterJdbcOperations.class);
			assertThat(context.getBean(NamedParameterJdbcOperations.class))
				.isEqualTo(context.getBean('customNamedParameterJdbcOperations'));
		});
	}
	@Test
	void testDependencyToScriptBasedDataSourceInitialization() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(SqlInitializationAutoConfiguration.class))
			.withUserConfiguration(DataSourceInitializationValidator.class)
			.run((context) -> {
				assertThat(context).hasNotFailed();
				assertThat(context.getBean(DataSourceInitializationValidator.class).count).isOne();
			});
	}
	@Test
	void testDependencyToFlyway() {
		this.contextRunner.withUserConfiguration(DataSourceMigrationValidator.class)
			.withPropertyValues('spring.flyway.locations:classpath:db/city')
			.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasNotFailed();
				assertThat(context.getBean(DataSourceMigrationValidator.class).count).isZero();
			});
	}
	@Test
	void testDependencyToFlywayWithJdbcTemplateMixed() {
		this.contextRunner.withUserConfiguration(NamedParameterDataSourceMigrationValidator.class)
			.withPropertyValues('spring.flyway.locations:classpath:db/city')
			.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasNotFailed();
				assertThat(context.getBean(JdbcTemplate.class)).isNotNull();
				assertThat(context.getBean(NamedParameterDataSourceMigrationValidator.class).count).isZero();
			});
	}
	@Test
	void testDependencyToLiquibase() {
		this.contextRunner.withUserConfiguration(DataSourceMigrationValidator.class)
			.withPropertyValues('spring.liquibase.change-log:classpath:db/changelog/db.changelog-city.yaml')
			.withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasNotFailed();
				assertThat(context.getBean(DataSourceMigrationValidator.class).count).isZero();
			});
	}
	@Test
	void testDependencyToLiquibaseWithJdbcTemplateMixed() {
		this.contextRunner.withUserConfiguration(NamedParameterDataSourceMigrationValidator.class)
			.withPropertyValues('spring.liquibase.change-log:classpath:db/changelog/db.changelog-city.yaml')
			.withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasNotFailed();
				assertThat(context.getBean(JdbcTemplate.class)).isNotNull();
				assertThat(context.getBean(NamedParameterDataSourceMigrationValidator.class).count).isZero();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConfiguration {
		@Bean
		JdbcOperations customJdbcOperations(DataSource dataSource) {
			return new JdbcTemplate(dataSource);
		}
		@Bean
		NamedParameterJdbcOperations customNamedParameterJdbcOperations(DataSource dataSource) {
			return new NamedParameterJdbcTemplate(dataSource);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestDataSourceConfiguration {
		@Bean
		DataSource customDataSource() {
			return new TestDataSource();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultiJdbcTemplateConfiguration {
		@Bean
		JdbcTemplate test1Template() {
			return mock(JdbcTemplate.class);
		}
		@Bean
		JdbcTemplate test2Template() {
			return mock(JdbcTemplate.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultiJdbcTemplateUsingPrimaryConfiguration {
		@Bean
		@Primary
		JdbcTemplate test1Template() {
			return mock(JdbcTemplate.class);
		}
		@Bean
		JdbcTemplate test2Template() {
			return mock(JdbcTemplate.class);
		}
	}
	static class DataSourceInitializationValidator {
		private final Integer count;
		DataSourceInitializationValidator(JdbcTemplate jdbcTemplate) {
			this.count = jdbcTemplate.queryForObject('SELECT COUNT(*) from BAR', Integer.class);
		}
	}
	static class DataSourceMigrationValidator {
		private final Integer count;
		DataSourceMigrationValidator(JdbcTemplate jdbcTemplate) {
			this.count = jdbcTemplate.queryForObject('SELECT COUNT(*) from CITY', Integer.class);
		}
	}
	static class NamedParameterDataSourceMigrationValidator {
		private final Integer count;
		NamedParameterDataSourceMigrationValidator(NamedParameterJdbcTemplate namedParameterJdbcTemplate) {
			this.count = namedParameterJdbcTemplate.queryForObject('SELECT COUNT(*) from CITY', Collections.emptyMap(),
					Integer.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class TomcatJdbcConnectionDetailsBeanPostProcessorTests {
	@Test
	void setUsernamePasswordUrlAndDriverClassName() {
		DataSource dataSource = new DataSource();
		dataSource.setUrl('will-be-overwritten');
		dataSource.setUsername('will-be-overwritten');
		dataSource.setPassword('will-be-overwritten');
		dataSource.setDriverClassName('will-be-overwritten');
		new TomcatJdbcConnectionDetailsBeanPostProcessor(null).processDataSource(dataSource,
				new TestJdbcConnectionDetails());
		assertThat(dataSource.getUrl()).isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
		assertThat(dataSource.getUsername()).isEqualTo('user-1');
		assertThat(dataSource.getPoolProperties().getPassword()).isEqualTo('password-1');
		assertThat(dataSource.getPoolProperties().getDriverClassName())
			.isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class OracleUcpDataSourceConfigurationTests {
	private static final String PREFIX = 'spring.datasource.oracleucp.';
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
		.withPropertyValues('spring.datasource.type=' + PoolDataSource.class.getName());
	@Test
	void testDataSourceExists() {
		this.contextRunner.run((context) -> {
			assertThat(context.getBeansOfType(DataSource.class)).hasSize(1);
			assertThat(context.getBeansOfType(PoolDataSourceImpl.class)).hasSize(1);
			try (Connection connection = context.getBean(DataSource.class).getConnection()) {
				assertThat(connection.isValid(1000)).isTrue();
			}
		});
	}
	@Test
	void testDataSourcePropertiesOverridden() {
		this.contextRunner.withPropertyValues(PREFIX + 'url=jdbc:foo//bar/spam', PREFIX + 'max-idle-time=1234')
			.run((context) -> {
				PoolDataSourceImpl ds = context.getBean(PoolDataSourceImpl.class);
				assertThat(ds.getURL()).isEqualTo('jdbc:foo//bar/spam');
				assertThat(ds.getMaxIdleTime()).isEqualTo(1234);
			});
	}
	@Test
	void testDataSourceConnectionPropertiesOverridden() {
		this.contextRunner.withPropertyValues(PREFIX + 'connection-properties.autoCommit=false').run((context) -> {
			PoolDataSourceImpl ds = context.getBean(PoolDataSourceImpl.class);
			assertThat(ds.getConnectionProperty('autoCommit')).isEqualTo('false');
		});
	}
	@Test
	void testDataSourceDefaultsPreserved() {
		this.contextRunner.run((context) -> {
			PoolDataSourceImpl ds = context.getBean(PoolDataSourceImpl.class);
			assertThat(ds.getInitialPoolSize()).isZero();
			assertThat(ds.getMinPoolSize()).isOne();
			assertThat(ds.getMaxPoolSize()).isEqualTo(Integer.MAX_VALUE);
			assertThat(ds.getInactiveConnectionTimeout()).isZero();
			assertThat(ds.getConnectionWaitDuration()).isEqualTo(Duration.ofSeconds(3));
			assertThat(ds.getTimeToLiveConnectionTimeout()).isZero();
			assertThat(ds.getAbandonedConnectionTimeout()).isZero();
			assertThat(ds.getTimeoutCheckInterval()).isEqualTo(30);
			assertThat(ds.getFastConnectionFailoverEnabled()).isFalse();
		});
	}
	@Test
	void nameIsAliasedToPoolName() {
		this.contextRunner.withPropertyValues('spring.datasource.name=myDS').run((context) -> {
			PoolDataSourceImpl ds = context.getBean(PoolDataSourceImpl.class);
			assertThat(ds.getConnectionPoolName()).isEqualTo('myDS');
		});
	}
	@Test
	void poolNameTakesPrecedenceOverName() {
		this.contextRunner
			.withPropertyValues('spring.datasource.name=myDS', PREFIX + 'connection-pool-name=myOracleUcpDS')
			.run((context) -> {
				PoolDataSourceImpl ds = context.getBean(PoolDataSourceImpl.class);
				assertThat(ds.getConnectionPoolName()).isEqualTo('myOracleUcpDS');
			});
	}
	@Test
	void usesCustomJdbcConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(JdbcConnectionDetails.class, TestJdbcConnectionDetails::new)
			.withPropertyValues(PREFIX + 'url=jdbc:broken', PREFIX + 'username=alice', PREFIX + 'password=secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(JdbcConnectionDetails.class)
					.doesNotHaveBean(PropertiesJdbcConnectionDetails.class);
				DataSource dataSource = context.getBean(DataSource.class);
				assertThat(dataSource).isInstanceOf(PoolDataSourceImpl.class);
				PoolDataSourceImpl oracleUcp = (PoolDataSourceImpl) dataSource;
				assertThat(oracleUcp.getUser()).isEqualTo('user-1');
				assertThat(oracleUcp).extracting('password')
					.extracting((o) -> ((OpaqueString) o).get())
					.isEqualTo('password-1');
				assertThat(oracleUcp.getConnectionFactoryClassName())
					.isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
				assertThat(oracleUcp.getURL()).isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
			});
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class XADataSourceAutoConfigurationTests {
	@Test
	void wrapExistingXaDataSource() {
		ApplicationContext context = createContext(WrapExisting.class);
		context.getBean(DataSource.class);
		XADataSource source = context.getBean(XADataSource.class);
		MockXADataSourceWrapper wrapper = context.getBean(MockXADataSourceWrapper.class);
		assertThat(wrapper.getXaDataSource()).isEqualTo(source);
	}
	@Test
	void createFromUrl() {
		ApplicationContext context = createContext(FromProperties.class, 'spring.datasource.url:jdbc:hsqldb:mem:test',
				'spring.datasource.username:un');
		context.getBean(DataSource.class);
		MockXADataSourceWrapper wrapper = context.getBean(MockXADataSourceWrapper.class);
		JDBCXADataSource dataSource = (JDBCXADataSource) wrapper.getXaDataSource();
		assertThat(dataSource).isNotNull();
		assertThat(dataSource.getUrl()).isEqualTo('jdbc:hsqldb:mem:test');
		assertThat(dataSource.getUser()).isEqualTo('un');
	}
	@Test
	void createNonEmbeddedFromXAProperties() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(XADataSourceAutoConfiguration.class))
			.withUserConfiguration(FromProperties.class)
			.withClassLoader(new FilteredClassLoader('org.h2.Driver', 'org.hsqldb.jdbcDriver'))
			.withPropertyValues('spring.datasource.xa.data-source-class-name:com.ibm.db2.jcc.DB2XADataSource',
					'spring.datasource.xa.properties.user:test', 'spring.datasource.xa.properties.password:secret')
			.run((context) -> {
				MockXADataSourceWrapper wrapper = context.getBean(MockXADataSourceWrapper.class);
				XADataSource xaDataSource = wrapper.getXaDataSource();
				assertThat(xaDataSource).isInstanceOf(DB2XADataSource.class);
			});
	}
	@Test
	void createFromClass() throws Exception {
		ApplicationContext context = createContext(FromProperties.class,
				'spring.datasource.xa.data-source-class-name:org.hsqldb.jdbc.pool.JDBCXADataSource',
				'spring.datasource.xa.properties.login-timeout:123');
		context.getBean(DataSource.class);
		MockXADataSourceWrapper wrapper = context.getBean(MockXADataSourceWrapper.class);
		JDBCXADataSource dataSource = (JDBCXADataSource) wrapper.getXaDataSource();
		assertThat(dataSource).isNotNull();
		assertThat(dataSource.getLoginTimeout()).isEqualTo(123);
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(XADataSourceAutoConfiguration.class))
			.withUserConfiguration(FromProperties.class)
			.run((context) -> assertThat(context).hasSingleBean(PropertiesJdbcConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		JdbcConnectionDetails connectionDetails = mock(JdbcConnectionDetails.class);
		given(connectionDetails.getUsername()).willReturn('user-1');
		given(connectionDetails.getPassword()).willReturn('password-1');
		given(connectionDetails.getJdbcUrl()).willReturn('jdbc:postgresql://postgres.example.com:12345/database-1');
		given(connectionDetails.getDriverClassName()).willReturn(DatabaseDriver.POSTGRESQL.getDriverClassName());
		given(connectionDetails.getXaDataSourceClassName())
			.willReturn(DatabaseDriver.POSTGRESQL.getXaDataSourceClassName());
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(XADataSourceAutoConfiguration.class))
			.withUserConfiguration(FromProperties.class)
			.withBean(JdbcConnectionDetails.class, () -> connectionDetails)
			.run((context) -> {
				assertThat(context).hasSingleBean(JdbcConnectionDetails.class)
					.doesNotHaveBean(PropertiesJdbcConnectionDetails.class);
				MockXADataSourceWrapper wrapper = context.getBean(MockXADataSourceWrapper.class);
				PGXADataSource dataSource = (PGXADataSource) wrapper.getXaDataSource();
				assertThat(dataSource).isNotNull();
				assertThat(dataSource.getUrl()).startsWith('jdbc:postgresql://postgres.example.com:12345/database-1');
				assertThat(dataSource.getUser()).isEqualTo('user-1');
				assertThat(dataSource.getPassword()).isEqualTo('password-1');
			});
	}
	private ApplicationContext createContext(Class<?> configuration, String... env) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(env).applyTo(context);
		context.register(configuration, XADataSourceAutoConfiguration.class);
		context.refresh();
		return context;
	}
	@Configuration(proxyBeanMethods = false)
	static class WrapExisting {
		@Bean
		MockXADataSourceWrapper wrapper() {
			return new MockXADataSourceWrapper();
		}
		@Bean
		XADataSource xaDataSource() {
			return mock(XADataSource.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FromProperties {
		@Bean
		MockXADataSourceWrapper wrapper() {
			return new MockXADataSourceWrapper();
		}
	}
	static class MockXADataSourceWrapper implements XADataSourceWrapper {
		private XADataSource dataSource;
		@Override
		public DataSource wrapDataSource(XADataSource dataSource) {
			this.dataSource = dataSource;
			return mock(DataSource.class);
		}
		XADataSource getXaDataSource() {
			return this.dataSource;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class JndiDataSourceAutoConfigurationTests {
	private ClassLoader threadContextClassLoader;
	private String initialContextFactory;
	private AnnotationConfigApplicationContext context;
	@BeforeEach
	void setupJndi() {
		this.initialContextFactory = System.getProperty(Context.INITIAL_CONTEXT_FACTORY);
		System.setProperty(Context.INITIAL_CONTEXT_FACTORY, TestableInitialContextFactory.class.getName());
	}
	@BeforeEach
	void setupThreadContextClassLoader() {
		this.threadContextClassLoader = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(new JndiPropertiesHidingClassLoader(getClass().getClassLoader()));
	}
	@AfterEach
	void close() {
		TestableInitialContextFactory.clearAll();
		if (this.initialContextFactory != null) {
			System.setProperty(Context.INITIAL_CONTEXT_FACTORY, this.initialContextFactory);
		}
		else {
			System.clearProperty(Context.INITIAL_CONTEXT_FACTORY);
		}
		if (this.context != null) {
			this.context.close();
		}
		Thread.currentThread().setContextClassLoader(this.threadContextClassLoader);
	}
	@Test
	void dataSourceIsAvailableFromJndi() {
		DataSource dataSource = new BasicDataSource();
		configureJndi('foo', dataSource);
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.datasource.jndi-name:foo').applyTo(this.context);
		this.context.register(JndiDataSourceAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(DataSource.class)).isEqualTo(dataSource);
	}
	@SuppressWarnings('unchecked')
	@Test
	void mbeanDataSourceIsExcludedFromExport() {
		DataSource dataSource = new BasicDataSource();
		configureJndi('foo', dataSource);
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.datasource.jndi-name:foo').applyTo(this.context);
		this.context.register(JndiDataSourceAutoConfiguration.class, MBeanExporterConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(DataSource.class)).isEqualTo(dataSource);
		MBeanExporter exporter = this.context.getBean(MBeanExporter.class);
		Set<String> excludedBeans = (Set<String>) ReflectionTestUtils.getField(exporter, 'excludedBeans');
		assertThat(excludedBeans).containsExactly('dataSource');
	}
	@SuppressWarnings('unchecked')
	@Test
	void mbeanDataSourceIsExcludedFromExportByAllExporters() {
		DataSource dataSource = new BasicDataSource();
		configureJndi('foo', dataSource);
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.datasource.jndi-name:foo').applyTo(this.context);
		this.context.register(JndiDataSourceAutoConfiguration.class, MBeanExporterConfiguration.class,
				AnotherMBeanExporterConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(DataSource.class)).isEqualTo(dataSource);
		for (MBeanExporter exporter : this.context.getBeansOfType(MBeanExporter.class).values()) {
			Set<String> excludedBeans = (Set<String>) ReflectionTestUtils.getField(exporter, 'excludedBeans');
			assertThat(excludedBeans).containsExactly('dataSource');
		}
	}
	@SuppressWarnings('unchecked')
	@Test
	void standardDataSourceIsNotExcludedFromExport() {
		DataSource dataSource = mock(DataSource.class);
		configureJndi('foo', dataSource);
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.datasource.jndi-name:foo').applyTo(this.context);
		this.context.register(JndiDataSourceAutoConfiguration.class, MBeanExporterConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(DataSource.class)).isEqualTo(dataSource);
		MBeanExporter exporter = this.context.getBean(MBeanExporter.class);
		Set<String> excludedBeans = (Set<String>) ReflectionTestUtils.getField(exporter, 'excludedBeans');
		assertThat(excludedBeans).isEmpty();
	}
	private void configureJndi(String name, DataSource dataSource) {
		TestableInitialContextFactory.bind(name, dataSource);
	}
	@Configuration(proxyBeanMethods = false)
	static class MBeanExporterConfiguration {
		@Bean
		MBeanExporter mbeanExporter() {
			return new MBeanExporter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnotherMBeanExporterConfiguration {
		@Bean
		MBeanExporter anotherMbeanExporter() {
			return new MBeanExporter();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@Configuration(proxyBeanMethods = false)
class MultiDataSourceUsingPrimaryConfiguration {
	@Bean
	@Primary
	DataSource test1DataSource() {
		return new TestDataSource('test1', false);
	}
	@Bean
	DataSource test2DataSource() {
		return new TestDataSource('test2', false);
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class DataSourceJmxConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.datasource.url=jdbc:hsqldb:mem:test-' + UUID.randomUUID())
		.withConfiguration(AutoConfigurations.of(JmxAutoConfiguration.class, DataSourceAutoConfiguration.class));
	@Test
	void hikariAutoConfiguredCanUseRegisterMBeans() {
		String poolName = UUID.randomUUID().toString();
		this.contextRunner
			.withPropertyValues('spring.jmx.enabled=true', 'spring.datasource.type=' + HikariDataSource.class.getName(),
					'spring.datasource.name=' + poolName, 'spring.datasource.hikari.register-mbeans=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(HikariDataSource.class);
				HikariDataSource hikariDataSource = context.getBean(HikariDataSource.class);
				assertThat(hikariDataSource.isRegisterMbeans()).isTrue();
				// Ensure that the pool has been initialized, triggering MBean
				// registration
				hikariDataSource.getConnection().close();
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				validateHikariMBeansRegistration(mBeanServer, poolName, true);
			});
	}
	@Test
	void hikariAutoConfiguredWithoutDataSourceName() throws MalformedObjectNameException {
		MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
		Set<ObjectInstance> existingInstances = mBeanServer.queryMBeans(new ObjectName('com.zaxxer.hikari:type=*'),
				null);
		this.contextRunner
			.withPropertyValues('spring.datasource.type=' + HikariDataSource.class.getName(),
					'spring.datasource.hikari.register-mbeans=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(HikariDataSource.class);
				HikariDataSource hikariDataSource = context.getBean(HikariDataSource.class);
				assertThat(hikariDataSource.isRegisterMbeans()).isTrue();
				// Ensure that the pool has been initialized, triggering MBean
				// registration
				hikariDataSource.getConnection().close();
				// We can"t rely on the number of MBeans so we"re checking that the
				// pool and pool config MBeans were registered
				assertThat(mBeanServer.queryMBeans(new ObjectName('com.zaxxer.hikari:type=*'), null))
					.hasSize(existingInstances.size() + 2);
			});
	}
	@Test
	void hikariAutoConfiguredUsesJmxFlag() {
		String poolName = UUID.randomUUID().toString();
		this.contextRunner
			.withPropertyValues('spring.datasource.type=' + HikariDataSource.class.getName(),
					'spring.jmx.enabled=false', 'spring.datasource.name=' + poolName,
					'spring.datasource.hikari.register-mbeans=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(HikariDataSource.class);
				HikariDataSource hikariDataSource = context.getBean(HikariDataSource.class);
				assertThat(hikariDataSource.isRegisterMbeans()).isTrue();
				// Ensure that the pool has been initialized, triggering MBean
				// registration
				hikariDataSource.getConnection().close();
				// Hikari can still register mBeans
				validateHikariMBeansRegistration(ManagementFactory.getPlatformMBeanServer(), poolName, true);
			});
	}
	@Test
	void hikariProxiedCanUseRegisterMBeans() {
		String poolName = UUID.randomUUID().toString();
		this.contextRunner.withUserConfiguration(DataSourceProxyConfiguration.class)
			.withPropertyValues('spring.jmx.enabled=true', 'spring.datasource.type=' + HikariDataSource.class.getName(),
					'spring.datasource.name=' + poolName, 'spring.datasource.hikari.register-mbeans=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(javax.sql.DataSource.class);
				HikariDataSource hikariDataSource = context.getBean(javax.sql.DataSource.class)
					.unwrap(HikariDataSource.class);
				assertThat(hikariDataSource.isRegisterMbeans()).isTrue();
				// Ensure that the pool has been initialized, triggering MBean
				// registration
				hikariDataSource.getConnection().close();
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				validateHikariMBeansRegistration(mBeanServer, poolName, true);
			});
	}
	private void validateHikariMBeansRegistration(MBeanServer mBeanServer, String poolName, boolean expected)
			throws MalformedObjectNameException {
		assertThat(mBeanServer.isRegistered(new ObjectName('com.zaxxer.hikari:type=Pool (' + poolName + ')')))
			.isEqualTo(expected);
		assertThat(mBeanServer.isRegistered(new ObjectName('com.zaxxer.hikari:type=PoolConfig (' + poolName + ')')))
			.isEqualTo(expected);
	}
	@Test
	void tomcatDoesNotExposeMBeanPoolByDefault() {
		this.contextRunner.withPropertyValues('spring.datasource.type=' + DataSource.class.getName())
			.run((context) -> assertThat(context).doesNotHaveBean(ConnectionPool.class));
	}
	@Test
	void tomcatAutoConfiguredCanExposeMBeanPool() {
		this.contextRunner
			.withPropertyValues('spring.datasource.type=' + DataSource.class.getName(),
					'spring.datasource.tomcat.jmx-enabled=true')
			.run((context) -> {
				assertThat(context).hasBean('dataSourceMBean');
				assertThat(context).hasSingleBean(ConnectionPool.class);
				assertThat(context.getBean(DataSourceProxy.class).createPool().getJmxPool())
					.isSameAs(context.getBean(ConnectionPool.class));
			});
	}
	@Test
	void tomcatProxiedCanExposeMBeanPool() {
		this.contextRunner.withUserConfiguration(DataSourceProxyConfiguration.class)
			.withPropertyValues('spring.datasource.type=' + DataSource.class.getName(),
					'spring.datasource.tomcat.jmx-enabled=true')
			.run((context) -> {
				assertThat(context).hasBean('dataSourceMBean');
				assertThat(context).getBean('dataSourceMBean').isInstanceOf(ConnectionPool.class);
			});
	}
	@Test
	void tomcatDelegateCanExposeMBeanPool() {
		this.contextRunner.withUserConfiguration(DataSourceDelegateConfiguration.class)
			.withPropertyValues('spring.datasource.type=' + DataSource.class.getName(),
					'spring.datasource.tomcat.jmx-enabled=true')
			.run((context) -> {
				assertThat(context).hasBean('dataSourceMBean');
				assertThat(context).getBean('dataSourceMBean').isInstanceOf(ConnectionPool.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class DataSourceProxyConfiguration {
		@Bean
		static DataSourceBeanPostProcessor dataSourceBeanPostProcessor() {
			return new DataSourceBeanPostProcessor();
		}
	}
	static class DataSourceBeanPostProcessor implements BeanPostProcessor {
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) {
			if (bean instanceof javax.sql.DataSource) {
				return new ProxyFactory(bean).getProxy();
			}
			return bean;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataSourceDelegateConfiguration {
		@Bean
		static DataSourceBeanPostProcessor dataSourceBeanPostProcessor() {
			return new DataSourceBeanPostProcessor() {
				@Override
				public Object postProcessAfterInitialization(Object bean, String beanName) {
					return (bean instanceof javax.sql.DataSource)
							? new DelegatingDataSource((javax.sql.DataSource) bean) : bean;
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class DataSourceJsonSerializationTests {
	@Test
	void serializerFactory() throws Exception {
		DataSource dataSource = new DataSource();
		SerializerFactory factory = BeanSerializerFactory.instance
			.withSerializerModifier(new GenericSerializerModifier());
		ObjectMapper mapper = new ObjectMapper();
		mapper.setSerializerFactory(factory);
		String value = mapper.writeValueAsString(dataSource);
		assertThat(value).contains('\'url\':');
	}
	@Test
	void serializerWithMixin() throws Exception {
		DataSource dataSource = new DataSource();
		ObjectMapper mapper = new ObjectMapper();
		mapper.addMixIn(DataSource.class, DataSourceJson.class);
		String value = mapper.writeValueAsString(dataSource);
		assertThat(value).contains('\'url\':');
		assertThat(StringUtils.countOccurrencesOf(value, '\'url\'')).isOne();
	}
	@JsonSerialize(using = TomcatDataSourceSerializer.class)
	interface DataSourceJson {
	}
	static class TomcatDataSourceSerializer extends JsonSerializer<DataSource> {
		private final ConversionService conversionService = new DefaultConversionService();
		@Override
		public void serialize(DataSource value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
			jgen.writeStartObject();
			for (PropertyDescriptor property : BeanUtils.getPropertyDescriptors(DataSource.class)) {
				Method reader = property.getReadMethod();
				if (reader != null && property.getWriteMethod() != null
						&& this.conversionService.canConvert(String.class, property.getPropertyType())) {
					jgen.writeObjectField(property.getName(), ReflectionUtils.invokeMethod(reader, value));
				}
			}
			jgen.writeEndObject();
		}
	}
	static class GenericSerializerModifier extends BeanSerializerModifier {
		private final ConversionService conversionService = new DefaultConversionService();
		@Override
		public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BeanDescription beanDesc,
				List<BeanPropertyWriter> beanProperties) {
			List<BeanPropertyWriter> result = new ArrayList<>();
			for (BeanPropertyWriter writer : beanProperties) {
				AnnotatedMethod setter = beanDesc.findMethod('set' + StringUtils.capitalize(writer.getName()),
						new Class<?>[] { writer.getType().getRawClass() });
				if (setter != null && this.conversionService.canConvert(String.class, writer.getType().getRawClass())) {
					result.add(writer);
				}
			}
			return result;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class HikariDataSourceConfigurationTests {
	private static final String PREFIX = 'spring.datasource.hikari.';
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
		.withPropertyValues('spring.datasource.type=' + HikariDataSource.class.getName());
	@Test
	void testDataSourceExists() {
		this.contextRunner.run((context) -> {
			assertThat(context.getBeansOfType(DataSource.class)).hasSize(1);
			assertThat(context.getBeansOfType(HikariDataSource.class)).hasSize(1);
		});
	}
	@Test
	void testDataSourcePropertiesOverridden() {
		this.contextRunner
			.withPropertyValues(PREFIX + 'jdbc-url=jdbc:foo//bar/spam', 'spring.datasource.hikari.max-lifetime=1234')
			.run((context) -> {
				HikariDataSource ds = context.getBean(HikariDataSource.class);
				assertThat(ds.getJdbcUrl()).isEqualTo('jdbc:foo//bar/spam');
				assertThat(ds.getMaxLifetime()).isEqualTo(1234);
			});
	}
	@Test
	void testDataSourceGenericPropertiesOverridden() {
		this.contextRunner
			.withPropertyValues(PREFIX + 'data-source-properties.dataSourceClassName=org.h2.JDBCDataSource')
			.run((context) -> {
				HikariDataSource ds = context.getBean(HikariDataSource.class);
				assertThat(ds.getDataSourceProperties().getProperty('dataSourceClassName'))
					.isEqualTo('org.h2.JDBCDataSource');
			});
	}
	@Test
	void testDataSourceDefaultsPreserved() {
		this.contextRunner.run((context) -> {
			HikariDataSource ds = context.getBean(HikariDataSource.class);
			assertThat(ds.getMaxLifetime()).isEqualTo(1800000);
		});
	}
	@Test
	void nameIsAliasedToPoolName() {
		this.contextRunner.withPropertyValues('spring.datasource.name=myDS').run((context) -> {
			HikariDataSource ds = context.getBean(HikariDataSource.class);
			assertThat(ds.getPoolName()).isEqualTo('myDS');
		});
	}
	@Test
	void poolNameTakesPrecedenceOverName() {
		this.contextRunner.withPropertyValues('spring.datasource.name=myDS', PREFIX + 'pool-name=myHikariDS')
			.run((context) -> {
				HikariDataSource ds = context.getBean(HikariDataSource.class);
				assertThat(ds.getPoolName()).isEqualTo('myHikariDS');
			});
	}
	@Test
	void usesCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(JdbcConnectionDetails.class, TestJdbcConnectionDetails::new)
			.withPropertyValues(PREFIX + 'url=jdbc:broken', PREFIX + 'username=alice', PREFIX + 'password=secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(JdbcConnectionDetails.class)
					.doesNotHaveBean(PropertiesJdbcConnectionDetails.class);
				DataSource dataSource = context.getBean(DataSource.class);
				assertThat(dataSource).asInstanceOf(InstanceOfAssertFactories.type(HikariDataSource.class))
					.satisfies((hikari) -> {
						assertThat(hikari.getUsername()).isEqualTo('user-1');
						assertThat(hikari.getPassword()).isEqualTo('password-1');
						assertThat(hikari.getDriverClassName()).isEqualTo('org.postgresql.Driver');
						assertThat(hikari.getJdbcUrl())
							.isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
					});
			});
	}
	@Test
	@ClassPathOverrides('org.crac:crac:1.3.0')
	void whenCheckpointRestoreIsAvailableHikariAutoConfigRegistersLifecycleBean() {
		this.contextRunner.withPropertyValues('spring.datasource.type=' + HikariDataSource.class.getName())
			.run((context) -> assertThat(context).hasSingleBean(HikariCheckpointRestoreLifecycle.class));
	}
	@Test
	@ClassPathOverrides('org.crac:crac:1.3.0')
	void whenCheckpointRestoreIsAvailableAndDataSourceHasBeenWrappedHikariAutoConfigRegistersLifecycleBean() {
		this.contextRunner.withUserConfiguration(DataSourceWrapperConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(HikariCheckpointRestoreLifecycle.class));
	}
	@Test
	void whenCheckpointRestoreIsNotAvailableHikariAutoConfigDoesNotRegisterLifecycleBean() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(HikariCheckpointRestoreLifecycle.class));
	}
	@Test
	@ClassPathOverrides('org.crac:crac:1.3.0')
	void whenCheckpointRestoreIsAvailableAndDataSourceIsFromUserConfigurationHikariAutoConfigRegistersLifecycleBean() {
		this.contextRunner.withUserConfiguration(UserDataSourceConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(HikariCheckpointRestoreLifecycle.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		JdbcConnectionDetails sqlConnectionDetails() {
			return new TestJdbcConnectionDetails();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataSourceWrapperConfiguration {
		@Bean
		static BeanPostProcessor dataSourceWrapper() {
			return new BeanPostProcessor() {
				@Override
				public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
					if (bean instanceof DataSource dataSource) {
						return new DelegatingDataSource(dataSource);
					}
					return bean;
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDataSourceConfiguration {
		@Bean
		DataSource dataSource() {
			return DataSourceBuilder.create()
				.driverClassName('org.postgresql.Driver')
				.url('jdbc:postgresql://localhost:5432/database')
				.username('user')
				.password('password')
				.build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class DataSourceAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
		.withPropertyValues('spring.datasource.url:jdbc:hsqldb:mem:testdb-' + new Random().nextInt());
	@Test
	void testDefaultDataSourceExists() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(DataSource.class));
	}
	@Test
	void testDataSourceHasEmbeddedDefault() {
		this.contextRunner.run((context) -> {
			HikariDataSource dataSource = context.getBean(HikariDataSource.class);
			assertThat(dataSource.getJdbcUrl()).isNotNull();
			assertThat(dataSource.getDriverClassName()).isNotNull();
		});
	}
	@Test
	void testBadUrl() {
		this.contextRunner.withPropertyValues('spring.datasource.url:jdbc:not-going-to-work')
			.withClassLoader(new DisableEmbeddedDatabaseClassLoader())
			.run((context) -> assertThat(context).getFailure().isInstanceOf(BeanCreationException.class));
	}
	@Test
	void testBadDriverClass() {
		this.contextRunner.withPropertyValues('spring.datasource.driverClassName:org.none.jdbcDriver')
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('org.none.jdbcDriver'));
	}
	@Test
	void datasourceWhenConnectionFactoryPresentIsNotAutoConfigured() {
		this.contextRunner.withBean(ConnectionFactory.class, () -> mock(ConnectionFactory.class))
			.run((context) -> assertThat(context).doesNotHaveBean(DataSource.class));
	}
	@Test
	void hikariValidatesConnectionByDefault() {
		assertDataSource(HikariDataSource.class, Collections.singletonList('org.apache.tomcat'), (dataSource) ->
		// Use Connection#isValid()
		assertThat(dataSource.getConnectionTestQuery()).isNull());
	}
	@Test
	void tomcatIsFallback() {
		assertDataSource(org.apache.tomcat.jdbc.pool.DataSource.class, Collections.singletonList('com.zaxxer.hikari'),
				(dataSource) -> assertThat(dataSource.getUrl()).startsWith('jdbc:hsqldb:mem:testdb'));
	}
	@Test
	void tomcatValidatesConnectionByDefault() {
		assertDataSource(org.apache.tomcat.jdbc.pool.DataSource.class, Collections.singletonList('com.zaxxer.hikari'),
				(dataSource) -> {
					assertThat(dataSource.isTestOnBorrow()).isTrue();
					assertThat(dataSource.getValidationQuery()).isEqualTo(DatabaseDriver.HSQLDB.getValidationQuery());
				});
	}
	@Test
	void commonsDbcp2IsFallback() {
		assertDataSource(BasicDataSource.class, Arrays.asList('com.zaxxer.hikari', 'org.apache.tomcat'),
				(dataSource) -> assertThat(dataSource.getUrl()).startsWith('jdbc:hsqldb:mem:testdb'));
	}
	@Test
	void commonsDbcp2ValidatesConnectionByDefault() {
		assertDataSource(org.apache.commons.dbcp2.BasicDataSource.class,
				Arrays.asList('com.zaxxer.hikari', 'org.apache.tomcat'), (dataSource) -> {
					assertThat(dataSource.getTestOnBorrow()).isTrue();
					// Use Connection#isValid()
					assertThat(dataSource.getValidationQuery()).isNull();
				});
	}
	@Test
	void oracleUcpIsFallback() {
		assertDataSource(PoolDataSourceImpl.class,
				Arrays.asList('com.zaxxer.hikari', 'org.apache.tomcat', 'org.apache.commons.dbcp2'),
				(dataSource) -> assertThat(dataSource.getURL()).startsWith('jdbc:hsqldb:mem:testdb'));
	}
	@Test
	void oracleUcpDoesNotValidateConnectionByDefault() {
		assertDataSource(PoolDataSourceImpl.class,
				Arrays.asList('com.zaxxer.hikari', 'org.apache.tomcat', 'org.apache.commons.dbcp2'), (dataSource) -> {
					assertThat(dataSource.getValidateConnectionOnBorrow()).isFalse();
					// Use an internal ping when using an Oracle JDBC driver
					assertThat(dataSource.getSQLForValidateConnection()).isNull();
				});
	}
	@Test
	@SuppressWarnings('resource')
	void testEmbeddedTypeDefaultsUsername() {
		this.contextRunner
			.withPropertyValues('spring.datasource.driverClassName:org.hsqldb.jdbcDriver',
					'spring.datasource.url:jdbc:hsqldb:mem:testdb')
			.run((context) -> {
				DataSource bean = context.getBean(DataSource.class);
				HikariDataSource pool = (HikariDataSource) bean;
				assertThat(pool.getDriverClassName()).isEqualTo('org.hsqldb.jdbcDriver');
				assertThat(pool.getUsername()).isEqualTo('sa');
			});
	}
	@Test
	void dataSourceWhenNoConnectionPoolsAreAvailableWithUrlDoesNotCreateDataSource() {
		this.contextRunner.with(hideConnectionPools())
			.withPropertyValues('spring.datasource.url:jdbc:hsqldb:mem:testdb')
			.run((context) -> assertThat(context).doesNotHaveBean(DataSource.class));
	}
	/**
	 * This test makes sure that if no supported data source is present, a datasource is
	 * still created if 'spring.datasource.type' is present.
	 */
	@Test
	void dataSourceWhenNoConnectionPoolsAreAvailableWithUrlAndTypeCreatesDataSource() {
		this.contextRunner.with(hideConnectionPools())
			.withPropertyValues('spring.datasource.driverClassName:org.hsqldb.jdbcDriver',
					'spring.datasource.url:jdbc:hsqldb:mem:testdb',
					'spring.datasource.type:' + SimpleDriverDataSource.class.getName())
			.run(this::containsOnlySimpleDriverDataSource);
	}
	@Test
	void explicitTypeSupportedDataSource() {
		this.contextRunner
			.withPropertyValues('spring.datasource.driverClassName:org.hsqldb.jdbcDriver',
					'spring.datasource.url:jdbc:hsqldb:mem:testdb',
					'spring.datasource.type:' + SimpleDriverDataSource.class.getName())
			.run(this::containsOnlySimpleDriverDataSource);
	}
	private void containsOnlySimpleDriverDataSource(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(DataSource.class);
		assertThat(context).getBean(DataSource.class).isExactlyInstanceOf(SimpleDriverDataSource.class);
	}
	@Test
	void testExplicitDriverClassClearsUsername() {
		this.contextRunner
			.withPropertyValues('spring.datasource.driverClassName:' + DatabaseTestDriver.class.getName(),
					'spring.datasource.url:jdbc:foo://localhost')
			.run((context) -> {
				assertThat(context).hasSingleBean(DataSource.class);
				HikariDataSource dataSource = context.getBean(HikariDataSource.class);
				assertThat(dataSource.getDriverClassName()).isEqualTo(DatabaseTestDriver.class.getName());
				assertThat(dataSource.getUsername()).isNull();
			});
	}
	@Test
	void testDefaultDataSourceCanBeOverridden() {
		this.contextRunner.withUserConfiguration(TestDataSourceConfiguration.class)
			.run((context) -> assertThat(context).getBean(DataSource.class).isInstanceOf(BasicDataSource.class));
	}
	@Test
	void whenThereIsAUserProvidedDataSourceAnUnresolvablePlaceholderDoesNotCauseAProblem() {
		this.contextRunner.withUserConfiguration(TestDataSourceConfiguration.class)
			.withPropertyValues('spring.datasource.url:${UNRESOLVABLE_'}')
			.run((context) -> assertThat(context).getBean(DataSource.class).isInstanceOf(BasicDataSource.class));
	}
	@Test
	void whenThereIsAnEmptyUserProvidedDataSource() {
		this.contextRunner.with(hideConnectionPools())
			.withPropertyValues('spring.datasource.url:')
			.run((context) -> assertThat(context).getBean(DataSource.class).isInstanceOf(EmbeddedDatabase.class));
	}
	@Test
	void whenNoInitializationRelatedSpringDataSourcePropertiesAreConfiguredThenInitializationBacksOff() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(DataSourceScriptDatabaseInitializer.class));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesJdbcConnectionDetails.class));
	}
	@Test
	void dbcp2UsesCustomConnectionDetailsWhenDefined() {
		ApplicationContextRunner runner = new ApplicationContextRunner()
			.withPropertyValues('spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource',
					'spring.datasource.dbcp2.url=jdbc:broken', 'spring.datasource.dbcp2.username=alice',
					'spring.datasource.dbcp2.password=secret')
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withBean(JdbcConnectionDetails.class, TestJdbcConnectionDetails::new);
		runner.run((context) -> {
			assertThat(context).hasSingleBean(JdbcConnectionDetails.class)
				.doesNotHaveBean(PropertiesJdbcConnectionDetails.class);
			DataSource dataSource = context.getBean(DataSource.class);
			assertThat(dataSource).asInstanceOf(InstanceOfAssertFactories.type(BasicDataSource.class))
				.satisfies((dbcp2) -> {
					assertThat(dbcp2.getUserName()).isEqualTo('user-1');
					assertThat(dbcp2).extracting('password').isEqualTo('password-1');
					assertThat(dbcp2.getDriverClassName()).isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
					assertThat(dbcp2.getUrl()).isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
				});
		});
	}
	@Test
	void genericUsesCustomJdbcConnectionDetailsWhenAvailable() {
		ApplicationContextRunner runner = new ApplicationContextRunner()
			.withPropertyValues('spring.datasource.type=' + TestDataSource.class.getName())
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withBean(JdbcConnectionDetails.class, TestJdbcConnectionDetails::new);
		runner.run((context) -> {
			assertThat(context).hasSingleBean(JdbcConnectionDetails.class)
				.doesNotHaveBean(PropertiesJdbcConnectionDetails.class);
			DataSource dataSource = context.getBean(DataSource.class);
			assertThat(dataSource).isInstanceOf(TestDataSource.class);
			TestDataSource source = (TestDataSource) dataSource;
			assertThat(source.getUsername()).isEqualTo('user-1');
			assertThat(source.getPassword()).isEqualTo('password-1');
			assertThat(source.getDriver().getClass().getName())
				.isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
			assertThat(source.getUrl()).isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
		});
	}
	private static Function<ApplicationContextRunner, ApplicationContextRunner> hideConnectionPools() {
		return (runner) -> runner.withClassLoader(new FilteredClassLoader('org.apache.tomcat', 'com.zaxxer.hikari',
				'org.apache.commons.dbcp2', 'oracle.ucp.jdbc', 'com.mchange'));
	}
	private <T extends DataSource> void assertDataSource(Class<T> expectedType, List<String> hiddenPackages,
			Consumer<T> consumer) {
		FilteredClassLoader classLoader = new FilteredClassLoader(StringUtils.toStringArray(hiddenPackages));
		this.contextRunner.withClassLoader(classLoader).run((context) -> {
			DataSource bean = context.getBean(DataSource.class);
			assertThat(bean).isInstanceOf(expectedType);
			consumer.accept(expectedType.cast(bean));
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class JdbcConnectionDetailsConfiguration {
		@Bean
		JdbcConnectionDetails sqlJdbcConnectionDetails() {
			return new TestJdbcConnectionDetails();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestDataSourceConfiguration {
		private BasicDataSource pool;
		@Bean
		DataSource dataSource() {
			this.pool = new BasicDataSource();
			this.pool.setDriverClassName('org.hsqldb.jdbcDriver');
			this.pool.setUrl('jdbc:hsqldb:mem:overridedb');
			this.pool.setUsername('sa');
			return this.pool;
		}
	}
	// see testExplicitDriverClassClearsUsername
	public static class DatabaseTestDriver implements Driver {
		@Override
		public Connection connect(String url, Properties info) {
			return mock(Connection.class);
		}
		@Override
		public boolean acceptsURL(String url) {
			return true;
		}
		@Override
		public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) {
			return new DriverPropertyInfo[0];
		}
		@Override
		public int getMajorVersion() {
			return 1;
		}
		@Override
		public int getMinorVersion() {
			return 0;
		}
		@Override
		public boolean jdbcCompliant() {
			return false;
		}
		@Override
		public Logger getParentLogger() {
			return mock(Logger.class);
		}
	}
	static class DisableEmbeddedDatabaseClassLoader extends URLClassLoader {
		DisableEmbeddedDatabaseClassLoader() {
			super(new URL[0], DisableEmbeddedDatabaseClassLoader.class.getClassLoader());
		}
		@Override
		protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
			for (EmbeddedDatabaseConnection candidate : EmbeddedDatabaseConnection.values()) {
				if (name.equals(candidate.getDriverClassName())) {
					throw new ClassNotFoundException();
				}
			}
			return super.loadClass(name, resolve);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class TomcatDataSourceConfigurationTests {
	private static final String PREFIX = 'spring.datasource.tomcat.';
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
		.withPropertyValues('spring.datasource.type=' + org.apache.tomcat.jdbc.pool.DataSource.class.getName());
	@BeforeEach
	void init() {
		TestPropertyValues.of(PREFIX + 'initialize:false').applyTo(this.context);
	}
	@Test
	void testDataSourceExists() {
		this.context.register(TomcatDataSourceConfiguration.class);
		TestPropertyValues.of(PREFIX + 'url:jdbc:h2:mem:testdb').applyTo(this.context);
		this.context.refresh();
		assertThat(this.context.getBean(DataSource.class)).isNotNull();
		assertThat(this.context.getBean(org.apache.tomcat.jdbc.pool.DataSource.class)).isNotNull();
	}
	@Test
	void testDataSourcePropertiesOverridden() throws Exception {
		this.context.register(TomcatDataSourceConfiguration.class);
		TestPropertyValues
			.of(PREFIX + 'url:jdbc:h2:mem:testdb', PREFIX + 'testWhileIdle:true', PREFIX + 'testOnBorrow:true',
					PREFIX + 'testOnReturn:true', PREFIX + 'timeBetweenEvictionRunsMillis:10000',
					PREFIX + 'minEvictableIdleTimeMillis:12345', PREFIX + 'maxWait:1234',
					PREFIX + 'jdbcInterceptors:SlowQueryReport', PREFIX + 'validationInterval:9999')
			.applyTo(this.context);
		this.context.refresh();
		org.apache.tomcat.jdbc.pool.DataSource ds = this.context.getBean(org.apache.tomcat.jdbc.pool.DataSource.class);
		assertThat(ds.getUrl()).isEqualTo('jdbc:h2:mem:testdb');
		assertThat(ds.isTestWhileIdle()).isTrue();
		assertThat(ds.isTestOnBorrow()).isTrue();
		assertThat(ds.isTestOnReturn()).isTrue();
		assertThat(ds.getTimeBetweenEvictionRunsMillis()).isEqualTo(10000);
		assertThat(ds.getMinEvictableIdleTimeMillis()).isEqualTo(12345);
		assertThat(ds.getMaxWait()).isEqualTo(1234);
		assertThat(ds.getValidationInterval()).isEqualTo(9999L);
		assertDataSourceHasInterceptors(ds);
	}
	private void assertDataSourceHasInterceptors(DataSourceProxy ds) throws ClassNotFoundException {
		PoolProperties.InterceptorDefinition[] interceptors = ds.getJdbcInterceptorsAsArray();
		for (PoolProperties.InterceptorDefinition interceptor : interceptors) {
			if (SlowQueryReport.class == interceptor.getInterceptorClass()) {
				return;
			}
		}
		fail('SlowQueryReport interceptor should have been set.');
	}
	@Test
	void testDataSourceDefaultsPreserved() {
		this.context.register(TomcatDataSourceConfiguration.class);
		TestPropertyValues.of(PREFIX + 'url:jdbc:h2:mem:testdb').applyTo(this.context);
		this.context.refresh();
		org.apache.tomcat.jdbc.pool.DataSource ds = this.context.getBean(org.apache.tomcat.jdbc.pool.DataSource.class);
		assertThat(ds.getTimeBetweenEvictionRunsMillis()).isEqualTo(5000);
		assertThat(ds.getMinEvictableIdleTimeMillis()).isEqualTo(60000);
		assertThat(ds.getMaxWait()).isEqualTo(30000);
		assertThat(ds.getValidationInterval()).isEqualTo(3000L);
	}
	@Test
	void usesCustomJdbcConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(JdbcConnectionDetails.class, TestJdbcConnectionDetails::new)
			.withPropertyValues(PREFIX + 'url=jdbc:broken', PREFIX + 'username=alice', PREFIX + 'password=secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(JdbcConnectionDetails.class)
					.doesNotHaveBean(PropertiesJdbcConnectionDetails.class);
				DataSource dataSource = context.getBean(DataSource.class);
				assertThat(dataSource).isInstanceOf(org.apache.tomcat.jdbc.pool.DataSource.class);
				org.apache.tomcat.jdbc.pool.DataSource tomcat = (org.apache.tomcat.jdbc.pool.DataSource) dataSource;
				assertThat(tomcat.getPoolProperties().getUsername()).isEqualTo('user-1');
				assertThat(tomcat.getPoolProperties().getPassword()).isEqualTo('password-1');
				assertThat(tomcat.getPoolProperties().getDriverClassName())
					.isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
				assertThat(tomcat.getPoolProperties().getUrl())
					.isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
			});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties
	@EnableMBeanExport
	static class TomcatDataSourceConfiguration {
		@Bean
		@ConfigurationProperties(prefix = 'spring.datasource.tomcat')
		DataSource dataSource() {
			return DataSourceBuilder.create().type(org.apache.tomcat.jdbc.pool.DataSource.class).build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class JdbcClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.datasource.generate-unique-name=true')
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class, JdbcTemplateAutoConfiguration.class,
				JdbcClientAutoConfiguration.class));
	@Test
	void jdbcClientWhenNoAvailableJdbcTemplateIsNotCreated() {
		new ApplicationContextRunner()
			.withConfiguration(
					AutoConfigurations.of(DataSourceAutoConfiguration.class, JdbcClientAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(JdbcClient.class));
	}
	@Test
	void jdbcClientWhenExistingJdbcTemplateIsCreated() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(JdbcClient.class);
			NamedParameterJdbcTemplate namedParameterJdbcTemplate = context.getBean(NamedParameterJdbcTemplate.class);
			assertThat(namedParameterJdbcTemplate.getJdbcOperations()).isEqualTo(context.getBean(JdbcOperations.class));
		});
	}
	@Test
	void jdbcClientWithCustomJdbcClientIsNotCreated() {
		this.contextRunner.withBean('customJdbcClient', JdbcClient.class, () -> mock(JdbcClient.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(JdbcClient.class);
				assertThat(context.getBean(JdbcClient.class)).isEqualTo(context.getBean('customJdbcClient'));
			});
	}
	@Test
	void jdbcClientIsOrderedAfterFlywayMigration() {
		this.contextRunner.withUserConfiguration(JdbcClientDataSourceMigrationValidator.class)
			.withPropertyValues('spring.flyway.locations:classpath:db/city')
			.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasNotFailed().hasSingleBean(JdbcClient.class);
				assertThat(context.getBean(JdbcClientDataSourceMigrationValidator.class).count).isZero();
			});
	}
	@Test
	void jdbcClientIsOrderedAfterLiquibaseMigration() {
		this.contextRunner.withUserConfiguration(JdbcClientDataSourceMigrationValidator.class)
			.withPropertyValues('spring.liquibase.change-log:classpath:db/changelog/db.changelog-city.yaml')
			.withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasNotFailed().hasSingleBean(JdbcClient.class);
				assertThat(context.getBean(JdbcClientDataSourceMigrationValidator.class).count).isZero();
			});
	}
	static class JdbcClientDataSourceMigrationValidator {
		private final Long count;
		JdbcClientDataSourceMigrationValidator(JdbcClient jdbcClient) {
			this.count = jdbcClient.sql('SELECT COUNT(*) from CITY').query(Long.class).single();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class OracleUcpJdbcConnectionDetailsBeanPostProcessorTests {
	@Test
	void setUsernamePasswordUrlAndDriverClassName() throws SQLException {
		PoolDataSourceImpl dataSource = new PoolDataSourceImpl();
		dataSource.setURL('will-be-overwritten');
		dataSource.setUser('will-be-overwritten');
		dataSource.setPassword('will-be-overwritten');
		dataSource.setConnectionFactoryClassName('will-be-overwritten');
		new OracleUcpJdbcConnectionDetailsBeanPostProcessor(null).processDataSource(dataSource,
				new TestJdbcConnectionDetails());
		assertThat(dataSource.getURL()).isEqualTo('jdbc:customdb://customdb.example.com:12345/database-1');
		assertThat(dataSource.getUser()).isEqualTo('user-1');
		assertThat(dataSource).extracting('password')
			.extracting((password) -> ((OpaqueString) password).get())
			.isEqualTo('password-1');
		assertThat(dataSource.getConnectionFactoryClassName())
			.isEqualTo(DatabaseDriver.POSTGRESQL.getDriverClassName());
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
@EnabledForJreRange(min = JRE.JAVA_17, max = JRE.JAVA_22,
		disabledReason = 'https://issues.apache.org/jira/browse/ARTEMIS-4975')
class ArtemisAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ArtemisAutoConfiguration.class, JmsAutoConfiguration.class));
	@Test
	void connectionFactoryIsCachedByDefault() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ConnectionFactory.class)
				.hasSingleBean(CachingConnectionFactory.class)
				.hasBean('jmsConnectionFactory');
			CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
			assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
			assertThat(connectionFactory.getTargetConnectionFactory()).isInstanceOf(ActiveMQConnectionFactory.class);
			assertThat(connectionFactory.isCacheConsumers()).isFalse();
			assertThat(connectionFactory.isCacheProducers()).isTrue();
			assertThat(connectionFactory.getSessionCacheSize()).isOne();
		});
	}
	@Test
	void connectionFactoryCachingCanBeCustomized() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.jms.cache.consumers=true', 'spring.jms.cache.producers=false',
					'spring.jms.cache.session-cache-size=10')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(CachingConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
				assertThat(connectionFactory.isCacheConsumers()).isTrue();
				assertThat(connectionFactory.isCacheProducers()).isFalse();
				assertThat(connectionFactory.getSessionCacheSize()).isEqualTo(10);
			});
	}
	@Test
	void connectionFactoryCachingCanBeDisabled() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.jms.cache.enabled=false')
			.run((context) -> {
				assertThat(context).doesNotHaveBean(CachingConnectionFactory.class);
				ConnectionFactory connectionFactory = getConnectionFactory(context);
				assertThat(connectionFactory).isInstanceOf(ActiveMQConnectionFactory.class);
			});
	}
	@Test
	void nativeConnectionFactory() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.mode:native')
			.run((context) -> {
				JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
				ConnectionFactory connectionFactory = getConnectionFactory(context);
				assertThat(connectionFactory).isEqualTo(jmsTemplate.getConnectionFactory());
				ActiveMQConnectionFactory activeMQConnectionFactory = getActiveMQConnectionFactory(connectionFactory);
				assertNettyConnectionFactory(activeMQConnectionFactory, 'localhost', 61616);
				assertThat(activeMQConnectionFactory.getUser()).isNull();
				assertThat(activeMQConnectionFactory.getPassword()).isNull();
			});
	}
	@Test
	void nativeConnectionFactoryCustomBrokerUrl() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.mode:native', 'spring.artemis.broker-url:tcp://192.168.1.144:9876')
			.run((context) -> assertNettyConnectionFactory(getActiveMQConnectionFactory(getConnectionFactory(context)),
					'192.168.1.144', 9876));
	}
	@Test
	void nativeConnectionFactoryCredentials() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.mode:native', 'spring.artemis.user:user',
					'spring.artemis.password:secret')
			.run((context) -> {
				JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
				ConnectionFactory connectionFactory = getConnectionFactory(context);
				assertThat(connectionFactory).isEqualTo(jmsTemplate.getConnectionFactory());
				ActiveMQConnectionFactory activeMQConnectionFactory = getActiveMQConnectionFactory(connectionFactory);
				assertNettyConnectionFactory(activeMQConnectionFactory, 'localhost', 61616);
				assertThat(activeMQConnectionFactory.getUser()).isEqualTo('user');
				assertThat(activeMQConnectionFactory.getPassword()).isEqualTo('secret');
			});
	}
	@Test
	void embeddedConnectionFactory() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.mode:embedded')
			.run((context) -> {
				ArtemisProperties properties = context.getBean(ArtemisProperties.class);
				assertThat(properties.getMode()).isEqualTo(ArtemisMode.EMBEDDED);
				assertThat(context).hasSingleBean(EmbeddedActiveMQ.class);
				org.apache.activemq.artemis.core.config.Configuration configuration = context
					.getBean(org.apache.activemq.artemis.core.config.Configuration.class);
				assertThat(configuration.isPersistenceEnabled()).isFalse();
				assertThat(configuration.isSecurityEnabled()).isFalse();
				assertInVmConnectionFactory(getActiveMQConnectionFactory(getConnectionFactory(context)));
			});
	}
	@Test
	void embeddedConnectionFactoryByDefault() {
		// No mode is specified
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(EmbeddedActiveMQ.class);
			org.apache.activemq.artemis.core.config.Configuration configuration = context
				.getBean(org.apache.activemq.artemis.core.config.Configuration.class);
			assertThat(configuration.isPersistenceEnabled()).isFalse();
			assertThat(configuration.isSecurityEnabled()).isFalse();
			assertInVmConnectionFactory(getActiveMQConnectionFactory(getConnectionFactory(context)));
		});
	}
	@Test
	void nativeConnectionFactoryIfEmbeddedServiceDisabledExplicitly() {
		// No mode is specified
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.embedded.enabled:false')
			.run((context) -> {
				assertThat(context).doesNotHaveBean(ActiveMQServer.class);
				assertNettyConnectionFactory(getActiveMQConnectionFactory(getConnectionFactory(context)), 'localhost',
						61616);
			});
	}
	@Test
	void embeddedConnectionFactoryEvenIfEmbeddedServiceDisabled() {
		// No mode is specified
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.mode:embedded', 'spring.artemis.embedded.enabled:false')
			.run((context) -> {
				assertThat(context.getBeansOfType(ActiveMQServer.class)).isEmpty();
				assertInVmConnectionFactory(getActiveMQConnectionFactory(getConnectionFactory(context)));
			});
	}
	@Test
	void embeddedServerWithDestinations() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.embedded.queues=Queue1,Queue2', 'spring.artemis.embedded.topics=Topic1')
			.run((context) -> {
				DestinationChecker checker = new DestinationChecker(context);
				checker.checkQueue('Queue1', true);
				checker.checkQueue('Queue2', true);
				checker.checkQueue('NonExistentQueue', false);
				checker.checkTopic('Topic1', true);
				checker.checkTopic('NonExistentTopic', false);
			});
	}
	@Test
	void embeddedServerWithDestinationConfig() {
		this.contextRunner.withUserConfiguration(DestinationConfiguration.class).run((context) -> {
			DestinationChecker checker = new DestinationChecker(context);
			checker.checkQueue('sampleQueue', true);
			checker.checkTopic('sampleTopic', true);
		});
	}
	@Test
	void embeddedServiceWithCustomJmsConfiguration() {
		// Ignored with custom config
		this.contextRunner.withUserConfiguration(CustomJmsConfiguration.class)
			.withPropertyValues('spring.artemis.embedded.queues=Queue1,Queue2')
			.run((context) -> {
				DestinationChecker checker = new DestinationChecker(context);
				checker.checkQueue('custom', true); // See CustomJmsConfiguration
				checker.checkQueue('Queue1', false);
				checker.checkQueue('Queue2', false);
			});
	}
	@Test
	void embeddedServiceWithCustomArtemisConfiguration() {
		this.contextRunner.withUserConfiguration(CustomArtemisConfiguration.class)
			.run((context) -> assertThat(
					context.getBean(org.apache.activemq.artemis.core.config.Configuration.class).getName())
				.isEqualTo('customFooBar'));
	}
	@Test
	void embeddedWithPersistentMode(@TempDir Path temp) throws IOException {
		File dataDirectory = Files.createTempDirectory(temp, null).toFile();
		final String messageId = UUID.randomUUID().toString();
		// Start the server and post a message to some queue
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.embedded.queues=TestQueue', 'spring.artemis.embedded.persistent:true',
					'spring.artemis.embedded.dataDirectory:' + dataDirectory.getAbsolutePath())
			.run((context) -> context.getBean(JmsTemplate.class)
				.send('TestQueue', (session) -> session.createTextMessage(messageId)))
			.run((context) -> {
				// Start the server again and check if our message is still here
				JmsTemplate jmsTemplate2 = context.getBean(JmsTemplate.class);
				jmsTemplate2.setReceiveTimeout(1000L);
				Message message = jmsTemplate2.receive('TestQueue');
				assertThat(message).isNotNull();
				assertThat(((TextMessage) message).getText()).isEqualTo(messageId);
			});
	}
	@Test
	void severalEmbeddedBrokers() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.embedded.queues=Queue1')
			.run((first) -> {
				this.contextRunner.withPropertyValues('spring.artemis.embedded.queues=Queue2').run((second) -> {
					ArtemisProperties firstProperties = first.getBean(ArtemisProperties.class);
					ArtemisProperties secondProperties = second.getBean(ArtemisProperties.class);
					assertThat(firstProperties.getEmbedded().getServerId())
						.isLessThan(secondProperties.getEmbedded().getServerId());
					DestinationChecker firstChecker = new DestinationChecker(first);
					firstChecker.checkQueue('Queue1', true);
					firstChecker.checkQueue('Queue2', false);
					DestinationChecker secondChecker = new DestinationChecker(second);
					secondChecker.checkQueue('Queue1', false);
					secondChecker.checkQueue('Queue2', true);
				});
			});
	}
	@Test
	void connectToASpecificEmbeddedBroker() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.artemis.embedded.serverId=93', 'spring.artemis.embedded.queues=Queue1')
			.run((first) -> {
				this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
					.withPropertyValues('spring.artemis.mode=embedded',
							// Connect to the 'main' broker
							'spring.artemis.embedded.serverId=93',
							// Do not start a specific one
							'spring.artemis.embedded.enabled=false')
					.run((secondContext) -> {
						first.getBean(JmsTemplate.class).convertAndSend('Queue1', 'test');
						assertThat(secondContext.getBean(JmsTemplate.class).receiveAndConvert('Queue1'))
							.isEqualTo('test');
					});
			});
	}
	@Test
	void defaultPoolConnectionFactoryIsApplied() {
		this.contextRunner.withPropertyValues('spring.artemis.pool.enabled=true').run((context) -> {
			assertThat(context.getBeansOfType(JmsPoolConnectionFactory.class)).hasSize(1);
			JmsPoolConnectionFactory connectionFactory = context.getBean(JmsPoolConnectionFactory.class);
			JmsPoolConnectionFactory defaultFactory = new JmsPoolConnectionFactory();
			assertThat(connectionFactory.isBlockIfSessionPoolIsFull())
				.isEqualTo(defaultFactory.isBlockIfSessionPoolIsFull());
			assertThat(connectionFactory.getBlockIfSessionPoolIsFullTimeout())
				.isEqualTo(defaultFactory.getBlockIfSessionPoolIsFullTimeout());
			assertThat(connectionFactory.getConnectionIdleTimeout())
				.isEqualTo(defaultFactory.getConnectionIdleTimeout());
			assertThat(connectionFactory.getMaxConnections()).isEqualTo(defaultFactory.getMaxConnections());
			assertThat(connectionFactory.getMaxSessionsPerConnection())
				.isEqualTo(defaultFactory.getMaxSessionsPerConnection());
			assertThat(connectionFactory.getConnectionCheckInterval())
				.isEqualTo(defaultFactory.getConnectionCheckInterval());
			assertThat(connectionFactory.isUseAnonymousProducers()).isEqualTo(defaultFactory.isUseAnonymousProducers());
		});
	}
	@Test
	void customPoolConnectionFactoryIsApplied() {
		this.contextRunner
			.withPropertyValues('spring.artemis.pool.enabled=true', 'spring.artemis.pool.blockIfFull=false',
					'spring.artemis.pool.blockIfFullTimeout=64', 'spring.artemis.pool.idleTimeout=512',
					'spring.artemis.pool.maxConnections=256', 'spring.artemis.pool.maxSessionsPerConnection=1024',
					'spring.artemis.pool.timeBetweenExpirationCheck=2048',
					'spring.artemis.pool.useAnonymousProducers=false')
			.run((context) -> {
				assertThat(context.getBeansOfType(JmsPoolConnectionFactory.class)).hasSize(1);
				JmsPoolConnectionFactory connectionFactory = context.getBean(JmsPoolConnectionFactory.class);
				assertThat(connectionFactory.isBlockIfSessionPoolIsFull()).isFalse();
				assertThat(connectionFactory.getBlockIfSessionPoolIsFullTimeout()).isEqualTo(64);
				assertThat(connectionFactory.getConnectionIdleTimeout()).isEqualTo(512);
				assertThat(connectionFactory.getMaxConnections()).isEqualTo(256);
				assertThat(connectionFactory.getMaxSessionsPerConnection()).isEqualTo(1024);
				assertThat(connectionFactory.getConnectionCheckInterval()).isEqualTo(2048);
				assertThat(connectionFactory.isUseAnonymousProducers()).isFalse();
			});
	}
	@Test
	void poolConnectionFactoryConfiguration() {
		this.contextRunner.withPropertyValues('spring.artemis.pool.enabled:true').run((context) -> {
			ConnectionFactory factory = getConnectionFactory(context);
			assertThat(factory).isInstanceOf(JmsPoolConnectionFactory.class);
			context.getSourceApplicationContext().close();
			assertThat(factory.createConnection()).isNull();
		});
	}
	@Test
	void cachingConnectionFactoryNotOnTheClasspathThenSimpleConnectionFactoryAutoConfigured() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(CachingConnectionFactory.class))
			.withPropertyValues('spring.artemis.pool.enabled=false', 'spring.jms.cache.enabled=false')
			.run((context) -> assertThat(context).hasSingleBean(ActiveMQConnectionFactory.class));
	}
	@Test
	void cachingConnectionFactoryNotOnTheClasspathAndCacheEnabledThenSimpleConnectionFactoryNotConfigured() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(CachingConnectionFactory.class))
			.withPropertyValues('spring.artemis.pool.enabled=false', 'spring.jms.cache.enabled=true')
			.run((context) -> assertThat(context).doesNotHaveBean(ActiveMQConnectionFactory.class));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(PropertiesArtemisConnectionDetails.class));
	}
	@Test
	void testConnectionFactoryWithOverridesWhenUsingCustomConnectionDetails() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(CachingConnectionFactory.class))
			.withPropertyValues('spring.artemis.pool.enabled=false', 'spring.jms.cache.enabled=false')
			.withUserConfiguration(TestConnectionDetailsConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ArtemisConnectionDetails.class)
					.doesNotHaveBean(PropertiesArtemisConnectionDetails.class);
				ActiveMQConnectionFactory connectionFactory = context.getBean(ActiveMQConnectionFactory.class);
				assertThat(connectionFactory.toURI().toString()).startsWith('tcp://localhost:12345');
				assertThat(connectionFactory.getUser()).isEqualTo('springuser');
				assertThat(connectionFactory.getPassword()).isEqualTo('spring');
			});
	}
	private ConnectionFactory getConnectionFactory(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(ConnectionFactory.class).hasBean('jmsConnectionFactory');
		ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
		assertThat(connectionFactory).isSameAs(context.getBean('jmsConnectionFactory'));
		return connectionFactory;
	}
	private ActiveMQConnectionFactory getActiveMQConnectionFactory(ConnectionFactory connectionFactory) {
		assertThat(connectionFactory).isInstanceOf(CachingConnectionFactory.class);
		return (ActiveMQConnectionFactory) ((CachingConnectionFactory) connectionFactory).getTargetConnectionFactory();
	}
	private TransportConfiguration assertInVmConnectionFactory(ActiveMQConnectionFactory connectionFactory) {
		TransportConfiguration transportConfig = getSingleTransportConfiguration(connectionFactory);
		assertThat(transportConfig.getFactoryClassName()).isEqualTo(InVMConnectorFactory.class.getName());
		return transportConfig;
	}
	private TransportConfiguration assertNettyConnectionFactory(ActiveMQConnectionFactory connectionFactory,
			String host, int port) {
		TransportConfiguration transportConfig = getSingleTransportConfiguration(connectionFactory);
		assertThat(transportConfig.getFactoryClassName()).isEqualTo(NettyConnectorFactory.class.getName());
		assertThat(transportConfig.getParams()).containsEntry('host', host);
		Object transportConfigPort = transportConfig.getParams().get('port');
		if (transportConfigPort instanceof String portString) {
			transportConfigPort = Integer.parseInt(portString);
		}
		assertThat(transportConfigPort).isEqualTo(port);
		return transportConfig;
	}
	private TransportConfiguration getSingleTransportConfiguration(ActiveMQConnectionFactory connectionFactory) {
		TransportConfiguration[] transportConfigurations = connectionFactory.getServerLocator()
			.getStaticTransportConfigurations();
		assertThat(transportConfigurations).hasSize(1);
		return transportConfigurations[0];
	}
	private static final class DestinationChecker {
		private final ActiveMQServer server;
		private DestinationChecker(ApplicationContext applicationContext) {
			this.server = applicationContext.getBean(EmbeddedActiveMQ.class).getActiveMQServer();
		}
		void checkQueue(String name, boolean shouldExist) {
			checkDestination(name, RoutingType.ANYCAST, shouldExist);
		}
		void checkTopic(String name, boolean shouldExist) {
			checkDestination(name, RoutingType.MULTICAST, shouldExist);
		}
		void checkDestination(String name, RoutingType routingType, boolean shouldExist) {
			try {
				BindingQueryResult result = this.server.bindingQuery(SimpleString.of(name));
				assertThat(result.isExists()).isEqualTo(shouldExist);
				if (shouldExist) {
					assertThat(result.getAddressInfo().getRoutingType()).isEqualTo(routingType);
				}
			}
			catch (Exception ex) {
				throw new RuntimeException(ex);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class DestinationConfiguration {
		@Bean
		JMSQueueConfiguration sampleQueueConfiguration() {
			JMSQueueConfigurationImpl jmsQueueConfiguration = new JMSQueueConfigurationImpl();
			jmsQueueConfiguration.setName('sampleQueue');
			jmsQueueConfiguration.setSelector('foo=bar');
			jmsQueueConfiguration.setDurable(false);
			jmsQueueConfiguration.setBindings('/queue/1');
			return jmsQueueConfiguration;
		}
		@Bean
		TopicConfiguration sampleTopicConfiguration() {
			TopicConfigurationImpl topicConfiguration = new TopicConfigurationImpl();
			topicConfiguration.setName('sampleTopic');
			topicConfiguration.setBindings('/topic/1');
			return topicConfiguration;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJmsConfiguration {
		@Bean
		JMSConfiguration myJmsConfiguration() {
			JMSConfiguration config = new JMSConfigurationImpl();
			JMSQueueConfiguration jmsQueueConfiguration = new JMSQueueConfigurationImpl();
			jmsQueueConfiguration.setName('custom');
			jmsQueueConfiguration.setDurable(false);
			config.getQueueConfigurations().add(jmsQueueConfiguration);
			return config;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomArtemisConfiguration {
		@Bean
		ArtemisConfigurationCustomizer myArtemisCustomize() {
			return (configuration) -> {
				configuration.setClusterPassword('Foobar');
				configuration.setName('customFooBar');
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConnectionDetailsConfiguration {
		@Bean
		ArtemisConnectionDetails activemqConnectionDetails() {
			return new ArtemisConnectionDetails() {
				@Override
				public ArtemisMode getMode() {
					return ArtemisMode.NATIVE;
				}
				@Override
				public String getBrokerUrl() {
					return 'tcp://localhost:12345';
				}
				@Override
				public String getUser() {
					return 'springuser';
				}
				@Override
				public String getPassword() {
					return 'spring';
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
class ArtemisEmbeddedConfigurationFactoryTests {
	@Test
	void defaultDataDir() {
		ArtemisProperties properties = new ArtemisProperties();
		properties.getEmbedded().setPersistent(true);
		Configuration configuration = new ArtemisEmbeddedConfigurationFactory(properties).createConfiguration();
		assertThat(configuration.getJournalDirectory()).startsWith(System.getProperty('java.io.tmpdir'))
			.endsWith('/journal');
	}
	@Test
	void persistenceSetup() {
		ArtemisProperties properties = new ArtemisProperties();
		properties.getEmbedded().setPersistent(true);
		Configuration configuration = new ArtemisEmbeddedConfigurationFactory(properties).createConfiguration();
		assertThat(configuration.isPersistenceEnabled()).isTrue();
		assertThat(configuration.getJournalType()).isEqualTo(JournalType.NIO);
	}
	@Test
	void generatedClusterPassword() {
		ArtemisProperties properties = new ArtemisProperties();
		Configuration configuration = new ArtemisEmbeddedConfigurationFactory(properties).createConfiguration();
		assertThat(configuration.getClusterPassword()).hasSize(36);
	}
	@Test
	void specificClusterPassword() {
		ArtemisProperties properties = new ArtemisProperties();
		properties.getEmbedded().setClusterPassword('password');
		Configuration configuration = new ArtemisEmbeddedConfigurationFactory(properties).createConfiguration();
		assertThat(configuration.getClusterPassword()).isEqualTo('password');
	}
	@Test
	void hasDlqExpiryQueueAddressSettingsConfigured() {
		ArtemisProperties properties = new ArtemisProperties();
		Configuration configuration = new ArtemisEmbeddedConfigurationFactory(properties).createConfiguration();
		Map<String, AddressSettings> addressSettings = configuration.getAddressSettings();
		assertThat((Object) addressSettings.get('#').getDeadLetterAddress()).isEqualTo(SimpleString.of('DLQ'));
		assertThat((Object) addressSettings.get('#').getExpiryAddress()).isEqualTo(SimpleString.of('ExpiryQueue'));
	}
	@Test
	void hasDlqExpiryQueueConfigured() {
		ArtemisProperties properties = new ArtemisProperties();
		Configuration configuration = new ArtemisEmbeddedConfigurationFactory(properties).createConfiguration();
		List<CoreAddressConfiguration> addressConfigurations = configuration.getAddressConfigurations();
		assertThat(addressConfigurations).hasSize(2);
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
class JmsAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ArtemisAutoConfiguration.class, JmsAutoConfiguration.class));
	@Test
	void testDefaultJmsConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ConnectionFactory.class);
			assertThat(context).hasSingleBean(CachingConnectionFactory.class);
			CachingConnectionFactory factory = context.getBean(CachingConnectionFactory.class);
			assertThat(factory.getTargetConnectionFactory()).isInstanceOf(ActiveMQConnectionFactory.class);
			JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
			JmsMessagingTemplate messagingTemplate = context.getBean(JmsMessagingTemplate.class);
			assertThat(factory).isEqualTo(jmsTemplate.getConnectionFactory());
			assertThat(messagingTemplate.getJmsTemplate()).isEqualTo(jmsTemplate);
			assertThat(getBrokerUrl(factory)).startsWith('vm://');
			assertThat(context.containsBean('jmsListenerContainerFactory')).isTrue();
		});
	}
	@Test
	void testConnectionFactoryBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration2.class)
			.run((context) -> assertThat(context.getBeansOfType(ActiveMQConnectionFactory.class))
				.containsOnlyKeys('customConnectionFactory'));
	}
	@Test
	void testJmsTemplateBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration3.class)
			.run((context) -> assertThat(context.getBean(JmsTemplate.class).getPriority()).isEqualTo(999));
	}
	@Test
	void testJmsMessagingTemplateBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration5.class)
			.run((context) -> assertThat(context.getBean(JmsMessagingTemplate.class).getDefaultDestinationName())
				.isEqualTo('fooBar'));
	}
	@Test
	void testJmsTemplateBackOffEverything() {
		this.contextRunner
			.withUserConfiguration(TestConfiguration2.class, TestConfiguration3.class, TestConfiguration5.class)
			.run(this::testJmsTemplateBackOffEverything);
	}
	private void testJmsTemplateBackOffEverything(AssertableApplicationContext loaded) {
		JmsTemplate jmsTemplate = loaded.getBean(JmsTemplate.class);
		assertThat(jmsTemplate.getPriority()).isEqualTo(999);
		assertThat(loaded.getBeansOfType(ActiveMQConnectionFactory.class)).containsOnlyKeys('customConnectionFactory');
		JmsMessagingTemplate messagingTemplate = loaded.getBean(JmsMessagingTemplate.class);
		assertThat(messagingTemplate.getDefaultDestinationName()).isEqualTo('fooBar');
		assertThat(messagingTemplate.getJmsTemplate()).isEqualTo(jmsTemplate);
	}
	@Test
	void testDefaultJmsListenerConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((loaded) -> {
			assertThat(loaded).hasSingleBean(CachingConnectionFactory.class);
			CachingConnectionFactory connectionFactory = loaded.getBean(CachingConnectionFactory.class);
			assertThat(loaded).hasSingleBean(DefaultJmsListenerContainerFactory.class);
			DefaultJmsListenerContainerFactory containerFactory = loaded
				.getBean(DefaultJmsListenerContainerFactory.class);
			SimpleJmsListenerEndpoint jmsListenerEndpoint = new SimpleJmsListenerEndpoint();
			jmsListenerEndpoint.setMessageListener((message) -> {
			});
			DefaultMessageListenerContainer container = containerFactory.createListenerContainer(jmsListenerEndpoint);
			assertThat(container.getClientId()).isNull();
			assertThat(container.getConcurrentConsumers()).isEqualTo(1);
			assertThat(container.getConnectionFactory()).isSameAs(connectionFactory.getTargetConnectionFactory());
			assertThat(container.getMaxConcurrentConsumers()).isEqualTo(1);
			assertThat(container.getSessionAcknowledgeMode()).isEqualTo(Session.AUTO_ACKNOWLEDGE);
			assertThat(container.isAutoStartup()).isTrue();
			assertThat(container.isPubSubDomain()).isFalse();
			assertThat(container.isSubscriptionDurable()).isFalse();
			assertThat(container).hasFieldOrPropertyWithValue('receiveTimeout', 1000L);
		});
	}
	@Test
	void testEnableJmsCreateDefaultContainerFactory() {
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.run((context) -> assertThat(context)
				.getBean('jmsListenerContainerFactory', JmsListenerContainerFactory.class)
				.isExactlyInstanceOf(DefaultJmsListenerContainerFactory.class));
	}
	@Test
	void testJmsListenerContainerFactoryBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration6.class, EnableJmsConfiguration.class)
			.run((context) -> assertThat(context)
				.getBean('jmsListenerContainerFactory', JmsListenerContainerFactory.class)
				.isExactlyInstanceOf(SimpleJmsListenerContainerFactory.class));
	}
	@Test
	void jmsListenerContainerFactoryWhenMultipleConnectionFactoryBeansShouldBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration10.class)
			.run((context) -> assertThat(context).doesNotHaveBean(JmsListenerContainerFactory.class));
	}
	@Test
	void testJmsListenerContainerFactoryWithCustomSettings() {
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.withPropertyValues('spring.jms.listener.autoStartup=false',
					'spring.jms.listener.session.acknowledgeMode=client',
					'spring.jms.listener.session.transacted=false', 'spring.jms.listener.minConcurrency=2',
					'spring.jms.listener.receiveTimeout=2s', 'spring.jms.listener.maxConcurrency=10',
					'spring.jms.subscription-durable=true', 'spring.jms.client-id=exampleId',
					'spring.jms.listener.max-messages-per-task=5')
			.run(this::testJmsListenerContainerFactoryWithCustomSettings);
	}
	private void testJmsListenerContainerFactoryWithCustomSettings(AssertableApplicationContext loaded) {
		DefaultMessageListenerContainer container = getContainer(loaded, 'jmsListenerContainerFactory');
		assertThat(container.isAutoStartup()).isFalse();
		assertThat(container.getSessionAcknowledgeMode()).isEqualTo(Session.CLIENT_ACKNOWLEDGE);
		assertThat(container.isSessionTransacted()).isFalse();
		assertThat(container.getConcurrentConsumers()).isEqualTo(2);
		assertThat(container.getMaxConcurrentConsumers()).isEqualTo(10);
		assertThat(container).hasFieldOrPropertyWithValue('receiveTimeout', 2000L);
		assertThat(container).hasFieldOrPropertyWithValue('maxMessagesPerTask', 5);
		assertThat(container.isSubscriptionDurable()).isTrue();
		assertThat(container.getClientId()).isEqualTo('exampleId');
	}
	@Test
	void testJmsListenerContainerFactoryWithNonStandardAcknowledgeMode() {
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.withPropertyValues('spring.jms.listener.session.acknowledge-mode=9')
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.getSessionAcknowledgeMode()).isEqualTo(9);
			});
	}
	@Test
	void testJmsListenerContainerFactoryWithDefaultSettings() {
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.run(this::testJmsListenerContainerFactoryWithDefaultSettings);
	}
	private void testJmsListenerContainerFactoryWithDefaultSettings(AssertableApplicationContext loaded) {
		DefaultMessageListenerContainer container = getContainer(loaded, 'jmsListenerContainerFactory');
		assertThat(container).hasFieldOrPropertyWithValue('receiveTimeout', 1000L);
	}
	@Test
	void testDefaultContainerFactoryWithJtaTransactionManager() {
		this.contextRunner.withUserConfiguration(TestConfiguration7.class, EnableJmsConfiguration.class)
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.isSessionTransacted()).isFalse();
				assertThat(container).hasFieldOrPropertyWithValue('transactionManager',
						context.getBean(JtaTransactionManager.class));
			});
	}
	@Test
	void testDefaultContainerFactoryWithJtaTransactionManagerAndSessionTransactedEnabled() {
		this.contextRunner.withUserConfiguration(TestConfiguration7.class, EnableJmsConfiguration.class)
			.withPropertyValues('spring.jms.listener.session.transacted=true')
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.isSessionTransacted()).isTrue();
				assertThat(container).hasFieldOrPropertyWithValue('transactionManager',
						context.getBean(JtaTransactionManager.class));
			});
	}
	@Test
	void testDefaultContainerFactoryNonJtaTransactionManager() {
		this.contextRunner.withUserConfiguration(TestConfiguration8.class, EnableJmsConfiguration.class)
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.isSessionTransacted()).isTrue();
				assertThat(container).hasFieldOrPropertyWithValue('transactionManager', null);
			});
	}
	@Test
	void testDefaultContainerFactoryNoTransactionManager() {
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class).run((context) -> {
			DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
			assertThat(container.isSessionTransacted()).isTrue();
			assertThat(container).hasFieldOrPropertyWithValue('transactionManager', null);
		});
	}
	@Test
	void testDefaultContainerFactoryNoTransactionManagerAndSessionTransactedDisabled() {
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.withPropertyValues('spring.jms.listener.session.transacted=false')
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.isSessionTransacted()).isFalse();
				assertThat(container).hasFieldOrPropertyWithValue('transactionManager', null);
			});
	}
	@Test
	void testDefaultContainerFactoryWithMessageConverters() {
		this.contextRunner.withUserConfiguration(MessageConvertersConfiguration.class, EnableJmsConfiguration.class)
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.getMessageConverter()).isSameAs(context.getBean('myMessageConverter'));
			});
	}
	@Test
	void testDefaultContainerFactoryWithExceptionListener() {
		ExceptionListener exceptionListener = mock(ExceptionListener.class);
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.withBean(ExceptionListener.class, () -> exceptionListener)
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.getExceptionListener()).isSameAs(exceptionListener);
			});
	}
	@Test
	void testDefaultContainerFactoryWithObservationRegistry() {
		ObservationRegistry observationRegistry = mock(ObservationRegistry.class);
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.withBean(ObservationRegistry.class, () -> observationRegistry)
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'jmsListenerContainerFactory');
				assertThat(container.getObservationRegistry()).isSameAs(observationRegistry);
			});
	}
	@Test
	void testCustomContainerFactoryWithConfigurer() {
		this.contextRunner.withUserConfiguration(TestConfiguration9.class, EnableJmsConfiguration.class)
			.withPropertyValues('spring.jms.listener.autoStartup=false')
			.run((context) -> {
				DefaultMessageListenerContainer container = getContainer(context, 'customListenerContainerFactory');
				assertThat(container.getCacheLevel()).isEqualTo(DefaultMessageListenerContainer.CACHE_CONSUMER);
				assertThat(container.isAutoStartup()).isFalse();
			});
	}
	private DefaultMessageListenerContainer getContainer(AssertableApplicationContext loaded, String name) {
		JmsListenerContainerFactory<?> factory = loaded.getBean(name, JmsListenerContainerFactory.class);
		assertThat(factory).isInstanceOf(DefaultJmsListenerContainerFactory.class);
		return ((DefaultJmsListenerContainerFactory) factory).createListenerContainer(mock(JmsListenerEndpoint.class));
	}
	@Test
	void testJmsTemplateWithMessageConverter() {
		this.contextRunner.withUserConfiguration(MessageConvertersConfiguration.class).run((context) -> {
			JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
			assertThat(jmsTemplate.getMessageConverter()).isSameAs(context.getBean('myMessageConverter'));
		});
	}
	@Test
	void testJmsTemplateWithDestinationResolver() {
		this.contextRunner.withUserConfiguration(DestinationResolversConfiguration.class)
			.run((context) -> assertThat(context.getBean(JmsTemplate.class).getDestinationResolver())
				.isSameAs(context.getBean('myDestinationResolver')));
	}
	@Test
	void testJmsTemplateWithObservationRegistry() {
		ObservationRegistry observationRegistry = mock(ObservationRegistry.class);
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.withBean(ObservationRegistry.class, () -> observationRegistry)
			.run((context) -> {
				JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
				assertThat(jmsTemplate).extracting('observationRegistry').isSameAs(observationRegistry);
			});
	}
	@Test
	void testJmsTemplateFullCustomization() {
		this.contextRunner.withUserConfiguration(MessageConvertersConfiguration.class)
			.withPropertyValues('spring.jms.template.session.acknowledge-mode=client',
					'spring.jms.template.session.transacted=true', 'spring.jms.template.default-destination=testQueue',
					'spring.jms.template.delivery-delay=500', 'spring.jms.template.delivery-mode=non-persistent',
					'spring.jms.template.priority=6', 'spring.jms.template.time-to-live=6000',
					'spring.jms.template.receive-timeout=2000')
			.run((context) -> {
				JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
				assertThat(jmsTemplate.getMessageConverter()).isSameAs(context.getBean('myMessageConverter'));
				assertThat(jmsTemplate.isPubSubDomain()).isFalse();
				assertThat(jmsTemplate.getSessionAcknowledgeMode()).isEqualTo(Session.CLIENT_ACKNOWLEDGE);
				assertThat(jmsTemplate.isSessionTransacted()).isTrue();
				assertThat(jmsTemplate.getDefaultDestinationName()).isEqualTo('testQueue');
				assertThat(jmsTemplate.getDeliveryDelay()).isEqualTo(500);
				assertThat(jmsTemplate.getDeliveryMode()).isOne();
				assertThat(jmsTemplate.getPriority()).isEqualTo(6);
				assertThat(jmsTemplate.getTimeToLive()).isEqualTo(6000);
				assertThat(jmsTemplate.isExplicitQosEnabled()).isTrue();
				assertThat(jmsTemplate.getReceiveTimeout()).isEqualTo(2000);
			});
	}
	@Test
	void testJmsTemplateWithNonStandardAcknowledgeMode() {
		this.contextRunner.withUserConfiguration(EnableJmsConfiguration.class)
			.withPropertyValues('spring.jms.template.session.acknowledge-mode=7')
			.run((context) -> {
				JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
				assertThat(jmsTemplate.getSessionAcknowledgeMode()).isEqualTo(7);
			});
	}
	@Test
	void testJmsMessagingTemplateUseConfiguredDefaultDestination() {
		this.contextRunner.withPropertyValues('spring.jms.template.default-destination=testQueue').run((context) -> {
			JmsMessagingTemplate messagingTemplate = context.getBean(JmsMessagingTemplate.class);
			assertThat(messagingTemplate.getDefaultDestinationName()).isEqualTo('testQueue');
		});
	}
	@Test
	void testPubSubDisabledByDefault() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context.getBean(JmsTemplate.class).isPubSubDomain()).isFalse());
	}
	@Test
	void testJmsTemplatePostProcessedSoThatPubSubIsTrue() {
		this.contextRunner.withUserConfiguration(TestConfiguration4.class)
			.run((context) -> assertThat(context.getBean(JmsTemplate.class).isPubSubDomain()).isTrue());
	}
	@Test
	void testPubSubDomainActive() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.jms.pubSubDomain:true')
			.run((context) -> {
				JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
				DefaultMessageListenerContainer defaultMessageListenerContainer = context
					.getBean(DefaultJmsListenerContainerFactory.class)
					.createListenerContainer(mock(JmsListenerEndpoint.class));
				assertThat(jmsTemplate.isPubSubDomain()).isTrue();
				assertThat(defaultMessageListenerContainer.isPubSubDomain()).isTrue();
			});
	}
	@Test
	void testPubSubDomainOverride() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.jms.pubSubDomain:false')
			.run((context) -> {
				assertThat(context).hasSingleBean(JmsTemplate.class);
				assertThat(context).hasSingleBean(ConnectionFactory.class);
				JmsTemplate jmsTemplate = context.getBean(JmsTemplate.class);
				ConnectionFactory factory = context.getBean(ConnectionFactory.class);
				assertThat(jmsTemplate).isNotNull();
				assertThat(jmsTemplate.isPubSubDomain()).isFalse();
				assertThat(factory).isNotNull().isEqualTo(jmsTemplate.getConnectionFactory());
			});
	}
	private String getBrokerUrl(CachingConnectionFactory connectionFactory) {
		assertThat(connectionFactory.getTargetConnectionFactory()).isInstanceOf(ActiveMQConnectionFactory.class);
		try {
			return ((ActiveMQConnectionFactory) connectionFactory.getTargetConnectionFactory()).toURI().toString();
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	@Test
	void enableJmsAutomatically() {
		this.contextRunner.withUserConfiguration(NoEnableJmsConfiguration.class)
			.run((context) -> assertThat(context)
				.hasBean(JmsListenerConfigUtils.JMS_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)
				.hasBean(JmsListenerConfigUtils.JMS_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME));
	}
	@Test
	void runtimeHintsAreRegisteredForBindingOfAcknowledgeMode() {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			context.register(ArtemisAutoConfiguration.class, JmsAutoConfiguration.class);
			TestGenerationContext generationContext = new TestGenerationContext();
			new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext);
			assertThat(RuntimeHintsPredicates.reflection().onMethod(AcknowledgeMode.class, 'of').invoke())
				.accepts(generationContext.getRuntimeHints());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration2 {
		@Bean
		ConnectionFactory customConnectionFactory() {
			return new ActiveMQConnectionFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration3 {
		@Bean
		JmsTemplate jmsTemplate(ConnectionFactory connectionFactory) {
			JmsTemplate jmsTemplate = new JmsTemplate(connectionFactory);
			jmsTemplate.setPriority(999);
			return jmsTemplate;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration4 implements BeanPostProcessor {
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) {
			if (bean.getClass().isAssignableFrom(JmsTemplate.class)) {
				JmsTemplate jmsTemplate = (JmsTemplate) bean;
				jmsTemplate.setPubSubDomain(true);
			}
			return bean;
		}
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration5 {
		@Bean
		JmsMessagingTemplate jmsMessagingTemplate(JmsTemplate jmsTemplate) {
			JmsMessagingTemplate messagingTemplate = new JmsMessagingTemplate(jmsTemplate);
			messagingTemplate.setDefaultDestinationName('fooBar');
			return messagingTemplate;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration6 {
		@Bean
		JmsListenerContainerFactory<?> jmsListenerContainerFactory(ConnectionFactory connectionFactory) {
			SimpleJmsListenerContainerFactory factory = new SimpleJmsListenerContainerFactory();
			factory.setConnectionFactory(connectionFactory);
			return factory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration7 {
		@Bean
		JtaTransactionManager transactionManager() {
			return mock(JtaTransactionManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration8 {
		@Bean
		DataSourceTransactionManager transactionManager() {
			return mock(DataSourceTransactionManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MessageConvertersConfiguration {
		@Bean
		@Primary
		MessageConverter myMessageConverter() {
			return mock(MessageConverter.class);
		}
		@Bean
		MessageConverter anotherMessageConverter() {
			return mock(MessageConverter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DestinationResolversConfiguration {
		@Bean
		@Primary
		DestinationResolver myDestinationResolver() {
			return mock(DestinationResolver.class);
		}
		@Bean
		DestinationResolver anotherDestinationResolver() {
			return mock(DestinationResolver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration9 {
		@Bean
		JmsListenerContainerFactory<?> customListenerContainerFactory(
				DefaultJmsListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {
			DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
			configurer.configure(factory, connectionFactory);
			factory.setCacheLevel(DefaultMessageListenerContainer.CACHE_CONSUMER);
			return factory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration10 {
		@Bean
		ConnectionFactory connectionFactory1() {
			return new ActiveMQConnectionFactory();
		}
		@Bean
		ConnectionFactory connectionFactory2() {
			return new ActiveMQConnectionFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableJms
	static class EnableJmsConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class NoEnableJmsConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
class JmsPropertiesTests {
	@Test
	void formatConcurrencyNull() {
		JmsProperties properties = new JmsProperties();
		assertThat(properties.getListener().formatConcurrency()).isNull();
	}
	@Test
	void formatConcurrencyOnlyLowerBound() {
		JmsProperties properties = new JmsProperties();
		properties.getListener().setMinConcurrency(2);
		assertThat(properties.getListener().formatConcurrency()).isEqualTo('2-2');
	}
	@Test
	void formatConcurrencyOnlyHigherBound() {
		JmsProperties properties = new JmsProperties();
		properties.getListener().setMaxConcurrency(5);
		assertThat(properties.getListener().formatConcurrency()).isEqualTo('1-5');
	}
	@Test
	void formatConcurrencyBothBounds() {
		JmsProperties properties = new JmsProperties();
		properties.getListener().setMinConcurrency(2);
		properties.getListener().setMaxConcurrency(10);
		assertThat(properties.getListener().formatConcurrency()).isEqualTo('2-10');
	}
	@Test
	void setDeliveryModeEnablesQoS() {
		JmsProperties properties = new JmsProperties();
		properties.getTemplate().setDeliveryMode(JmsProperties.DeliveryMode.PERSISTENT);
		assertThat(properties.getTemplate().determineQosEnabled()).isTrue();
	}
	@Test
	void setPriorityEnablesQoS() {
		JmsProperties properties = new JmsProperties();
		properties.getTemplate().setPriority(6);
		assertThat(properties.getTemplate().determineQosEnabled()).isTrue();
	}
	@Test
	void setTimeToLiveEnablesQoS() {
		JmsProperties properties = new JmsProperties();
		properties.getTemplate().setTimeToLive(Duration.ofSeconds(5));
		assertThat(properties.getTemplate().determineQosEnabled()).isTrue();
	}
	@Test
	void defaultReceiveTimeoutMatchesListenerContainersDefault() {
		assertThat(new JmsProperties().getListener().getReceiveTimeout())
			.hasMillis(AbstractPollingMessageListenerContainer.DEFAULT_RECEIVE_TIMEOUT);
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
class AcknowledgeModeTests {
	@ParameterizedTest
	@EnumSource(Mapping.class)
	void stringIsMappedToInt(Mapping mapping) {
		assertThat(AcknowledgeMode.of(mapping.actual)).extracting(AcknowledgeMode::getMode).isEqualTo(mapping.expected);
	}
	@Test
	void mapShouldThrowWhenMapIsCalledWithUnknownNonIntegerString() {
		assertThatIllegalArgumentException().isThrownBy(() -> AcknowledgeMode.of('some-string'))
			.withMessage(
					'"some-string" is neither a known acknowledge mode (auto, client, or dups_ok) nor an integer value');
	}
	private enum Mapping {
		AUTO_LOWER_CASE('auto', Session.AUTO_ACKNOWLEDGE),
		CLIENT_LOWER_CASE('client', Session.CLIENT_ACKNOWLEDGE),
		DUPS_OK_LOWER_CASE('dups_ok', Session.DUPS_OK_ACKNOWLEDGE),
		AUTO_UPPER_CASE('AUTO', Session.AUTO_ACKNOWLEDGE),
		CLIENT_UPPER_CASE('CLIENT', Session.CLIENT_ACKNOWLEDGE),
		DUPS_OK_UPPER_CASE('DUPS_OK', Session.DUPS_OK_ACKNOWLEDGE),
		AUTO_MIXED_CASE('AuTo', Session.AUTO_ACKNOWLEDGE),
		CLIENT_MIXED_CASE('CliEnT', Session.CLIENT_ACKNOWLEDGE),
		DUPS_OK_MIXED_CASE('dUPs_Ok', Session.DUPS_OK_ACKNOWLEDGE),
		DUPS_OK_KEBAB_CASE('DUPS-OK', Session.DUPS_OK_ACKNOWLEDGE),
		DUPS_OK_NO_SEPARATOR_UPPER_CASE('DUPSOK', Session.DUPS_OK_ACKNOWLEDGE),
		DUPS_OK_NO_SEPARATOR_LOWER_CASE('dupsok', Session.DUPS_OK_ACKNOWLEDGE),
		DUPS_OK_NO_SEPARATOR_MIXED_CASE('duPSok', Session.DUPS_OK_ACKNOWLEDGE),
		INTEGER('36', 36);
		private final String actual;
		private final int expected;
		Mapping(String actual, int expected) {
			this.actual = actual;
			this.expected = expected;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
class JndiConnectionFactoryAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JndiConnectionFactoryAutoConfiguration.class));
	private ClassLoader threadContextClassLoader;
	private String initialContextFactory;
	@BeforeEach
	void setupJndi() {
		this.initialContextFactory = System.getProperty(Context.INITIAL_CONTEXT_FACTORY);
		System.setProperty(Context.INITIAL_CONTEXT_FACTORY, TestableInitialContextFactory.class.getName());
		this.threadContextClassLoader = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(new JndiPropertiesHidingClassLoader(getClass().getClassLoader()));
	}
	@AfterEach
	void cleanUp() {
		TestableInitialContextFactory.clearAll();
		if (this.initialContextFactory != null) {
			System.setProperty(Context.INITIAL_CONTEXT_FACTORY, this.initialContextFactory);
		}
		else {
			System.clearProperty(Context.INITIAL_CONTEXT_FACTORY);
		}
		Thread.currentThread().setContextClassLoader(this.threadContextClassLoader);
	}
	@Test
	void detectNoAvailableCandidates() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ConnectionFactory.class));
	}
	@Test
	void detectWithJmsXAConnectionFactory() {
		ConnectionFactory connectionFactory = configureConnectionFactory('java:/JmsXA');
		this.contextRunner.run(assertConnectionFactory(connectionFactory));
	}
	@Test
	void detectWithXAConnectionFactory() {
		ConnectionFactory connectionFactory = configureConnectionFactory('java:/XAConnectionFactory');
		this.contextRunner.run(assertConnectionFactory(connectionFactory));
	}
	@Test
	void jndiNamePropertySet() {
		ConnectionFactory connectionFactory = configureConnectionFactory('java:comp/env/myCF');
		this.contextRunner.withPropertyValues('spring.jms.jndi-name=java:comp/env/myCF')
			.run(assertConnectionFactory(connectionFactory));
	}
	@Test
	void jndiNamePropertySetWithResourceRef() {
		ConnectionFactory connectionFactory = configureConnectionFactory('java:comp/env/myCF');
		this.contextRunner.withPropertyValues('spring.jms.jndi-name=myCF')
			.run(assertConnectionFactory(connectionFactory));
	}
	@Test
	void jndiNamePropertySetWithWrongValue() {
		this.contextRunner.withPropertyValues('spring.jms.jndi-name=doesNotExistCF').run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('doesNotExistCF');
		});
	}
	private ContextConsumer<AssertableApplicationContext> assertConnectionFactory(ConnectionFactory connectionFactory) {
		return (context) -> {
			assertThat(context).hasSingleBean(ConnectionFactory.class).hasBean('jmsConnectionFactory');
			assertThat(context.getBean(ConnectionFactory.class)).isSameAs(connectionFactory)
				.isSameAs(context.getBean('jmsConnectionFactory'));
		};
	}
	private ConnectionFactory configureConnectionFactory(String name) {
		ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
		TestableInitialContextFactory.bind(name, connectionFactory);
		return connectionFactory;
	}
}
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
class ActiveMQPropertiesTests {
	private static final String DEFAULT_EMBEDDED_BROKER_URL = 'vm://localhost?broker.persistent=false';
	private static final String DEFAULT_NETWORK_BROKER_URL = 'tcp://localhost:61616';
	private final ActiveMQProperties properties = new ActiveMQProperties();
	@Test
	void getBrokerUrlIsEmbeddedByDefault() {
		assertThat(this.properties.determineBrokerUrl()).isEqualTo(DEFAULT_EMBEDDED_BROKER_URL);
	}
	@Test
	void getBrokerUrlUseExplicitBrokerUrl() {
		this.properties.setBrokerUrl('tcp://activemq.example.com:71717');
		assertThat(this.properties.determineBrokerUrl()).isEqualTo('tcp://activemq.example.com:71717');
	}
	@Test
	void getBrokerUrlWithEmbeddedSetToFalse() {
		this.properties.getEmbedded().setEnabled(false);
		assertThat(this.properties.determineBrokerUrl()).isEqualTo(DEFAULT_NETWORK_BROKER_URL);
	}
	@Test
	void getExplicitBrokerUrlAlwaysWins() {
		this.properties.setBrokerUrl('tcp://activemq.example.com:71717');
		this.properties.getEmbedded().setEnabled(false);
		assertThat(this.properties.determineBrokerUrl()).isEqualTo('tcp://activemq.example.com:71717');
	}
	@Test
	void setTrustAllPackages() {
		ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory();
		this.properties.getPackages().setTrustAll(true);
		new ActiveMQConnectionFactoryConfigurer(this.properties, null).configure(factory);
		assertThat(factory.isTrustAllPackages()).isTrue();
	}
	@Test
	void setTrustedPackages() {
		ActiveMQConnectionFactory factory = new ActiveMQConnectionFactory();
		this.properties.getPackages().setTrustAll(false);
		this.properties.getPackages().getTrusted().add('trusted.package');
		new ActiveMQConnectionFactoryConfigurer(this.properties, null).configure(factory);
		assertThat(factory.isTrustAllPackages()).isFalse();
		assertThat(factory.getTrustedPackages()).hasSize(1);
		assertThat(factory.getTrustedPackages().get(0)).isEqualTo('trusted.package');
	}
}
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
class ActiveMQAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ActiveMQAutoConfiguration.class, JmsAutoConfiguration.class));
	@Test
	void brokerIsEmbeddedByDefault() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CachingConnectionFactory.class).hasBean('jmsConnectionFactory');
			CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
			assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
			assertThat(connectionFactory.getTargetConnectionFactory()).isInstanceOf(ActiveMQConnectionFactory.class);
			assertThat(((ActiveMQConnectionFactory) connectionFactory.getTargetConnectionFactory()).getBrokerURL())
				.isEqualTo('vm://localhost?broker.persistent=false');
		});
	}
	@Test
	void configurationBacksOffWhenCustomConnectionFactoryExists() {
		this.contextRunner.withUserConfiguration(CustomConnectionFactoryConfiguration.class)
			.run((context) -> assertThat(mockingDetails(context.getBean(ConnectionFactory.class)).isMock()).isTrue());
	}
	@Test
	void connectionFactoryIsCachedByDefault() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ConnectionFactory.class)
				.hasSingleBean(CachingConnectionFactory.class)
				.hasBean('jmsConnectionFactory');
			CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
			assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
			assertThat(connectionFactory.getTargetConnectionFactory()).isInstanceOf(ActiveMQConnectionFactory.class);
			assertThat(connectionFactory.isCacheConsumers()).isFalse();
			assertThat(connectionFactory.isCacheProducers()).isTrue();
			assertThat(connectionFactory.getSessionCacheSize()).isEqualTo(1);
		});
	}
	@Test
	void connectionFactoryCachingCanBeCustomized() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.jms.cache.consumers=true', 'spring.jms.cache.producers=false',
					'spring.jms.cache.session-cache-size=10')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(CachingConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
				assertThat(connectionFactory.isCacheConsumers()).isTrue();
				assertThat(connectionFactory.isCacheProducers()).isFalse();
				assertThat(connectionFactory.getSessionCacheSize()).isEqualTo(10);
			});
	}
	@Test
	void connectionFactoryCachingCanBeDisabled() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.jms.cache.enabled=false')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(ActiveMQConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				ActiveMQConnectionFactory connectionFactory = context.getBean(ActiveMQConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
				ActiveMQConnectionFactory defaultFactory = new ActiveMQConnectionFactory(
						'vm://localhost?broker.persistent=false');
				assertThat(connectionFactory.getUserName()).isEqualTo(defaultFactory.getUserName());
				assertThat(connectionFactory.getPassword()).isEqualTo(defaultFactory.getPassword());
				assertThat(connectionFactory.getCloseTimeout()).isEqualTo(defaultFactory.getCloseTimeout());
				assertThat(connectionFactory.isNonBlockingRedelivery())
					.isEqualTo(defaultFactory.isNonBlockingRedelivery());
				assertThat(connectionFactory.getSendTimeout()).isEqualTo(defaultFactory.getSendTimeout());
				assertThat(connectionFactory.isTrustAllPackages()).isEqualTo(defaultFactory.isTrustAllPackages());
				assertThat(connectionFactory.getTrustedPackages())
					.containsExactly(StringUtils.toStringArray(defaultFactory.getTrustedPackages()));
			});
	}
	@Test
	void customConnectionFactoryIsApplied() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.jms.cache.enabled=false',
					'spring.activemq.brokerUrl=vm://localhost?useJmx=false&broker.persistent=false',
					'spring.activemq.user=foo', 'spring.activemq.password=bar', 'spring.activemq.closeTimeout=500',
					'spring.activemq.nonBlockingRedelivery=true', 'spring.activemq.sendTimeout=1000',
					'spring.activemq.packages.trust-all=false', 'spring.activemq.packages.trusted=com.example.acme')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(ActiveMQConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				ActiveMQConnectionFactory connectionFactory = context.getBean(ActiveMQConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
				assertThat(connectionFactory.getUserName()).isEqualTo('foo');
				assertThat(connectionFactory.getPassword()).isEqualTo('bar');
				assertThat(connectionFactory.getCloseTimeout()).isEqualTo(500);
				assertThat(connectionFactory.isNonBlockingRedelivery()).isTrue();
				assertThat(connectionFactory.getSendTimeout()).isEqualTo(1000);
				assertThat(connectionFactory.isTrustAllPackages()).isFalse();
				assertThat(connectionFactory.getTrustedPackages()).containsExactly('com.example.acme');
			});
	}
	@Test
	void defaultPoolConnectionFactoryIsApplied() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.activemq.pool.enabled=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(JmsPoolConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				JmsPoolConnectionFactory connectionFactory = context.getBean(JmsPoolConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
				JmsPoolConnectionFactory defaultFactory = new JmsPoolConnectionFactory();
				assertThat(connectionFactory.isBlockIfSessionPoolIsFull())
					.isEqualTo(defaultFactory.isBlockIfSessionPoolIsFull());
				assertThat(connectionFactory.getBlockIfSessionPoolIsFullTimeout())
					.isEqualTo(defaultFactory.getBlockIfSessionPoolIsFullTimeout());
				assertThat(connectionFactory.getConnectionIdleTimeout())
					.isEqualTo(defaultFactory.getConnectionIdleTimeout());
				assertThat(connectionFactory.getMaxConnections()).isEqualTo(defaultFactory.getMaxConnections());
				assertThat(connectionFactory.getMaxSessionsPerConnection())
					.isEqualTo(defaultFactory.getMaxSessionsPerConnection());
				assertThat(connectionFactory.getConnectionCheckInterval())
					.isEqualTo(defaultFactory.getConnectionCheckInterval());
				assertThat(connectionFactory.isUseAnonymousProducers())
					.isEqualTo(defaultFactory.isUseAnonymousProducers());
			});
	}
	@Test
	void customPoolConnectionFactoryIsApplied() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.activemq.pool.enabled=true', 'spring.activemq.pool.blockIfFull=false',
					'spring.activemq.pool.blockIfFullTimeout=64', 'spring.activemq.pool.idleTimeout=512',
					'spring.activemq.pool.maxConnections=256', 'spring.activemq.pool.maxSessionsPerConnection=1024',
					'spring.activemq.pool.timeBetweenExpirationCheck=2048',
					'spring.activemq.pool.useAnonymousProducers=false')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(JmsPoolConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				JmsPoolConnectionFactory connectionFactory = context.getBean(JmsPoolConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
				assertThat(connectionFactory.isBlockIfSessionPoolIsFull()).isFalse();
				assertThat(connectionFactory.getBlockIfSessionPoolIsFullTimeout()).isEqualTo(64);
				assertThat(connectionFactory.getConnectionIdleTimeout()).isEqualTo(512);
				assertThat(connectionFactory.getMaxConnections()).isEqualTo(256);
				assertThat(connectionFactory.getMaxSessionsPerConnection()).isEqualTo(1024);
				assertThat(connectionFactory.getConnectionCheckInterval()).isEqualTo(2048);
				assertThat(connectionFactory.isUseAnonymousProducers()).isFalse();
			});
	}
	@Test
	void poolConnectionFactoryConfiguration() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.withPropertyValues('spring.activemq.pool.enabled:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(JmsPoolConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				ConnectionFactory factory = context.getBean(ConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(factory);
				assertThat(factory).isInstanceOf(JmsPoolConnectionFactory.class);
				context.getSourceApplicationContext().close();
				assertThat(factory.createConnection()).isNull();
			});
	}
	@Test
	void cachingConnectionFactoryNotOnTheClasspathThenSimpleConnectionFactoryAutoConfigured() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(CachingConnectionFactory.class))
			.withPropertyValues('spring.activemq.pool.enabled=false', 'spring.jms.cache.enabled=false')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(ActiveMQConnectionFactory.class)
					.hasBean('jmsConnectionFactory');
				ActiveMQConnectionFactory connectionFactory = context.getBean(ActiveMQConnectionFactory.class);
				assertThat(context.getBean('jmsConnectionFactory')).isSameAs(connectionFactory);
			});
	}
	@Test
	void cachingConnectionFactoryNotOnTheClasspathAndCacheEnabledThenSimpleConnectionFactoryNotConfigured() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(CachingConnectionFactory.class))
			.withPropertyValues('spring.activemq.pool.enabled=false', 'spring.jms.cache.enabled=true')
			.run((context) -> assertThat(context).doesNotHaveBean(ConnectionFactory.class)
				.doesNotHaveBean(ActiveMQConnectionFactory.class)
				.doesNotHaveBean('jmsConnectionFactory'));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context)
			.hasSingleBean(ActiveMQAutoConfiguration.PropertiesActiveMQConnectionDetails.class));
	}
	@Test
	void testConnectionFactoryWithOverridesWhenUsingCustomConnectionDetails() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(CachingConnectionFactory.class))
			.withPropertyValues('spring.activemq.pool.enabled=false', 'spring.jms.cache.enabled=false')
			.withUserConfiguration(TestConnectionDetailsConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ActiveMQConnectionDetails.class)
					.doesNotHaveBean(ActiveMQAutoConfiguration.PropertiesActiveMQConnectionDetails.class);
				ActiveMQConnectionFactory connectionFactory = context.getBean(ActiveMQConnectionFactory.class);
				assertThat(connectionFactory.getBrokerURL()).isEqualTo('tcp://localhost:12345');
				assertThat(connectionFactory.getUserName()).isEqualTo('springuser');
				assertThat(connectionFactory.getPassword()).isEqualTo('spring');
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConnectionFactoryConfiguration {
		@Bean
		ConnectionFactory connectionFactory() {
			return mock(ConnectionFactory.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		ActiveMQConnectionFactoryCustomizer activeMQConnectionFactoryCustomizer() {
			return (factory) -> {
				factory.setBrokerURL('vm://localhost?useJmx=false&broker.persistent=false');
				factory.setUserName('foobar');
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConnectionDetailsConfiguration {
		@Bean
		ActiveMQConnectionDetails activemqConnectionDetails() {
			return new ActiveMQConnectionDetails() {
				@Override
				public String getBrokerUrl() {
					return 'tcp://localhost:12345';
				}
				@Override
				public String getUser() {
					return 'springuser';
				}
				@Override
				public String getPassword() {
					return 'spring';
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
class MessageSourceAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MessageSourceAutoConfiguration.class));
	@Test
	void testDefaultMessageSource() {
		this.contextRunner.run((context) -> assertThat(context.getMessage('foo', null, 'Foo message', Locale.UK))
			.isEqualTo('Foo message'));
	}
	@Test
	void propertiesBundleWithSlashIsDetected() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test/messages').run((context) -> {
			assertThat(context).hasSingleBean(MessageSource.class);
			assertThat(context.getMessage('foo', null, 'Foo message', Locale.UK)).isEqualTo('bar');
		});
	}
	@Test
	void propertiesBundleWithDotIsDetected() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test.messages').run((context) -> {
			assertThat(context).hasSingleBean(MessageSource.class);
			assertThat(context.getMessage('foo', null, 'Foo message', Locale.UK)).isEqualTo('bar');
		});
	}
	@Test
	void testEncodingWorks() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test/swedish')
			.run((context) -> assertThat(context.getMessage('foo', null, 'Foo message', Locale.UK))
				.isEqualTo('Some text with some swedish !'));
	}
	@Test
	void testCacheDurationNoUnit() {
		this.contextRunner
			.withPropertyValues('spring.messages.basename=test/messages', 'spring.messages.cache-duration=10')
			.run(assertCache(10 * 1000));
	}
	@Test
	void testCacheDurationWithUnit() {
		this.contextRunner
			.withPropertyValues('spring.messages.basename=test/messages', 'spring.messages.cache-duration=1m')
			.run(assertCache(60 * 1000));
	}
	private ContextConsumer<AssertableApplicationContext> assertCache(long expected) {
		return (context) -> {
			assertThat(context).hasSingleBean(MessageSource.class);
			assertThat(context.getBean(MessageSource.class)).hasFieldOrPropertyWithValue('cacheMillis', expected);
		};
	}
	@Test
	void testMultipleMessageSourceCreated() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test/messages,test/messages2')
			.run((context) -> {
				assertThat(context.getMessage('foo', null, 'Foo message', Locale.UK)).isEqualTo('bar');
				assertThat(context.getMessage('foo-foo', null, 'Foo-Foo message', Locale.UK)).isEqualTo('bar-bar');
			});
	}
	@Test
	@Disabled('Expected to fail per gh-1075')
	void testMessageSourceFromPropertySourceAnnotation() {
		this.contextRunner.withUserConfiguration(Config.class)
			.run((context) -> assertThat(context.getMessage('foo', null, 'Foo message', Locale.UK)).isEqualTo('bar'));
	}
	@Test
	void testCommonMessages() {
		this.contextRunner
			.withPropertyValues('spring.messages.basename=test/messages',
					'spring.messages.common-messages=classpath:test/common-messages.properties')
			.run((context) -> assertThat(context.getMessage('hello', null, 'Hello!', Locale.UK)).isEqualTo('world'));
	}
	@Test
	void testCommonMessagesWhenNotFound() {
		this.contextRunner
			.withPropertyValues('spring.messages.basename=test/messages',
					'spring.messages.common-messages=classpath:test/common-messages-missing.properties')
			.run((context) -> assertThat(context).getFailure()
				.hasMessageContaining(
						'Failed to load common messages from "class path resource [test/common-messages-missing.properties]"'));
	}
	@Test
	void testFallbackDefault() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test/messages')
			.run((context) -> assertThat(context.getBean(MessageSource.class))
				.hasFieldOrPropertyWithValue('fallbackToSystemLocale', true));
	}
	@Test
	void testFallbackTurnOff() {
		this.contextRunner
			.withPropertyValues('spring.messages.basename=test/messages',
					'spring.messages.fallback-to-system-locale:false')
			.run((context) -> assertThat(context.getBean(MessageSource.class))
				.hasFieldOrPropertyWithValue('fallbackToSystemLocale', false));
	}
	@Test
	void testFormatMessageDefault() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test/messages')
			.run((context) -> assertThat(context.getBean(MessageSource.class))
				.hasFieldOrPropertyWithValue('alwaysUseMessageFormat', false));
	}
	@Test
	void testFormatMessageOn() {
		this.contextRunner
			.withPropertyValues('spring.messages.basename=test/messages',
					'spring.messages.always-use-message-format:true')
			.run((context) -> assertThat(context.getBean(MessageSource.class))
				.hasFieldOrPropertyWithValue('alwaysUseMessageFormat', true));
	}
	@Test
	void testUseCodeAsDefaultMessageDefault() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test/messages')
			.run((context) -> assertThat(context.getBean(MessageSource.class))
				.hasFieldOrPropertyWithValue('useCodeAsDefaultMessage', false));
	}
	@Test
	void testUseCodeAsDefaultMessageOn() {
		this.contextRunner
			.withPropertyValues('spring.messages.basename=test/messages',
					'spring.messages.use-code-as-default-message=true')
			.run((context) -> assertThat(context.getBean(MessageSource.class))
				.hasFieldOrPropertyWithValue('useCodeAsDefaultMessage', true));
	}
	@Test
	void existingMessageSourceIsPreferred() {
		this.contextRunner.withUserConfiguration(CustomMessageSourceConfiguration.class)
			.run((context) -> assertThat(context.getMessage('foo', null, null, null)).isEqualTo('foo'));
	}
	@Test
	void existingMessageSourceInParentIsIgnored() {
		this.contextRunner.run((parent) -> this.contextRunner.withParent(parent)
			.withPropertyValues('spring.messages.basename=test/messages')
			.run((context) -> assertThat(context.getMessage('foo', null, 'Foo message', Locale.UK)).isEqualTo('bar')));
	}
	@Test
	void messageSourceWithNonStandardBeanNameIsIgnored() {
		this.contextRunner.withPropertyValues('spring.messages.basename=test/messages')
			.withUserConfiguration(CustomBeanNameMessageSourceConfiguration.class)
			.run((context) -> assertThat(context.getMessage('foo', null, Locale.US)).isEqualTo('bar'));
	}
	@Test
	void shouldRegisterDefaultHints() {
		RuntimeHints hints = new RuntimeHints();
		new MessageSourceRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('messages.properties')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('messages_de.properties')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('messages_zh-CN.properties')).accepts(hints);
	}
	@Configuration(proxyBeanMethods = false)
	@PropertySource('classpath:/switch-messages.properties')
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomMessageSourceConfiguration {
		@Bean
		MessageSource messageSource() {
			return new TestMessageSource();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomBeanNameMessageSourceConfiguration {
		@Bean
		MessageSource codeReturningMessageSource() {
			return new TestMessageSource();
		}
	}
	static class TestMessageSource implements MessageSource {
		@Override
		public String getMessage(String code, Object[] args, String defaultMessage, Locale locale) {
			return code;
		}
		@Override
		public String getMessage(String code, Object[] args, Locale locale) {
			return code;
		}
		@Override
		public String getMessage(MessageSourceResolvable resolvable, Locale locale) {
			return resolvable.getCodes()[0];
		}
	}
}
/*
package org.springframework.boot.autoconfigure.context.filtersample;
@Configuration(proxyBeanMethods = false)
public class ExampleConfiguration {
	@Bean
	public String example() {
		return 'test';
	}
}
/*
package org.springframework.boot.autoconfigure.context.filtersample;
@AutoConfiguration
public class ExampleFilteredAutoConfiguration {
	@Bean
	public String anotherExample() {
		return 'fail';
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
class PropertyPlaceholderAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void whenTheAutoConfigurationIsNotUsedThenBeanDefinitionPlaceholdersAreNotResolved() {
		this.contextRunner.withPropertyValues('fruit:banana')
			.withInitializer(this::definePlaceholderBean)
			.run((context) -> assertThat(context.getBean(PlaceholderBean.class).fruit).isEqualTo('${fruit:apple}'));
	}
	@Test
	void whenTheAutoConfigurationIsUsedThenBeanDefinitionPlaceholdersAreResolved() {
		this.contextRunner.withPropertyValues('fruit:banana')
			.withInitializer(this::definePlaceholderBean)
			.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class))
			.run((context) -> assertThat(context.getBean(PlaceholderBean.class).fruit).isEqualTo('banana'));
	}
	@Test
	void whenTheAutoConfigurationIsNotUsedThenValuePlaceholdersAreResolved() {
		this.contextRunner.withPropertyValues('fruit:banana')
			.withUserConfiguration(PlaceholderConfig.class)
			.run((context) -> assertThat(context.getBean(PlaceholderConfig.class).fruit).isEqualTo('banana'));
	}
	@Test
	void whenTheAutoConfigurationIsUsedThenValuePlaceholdersAreResolved() {
		this.contextRunner.withPropertyValues('fruit:banana')
			.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class))
			.withUserConfiguration(PlaceholderConfig.class)
			.run((context) -> assertThat(context.getBean(PlaceholderConfig.class).fruit).isEqualTo('banana'));
	}
	@Test
	void whenThereIsAUserDefinedPropertySourcesPlaceholderConfigurerThenItIsUsedForBeanDefinitionPlaceholderResolution() {
		this.contextRunner.withPropertyValues('fruit:banana')
			.withInitializer(this::definePlaceholderBean)
			.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class))
			.withUserConfiguration(PlaceholdersOverride.class)
			.run((context) -> assertThat(context.getBean(PlaceholderBean.class).fruit).isEqualTo('orange'));
	}
	@Test
	void whenThereIsAUserDefinedPropertySourcesPlaceholderConfigurerThenItIsUsedForValuePlaceholderResolution() {
		this.contextRunner.withPropertyValues('fruit:banana')
			.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class))
			.withUserConfiguration(PlaceholderConfig.class, PlaceholdersOverride.class)
			.run((context) -> assertThat(context.getBean(PlaceholderConfig.class).fruit).isEqualTo('orange'));
	}
	private void definePlaceholderBean(ConfigurableApplicationContext context) {
		((BeanDefinitionRegistry) context.getBeanFactory()).registerBeanDefinition('placeholderBean',
				BeanDefinitionBuilder.rootBeanDefinition(PlaceholderBean.class)
					.addConstructorArgValue('${fruit:apple}')
					.getBeanDefinition());
	}
	@Configuration(proxyBeanMethods = false)
	static class PlaceholderConfig {
		@Value('${fruit:apple}')
		private String fruit;
	}
	static class PlaceholderBean {
		private final String fruit;
		PlaceholderBean(String fruit) {
			this.fruit = fruit;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PlaceholdersOverride {
		@Bean
		static PropertySourcesPlaceholderConfigurer morePlaceholders() {
			PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();
			configurer
				.setProperties(StringUtils.splitArrayElementsIntoProperties(new String[] { 'fruit=orange' }, '='));
			configurer.setLocalOverride(true);
			configurer.setOrder(0);
			return configurer;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@SpringBootTest('spring.messages.basename:test/messages')
@ImportAutoConfiguration({ MessageSourceAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
@DirtiesContext
class MessageSourceAutoConfigurationIntegrationTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void testMessageSourceFromPropertySourceAnnotation() {
		assertThat(this.context.getMessage('foo', null, 'Foo message', Locale.UK)).isEqualTo('bar');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
class LifecycleAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LifecycleAutoConfiguration.class));
	@Test
	void lifecycleProcessorIsConfiguredWithDefaultTimeout() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
			Object processor = context.getBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
			assertThat(processor).extracting('timeoutPerShutdownPhase').isEqualTo(30000L);
		});
	}
	@Test
	void lifecycleProcessorIsConfiguredWithCustomTimeout() {
		this.contextRunner.withPropertyValues('spring.lifecycle.timeout-per-shutdown-phase=15s').run((context) -> {
			assertThat(context).hasBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
			Object processor = context.getBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
			assertThat(processor).extracting('timeoutPerShutdownPhase').isEqualTo(15000L);
		});
	}
	@Test
	void lifecycleProcessorIsConfiguredWithCustomTimeoutInAChildContext() {
		new ApplicationContextRunner().run((parent) -> {
			this.contextRunner.withParent(parent)
				.withPropertyValues('spring.lifecycle.timeout-per-shutdown-phase=15s')
				.run((child) -> {
					assertThat(child).hasBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
					Object processor = child.getBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
					assertThat(processor).extracting('timeoutPerShutdownPhase').isEqualTo(15000L);
				});
		});
	}
	@Test
	void whenUserDefinesALifecycleProcessorBeanThenTheAutoConfigurationBacksOff() {
		this.contextRunner.withUserConfiguration(LifecycleProcessorConfiguration.class).run((context) -> {
			assertThat(context).hasBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
			Object processor = context.getBean(AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME);
			assertThat(processor).extracting('timeoutPerShutdownPhase').isEqualTo(5000L);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class LifecycleProcessorConfiguration {
		@Bean(name = AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME)
		DefaultLifecycleProcessor customLifecycleProcessor() {
			DefaultLifecycleProcessor processor = new DefaultLifecycleProcessor();
			processor.setTimeoutPerShutdownPhase(5000);
			return processor;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
class ConfigurationPropertiesAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void tearDown() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void processAnnotatedBean() {
		load(new Class<?>[] { AutoConfig.class, SampleBean.class }, 'foo.name:test');
		assertThat(this.context.getBean(SampleBean.class).getName()).isEqualTo('test');
	}
	@Test
	void processAnnotatedBeanNoAutoConfig() {
		load(new Class<?>[] { SampleBean.class }, 'foo.name:test');
		assertThat(this.context.getBean(SampleBean.class).getName()).isEqualTo('default');
	}
	private void load(Class<?>[] configs, String... environment) {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(configs);
		TestPropertyValues.of(environment).applyTo(this.context);
		this.context.refresh();
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(ConfigurationPropertiesAutoConfiguration.class)
	static class AutoConfig {
	}
	@Component
	@ConfigurationProperties('foo')
	static class SampleBean {
		private String name = 'default';
		String getName() {
			return this.name;
		}
		void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@SpringBootTest
@ImportAutoConfiguration({ MessageSourceAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
@ActiveProfiles('switch-messages')
@DirtiesContext
class MessageSourceAutoConfigurationProfileTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void testMessageSourceFromPropertySourceAnnotation() {
		assertThat(this.context.getMessage('foo', null, 'Foo message', Locale.UK)).isEqualTo('bar');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public class TestAutoConfigurationPackageRegistrar implements ImportBeanDefinitionRegistrar {
	@Override
	public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
		AnnotationAttributes attributes = AnnotationAttributes
			.fromMap(metadata.getAnnotationAttributes(TestAutoConfigurationPackage.class.getName(), true));
		AutoConfigurationPackages.register(registry, ClassUtils.getPackageName(attributes.getString('value')));
	}
}
/*
package org.springframework.boot.autoconfigure;
public class EarlyInitFactoryBean implements FactoryBean<String> {
	private String propertyFromConfig;
	public void setPropertyFromConfig(String propertyFromConfig) {
		this.propertyFromConfig = propertyFromConfig;
	}
	@Override
	public boolean isSingleton() {
		return true;
	}
	@Override
	public Class<?> getObjectType() {
		return null;
	}
	@Override
	public String getObject() throws Exception {
		return this.propertyFromConfig;
	}
}
/*
package org.springframework.boot.autoconfigure.task;
/**
class ScheduledBeanLazyInitializationExcludeFilterTests {
	private final ScheduledBeanLazyInitializationExcludeFilter filter = new ScheduledBeanLazyInitializationExcludeFilter();
	@Test
	void beanWithScheduledMethodIsDetected() {
		assertThat(isExcluded(TestBean.class)).isTrue();
	}
	@Test
	void beanWithSchedulesMethodIsDetected() {
		assertThat(isExcluded(AnotherTestBean.class)).isTrue();
	}
	@Test
	void beanWithoutScheduledMethodIsDetected() {
		assertThat(isExcluded(ScheduledBeanLazyInitializationExcludeFilterTests.class)).isFalse();
	}
	private boolean isExcluded(Class<?> type) {
		return this.filter.isExcluded('test', new RootBeanDefinition(type), type);
	}
	private static final class TestBean {
		@Scheduled
		void doStuff() {
		}
	}
	private static final class AnotherTestBean {
		@Schedules({ @Scheduled(fixedRate = 5000), @Scheduled(fixedRate = 2500) })
		void doStuff() {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.task;
/**
@ExtendWith(OutputCaptureExtension.class)
class TaskExecutionAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(ThreadPoolTaskExecutorBuilder.class);
			assertThat(context).hasSingleBean(ThreadPoolTaskExecutor.class);
			assertThat(context).hasSingleBean(SimpleAsyncTaskExecutorBuilder.class);
		});
	}
	@Test
	void simpleAsyncTaskExecutorBuilderShouldReadProperties() {
		this.contextRunner
			.withPropertyValues('spring.task.execution.thread-name-prefix=mytest-',
					'spring.task.execution.simple.concurrency-limit=1',
					'spring.task.execution.shutdown.await-termination=true',
					'spring.task.execution.shutdown.await-termination-period=30s')
			.run(assertSimpleAsyncTaskExecutor((taskExecutor) -> {
				assertThat(taskExecutor.getConcurrencyLimit()).isEqualTo(1);
				assertThat(taskExecutor.getThreadNamePrefix()).isEqualTo('mytest-');
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('taskTerminationTimeout', 30000L);
			}));
	}
	@Test
	void threadPoolTaskExecutorBuilderShouldApplyCustomSettings() {
		this.contextRunner.withPropertyValues('spring.task.execution.pool.queue-capacity=10',
				'spring.task.execution.pool.core-size=2', 'spring.task.execution.pool.max-size=4',
				'spring.task.execution.pool.allow-core-thread-timeout=true', 'spring.task.execution.pool.keep-alive=5s',
				'spring.task.execution.pool.shutdown.accept-tasks-after-context-close=true',
				'spring.task.execution.shutdown.await-termination=true',
				'spring.task.execution.shutdown.await-termination-period=30s',
				'spring.task.execution.thread-name-prefix=mytest-')
			.run(assertThreadPoolTaskExecutor((taskExecutor) -> {
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('queueCapacity', 10);
				assertThat(taskExecutor.getCorePoolSize()).isEqualTo(2);
				assertThat(taskExecutor.getMaxPoolSize()).isEqualTo(4);
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('allowCoreThreadTimeOut', true);
				assertThat(taskExecutor.getKeepAliveSeconds()).isEqualTo(5);
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('acceptTasksAfterContextClose', true);
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('waitForTasksToCompleteOnShutdown', true);
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('awaitTerminationMillis', 30000L);
				assertThat(taskExecutor.getThreadNamePrefix()).isEqualTo('mytest-');
			}));
	}
	@Test
	void threadPoolTaskExecutorBuilderWhenHasCustomBuilderShouldUseCustomBuilder() {
		this.contextRunner.withUserConfiguration(CustomThreadPoolTaskExecutorBuilderConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(ThreadPoolTaskExecutorBuilder.class);
			assertThat(context.getBean(ThreadPoolTaskExecutorBuilder.class))
				.isSameAs(context.getBean(CustomThreadPoolTaskExecutorBuilderConfig.class).builder);
		});
	}
	@Test
	void threadPoolTaskExecutorBuilderShouldUseTaskDecorator() {
		this.contextRunner.withUserConfiguration(TaskDecoratorConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(ThreadPoolTaskExecutorBuilder.class);
			ThreadPoolTaskExecutor executor = context.getBean(ThreadPoolTaskExecutorBuilder.class).build();
			assertThat(executor).extracting('taskDecorator').isSameAs(context.getBean(TaskDecorator.class));
		});
	}
	@Test
	void whenThreadPoolTaskExecutorIsAutoConfiguredThenItIsLazy() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Executor.class).hasBean('applicationTaskExecutor');
			BeanDefinition beanDefinition = context.getSourceApplicationContext()
				.getBeanFactory()
				.getBeanDefinition('applicationTaskExecutor');
			assertThat(beanDefinition.isLazyInit()).isTrue();
			assertThat(context).getBean('applicationTaskExecutor').isInstanceOf(ThreadPoolTaskExecutor.class);
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void whenVirtualThreadsAreEnabledThenSimpleAsyncTaskExecutorWithVirtualThreadsIsAutoConfigured() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			assertThat(context).hasSingleBean(Executor.class).hasBean('applicationTaskExecutor');
			assertThat(context).getBean('applicationTaskExecutor').isInstanceOf(SimpleAsyncTaskExecutor.class);
			SimpleAsyncTaskExecutor taskExecutor = context.getBean('applicationTaskExecutor',
					SimpleAsyncTaskExecutor.class);
			assertThat(virtualThreadName(taskExecutor)).startsWith('task-');
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void whenTaskNamePrefixIsConfiguredThenSimpleAsyncTaskExecutorWithVirtualThreadsUsesIt() {
		this.contextRunner
			.withPropertyValues('spring.threads.virtual.enabled=true',
					'spring.task.execution.thread-name-prefix=custom-')
			.run((context) -> {
				SimpleAsyncTaskExecutor taskExecutor = context.getBean('applicationTaskExecutor',
						SimpleAsyncTaskExecutor.class);
				assertThat(virtualThreadName(taskExecutor)).startsWith('custom-');
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void whenVirtualThreadsAreAvailableButNotEnabledThenThreadPoolTaskExecutorIsAutoConfigured() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Executor.class).hasBean('applicationTaskExecutor');
			assertThat(context).getBean('applicationTaskExecutor').isInstanceOf(ThreadPoolTaskExecutor.class);
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void whenTaskDecoratorIsDefinedThenSimpleAsyncTaskExecutorWithVirtualThreadsUsesIt() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.withUserConfiguration(TaskDecoratorConfig.class)
			.run((context) -> {
				SimpleAsyncTaskExecutor executor = context.getBean(SimpleAsyncTaskExecutor.class);
				assertThat(executor).extracting('taskDecorator').isSameAs(context.getBean(TaskDecorator.class));
			});
	}
	@Test
	void simpleAsyncTaskExecutorBuilderUsesPlatformThreadsByDefault() {
		this.contextRunner.run((context) -> {
			SimpleAsyncTaskExecutorBuilder builder = context.getBean(SimpleAsyncTaskExecutorBuilder.class);
			assertThat(builder).hasFieldOrPropertyWithValue('virtualThreads', null);
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void simpleAsyncTaskExecutorBuilderUsesVirtualThreadsWhenEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			SimpleAsyncTaskExecutorBuilder builder = context.getBean(SimpleAsyncTaskExecutorBuilder.class);
			assertThat(builder).hasFieldOrPropertyWithValue('virtualThreads', true);
		});
	}
	@Test
	void taskExecutorWhenHasCustomTaskExecutorShouldBackOff() {
		this.contextRunner.withUserConfiguration(CustomTaskExecutorConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(Executor.class);
			assertThat(context.getBean(Executor.class)).isSameAs(context.getBean('customTaskExecutor'));
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void whenVirtualThreadsAreEnabledAndCustomTaskExecutorIsDefinedThenSimpleAsyncTaskExecutorThatUsesVirtualThreadsBacksOff() {
		this.contextRunner.withUserConfiguration(CustomTaskExecutorConfig.class)
			.withPropertyValues('spring.threads.virtual.enabled=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(Executor.class);
				assertThat(context.getBean(Executor.class)).isSameAs(context.getBean('customTaskExecutor'));
			});
	}
	@Test
	void enableAsyncUsesAutoConfiguredOneByDefault() {
		this.contextRunner.withPropertyValues('spring.task.execution.thread-name-prefix=task-test-')
			.withUserConfiguration(AsyncConfiguration.class, TestBean.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(TaskExecutor.class);
				TestBean bean = context.getBean(TestBean.class);
				String text = bean.echo('something').get();
				assertThat(text).contains('task-test-').contains('something');
			});
	}
	@Test
	void enableAsyncUsesAutoConfiguredOneByDefaultEvenThoughSchedulingIsConfigured() {
		this.contextRunner.withPropertyValues('spring.task.execution.thread-name-prefix=task-test-')
			.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class))
			.withUserConfiguration(AsyncConfiguration.class, SchedulingConfiguration.class, TestBean.class)
			.run((context) -> {
				TestBean bean = context.getBean(TestBean.class);
				String text = bean.echo('something').get();
				assertThat(text).contains('task-test-').contains('something');
			});
	}
	private ContextConsumer<AssertableApplicationContext> assertThreadPoolTaskExecutor(
			Consumer<ThreadPoolTaskExecutor> taskExecutor) {
		return (context) -> {
			assertThat(context).hasSingleBean(ThreadPoolTaskExecutorBuilder.class);
			ThreadPoolTaskExecutorBuilder builder = context.getBean(ThreadPoolTaskExecutorBuilder.class);
			taskExecutor.accept(builder.build());
		};
	}
	private ContextConsumer<AssertableApplicationContext> assertSimpleAsyncTaskExecutor(
			Consumer<SimpleAsyncTaskExecutor> taskExecutor) {
		return (context) -> {
			assertThat(context).hasSingleBean(SimpleAsyncTaskExecutorBuilder.class);
			SimpleAsyncTaskExecutorBuilder builder = context.getBean(SimpleAsyncTaskExecutorBuilder.class);
			taskExecutor.accept(builder.build());
		};
	}
	private String virtualThreadName(SimpleAsyncTaskExecutor taskExecutor) throws InterruptedException {
		AtomicReference<Thread> threadReference = new AtomicReference<>();
		CountDownLatch latch = new CountDownLatch(1);
		taskExecutor.execute(() -> {
			Thread currentThread = Thread.currentThread();
			threadReference.set(currentThread);
			latch.countDown();
		});
		assertThat(latch.await(30, TimeUnit.SECONDS)).isTrue();
		Thread thread = threadReference.get();
		assertThat(thread).extracting('virtual').as('%s is virtual', thread).isEqualTo(true);
		return thread.getName();
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomThreadPoolTaskExecutorBuilderConfig {
		private final ThreadPoolTaskExecutorBuilder builder = new ThreadPoolTaskExecutorBuilder();
		@Bean
		ThreadPoolTaskExecutorBuilder customThreadPoolTaskExecutorBuilder() {
			return this.builder;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TaskDecoratorConfig {
		@Bean
		TaskDecorator mockTaskDecorator() {
			return mock(TaskDecorator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTaskExecutorConfig {
		@Bean
		Executor customTaskExecutor() {
			return new SyncTaskExecutor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAsync
	static class AsyncConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableScheduling
	static class SchedulingConfiguration {
	}
	static class TestBean {
		@Async
		Future<String> echo(String text) {
			return CompletableFuture.completedFuture(Thread.currentThread().getName() + ' ' + text);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.task;
/**
class TaskSchedulingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(TestConfiguration.class)
		.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class));
	@Test
	void noSchedulingDoesNotExposeTaskScheduler() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(TaskScheduler.class));
	}
	@Test
	void noSchedulingDoesNotExposeScheduledBeanLazyInitializationExcludeFilter() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(ScheduledBeanLazyInitializationExcludeFilter.class));
	}
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ThreadPoolTaskSchedulerBuilder.class);
			assertThat(context).hasSingleBean(ThreadPoolTaskScheduler.class);
		});
	}
	@Test
	void enableSchedulingWithNoTaskExecutorAutoConfiguresOne() {
		this.contextRunner
			.withPropertyValues('spring.task.scheduling.shutdown.await-termination=true',
					'spring.task.scheduling.shutdown.await-termination-period=30s',
					'spring.task.scheduling.thread-name-prefix=scheduling-test-')
			.withUserConfiguration(SchedulingConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(TaskExecutor.class);
				TaskExecutor taskExecutor = context.getBean(TaskExecutor.class);
				TestBean bean = context.getBean(TestBean.class);
				assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue();
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('waitForTasksToCompleteOnShutdown', true);
				assertThat(taskExecutor).hasFieldOrPropertyWithValue('awaitTerminationMillis', 30000L);
				assertThat(bean.threadNames).allMatch((name) -> name.contains('scheduling-test-'));
			});
	}
	@Test
	void simpleAsyncTaskSchedulerBuilderShouldReadProperties() {
		this.contextRunner
			.withPropertyValues('spring.task.scheduling.simple.concurrency-limit=1',
					'spring.task.scheduling.thread-name-prefix=scheduling-test-',
					'spring.task.scheduling.shutdown.await-termination=true',
					'spring.task.scheduling.shutdown.await-termination-period=30s')
			.withUserConfiguration(SchedulingConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SimpleAsyncTaskSchedulerBuilder.class);
				SimpleAsyncTaskSchedulerBuilder builder = context.getBean(SimpleAsyncTaskSchedulerBuilder.class);
				assertThat(builder).hasFieldOrPropertyWithValue('threadNamePrefix', 'scheduling-test-');
				assertThat(builder).hasFieldOrPropertyWithValue('concurrencyLimit', 1);
				assertThat(builder).hasFieldOrPropertyWithValue('taskTerminationTimeout', Duration.ofSeconds(30));
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void simpleAsyncTaskSchedulerBuilderShouldUseVirtualThreadsIfEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.withUserConfiguration(SchedulingConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SimpleAsyncTaskSchedulerBuilder.class);
				SimpleAsyncTaskSchedulerBuilder builder = context.getBean(SimpleAsyncTaskSchedulerBuilder.class);
				assertThat(builder).hasFieldOrPropertyWithValue('virtualThreads', true);
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void simpleAsyncTaskSchedulerBuilderShouldUsePlatformThreadsByDefault() {
		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(SimpleAsyncTaskSchedulerBuilder.class);
			SimpleAsyncTaskSchedulerBuilder builder = context.getBean(SimpleAsyncTaskSchedulerBuilder.class);
			assertThat(builder).hasFieldOrPropertyWithValue('virtualThreads', null);
		});
	}
	@Test
	void simpleAsyncTaskSchedulerBuilderShouldApplyCustomizers() {
		SimpleAsyncTaskSchedulerCustomizer customizer = (scheduler) -> {
		};
		this.contextRunner.withBean(SimpleAsyncTaskSchedulerCustomizer.class, () -> customizer)
			.withUserConfiguration(SchedulingConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SimpleAsyncTaskSchedulerBuilder.class);
				SimpleAsyncTaskSchedulerBuilder builder = context.getBean(SimpleAsyncTaskSchedulerBuilder.class);
				assertThat(builder).extracting('customizers')
					.asInstanceOf(InstanceOfAssertFactories.collection(SimpleAsyncTaskSchedulerCustomizer.class))
					.containsExactly(customizer);
			});
	}
	@Test
	void enableSchedulingWithNoTaskExecutorAppliesCustomizers() {
		this.contextRunner.withPropertyValues('spring.task.scheduling.thread-name-prefix=scheduling-test-')
			.withUserConfiguration(SchedulingConfiguration.class, ThreadPoolTaskSchedulerCustomizerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(TaskExecutor.class);
				TestBean bean = context.getBean(TestBean.class);
				assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue();
				assertThat(bean.threadNames).allMatch((name) -> name.contains('customized-scheduler-'));
			});
	}
	@Test
	void enableSchedulingWithExistingTaskSchedulerBacksOff() {
		this.contextRunner.withUserConfiguration(SchedulingConfiguration.class, TaskSchedulerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(TaskScheduler.class);
				assertThat(context.getBean(TaskScheduler.class)).isInstanceOf(TestTaskScheduler.class);
				TestBean bean = context.getBean(TestBean.class);
				assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue();
				assertThat(bean.threadNames).containsExactly('test-1');
			});
	}
	@Test
	void enableSchedulingWithExistingScheduledExecutorServiceBacksOff() {
		this.contextRunner
			.withUserConfiguration(SchedulingConfiguration.class, ScheduledExecutorServiceConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(TaskScheduler.class);
				assertThat(context).hasSingleBean(ScheduledExecutorService.class);
				TestBean bean = context.getBean(TestBean.class);
				assertThat(bean.latch.await(30, TimeUnit.SECONDS)).isTrue();
				assertThat(bean.threadNames).allMatch((name) -> name.contains('pool-'));
			});
	}
	@Test
	void enableSchedulingWithLazyInitializationInvokeScheduledMethods() {
		List<String> threadNames = new ArrayList<>();
		new ApplicationContextRunner()
			.withInitializer(
					(context) -> context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()))
			.withPropertyValues('spring.task.scheduling.thread-name-prefix=scheduling-test-')
			.withBean(LazyTestBean.class, () -> new LazyTestBean(threadNames))
			.withUserConfiguration(SchedulingConfiguration.class)
			.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class))
			.run((context) -> {
				// No lazy lookup.
				Awaitility.waitAtMost(Duration.ofSeconds(3)).until(() -> !threadNames.isEmpty());
				assertThat(threadNames).allMatch((name) -> name.contains('scheduling-test-'));
			});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableScheduling
	static class SchedulingConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TaskSchedulerConfiguration {
		@Bean
		TaskScheduler customTaskScheduler() {
			return new TestTaskScheduler();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ScheduledExecutorServiceConfiguration {
		@Bean
		ScheduledExecutorService customScheduledExecutorService() {
			return Executors.newScheduledThreadPool(2);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ThreadPoolTaskSchedulerCustomizerConfiguration {
		@Bean
		ThreadPoolTaskSchedulerCustomizer testTaskSchedulerCustomizer() {
			return ((taskScheduler) -> taskScheduler.setThreadNamePrefix('customized-scheduler-'));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SchedulingConfigurerConfiguration implements SchedulingConfigurer {
		private final TaskScheduler taskScheduler = new TestTaskScheduler();
		@Override
		public void configureTasks(ScheduledTaskRegistrar taskRegistrar) {
			taskRegistrar.setScheduler(this.taskScheduler);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		TestBean testBean() {
			return new TestBean();
		}
	}
	static class TestBean {
		private final Set<String> threadNames = ConcurrentHashMap.newKeySet();
		private final CountDownLatch latch = new CountDownLatch(1);
		@Scheduled(fixedRate = 60000)
		void accumulate() {
			this.threadNames.add(Thread.currentThread().getName());
			this.latch.countDown();
		}
	}
	static class LazyTestBean {
		private final List<String> threadNames;
		LazyTestBean(List<String> threadNames) {
			this.threadNames = threadNames;
		}
		@Scheduled(fixedRate = 2000)
		void accumulate() {
			this.threadNames.add(Thread.currentThread().getName());
		}
	}
	static class TestTaskScheduler extends ThreadPoolTaskScheduler {
		TestTaskScheduler() {
			setPoolSize(1);
			setThreadNamePrefix('test-');
			afterPropertiesSet();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
@ExtendWith(OutputCaptureExtension.class)
class QuartzAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.datasource.generate-unique-name=true')
		.withConfiguration(AutoConfigurations.of(QuartzAutoConfiguration.class));
	@Test
	void withNoDataSource() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Scheduler.class);
			Scheduler scheduler = context.getBean(Scheduler.class);
			assertThat(scheduler.getMetaData().getJobStoreClass()).isAssignableFrom(RAMJobStore.class);
		});
	}
	@Test
	void withDataSourceUseMemoryByDefault() {
		this.contextRunner
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(Scheduler.class);
				Scheduler scheduler = context.getBean(Scheduler.class);
				assertThat(scheduler.getMetaData().getJobStoreClass()).isAssignableFrom(RAMJobStore.class);
			});
	}
	@Test
	void withDataSource() {
		this.contextRunner.withUserConfiguration(QuartzJobsConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withPropertyValues('spring.quartz.job-store-type=jdbc')
			.run(assertDataSourceInitializedByDataSourceDatabaseScriptInitializer('dataSource'));
	}
	@Test
	void withDataSourceAndInMemoryStoreDoesNotInitializeDataSource() {
		this.contextRunner.withUserConfiguration(QuartzJobsConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withPropertyValues('spring.quartz.job-store-type=memory')
			.run((context) -> {
				JdbcTemplate jdbcTemplate = new JdbcTemplate(context.getBean('dataSource', DataSource.class));
				assertThat(jdbcTemplate.queryForList('SHOW TABLES')
					.stream()
					.map((table) -> (String) table.get('TABLE_NAME'))).noneMatch((name) -> name.startsWith('QRTZ'));
			});
	}
	@Test
	void withDataSourceNoTransactionManager() {
		this.contextRunner.withUserConfiguration(QuartzJobsConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('spring.quartz.job-store-type=jdbc')
			.run(assertDataSourceInitializedByDataSourceDatabaseScriptInitializer('dataSource'));
	}
	@Test
	void dataSourceWithQuartzDataSourceQualifierUsedWhenMultiplePresent() {
		this.contextRunner.withUserConfiguration(QuartzJobsConfiguration.class, MultipleDataSourceConfiguration.class)
			.withPropertyValues('spring.quartz.job-store-type=jdbc')
			.run(assertDataSourceInitializedByDataSourceDatabaseScriptInitializer('quartzDataSource'));
	}
	@Test
	void transactionManagerWithQuartzTransactionManagerUsedWhenMultiplePresent() {
		this.contextRunner
			.withUserConfiguration(QuartzJobsConfiguration.class, MultipleTransactionManagersConfiguration.class)
			.withPropertyValues('spring.quartz.job-store-type=jdbc')
			.run((context) -> {
				SchedulerFactoryBean schedulerFactoryBean = context.getBean(SchedulerFactoryBean.class);
				assertThat(schedulerFactoryBean).extracting('transactionManager')
					.isEqualTo(context.getBean('quartzTransactionManager'));
			});
	}
	@Test
	void withTaskExecutor() {
		this.contextRunner.withUserConfiguration(MockExecutorConfiguration.class)
			.withPropertyValues('spring.quartz.properties.org.quartz.threadPool.threadCount=50')
			.run((context) -> {
				assertThat(context).hasSingleBean(Scheduler.class);
				Scheduler scheduler = context.getBean(Scheduler.class);
				assertThat(scheduler.getMetaData().getThreadPoolSize()).isEqualTo(50);
				Executor executor = context.getBean(Executor.class);
				then(executor).shouldHaveNoInteractions();
			});
	}
	@Test
	void withOverwriteExistingJobs() {
		this.contextRunner.withUserConfiguration(OverwriteTriggerConfiguration.class)
			.withPropertyValues('spring.quartz.overwrite-existing-jobs=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(Scheduler.class);
				Scheduler scheduler = context.getBean(Scheduler.class);
				Trigger fooTrigger = scheduler.getTrigger(TriggerKey.triggerKey('fooTrigger'));
				assertThat(fooTrigger).isNotNull();
				assertThat(((SimpleTrigger) fooTrigger).getRepeatInterval()).isEqualTo(30000);
			});
	}
	@Test
	void withConfiguredJobAndTrigger(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(QuartzFullConfiguration.class)
			.withPropertyValues('test-name=withConfiguredJobAndTrigger')
			.run((context) -> {
				assertThat(context).hasSingleBean(Scheduler.class);
				Scheduler scheduler = context.getBean(Scheduler.class);
				assertThat(scheduler.getJobDetail(JobKey.jobKey('fooJob'))).isNotNull();
				assertThat(scheduler.getTrigger(TriggerKey.triggerKey('fooTrigger'))).isNotNull();
				Awaitility.waitAtMost(Duration.ofSeconds(5))
					.untilAsserted(
							() -> assertThat(output).contains('withConfiguredJobAndTrigger').contains('jobDataValue'));
			});
	}
	@Test
	void withConfiguredCalendars() {
		this.contextRunner.withUserConfiguration(QuartzCalendarsConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Scheduler.class);
			Scheduler scheduler = context.getBean(Scheduler.class);
			assertThat(scheduler.getCalendar('weekly')).isNotNull();
			assertThat(scheduler.getCalendar('monthly')).isNotNull();
		});
	}
	@Test
	void withQuartzProperties() {
		this.contextRunner.withPropertyValues('spring.quartz.properties.org.quartz.scheduler.instanceId=FOO')
			.run((context) -> {
				assertThat(context).hasSingleBean(Scheduler.class);
				Scheduler scheduler = context.getBean(Scheduler.class);
				assertThat(scheduler.getSchedulerInstanceId()).isEqualTo('FOO');
			});
	}
	@Test
	void withCustomizer() {
		this.contextRunner.withUserConfiguration(QuartzCustomConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Scheduler.class);
			Scheduler scheduler = context.getBean(Scheduler.class);
			assertThat(scheduler.getSchedulerName()).isEqualTo('fooScheduler');
		});
	}
	@Test
	void validateDefaultProperties() {
		this.contextRunner.withUserConfiguration(ManualSchedulerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(SchedulerFactoryBean.class);
			SchedulerFactoryBean schedulerFactory = context.getBean(SchedulerFactoryBean.class);
			QuartzProperties properties = new QuartzProperties();
			assertThat(properties.isAutoStartup()).isEqualTo(schedulerFactory.isAutoStartup());
			assertThat(schedulerFactory).hasFieldOrPropertyWithValue('startupDelay',
					(int) properties.getStartupDelay().getSeconds());
			assertThat(schedulerFactory).hasFieldOrPropertyWithValue('waitForJobsToCompleteOnShutdown',
					properties.isWaitForJobsToCompleteOnShutdown());
			assertThat(schedulerFactory).hasFieldOrPropertyWithValue('overwriteExistingJobs',
					properties.isOverwriteExistingJobs());
		});
	}
	@Test
	void withCustomConfiguration() {
		this.contextRunner
			.withPropertyValues('spring.quartz.auto-startup=false', 'spring.quartz.startup-delay=1m',
					'spring.quartz.wait-for-jobs-to-complete-on-shutdown=true',
					'spring.quartz.overwrite-existing-jobs=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(SchedulerFactoryBean.class);
				SchedulerFactoryBean schedulerFactory = context.getBean(SchedulerFactoryBean.class);
				assertThat(schedulerFactory.isAutoStartup()).isFalse();
				assertThat(schedulerFactory).hasFieldOrPropertyWithValue('startupDelay', 60);
				assertThat(schedulerFactory).hasFieldOrPropertyWithValue('waitForJobsToCompleteOnShutdown', true);
				assertThat(schedulerFactory).hasFieldOrPropertyWithValue('overwriteExistingJobs', true);
			});
	}
	@Test
	void withLiquibase() {
		this.contextRunner.withUserConfiguration(QuartzJobsConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class, LiquibaseAutoConfiguration.class))
			.withPropertyValues('spring.quartz.job-store-type=jdbc', 'spring.quartz.jdbc.initialize-schema=never',
					'spring.liquibase.change-log=classpath:org/quartz/impl/jdbcjobstore/liquibase.quartz.init.xml')
			.run(assertDataSourceInitialized('dataSource').andThen(
					(context) -> assertThat(context).doesNotHaveBean(QuartzDataSourceScriptDatabaseInitializer.class)));
	}
	@Test
	void withFlyway(@TempDir Path flywayLocation) throws Exception {
		ClassPathResource tablesResource = new ClassPathResource('org/quartz/impl/jdbcjobstore/tables_h2.sql');
		try (InputStream stream = tablesResource.getInputStream()) {
			Files.copy(stream, flywayLocation.resolve('V2__quartz.sql'));
		}
		this.contextRunner.withUserConfiguration(QuartzJobsConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class, FlywayAutoConfiguration.class))
			.withPropertyValues('spring.quartz.job-store-type=jdbc', 'spring.quartz.jdbc.initialize-schema=never',
					'spring.flyway.locations=filesystem:' + flywayLocation, 'spring.flyway.baseline-on-migrate=true')
			.run(assertDataSourceInitialized('dataSource').andThen(
					(context) -> assertThat(context).doesNotHaveBean(QuartzDataSourceScriptDatabaseInitializer.class)));
	}
	@Test
	void schedulerNameWithDedicatedProperty() {
		this.contextRunner.withPropertyValues('spring.quartz.scheduler-name=testScheduler')
			.run(assertSchedulerName('testScheduler'));
	}
	@Test
	void schedulerNameWithQuartzProperty() {
		this.contextRunner
			.withPropertyValues('spring.quartz.properties.org.quartz.scheduler.instanceName=testScheduler')
			.run(assertSchedulerName('testScheduler'));
	}
	@Test
	void schedulerNameWithDedicatedPropertyTakesPrecedence() {
		this.contextRunner
			.withPropertyValues('spring.quartz.scheduler-name=specificTestScheduler',
					'spring.quartz.properties.org.quartz.scheduler.instanceName=testScheduler')
			.run(assertSchedulerName('specificTestScheduler'));
	}
	@Test
	void schedulerNameUseBeanNameByDefault() {
		this.contextRunner.withPropertyValues().run(assertSchedulerName('quartzScheduler'));
	}
	@Test
	void whenTheUserDefinesTheirOwnQuartzDatabaseInitializerThenTheAutoConfiguredInitializerBacksOff() {
		this.contextRunner.withUserConfiguration(CustomQuartzDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withPropertyValues('spring.quartz.job-store-type=jdbc')
			.run((context) -> assertThat(context).hasSingleBean(QuartzDataSourceScriptDatabaseInitializer.class)
				.doesNotHaveBean('quartzDataSourceScriptDatabaseInitializer')
				.hasBean('customInitializer'));
	}
	@Test
	void whenTheUserDefinesTheirOwnDatabaseInitializerThenTheAutoConfiguredQuartzInitializerRemains() {
		this.contextRunner.withUserConfiguration(CustomDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withPropertyValues('spring.quartz.job-store-type=jdbc')
			.run((context) -> assertThat(context).hasSingleBean(QuartzDataSourceScriptDatabaseInitializer.class)
				.hasBean('customInitializer'));
	}
	private ContextConsumer<AssertableApplicationContext> assertDataSourceInitialized(String dataSourceName) {
		return (context) -> {
			assertThat(context).hasSingleBean(Scheduler.class);
			Scheduler scheduler = context.getBean(Scheduler.class);
			assertThat(scheduler.getMetaData().getJobStoreClass()).isAssignableFrom(LocalDataSourceJobStore.class);
			JdbcTemplate jdbcTemplate = new JdbcTemplate(context.getBean(dataSourceName, DataSource.class));
			assertThat(jdbcTemplate.queryForObject('SELECT COUNT(*) FROM QRTZ_JOB_DETAILS', Integer.class))
				.isEqualTo(2);
			assertThat(jdbcTemplate.queryForObject('SELECT COUNT(*) FROM QRTZ_SIMPLE_TRIGGERS', Integer.class))
				.isZero();
		};
	}
	private ContextConsumer<AssertableApplicationContext> assertDataSourceInitializedByDataSourceDatabaseScriptInitializer(
			String dataSourceName) {
		return assertDataSourceInitialized(dataSourceName).andThen((context) -> {
			assertThat(context).hasSingleBean(QuartzDataSourceScriptDatabaseInitializer.class);
			QuartzDataSourceScriptDatabaseInitializer initializer = context
				.getBean(QuartzDataSourceScriptDatabaseInitializer.class);
			assertThat(initializer).hasFieldOrPropertyWithValue('dataSource', context.getBean(dataSourceName));
		});
	}
	private ContextConsumer<AssertableApplicationContext> assertSchedulerName(String schedulerName) {
		return (context) -> {
			assertThat(context).hasSingleBean(SchedulerFactoryBean.class);
			SchedulerFactoryBean schedulerFactory = context.getBean(SchedulerFactoryBean.class);
			assertThat(schedulerFactory).hasFieldOrPropertyWithValue('schedulerName', schedulerName);
		};
	}
	@Import(ComponentThatUsesScheduler.class)
	@Configuration(proxyBeanMethods = false)
	static class BaseQuartzConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class QuartzJobsConfiguration extends BaseQuartzConfiguration {
		@Bean
		JobDetail fooJob() {
			return JobBuilder.newJob().ofType(FooJob.class).withIdentity('fooJob').storeDurably().build();
		}
		@Bean
		JobDetail barJob() {
			return JobBuilder.newJob().ofType(FooJob.class).withIdentity('barJob').storeDurably().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class QuartzFullConfiguration extends BaseQuartzConfiguration {
		@Bean
		JobDetail fooJob() {
			return JobBuilder.newJob()
				.ofType(FooJob.class)
				.withIdentity('fooJob')
				.usingJobData('jobDataKey', 'jobDataValue')
				.storeDurably()
				.build();
		}
		@Bean
		Trigger fooTrigger(JobDetail jobDetail) {
			SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
				.withIntervalInSeconds(10)
				.repeatForever();
			return TriggerBuilder.newTrigger()
				.forJob(jobDetail)
				.withIdentity('fooTrigger')
				.withSchedule(scheduleBuilder)
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(QuartzFullConfiguration.class)
	static class OverwriteTriggerConfiguration extends BaseQuartzConfiguration {
		@Bean
		Trigger anotherFooTrigger(JobDetail fooJob) {
			SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
				.withIntervalInSeconds(30)
				.repeatForever();
			return TriggerBuilder.newTrigger()
				.forJob(fooJob)
				.withIdentity('fooTrigger')
				.withSchedule(scheduleBuilder)
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class QuartzCalendarsConfiguration extends BaseQuartzConfiguration {
		@Bean
		Calendar weekly() {
			return new WeeklyCalendar();
		}
		@Bean
		Calendar monthly() {
			return new MonthlyCalendar();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MockExecutorConfiguration extends BaseQuartzConfiguration {
		@Bean
		Executor executor() {
			return mock(Executor.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class QuartzCustomConfiguration extends BaseQuartzConfiguration {
		@Bean
		SchedulerFactoryBeanCustomizer customizer() {
			return (schedulerFactoryBean) -> schedulerFactoryBean.setSchedulerName('fooScheduler');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ManualSchedulerConfiguration {
		@Bean
		SchedulerFactoryBean quartzScheduler() {
			return new SchedulerFactoryBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleDataSourceConfiguration extends BaseQuartzConfiguration {
		@Bean
		@Primary
		DataSource applicationDataSource() throws Exception {
			return createTestDataSource();
		}
		@QuartzDataSource
		@Bean
		DataSource quartzDataSource() throws Exception {
			return createTestDataSource();
		}
		private DataSource createTestDataSource() throws Exception {
			DataSourceProperties properties = new DataSourceProperties();
			properties.setGenerateUniqueName(true);
			properties.afterPropertiesSet();
			return properties.initializeDataSourceBuilder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleTransactionManagersConfiguration extends BaseQuartzConfiguration {
		private final DataSource primaryDataSource = createTestDataSource();
		private final DataSource quartzDataSource = createTestDataSource();
		@Bean
		@Primary
		DataSource applicationDataSource() {
			return this.primaryDataSource;
		}
		@Bean
		@QuartzDataSource
		DataSource quartzDataSource() {
			return this.quartzDataSource;
		}
		@Bean
		@Primary
		PlatformTransactionManager applicationTransactionManager() {
			return new DataSourceTransactionManager(this.primaryDataSource);
		}
		@Bean
		@QuartzTransactionManager
		PlatformTransactionManager quartzTransactionManager() {
			return new DataSourceTransactionManager(this.quartzDataSource);
		}
		private DataSource createTestDataSource() {
			DataSourceProperties properties = new DataSourceProperties();
			properties.setGenerateUniqueName(true);
			try {
				properties.afterPropertiesSet();
			}
			catch (Exception ex) {
				throw new RuntimeException(ex);
			}
			return properties.initializeDataSourceBuilder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomQuartzDatabaseInitializerConfiguration {
		@Bean
		QuartzDataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource,
				QuartzProperties properties) {
			return new QuartzDataSourceScriptDatabaseInitializer(dataSource, properties);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDatabaseInitializerConfiguration {
		@Bean
		DataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource) {
			return new DataSourceScriptDatabaseInitializer(dataSource, new DatabaseInitializationSettings());
		}
	}
	static class ComponentThatUsesScheduler {
		ComponentThatUsesScheduler(Scheduler scheduler) {
			Assert.notNull(scheduler, 'Scheduler must not be null');
		}
	}
	public static class FooJob extends QuartzJobBean {
		@Autowired
		private Environment env;
		private String jobDataKey;
		@Override
		protected void executeInternal(JobExecutionContext context) {
			System.out.println(this.env.getProperty('test-name', 'unknown') + ' - ' + this.jobDataKey);
		}
		public void setJobDataKey(String jobDataKey) {
			this.jobDataKey = jobDataKey;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
class QuartzDataSourceScriptDatabaseInitializerTests {
	@Test
	void getSettingsWithPlatformDoesNotTouchDataSource() {
		DataSource dataSource = mock(DataSource.class);
		QuartzProperties properties = new QuartzProperties();
		properties.getJdbc().setPlatform('test');
		DatabaseInitializationSettings settings = QuartzDataSourceScriptDatabaseInitializer.getSettings(dataSource,
				properties);
		assertThat(settings.getSchemaLocations())
			.containsOnly('classpath:org/quartz/impl/jdbcjobstore/tables_test.sql');
		then(dataSource).shouldHaveNoInteractions();
	}
	@Test
	void customizeSetCommentPrefixes() {
		QuartzProperties properties = new QuartzProperties();
		properties.getJdbc().setPlatform('test');
		properties.getJdbc().setCommentPrefix(Arrays.asList('##', '--'));
		QuartzDataSourceScriptDatabaseInitializer initializer = new QuartzDataSourceScriptDatabaseInitializer(
				mock(DataSource.class), properties);
		ResourceDatabasePopulator populator = mock(ResourceDatabasePopulator.class);
		initializer.customize(populator);
		then(populator).should().setCommentPrefixes('##', '--');
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationReplacementsTests {
	private final AutoConfigurationReplacements replacements = AutoConfigurationReplacements
		.load(TestAutoConfigurationReplacements.class, null);
	@Test
	void replaceWhenMatchReplacesClassName() {
		assertThat(this.replacements.replace('com.example.A1')).isEqualTo('com.example.A2');
	}
	@Test
	void replaceWhenNoMatchReturnsOriginalClassName() {
		assertThat(this.replacements.replace('com.example.Z1')).isEqualTo('com.example.Z1');
	}
	@Test
	void replaceAllReplacesAllMatching() {
		Set<String> classNames = new LinkedHashSet<>(
				List.of('com.example.A1', 'com.example.B1', 'com.example.Y1', 'com.example.Z1'));
		assertThat(this.replacements.replaceAll(classNames)).containsExactly('com.example.A2', 'com.example.B2',
				'com.example.Y1', 'com.example.Z1');
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@interface TestAutoConfigurationReplacements {
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
abstract class AbstractCacheAutoConfigurationTests {
	protected final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CacheAutoConfiguration.class));
	protected <T extends CacheManager> T getCacheManager(AssertableApplicationContext loaded, Class<T> type) {
		CacheManager cacheManager = loaded.getBean(CacheManager.class);
		assertThat(cacheManager).as('Wrong cache manager type').isInstanceOf(type);
		return type.cast(cacheManager);
	}
	@SuppressWarnings('rawtypes')
	protected ContextConsumer<AssertableApplicationContext> verifyCustomizers(String... expectedCustomizerNames) {
		return (context) -> {
			CacheManager cacheManager = getCacheManager(context, CacheManager.class);
			List<String> expected = new ArrayList<>(Arrays.asList(expectedCustomizerNames));
			Map<String, CacheManagerTestCustomizer> customizer = context
				.getBeansOfType(CacheManagerTestCustomizer.class);
			customizer.forEach((key, value) -> {
				if (expected.contains(key)) {
					expected.remove(key);
					assertThat(value.cacheManager).isSameAs(cacheManager);
				}
				else {
					assertThat(value.cacheManager).isNull();
				}
			});
			assertThat(expected).isEmpty();
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class CacheManagerCustomizersConfiguration {
		@Bean
		CacheManagerCustomizer<CacheManager> allCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<ConcurrentMapCacheManager> simpleCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<SimpleCacheManager> genericCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<CouchbaseCacheManager> couchbaseCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<RedisCacheManager> redisCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<HazelcastCacheManager> hazelcastCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<SpringEmbeddedCacheManager> infinispanCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<SpringCache2kCacheManager> cache2kCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
		@Bean
		CacheManagerCustomizer<CaffeineCacheManager> caffeineCacheManagerCustomizer() {
			return new CacheManagerTestCustomizer<>() {
			};
		}
	}
	abstract static class CacheManagerTestCustomizer<T extends CacheManager> implements CacheManagerCustomizer<T> {
		T cacheManager;
		@Override
		public void customize(T cacheManager) {
			if (this.cacheManager != null) {
				throw new IllegalStateException('Customized invoked twice');
			}
			this.cacheManager = cacheManager;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
class CacheManagerCustomizersTests {
	@Test
	void customizeWithNullCustomizersShouldDoNothing() {
		new CacheManagerCustomizers(null).customize(mock(CacheManager.class));
	}
	@Test
	void customizeSimpleCacheManager() {
		CacheManagerCustomizers customizers = new CacheManagerCustomizers(
				Collections.singletonList(new CacheNamesCacheManagerCustomizer()));
		ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();
		customizers.customize(cacheManager);
		assertThat(cacheManager.getCacheNames()).containsOnly('one', 'two');
	}
	@Test
	void customizeShouldCheckGeneric() {
		List<TestCustomizer<?>> list = new ArrayList<>();
		list.add(new TestCustomizer<>());
		list.add(new TestConcurrentMapCacheManagerCustomizer());
		CacheManagerCustomizers customizers = new CacheManagerCustomizers(list);
		customizers.customize(mock(CacheManager.class));
		assertThat(list.get(0).getCount()).isOne();
		assertThat(list.get(1).getCount()).isZero();
		customizers.customize(mock(ConcurrentMapCacheManager.class));
		assertThat(list.get(0).getCount()).isEqualTo(2);
		assertThat(list.get(1).getCount()).isOne();
		customizers.customize(mock(CaffeineCacheManager.class));
		assertThat(list.get(0).getCount()).isEqualTo(3);
		assertThat(list.get(1).getCount()).isOne();
	}
	static class CacheNamesCacheManagerCustomizer implements CacheManagerCustomizer<ConcurrentMapCacheManager> {
		@Override
		public void customize(ConcurrentMapCacheManager cacheManager) {
			cacheManager.setCacheNames(Arrays.asList('one', 'two'));
		}
	}
	static class TestCustomizer<T extends CacheManager> implements CacheManagerCustomizer<T> {
		private int count;
		@Override
		public void customize(T cacheManager) {
			this.count++;
		}
		int getCount() {
			return this.count;
		}
	}
	static class TestConcurrentMapCacheManagerCustomizer extends TestCustomizer<ConcurrentMapCacheManager> {
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@ClassPathExclusions('hazelcast-client-*.jar')
class CacheAutoConfigurationTests extends AbstractCacheAutoConfigurationTests {
	@Test
	void noEnableCaching() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(CacheManager.class));
	}
	@Test
	void cacheManagerBackOff() {
		this.contextRunner.withUserConfiguration(CustomCacheManagerConfiguration.class)
			.run((context) -> assertThat(getCacheManager(context, ConcurrentMapCacheManager.class).getCacheNames())
				.containsOnly('custom1'));
	}
	@Test
	void cacheManagerFromSupportBackOff() {
		this.contextRunner.withUserConfiguration(CustomCacheManagerFromSupportConfiguration.class)
			.run((context) -> assertThat(getCacheManager(context, ConcurrentMapCacheManager.class).getCacheNames())
				.containsOnly('custom1'));
	}
	@Test
	void cacheResolverFromSupportBackOff() {
		this.contextRunner.withUserConfiguration(CustomCacheResolverFromSupportConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(CacheManager.class));
	}
	@Test
	void customCacheResolverCanBeDefined() {
		this.contextRunner.withUserConfiguration(SpecificCacheResolverConfiguration.class)
			.withPropertyValues('spring.cache.type=simple')
			.run((context) -> {
				getCacheManager(context, ConcurrentMapCacheManager.class);
				assertThat(context).hasSingleBean(CacheResolver.class);
			});
	}
	@Test
	void notSupportedCachingMode() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=foobar')
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.rootCause()
				.hasMessageContaining('No enum constant')
				.hasMessageContaining('foobar'));
	}
	@Test
	void simpleCacheExplicit() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=simple')
			.run((context) -> assertThat(getCacheManager(context, ConcurrentMapCacheManager.class).getCacheNames())
				.isEmpty());
	}
	@Test
	void simpleCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(DefaultCacheAndCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=simple')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'simpleCacheManagerCustomizer'));
	}
	@Test
	void simpleCacheExplicitWithCacheNames() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=simple', 'spring.cache.cacheNames[0]=foo',
					'spring.cache.cacheNames[1]=bar')
			.run((context) -> {
				ConcurrentMapCacheManager cacheManager = getCacheManager(context, ConcurrentMapCacheManager.class);
				assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
			});
	}
	@Test
	void genericCacheWithCaches() {
		this.contextRunner.withUserConfiguration(GenericCacheConfiguration.class).run((context) -> {
			SimpleCacheManager cacheManager = getCacheManager(context, SimpleCacheManager.class);
			assertThat(cacheManager.getCache('first')).isEqualTo(context.getBean('firstCache'));
			assertThat(cacheManager.getCache('second')).isEqualTo(context.getBean('secondCache'));
			assertThat(cacheManager.getCacheNames()).hasSize(2);
		});
	}
	@Test
	void genericCacheExplicit() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=generic')
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('No cache manager could be auto-configured')
				.hasMessageContaining('GENERIC'));
	}
	@Test
	void genericCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(GenericCacheAndCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=generic')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'genericCacheManagerCustomizer'));
	}
	@Test
	void genericCacheExplicitWithCaches() {
		this.contextRunner.withUserConfiguration(GenericCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=generic')
			.run((context) -> {
				SimpleCacheManager cacheManager = getCacheManager(context, SimpleCacheManager.class);
				assertThat(cacheManager.getCache('first')).isEqualTo(context.getBean('firstCache'));
				assertThat(cacheManager.getCache('second')).isEqualTo(context.getBean('secondCache'));
				assertThat(cacheManager.getCacheNames()).hasSize(2);
			});
	}
	@Test
	void couchbaseCacheExplicit() {
		this.contextRunner.withUserConfiguration(CouchbaseConfiguration.class)
			.withPropertyValues('spring.cache.type=couchbase')
			.run((context) -> {
				CouchbaseCacheManager cacheManager = getCacheManager(context, CouchbaseCacheManager.class);
				assertThat(cacheManager.getCacheNames()).isEmpty();
			});
	}
	@Test
	void couchbaseCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(CouchbaseWithCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=couchbase')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'couchbaseCacheManagerCustomizer'));
	}
	@Test
	void couchbaseCacheExplicitWithCaches() {
		this.contextRunner.withUserConfiguration(CouchbaseConfiguration.class)
			.withPropertyValues('spring.cache.type=couchbase', 'spring.cache.cacheNames[0]=foo',
					'spring.cache.cacheNames[1]=bar')
			.run((context) -> {
				CouchbaseCacheManager cacheManager = getCacheManager(context, CouchbaseCacheManager.class);
				assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
				Cache cache = cacheManager.getCache('foo');
				assertThat(cache).isInstanceOf(CouchbaseCache.class);
				assertThat(((CouchbaseCache) cache).getCacheConfiguration().getExpiry()).hasSeconds(0);
			});
	}
	@Test
	void couchbaseCacheExplicitWithTtl() {
		this.contextRunner.withUserConfiguration(CouchbaseConfiguration.class)
			.withPropertyValues('spring.cache.type=couchbase', 'spring.cache.cacheNames=foo,bar',
					'spring.cache.couchbase.expiration=2000')
			.run((context) -> {
				CouchbaseCacheManager cacheManager = getCacheManager(context, CouchbaseCacheManager.class);
				assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
				Cache cache = cacheManager.getCache('foo');
				assertThat(cache).isInstanceOf(CouchbaseCache.class);
				assertThat(((CouchbaseCache) cache).getCacheConfiguration().getExpiry()).hasSeconds(2);
			});
	}
	@Test
	void couchbaseCacheWithCouchbaseCacheManagerBuilderCustomizer() {
		this.contextRunner.withUserConfiguration(CouchbaseConfiguration.class)
			.withPropertyValues('spring.cache.type=couchbase', 'spring.cache.couchbase.expiration=15s')
			.withBean(CouchbaseCacheManagerBuilderCustomizer.class,
					() -> (builder) -> builder.cacheDefaults(CouchbaseCacheConfiguration.defaultCacheConfig()
						.entryExpiry(java.time.Duration.ofSeconds(10))))
			.run((context) -> {
				CouchbaseCacheManager cacheManager = getCacheManager(context, CouchbaseCacheManager.class);
				CouchbaseCacheConfiguration couchbaseCacheConfiguration = getDefaultCouchbaseCacheConfiguration(
						cacheManager);
				assertThat(couchbaseCacheConfiguration.getExpiry()).isEqualTo(java.time.Duration.ofSeconds(10));
			});
	}
	@Test
	void redisCacheExplicit() {
		this.contextRunner.withUserConfiguration(RedisConfiguration.class)
			.withPropertyValues('spring.cache.type=redis', 'spring.cache.redis.time-to-live=15000',
					'spring.cache.redis.cacheNullValues=false', 'spring.cache.redis.keyPrefix=prefix',
					'spring.cache.redis.useKeyPrefix=true')
			.run((context) -> {
				RedisCacheManager cacheManager = getCacheManager(context, RedisCacheManager.class);
				assertThat(cacheManager.getCacheNames()).isEmpty();
				RedisCacheConfiguration redisCacheConfiguration = getDefaultRedisCacheConfiguration(cacheManager);
				assertThat(redisCacheConfiguration).extracting(RedisCacheConfiguration::getTtlFunction)
					.isInstanceOf(FixedDurationTtlFunction.class)
					.extracting('duration')
					.isEqualTo(java.time.Duration.ofSeconds(15));
				assertThat(redisCacheConfiguration.getAllowCacheNullValues()).isFalse();
				assertThat(redisCacheConfiguration.getKeyPrefixFor('MyCache')).isEqualTo('prefixMyCache::');
				assertThat(redisCacheConfiguration.usePrefix()).isTrue();
			});
	}
	@Test
	void redisCacheWithRedisCacheConfiguration() {
		this.contextRunner.withUserConfiguration(RedisWithCacheConfigurationConfiguration.class)
			.withPropertyValues('spring.cache.type=redis', 'spring.cache.redis.time-to-live=15000',
					'spring.cache.redis.keyPrefix=foo')
			.run((context) -> {
				RedisCacheManager cacheManager = getCacheManager(context, RedisCacheManager.class);
				assertThat(cacheManager.getCacheNames()).isEmpty();
				RedisCacheConfiguration redisCacheConfiguration = getDefaultRedisCacheConfiguration(cacheManager);
				assertThat(redisCacheConfiguration).extracting(RedisCacheConfiguration::getTtlFunction)
					.isInstanceOf(FixedDurationTtlFunction.class)
					.extracting('duration')
					.isEqualTo(java.time.Duration.ofSeconds(30));
				assertThat(redisCacheConfiguration.getKeyPrefixFor('')).isEqualTo('bar::');
			});
	}
	@Test
	void redisCacheWithRedisCacheManagerBuilderCustomizer() {
		this.contextRunner.withUserConfiguration(RedisWithRedisCacheManagerBuilderCustomizerConfiguration.class)
			.withPropertyValues('spring.cache.type=redis', 'spring.cache.redis.time-to-live=15000')
			.run((context) -> {
				RedisCacheManager cacheManager = getCacheManager(context, RedisCacheManager.class);
				RedisCacheConfiguration redisCacheConfiguration = getDefaultRedisCacheConfiguration(cacheManager);
				assertThat(redisCacheConfiguration).extracting(RedisCacheConfiguration::getTtlFunction)
					.isInstanceOf(FixedDurationTtlFunction.class)
					.extracting('duration')
					.isEqualTo(java.time.Duration.ofSeconds(10));
			});
	}
	@Test
	void redisCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(RedisWithCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=redis')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'redisCacheManagerCustomizer'));
	}
	@Test
	void redisCacheExplicitWithCaches() {
		this.contextRunner.withUserConfiguration(RedisConfiguration.class)
			.withPropertyValues('spring.cache.type=redis', 'spring.cache.cacheNames[0]=foo',
					'spring.cache.cacheNames[1]=bar')
			.run((context) -> {
				RedisCacheManager cacheManager = getCacheManager(context, RedisCacheManager.class);
				assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
				RedisCacheConfiguration redisCacheConfiguration = getDefaultRedisCacheConfiguration(cacheManager);
				assertThat(redisCacheConfiguration).extracting(RedisCacheConfiguration::getTtlFunction)
					.isInstanceOf(FixedDurationTtlFunction.class)
					.extracting('duration')
					.isEqualTo(java.time.Duration.ofSeconds(0));
				assertThat(redisCacheConfiguration.getAllowCacheNullValues()).isTrue();
				assertThat(redisCacheConfiguration.getKeyPrefixFor('test')).isEqualTo('test::');
				assertThat(redisCacheConfiguration.usePrefix()).isTrue();
			});
	}
	@Test
	void noOpCacheExplicit() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=none')
			.run((context) -> {
				NoOpCacheManager cacheManager = getCacheManager(context, NoOpCacheManager.class);
				assertThat(cacheManager.getCacheNames()).isEmpty();
			});
	}
	@Test
	void jCacheCacheNoProviderExplicit() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache')
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('No cache manager could be auto-configured')
				.hasMessageContaining('JCACHE'));
	}
	@Test
	void jCacheCacheWithProvider() {
		String cachingProviderFqn = MockCachingProvider.class.getName();
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn)
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				assertThat(cacheManager.getCacheNames()).isEmpty();
				assertThat(context.getBean(javax.cache.CacheManager.class)).isEqualTo(cacheManager.getCacheManager());
			});
	}
	@Test
	void jCacheCacheWithCaches() {
		String cachingProviderFqn = MockCachingProvider.class.getName();
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
					'spring.cache.cacheNames[0]=foo', 'spring.cache.cacheNames[1]=bar')
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
			});
	}
	@Test
	void jCacheCacheWithCachesAndCustomConfig() {
		String cachingProviderFqn = MockCachingProvider.class.getName();
		this.contextRunner.withUserConfiguration(JCacheCustomConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
					'spring.cache.cacheNames[0]=one', 'spring.cache.cacheNames[1]=two')
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				assertThat(cacheManager.getCacheNames()).containsOnly('one', 'two');
				CompleteConfiguration<?, ?> defaultCacheConfiguration = context.getBean(CompleteConfiguration.class);
				MockCacheManager mockCacheManager = (MockCacheManager) cacheManager.getCacheManager();
				assertThat(mockCacheManager.getConfigurations()).containsEntry('one', defaultCacheConfiguration)
					.containsEntry('two', defaultCacheConfiguration);
			});
	}
	@Test
	void jCacheCacheWithExistingJCacheManager() {
		this.contextRunner.withUserConfiguration(JCacheCustomCacheManager.class)
			.withPropertyValues('spring.cache.type=jcache')
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				assertThat(cacheManager.getCacheManager()).isEqualTo(context.getBean('customJCacheCacheManager'));
			});
	}
	@Test
	void jCacheCacheWithUnknownProvider() {
		String wrongCachingProviderClassName = 'org.acme.FooBar';
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache',
					'spring.cache.jcache.provider=' + wrongCachingProviderClassName)
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining(wrongCachingProviderClassName));
	}
	@Test
	void jCacheCacheWithConfig() {
		String cachingProviderFqn = MockCachingProvider.class.getName();
		String configLocation = 'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.xml';
		this.contextRunner.withUserConfiguration(JCacheCustomConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
					'spring.cache.jcache.config=' + configLocation)
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				Resource configResource = new ClassPathResource(configLocation);
				assertThat(cacheManager.getCacheManager().getURI()).isEqualTo(configResource.getURI());
			});
	}
	@Test
	void jCacheCacheWithWrongConfig() {
		String cachingProviderFqn = MockCachingProvider.class.getName();
		String configLocation = 'org/springframework/boot/autoconfigure/cache/does-not-exist.xml';
		this.contextRunner.withUserConfiguration(JCacheCustomConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
					'spring.cache.jcache.config=' + configLocation)
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('does not exist')
				.hasMessageContaining(configLocation));
	}
	@Test
	void jCacheCacheUseBeanClassLoader() {
		String cachingProviderFqn = MockCachingProvider.class.getName();
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn)
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				assertThat(cacheManager.getCacheManager().getClassLoader()).isEqualTo(context.getClassLoader());
			});
	}
	@Test
	void jCacheCacheWithPropertiesCustomizer() {
		JCachePropertiesCustomizer customizer = mock(JCachePropertiesCustomizer.class);
		willAnswer((invocation) -> {
			invocation.getArgument(0, Properties.class).setProperty('customized', 'true');
			return null;
		}).given(customizer).customize(any(Properties.class));
		String cachingProviderFqn = MockCachingProvider.class.getName();
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn)
			.withBean(JCachePropertiesCustomizer.class, () -> customizer)
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				assertThat(cacheManager.getCacheManager().getProperties()).containsEntry('customized', 'true');
			});
	}
	@Test
	void hazelcastCacheExplicit() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class))
			.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=hazelcast')
			.run((context) -> {
				HazelcastCacheManager cacheManager = getCacheManager(context, HazelcastCacheManager.class);
				// NOTE: the hazelcast implementation knows about a cache in a lazy
				// manner.
				cacheManager.getCache('defaultCache');
				assertThat(cacheManager.getCacheNames()).containsOnly('defaultCache');
				assertThat(context.getBean(HazelcastInstance.class)).isEqualTo(cacheManager.getHazelcastInstance());
			});
	}
	@Test
	void hazelcastCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(HazelcastCacheAndCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=hazelcast')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'hazelcastCacheManagerCustomizer'));
	}
	@Test
	void hazelcastCacheWithExistingHazelcastInstance() {
		this.contextRunner.withUserConfiguration(HazelcastCustomHazelcastInstance.class)
			.withPropertyValues('spring.cache.type=hazelcast')
			.run((context) -> {
				HazelcastCacheManager cacheManager = getCacheManager(context, HazelcastCacheManager.class);
				assertThat(cacheManager.getHazelcastInstance()).isEqualTo(context.getBean('customHazelcastInstance'));
			});
	}
	@Test
	void hazelcastCacheWithHazelcastAutoConfiguration() {
		String hazelcastConfig = 'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.xml';
		this.contextRunner.withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class))
			.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=hazelcast', 'spring.hazelcast.config=' + hazelcastConfig)
			.run((context) -> {
				HazelcastCacheManager cacheManager = getCacheManager(context, HazelcastCacheManager.class);
				HazelcastInstance hazelcastInstance = context.getBean(HazelcastInstance.class);
				assertThat(cacheManager.getHazelcastInstance()).isSameAs(hazelcastInstance);
				assertThat(hazelcastInstance.getConfig().getConfigurationFile())
					.isEqualTo(new ClassPathResource(hazelcastConfig).getFile());
				assertThat(cacheManager.getCache('foobar')).isNotNull();
				assertThat(cacheManager.getCacheNames()).containsOnly('foobar');
			});
	}
	@Test
	void hazelcastAsJCacheWithCaches() {
		String cachingProviderFqn = HazelcastServerCachingProvider.class.getName();
		try {
			this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
				.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
						'spring.cache.cacheNames[0]=foo', 'spring.cache.cacheNames[1]=bar')
				.run((context) -> {
					JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
					assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
					assertThat(Hazelcast.getAllHazelcastInstances()).hasSize(1);
				});
		}
		finally {
			Caching.getCachingProvider(cachingProviderFqn).close();
		}
	}
	@Test
	void hazelcastAsJCacheWithConfig() {
		String cachingProviderFqn = HazelcastServerCachingProvider.class.getName();
		try {
			String configLocation = 'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.xml';
			this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
				.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
						'spring.cache.jcache.config=' + configLocation)
				.run((context) -> {
					JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
					Resource configResource = new ClassPathResource(configLocation);
					assertThat(cacheManager.getCacheManager().getURI()).isEqualTo(configResource.getURI());
					assertThat(Hazelcast.getAllHazelcastInstances()).hasSize(1);
				});
		}
		finally {
			Caching.getCachingProvider(cachingProviderFqn).close();
		}
	}
	@Test
	void hazelcastAsJCacheWithExistingHazelcastInstance() {
		String cachingProviderFqn = HazelcastServerCachingProvider.class.getName();
		this.contextRunner.withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class))
			.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn)
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				javax.cache.CacheManager jCacheManager = cacheManager.getCacheManager();
				assertThat(jCacheManager).isInstanceOf(com.hazelcast.cache.HazelcastCacheManager.class);
				assertThat(context).hasSingleBean(HazelcastInstance.class);
				HazelcastInstance hazelcastInstance = context.getBean(HazelcastInstance.class);
				assertThat(((com.hazelcast.cache.HazelcastCacheManager) jCacheManager).getHazelcastInstance())
					.isSameAs(hazelcastInstance);
				assertThat(hazelcastInstance.getName()).isEqualTo('default-instance');
				assertThat(Hazelcast.getAllHazelcastInstances()).hasSize(1);
			});
	}
	@Test
	void infinispanCacheWithConfig() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=infinispan', 'spring.cache.infinispan.config=infinispan.xml')
			.run((context) -> {
				SpringEmbeddedCacheManager cacheManager = getCacheManager(context, SpringEmbeddedCacheManager.class);
				assertThat(cacheManager.getCacheNames()).contains('foo', 'bar');
			});
	}
	@Test
	void infinispanCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(DefaultCacheAndCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=infinispan')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'infinispanCacheManagerCustomizer'));
	}
	@Test
	void infinispanCacheWithCaches() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=infinispan', 'spring.cache.cacheNames[0]=foo',
					'spring.cache.cacheNames[1]=bar')
			.run((context) -> assertThat(getCacheManager(context, SpringEmbeddedCacheManager.class).getCacheNames())
				.containsOnly('foo', 'bar'));
	}
	@Test
	void infinispanCacheWithCachesAndCustomConfig() {
		this.contextRunner.withUserConfiguration(InfinispanCustomConfiguration.class)
			.withPropertyValues('spring.cache.type=infinispan', 'spring.cache.cacheNames[0]=foo',
					'spring.cache.cacheNames[1]=bar')
			.run((context) -> {
				assertThat(getCacheManager(context, SpringEmbeddedCacheManager.class).getCacheNames())
					.containsOnly('foo', 'bar');
				then(context.getBean(ConfigurationBuilder.class)).should(times(2)).build();
			});
	}
	@Test
	void infinispanAsJCacheWithCaches() {
		String cachingProviderClassName = JCachingProvider.class.getName();
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderClassName,
					'spring.cache.cacheNames[0]=foo', 'spring.cache.cacheNames[1]=bar')
			.run((context) -> assertThat(getCacheManager(context, JCacheCacheManager.class).getCacheNames())
				.containsOnly('foo', 'bar'));
	}
	@Test
	void infinispanAsJCacheWithConfig() {
		String cachingProviderClassName = JCachingProvider.class.getName();
		String configLocation = 'infinispan.xml';
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderClassName,
					'spring.cache.jcache.config=' + configLocation)
			.run((context) -> {
				Resource configResource = new ClassPathResource(configLocation);
				assertThat(getCacheManager(context, JCacheCacheManager.class).getCacheManager().getURI())
					.isEqualTo(configResource.getURI());
			});
	}
	@Test
	void jCacheCacheWithCachesAndCustomizer() {
		String cachingProviderFqn = HazelcastServerCachingProvider.class.getName();
		try {
			this.contextRunner.withUserConfiguration(JCacheWithCustomizerConfiguration.class)
				.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
						'spring.cache.cacheNames[0]=foo', 'spring.cache.cacheNames[1]=bar')
				.run((context) ->
				// see customizer
				assertThat(getCacheManager(context, JCacheCacheManager.class).getCacheNames()).containsOnly('foo',
						'custom1'));
		}
		finally {
			Caching.getCachingProvider(cachingProviderFqn).close();
		}
	}
	@Test
	void cache2kCacheWithExplicitCaches() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=cache2k', 'spring.cache.cacheNames=foo,bar')
			.run((context) -> {
				SpringCache2kCacheManager manager = getCacheManager(context, SpringCache2kCacheManager.class);
				assertThat(manager.getCacheNames()).containsExactlyInAnyOrder('foo', 'bar');
			});
	}
	@Test
	void cache2kCacheWithCustomizedDefaults() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=cache2k')
			.withBean(Cache2kBuilderCustomizer.class,
					() -> (builder) -> builder.valueType(String.class).loader((key) -> 'default'))
			.run((context) -> {
				SpringCache2kCacheManager manager = getCacheManager(context, SpringCache2kCacheManager.class);
				assertThat(manager.getCacheNames()).isEmpty();
				Cache dynamic = manager.getCache('dynamic');
				assertThat(dynamic.get('1')).satisfies(hasEntry('default'));
				assertThat(dynamic.get('2')).satisfies(hasEntry('default'));
			});
	}
	@Test
	void cache2kCacheWithCustomizedDefaultsAndExplicitCaches() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=cache2k', 'spring.cache.cacheNames=foo,bar')
			.withBean(Cache2kBuilderCustomizer.class,
					() -> (builder) -> builder.valueType(String.class).loader((key) -> 'default'))
			.run((context) -> {
				SpringCache2kCacheManager manager = getCacheManager(context, SpringCache2kCacheManager.class);
				assertThat(manager.getCacheNames()).containsExactlyInAnyOrder('foo', 'bar');
				assertThat(manager.getCache('foo').get('1')).satisfies(hasEntry('default'));
				assertThat(manager.getCache('bar').get('1')).satisfies(hasEntry('default'));
			});
	}
	@Test
	void cache2kCacheWithCacheManagerCustomizer() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=cache2k')
			.withBean(CacheManagerCustomizer.class,
					() -> cache2kCacheManagerCustomizer((cacheManager) -> cacheManager.addCache('custom',
							(builder) -> builder.valueType(String.class).loader((key) -> 'custom'))))
			.run((context) -> {
				SpringCache2kCacheManager manager = getCacheManager(context, SpringCache2kCacheManager.class);
				assertThat(manager.getCacheNames()).containsExactlyInAnyOrder('custom');
				assertThat(manager.getCache('custom').get('1')).satisfies(hasEntry('custom'));
			});
	}
	private CacheManagerCustomizer<SpringCache2kCacheManager> cache2kCacheManagerCustomizer(
			Consumer<SpringCache2kCacheManager> cacheManager) {
		return cacheManager::accept;
	}
	@Test
	void cache2kCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(DefaultCacheAndCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=cache2k')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'cache2kCacheManagerCustomizer'));
	}
	@Test
	void caffeineCacheWithExplicitCaches() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=caffeine', 'spring.cache.cacheNames=foo')
			.run((context) -> {
				CaffeineCacheManager manager = getCacheManager(context, CaffeineCacheManager.class);
				assertThat(manager.getCacheNames()).containsOnly('foo');
				Cache foo = manager.getCache('foo');
				foo.get('1');
				// See next tests: no spec given so stats should be disabled
				assertThat(((CaffeineCache) foo).getNativeCache().stats().missCount()).isZero();
			});
	}
	@Test
	void caffeineCacheWithCustomizers() {
		this.contextRunner.withUserConfiguration(DefaultCacheAndCustomizersConfiguration.class)
			.withPropertyValues('spring.cache.type=caffeine')
			.run(verifyCustomizers('allCacheManagerCustomizer', 'caffeineCacheManagerCustomizer'));
	}
	@Test
	void caffeineCacheWithExplicitCacheBuilder() {
		this.contextRunner.withUserConfiguration(CaffeineCacheBuilderConfiguration.class)
			.withPropertyValues('spring.cache.type=caffeine', 'spring.cache.cacheNames=foo,bar')
			.run(this::validateCaffeineCacheWithStats);
	}
	@Test
	void caffeineCacheExplicitWithSpec() {
		this.contextRunner.withUserConfiguration(CaffeineCacheSpecConfiguration.class)
			.withPropertyValues('spring.cache.type=caffeine', 'spring.cache.cacheNames[0]=foo',
					'spring.cache.cacheNames[1]=bar')
			.run(this::validateCaffeineCacheWithStats);
	}
	@Test
	void caffeineCacheExplicitWithSpecString() {
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=caffeine', 'spring.cache.caffeine.spec=recordStats',
					'spring.cache.cacheNames[0]=foo', 'spring.cache.cacheNames[1]=bar')
			.run(this::validateCaffeineCacheWithStats);
	}
	@Test
	void autoConfiguredCacheManagerCanBeSwapped() {
		this.contextRunner.withUserConfiguration(CacheManagerPostProcessorConfiguration.class)
			.withPropertyValues('spring.cache.type=caffeine')
			.run((context) -> {
				getCacheManager(context, SimpleCacheManager.class);
				CacheManagerPostProcessor postProcessor = context.getBean(CacheManagerPostProcessor.class);
				assertThat(postProcessor.cacheManagers).hasSize(1);
				assertThat(postProcessor.cacheManagers.get(0)).isInstanceOf(CaffeineCacheManager.class);
			});
	}
	private Consumer<ValueWrapper> hasEntry(Object value) {
		return (valueWrapper) -> assertThat(valueWrapper.get()).isEqualTo(value);
	}
	private void validateCaffeineCacheWithStats(AssertableApplicationContext context) {
		CaffeineCacheManager manager = getCacheManager(context, CaffeineCacheManager.class);
		assertThat(manager.getCacheNames()).containsOnly('foo', 'bar');
		Cache foo = manager.getCache('foo');
		foo.get('1');
		assertThat(((CaffeineCache) foo).getNativeCache().stats().missCount()).isOne();
	}
	private CouchbaseCacheConfiguration getDefaultCouchbaseCacheConfiguration(CouchbaseCacheManager cacheManager) {
		return (CouchbaseCacheConfiguration) ReflectionTestUtils.getField(cacheManager, 'defaultCacheConfig');
	}
	private RedisCacheConfiguration getDefaultRedisCacheConfiguration(RedisCacheManager cacheManager) {
		return (RedisCacheConfiguration) ReflectionTestUtils.getField(cacheManager, 'defaultCacheConfiguration');
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class DefaultCacheConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	@Import(CacheManagerCustomizersConfiguration.class)
	static class DefaultCacheAndCustomizersConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class GenericCacheConfiguration {
		@Bean
		Cache firstCache() {
			return new ConcurrentMapCache('first');
		}
		@Bean
		Cache secondCache() {
			return new ConcurrentMapCache('second');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ GenericCacheConfiguration.class, CacheManagerCustomizersConfiguration.class })
	static class GenericCacheAndCustomizersConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	@Import({ HazelcastAutoConfiguration.class, CacheManagerCustomizersConfiguration.class })
	static class HazelcastCacheAndCustomizersConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CouchbaseConfiguration {
		@Bean
		CouchbaseClientFactory couchbaseClientFactory() {
			return mock(CouchbaseClientFactory.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ CouchbaseConfiguration.class, CacheManagerCustomizersConfiguration.class })
	static class CouchbaseWithCustomizersConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class RedisConfiguration {
		@Bean
		RedisConnectionFactory redisConnectionFactory() {
			return mock(RedisConnectionFactory.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(RedisConfiguration.class)
	static class RedisWithCacheConfigurationConfiguration {
		@Bean
		org.springframework.data.redis.cache.RedisCacheConfiguration customRedisCacheConfiguration() {
			return org.springframework.data.redis.cache.RedisCacheConfiguration.defaultCacheConfig()
				.entryTtl(java.time.Duration.ofSeconds(30))
				.prefixCacheNameWith('bar');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(RedisConfiguration.class)
	static class RedisWithRedisCacheManagerBuilderCustomizerConfiguration {
		@Bean
		RedisCacheManagerBuilderCustomizer ttlRedisCacheManagerBuilderCustomizer() {
			return (builder) -> builder
				.cacheDefaults(RedisCacheConfiguration.defaultCacheConfig().entryTtl(java.time.Duration.ofSeconds(10)));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ RedisConfiguration.class, CacheManagerCustomizersConfiguration.class })
	static class RedisWithCustomizersConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class JCacheCustomConfiguration {
		@Bean
		CompleteConfiguration<?, ?> defaultCacheConfiguration() {
			return mock(CompleteConfiguration.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class JCacheCustomCacheManager {
		@Bean
		javax.cache.CacheManager customJCacheCacheManager() {
			javax.cache.CacheManager cacheManager = mock(javax.cache.CacheManager.class);
			given(cacheManager.getCacheNames()).willReturn(Collections.emptyList());
			return cacheManager;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class JCacheWithCustomizerConfiguration {
		@Bean
		JCacheManagerCustomizer myCustomizer() {
			return (cacheManager) -> {
				MutableConfiguration<?, ?> config = new MutableConfiguration<>();
				config.setExpiryPolicyFactory(CreatedExpiryPolicy.factoryOf(Duration.TEN_MINUTES));
				config.setStatisticsEnabled(true);
				cacheManager.createCache('custom1', config);
				cacheManager.destroyCache('bar');
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class HazelcastCustomHazelcastInstance {
		@Bean
		HazelcastInstance customHazelcastInstance() {
			return mock(HazelcastInstance.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class InfinispanCustomConfiguration {
		@Bean
		ConfigurationBuilder configurationBuilder() {
			ConfigurationBuilder builder = mock(ConfigurationBuilder.class);
			given(builder.build()).willReturn(new ConfigurationBuilder().build());
			return builder;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CustomCacheManagerConfiguration {
		@Bean
		CacheManager cacheManager() {
			return new ConcurrentMapCacheManager('custom1');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CustomCacheManagerFromSupportConfiguration implements CachingConfigurer {
		@Override
		@Bean
		public CacheManager cacheManager() {
			// The @Bean annotation is important, see CachingConfigurerSupport Javadoc
			return new ConcurrentMapCacheManager('custom1');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CustomCacheResolverFromSupportConfiguration implements CachingConfigurer {
		@Override
		@Bean
		public CacheResolver cacheResolver() {
			// The @Bean annotation is important, see CachingConfigurerSupport Javadoc
			return (context) -> Collections.singleton(mock(Cache.class));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class SpecificCacheResolverConfiguration {
		@Bean
		CacheResolver myCacheResolver() {
			return mock(CacheResolver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CaffeineCacheBuilderConfiguration {
		@Bean
		Caffeine<Object, Object> cacheBuilder() {
			return Caffeine.newBuilder().recordStats();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CaffeineCacheSpecConfiguration {
		@Bean
		CaffeineSpec caffeineSpec() {
			return CaffeineSpec.parse('recordStats');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class CacheManagerPostProcessorConfiguration {
		@Bean
		static BeanPostProcessor cacheManagerBeanPostProcessor() {
			return new CacheManagerPostProcessor();
		}
	}
	static class CacheManagerPostProcessor implements BeanPostProcessor {
		private final List<CacheManager> cacheManagers = new ArrayList<>();
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			return bean;
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) {
			if (bean instanceof CacheManager cacheManager) {
				this.cacheManagers.add(cacheManager);
				return new SimpleCacheManager();
			}
			return bean;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache.support;
/**
public class MockCachingProvider implements CachingProvider {
	@Override
	public CacheManager getCacheManager(URI uri, ClassLoader classLoader, Properties properties) {
		return new MockCacheManager(uri, classLoader, properties);
	}
	@Override
	public ClassLoader getDefaultClassLoader() {
		return mock(ClassLoader.class);
	}
	@Override
	public URI getDefaultURI() {
		return null;
	}
	@Override
	public Properties getDefaultProperties() {
		return new Properties();
	}
	@Override
	public CacheManager getCacheManager(URI uri, ClassLoader classLoader) {
		return getCacheManager(uri, classLoader, getDefaultProperties());
	}
	@Override
	public CacheManager getCacheManager() {
		return getCacheManager(getDefaultURI(), getDefaultClassLoader());
	}
	@Override
	public void close() {
	}
	@Override
	public void close(ClassLoader classLoader) {
	}
	@Override
	public void close(URI uri, ClassLoader classLoader) {
	}
	@Override
	public boolean isSupported(OptionalFeature optionalFeature) {
		return false;
	}
	public static class MockCacheManager implements CacheManager {
		private final Map<String, Configuration<?, ?>> configurations = new HashMap<>();
		private final Map<String, Cache<?, ?>> caches = new HashMap<>();
		private final URI uri;
		private final ClassLoader classLoader;
		private final Properties properties;
		private boolean closed;
		public MockCacheManager(URI uri, ClassLoader classLoader, Properties properties) {
			this.uri = uri;
			this.classLoader = classLoader;
			this.properties = properties;
		}
		@Override
		public CachingProvider getCachingProvider() {
			throw new UnsupportedOperationException();
		}
		@Override
		public URI getURI() {
			return this.uri;
		}
		@Override
		public ClassLoader getClassLoader() {
			return this.classLoader;
		}
		@Override
		public Properties getProperties() {
			return this.properties;
		}
		@Override
		@SuppressWarnings('unchecked')
		public <K, V, C extends Configuration<K, V>> Cache<K, V> createCache(String cacheName, C configuration) {
			this.configurations.put(cacheName, configuration);
			Cache<K, V> cache = mock(Cache.class);
			given(cache.getName()).willReturn(cacheName);
			this.caches.put(cacheName, cache);
			return cache;
		}
		@Override
		@SuppressWarnings('unchecked')
		public <K, V> Cache<K, V> getCache(String cacheName, Class<K> keyType, Class<V> valueType) {
			return (Cache<K, V>) this.caches.get(cacheName);
		}
		@Override
		@SuppressWarnings('unchecked')
		public <K, V> Cache<K, V> getCache(String cacheName) {
			return (Cache<K, V>) this.caches.get(cacheName);
		}
		@Override
		public Iterable<String> getCacheNames() {
			return this.caches.keySet();
		}
		@Override
		public void destroyCache(String cacheName) {
			this.caches.remove(cacheName);
		}
		@Override
		public void enableManagement(String cacheName, boolean enabled) {
			throw new UnsupportedOperationException();
		}
		@Override
		public void enableStatistics(String cacheName, boolean enabled) {
			throw new UnsupportedOperationException();
		}
		@Override
		public void close() {
			this.closed = true;
		}
		@Override
		public boolean isClosed() {
			return this.closed;
		}
		@Override
		public <T> T unwrap(Class<T> type) {
			throw new UnsupportedOperationException();
		}
		public Map<String, Configuration<?, ?>> getConfigurations() {
			return this.configurations;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@ClassPathExclusions('ehcache-2*.jar')
class EhCache3CacheAutoConfigurationTests extends AbstractCacheAutoConfigurationTests {
	@Test
	void ehcache3AsJCacheWithCaches() {
		String cachingProviderFqn = EhcacheCachingProvider.class.getName();
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
					'spring.cache.cacheNames[0]=foo', 'spring.cache.cacheNames[1]=bar')
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
			});
	}
	@Test
	void ehcache3AsJCacheWithConfig() {
		String cachingProviderFqn = EhcacheCachingProvider.class.getName();
		String configLocation = 'ehcache3.xml';
		this.contextRunner.withUserConfiguration(DefaultCacheConfiguration.class)
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
					'spring.cache.jcache.config=' + configLocation)
			.run((context) -> {
				JCacheCacheManager cacheManager = getCacheManager(context, JCacheCacheManager.class);
				Resource configResource = new ClassPathResource(configLocation);
				assertThat(cacheManager.getCacheManager().getURI()).isEqualTo(configResource.getURI());
				assertThat(cacheManager.getCacheNames()).containsOnly('foo', 'bar');
			});
	}
}
/*
package org.springframework.boot.autoconfigure.transaction.jta;
/**
@ClassPathExclusions('jetty-jndi-*.jar')
class JtaAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@ParameterizedTest
	@ExtendWith(JndiExtension.class)
	@MethodSource('transactionManagerJndiEntries')
	void transactionManagerFromJndi(JndiEntry jndiEntry, InitialContext initialContext) throws NamingException {
		jndiEntry.register(initialContext);
		this.context = new AnnotationConfigApplicationContext(JtaAutoConfiguration.class);
		JtaTransactionManager transactionManager = this.context.getBean(JtaTransactionManager.class);
		if (jndiEntry.value instanceof UserTransaction) {
			assertThat(transactionManager.getUserTransaction()).isEqualTo(jndiEntry.value);
			assertThat(transactionManager.getTransactionManager()).isNull();
		}
		else {
			assertThat(transactionManager.getUserTransaction()).isInstanceOf(UserTransactionAdapter.class);
			assertThat(transactionManager.getTransactionManager()).isEqualTo(jndiEntry.value);
		}
	}
	static List<Arguments> transactionManagerJndiEntries() {
		return Arrays.asList(Arguments.of(new JndiEntry('java:comp/UserTransaction', UserTransaction.class)),
				Arguments.of(new JndiEntry('java:appserver/TransactionManager', TransactionManager.class)),
				Arguments.of(new JndiEntry('java:pm/TransactionManager', TransactionManager.class)),
				Arguments.of(new JndiEntry('java:/TransactionManager', TransactionManager.class)));
	}
	@Test
	void customTransactionManager() {
		this.context = new AnnotationConfigApplicationContext(CustomTransactionManagerConfig.class,
				JtaAutoConfiguration.class);
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(JtaTransactionManager.class));
	}
	@Test
	@ExtendWith(JndiExtension.class)
	void disableJtaSupport(InitialContext initialContext) throws NamingException {
		new JndiEntry('java:comp/UserTransaction', UserTransaction.class).register(initialContext);
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.jta.enabled:false').applyTo(this.context);
		this.context.register(JtaAutoConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBeansOfType(JtaTransactionManager.class)).isEmpty();
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTransactionManagerConfig {
		@Bean
		org.springframework.transaction.TransactionManager testTransactionManager() {
			return mock(org.springframework.transaction.TransactionManager.class);
		}
	}
	private static final class JndiEntry {
		private final String name;
		private final Class<?> type;
		private final Object value;
		private JndiEntry(String name, Class<?> type) {
			this.name = name;
			this.type = type;
			this.value = mock(type);
		}
		private void register(InitialContext initialContext) throws NamingException {
			String[] components = this.name.split('/');
			String subcontextName = components[0];
			String entryName = components[1];
			Context javaComp = initialContext.createSubcontext(subcontextName);
			JndiLoader loader = new JndiLoader(initialContext.getEnvironment());
			Properties properties = new Properties();
			properties.setProperty(entryName + '/type', this.type.getName());
			properties.put(entryName + '/valueToConvert', this.value);
			loader.load(properties, javaComp);
		}
		@Override
		public String toString() {
			return this.name;
		}
	}
	private static final class JndiExtension implements BeforeEachCallback, AfterEachCallback, ParameterResolver {
		@Override
		public void beforeEach(ExtensionContext context) throws Exception {
			Namespace namespace = Namespace.create(getClass(), context.getUniqueId());
			context.getStore(namespace)
				.getOrComputeIfAbsent(InitialContext.class, (k) -> createInitialContext(), InitialContext.class);
		}
		private InitialContext createInitialContext() {
			try {
				return new InitialContext();
			}
			catch (Exception ex) {
				throw new RuntimeException();
			}
		}
		@Override
		public void afterEach(ExtensionContext context) throws Exception {
			Namespace namespace = Namespace.create(getClass(), context.getUniqueId());
			InitialContext initialContext = context.getStore(namespace)
				.remove(InitialContext.class, InitialContext.class);
			initialContext.removeFromEnvironment('org.osjava.sj.jndi.ignoreClose');
			initialContext.close();
		}
		@Override
		public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
				throws ParameterResolutionException {
			return InitialContext.class.isAssignableFrom(parameterContext.getParameter().getType());
		}
		@Override
		public Object resolveParameter(ParameterContext parameterContext, ExtensionContext extensionContext)
				throws ParameterResolutionException {
			Namespace namespace = Namespace.create(getClass(), extensionContext.getUniqueId());
			return extensionContext.getStore(namespace).get(InitialContext.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
class TransactionAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(TransactionAutoConfiguration.class));
	@Test
	void whenThereIsNoPlatformTransactionManagerNoTransactionTemplateIsAutoConfigured() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(TransactionTemplate.class));
	}
	@Test
	void whenThereIsASinglePlatformTransactionManagerATransactionTemplateIsAutoConfigured() {
		this.contextRunner.withUserConfiguration(SinglePlatformTransactionManagerConfiguration.class).run((context) -> {
			PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);
			TransactionTemplate transactionTemplate = context.getBean(TransactionTemplate.class);
			assertThat(transactionTemplate.getTransactionManager()).isSameAs(transactionManager);
		});
	}
	@Test
	void whenThereIsASingleReactiveTransactionManagerATransactionalOperatorIsAutoConfigured() {
		this.contextRunner.withUserConfiguration(SingleReactiveTransactionManagerConfiguration.class).run((context) -> {
			ReactiveTransactionManager transactionManager = context.getBean(ReactiveTransactionManager.class);
			TransactionalOperator transactionalOperator = context.getBean(TransactionalOperator.class);
			assertThat(transactionalOperator).extracting('transactionManager').isSameAs(transactionManager);
		});
	}
	@Test
	void whenThereAreBothReactiveAndPlatformTransactionManagersATemplateAndAnOperatorAreAutoConfigured() {
		this.contextRunner
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withUserConfiguration(SinglePlatformTransactionManagerConfiguration.class,
					SingleReactiveTransactionManagerConfiguration.class)
			.withPropertyValues('spring.datasource.url:jdbc:h2:mem:' + UUID.randomUUID())
			.run((context) -> {
				PlatformTransactionManager platformTransactionManager = context
					.getBean(PlatformTransactionManager.class);
				TransactionTemplate transactionTemplate = context.getBean(TransactionTemplate.class);
				assertThat(transactionTemplate.getTransactionManager()).isSameAs(platformTransactionManager);
				ReactiveTransactionManager reactiveTransactionManager = context
					.getBean(ReactiveTransactionManager.class);
				TransactionalOperator transactionalOperator = context.getBean(TransactionalOperator.class);
				assertThat(transactionalOperator).extracting('transactionManager').isSameAs(reactiveTransactionManager);
			});
	}
	@Test
	void whenThereAreSeveralPlatformTransactionManagersNoTransactionTemplateIsAutoConfigured() {
		this.contextRunner.withUserConfiguration(SeveralPlatformTransactionManagersConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(TransactionTemplate.class));
	}
	@Test
	void whenThereAreSeveralReactiveTransactionManagersNoTransactionOperatorIsAutoConfigured() {
		this.contextRunner.withUserConfiguration(SeveralReactiveTransactionManagersConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(TransactionalOperator.class));
	}
	@Test
	void whenAUserProvidesATransactionTemplateTheAutoConfiguredTemplateBacksOff() {
		this.contextRunner.withUserConfiguration(CustomPlatformTransactionManagerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(TransactionTemplate.class);
			assertThat(context.getBean('transactionTemplateFoo')).isInstanceOf(TransactionTemplate.class);
		});
	}
	@Test
	void whenAUserProvidesATransactionalOperatorTheAutoConfiguredOperatorBacksOff() {
		this.contextRunner
			.withUserConfiguration(SingleReactiveTransactionManagerConfiguration.class,
					CustomTransactionalOperatorConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(TransactionalOperator.class);
				assertThat(context.getBean('customTransactionalOperator')).isInstanceOf(TransactionalOperator.class);
			});
	}
	@Test
	void transactionNotManagedWithNoTransactionManager() {
		this.contextRunner.withUserConfiguration(BaseConfiguration.class)
			.run((context) -> assertThat(context.getBean(TransactionalService.class).isTransactionActive()).isFalse());
	}
	@Test
	void transactionManagerUsesCglibByDefault() {
		this.contextRunner.withUserConfiguration(PlatformTransactionManagersConfiguration.class).run((context) -> {
			assertThat(context.getBean(AnotherServiceImpl.class).isTransactionActive()).isTrue();
			assertThat(context.getBeansOfType(TransactionalServiceImpl.class)).hasSize(1);
		});
	}
	@Test
	void transactionManagerCanBeConfiguredToJdkProxy() {
		this.contextRunner.withUserConfiguration(PlatformTransactionManagersConfiguration.class)
			.withPropertyValues('spring.aop.proxy-target-class=false')
			.run((context) -> {
				assertThat(context.getBean(AnotherService.class).isTransactionActive()).isTrue();
				assertThat(context).doesNotHaveBean(AnotherServiceImpl.class);
				assertThat(context).doesNotHaveBean(TransactionalServiceImpl.class);
			});
	}
	@Test
	void customEnableTransactionManagementTakesPrecedence() {
		this.contextRunner
			.withUserConfiguration(CustomTransactionManagementConfiguration.class,
					PlatformTransactionManagersConfiguration.class)
			.withPropertyValues('spring.aop.proxy-target-class=true')
			.run((context) -> {
				assertThat(context.getBean(AnotherService.class).isTransactionActive()).isTrue();
				assertThat(context).doesNotHaveBean(AnotherServiceImpl.class);
				assertThat(context).doesNotHaveBean(TransactionalServiceImpl.class);
			});
	}
	@Test
	void excludesAbstractTransactionAspectFromLazyInit() {
		this.contextRunner.withUserConfiguration(AspectJTransactionManagementConfiguration.class).run((context) -> {
			LazyInitializationExcludeFilter filter = context.getBean(LazyInitializationExcludeFilter.class);
			assertThat(filter.isExcluded(null, null, AbstractTransactionAspect.class)).isTrue();
		});
	}
	@Configuration
	static class SinglePlatformTransactionManagerConfiguration {
		@Bean
		PlatformTransactionManager transactionManager() {
			return mock(PlatformTransactionManager.class);
		}
	}
	@Configuration
	static class SingleReactiveTransactionManagerConfiguration {
		@Bean
		ReactiveTransactionManager reactiveTransactionManager() {
			return mock(ReactiveTransactionManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SeveralPlatformTransactionManagersConfiguration {
		@Bean
		PlatformTransactionManager transactionManagerOne() {
			return mock(PlatformTransactionManager.class);
		}
		@Bean
		PlatformTransactionManager transactionManagerTwo() {
			return mock(PlatformTransactionManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SeveralReactiveTransactionManagersConfiguration {
		@Bean
		ReactiveTransactionManager reactiveTransactionManager1() {
			return mock(ReactiveTransactionManager.class);
		}
		@Bean
		ReactiveTransactionManager reactiveTransactionManager2() {
			return mock(ReactiveTransactionManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomPlatformTransactionManagerConfiguration {
		@Bean
		TransactionTemplate transactionTemplateFoo(PlatformTransactionManager transactionManager) {
			return new TransactionTemplate(transactionManager);
		}
		@Bean
		PlatformTransactionManager transactionManagerFoo() {
			return mock(PlatformTransactionManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTransactionalOperatorConfiguration {
		@Bean
		TransactionalOperator customTransactionalOperator() {
			return mock(TransactionalOperator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		TransactionalService transactionalService() {
			return new TransactionalServiceImpl();
		}
		@Bean
		AnotherServiceImpl anotherService() {
			return new AnotherServiceImpl();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class PlatformTransactionManagersConfiguration {
		@Bean
		DataSourceTransactionManager transactionManager(DataSource dataSource) {
			return new DataSourceTransactionManager(dataSource);
		}
		@Bean
		DataSource dataSource() {
			return DataSourceBuilder.create()
				.driverClassName('org.hsqldb.jdbc.JDBCDriver')
				.url('jdbc:hsqldb:mem:tx')
				.username('sa')
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableTransactionManagement(proxyTargetClass = false)
	static class CustomTransactionManagementConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableTransactionManagement(mode = AdviceMode.ASPECTJ)
	static class AspectJTransactionManagementConfiguration {
	}
	interface TransactionalService {
		@Transactional
		boolean isTransactionActive();
	}
	static class TransactionalServiceImpl implements TransactionalService {
		@Override
		public boolean isTransactionActive() {
			return TransactionSynchronizationManager.isActualTransactionActive();
		}
	}
	interface AnotherService {
		boolean isTransactionActive();
	}
	static class AnotherServiceImpl implements AnotherService {
		@Override
		@Transactional
		public boolean isTransactionActive() {
			return TransactionSynchronizationManager.isActualTransactionActive();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
class TransactionManagerCustomizationAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(TransactionManagerCustomizationAutoConfiguration.class));
	@Test
	void autoConfiguresTransactionManagerCustomizers() {
		this.contextRunner.run((context) -> {
			TransactionManagerCustomizers customizers = context.getBean(TransactionManagerCustomizers.class);
			assertThat(customizers).extracting('customizers')
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.hasSize(2)
				.hasAtLeastOneElementOfType(TransactionProperties.class)
				.hasAtLeastOneElementOfType(ExecutionListenersTransactionManagerCustomizer.class);
		});
	}
	@Test
	void autoConfiguredTransactionManagerCustomizersBacksOff() {
		this.contextRunner.withUserConfiguration(CustomTransactionManagerCustomizersConfiguration.class)
			.run((context) -> {
				TransactionManagerCustomizers customizers = context.getBean(TransactionManagerCustomizers.class);
				assertThat(customizers).extracting('customizers')
					.asInstanceOf(InstanceOfAssertFactories.LIST)
					.isEmpty();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTransactionManagerCustomizersConfiguration {
		@Bean
		TransactionManagerCustomizers customTransactionManagerCustomizers() {
			return TransactionManagerCustomizers.of(Collections.<TransactionManagerCustomizer<?>>emptyList());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
class TransactionManagerCustomizersTests {
	@Test
	void customizeWithNullCustomizersShouldDoNothing() {
		TransactionManagerCustomizers.of(null).customize(mock(TransactionManager.class));
	}
	@Test
	void customizeShouldCheckGeneric() {
		List<TestCustomizer<?>> list = new ArrayList<>();
		list.add(new TestCustomizer<>());
		list.add(new TestJtaCustomizer());
		TransactionManagerCustomizers customizers = TransactionManagerCustomizers.of(list);
		customizers.customize(mock(PlatformTransactionManager.class));
		customizers.customize(mock(JtaTransactionManager.class));
		assertThat(list.get(0).getCount()).isEqualTo(2);
		assertThat(list.get(1).getCount()).isOne();
	}
	static class TestCustomizer<T extends PlatformTransactionManager> implements TransactionManagerCustomizer<T> {
		private int count;
		@Override
		public void customize(T transactionManager) {
			this.count++;
		}
		int getCount() {
			return this.count;
		}
	}
	static class TestJtaCustomizer extends TestCustomizer<JtaTransactionManager> {
	}
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
class ExecutionListenersTransactionManagerCustomizerTests {
	@Test
	void whenTransactionManagerIsCustomizedThenExecutionListenersAreAddedToIt() {
		TransactionExecutionListener listener1 = mock(TransactionExecutionListener.class);
		TransactionExecutionListener listener2 = mock(TransactionExecutionListener.class);
		ConfigurableTransactionManager transactionManager = mock(ConfigurableTransactionManager.class);
		new ExecutionListenersTransactionManagerCustomizer(List.of(listener1, listener2)).customize(transactionManager);
		then(transactionManager).should().addListener(listener1);
		then(transactionManager).should().addListener(listener2);
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
class WebPropertiesResourcesBindingTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(TestConfiguration.class);
	@Test
	void staticLocationsExpandArray() {
		this.contextRunner
			.withPropertyValues('spring.web.resources.static-locations[0]=classpath:/one/',
					'spring.web.resources.static-locations[1]=classpath:/two',
					'spring.web.resources.static-locations[2]=classpath:/three/',
					'spring.web.resources.static-locations[3]=classpath:/four',
					'spring.web.resources.static-locations[4]=classpath:/five/',
					'spring.web.resources.static-locations[5]=classpath:/six')
			.run(assertResourceProperties((properties) -> assertThat(properties.getStaticLocations()).contains(
					'classpath:/one/', 'classpath:/two/', 'classpath:/three/', 'classpath:/four/', 'classpath:/five/',
					'classpath:/six/')));
	}
	private ContextConsumer<AssertableApplicationContext> assertResourceProperties(Consumer<Resources> consumer) {
		return (context) -> {
			assertThat(context).hasSingleBean(WebProperties.class);
			consumer.accept(context.getBean(WebProperties.class).getResources());
		};
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WebProperties.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
class WebResourcesRuntimeHintsTests {
	@Test
	void registerHintsWithAllLocations() {
		RuntimeHints hints = register(
				new TestClassLoader(List.of('META-INF/resources/', 'resources/', 'static/', 'public/')));
		assertThat(hints.resources().resourcePatternHints()).singleElement()
			.satisfies(include('META-INF/resources/*', 'resources/*', 'static/*', 'public/*'));
	}
	@Test
	void registerHintsWithOnlyStaticLocations() {
		RuntimeHints hints = register(new TestClassLoader(List.of('static/')));
		assertThat(hints.resources().resourcePatternHints()).singleElement().satisfies(include('static/*'));
	}
	@Test
	void registerHintsWithNoLocation() {
		RuntimeHints hints = register(new TestClassLoader(Collections.emptyList()));
		assertThat(hints.resources().resourcePatternHints()).isEmpty();
	}
	private RuntimeHints register(ClassLoader classLoader) {
		RuntimeHints hints = new RuntimeHints();
		WebResourcesRuntimeHints registrar = new WebResourcesRuntimeHints();
		registrar.registerHints(hints, classLoader);
		return hints;
	}
	private Consumer<ResourcePatternHints> include(String... patterns) {
		return (hint) -> {
			assertThat(hint.getIncludes()).map(ResourcePatternHint::getPattern).contains(patterns);
			assertThat(hint.getExcludes()).isEmpty();
		};
	}
	private static class TestClassLoader extends URLClassLoader {
		private final List<String> availableResources;
		TestClassLoader(List<String> availableResources) {
			super(new URL[0], TestClassLoader.class.getClassLoader());
			this.availableResources = availableResources;
		}
		@Override
		public URL getResource(String name) {
			return (this.availableResources.contains(name)) ? super.getResource('web/custom-resource.txt') : null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
class JettyVirtualThreadsWebServerFactoryCustomizerTests {
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldConfigureVirtualThreads() {
		ServerProperties properties = new ServerProperties();
		JettyVirtualThreadsWebServerFactoryCustomizer customizer = new JettyVirtualThreadsWebServerFactoryCustomizer(
				properties);
		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
		customizer.customize(factory);
		then(factory).should().setThreadPool(assertArg((threadPool) -> {
			assertThat(threadPool).isInstanceOf(QueuedThreadPool.class);
			QueuedThreadPool queuedThreadPool = (QueuedThreadPool) threadPool;
			Executor executor = queuedThreadPool.getVirtualThreadsExecutor();
			assertThat(executor).isNotNull();
			AtomicReference<String> threadName = new AtomicReference<>();
			executor.execute(() -> threadName.set(Thread.currentThread().getName()));
			Awaitility.await().atMost(Duration.ofSeconds(1)).untilAtomic(threadName, Matchers.notNullValue());
			assertThat(threadName.get()).startsWith('jetty-');
		}));
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
@DirtiesUrlFactories
class JettyWebServerFactoryCustomizerTests {
	private MockEnvironment environment;
	private ServerProperties serverProperties;
	private JettyWebServerFactoryCustomizer customizer;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.serverProperties = new ServerProperties();
		ConfigurationPropertySources.attach(this.environment);
		this.customizer = new JettyWebServerFactoryCustomizer(this.environment, this.serverProperties);
	}
	@Test
	void deduceUseForwardHeaders() {
		this.environment.setProperty('DYNO', '-');
		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(true);
	}
	@Test
	void defaultUseForwardHeaders() {
		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(false);
	}
	@Test
	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(true);
	}
	@Test
	void forwardHeadersWhenStrategyIsNoneShouldNotConfigureValve() {
		this.environment.setProperty('DYNO', '-');
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NONE);
		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(false);
	}
	@Test
	void accessLogCanBeCustomized() throws IOException {
		File logFile = File.createTempFile('jetty_log', '.log');
		bind('server.jetty.accesslog.enabled=true', 'server.jetty.accesslog.format=extended_ncsa',
				'server.jetty.accesslog.filename=' + logFile.getAbsolutePath().replace('\\', '\\\\'),
				'server.jetty.accesslog.file-date-format=yyyy-MM-dd', 'server.jetty.accesslog.retention-period=42',
				'server.jetty.accesslog.append=true', 'server.jetty.accesslog.ignore-paths=/a/path,/b/path');
		JettyWebServer server = customizeAndGetServer();
		CustomRequestLog requestLog = getRequestLog(server);
		assertThat(requestLog.getFormatString()).isEqualTo(CustomRequestLog.EXTENDED_NCSA_FORMAT);
		assertThat(requestLog.getIgnorePaths()).hasSize(2);
		assertThat(requestLog.getIgnorePaths()).containsExactly('/a/path', '/b/path');
		RequestLogWriter logWriter = getLogWriter(requestLog);
		assertThat(logWriter.getFileName()).isEqualTo(logFile.getAbsolutePath());
		assertThat(logWriter.getFilenameDateFormat()).isEqualTo('yyyy-MM-dd');
		assertThat(logWriter.getRetainDays()).isEqualTo(42);
		assertThat(logWriter.isAppend()).isTrue();
	}
	@Test
	void accessLogCanBeEnabled() {
		bind('server.jetty.accesslog.enabled=true');
		JettyWebServer server = customizeAndGetServer();
		CustomRequestLog requestLog = getRequestLog(server);
		assertThat(requestLog.getFormatString()).isEqualTo(CustomRequestLog.NCSA_FORMAT);
		assertThat(requestLog.getIgnorePaths()).isNull();
		RequestLogWriter logWriter = getLogWriter(requestLog);
		assertThat(logWriter.getFileName()).isNull();
		assertThat(logWriter.isAppend()).isFalse();
	}
	@Test
	void threadPoolMatchesJettyDefaults() {
		ThreadPool defaultThreadPool = new Server(0).getThreadPool();
		ThreadPool configuredThreadPool = customizeAndGetServer().getServer().getThreadPool();
		assertThat(defaultThreadPool).isInstanceOf(QueuedThreadPool.class);
		assertThat(configuredThreadPool).isInstanceOf(QueuedThreadPool.class);
		QueuedThreadPool defaultQueuedThreadPool = (QueuedThreadPool) defaultThreadPool;
		QueuedThreadPool configuredQueuedThreadPool = (QueuedThreadPool) configuredThreadPool;
		assertThat(configuredQueuedThreadPool.getMinThreads()).isEqualTo(defaultQueuedThreadPool.getMinThreads());
		assertThat(configuredQueuedThreadPool.getMaxThreads()).isEqualTo(defaultQueuedThreadPool.getMaxThreads());
		assertThat(configuredQueuedThreadPool.getIdleTimeout()).isEqualTo(defaultQueuedThreadPool.getIdleTimeout());
		BlockingQueue<?> defaultQueue = getQueue(defaultThreadPool);
		BlockingQueue<?> configuredQueue = getQueue(configuredThreadPool);
		assertThat(defaultQueue).isInstanceOf(BlockingArrayQueue.class);
		assertThat(configuredQueue).isInstanceOf(BlockingArrayQueue.class);
		assertThat(((BlockingArrayQueue<?>) defaultQueue).getMaxCapacity())
			.isEqualTo(((BlockingArrayQueue<?>) configuredQueue).getMaxCapacity());
	}
	@Test
	void threadPoolMaxThreadsCanBeCustomized() {
		bind('server.jetty.threads.max=100');
		JettyWebServer server = customizeAndGetServer();
		QueuedThreadPool threadPool = (QueuedThreadPool) server.getServer().getThreadPool();
		assertThat(threadPool.getMaxThreads()).isEqualTo(100);
	}
	@Test
	void threadPoolMinThreadsCanBeCustomized() {
		bind('server.jetty.threads.min=100');
		JettyWebServer server = customizeAndGetServer();
		QueuedThreadPool threadPool = (QueuedThreadPool) server.getServer().getThreadPool();
		assertThat(threadPool.getMinThreads()).isEqualTo(100);
	}
	@Test
	void threadPoolIdleTimeoutCanBeCustomized() {
		bind('server.jetty.threads.idle-timeout=100s');
		JettyWebServer server = customizeAndGetServer();
		QueuedThreadPool threadPool = (QueuedThreadPool) server.getServer().getThreadPool();
		assertThat(threadPool.getIdleTimeout()).isEqualTo(100000);
	}
	@Test
	void threadPoolWithMaxQueueCapacityEqualToZeroCreateSynchronousQueue() {
		bind('server.jetty.threads.max-queue-capacity=0');
		JettyWebServer server = customizeAndGetServer();
		ThreadPool threadPool = server.getServer().getThreadPool();
		BlockingQueue<?> queue = getQueue(threadPool);
		assertThat(queue).isInstanceOf(SynchronousQueue.class);
		assertDefaultThreadPoolSettings(threadPool);
	}
	@Test
	void threadPoolWithMaxQueueCapacityEqualToZeroCustomizesThreadPool() {
		bind('server.jetty.threads.max-queue-capacity=0', 'server.jetty.threads.min=100',
				'server.jetty.threads.max=100', 'server.jetty.threads.idle-timeout=6s');
		JettyWebServer server = customizeAndGetServer();
		QueuedThreadPool threadPool = (QueuedThreadPool) server.getServer().getThreadPool();
		assertThat(threadPool.getMinThreads()).isEqualTo(100);
		assertThat(threadPool.getMaxThreads()).isEqualTo(100);
		assertThat(threadPool.getIdleTimeout()).isEqualTo(Duration.ofSeconds(6).toMillis());
	}
	@Test
	void threadPoolWithMaxQueueCapacityPositiveCreateBlockingArrayQueue() {
		bind('server.jetty.threads.max-queue-capacity=1234');
		JettyWebServer server = customizeAndGetServer();
		ThreadPool threadPool = server.getServer().getThreadPool();
		BlockingQueue<?> queue = getQueue(threadPool);
		assertThat(queue).isInstanceOf(BlockingArrayQueue.class);
		assertThat(((BlockingArrayQueue<?>) queue).getMaxCapacity()).isEqualTo(1234);
		assertDefaultThreadPoolSettings(threadPool);
	}
	@Test
	void threadPoolWithMaxQueueCapacityPositiveCustomizesThreadPool() {
		bind('server.jetty.threads.max-queue-capacity=1234', 'server.jetty.threads.min=10',
				'server.jetty.threads.max=150', 'server.jetty.threads.idle-timeout=3s');
		JettyWebServer server = customizeAndGetServer();
		QueuedThreadPool threadPool = (QueuedThreadPool) server.getServer().getThreadPool();
		assertThat(threadPool.getMinThreads()).isEqualTo(10);
		assertThat(threadPool.getMaxThreads()).isEqualTo(150);
		assertThat(threadPool.getIdleTimeout()).isEqualTo(Duration.ofSeconds(3).toMillis());
	}
	private void assertDefaultThreadPoolSettings(ThreadPool threadPool) {
		assertThat(threadPool).isInstanceOf(QueuedThreadPool.class);
		QueuedThreadPool queuedThreadPool = (QueuedThreadPool) threadPool;
		Jetty defaultProperties = new Jetty();
		assertThat(queuedThreadPool.getMinThreads()).isEqualTo(defaultProperties.getThreads().getMin());
		assertThat(queuedThreadPool.getMaxThreads()).isEqualTo(defaultProperties.getThreads().getMax());
		assertThat(queuedThreadPool.getIdleTimeout())
			.isEqualTo(defaultProperties.getThreads().getIdleTimeout().toMillis());
	}
	private CustomRequestLog getRequestLog(JettyWebServer server) {
		RequestLog requestLog = server.getServer().getRequestLog();
		assertThat(requestLog).isInstanceOf(CustomRequestLog.class);
		return (CustomRequestLog) requestLog;
	}
	private RequestLogWriter getLogWriter(CustomRequestLog requestLog) {
		RequestLog.Writer writer = requestLog.getWriter();
		assertThat(writer).isInstanceOf(RequestLogWriter.class);
		return (RequestLogWriter) requestLog.getWriter();
	}
	@Test
	void setUseForwardHeaders() {
		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NATIVE);
		ConfigurableJettyWebServerFactory factory = mock(ConfigurableJettyWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(true);
	}
	@Test
	void customizeMaxRequestHttpHeaderSize() {
		bind('server.max-http-request-header-size=2048');
		JettyWebServer server = customizeAndGetServer();
		List<Integer> requestHeaderSizes = getRequestHeaderSizes(server);
		assertThat(requestHeaderSizes).containsOnly(2048);
	}
	@Test
	void customMaxHttpRequestHeaderSizeIgnoredIfNegative() {
		bind('server.max-http-request-header-size=-1');
		JettyWebServer server = customizeAndGetServer();
		List<Integer> requestHeaderSizes = getRequestHeaderSizes(server);
		assertThat(requestHeaderSizes).containsOnly(8192);
	}
	@Test
	void customMaxHttpRequestHeaderSizeIgnoredIfZero() {
		bind('server.max-http-request-header-size=0');
		JettyWebServer server = customizeAndGetServer();
		List<Integer> requestHeaderSizes = getRequestHeaderSizes(server);
		assertThat(requestHeaderSizes).containsOnly(8192);
	}
	@Test
	void defaultMaxHttpResponseHeaderSize() {
		JettyWebServer server = customizeAndGetServer();
		List<Integer> responseHeaderSizes = getResponseHeaderSizes(server);
		assertThat(responseHeaderSizes).containsOnly(8192);
	}
	@Test
	void customizeMaxHttpResponseHeaderSize() {
		bind('server.jetty.max-http-response-header-size=2KB');
		JettyWebServer server = customizeAndGetServer();
		List<Integer> responseHeaderSizes = getResponseHeaderSizes(server);
		assertThat(responseHeaderSizes).containsOnly(2048);
	}
	@Test
	void customMaxHttpResponseHeaderSizeIgnoredIfNegative() {
		bind('server.jetty.max-http-response-header-size=-1');
		JettyWebServer server = customizeAndGetServer();
		List<Integer> responseHeaderSizes = getResponseHeaderSizes(server);
		assertThat(responseHeaderSizes).containsOnly(8192);
	}
	@Test
	void customMaxHttpResponseHeaderSizeIgnoredIfZero() {
		bind('server.jetty.max-http-response-header-size=0');
		JettyWebServer server = customizeAndGetServer();
		List<Integer> responseHeaderSizes = getResponseHeaderSizes(server);
		assertThat(responseHeaderSizes).containsOnly(8192);
	}
	@Test
	void customIdleTimeout() {
		bind('server.jetty.connection-idle-timeout=60s');
		JettyWebServer server = customizeAndGetServer();
		List<Long> timeouts = connectorsIdleTimeouts(server);
		assertThat(timeouts).containsOnly(60000L);
	}
	@Test
	void customMaxFormKeys() {
		bind('server.jetty.max-form-keys=2048');
		JettyWebServer server = customizeAndGetServer();
		startAndStopToMakeInternalsAvailable(server);
		List<Integer> maxFormKeys = server.getServer()
			.getHandlers()
			.stream()
			.filter(ServletContextHandler.class::isInstance)
			.map(ServletContextHandler.class::cast)
			.map(ServletContextHandler::getMaxFormKeys)
			.toList();
		assertThat(maxFormKeys).containsOnly(2048);
	}
	private List<Long> connectorsIdleTimeouts(JettyWebServer server) {
		startAndStopToMakeInternalsAvailable(server);
		return Arrays.stream(server.getServer().getConnectors())
			.filter((connector) -> connector instanceof AbstractConnector)
			.map(Connector::getIdleTimeout)
			.toList();
	}
	private List<Integer> getRequestHeaderSizes(JettyWebServer server) {
		return getHeaderSizes(server, HttpConfiguration::getRequestHeaderSize);
	}
	private List<Integer> getResponseHeaderSizes(JettyWebServer server) {
		return getHeaderSizes(server, HttpConfiguration::getResponseHeaderSize);
	}
	private List<Integer> getHeaderSizes(JettyWebServer server, Function<HttpConfiguration, Integer> provider) {
		List<Integer> requestHeaderSizes = new ArrayList<>();
		startAndStopToMakeInternalsAvailable(server);
		Connector[] connectors = server.getServer().getConnectors();
		for (Connector connector : connectors) {
			connector.getConnectionFactories()
				.stream()
				.filter((factory) -> factory instanceof ConnectionFactory)
				.forEach((cf) -> {
					ConnectionFactory factory = (ConnectionFactory) cf;
					HttpConfiguration configuration = factory.getHttpConfiguration();
					requestHeaderSizes.add(provider.apply(configuration));
				});
		}
		return requestHeaderSizes;
	}
	private void startAndStopToMakeInternalsAvailable(JettyWebServer server) {
		server.start();
		server.stop();
	}
	private BlockingQueue<?> getQueue(ThreadPool threadPool) {
		return ReflectionTestUtils.invokeMethod(threadPool, 'getQueue');
	}
	private void bind(String... inlinedProperties) {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, inlinedProperties);
		new Binder(ConfigurationPropertySources.get(this.environment)).bind('server',
				Bindable.ofInstance(this.serverProperties));
	}
	private JettyWebServer customizeAndGetServer() {
		JettyServletWebServerFactory factory = customizeAndGetFactory();
		return (JettyWebServer) factory.getWebServer();
	}
	private JettyServletWebServerFactory customizeAndGetFactory() {
		JettyServletWebServerFactory factory = new JettyServletWebServerFactory(0);
		this.customizer.customize(factory);
		return factory;
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
class UndertowWebServerFactoryCustomizerConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
			AnnotationConfigServletWebApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(EmbeddedWebServerFactoryCustomizerAutoConfiguration.class));
	@EnabledForJreRange(min = JRE.JAVA_21)
	@Test
	void shouldUseVirtualThreadsIfEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			assertThat(context).hasSingleBean(UndertowDeploymentInfoCustomizer.class);
			assertThat(context).hasBean('virtualThreadsUndertowDeploymentInfoCustomizer');
			UndertowDeploymentInfoCustomizer customizer = context.getBean(UndertowDeploymentInfoCustomizer.class);
			DeploymentInfo deploymentInfo = new DeploymentInfo();
			customizer.customize(deploymentInfo);
			assertThat(deploymentInfo.getExecutor()).isInstanceOf(VirtualThreadTaskExecutor.class);
		});
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
@ExtendWith(MockitoExtension.class)
class NettyWebServerFactoryCustomizerTests {
	private MockEnvironment environment;
	private ServerProperties serverProperties;
	private NettyWebServerFactoryCustomizer customizer;
	@Captor
	private ArgumentCaptor<NettyServerCustomizer> customizerCaptor;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.serverProperties = new ServerProperties();
		ConfigurationPropertySources.attach(this.environment);
		this.customizer = new NettyWebServerFactoryCustomizer(this.environment, this.serverProperties);
	}
	@Test
	void deduceUseForwardHeaders() {
		this.environment.setProperty('DYNO', '-');
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(true);
	}
	@Test
	void defaultUseForwardHeaders() {
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(false);
	}
	@Test
	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(true);
	}
	@Test
	void forwardHeadersWhenStrategyIsNoneShouldNotConfigureValve() {
		this.environment.setProperty('DYNO', '-');
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NONE);
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(false);
	}
	@Test
	void setConnectionTimeout() {
		this.serverProperties.getNetty().setConnectionTimeout(Duration.ofSeconds(1));
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		verifyConnectionTimeout(factory, 1000);
	}
	@Test
	void setIdleTimeout() {
		this.serverProperties.getNetty().setIdleTimeout(Duration.ofSeconds(1));
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		verifyIdleTimeout(factory, Duration.ofSeconds(1));
	}
	@Test
	void setMaxKeepAliveRequests() {
		this.serverProperties.getNetty().setMaxKeepAliveRequests(100);
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		verifyMaxKeepAliveRequests(factory, 100);
	}
	@Test
	void setHttp2MaxRequestHeaderSize() {
		DataSize headerSize = DataSize.ofKilobytes(24);
		this.serverProperties.getHttp2().setEnabled(true);
		this.serverProperties.setMaxHttpRequestHeaderSize(headerSize);
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		verifyHttp2MaxHeaderSize(factory, headerSize.toBytes());
	}
	@Test
	void configureHttpRequestDecoder() {
		ServerProperties.Netty nettyProperties = this.serverProperties.getNetty();
		this.serverProperties.setMaxHttpRequestHeaderSize(DataSize.ofKilobytes(24));
		nettyProperties.setValidateHeaders(false);
		nettyProperties.setInitialBufferSize(DataSize.ofBytes(512));
		nettyProperties.setH2cMaxContentLength(DataSize.ofKilobytes(1));
		nettyProperties.setMaxInitialLineLength(DataSize.ofKilobytes(32));
		NettyReactiveWebServerFactory factory = mock(NettyReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().addServerCustomizers(this.customizerCaptor.capture());
		NettyServerCustomizer serverCustomizer = this.customizerCaptor.getAllValues().get(0);
		HttpServer httpServer = serverCustomizer.apply(HttpServer.create());
		HttpRequestDecoderSpec decoder = httpServer.configuration().decoder();
		assertThat(decoder.validateHeaders()).isFalse();
		assertThat(decoder.maxHeaderSize()).isEqualTo(this.serverProperties.getMaxHttpRequestHeaderSize().toBytes());
		assertThat(decoder.initialBufferSize()).isEqualTo(nettyProperties.getInitialBufferSize().toBytes());
		assertThat(decoder.h2cMaxContentLength()).isEqualTo(nettyProperties.getH2cMaxContentLength().toBytes());
		assertThat(decoder.maxInitialLineLength()).isEqualTo(nettyProperties.getMaxInitialLineLength().toBytes());
	}
	private void verifyConnectionTimeout(NettyReactiveWebServerFactory factory, Integer expected) {
		if (expected == null) {
			then(factory).should(never()).addServerCustomizers(any(NettyServerCustomizer.class));
			return;
		}
		then(factory).should(times(2)).addServerCustomizers(this.customizerCaptor.capture());
		NettyServerCustomizer serverCustomizer = this.customizerCaptor.getAllValues().get(0);
		HttpServer httpServer = serverCustomizer.apply(HttpServer.create());
		Map<ChannelOption<?>, ?> options = httpServer.configuration().options();
		assertThat(options.get(ChannelOption.CONNECT_TIMEOUT_MILLIS)).isEqualTo(expected);
	}
	private void verifyIdleTimeout(NettyReactiveWebServerFactory factory, Duration expected) {
		if (expected == null) {
			then(factory).should(never()).addServerCustomizers(any(NettyServerCustomizer.class));
			return;
		}
		then(factory).should(times(2)).addServerCustomizers(this.customizerCaptor.capture());
		NettyServerCustomizer serverCustomizer = this.customizerCaptor.getAllValues().get(0);
		HttpServer httpServer = serverCustomizer.apply(HttpServer.create());
		Duration idleTimeout = httpServer.configuration().idleTimeout();
		assertThat(idleTimeout).isEqualTo(expected);
	}
	private void verifyMaxKeepAliveRequests(NettyReactiveWebServerFactory factory, int expected) {
		then(factory).should(times(2)).addServerCustomizers(this.customizerCaptor.capture());
		NettyServerCustomizer serverCustomizer = this.customizerCaptor.getAllValues().get(0);
		HttpServer httpServer = serverCustomizer.apply(HttpServer.create());
		int maxKeepAliveRequests = httpServer.configuration().maxKeepAliveRequests();
		assertThat(maxKeepAliveRequests).isEqualTo(expected);
	}
	private void verifyHttp2MaxHeaderSize(NettyReactiveWebServerFactory factory, long expected) {
		then(factory).should(times(2)).addServerCustomizers(this.customizerCaptor.capture());
		NettyServerCustomizer serverCustomizer = this.customizerCaptor.getAllValues().get(0);
		HttpServer httpServer = serverCustomizer.apply(HttpServer.create());
		Http2SettingsSpec decoder = httpServer.configuration().http2SettingsSpec();
		assertThat(decoder.maxHeaderListSize()).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
class TomcatVirtualThreadsWebServerFactoryCustomizerTests {
	private final TomcatVirtualThreadsWebServerFactoryCustomizer customizer = new TomcatVirtualThreadsWebServerFactoryCustomizer();
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldSetVirtualThreadExecutor() {
		withWebServer((webServer) -> assertThat(webServer.getTomcat().getConnector().getProtocolHandler().getExecutor())
			.isInstanceOf(VirtualThreadExecutor.class));
	}
	private TomcatWebServer getWebServer() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
		this.customizer.customize(factory);
		return (TomcatWebServer) factory.getWebServer();
	}
	private void withWebServer(Consumer<TomcatWebServer> callback) {
		TomcatWebServer webServer = getWebServer();
		webServer.start();
		try {
			callback.accept(webServer);
		}
		finally {
			webServer.stop();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
class TomcatWebServerFactoryCustomizerTests {
	private MockEnvironment environment;
	private ServerProperties serverProperties;
	private TomcatWebServerFactoryCustomizer customizer;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.serverProperties = new ServerProperties();
		ConfigurationPropertySources.attach(this.environment);
		this.customizer = new TomcatWebServerFactoryCustomizer(this.environment, this.serverProperties);
	}
	@Test
	void defaultsAreConsistent() {
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxSwallowSize())
			.isEqualTo(this.serverProperties.getTomcat().getMaxSwallowSize().toBytes()));
	}
	@Test
	void customAcceptCount() {
		bind('server.tomcat.accept-count=10');
		customizeAndRunServer((server) -> assertThat(
				((AbstractProtocol<?>) server.getTomcat().getConnector().getProtocolHandler()).getAcceptCount())
			.isEqualTo(10));
	}
	@Test
	void customProcessorCache() {
		bind('server.tomcat.processor-cache=100');
		customizeAndRunServer((server) -> assertThat(
				((AbstractProtocol<?>) server.getTomcat().getConnector().getProtocolHandler()).getProcessorCache())
			.isEqualTo(100));
	}
	@Test
	void customKeepAliveTimeout() {
		bind('server.tomcat.keep-alive-timeout=30ms');
		customizeAndRunServer((server) -> assertThat(
				((AbstractProtocol<?>) server.getTomcat().getConnector().getProtocolHandler()).getKeepAliveTimeout())
			.isEqualTo(30));
	}
	@Test
	void defaultKeepAliveTimeoutWithHttp2() {
		bind('server.http2.enabled=true');
		customizeAndRunServer((server) -> assertThat(
				((Http2Protocol) server.getTomcat().getConnector().findUpgradeProtocols()[0]).getKeepAliveTimeout())
			.isEqualTo(20000L));
	}
	@Test
	void customKeepAliveTimeoutWithHttp2() {
		bind('server.tomcat.keep-alive-timeout=30s', 'server.http2.enabled=true');
		customizeAndRunServer((server) -> assertThat(
				((Http2Protocol) server.getTomcat().getConnector().findUpgradeProtocols()[0]).getKeepAliveTimeout())
			.isEqualTo(30000L));
	}
	@Test
	void customMaxKeepAliveRequests() {
		bind('server.tomcat.max-keep-alive-requests=-1');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxKeepAliveRequests())
			.isEqualTo(-1));
	}
	@Test
	void defaultMaxKeepAliveRequests() {
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxKeepAliveRequests())
			.isEqualTo(100));
	}
	@Test
	void unlimitedProcessorCache() {
		bind('server.tomcat.processor-cache=-1');
		customizeAndRunServer((server) -> assertThat(
				((AbstractProtocol<?>) server.getTomcat().getConnector().getProtocolHandler()).getProcessorCache())
			.isEqualTo(-1));
	}
	@Test
	void customBackgroundProcessorDelay() {
		bind('server.tomcat.background-processor-delay=5');
		TomcatWebServer server = customizeAndGetServer();
		assertThat(server.getTomcat().getEngine().getBackgroundProcessorDelay()).isEqualTo(5);
	}
	@Test
	void customDisableMaxHttpFormPostSize() {
		bind('server.tomcat.max-http-form-post-size=-1');
		customizeAndRunServer((server) -> assertThat(server.getTomcat().getConnector().getMaxPostSize()).isEqualTo(-1));
	}
	@Test
	void customMaxConnections() {
		bind('server.tomcat.max-connections=5');
		customizeAndRunServer((server) -> assertThat(
				((AbstractProtocol<?>) server.getTomcat().getConnector().getProtocolHandler()).getMaxConnections())
			.isEqualTo(5));
	}
	@Test
	void customMaxHttpFormPostSize() {
		bind('server.tomcat.max-http-form-post-size=10000');
		customizeAndRunServer(
				(server) -> assertThat(server.getTomcat().getConnector().getMaxPostSize()).isEqualTo(10000));
	}
	@Test
	void defaultMaxHttpRequestHeaderSize() {
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpRequestHeaderSize())
			.isEqualTo(DataSize.ofKilobytes(8).toBytes()));
	}
	@Test
	void customMaxHttpRequestHeaderSize() {
		bind('server.max-http-request-header-size=10MB');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpRequestHeaderSize())
			.isEqualTo(DataSize.ofMegabytes(10).toBytes()));
	}
	@Test
	void customMaxRequestHttpHeaderSizeIgnoredIfNegative() {
		bind('server.max-http-request-header-size=-1');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpRequestHeaderSize())
			.isEqualTo(DataSize.ofKilobytes(8).toBytes()));
	}
	@Test
	void customMaxRequestHttpHeaderSizeIgnoredIfZero() {
		bind('server.max-http-request-header-size=0');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpRequestHeaderSize())
			.isEqualTo(DataSize.ofKilobytes(8).toBytes()));
	}
	@Test
	void defaultMaxHttpResponseHeaderSize() {
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpResponseHeaderSize())
			.isEqualTo(DataSize.ofKilobytes(8).toBytes()));
	}
	@Test
	void customMaxHttpResponseHeaderSize() {
		bind('server.tomcat.max-http-response-header-size=10MB');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpResponseHeaderSize())
			.isEqualTo(DataSize.ofMegabytes(10).toBytes()));
	}
	@Test
	void customMaxResponseHttpHeaderSizeIgnoredIfNegative() {
		bind('server.tomcat.max-http-response-header-size=-1');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpResponseHeaderSize())
			.isEqualTo(DataSize.ofKilobytes(8).toBytes()));
	}
	@Test
	void customMaxResponseHttpHeaderSizeIgnoredIfZero() {
		bind('server.tomcat.max-http-response-header-size=0');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxHttpResponseHeaderSize())
			.isEqualTo(DataSize.ofKilobytes(8).toBytes()));
	}
	@Test
	void customMaxSwallowSize() {
		bind('server.tomcat.max-swallow-size=10MB');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getMaxSwallowSize())
			.isEqualTo(DataSize.ofMegabytes(10).toBytes()));
	}
	@Test
	void customRemoteIpValve() {
		bind('server.tomcat.remoteip.remote-ip-header=x-my-remote-ip-header',
				'server.tomcat.remoteip.protocol-header=x-my-protocol-header',
				'server.tomcat.remoteip.internal-proxies=192.168.0.1',
				'server.tomcat.remoteip.host-header=x-my-forward-host',
				'server.tomcat.remoteip.port-header=x-my-forward-port',
				'server.tomcat.remoteip.protocol-header-https-value=On',
				'server.tomcat.remoteip.trusted-proxies=proxy1|proxy2');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getEngineValves()).hasSize(1);
		Valve valve = factory.getEngineValves().iterator().next();
		assertThat(valve).isInstanceOf(RemoteIpValve.class);
		RemoteIpValve remoteIpValve = (RemoteIpValve) valve;
		assertThat(remoteIpValve.getProtocolHeader()).isEqualTo('x-my-protocol-header');
		assertThat(remoteIpValve.getProtocolHeaderHttpsValue()).isEqualTo('On');
		assertThat(remoteIpValve.getRemoteIpHeader()).isEqualTo('x-my-remote-ip-header');
		assertThat(remoteIpValve.getHostHeader()).isEqualTo('x-my-forward-host');
		assertThat(remoteIpValve.getPortHeader()).isEqualTo('x-my-forward-port');
		assertThat(remoteIpValve.getInternalProxies()).isEqualTo('192.168.0.1');
		assertThat(remoteIpValve.getTrustedProxies()).isEqualTo('proxy1|proxy2');
	}
	@Test
	void customStaticResourceAllowCaching() {
		bind('server.tomcat.resource.allow-caching=false');
		customizeAndRunServer((server) -> {
			Tomcat tomcat = server.getTomcat();
			Context context = (Context) tomcat.getHost().findChildren()[0];
			assertThat(context.getResources().isCachingAllowed()).isFalse();
		});
	}
	@Test
	void customStaticResourceCacheTtl() {
		bind('server.tomcat.resource.cache-ttl=10000');
		customizeAndRunServer((server) -> {
			Tomcat tomcat = server.getTomcat();
			Context context = (Context) tomcat.getHost().findChildren()[0];
			assertThat(context.getResources().getCacheTtl()).isEqualTo(10000L);
		});
	}
	@Test
	void customRelaxedPathChars() {
		bind('server.tomcat.relaxed-path-chars=|,^');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getRelaxedPathChars())
			.isEqualTo('|^'));
	}
	@Test
	void customRelaxedQueryChars() {
		bind('server.tomcat.relaxed-query-chars=^  ,  | ');
		customizeAndRunServer((server) -> assertThat(
				((AbstractHttp11Protocol<?>) server.getTomcat().getConnector().getProtocolHandler())
					.getRelaxedQueryChars())
			.isEqualTo('^|'));
	}
	@Test
	void deduceUseForwardHeaders() {
		this.environment.setProperty('DYNO', '-');
		testRemoteIpValveConfigured();
	}
	@Test
	void defaultUseForwardHeaders() {
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getEngineValves()).isEmpty();
	}
	@Test
	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
		testRemoteIpValveConfigured();
	}
	@Test
	void forwardHeadersWhenStrategyIsNoneShouldNotConfigureValve() {
		this.environment.setProperty('DYNO', '-');
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NONE);
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getEngineValves()).isEmpty();
	}
	@Test
	void defaultRemoteIpValve() {
		// Since 1.1.7 you need to specify at least the protocol
		bind('server.tomcat.remoteip.protocol-header=X-Forwarded-Proto',
				'server.tomcat.remoteip.remote-ip-header=X-Forwarded-For');
		testRemoteIpValveConfigured();
	}
	@Test
	void setUseNativeForwardHeadersStrategy() {
		this.serverProperties.setForwardHeadersStrategy(ForwardHeadersStrategy.NATIVE);
		testRemoteIpValveConfigured();
	}
	private void testRemoteIpValveConfigured() {
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getEngineValves()).hasSize(1);
		Valve valve = factory.getEngineValves().iterator().next();
		assertThat(valve).isInstanceOf(RemoteIpValve.class);
		RemoteIpValve remoteIpValve = (RemoteIpValve) valve;
		assertThat(remoteIpValve.getProtocolHeader()).isEqualTo('X-Forwarded-Proto');
		assertThat(remoteIpValve.getProtocolHeaderHttpsValue()).isEqualTo('https');
		assertThat(remoteIpValve.getRemoteIpHeader()).isEqualTo('X-Forwarded-For');
		assertThat(remoteIpValve.getHostHeader()).isEqualTo('X-Forwarded-Host');
		assertThat(remoteIpValve.getPortHeader()).isEqualTo('X-Forwarded-Port');
		String expectedInternalProxies = '10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|' // 10/8
				+ '192\\.168\\.\\d{1,3}\\.\\d{1,3}|' // 192.168/16
				+ '169\\.254\\.\\d{1,3}\\.\\d{1,3}|' // 169.254/16
				+ '127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|' // 127/8
				+ '100\\.6[4-9]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
				+ '100\\.[7-9]{1}\\d{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
				+ '100\\.1[0-1]{1}\\d{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
				+ '100\\.12[0-7]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
				+ '172\\.1[6-9]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 172.16/12
				+ '172\\.2[0-9]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 172.16/12
				+ '172\\.3[0-1]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 172.16/12
				+ '0:0:0:0:0:0:0:1|::1';
		assertThat(remoteIpValve.getInternalProxies()).isEqualTo(expectedInternalProxies);
	}
	@Test
	void defaultBackgroundProcessorDelay() {
		TomcatWebServer server = customizeAndGetServer();
		assertThat(server.getTomcat().getEngine().getBackgroundProcessorDelay()).isEqualTo(10);
	}
	@Test
	void disableRemoteIpValve() {
		bind('server.tomcat.remoteip.remote-ip-header=', 'server.tomcat.remoteip.protocol-header=');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getEngineValves()).isEmpty();
	}
	@Test
	void errorReportValveIsConfiguredToNotReportStackTraces() {
		TomcatWebServer server = customizeAndGetServer();
		Valve[] valves = server.getTomcat().getHost().getPipeline().getValves();
		assertThat(valves).hasAtLeastOneElementOfType(ErrorReportValve.class);
		for (Valve valve : valves) {
			if (valve instanceof ErrorReportValve errorReportValve) {
				assertThat(errorReportValve.isShowReport()).isFalse();
				assertThat(errorReportValve.isShowServerInfo()).isFalse();
			}
		}
	}
	@Test
	void testCustomizeMinSpareThreads() {
		bind('server.tomcat.threads.min-spare=10');
		assertThat(this.serverProperties.getTomcat().getThreads().getMinSpare()).isEqualTo(10);
	}
	@Test
	void customConnectionTimeout() {
		bind('server.tomcat.connection-timeout=30s');
		customizeAndRunServer((server) -> assertThat(
				((AbstractProtocol<?>) server.getTomcat().getConnector().getProtocolHandler()).getConnectionTimeout())
			.isEqualTo(30000));
	}
	@Test
	void accessLogBufferingCanBeDisabled() {
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.buffered=false');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).isBuffered()).isFalse();
	}
	@Test
	void accessLogCanBeEnabled() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getEngineValves()).hasSize(1);
		assertThat(factory.getEngineValves()).first().isInstanceOf(AccessLogValve.class);
	}
	@Test
	void accessLogFileDateFormatByDefault() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getFileDateFormat())
			.isEqualTo('.yyyy-MM-dd');
	}
	@Test
	void accessLogFileDateFormatCanBeRedefined() {
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.file-date-format=yyyy-MM-dd.HH');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getFileDateFormat())
			.isEqualTo('yyyy-MM-dd.HH');
	}
	@Test
	void accessLogIsBufferedByDefault() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).isBuffered()).isTrue();
	}
	@Test
	void accessLogIsDisabledByDefault() {
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getEngineValves()).isEmpty();
	}
	@Test
	void accessLogMaxDaysDefault() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getMaxDays())
			.isEqualTo(this.serverProperties.getTomcat().getAccesslog().getMaxDays());
	}
	@Test
	void accessLogConditionCanBeSpecified() {
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.conditionIf=foo',
				'server.tomcat.accesslog.conditionUnless=bar');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getConditionIf()).isEqualTo('foo');
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getConditionUnless())
			.isEqualTo('bar');
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getCondition())
			.describedAs('value of condition should equal conditionUnless - provided for backwards compatibility')
			.isEqualTo('bar');
	}
	@Test
	void accessLogEncodingIsNullWhenNotSpecified() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getEncoding()).isNull();
	}
	@Test
	void accessLogEncodingCanBeSpecified() {
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.encoding=UTF-8');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getEncoding()).isEqualTo('UTF-8');
	}
	@Test
	void accessLogWithDefaultLocale() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getLocale())
			.isEqualTo(Locale.getDefault().toString());
	}
	@Test
	void accessLogLocaleCanBeSpecified() {
		String locale = 'en_AU'.equals(Locale.getDefault().toString()) ? 'en_US' : 'en_AU';
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.locale=' + locale);
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getLocale()).isEqualTo(locale);
	}
	@Test
	void accessLogCheckExistsDefault() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).isCheckExists()).isFalse();
	}
	@Test
	void accessLogCheckExistsSpecified() {
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.check-exists=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).isCheckExists()).isTrue();
	}
	@Test
	void accessLogMaxDaysCanBeRedefined() {
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.max-days=20');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getMaxDays()).isEqualTo(20);
	}
	@Test
	void accessLogDoesNotUseIpv6CanonicalFormatByDefault() {
		bind('server.tomcat.accesslog.enabled=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getIpv6Canonical()).isFalse();
	}
	@Test
	void accessLogWithIpv6CanonicalSet() {
		bind('server.tomcat.accesslog.enabled=true', 'server.tomcat.accesslog.ipv6-canonical=true');
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(((AccessLogValve) factory.getEngineValves().iterator().next()).getIpv6Canonical()).isTrue();
	}
	@Test
	void ajpConnectorCanBeCustomized() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
		factory.setProtocol('AJP/1.3');
		factory.addConnectorCustomizers(
				(connector) -> ((AbstractAjpProtocol<?>) connector.getProtocolHandler()).setSecretRequired(false));
		this.customizer.customize(factory);
		WebServer server = factory.getWebServer();
		server.start();
		server.stop();
	}
	@Test
	void configureExecutor() {
		bind('server.tomcat.threads.max=10', 'server.tomcat.threads.min-spare=2',
				'server.tomcat.threads.max-queue-capacity=20');
		customizeAndRunServer((server) -> {
			AbstractProtocol<?> protocol = (AbstractProtocol<?>) server.getTomcat().getConnector().getProtocolHandler();
			assertThat(protocol.getMaxThreads()).isEqualTo(10);
			assertThat(protocol.getMinSpareThreads()).isEqualTo(2);
			assertThat(protocol.getMaxQueueSize()).isEqualTo(20);
		});
	}
	private void bind(String... inlinedProperties) {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, inlinedProperties);
		new Binder(ConfigurationPropertySources.get(this.environment)).bind('server',
				Bindable.ofInstance(this.serverProperties));
	}
	private void customizeAndRunServer(Consumer<TomcatWebServer> consumer) {
		TomcatWebServer server = customizeAndGetServer();
		server.start();
		try {
			consumer.accept(server);
		}
		finally {
			server.stop();
		}
	}
	private TomcatWebServer customizeAndGetServer() {
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		return (TomcatWebServer) factory.getWebServer();
	}
	private TomcatServletWebServerFactory customizeAndGetFactory() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
		factory.setHttp2(this.serverProperties.getHttp2());
		this.customizer.customize(factory);
		return factory;
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
class UndertowWebServerFactoryCustomizerTests {
	private MockEnvironment environment;
	private ServerProperties serverProperties;
	private UndertowWebServerFactoryCustomizer customizer;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.serverProperties = new ServerProperties();
		ConfigurationPropertySources.attach(this.environment);
		this.customizer = new UndertowWebServerFactoryCustomizer(this.environment, this.serverProperties);
	}
	@Test
	void customizeUndertowAccessLog() {
		bind('server.undertow.accesslog.enabled=true', 'server.undertow.accesslog.pattern=foo',
				'server.undertow.accesslog.prefix=test_log', 'server.undertow.accesslog.suffix=txt',
				'server.undertow.accesslog.dir=test-logs', 'server.undertow.accesslog.rotate=false');
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setAccessLogEnabled(true);
		then(factory).should().setAccessLogPattern('foo');
		then(factory).should().setAccessLogPrefix('test_log');
		then(factory).should().setAccessLogSuffix('txt');
		then(factory).should().setAccessLogDirectory(new File('test-logs'));
		then(factory).should().setAccessLogRotate(false);
	}
	@Test
	void customMaxHttpRequestHeaderSize() {
		bind('server.max-http-request-header-size=2048');
		assertThat(boundServerOption(UndertowOptions.MAX_HEADER_SIZE)).isEqualTo(2048);
	}
	@Test
	void customMaxHttpRequestHeaderSizeIgnoredIfNegative() {
		bind('server.max-http-request-header-size=-1');
		assertThat(boundServerOption(UndertowOptions.MAX_HEADER_SIZE)).isNull();
	}
	@Test
	void customMaxHttpRequestHeaderSizeIgnoredIfZero() {
		bind('server.max-http-request-header-size=0');
		assertThat(boundServerOption(UndertowOptions.MAX_HEADER_SIZE)).isNull();
	}
	@Test
	void customMaxHttpPostSize() {
		bind('server.undertow.max-http-post-size=256');
		assertThat(boundServerOption(UndertowOptions.MAX_ENTITY_SIZE)).isEqualTo(256);
	}
	@Test
	void customConnectionTimeout() {
		bind('server.undertow.no-request-timeout=1m');
		assertThat(boundServerOption(UndertowOptions.NO_REQUEST_TIMEOUT)).isEqualTo(60000);
	}
	@Test
	void customMaxParameters() {
		bind('server.undertow.max-parameters=4');
		assertThat(boundServerOption(UndertowOptions.MAX_PARAMETERS)).isEqualTo(4);
	}
	@Test
	void customMaxHeaders() {
		bind('server.undertow.max-headers=4');
		assertThat(boundServerOption(UndertowOptions.MAX_HEADERS)).isEqualTo(4);
	}
	@Test
	void customMaxCookies() {
		bind('server.undertow.max-cookies=4');
		assertThat(boundServerOption(UndertowOptions.MAX_COOKIES)).isEqualTo(4);
	}
	@Test
	void customizeIoThreads() {
		bind('server.undertow.threads.io=4');
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setIoThreads(4);
	}
	@Test
	void customizeWorkerThreads() {
		bind('server.undertow.threads.worker=10');
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setWorkerThreads(10);
	}
	@Test
	@Deprecated(forRemoval = true, since = '3.0.3')
	void allowEncodedSlashes() {
		bind('server.undertow.allow-encoded-slash=true');
		assertThat(boundServerOption(UndertowOptions.ALLOW_ENCODED_SLASH)).isTrue();
	}
	@Test
	void enableSlashDecoding() {
		bind('server.undertow.decode-slash=true');
		assertThat(boundServerOption(UndertowOptions.DECODE_SLASH)).isTrue();
	}
	@Test
	void disableUrlDecoding() {
		bind('server.undertow.decode-url=false');
		assertThat(boundServerOption(UndertowOptions.DECODE_URL)).isFalse();
	}
	@Test
	void customUrlCharset() {
		bind('server.undertow.url-charset=UTF-16');
		assertThat(boundServerOption(UndertowOptions.URL_CHARSET)).isEqualTo(StandardCharsets.UTF_16.name());
	}
	@Test
	void disableAlwaysSetKeepAlive() {
		bind('server.undertow.always-set-keep-alive=false');
		assertThat(boundServerOption(UndertowOptions.ALWAYS_SET_KEEP_ALIVE)).isFalse();
	}
	@Test
	void customServerOption() {
		bind('server.undertow.options.server.ALWAYS_SET_KEEP_ALIVE=false');
		assertThat(boundServerOption(UndertowOptions.ALWAYS_SET_KEEP_ALIVE)).isFalse();
	}
	@Test
	void customServerOptionShouldBeRelaxed() {
		bind('server.undertow.options.server.always-set-keep-alive=false');
		assertThat(boundServerOption(UndertowOptions.ALWAYS_SET_KEEP_ALIVE)).isFalse();
	}
	@Test
	void customSocketOption() {
		bind('server.undertow.options.socket.CONNECTION_LOW_WATER=8');
		assertThat(boundSocketOption(Options.CONNECTION_LOW_WATER)).isEqualTo(8);
	}
	@Test
	void customSocketOptionShouldBeRelaxed() {
		bind('server.undertow.options.socket.connection-low-water=8');
		assertThat(boundSocketOption(Options.CONNECTION_LOW_WATER)).isEqualTo(8);
	}
	@Test
	void deduceUseForwardHeaders() {
		this.environment.setProperty('DYNO', '-');
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(true);
	}
	@Test
	void defaultUseForwardHeaders() {
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(false);
	}
	@Test
	void forwardHeadersWhenStrategyIsNativeShouldConfigureValve() {
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NATIVE);
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(true);
	}
	@Test
	void forwardHeadersWhenStrategyIsNoneShouldNotConfigureValve() {
		this.environment.setProperty('DYNO', '-');
		this.serverProperties.setForwardHeadersStrategy(ServerProperties.ForwardHeadersStrategy.NONE);
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setUseForwardHeaders(false);
	}
	private <T> T boundServerOption(Option<T> option) {
		Builder builder = Undertow.builder();
		ConfigurableUndertowWebServerFactory factory = mockFactory(builder);
		this.customizer.customize(factory);
		OptionMap map = ((OptionMap.Builder) ReflectionTestUtils.getField(builder, 'serverOptions')).getMap();
		return map.get(option);
	}
	private <T> T boundSocketOption(Option<T> option) {
		Builder builder = Undertow.builder();
		ConfigurableUndertowWebServerFactory factory = mockFactory(builder);
		this.customizer.customize(factory);
		OptionMap map = ((OptionMap.Builder) ReflectionTestUtils.getField(builder, 'socketOptions')).getMap();
		return map.get(option);
	}
	private ConfigurableUndertowWebServerFactory mockFactory(Builder builder) {
		ConfigurableUndertowWebServerFactory factory = mock(ConfigurableUndertowWebServerFactory.class);
		willAnswer((invocation) -> {
			Object argument = invocation.getArgument(0);
			Arrays.stream((argument instanceof UndertowBuilderCustomizer undertowCustomizer)
					? new UndertowBuilderCustomizer[] { undertowCustomizer } : (UndertowBuilderCustomizer[]) argument)
				.forEach((customizer) -> customizer.customize(builder));
			return null;
		}).given(factory).addBuilderCustomizers(any());
		return factory;
	}
	private void bind(String... inlinedProperties) {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, inlinedProperties);
		new Binder(ConfigurationPropertySources.get(this.environment)).bind('server',
				Bindable.ofInstance(this.serverProperties));
	}
}
/*
package org.springframework.boot.autoconfigure.web.format;
/**
class WebConversionServiceTests {
	@Test
	void defaultDateFormat() {
		WebConversionService conversionService = new WebConversionService(new DateTimeFormatters());
		LocalDate date = LocalDate.of(2020, 4, 26);
		assertThat(conversionService.convert(date, String.class))
			.isEqualTo(DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT).format(date));
	}
	@Test
	void isoDateFormat() {
		WebConversionService conversionService = new WebConversionService(new DateTimeFormatters().dateFormat('iso'));
		LocalDate date = LocalDate.of(2020, 4, 26);
		assertThat(conversionService.convert(date, String.class))
			.isEqualTo(DateTimeFormatter.ISO_LOCAL_DATE.format(date));
	}
	@Test
	void customDateFormatWithJavaUtilDate() {
		customDateFormat(Date.from(ZonedDateTime.of(2018, 1, 1, 20, 30, 0, 0, ZoneId.systemDefault()).toInstant()));
	}
	@Test
	void customDateFormatWithJavaTime() {
		customDateFormat(java.time.LocalDate.of(2018, 1, 1));
	}
	@Test
	void defaultTimeFormat() {
		WebConversionService conversionService = new WebConversionService(new DateTimeFormatters());
		LocalTime time = LocalTime.of(12, 45, 23);
		assertThat(conversionService.convert(time, String.class))
			.isEqualTo(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(time));
	}
	@Test
	void isoTimeFormat() {
		WebConversionService conversionService = new WebConversionService(new DateTimeFormatters().timeFormat('iso'));
		LocalTime time = LocalTime.of(12, 45, 23);
		assertThat(conversionService.convert(time, String.class))
			.isEqualTo(DateTimeFormatter.ISO_LOCAL_TIME.format(time));
	}
	@Test
	void isoOffsetTimeFormat() {
		isoOffsetTimeFormat(new DateTimeFormatters().timeFormat('isooffset'));
	}
	@Test
	void hyphenatedIsoOffsetTimeFormat() {
		isoOffsetTimeFormat(new DateTimeFormatters().timeFormat('iso-offset'));
	}
	private void isoOffsetTimeFormat(DateTimeFormatters formatters) {
		WebConversionService conversionService = new WebConversionService(formatters);
		OffsetTime offsetTime = OffsetTime.of(LocalTime.of(12, 45, 23), ZoneOffset.ofHoursMinutes(1, 30));
		assertThat(conversionService.convert(offsetTime, String.class))
			.isEqualTo(DateTimeFormatter.ISO_OFFSET_TIME.format(offsetTime));
	}
	@Test
	void customTimeFormat() {
		WebConversionService conversionService = new WebConversionService(
				new DateTimeFormatters().timeFormat('HH*mm*ss'));
		LocalTime time = LocalTime.of(12, 45, 23);
		assertThat(conversionService.convert(time, String.class)).isEqualTo('12*45*23');
	}
	@Test
	void defaultDateTimeFormat() {
		WebConversionService conversionService = new WebConversionService(new DateTimeFormatters());
		LocalDateTime dateTime = LocalDateTime.of(2020, 4, 26, 12, 45, 23);
		assertThat(conversionService.convert(dateTime, String.class))
			.isEqualTo(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(dateTime));
	}
	@Test
	void isoDateTimeFormat() {
		WebConversionService conversionService = new WebConversionService(
				new DateTimeFormatters().dateTimeFormat('iso'));
		LocalDateTime dateTime = LocalDateTime.of(2020, 4, 26, 12, 45, 23);
		assertThat(conversionService.convert(dateTime, String.class))
			.isEqualTo(DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(dateTime));
	}
	@Test
	void isoOffsetDateTimeFormat() {
		isoOffsetDateTimeFormat(new DateTimeFormatters().dateTimeFormat('isooffset'));
	}
	@Test
	void hyphenatedIsoOffsetDateTimeFormat() {
		isoOffsetDateTimeFormat(new DateTimeFormatters().dateTimeFormat('iso-offset'));
	}
	private void isoOffsetDateTimeFormat(DateTimeFormatters formatters) {
		WebConversionService conversionService = new WebConversionService(formatters);
		OffsetDateTime offsetDateTime = OffsetDateTime.of(LocalDate.of(2020, 4, 26), LocalTime.of(12, 45, 23),
				ZoneOffset.ofHoursMinutes(1, 30));
		assertThat(conversionService.convert(offsetDateTime, String.class))
			.isEqualTo(DateTimeFormatter.ISO_OFFSET_DATE_TIME.format(offsetDateTime));
	}
	@Test
	void customDateTimeFormat() {
		WebConversionService conversionService = new WebConversionService(
				new DateTimeFormatters().dateTimeFormat('dd*MM*yyyy HH*mm*ss'));
		LocalDateTime dateTime = LocalDateTime.of(2020, 4, 26, 12, 45, 23);
		assertThat(conversionService.convert(dateTime, String.class)).isEqualTo('26*04*2020 12*45*23');
	}
	@Test
	void convertFromStringToLocalDate() {
		WebConversionService conversionService = new WebConversionService(
				new DateTimeFormatters().dateFormat('yyyy-MM-dd'));
		LocalDate date = conversionService.convert('2018-01-01', LocalDate.class);
		assertThat(date).isEqualTo(java.time.LocalDate.of(2018, 1, 1));
	}
	@Test
	void convertFromStringToLocalDateWithIsoFormatting() {
		WebConversionService conversionService = new WebConversionService(new DateTimeFormatters().dateFormat('iso'));
		LocalDate date = conversionService.convert('2018-01-01', LocalDate.class);
		assertThat(date).isEqualTo(java.time.LocalDate.of(2018, 1, 1));
	}
	@Test
	void convertFromStringToDateWithIsoFormatting() {
		WebConversionService conversionService = new WebConversionService(new DateTimeFormatters().dateFormat('iso'));
		Date date = conversionService.convert('2018-01-01', Date.class);
		Calendar calendar = Calendar.getInstance();
		calendar.setTime(date);
		assertThat(calendar.get(Calendar.YEAR)).isEqualTo(2018);
		assertThat(calendar.get(Calendar.MONTH)).isZero();
		assertThat(calendar.get(Calendar.DAY_OF_MONTH)).isOne();
	}
	private void customDateFormat(Object input) {
		WebConversionService conversionService = new WebConversionService(
				new DateTimeFormatters().dateFormat('dd*MM*yyyy'));
		assertThat(conversionService.convert(input, String.class)).isEqualTo('01*01*2018');
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
class WebPropertiesResourcesTests {
	private final Resources properties = new WebProperties().getResources();
	@Test
	void resourceChainNoCustomization() {
		assertThat(this.properties.getChain().getEnabled()).isNull();
	}
	@Test
	void resourceChainStrategyEnabled() {
		this.properties.getChain().getStrategy().getFixed().setEnabled(true);
		assertThat(this.properties.getChain().getEnabled()).isTrue();
	}
	@Test
	void resourceChainEnabled() {
		this.properties.getChain().setEnabled(true);
		assertThat(this.properties.getChain().getEnabled()).isTrue();
	}
	@Test
	void resourceChainDisabled() {
		this.properties.getChain().setEnabled(false);
		assertThat(this.properties.getChain().getEnabled()).isFalse();
	}
	@Test
	void defaultStaticLocationsAllEndWithTrailingSlash() {
		assertThat(this.properties.getStaticLocations()).allMatch((location) -> location.endsWith('/'));
	}
	@Test
	void customStaticLocationsAreNormalizedToEndWithTrailingSlash() {
		this.properties.setStaticLocations(new String[] { '/foo', '/bar', '/baz/' });
		String[] actual = this.properties.getStaticLocations();
		assertThat(actual).containsExactly('/foo/', '/bar/', '/baz/');
	}
	@Test
	void emptyCacheControl() {
		CacheControl cacheControl = this.properties.getCache().getCachecontrol().toHttpCacheControl();
		assertThat(cacheControl).isNull();
	}
	@Test
	void cacheControlAllPropertiesSet() {
		Cache.Cachecontrol properties = this.properties.getCache().getCachecontrol();
		properties.setMaxAge(Duration.ofSeconds(4));
		properties.setCachePrivate(true);
		properties.setCachePublic(true);
		properties.setMustRevalidate(true);
		properties.setNoTransform(true);
		properties.setProxyRevalidate(true);
		properties.setSMaxAge(Duration.ofSeconds(5));
		properties.setStaleIfError(Duration.ofSeconds(6));
		properties.setStaleWhileRevalidate(Duration.ofSeconds(7));
		CacheControl cacheControl = properties.toHttpCacheControl();
		assertThat(cacheControl.getHeaderValue())
			.isEqualTo('max-age=4, must-revalidate, no-transform, public, private, proxy-revalidate,'
					+ ' s-maxage=5, stale-if-error=6, stale-while-revalidate=7');
	}
	@Test
	void invalidCacheControlCombination() {
		Cache.Cachecontrol properties = this.properties.getCache().getCachecontrol();
		properties.setMaxAge(Duration.ofSeconds(4));
		properties.setNoStore(true);
		CacheControl cacheControl = properties.toHttpCacheControl();
		assertThat(cacheControl.getHeaderValue()).isEqualTo('no-store');
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
@DirtiesUrlFactories
class ServerPropertiesTests {
	private final ServerProperties properties = new ServerProperties();
	@Test
	void testAddressBinding() throws Exception {
		bind('server.address', '127.0.0.1');
		assertThat(this.properties.getAddress()).isEqualTo(InetAddress.getByName('127.0.0.1'));
	}
	@Test
	void testPortBinding() {
		bind('server.port', '9000');
		assertThat(this.properties.getPort().intValue()).isEqualTo(9000);
	}
	@Test
	void testServerHeaderDefault() {
		assertThat(this.properties.getServerHeader()).isNull();
	}
	@Test
	void testServerHeader() {
		bind('server.server-header', 'Custom Server');
		assertThat(this.properties.getServerHeader()).isEqualTo('Custom Server');
	}
	@Test
	@SuppressWarnings('removal')
	void testTomcatBinding() {
		Map<String, String> map = new HashMap<>();
		map.put('server.tomcat.accesslog.conditionIf', 'foo');
		map.put('server.tomcat.accesslog.conditionUnless', 'bar');
		map.put('server.tomcat.accesslog.pattern', '%h %t "%r" %s %b');
		map.put('server.tomcat.accesslog.prefix', 'foo');
		map.put('server.tomcat.accesslog.suffix', '-bar.log');
		map.put('server.tomcat.accesslog.encoding', 'UTF-8');
		map.put('server.tomcat.accesslog.locale', 'en-AU');
		map.put('server.tomcat.accesslog.checkExists', 'true');
		map.put('server.tomcat.accesslog.rotate', 'false');
		map.put('server.tomcat.accesslog.rename-on-rotate', 'true');
		map.put('server.tomcat.accesslog.ipv6Canonical', 'true');
		map.put('server.tomcat.accesslog.request-attributes-enabled', 'true');
		map.put('server.tomcat.remoteip.protocol-header', 'X-Forwarded-Protocol');
		map.put('server.tomcat.remoteip.remote-ip-header', 'Remote-Ip');
		map.put('server.tomcat.remoteip.internal-proxies', '10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}');
		map.put('server.tomcat.remoteip.trusted-proxies', 'proxy1|proxy2|proxy3');
		map.put('server.tomcat.reject-illegal-header', 'false');
		map.put('server.tomcat.background-processor-delay', '10');
		map.put('server.tomcat.relaxed-path-chars', '|,<');
		map.put('server.tomcat.relaxed-query-chars', '^  ,  | ');
		map.put('server.tomcat.use-relative-redirects', 'true');
		bind(map);
		ServerProperties.Tomcat tomcat = this.properties.getTomcat();
		Accesslog accesslog = tomcat.getAccesslog();
		assertThat(accesslog.getConditionIf()).isEqualTo('foo');
		assertThat(accesslog.getConditionUnless()).isEqualTo('bar');
		assertThat(accesslog.getPattern()).isEqualTo('%h %t "%r" %s %b');
		assertThat(accesslog.getPrefix()).isEqualTo('foo');
		assertThat(accesslog.getSuffix()).isEqualTo('-bar.log');
		assertThat(accesslog.getEncoding()).isEqualTo('UTF-8');
		assertThat(accesslog.getLocale()).isEqualTo('en-AU');
		assertThat(accesslog.isCheckExists()).isTrue();
		assertThat(accesslog.isRotate()).isFalse();
		assertThat(accesslog.isRenameOnRotate()).isTrue();
		assertThat(accesslog.isIpv6Canonical()).isTrue();
		assertThat(accesslog.isRequestAttributesEnabled()).isTrue();
		assertThat(tomcat.getRemoteip().getRemoteIpHeader()).isEqualTo('Remote-Ip');
		assertThat(tomcat.getRemoteip().getProtocolHeader()).isEqualTo('X-Forwarded-Protocol');
		assertThat(tomcat.getRemoteip().getInternalProxies()).isEqualTo('10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}');
		assertThat(tomcat.getRemoteip().getTrustedProxies()).isEqualTo('proxy1|proxy2|proxy3');
		assertThat(tomcat.getBackgroundProcessorDelay()).hasSeconds(10);
		assertThat(tomcat.getRelaxedPathChars()).containsExactly("|", "<");
		assertThat(tomcat.getRelaxedQueryChars()).containsExactly("^", "|");
		assertThat(tomcat.isUseRelativeRedirects()).isTrue();
	}
	@Test
	void testTrailingSlashOfContextPathIsRemoved() {
		bind('server.servlet.context-path', '/foo/');
		assertThat(this.properties.getServlet().getContextPath()).isEqualTo('/foo');
	}
	@Test
	void testSlashOfContextPathIsDefaultValue() {
		bind('server.servlet.context-path', '/');
		assertThat(this.properties.getServlet().getContextPath()).isEmpty();
	}
	@Test
	void testContextPathWithLeadingWhitespace() {
		bind('server.servlet.context-path', ' /assets');
		assertThat(this.properties.getServlet().getContextPath()).isEqualTo('/assets');
	}
	@Test
	void testContextPathWithTrailingWhitespace() {
		bind('server.servlet.context-path', '/assets/copy/ ');
		assertThat(this.properties.getServlet().getContextPath()).isEqualTo('/assets/copy');
	}
	@Test
	void testContextPathWithLeadingAndTrailingWhitespace() {
		bind('server.servlet.context-path', ' /assets ');
		assertThat(this.properties.getServlet().getContextPath()).isEqualTo('/assets');
	}
	@Test
	void testContextPathWithLeadingAndTrailingWhitespaceAndContextWithSpace() {
		bind('server.servlet.context-path', '  /assets /copy/    ');
		assertThat(this.properties.getServlet().getContextPath()).isEqualTo('/assets /copy');
	}
	@Test
	void testDefaultMimeMapping() {
		assertThat(this.properties.getMimeMappings()).isEmpty();
	}
	@Test
	void testCustomizedMimeMapping() {
		MimeMappings expectedMappings = new MimeMappings();
		expectedMappings.add('mjs', 'text/javascript');
		bind('server.mime-mappings.mjs', 'text/javascript');
		assertThat(this.properties.getMimeMappings())
			.containsExactly(expectedMappings.getAll().toArray(new Mapping[0]));
	}
	@Test
	void testCustomizeUriEncoding() {
		bind('server.tomcat.uri-encoding', 'US-ASCII');
		assertThat(this.properties.getTomcat().getUriEncoding()).isEqualTo(StandardCharsets.US_ASCII);
	}
	@Test
	void testCustomizeMaxHttpRequestHeaderSize() {
		bind('server.max-http-request-header-size', '1MB');
		assertThat(this.properties.getMaxHttpRequestHeaderSize()).isEqualTo(DataSize.ofMegabytes(1));
	}
	@Test
	void testCustomizeMaxHttpRequestHeaderSizeUseBytesByDefault() {
		bind('server.max-http-request-header-size', '1024');
		assertThat(this.properties.getMaxHttpRequestHeaderSize()).isEqualTo(DataSize.ofKilobytes(1));
	}
	@Test
	void testCustomizeTomcatMaxThreads() {
		bind('server.tomcat.threads.max', '10');
		assertThat(this.properties.getTomcat().getThreads().getMax()).isEqualTo(10);
	}
	@Test
	void testCustomizeTomcatKeepAliveTimeout() {
		bind('server.tomcat.keep-alive-timeout', '30s');
		assertThat(this.properties.getTomcat().getKeepAliveTimeout()).hasSeconds(30);
	}
	@Test
	void testCustomizeTomcatKeepAliveTimeoutWithInfinite() {
		bind('server.tomcat.keep-alive-timeout', '-1');
		assertThat(this.properties.getTomcat().getKeepAliveTimeout()).hasMillis(-1);
	}
	@Test
	void customizeMaxKeepAliveRequests() {
		bind('server.tomcat.max-keep-alive-requests', '200');
		assertThat(this.properties.getTomcat().getMaxKeepAliveRequests()).isEqualTo(200);
	}
	@Test
	void customizeMaxKeepAliveRequestsWithInfinite() {
		bind('server.tomcat.max-keep-alive-requests', '-1');
		assertThat(this.properties.getTomcat().getMaxKeepAliveRequests()).isEqualTo(-1);
	}
	@Test
	void testCustomizeTomcatMinSpareThreads() {
		bind('server.tomcat.threads.min-spare', '10');
		assertThat(this.properties.getTomcat().getThreads().getMinSpare()).isEqualTo(10);
	}
	@Test
	void testCustomizeJettyAcceptors() {
		bind('server.jetty.threads.acceptors', '10');
		assertThat(this.properties.getJetty().getThreads().getAcceptors()).isEqualTo(10);
	}
	@Test
	void testCustomizeJettySelectors() {
		bind('server.jetty.threads.selectors', '10');
		assertThat(this.properties.getJetty().getThreads().getSelectors()).isEqualTo(10);
	}
	@Test
	void testCustomizeJettyMaxThreads() {
		bind('server.jetty.threads.max', '10');
		assertThat(this.properties.getJetty().getThreads().getMax()).isEqualTo(10);
	}
	@Test
	void testCustomizeJettyMinThreads() {
		bind('server.jetty.threads.min', '10');
		assertThat(this.properties.getJetty().getThreads().getMin()).isEqualTo(10);
	}
	@Test
	void testCustomizeJettyIdleTimeout() {
		bind('server.jetty.threads.idle-timeout', '10s');
		assertThat(this.properties.getJetty().getThreads().getIdleTimeout()).isEqualTo(Duration.ofSeconds(10));
	}
	@Test
	void testCustomizeJettyMaxQueueCapacity() {
		bind('server.jetty.threads.max-queue-capacity', '5150');
		assertThat(this.properties.getJetty().getThreads().getMaxQueueCapacity()).isEqualTo(5150);
	}
	@Test
	void testCustomizeUndertowServerOption() {
		bind('server.undertow.options.server.ALWAYS_SET_KEEP_ALIVE', 'true');
		assertThat(this.properties.getUndertow().getOptions().getServer()).containsEntry('ALWAYS_SET_KEEP_ALIVE',
				'true');
	}
	@Test
	void testCustomizeUndertowSocketOption() {
		bind('server.undertow.options.socket.ALWAYS_SET_KEEP_ALIVE', 'true');
		assertThat(this.properties.getUndertow().getOptions().getSocket()).containsEntry('ALWAYS_SET_KEEP_ALIVE',
				'true');
	}
	@Test
	void testCustomizeUndertowIoThreads() {
		bind('server.undertow.threads.io', '4');
		assertThat(this.properties.getUndertow().getThreads().getIo()).isEqualTo(4);
	}
	@Test
	void testCustomizeUndertowWorkerThreads() {
		bind('server.undertow.threads.worker', '10');
		assertThat(this.properties.getUndertow().getThreads().getWorker()).isEqualTo(10);
	}
	@Test
	void testCustomizeJettyAccessLog() {
		Map<String, String> map = new HashMap<>();
		map.put('server.jetty.accesslog.enabled', 'true');
		map.put('server.jetty.accesslog.filename', 'foo.txt');
		map.put('server.jetty.accesslog.file-date-format', 'yyyymmdd');
		map.put('server.jetty.accesslog.retention-period', '4');
		map.put('server.jetty.accesslog.append', 'true');
		map.put('server.jetty.accesslog.custom-format', '{client}a - %u %t \'%r\' %s %O');
		map.put('server.jetty.accesslog.ignore-paths', '/a/path,/b/path');
		bind(map);
		ServerProperties.Jetty jetty = this.properties.getJetty();
		assertThat(jetty.getAccesslog().isEnabled()).isTrue();
		assertThat(jetty.getAccesslog().getFilename()).isEqualTo('foo.txt');
		assertThat(jetty.getAccesslog().getFileDateFormat()).isEqualTo('yyyymmdd');
		assertThat(jetty.getAccesslog().getRetentionPeriod()).isEqualTo(4);
		assertThat(jetty.getAccesslog().isAppend()).isTrue();
		assertThat(jetty.getAccesslog().getCustomFormat()).isEqualTo('{client}a - %u %t \'%r\' %s %O');
		assertThat(jetty.getAccesslog().getIgnorePaths()).containsExactly('/a/path', '/b/path');
	}
	@Test
	void testCustomizeNettyIdleTimeout() {
		bind('server.netty.idle-timeout', '10s');
		assertThat(this.properties.getNetty().getIdleTimeout()).isEqualTo(Duration.ofSeconds(10));
	}
	@Test
	void testCustomizeNettyMaxKeepAliveRequests() {
		bind('server.netty.max-keep-alive-requests', '100');
		assertThat(this.properties.getNetty().getMaxKeepAliveRequests()).isEqualTo(100);
	}
	@Test
	void tomcatAcceptCountMatchesProtocolDefault() throws Exception {
		assertThat(this.properties.getTomcat().getAcceptCount()).isEqualTo(getDefaultProtocol().getAcceptCount());
	}
	@Test
	void tomcatProcessorCacheMatchesProtocolDefault() throws Exception {
		assertThat(this.properties.getTomcat().getProcessorCache()).isEqualTo(getDefaultProtocol().getProcessorCache());
	}
	@Test
	void tomcatMaxConnectionsMatchesProtocolDefault() throws Exception {
		assertThat(this.properties.getTomcat().getMaxConnections()).isEqualTo(getDefaultProtocol().getMaxConnections());
	}
	@Test
	void tomcatMaxThreadsMatchesProtocolDefault() throws Exception {
		assertThat(this.properties.getTomcat().getThreads().getMax()).isEqualTo(getDefaultProtocol().getMaxThreads());
	}
	@Test
	void tomcatMinSpareThreadsMatchesProtocolDefault() throws Exception {
		assertThat(this.properties.getTomcat().getThreads().getMinSpare())
			.isEqualTo(getDefaultProtocol().getMinSpareThreads());
	}
	@Test
	void tomcatMaxHttpPostSizeMatchesConnectorDefault() {
		assertThat(this.properties.getTomcat().getMaxHttpFormPostSize().toBytes())
			.isEqualTo(getDefaultConnector().getMaxPostSize());
	}
	@Test
	void tomcatBackgroundProcessorDelayMatchesEngineDefault() {
		assertThat(this.properties.getTomcat().getBackgroundProcessorDelay())
			.hasSeconds((new StandardEngine().getBackgroundProcessorDelay()));
	}
	@Test
	void tomcatMaxHttpFormPostSizeMatchesConnectorDefault() {
		assertThat(this.properties.getTomcat().getMaxHttpFormPostSize().toBytes())
			.isEqualTo(getDefaultConnector().getMaxPostSize());
	}
	@Test
	void tomcatUriEncodingMatchesConnectorDefault() {
		assertThat(this.properties.getTomcat().getUriEncoding().name())
			.isEqualTo(getDefaultConnector().getURIEncoding());
	}
	@Test
	void tomcatRedirectContextRootMatchesDefault() {
		assertThat(this.properties.getTomcat().getRedirectContextRoot())
			.isEqualTo(new StandardContext().getMapperContextRootRedirectEnabled());
	}
	@Test
	void tomcatAccessLogRenameOnRotateMatchesDefault() {
		assertThat(this.properties.getTomcat().getAccesslog().isRenameOnRotate())
			.isEqualTo(new AccessLogValve().isRenameOnRotate());
	}
	@Test
	void tomcatAccessLogRequestAttributesEnabledMatchesDefault() {
		assertThat(this.properties.getTomcat().getAccesslog().isRequestAttributesEnabled())
			.isEqualTo(new AccessLogValve().getRequestAttributesEnabled());
	}
	@Test
	void tomcatInternalProxiesMatchesDefault() {
		assertThat(this.properties.getTomcat().getRemoteip().getInternalProxies())
			.isEqualTo(new RemoteIpValve().getInternalProxies());
	}
	@Test
	void tomcatUseRelativeRedirectsDefaultsToFalse() {
		assertThat(this.properties.getTomcat().isUseRelativeRedirects()).isFalse();
	}
	@Test
	void tomcatMaxKeepAliveRequestsDefault() throws Exception {
		AbstractEndpoint<?, ?> endpoint = (AbstractEndpoint<?, ?>) ReflectionTestUtils.getField(getDefaultProtocol(),
				'endpoint');
		int defaultMaxKeepAliveRequests = (int) ReflectionTestUtils.getField(endpoint, 'maxKeepAliveRequests');
		assertThat(this.properties.getTomcat().getMaxKeepAliveRequests()).isEqualTo(defaultMaxKeepAliveRequests);
	}
	@Test
	void jettyThreadPoolPropertyDefaultsShouldMatchServerDefault() {
		JettyServletWebServerFactory jettyFactory = new JettyServletWebServerFactory(0);
		JettyWebServer jetty = (JettyWebServer) jettyFactory.getWebServer();
		Server server = jetty.getServer();
		QueuedThreadPool threadPool = (QueuedThreadPool) server.getThreadPool();
		int idleTimeout = threadPool.getIdleTimeout();
		int maxThreads = threadPool.getMaxThreads();
		int minThreads = threadPool.getMinThreads();
		assertThat(this.properties.getJetty().getThreads().getIdleTimeout().toMillis()).isEqualTo(idleTimeout);
		assertThat(this.properties.getJetty().getThreads().getMax()).isEqualTo(maxThreads);
		assertThat(this.properties.getJetty().getThreads().getMin()).isEqualTo(minThreads);
	}
	@Test
	void jettyMaxHttpFormPostSizeMatchesDefault() {
		JettyServletWebServerFactory jettyFactory = new JettyServletWebServerFactory(0);
		JettyWebServer jetty = (JettyWebServer) jettyFactory.getWebServer();
		Server server = jetty.getServer();
		assertThat(this.properties.getJetty().getMaxHttpFormPostSize().toBytes())
			.isEqualTo(((ServletContextHandler) server.getHandler()).getMaxFormContentSize());
	}
	@Test
	void jettyMaxFormKeysMatchesDefault() {
		JettyServletWebServerFactory jettyFactory = new JettyServletWebServerFactory(0);
		JettyWebServer jetty = (JettyWebServer) jettyFactory.getWebServer();
		Server server = jetty.getServer();
		assertThat(this.properties.getJetty().getMaxFormKeys())
			.isEqualTo(((ServletContextHandler) server.getHandler()).getMaxFormKeys());
	}
	@Test
	void undertowMaxHttpPostSizeMatchesDefault() {
		assertThat(this.properties.getUndertow().getMaxHttpPostSize().toBytes())
			.isEqualTo(UndertowOptions.DEFAULT_MAX_ENTITY_SIZE);
	}
	@Test
	void nettyMaxInitialLineLengthMatchesHttpDecoderSpecDefault() {
		assertThat(this.properties.getNetty().getMaxInitialLineLength().toBytes())
			.isEqualTo(HttpDecoderSpec.DEFAULT_MAX_INITIAL_LINE_LENGTH);
	}
	@Test
	void nettyValidateHeadersMatchesHttpDecoderSpecDefault() {
		assertThat(this.properties.getNetty().isValidateHeaders()).isTrue();
	}
	@Test
	void nettyH2cMaxContentLengthMatchesHttpDecoderSpecDefault() {
		assertThat(this.properties.getNetty().getH2cMaxContentLength().toBytes()).isZero();
	}
	@Test
	void nettyInitialBufferSizeMatchesHttpDecoderSpecDefault() {
		assertThat(this.properties.getNetty().getInitialBufferSize().toBytes())
			.isEqualTo(HttpDecoderSpec.DEFAULT_INITIAL_BUFFER_SIZE);
	}
	private Connector getDefaultConnector() {
		return new Connector(TomcatServletWebServerFactory.DEFAULT_PROTOCOL);
	}
	private AbstractProtocol<?> getDefaultProtocol() throws Exception {
		return (AbstractProtocol<?>) Class.forName(TomcatServletWebServerFactory.DEFAULT_PROTOCOL)
			.getDeclaredConstructor()
			.newInstance();
	}
	private void bind(String name, String value) {
		bind(Collections.singletonMap(name, value));
	}
	private void bind(Map<String, String> map) {
		ConfigurationPropertySource source = new MapConfigurationPropertySource(map);
		new Binder(source).bind('server', Bindable.ofInstance(this.properties));
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
class RestClientBuilderConfigurerTests {
	@Test
	void shouldApplyCustomizers() {
		RestClientBuilderConfigurer configurer = new RestClientBuilderConfigurer();
		RestClientCustomizer customizer = mock(RestClientCustomizer.class);
		configurer.setRestClientCustomizers(List.of(customizer));
		RestClient.Builder builder = RestClient.builder();
		configurer.configure(builder);
		then(customizer).should().customize(builder);
	}
	@Test
	void shouldSupportNullAsCustomizers() {
		RestClientBuilderConfigurer configurer = new RestClientBuilderConfigurer();
		configurer.setRestClientCustomizers(null);
		assertThatCode(() -> configurer.configure(RestClient.builder())).doesNotThrowAnyException();
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
class RestClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RestClientAutoConfiguration.class, HttpClientAutoConfiguration.class));
	@Test
	void shouldSupplyBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(HttpMessageConvertersRestClientCustomizer.class);
			assertThat(context).hasSingleBean(RestClientBuilderConfigurer.class);
			assertThat(context).hasSingleBean(RestClient.Builder.class);
		});
	}
	@Test
	void shouldSupplyRestClientSslIfSslBundlesIsThere() {
		this.contextRunner.withBean(SslBundles.class, () -> mock(SslBundles.class))
			.run((context) -> assertThat(context).hasSingleBean(RestClientSsl.class));
	}
	@Test
	void shouldCreateBuilder() {
		this.contextRunner.run((context) -> {
			RestClient.Builder builder = context.getBean(RestClient.Builder.class);
			RestClient restClient = builder.build();
			assertThat(restClient).isNotNull();
		});
	}
	@Test
	void configurerShouldCallCustomizers() {
		this.contextRunner.withUserConfiguration(RestClientCustomizerConfig.class).run((context) -> {
			RestClientBuilderConfigurer configurer = context.getBean(RestClientBuilderConfigurer.class);
			RestClientCustomizer customizer = context.getBean('restClientCustomizer', RestClientCustomizer.class);
			Builder builder = RestClient.builder();
			configurer.configure(builder);
			then(customizer).should().customize(builder);
		});
	}
	@Test
	void restClientShouldApplyCustomizers() {
		this.contextRunner.withUserConfiguration(RestClientCustomizerConfig.class).run((context) -> {
			RestClient.Builder builder = context.getBean(RestClient.Builder.class);
			RestClientCustomizer customizer = context.getBean('restClientCustomizer', RestClientCustomizer.class);
			builder.build();
			then(customizer).should().customize(any(RestClient.Builder.class));
		});
	}
	@Test
	void shouldGetPrototypeScopedBean() {
		this.contextRunner.withUserConfiguration(RestClientCustomizerConfig.class).run((context) -> {
			RestClient.Builder firstBuilder = context.getBean(RestClient.Builder.class);
			RestClient.Builder secondBuilder = context.getBean(RestClient.Builder.class);
			assertThat(firstBuilder).isNotEqualTo(secondBuilder);
		});
	}
	@Test
	void shouldNotCreateClientBuilderIfAlreadyPresent() {
		this.contextRunner.withUserConfiguration(CustomRestClientBuilderConfig.class).run((context) -> {
			RestClient.Builder builder = context.getBean(RestClient.Builder.class);
			assertThat(builder).isInstanceOf(MyRestClientBuilder.class);
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void restClientWhenMessageConvertersDefinedShouldHaveMessageConverters() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withUserConfiguration(RestClientConfig.class)
			.run((context) -> {
				RestClient restClient = context.getBean(RestClient.class);
				List<HttpMessageConverter<?>> expectedConverters = context.getBean(HttpMessageConverters.class)
					.getConverters();
				List<HttpMessageConverter<?>> actualConverters = (List<HttpMessageConverter<?>>) ReflectionTestUtils
					.getField(restClient, 'messageConverters');
				assertThat(actualConverters).containsExactlyElementsOf(expectedConverters);
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void restClientWhenNoMessageConvertersDefinedShouldHaveDefaultMessageConverters() {
		this.contextRunner.withUserConfiguration(RestClientConfig.class).run((context) -> {
			RestClient restClient = context.getBean(RestClient.class);
			RestClient defaultRestClient = RestClient.builder().build();
			List<HttpMessageConverter<?>> actualConverters = (List<HttpMessageConverter<?>>) ReflectionTestUtils
				.getField(restClient, 'messageConverters');
			List<HttpMessageConverter<?>> expectedConverters = (List<HttpMessageConverter<?>>) ReflectionTestUtils
				.getField(defaultRestClient, 'messageConverters');
			assertThat(actualConverters).hasSameSizeAs(expectedConverters);
		});
	}
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void restClientWhenHasCustomMessageConvertersShouldHaveMessageConverters() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withUserConfiguration(CustomHttpMessageConverter.class, RestClientConfig.class)
			.run((context) -> {
				RestClient restClient = context.getBean(RestClient.class);
				List<HttpMessageConverter<?>> actualConverters = (List<HttpMessageConverter<?>>) ReflectionTestUtils
					.getField(restClient, 'messageConverters');
				assertThat(actualConverters).extracting(HttpMessageConverter::getClass)
					.contains((Class) CustomHttpMessageConverter.class);
			});
	}
	@Test
	void whenHasFactoryProperty() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withUserConfiguration(RestClientConfig.class)
			.withPropertyValues('spring.http.client.factory=simple')
			.run((context) -> {
				assertThat(context).hasSingleBean(RestClient.class);
				RestClient restClient = context.getBean(RestClient.class);
				assertThat(restClient).extracting('clientRequestFactory')
					.isInstanceOf(SimpleClientHttpRequestFactory.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CodecConfiguration {
		@Bean
		CodecCustomizer myCodecCustomizer() {
			return mock(CodecCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RestClientCustomizerConfig {
		@Bean
		RestClientCustomizer restClientCustomizer() {
			return mock(RestClientCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRestClientBuilderConfig {
		@Bean
		MyRestClientBuilder myRestClientBuilder() {
			return mock(MyRestClientBuilder.class);
		}
	}
	interface MyRestClientBuilder extends RestClient.Builder {
	}
	@Configuration(proxyBeanMethods = false)
	static class RestClientConfig {
		@Bean
		RestClient restClient(RestClient.Builder restClientBuilder) {
			return restClientBuilder.build();
		}
	}
	static class CustomHttpMessageConverter extends StringHttpMessageConverter {
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
class RestTemplateAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(RestTemplateAutoConfiguration.class, HttpClientAutoConfiguration.class));
	@Test
	void restTemplateBuilderConfigurerShouldBeLazilyDefined() {
		this.contextRunner.run((context) -> assertThat(
				context.getBeanFactory().getBeanDefinition('restTemplateBuilderConfigurer').isLazyInit())
			.isTrue());
	}
	@Test
	void shouldFailOnCustomRestTemplateBuilderConfigurer() {
		this.contextRunner.withUserConfiguration(RestTemplateBuilderConfigurerConfig.class)
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanDefinitionOverrideException.class)
				.hasMessageContaining('with name "restTemplateBuilderConfigurer"'));
	}
	@Test
	void restTemplateBuilderShouldBeLazilyDefined() {
		this.contextRunner
			.run((context) -> assertThat(context.getBeanFactory().getBeanDefinition('restTemplateBuilder').isLazyInit())
				.isTrue());
	}
	@Test
	void restTemplateWhenMessageConvertersDefinedShouldHaveMessageConverters() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withUserConfiguration(RestTemplateConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RestTemplate.class);
				RestTemplate restTemplate = context.getBean(RestTemplate.class);
				List<HttpMessageConverter<?>> converters = context.getBean(HttpMessageConverters.class).getConverters();
				assertThat(restTemplate.getMessageConverters()).containsExactlyElementsOf(converters);
				assertThat(restTemplate.getRequestFactory()).isInstanceOf(HttpComponentsClientHttpRequestFactory.class);
			});
	}
	@Test
	void restTemplateWhenNoMessageConvertersDefinedShouldHaveDefaultMessageConverters() {
		this.contextRunner.withUserConfiguration(RestTemplateConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(RestTemplate.class);
			RestTemplate restTemplate = context.getBean(RestTemplate.class);
			assertThat(restTemplate.getMessageConverters()).hasSameSizeAs(new RestTemplate().getMessageConverters());
		});
	}
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void restTemplateWhenHasCustomMessageConvertersShouldHaveMessageConverters() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withUserConfiguration(CustomHttpMessageConverter.class, RestTemplateConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RestTemplate.class);
				RestTemplate restTemplate = context.getBean(RestTemplate.class);
				assertThat(restTemplate.getMessageConverters()).extracting(HttpMessageConverter::getClass)
					.contains((Class) CustomHttpMessageConverter.class);
			});
	}
	@Test
	void restTemplateShouldApplyCustomizer() {
		this.contextRunner.withUserConfiguration(RestTemplateConfig.class, RestTemplateCustomizerConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RestTemplate.class);
				RestTemplate restTemplate = context.getBean(RestTemplate.class);
				RestTemplateCustomizer customizer = context.getBean(RestTemplateCustomizer.class);
				then(customizer).should().customize(restTemplate);
			});
	}
	@Test
	void restTemplateWhenHasCustomBuilderShouldUseCustomBuilder() {
		this.contextRunner
			.withUserConfiguration(RestTemplateConfig.class, CustomRestTemplateBuilderConfig.class,
					RestTemplateCustomizerConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RestTemplate.class);
				RestTemplate restTemplate = context.getBean(RestTemplate.class);
				assertThat(restTemplate.getMessageConverters()).hasSize(1);
				assertThat(restTemplate.getMessageConverters().get(0)).isInstanceOf(CustomHttpMessageConverter.class);
				then(context.getBean(RestTemplateCustomizer.class)).shouldHaveNoInteractions();
			});
	}
	@Test
	void restTemplateWhenHasCustomBuilderCouldReuseBuilderConfigurer() {
		this.contextRunner
			.withUserConfiguration(RestTemplateConfig.class, CustomRestTemplateBuilderWithConfigurerConfig.class,
					RestTemplateCustomizerConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RestTemplate.class);
				RestTemplate restTemplate = context.getBean(RestTemplate.class);
				assertThat(restTemplate.getMessageConverters()).hasSize(1);
				assertThat(restTemplate.getMessageConverters().get(0)).isInstanceOf(CustomHttpMessageConverter.class);
				RestTemplateCustomizer customizer = context.getBean(RestTemplateCustomizer.class);
				then(customizer).should().customize(restTemplate);
			});
	}
	@Test
	void restTemplateShouldApplyRequestCustomizer() {
		this.contextRunner.withUserConfiguration(RestTemplateRequestCustomizerConfig.class).run((context) -> {
			RestTemplateBuilder builder = context.getBean(RestTemplateBuilder.class);
			ClientHttpRequestFactory requestFactory = mock(ClientHttpRequestFactory.class);
			MockClientHttpRequest request = new MockClientHttpRequest();
			request.setResponse(new MockClientHttpResponse(new byte[0], HttpStatus.OK));
			given(requestFactory.createRequest(any(), any())).willReturn(request);
			RestTemplate restTemplate = builder.requestFactory(() -> requestFactory).build();
			restTemplate.getForEntity('http://localhost:8080/test', String.class);
			assertThat(request.getHeaders()).containsEntry('spring', Collections.singletonList('boot'));
		});
	}
	@Test
	void builderShouldBeFreshForEachUse() {
		this.contextRunner.withUserConfiguration(DirtyRestTemplateConfig.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void whenServletWebApplicationRestTemplateBuilderIsConfigured() {
		new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(RestTemplateAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(RestTemplateBuilder.class)
				.hasSingleBean(RestTemplateBuilderConfigurer.class));
	}
	@Test
	void whenReactiveWebApplicationRestTemplateBuilderIsNotConfigured() {
		new ReactiveWebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(RestTemplateAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(RestTemplateBuilder.class)
				.doesNotHaveBean(RestTemplateBuilderConfigurer.class));
	}
	@Test
	void whenHasFactoryProperty() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withUserConfiguration(RestTemplateConfig.class)
			.withPropertyValues('spring.http.client.factory=simple')
			.run((context) -> {
				assertThat(context).hasSingleBean(RestTemplate.class);
				RestTemplate restTemplate = context.getBean(RestTemplate.class);
				assertThat(restTemplate.getRequestFactory()).isInstanceOf(SimpleClientHttpRequestFactory.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class RestTemplateConfig {
		@Bean
		RestTemplate restTemplate(RestTemplateBuilder builder) {
			return builder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DirtyRestTemplateConfig {
		@Bean
		RestTemplate restTemplateOne(RestTemplateBuilder builder) {
			try {
				return builder.build();
			}
			finally {
				breakBuilderOnNextCall(builder);
			}
		}
		@Bean
		RestTemplate restTemplateTwo(RestTemplateBuilder builder) {
			try {
				return builder.build();
			}
			finally {
				breakBuilderOnNextCall(builder);
			}
		}
		private void breakBuilderOnNextCall(RestTemplateBuilder builder) {
			builder.additionalCustomizers((restTemplate) -> {
				throw new IllegalStateException();
			});
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRestTemplateBuilderConfig {
		@Bean
		RestTemplateBuilder restTemplateBuilder() {
			return new RestTemplateBuilder().messageConverters(new CustomHttpMessageConverter());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRestTemplateBuilderWithConfigurerConfig {
		@Bean
		RestTemplateBuilder restTemplateBuilder(RestTemplateBuilderConfigurer configurer) {
			return configurer.configure(new RestTemplateBuilder()).messageConverters(new CustomHttpMessageConverter());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RestTemplateCustomizerConfig {
		@Bean
		RestTemplateCustomizer restTemplateCustomizer() {
			return mock(RestTemplateCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RestTemplateRequestCustomizerConfig {
		@Bean
		RestTemplateRequestCustomizer<?> restTemplateRequestCustomizer() {
			return (request) -> request.getHeaders().add('spring', 'boot');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RestTemplateBuilderConfigurerConfig {
		@Bean
		RestTemplateBuilderConfigurer restTemplateBuilderConfigurer() {
			return new RestTemplateBuilderConfigurer();
		}
	}
	static class CustomHttpMessageConverter extends StringHttpMessageConverter {
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
class HttpMessageConvertersRestClientCustomizerTests {
	@Test
	void createWhenNullMessageConvertersArrayThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new HttpMessageConvertersRestClientCustomizer((HttpMessageConverter<?>[]) null))
			.withMessage('MessageConverters must not be null');
	}
	@Test
	void createWhenNullMessageConvertersDoesNotCustomize() {
		HttpMessageConverter<?> c0 = mock();
		assertThat(apply(new HttpMessageConvertersRestClientCustomizer((HttpMessageConverters) null), c0))
			.containsExactly(c0);
	}
	@Test
	void customizeConfiguresMessageConverters() {
		HttpMessageConverter<?> c0 = mock();
		HttpMessageConverter<?> c1 = mock();
		HttpMessageConverter<?> c2 = mock();
		assertThat(apply(new HttpMessageConvertersRestClientCustomizer(c1, c2), c0)).containsExactly(c1, c2);
	}
	@SuppressWarnings('unchecked')
	private List<HttpMessageConverter<?>> apply(HttpMessageConvertersRestClientCustomizer customizer,
			HttpMessageConverter<?>... converters) {
		List<HttpMessageConverter<?>> messageConverters = new ArrayList<>(Arrays.asList(converters));
		RestClient.Builder restClientBuilder = mock();
		ArgumentCaptor<Consumer<List<HttpMessageConverter<?>>>> captor = ArgumentCaptor.forClass(Consumer.class);
		given(restClientBuilder.messageConverters(captor.capture())).willReturn(restClientBuilder);
		customizer.customize(restClientBuilder);
		captor.getValue().accept(messageConverters);
		return messageConverters;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class UndertowServletWebServerFactoryCustomizerTests {
	@Test
	void eagerFilterInitCanBeDisabled() {
		UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory(0);
		assertThat(factory.isEagerFilterInit()).isTrue();
		ServerProperties serverProperties = new ServerProperties();
		serverProperties.getUndertow().setEagerFilterInit(false);
		new UndertowServletWebServerFactoryCustomizer(serverProperties).customize(factory);
		assertThat(factory.isEagerFilterInit()).isFalse();
	}
	@Test
	void preservePathOnForwardCanBeEnabled() {
		UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory(0);
		assertThat(factory.isPreservePathOnForward()).isFalse();
		ServerProperties serverProperties = new ServerProperties();
		serverProperties.getUndertow().setPreservePathOnForward(true);
		new UndertowServletWebServerFactoryCustomizer(serverProperties).customize(factory);
		assertThat(factory.isPreservePathOnForward()).isTrue();
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class DispatcherServletAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DispatcherServletAutoConfiguration.class));
	@Test
	void registrationProperties() {
		this.contextRunner.run((context) -> {
			assertThat(context.getBean(DispatcherServlet.class)).isNotNull();
			ServletRegistrationBean<?> registration = context.getBean(ServletRegistrationBean.class);
			assertThat(registration.getUrlMappings()).containsExactly('/');
		});
	}
	@Test
	void registrationNonServletBean() {
		this.contextRunner.withUserConfiguration(NonServletConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(ServletRegistrationBean.class);
			assertThat(context).doesNotHaveBean(DispatcherServlet.class);
			assertThat(context).doesNotHaveBean(DispatcherServletPath.class);
		});
	}
	// If a DispatcherServlet instance is registered with a name different
	// from the default one, we"re registering one anyway
	@Test
	void registrationOverrideWithDispatcherServletWrongName() {
		this.contextRunner
			.withUserConfiguration(CustomDispatcherServletDifferentName.class, CustomDispatcherServletPath.class)
			.run((context) -> {
				ServletRegistrationBean<?> registration = context.getBean(ServletRegistrationBean.class);
				assertThat(registration.getUrlMappings()).containsExactly('/');
				assertThat(registration.getServletName()).isEqualTo('dispatcherServlet');
				assertThat(context).getBeanNames(DispatcherServlet.class).hasSize(2);
			});
	}
	@Test
	void registrationOverrideWithAutowiredServlet() {
		this.contextRunner.withUserConfiguration(CustomAutowiredRegistration.class).run((context) -> {
			ServletRegistrationBean<?> registration = context.getBean(ServletRegistrationBean.class);
			assertThat(registration.getUrlMappings()).containsExactly('/foo');
			assertThat(registration.getServletName()).isEqualTo('customDispatcher');
			assertThat(context).hasSingleBean(DispatcherServlet.class);
		});
	}
	@Test
	void servletPath() {
		this.contextRunner.withPropertyValues('spring.mvc.servlet.path:/spring').run((context) -> {
			assertThat(context.getBean(DispatcherServlet.class)).isNotNull();
			ServletRegistrationBean<?> registration = context.getBean(ServletRegistrationBean.class);
			assertThat(registration.getUrlMappings()).containsExactly('/spring/*');
			assertThat(registration.getMultipartConfig()).isNull();
			assertThat(context.getBean(DispatcherServletPath.class).getPath()).isEqualTo('/spring');
		});
	}
	@Test
	void dispatcherServletPathWhenCustomDispatcherServletSameNameShouldReturnConfiguredServletPath() {
		this.contextRunner.withUserConfiguration(CustomDispatcherServletSameName.class)
			.withPropertyValues('spring.mvc.servlet.path:/spring')
			.run((context) -> assertThat(context.getBean(DispatcherServletPath.class).getPath()).isEqualTo('/spring'));
	}
	@Test
	void dispatcherServletPathNotCreatedWhenDefaultDispatcherServletNotAvailable() {
		this.contextRunner
			.withUserConfiguration(CustomDispatcherServletDifferentName.class, NonServletConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(DispatcherServletPath.class));
	}
	@Test
	void dispatcherServletPathNotCreatedWhenCustomRegistrationBeanPresent() {
		this.contextRunner.withUserConfiguration(CustomDispatcherServletRegistration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(DispatcherServletPath.class));
	}
	@Test
	void multipartConfig() {
		this.contextRunner.withUserConfiguration(MultipartConfiguration.class).run((context) -> {
			ServletRegistrationBean<?> registration = context.getBean(ServletRegistrationBean.class);
			assertThat(registration.getMultipartConfig()).isNotNull();
		});
	}
	@Test
	void renamesMultipartResolver() {
		this.contextRunner.withUserConfiguration(MultipartResolverConfiguration.class).run((context) -> {
			DispatcherServlet dispatcherServlet = context.getBean(DispatcherServlet.class);
			dispatcherServlet.onApplicationEvent(new ContextRefreshedEvent(context));
			assertThat(dispatcherServlet.getMultipartResolver()).isInstanceOf(MockMultipartResolver.class);
		});
	}
	@Test
	void dispatcherServletDefaultConfig() {
		this.contextRunner.run((context) -> {
			DispatcherServlet dispatcherServlet = context.getBean(DispatcherServlet.class);
			assertThat(dispatcherServlet).extracting('dispatchOptionsRequest').isEqualTo(true);
			assertThat(dispatcherServlet).extracting('dispatchTraceRequest').isEqualTo(false);
			assertThat(dispatcherServlet).extracting('enableLoggingRequestDetails').isEqualTo(false);
			assertThat(dispatcherServlet).extracting('publishEvents').isEqualTo(true);
			assertThat(context.getBean('dispatcherServletRegistration')).hasFieldOrPropertyWithValue('loadOnStartup',
					-1);
		});
	}
	@Test
	@Deprecated(since = '3.2.0', forRemoval = true)
	void dispatcherServletThrowExceptionIfNoHandlerFoundDefaultConfig() {
		this.contextRunner.run((context) -> {
			DispatcherServlet dispatcherServlet = context.getBean(DispatcherServlet.class);
			assertThat(dispatcherServlet).extracting('throwExceptionIfNoHandlerFound').isEqualTo(true);
		});
	}
	@Test
	void dispatcherServletCustomConfig() {
		this.contextRunner
			.withPropertyValues('spring.mvc.dispatch-options-request:false', 'spring.mvc.dispatch-trace-request:true',
					'spring.mvc.publish-request-handled-events:false', 'spring.mvc.servlet.load-on-startup=5')
			.run((context) -> {
				DispatcherServlet dispatcherServlet = context.getBean(DispatcherServlet.class);
				assertThat(dispatcherServlet).extracting('dispatchOptionsRequest').isEqualTo(false);
				assertThat(dispatcherServlet).extracting('dispatchTraceRequest').isEqualTo(true);
				assertThat(dispatcherServlet).extracting('publishEvents').isEqualTo(false);
				assertThat(context.getBean('dispatcherServletRegistration'))
					.hasFieldOrPropertyWithValue('loadOnStartup', 5);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipartConfiguration {
		@Bean
		MultipartConfigElement multipartConfig() {
			MultipartConfigFactory factory = new MultipartConfigFactory();
			factory.setMaxFileSize(DataSize.ofKilobytes(128));
			factory.setMaxRequestSize(DataSize.ofKilobytes(128));
			return factory.createMultipartConfig();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDispatcherServletDifferentName {
		@Bean
		DispatcherServlet customDispatcherServlet() {
			return new DispatcherServlet();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDispatcherServletPath {
		@Bean
		DispatcherServletPath dispatcherServletPath() {
			return mock(DispatcherServletPath.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAutowiredRegistration {
		@Bean
		ServletRegistrationBean<?> dispatcherServletRegistration(DispatcherServlet dispatcherServlet) {
			ServletRegistrationBean<DispatcherServlet> registration = new ServletRegistrationBean<>(dispatcherServlet,
					'/foo');
			registration.setName('customDispatcher');
			return registration;
		}
		@Bean
		DispatcherServletPath dispatcherServletPath() {
			return mock(DispatcherServletPath.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonServletConfiguration {
		@Bean
		String dispatcherServlet() {
			return 'spring';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipartResolverConfiguration {
		@Bean
		MultipartResolver getMultipartResolver() {
			return new MockMultipartResolver();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDispatcherServletSameName {
		@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDispatcherServletRegistration {
		@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
		ServletRegistrationBean<DispatcherServlet> dispatcherServletRegistration(DispatcherServlet dispatcherServlet) {
			ServletRegistrationBean<DispatcherServlet> registration = new ServletRegistrationBean<>(dispatcherServlet,
					'/foo');
			registration.setName('customDispatcher');
			return registration;
		}
	}
	static class MockMultipartResolver implements MultipartResolver {
		@Override
		public boolean isMultipart(HttpServletRequest request) {
			return false;
		}
		@Override
		public MultipartHttpServletRequest resolveMultipart(HttpServletRequest request) {
			return null;
		}
		@Override
		public void cleanupMultipart(MultipartHttpServletRequest request) {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class DispatcherServletRegistrationBeanTests {
	@Test
	void createWhenPathIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DispatcherServletRegistrationBean(new DispatcherServlet(), null))
			.withMessageContaining('Path must not be null');
	}
	@Test
	void getPathReturnsPath() {
		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(new DispatcherServlet(),
				'/test');
		assertThat(bean.getPath()).isEqualTo('/test');
	}
	@Test
	void getUrlMappingsReturnsSinglePathMappedPattern() {
		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(new DispatcherServlet(),
				'/test');
		assertThat(bean.getUrlMappings()).containsOnly('/test/*');
	}
	@Test
	void setUrlMappingsCannotBeCalled() {
		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(new DispatcherServlet(),
				'/test');
		assertThatExceptionOfType(UnsupportedOperationException.class)
			.isThrownBy(() -> bean.setUrlMappings(Collections.emptyList()));
	}
	@Test
	void addUrlMappingsCannotBeCalled() {
		DispatcherServletRegistrationBean bean = new DispatcherServletRegistrationBean(new DispatcherServlet(),
				'/test');
		assertThatExceptionOfType(UnsupportedOperationException.class).isThrownBy(() -> bean.addUrlMappings('/test'));
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class TomcatServletWebServerFactoryCustomizerTests {
	private TomcatServletWebServerFactoryCustomizer customizer;
	private MockEnvironment environment;
	private ServerProperties serverProperties;
	@BeforeEach
	void setup() {
		this.environment = new MockEnvironment();
		this.serverProperties = new ServerProperties();
		ConfigurationPropertySources.attach(this.environment);
		this.customizer = new TomcatServletWebServerFactoryCustomizer(this.serverProperties);
	}
	@Test
	void customTldSkip() {
		bind('server.tomcat.additional-tld-skip-patterns=foo.jar,bar.jar');
		testCustomTldSkip('foo.jar', 'bar.jar');
	}
	@Test
	void customTldSkipAsList() {
		bind('server.tomcat.additional-tld-skip-patterns[0]=biz.jar',
				'server.tomcat.additional-tld-skip-patterns[1]=bah.jar');
		testCustomTldSkip('biz.jar', 'bah.jar');
	}
	private void testCustomTldSkip(String... expectedJars) {
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		assertThat(factory.getTldSkipPatterns()).contains(expectedJars);
		assertThat(factory.getTldSkipPatterns()).contains('junit-*.jar', 'spring-boot-*.jar');
	}
	@Test
	void redirectContextRootCanBeConfigured() {
		bind('server.tomcat.redirect-context-root=false');
		ServerProperties.Tomcat tomcat = this.serverProperties.getTomcat();
		assertThat(tomcat.getRedirectContextRoot()).isFalse();
		TomcatWebServer server = customizeAndGetServer();
		Context context = (Context) server.getTomcat().getHost().findChildren()[0];
		assertThat(context.getMapperContextRootRedirectEnabled()).isFalse();
	}
	@Test
	void useRelativeRedirectsCanBeConfigured() {
		bind('server.tomcat.use-relative-redirects=true');
		assertThat(this.serverProperties.getTomcat().isUseRelativeRedirects()).isTrue();
		TomcatWebServer server = customizeAndGetServer();
		Context context = (Context) server.getTomcat().getHost().findChildren()[0];
		assertThat(context.getUseRelativeRedirects()).isTrue();
	}
	private void bind(String... inlinedProperties) {
		TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, inlinedProperties);
		new Binder(ConfigurationPropertySources.get(this.environment)).bind('server',
				Bindable.ofInstance(this.serverProperties));
	}
	private TomcatWebServer customizeAndGetServer() {
		TomcatServletWebServerFactory factory = customizeAndGetFactory();
		return (TomcatWebServer) factory.getWebServer();
	}
	private TomcatServletWebServerFactory customizeAndGetFactory() {
		TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(0);
		this.customizer.customize(factory);
		return factory;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class HttpEncodingAutoConfigurationTests {
	private AnnotationConfigServletWebApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void defaultConfiguration() {
		load(EmptyConfiguration.class);
		CharacterEncodingFilter filter = this.context.getBean(CharacterEncodingFilter.class);
		assertCharacterEncodingFilter(filter, 'UTF-8', true, false);
	}
	@Test
	void disableConfiguration() {
		load(EmptyConfiguration.class, 'server.servlet.encoding.enabled:false');
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(CharacterEncodingFilter.class));
	}
	@Test
	void customConfiguration() {
		load(EmptyConfiguration.class, 'server.servlet.encoding.charset:ISO-8859-15',
				'server.servlet.encoding.force:false');
		CharacterEncodingFilter filter = this.context.getBean(CharacterEncodingFilter.class);
		assertCharacterEncodingFilter(filter, 'ISO-8859-15', false, false);
	}
	@Test
	void customFilterConfiguration() {
		load(FilterConfiguration.class, 'server.servlet.encoding.charset:ISO-8859-15',
				'server.servlet.encoding.force:false');
		CharacterEncodingFilter filter = this.context.getBean(CharacterEncodingFilter.class);
		assertCharacterEncodingFilter(filter, 'US-ASCII', false, false);
	}
	@Test
	void forceRequest() {
		load(EmptyConfiguration.class, 'server.servlet.encoding.force-request:false');
		CharacterEncodingFilter filter = this.context.getBean(CharacterEncodingFilter.class);
		assertCharacterEncodingFilter(filter, 'UTF-8', false, false);
	}
	@Test
	void forceResponse() {
		load(EmptyConfiguration.class, 'server.servlet.encoding.force-response:true');
		CharacterEncodingFilter filter = this.context.getBean(CharacterEncodingFilter.class);
		assertCharacterEncodingFilter(filter, 'UTF-8', true, true);
	}
	@Test
	void forceRequestOverridesForce() {
		load(EmptyConfiguration.class, 'server.servlet.encoding.force:true',
				'server.servlet.encoding.force-request:false');
		CharacterEncodingFilter filter = this.context.getBean(CharacterEncodingFilter.class);
		assertCharacterEncodingFilter(filter, 'UTF-8', false, true);
	}
	@Test
	void forceResponseOverridesForce() {
		load(EmptyConfiguration.class, 'server.servlet.encoding.force:true',
				'server.servlet.encoding.force-response:false');
		CharacterEncodingFilter filter = this.context.getBean(CharacterEncodingFilter.class);
		assertCharacterEncodingFilter(filter, 'UTF-8', true, false);
	}
	@Test
	void filterIsOrderedHighest() {
		load(OrderedConfiguration.class);
		List<Filter> beans = new ArrayList<>(this.context.getBeansOfType(Filter.class).values());
		AnnotationAwareOrderComparator.sort(beans);
		assertThat(beans.get(0)).isInstanceOf(CharacterEncodingFilter.class);
		assertThat(beans.get(1)).isInstanceOf(HiddenHttpMethodFilter.class);
	}
	@Test
	void noLocaleCharsetMapping() {
		load(EmptyConfiguration.class);
		Map<String, WebServerFactoryCustomizer<?>> beans = getWebServerFactoryCustomizerBeans();
		assertThat(beans).hasSize(1);
		assertThat(this.context.getBean(MockServletWebServerFactory.class).getLocaleCharsetMappings()).isEmpty();
	}
	@Test
	void customLocaleCharsetMappings() {
		load(EmptyConfiguration.class, 'server.servlet.encoding.mapping.en:UTF-8',
				'server.servlet.encoding.mapping.fr_FR:UTF-8');
		Map<String, WebServerFactoryCustomizer<?>> beans = getWebServerFactoryCustomizerBeans();
		assertThat(beans).hasSize(1);
		assertThat(this.context.getBean(MockServletWebServerFactory.class).getLocaleCharsetMappings()).hasSize(2)
			.containsEntry(Locale.ENGLISH, StandardCharsets.UTF_8)
			.containsEntry(Locale.FRANCE, StandardCharsets.UTF_8);
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	private Map<String, WebServerFactoryCustomizer<?>> getWebServerFactoryCustomizerBeans() {
		return (Map) this.context.getBeansOfType(WebServerFactoryCustomizer.class);
	}
	private void assertCharacterEncodingFilter(CharacterEncodingFilter actual, String encoding,
			boolean forceRequestEncoding, boolean forceResponseEncoding) {
		assertThat(actual.getEncoding()).isEqualTo(encoding);
		assertThat(actual.isForceRequestEncoding()).isEqualTo(forceRequestEncoding);
		assertThat(actual.isForceResponseEncoding()).isEqualTo(forceResponseEncoding);
	}
	private void load(Class<?> config, String... environment) {
		this.context = doLoad(new Class<?>[] { config }, environment);
	}
	private AnnotationConfigServletWebApplicationContext doLoad(Class<?>[] configs, String... environment) {
		AnnotationConfigServletWebApplicationContext applicationContext = new AnnotationConfigServletWebApplicationContext();
		TestPropertyValues.of(environment).applyTo(applicationContext);
		applicationContext.register(configs);
		applicationContext.register(MinimalWebAutoConfiguration.class, HttpEncodingAutoConfiguration.class);
		applicationContext.setServletContext(new MockServletContext());
		applicationContext.refresh();
		return applicationContext;
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class FilterConfiguration {
		@Bean
		CharacterEncodingFilter myCharacterEncodingFilter() {
			CharacterEncodingFilter filter = new CharacterEncodingFilter();
			filter.setEncoding('US-ASCII');
			filter.setForceEncoding(false);
			return filter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OrderedConfiguration {
		@Bean
		OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
			return new OrderedHiddenHttpMethodFilter();
		}
		@Bean
		OrderedFormContentFilter formContentFilter() {
			return new OrderedFormContentFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MinimalWebAutoConfiguration {
		@Bean
		MockServletWebServerFactory MockServletWebServerFactory() {
			return new MockServletWebServerFactory();
		}
		@Bean
		WebServerFactoryCustomizerBeanPostProcessor ServletWebServerCustomizerBeanPostProcessor() {
			return new WebServerFactoryCustomizerBeanPostProcessor();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@DirtiesUrlFactories
class MultipartAutoConfigurationTests {
	private AnnotationConfigServletWebServerApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void webServerWithNothing() throws Exception {
		this.context = new AnnotationConfigServletWebServerApplicationContext(WebServerWithNothing.class,
				BaseConfiguration.class);
		DispatcherServlet servlet = this.context.getBean(DispatcherServlet.class);
		verify404();
		assertThat(servlet.getMultipartResolver()).isNotNull();
		assertThat(this.context.getBeansOfType(StandardServletMultipartResolver.class)).hasSize(1);
		assertThat(this.context.getBeansOfType(MultipartResolver.class)).hasSize(1);
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('webServerWithNoMultipartConfigurationArguments')
	@ForkedClassPath
	void webServerWithNoMultipartConfiguration(String server, Class<?> configuration) {
		this.context = new AnnotationConfigServletWebServerApplicationContext(configuration, BaseConfiguration.class);
		assertThat(this.context.getBeansOfType(StandardServletMultipartResolver.class)).hasSize(1);
		assertThat(this.context.getBeansOfType(MultipartResolver.class)).hasSize(1);
		verifyServletWorks();
		assertThat(this.context.getBean(StandardServletMultipartResolver.class))
			.isSameAs(this.context.getBean(DispatcherServlet.class).getMultipartResolver());
	}
	static Stream<Arguments> webServerWithNoMultipartConfigurationArguments() {
		return Stream.of(Arguments.of('Jetty', WebServerWithNoMultipartJetty.class),
				Arguments.of('Tomcat', WebServerWithNoMultipartTomcat.class),
				Arguments.of('Undertow', WebServerWithNoMultipartUndertow.class));
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('webServerWithAutomatedMultipartConfigurationArguments')
	@ForkedClassPath
	void webServerWithAutomatedMultipartConfiguration(String server, Class<?> configuration) {
		this.context = new AnnotationConfigServletWebServerApplicationContext(configuration, BaseConfiguration.class);
		this.context.getBean(MultipartConfigElement.class);
		verifyServletWorks();
		assertThat(this.context.getBean(StandardServletMultipartResolver.class))
			.isSameAs(this.context.getBean(DispatcherServlet.class).getMultipartResolver());
	}
	static Stream<Arguments> webServerWithAutomatedMultipartConfigurationArguments() {
		return Stream.of(Arguments.of('Jetty', WebServerWithEverythingJetty.class),
				Arguments.of('Tomcat', WebServerWithEverythingTomcat.class),
				Arguments.of('Undertow', WebServerWithEverythingUndertow.class));
	}
	@Test
	void webServerWithNonAbsoluteMultipartLocationUndertowConfiguration() {
		this.context = new AnnotationConfigServletWebServerApplicationContext(
				WebServerWithNonAbsolutePathUndertow.class, BaseConfiguration.class);
		this.context.getBean(MultipartConfigElement.class);
		verifyServletWorks();
		assertThat(this.context.getBean(StandardServletMultipartResolver.class))
			.isSameAs(this.context.getBean(DispatcherServlet.class).getMultipartResolver());
	}
	@Test
	void webServerWithMultipartConfigDisabled() {
		testWebServerWithCustomMultipartConfigEnabledSetting('false', 0);
	}
	@Test
	void webServerWithMultipartConfigEnabled() {
		testWebServerWithCustomMultipartConfigEnabledSetting('true', 1);
	}
	private void testWebServerWithCustomMultipartConfigEnabledSetting(final String propertyValue,
			int expectedNumberOfMultipartConfigElementBeans) {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		TestPropertyValues.of('spring.servlet.multipart.enabled=' + propertyValue).applyTo(this.context);
		this.context.register(WebServerWithNoMultipartTomcat.class, BaseConfiguration.class);
		this.context.refresh();
		this.context.getBean(MultipartProperties.class);
		assertThat(this.context.getBeansOfType(MultipartConfigElement.class))
			.hasSize(expectedNumberOfMultipartConfigElementBeans);
	}
	@Test
	void webServerWithCustomMultipartResolver() {
		this.context = new AnnotationConfigServletWebServerApplicationContext(
				WebServerWithCustomMultipartResolver.class, BaseConfiguration.class);
		MultipartResolver multipartResolver = this.context.getBean(MultipartResolver.class);
		assertThat(multipartResolver).isNotInstanceOf(StandardServletMultipartResolver.class);
		assertThat(this.context.getBeansOfType(MultipartConfigElement.class)).hasSize(1);
	}
	@Test
	void configureResolveLazily() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		TestPropertyValues.of('spring.servlet.multipart.resolve-lazily=true').applyTo(this.context);
		this.context.register(WebServerWithNothing.class, BaseConfiguration.class);
		this.context.refresh();
		StandardServletMultipartResolver multipartResolver = this.context
			.getBean(StandardServletMultipartResolver.class);
		assertThat(multipartResolver).hasFieldOrPropertyWithValue('resolveLazily', true);
	}
	@Test
	void configureStrictServletCompliance() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		TestPropertyValues.of('spring.servlet.multipart.strict-servlet-compliance=true').applyTo(this.context);
		this.context.register(WebServerWithNothing.class, BaseConfiguration.class);
		this.context.refresh();
		StandardServletMultipartResolver multipartResolver = this.context
			.getBean(StandardServletMultipartResolver.class);
		assertThat(multipartResolver).hasFieldOrPropertyWithValue('strictServletCompliance', true);
	}
	@Test
	void configureMultipartProperties() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		TestPropertyValues
			.of('spring.servlet.multipart.max-file-size=2048KB', 'spring.servlet.multipart.max-request-size=15MB')
			.applyTo(this.context);
		this.context.register(WebServerWithNothing.class, BaseConfiguration.class);
		this.context.refresh();
		MultipartConfigElement multipartConfigElement = this.context.getBean(MultipartConfigElement.class);
		assertThat(multipartConfigElement.getMaxFileSize()).isEqualTo(2048 * 1024);
		assertThat(multipartConfigElement.getMaxRequestSize()).isEqualTo(15 * 1024 * 1024);
	}
	@Test
	void configureMultipartPropertiesWithRawLongValues() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		TestPropertyValues
			.of('spring.servlet.multipart.max-file-size=512', 'spring.servlet.multipart.max-request-size=2048')
			.applyTo(this.context);
		this.context.register(WebServerWithNothing.class, BaseConfiguration.class);
		this.context.refresh();
		MultipartConfigElement multipartConfigElement = this.context.getBean(MultipartConfigElement.class);
		assertThat(multipartConfigElement.getMaxFileSize()).isEqualTo(512);
		assertThat(multipartConfigElement.getMaxRequestSize()).isEqualTo(2048);
	}
	private void verify404() throws Exception {
		HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory();
		ClientHttpRequest request = requestFactory
			.createRequest(new URI('http://localhost:' + this.context.getWebServer().getPort() + '/'), HttpMethod.GET);
		try (ClientHttpResponse response = request.execute()) {
			assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
		}
	}
	private void verifyServletWorks() {
		RestTemplate restTemplate = new RestTemplate();
		String url = 'http://localhost:' + this.context.getWebServer().getPort() + '/';
		assertThat(restTemplate.getForObject(url, String.class)).isEqualTo('Hello');
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerWithNothing {
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerWithNoMultipartJetty {
		@Bean
		JettyServletWebServerFactory webServerFactory() {
			return new JettyServletWebServerFactory();
		}
		@Bean
		WebController controller() {
			return new WebController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerWithNoMultipartUndertow {
		@Bean
		UndertowServletWebServerFactory webServerFactory() {
			return new UndertowServletWebServerFactory();
		}
		@Bean
		WebController controller() {
			return new WebController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			MultipartAutoConfiguration.class })
	@EnableConfigurationProperties(MultipartProperties.class)
	static class BaseConfiguration {
		@Bean
		ServerProperties serverProperties() {
			ServerProperties properties = new ServerProperties();
			properties.setPort(0);
			return properties;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerWithNoMultipartTomcat {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory();
		}
		@Bean
		WebController controller() {
			return new WebController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerWithEverythingJetty {
		@Bean
		MultipartConfigElement multipartConfigElement() {
			return new MultipartConfigElement('');
		}
		@Bean
		JettyServletWebServerFactory webServerFactory() {
			return new JettyServletWebServerFactory();
		}
		@Bean
		WebController webController() {
			return new WebController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class WebServerWithEverythingTomcat {
		@Bean
		MultipartConfigElement multipartConfigElement() {
			return new MultipartConfigElement('');
		}
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory();
		}
		@Bean
		WebController webController() {
			return new WebController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class WebServerWithEverythingUndertow {
		@Bean
		MultipartConfigElement multipartConfigElement() {
			return new MultipartConfigElement('');
		}
		@Bean
		UndertowServletWebServerFactory webServerFactory() {
			return new UndertowServletWebServerFactory();
		}
		@Bean
		WebController webController() {
			return new WebController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class WebServerWithNonAbsolutePathUndertow {
		@Bean
		MultipartConfigElement multipartConfigElement() {
			return new MultipartConfigElement('test/not-absolute');
		}
		@Bean
		UndertowServletWebServerFactory webServerFactory() {
			return new UndertowServletWebServerFactory();
		}
		@Bean
		WebController webController() {
			return new WebController();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebServerWithCustomMultipartResolver {
		@Bean
		MultipartResolver multipartResolver() {
			return mock(MultipartResolver.class);
		}
	}
	@Controller
	static class WebController {
		@RequestMapping('/')
		@ResponseBody
		String index() {
			return 'Hello';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class WebMvcAutoConfigurationTests {
	private static final MockServletWebServerFactory webServerFactory = new MockServletWebServerFactory();
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
						HttpMessageConvertersAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class))
		.withUserConfiguration(Config.class);
	@Test
	void handlerAdaptersCreated() {
		this.contextRunner.run((context) -> {
			assertThat(context).getBeans(HandlerAdapter.class).hasSize(4);
			assertThat(context.getBean(RequestMappingHandlerAdapter.class).getMessageConverters()).isNotEmpty()
				.isEqualTo(context.getBean(HttpMessageConverters.class).getConverters());
		});
	}
	@Test
	void handlerMappingsCreated() {
		this.contextRunner.run((context) -> assertThat(context).getBeans(HandlerMapping.class).hasSize(6));
	}
	@Test
	void resourceHandlerMapping() {
		this.contextRunner.run((context) -> {
			Map<String, List<Resource>> locations = getResourceMappingLocations(context);
			assertThat(locations.get('/**')).hasSize(5);
			assertThat(locations.get('/webjars/**')).hasSize(1);
			assertThat(locations.get('/webjars/**').get(0))
				.isEqualTo(new ClassPathResource('/META-INF/resources/webjars/'));
			assertThat(getResourceResolvers(context, '/webjars/**')).hasSize(1);
			assertThat(getResourceTransformers(context, '/webjars/**')).isEmpty();
			assertThat(getResourceResolvers(context, '/**')).hasSize(1);
			assertThat(getResourceTransformers(context, '/**')).isEmpty();
		});
	}
	@Test
	void customResourceHandlerMapping() {
		this.contextRunner.withPropertyValues('spring.mvc.static-path-pattern:/static/**').run((context) -> {
			Map<String, List<Resource>> locations = getResourceMappingLocations(context);
			assertThat(locations.get('/static/**')).hasSize(5);
			assertThat(getResourceResolvers(context, '/static/**')).hasSize(1);
		});
	}
	@Test
	void customWebjarsHandlerMapping() {
		this.contextRunner.withPropertyValues('spring.mvc.webjars-path-pattern:/assets/**').run((context) -> {
			Map<String, List<Resource>> locations = getResourceMappingLocations(context);
			assertThat(locations.get('/assets/**')).hasSize(1);
			assertThat(locations.get('/assets/**').get(0))
				.isEqualTo(new ClassPathResource('/META-INF/resources/webjars/'));
			assertThat(getResourceResolvers(context, '/assets/**')).hasSize(1);
		});
	}
	@Test
	void resourceHandlerMappingOverrideWebjars() {
		this.contextRunner.withUserConfiguration(WebJars.class).run((context) -> {
			Map<String, List<Resource>> locations = getResourceMappingLocations(context);
			assertThat(locations.get('/webjars/**')).hasSize(1);
			assertThat(locations.get('/webjars/**').get(0)).isEqualTo(new ClassPathResource('/foo/'));
		});
	}
	@Test
	void resourceHandlerMappingOverrideAll() {
		this.contextRunner.withUserConfiguration(AllResources.class).run((context) -> {
			Map<String, List<Resource>> locations = getResourceMappingLocations(context);
			assertThat(locations.get('/**')).hasSize(1);
			assertThat(locations.get('/**').get(0)).isEqualTo(new ClassPathResource('/foo/'));
		});
	}
	@Test
	void resourceHandlerMappingDisabled() {
		this.contextRunner.withPropertyValues('spring.web.resources.add-mappings:false')
			.run((context) -> assertThat(getResourceMappingLocations(context)).isEmpty());
	}
	@Test
	void resourceHandlerChainEnabled() {
		this.contextRunner.withPropertyValues('spring.web.resources.chain.enabled:true').run((context) -> {
			assertThat(getResourceResolvers(context, '/webjars/**')).hasSize(2);
			assertThat(getResourceTransformers(context, '/webjars/**')).hasSize(1);
			assertThat(getResourceResolvers(context, '/**')).extractingResultOf('getClass')
				.containsOnly(CachingResourceResolver.class, PathResourceResolver.class);
			assertThat(getResourceTransformers(context, '/**')).extractingResultOf('getClass')
				.containsOnly(CachingResourceTransformer.class);
		});
	}
	@Test
	void resourceHandlerFixedStrategyEnabled() {
		this.contextRunner
			.withPropertyValues('spring.web.resources.chain.strategy.fixed.enabled:true',
					'spring.web.resources.chain.strategy.fixed.version:test',
					'spring.web.resources.chain.strategy.fixed.paths:/**/*.js')
			.run((context) -> {
				assertThat(getResourceResolvers(context, '/webjars/**')).hasSize(3);
				assertThat(getResourceTransformers(context, '/webjars/**')).hasSize(2);
				assertThat(getResourceResolvers(context, '/**')).extractingResultOf('getClass')
					.containsOnly(CachingResourceResolver.class, VersionResourceResolver.class,
							PathResourceResolver.class);
				assertThat(getResourceTransformers(context, '/**')).extractingResultOf('getClass')
					.containsOnly(CachingResourceTransformer.class, CssLinkResourceTransformer.class);
				VersionResourceResolver resolver = (VersionResourceResolver) getResourceResolvers(context, '/**')
					.get(1);
				assertThat(resolver.getStrategyMap().get('/**/*.js')).isInstanceOf(FixedVersionStrategy.class);
			});
	}
	@Test
	void resourceHandlerContentStrategyEnabled() {
		this.contextRunner
			.withPropertyValues('spring.web.resources.chain.strategy.content.enabled:true',
					'spring.web.resources.chain.strategy.content.paths:/**,/*.png')
			.run((context) -> {
				assertThat(getResourceResolvers(context, '/webjars/**')).hasSize(3);
				assertThat(getResourceTransformers(context, '/webjars/**')).hasSize(2);
				assertThat(getResourceResolvers(context, '/**')).extractingResultOf('getClass')
					.containsOnly(CachingResourceResolver.class, VersionResourceResolver.class,
							PathResourceResolver.class);
				assertThat(getResourceTransformers(context, '/**')).extractingResultOf('getClass')
					.containsOnly(CachingResourceTransformer.class, CssLinkResourceTransformer.class);
				VersionResourceResolver resolver = (VersionResourceResolver) getResourceResolvers(context, '/**')
					.get(1);
				assertThat(resolver.getStrategyMap().get('/*.png')).isInstanceOf(ContentVersionStrategy.class);
			});
	}
	@Test
	void resourceHandlerChainCustomized() {
		this.contextRunner.withPropertyValues('spring.web.resources.chain.enabled:true',
				'spring.web.resources.chain.cache:false', 'spring.web.resources.chain.strategy.content.enabled:true',
				'spring.web.resources.chain.strategy.content.paths:/**,/*.png',
				'spring.web.resources.chain.strategy.fixed.enabled:true',
				'spring.web.resources.chain.strategy.fixed.version:test',
				'spring.web.resources.chain.strategy.fixed.paths:/**/*.js',
				'spring.web.resources.chain.html-application-cache:true', 'spring.web.resources.chain.compressed:true')
			.run((context) -> {
				assertThat(getResourceResolvers(context, '/webjars/**')).hasSize(3);
				assertThat(getResourceTransformers(context, '/webjars/**')).hasSize(1);
				assertThat(getResourceResolvers(context, '/**')).extractingResultOf('getClass')
					.containsOnly(EncodedResourceResolver.class, VersionResourceResolver.class,
							PathResourceResolver.class);
				assertThat(getResourceTransformers(context, '/**')).extractingResultOf('getClass')
					.containsOnly(CssLinkResourceTransformer.class);
				VersionResourceResolver resolver = (VersionResourceResolver) getResourceResolvers(context, '/**')
					.get(1);
				Map<String, VersionStrategy> strategyMap = resolver.getStrategyMap();
				assertThat(strategyMap.get('/*.png')).isInstanceOf(ContentVersionStrategy.class);
				assertThat(strategyMap.get('/**/*.js')).isInstanceOf(FixedVersionStrategy.class);
			});
	}
	@Test
	void defaultLocaleResolver() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(LocaleResolver.class);
			LocaleResolver localeResolver = context.getBean(LocaleResolver.class);
			assertThat(localeResolver).hasFieldOrPropertyWithValue('defaultLocale', null);
		});
	}
	@Test
	void overrideLocale() {
		this.contextRunner.withPropertyValues('spring.web.locale:en_UK', 'spring.web.locale-resolver=fixed')
			.run((loader) -> {
				// mock request and set user preferred locale
				MockHttpServletRequest request = new MockHttpServletRequest();
				request.addPreferredLocale(StringUtils.parseLocaleString('nl_NL'));
				request.addHeader(HttpHeaders.ACCEPT_LANGUAGE, 'nl_NL');
				LocaleResolver localeResolver = loader.getBean(LocaleResolver.class);
				assertThat(localeResolver).isInstanceOf(FixedLocaleResolver.class);
				Locale locale = localeResolver.resolveLocale(request);
				// test locale resolver uses fixed locale and not user preferred
				// locale
				assertThat(locale).hasToString('en_UK');
			});
	}
	@Test
	void useAcceptHeaderLocale() {
		this.contextRunner.withPropertyValues('spring.web.locale:en_UK').run((loader) -> {
			// mock request and set user preferred locale
			MockHttpServletRequest request = new MockHttpServletRequest();
			request.addPreferredLocale(StringUtils.parseLocaleString('nl_NL'));
			request.addHeader(HttpHeaders.ACCEPT_LANGUAGE, 'nl_NL');
			LocaleResolver localeResolver = loader.getBean(LocaleResolver.class);
			assertThat(localeResolver).isInstanceOf(AcceptHeaderLocaleResolver.class);
			Locale locale = localeResolver.resolveLocale(request);
			// test locale resolver uses user preferred locale
			assertThat(locale).hasToString('nl_NL');
		});
	}
	@Test
	void useDefaultLocaleIfAcceptHeaderNoSet() {
		this.contextRunner.withPropertyValues('spring.web.locale:en_UK').run((context) -> {
			// mock request and set user preferred locale
			MockHttpServletRequest request = new MockHttpServletRequest();
			LocaleResolver localeResolver = context.getBean(LocaleResolver.class);
			assertThat(localeResolver).isInstanceOf(AcceptHeaderLocaleResolver.class);
			Locale locale = localeResolver.resolveLocale(request);
			// test locale resolver uses default locale if no header is set
			assertThat(locale).hasToString('en_UK');
		});
	}
	@Test
	void customLocaleResolverWithMatchingNameReplacesAutoConfiguredLocaleResolver() {
		this.contextRunner.withBean('localeResolver', CustomLocaleResolver.class, CustomLocaleResolver::new)
			.run((context) -> {
				assertThat(context).hasSingleBean(LocaleResolver.class);
				assertThat(context.getBean('localeResolver')).isInstanceOf(CustomLocaleResolver.class);
			});
	}
	@Test
	void customLocaleResolverWithDifferentNameDoesNotReplaceAutoConfiguredLocaleResolver() {
		this.contextRunner.withBean('customLocaleResolver', CustomLocaleResolver.class, CustomLocaleResolver::new)
			.run((context) -> {
				assertThat(context.getBean('customLocaleResolver')).isInstanceOf(CustomLocaleResolver.class);
				assertThat(context.getBean('localeResolver')).isInstanceOf(AcceptHeaderLocaleResolver.class);
			});
	}
	@Test
	void customFlashMapManagerWithMatchingNameReplacesDefaultFlashMapManager() {
		this.contextRunner.withBean('flashMapManager', CustomFlashMapManager.class, CustomFlashMapManager::new)
			.run((context) -> {
				assertThat(context).hasSingleBean(FlashMapManager.class);
				assertThat(context.getBean('flashMapManager')).isInstanceOf(CustomFlashMapManager.class);
			});
	}
	@Test
	void customFlashMapManagerWithDifferentNameDoesNotReplaceDefaultFlashMapManager() {
		this.contextRunner.withBean('customFlashMapManager', CustomFlashMapManager.class, CustomFlashMapManager::new)
			.run((context) -> {
				assertThat(context.getBean('customFlashMapManager')).isInstanceOf(CustomFlashMapManager.class);
				assertThat(context.getBean('flashMapManager')).isInstanceOf(SessionFlashMapManager.class);
			});
	}
	@Test
	void customViewNameTranslatorWithMatchingNameReplacesDefaultViewNameTranslator() {
		this.contextRunner.withBean('viewNameTranslator', CustomViewNameTranslator.class, CustomViewNameTranslator::new)
			.run((context) -> {
				assertThat(context).hasSingleBean(RequestToViewNameTranslator.class);
				assertThat(context.getBean('viewNameTranslator')).isInstanceOf(CustomViewNameTranslator.class);
			});
	}
	@Test
	void customViewNameTranslatorWithDifferentNameDoesNotReplaceDefaultViewNameTranslator() {
		this.contextRunner
			.withBean('customViewNameTranslator', CustomViewNameTranslator.class, CustomViewNameTranslator::new)
			.run((context) -> {
				assertThat(context.getBean('customViewNameTranslator')).isInstanceOf(CustomViewNameTranslator.class);
				assertThat(context.getBean('viewNameTranslator'))
					.isInstanceOf(DefaultRequestToViewNameTranslator.class);
			});
	}
	@Test
	void defaultDateFormat() {
		this.contextRunner.run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			Date date = Date.from(ZonedDateTime.of(1988, 6, 25, 20, 30, 0, 0, ZoneId.systemDefault()).toInstant());
			// formatting conversion service should use simple toString()
			assertThat(conversionService.convert(date, String.class)).isEqualTo(date.toString());
		});
	}
	@Test
	void customDateFormat() {
		this.contextRunner.withPropertyValues('spring.mvc.format.date:dd*MM*yyyy').run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			Date date = Date.from(ZonedDateTime.of(1988, 6, 25, 20, 30, 0, 0, ZoneId.systemDefault()).toInstant());
			assertThat(conversionService.convert(date, String.class)).isEqualTo('25*06*1988');
		});
	}
	@Test
	void defaultTimeFormat() {
		this.contextRunner.run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalTime time = LocalTime.of(11, 43, 10);
			assertThat(conversionService.convert(time, String.class))
				.isEqualTo(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(time));
		});
	}
	@Test
	void customTimeFormat() {
		this.contextRunner.withPropertyValues('spring.mvc.format.time=HH:mm:ss').run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalTime time = LocalTime.of(11, 43, 10);
			assertThat(conversionService.convert(time, String.class)).isEqualTo('11:43:10');
		});
	}
	@Test
	void defaultDateTimeFormat() {
		this.contextRunner.run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalDateTime dateTime = LocalDateTime.of(2020, 4, 28, 11, 43, 10);
			assertThat(conversionService.convert(dateTime, String.class))
				.isEqualTo(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(dateTime));
		});
	}
	@Test
	void customDateTimeTimeFormat() {
		this.contextRunner.withPropertyValues('spring.mvc.format.date-time=yyyy-MM-dd HH:mm:ss').run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalDateTime dateTime = LocalDateTime.of(2020, 4, 28, 11, 43, 10);
			assertThat(conversionService.convert(dateTime, String.class)).isEqualTo('2020-04-28 11:43:10');
		});
	}
	@Test
	void noMessageCodesResolver() {
		this.contextRunner.run(
				(context) -> assertThat(context.getBean(WebMvcAutoConfigurationAdapter.class).getMessageCodesResolver())
					.isNull());
	}
	@Test
	void overrideMessageCodesFormat() {
		this.contextRunner.withPropertyValues('spring.mvc.messageCodesResolverFormat:POSTFIX_ERROR_CODE')
			.run((context) -> assertThat(
					context.getBean(WebMvcAutoConfigurationAdapter.class).getMessageCodesResolver())
				.isNotNull());
	}
	@Test
	void customViewResolver() {
		this.contextRunner.withUserConfiguration(CustomViewResolver.class)
			.run((context) -> assertThat(context.getBean('viewResolver')).isInstanceOf(MyViewResolver.class));
	}
	@Test
	void customContentNegotiatingViewResolver() {
		this.contextRunner.withUserConfiguration(CustomContentNegotiatingViewResolver.class)
			.run((context) -> assertThat(context).getBeanNames(ContentNegotiatingViewResolver.class)
				.containsOnly('myViewResolver'));
	}
	@Test
	void defaultAsyncRequestTimeout() {
		this.contextRunner.run((context) -> assertThat(context.getBean(RequestMappingHandlerAdapter.class))
			.extracting('asyncRequestTimeout')
			.isNull());
	}
	@Test
	void customAsyncRequestTimeout() {
		this.contextRunner.withPropertyValues('spring.mvc.async.request-timeout:12345')
			.run((context) -> assertThat(context.getBean(RequestMappingHandlerAdapter.class))
				.extracting('asyncRequestTimeout')
				.isEqualTo(12345L));
	}
	@Test
	void asyncTaskExecutorWithApplicationTaskExecutor() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(AsyncTaskExecutor.class);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('taskExecutor')
					.isSameAs(context.getBean('applicationTaskExecutor'));
			});
	}
	@Test
	void asyncTaskExecutorWithNonMatchApplicationTaskExecutorBean() {
		this.contextRunner.withUserConfiguration(CustomApplicationTaskExecutorConfig.class)
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(AsyncTaskExecutor.class);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('taskExecutor')
					.isNotSameAs(context.getBean('applicationTaskExecutor'));
			});
	}
	@Test
	void asyncTaskExecutorWithMvcConfigurerCanOverrideExecutor() {
		this.contextRunner.withUserConfiguration(CustomAsyncTaskExecutorConfigurer.class)
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('taskExecutor')
				.isSameAs(context.getBean(CustomAsyncTaskExecutorConfigurer.class).taskExecutor));
	}
	@Test
	void asyncTaskExecutorWithCustomNonApplicationTaskExecutor() {
		this.contextRunner.withUserConfiguration(CustomAsyncTaskExecutorConfig.class)
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(AsyncTaskExecutor.class);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('taskExecutor')
					.isNotSameAs(context.getBean('customTaskExecutor'));
			});
	}
	@Test
	void customMediaTypes() {
		this.contextRunner.withPropertyValues('spring.mvc.contentnegotiation.media-types.yaml:text/yaml')
			.run((context) -> {
				RequestMappingHandlerAdapter adapter = context.getBean(RequestMappingHandlerAdapter.class);
				ContentNegotiationManager contentNegotiationManager = (ContentNegotiationManager) ReflectionTestUtils
					.getField(adapter, 'contentNegotiationManager');
				assertThat(contentNegotiationManager.getAllFileExtensions()).contains('yaml');
			});
	}
	@Test
	void formContentFilterIsAutoConfigured() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(OrderedFormContentFilter.class));
	}
	@Test
	void formContentFilterCanBeOverridden() {
		this.contextRunner.withUserConfiguration(CustomFormContentFilter.class).run((context) -> {
			assertThat(context).doesNotHaveBean(OrderedFormContentFilter.class);
			assertThat(context).hasSingleBean(FormContentFilter.class);
		});
	}
	@Test
	void formContentFilterCanBeDisabled() {
		this.contextRunner.withPropertyValues('spring.mvc.formcontent.filter.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(FormContentFilter.class));
	}
	@Test
	void hiddenHttpMethodFilterCanBeEnabled() {
		this.contextRunner.withPropertyValues('spring.mvc.hiddenmethod.filter.enabled=true')
			.run((context) -> assertThat(context).hasSingleBean(HiddenHttpMethodFilter.class));
	}
	@Test
	void hiddenHttpMethodFilterDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(HiddenHttpMethodFilter.class));
	}
	@Test
	void customConfigurableWebBindingInitializer() {
		this.contextRunner.withUserConfiguration(CustomConfigurableWebBindingInitializer.class)
			.run((context) -> assertThat(context.getBean(RequestMappingHandlerAdapter.class).getWebBindingInitializer())
				.isInstanceOf(CustomWebBindingInitializer.class));
	}
	@Test
	void customRequestMappingHandlerMapping() {
		this.contextRunner.withUserConfiguration(CustomRequestMappingHandlerMapping.class).run((context) -> {
			assertThat(context).getBean(RequestMappingHandlerMapping.class)
				.isInstanceOf(MyRequestMappingHandlerMapping.class);
			assertThat(context.getBean(CustomRequestMappingHandlerMapping.class).handlerMappings).isOne();
		});
	}
	@Test
	void customRequestMappingHandlerAdapter() {
		this.contextRunner.withUserConfiguration(CustomRequestMappingHandlerAdapter.class).run((context) -> {
			assertThat(context).getBean(RequestMappingHandlerAdapter.class)
				.isInstanceOf(MyRequestMappingHandlerAdapter.class);
			assertThat(context.getBean(CustomRequestMappingHandlerAdapter.class).handlerAdapters).isOne();
		});
	}
	@Test
	void customExceptionHandlerExceptionResolver() {
		this.contextRunner.withUserConfiguration(CustomExceptionHandlerExceptionResolver.class)
			.run((context) -> assertThat(
					context.getBean(CustomExceptionHandlerExceptionResolver.class).exceptionResolvers)
				.isOne());
	}
	@Test
	void multipleWebMvcRegistrations() {
		this.contextRunner.withUserConfiguration(MultipleWebMvcRegistrations.class).run((context) -> {
			assertThat(context.getBean(RequestMappingHandlerMapping.class))
				.isNotInstanceOf(MyRequestMappingHandlerMapping.class);
			assertThat(context.getBean(RequestMappingHandlerAdapter.class))
				.isNotInstanceOf(MyRequestMappingHandlerAdapter.class);
		});
	}
	@Test
	void defaultLogResolvedException() {
		this.contextRunner.run(assertExceptionResolverWarnLoggers((logger) -> assertThat(logger).isNull()));
	}
	@Test
	void customLogResolvedException() {
		this.contextRunner.withPropertyValues('spring.mvc.log-resolved-exception:true')
			.run(assertExceptionResolverWarnLoggers((logger) -> assertThat(logger).isNotNull()));
	}
	private ContextConsumer<AssertableWebApplicationContext> assertExceptionResolverWarnLoggers(
			Consumer<Object> consumer) {
		return (context) -> {
			HandlerExceptionResolver resolver = context.getBean(HandlerExceptionResolver.class);
			assertThat(resolver).isInstanceOf(HandlerExceptionResolverComposite.class);
			List<HandlerExceptionResolver> delegates = ((HandlerExceptionResolverComposite) resolver)
				.getExceptionResolvers();
			for (HandlerExceptionResolver delegate : delegates) {
				if (delegate instanceof AbstractHandlerExceptionResolver
						&& !(delegate instanceof DefaultHandlerExceptionResolver)) {
					consumer.accept(ReflectionTestUtils.getField(delegate, 'warnLogger'));
				}
			}
		};
	}
	@Test
	void welcomePageHandlerMappingIsAutoConfigured() {
		this.contextRunner.withPropertyValues('spring.web.resources.static-locations:classpath:/welcome-page/')
			.run((context) -> {
				assertThat(context).hasSingleBean(WelcomePageHandlerMapping.class);
				assertThat(context.getBean(WelcomePageHandlerMapping.class).getRootHandler()).isNotNull();
				assertThat(context.getBean(WelcomePageNotAcceptableHandlerMapping.class).getRootHandler()).isNotNull();
			});
	}
	@Test
	void welcomePageHandlerIncludesCorsConfiguration() {
		this.contextRunner.withPropertyValues('spring.web.resources.static-locations:classpath:/welcome-page/')
			.withUserConfiguration(CorsConfigurer.class)
			.run((context) -> {
				WelcomePageHandlerMapping bean = context.getBean(WelcomePageHandlerMapping.class);
				UrlBasedCorsConfigurationSource source = (UrlBasedCorsConfigurationSource) bean
					.getCorsConfigurationSource();
				assertThat(source.getCorsConfigurations()).containsKey('/**');
			});
	}
	@Test
	void validatorWhenNoValidatorShouldUseDefault() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(ValidatorFactory.class);
			assertThat(context).doesNotHaveBean(jakarta.validation.Validator.class);
			assertThat(context).getBeanNames(Validator.class).containsOnly('mvcValidator');
		});
	}
	@Test
	void validatorWhenNoCustomizationShouldUseAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).getBeanNames(jakarta.validation.Validator.class).containsOnly('defaultValidator');
				assertThat(context).getBeanNames(Validator.class).containsOnly('defaultValidator', 'mvcValidator');
				Validator validator = context.getBean('mvcValidator', Validator.class);
				assertThat(validator).isInstanceOf(ValidatorAdapter.class);
				Object defaultValidator = context.getBean('defaultValidator');
				assertThat(((ValidatorAdapter) validator).getTarget()).isSameAs(defaultValidator);
				// Primary Spring validator is the one used by MVC behind the scenes
				assertThat(context.getBean(Validator.class)).isEqualTo(defaultValidator);
			});
	}
	@Test
	void validatorWithConfigurerAloneShouldUseSpringValidator() {
		this.contextRunner.withUserConfiguration(MvcValidator.class).run((context) -> {
			assertThat(context).doesNotHaveBean(ValidatorFactory.class);
			assertThat(context).doesNotHaveBean(jakarta.validation.Validator.class);
			assertThat(context).getBeanNames(Validator.class).containsOnly('mvcValidator');
			Validator expectedValidator = context.getBean(MvcValidator.class).validator;
			assertThat(context.getBean('mvcValidator')).isSameAs(expectedValidator);
			assertThat(context.getBean(RequestMappingHandlerAdapter.class).getWebBindingInitializer())
				.hasFieldOrPropertyWithValue('validator', expectedValidator);
		});
	}
	@Test
	void validatorWithConfigurerShouldUseSpringValidator() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.withUserConfiguration(MvcValidator.class)
			.run((context) -> {
				assertThat(context).getBeanNames(jakarta.validation.Validator.class).containsOnly('defaultValidator');
				assertThat(context).getBeanNames(Validator.class).containsOnly('defaultValidator', 'mvcValidator');
				Validator expectedValidator = context.getBean(MvcValidator.class).validator;
				assertThat(context.getBean('mvcValidator')).isSameAs(expectedValidator);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class).getWebBindingInitializer())
					.hasFieldOrPropertyWithValue('validator', expectedValidator);
			});
	}
	@Test
	void validatorWithConfigurerDoesNotExposeJsr303() {
		this.contextRunner.withUserConfiguration(MvcJsr303Validator.class).run((context) -> {
			assertThat(context).doesNotHaveBean(ValidatorFactory.class);
			assertThat(context).doesNotHaveBean(jakarta.validation.Validator.class);
			assertThat(context).getBeanNames(Validator.class).containsOnly('mvcValidator');
			Validator validator = context.getBean('mvcValidator', Validator.class);
			assertThat(validator).isInstanceOf(ValidatorAdapter.class);
			assertThat(((ValidatorAdapter) validator).getTarget())
				.isSameAs(context.getBean(MvcJsr303Validator.class).validator);
		});
	}
	@Test
	void validatorWithConfigurerTakesPrecedence() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.withUserConfiguration(MvcValidator.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ValidatorFactory.class);
				assertThat(context).hasSingleBean(jakarta.validation.Validator.class);
				assertThat(context).getBeanNames(Validator.class).containsOnly('defaultValidator', 'mvcValidator');
				assertThat(context.getBean('mvcValidator')).isSameAs(context.getBean(MvcValidator.class).validator);
				// Primary Spring validator is the auto-configured one as the MVC one
				// has been customized through a WebMvcConfigurer
				assertThat(context.getBean(Validator.class)).isEqualTo(context.getBean('defaultValidator'));
			});
	}
	@Test
	void validatorWithCustomSpringValidatorIgnored() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.withUserConfiguration(CustomSpringValidator.class)
			.run((context) -> {
				assertThat(context).getBeanNames(jakarta.validation.Validator.class).containsOnly('defaultValidator');
				assertThat(context).getBeanNames(Validator.class)
					.containsOnly('customSpringValidator', 'defaultValidator', 'mvcValidator');
				Validator validator = context.getBean('mvcValidator', Validator.class);
				assertThat(validator).isInstanceOf(ValidatorAdapter.class);
				Object defaultValidator = context.getBean('defaultValidator');
				assertThat(((ValidatorAdapter) validator).getTarget()).isSameAs(defaultValidator);
				// Primary Spring validator is the one used by MVC behind the scenes
				assertThat(context.getBean(Validator.class)).isEqualTo(defaultValidator);
			});
	}
	@Test
	void validatorWithCustomJsr303ValidatorExposedAsSpringValidator() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.withUserConfiguration(CustomJsr303Validator.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(ValidatorFactory.class);
				assertThat(context).getBeanNames(jakarta.validation.Validator.class)
					.containsOnly('customJsr303Validator');
				assertThat(context).getBeanNames(Validator.class).containsOnly('mvcValidator');
				Validator validator = context.getBean(Validator.class);
				assertThat(validator).isInstanceOf(ValidatorAdapter.class);
				Validator target = ((ValidatorAdapter) validator).getTarget();
				assertThat(target).extracting('targetValidator').isSameAs(context.getBean('customJsr303Validator'));
			});
	}
	@Test
	void httpMessageConverterThatUsesConversionServiceDoesNotCreateACycle() {
		this.contextRunner.withUserConfiguration(CustomHttpMessageConverter.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void cachePeriod() {
		this.contextRunner.withPropertyValues('spring.web.resources.cache.period:5').run((context) -> {
			assertResourceHttpRequestHandler((context), (handler) -> {
				assertThat(handler.getCacheSeconds()).isEqualTo(5);
				assertThat(handler.getCacheControl()).isNull();
			});
		});
	}
	@Test
	void cacheControl() {
		this.contextRunner
			.withPropertyValues('spring.web.resources.cache.cachecontrol.max-age:5',
					'spring.web.resources.cache.cachecontrol.proxy-revalidate:true')
			.run((context) -> assertResourceHttpRequestHandler(context, (handler) -> {
				assertThat(handler.getCacheSeconds()).isEqualTo(-1);
				assertThat(handler.getCacheControl()).usingRecursiveComparison()
					.isEqualTo(CacheControl.maxAge(5, TimeUnit.SECONDS).proxyRevalidate());
			}));
	}
	@Test
	void usePathPatternParser() {
		this.contextRunner.withPropertyValues('spring.mvc.pathmatch.matching-strategy:path_pattern_parser')
			.run((context) -> {
				RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class);
				assertThat(handlerMapping.usesPathPatterns()).isTrue();
			});
	}
	@Test
	void defaultContentNegotiation() {
		this.contextRunner.run((context) -> {
			RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class);
			ContentNegotiationManager contentNegotiationManager = handlerMapping.getContentNegotiationManager();
			assertThat(contentNegotiationManager.getStrategies()).doesNotHaveAnyElementsOfTypes(
					WebMvcAutoConfiguration.OptionalPathExtensionContentNegotiationStrategy.class);
		});
	}
	@Test
	void queryParameterContentNegotiation() {
		this.contextRunner.withPropertyValues('spring.mvc.contentnegotiation.favor-parameter:true').run((context) -> {
			RequestMappingHandlerMapping handlerMapping = context.getBean(RequestMappingHandlerMapping.class);
			ContentNegotiationManager contentNegotiationManager = handlerMapping.getContentNegotiationManager();
			assertThat(contentNegotiationManager.getStrategies())
				.hasAtLeastOneElementOfType(ParameterContentNegotiationStrategy.class);
		});
	}
	@Test
	void customConfigurerAppliedAfterAutoConfig() {
		this.contextRunner.withUserConfiguration(CustomConfigurer.class).run((context) -> {
			ContentNegotiationManager manager = context.getBean(ContentNegotiationManager.class);
			assertThat(manager.getStrategies())
				.anyMatch((strategy) -> WebMvcAutoConfiguration.OptionalPathExtensionContentNegotiationStrategy.class
					.isAssignableFrom(strategy.getClass()));
		});
	}
	@Test
	void requestContextFilterIsAutoConfigured() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(RequestContextFilter.class));
	}
	@Test
	void whenUserDefinesARequestContextFilterTheAutoConfiguredRegistrationBacksOff() {
		this.contextRunner.withUserConfiguration(RequestContextFilterConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(RequestContextFilter.class);
			assertThat(context).hasBean('customRequestContextFilter');
		});
	}
	@Test
	void whenUserDefinesARequestContextFilterRegistrationTheAutoConfiguredFilterBacksOff() {
		this.contextRunner.withUserConfiguration(RequestContextFilterRegistrationConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(FilterRegistrationBean.class);
			assertThat(context).hasBean('customRequestContextFilterRegistration');
			assertThat(context).doesNotHaveBean(RequestContextFilter.class);
		});
	}
	@Test
	void customPrinterAndParserShouldBeRegisteredAsConverters() {
		this.contextRunner.withUserConfiguration(ParserConfiguration.class, PrinterConfiguration.class)
			.run((context) -> {
				ConversionService service = context.getBean(ConversionService.class);
				assertThat(service.convert(new Example('spring', new Date()), String.class)).isEqualTo('spring');
				assertThat(service.convert('boot', Example.class)).extracting(Example::getName).isEqualTo('boot');
			});
	}
	@Test
	void urlPathHelperUsesFullPathByDefaultWhenAntPathMatchingIsUsed() {
		this.contextRunner.withPropertyValues('spring.mvc.pathmatch.matching-strategy:ant-path-matcher')
			.run((context) -> {
				UrlPathHelper urlPathHelper = context.getBean(UrlPathHelper.class);
				assertThat(urlPathHelper).extracting('alwaysUseFullPath').isEqualTo(true);
			});
	}
	@Test
	void urlPathHelperDoesNotUseFullPathWithServletMapping() {
		this.contextRunner.withPropertyValues('spring.mvc.pathmatch.matching-strategy:ant-path-matcher')
			.withPropertyValues('spring.mvc.servlet.path=/test/')
			.run((context) -> {
				UrlPathHelper urlPathHelper = context.getBean(UrlPathHelper.class);
				assertThat(urlPathHelper).extracting('alwaysUseFullPath').isEqualTo(false);
			});
	}
	@Test
	void urlPathHelperDoesNotUseFullPathWithAdditionalDispatcherServlet() {
		this.contextRunner.withUserConfiguration(AdditionalDispatcherServletConfiguration.class).run((context) -> {
			UrlPathHelper urlPathHelper = context.getBean(UrlPathHelper.class);
			assertThat(urlPathHelper).extracting('alwaysUseFullPath').isEqualTo(false);
		});
	}
	@Test
	void urlPathHelperDoesNotUseFullPathWithAdditionalUntypedDispatcherServlet() {
		this.contextRunner.withUserConfiguration(AdditionalUntypedDispatcherServletConfiguration.class)
			.run((context) -> {
				UrlPathHelper urlPathHelper = context.getBean(UrlPathHelper.class);
				assertThat(urlPathHelper).extracting('alwaysUseFullPath').isEqualTo(false);
			});
	}
	@Test
	void lastModifiedNotUsedIfDisabled() {
		this.contextRunner.withPropertyValues('spring.web.resources.cache.use-last-modified=false')
			.run((context) -> assertResourceHttpRequestHandler(context,
					(handler) -> assertThat(handler.isUseLastModified()).isFalse()));
	}
	@Test // gh-25743
	void addResourceHandlersAppliesToChildAndParentContext() {
		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext()) {
			context.register(WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
					HttpMessageConvertersAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
					ResourceHandlersWithChildAndParentContextConfiguration.class);
			context.refresh();
			SimpleUrlHandlerMapping resourceHandlerMapping = context.getBean('resourceHandlerMapping',
					SimpleUrlHandlerMapping.class);
			DispatcherServlet extraDispatcherServlet = context.getBean('extraDispatcherServlet',
					DispatcherServlet.class);
			SimpleUrlHandlerMapping extraResourceHandlerMapping = extraDispatcherServlet.getWebApplicationContext()
				.getBean('resourceHandlerMapping', SimpleUrlHandlerMapping.class);
			assertThat(resourceHandlerMapping).isNotSameAs(extraResourceHandlerMapping);
			assertThat(resourceHandlerMapping.getUrlMap()).containsKey('/**');
			assertThat(extraResourceHandlerMapping.getUrlMap()).containsKey('/**');
		}
	}
	@Test
	void problemDetailsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ProblemDetailsExceptionHandler.class));
	}
	@Test
	void problemDetailsEnabledAddsExceptionHandler() {
		this.contextRunner.withPropertyValues('spring.mvc.problemdetails.enabled:true')
			.run((context) -> assertThat(context).hasSingleBean(ProblemDetailsExceptionHandler.class));
	}
	@Test
	void problemDetailsExceptionHandlerDoesNotPreventProxying() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(AopAutoConfiguration.class))
			.withBean(ExceptionHandlerInterceptor.class)
			.withPropertyValues('spring.mvc.problemdetails.enabled:true')
			.run((context) -> assertThat(context).getBean(ProblemDetailsExceptionHandler.class)
				.matches(AopUtils::isCglibProxy));
	}
	@Test
	void problemDetailsBacksOffWhenExceptionHandler() {
		this.contextRunner.withPropertyValues('spring.mvc.problemdetails.enabled:true')
			.withUserConfiguration(CustomExceptionHandlerConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ProblemDetailsExceptionHandler.class)
				.hasSingleBean(CustomExceptionHandler.class));
	}
	@Test
	void problemDetailsExceptionHandlerIsOrderedAt0() {
		this.contextRunner.withPropertyValues('spring.mvc.problemdetails.enabled:true')
			.withUserConfiguration(OrderedControllerAdviceBeansConfiguration.class)
			.run((context) -> assertThat(
					ControllerAdviceBean.findAnnotatedBeans(context).stream().map(ControllerAdviceBean::getBeanType))
				.asInstanceOf(InstanceOfAssertFactories.list(Class.class))
				.containsExactly(HighestOrderedControllerAdvice.class, ProblemDetailsExceptionHandler.class,
						OrderedControllerAdviceBeansConfiguration.LowestOrderedControllerAdvice.class));
	}
	private void assertResourceHttpRequestHandler(AssertableWebApplicationContext context,
			Consumer<ResourceHttpRequestHandler> handlerConsumer) {
		Map<String, Object> handlerMap = getHandlerMap(context.getBean('resourceHandlerMapping', HandlerMapping.class));
		assertThat(handlerMap).hasSize(2);
		for (Object handler : handlerMap.values()) {
			if (handler instanceof ResourceHttpRequestHandler resourceHandler) {
				handlerConsumer.accept(resourceHandler);
			}
		}
	}
	protected Map<String, List<Resource>> getResourceMappingLocations(ApplicationContext context) {
		Object bean = context.getBean('resourceHandlerMapping');
		if (bean instanceof HandlerMapping handlerMapping) {
			return getMappingLocations(context, handlerMapping);
		}
		assertThat(bean).hasToString('null');
		return Collections.emptyMap();
	}
	protected List<ResourceResolver> getResourceResolvers(ApplicationContext context, String mapping) {
		ResourceHttpRequestHandler resourceHandler = (ResourceHttpRequestHandler) context
			.getBean('resourceHandlerMapping', SimpleUrlHandlerMapping.class)
			.getHandlerMap()
			.get(mapping);
		return resourceHandler.getResourceResolvers();
	}
	protected List<ResourceTransformer> getResourceTransformers(ApplicationContext context, String mapping) {
		SimpleUrlHandlerMapping handler = context.getBean('resourceHandlerMapping', SimpleUrlHandlerMapping.class);
		ResourceHttpRequestHandler resourceHandler = (ResourceHttpRequestHandler) handler.getHandlerMap().get(mapping);
		return resourceHandler.getResourceTransformers();
	}
	@SuppressWarnings('unchecked')
	private Map<String, List<Resource>> getMappingLocations(ApplicationContext context, HandlerMapping mapping) {
		Map<String, List<Resource>> mappingLocations = new LinkedHashMap<>();
		getHandlerMap(mapping).forEach((key, value) -> {
			List<String> locationValues = (List<String>) ReflectionTestUtils.getField(value, 'locationValues');
			List<Resource> locationResources = (List<Resource>) ReflectionTestUtils.getField(value,
					'locationResources');
			List<Resource> resources = new ArrayList<>();
			for (String locationValue : locationValues) {
				resources.add(context.getResource(locationValue));
			}
			resources.addAll(locationResources);
			mappingLocations.put(key, resources);
		});
		return mappingLocations;
	}
	protected Map<String, Object> getHandlerMap(HandlerMapping mapping) {
		if (mapping instanceof SimpleUrlHandlerMapping handlerMapping) {
			return handlerMapping.getHandlerMap();
		}
		return Collections.emptyMap();
	}
	@Configuration(proxyBeanMethods = false)
	static class ViewConfig {
		@Bean
		View jsonView() {
			return new AbstractView() {
				@Override
				protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,
						HttpServletResponse response) throws Exception {
					response.getOutputStream().write('Hello World'.getBytes());
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebJars implements WebMvcConfigurer {
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler('/webjars/**').addResourceLocations('classpath:/foo/');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AllResources implements WebMvcConfigurer {
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			registry.addResourceHandler('/**').addResourceLocations('classpath:/foo/');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return webServerFactory;
		}
		@Bean
		WebServerFactoryCustomizerBeanPostProcessor ServletWebServerCustomizerBeanPostProcessor() {
			return new WebServerFactoryCustomizerBeanPostProcessor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomViewResolver {
		@Bean
		ViewResolver viewResolver() {
			return new MyViewResolver();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomContentNegotiatingViewResolver {
		@Bean
		ContentNegotiatingViewResolver myViewResolver() {
			return new ContentNegotiatingViewResolver();
		}
	}
	static class MyViewResolver implements ViewResolver {
		@Override
		public View resolveViewName(String viewName, Locale locale) {
			return null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConfigurableWebBindingInitializer {
		@Bean
		ConfigurableWebBindingInitializer customConfigurableWebBindingInitializer() {
			return new CustomWebBindingInitializer();
		}
	}
	static class CustomWebBindingInitializer extends ConfigurableWebBindingInitializer {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomFormContentFilter {
		@Bean
		FormContentFilter customFormContentFilter() {
			return new FormContentFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRequestMappingHandlerMapping {
		private int handlerMappings;
		@Bean
		WebMvcRegistrations webMvcRegistrationsHandlerMapping() {
			return new WebMvcRegistrations() {
				@Override
				public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
					CustomRequestMappingHandlerMapping.this.handlerMappings++;
					return new MyRequestMappingHandlerMapping();
				}
			};
		}
	}
	static class MyRequestMappingHandlerMapping extends RequestMappingHandlerMapping {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRequestMappingHandlerAdapter {
		private int handlerAdapters = 0;
		@Bean
		WebMvcRegistrations webMvcRegistrationsHandlerAdapter() {
			return new WebMvcRegistrations() {
				@Override
				public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
					CustomRequestMappingHandlerAdapter.this.handlerAdapters++;
					return new MyRequestMappingHandlerAdapter();
				}
			};
		}
	}
	static class MyRequestMappingHandlerAdapter extends RequestMappingHandlerAdapter {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomExceptionHandlerExceptionResolver {
		private int exceptionResolvers = 0;
		@Bean
		WebMvcRegistrations webMvcRegistrationsExceptionResolver() {
			return new WebMvcRegistrations() {
				@Override
				public ExceptionHandlerExceptionResolver getExceptionHandlerExceptionResolver() {
					CustomExceptionHandlerExceptionResolver.this.exceptionResolvers++;
					return new MyExceptionHandlerExceptionResolver();
				}
			};
		}
	}
	static class MyExceptionHandlerExceptionResolver extends ExceptionHandlerExceptionResolver {
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ CustomRequestMappingHandlerMapping.class, CustomRequestMappingHandlerAdapter.class })
	static class MultipleWebMvcRegistrations {
	}
	@Configuration(proxyBeanMethods = false)
	static class MvcValidator implements WebMvcConfigurer {
		private final Validator validator = mock(Validator.class);
		@Override
		public Validator getValidator() {
			return this.validator;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MvcJsr303Validator implements WebMvcConfigurer {
		private final LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();
		@Override
		public Validator getValidator() {
			return this.validator;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJsr303Validator {
		@Bean
		jakarta.validation.Validator customJsr303Validator() {
			return mock(jakarta.validation.Validator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSpringValidator {
		@Bean
		Validator customSpringValidator() {
			return mock(Validator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHttpMessageConverter {
		@Bean
		HttpMessageConverter<?> customHttpMessageConverter(ConversionService conversionService) {
			return mock(HttpMessageConverter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConfigurer implements WebMvcConfigurer {
		@Override
		@SuppressWarnings('deprecation')
		public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
			configurer.favorPathExtension(true);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomApplicationTaskExecutorConfig {
		@Bean
		Executor applicationTaskExecutor() {
			return mock(Executor.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAsyncTaskExecutorConfig {
		@Bean
		AsyncTaskExecutor customTaskExecutor() {
			return mock(AsyncTaskExecutor.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAsyncTaskExecutorConfigurer implements WebMvcConfigurer {
		private final AsyncTaskExecutor taskExecutor = mock(AsyncTaskExecutor.class);
		@Override
		public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
			configurer.setTaskExecutor(this.taskExecutor);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RequestContextFilterConfiguration {
		@Bean
		RequestContextFilter customRequestContextFilter() {
			return new RequestContextFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RequestContextFilterRegistrationConfiguration {
		@Bean
		FilterRegistrationBean<RequestContextFilter> customRequestContextFilterRegistration() {
			return new FilterRegistrationBean<>(new RequestContextFilter());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PrinterConfiguration {
		@Bean
		Printer<Example> examplePrinter() {
			return new ExamplePrinter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParserConfiguration {
		@Bean
		Parser<Example> exampleParser() {
			return new ExampleParser();
		}
	}
	static final class Example {
		private final String name;
		private Example(String name, Date date) {
			this.name = name;
		}
		String getName() {
			return this.name;
		}
	}
	static class ExamplePrinter implements Printer<Example> {
		@Override
		public String print(Example example, Locale locale) {
			return example.getName();
		}
	}
	static class ExampleParser implements Parser<Example> {
		@Override
		public Example parse(String source, Locale locale) {
			return new Example(source, new Date());
		}
	}
	@Configuration
	static class CorsConfigurer implements WebMvcConfigurer {
		@Override
		public void addCorsMappings(CorsRegistry registry) {
			registry.addMapping('/**').allowedMethods('GET');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AdditionalDispatcherServletConfiguration {
		@Bean
		ServletRegistrationBean<DispatcherServlet> additionalDispatcherServlet() {
			return new ServletRegistrationBean<>(new DispatcherServlet());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AdditionalUntypedDispatcherServletConfiguration {
		@Bean
		ServletRegistrationBean<?> additionalDispatcherServlet() {
			return new ServletRegistrationBean<>(new DispatcherServlet());
		}
	}
	static class CustomLocaleResolver implements LocaleResolver {
		@Override
		public Locale resolveLocale(HttpServletRequest request) {
			return Locale.ENGLISH;
		}
		@Override
		public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {
		}
	}
	static class CustomFlashMapManager extends AbstractFlashMapManager {
		@Override
		protected List<FlashMap> retrieveFlashMaps(HttpServletRequest request) {
			return null;
		}
		@Override
		protected void updateFlashMaps(List<FlashMap> flashMaps, HttpServletRequest request,
				HttpServletResponse response) {
		}
	}
	static class CustomViewNameTranslator implements RequestToViewNameTranslator {
		@Override
		public String getViewName(HttpServletRequest requestAttributes) {
			return null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ResourceHandlersWithChildAndParentContextConfiguration {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		ServletRegistrationBean<?> additionalDispatcherServlet(DispatcherServlet extraDispatcherServlet) {
			ServletRegistrationBean<?> registration = new ServletRegistrationBean<>(extraDispatcherServlet, '/extra/*');
			registration.setName('additionalDispatcherServlet');
			registration.setLoadOnStartup(1);
			return registration;
		}
		@Bean
		private DispatcherServlet extraDispatcherServlet() {
			DispatcherServlet dispatcherServlet = new DispatcherServlet();
			AnnotationConfigWebApplicationContext applicationContext = new AnnotationConfigWebApplicationContext();
			applicationContext.register(ResourceHandlersWithChildAndParentContextChildConfiguration.class);
			dispatcherServlet.setApplicationContext(applicationContext);
			return dispatcherServlet;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebMvc
	static class ResourceHandlersWithChildAndParentContextChildConfiguration {
		@Bean
		WebMvcConfigurer myConfigurer() {
			return new WebMvcConfigurer() {
				@Override
				public void addResourceHandlers(ResourceHandlerRegistry registry) {
					registry.addResourceHandler('/testtesttest');
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomExceptionHandlerConfiguration {
		@Bean
		CustomExceptionHandler customExceptionHandler() {
			return new CustomExceptionHandler();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ LowestOrderedControllerAdvice.class, HighestOrderedControllerAdvice.class })
	static class OrderedControllerAdviceBeansConfiguration {
		@ControllerAdvice
		@Order
		static class LowestOrderedControllerAdvice {
		}
		@ControllerAdvice
		@Order(Ordered.HIGHEST_PRECEDENCE)
		static class HighestOrderedControllerAdvice {
		}
	}
	@ControllerAdvice
	static class CustomExceptionHandler extends ResponseEntityExceptionHandler {
	}
	@Aspect
	static class ExceptionHandlerInterceptor {
		@AfterReturning(pointcut = '@annotation(org.springframework.web.bind.annotation.ExceptionHandler)',
				returning = 'returnValue')
		void exceptionHandlerIntercept(JoinPoint joinPoint, Object returnValue) {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class JspTemplateAvailabilityProviderTests {
	private final JspTemplateAvailabilityProvider provider = new JspTemplateAvailabilityProvider();
	private final ResourceLoader resourceLoader = new DefaultResourceLoader();
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void availabilityOfTemplateThatDoesNotExist() {
		assertThat(isTemplateAvailable('whatever')).isFalse();
	}
	@Test
	void availabilityOfTemplateWithCustomPrefix() {
		this.environment.setProperty('spring.mvc.view.prefix', 'classpath:/custom-templates/');
		assertThat(isTemplateAvailable('custom.jsp')).isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomSuffix() {
		this.environment.setProperty('spring.mvc.view.prefix', 'classpath:/custom-templates/');
		this.environment.setProperty('spring.mvc.view.suffix', '.jsp');
		assertThat(isTemplateAvailable('suffixed')).isTrue();
	}
	private boolean isTemplateAvailable(String view) {
		return this.provider.isTemplateAvailable(view, this.environment, getClass().getClassLoader(),
				this.resourceLoader);
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
class BasicErrorControllerIntegrationTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void testErrorForMachineClientDefault() {
		load();
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('?trace=true'), Map.class);
		assertErrorAttributes(entity.getBody(), '500', 'Internal Server Error', null, null, '/');
		assertThat(entity.getBody()).doesNotContainKey('exception');
		assertThat(entity.getBody()).doesNotContainKey('trace');
	}
	@Test
	void testErrorForMachineClientWithParamsTrue() {
		load('--server.error.include-exception=true', '--server.error.include-stacktrace=on-param',
				'--server.error.include-message=on-param');
		exceptionWithStackTraceAndMessage('?trace=true&message=true');
	}
	@Test
	void testErrorForMachineClientWithParamsFalse() {
		load('--server.error.include-exception=true', '--server.error.include-stacktrace=on-param',
				'--server.error.include-message=on-param');
		exceptionWithoutStackTraceAndMessage('?trace=false&message=false');
	}
	@Test
	void testErrorForMachineClientWithParamsAbsent() {
		load('--server.error.include-exception=true', '--server.error.include-stacktrace=on-param',
				'--server.error.include-message=on-param');
		exceptionWithoutStackTraceAndMessage('');
	}
	@Test
	void testErrorForMachineClientNeverParams() {
		load('--server.error.include-exception=true', '--server.error.include-stacktrace=never',
				'--server.error.include-message=never');
		exceptionWithoutStackTraceAndMessage('?trace=true&message=true');
	}
	@Test
	void testErrorForMachineClientAlwaysParams() {
		load('--server.error.include-exception=true', '--server.error.include-stacktrace=always',
				'--server.error.include-message=always');
		exceptionWithStackTraceAndMessage('?trace=false&message=false');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void testErrorForMachineClientAlwaysParamsWithoutMessage() {
		load('--server.error.include-exception=true', '--server.error.include-message=always');
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/noMessage'), Map.class);
		assertErrorAttributes(entity.getBody(), '500', 'Internal Server Error', IllegalStateException.class,
				'No message available', '/noMessage');
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private void exceptionWithStackTraceAndMessage(String path) {
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl(path), Map.class);
		assertErrorAttributes(entity.getBody(), '500', 'Internal Server Error', IllegalStateException.class,
				'Expected!', '/');
		assertThat(entity.getBody()).containsKey('trace');
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private void exceptionWithoutStackTraceAndMessage(String path) {
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl(path), Map.class);
		assertErrorAttributes(entity.getBody(), '500', 'Internal Server Error', IllegalStateException.class, null, '/');
		assertThat(entity.getBody()).doesNotContainKey('trace');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void testErrorForAnnotatedExceptionWithoutMessage() {
		load('--server.error.include-exception=true');
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/annotated'), Map.class);
		assertErrorAttributes(entity.getBody(), '400', 'Bad Request', TestConfiguration.Errors.ExpectedException.class,
				null, '/annotated');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void testErrorForAnnotatedExceptionWithMessage() {
		load('--server.error.include-exception=true', '--server.error.include-message=always');
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/annotated'), Map.class);
		assertErrorAttributes(entity.getBody(), '400', 'Bad Request', TestConfiguration.Errors.ExpectedException.class,
				'Expected!', '/annotated');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void testErrorForAnnotatedNoReasonExceptionWithoutMessage() {
		load('--server.error.include-exception=true');
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/annotatedNoReason'), Map.class);
		assertErrorAttributes(entity.getBody(), '406', 'Not Acceptable',
				TestConfiguration.Errors.NoReasonExpectedException.class, null, '/annotatedNoReason');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void testErrorForAnnotatedNoReasonExceptionWithMessage() {
		load('--server.error.include-exception=true', '--server.error.include-message=always');
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/annotatedNoReason'), Map.class);
		assertErrorAttributes(entity.getBody(), '406', 'Not Acceptable',
				TestConfiguration.Errors.NoReasonExpectedException.class, 'Expected message', '/annotatedNoReason');
	}
	@Test
	@SuppressWarnings('rawtypes')
	void testErrorForAnnotatedNoMessageExceptionWithMessage() {
		load('--server.error.include-exception=true', '--server.error.include-message=always');
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/annotatedNoMessage'), Map.class);
		assertErrorAttributes(entity.getBody(), '406', 'Not Acceptable',
				TestConfiguration.Errors.NoReasonExpectedException.class, 'No message available',
				'/annotatedNoMessage');
	}
	@Test
	void testBindingExceptionForMachineClientWithErrorsParamTrue() {
		load('--server.error.include-exception=true', '--server.error.include-binding-errors=on-param');
		bindingExceptionWithErrors('?errors=true');
	}
	@Test
	void testBindingExceptionForMachineClientWithErrorsParamFalse() {
		load('--server.error.include-exception=true', '--server.error.include-binding-errors=on-param');
		bindingExceptionWithoutErrors('?errors=false');
	}
	@Test
	void testBindingExceptionForMachineClientWithErrorsParamAbsent() {
		load('--server.error.include-exception=true', '--server.error.include-binding-errors=on-param');
		bindingExceptionWithoutErrors('');
	}
	@Test
	void testBindingExceptionForMachineClientAlwaysErrors() {
		load('--server.error.include-exception=true', '--server.error.include-binding-errors=always');
		bindingExceptionWithErrors('?errors=false');
	}
	@Test
	void testBindingExceptionForMachineClientNeverErrors() {
		load('--server.error.include-exception=true', '--server.error.include-binding-errors=never');
		bindingExceptionWithoutErrors('?errors=true');
	}
	@Test
	void testBindingExceptionForMachineClientWithMessageParamTrue() {
		load('--server.error.include-exception=true', '--server.error.include-message=on-param');
		bindingExceptionWithMessage('?message=true');
	}
	@Test
	void testBindingExceptionForMachineClientWithMessageParamFalse() {
		load('--server.error.include-exception=true', '--server.error.include-message=on-param');
		bindingExceptionWithoutMessage('?message=false');
	}
	@Test
	void testBindingExceptionForMachineClientWithMessageParamAbsent() {
		load('--server.error.include-exception=true', '--server.error.include-message=on-param');
		bindingExceptionWithoutMessage('');
	}
	@Test
	void testBindingExceptionForMachineClientAlwaysMessage() {
		load('--server.error.include-exception=true', '--server.error.include-message=always');
		bindingExceptionWithMessage('?message=false');
	}
	@Test
	void testBindingExceptionForMachineClientNeverMessage() {
		load('--server.error.include-exception=true', '--server.error.include-message=never');
		bindingExceptionWithoutMessage('?message=true');
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private void bindingExceptionWithErrors(String param) {
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/bind' + param), Map.class);
		assertErrorAttributes(entity.getBody(), '400', 'Bad Request', MethodArgumentNotValidException.class, null,
				'/bind');
		assertThat(entity.getBody()).containsKey('errors');
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private void bindingExceptionWithoutErrors(String param) {
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/bind' + param), Map.class);
		assertErrorAttributes(entity.getBody(), '400', 'Bad Request', MethodArgumentNotValidException.class, null,
				'/bind');
		assertThat(entity.getBody()).doesNotContainKey('errors');
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private void bindingExceptionWithMessage(String param) {
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/bind' + param), Map.class);
		assertErrorAttributes(entity.getBody(), '400', 'Bad Request', MethodArgumentNotValidException.class,
				'Validation failed for object="test". Error count: 1', '/bind');
		assertThat(entity.getBody()).doesNotContainKey('errors');
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	private void bindingExceptionWithoutMessage(String param) {
		ResponseEntity<Map> entity = new TestRestTemplate().getForEntity(createUrl('/bind' + param), Map.class);
		assertErrorAttributes(entity.getBody(), '400', 'Bad Request', MethodArgumentNotValidException.class, null,
				'/bind');
		assertThat(entity.getBody()).doesNotContainKey('errors');
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void testRequestBodyValidationForMachineClient() {
		load('--server.error.include-exception=true');
		RequestEntity request = RequestEntity.post(URI.create(createUrl('/bodyValidation')))
			.accept(MediaType.APPLICATION_JSON)
			.contentType(MediaType.APPLICATION_JSON)
			.body('{}');
		ResponseEntity<Map> entity = new TestRestTemplate().exchange(request, Map.class);
		assertErrorAttributes(entity.getBody(), '400', 'Bad Request', MethodArgumentNotValidException.class, null,
				'/bodyValidation');
		assertThat(entity.getBody()).doesNotContainKey('errors');
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void testBindingExceptionForMachineClientDefault() {
		load();
		RequestEntity request = RequestEntity.get(URI.create(createUrl('/bind?trace=true,message=true')))
			.accept(MediaType.APPLICATION_JSON)
			.build();
		ResponseEntity<Map> entity = new TestRestTemplate().exchange(request, Map.class);
		assertThat(entity.getBody()).doesNotContainKey('exception');
		assertThat(entity.getBody()).doesNotContainKey('trace');
		assertThat(entity.getBody()).doesNotContainKey('errors');
	}
	@Test
	void testConventionTemplateMapping() {
		load();
		RequestEntity<?> request = RequestEntity.get(URI.create(createUrl('/noStorage')))
			.accept(MediaType.TEXT_HTML)
			.build();
		ResponseEntity<String> entity = new TestRestTemplate().exchange(request, String.class);
		String resp = entity.getBody();
		assertThat(resp).contains('We are out of storage');
	}
	@Test
	void testIncompatibleMediaType() {
		load();
		RequestEntity<?> request = RequestEntity.get(URI.create(createUrl('/incompatibleType')))
			.accept(MediaType.TEXT_PLAIN)
			.build();
		ResponseEntity<String> entity = new TestRestTemplate().exchange(request, String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
		assertThat(entity.getHeaders().getContentType()).isNull();
		assertThat(entity.getBody()).isNull();
	}
	@Test
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	void customErrorControllerWithoutStatusConfiguration() {
		load(CustomErrorControllerWithoutStatusConfiguration.class);
		RequestEntity request = RequestEntity.post(URI.create(createUrl('/bodyValidation')))
			.accept(MediaType.APPLICATION_JSON)
			.contentType(MediaType.APPLICATION_JSON)
			.body('{}');
		ResponseEntity<Map> entity = new TestRestTemplate().exchange(request, Map.class);
		assertThat(entity.getBody()).doesNotContainKey('status');
	}
	private void assertErrorAttributes(Map<?, ?> content, String status, String error, Class<?> exception,
			String message, String path) {
		assertThat(content.get('status')).as('Wrong status').hasToString(status);
		assertThat(content.get('error')).as('Wrong error').isEqualTo(error);
		if (exception != null) {
			assertThat(content.get('exception')).as('Wrong exception').isEqualTo(exception.getName());
		}
		else {
			assertThat(content.containsKey('exception')).as('Exception attribute should not be set').isFalse();
		}
		assertThat(content.get('message')).as('Wrong message').isEqualTo(message);
		assertThat(content.get('path')).as('Wrong path').isEqualTo(path);
	}
	private String createUrl(String path) {
		int port = this.context.getEnvironment().getProperty('local.server.port', int.class);
		return 'http://localhost:' + port + path;
	}
	private void load(String... arguments) {
		load(TestConfiguration.class, arguments);
	}
	private void load(Class<?> configuration, String... arguments) {
		List<String> args = new ArrayList<>();
		args.add('--server.port=0');
		if (arguments != null) {
			args.addAll(Arrays.asList(arguments));
		}
		this.context = SpringApplication.run(configuration, StringUtils.toStringArray(args));
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@ImportAutoConfiguration({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			ErrorMvcAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	private @interface MinimalWebConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	@ImportAutoConfiguration(FreeMarkerAutoConfiguration.class)
	public static class TestConfiguration {
		// For manual testing
		static void main(String[] args) {
			SpringApplication.run(TestConfiguration.class, args);
		}
		@Bean
		View error() {
			return new AbstractView() {
				@Override
				protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,
						HttpServletResponse response) throws Exception {
					response.getWriter().write('ERROR_BEAN');
				}
			};
		}
		@RestController
		public static class Errors {
			public String getFoo() {
				return 'foo';
			}
			@RequestMapping('/')
			String home() {
				throw new IllegalStateException('Expected!');
			}
			@RequestMapping('/noMessage')
			String noMessage() {
				throw new IllegalStateException();
			}
			@RequestMapping('/annotated')
			String annotated() {
				throw new ExpectedException();
			}
			@RequestMapping('/annotatedNoReason')
			String annotatedNoReason() {
				throw new NoReasonExpectedException('Expected message');
			}
			@RequestMapping('/annotatedNoMessage')
			String annotatedNoMessage() {
				throw new NoReasonExpectedException('');
			}
			@RequestMapping('/bind')
			String bind(@RequestAttribute(required = false) String foo) throws Exception {
				BindException error = new BindException(this, 'test');
				error.rejectValue('foo', 'bar.error');
				Parameter fooParameter = ReflectionUtils.findMethod(Errors.class, 'bind', String.class)
					.getParameters()[0];
				throw new MethodArgumentNotValidException(MethodParameter.forParameter(fooParameter), error);
			}
			@PostMapping(path = '/bodyValidation', produces = 'application/json')
			String bodyValidation(@Valid @RequestBody DummyBody body) {
				return body.content;
			}
			@RequestMapping(path = '/noStorage')
			String noStorage() {
				throw new InsufficientStorageException();
			}
			@RequestMapping(path = '/incompatibleType', produces = 'text/plain')
			String incompatibleType() {
				throw new ExpectedException();
			}
			@ResponseStatus(value = HttpStatus.BAD_REQUEST, reason = 'Expected!')
			@SuppressWarnings('serial')
			static class ExpectedException extends RuntimeException {
			}
			@ResponseStatus(HttpStatus.INSUFFICIENT_STORAGE)
			static class InsufficientStorageException extends RuntimeException {
			}
			@ResponseStatus(HttpStatus.NOT_ACCEPTABLE)
			@SuppressWarnings('serial')
			static class NoReasonExpectedException extends RuntimeException {
				NoReasonExpectedException(String message) {
					super(message);
				}
			}
			static class DummyBody {
				@NotNull
				private String content;
				String getContent() {
					return this.content;
				}
				void setContent(String content) {
					this.content = content;
				}
			}
		}
	}
	static class CustomErrorControllerWithoutStatusConfiguration extends TestConfiguration {
		@Bean
		BasicErrorController basicErrorController(ServerProperties serverProperties, ErrorAttributes errorAttributes,
				ObjectProvider<ErrorViewResolver> errorViewResolvers) {
			return new BasicErrorController(errorAttributes, serverProperties.getError(),
					errorViewResolvers.orderedStream().toList()) {
				@Override
				protected ErrorAttributeOptions getErrorAttributeOptions(HttpServletRequest request,
						MediaType mediaType) {
					return super.getErrorAttributeOptions(request, mediaType).excluding(Include.STATUS);
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
class BasicErrorControllerDirectMockMvcTests {
	private ConfigurableWebApplicationContext wac;
	private MockMvcTester mvc;
	@AfterEach
	void close() {
		ApplicationContextTestUtils.closeAll(this.wac);
	}
	void setup(ConfigurableWebApplicationContext context) {
		this.wac = context;
		this.mvc = MockMvcTester.from(this.wac);
	}
	@Test
	void errorPageAvailableWithParentContext() {
		setup((ConfigurableWebApplicationContext) new SpringApplicationBuilder(ParentConfiguration.class)
			.child(ChildConfiguration.class)
			.run('--server.port=0'));
		assertThat(this.mvc.get().uri('/error').accept(MediaType.TEXT_HTML)).hasStatus5xxServerError()
			.bodyText()
			.contains('status=999');
	}
	@Test
	void errorPageAvailableWithMvcIncluded() {
		setup((ConfigurableWebApplicationContext) new SpringApplication(WebMvcIncludedConfiguration.class)
			.run('--server.port=0'));
		assertThat(this.mvc.get().uri('/error').accept(MediaType.TEXT_HTML)).hasStatus5xxServerError()
			.bodyText()
			.contains('status=999');
	}
	@Test
	void errorPageNotAvailableWithWhitelabelDisabled() {
		setup((ConfigurableWebApplicationContext) new SpringApplication(WebMvcIncludedConfiguration.class)
			.run('--server.port=0', '--server.error.whitelabel.enabled=false'));
		assertThat(this.mvc.get().uri('/error').accept(MediaType.TEXT_HTML)).hasFailed()
			.failure()
			.isInstanceOf(ServletException.class);
	}
	@Test
	void errorControllerWithAop() {
		setup((ConfigurableWebApplicationContext) new SpringApplication(WithAopConfiguration.class)
			.run('--server.port=0'));
		assertThat(this.mvc.get().uri('/error').accept(MediaType.TEXT_HTML)).hasStatus5xxServerError()
			.bodyText()
			.contains('status=999');
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Import({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			ErrorMvcAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	static class ParentConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	@EnableWebMvc
	static class WebMvcIncludedConfiguration {
		// For manual testing
		static void main(String[] args) {
			SpringApplication.run(WebMvcIncludedConfiguration.class, args);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	static class VanillaConfiguration {
		// For manual testing
		static void main(String[] args) {
			SpringApplication.run(VanillaConfiguration.class, args);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	static class ChildConfiguration {
		// For manual testing
		static void main(String[] args) {
			new SpringApplicationBuilder(ParentConfiguration.class).child(ChildConfiguration.class).run(args);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableAspectJAutoProxy(proxyTargetClass = false)
	@MinimalWebConfiguration
	@Aspect
	static class WithAopConfiguration {
		@Pointcut('within(@org.springframework.stereotype.Controller *)')
		private void controllerPointCut() {
		}
		@Around('controllerPointCut()')
		Object mvcAdvice(ProceedingJoinPoint pjp) throws Throwable {
			return pjp.proceed();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.mvc.servlet.path:/spring/')
@DirtiesContext
class RemappedErrorViewIntegrationTests {
	@LocalServerPort
	private int port;
	private final TestRestTemplate template = new TestRestTemplate();
	@Test
	void directAccessToErrorPage() {
		String content = this.template.getForObject('http://localhost:' + this.port + '/spring/error', String.class);
		assertThat(content).contains('error');
		assertThat(content).contains('999');
	}
	@Test
	void forwardToErrorPage() {
		String content = this.template.getForObject('http://localhost:' + this.port + '/spring/', String.class);
		assertThat(content).contains('error');
		assertThat(content).contains('500');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ PropertyPlaceholderAutoConfiguration.class, WebMvcAutoConfiguration.class,
			HttpMessageConvertersAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class })
	@Controller
	static class TestConfiguration implements ErrorPageRegistrar {
		@RequestMapping('/')
		String home() {
			throw new RuntimeException('Planned!');
		}
		@Override
		public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {
			errorPageRegistry.addErrorPages(new ErrorPage('/spring/error'));
		}
		// For manual testing
		static void main(String[] args) {
			new SpringApplicationBuilder(TestConfiguration.class).properties('spring.mvc.servlet.path:spring/*')
				.run(args);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
@ExtendWith(MockitoExtension.class)
class DefaultErrorViewResolverTests {
	private DefaultErrorViewResolver resolver;
	@Mock
	private TemplateAvailabilityProvider templateAvailabilityProvider;
	private Resources resourcesProperties;
	private final Map<String, Object> model = new HashMap<>();
	private final HttpServletRequest request = new MockHttpServletRequest();
	@BeforeEach
	void setup() {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		applicationContext.refresh();
		this.resourcesProperties = new Resources();
		TemplateAvailabilityProviders templateAvailabilityProviders = new TestTemplateAvailabilityProviders(
				this.templateAvailabilityProvider);
		this.resolver = new DefaultErrorViewResolver(applicationContext, this.resourcesProperties,
				templateAvailabilityProviders);
	}
	@Test
	void createWhenApplicationContextIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new DefaultErrorViewResolver(null, new Resources()))
			.withMessageContaining('ApplicationContext must not be null');
	}
	@Test
	void createWhenResourcePropertiesIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DefaultErrorViewResolver(mock(ApplicationContext.class), (Resources) null))
			.withMessageContaining('Resources must not be null');
	}
	@Test
	void resolveWhenNoMatchShouldReturnNull() {
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.NOT_FOUND, this.model);
		assertThat(resolved).isNull();
	}
	@Test
	void resolveWhenExactTemplateMatchShouldReturnTemplate() {
		given(this.templateAvailabilityProvider.isTemplateAvailable(eq('error/404'), any(Environment.class),
				any(ClassLoader.class), any(ResourceLoader.class)))
			.willReturn(true);
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.NOT_FOUND, this.model);
		assertThat(resolved).isNotNull();
		assertThat(resolved.getViewName()).isEqualTo('error/404');
		then(this.templateAvailabilityProvider).should()
			.isTemplateAvailable(eq('error/404'), any(Environment.class), any(ClassLoader.class),
					any(ResourceLoader.class));
		then(this.templateAvailabilityProvider).shouldHaveNoMoreInteractions();
	}
	@Test
	void resolveWhenSeries5xxTemplateMatchShouldReturnTemplate() {
		given(this.templateAvailabilityProvider.isTemplateAvailable(eq('error/503'), any(Environment.class),
				any(ClassLoader.class), any(ResourceLoader.class)))
			.willReturn(false);
		given(this.templateAvailabilityProvider.isTemplateAvailable(eq('error/5xx'), any(Environment.class),
				any(ClassLoader.class), any(ResourceLoader.class)))
			.willReturn(true);
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.SERVICE_UNAVAILABLE,
				this.model);
		assertThat(resolved.getViewName()).isEqualTo('error/5xx');
	}
	@Test
	void resolveWhenSeries4xxTemplateMatchShouldReturnTemplate() {
		given(this.templateAvailabilityProvider.isTemplateAvailable(eq('error/404'), any(Environment.class),
				any(ClassLoader.class), any(ResourceLoader.class)))
			.willReturn(false);
		given(this.templateAvailabilityProvider.isTemplateAvailable(eq('error/4xx'), any(Environment.class),
				any(ClassLoader.class), any(ResourceLoader.class)))
			.willReturn(true);
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.NOT_FOUND, this.model);
		assertThat(resolved.getViewName()).isEqualTo('error/4xx');
	}
	@Test
	void resolveWhenExactResourceMatchShouldReturnResource() throws Exception {
		setResourceLocation('/exact');
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.NOT_FOUND, this.model);
		MockHttpServletResponse response = render(resolved);
		assertThat(response.getContentAsString().trim()).isEqualTo('exact/404');
		assertThat(response.getContentType()).isEqualTo(MediaType.TEXT_HTML_VALUE);
	}
	@Test
	void resolveWhenSeries4xxResourceMatchShouldReturnResource() throws Exception {
		setResourceLocation('/4xx');
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.NOT_FOUND, this.model);
		MockHttpServletResponse response = render(resolved);
		assertThat(response.getContentAsString().trim()).isEqualTo('4xx/4xx');
		assertThat(response.getContentType()).isEqualTo(MediaType.TEXT_HTML_VALUE);
	}
	@Test
	void resolveWhenSeries5xxResourceMatchShouldReturnResource() throws Exception {
		setResourceLocation('/5xx');
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.INTERNAL_SERVER_ERROR,
				this.model);
		MockHttpServletResponse response = render(resolved);
		assertThat(response.getContentAsString().trim()).isEqualTo('5xx/5xx');
		assertThat(response.getContentType()).isEqualTo(MediaType.TEXT_HTML_VALUE);
	}
	@Test
	void resolveWhenTemplateAndResourceMatchShouldFavorTemplate() {
		setResourceLocation('/exact');
		given(this.templateAvailabilityProvider.isTemplateAvailable(eq('error/404'), any(Environment.class),
				any(ClassLoader.class), any(ResourceLoader.class)))
			.willReturn(true);
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.NOT_FOUND, this.model);
		assertThat(resolved.getViewName()).isEqualTo('error/404');
	}
	@Test
	void resolveWhenExactResourceMatchAndSeriesTemplateMatchShouldFavorResource() throws Exception {
		setResourceLocation('/exact');
		given(this.templateAvailabilityProvider.isTemplateAvailable(eq('error/404'), any(Environment.class),
				any(ClassLoader.class), any(ResourceLoader.class)))
			.willReturn(false);
		ModelAndView resolved = this.resolver.resolveErrorView(this.request, HttpStatus.NOT_FOUND, this.model);
		then(this.templateAvailabilityProvider).shouldHaveNoMoreInteractions();
		MockHttpServletResponse response = render(resolved);
		assertThat(response.getContentAsString().trim()).isEqualTo('exact/404');
		assertThat(response.getContentType()).isEqualTo(MediaType.TEXT_HTML_VALUE);
	}
	@Test
	void orderShouldBeLowest() {
		assertThat(this.resolver.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE);
	}
	@Test
	void setOrderShouldChangeOrder() {
		this.resolver.setOrder(123);
		assertThat(this.resolver.getOrder()).isEqualTo(123);
	}
	private void setResourceLocation(String path) {
		String packageName = getClass().getPackage().getName();
		this.resourcesProperties
			.setStaticLocations(new String[] { 'classpath:' + packageName.replace(".", "/") + path + '/' });
	}
	private MockHttpServletResponse render(ModelAndView modelAndView) throws Exception {
		MockHttpServletResponse response = new MockHttpServletResponse();
		modelAndView.getView().render(this.model, this.request, response);
		return response;
	}
	static class TestTemplateAvailabilityProviders extends TemplateAvailabilityProviders {
		TestTemplateAvailabilityProviders(TemplateAvailabilityProvider provider) {
			super(Collections.singletonList(provider));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
@SpringBootTest(properties = { 'server.error.include-message=always' })
@DirtiesContext
class DefaultErrorViewIntegrationTests {
	@Autowired
	private WebApplicationContext wac;
	private MockMvcTester mvc;
	@BeforeEach
	void setup() {
		this.mvc = MockMvcTester.from(this.wac);
	}
	@Test
	void testErrorForBrowserClient() {
		assertThat(this.mvc.get().uri('/error').accept(MediaType.TEXT_HTML)).hasStatus5xxServerError()
			.bodyText()
			.contains('<html>', '999');
	}
	@Test
	void testErrorWithHtmlEscape() {
		assertThat(this.mvc.get()
			.uri('/error')
			.requestAttr('jakarta.servlet.error.exception',
					new RuntimeException('<script>alert("Hello World")</script>'))
			.accept(MediaType.TEXT_HTML)).hasStatus5xxServerError()
			.bodyText()
			.contains('&lt;script&gt;', 'Hello World', '999');
	}
	@Test
	void testErrorWithSpelEscape() {
		String spel = '${T(' + getClass().getName() + ').injectCall()}';
		assertThat(this.mvc.get()
			.uri('/error')
			.requestAttr('jakarta.servlet.error.exception', new RuntimeException(spel))
			.accept(MediaType.TEXT_HTML)).hasStatus5xxServerError().bodyText().doesNotContain('injection');
	}
	static String injectCall() {
		return 'injection';
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Import({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			ErrorMvcAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	static class TestConfiguration {
		// For manual testing
		static void main(String[] args) {
			SpringApplication.run(TestConfiguration.class, args);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
@SpringBootTest(properties = { 'server.error.include-message=always' })
@DirtiesContext
class BasicErrorControllerMockMvcTests {
	@Autowired
	private WebApplicationContext wac;
	private MockMvcTester mvc;
	@BeforeEach
	void setup() {
		this.mvc = MockMvcTester.from(this.wac);
	}
	@Test
	void testDirectAccessForMachineClient() {
		assertThat(this.mvc.get().uri('/error')).hasStatus5xxServerError().bodyText().contains('999');
	}
	@Test
	void testErrorWithNotFoundResponseStatus() {
		assertThat(this.mvc.get().uri('/bang')).hasStatus(HttpStatus.NOT_FOUND)
			.satisfies((result) -> assertThat(this.mvc.perform(new ErrorDispatcher(result, '/error'))).bodyText()
				.contains('Expected!'));
	}
	@Test
	void testErrorWithNoContentResponseStatus() {
		assertThat(this.mvc.get().uri('/noContent').accept('some/thing')).hasStatus(HttpStatus.NO_CONTENT)
			.satisfies((result) -> assertThat(this.mvc.perform(new ErrorDispatcher(result, '/error')))
				.hasStatus(HttpStatus.NO_CONTENT)
				.body()
				.isEmpty());
	}
	@Test
	void testBindingExceptionForMachineClient() {
		// In a real server the response is carried over into the error dispatcher, but
		// in the mock a new one is created, so we have to assert the status at this
		// intermediate point, and the rendered status code is always wrong (but would
		// be 400 in a real system)
		assertThat(this.mvc.get().uri('/bind')).hasStatus4xxClientError()
			.satisfies((result) -> assertThat(this.mvc.perform(new ErrorDispatcher(result, '/error'))).bodyText()
				.contains('Validation failed'));
	}
	@Test
	void testDirectAccessForBrowserClient() {
		assertThat(this.mvc.get().uri('/error').accept(MediaType.TEXT_HTML)).hasStatus5xxServerError()
			.bodyText()
			.contains('ERROR_BEAN');
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@ImportAutoConfiguration({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			ErrorMvcAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	private @interface MinimalWebConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	static class TestConfiguration {
		// For manual testing
		static void main(String[] args) {
			SpringApplication.run(TestConfiguration.class, args);
		}
		@Bean
		View error() {
			return new AbstractView() {
				@Override
				protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,
						HttpServletResponse response) throws Exception {
					response.getWriter().write('ERROR_BEAN');
				}
			};
		}
		@RestController
		public static class Errors {
			@RequestMapping('/')
			String home() {
				throw new IllegalStateException('Expected!');
			}
			@RequestMapping('/bang')
			String bang() {
				throw new NotFoundException('Expected!');
			}
			@RequestMapping('/bind')
			String bind(@RequestAttribute(required = false) String foo) throws Exception {
				BindException error = new BindException(this, 'test');
				error.rejectValue('foo', 'bar.error');
				Parameter fooParameter = ReflectionUtils.findMethod(Errors.class, 'bind', String.class)
					.getParameters()[0];
				throw new MethodArgumentNotValidException(MethodParameter.forParameter(fooParameter), error);
			}
			@RequestMapping('/noContent')
			void noContent() {
				throw new NoContentException('Expected!');
			}
			public String getFoo() {
				return 'foo';
			}
		}
	}
	@ResponseStatus(HttpStatus.NOT_FOUND)
	static class NotFoundException extends RuntimeException {
		NotFoundException(String string) {
			super(string);
		}
	}
	@ResponseStatus(HttpStatus.NO_CONTENT)
	private static class NoContentException extends RuntimeException {
		NoContentException(String string) {
			super(string);
		}
	}
	private class ErrorDispatcher implements RequestBuilder {
		private final MvcResult result;
		private final String path;
		ErrorDispatcher(MvcTestResult mvcTestResult, String path) {
			this.result = mvcTestResult.getMvcResult();
			this.path = path;
		}
		@Override
		public MockHttpServletRequest buildRequest(ServletContext servletContext) {
			MockHttpServletRequest request = this.result.getRequest();
			request.setDispatcherType(DispatcherType.ERROR);
			request.setRequestURI(this.path);
			request.setAttribute('jakarta.servlet.error.status_code', this.result.getResponse().getStatus());
			return request;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
@ExtendWith(OutputCaptureExtension.class)
class ErrorMvcAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(DispatcherServletAutoConfiguration.class, ErrorMvcAutoConfiguration.class));
	@Test
	void renderContainsViewWithExceptionDetails() {
		this.contextRunner.run((context) -> {
			View errorView = context.getBean('error', View.class);
			ErrorAttributes errorAttributes = context.getBean(ErrorAttributes.class);
			DispatcherServletWebRequest webRequest = createWebRequest(new IllegalStateException('Exception message'),
					false);
			errorView.render(errorAttributes.getErrorAttributes(webRequest, withAllOptions()), webRequest.getRequest(),
					webRequest.getResponse());
			assertThat(webRequest.getResponse().getContentType()).isEqualTo('text/html;charset=UTF-8');
			String responseString = ((MockHttpServletResponse) webRequest.getResponse()).getContentAsString();
			assertThat(responseString).contains(
					'<p>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p>')
				.contains('<div>Exception message</div>')
				.contains('<div style="white-space:pre-wrap;">java.lang.IllegalStateException');
		});
	}
	@Test
	void renderCanUseJavaTimeTypeAsTimestamp() { // gh-23256
		this.contextRunner.run((context) -> {
			View errorView = context.getBean('error', View.class);
			ErrorAttributes errorAttributes = context.getBean(ErrorAttributes.class);
			DispatcherServletWebRequest webRequest = createWebRequest(new IllegalStateException('Exception message'),
					false);
			Map<String, Object> attributes = errorAttributes.getErrorAttributes(webRequest, withAllOptions());
			attributes.put('timestamp', Clock.systemUTC().instant());
			errorView.render(attributes, webRequest.getRequest(), webRequest.getResponse());
			assertThat(webRequest.getResponse().getContentType()).isEqualTo('text/html;charset=UTF-8');
			String responseString = ((MockHttpServletResponse) webRequest.getResponse()).getContentAsString();
			assertThat(responseString).contains('This application has no explicit mapping for /error');
		});
	}
	@Test
	void renderWhenAlreadyCommittedLogsMessage(CapturedOutput output) {
		this.contextRunner.run((context) -> {
			View errorView = context.getBean('error', View.class);
			ErrorAttributes errorAttributes = context.getBean(ErrorAttributes.class);
			DispatcherServletWebRequest webRequest = createWebRequest(new IllegalStateException('Exception message'),
					true);
			errorView.render(errorAttributes.getErrorAttributes(webRequest, withAllOptions()), webRequest.getRequest(),
					webRequest.getResponse());
			assertThat(output).contains('Cannot render error page for request [/path] '
					+ 'and exception [Exception message] as the response has '
					+ 'already been committed. As a result, the response may have the wrong status code.');
		});
	}
	private DispatcherServletWebRequest createWebRequest(Exception ex, boolean committed) {
		MockHttpServletRequest request = new MockHttpServletRequest('GET', '/path');
		MockHttpServletResponse response = new MockHttpServletResponse();
		DispatcherServletWebRequest webRequest = new DispatcherServletWebRequest(request, response);
		webRequest.setAttribute('jakarta.servlet.error.exception', ex, RequestAttributes.SCOPE_REQUEST);
		webRequest.setAttribute('jakarta.servlet.error.request_uri', '/path', RequestAttributes.SCOPE_REQUEST);
		response.setCommitted(committed);
		response.setOutputStreamAccessAllowed(!committed);
		response.setWriterAccessAllowed(!committed);
		return webRequest;
	}
	private ErrorAttributeOptions withAllOptions() {
		return ErrorAttributeOptions.of(Include.values());
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class FilterOrderingIntegrationTests {
	private AnnotationConfigServletWebServerApplicationContext context;
	@AfterEach
	void cleanup() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void testFilterOrdering() {
		load();
		List<RegisteredFilter> registeredFilters = this.context.getBean(MockServletWebServerFactory.class)
			.getWebServer()
			.getRegisteredFilters();
		assertThat(registeredFilters.get(0).getFilter()).isInstanceOf(OrderedCharacterEncodingFilter.class);
		assertThat(registeredFilters.get(1).getFilter()).isInstanceOf(DelegatingFilterProxy.class)
			.extracting('targetBeanName')
			.isEqualTo('springSessionRepositoryFilter');
		assertThat(registeredFilters.get(2).getFilter()).isInstanceOf(Filter.class)
			.extracting('beanName')
			.isEqualTo('hiddenHttpMethodFilter');
		assertThat(registeredFilters.get(3).getFilter()).isInstanceOf(Filter.class)
			.extracting('beanName')
			.isEqualTo('formContentFilter');
		assertThat(registeredFilters.get(4).getFilter()).isInstanceOf(OrderedRequestContextFilter.class);
		assertThat(registeredFilters.get(5).getFilter()).isInstanceOf(FilterChainProxy.class);
	}
	private void load() {
		this.context = new AnnotationConfigServletWebServerApplicationContext();
		this.context.register(MockWebServerConfiguration.class, TestSessionConfiguration.class,
				TestRedisConfiguration.class, WebMvcAutoConfiguration.class, SecurityAutoConfiguration.class,
				SessionAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class, HttpEncodingAutoConfiguration.class);
		TestPropertyValues.of('spring.mvc.hiddenmethod.filter.enabled:true').applyTo(this.context);
		this.context.refresh();
	}
	@Configuration(proxyBeanMethods = false)
	static class MockWebServerConfiguration {
		@Bean
		MockServletWebServerFactory webServerFactory() {
			return new MockServletWebServerFactory();
		}
		@Bean
		WebServerFactoryCustomizerBeanPostProcessor ServletWebServerCustomizerBeanPostProcessor() {
			return new WebServerFactoryCustomizerBeanPostProcessor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class TestSessionConfiguration {
		@Bean
		MapSessionRepository mapSessionRepository() {
			return new MapSessionRepository(new ConcurrentHashMap<>());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestRedisConfiguration {
		@Bean
		RedisConnectionFactory redisConnectionFactory() {
			RedisConnectionFactory connectionFactory = mock(RedisConnectionFactory.class);
			RedisConnection connection = mock(RedisConnection.class);
			given(connectionFactory.getConnection()).willReturn(connection);
			return connectionFactory;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class JerseyApplicationPathTests {
	@Test
	void getRelativePathReturnsRelativePath() {
		assertThat(((JerseyApplicationPath) () -> 'spring').getRelativePath('boot')).isEqualTo('spring/boot');
		assertThat(((JerseyApplicationPath) () -> 'spring/').getRelativePath('boot')).isEqualTo('spring/boot');
		assertThat(((JerseyApplicationPath) () -> 'spring').getRelativePath('/boot')).isEqualTo('spring/boot');
		assertThat(((JerseyApplicationPath) () -> 'spring/*').getRelativePath('/boot')).isEqualTo('spring/boot');
	}
	@Test
	void getPrefixWhenHasSimplePathReturnPath() {
		assertThat(((JerseyApplicationPath) () -> 'spring').getPrefix()).isEqualTo('spring');
	}
	@Test
	void getPrefixWhenHasPatternRemovesPattern() {
		assertThat(((JerseyApplicationPath) () -> 'spring/*.do').getPrefix()).isEqualTo('spring');
	}
	@Test
	void getPrefixWhenPathEndsWithSlashRemovesSlash() {
		assertThat(((JerseyApplicationPath) () -> 'spring/').getPrefix()).isEqualTo('spring');
	}
	@Test
	void getUrlMappingWhenPathIsEmptyReturnsSlash() {
		assertThat(((JerseyApplicationPath) () -> '').getUrlMapping()).isEqualTo('/*');
	}
	@Test
	void getUrlMappingWhenPathIsSlashReturnsSlash() {
		assertThat(((JerseyApplicationPath) () -> '/').getUrlMapping()).isEqualTo('/*');
	}
	@Test
	void getUrlMappingWhenPathContainsStarReturnsPath() {
		assertThat(((JerseyApplicationPath) () -> '/spring/*.do').getUrlMapping()).isEqualTo('/spring/*.do');
	}
	@Test
	void getUrlMappingWhenHasPathNotEndingSlashReturnsSlashStarPattern() {
		assertThat(((JerseyApplicationPath) () -> '/spring/boot').getUrlMapping()).isEqualTo('/spring/boot/*');
	}
	@Test
	void getUrlMappingWhenHasPathDoesNotStartWithSlashPrependsSlash() {
		assertThat(((JerseyApplicationPath) () -> 'spring/boot').getUrlMapping()).isEqualTo('/spring/boot/*');
	}
	@Test
	void getUrlMappingWhenHasPathEndingWithSlashReturnsSlashStarPattern() {
		assertThat(((JerseyApplicationPath) () -> '/spring/boot/').getUrlMapping()).isEqualTo('/spring/boot/*');
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class WelcomePageNotAcceptableHandlerMappingTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withUserConfiguration(HandlerMappingConfiguration.class)
		.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class));
	@Test
	void isOrderedAtLowPriorityButAboveResourceHandlerRegistry() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class).run((context) -> {
			WelcomePageNotAcceptableHandlerMapping handler = context
				.getBean(WelcomePageNotAcceptableHandlerMapping.class);
			ResourceHandlerRegistry registry = new ResourceHandlerRegistry(context, null);
			Integer resourceOrder = (Integer) ReflectionTestUtils.getField(registry, 'order');
			assertThat(handler.getOrder()).isEqualTo(Ordered.LOWEST_PRECEDENCE - 10);
			assertThat(handler.getOrder()).isLessThan(resourceOrder);
		});
	}
	@Test
	void handlesRequestForStaticPageThatAcceptsTextHtml() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.TEXT_HTML))
				.hasStatus(HttpStatus.NOT_ACCEPTABLE)));
	}
	@Test
	void handlesRequestForStaticPageThatDoesNotAcceptTextHtml() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.APPLICATION_JSON))
				.hasStatus(HttpStatus.NOT_ACCEPTABLE)));
	}
	@Test
	void handlesRequestWithNoAcceptHeader() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/')).hasStatus(HttpStatus.NOT_ACCEPTABLE)));
	}
	@Test
	void handlesRequestWithEmptyAcceptHeader() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').header(HttpHeaders.ACCEPT, ''))
				.hasStatus(HttpStatus.NOT_ACCEPTABLE)));
	}
	@Test
	void rootHandlerIsNotRegisteredWhenStaticPathPatternIsNotSlashStarStar() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.withPropertyValues('static-path-pattern=/foo/**')
			.run((context) -> assertThat(context.getBean(WelcomePageNotAcceptableHandlerMapping.class).getRootHandler())
				.isNull());
	}
	@Test
	void producesNotFoundResponseWhenThereIsNoWelcomePage() {
		this.contextRunner.run(testWith(
				(mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.TEXT_HTML)).hasStatus(HttpStatus.NOT_FOUND)));
	}
	private ContextConsumer<AssertableWebApplicationContext> testWith(ThrowingConsumer<MockMvcTester> mvc) {
		return (context) -> mvc.accept(MockMvcTester.from(context));
	}
	@Configuration(proxyBeanMethods = false)
	static class HandlerMappingConfiguration {
		@Bean
		WelcomePageNotAcceptableHandlerMapping handlerMapping(ApplicationContext applicationContext,
				ObjectProvider<TemplateAvailabilityProviders> templateAvailabilityProviders,
				ObjectProvider<Resource> staticIndexPage,
				@Value('${static-path-pattern:/**}') String staticPathPattern) {
			return new WelcomePageNotAcceptableHandlerMapping(
					templateAvailabilityProviders
						.getIfAvailable(() -> new TemplateAvailabilityProviders(applicationContext)),
					applicationContext, staticIndexPage.getIfAvailable(), staticPathPattern);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class StaticResourceConfiguration {
		@Bean
		Resource staticIndexPage() {
			return new FileSystemResource('src/test/resources/welcome-page/index.html');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class ConditionalOnMissingFilterBeanTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void outcomeWhenValueIsOfMissingBeanReturnsMatch() {
		this.contextRunner.withUserConfiguration(WithoutTestFilterConfig.class, OnMissingWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myOtherFilter', 'testFilter')));
	}
	@Test
	void outcomeWhenValueIsOfExistingBeanReturnsNoMatch() {
		this.contextRunner.withUserConfiguration(WithTestFilterConfig.class, OnMissingWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myTestFilter')));
	}
	@Test
	void outcomeWhenValueIsOfMissingBeanRegistrationReturnsMatch() {
		this.contextRunner
			.withUserConfiguration(WithoutTestFilterRegistrationConfig.class, OnMissingWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myOtherFilter', 'testFilter')));
	}
	@Test
	void outcomeWhenValueIsOfExistingBeanRegistrationReturnsNoMatch() {
		this.contextRunner.withUserConfiguration(WithTestFilterRegistrationConfig.class, OnMissingWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myTestFilter')));
	}
	@Test
	void outcomeWhenReturnTypeIsOfExistingBeanReturnsNoMatch() {
		this.contextRunner.withUserConfiguration(WithTestFilterConfig.class, OnMissingWithReturnTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myTestFilter')));
	}
	@Test
	void outcomeWhenReturnTypeIsOfExistingBeanRegistrationReturnsNoMatch() {
		this.contextRunner
			.withUserConfiguration(WithTestFilterRegistrationConfig.class, OnMissingWithReturnTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myTestFilter')));
	}
	@Test
	void outcomeWhenReturnRegistrationTypeIsOfExistingBeanReturnsNoMatch() {
		this.contextRunner
			.withUserConfiguration(WithTestFilterConfig.class, OnMissingWithReturnRegistrationTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myTestFilter')));
	}
	@Test
	void outcomeWhenReturnRegistrationTypeIsOfExistingBeanRegistrationReturnsNoMatch() {
		this.contextRunner
			.withUserConfiguration(WithTestFilterRegistrationConfig.class,
					OnMissingWithReturnRegistrationTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(filterBeanRequirement('myTestFilter')));
	}
	private Consumer<ConfigurableApplicationContext> filterBeanRequirement(String... names) {
		return (context) -> {
			String[] filters = context.getBeanNamesForType(Filter.class);
			String[] registrations = context.getBeanNamesForType(FilterRegistrationBean.class);
			assertThat(StringUtils.concatenateStringArrays(filters, registrations)).containsOnly(names);
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class WithTestFilterConfig {
		@Bean
		TestFilter myTestFilter() {
			return new TestFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WithoutTestFilterConfig {
		@Bean
		OtherFilter myOtherFilter() {
			return new OtherFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WithoutTestFilterRegistrationConfig {
		@Bean
		FilterRegistrationBean<OtherFilter> myOtherFilter() {
			return new FilterRegistrationBean<>(new OtherFilter());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WithTestFilterRegistrationConfig {
		@Bean
		FilterRegistrationBean<TestFilter> myTestFilter() {
			return new FilterRegistrationBean<>(new TestFilter());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OnMissingWithValueConfig {
		@Bean
		@ConditionalOnMissingFilterBean(TestFilter.class)
		TestFilter testFilter() {
			return new TestFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OnMissingWithReturnTypeConfig {
		@Bean
		@ConditionalOnMissingFilterBean
		TestFilter testFilter() {
			return new TestFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OnMissingWithReturnRegistrationTypeConfig {
		@Bean
		@ConditionalOnMissingFilterBean
		FilterRegistrationBean<TestFilter> testFilter() {
			return new FilterRegistrationBean<>(new TestFilter());
		}
	}
	static class TestFilter implements Filter {
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
				throws IOException, ServletException {
		}
	}
	static class OtherFilter implements Filter {
		@Override
		public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
				throws IOException, ServletException {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class ServletWebServerFactoryCustomizerTests {
	private final ServerProperties properties = new ServerProperties();
	private ServletWebServerFactoryCustomizer customizer;
	@BeforeEach
	void setup() {
		this.customizer = new ServletWebServerFactoryCustomizer(this.properties);
	}
	@Test
	void testDefaultDisplayName() {
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setDisplayName('application');
	}
	@Test
	void testCustomizeDisplayName() {
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.properties.getServlet().setApplicationDisplayName('TestName');
		this.customizer.customize(factory);
		then(factory).should().setDisplayName('TestName');
	}
	@Test
	void withNoCustomMimeMappingsThenEmptyMimeMappingsIsAdded() {
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		ArgumentCaptor<MimeMappings> mimeMappingsCaptor = ArgumentCaptor.forClass(MimeMappings.class);
		then(factory).should().addMimeMappings(mimeMappingsCaptor.capture());
		MimeMappings mimeMappings = mimeMappingsCaptor.getValue();
		assertThat(mimeMappings.getAll()).isEmpty();
	}
	@Test
	void withCustomMimeMappingsThenPopulatedMimeMappingsIsAdded() {
		this.properties.getMimeMappings().add('a', 'alpha');
		this.properties.getMimeMappings().add('b', 'bravo');
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		ArgumentCaptor<MimeMappings> mimeMappingsCaptor = ArgumentCaptor.forClass(MimeMappings.class);
		then(factory).should().addMimeMappings(mimeMappingsCaptor.capture());
		MimeMappings mimeMappings = mimeMappingsCaptor.getValue();
		assertThat(mimeMappings.getAll()).hasSize(2);
	}
	@Test
	void testCustomizeDefaultServlet() {
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.properties.getServlet().setRegisterDefaultServlet(false);
		this.customizer.customize(factory);
		then(factory).should().setRegisterDefaultServlet(false);
	}
	@Test
	void testCustomizeSsl() {
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		Ssl ssl = mock(Ssl.class);
		this.properties.setSsl(ssl);
		this.customizer.customize(factory);
		then(factory).should().setSsl(ssl);
	}
	@Test
	void testCustomizeJsp() {
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setJsp(any(Jsp.class));
	}
	@Test
	void customizeSessionProperties() {
		Map<String, String> map = new HashMap<>();
		map.put('server.servlet.session.timeout', '123');
		map.put('server.servlet.session.tracking-modes', 'cookie,url');
		map.put('server.servlet.session.cookie.name', 'testname');
		map.put('server.servlet.session.cookie.domain', 'testdomain');
		map.put('server.servlet.session.cookie.path', '/testpath');
		map.put('server.servlet.session.cookie.http-only', 'true');
		map.put('server.servlet.session.cookie.secure', 'true');
		map.put('server.servlet.session.cookie.max-age', '60');
		bindProperties(map);
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setSession(assertArg((session) -> {
			assertThat(session.getTimeout()).hasSeconds(123);
			Cookie cookie = session.getCookie();
			assertThat(cookie.getName()).isEqualTo('testname');
			assertThat(cookie.getDomain()).isEqualTo('testdomain');
			assertThat(cookie.getPath()).isEqualTo('/testpath');
			assertThat(cookie.getHttpOnly()).isTrue();
			assertThat(cookie.getMaxAge()).hasSeconds(60);
		}));
	}
	@Test
	void testCustomizeTomcatPort() {
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.properties.setPort(8080);
		this.customizer.customize(factory);
		then(factory).should().setPort(8080);
	}
	@Test
	void customizeServletDisplayName() {
		Map<String, String> map = new HashMap<>();
		map.put('server.servlet.application-display-name', 'MyBootApp');
		bindProperties(map);
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setDisplayName('MyBootApp');
	}
	@Test
	void testCustomizeTomcatMinSpareThreads() {
		Map<String, String> map = new HashMap<>();
		map.put('server.tomcat.threads.min-spare', '10');
		bindProperties(map);
		assertThat(this.properties.getTomcat().getThreads().getMinSpare()).isEqualTo(10);
	}
	@Test
	void sessionStoreDir() {
		Map<String, String> map = new HashMap<>();
		map.put('server.servlet.session.store-dir', 'mydirectory');
		bindProperties(map);
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should()
			.setSession(assertArg((session) -> assertThat(session.getStoreDir()).isEqualTo(new File('mydirectory'))));
	}
	@Test
	void whenShutdownPropertyIsSetThenShutdownIsCustomized() {
		Map<String, String> map = new HashMap<>();
		map.put('server.shutdown', 'immediate');
		bindProperties(map);
		ConfigurableServletWebServerFactory factory = mock(ConfigurableServletWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setShutdown(assertArg((shutdown) -> assertThat(shutdown).isEqualTo(Shutdown.IMMEDIATE)));
	}
	private void bindProperties(Map<String, String> map) {
		ConfigurationPropertySource source = new MapConfigurationPropertySource(map);
		new Binder(source).bind('server', Bindable.ofInstance(this.properties));
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@DirtiesUrlFactories
class ServletWebServerFactoryAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
			AnnotationConfigServletWebServerApplicationContext::new)
		.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class,
				DispatcherServletAutoConfiguration.class))
		.withUserConfiguration(WebServerConfiguration.class);
	@Test
	void createFromConfigClass() {
		this.contextRunner.run(verifyContext());
	}
	@Test
	void contextAlreadyHasDispatcherServletWithDefaultName() {
		this.contextRunner.withUserConfiguration(DispatcherServletConfiguration.class).run(verifyContext());
	}
	@Test
	void contextAlreadyHasDispatcherServlet() {
		this.contextRunner.withUserConfiguration(SpringServletConfiguration.class).run((context) -> {
			verifyContext(context);
			assertThat(context.getBeanNamesForType(DispatcherServlet.class)).hasSize(2);
		});
	}
	@Test
	void contextAlreadyHasNonDispatcherServlet() {
		this.contextRunner.withUserConfiguration(NonSpringServletConfiguration.class).run((context) -> {
			verifyContext(context); // the non default servlet is still registered
			assertThat(context).doesNotHaveBean(DispatcherServlet.class);
		});
	}
	@Test
	void contextAlreadyHasNonServlet() {
		this.contextRunner.withUserConfiguration(NonServletConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(DispatcherServlet.class);
			assertThat(context).doesNotHaveBean(Servlet.class);
		});
	}
	@Test
	void contextAlreadyHasDispatcherServletAndRegistration() {
		this.contextRunner.withUserConfiguration(DispatcherServletWithRegistrationConfiguration.class)
			.run((context) -> {
				verifyContext(context);
				assertThat(context).hasSingleBean(DispatcherServlet.class);
			});
	}
	@Test
	void webServerHasNoServletContext() {
		this.contextRunner.withUserConfiguration(EnsureWebServerHasNoServletContext.class).run(verifyContext());
	}
	@Test
	void customizeWebServerFactoryThroughCallback() {
		this.contextRunner.withUserConfiguration(CallbackEmbeddedServerFactoryCustomizer.class).run((context) -> {
			verifyContext(context);
			assertThat(context.getBean(MockServletWebServerFactory.class).getPort()).isEqualTo(9000);
		});
	}
	@Test
	void initParametersAreConfiguredOnTheServletContext() {
		this.contextRunner
			.withPropertyValues('server.servlet.context-parameters.a:alpha',
					'server.servlet.context-parameters.b:bravo')
			.run((context) -> {
				ServletContext servletContext = context.getServletContext();
				assertThat(servletContext.getInitParameter('a')).isEqualTo('alpha');
				assertThat(servletContext.getInitParameter('b')).isEqualTo('bravo');
			});
	}
	@Test
	void jettyServerCustomizerBeanIsAddedToFactory() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(JettyServerCustomizerConfiguration.class)
			.withPropertyValues('server.port:0');
		runner.run((context) -> {
			JettyServletWebServerFactory factory = context.getBean(JettyServletWebServerFactory.class);
			assertThat(factory.getServerCustomizers()).hasSize(1);
		});
	}
	@Test
	void jettyServerCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(DoubleRegistrationJettyServerCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			JettyServletWebServerFactory factory = context.getBean(JettyServletWebServerFactory.class);
			JettyServerCustomizer customizer = context.getBean('serverCustomizer', JettyServerCustomizer.class);
			assertThat(factory.getServerCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Server.class));
		});
	}
	@Test
	void undertowDeploymentInfoCustomizerBeanIsAddedToFactory() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class, Server.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(UndertowDeploymentInfoCustomizerConfiguration.class)
			.withPropertyValues('server.port:0');
		runner.run((context) -> {
			UndertowServletWebServerFactory factory = context.getBean(UndertowServletWebServerFactory.class);
			assertThat(factory.getDeploymentInfoCustomizers()).hasSize(1);
		});
	}
	@Test
	void undertowDeploymentInfoCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class, Server.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(DoubleRegistrationUndertowDeploymentInfoCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			UndertowServletWebServerFactory factory = context.getBean(UndertowServletWebServerFactory.class);
			UndertowDeploymentInfoCustomizer customizer = context.getBean('deploymentInfoCustomizer',
					UndertowDeploymentInfoCustomizer.class);
			assertThat(factory.getDeploymentInfoCustomizers()).contains(customizer);
			then(customizer).should().customize(any(DeploymentInfo.class));
		});
	}
	@Test
	void undertowBuilderCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class, Server.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(DoubleRegistrationUndertowBuilderCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			UndertowServletWebServerFactory factory = context.getBean(UndertowServletWebServerFactory.class);
			UndertowBuilderCustomizer customizer = context.getBean('builderCustomizer',
					UndertowBuilderCustomizer.class);
			assertThat(factory.getBuilderCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Builder.class));
		});
	}
	@Test
	void undertowBuilderCustomizerBeanIsAddedToFactory() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class, Server.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(UndertowBuilderCustomizerConfiguration.class)
			.withPropertyValues('server.port:0');
		runner.run((context) -> {
			UndertowServletWebServerFactory factory = context.getBean(UndertowServletWebServerFactory.class);
			assertThat(factory.getBuilderCustomizers()).hasSize(1);
		});
	}
	@Test
	void undertowServletWebServerFactoryCustomizerIsAutoConfigured() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class, Server.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(UndertowBuilderCustomizerConfiguration.class)
			.withPropertyValues('server.port:0');
		runner.run((context) -> assertThat(context).hasSingleBean(UndertowServletWebServerFactoryCustomizer.class));
	}
	@Test
	void tomcatConnectorCustomizerBeanIsAddedToFactory() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(TomcatConnectorCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatServletWebServerFactory factory = context.getBean(TomcatServletWebServerFactory.class);
			TomcatConnectorCustomizer customizer = context.getBean('connectorCustomizer',
					TomcatConnectorCustomizer.class);
			assertThat(factory.getTomcatConnectorCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Connector.class));
		});
	}
	@Test
	void tomcatConnectorCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(DoubleRegistrationTomcatConnectorCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatServletWebServerFactory factory = context.getBean(TomcatServletWebServerFactory.class);
			TomcatConnectorCustomizer customizer = context.getBean('connectorCustomizer',
					TomcatConnectorCustomizer.class);
			assertThat(factory.getTomcatConnectorCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Connector.class));
		});
	}
	@Test
	void tomcatContextCustomizerBeanIsAddedToFactory() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(TomcatContextCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatServletWebServerFactory factory = context.getBean(TomcatServletWebServerFactory.class);
			TomcatContextCustomizer customizer = context.getBean('contextCustomizer', TomcatContextCustomizer.class);
			assertThat(factory.getTomcatContextCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Context.class));
		});
	}
	@Test
	void tomcatContextCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(DoubleRegistrationTomcatContextCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatServletWebServerFactory factory = context.getBean(TomcatServletWebServerFactory.class);
			TomcatContextCustomizer customizer = context.getBean('contextCustomizer', TomcatContextCustomizer.class);
			assertThat(factory.getTomcatContextCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Context.class));
		});
	}
	@Test
	void tomcatProtocolHandlerCustomizerBeanIsAddedToFactory() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(TomcatProtocolHandlerCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatServletWebServerFactory factory = context.getBean(TomcatServletWebServerFactory.class);
			TomcatProtocolHandlerCustomizer<?> customizer = context.getBean('protocolHandlerCustomizer',
					TomcatProtocolHandlerCustomizer.class);
			assertThat(factory.getTomcatProtocolHandlerCustomizers()).contains(customizer);
			then(customizer).should().customize(any());
		});
	}
	@Test
	void tomcatProtocolHandlerCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(DoubleRegistrationTomcatProtocolHandlerCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatServletWebServerFactory factory = context.getBean(TomcatServletWebServerFactory.class);
			TomcatProtocolHandlerCustomizer<?> customizer = context.getBean('protocolHandlerCustomizer',
					TomcatProtocolHandlerCustomizer.class);
			assertThat(factory.getTomcatProtocolHandlerCustomizers()).contains(customizer);
			then(customizer).should().customize(any());
		});
	}
	@Test
	void forwardedHeaderFilterShouldBeConfigured() {
		this.contextRunner.withPropertyValues('server.forward-headers-strategy=framework').run((context) -> {
			assertThat(context).hasSingleBean(FilterRegistrationBean.class);
			Filter filter = context.getBean(FilterRegistrationBean.class).getFilter();
			assertThat(filter).isInstanceOf(ForwardedHeaderFilter.class);
			assertThat(filter).extracting('relativeRedirects').isEqualTo(false);
		});
	}
	@Test
	void forwardedHeaderFilterWhenStrategyNotFilterShouldNotBeConfigured() {
		this.contextRunner.withPropertyValues('server.forward-headers-strategy=native')
			.run((context) -> assertThat(context).doesNotHaveBean(FilterRegistrationBean.class));
	}
	@Test
	void forwardedHeaderFilterWhenFilterAlreadyRegisteredShouldBackOff() {
		this.contextRunner.withUserConfiguration(ForwardedHeaderFilterConfiguration.class)
			.withPropertyValues('server.forward-headers-strategy=framework')
			.run((context) -> assertThat(context).hasSingleBean(FilterRegistrationBean.class));
	}
	@Test
	void cookieSameSiteSuppliersAreApplied() {
		this.contextRunner.withUserConfiguration(CookieSameSiteSupplierConfiguration.class).run((context) -> {
			AbstractServletWebServerFactory webServerFactory = context.getBean(AbstractServletWebServerFactory.class);
			assertThat(webServerFactory.getCookieSameSiteSuppliers()).hasSize(2);
		});
	}
	@Test
	void relativeRedirectsShouldBeEnabledWhenUsingTomcatContainerAndUseRelativeRedirects() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withPropertyValues('server.forward-headers-strategy=framework',
					'server.tomcat.use-relative-redirects=true', 'server.port=0');
		runner.run((context) -> {
			Filter filter = context.getBean(FilterRegistrationBean.class).getFilter();
			assertThat(filter).isInstanceOf(ForwardedHeaderFilter.class);
			assertThat(filter).extracting('relativeRedirects').isEqualTo(true);
		});
	}
	@Test
	void relativeRedirectsShouldNotBeEnabledWhenUsingTomcatContainerAndNotUsingRelativeRedirects() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withPropertyValues('server.forward-headers-strategy=framework',
					'server.tomcat.use-relative-redirects=false', 'server.port=0');
		runner.run((context) -> {
			Filter filter = context.getBean(FilterRegistrationBean.class).getFilter();
			assertThat(filter).isInstanceOf(ForwardedHeaderFilter.class);
			assertThat(filter).extracting('relativeRedirects').isEqualTo(false);
		});
	}
	@Test
	void relativeRedirectsShouldNotBeEnabledWhenNotUsingTomcatContainer() {
		WebApplicationContextRunner runner = new WebApplicationContextRunner(
				AnnotationConfigServletWebServerApplicationContext::new)
			.withClassLoader(new FilteredClassLoader(Tomcat.class, Server.class))
			.withConfiguration(AutoConfigurations.of(ServletWebServerFactoryAutoConfiguration.class))
			.withPropertyValues('server.forward-headers-strategy=framework', 'server.port=0');
		runner.run((context) -> {
			Filter filter = context.getBean(FilterRegistrationBean.class).getFilter();
			assertThat(filter).isInstanceOf(ForwardedHeaderFilter.class);
			assertThat(filter).extracting('relativeRedirects').isEqualTo(false);
		});
	}
	private ContextConsumer<AssertableWebApplicationContext> verifyContext() {
		return this::verifyContext;
	}
	private void verifyContext(ApplicationContext context) {
		MockServletWebServerFactory factory = context.getBean(MockServletWebServerFactory.class);
		Servlet servlet = context.getBean(DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME,
				Servlet.class);
		then(factory.getServletContext()).should().addServlet('dispatcherServlet', servlet);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnExpression('true')
	static class WebServerConfiguration {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new MockServletWebServerFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DispatcherServletConfiguration {
		@Bean
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SpringServletConfiguration {
		@Bean
		DispatcherServlet springServlet() {
			return new DispatcherServlet();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonSpringServletConfiguration {
		@Bean
		FrameworkServlet dispatcherServlet() {
			return new FrameworkServlet() {
				@Override
				protected void doService(HttpServletRequest request, HttpServletResponse response) {
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonServletConfiguration {
		@Bean
		String dispatcherServlet() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DispatcherServletWithRegistrationConfiguration {
		@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		DispatcherServlet dispatcherServlet() {
			return new DispatcherServlet();
		}
		@Bean(name = DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
		ServletRegistrationBean<DispatcherServlet> dispatcherRegistration(DispatcherServlet dispatcherServlet) {
			ServletRegistrationBean<DispatcherServlet> registration = new ServletRegistrationBean<>(dispatcherServlet,
					'/app/*');
			registration.setName(DispatcherServletAutoConfiguration.DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
			return registration;
		}
	}
	@Component
	static class EnsureWebServerHasNoServletContext implements BeanPostProcessor {
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			if (bean instanceof ConfigurableServletWebServerFactory) {
				MockServletWebServerFactory webServerFactory = (MockServletWebServerFactory) bean;
				assertThat(webServerFactory.getServletContext()).isNull();
			}
			return bean;
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) {
			return bean;
		}
	}
	@Component
	static class CallbackEmbeddedServerFactoryCustomizer
			implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory> {
		@Override
		public void customize(ConfigurableServletWebServerFactory serverFactory) {
			serverFactory.setPort(9000);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatConnectorCustomizerConfiguration {
		@Bean
		TomcatConnectorCustomizer connectorCustomizer() {
			return mock(TomcatConnectorCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationTomcatConnectorCustomizerConfiguration {
		private final TomcatConnectorCustomizer customizer = mock(TomcatConnectorCustomizer.class);
		@Bean
		TomcatConnectorCustomizer connectorCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<TomcatServletWebServerFactory> tomcatCustomizer() {
			return (tomcat) -> tomcat.addConnectorCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatContextCustomizerConfiguration {
		@Bean
		TomcatContextCustomizer contextCustomizer() {
			return mock(TomcatContextCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationTomcatContextCustomizerConfiguration {
		private final TomcatContextCustomizer customizer = mock(TomcatContextCustomizer.class);
		@Bean
		TomcatContextCustomizer contextCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<TomcatServletWebServerFactory> tomcatCustomizer() {
			return (tomcat) -> tomcat.addContextCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatProtocolHandlerCustomizerConfiguration {
		@Bean
		TomcatProtocolHandlerCustomizer<?> protocolHandlerCustomizer() {
			return mock(TomcatProtocolHandlerCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationTomcatProtocolHandlerCustomizerConfiguration {
		private final TomcatProtocolHandlerCustomizer<?> customizer = mock(TomcatProtocolHandlerCustomizer.class);
		@Bean
		TomcatProtocolHandlerCustomizer<?> protocolHandlerCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<TomcatServletWebServerFactory> tomcatCustomizer() {
			return (tomcat) -> tomcat.addProtocolHandlerCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JettyServerCustomizerConfiguration {
		@Bean
		JettyServerCustomizer serverCustomizer() {
			return (server) -> {
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationJettyServerCustomizerConfiguration {
		private final JettyServerCustomizer customizer = mock(JettyServerCustomizer.class);
		@Bean
		JettyServerCustomizer serverCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<JettyServletWebServerFactory> jettyCustomizer() {
			return (jetty) -> jetty.addServerCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UndertowBuilderCustomizerConfiguration {
		@Bean
		UndertowBuilderCustomizer builderCustomizer() {
			return (builder) -> {
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationUndertowBuilderCustomizerConfiguration {
		private final UndertowBuilderCustomizer customizer = mock(UndertowBuilderCustomizer.class);
		@Bean
		UndertowBuilderCustomizer builderCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<UndertowServletWebServerFactory> undertowCustomizer() {
			return (undertow) -> undertow.addBuilderCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UndertowDeploymentInfoCustomizerConfiguration {
		@Bean
		UndertowDeploymentInfoCustomizer deploymentInfoCustomizer() {
			return (deploymentInfo) -> {
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationUndertowDeploymentInfoCustomizerConfiguration {
		private final UndertowDeploymentInfoCustomizer customizer = mock(UndertowDeploymentInfoCustomizer.class);
		@Bean
		UndertowDeploymentInfoCustomizer deploymentInfoCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<UndertowServletWebServerFactory> undertowCustomizer() {
			return (undertow) -> undertow.addDeploymentInfoCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ForwardedHeaderFilterConfiguration {
		@Bean
		FilterRegistrationBean<ForwardedHeaderFilter> testForwardedHeaderFilter() {
			ForwardedHeaderFilter filter = new ForwardedHeaderFilter();
			return new FilterRegistrationBean<>(filter);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CookieSameSiteSupplierConfiguration {
		@Bean
		CookieSameSiteSupplier cookieSameSiteSupplier1() {
			return CookieSameSiteSupplier.ofLax().whenHasName('test1');
		}
		@Bean
		CookieSameSiteSupplier cookieSameSiteSupplier2() {
			return CookieSameSiteSupplier.ofNone().whenHasName('test2');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public class MockServletWebServerFactory extends AbstractServletWebServerFactory {
	private MockServletWebServer webServer;
	@Override
	public WebServer getWebServer(ServletContextInitializer... initializers) {
		this.webServer = spy(new MockServletWebServer(mergeInitializers(initializers), getPort()));
		return this.webServer;
	}
	public MockServletWebServer getWebServer() {
		return this.webServer;
	}
	public ServletContext getServletContext() {
		return (getWebServer() != null) ? getWebServer().getServletContext() : null;
	}
	public RegisteredServlet getRegisteredServlet(int index) {
		return (getWebServer() != null) ? getWebServer().getRegisteredServlet(index) : null;
	}
	public RegisteredFilter getRegisteredFilter(int index) {
		return (getWebServer() != null) ? getWebServer().getRegisteredFilters(index) : null;
	}
	static class MockServletWebServer extends org.springframework.boot.testsupport.web.servlet.MockServletWebServer
			implements WebServer {
		MockServletWebServer(ServletContextInitializer[] initializers, int port) {
			super(Arrays.stream(initializers)
				.map((initializer) -> (Initializer) initializer::onStartup)
				.toArray(Initializer[]::new), port);
		}
		@Override
		public void start() {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class WebMvcPropertiesTests {
	private final WebMvcProperties properties = new WebMvcProperties();
	@Test
	void servletPathWhenEndsWithSlashHasValidMappingAndPrefix() {
		bind('spring.mvc.servlet.path', '/foo/');
		assertThat(this.properties.getServlet().getServletMapping()).isEqualTo('/foo/*');
		assertThat(this.properties.getServlet().getServletPrefix()).isEqualTo('/foo');
	}
	@Test
	void servletPathWhenDoesNotEndWithSlashHasValidMappingAndPrefix() {
		bind('spring.mvc.servlet.path', '/foo');
		assertThat(this.properties.getServlet().getServletMapping()).isEqualTo('/foo/*');
		assertThat(this.properties.getServlet().getServletPrefix()).isEqualTo('/foo');
	}
	@Test
	void servletPathWhenHasWildcardThrowsException() {
		assertThatExceptionOfType(BindException.class).isThrownBy(() -> bind('spring.mvc.servlet.path', '/*'))
			.withRootCauseInstanceOf(IllegalArgumentException.class)
			.satisfies((ex) -> assertThat(Throwables.getRootCause(ex)).hasMessage('Path must not contain wildcards'));
	}
	private void bind(String name, String value) {
		bind(Collections.singletonMap(name, value));
	}
	private void bind(Map<String, String> map) {
		ConfigurationPropertySource source = new MapConfigurationPropertySource(map);
		new Binder(source).bind('spring.mvc', Bindable.ofInstance(this.properties));
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@DirtiesUrlFactories
class ServletWebServerServletContextListenerTests {
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void registeredServletContextListenerBeanIsCalled(String serverName, Class<?> configuration) {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
				ServletListenerRegistrationBeanConfiguration.class, configuration);
		ServletContextListener servletContextListener = (ServletContextListener) context
			.getBean('registration', ServletListenerRegistrationBean.class)
			.getListener();
		then(servletContextListener).should().contextInitialized(any(ServletContextEvent.class));
		context.close();
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void servletContextListenerBeanIsCalled(String serverName, Class<?> configuration) {
		AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
				ServletContextListenerBeanConfiguration.class, configuration);
		ServletContextListener servletContextListener = context.getBean('servletContextListener',
				ServletContextListener.class);
		then(servletContextListener).should().contextInitialized(any(ServletContextEvent.class));
		context.close();
	}
	static Stream<Arguments> testConfiguration() {
		return Stream.of(Arguments.of('Jetty', JettyConfiguration.class),
				Arguments.of('Tomcat', TomcatConfiguration.class),
				Arguments.of('Undertow', UndertowConfiguration.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatConfiguration {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JettyConfiguration {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new JettyServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UndertowConfiguration {
		@Bean
		ServletWebServerFactory webServerFactory() {
			return new UndertowServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ServletContextListenerBeanConfiguration {
		@Bean
		ServletContextListener servletContextListener() {
			return mock(ServletContextListener.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ServletListenerRegistrationBeanConfiguration {
		@Bean
		ServletListenerRegistrationBean<ServletContextListener> registration() {
			return new ServletListenerRegistrationBean<>(mock(ServletContextListener.class));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@ExtendWith(OutputCaptureExtension.class)
class WelcomePageHandlerMappingTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withUserConfiguration(HandlerMappingConfiguration.class)
		.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class));
	@Test
	void isOrderedAtLowPriority() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class).run((context) -> {
			WelcomePageHandlerMapping handler = context.getBean(WelcomePageHandlerMapping.class);
			assertThat(handler.getOrder()).isEqualTo(2);
		});
	}
	@Test
	void handlesRequestForStaticPageThatAcceptsTextHtml() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.TEXT_HTML)).hasStatusOk()
				.hasForwardedUrl('index.html')));
	}
	@Test
	void handlesRequestForStaticPageThatAcceptsAll() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.ALL)).hasStatusOk()
				.hasForwardedUrl('index.html')));
	}
	@Test
	void doesNotHandleRequestThatDoesNotAcceptTextHtml() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.APPLICATION_JSON))
				.hasStatus(HttpStatus.NOT_FOUND)));
	}
	@Test
	void handlesRequestWithNoAcceptHeader() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/')).hasStatusOk().hasForwardedUrl('index.html')));
	}
	@Test
	void handlesRequestWithEmptyAcceptHeader() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').header(HttpHeaders.ACCEPT, '')).hasStatusOk()
				.hasForwardedUrl('index.html')));
	}
	@Test
	void rootHandlerIsNotRegisteredWhenStaticPathPatternIsNotSlashStarStar() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class)
			.withPropertyValues('static-path-pattern=/foo/**')
			.run((context) -> assertThat(context.getBean(WelcomePageHandlerMapping.class).getRootHandler()).isNull());
	}
	@Test
	void producesNotFoundResponseWhenThereIsNoWelcomePage() {
		this.contextRunner.run(testWith(
				(mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.TEXT_HTML)).hasStatus(HttpStatus.NOT_FOUND)));
	}
	@Test
	void handlesRequestForTemplateThatAcceptsTextHtml() {
		this.contextRunner.withUserConfiguration(TemplateConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.TEXT_HTML)).hasStatusOk()
				.hasBodyTextEqualTo('index template')));
	}
	@Test
	void handlesRequestForTemplateThatAcceptsAll() {
		this.contextRunner.withUserConfiguration(TemplateConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.ALL)).hasStatusOk()
				.hasBodyTextEqualTo('index template')));
	}
	@Test
	void prefersAStaticResourceToATemplate() {
		this.contextRunner.withUserConfiguration(StaticResourceConfiguration.class, TemplateConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept(MediaType.ALL)).hasStatusOk()
				.hasForwardedUrl('index.html')));
	}
	@Test
	void logsInvalidAcceptHeader(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TemplateConfiguration.class)
			.run(testWith((mvc) -> assertThat(mvc.get().uri('/').accept('*/*q=0.8')).hasStatusOk()
				.hasBodyTextEqualTo('index template')));
		assertThat(output).contains('Received invalid Accept header. Assuming all media types are accepted');
	}
	private ContextConsumer<AssertableWebApplicationContext> testWith(ThrowingConsumer<MockMvcTester> mvc) {
		return (context) -> mvc.accept(MockMvcTester.from(context));
	}
	@Configuration(proxyBeanMethods = false)
	static class HandlerMappingConfiguration {
		@Bean
		WelcomePageHandlerMapping handlerMapping(ApplicationContext applicationContext,
				ObjectProvider<TemplateAvailabilityProviders> templateAvailabilityProviders,
				ObjectProvider<Resource> staticIndexPage,
				@Value('${static-path-pattern:/**}') String staticPathPattern) {
			return new WelcomePageHandlerMapping(
					templateAvailabilityProviders
						.getIfAvailable(() -> new TemplateAvailabilityProviders(applicationContext)),
					applicationContext, staticIndexPage.getIfAvailable(), staticPathPattern);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class StaticResourceConfiguration {
		@Bean
		Resource staticIndexPage() {
			return new FileSystemResource('src/test/resources/welcome-page/index.html');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TemplateConfiguration {
		@Bean
		TemplateAvailabilityProviders templateAvailabilityProviders() {
			return new TestTemplateAvailabilityProviders(
					(view, environment, classLoader, resourceLoader) -> view.equals('index'));
		}
		@Bean
		ViewResolver viewResolver() {
			return (name, locale) -> {
				if (name.startsWith('forward:')) {
					return new InternalResourceView(name.substring('forward:'.length()));
				}
				return new AbstractView() {
					@Override
					protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request,
							HttpServletResponse response) throws Exception {
						response.getWriter().print(name + ' template');
					}
				};
			};
		}
	}
	static class TestTemplateAvailabilityProviders extends TemplateAvailabilityProviders {
		TestTemplateAvailabilityProviders(TemplateAvailabilityProvider provider) {
			super(Collections.singletonList(provider));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT,
		properties = { 'spring.web.resources.chain.strategy.content.enabled=true',
				'spring.thymeleaf.prefix=classpath:/templates/thymeleaf/' })
class WelcomePageIntegrationTests {
	@LocalServerPort
	private int port;
	private final TestRestTemplate template = new TestRestTemplate();
	@Test
	void contentStrategyWithWelcomePage() throws Exception {
		RequestEntity<?> entity = RequestEntity.get(new URI('http://localhost:' + this.port + '/'))
			.header('Accept', MediaType.ALL.toString())
			.build();
		ResponseEntity<String> content = this.template.exchange(entity, String.class);
		assertThat(content.getBody()).contains('/custom-');
		assertThat(content.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@Test
	void notAcceptableWelcomePage() throws Exception {
		RequestEntity<?> entity = RequestEntity.get(new URI('http://localhost:' + this.port + '/'))
			.header('Accept', 'spring/boot')
			.build();
		ResponseEntity<String> content = this.template.exchange(entity, String.class);
		assertThat(content.getStatusCode()).isEqualTo(HttpStatus.NOT_ACCEPTABLE);
	}
	@Configuration
	@Import({ PropertyPlaceholderAutoConfiguration.class, WebMvcAutoConfiguration.class,
			HttpMessageConvertersAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class,
			DispatcherServletAutoConfiguration.class, ThymeleafAutoConfiguration.class })
	static class TestConfiguration {
		static void main(String[] args) {
			new SpringApplicationBuilder(TestConfiguration.class).run(args);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class DispatcherServletPathTests {
	@Test
	void getRelativePathReturnsRelativePath() {
		assertThat(((DispatcherServletPath) () -> 'spring').getRelativePath('boot')).isEqualTo('spring/boot');
		assertThat(((DispatcherServletPath) () -> 'spring/').getRelativePath('boot')).isEqualTo('spring/boot');
		assertThat(((DispatcherServletPath) () -> 'spring').getRelativePath('/boot')).isEqualTo('spring/boot');
	}
	@Test
	void getPrefixWhenHasSimplePathReturnPath() {
		assertThat(((DispatcherServletPath) () -> 'spring').getPrefix()).isEqualTo('spring');
	}
	@Test
	void getPrefixWhenHasPatternRemovesPattern() {
		assertThat(((DispatcherServletPath) () -> 'spring/*.do').getPrefix()).isEqualTo('spring');
	}
	@Test
	void getPathWhenPathEndsWithSlashRemovesSlash() {
		assertThat(((DispatcherServletPath) () -> 'spring/').getPrefix()).isEqualTo('spring');
	}
	@Test
	void getServletUrlMappingWhenPathIsEmptyReturnsSlash() {
		assertThat(((DispatcherServletPath) () -> '').getServletUrlMapping()).isEqualTo('/');
	}
	@Test
	void getServletUrlMappingWhenPathIsSlashReturnsSlash() {
		assertThat(((DispatcherServletPath) () -> '/').getServletUrlMapping()).isEqualTo('/');
	}
	@Test
	void getServletUrlMappingWhenPathContainsStarReturnsPath() {
		assertThat(((DispatcherServletPath) () -> 'spring/*.do').getServletUrlMapping()).isEqualTo('spring/*.do');
	}
	@Test
	void getServletUrlMappingWhenHasPathNotEndingSlashReturnsSlashStarPattern() {
		assertThat(((DispatcherServletPath) () -> 'spring/boot').getServletUrlMapping()).isEqualTo('spring/boot/*');
	}
	@Test
	void getServletUrlMappingWhenHasPathEndingWithSlashReturnsSlashStarPattern() {
		assertThat(((DispatcherServletPath) () -> 'spring/boot/').getServletUrlMapping()).isEqualTo('spring/boot/*');
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
class ConditionalOnEnabledResourceChainTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@AfterEach
	void closeContext() {
		this.context.close();
	}
	@Test
	void disabledByDefault() {
		load();
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void disabledExplicitly() {
		load('spring.web.resources.chain.enabled:false');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void enabledViaMainEnabledFlag() {
		load('spring.web.resources.chain.enabled:true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void enabledViaFixedStrategyFlag() {
		load('spring.web.resources.chain.strategy.fixed.enabled:true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void enabledViaContentStrategyFlag() {
		load('spring.web.resources.chain.strategy.content.enabled:true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	private void load(String... environment) {
		this.context.register(Config.class);
		TestPropertyValues.of(environment).applyTo(this.context);
		this.context.refresh();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		@ConditionalOnEnabledResourceChain
		String foo() {
			return 'foo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@DirtiesUrlFactories
class ReactiveWebServerFactoryAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner(
			AnnotationConfigReactiveWebServerApplicationContext::new)
		.withConfiguration(
				AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void createFromConfigClass() {
		this.contextRunner.withUserConfiguration(MockWebServerConfiguration.class, HttpHandlerConfiguration.class)
			.run((context) -> {
				assertThat(context.getBeansOfType(ReactiveWebServerFactory.class)).hasSize(1);
				assertThat(context.getBeansOfType(WebServerFactoryCustomizer.class)).hasSize(2);
				assertThat(context.getBeansOfType(ReactiveWebServerFactoryCustomizer.class)).hasSize(1);
			});
	}
	@Test
	void missingHttpHandler() {
		this.contextRunner.withUserConfiguration(MockWebServerConfiguration.class)
			.run((context) -> assertThat(context.getStartupFailure()).isInstanceOf(ApplicationContextException.class)
				.rootCause()
				.hasMessageContaining('missing HttpHandler bean'));
	}
	@Test
	void multipleHttpHandler() {
		this.contextRunner
			.withUserConfiguration(MockWebServerConfiguration.class, HttpHandlerConfiguration.class,
					TooManyHttpHandlers.class)
			.run((context) -> assertThat(context.getStartupFailure()).isInstanceOf(ApplicationContextException.class)
				.rootCause()
				.hasMessageContaining('multiple HttpHandler beans : httpHandler,additionalHttpHandler'));
	}
	@Test
	void customizeReactiveWebServer() {
		this.contextRunner
			.withUserConfiguration(MockWebServerConfiguration.class, HttpHandlerConfiguration.class,
					ReactiveWebServerCustomization.class)
			.run((context) -> assertThat(context.getBean(MockReactiveWebServerFactory.class).getPort())
				.isEqualTo(9000));
	}
	@Test
	void defaultWebServerIsTomcat() {
		// Tomcat should be chosen over Netty if the Tomcat library is present.
		this.contextRunner.withUserConfiguration(HttpHandlerConfiguration.class)
			.withPropertyValues('server.port=0')
			.run((context) -> assertThat(context.getBean(ReactiveWebServerFactory.class))
				.isInstanceOf(TomcatReactiveWebServerFactory.class));
	}
	@Test
	void webServerFailsWithInvalidSslBundle() {
		this.contextRunner.withUserConfiguration(HttpHandlerConfiguration.class)
			.withPropertyValues('server.port=0', 'server.ssl.bundle=test-bundle')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure().getCause()).isInstanceOf(NoSuchSslBundleException.class)
					.withFailMessage('test');
			});
	}
	@Test
	void tomcatConnectorCustomizerBeanIsAddedToFactory() {
		ReactiveWebApplicationContextRunner runner = new ReactiveWebApplicationContextRunner(
				AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(HttpHandlerConfiguration.class, TomcatConnectorCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatReactiveWebServerFactory factory = context.getBean(TomcatReactiveWebServerFactory.class);
			TomcatConnectorCustomizer customizer = context.getBean('connectorCustomizer',
					TomcatConnectorCustomizer.class);
			assertThat(factory.getTomcatConnectorCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Connector.class));
		});
	}
	@Test
	void tomcatConnectorCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		ReactiveWebApplicationContextRunner runner = new ReactiveWebApplicationContextRunner(
				AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(HttpHandlerConfiguration.class,
					DoubleRegistrationTomcatConnectorCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatReactiveWebServerFactory factory = context.getBean(TomcatReactiveWebServerFactory.class);
			TomcatConnectorCustomizer customizer = context.getBean('connectorCustomizer',
					TomcatConnectorCustomizer.class);
			assertThat(factory.getTomcatConnectorCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Connector.class));
		});
	}
	@Test
	void tomcatContextCustomizerBeanIsAddedToFactory() {
		ReactiveWebApplicationContextRunner runner = new ReactiveWebApplicationContextRunner(
				AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(HttpHandlerConfiguration.class, TomcatContextCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatReactiveWebServerFactory factory = context.getBean(TomcatReactiveWebServerFactory.class);
			TomcatContextCustomizer customizer = context.getBean('contextCustomizer', TomcatContextCustomizer.class);
			assertThat(factory.getTomcatContextCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Context.class));
		});
	}
	@Test
	void tomcatContextCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		ReactiveWebApplicationContextRunner runner = new ReactiveWebApplicationContextRunner(
				AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(HttpHandlerConfiguration.class,
					DoubleRegistrationTomcatContextCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatReactiveWebServerFactory factory = context.getBean(TomcatReactiveWebServerFactory.class);
			TomcatContextCustomizer customizer = context.getBean('contextCustomizer', TomcatContextCustomizer.class);
			assertThat(factory.getTomcatContextCustomizers()).contains(customizer);
			then(customizer).should().customize(any(Context.class));
		});
	}
	@Test
	void tomcatProtocolHandlerCustomizerBeanIsAddedToFactory() {
		ReactiveWebApplicationContextRunner runner = new ReactiveWebApplicationContextRunner(
				AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(HttpHandlerConfiguration.class, TomcatProtocolHandlerCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatReactiveWebServerFactory factory = context.getBean(TomcatReactiveWebServerFactory.class);
			TomcatProtocolHandlerCustomizer<?> customizer = context.getBean('protocolHandlerCustomizer',
					TomcatProtocolHandlerCustomizer.class);
			assertThat(factory.getTomcatProtocolHandlerCustomizers()).contains(customizer);
			then(customizer).should().customize(any());
		});
	}
	@Test
	void tomcatProtocolHandlerCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		ReactiveWebApplicationContextRunner runner = new ReactiveWebApplicationContextRunner(
				AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withUserConfiguration(HttpHandlerConfiguration.class,
					DoubleRegistrationTomcatProtocolHandlerCustomizerConfiguration.class)
			.withPropertyValues('server.port: 0');
		runner.run((context) -> {
			TomcatReactiveWebServerFactory factory = context.getBean(TomcatReactiveWebServerFactory.class);
			TomcatProtocolHandlerCustomizer<?> customizer = context.getBean('protocolHandlerCustomizer',
					TomcatProtocolHandlerCustomizer.class);
			assertThat(factory.getTomcatProtocolHandlerCustomizers()).contains(customizer);
			then(customizer).should().customize(any());
		});
	}
	@Test
	void jettyServerCustomizerBeanIsAddedToFactory() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class))
			.withUserConfiguration(JettyServerCustomizerConfiguration.class, HttpHandlerConfiguration.class)
			.run((context) -> {
				JettyReactiveWebServerFactory factory = context.getBean(JettyReactiveWebServerFactory.class);
				assertThat(factory.getServerCustomizers()).hasSize(1);
			});
	}
	@Test
	void jettyServerCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class))
			.withUserConfiguration(DoubleRegistrationJettyServerCustomizerConfiguration.class,
					HttpHandlerConfiguration.class)
			.withPropertyValues('server.port=0')
			.run((context) -> {
				JettyReactiveWebServerFactory factory = context.getBean(JettyReactiveWebServerFactory.class);
				JettyServerCustomizer customizer = context.getBean('serverCustomizer', JettyServerCustomizer.class);
				assertThat(factory.getServerCustomizers()).contains(customizer);
				then(customizer).should().customize(any(Server.class));
			});
	}
	@Test
	void undertowBuilderCustomizerBeanIsAddedToFactory() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class, Server.class))
			.withUserConfiguration(UndertowBuilderCustomizerConfiguration.class, HttpHandlerConfiguration.class)
			.run((context) -> {
				UndertowReactiveWebServerFactory factory = context.getBean(UndertowReactiveWebServerFactory.class);
				assertThat(factory.getBuilderCustomizers()).hasSize(1);
			});
	}
	@Test
	void undertowBuilderCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(Tomcat.class, HttpServer.class, Server.class))
			.withUserConfiguration(DoubleRegistrationUndertowBuilderCustomizerConfiguration.class,
					HttpHandlerConfiguration.class)
			.withPropertyValues('server.port: 0')
			.run((context) -> {
				UndertowReactiveWebServerFactory factory = context.getBean(UndertowReactiveWebServerFactory.class);
				UndertowBuilderCustomizer customizer = context.getBean('builderCustomizer',
						UndertowBuilderCustomizer.class);
				assertThat(factory.getBuilderCustomizers()).contains(customizer);
				then(customizer).should().customize(any(Builder.class));
			});
	}
	@Test
	void nettyServerCustomizerBeanIsAddedToFactory() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(Tomcat.class, Server.class, Undertow.class))
			.withUserConfiguration(NettyServerCustomizerConfiguration.class, HttpHandlerConfiguration.class)
			.run((context) -> {
				NettyReactiveWebServerFactory factory = context.getBean(NettyReactiveWebServerFactory.class);
				assertThat(factory.getServerCustomizers()).hasSize(1);
			});
	}
	@Test
	void nettyServerCustomizerRegisteredAsBeanAndViaFactoryIsOnlyCalledOnce() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(Tomcat.class, Server.class, Undertow.class))
			.withUserConfiguration(DoubleRegistrationNettyServerCustomizerConfiguration.class,
					HttpHandlerConfiguration.class)
			.withPropertyValues('server.port: 0')
			.run((context) -> {
				NettyReactiveWebServerFactory factory = context.getBean(NettyReactiveWebServerFactory.class);
				NettyServerCustomizer customizer = context.getBean('serverCustomizer', NettyServerCustomizer.class);
				assertThat(factory.getServerCustomizers()).contains(customizer);
				then(customizer).should().apply(any(HttpServer.class));
			});
	}
	@Test
	void forwardedHeaderTransformerShouldBeConfigured() {
		this.contextRunner.withUserConfiguration(HttpHandlerConfiguration.class)
			.withPropertyValues('server.forward-headers-strategy=framework', 'server.port=0')
			.run((context) -> assertThat(context).hasSingleBean(ForwardedHeaderTransformer.class));
	}
	@Test
	void forwardedHeaderTransformerWhenStrategyNotFilterShouldNotBeConfigured() {
		this.contextRunner.withUserConfiguration(HttpHandlerConfiguration.class)
			.withPropertyValues('server.forward-headers-strategy=native', 'server.port=0')
			.run((context) -> assertThat(context).doesNotHaveBean(ForwardedHeaderTransformer.class));
	}
	@Test
	void forwardedHeaderTransformerWhenAlreadyRegisteredShouldBackOff() {
		this.contextRunner
			.withUserConfiguration(ForwardedHeaderTransformerConfiguration.class, HttpHandlerConfiguration.class)
			.withPropertyValues('server.forward-headers-strategy=framework', 'server.port=0')
			.run((context) -> assertThat(context).hasSingleBean(ForwardedHeaderTransformer.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class HttpHandlerConfiguration {
		@Bean
		HttpHandler httpHandler() {
			return mock(HttpHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TooManyHttpHandlers {
		@Bean
		HttpHandler additionalHttpHandler() {
			return mock(HttpHandler.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveWebServerCustomization {
		@Bean
		WebServerFactoryCustomizer<ConfigurableReactiveWebServerFactory> reactiveWebServerCustomizer() {
			return (factory) -> factory.setPort(9000);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MockWebServerConfiguration {
		@Bean
		MockReactiveWebServerFactory mockReactiveWebServerFactory() {
			return new MockReactiveWebServerFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatConnectorCustomizerConfiguration {
		@Bean
		TomcatConnectorCustomizer connectorCustomizer() {
			return mock(TomcatConnectorCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationTomcatConnectorCustomizerConfiguration {
		private final TomcatConnectorCustomizer customizer = mock(TomcatConnectorCustomizer.class);
		@Bean
		TomcatConnectorCustomizer connectorCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<TomcatReactiveWebServerFactory> tomcatCustomizer() {
			return (tomcat) -> tomcat.addConnectorCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatContextCustomizerConfiguration {
		@Bean
		TomcatContextCustomizer contextCustomizer() {
			return mock(TomcatContextCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationTomcatContextCustomizerConfiguration {
		private final TomcatContextCustomizer customizer = mock(TomcatContextCustomizer.class);
		@Bean
		TomcatContextCustomizer contextCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<TomcatReactiveWebServerFactory> tomcatCustomizer() {
			return (tomcat) -> tomcat.addContextCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatProtocolHandlerCustomizerConfiguration {
		@Bean
		TomcatProtocolHandlerCustomizer<?> protocolHandlerCustomizer() {
			return mock(TomcatProtocolHandlerCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationTomcatProtocolHandlerCustomizerConfiguration {
		private final TomcatProtocolHandlerCustomizer<?> customizer = mock(TomcatProtocolHandlerCustomizer.class);
		@Bean
		TomcatProtocolHandlerCustomizer<?> protocolHandlerCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<TomcatReactiveWebServerFactory> tomcatCustomizer() {
			return (tomcat) -> tomcat.addProtocolHandlerCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JettyServerCustomizerConfiguration {
		@Bean
		JettyServerCustomizer serverCustomizer() {
			return (server) -> {
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationJettyServerCustomizerConfiguration {
		private final JettyServerCustomizer customizer = mock(JettyServerCustomizer.class);
		@Bean
		JettyServerCustomizer serverCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<JettyReactiveWebServerFactory> jettyCustomizer() {
			return (jetty) -> jetty.addServerCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UndertowBuilderCustomizerConfiguration {
		@Bean
		UndertowBuilderCustomizer builderCustomizer() {
			return (builder) -> {
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationUndertowBuilderCustomizerConfiguration {
		private final UndertowBuilderCustomizer customizer = mock(UndertowBuilderCustomizer.class);
		@Bean
		UndertowBuilderCustomizer builderCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<UndertowReactiveWebServerFactory> undertowCustomizer() {
			return (undertow) -> undertow.addBuilderCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UndertowDeploymentInfoCustomizerConfiguration {
		@Bean
		UndertowDeploymentInfoCustomizer deploymentInfoCustomizer() {
			return (deploymentInfo) -> {
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NettyServerCustomizerConfiguration {
		@Bean
		NettyServerCustomizer serverCustomizer() {
			return (server) -> server;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleRegistrationNettyServerCustomizerConfiguration {
		private final NettyServerCustomizer customizer = mock(NettyServerCustomizer.class);
		DoubleRegistrationNettyServerCustomizerConfiguration() {
			given(this.customizer.apply(any(HttpServer.class))).willAnswer((invocation) -> invocation.getArgument(0));
		}
		@Bean
		NettyServerCustomizer serverCustomizer() {
			return this.customizer;
		}
		@Bean
		WebServerFactoryCustomizer<NettyReactiveWebServerFactory> nettyCustomizer() {
			return (netty) -> netty.addServerCustomizers(this.customizer);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ForwardedHeaderTransformerConfiguration {
		@Bean
		ForwardedHeaderTransformer testForwardedHeaderTransformer() {
			return new ForwardedHeaderTransformer();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.error;
/**
@ExtendWith(OutputCaptureExtension.class)
class DefaultErrorWebExceptionHandlerIntegrationTests {
	private static final MediaType TEXT_HTML_UTF8 = new MediaType('text', 'html', StandardCharsets.UTF_8);
	private final LogIdFilter logIdFilter = new LogIdFilter();
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactiveWebServerFactoryAutoConfiguration.class,
				HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class, ErrorWebFluxAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class, MustacheAutoConfiguration.class))
		.withPropertyValues('spring.main.web-application-type=reactive', 'server.port=0')
		.withUserConfiguration(Application.class);
	@Test
	void jsonError(CapturedOutput output) {
		this.contextRunner.run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
				.expectBody()
				.jsonPath('status')
				.isEqualTo('500')
				.jsonPath('error')
				.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase())
				.jsonPath('path')
				.isEqualTo(('/'))
				.jsonPath('message')
				.doesNotExist()
				.jsonPath('exception')
				.doesNotExist()
				.jsonPath('trace')
				.doesNotExist()
				.jsonPath('requestId')
				.isEqualTo(this.logIdFilter.getLogId());
			assertThat(output).contains('500 Server Error for HTTP GET \'/\'')
				.contains('java.lang.IllegalStateException: Expected!');
		});
	}
	@Test
	void notFound() {
		this.contextRunner.run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/notFound')
				.exchange()
				.expectStatus()
				.isNotFound()
				.expectBody()
				.jsonPath('status')
				.isEqualTo('404')
				.jsonPath('error')
				.isEqualTo(HttpStatus.NOT_FOUND.getReasonPhrase())
				.jsonPath('path')
				.isEqualTo(('/notFound'))
				.jsonPath('exception')
				.doesNotExist()
				.jsonPath('requestId')
				.isEqualTo(this.logIdFilter.getLogId());
		});
	}
	@Test
	void htmlError() {
		this.contextRunner.withPropertyValues('server.error.include-message=always').run((context) -> {
			WebTestClient client = getWebClient(context);
			String body = client.get()
				.uri('/')
				.accept(MediaType.TEXT_HTML)
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
				.expectHeader()
				.contentType(TEXT_HTML_UTF8)
				.expectBody(String.class)
				.returnResult()
				.getResponseBody();
			assertThat(body).contains('status: 500').contains('message: Expected!');
		});
	}
	@Test
	void bindingResultError() {
		this.contextRunner.run((context) -> {
			WebTestClient client = getWebClient(context);
			client.post()
				.uri('/bind')
				.contentType(MediaType.APPLICATION_JSON)
				.bodyValue('{}')
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody()
				.jsonPath('status')
				.isEqualTo('400')
				.jsonPath('error')
				.isEqualTo(HttpStatus.BAD_REQUEST.getReasonPhrase())
				.jsonPath('path')
				.isEqualTo(('/bind'))
				.jsonPath('exception')
				.doesNotExist()
				.jsonPath('errors')
				.doesNotExist()
				.jsonPath('message')
				.doesNotExist()
				.jsonPath('requestId')
				.isEqualTo(this.logIdFilter.getLogId());
		});
	}
	@Test
	void bindingResultErrorIncludeMessageAndErrors() {
		this.contextRunner
			.withPropertyValues('server.error.include-message=on-param', 'server.error.include-binding-errors=on-param')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.post()
					.uri('/bind?message=true&errors=true')
					.contentType(MediaType.APPLICATION_JSON)
					.bodyValue('{}')
					.exchange()
					.expectStatus()
					.isBadRequest()
					.expectBody()
					.jsonPath('status')
					.isEqualTo('400')
					.jsonPath('error')
					.isEqualTo(HttpStatus.BAD_REQUEST.getReasonPhrase())
					.jsonPath('path')
					.isEqualTo(('/bind'))
					.jsonPath('exception')
					.doesNotExist()
					.jsonPath('errors')
					.isArray()
					.jsonPath('message')
					.isNotEmpty()
					.jsonPath('requestId')
					.isEqualTo(this.logIdFilter.getLogId());
			});
	}
	@Test
	void includeStackTraceOnParam() {
		this.contextRunner
			.withPropertyValues('server.error.include-exception=true', 'server.error.include-stacktrace=on-param')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.get()
					.uri('/?trace=true')
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('500')
					.jsonPath('error')
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase())
					.jsonPath('exception')
					.isEqualTo(IllegalStateException.class.getName())
					.jsonPath('trace')
					.exists()
					.jsonPath('requestId')
					.isEqualTo(this.logIdFilter.getLogId());
			});
	}
	@Test
	void alwaysIncludeStackTrace() {
		this.contextRunner
			.withPropertyValues('server.error.include-exception=true', 'server.error.include-stacktrace=always')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.get()
					.uri('/?trace=false')
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('500')
					.jsonPath('error')
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase())
					.jsonPath('exception')
					.isEqualTo(IllegalStateException.class.getName())
					.jsonPath('trace')
					.exists()
					.jsonPath('requestId')
					.isEqualTo(this.logIdFilter.getLogId());
			});
	}
	@Test
	void neverIncludeStackTrace() {
		this.contextRunner
			.withPropertyValues('server.error.include-exception=true', 'server.error.include-stacktrace=never')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.get()
					.uri('/?trace=true')
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('500')
					.jsonPath('error')
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase())
					.jsonPath('exception')
					.isEqualTo(IllegalStateException.class.getName())
					.jsonPath('trace')
					.doesNotExist()
					.jsonPath('requestId')
					.isEqualTo(this.logIdFilter.getLogId());
			});
	}
	@Test
	void includeMessageOnParam() {
		this.contextRunner
			.withPropertyValues('server.error.include-exception=true', 'server.error.include-message=on-param')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.get()
					.uri('/?message=true')
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('500')
					.jsonPath('error')
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase())
					.jsonPath('exception')
					.isEqualTo(IllegalStateException.class.getName())
					.jsonPath('message')
					.isNotEmpty()
					.jsonPath('requestId')
					.isEqualTo(this.logIdFilter.getLogId());
			});
	}
	@Test
	void alwaysIncludeMessage() {
		this.contextRunner
			.withPropertyValues('server.error.include-exception=true', 'server.error.include-message=always')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.get()
					.uri('/?trace=false')
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('500')
					.jsonPath('error')
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase())
					.jsonPath('exception')
					.isEqualTo(IllegalStateException.class.getName())
					.jsonPath('message')
					.isNotEmpty()
					.jsonPath('requestId')
					.isEqualTo(this.logIdFilter.getLogId());
			});
	}
	@Test
	void neverIncludeMessage() {
		this.contextRunner
			.withPropertyValues('server.error.include-exception=true', 'server.error.include-message=never')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.get()
					.uri('/?trace=true')
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectBody()
					.jsonPath('status')
					.isEqualTo('500')
					.jsonPath('error')
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR.getReasonPhrase())
					.jsonPath('exception')
					.isEqualTo(IllegalStateException.class.getName())
					.jsonPath('message')
					.doesNotExist()
					.jsonPath('requestId')
					.isEqualTo(this.logIdFilter.getLogId());
			});
	}
	@Test
	void statusException() {
		this.contextRunner.withPropertyValues('server.error.include-exception=true').run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/badRequest')
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody()
				.jsonPath('status')
				.isEqualTo('400')
				.jsonPath('error')
				.isEqualTo(HttpStatus.BAD_REQUEST.getReasonPhrase())
				.jsonPath('exception')
				.isEqualTo(ResponseStatusException.class.getName())
				.jsonPath('requestId')
				.isEqualTo(this.logIdFilter.getLogId());
		});
	}
	@Test
	void defaultErrorView() {
		this.contextRunner
			.withPropertyValues('spring.mustache.prefix=classpath:/unknown/', 'server.error.include-stacktrace=always',
					'server.error.include-message=always')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				String body = client.get()
					.uri('/')
					.accept(MediaType.TEXT_HTML)
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectHeader()
					.contentType(TEXT_HTML_UTF8)
					.expectBody(String.class)
					.returnResult()
					.getResponseBody();
				assertThat(body).contains('Whitelabel Error Page')
					.contains(this.logIdFilter.getLogId())
					.contains('<div>Expected!</div>')
					.contains('<div style="white-space:pre-wrap;">java.lang.IllegalStateException');
			});
	}
	@Test
	void escapeHtmlInDefaultErrorView() {
		this.contextRunner
			.withPropertyValues('spring.mustache.prefix=classpath:/unknown/', 'server.error.include-message=always')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				String body = client.get()
					.uri('/html')
					.accept(MediaType.TEXT_HTML)
					.exchange()
					.expectStatus()
					.isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR)
					.expectHeader()
					.contentType(TEXT_HTML_UTF8)
					.expectBody(String.class)
					.returnResult()
					.getResponseBody();
				assertThat(body).contains('Whitelabel Error Page')
					.contains(this.logIdFilter.getLogId())
					.doesNotContain('<script>')
					.contains('&lt;script&gt;');
			});
	}
	@Test
	void testExceptionWithNullMessage() {
		this.contextRunner.withPropertyValues('spring.mustache.prefix=classpath:/unknown/').run((context) -> {
			WebTestClient client = getWebClient(context);
			String body = client.get()
				.uri('/notfound')
				.accept(MediaType.TEXT_HTML)
				.exchange()
				.expectStatus()
				.isNotFound()
				.expectHeader()
				.contentType(TEXT_HTML_UTF8)
				.expectBody(String.class)
				.returnResult()
				.getResponseBody();
			assertThat(body).contains('Whitelabel Error Page')
				.contains(this.logIdFilter.getLogId())
				.contains('type=Not Found, status=404');
		});
	}
	@Test
	void responseCommitted() {
		this.contextRunner.run((context) -> {
			WebTestClient client = getWebClient(context);
			assertThatExceptionOfType(RuntimeException.class)
				.isThrownBy(() -> client.get().uri('/commit').exchange().expectStatus())
				.withCauseInstanceOf(FailureAfterResponseCompletedException.class)
				.withMessageContaining('Error occurred after response was completed');
		});
	}
	@Test
	void whitelabelDisabled() {
		this.contextRunner
			.withPropertyValues('server.error.whitelabel.enabled=false', 'spring.mustache.prefix=classpath:/unknown/')
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				client.get()
					.uri('/notfound')
					.accept(MediaType.TEXT_HTML)
					.exchange()
					.expectStatus()
					.isNotFound()
					.expectBody()
					.isEmpty();
			});
	}
	@Test
	void exactStatusTemplateErrorPage() {
		this.contextRunner
			.withPropertyValues('server.error.whitelabel.enabled=false',
					'spring.mustache.prefix=' + getErrorTemplatesLocation())
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				String body = client.get()
					.uri('/notfound')
					.accept(MediaType.TEXT_HTML)
					.exchange()
					.expectStatus()
					.isNotFound()
					.expectBody(String.class)
					.returnResult()
					.getResponseBody();
				assertThat(body).contains('404 page');
			});
	}
	@Test
	void seriesStatusTemplateErrorPage() {
		this.contextRunner
			.withPropertyValues('server.error.whitelabel.enabled=false',
					'spring.mustache.prefix=' + getErrorTemplatesLocation())
			.run((context) -> {
				WebTestClient client = getWebClient(context);
				String body = client.get()
					.uri('/badRequest')
					.accept(MediaType.TEXT_HTML)
					.exchange()
					.expectStatus()
					.isBadRequest()
					.expectBody(String.class)
					.returnResult()
					.getResponseBody();
				assertThat(body).contains('4xx page');
			});
	}
	@Test
	void invalidAcceptMediaType() {
		this.contextRunner.run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/notfound')
				.header('Accept', 'v=3.0')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.NOT_FOUND);
		});
	}
	@Test
	void defaultErrorAttributesSubclassUsingDelegation() {
		this.contextRunner.withUserConfiguration(CustomErrorAttributesWithDelegation.class).run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/badRequest')
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody()
				.jsonPath('status')
				.isEqualTo('400')
				.jsonPath('error')
				.isEqualTo('custom error')
				.jsonPath('newAttribute')
				.isEqualTo('value')
				.jsonPath('path')
				.doesNotExist();
		});
	}
	@Test
	void defaultErrorAttributesSubclassWithoutDelegation() {
		this.contextRunner.withUserConfiguration(CustomErrorAttributesWithoutDelegation.class).run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/badRequest')
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody()
				.jsonPath('status')
				.isEqualTo('400')
				.jsonPath('timestamp')
				.doesNotExist()
				.jsonPath('error')
				.isEqualTo('custom error')
				.jsonPath('path')
				.doesNotExist();
		});
	}
	@Test
	void customErrorWebExceptionHandlerWithoutStatus() {
		this.contextRunner.withUserConfiguration(CustomErrorWebExceptionHandlerWithoutStatus.class).run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/badRequest')
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody()
				.jsonPath('status')
				.doesNotExist();
		});
	}
	@Test
	void customErrorAttributesWithoutStatus() {
		this.contextRunner.withUserConfiguration(CustomErrorAttributesWithoutStatus.class).run((context) -> {
			WebTestClient client = getWebClient(context);
			client.get()
				.uri('/badRequest')
				.exchange()
				.expectStatus()
				.isBadRequest()
				.expectBody()
				.jsonPath('status')
				.doesNotExist();
		});
	}
	private String getErrorTemplatesLocation() {
		String packageName = getClass().getPackage().getName();
		return 'classpath:/' + packageName.replace(".", "/") + '/templates/';
	}
	private WebTestClient getWebClient(AssertableReactiveWebApplicationContext context) {
		return WebTestClient.bindToApplicationContext(context).webFilter(this.logIdFilter).build();
	}
	private static final class LogIdFilter implements WebFilter {
		private String logId;
		@Override
		public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
			this.logId = exchange.getRequest().getId();
			return chain.filter(exchange);
		}
		String getLogId() {
			return this.logId;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Application {
		@RestController
		static class ErrorController {
			@GetMapping('/')
			String home() {
				throw new IllegalStateException('Expected!');
			}
			@GetMapping('/badRequest')
			Mono<String> badRequest() {
				return Mono.error(new ResponseStatusException(HttpStatus.BAD_REQUEST));
			}
			@GetMapping('/commit')
			Mono<Void> commit(ServerWebExchange exchange) {
				return exchange.getResponse()
					.setComplete()
					.then(Mono.error(new IllegalStateException('already committed!')));
			}
			@GetMapping('/html')
			String htmlEscape() {
				throw new IllegalStateException('<script>');
			}
			@PostMapping(path = '/bind', produces = 'application/json')
			@ResponseBody
			String bodyValidation(@Valid @RequestBody DummyBody body) {
				return body.getContent();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomErrorAttributesWithDelegation {
		@Bean
		ErrorAttributes errorAttributes() {
			return new DefaultErrorAttributes() {
				@Override
				public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
					Map<String, Object> errorAttributes = super.getErrorAttributes(request, options);
					errorAttributes.put('error', 'custom error');
					errorAttributes.put('newAttribute', 'value');
					errorAttributes.remove('path');
					return errorAttributes;
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomErrorAttributesWithoutDelegation {
		@Bean
		ErrorAttributes errorAttributes() {
			return new DefaultErrorAttributes() {
				@Override
				public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
					Map<String, Object> errorAttributes = new HashMap<>();
					errorAttributes.put('status', 400);
					errorAttributes.put('error', 'custom error');
					return errorAttributes;
				}
			};
		}
	}
	static class CustomErrorWebExceptionHandlerWithoutStatus {
		@Bean
		@Order(-1)
		ErrorWebExceptionHandler errorWebExceptionHandler(ServerProperties serverProperties,
				ErrorAttributes errorAttributes, WebProperties webProperties,
				ObjectProvider<ViewResolver> viewResolvers, ServerCodecConfigurer serverCodecConfigurer,
				ApplicationContext applicationContext) {
			DefaultErrorWebExceptionHandler exceptionHandler = new DefaultErrorWebExceptionHandler(errorAttributes,
					webProperties.getResources(), serverProperties.getError(), applicationContext) {
				@Override
				protected ErrorAttributeOptions getErrorAttributeOptions(ServerRequest request, MediaType mediaType) {
					return super.getErrorAttributeOptions(request, mediaType).excluding(Include.STATUS, Include.ERROR);
				}
			};
			exceptionHandler.setViewResolvers(viewResolvers.orderedStream().toList());
			exceptionHandler.setMessageWriters(serverCodecConfigurer.getWriters());
			exceptionHandler.setMessageReaders(serverCodecConfigurer.getReaders());
			return exceptionHandler;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomErrorAttributesWithoutStatus {
		@Bean
		ErrorAttributes errorAttributes() {
			return new DefaultErrorAttributes() {
				@Override
				public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
					Map<String, Object> attributes = new LinkedHashMap<>(super.getErrorAttributes(request, options));
					attributes.remove('status');
					return attributes;
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.error;
/**
class DefaultErrorWebExceptionHandlerTests {
	@Test
	void nonStandardErrorStatusCodeShouldNotFail() {
		ErrorAttributes errorAttributes = mock(ErrorAttributes.class);
		given(errorAttributes.getErrorAttributes(any(), any())).willReturn(Collections.singletonMap('status', 498));
		Resources resourceProperties = new Resources();
		ErrorProperties errorProperties = new ErrorProperties();
		ApplicationContext context = new AnnotationConfigReactiveWebApplicationContext();
		DefaultErrorWebExceptionHandler exceptionHandler = new DefaultErrorWebExceptionHandler(errorAttributes,
				resourceProperties, errorProperties, context);
		setupViewResolver(exceptionHandler);
		ServerWebExchange exchange = MockServerWebExchange
			.from(MockServerHttpRequest.get('/some-other-path').accept(MediaType.TEXT_HTML));
		exceptionHandler.handle(exchange, new RuntimeException()).block();
	}
	private void setupViewResolver(DefaultErrorWebExceptionHandler exceptionHandler) {
		View view = mock(View.class);
		given(view.render(any(), any(), any())).willReturn(Mono.empty());
		ViewResolver viewResolver = mock(ViewResolver.class);
		given(viewResolver.resolveViewName(any(), any())).willReturn(Mono.just(view));
		exceptionHandler.setViewResolvers(Collections.singletonList(viewResolver));
	}
	@Test
	void acceptsTextHtmlShouldNotConsiderMediaAllEvenWithQuality() {
		ErrorAttributes errorAttributes = mock(ErrorAttributes.class);
		Resources resourceProperties = new Resources();
		ErrorProperties errorProperties = new ErrorProperties();
		ApplicationContext context = new AnnotationConfigReactiveWebApplicationContext();
		DefaultErrorWebExceptionHandler exceptionHandler = new DefaultErrorWebExceptionHandler(errorAttributes,
				resourceProperties, errorProperties, context);
		MediaType allWithQuality = new MediaType(MediaType.ALL.getType(), MediaType.ALL.getSubtype(), 0.9);
		MockServerWebExchange exchange = MockServerWebExchange
			.from(MockServerHttpRequest.get('/test').accept(allWithQuality));
		List<HttpMessageReader<?>> readers = ServerCodecConfigurer.create().getReaders();
		ServerRequest request = ServerRequest.create(exchange, readers);
		assertThat(exceptionHandler.acceptsTextHtml().test(request)).isFalse();
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.error;
public class DummyBody {
	@NotNull
	private String content;
	public String getContent() {
		return this.content;
	}
	public void setContent(String content) {
		this.content = content;
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class ReactiveMultipartAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactiveMultipartAutoConfiguration.class));
	@Test
	void shouldNotProvideCustomizerForNonReactiveApp() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(ReactiveMultipartAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(CodecCustomizer.class));
	}
	@Test
	void shouldNotProvideCustomizerWhenWebFluxNotAvailable() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(WebFluxConfigurer.class))
			.run((context) -> assertThat(context).doesNotHaveBean(CodecCustomizer.class));
	}
	@Test
	void shouldConfigureMultipartPropertiesForDefaultReader() {
		this.contextRunner
			.withPropertyValues('spring.webflux.multipart.max-in-memory-size=1GB',
					'spring.webflux.multipart.max-headers-size=16KB',
					'spring.webflux.multipart.max-disk-usage-per-part=3GB', 'spring.webflux.multipart.max-parts=7',
					'spring.webflux.multipart.headers-charset:UTF_16')
			.run((context) -> {
				CodecCustomizer customizer = context.getBean(CodecCustomizer.class);
				DefaultServerCodecConfigurer configurer = new DefaultServerCodecConfigurer();
				customizer.customize(configurer);
				DefaultPartHttpMessageReader partReader = getDefaultPartReader(configurer);
				assertThat(partReader).hasFieldOrPropertyWithValue('maxParts', 7);
				assertThat(partReader).hasFieldOrPropertyWithValue('maxHeadersSize',
						Math.toIntExact(DataSize.ofKilobytes(16).toBytes()));
				assertThat(partReader).hasFieldOrPropertyWithValue('headersCharset', StandardCharsets.UTF_16);
				assertThat(partReader).hasFieldOrPropertyWithValue('maxInMemorySize',
						Math.toIntExact(DataSize.ofGigabytes(1).toBytes()));
				assertThat(partReader).hasFieldOrPropertyWithValue('maxDiskUsagePerPart',
						DataSize.ofGigabytes(3).toBytes());
			});
	}
	@Test
	void shouldConfigureMultipartPropertiesForPartEventReader() {
		this.contextRunner
			.withPropertyValues('spring.webflux.multipart.max-in-memory-size=1GB',
					'spring.webflux.multipart.max-headers-size=16KB',
					'spring.webflux.multipart.max-disk-usage-per-part=3GB', 'spring.webflux.multipart.max-parts=7',
					'spring.webflux.multipart.headers-charset:UTF_16')
			.run((context) -> {
				CodecCustomizer customizer = context.getBean(CodecCustomizer.class);
				DefaultServerCodecConfigurer configurer = new DefaultServerCodecConfigurer();
				customizer.customize(configurer);
				PartEventHttpMessageReader partReader = getPartEventReader(configurer);
				assertThat(partReader).hasFieldOrPropertyWithValue('maxParts', 7);
				assertThat(partReader).hasFieldOrPropertyWithValue('maxHeadersSize',
						Math.toIntExact(DataSize.ofKilobytes(16).toBytes()));
				assertThat(partReader).hasFieldOrPropertyWithValue('headersCharset', StandardCharsets.UTF_16);
				assertThat(partReader).hasFieldOrPropertyWithValue('maxInMemorySize',
						Math.toIntExact(DataSize.ofGigabytes(1).toBytes()));
				assertThat(partReader).hasFieldOrPropertyWithValue('maxPartSize', DataSize.ofGigabytes(3).toBytes());
			});
	}
	private DefaultPartHttpMessageReader getDefaultPartReader(DefaultServerCodecConfigurer codecConfigurer) {
		return codecConfigurer.getReaders()
			.stream()
			.filter(DefaultPartHttpMessageReader.class::isInstance)
			.map(DefaultPartHttpMessageReader.class::cast)
			.findFirst()
			.orElseThrow(() -> new IllegalStateException('Could not find DefaultPartHttpMessageReader'));
	}
	private PartEventHttpMessageReader getPartEventReader(DefaultServerCodecConfigurer codecConfigurer) {
		return codecConfigurer.getReaders()
			.stream()
			.filter(PartEventHttpMessageReader.class::isInstance)
			.map(PartEventHttpMessageReader.class::cast)
			.findFirst()
			.orElseThrow(() -> new IllegalStateException('Could not find PartEventHttpMessageReader'));
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class ReactiveMultipartPropertiesTests {
	@Test
	void defaultValuesAreConsistent() {
		ReactiveMultipartProperties multipartProperties = new ReactiveMultipartProperties();
		DefaultPartHttpMessageReader defaultPartHttpMessageReader = new DefaultPartHttpMessageReader();
		assertThat(defaultPartHttpMessageReader).hasFieldOrPropertyWithValue('maxInMemorySize',
				(int) multipartProperties.getMaxInMemorySize().toBytes());
		assertThat(defaultPartHttpMessageReader).hasFieldOrPropertyWithValue('maxHeadersSize',
				(int) multipartProperties.getMaxHeadersSize().toBytes());
		assertThat(defaultPartHttpMessageReader).hasFieldOrPropertyWithValue('maxDiskUsagePerPart',
				multipartProperties.getMaxDiskUsagePerPart().toBytes());
		assertThat(defaultPartHttpMessageReader).hasFieldOrPropertyWithValue('maxParts',
				multipartProperties.getMaxParts());
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class WelcomePageRouterFunctionFactoryTests {
	private StaticApplicationContext applicationContext;
	private final String[] noIndexLocations = { 'classpath:/' };
	private final String[] indexLocations = { 'classpath:/public/', 'classpath:/welcome-page/' };
	@BeforeEach
	void setup() {
		this.applicationContext = new StaticApplicationContext();
		this.applicationContext.refresh();
	}
	@Test
	void handlesRequestForStaticPageThatAcceptsTextHtml() {
		WebTestClient client = withStaticIndex();
		client.get()
			.uri('/')
			.accept(MediaType.TEXT_HTML)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('welcome-page-static');
	}
	@Test
	void handlesRequestForStaticPageThatAcceptsAll() {
		WebTestClient client = withStaticIndex();
		client.get()
			.uri('/')
			.accept(MediaType.ALL)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('welcome-page-static');
	}
	@Test
	void doesNotHandleRequestThatDoesNotAcceptTextHtml() {
		WebTestClient client = withStaticIndex();
		client.get().uri('/').accept(MediaType.APPLICATION_JSON).exchange().expectStatus().isNotFound();
	}
	@Test
	void handlesRequestWithNoAcceptHeader() {
		WebTestClient client = withStaticIndex();
		client.get()
			.uri('/')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('welcome-page-static');
	}
	@Test
	void handlesRequestWithEmptyAcceptHeader() {
		WebTestClient client = withStaticIndex();
		client.get()
			.uri('/')
			.header(HttpHeaders.ACCEPT, '')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('welcome-page-static');
	}
	@Test
	void producesNotFoundResponseWhenThereIsNoWelcomePage() {
		WelcomePageRouterFunctionFactory factory = factoryWithoutTemplateSupport(this.noIndexLocations, '/**');
		assertThat(factory.createRouterFunction()).isNull();
	}
	@Test
	void handlesRequestForTemplateThatAcceptsTextHtml() {
		WebTestClient client = withTemplateIndex();
		client.get()
			.uri('/')
			.accept(MediaType.TEXT_HTML)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('welcome-page-template');
	}
	@Test
	void handlesRequestForTemplateThatAcceptsAll() {
		WebTestClient client = withTemplateIndex();
		client.get()
			.uri('/')
			.accept(MediaType.ALL)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('welcome-page-template');
	}
	@Test
	void prefersAStaticResourceToATemplate() {
		WebTestClient client = withStaticAndTemplateIndex();
		client.get()
			.uri('/')
			.accept(MediaType.ALL)
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.isEqualTo('welcome-page-static');
	}
	private WebTestClient withStaticIndex() {
		WelcomePageRouterFunctionFactory factory = factoryWithoutTemplateSupport(this.indexLocations, '/**');
		return WebTestClient.bindToRouterFunction(factory.createRouterFunction()).build();
	}
	private WebTestClient withTemplateIndex() {
		WelcomePageRouterFunctionFactory factory = factoryWithTemplateSupport(this.noIndexLocations);
		TestViewResolver testViewResolver = new TestViewResolver();
		return WebTestClient.bindToRouterFunction(factory.createRouterFunction())
			.handlerStrategies(HandlerStrategies.builder().viewResolver(testViewResolver).build())
			.build();
	}
	private WebTestClient withStaticAndTemplateIndex() {
		WelcomePageRouterFunctionFactory factory = factoryWithTemplateSupport(this.indexLocations);
		TestViewResolver testViewResolver = new TestViewResolver();
		return WebTestClient.bindToRouterFunction(factory.createRouterFunction())
			.handlerStrategies(HandlerStrategies.builder().viewResolver(testViewResolver).build())
			.build();
	}
	private WelcomePageRouterFunctionFactory factoryWithoutTemplateSupport(String[] locations,
			String staticPathPattern) {
		return new WelcomePageRouterFunctionFactory(new TestTemplateAvailabilityProviders(), this.applicationContext,
				locations, staticPathPattern);
	}
	private WelcomePageRouterFunctionFactory factoryWithTemplateSupport(String[] locations) {
		return new WelcomePageRouterFunctionFactory(new TestTemplateAvailabilityProviders('index'),
				this.applicationContext, locations, '/**');
	}
	static class TestTemplateAvailabilityProviders extends TemplateAvailabilityProviders {
		TestTemplateAvailabilityProviders() {
			super(Collections.emptyList());
		}
		TestTemplateAvailabilityProviders(String viewName) {
			this((view, environment, classLoader, resourceLoader) -> view.equals(viewName));
		}
		TestTemplateAvailabilityProviders(TemplateAvailabilityProvider provider) {
			super(Collections.singletonList(provider));
		}
	}
	static class TestViewResolver implements ViewResolver {
		@Override
		public Mono<View> resolveViewName(String viewName, Locale locale) {
			return Mono.just(new TestView());
		}
	}
	static class TestView implements View {
		private final DataBufferFactory bufferFactory = new DefaultDataBufferFactory();
		@Override
		public Mono<Void> render(Map<String, ?> model, MediaType contentType, ServerWebExchange exchange) {
			DataBuffer buffer = this.bufferFactory.wrap('welcome-page-template'.getBytes(StandardCharsets.UTF_8));
			return exchange.getResponse().writeWith(Mono.just(buffer));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class ReactiveWebServerFactoryCustomizerTests {
	private final ServerProperties properties = new ServerProperties();
	private final SslBundles sslBundles = new DefaultSslBundleRegistry();
	private ReactiveWebServerFactoryCustomizer customizer;
	@BeforeEach
	void setup() {
		this.customizer = new ReactiveWebServerFactoryCustomizer(this.properties, this.sslBundles);
	}
	@Test
	void testCustomizeServerPort() {
		ConfigurableReactiveWebServerFactory factory = mock(ConfigurableReactiveWebServerFactory.class);
		this.properties.setPort(9000);
		this.customizer.customize(factory);
		then(factory).should().setPort(9000);
	}
	@Test
	void testCustomizeServerAddress() {
		ConfigurableReactiveWebServerFactory factory = mock(ConfigurableReactiveWebServerFactory.class);
		InetAddress address = InetAddress.getLoopbackAddress();
		this.properties.setAddress(address);
		this.customizer.customize(factory);
		then(factory).should().setAddress(address);
	}
	@Test
	void testCustomizeServerSsl() {
		ConfigurableReactiveWebServerFactory factory = mock(ConfigurableReactiveWebServerFactory.class);
		Ssl ssl = mock(Ssl.class);
		this.properties.setSsl(ssl);
		this.customizer.customize(factory);
		then(factory).should().setSsl(ssl);
		then(factory).should().setSslBundles(this.sslBundles);
	}
	@Test
	void whenShutdownPropertyIsSetThenShutdownIsCustomized() {
		this.properties.setShutdown(Shutdown.GRACEFUL);
		ConfigurableReactiveWebServerFactory factory = mock(ConfigurableReactiveWebServerFactory.class);
		this.customizer.customize(factory);
		then(factory).should().setShutdown(assertArg((shutdown) -> assertThat(shutdown).isEqualTo(Shutdown.GRACEFUL)));
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
public class MockReactiveWebServerFactory extends AbstractReactiveWebServerFactory {
	private MockReactiveWebServer webServer;
	@Override
	public WebServer getWebServer(HttpHandler httpHandler) {
		this.webServer = spy(new MockReactiveWebServer(httpHandler, getPort()));
		return this.webServer;
	}
	public MockReactiveWebServer getWebServer() {
		return this.webServer;
	}
	static class MockReactiveWebServer implements WebServer {
		private final int port;
		private HttpHandler httpHandler;
		private Map<String, HttpHandler> httpHandlerMap;
		MockReactiveWebServer(HttpHandler httpHandler, int port) {
			this.httpHandler = httpHandler;
			this.port = port;
		}
		MockReactiveWebServer(Map<String, HttpHandler> httpHandlerMap, int port) {
			this.httpHandlerMap = httpHandlerMap;
			this.port = port;
		}
		HttpHandler getHttpHandler() {
			return this.httpHandler;
		}
		Map<String, HttpHandler> getHttpHandlerMap() {
			return this.httpHandlerMap;
		}
		@Override
		public void start() {
		}
		@Override
		public void stop() {
		}
		@Override
		public int getPort() {
			return this.port;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class WebClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ClientHttpConnectorAutoConfiguration.class,
				WebClientAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void shouldCreateBuilder() {
		this.contextRunner.run((context) -> {
			WebClient.Builder builder = context.getBean(WebClient.Builder.class);
			WebClient webClient = builder.build();
			assertThat(webClient).isNotNull();
		});
	}
	@Test
	void shouldCustomizeClientCodecs() {
		this.contextRunner.withUserConfiguration(CodecConfiguration.class).run((context) -> {
			WebClient.Builder builder = context.getBean(WebClient.Builder.class);
			CodecCustomizer codecCustomizer = context.getBean(CodecCustomizer.class);
			WebClientCodecCustomizer clientCustomizer = context.getBean(WebClientCodecCustomizer.class);
			builder.build();
			assertThat(clientCustomizer).isNotNull();
			then(codecCustomizer).should().customize(any(CodecConfigurer.class));
		});
	}
	@Test
	void webClientShouldApplyCustomizers() {
		this.contextRunner.withUserConfiguration(WebClientCustomizerConfig.class).run((context) -> {
			WebClient.Builder builder = context.getBean(WebClient.Builder.class);
			WebClientCustomizer customizer = context.getBean('webClientCustomizer', WebClientCustomizer.class);
			builder.build();
			then(customizer).should().customize(any(WebClient.Builder.class));
		});
	}
	@Test
	void shouldGetPrototypeScopedBean() {
		this.contextRunner.withUserConfiguration(WebClientCustomizerConfig.class).run((context) -> {
			WebClient.Builder firstBuilder = context.getBean(WebClient.Builder.class);
			WebClient.Builder secondBuilder = context.getBean(WebClient.Builder.class);
			assertThat(firstBuilder).isNotEqualTo(secondBuilder);
		});
	}
	@Test
	void shouldNotCreateClientBuilderIfAlreadyPresent() {
		this.contextRunner.withUserConfiguration(WebClientCustomizerConfig.class, CustomWebClientBuilderConfig.class)
			.run((context) -> {
				WebClient.Builder builder = context.getBean(WebClient.Builder.class);
				assertThat(builder).isInstanceOf(MyWebClientBuilder.class);
			});
	}
	@Test
	void shouldCreateWebClientSsl() {
		this.contextRunner.run((context) -> {
			WebClientSsl webClientSsl = context.getBean(WebClientSsl.class);
			assertThat(webClientSsl).isInstanceOf(AutoConfiguredWebClientSsl.class);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CodecConfiguration {
		@Bean
		CodecCustomizer myCodecCustomizer() {
			return mock(CodecCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebClientCustomizerConfig {
		@Bean
		WebClientCustomizer webClientCustomizer() {
			return mock(WebClientCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebClientBuilderConfig {
		@Bean
		MyWebClientBuilder myWebClientBuilder() {
			return mock(MyWebClientBuilder.class);
		}
	}
	interface MyWebClientBuilder extends WebClient.Builder {
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class ClientHttpConnectorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ClientHttpConnectorAutoConfiguration.class));
	@Test
	void whenReactorIsAvailableThenReactorBeansAreDefined() {
		this.contextRunner.run((context) -> {
			BeanDefinition customizerDefinition = context.getBeanFactory()
				.getBeanDefinition('webClientHttpConnectorCustomizer');
			assertThat(customizerDefinition.isLazyInit()).isTrue();
			BeanDefinition connectorDefinition = context.getBeanFactory().getBeanDefinition('webClientHttpConnector');
			assertThat(connectorDefinition.isLazyInit()).isTrue();
			assertThat(context).hasBean('reactorClientHttpConnectorFactory');
			assertThat(context).hasSingleBean(ReactorResourceFactory.class);
		});
	}
	@Test
	void whenReactorIsUnavailableThenHttpClientBeansAreDefined() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(HttpClient.class)).run((context) -> {
			BeanDefinition customizerDefinition = context.getBeanFactory()
				.getBeanDefinition('webClientHttpConnectorCustomizer');
			assertThat(customizerDefinition.isLazyInit()).isTrue();
			BeanDefinition connectorDefinition = context.getBeanFactory().getBeanDefinition('webClientHttpConnector');
			assertThat(connectorDefinition.isLazyInit()).isTrue();
			assertThat(context).hasBean('httpComponentsClientHttpConnectorFactory');
		});
	}
	@Test
	void whenReactorAndHttpClientBeansAreUnavailableThenJdkClientBeansAreDefined() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(HttpClient.class, HttpAsyncClients.class))
			.run((context) -> {
				BeanDefinition customizerDefinition = context.getBeanFactory()
					.getBeanDefinition('webClientHttpConnectorCustomizer');
				assertThat(customizerDefinition.isLazyInit()).isTrue();
				BeanDefinition connectorDefinition = context.getBeanFactory()
					.getBeanDefinition('webClientHttpConnector');
				assertThat(connectorDefinition.isLazyInit()).isTrue();
				assertThat(context).hasBean('jdkClientHttpConnectorFactory');
			});
	}
	@Test
	void shouldCreateHttpClientBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(ReactorResourceFactory.class);
			assertThat(context).hasSingleBean(ClientHttpConnector.class);
			WebClientCustomizer clientCustomizer = context.getBean(WebClientCustomizer.class);
			WebClient.Builder builder = mock(WebClient.Builder.class);
			clientCustomizer.customize(builder);
			then(builder).should().clientConnector(any(ReactorClientHttpConnector.class));
		});
	}
	@Test
	void shouldNotOverrideCustomClientConnector() {
		this.contextRunner.withUserConfiguration(CustomClientHttpConnectorConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(ClientHttpConnector.class).hasBean('customConnector');
			WebClientCustomizer clientCustomizer = context.getBean(WebClientCustomizer.class);
			WebClient.Builder builder = mock(WebClient.Builder.class);
			clientCustomizer.customize(builder);
			then(builder).should().clientConnector(any(ClientHttpConnector.class));
		});
	}
	@Test
	void shouldNotOverrideCustomClientConnectorFactory() {
		this.contextRunner.withUserConfiguration(CustomClientHttpConnectorFactoryConfig.class).run((context) -> {
			assertThat(context).hasSingleBean(ClientHttpConnectorFactory.class)
				.hasBean('customConnector')
				.doesNotHaveBean(ReactorResourceFactory.class);
			WebClientCustomizer clientCustomizer = context.getBean(WebClientCustomizer.class);
			WebClient.Builder builder = mock(WebClient.Builder.class);
			clientCustomizer.customize(builder);
			then(builder).should().clientConnector(any(ClientHttpConnector.class));
		});
	}
	@Test
	void shouldUseCustomReactorResourceFactory() {
		this.contextRunner.withUserConfiguration(CustomReactorResourceConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(ClientHttpConnector.class)
				.hasSingleBean(ReactorResourceFactory.class)
				.hasBean('customReactorResourceFactory'));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomClientHttpConnectorConfig {
		@Bean
		ClientHttpConnector customConnector() {
			return mock(ClientHttpConnector.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomClientHttpConnectorFactoryConfig {
		@Bean
		ClientHttpConnectorFactory<?> customConnector() {
			return (sslBundle) -> mock(ClientHttpConnector.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomReactorResourceConfig {
		@Bean
		ReactorResourceFactory customReactorResourceFactory() {
			return new ReactorResourceFactory();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class ClientHttpConnectorFactoryConfigurationTests {
	@Test
	void shouldApplyHttpClientMapper() {
		JksSslStoreDetails storeDetails = JksSslStoreDetails.forLocation('classpath:test.jks');
		JksSslStoreBundle stores = new JksSslStoreBundle(storeDetails, storeDetails);
		SslBundle sslBundle = spy(SslBundle.of(stores, SslBundleKey.of('password')));
		new ReactiveWebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(ClientHttpConnectorFactoryConfiguration.ReactorNetty.class))
			.withUserConfiguration(CustomHttpClientMapper.class)
			.run((context) -> {
				context.getBean(ReactorClientHttpConnectorFactory.class).createClientHttpConnector(sslBundle);
				assertThat(CustomHttpClientMapper.called).isTrue();
				then(sslBundle).should().getManagers();
			});
	}
	@Test
	void shouldNotConfigureReactiveHttpClient5WhenHttpCore5ReactiveJarIsMissing() {
		new ReactiveWebApplicationContextRunner()
			.withClassLoader(new FilteredClassLoader('org.apache.hc.core5.reactive'))
			.withConfiguration(AutoConfigurations.of(ClientHttpConnectorFactoryConfiguration.HttpClient5.class))
			.run((context) -> assertThat(context).doesNotHaveBean(HttpComponentsClientHttpConnector.class));
	}
	static class CustomHttpClientMapper {
		static boolean called = false;
		@Bean
		ReactorNettyHttpClientMapper clientMapper() {
			return (client) -> {
				called = true;
				return client.baseUrl('/test');
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class JdkClientHttpConnectorFactoryTests extends AbstractClientHttpConnectorFactoryTests {
	@Override
	protected ClientHttpConnectorFactory<?> getFactory() {
		return new JdkClientHttpConnectorFactory();
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class ReactorNettyHttpClientMapperTests {
	@Test
	void ofWithCollectionCreatesComposite() {
		ReactorNettyHttpClientMapper one = (httpClient) -> new TestHttpClient(httpClient, '1');
		ReactorNettyHttpClientMapper two = (httpClient) -> new TestHttpClient(httpClient, '2');
		ReactorNettyHttpClientMapper three = (httpClient) -> new TestHttpClient(httpClient, '3');
		ReactorNettyHttpClientMapper compose = ReactorNettyHttpClientMapper.of(List.of(one, two, three));
		TestHttpClient httpClient = (TestHttpClient) compose.configure(new TestHttpClient());
		assertThat(httpClient.getContent()).isEqualTo('123');
	}
	@Test
	void ofWhenCollectionIsNullThrowsException() {
		Collection<ReactorNettyHttpClientMapper> mappers = null;
		assertThatIllegalArgumentException().isThrownBy(() -> ReactorNettyHttpClientMapper.of(mappers))
			.withMessage('Mappers must not be null');
	}
	@Test
	void ofWithArrayCreatesComposite() {
		ReactorNettyHttpClientMapper one = (httpClient) -> new TestHttpClient(httpClient, '1');
		ReactorNettyHttpClientMapper two = (httpClient) -> new TestHttpClient(httpClient, '2');
		ReactorNettyHttpClientMapper three = (httpClient) -> new TestHttpClient(httpClient, '3');
		ReactorNettyHttpClientMapper compose = ReactorNettyHttpClientMapper.of(one, two, three);
		TestHttpClient httpClient = (TestHttpClient) compose.configure(new TestHttpClient());
		assertThat(httpClient.getContent()).isEqualTo('123');
	}
	@Test
	void ofWhenArrayIsNullThrowsException() {
		ReactorNettyHttpClientMapper[] mappers = null;
		assertThatIllegalArgumentException().isThrownBy(() -> ReactorNettyHttpClientMapper.of(mappers))
			.withMessage('Mappers must not be null');
	}
	private static class TestHttpClient extends HttpClient {
		private final String content;
		TestHttpClient() {
			this.content = '';
		}
		TestHttpClient(HttpClient httpClient, String content) {
			this.content = (httpClient instanceof TestHttpClient testHttpClient) ? testHttpClient.content + content
					: content;
		}
		@Override
		public HttpClientConfig configuration() {
			throw new UnsupportedOperationException('Auto-generated method stub');
		}
		@Override
		protected HttpClient duplicate() {
			throw new UnsupportedOperationException('Auto-generated method stub');
		}
		String getContent() {
			return this.content;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class HttpComponentsClientHttpConnectorFactoryTests extends AbstractClientHttpConnectorFactoryTests {
	@Override
	protected ClientHttpConnectorFactory<?> getFactory() {
		return new HttpComponentsClientHttpConnectorFactory();
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
abstract class AbstractClientHttpConnectorFactoryTests {
	@Test
	void insecureConnection() {
		TomcatServletWebServerFactory webServerFactory = new TomcatServletWebServerFactory(0);
		WebServer webServer = webServerFactory.getWebServer();
		try {
			webServer.start();
			int port = webServer.getPort();
			String url = 'http://localhost:%s'.formatted(port);
			WebClient insecureWebClient = WebClient.builder()
				.clientConnector(getFactory().createClientHttpConnector())
				.build();
			String insecureBody = insecureWebClient.get()
				.uri(url)
				.exchangeToMono((response) -> response.bodyToMono(String.class))
				.block();
			assertThat(insecureBody).contains('HTTP Status 404  Not Found');
		}
		finally {
			webServer.stop();
		}
	}
	@Test
	void secureConnection() throws Exception {
		TomcatServletWebServerFactory webServerFactory = new TomcatServletWebServerFactory(0);
		Ssl ssl = new Ssl();
		ssl.setClientAuth(ClientAuth.NEED);
		ssl.setKeyPassword('password');
		ssl.setKeyStore('classpath:test.jks');
		ssl.setTrustStore('classpath:test.jks');
		webServerFactory.setSsl(ssl);
		WebServer webServer = webServerFactory.getWebServer();
		try {
			webServer.start();
			int port = webServer.getPort();
			String url = 'https://localhost:%s'.formatted(port);
			WebClient insecureWebClient = WebClient.builder()
				.clientConnector(getFactory().createClientHttpConnector())
				.build();
			assertThatExceptionOfType(WebClientRequestException.class).isThrownBy(() -> insecureWebClient.get()
				.uri(url)
				.exchangeToMono((response) -> response.bodyToMono(String.class))
				.block());
			JksSslStoreDetails storeDetails = JksSslStoreDetails.forLocation('classpath:test.jks');
			JksSslStoreBundle stores = new JksSslStoreBundle(storeDetails, storeDetails);
			SslBundle sslBundle = SslBundle.of(stores, SslBundleKey.of('password'));
			WebClient secureWebClient = WebClient.builder()
				.clientConnector(getFactory().createClientHttpConnector(sslBundle))
				.build();
			String secureBody = secureWebClient.get()
				.uri(url)
				.exchangeToMono((response) -> response.bodyToMono(String.class))
				.block();
			assertThat(secureBody).contains('HTTP Status 404  Not Found');
		}
		finally {
			webServer.stop();
		}
	}
	protected abstract ClientHttpConnectorFactory<?> getFactory();
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class ReactorClientHttpConnectorFactoryTests extends AbstractClientHttpConnectorFactoryTests {
	private ReactorResourceFactory resourceFactory;
	@BeforeEach
	void setup() {
		this.resourceFactory = new ReactorResourceFactory();
		this.resourceFactory.afterPropertiesSet();
	}
	@AfterEach
	void teardown() {
		this.resourceFactory.destroy();
	}
	@Override
	protected ClientHttpConnectorFactory<?> getFactory() {
		return new ReactorClientHttpConnectorFactory(this.resourceFactory);
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class WebFluxPropertiesTests {
	private final WebFluxProperties properties = new WebFluxProperties();
	@Test
	void shouldPrefixBasePathWithMissingSlash() {
		bind('spring.webflux.base-path', 'something');
		assertThat(this.properties.getBasePath()).isEqualTo('/something');
	}
	@Test
	void shouldRemoveTrailingSlashFromBasePath() {
		bind('spring.webflux.base-path', '/something/');
		assertThat(this.properties.getBasePath()).isEqualTo('/something');
	}
	private void bind(String name, String value) {
		bind(Collections.singletonMap(name, value));
	}
	private void bind(Map<String, String> map) {
		ConfigurationPropertySource source = new MapConfigurationPropertySource(map);
		new Binder(source).bind('spring.webflux', Bindable.ofInstance(this.properties));
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class WebFluxAutoConfigurationTests {
	private static final MockReactiveWebServerFactory mockReactiveWebServerFactory = new MockReactiveWebServerFactory();
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(WebFluxAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class))
		.withUserConfiguration(Config.class);
	@Test
	void shouldNotProcessIfExistingWebReactiveConfiguration() {
		this.contextRunner.withUserConfiguration(WebFluxConfigurationSupport.class).run((context) -> {
			assertThat(context).getBeans(RequestMappingHandlerMapping.class).hasSize(1);
			assertThat(context).getBeans(RequestMappingHandlerAdapter.class).hasSize(1);
		});
	}
	@Test
	void shouldCreateDefaultBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).getBeans(RequestMappingHandlerMapping.class).hasSize(1);
			assertThat(context).getBeans(RequestMappingHandlerAdapter.class).hasSize(1);
			assertThat(context).getBeans(RequestedContentTypeResolver.class).hasSize(1);
			assertThat(context).getBeans(RouterFunctionMapping.class).hasSize(1);
			assertThat(context.getBean(WebHttpHandlerBuilder.WEB_SESSION_MANAGER_BEAN_NAME, WebSessionManager.class))
				.isNotNull();
			assertThat(context.getBean('resourceHandlerMapping', HandlerMapping.class)).isNotNull();
		});
	}
	@SuppressWarnings('unchecked')
	@Test
	void shouldRegisterCustomHandlerMethodArgumentResolver() {
		this.contextRunner.withUserConfiguration(CustomArgumentResolvers.class).run((context) -> {
			RequestMappingHandlerAdapter adapter = context.getBean(RequestMappingHandlerAdapter.class);
			List<HandlerMethodArgumentResolver> customResolvers = (List<HandlerMethodArgumentResolver>) ReflectionTestUtils
				.getField(adapter.getArgumentResolverConfigurer(), 'customResolvers');
			assertThat(customResolvers).contains(context.getBean('firstResolver', HandlerMethodArgumentResolver.class),
					context.getBean('secondResolver', HandlerMethodArgumentResolver.class));
		});
	}
	@Test
	void shouldCustomizeCodecs() {
		this.contextRunner.withUserConfiguration(CustomCodecCustomizers.class).run((context) -> {
			CodecCustomizer codecCustomizer = context.getBean('firstCodecCustomizer', CodecCustomizer.class);
			assertThat(codecCustomizer).isNotNull();
			then(codecCustomizer).should().customize(any(ServerCodecConfigurer.class));
		});
	}
	@Test
	void shouldRegisterResourceHandlerMapping() {
		this.contextRunner.run((context) -> {
			SimpleUrlHandlerMapping hm = context.getBean('resourceHandlerMapping', SimpleUrlHandlerMapping.class);
			assertThat(hm.getUrlMap().get('/**')).isInstanceOf(ResourceWebHandler.class);
			ResourceWebHandler staticHandler = (ResourceWebHandler) hm.getUrlMap().get('/**');
			assertThat(staticHandler.getLocations()).hasSize(4);
			assertThat(hm.getUrlMap().get('/webjars/**')).isInstanceOf(ResourceWebHandler.class);
			ResourceWebHandler webjarsHandler = (ResourceWebHandler) hm.getUrlMap().get('/webjars/**');
			assertThat(webjarsHandler.getLocations()).hasSize(1);
			assertThat(webjarsHandler.getLocations().get(0))
				.isEqualTo(new ClassPathResource('/META-INF/resources/webjars/'));
		});
	}
	@Test
	void shouldMapResourcesToCustomPath() {
		this.contextRunner.withPropertyValues('spring.webflux.static-path-pattern:/static/**').run((context) -> {
			SimpleUrlHandlerMapping hm = context.getBean('resourceHandlerMapping', SimpleUrlHandlerMapping.class);
			assertThat(hm.getUrlMap().get('/static/**')).isInstanceOf(ResourceWebHandler.class);
			ResourceWebHandler staticHandler = (ResourceWebHandler) hm.getUrlMap().get('/static/**');
			assertThat(staticHandler).extracting('locationValues')
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.hasSize(4);
		});
	}
	@Test
	void shouldMapWebjarsToCustomPath() {
		this.contextRunner.withPropertyValues('spring.webflux.webjars-path-pattern:/assets/**').run((context) -> {
			SimpleUrlHandlerMapping hm = context.getBean('resourceHandlerMapping', SimpleUrlHandlerMapping.class);
			assertThat(hm.getUrlMap().get('/assets/**')).isInstanceOf(ResourceWebHandler.class);
			ResourceWebHandler webjarsHandler = (ResourceWebHandler) hm.getUrlMap().get('/assets/**');
			assertThat(webjarsHandler.getLocations()).hasSize(1);
			assertThat(webjarsHandler.getLocations().get(0))
				.isEqualTo(new ClassPathResource('/META-INF/resources/webjars/'));
		});
	}
	@Test
	void shouldNotMapResourcesWhenDisabled() {
		this.contextRunner.withPropertyValues('spring.web.resources.add-mappings:false')
			.run((context) -> assertThat(context.getBean('resourceHandlerMapping'))
				.isNotInstanceOf(SimpleUrlHandlerMapping.class));
	}
	@Test
	void resourceHandlerChainEnabled() {
		this.contextRunner.withPropertyValues('spring.web.resources.chain.enabled:true').run((context) -> {
			SimpleUrlHandlerMapping hm = context.getBean('resourceHandlerMapping', SimpleUrlHandlerMapping.class);
			assertThat(hm.getUrlMap().get('/**')).isInstanceOf(ResourceWebHandler.class);
			ResourceWebHandler staticHandler = (ResourceWebHandler) hm.getUrlMap().get('/**');
			assertThat(staticHandler.getResourceResolvers()).extractingResultOf('getClass')
				.containsOnly(CachingResourceResolver.class, PathResourceResolver.class);
			assertThat(staticHandler.getResourceTransformers()).extractingResultOf('getClass')
				.containsOnly(CachingResourceTransformer.class);
		});
	}
	@Test
	void shouldRegisterViewResolvers() {
		this.contextRunner.withUserConfiguration(ViewResolvers.class).run((context) -> {
			ViewResolutionResultHandler resultHandler = context.getBean(ViewResolutionResultHandler.class);
			assertThat(resultHandler.getViewResolvers()).containsExactly(
					context.getBean('aViewResolver', ViewResolver.class),
					context.getBean('anotherViewResolver', ViewResolver.class));
		});
	}
	@Test
	void defaultDateFormat() {
		this.contextRunner.run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			Date date = Date.from(ZonedDateTime.of(1988, 6, 25, 20, 30, 0, 0, ZoneId.systemDefault()).toInstant());
			// formatting conversion service should use simple toString()
			assertThat(conversionService.convert(date, String.class)).isEqualTo(date.toString());
		});
	}
	@Test
	void customDateFormat() {
		this.contextRunner.withPropertyValues('spring.webflux.format.date:dd*MM*yyyy').run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			Date date = Date.from(ZonedDateTime.of(1988, 6, 25, 20, 30, 0, 0, ZoneId.systemDefault()).toInstant());
			assertThat(conversionService.convert(date, String.class)).isEqualTo('25*06*1988');
		});
	}
	@Test
	void defaultTimeFormat() {
		this.contextRunner.run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalTime time = LocalTime.of(11, 43, 10);
			assertThat(conversionService.convert(time, String.class))
				.isEqualTo(DateTimeFormatter.ofLocalizedTime(FormatStyle.SHORT).format(time));
		});
	}
	@Test
	void customTimeFormat() {
		this.contextRunner.withPropertyValues('spring.webflux.format.time=HH:mm:ss').run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalTime time = LocalTime.of(11, 43, 10);
			assertThat(conversionService.convert(time, String.class)).isEqualTo('11:43:10');
		});
	}
	@Test
	void defaultDateTimeFormat() {
		this.contextRunner.run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalDateTime dateTime = LocalDateTime.of(2020, 4, 28, 11, 43, 10);
			assertThat(conversionService.convert(dateTime, String.class))
				.isEqualTo(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT).format(dateTime));
		});
	}
	@Test
	void customDateTimeTimeFormat() {
		this.contextRunner.withPropertyValues('spring.webflux.format.date-time=yyyy-MM-dd HH:mm:ss').run((context) -> {
			FormattingConversionService conversionService = context.getBean(FormattingConversionService.class);
			LocalDateTime dateTime = LocalDateTime.of(2020, 4, 28, 11, 43, 10);
			assertThat(conversionService.convert(dateTime, String.class)).isEqualTo('2020-04-28 11:43:10');
		});
	}
	@Test
	void validatorWhenNoValidatorShouldUseDefault() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(ValidatorFactory.class);
			assertThat(context).doesNotHaveBean(jakarta.validation.Validator.class);
			assertThat(context).getBeanNames(Validator.class).containsExactly('webFluxValidator');
		});
	}
	@Test
	void validatorWhenNoCustomizationShouldUseAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).getBeanNames(jakarta.validation.Validator.class)
					.containsExactly('defaultValidator');
				assertThat(context).getBeanNames(Validator.class)
					.containsExactlyInAnyOrder('defaultValidator', 'webFluxValidator');
				Validator validator = context.getBean('webFluxValidator', Validator.class);
				assertThat(validator).isInstanceOf(ValidatorAdapter.class);
				Object defaultValidator = context.getBean('defaultValidator');
				assertThat(((ValidatorAdapter) validator).getTarget()).isSameAs(defaultValidator);
				// Primary Spring validator is the one used by WebFlux behind the
				// scenes
				assertThat(context.getBean(Validator.class)).isEqualTo(defaultValidator);
			});
	}
	@Test
	void validatorWithConfigurerShouldUseSpringValidator() {
		this.contextRunner.withUserConfiguration(ValidatorWebFluxConfigurer.class).run((context) -> {
			assertThat(context).doesNotHaveBean(ValidatorFactory.class);
			assertThat(context).doesNotHaveBean(jakarta.validation.Validator.class);
			assertThat(context).getBeanNames(Validator.class).containsOnly('webFluxValidator');
			assertThat(context.getBean('webFluxValidator'))
				.isSameAs(context.getBean(ValidatorWebFluxConfigurer.class).validator);
		});
	}
	@Test
	void validatorWithConfigurerDoesNotExposeJsr303() {
		this.contextRunner.withUserConfiguration(ValidatorJsr303WebFluxConfigurer.class).run((context) -> {
			assertThat(context).doesNotHaveBean(ValidatorFactory.class);
			assertThat(context).doesNotHaveBean(jakarta.validation.Validator.class);
			assertThat(context).getBeanNames(Validator.class).containsOnly('webFluxValidator');
			Validator validator = context.getBean('webFluxValidator', Validator.class);
			assertThat(validator).isInstanceOf(ValidatorAdapter.class);
			assertThat(((ValidatorAdapter) validator).getTarget())
				.isSameAs(context.getBean(ValidatorJsr303WebFluxConfigurer.class).validator);
		});
	}
	@Test
	void validationCustomConfigurerTakesPrecedence() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.withUserConfiguration(ValidatorWebFluxConfigurer.class)
			.run((context) -> {
				assertThat(context).getBeans(ValidatorFactory.class).hasSize(1);
				assertThat(context).getBeans(jakarta.validation.Validator.class).hasSize(1);
				assertThat(context).getBeanNames(Validator.class)
					.containsExactlyInAnyOrder('defaultValidator', 'webFluxValidator');
				assertThat(context.getBean('webFluxValidator'))
					.isSameAs(context.getBean(ValidatorWebFluxConfigurer.class).validator);
				// Primary Spring validator is the auto-configured one as the WebFlux
				// one has been customized through a WebFluxConfigurer
				assertThat(context.getBean(Validator.class)).isEqualTo(context.getBean('defaultValidator'));
			});
	}
	@Test
	void validatorWithCustomSpringValidatorIgnored() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.withUserConfiguration(CustomSpringValidator.class)
			.run((context) -> {
				assertThat(context).getBeanNames(jakarta.validation.Validator.class)
					.containsExactly('defaultValidator');
				assertThat(context).getBeanNames(Validator.class)
					.containsExactlyInAnyOrder('customValidator', 'defaultValidator', 'webFluxValidator');
				Validator validator = context.getBean('webFluxValidator', Validator.class);
				assertThat(validator).isInstanceOf(ValidatorAdapter.class);
				Object defaultValidator = context.getBean('defaultValidator');
				assertThat(((ValidatorAdapter) validator).getTarget()).isSameAs(defaultValidator);
				// Primary Spring validator is the one used by WebFlux behind the
				// scenes
				assertThat(context.getBean(Validator.class)).isEqualTo(defaultValidator);
			});
	}
	@Test
	void validatorWithCustomJsr303ValidatorExposedAsSpringValidator() {
		this.contextRunner.withUserConfiguration(CustomJsr303Validator.class).run((context) -> {
			assertThat(context).doesNotHaveBean(ValidatorFactory.class);
			assertThat(context).getBeanNames(jakarta.validation.Validator.class).containsExactly('customValidator');
			assertThat(context).getBeanNames(Validator.class).containsExactly('webFluxValidator');
			Validator validator = context.getBean(Validator.class);
			assertThat(validator).isInstanceOf(ValidatorAdapter.class);
			Validator target = ((ValidatorAdapter) validator).getTarget();
			assertThat(target).hasFieldOrPropertyWithValue('targetValidator', context.getBean('customValidator'));
		});
	}
	@Test
	void hiddenHttpMethodFilterIsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(HiddenHttpMethodFilter.class));
	}
	@Test
	void hiddenHttpMethodFilterCanBeOverridden() {
		this.contextRunner.withPropertyValues('spring.webflux.hiddenmethod.filter.enabled=true')
			.withUserConfiguration(CustomHiddenHttpMethodFilter.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(OrderedHiddenHttpMethodFilter.class);
				assertThat(context).hasSingleBean(HiddenHttpMethodFilter.class);
			});
	}
	@Test
	void hiddenHttpMethodFilterCanBeEnabled() {
		this.contextRunner.withPropertyValues('spring.webflux.hiddenmethod.filter.enabled=true')
			.run((context) -> assertThat(context).hasSingleBean(OrderedHiddenHttpMethodFilter.class));
	}
	@Test
	void customRequestMappingHandlerMapping() {
		this.contextRunner.withUserConfiguration(CustomRequestMappingHandlerMapping.class).run((context) -> {
			assertThat(context).getBean(RequestMappingHandlerMapping.class)
				.isInstanceOf(MyRequestMappingHandlerMapping.class);
			assertThat(context.getBean(CustomRequestMappingHandlerMapping.class).handlerMappings).isOne();
		});
	}
	@Test
	void customRequestMappingHandlerAdapter() {
		this.contextRunner.withUserConfiguration(CustomRequestMappingHandlerAdapter.class).run((context) -> {
			assertThat(context).getBean(RequestMappingHandlerAdapter.class)
				.isInstanceOf(MyRequestMappingHandlerAdapter.class);
			assertThat(context.getBean(CustomRequestMappingHandlerAdapter.class).handlerAdapters).isOne();
		});
	}
	@Test
	void multipleWebFluxRegistrations() {
		this.contextRunner.withUserConfiguration(MultipleWebFluxRegistrations.class).run((context) -> {
			assertThat(context.getBean(RequestMappingHandlerMapping.class))
				.isNotInstanceOf(MyRequestMappingHandlerMapping.class);
			assertThat(context.getBean(RequestMappingHandlerAdapter.class))
				.isNotInstanceOf(MyRequestMappingHandlerAdapter.class);
		});
	}
	@Test
	void cachePeriod() {
		Assertions.setExtractBareNamePropertyMethods(false);
		this.contextRunner.withPropertyValues('spring.web.resources.cache.period:5').run((context) -> {
			Map<PathPattern, Object> handlerMap = getHandlerMap(context);
			assertThat(handlerMap).hasSize(2);
			for (Object handler : handlerMap.values()) {
				if (handler instanceof ResourceWebHandler resourceWebHandler) {
					assertThat(resourceWebHandler.getCacheControl()).usingRecursiveComparison()
						.isEqualTo(CacheControl.maxAge(5, TimeUnit.SECONDS));
				}
			}
		});
		Assertions.setExtractBareNamePropertyMethods(true);
	}
	@Test
	void cacheControl() {
		Assertions.setExtractBareNamePropertyMethods(false);
		this.contextRunner
			.withPropertyValues('spring.web.resources.cache.cachecontrol.max-age:5',
					'spring.web.resources.cache.cachecontrol.proxy-revalidate:true')
			.run((context) -> {
				Map<PathPattern, Object> handlerMap = getHandlerMap(context);
				assertThat(handlerMap).hasSize(2);
				for (Object handler : handlerMap.values()) {
					if (handler instanceof ResourceWebHandler resourceWebHandler) {
						assertThat(resourceWebHandler.getCacheControl()).usingRecursiveComparison()
							.isEqualTo(CacheControl.maxAge(5, TimeUnit.SECONDS).proxyRevalidate());
					}
				}
			});
		Assertions.setExtractBareNamePropertyMethods(true);
	}
	@Test
	void useLastModified() {
		this.contextRunner.withPropertyValues('spring.web.resources.cache.use-last-modified=false').run((context) -> {
			Map<PathPattern, Object> handlerMap = getHandlerMap(context);
			assertThat(handlerMap).hasSize(2);
			for (Object handler : handlerMap.values()) {
				if (handler instanceof ResourceWebHandler resourceWebHandler) {
					assertThat(resourceWebHandler.isUseLastModified()).isFalse();
				}
			}
		});
	}
	@Test
	void customPrinterAndParserShouldBeRegisteredAsConverters() {
		this.contextRunner.withUserConfiguration(ParserConfiguration.class, PrinterConfiguration.class)
			.run((context) -> {
				ConversionService service = context.getBean(ConversionService.class);
				assertThat(service.convert(new Example('spring', new Date()), String.class)).isEqualTo('spring');
				assertThat(service.convert('boot', Example.class)).extracting(Example::getName).isEqualTo('boot');
			});
	}
	@Test
	void welcomePageHandlerMapping() {
		this.contextRunner.withPropertyValues('spring.web.resources.static-locations=classpath:/welcome-page/')
			.run((context) -> {
				assertThat(context).getBeans(RouterFunctionMapping.class).hasSize(2);
				assertThat(context.getBean('welcomePageRouterFunctionMapping', HandlerMapping.class)).isNotNull()
					.extracting('order')
					.isEqualTo(1);
			});
	}
	@Test
	void defaultLocaleContextResolver() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(LocaleContextResolver.class);
			LocaleContextResolver resolver = context.getBean(LocaleContextResolver.class);
			assertThat(((AcceptHeaderLocaleContextResolver) resolver).getDefaultLocale()).isNull();
		});
	}
	@Test
	void whenFixedLocalContextResolverIsUsedThenAcceptLanguagesHeaderIsIgnored() {
		this.contextRunner.withPropertyValues('spring.web.locale:en_UK', 'spring.web.locale-resolver=fixed')
			.run((context) -> {
				MockServerHttpRequest request = MockServerHttpRequest.get('/')
					.acceptLanguageAsLocales(StringUtils.parseLocaleString('nl_NL'))
					.build();
				MockServerWebExchange exchange = MockServerWebExchange.from(request);
				LocaleContextResolver localeContextResolver = context.getBean(LocaleContextResolver.class);
				assertThat(localeContextResolver).isInstanceOf(FixedLocaleContextResolver.class);
				LocaleContext localeContext = localeContextResolver.resolveLocaleContext(exchange);
				assertThat(localeContext.getLocale()).isEqualTo(StringUtils.parseLocaleString('en_UK'));
			});
	}
	@Test
	void whenAcceptHeaderLocaleContextResolverIsUsedThenAcceptLanguagesHeaderIsHonoured() {
		this.contextRunner.withPropertyValues('spring.web.locale:en_UK').run((context) -> {
			MockServerHttpRequest request = MockServerHttpRequest.get('/')
				.acceptLanguageAsLocales(StringUtils.parseLocaleString('nl_NL'))
				.build();
			MockServerWebExchange exchange = MockServerWebExchange.from(request);
			LocaleContextResolver localeContextResolver = context.getBean(LocaleContextResolver.class);
			assertThat(localeContextResolver).isInstanceOf(AcceptHeaderLocaleContextResolver.class);
			LocaleContext localeContext = localeContextResolver.resolveLocaleContext(exchange);
			assertThat(localeContext.getLocale()).isEqualTo(StringUtils.parseLocaleString('nl_NL'));
		});
	}
	@Test
	void whenAcceptHeaderLocaleContextResolverIsUsedAndHeaderIsAbsentThenConfiguredLocaleIsUsed() {
		this.contextRunner.withPropertyValues('spring.web.locale:en_UK').run((context) -> {
			MockServerHttpRequest request = MockServerHttpRequest.get('/').build();
			MockServerWebExchange exchange = MockServerWebExchange.from(request);
			LocaleContextResolver localeContextResolver = context.getBean(LocaleContextResolver.class);
			assertThat(localeContextResolver).isInstanceOf(AcceptHeaderLocaleContextResolver.class);
			LocaleContext localeContext = localeContextResolver.resolveLocaleContext(exchange);
			assertThat(localeContext.getLocale()).isEqualTo(StringUtils.parseLocaleString('en_UK'));
		});
	}
	@Test
	void customLocaleContextResolverWithMatchingNameReplacedAutoConfiguredLocaleContextResolver() {
		this.contextRunner
			.withBean('localeContextResolver', CustomLocaleContextResolver.class, CustomLocaleContextResolver::new)
			.run((context) -> {
				assertThat(context).hasSingleBean(LocaleContextResolver.class);
				assertThat(context.getBean('localeContextResolver')).isInstanceOf(CustomLocaleContextResolver.class);
			});
	}
	@Test
	void customLocaleContextResolverWithDifferentNameDoesNotReplaceAutoConfiguredLocaleContextResolver() {
		this.contextRunner
			.withBean('customLocaleContextResolver', CustomLocaleContextResolver.class,
					CustomLocaleContextResolver::new)
			.run((context) -> {
				assertThat(context.getBean('customLocaleContextResolver'))
					.isInstanceOf(CustomLocaleContextResolver.class);
				assertThat(context.getBean('localeContextResolver'))
					.isInstanceOf(AcceptHeaderLocaleContextResolver.class);
			});
	}
	@Test
	@SuppressWarnings('rawtypes')
	void userConfigurersCanBeOrderedBeforeOrAfterTheAutoConfiguredConfigurer() {
		this.contextRunner.withBean(HighPrecedenceConfigurer.class, HighPrecedenceConfigurer::new)
			.withBean(LowPrecedenceConfigurer.class, LowPrecedenceConfigurer::new)
			.run((context) -> assertThat(context.getBean(DelegatingWebFluxConfiguration.class))
				.extracting('configurers.delegates')
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.extracting((configurer) -> (Class) configurer.getClass())
				.containsExactly(HighPrecedenceConfigurer.class, WebFluxConfig.class, LowPrecedenceConfigurer.class));
	}
	@Test
	void customWebSessionIdResolverShouldBeApplied() {
		this.contextRunner.withUserConfiguration(CustomWebSessionIdResolver.class)
			.run(assertExchangeWithSession(
					(exchange) -> assertThat(exchange.getResponse().getCookies().get('TEST')).isNotEmpty()));
	}
	@Test
	void customSessionTimeoutConfigurationShouldBeApplied() {
		this.contextRunner.withPropertyValues('server.reactive.session.timeout:123')
			.run((assertSessionTimeoutWithWebSession((webSession) -> {
				webSession.start();
				assertThat(webSession.getMaxIdleTime()).hasSeconds(123);
			})));
	}
	@Test
	void customSessionMaxSessionsConfigurationShouldBeApplied() {
		this.contextRunner.withPropertyValues('server.reactive.session.max-sessions:123')
			.run(assertMaxSessionsWithWebSession(123));
	}
	@Test
	void defaultSessionMaxSessionsConfigurationShouldBeInSync() {
		int defaultMaxSessions = new InMemoryWebSessionStore().getMaxSessions();
		this.contextRunner.run(assertMaxSessionsWithWebSession(defaultMaxSessions));
	}
	@Test
	void customSessionCookieConfigurationShouldBeApplied() {
		this.contextRunner.withPropertyValues('server.reactive.session.cookie.name:JSESSIONID',
				'server.reactive.session.cookie.domain:.example.com', 'server.reactive.session.cookie.path:/example',
				'server.reactive.session.cookie.max-age:60', 'server.reactive.session.cookie.http-only:false',
				'server.reactive.session.cookie.secure:false', 'server.reactive.session.cookie.same-site:strict',
				'server.reactive.session.cookie.partitioned:true')
			.run(assertExchangeWithSession((exchange) -> {
				List<ResponseCookie> cookies = exchange.getResponse().getCookies().get('JSESSIONID');
				assertThat(cookies).isNotEmpty();
				assertThat(cookies).allMatch((cookie) -> cookie.getDomain().equals('.example.com'));
				assertThat(cookies).allMatch((cookie) -> cookie.getPath().equals('/example'));
				assertThat(cookies).allMatch((cookie) -> cookie.getMaxAge().equals(Duration.ofSeconds(60)));
				assertThat(cookies).allMatch((cookie) -> !cookie.isHttpOnly());
				assertThat(cookies).allMatch((cookie) -> !cookie.isSecure());
				assertThat(cookies).allMatch((cookie) -> cookie.getSameSite().equals('Strict'));
				assertThat(cookies).allMatch(ResponseCookie::isPartitioned);
			}));
	}
	@ParameterizedTest
	@ValueSource(classes = { ServerProperties.class, WebFluxProperties.class })
	void propertiesAreNotEnabledInNonWebApplication(Class<?> propertiesClass) {
		new ApplicationContextRunner()
			.withConfiguration(
					AutoConfigurations.of(WebFluxAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(propertiesClass));
	}
	@Test
	void problemDetailsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ProblemDetailsExceptionHandler.class));
	}
	@Test
	void problemDetailsEnabledAddsExceptionHandler() {
		this.contextRunner.withPropertyValues('spring.webflux.problemdetails.enabled:true')
			.run((context) -> assertThat(context).hasSingleBean(ProblemDetailsExceptionHandler.class));
	}
	@Test
	void problemDetailsExceptionHandlerDoesNotPreventProxying() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(AopAutoConfiguration.class))
			.withBean(ExceptionHandlerInterceptor.class)
			.withPropertyValues('spring.webflux.problemdetails.enabled:true')
			.run((context) -> assertThat(context).getBean(ProblemDetailsExceptionHandler.class)
				.matches(AopUtils::isCglibProxy));
	}
	@Test
	void problemDetailsBacksOffWhenExceptionHandler() {
		this.contextRunner.withPropertyValues('spring.webflux.problemdetails.enabled:true')
			.withUserConfiguration(CustomExceptionHandlerConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ProblemDetailsExceptionHandler.class)
				.hasSingleBean(CustomExceptionHandler.class));
	}
	@Test
	void problemDetailsExceptionHandlerIsOrderedAt0() {
		this.contextRunner.withPropertyValues('spring.webflux.problemdetails.enabled:true')
			.withUserConfiguration(OrderedControllerAdviceBeansConfiguration.class)
			.run((context) -> assertThat(
					ControllerAdviceBean.findAnnotatedBeans(context).stream().map(ControllerAdviceBean::getBeanType))
				.asInstanceOf(InstanceOfAssertFactories.list(Class.class))
				.containsExactly(HighestOrderedControllerAdvice.class, ProblemDetailsExceptionHandler.class,
						LowestOrderedControllerAdvice.class));
	}
	@Test
	void asyncTaskExecutorWithPlatformThreadsAndApplicationTaskExecutor() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(AsyncTaskExecutor.class);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('scheduler.executor')
					.isNull();
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void asyncTaskExecutorWithVirtualThreadsAndApplicationTaskExecutor() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(AsyncTaskExecutor.class);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('scheduler.executor')
					.isSameAs(context.getBean('applicationTaskExecutor'));
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void asyncTaskExecutorWithVirtualThreadsAndNonMatchApplicationTaskExecutorBean() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.withUserConfiguration(CustomApplicationTaskExecutorConfig.class)
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(AsyncTaskExecutor.class);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('scheduler.executor')
					.isNotSameAs(context.getBean('applicationTaskExecutor'));
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void asyncTaskExecutorWithVirtualThreadsAndWebFluxConfigurerCanOverrideExecutor() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.withUserConfiguration(CustomAsyncTaskExecutorConfigurer.class)
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> assertThat(context.getBean(RequestMappingHandlerAdapter.class))
				.extracting('scheduler.executor')
				.isSameAs(context.getBean(CustomAsyncTaskExecutorConfigurer.class).taskExecutor));
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void asyncTaskExecutorWithVirtualThreadsAndCustomNonApplicationTaskExecutor() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.withUserConfiguration(CustomAsyncTaskExecutorConfig.class)
			.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(AsyncTaskExecutor.class);
				assertThat(context.getBean(RequestMappingHandlerAdapter.class)).extracting('scheduler.executor')
					.isNull();
			});
	}
	private ContextConsumer<ReactiveWebApplicationContext> assertExchangeWithSession(
			Consumer<MockServerWebExchange> exchange) {
		return (context) -> {
			MockServerHttpRequest request = MockServerHttpRequest.get('/').build();
			MockServerWebExchange webExchange = MockServerWebExchange.from(request);
			WebSessionManager webSessionManager = context.getBean(WebSessionManager.class);
			WebSession webSession = webSessionManager.getSession(webExchange).block();
			webSession.start();
			webExchange.getResponse().setComplete().block();
			exchange.accept(webExchange);
		};
	}
	private ContextConsumer<ReactiveWebApplicationContext> assertSessionTimeoutWithWebSession(
			Consumer<WebSession> session) {
		return (context) -> {
			MockServerHttpRequest request = MockServerHttpRequest.get('/').build();
			MockServerWebExchange webExchange = MockServerWebExchange.from(request);
			WebSessionManager webSessionManager = context.getBean(WebSessionManager.class);
			WebSession webSession = webSessionManager.getSession(webExchange).block();
			session.accept(webSession);
		};
	}
	private ContextConsumer<ReactiveWebApplicationContext> assertMaxSessionsWithWebSession(int maxSessions) {
		return (context) -> {
			WebSessionManager sessionManager = context.getBean(WebSessionManager.class);
			assertThat(sessionManager).isInstanceOf(DefaultWebSessionManager.class);
			WebSessionStore sessionStore = ((DefaultWebSessionManager) sessionManager).getSessionStore();
			assertThat(sessionStore).isInstanceOf(InMemoryWebSessionStore.class);
			assertThat(((InMemoryWebSessionStore) sessionStore).getMaxSessions()).isEqualTo(maxSessions);
		};
	}
	private Map<PathPattern, Object> getHandlerMap(ApplicationContext context) {
		HandlerMapping mapping = context.getBean('resourceHandlerMapping', HandlerMapping.class);
		if (mapping instanceof SimpleUrlHandlerMapping simpleMapping) {
			return simpleMapping.getHandlerMap();
		}
		return Collections.emptyMap();
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebSessionIdResolver {
		@Bean
		WebSessionIdResolver webSessionIdResolver() {
			CookieWebSessionIdResolver resolver = new CookieWebSessionIdResolver();
			resolver.setCookieName('TEST');
			return resolver;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomArgumentResolvers {
		@Bean
		HandlerMethodArgumentResolver firstResolver() {
			return mock(HandlerMethodArgumentResolver.class);
		}
		@Bean
		HandlerMethodArgumentResolver secondResolver() {
			return mock(HandlerMethodArgumentResolver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomCodecCustomizers {
		@Bean
		CodecCustomizer firstCodecCustomizer() {
			return mock(CodecCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ViewResolvers {
		@Bean
		@Order(Ordered.HIGHEST_PRECEDENCE)
		ViewResolver aViewResolver() {
			return mock(ViewResolver.class);
		}
		@Bean
		ViewResolver anotherViewResolver() {
			return mock(ViewResolver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		MockReactiveWebServerFactory mockReactiveWebServerFactory() {
			return mockReactiveWebServerFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHttpHandler {
		@Bean
		HttpHandler httpHandler() {
			return (serverHttpRequest, serverHttpResponse) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ValidatorWebFluxConfigurer implements WebFluxConfigurer {
		private final Validator validator = mock(Validator.class);
		@Override
		public Validator getValidator() {
			return this.validator;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ValidatorJsr303WebFluxConfigurer implements WebFluxConfigurer {
		private final LocalValidatorFactoryBean validator = new LocalValidatorFactoryBean();
		@Override
		public Validator getValidator() {
			return this.validator;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJsr303Validator {
		@Bean
		jakarta.validation.Validator customValidator() {
			return mock(jakarta.validation.Validator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomSpringValidator {
		@Bean
		Validator customValidator() {
			return mock(Validator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHiddenHttpMethodFilter {
		@Bean
		HiddenHttpMethodFilter customHiddenHttpMethodFilter() {
			return mock(HiddenHttpMethodFilter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRequestMappingHandlerAdapter {
		private int handlerAdapters = 0;
		@Bean
		WebFluxRegistrations webFluxRegistrationsHandlerAdapter() {
			return new WebFluxRegistrations() {
				@Override
				public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
					CustomRequestMappingHandlerAdapter.this.handlerAdapters++;
					return new WebFluxAutoConfigurationTests.MyRequestMappingHandlerAdapter();
				}
			};
		}
	}
	static class MyRequestMappingHandlerAdapter extends RequestMappingHandlerAdapter {
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ WebFluxAutoConfigurationTests.CustomRequestMappingHandlerMapping.class,
			WebFluxAutoConfigurationTests.CustomRequestMappingHandlerAdapter.class })
	static class MultipleWebFluxRegistrations {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRequestMappingHandlerMapping {
		private int handlerMappings = 0;
		@Bean
		WebFluxRegistrations webFluxRegistrationsHandlerMapping() {
			return new WebFluxRegistrations() {
				@Override
				public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
					CustomRequestMappingHandlerMapping.this.handlerMappings++;
					return new MyRequestMappingHandlerMapping();
				}
			};
		}
	}
	static class MyRequestMappingHandlerMapping extends RequestMappingHandlerMapping {
	}
	@Configuration(proxyBeanMethods = false)
	static class PrinterConfiguration {
		@Bean
		Printer<Example> examplePrinter() {
			return new ExamplePrinter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParserConfiguration {
		@Bean
		Parser<Example> exampleParser() {
			return new ExampleParser();
		}
	}
	static final class Example {
		private final String name;
		private Example(String name, Date date) {
			this.name = name;
		}
		String getName() {
			return this.name;
		}
	}
	static class ExamplePrinter implements Printer<Example> {
		@Override
		public String print(Example example, Locale locale) {
			return example.getName();
		}
	}
	static class ExampleParser implements Parser<Example> {
		@Override
		public Example parse(String source, Locale locale) {
			return new Example(source, new Date());
		}
	}
	static class CustomLocaleContextResolver implements LocaleContextResolver {
		@Override
		public LocaleContext resolveLocaleContext(ServerWebExchange exchange) {
			return () -> Locale.ENGLISH;
		}
		@Override
		public void setLocaleContext(ServerWebExchange exchange, LocaleContext localeContext) {
		}
	}
	@Order(-100)
	static class HighPrecedenceConfigurer implements WebFluxConfigurer {
	}
	@Order(100)
	static class LowPrecedenceConfigurer implements WebFluxConfigurer {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomExceptionHandlerConfiguration {
		@Bean
		CustomExceptionHandler customExceptionHandler() {
			return new CustomExceptionHandler();
		}
	}
	@ControllerAdvice
	static class CustomExceptionHandler extends ResponseEntityExceptionHandler {
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ LowestOrderedControllerAdvice.class, HighestOrderedControllerAdvice.class })
	static class OrderedControllerAdviceBeansConfiguration {
		@ControllerAdvice
		@Order
		static class LowestOrderedControllerAdvice {
		}
		@ControllerAdvice
		@Order(Ordered.HIGHEST_PRECEDENCE)
		static class HighestOrderedControllerAdvice {
		}
	}
	@Aspect
	static class ExceptionHandlerInterceptor {
		@AfterReturning(pointcut = '@annotation(org.springframework.web.bind.annotation.ExceptionHandler)',
				returning = 'returnValue')
		void exceptionHandlerIntercept(JoinPoint joinPoint, Object returnValue) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomApplicationTaskExecutorConfig {
		@Bean
		Executor applicationTaskExecutor() {
			return mock(Executor.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAsyncTaskExecutorConfig {
		@Bean
		AsyncTaskExecutor customTaskExecutor() {
			return mock(AsyncTaskExecutor.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomAsyncTaskExecutorConfigurer implements WebFluxConfigurer {
		private final AsyncTaskExecutor taskExecutor = mock(AsyncTaskExecutor.class);
		@Override
		public void configureBlockingExecution(BlockingExecutionConfigurer configurer) {
			configurer.setExecutor(this.taskExecutor);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class HttpHandlerAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HttpHandlerAutoConfiguration.class));
	@Test
	void shouldNotProcessIfExistingHttpHandler() {
		this.contextRunner.withUserConfiguration(CustomHttpHandler.class).run((context) -> {
			assertThat(context).hasSingleBean(HttpHandler.class);
			assertThat(context).getBean(HttpHandler.class).isSameAs(context.getBean('customHttpHandler'));
		});
	}
	@Test
	void shouldConfigureHttpHandlerAnnotation() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebFluxAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(HttpHandler.class));
	}
	@Test
	void shouldConfigureHttpHandlerWithoutWebFluxAutoConfiguration() {
		this.contextRunner.withUserConfiguration(CustomWebHandler.class)
			.run((context) -> assertThat(context).hasSingleBean(HttpHandler.class));
	}
	@Test
	void customizersAreCalled() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebFluxAutoConfiguration.class))
			.withUserConfiguration(WebHttpHandlerBuilderCustomizers.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(HttpHandler.class);
				HttpHandler httpHandler = context.getBean(HttpHandler.class);
				ServerHttpRequest request = MockServerHttpRequest.get('').build();
				ServerHttpResponse response = new MockServerHttpResponse();
				httpHandler.handle(request, response).block();
				assertThat(response.getStatusCode()).isEqualTo(HttpStatus.I_AM_A_TEAPOT);
			});
	}
	@Test
	void shouldConfigureBasePathCompositeHandler() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebFluxAutoConfiguration.class))
			.withPropertyValues('spring.webflux.base-path=/something')
			.run((context) -> {
				assertThat(context).hasSingleBean(HttpHandler.class);
				HttpHandler httpHandler = context.getBean(HttpHandler.class);
				assertThat(httpHandler).isInstanceOf(ContextPathCompositeHandler.class)
					.extracting('handlerMap', InstanceOfAssertFactories.map(String.class, HttpHandler.class))
					.containsKey('/something');
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomHttpHandler {
		@Bean
		HttpHandler customHttpHandler() {
			return (serverHttpRequest, serverHttpResponse) -> null;
		}
		@Bean
		RouterFunction<ServerResponse> routerFunction() {
			return route(GET('/test'), (serverRequest) -> null);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebHandler {
		@Bean
		WebHandler webHandler() {
			return new DispatcherHandler();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class WebHttpHandlerBuilderCustomizers {
		@Bean
		WebHttpHandlerBuilderCustomizer customizerDecorator() {
			return (webHttpHandlerBuilder) -> webHttpHandlerBuilder
				.httpHandlerDecorator(((httpHandler) -> (request, response) -> {
					response.setStatusCode(HttpStatus.I_AM_A_TEAPOT);
					return response.setComplete();
				}));
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AbstractDependsOnBeanFactoryPostProcessorTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(FooBarConfiguration.class);
	@Test
	void fooBeansShouldDependOnBarBeanNames() {
		this.contextRunner
			.withUserConfiguration(FooDependsOnBarNamePostProcessor.class, FooBarFactoryBeanConfiguration.class)
			.run(this::assertThatFooDependsOnBar);
	}
	@Test
	void fooBeansShouldDependOnBarBeanTypes() {
		this.contextRunner
			.withUserConfiguration(FooDependsOnBarTypePostProcessor.class, FooBarFactoryBeanConfiguration.class)
			.run(this::assertThatFooDependsOnBar);
	}
	@Test
	void fooBeansShouldDependOnBarBeanNamesParentContext() {
		try (AnnotationConfigApplicationContext parentContext = new AnnotationConfigApplicationContext(
				FooBarFactoryBeanConfiguration.class)) {
			this.contextRunner.withUserConfiguration(FooDependsOnBarNamePostProcessor.class)
				.withParent(parentContext)
				.run(this::assertThatFooDependsOnBar);
		}
	}
	@Test
	void fooBeansShouldDependOnBarBeanTypesParentContext() {
		try (AnnotationConfigApplicationContext parentContext = new AnnotationConfigApplicationContext(
				FooBarFactoryBeanConfiguration.class)) {
			this.contextRunner.withUserConfiguration(FooDependsOnBarTypePostProcessor.class)
				.withParent(parentContext)
				.run(this::assertThatFooDependsOnBar);
		}
	}
	@Test
	void postProcessorHasADefaultOrderOfZero() {
		assertThat(new FooDependsOnBarTypePostProcessor().getOrder()).isZero();
	}
	private void assertThatFooDependsOnBar(AssertableApplicationContext context) {
		ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
		assertThat(getBeanDefinition('foo', beanFactory).getDependsOn()).containsExactly('bar', 'barFactoryBean');
		assertThat(getBeanDefinition('fooFactoryBean', beanFactory).getDependsOn()).containsExactly('bar',
				'barFactoryBean');
	}
	private BeanDefinition getBeanDefinition(String beanName, ConfigurableListableBeanFactory beanFactory) {
		try {
			return beanFactory.getBeanDefinition(beanName);
		}
		catch (NoSuchBeanDefinitionException ex) {
			BeanFactory parentBeanFactory = beanFactory.getParentBeanFactory();
			if (parentBeanFactory instanceof ConfigurableListableBeanFactory configurableListableBeanFactory) {
				return getBeanDefinition(beanName, configurableListableBeanFactory);
			}
			throw ex;
		}
	}
	static class Foo {
	}
	static class Bar {
	}
	@Configuration(proxyBeanMethods = false)
	static class FooBarFactoryBeanConfiguration {
		@Bean
		FooFactoryBean fooFactoryBean() {
			return new FooFactoryBean();
		}
		@Bean
		BarFactoryBean barFactoryBean() {
			return new BarFactoryBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FooBarConfiguration {
		@Bean
		Bar bar() {
			return new Bar();
		}
		@Bean
		Foo foo() {
			return new Foo();
		}
	}
	static class FooDependsOnBarTypePostProcessor extends AbstractDependsOnBeanFactoryPostProcessor {
		protected FooDependsOnBarTypePostProcessor() {
			super(Foo.class, FooFactoryBean.class, Bar.class, BarFactoryBean.class);
		}
	}
	static class FooDependsOnBarNamePostProcessor extends AbstractDependsOnBeanFactoryPostProcessor {
		protected FooDependsOnBarNamePostProcessor() {
			super(Foo.class, FooFactoryBean.class, 'bar', 'barFactoryBean');
		}
	}
	static class FooFactoryBean implements FactoryBean<Foo> {
		@Override
		public Foo getObject() {
			return new Foo();
		}
		@Override
		public Class<?> getObjectType() {
			return Foo.class;
		}
	}
	static class BarFactoryBean implements FactoryBean<Bar> {
		@Override
		public Bar getObject() {
			return new Bar();
		}
		@Override
		public Class<?> getObjectType() {
			return Bar.class;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.integration;
/**
class IntegrationAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JmxAutoConfiguration.class, IntegrationAutoConfiguration.class));
	@Test
	void integrationIsAvailable() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(TestGateway.class);
			assertThat(context).hasSingleBean(IntegrationComponentScanConfiguration.class);
		});
	}
	@Test
	void explicitIntegrationComponentScan() {
		this.contextRunner.withUserConfiguration(CustomIntegrationComponentScanConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(TestGateway.class);
			assertThat(context).doesNotHaveBean(IntegrationComponentScanConfiguration.class);
		});
	}
	@Test
	void noMBeanServerAvailable() {
		ApplicationContextRunner contextRunnerWithoutJmx = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(IntegrationAutoConfiguration.class));
		contextRunnerWithoutJmx.run((context) -> {
			assertThat(context).hasSingleBean(TestGateway.class);
			assertThat(context).hasSingleBean(IntegrationComponentScanConfiguration.class);
		});
	}
	@Test
	void parentContext() {
		this.contextRunner.run((context) -> this.contextRunner.withParent(context)
			.withPropertyValues('spring.jmx.default_domain=org.foo')
			.run((child) -> assertThat(child).hasSingleBean(HeaderChannelRegistry.class)));
	}
	@Test
	void enableJmxIntegration() {
		this.contextRunner.withPropertyValues('spring.jmx.enabled=true').run((context) -> {
			MBeanServer mBeanServer = context.getBean(MBeanServer.class);
			assertThat(mBeanServer.getDomains()).contains('org.springframework.integration',
					'org.springframework.integration.monitor');
			assertThat(context).hasBean(IntegrationManagementConfigurer.MANAGEMENT_CONFIGURER_NAME);
		});
	}
	@Test
	void jmxIntegrationIsDisabledByDefault() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(MBeanServer.class);
			assertThat(context).hasSingleBean(IntegrationManagementConfigurer.class);
		});
	}
	@Test
	void customizeJmxDomain() {
		this.contextRunner.withPropertyValues('spring.jmx.enabled=true', 'spring.jmx.default_domain=org.foo')
			.run((context) -> {
				MBeanServer mBeanServer = context.getBean(MBeanServer.class);
				assertThat(mBeanServer.getDomains()).contains('org.foo')
					.doesNotContain('org.springframework.integration', 'org.springframework.integration.monitor');
			});
	}
	@Test
	void primaryExporterIsAllowed() {
		this.contextRunner.withPropertyValues('spring.jmx.enabled=true')
			.withUserConfiguration(CustomMBeanExporter.class)
			.run((context) -> {
				assertThat(context).getBeans(MBeanExporter.class).hasSize(2);
				assertThat(context.getBean(MBeanExporter.class)).isSameAs(context.getBean('myMBeanExporter'));
			});
	}
	@Test
	void integrationJdbcDataSourceInitializerEnabled() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceTransactionManagerAutoConfiguration.class,
					JdbcTemplateAutoConfiguration.class, IntegrationAutoConfiguration.class))
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.integration.jdbc.initialize-schema=always')
			.run((context) -> {
				IntegrationProperties properties = context.getBean(IntegrationProperties.class);
				assertThat(properties.getJdbc().getInitializeSchema()).isEqualTo(DatabaseInitializationMode.ALWAYS);
				JdbcOperations jdbc = context.getBean(JdbcOperations.class);
				assertThat(jdbc.queryForList('select * from INT_MESSAGE')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_GROUP_TO_MESSAGE')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_MESSAGE_GROUP')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_LOCK')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_CHANNEL_MESSAGE')).isEmpty();
			});
	}
	@Test
	void whenIntegrationJdbcDataSourceInitializerIsEnabledThenFlywayCanBeUsed() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceTransactionManagerAutoConfiguration.class,
					JdbcTemplateAutoConfiguration.class, IntegrationAutoConfiguration.class,
					FlywayAutoConfiguration.class))
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.integration.jdbc.initialize-schema=always')
			.run((context) -> {
				IntegrationProperties properties = context.getBean(IntegrationProperties.class);
				assertThat(properties.getJdbc().getInitializeSchema()).isEqualTo(DatabaseInitializationMode.ALWAYS);
				JdbcOperations jdbc = context.getBean(JdbcOperations.class);
				assertThat(jdbc.queryForList('select * from INT_MESSAGE')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_GROUP_TO_MESSAGE')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_MESSAGE_GROUP')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_LOCK')).isEmpty();
				assertThat(jdbc.queryForList('select * from INT_CHANNEL_MESSAGE')).isEmpty();
			});
	}
	@Test
	void integrationJdbcDataSourceInitializerDisabled() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceTransactionManagerAutoConfiguration.class,
					JdbcTemplateAutoConfiguration.class, IntegrationAutoConfiguration.class))
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.integration.jdbc.initialize-schema=never')
			.run((context) -> {
				assertThat(context).doesNotHaveBean(IntegrationDataSourceScriptDatabaseInitializer.class);
				IntegrationProperties properties = context.getBean(IntegrationProperties.class);
				assertThat(properties.getJdbc().getInitializeSchema()).isEqualTo(DatabaseInitializationMode.NEVER);
				JdbcOperations jdbc = context.getBean(JdbcOperations.class);
				assertThatExceptionOfType(BadSqlGrammarException.class)
					.isThrownBy(() -> jdbc.queryForList('select * from INT_MESSAGE'));
			});
	}
	@Test
	void integrationJdbcDataSourceInitializerEnabledByDefaultWithEmbeddedDb() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceTransactionManagerAutoConfiguration.class,
					JdbcTemplateAutoConfiguration.class, IntegrationAutoConfiguration.class))
			.withPropertyValues('spring.datasource.generate-unique-name=true')
			.run((context) -> {
				IntegrationProperties properties = context.getBean(IntegrationProperties.class);
				assertThat(properties.getJdbc().getInitializeSchema()).isEqualTo(DatabaseInitializationMode.EMBEDDED);
				JdbcOperations jdbc = context.getBean(JdbcOperations.class);
				assertThat(jdbc.queryForList('select * from INT_MESSAGE')).isEmpty();
			});
	}
	@Test
	void rsocketSupportEnabled() {
		this.contextRunner.withUserConfiguration(RSocketServerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(RSocketServerAutoConfiguration.class,
					RSocketStrategiesAutoConfiguration.class, RSocketMessagingAutoConfiguration.class,
					RSocketRequesterAutoConfiguration.class, IntegrationAutoConfiguration.class))
			.withPropertyValues('spring.rsocket.server.port=0', 'spring.integration.rsocket.client.port=0',
					'spring.integration.rsocket.client.host=localhost',
					'spring.integration.rsocket.server.message-mapping-enabled=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(ClientRSocketConnector.class)
					.hasBean('clientRSocketConnector')
					.hasSingleBean(ServerRSocketConnector.class)
					.hasSingleBean(ServerRSocketMessageHandler.class)
					.hasSingleBean(RSocketMessageHandler.class);
				ServerRSocketMessageHandler serverRSocketMessageHandler = context
					.getBean(ServerRSocketMessageHandler.class);
				assertThat(context).getBean(RSocketMessageHandler.class).isSameAs(serverRSocketMessageHandler);
				ClientRSocketConnector clientRSocketConnector = context.getBean(ClientRSocketConnector.class);
				ClientTransport clientTransport = (ClientTransport) new DirectFieldAccessor(clientRSocketConnector)
					.getPropertyValue('clientTransport');
				assertThat(clientTransport).isInstanceOf(TcpClientTransport.class);
			});
	}
	@Test
	void taskSchedulerIsNotOverridden() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class))
			.withPropertyValues('spring.task.scheduling.thread-name-prefix=integration-scheduling-',
					'spring.task.scheduling.pool.size=3')
			.run((context) -> {
				assertThat(context).hasSingleBean(TaskScheduler.class);
				assertThat(context).getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)
					.hasFieldOrPropertyWithValue('threadNamePrefix', 'integration-scheduling-')
					.hasFieldOrPropertyWithValue('scheduledExecutor.corePoolSize', 3);
			});
	}
	@Test
	void taskSchedulerCanBeCustomized() {
		TaskScheduler customTaskScheduler = mock(TaskScheduler.class);
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class))
			.withBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class, () -> customTaskScheduler)
			.run((context) -> {
				assertThat(context).hasSingleBean(TaskScheduler.class);
				assertThat(context).getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)
					.isSameAs(customTaskScheduler);
			});
	}
	@Test
	void integrationGlobalPropertiesAutoConfigured() {
		String[] propertyValues = { 'spring.integration.channel.auto-create=false',
				'spring.integration.channel.max-unicast-subscribers=2',
				'spring.integration.channel.max-broadcast-subscribers=3',
				'spring.integration.error.require-subscribers=false', 'spring.integration.error.ignore-failures=false',
				'spring.integration.endpoint.defaultTimeout=60s',
				'spring.integration.endpoint.throw-exception-on-late-reply=true',
				'spring.integration.endpoint.read-only-headers=ignoredHeader',
				'spring.integration.endpoint.no-auto-startup=notStartedEndpoint,_org.springframework.integration.errorLogger' };
		assertThat(propertyValues).hasSameSizeAs(globalIntegrationPropertyNames());
		this.contextRunner.withPropertyValues(propertyValues).run((context) -> {
			assertThat(context).hasSingleBean(org.springframework.integration.context.IntegrationProperties.class);
			org.springframework.integration.context.IntegrationProperties integrationProperties = context
				.getBean(org.springframework.integration.context.IntegrationProperties.class);
			assertThat(integrationProperties.isChannelsAutoCreate()).isFalse();
			assertThat(integrationProperties.getChannelsMaxUnicastSubscribers()).isEqualTo(2);
			assertThat(integrationProperties.getChannelsMaxBroadcastSubscribers()).isEqualTo(3);
			assertThat(integrationProperties.isErrorChannelRequireSubscribers()).isFalse();
			assertThat(integrationProperties.isErrorChannelIgnoreFailures()).isFalse();
			assertThat(integrationProperties.getEndpointsDefaultTimeout()).isEqualTo(60000);
			assertThat(integrationProperties.isMessagingTemplateThrowExceptionOnLateReply()).isTrue();
			assertThat(integrationProperties.getReadOnlyHeaders()).containsOnly('ignoredHeader');
			assertThat(integrationProperties.getNoAutoStartupEndpoints()).containsOnly('notStartedEndpoint',
					'_org.springframework.integration.errorLogger');
		});
	}
	@Test
	void integrationGlobalPropertiesUseConsistentDefault() {
		List<PropertyAccessor> properties = List
			.of('isChannelsAutoCreate', 'getChannelsMaxUnicastSubscribers', 'getChannelsMaxBroadcastSubscribers',
					'isErrorChannelRequireSubscribers', 'isErrorChannelIgnoreFailures', 'getEndpointsDefaultTimeout',
					'isMessagingTemplateThrowExceptionOnLateReply', 'getReadOnlyHeaders', 'getNoAutoStartupEndpoints')
			.stream()
			.map(PropertyAccessor::new)
			.toList();
		assertThat(properties).hasSameSizeAs(globalIntegrationPropertyNames());
		org.springframework.integration.context.IntegrationProperties defaultIntegrationProperties = new org.springframework.integration.context.IntegrationProperties();
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(org.springframework.integration.context.IntegrationProperties.class);
			org.springframework.integration.context.IntegrationProperties integrationProperties = context
				.getBean(org.springframework.integration.context.IntegrationProperties.class);
			properties.forEach((property) -> assertThat(property.get(integrationProperties))
				.isEqualTo(property.get(defaultIntegrationProperties)));
		});
	}
	private List<String> globalIntegrationPropertyNames() {
		return Stream
			.of(PropertyAccessorFactory
				.forBeanPropertyAccess(new org.springframework.integration.context.IntegrationProperties())
				.getPropertyDescriptors())
			.map(PropertyDescriptor::getName)
			.filter((name) -> !'class'.equals(name))
			.filter((name) -> !'taskSchedulerPoolSize'.equals(name))
			.toList();
	}
	@Test
	void integrationGlobalPropertiesUserBeanOverridesAutoConfiguration() {
		org.springframework.integration.context.IntegrationProperties userIntegrationProperties = new org.springframework.integration.context.IntegrationProperties();
		this.contextRunner.withPropertyValues()
			.withBean(IntegrationContextUtils.INTEGRATION_GLOBAL_PROPERTIES_BEAN_NAME,
					org.springframework.integration.context.IntegrationProperties.class,
					() -> userIntegrationProperties)
			.run((context) -> {
				assertThat(context).hasSingleBean(org.springframework.integration.context.IntegrationProperties.class);
				assertThat(context.getBean(org.springframework.integration.context.IntegrationProperties.class))
					.isSameAs(userIntegrationProperties);
			});
	}
	@Test
	void integrationGlobalPropertiesFromSpringIntegrationPropertiesFile() {
		this.contextRunner
			.withPropertyValues('spring.integration.channel.auto-create=false',
					'spring.integration.endpoint.read-only-headers=ignoredHeader')
			.withInitializer((applicationContext) -> new IntegrationPropertiesEnvironmentPostProcessor()
				.postProcessEnvironment(applicationContext.getEnvironment(), null))
			.run((context) -> {
				assertThat(context).hasSingleBean(org.springframework.integration.context.IntegrationProperties.class);
				org.springframework.integration.context.IntegrationProperties integrationProperties = context
					.getBean(org.springframework.integration.context.IntegrationProperties.class);
				assertThat(integrationProperties.isChannelsAutoCreate()).isFalse();
				assertThat(integrationProperties.getReadOnlyHeaders()).containsOnly('ignoredHeader');
				// See META-INF/spring.integration.properties
				assertThat(integrationProperties.getNoAutoStartupEndpoints()).containsOnly('testService*');
			});
	}
	@Test
	void whenTheUserDefinesTheirOwnIntegrationDatabaseInitializerThenTheAutoConfiguredInitializerBacksOff() {
		this.contextRunner.withUserConfiguration(CustomIntegrationDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(IntegrationDataSourceScriptDatabaseInitializer.class)
				.doesNotHaveBean('integrationDataSourceScriptDatabaseInitializer')
				.hasBean('customInitializer'));
	}
	@Test
	void whenTheUserDefinesTheirOwnDatabaseInitializerThenTheAutoConfiguredIntegrationInitializerRemains() {
		this.contextRunner.withUserConfiguration(CustomDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(IntegrationDataSourceScriptDatabaseInitializer.class)
				.hasBean('customInitializer'));
	}
	@Test
	void defaultPoller() {
		this.contextRunner.withUserConfiguration(PollingConsumerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(PollerMetadata.class);
			PollerMetadata metadata = context.getBean(PollerMetadata.DEFAULT_POLLER, PollerMetadata.class);
			assertThat(metadata.getMaxMessagesPerPoll()).isEqualTo(PollerMetadata.MAX_MESSAGES_UNBOUNDED);
			assertThat(metadata.getReceiveTimeout()).isEqualTo(PollerMetadata.DEFAULT_RECEIVE_TIMEOUT);
			assertThat(metadata.getTrigger()).isNull();
			GenericMessage<String> testMessage = new GenericMessage<>('test');
			context.getBean('testChannel', QueueChannel.class).send(testMessage);
			assertThat(context.getBean('sink', BlockingQueue.class).poll(10, TimeUnit.SECONDS)).isSameAs(testMessage);
		});
	}
	@Test
	void whenCustomPollerPropertiesAreSetThenTheyAreReflectedInPollerMetadata() {
		this.contextRunner.withUserConfiguration(PollingConsumerConfiguration.class)
			.withPropertyValues('spring.integration.poller.cron=* * * ? * *',
					'spring.integration.poller.max-messages-per-poll=1',
					'spring.integration.poller.receive-timeout=10s')
			.run((context) -> {
				assertThat(context).hasSingleBean(PollerMetadata.class);
				PollerMetadata metadata = context.getBean(PollerMetadata.DEFAULT_POLLER, PollerMetadata.class);
				assertThat(metadata.getMaxMessagesPerPoll()).isOne();
				assertThat(metadata.getReceiveTimeout()).isEqualTo(10000L);
				assertThat(metadata.getTrigger()).asInstanceOf(InstanceOfAssertFactories.type(CronTrigger.class))
					.satisfies((trigger) -> assertThat(trigger.getExpression()).isEqualTo('* * * ? * *'));
			});
	}
	@Test
	void whenPollerPropertiesForMultipleTriggerTypesAreSetThenRefreshFails() {
		this.contextRunner
			.withPropertyValues('spring.integration.poller.cron=* * * ? * *',
					'spring.integration.poller.fixed-delay=1s')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.hasRootCauseExactlyInstanceOf(MutuallyExclusiveConfigurationPropertiesException.class)
				.rootCause()
				.asInstanceOf(InstanceOfAssertFactories.type(MutuallyExclusiveConfigurationPropertiesException.class))
				.satisfies((ex) -> {
					assertThat(ex.getConfiguredNames()).containsExactlyInAnyOrder('spring.integration.poller.cron',
							'spring.integration.poller.fixed-delay');
					assertThat(ex.getMutuallyExclusiveNames()).containsExactlyInAnyOrder(
							'spring.integration.poller.cron', 'spring.integration.poller.fixed-delay',
							'spring.integration.poller.fixed-rate');
				}));
	}
	@Test
	void whenFixedDelayPollerPropertyIsSetThenItIsReflectedAsFixedDelayPropertyOfPeriodicTrigger() {
		this.contextRunner.withUserConfiguration(PollingConsumerConfiguration.class)
			.withPropertyValues('spring.integration.poller.fixed-delay=5000')
			.run((context) -> {
				assertThat(context).hasSingleBean(PollerMetadata.class);
				PollerMetadata metadata = context.getBean(PollerMetadata.DEFAULT_POLLER, PollerMetadata.class);
				assertThat(metadata.getTrigger()).asInstanceOf(InstanceOfAssertFactories.type(PeriodicTrigger.class))
					.satisfies((trigger) -> {
						assertThat(trigger.getPeriodDuration()).isEqualTo(Duration.ofSeconds(5));
						assertThat(trigger.isFixedRate()).isFalse();
					});
			});
	}
	@Test
	void whenFixedRatePollerPropertyIsSetThenItIsReflectedAsFixedRatePropertyOfPeriodicTrigger() {
		this.contextRunner.withUserConfiguration(PollingConsumerConfiguration.class)
			.withPropertyValues('spring.integration.poller.fixed-rate=5000')
			.run((context) -> {
				assertThat(context).hasSingleBean(PollerMetadata.class);
				PollerMetadata metadata = context.getBean(PollerMetadata.DEFAULT_POLLER, PollerMetadata.class);
				assertThat(metadata.getTrigger()).asInstanceOf(InstanceOfAssertFactories.type(PeriodicTrigger.class))
					.satisfies((trigger) -> {
						assertThat(trigger.getPeriodDuration()).isEqualTo(Duration.ofSeconds(5));
						assertThat(trigger.isFixedRate()).isTrue();
					});
			});
	}
	@Test
	void integrationManagementLoggingIsEnabledByDefault() {
		this.contextRunner.withBean(DirectChannel.class, DirectChannel::new)
			.run((context) -> assertThat(context).getBean(DirectChannel.class)
				.extracting(DirectChannel::isLoggingEnabled)
				.isEqualTo(true));
	}
	@Test
	void integrationManagementLoggingCanBeDisabled() {
		this.contextRunner.withPropertyValues('spring.integration.management.defaultLoggingEnabled=false')
			.withBean(DirectChannel.class, DirectChannel::new)
			.run((context) -> assertThat(context).getBean(DirectChannel.class)
				.extracting(DirectChannel::isLoggingEnabled)
				.isEqualTo(false));
	}
	@Test
	void integrationManagementInstrumentedWithObservation() {
		this.contextRunner.withPropertyValues('spring.integration.management.observation-patterns=testHandler')
			.withBean('testHandler', LoggingHandler.class, () -> new LoggingHandler('warn'))
			.withBean(ObservationRegistry.class, ObservationRegistry::create)
			.withBean(BridgeHandler.class, BridgeHandler::new)
			.run((context) -> {
				assertThat(context).getBean('testHandler').extracting('observationRegistry').isNotNull();
				assertThat(context).getBean(BridgeHandler.class)
					.extracting('observationRegistry')
					.isEqualTo(ObservationRegistry.NOOP);
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void integrationVirtualThreadsEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.withConfiguration(AutoConfigurations.of(TaskSchedulingAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(TaskScheduler.class)
				.getBean(IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME, TaskScheduler.class)
				.isInstanceOf(SimpleAsyncTaskScheduler.class)
				.satisfies((taskScheduler) -> SimpleAsyncTaskExecutorAssert
					.assertThat((SimpleAsyncTaskExecutor) taskScheduler)
					.usesVirtualThreads()));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomMBeanExporter {
		@Bean
		@Primary
		MBeanExporter myMBeanExporter() {
			return mock(MBeanExporter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@IntegrationComponentScan
	static class CustomIntegrationComponentScanConfiguration {
	}
	@MessagingGateway
	interface TestGateway extends RequestReplyExchanger {
	}
	@Configuration(proxyBeanMethods = false)
	static class MessageSourceConfiguration {
		@Bean
		MessageSource<?> myMessageSource() {
			return new MessageProcessorMessageSource(mock(MessageProcessor.class));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RSocketServerConfiguration {
		@Bean
		IntegrationRSocketEndpoint mockIntegrationRSocketEndpoint() {
			return new IntegrationRSocketEndpoint() {
				@Override
				public Mono<Void> handleMessage(Message<?> message) {
					return null;
				}
				@Override
				public String[] getPath() {
					return new String[] { '/rsocketTestPath' };
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomIntegrationDatabaseInitializerConfiguration {
		@Bean
		IntegrationDataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource,
				IntegrationProperties properties) {
			return new IntegrationDataSourceScriptDatabaseInitializer(dataSource, properties.getJdbc());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDatabaseInitializerConfiguration {
		@Bean
		DataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource) {
			return new DataSourceScriptDatabaseInitializer(dataSource, new DatabaseInitializationSettings());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PollingConsumerConfiguration {
		@Bean
		QueueChannel testChannel() {
			return new QueueChannel();
		}
		@Bean
		BlockingQueue<Message<?>> sink() {
			return new LinkedBlockingQueue<>();
		}
		@ServiceActivator(inputChannel = 'testChannel')
		@Bean
		MessageHandler handler(BlockingQueue<Message<?>> sink) {
			return sink::add;
		}
	}
	static class PropertyAccessor {
		private final String name;
		PropertyAccessor(String name) {
			this.name = name;
		}
		Object get(org.springframework.integration.context.IntegrationProperties properties) {
			return ReflectionTestUtils.invokeMethod(properties, this.name);
		}
		@Override
		public String toString() {
			return this.name;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.integration;
/**
class IntegrationPropertiesEnvironmentPostProcessorTests {
	@Test
	void postProcessEnvironmentAddPropertySource() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		new IntegrationPropertiesEnvironmentPostProcessor().postProcessEnvironment(environment,
				mock(SpringApplication.class));
		assertThat(environment.getPropertySources().contains('META-INF/spring.integration.properties')).isTrue();
		assertThat(environment.getProperty('spring.integration.endpoint.no-auto-startup')).isEqualTo('testService*');
	}
	@Test
	void postProcessEnvironmentAddPropertySourceLast() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		environment.getPropertySources()
			.addLast(new MapPropertySource('test',
					Collections.singletonMap('spring.integration.endpoint.no-auto-startup', 'another*')));
		new IntegrationPropertiesEnvironmentPostProcessor().postProcessEnvironment(environment,
				mock(SpringApplication.class));
		assertThat(environment.getPropertySources().contains('META-INF/spring.integration.properties')).isTrue();
		assertThat(environment.getProperty('spring.integration.endpoint.no-auto-startup')).isEqualTo('another*');
	}
	@Test
	void registerIntegrationPropertiesPropertySourceWithUnknownResourceThrowsException() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		ClassPathResource unknown = new ClassPathResource('does-not-exist.properties', getClass());
		assertThatIllegalStateException()
			.isThrownBy(() -> new IntegrationPropertiesEnvironmentPostProcessor()
				.registerIntegrationPropertiesPropertySource(environment, unknown))
			.withCauseInstanceOf(FileNotFoundException.class)
			.withMessageContaining(unknown.toString());
	}
	@Test
	void registerIntegrationPropertiesPropertySourceWithResourceAddPropertySource() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		new IntegrationPropertiesEnvironmentPostProcessor().registerIntegrationPropertiesPropertySource(environment,
				new ClassPathResource('spring.integration.properties', getClass()));
		assertThat(environment.getProperty('spring.integration.channel.auto-create', Boolean.class)).isFalse();
		assertThat(environment.getProperty('spring.integration.channel.max-unicast-subscribers', Integer.class))
			.isEqualTo(4);
		assertThat(environment.getProperty('spring.integration.channel.max-broadcast-subscribers', Integer.class))
			.isEqualTo(6);
		assertThat(environment.getProperty('spring.integration.error.require-subscribers', Boolean.class)).isFalse();
		assertThat(environment.getProperty('spring.integration.error.ignore-failures', Boolean.class)).isFalse();
		assertThat(environment.getProperty('spring.integration.endpoint.throw-exception-on-late-reply', Boolean.class))
			.isTrue();
		assertThat(environment.getProperty('spring.integration.endpoint.read-only-headers', String.class))
			.isEqualTo('header1,header2');
		assertThat(environment.getProperty('spring.integration.endpoint.no-auto-startup', String.class))
			.isEqualTo('testService,anotherService');
	}
	@Test
	@SuppressWarnings('unchecked')
	void registerIntegrationPropertiesPropertySourceWithResourceCanRetrieveOrigin() {
		ConfigurableEnvironment environment = new StandardEnvironment();
		ClassPathResource resource = new ClassPathResource('spring.integration.properties', getClass());
		new IntegrationPropertiesEnvironmentPostProcessor().registerIntegrationPropertiesPropertySource(environment,
				resource);
		PropertySource<?> ps = environment.getPropertySources().get('META-INF/spring.integration.properties');
		assertThat(ps).isInstanceOf(OriginLookup.class);
		OriginLookup<String> originLookup = (OriginLookup<String>) ps;
		assertThat(originLookup.getOrigin('spring.integration.channel.auto-create'))
			.satisfies(textOrigin(resource, 0, 39));
		assertThat(originLookup.getOrigin('spring.integration.channel.max-unicast-subscribers'))
			.satisfies(textOrigin(resource, 1, 50));
		assertThat(originLookup.getOrigin('spring.integration.channel.max-broadcast-subscribers'))
			.satisfies(textOrigin(resource, 2, 52));
	}
	@Test
	@SuppressWarnings('unchecked')
	void hasMappingsForAllMappableProperties() throws Exception {
		Class<?> propertySource = ClassUtils.forName('%s.IntegrationPropertiesPropertySource'
			.formatted(IntegrationPropertiesEnvironmentPostProcessor.class.getName()), getClass().getClassLoader());
		Map<String, String> mappings = (Map<String, String>) ReflectionTestUtils.getField(propertySource,
				'KEYS_MAPPING');
		assertThat(mappings.values()).containsExactlyInAnyOrderElementsOf(integrationPropertyNames());
	}
	private static List<String> integrationPropertyNames() {
		List<String> propertiesToMap = new ArrayList<>();
		ReflectionUtils.doWithFields(IntegrationProperties.class, (field) -> {
			String value = (String) ReflectionUtils.getField(field, null);
			if (value.startsWith(IntegrationProperties.INTEGRATION_PROPERTIES_PREFIX)
					&& value.length() > IntegrationProperties.INTEGRATION_PROPERTIES_PREFIX.length()) {
				propertiesToMap.add(value);
			}
		}, (field) -> Modifier.isStatic(field.getModifiers()) && field.getType().equals(String.class));
		propertiesToMap.remove(IntegrationProperties.TASK_SCHEDULER_POOL_SIZE);
		return propertiesToMap;
	}
	@MethodSource('mappedConfigurationProperties')
	@ParameterizedTest
	void mappedPropertiesExistOnBootsIntegrationProperties(String mapping) {
		Bindable<org.springframework.boot.autoconfigure.integration.IntegrationProperties> bindable = Bindable
			.of(org.springframework.boot.autoconfigure.integration.IntegrationProperties.class);
		MockEnvironment environment = new MockEnvironment().withProperty(mapping,
				(mapping.contains('max') || mapping.contains('timeout')) ? '1' : 'true');
		BindResult<org.springframework.boot.autoconfigure.integration.IntegrationProperties> result = Binder
			.get(environment)
			.bind('spring.integration', bindable);
		assertThat(result.isBound()).isTrue();
	}
	@SuppressWarnings('unchecked')
	private static Collection<String> mappedConfigurationProperties() {
		try {
			Class<?> propertySource = ClassUtils.forName('%s.IntegrationPropertiesPropertySource'
				.formatted(IntegrationPropertiesEnvironmentPostProcessor.class.getName()), null);
			Map<String, String> mappings = (Map<String, String>) ReflectionTestUtils.getField(propertySource,
					'KEYS_MAPPING');
			return mappings.keySet();
		}
		catch (Exception ex) {
			throw new RuntimeException(ex);
		}
	}
	private Consumer<Origin> textOrigin(Resource resource, int line, int column) {
		return (origin) -> {
			assertThat(origin).isInstanceOf(TextResourceOrigin.class);
			TextResourceOrigin textOrigin = (TextResourceOrigin) origin;
			assertThat(textOrigin.getResource()).isEqualTo(resource);
			assertThat(textOrigin.getLocation().getLine()).isEqualTo(line);
			assertThat(textOrigin.getLocation().getColumn()).isEqualTo(column);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.integration;
/**
class IntegrationDataSourceScriptDatabaseInitializerTests {
	@Test
	void getSettingsWithPlatformDoesNotTouchDataSource() {
		DataSource dataSource = mock(DataSource.class);
		IntegrationProperties properties = new IntegrationProperties();
		properties.getJdbc().setPlatform('test');
		DatabaseInitializationSettings settings = IntegrationDataSourceScriptDatabaseInitializer.getSettings(dataSource,
				properties.getJdbc());
		assertThat(settings.getSchemaLocations())
			.containsOnly('classpath:org/springframework/integration/jdbc/schema-test.sql');
		then(dataSource).shouldHaveNoInteractions();
	}
}
/*
package org.springframework.boot.autoconfigure.domain;
/**
class EntityScannerTests {
	@Test
	void createWhenContextIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new EntityScanner(null))
			.withMessageContaining('Context must not be null');
	}
	@Test
	void scanShouldScanFromSinglePackage() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanConfig.class);
		EntityScanner scanner = new EntityScanner(context);
		Set<Class<?>> scanned = scanner.scan(Entity.class);
		assertThat(scanned).containsOnly(EntityA.class, EntityB.class, EntityC.class);
		context.close();
	}
	@Test
	void scanShouldScanFromResolvedPlaceholderPackage() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('com.example.entity-package=org.springframework.boot.autoconfigure.domain.scan')
			.applyTo(context);
		context.register(ScanPlaceholderConfig.class);
		context.refresh();
		EntityScanner scanner = new EntityScanner(context);
		Set<Class<?>> scanned = scanner.scan(Entity.class);
		assertThat(scanned).containsOnly(EntityA.class, EntityB.class, EntityC.class);
		context.close();
	}
	@Test
	void scanShouldScanFromMultiplePackages() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanAConfig.class,
				ScanBConfig.class);
		EntityScanner scanner = new EntityScanner(context);
		Set<Class<?>> scanned = scanner.scan(Entity.class);
		assertThat(scanned).containsOnly(EntityA.class, EntityB.class);
		context.close();
	}
	@Test
	void scanShouldFilterOnAnnotation() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanConfig.class);
		EntityScanner scanner = new EntityScanner(context);
		assertThat(scanner.scan(Entity.class)).containsOnly(EntityA.class, EntityB.class, EntityC.class);
		assertThat(scanner.scan(Embeddable.class)).containsOnly(EmbeddableA.class, EmbeddableB.class,
				EmbeddableC.class);
		assertThat(scanner.scan(Entity.class, Embeddable.class)).containsOnly(EntityA.class, EntityB.class,
				EntityC.class, EmbeddableA.class, EmbeddableB.class, EmbeddableC.class);
		context.close();
	}
	@Test
	void scanShouldUseCustomCandidateComponentProvider() throws ClassNotFoundException {
		ClassPathScanningCandidateComponentProvider candidateComponentProvider = mock(
				ClassPathScanningCandidateComponentProvider.class);
		given(candidateComponentProvider.findCandidateComponents('org.springframework.boot.autoconfigure.domain.scan'))
			.willReturn(Collections.emptySet());
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ScanConfig.class);
		TestEntityScanner scanner = new TestEntityScanner(context, candidateComponentProvider);
		scanner.scan(Entity.class);
		then(candidateComponentProvider).should()
			.addIncludeFilter(
					assertArg((typeFilter) -> assertThat(typeFilter).isInstanceOfSatisfying(AnnotationTypeFilter.class,
							(filter) -> assertThat(filter.getAnnotationType()).isEqualTo(Entity.class))));
		then(candidateComponentProvider).should()
			.findCandidateComponents('org.springframework.boot.autoconfigure.domain.scan');
		then(candidateComponentProvider).shouldHaveNoMoreInteractions();
	}
	@Test
	void scanShouldScanCommaSeparatedPackagesInPlaceholderPackage() throws Exception {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues
			.of('com.example.entity-package=org.springframework.boot.autoconfigure.domain.scan.a,org.springframework.boot.autoconfigure.domain.scan.b')
			.applyTo(context);
		context.register(ScanPlaceholderConfig.class);
		context.refresh();
		EntityScanner scanner = new EntityScanner(context);
		Set<Class<?>> scanned = scanner.scan(Entity.class);
		assertThat(scanned).containsOnly(EntityA.class, EntityB.class);
		context.close();
	}
	private static class TestEntityScanner extends EntityScanner {
		private final ClassPathScanningCandidateComponentProvider candidateComponentProvider;
		TestEntityScanner(ApplicationContext context,
				ClassPathScanningCandidateComponentProvider candidateComponentProvider) {
			super(context);
			this.candidateComponentProvider = candidateComponentProvider;
		}
		@Override
		protected ClassPathScanningCandidateComponentProvider createClassPathScanningCandidateComponentProvider(
				ApplicationContext context) {
			return this.candidateComponentProvider;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('org.springframework.boot.autoconfigure.domain.scan')
	static class ScanConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan(basePackageClasses = EntityA.class)
	static class ScanAConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan(basePackageClasses = EntityB.class)
	static class ScanBConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('${com.example.entity-package}')
	static class ScanPlaceholderConfig {
	}
}
/*
package org.springframework.boot.autoconfigure.domain;
/**
class EntityScanPackagesTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void cleanup() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void getWhenNoneRegisteredShouldReturnNone() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.refresh();
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages).isNotNull();
		assertThat(packages.getPackageNames()).isEmpty();
	}
	@Test
	void getShouldReturnRegisterPackages() {
		this.context = new AnnotationConfigApplicationContext();
		EntityScanPackages.register(this.context, 'a', 'b');
		EntityScanPackages.register(this.context, 'b', 'c');
		this.context.refresh();
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages.getPackageNames()).containsExactly('a', 'b', 'c');
	}
	@Test
	void registerFromArrayWhenRegistryIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> EntityScanPackages.register(null))
			.withMessageContaining('Registry must not be null');
	}
	@Test
	void registerFromArrayWhenPackageNamesIsNullShouldThrowException() {
		this.context = new AnnotationConfigApplicationContext();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> EntityScanPackages.register(this.context, (String[]) null))
			.withMessageContaining('PackageNames must not be null');
	}
	@Test
	void registerFromCollectionWhenRegistryIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> EntityScanPackages.register(null, Collections.emptyList()))
			.withMessageContaining('Registry must not be null');
	}
	@Test
	void registerFromCollectionWhenPackageNamesIsNullShouldThrowException() {
		this.context = new AnnotationConfigApplicationContext();
		assertThatIllegalArgumentException()
			.isThrownBy(() -> EntityScanPackages.register(this.context, (Collection<String>) null))
			.withMessageContaining('PackageNames must not be null');
	}
	@Test
	void entityScanAnnotationWhenHasValueAttributeShouldSetupPackages() {
		this.context = new AnnotationConfigApplicationContext(EntityScanValueConfig.class);
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages.getPackageNames()).containsExactly('a');
	}
	@Test
	void entityScanAnnotationWhenHasValueAttributeShouldSetupPackagesAsm() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.registerBeanDefinition('entityScanValueConfig',
				new RootBeanDefinition(EntityScanValueConfig.class.getName()));
		this.context.refresh();
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages.getPackageNames()).containsExactly('a');
	}
	@Test
	void entityScanAnnotationWhenHasBasePackagesAttributeShouldSetupPackages() {
		this.context = new AnnotationConfigApplicationContext(EntityScanBasePackagesConfig.class);
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages.getPackageNames()).containsExactly('b');
	}
	@Test
	void entityScanAnnotationWhenHasValueAndBasePackagesAttributeShouldThrow() {
		assertThatExceptionOfType(AnnotationConfigurationException.class)
			.isThrownBy(() -> this.context = new AnnotationConfigApplicationContext(
					EntityScanValueAndBasePackagesConfig.class));
	}
	@Test
	void entityScanAnnotationWhenHasBasePackageClassesAttributeShouldSetupPackages() {
		this.context = new AnnotationConfigApplicationContext(EntityScanBasePackageClassesConfig.class);
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages.getPackageNames()).containsExactly(getClass().getPackage().getName());
	}
	@Test
	void entityScanAnnotationWhenNoAttributesShouldSetupPackages() {
		this.context = new AnnotationConfigApplicationContext(EntityScanNoAttributesConfig.class);
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages.getPackageNames()).containsExactly(getClass().getPackage().getName());
	}
	@Test
	void entityScanAnnotationWhenLoadingFromMultipleConfigsShouldCombinePackages() {
		this.context = new AnnotationConfigApplicationContext(EntityScanValueConfig.class,
				EntityScanBasePackagesConfig.class);
		EntityScanPackages packages = EntityScanPackages.get(this.context);
		assertThat(packages.getPackageNames()).containsExactly('a', 'b');
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('a')
	static class EntityScanValueConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan(basePackages = 'b')
	static class EntityScanBasePackagesConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan(value = 'a', basePackages = 'b')
	static class EntityScanValueAndBasePackagesConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan(basePackageClasses = EntityScanPackagesTests.class)
	static class EntityScanBasePackageClassesConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan
	static class EntityScanNoAttributesConfig {
	}
}
/*
package org.springframework.boot.autoconfigure.domain.scan.c;
@Embeddable
public class EmbeddableC {
}
/*
package org.springframework.boot.autoconfigure.domain.scan.c;
@Entity
public class EntityC {
}
/*
package org.springframework.boot.autoconfigure.domain.scan.b;
@Embeddable
public class EmbeddableB {
}
/*
package org.springframework.boot.autoconfigure.domain.scan.b;
@Entity
public class EntityB {
}
/*
package org.springframework.boot.autoconfigure.domain.scan.a;
@Entity
public class EntityA {
}
/*
package org.springframework.boot.autoconfigure.domain.scan.a;
@Embeddable
public class EmbeddableA {
}
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
class CassandraAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CassandraAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void cqlSessionBuildHasScopePrototype() {
		this.contextRunner.run((context) -> {
			CqlIdentifier keyspace = CqlIdentifier.fromCql('test');
			CqlSessionBuilder firstBuilder = context.getBean(CqlSessionBuilder.class);
			assertThat(firstBuilder.withKeyspace(keyspace)).hasFieldOrPropertyWithValue('keyspace', keyspace);
			CqlSessionBuilder secondBuilder = context.getBean(CqlSessionBuilder.class);
			assertThat(secondBuilder).hasFieldOrPropertyWithValue('keyspace', null);
		});
	}
	@Test
	void cqlSessionBuilderWithNoSslConfiguration() {
		this.contextRunner.run((context) -> {
			CqlSessionBuilder builder = context.getBean(CqlSessionBuilder.class);
			assertThat(builder).hasFieldOrPropertyWithValue('programmaticSslFactory', false);
		});
	}
	@Test
	void cqlSessionBuilderWithSslEnabled() {
		this.contextRunner.withPropertyValues('spring.cassandra.ssl.enabled=true').run((context) -> {
			CqlSessionBuilder builder = context.getBean(CqlSessionBuilder.class);
			assertThat(builder).hasFieldOrPropertyWithValue('programmaticSslFactory', true);
		});
	}
	@Test
	void cqlSessionBuilderWithSslBundle() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.ssl.bundle=test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location=classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password=secret',
					'spring.ssl.bundle.jks.test-bundle.key.password=password')
			.run((context) -> {
				CqlSessionBuilder builder = context.getBean(CqlSessionBuilder.class);
				assertThat(builder).hasFieldOrPropertyWithValue('programmaticSslFactory', true);
			});
	}
	@Test
	void cqlSessionBuilderWithSslBundleAndSslDisabled() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.ssl.enabled=false', 'spring.cassandra.ssl.bundle=test-bundle')
			.run((context) -> {
				CqlSessionBuilder builder = context.getBean(CqlSessionBuilder.class);
				assertThat(builder).hasFieldOrPropertyWithValue('programmaticSslFactory', false);
			});
	}
	@Test
	void cqlSessionBuilderWithInvalidSslBundle() {
		this.contextRunner.withPropertyValues('spring.cassandra.ssl.bundle=test-bundle')
			.run((context) -> assertThatException().isThrownBy(() -> context.getBean(CqlSessionBuilder.class))
				.withRootCauseInstanceOf(NoSuchSslBundleException.class)
				.withMessageContaining('test-bundle'));
	}
	@Test
	void driverConfigLoaderWithDefaultConfiguration() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(DriverConfigLoader.class);
			assertThat(context.getBean(DriverConfigLoader.class)
				.getInitialConfig()
				.getDefaultProfile()
				.isDefined(DefaultDriverOption.SESSION_NAME)).isFalse();
		});
	}
	@Test
	void driverConfigLoaderWithContactPoints() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.contact-points=cluster.example.com:9042',
					'spring.cassandra.local-datacenter=cassandra-eu1')
			.run((context) -> {
				assertThat(context).hasSingleBean(DriverConfigLoader.class);
				DriverExecutionProfile configuration = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(configuration.getStringList(DefaultDriverOption.CONTACT_POINTS))
					.containsOnly('cluster.example.com:9042');
				assertThat(configuration.getString(DefaultDriverOption.LOAD_BALANCING_LOCAL_DATACENTER))
					.isEqualTo('cassandra-eu1');
			});
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(PropertiesCassandraConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.contact-points=localhost:9042', 'spring.cassandra.username=a-user',
					'spring.cassandra.password=a-password', 'spring.cassandra.local-datacenter=some-datacenter')
			.withBean(CassandraConnectionDetails.class, this::cassandraConnectionDetails)
			.run((context) -> {
				assertThat(context).hasSingleBean(DriverConfigLoader.class)
					.hasSingleBean(CassandraConnectionDetails.class)
					.doesNotHaveBean(PropertiesCassandraConnectionDetails.class);
				DriverExecutionProfile configuration = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(configuration.getStringList(DefaultDriverOption.CONTACT_POINTS))
					.containsOnly('cassandra.example.com:9042');
				assertThat(configuration.getString(DefaultDriverOption.AUTH_PROVIDER_USER_NAME)).isEqualTo('user-1');
				assertThat(configuration.getString(DefaultDriverOption.AUTH_PROVIDER_PASSWORD)).isEqualTo('secret-1');
				assertThat(configuration.getString(DefaultDriverOption.LOAD_BALANCING_LOCAL_DATACENTER))
					.isEqualTo('datacenter-1');
			});
	}
	@Test
	void driverConfigLoaderWithContactPointAndNoPort() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.contact-points=cluster.example.com,another.example.com:9041',
					'spring.cassandra.local-datacenter=cassandra-eu1')
			.run((context) -> {
				assertThat(context).hasSingleBean(DriverConfigLoader.class);
				DriverExecutionProfile configuration = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(configuration.getStringList(DefaultDriverOption.CONTACT_POINTS))
					.containsOnly('cluster.example.com:9042', 'another.example.com:9041');
				assertThat(configuration.getString(DefaultDriverOption.LOAD_BALANCING_LOCAL_DATACENTER))
					.isEqualTo('cassandra-eu1');
			});
	}
	@Test
	void driverConfigLoaderWithContactPointAndNoPortAndCustomPort() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.contact-points=cluster.example.com:9041,another.example.com',
					'spring.cassandra.port=9043', 'spring.cassandra.local-datacenter=cassandra-eu1')
			.run((context) -> {
				assertThat(context).hasSingleBean(DriverConfigLoader.class);
				DriverExecutionProfile configuration = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(configuration.getStringList(DefaultDriverOption.CONTACT_POINTS))
					.containsOnly('cluster.example.com:9041', 'another.example.com:9043');
				assertThat(configuration.getString(DefaultDriverOption.LOAD_BALANCING_LOCAL_DATACENTER))
					.isEqualTo('cassandra-eu1');
			});
	}
	@Test
	void driverConfigLoaderWithCustomSessionName() {
		this.contextRunner.withPropertyValues('spring.cassandra.session-name=testcluster').run((context) -> {
			assertThat(context).hasSingleBean(DriverConfigLoader.class);
			assertThat(context.getBean(DriverConfigLoader.class)
				.getInitialConfig()
				.getDefaultProfile()
				.getString(DefaultDriverOption.SESSION_NAME)).isEqualTo('testcluster');
		});
	}
	@Test
	void driverConfigLoaderWithCustomSessionNameAndCustomizer() {
		this.contextRunner.withUserConfiguration(SimpleDriverConfigLoaderBuilderCustomizerConfig.class)
			.withPropertyValues('spring.cassandra.session-name=testcluster')
			.run((context) -> {
				assertThat(context).hasSingleBean(DriverConfigLoader.class);
				assertThat(context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile()
					.getString(DefaultDriverOption.SESSION_NAME)).isEqualTo('overridden-name');
			});
	}
	@Test
	void driverConfigLoaderCustomizeConnectionOptions() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.connection.connect-timeout=200ms',
					'spring.cassandra.connection.init-query-timeout=10')
			.run((context) -> {
				DriverExecutionProfile config = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(config.getInt(DefaultDriverOption.CONNECTION_CONNECT_TIMEOUT)).isEqualTo(200);
				assertThat(config.getInt(DefaultDriverOption.CONNECTION_INIT_QUERY_TIMEOUT)).isEqualTo(10);
			});
	}
	@Test
	void driverConfigLoaderCustomizePoolOptions() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.pool.idle-timeout=42', 'spring.cassandra.pool.heartbeat-interval=62')
			.run((context) -> {
				DriverExecutionProfile config = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(config.getInt(DefaultDriverOption.HEARTBEAT_TIMEOUT)).isEqualTo(42);
				assertThat(config.getInt(DefaultDriverOption.HEARTBEAT_INTERVAL)).isEqualTo(62);
			});
	}
	@Test
	void driverConfigLoaderCustomizeRequestOptions() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.request.timeout=5s', 'spring.cassandra.request.consistency=two',
					'spring.cassandra.request.serial-consistency=quorum', 'spring.cassandra.request.page-size=42')
			.run((context) -> {
				DriverExecutionProfile config = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(config.getInt(DefaultDriverOption.REQUEST_TIMEOUT)).isEqualTo(5000);
				assertThat(config.getString(DefaultDriverOption.REQUEST_CONSISTENCY)).isEqualTo('TWO');
				assertThat(config.getString(DefaultDriverOption.REQUEST_SERIAL_CONSISTENCY)).isEqualTo('QUORUM');
				assertThat(config.getInt(DefaultDriverOption.REQUEST_PAGE_SIZE)).isEqualTo(42);
			});
	}
	@Test
	void driverConfigLoaderCustomizeControlConnectionOptions() {
		this.contextRunner.withPropertyValues('spring.cassandra.controlconnection.timeout=200ms').run((context) -> {
			DriverExecutionProfile config = context.getBean(DriverConfigLoader.class)
				.getInitialConfig()
				.getDefaultProfile();
			assertThat(config.getInt(DefaultDriverOption.CONTROL_CONNECTION_TIMEOUT)).isEqualTo(200);
		});
	}
	@Test
	void driverConfigLoaderUsePassThroughLimitingRequestThrottlerByDefault() {
		this.contextRunner.withPropertyValues().run((context) -> {
			DriverExecutionProfile config = context.getBean(DriverConfigLoader.class)
				.getInitialConfig()
				.getDefaultProfile();
			assertThat(config.getString(DefaultDriverOption.REQUEST_THROTTLER_CLASS))
				.isEqualTo(PassThroughRequestThrottler.class.getSimpleName());
		});
	}
	@Test
	void driverConfigLoaderWithRateLimitingRequiresExtraConfiguration() {
		this.contextRunner.withPropertyValues('spring.cassandra.request.throttler.type=rate-limiting')
			.run((context) -> assertThatExceptionOfType(BeanCreationException.class)
				.isThrownBy(() -> context.getBean(CqlSession.class))
				.withMessageContaining('Error instantiating class RateLimitingRequestThrottler')
				.withMessageContaining('No configuration setting found for key'));
	}
	@Test
	void driverConfigLoaderCustomizeConcurrencyLimitingRequestThrottler() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.request.throttler.type=concurrency-limiting',
					'spring.cassandra.request.throttler.max-concurrent-requests=62',
					'spring.cassandra.request.throttler.max-queue-size=72')
			.run((context) -> {
				DriverExecutionProfile config = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(config.getString(DefaultDriverOption.REQUEST_THROTTLER_CLASS))
					.isEqualTo(ConcurrencyLimitingRequestThrottler.class.getSimpleName());
				assertThat(config.getInt(DefaultDriverOption.REQUEST_THROTTLER_MAX_CONCURRENT_REQUESTS)).isEqualTo(62);
				assertThat(config.getInt(DefaultDriverOption.REQUEST_THROTTLER_MAX_QUEUE_SIZE)).isEqualTo(72);
			});
	}
	@Test
	void driverConfigLoaderCustomizeRateLimitingRequestThrottler() {
		this.contextRunner
			.withPropertyValues('spring.cassandra.request.throttler.type=rate-limiting',
					'spring.cassandra.request.throttler.max-requests-per-second=62',
					'spring.cassandra.request.throttler.max-queue-size=72',
					'spring.cassandra.request.throttler.drain-interval=16ms')
			.run((context) -> {
				DriverExecutionProfile config = context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile();
				assertThat(config.getString(DefaultDriverOption.REQUEST_THROTTLER_CLASS))
					.isEqualTo(RateLimitingRequestThrottler.class.getSimpleName());
				assertThat(config.getInt(DefaultDriverOption.REQUEST_THROTTLER_MAX_REQUESTS_PER_SECOND)).isEqualTo(62);
				assertThat(config.getInt(DefaultDriverOption.REQUEST_THROTTLER_MAX_QUEUE_SIZE)).isEqualTo(72);
				assertThat(config.getInt(DefaultDriverOption.REQUEST_THROTTLER_DRAIN_INTERVAL)).isEqualTo(16);
			});
	}
	@Test
	void driverConfigLoaderWithConfigComplementSettings() {
		String configLocation = 'org/springframework/boot/autoconfigure/cassandra/simple.conf';
		this.contextRunner
			.withPropertyValues('spring.cassandra.session-name=testcluster',
					'spring.cassandra.config=' + configLocation)
			.run((context) -> {
				assertThat(context).hasSingleBean(DriverConfigLoader.class);
				assertThat(context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile()
					.getString(DefaultDriverOption.SESSION_NAME)).isEqualTo('testcluster');
				assertThat(context.getBean(DriverConfigLoader.class)
					.getInitialConfig()
					.getDefaultProfile()
					.getDuration(DefaultDriverOption.REQUEST_TIMEOUT)).isEqualTo(Duration.ofMillis(500));
			});
	}
	@Test // gh-31238
	void driverConfigLoaderWithConfigOverridesDefaults() {
		String configLocation = 'org/springframework/boot/autoconfigure/cassandra/override-defaults.conf';
		this.contextRunner.withPropertyValues('spring.cassandra.config=' + configLocation).run((context) -> {
			DriverExecutionProfile actual = context.getBean(DriverConfigLoader.class)
				.getInitialConfig()
				.getDefaultProfile();
			assertThat(actual.getString(DefaultDriverOption.SESSION_NAME)).isEqualTo('advanced session');
			assertThat(actual.getDuration(DefaultDriverOption.REQUEST_TIMEOUT)).isEqualTo(Duration.ofSeconds(2));
			assertThat(actual.getStringList(DefaultDriverOption.CONTACT_POINTS))
				.isEqualTo(Collections.singletonList('1.2.3.4:5678'));
			assertThat(actual.getBoolean(DefaultDriverOption.RESOLVE_CONTACT_POINTS)).isFalse();
			assertThat(actual.getInt(DefaultDriverOption.REQUEST_PAGE_SIZE)).isEqualTo(11);
			assertThat(actual.getString(DefaultDriverOption.LOAD_BALANCING_LOCAL_DATACENTER)).isEqualTo('datacenter1');
			assertThat(actual.getInt(DefaultDriverOption.REQUEST_THROTTLER_MAX_CONCURRENT_REQUESTS)).isEqualTo(22);
			assertThat(actual.getInt(DefaultDriverOption.REQUEST_THROTTLER_MAX_REQUESTS_PER_SECOND)).isEqualTo(33);
			assertThat(actual.getInt(DefaultDriverOption.REQUEST_THROTTLER_MAX_QUEUE_SIZE)).isEqualTo(44);
			assertThat(actual.getDuration(DefaultDriverOption.CONTROL_CONNECTION_TIMEOUT))
				.isEqualTo(Duration.ofMillis(5555));
			assertThat(actual.getString(DefaultDriverOption.PROTOCOL_COMPRESSION)).isEqualTo('SNAPPY');
		});
	}
	@Test
	void placeholdersInReferenceConfAreResolvedAgainstConfigDerivedFromSpringCassandraProperties() {
		this.contextRunner.withPropertyValues('spring.cassandra.request.timeout=60s').run((context) -> {
			DriverExecutionProfile actual = context.getBean(DriverConfigLoader.class)
				.getInitialConfig()
				.getDefaultProfile();
			assertThat(actual.getDuration(DefaultDriverOption.REQUEST_TIMEOUT)).isEqualTo(Duration.ofSeconds(60));
			assertThat(actual.getDuration(DefaultDriverOption.METADATA_SCHEMA_REQUEST_TIMEOUT))
				.isEqualTo(Duration.ofSeconds(60));
		});
	}
	@Test
	void driverConfigLoaderWithConfigCreateProfiles() {
		String configLocation = 'org/springframework/boot/autoconfigure/cassandra/profiles.conf';
		this.contextRunner.withPropertyValues('spring.cassandra.config=' + configLocation).run((context) -> {
			assertThat(context).hasSingleBean(DriverConfigLoader.class);
			DriverConfig driverConfig = context.getBean(DriverConfigLoader.class).getInitialConfig();
			assertThat(driverConfig.getProfiles()).containsOnlyKeys('default', 'first', 'second');
			assertThat(driverConfig.getProfile('first').getDuration(DefaultDriverOption.REQUEST_TIMEOUT))
				.isEqualTo(Duration.ofMillis(100));
		});
	}
	private CassandraConnectionDetails cassandraConnectionDetails() {
		return new CassandraConnectionDetails() {
			@Override
			public List<Node> getContactPoints() {
				return List.of(new Node('cassandra.example.com', 9042));
			}
			@Override
			public String getUsername() {
				return 'user-1';
			}
			@Override
			public String getPassword() {
				return 'secret-1';
			}
			@Override
			public String getLocalDatacenter() {
				return 'datacenter-1';
			}
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class SimpleDriverConfigLoaderBuilderCustomizerConfig {
		@Bean
		DriverConfigLoaderBuilderCustomizer customizer() {
			return (builder) -> builder.withString(DefaultDriverOption.SESSION_NAME, 'overridden-name');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
class CassandraPropertiesTests {
	/**
	 * To let a configuration file override values, {@link CassandraProperties} can"t have
	 * any default hardcoded. This test makes sure that the default that we moved to
	 * manual meta-data are accurate.
	 */
	@Test
	void defaultValuesInManualMetadataAreConsistent() {
		OptionsMap driverDefaults = OptionsMap.driverDefaults();
		// spring.cassandra.connection.connect-timeout
		assertThat(driverDefaults.get(TypedDriverOption.CONNECTION_CONNECT_TIMEOUT)).isEqualTo(Duration.ofSeconds(5));
		// spring.cassandra.connection.init-query-timeout
		assertThat(driverDefaults.get(TypedDriverOption.CONNECTION_INIT_QUERY_TIMEOUT))
			.isEqualTo(Duration.ofSeconds(5));
		// spring.cassandra.request.timeout
		assertThat(driverDefaults.get(TypedDriverOption.REQUEST_TIMEOUT)).isEqualTo(Duration.ofSeconds(2));
		// spring.cassandra.request.page-size
		assertThat(driverDefaults.get(TypedDriverOption.REQUEST_PAGE_SIZE)).isEqualTo(5000);
		// spring.cassandra.request.throttler.type
		assertThat(driverDefaults.get(TypedDriverOption.REQUEST_THROTTLER_CLASS))
			.isEqualTo('PassThroughRequestThrottler'); // 'none'
		// spring.cassandra.pool.heartbeat-interval
		assertThat(driverDefaults.get(TypedDriverOption.HEARTBEAT_INTERVAL)).isEqualTo(Duration.ofSeconds(30));
		// spring.cassandra.pool.idle-timeout
		assertThat(driverDefaults.get(TypedDriverOption.HEARTBEAT_TIMEOUT)).isEqualTo(Duration.ofSeconds(5));
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationImportSelectorTests {
	private final TestAutoConfigurationImportSelector importSelector = new TestAutoConfigurationImportSelector(null);
	private final ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	private final MockEnvironment environment = new MockEnvironment();
	private final List<AutoConfigurationImportFilter> filters = new ArrayList<>();
	@BeforeEach
	void setup() {
		setupImportSelector(this.importSelector);
	}
	@Test
	void importsAreSelectedWhenUsingEnableAutoConfiguration() {
		String[] imports = selectImports(BasicEnableAutoConfiguration.class);
		assertThat(imports).hasSameSizeAs(getAutoConfigurationClassNames());
		assertThat(this.importSelector.getLastEvent().getExclusions()).isEmpty();
	}
	@Test
	void classExclusionsAreApplied() {
		String[] imports = selectImports(EnableAutoConfigurationWithClassExclusions.class);
		assertThat(imports).hasSize(getAutoConfigurationClassNames().size() - 1);
		assertThat(this.importSelector.getLastEvent().getExclusions())
			.contains(FreeMarkerAutoConfiguration.class.getName());
	}
	@Test
	void classExclusionsAreAppliedWhenUsingSpringBootApplication() {
		String[] imports = selectImports(SpringBootApplicationWithClassExclusions.class);
		assertThat(imports).hasSize(getAutoConfigurationClassNames().size() - 1);
		assertThat(this.importSelector.getLastEvent().getExclusions())
			.contains(FreeMarkerAutoConfiguration.class.getName());
	}
	@Test
	void classNamesExclusionsAreApplied() {
		String[] imports = selectImports(EnableAutoConfigurationWithClassNameExclusions.class);
		assertThat(imports).hasSize(getAutoConfigurationClassNames().size() - 1);
		assertThat(this.importSelector.getLastEvent().getExclusions())
			.contains(MustacheAutoConfiguration.class.getName());
	}
	@Test
	void classNamesExclusionsAreAppliedWhenUsingSpringBootApplication() {
		String[] imports = selectImports(SpringBootApplicationWithClassNameExclusions.class);
		assertThat(imports).hasSize(getAutoConfigurationClassNames().size() - 1);
		assertThat(this.importSelector.getLastEvent().getExclusions())
			.contains(MustacheAutoConfiguration.class.getName());
	}
	@Test
	void propertyExclusionsAreApplied() {
		this.environment.setProperty('spring.autoconfigure.exclude', FreeMarkerAutoConfiguration.class.getName());
		String[] imports = selectImports(BasicEnableAutoConfiguration.class);
		assertThat(imports).hasSize(getAutoConfigurationClassNames().size() - 1);
		assertThat(this.importSelector.getLastEvent().getExclusions())
			.contains(FreeMarkerAutoConfiguration.class.getName());
	}
	@Test
	void severalPropertyExclusionsAreApplied() {
		this.environment.setProperty('spring.autoconfigure.exclude',
				FreeMarkerAutoConfiguration.class.getName() + ',' + MustacheAutoConfiguration.class.getName());
		testSeveralPropertyExclusionsAreApplied();
	}
	@Test
	void severalPropertyExclusionsAreAppliedWithExtraSpaces() {
		this.environment.setProperty('spring.autoconfigure.exclude',
				FreeMarkerAutoConfiguration.class.getName() + ' , ' + MustacheAutoConfiguration.class.getName() + ' ');
		testSeveralPropertyExclusionsAreApplied();
	}
	@Test
	void severalPropertyYamlExclusionsAreApplied() {
		this.environment.setProperty('spring.autoconfigure.exclude[0]', FreeMarkerAutoConfiguration.class.getName());
		this.environment.setProperty('spring.autoconfigure.exclude[1]', MustacheAutoConfiguration.class.getName());
		testSeveralPropertyExclusionsAreApplied();
	}
	private void testSeveralPropertyExclusionsAreApplied() {
		String[] imports = selectImports(BasicEnableAutoConfiguration.class);
		assertThat(imports).hasSize(getAutoConfigurationClassNames().size() - 2);
		assertThat(this.importSelector.getLastEvent().getExclusions())
			.contains(FreeMarkerAutoConfiguration.class.getName(), MustacheAutoConfiguration.class.getName());
	}
	@Test
	void combinedExclusionsAreApplied() {
		this.environment.setProperty('spring.autoconfigure.exclude', ThymeleafAutoConfiguration.class.getName());
		String[] imports = selectImports(EnableAutoConfigurationWithClassAndClassNameExclusions.class);
		assertThat(imports).hasSize(getAutoConfigurationClassNames().size() - 3);
		assertThat(this.importSelector.getLastEvent().getExclusions()).contains(
				FreeMarkerAutoConfiguration.class.getName(), MustacheAutoConfiguration.class.getName(),
				ThymeleafAutoConfiguration.class.getName());
	}
	@Test
	void removedExclusionsAreApplied() {
		TestAutoConfigurationImportSelector importSelector = new TestAutoConfigurationImportSelector(
				TestAutoConfiguration.class);
		setupImportSelector(importSelector);
		AnnotationMetadata metadata = AnnotationMetadata.introspect(BasicEnableAutoConfiguration.class);
		assertThat(importSelector.selectImports(metadata)).contains(ReplacementAutoConfiguration.class.getName());
		this.environment.setProperty('spring.autoconfigure.exclude', DeprecatedAutoConfiguration.class.getName());
		assertThat(importSelector.selectImports(metadata)).doesNotContain(ReplacementAutoConfiguration.class.getName());
	}
	@Test
	void nonAutoConfigurationClassExclusionsShouldThrowException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> selectImports(EnableAutoConfigurationWithFaultyClassExclude.class));
	}
	@Test
	void nonAutoConfigurationClassNameExclusionsWhenPresentOnClassPathShouldThrowException() {
		assertThatIllegalStateException()
			.isThrownBy(() -> selectImports(EnableAutoConfigurationWithFaultyClassNameExclude.class));
	}
	@Test
	void nonAutoConfigurationPropertyExclusionsWhenPresentOnClassPathShouldThrowException() {
		this.environment.setProperty('spring.autoconfigure.exclude',
				'org.springframework.boot.autoconfigure.AutoConfigurationImportSelectorTests.TestConfiguration');
		assertThatIllegalStateException().isThrownBy(() -> selectImports(BasicEnableAutoConfiguration.class));
	}
	@Test
	void nameAndPropertyExclusionsWhenNotPresentOnClasspathShouldNotThrowException() {
		this.environment.setProperty('spring.autoconfigure.exclude',
				'org.springframework.boot.autoconfigure.DoesNotExist2');
		selectImports(EnableAutoConfigurationWithAbsentClassNameExclude.class);
		assertThat(this.importSelector.getLastEvent().getExclusions()).containsExactlyInAnyOrder(
				'org.springframework.boot.autoconfigure.DoesNotExist1',
				'org.springframework.boot.autoconfigure.DoesNotExist2');
	}
	@Test
	void filterShouldFilterImports() {
		String[] defaultImports = selectImports(BasicEnableAutoConfiguration.class);
		this.filters.add(new TestAutoConfigurationImportFilter(defaultImports, 1));
		this.filters.add(new TestAutoConfigurationImportFilter(defaultImports, 3, 4));
		String[] filtered = selectImports(BasicEnableAutoConfiguration.class);
		assertThat(filtered).hasSize(defaultImports.length - 3);
		assertThat(filtered).doesNotContain(defaultImports[1], defaultImports[3], defaultImports[4]);
	}
	@Test
	void filterShouldSupportAware() {
		TestAutoConfigurationImportFilter filter = new TestAutoConfigurationImportFilter(new String[] {});
		this.filters.add(filter);
		selectImports(BasicEnableAutoConfiguration.class);
		assertThat(filter.getBeanFactory()).isEqualTo(this.beanFactory);
	}
	@Test
	void getExclusionFilterReuseFilters() {
		String[] allImports = new String[] { 'com.example.A', 'com.example.B', 'com.example.C' };
		this.filters.add(new TestAutoConfigurationImportFilter(allImports, 0));
		this.filters.add(new TestAutoConfigurationImportFilter(allImports, 2));
		assertThat(this.importSelector.getExclusionFilter().test('com.example.A')).isTrue();
		assertThat(this.importSelector.getExclusionFilter().test('com.example.B')).isFalse();
		assertThat(this.importSelector.getExclusionFilter().test('com.example.C')).isTrue();
	}
	@Test
	void soringConsidersReplacements() {
		TestAutoConfigurationImportSelector importSelector = new TestAutoConfigurationImportSelector(
				TestAutoConfiguration.class);
		setupImportSelector(importSelector);
		AnnotationMetadata metadata = AnnotationMetadata.introspect(BasicEnableAutoConfiguration.class);
		assertThat(importSelector.selectImports(metadata)).containsExactly(
				AfterDeprecatedAutoConfiguration.class.getName(), ReplacementAutoConfiguration.class.getName());
		Group group = BeanUtils.instantiateClass(importSelector.getImportGroup());
		((BeanFactoryAware) group).setBeanFactory(this.beanFactory);
		group.process(metadata, importSelector);
		Stream<Entry> imports = StreamSupport.stream(group.selectImports().spliterator(), false);
		assertThat(imports.map(Entry::getImportClassName)).containsExactly(ReplacementAutoConfiguration.class.getName(),
				AfterDeprecatedAutoConfiguration.class.getName());
	}
	private String[] selectImports(Class<?> source) {
		return this.importSelector.selectImports(AnnotationMetadata.introspect(source));
	}
	private List<String> getAutoConfigurationClassNames() {
		return ImportCandidates.load(AutoConfiguration.class, getClass().getClassLoader()).getCandidates();
	}
	private void setupImportSelector(TestAutoConfigurationImportSelector importSelector) {
		importSelector.setBeanFactory(this.beanFactory);
		importSelector.setEnvironment(this.environment);
		importSelector.setResourceLoader(new DefaultResourceLoader());
	}
	private final class TestAutoConfigurationImportSelector extends AutoConfigurationImportSelector {
		private AutoConfigurationImportEvent lastEvent;
		TestAutoConfigurationImportSelector(Class<?> autoConfigurationAnnotation) {
			super(autoConfigurationAnnotation);
		}
		@Override
		protected List<AutoConfigurationImportFilter> getAutoConfigurationImportFilters() {
			return AutoConfigurationImportSelectorTests.this.filters;
		}
		@Override
		protected List<AutoConfigurationImportListener> getAutoConfigurationImportListeners() {
			return Collections.singletonList((event) -> this.lastEvent = event);
		}
		AutoConfigurationImportEvent getLastEvent() {
			return this.lastEvent;
		}
	}
	static class TestAutoConfigurationImportFilter implements AutoConfigurationImportFilter, BeanFactoryAware {
		private final Set<String> nonMatching = new HashSet<>();
		private BeanFactory beanFactory;
		TestAutoConfigurationImportFilter(String[] configurations, int... nonMatching) {
			for (int i : nonMatching) {
				this.nonMatching.add(configurations[i]);
			}
		}
		@Override
		public boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) {
			boolean[] result = new boolean[autoConfigurationClasses.length];
			for (int i = 0; i < result.length; i++) {
				result[i] = !this.nonMatching.contains(autoConfigurationClasses[i]);
			}
			return result;
		}
		@Override
		public void setBeanFactory(BeanFactory beanFactory) {
			this.beanFactory = beanFactory;
		}
		BeanFactory getBeanFactory() {
			return this.beanFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	private final class TestConfiguration {
	}
	@EnableAutoConfiguration
	private final class BasicEnableAutoConfiguration {
	}
	@EnableAutoConfiguration(exclude = FreeMarkerAutoConfiguration.class)
	private final class EnableAutoConfigurationWithClassExclusions {
	}
	@SpringBootApplication(exclude = FreeMarkerAutoConfiguration.class)
	private final class SpringBootApplicationWithClassExclusions {
	}
	@EnableAutoConfiguration(excludeName = 'org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration')
	private final class EnableAutoConfigurationWithClassNameExclusions {
	}
	@EnableAutoConfiguration(exclude = MustacheAutoConfiguration.class,
			excludeName = 'org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration')
	private final class EnableAutoConfigurationWithClassAndClassNameExclusions {
	}
	@EnableAutoConfiguration(exclude = TestConfiguration.class)
	private final class EnableAutoConfigurationWithFaultyClassExclude {
	}
	@EnableAutoConfiguration(
			excludeName = 'org.springframework.boot.autoconfigure.AutoConfigurationImportSelectorTests.TestConfiguration')
	private final class EnableAutoConfigurationWithFaultyClassNameExclude {
	}
	@EnableAutoConfiguration(excludeName = 'org.springframework.boot.autoconfigure.DoesNotExist1')
	private final class EnableAutoConfigurationWithAbsentClassNameExclude {
	}
	@SpringBootApplication(excludeName = 'org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration')
	private final class SpringBootApplicationWithClassNameExclusions {
	}
	static class DeprecatedAutoConfiguration {
	}
	static class ReplacementAutoConfiguration {
	}
	@AutoConfigureAfter(DeprecatedAutoConfiguration.class)
	static class AfterDeprecatedAutoConfiguration {
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@interface TestAutoConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.sendgrid;
/**
class SendGridAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void expectedSendGridBeanCreatedApiKey() {
		loadContext('spring.sendgrid.api-key:SG.SECRET-API-KEY');
		SendGrid sendGrid = this.context.getBean(SendGrid.class);
		assertThat(sendGrid.getRequestHeaders()).containsEntry('Authorization', 'Bearer SG.SECRET-API-KEY');
	}
	@Test
	void autoConfigurationNotFiredWhenPropertiesNotSet() {
		loadContext();
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
			.isThrownBy(() -> this.context.getBean(SendGrid.class));
	}
	@Test
	void autoConfigurationNotFiredWhenBeanAlreadyCreated() {
		loadContext(ManualSendGridConfiguration.class, 'spring.sendgrid.api-key:SG.SECRET-API-KEY');
		SendGrid sendGrid = this.context.getBean(SendGrid.class);
		assertThat(sendGrid.getRequestHeaders()).containsEntry('Authorization', 'Bearer SG.CUSTOM_API_KEY');
	}
	@Test
	void expectedSendGridBeanWithProxyCreated() {
		loadContext('spring.sendgrid.api-key:SG.SECRET-API-KEY', 'spring.sendgrid.proxy.host:localhost',
				'spring.sendgrid.proxy.port:5678');
		SendGrid sendGrid = this.context.getBean(SendGrid.class);
		assertThat(sendGrid).extracting('client.httpClient.routePlanner').isInstanceOf(DefaultProxyRoutePlanner.class);
	}
	private void loadContext(String... environment) {
		loadContext(null, environment);
	}
	private void loadContext(Class<?> additionalConfiguration, String... environment) {
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(environment).applyTo(this.context);
		ConfigurationPropertySources.attach(this.context.getEnvironment());
		this.context.register(SendGridAutoConfiguration.class);
		if (additionalConfiguration != null) {
			this.context.register(additionalConfiguration);
		}
		this.context.refresh();
	}
	@Configuration(proxyBeanMethods = false)
	static class ManualSendGridConfiguration {
		@Bean
		SendGrid sendGrid() {
			return new SendGrid('SG.CUSTOM_API_KEY', true);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.thymeleaf;
/**
@ExtendWith(OutputCaptureExtension.class)
class ThymeleafReactiveAutoConfigurationTests {
	private final BuildOutput buildOutput = new BuildOutput(getClass());
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ThymeleafAutoConfiguration.class));
	@Test
	void createFromConfigClass() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.suffix:.html').run((context) -> {
			TemplateEngine engine = context.getBean(TemplateEngine.class);
			Context attrs = new Context(Locale.UK, Collections.singletonMap('foo', 'bar'));
			String result = engine.process('template', attrs).trim();
			assertThat(result).isEqualTo('<html>bar</html>');
		});
	}
	@Test
	void overrideCharacterEncoding() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.encoding:UTF-16').run((context) -> {
			ITemplateResolver resolver = context.getBean(ITemplateResolver.class);
			assertThat(resolver).isInstanceOf(SpringResourceTemplateResolver.class);
			assertThat(((SpringResourceTemplateResolver) resolver).getCharacterEncoding()).isEqualTo('UTF-16');
			ThymeleafReactiveViewResolver views = context.getBean(ThymeleafReactiveViewResolver.class);
			assertThat(views.getDefaultCharset().name()).isEqualTo('UTF-16');
		});
	}
	@Test
	void defaultMediaTypes() {
		this.contextRunner
			.run((context) -> assertThat(context.getBean(ThymeleafReactiveViewResolver.class).getSupportedMediaTypes())
				.containsExactly(MediaType.TEXT_HTML, MediaType.APPLICATION_XHTML_XML, MediaType.APPLICATION_XML,
						MediaType.TEXT_XML, MediaType.APPLICATION_RSS_XML, MediaType.APPLICATION_ATOM_XML,
						new MediaType('application', 'javascript'), new MediaType('application', 'ecmascript'),
						new MediaType('text', 'javascript'), new MediaType('text', 'ecmascript'),
						MediaType.APPLICATION_JSON, new MediaType('text', 'css'), MediaType.TEXT_PLAIN,
						MediaType.TEXT_EVENT_STREAM));
	}
	@Test
	void overrideMediaTypes() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.reactive.media-types:text/html,text/plain')
			.run((context) -> assertThat(context.getBean(ThymeleafReactiveViewResolver.class).getSupportedMediaTypes())
				.containsExactly(MediaType.TEXT_HTML, MediaType.TEXT_PLAIN));
	}
	@Test
	void overrideTemplateResolverOrder() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.templateResolverOrder:25')
			.run((context) -> assertThat(context.getBean(ITemplateResolver.class).getOrder())
				.isEqualTo(Integer.valueOf(25)));
	}
	@Test
	void overrideViewNames() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.viewNames:foo,bar')
			.run((context) -> assertThat(context.getBean(ThymeleafReactiveViewResolver.class).getViewNames())
				.isEqualTo(new String[] { 'foo', 'bar' }));
	}
	@Test
	void overrideMaxChunkSize() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.reactive.maxChunkSize:8KB')
			.run((context) -> assertThat(
					context.getBean(ThymeleafReactiveViewResolver.class).getResponseMaxChunkSizeBytes())
				.isEqualTo(Integer.valueOf(8192)));
	}
	@Test
	void overrideFullModeViewNames() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.reactive.fullModeViewNames:foo,bar')
			.run((context) -> assertThat(context.getBean(ThymeleafReactiveViewResolver.class).getFullModeViewNames())
				.isEqualTo(new String[] { 'foo', 'bar' }));
	}
	@Test
	void overrideChunkedModeViewNames() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.reactive.chunkedModeViewNames:foo,bar')
			.run((context) -> assertThat(context.getBean(ThymeleafReactiveViewResolver.class).getChunkedModeViewNames())
				.isEqualTo(new String[] { 'foo', 'bar' }));
	}
	@Test
	void overrideEnableSpringElCompiler() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.enable-spring-el-compiler:true')
			.run((context) -> assertThat(context.getBean(SpringWebFluxTemplateEngine.class).getEnableSpringELCompiler())
				.isTrue());
	}
	@Test
	void enableSpringElCompilerIsDisabledByDefault() {
		this.contextRunner
			.run((context) -> assertThat(context.getBean(SpringWebFluxTemplateEngine.class).getEnableSpringELCompiler())
				.isFalse());
	}
	@Test
	void overrideRenderHiddenMarkersBeforeCheckboxes() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.render-hidden-markers-before-checkboxes:true')
			.run((context) -> assertThat(
					context.getBean(SpringWebFluxTemplateEngine.class).getRenderHiddenMarkersBeforeCheckboxes())
				.isTrue());
	}
	@Test
	void enableRenderHiddenMarkersBeforeCheckboxesIsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(
				context.getBean(SpringWebFluxTemplateEngine.class).getRenderHiddenMarkersBeforeCheckboxes())
			.isFalse());
	}
	@Test
	void templateLocationDoesNotExist(CapturedOutput output) {
		this.contextRunner.withPropertyValues('spring.thymeleaf.prefix:classpath:/no-such-directory/')
			.run((context) -> assertThat(output).contains('Cannot find template location'));
	}
	@Test
	void templateLocationEmpty(CapturedOutput output) {
		new File(this.buildOutput.getTestResourcesLocation(), 'empty-templates/empty-directory').mkdirs();
		this.contextRunner.withPropertyValues('spring.thymeleaf.prefix:classpath:/empty-templates/empty-directory/')
			.run((context) -> assertThat(output).doesNotContain('Cannot find template location'));
	}
	@Test
	void useDataDialect() {
		this.contextRunner.run((context) -> {
			ISpringWebFluxTemplateEngine engine = context.getBean(ISpringWebFluxTemplateEngine.class);
			Context attrs = new Context(Locale.UK, Collections.singletonMap('foo', 'bar'));
			String result = engine.process('data-dialect', attrs).trim();
			assertThat(result).isEqualTo('<html><body data-foo=\'bar\'></body></html>');
		});
	}
	@Test
	void useJava8TimeDialect() {
		this.contextRunner.run((context) -> {
			ISpringWebFluxTemplateEngine engine = context.getBean(ISpringWebFluxTemplateEngine.class);
			Context attrs = new Context(Locale.UK);
			String result = engine.process('java8time-dialect', attrs).trim();
			assertThat(result).isEqualTo('<html><body>2015-11-24</body></html>');
		});
	}
	@Test
	void useSecurityDialect() {
		this.contextRunner.run((context) -> {
			ISpringWebFluxTemplateEngine engine = context.getBean(ISpringWebFluxTemplateEngine.class);
			MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get('/test').build());
			exchange.getAttributes()
				.put(SpringSecurityContextUtils.SECURITY_CONTEXT_MODEL_ATTRIBUTE_NAME,
						new SecurityContextImpl(new TestingAuthenticationToken('alice', 'admin')));
			WebContext attrs = new WebContext(SpringWebFluxWebApplication.buildApplication(null)
				.buildExchange(exchange, Locale.US, MediaType.TEXT_HTML, StandardCharsets.UTF_8));
			String result = engine.process('security-dialect', attrs);
			assertThat(result).isEqualTo('<html><body><div>alice</div></body></html>' + System.lineSeparator());
		});
	}
	@Test
	void securityDialectAutoConfigurationBacksOffWithoutSpringSecurity() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.springframework.security'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpringSecurityDialect.class));
	}
	@Test
	void renderTemplate() {
		this.contextRunner.run((context) -> {
			ISpringWebFluxTemplateEngine engine = context.getBean(ISpringWebFluxTemplateEngine.class);
			Context attrs = new Context(Locale.UK, Collections.singletonMap('foo', 'bar'));
			String result = engine.process('home', attrs).trim();
			assertThat(result).isEqualTo('<html><body>bar</body></html>');
		});
	}
	@Test
	void layoutDialectCanBeCustomized() {
		this.contextRunner.withUserConfiguration(LayoutDialectConfiguration.class)
			.run((context) -> assertThat(
					ReflectionTestUtils.getField(context.getBean(LayoutDialect.class), 'sortingStrategy'))
				.isInstanceOf(GroupingStrategy.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class LayoutDialectConfiguration {
		@Bean
		LayoutDialect layoutDialect() {
			return new LayoutDialect(new GroupingStrategy());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.thymeleaf;
/**
@ExtendWith(OutputCaptureExtension.class)
class ThymeleafServletAutoConfigurationTests {
	private final BuildOutput buildOutput = new BuildOutput(getClass());
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ThymeleafAutoConfiguration.class));
	@Test
	void autoConfigurationBackOffWithoutThymeleafSpring() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.thymeleaf.spring6'))
			.run((context) -> assertThat(context).doesNotHaveBean(TemplateEngine.class));
	}
	@Test
	void createFromConfigClass() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.mode:HTML', 'spring.thymeleaf.suffix:')
			.run((context) -> {
				assertThat(context).hasSingleBean(TemplateEngine.class);
				TemplateEngine engine = context.getBean(TemplateEngine.class);
				Context attrs = new Context(Locale.UK, Collections.singletonMap('foo', 'bar'));
				String result = engine.process('template.html', attrs).trim();
				assertThat(result).isEqualTo('<html>bar</html>');
			});
	}
	@Test
	void overrideCharacterEncoding() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.encoding:UTF-16').run((context) -> {
			ITemplateResolver resolver = context.getBean(ITemplateResolver.class);
			assertThat(resolver).isInstanceOf(SpringResourceTemplateResolver.class);
			assertThat(((SpringResourceTemplateResolver) resolver).getCharacterEncoding()).isEqualTo('UTF-16');
			ThymeleafViewResolver views = context.getBean(ThymeleafViewResolver.class);
			assertThat(views.getCharacterEncoding()).isEqualTo('UTF-16');
			assertThat(views.getContentType()).isEqualTo('text/html;charset=UTF-16');
		});
	}
	@Test
	void overrideDisableProducePartialOutputWhileProcessing() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.servlet.produce-partial-output-while-processing:false')
			.run((context) -> assertThat(
					context.getBean(ThymeleafViewResolver.class).getProducePartialOutputWhileProcessing())
				.isFalse());
	}
	@Test
	void disableProducePartialOutputWhileProcessingIsEnabledByDefault() {
		this.contextRunner.run((context) -> assertThat(
				context.getBean(ThymeleafViewResolver.class).getProducePartialOutputWhileProcessing())
			.isTrue());
	}
	@Test
	void overrideTemplateResolverOrder() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.templateResolverOrder:25')
			.run((context) -> assertThat(context.getBean(ITemplateResolver.class).getOrder())
				.isEqualTo(Integer.valueOf(25)));
	}
	@Test
	void overrideViewNames() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.viewNames:foo,bar')
			.run((context) -> assertThat(context.getBean(ThymeleafViewResolver.class).getViewNames())
				.isEqualTo(new String[] { 'foo', 'bar' }));
	}
	@Test
	void overrideEnableSpringElCompiler() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.enable-spring-el-compiler:true')
			.run((context) -> assertThat(context.getBean(SpringTemplateEngine.class).getEnableSpringELCompiler())
				.isTrue());
	}
	@Test
	void enableSpringElCompilerIsDisabledByDefault() {
		this.contextRunner
			.run((context) -> assertThat(context.getBean(SpringTemplateEngine.class).getEnableSpringELCompiler())
				.isFalse());
	}
	@Test
	void overrideRenderHiddenMarkersBeforeCheckboxes() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.render-hidden-markers-before-checkboxes:true')
			.run((context) -> assertThat(
					context.getBean(SpringTemplateEngine.class).getRenderHiddenMarkersBeforeCheckboxes())
				.isTrue());
	}
	@Test
	void enableRenderHiddenMarkersBeforeCheckboxesIsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(
				context.getBean(SpringTemplateEngine.class).getRenderHiddenMarkersBeforeCheckboxes())
			.isFalse());
	}
	@Test
	void templateLocationDoesNotExist(CapturedOutput output) {
		this.contextRunner.withPropertyValues('spring.thymeleaf.prefix:classpath:/no-such-directory/')
			.run((context) -> assertThat(output).contains('Cannot find template location'));
	}
	@Test
	void templateLocationEmpty(CapturedOutput output) {
		new File(this.buildOutput.getTestResourcesLocation(), 'empty-templates/empty-directory').mkdirs();
		this.contextRunner.withPropertyValues('spring.thymeleaf.prefix:classpath:/empty-templates/empty-directory/')
			.run((context) -> assertThat(output).doesNotContain('Cannot find template location'));
	}
	@Test
	void createLayoutFromConfigClass() {
		this.contextRunner.run((context) -> {
			ThymeleafView view = (ThymeleafView) context.getBean(ThymeleafViewResolver.class)
				.resolveViewName('view', Locale.UK);
			MockHttpServletResponse response = new MockHttpServletResponse();
			MockHttpServletRequest request = new MockHttpServletRequest(context.getBean(ServletContext.class));
			request.setAttribute(RequestContext.WEB_APPLICATION_CONTEXT_ATTRIBUTE, context);
			view.render(Collections.singletonMap('foo', 'bar'), request, response);
			String result = response.getContentAsString();
			assertThat(result).contains('<title>Content</title>');
			assertThat(result).contains('<span>bar</span>');
			context.close();
		});
	}
	@Test
	void useDataDialect() {
		this.contextRunner.run((context) -> {
			TemplateEngine engine = context.getBean(TemplateEngine.class);
			Context attrs = new Context(Locale.UK, Collections.singletonMap('foo', 'bar'));
			String result = engine.process('data-dialect', attrs).trim();
			assertThat(result).isEqualTo('<html><body data-foo=\'bar\'></body></html>');
		});
	}
	@Test
	void useJava8TimeDialect() {
		this.contextRunner.run((context) -> {
			TemplateEngine engine = context.getBean(TemplateEngine.class);
			Context attrs = new Context(Locale.UK);
			String result = engine.process('java8time-dialect', attrs).trim();
			assertThat(result).isEqualTo('<html><body>2015-11-24</body></html>');
		});
	}
	@Test
	void useSecurityDialect() {
		this.contextRunner.run((context) -> {
			TemplateEngine engine = context.getBean(TemplateEngine.class);
			MockServletContext servletContext = new MockServletContext();
			JakartaServletWebApplication webApplication = JakartaServletWebApplication.buildApplication(servletContext);
			WebContext attrs = new WebContext(webApplication.buildExchange(new MockHttpServletRequest(servletContext),
					new MockHttpServletResponse()));
			try {
				SecurityContextHolder
					.setContext(new SecurityContextImpl(new TestingAuthenticationToken('alice', 'admin')));
				String result = engine.process('security-dialect', attrs);
				assertThat(result).isEqualTo('<html><body><div>alice</div></body></html>' + System.lineSeparator());
			}
			finally {
				SecurityContextHolder.clearContext();
			}
		});
	}
	@Test
	void securityDialectAutoConfigurationBacksOffWithoutSpringSecurity() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.springframework.security'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpringSecurityDialect.class));
	}
	@Test
	void renderTemplate() {
		this.contextRunner.run((context) -> {
			TemplateEngine engine = context.getBean(TemplateEngine.class);
			Context attrs = new Context(Locale.UK, Collections.singletonMap('foo', 'bar'));
			String result = engine.process('home', attrs).trim();
			assertThat(result).isEqualTo('<html><body>bar</body></html>');
		});
	}
	@Test
	void renderNonWebAppTemplate() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(ThymeleafAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(ViewResolver.class);
				TemplateEngine engine = context.getBean(TemplateEngine.class);
				Context attrs = new Context(Locale.UK, Collections.singletonMap('greeting', 'Hello World'));
				String result = engine.process('message', attrs);
				assertThat(result).contains('Hello World');
			});
	}
	@Test
	void registerResourceHandlingFilterDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(FilterRegistrationBean.class));
	}
	@Test
	void registerResourceHandlingFilterOnlyIfResourceChainIsEnabled() {
		this.contextRunner.withPropertyValues('spring.web.resources.chain.enabled:true').run((context) -> {
			FilterRegistrationBean<?> registration = context.getBean(FilterRegistrationBean.class);
			assertThat(registration.getFilter()).isInstanceOf(ResourceUrlEncodingFilter.class);
			assertThat(registration).hasFieldOrPropertyWithValue('dispatcherTypes',
					EnumSet.of(DispatcherType.REQUEST, DispatcherType.ERROR));
		});
	}
	@Test
	@SuppressWarnings('rawtypes')
	void registerResourceHandlingFilterWithOtherRegistrationBean() {
		// gh-14897
		this.contextRunner.withUserConfiguration(FilterRegistrationOtherConfiguration.class)
			.withPropertyValues('spring.web.resources.chain.enabled:true')
			.run((context) -> {
				Map<String, FilterRegistrationBean> beans = context.getBeansOfType(FilterRegistrationBean.class);
				assertThat(beans).hasSize(2);
				FilterRegistrationBean registration = beans.values()
					.stream()
					.filter((r) -> r.getFilter() instanceof ResourceUrlEncodingFilter)
					.findFirst()
					.get();
				assertThat(registration).hasFieldOrPropertyWithValue('dispatcherTypes',
						EnumSet.of(DispatcherType.REQUEST, DispatcherType.ERROR));
			});
	}
	@Test
	@SuppressWarnings('rawtypes')
	void registerResourceHandlingFilterWithResourceRegistrationBean() {
		// gh-14926
		this.contextRunner.withUserConfiguration(FilterRegistrationResourceConfiguration.class)
			.withPropertyValues('spring.web.resources.chain.enabled:true')
			.run((context) -> {
				Map<String, FilterRegistrationBean> beans = context.getBeansOfType(FilterRegistrationBean.class);
				assertThat(beans).hasSize(1);
				FilterRegistrationBean registration = beans.values()
					.stream()
					.filter((r) -> r.getFilter() instanceof ResourceUrlEncodingFilter)
					.findFirst()
					.get();
				assertThat(registration).hasFieldOrPropertyWithValue('dispatcherTypes',
						EnumSet.of(DispatcherType.INCLUDE));
			});
	}
	@Test
	void layoutDialectCanBeCustomized() {
		this.contextRunner.withUserConfiguration(LayoutDialectConfiguration.class)
			.run((context) -> assertThat(
					ReflectionTestUtils.getField(context.getBean(LayoutDialect.class), 'sortingStrategy'))
				.isInstanceOf(GroupingStrategy.class));
	}
	@Test
	void cachingCanBeDisabled() {
		this.contextRunner.withPropertyValues('spring.thymeleaf.cache:false').run((context) -> {
			assertThat(context.getBean(ThymeleafViewResolver.class).isCache()).isFalse();
			SpringResourceTemplateResolver templateResolver = context.getBean(SpringResourceTemplateResolver.class);
			assertThat(templateResolver.isCacheable()).isFalse();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class LayoutDialectConfiguration {
		@Bean
		LayoutDialect layoutDialect() {
			return new LayoutDialect(new GroupingStrategy());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FilterRegistrationResourceConfiguration {
		@Bean
		FilterRegistrationBean<ResourceUrlEncodingFilter> filterRegistration() {
			FilterRegistrationBean<ResourceUrlEncodingFilter> bean = new FilterRegistrationBean<>(
					new ResourceUrlEncodingFilter());
			bean.setDispatcherTypes(EnumSet.of(DispatcherType.INCLUDE));
			return bean;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FilterRegistrationOtherConfiguration {
		@Bean
		FilterRegistrationBean<OrderedCharacterEncodingFilter> filterRegistration() {
			return new FilterRegistrationBean<>(new OrderedCharacterEncodingFilter());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.thymeleaf;
/**
class ThymeleafTemplateAvailabilityProviderTests {
	private final TemplateAvailabilityProvider provider = new ThymeleafTemplateAvailabilityProvider();
	private final ResourceLoader resourceLoader = new DefaultResourceLoader();
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void availabilityOfTemplateInDefaultLocation() {
		assertThat(this.provider.isTemplateAvailable('home', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateThatDoesNotExist() {
		assertThat(this.provider.isTemplateAvailable('whatever', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isFalse();
	}
	@Test
	void availabilityOfTemplateWithCustomPrefix() {
		this.environment.setProperty('spring.thymeleaf.prefix', 'classpath:/custom-templates/');
		assertThat(this.provider.isTemplateAvailable('custom', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomSuffix() {
		this.environment.setProperty('spring.thymeleaf.suffix', '.thymeleaf');
		assertThat(this.provider.isTemplateAvailable('suffixed', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
class ValidationAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class));
	@Test
	void validationAutoConfigurationShouldConfigureDefaultValidator() {
		this.contextRunner.run((context) -> {
			assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('defaultValidator');
			assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class))
				.containsExactly('defaultValidator');
			assertThat(context.getBean(Validator.class)).isInstanceOf(LocalValidatorFactoryBean.class)
				.isEqualTo(context.getBean(org.springframework.validation.Validator.class));
			assertThat(isPrimaryBean(context, 'defaultValidator')).isTrue();
		});
	}
	@Test
	void validationAutoConfigurationWhenUserProvidesValidatorShouldBackOff() {
		this.contextRunner.withUserConfiguration(UserDefinedValidatorConfig.class).run((context) -> {
			assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('customValidator');
			assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class))
				.containsExactly('customValidator');
			assertThat(context.getBean(Validator.class)).isInstanceOf(OptionalValidatorFactoryBean.class)
				.isEqualTo(context.getBean(org.springframework.validation.Validator.class));
			assertThat(isPrimaryBean(context, 'customValidator')).isFalse();
		});
	}
	@Test
	void validationAutoConfigurationWhenUserProvidesDefaultValidatorShouldNotEnablePrimary() {
		this.contextRunner.withUserConfiguration(UserDefinedDefaultValidatorConfig.class).run((context) -> {
			assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('defaultValidator');
			assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class))
				.containsExactly('defaultValidator');
			assertThat(isPrimaryBean(context, 'defaultValidator')).isFalse();
		});
	}
	@Test
	void validationAutoConfigurationWhenUserProvidesJsrValidatorShouldBackOff() {
		this.contextRunner.withUserConfiguration(UserDefinedJsrValidatorConfig.class).run((context) -> {
			assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('customValidator');
			assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class)).isEmpty();
			assertThat(isPrimaryBean(context, 'customValidator')).isFalse();
		});
	}
	@Test
	void validationAutoConfigurationWhenUserProvidesSpringValidatorShouldCreateJsrValidator() {
		this.contextRunner.withUserConfiguration(UserDefinedSpringValidatorConfig.class).run((context) -> {
			assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('defaultValidator');
			assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class))
				.containsExactly('customValidator', 'anotherCustomValidator', 'defaultValidator');
			assertThat(context.getBean(Validator.class)).isInstanceOf(LocalValidatorFactoryBean.class)
				.isEqualTo(context.getBean(org.springframework.validation.Validator.class));
			assertThat(isPrimaryBean(context, 'defaultValidator')).isTrue();
		});
	}
	@Test
	void validationAutoConfigurationWhenUserProvidesPrimarySpringValidatorShouldRemovePrimaryFlag() {
		this.contextRunner.withUserConfiguration(UserDefinedPrimarySpringValidatorConfig.class).run((context) -> {
			assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('defaultValidator');
			assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class))
				.containsExactly('customValidator', 'anotherCustomValidator', 'defaultValidator');
			assertThat(context.getBean(Validator.class)).isInstanceOf(LocalValidatorFactoryBean.class);
			assertThat(context.getBean(org.springframework.validation.Validator.class))
				.isEqualTo(context.getBean('anotherCustomValidator'));
			assertThat(isPrimaryBean(context, 'defaultValidator')).isFalse();
		});
	}
	@Test
	void whenUserProvidesSpringValidatorInParentContextThenAutoConfiguredValidatorIsPrimary() {
		new ApplicationContextRunner().withUserConfiguration(UserDefinedSpringValidatorConfig.class).run((parent) -> {
			this.contextRunner.withParent(parent).run((context) -> {
				assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('defaultValidator');
				assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class))
					.containsExactly('defaultValidator');
				assertThat(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context.getBeanFactory(),
						org.springframework.validation.Validator.class))
					.containsExactly('defaultValidator', 'customValidator', 'anotherCustomValidator');
				assertThat(isPrimaryBean(context, 'defaultValidator')).isTrue();
			});
		});
	}
	@Test
	void whenUserProvidesPrimarySpringValidatorInParentContextThenAutoConfiguredValidatorIsPrimary() {
		new ApplicationContextRunner().withUserConfiguration(UserDefinedPrimarySpringValidatorConfig.class)
			.run((parent) -> {
				this.contextRunner.withParent(parent).run((context) -> {
					assertThat(context.getBeanNamesForType(Validator.class)).containsExactly('defaultValidator');
					assertThat(context.getBeanNamesForType(org.springframework.validation.Validator.class))
						.containsExactly('defaultValidator');
					assertThat(BeanFactoryUtils.beanNamesForTypeIncludingAncestors(context.getBeanFactory(),
							org.springframework.validation.Validator.class))
						.containsExactly('defaultValidator', 'customValidator', 'anotherCustomValidator');
					assertThat(isPrimaryBean(context, 'defaultValidator')).isTrue();
				});
			});
	}
	@Test
	void validationIsEnabled() {
		this.contextRunner.withUserConfiguration(SampleService.class).run((context) -> {
			assertThat(context.getBeansOfType(Validator.class)).hasSize(1);
			SampleService service = context.getBean(SampleService.class);
			service.doSomething('Valid');
			assertThatExceptionOfType(ConstraintViolationException.class).isThrownBy(() -> service.doSomething('KO'));
		});
	}
	@Test
	void classCanBeExcludedFromValidation() {
		this.contextRunner.withUserConfiguration(ExcludedServiceConfiguration.class).run((context) -> {
			assertThat(context.getBeansOfType(Validator.class)).hasSize(1);
			ExcludedService service = context.getBean(ExcludedService.class);
			service.doSomething('Valid');
			assertThatNoException().isThrownBy(() -> service.doSomething('KO'));
		});
	}
	@Test
	void validationUsesCglibProxy() {
		this.contextRunner.withUserConfiguration(DefaultAnotherSampleService.class).run((context) -> {
			assertThat(context.getBeansOfType(Validator.class)).hasSize(1);
			DefaultAnotherSampleService service = context.getBean(DefaultAnotherSampleService.class);
			service.doSomething(42);
			assertThatExceptionOfType(ConstraintViolationException.class).isThrownBy(() -> service.doSomething(2));
		});
	}
	@Test
	void validationCanBeConfiguredToUseJdkProxy() {
		this.contextRunner.withUserConfiguration(AnotherSampleServiceConfiguration.class)
			.withPropertyValues('spring.aop.proxy-target-class=false')
			.run((context) -> {
				assertThat(context.getBeansOfType(Validator.class)).hasSize(1);
				assertThat(context.getBeansOfType(DefaultAnotherSampleService.class)).isEmpty();
				AnotherSampleService service = context.getBean(AnotherSampleService.class);
				service.doSomething(42);
				assertThatExceptionOfType(ConstraintViolationException.class).isThrownBy(() -> service.doSomething(2));
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void userDefinedMethodValidationPostProcessorTakesPrecedence() {
		this.contextRunner.withUserConfiguration(SampleConfiguration.class).run((context) -> {
			assertThat(context.getBeansOfType(Validator.class)).hasSize(1);
			Object userMethodValidationPostProcessor = context.getBean('testMethodValidationPostProcessor');
			assertThat(context.getBean(MethodValidationPostProcessor.class))
				.isSameAs(userMethodValidationPostProcessor);
			assertThat(context.getBeansOfType(MethodValidationPostProcessor.class)).hasSize(1);
			Object validator = ReflectionTestUtils.getField(userMethodValidationPostProcessor, 'validator');
			assertThat(validator).isInstanceOf(Supplier.class);
			assertThat(context.getBean(Validator.class)).isNotSameAs(((Supplier<Validator>) validator).get());
		});
	}
	@Test
	void methodValidationPostProcessorValidatorDependencyDoesNotTriggerEarlyInitialization() {
		this.contextRunner.withUserConfiguration(CustomValidatorConfiguration.class)
			.run((context) -> assertThat(context.getBean(TestBeanPostProcessor.class).postProcessed)
				.contains('someService'));
	}
	@Test
	void validationIsEnabledInChildContext() {
		this.contextRunner.run((parent) -> new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))
			.withUserConfiguration(SampleService.class)
			.withParent(parent)
			.run((context) -> {
				assertThat(context.getBeansOfType(Validator.class)).isEmpty();
				assertThat(parent.getBeansOfType(Validator.class)).hasSize(1);
				SampleService service = context.getBean(SampleService.class);
				service.doSomething('Valid');
				assertThatExceptionOfType(ConstraintViolationException.class)
					.isThrownBy(() -> service.doSomething('KO'));
			}));
	}
	@Test
	void configurationCustomizerBeansAreCalledInOrder() {
		this.contextRunner.withUserConfiguration(ConfigurationCustomizersConfiguration.class).run((context) -> {
			ValidationConfigurationCustomizer customizerOne = context.getBean('customizerOne',
					ValidationConfigurationCustomizer.class);
			ValidationConfigurationCustomizer customizerTwo = context.getBean('customizerTwo',
					ValidationConfigurationCustomizer.class);
			InOrder inOrder = Mockito.inOrder(customizerOne, customizerTwo);
			then(customizerTwo).should(inOrder).customize(any(jakarta.validation.Configuration.class));
			then(customizerOne).should(inOrder).customize(any(jakarta.validation.Configuration.class));
		});
	}
	private boolean isPrimaryBean(AssertableApplicationContext context, String beanName) {
		return ((BeanDefinitionRegistry) context.getSourceApplicationContext()).getBeanDefinition(beanName).isPrimary();
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDefinedValidatorConfig {
		@Bean
		OptionalValidatorFactoryBean customValidator() {
			return new OptionalValidatorFactoryBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDefinedDefaultValidatorConfig {
		@Bean
		OptionalValidatorFactoryBean defaultValidator() {
			return new OptionalValidatorFactoryBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDefinedJsrValidatorConfig {
		@Bean
		Validator customValidator() {
			return mock(Validator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDefinedSpringValidatorConfig {
		@Bean
		org.springframework.validation.Validator customValidator() {
			return mock(org.springframework.validation.Validator.class);
		}
		@Bean
		org.springframework.validation.Validator anotherCustomValidator() {
			return mock(org.springframework.validation.Validator.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDefinedPrimarySpringValidatorConfig {
		@Bean
		org.springframework.validation.Validator customValidator() {
			return mock(org.springframework.validation.Validator.class);
		}
		@Bean
		@Primary
		org.springframework.validation.Validator anotherCustomValidator() {
			return mock(org.springframework.validation.Validator.class);
		}
	}
	@Validated
	static class SampleService {
		void doSomething(@Size(min = 3, max = 10) String name) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static final class ExcludedServiceConfiguration {
		@Bean
		ExcludedService excludedService() {
			return new ExcludedService();
		}
		@Bean
		MethodValidationExcludeFilter exclusionFilter() {
			return (type) -> type.equals(ExcludedService.class);
		}
	}
	@Validated
	static final class ExcludedService {
		void doSomething(@Size(min = 3, max = 10) String name) {
		}
	}
	interface AnotherSampleService {
		void doSomething(@Min(42) Integer counter);
	}
	@Validated
	static class DefaultAnotherSampleService implements AnotherSampleService {
		@Override
		public void doSomething(Integer counter) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnotherSampleServiceConfiguration {
		@Bean
		AnotherSampleService anotherSampleService() {
			return new DefaultAnotherSampleService();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SampleConfiguration {
		@Bean
		static MethodValidationPostProcessor testMethodValidationPostProcessor() {
			return new MethodValidationPostProcessor();
		}
	}
	@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
	static class CustomValidatorConfiguration {
		CustomValidatorConfiguration(SomeService someService) {
		}
		@Bean
		Validator customValidator() {
			return new CustomValidatorBean();
		}
		@Bean
		static TestBeanPostProcessor testBeanPostProcessor() {
			return new TestBeanPostProcessor();
		}
		@Configuration(proxyBeanMethods = false)
		static class SomeServiceConfiguration {
			@Bean
			SomeService someService() {
				return new SomeService();
			}
		}
		static class SomeService {
		}
		static class TestBeanPostProcessor implements BeanPostProcessor {
			private final Set<String> postProcessed = new HashSet<>();
			@Override
			public Object postProcessAfterInitialization(Object bean, String name) {
				this.postProcessed.add(name);
				return bean;
			}
			@Override
			public Object postProcessBeforeInitialization(Object bean, String name) {
				return bean;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigurationCustomizersConfiguration {
		@Bean
		@Order(1)
		ValidationConfigurationCustomizer customizerOne() {
			return mock(ValidationConfigurationCustomizer.class);
		}
		@Bean
		@Order(0)
		ValidationConfigurationCustomizer customizerTwo() {
			return mock(ValidationConfigurationCustomizer.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
@ClassPathExclusions('hibernate-validator-*.jar')
class ValidationAutoConfigurationWithoutValidatorTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class));
	@Test
	void validationIsDisabled() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(Validator.class);
			assertThat(context).doesNotHaveBean(MethodValidationPostProcessor.class);
		});
	}
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
@ClassPathExclusions({ 'tomcat-embed-el-*.jar', 'el-api-*.jar' })
class ValidationAutoConfigurationWithHibernateValidatorMissingElImplTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class));
	@Test
	void missingElDependencyIsTolerated() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Validator.class);
			assertThat(context).hasSingleBean(MethodValidationPostProcessor.class);
		});
	}
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
class ValidatorAdapterTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void wrapLocalValidatorFactoryBean() {
		this.contextRunner.withUserConfiguration(LocalValidatorFactoryBeanConfig.class).run((context) -> {
			ValidatorAdapter wrapper = context.getBean(ValidatorAdapter.class);
			assertThat(wrapper.supports(SampleData.class)).isTrue();
			MapBindingResult errors = new MapBindingResult(new HashMap<String, Object>(), 'test');
			wrapper.validate(new SampleData(40), errors);
			assertThat(errors.getErrorCount()).isOne();
		});
	}
	@Test
	void wrapperInvokesCallbackOnNonManagedBean() {
		this.contextRunner.withUserConfiguration(NonManagedBeanConfig.class).run((context) -> {
			LocalValidatorFactoryBean validator = context.getBean(NonManagedBeanConfig.class).validator;
			then(validator).should().setApplicationContext(any(ApplicationContext.class));
			then(validator).should().afterPropertiesSet();
			then(validator).should(never()).destroy();
			context.close();
			then(validator).should().destroy();
		});
	}
	@Test
	void wrapperDoesNotInvokeCallbackOnManagedBean() {
		this.contextRunner.withUserConfiguration(ManagedBeanConfig.class).run((context) -> {
			LocalValidatorFactoryBean validator = context.getBean(ManagedBeanConfig.class).validator;
			then(validator).should(never()).setApplicationContext(any(ApplicationContext.class));
			then(validator).should(never()).afterPropertiesSet();
			then(validator).should(never()).destroy();
			context.close();
			then(validator).should(never()).destroy();
		});
	}
	@Test
	void wrapperWhenValidationProviderNotPresentShouldNotThrowException() {
		ClassPathResource hibernateValidator = new ClassPathResource(
				'META-INF/services/jakarta.validation.spi.ValidationProvider');
		this.contextRunner
			.withClassLoader(new FilteredClassLoader(FilteredClassLoader.ClassPathResourceFilter.of(hibernateValidator),
					FilteredClassLoader.PackageFilter.of('org.hibernate.validator')))
			.run((context) -> ValidatorAdapter.get(context, null));
	}
	@Test
	void unwrapToJakartaValidatorShouldReturnJakartaValidator() {
		this.contextRunner.withUserConfiguration(LocalValidatorFactoryBeanConfig.class).run((context) -> {
			ValidatorAdapter wrapper = context.getBean(ValidatorAdapter.class);
			assertThat(wrapper.unwrap(Validator.class)).isInstanceOf(Validator.class);
		});
	}
	@Test
	void whenJakartaValidatorIsWrappedMultipleTimesUnwrapToJakartaValidatorShouldReturnJakartaValidator() {
		this.contextRunner.withUserConfiguration(DoubleWrappedConfig.class).run((context) -> {
			ValidatorAdapter wrapper = context.getBean(ValidatorAdapter.class);
			assertThat(wrapper.unwrap(Validator.class)).isInstanceOf(Validator.class);
		});
	}
	@Test
	void unwrapToUnsupportedTypeShouldThrow() {
		this.contextRunner.withUserConfiguration(LocalValidatorFactoryBeanConfig.class).run((context) -> {
			ValidatorAdapter wrapper = context.getBean(ValidatorAdapter.class);
			assertThatRuntimeException().isThrownBy(() -> wrapper.unwrap(HibernateValidator.class));
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class LocalValidatorFactoryBeanConfig {
		@Bean
		LocalValidatorFactoryBean validator() {
			return new LocalValidatorFactoryBean();
		}
		@Bean
		ValidatorAdapter wrapper(LocalValidatorFactoryBean validator) {
			return new ValidatorAdapter(validator, true);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DoubleWrappedConfig {
		@Bean
		LocalValidatorFactoryBean validator() {
			return new LocalValidatorFactoryBean();
		}
		@Bean
		ValidatorAdapter wrapper(LocalValidatorFactoryBean validator) {
			return new ValidatorAdapter(new Wrapper(validator), true);
		}
		static class Wrapper implements SmartValidator {
			private final SmartValidator delegate;
			Wrapper(SmartValidator delegate) {
				this.delegate = delegate;
			}
			@Override
			public boolean supports(Class<?> type) {
				return this.delegate.supports(type);
			}
			@Override
			public void validate(Object target, Errors errors) {
				this.delegate.validate(target, errors);
			}
			@Override
			public void validate(Object target, Errors errors, Object... validationHints) {
				this.delegate.validate(target, errors, validationHints);
			}
			@Override
			@SuppressWarnings('unchecked')
			public <T> T unwrap(Class<T> type) {
				if (type.isInstance(this.delegate)) {
					return (T) this.delegate;
				}
				return this.delegate.unwrap(type);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NonManagedBeanConfig {
		private final LocalValidatorFactoryBean validator = mock(LocalValidatorFactoryBean.class);
		@Bean
		ValidatorAdapter wrapper() {
			return new ValidatorAdapter(this.validator, false);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ManagedBeanConfig {
		private final LocalValidatorFactoryBean validator = mock(LocalValidatorFactoryBean.class);
		@Bean
		ValidatorAdapter wrapper() {
			return new ValidatorAdapter(this.validator, true);
		}
	}
	static class SampleData {
		@Min(42)
		private final int counter;
		SampleData(int counter) {
			this.counter = counter;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.availability;
/**
class ApplicationAvailabilityAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ApplicationAvailabilityAutoConfiguration.class));
	@Test
	void providerIsPresentWhenNotRegistered() {
		this.contextRunner.run(((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class)
			.hasBean('applicationAvailability')));
	}
	@Test
	void providerIsNotConfiguredWhenCustomOneIsPresent() {
		this.contextRunner
			.withBean('customApplicationAvailability', ApplicationAvailability.class,
					() -> mock(ApplicationAvailability.class))
			.run(((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class)
				.hasBean('customApplicationAvailability')));
	}
	@Test
	void whenLazyInitializationIsEnabledApplicationAvailabilityBeanShouldStillReceiveAvailabilityChangeEvents() {
		this.contextRunner.withBean(LazyInitializationBeanFactoryPostProcessor.class).run((context) -> {
			AvailabilityChangeEvent.publish(context, ReadinessState.ACCEPTING_TRAFFIC);
			ApplicationAvailability applicationAvailability = context.getBean(ApplicationAvailability.class);
			assertThat(applicationAvailability.getLastChangeEvent(ReadinessState.class)).isNotNull();
		});
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
class SqlInitializationScriptsRuntimeHintsTests {
	@Test
	void shouldRegisterSchemaHints() {
		RuntimeHints hints = new RuntimeHints();
		new SqlInitializationScriptsRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('schema.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('schema-all.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('schema-mysql.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('schema-postgres.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('schema-oracle.sql')).accepts(hints);
	}
	@Test
	void shouldRegisterDataHints() {
		RuntimeHints hints = new RuntimeHints();
		new SqlInitializationScriptsRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('data.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('data-all.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('data-mysql.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('data-postgres.sql')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('data-oracle.sql')).accepts(hints);
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
class OnDatabaseInitializationConditionTests {
	@Test
	void getMatchOutcomeWithPropertyNoSetMatches() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode');
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(TestPropertyValues.of('test.another', 'noise')), null);
		assertThat(outcome.isMatch()).isTrue();
	}
	@Test
	void getMatchOutcomeWithPropertySetToAlwaysMatches() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode');
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(TestPropertyValues.of('test.init-mode=always')), null);
		assertThat(outcome.isMatch()).isTrue();
	}
	@Test
	void getMatchOutcomeWithPropertySetToEmbeddedMatches() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode');
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(TestPropertyValues.of('test.init-mode=embedded')), null);
		assertThat(outcome.isMatch()).isTrue();
	}
	@Test
	void getMatchOutcomeWithPropertySetToNeverDoesNotMatch() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode');
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(TestPropertyValues.of('test.init-mode=never')), null);
		assertThat(outcome.isMatch()).isFalse();
	}
	@Test
	void getMatchOutcomeWithPropertySetToEmptyStringIsIgnored() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode');
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(TestPropertyValues.of('test.init-mode')), null);
		assertThat(outcome.isMatch()).isTrue();
	}
	@Test
	void getMatchOutcomeWithMultiplePropertiesUsesFirstSet() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode',
				'test.schema-mode', 'test.init-schema-mode');
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(TestPropertyValues.of('test.init-schema-mode=embedded')), null);
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage()).isEqualTo('TestDatabase Initialization test.init-schema-mode is EMBEDDED');
	}
	@Test
	void getMatchOutcomeHasDedicatedDescription() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode');
		ConditionOutcome outcome = condition
			.getMatchOutcome(mockConditionContext(TestPropertyValues.of('test.init-mode=embedded')), null);
		assertThat(outcome.getMessage()).isEqualTo('TestDatabase Initialization test.init-mode is EMBEDDED');
	}
	@Test
	void getMatchOutcomeHasWhenPropertyIsNotSetHasDefaultDescription() {
		OnDatabaseInitializationCondition condition = new OnDatabaseInitializationCondition('Test', 'test.init-mode');
		ConditionOutcome outcome = condition.getMatchOutcome(mockConditionContext(TestPropertyValues.empty()), null);
		assertThat(outcome.getMessage()).isEqualTo('TestDatabase Initialization default value is EMBEDDED');
	}
	private ConditionContext mockConditionContext(TestPropertyValues propertyValues) {
		MockEnvironment environment = new MockEnvironment();
		propertyValues.applyTo(environment);
		ConditionContext conditionContext = mock(ConditionContext.class);
		given(conditionContext.getEnvironment()).willReturn(environment);
		return conditionContext;
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
class SqlInitializationAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SqlInitializationAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name:true', 'spring.r2dbc.generate-unique-name:true');
	@Test
	void whenNoDataSourceOrConnectionFactoryIsAvailableThenAutoConfigurationBacksOff() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(AbstractScriptDatabaseInitializer.class));
	}
	@Test
	void whenConnectionFactoryIsAvailableThenR2dbcInitializerIsAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(R2dbcScriptDatabaseInitializer.class));
	}
	@Test
	void whenConnectionFactoryIsAvailableAndModeIsNeverThenInitializerIsNotAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withPropertyValues('spring.sql.init.mode:never')
			.run((context) -> assertThat(context).doesNotHaveBean(AbstractScriptDatabaseInitializer.class));
	}
	@Test
	void whenDataSourceIsAvailableThenDataSourceInitializerIsAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(DataSourceScriptDatabaseInitializer.class));
	}
	@Test
	void whenDataSourceIsAvailableAndModeIsNeverThenThenInitializerIsNotAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('spring.sql.init.mode:never')
			.run((context) -> assertThat(context).doesNotHaveBean(AbstractScriptDatabaseInitializer.class));
	}
	@Test
	void whenDataSourceAndConnectionFactoryAreAvailableThenOnlyR2dbcInitializerIsAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withUserConfiguration(DataSourceAutoConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ConnectionFactory.class)
				.hasSingleBean(DataSource.class)
				.hasSingleBean(R2dbcScriptDatabaseInitializer.class)
				.doesNotHaveBean(DataSourceScriptDatabaseInitializer.class));
	}
	@Test
	void whenAnSqlInitializerIsDefinedThenInitializerIsNotAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withUserConfiguration(DataSourceAutoConfiguration.class, SqlDatabaseInitializerConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(AbstractScriptDatabaseInitializer.class)
				.hasBean('customInitializer'));
	}
	@Test
	void whenAnInitializerIsDefinedThenSqlInitializerIsStillAutoConfigured() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withUserConfiguration(DatabaseInitializerConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(SqlDataSourceScriptDatabaseInitializer.class)
				.hasBean('customInitializer'));
	}
	@Test
	void whenBeanIsAnnotatedAsDependingOnDatabaseInitializationThenItDependsOnR2dbcScriptDatabaseInitializer() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withUserConfiguration(DependsOnInitializedDatabaseConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory()
					.getBeanDefinition(
							'sqlInitializationAutoConfigurationTests.DependsOnInitializedDatabaseConfiguration');
				assertThat(beanDefinition.getDependsOn()).containsExactlyInAnyOrder('r2dbcScriptDatabaseInitializer');
			});
	}
	@Test
	void whenBeanIsAnnotatedAsDependingOnDatabaseInitializationThenItDependsOnDataSourceScriptDatabaseInitializer() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withUserConfiguration(DependsOnInitializedDatabaseConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory()
					.getBeanDefinition(
							'sqlInitializationAutoConfigurationTests.DependsOnInitializedDatabaseConfiguration');
				assertThat(beanDefinition.getDependsOn())
					.containsExactlyInAnyOrder('dataSourceScriptDatabaseInitializer');
			});
	}
	@Test
	void whenADataSourceIsAvailableAndSpringJdbcIsNotThenAutoConfigurationBacksOff() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(DatabasePopulator.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(DataSource.class);
				assertThat(context).doesNotHaveBean(AbstractScriptDatabaseInitializer.class);
			});
	}
	@Test
	void whenAConnectionFactoryIsAvailableAndSpringR2dbcIsNotThenAutoConfigurationBacksOff() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(org.springframework.r2dbc.connection.init.DatabasePopulator.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class);
				assertThat(context).doesNotHaveBean(AbstractScriptDatabaseInitializer.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class SqlDatabaseInitializerConfiguration {
		@Bean
		SqlDataSourceScriptDatabaseInitializer customInitializer() {
			return new SqlDataSourceScriptDatabaseInitializer(null, new DatabaseInitializationSettings()) {
				@Override
				protected void runScripts(Scripts scripts) {
					// No-op
				}
				@Override
				protected boolean isEmbeddedDatabase() {
					return true;
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DatabaseInitializerConfiguration {
		@Bean
		DataSourceScriptDatabaseInitializer customInitializer() {
			return new DataSourceScriptDatabaseInitializer(null, new DatabaseInitializationSettings()) {
				@Override
				protected void runScripts(Scripts scripts) {
					// No-op
				}
				@Override
				protected boolean isEmbeddedDatabase() {
					return true;
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@DependsOnDatabaseInitialization
	static class DependsOnInitializedDatabaseConfiguration {
		DependsOnInitializedDatabaseConfiguration() {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mail;
/**
class MailSenderAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MailSenderAutoConfiguration.class,
				MailSenderValidatorAutoConfiguration.class, SslAutoConfiguration.class));
	private ClassLoader threadContextClassLoader;
	private String initialContextFactory;
	@BeforeEach
	void setupJndi() {
		this.initialContextFactory = System.getProperty(Context.INITIAL_CONTEXT_FACTORY);
		System.setProperty(Context.INITIAL_CONTEXT_FACTORY, TestableInitialContextFactory.class.getName());
		this.threadContextClassLoader = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(new JndiPropertiesHidingClassLoader(getClass().getClassLoader()));
	}
	@AfterEach
	void close() {
		TestableInitialContextFactory.clearAll();
		if (this.initialContextFactory != null) {
			System.setProperty(Context.INITIAL_CONTEXT_FACTORY, this.initialContextFactory);
		}
		else {
			System.clearProperty(Context.INITIAL_CONTEXT_FACTORY);
		}
		Thread.currentThread().setContextClassLoader(this.threadContextClassLoader);
	}
	@Test
	void smtpHostSet() {
		String host = '192.168.1.234';
		this.contextRunner.withPropertyValues('spring.mail.host:' + host).run((context) -> {
			assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
			JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
			assertThat(mailSender.getHost()).isEqualTo(host);
			assertThat(mailSender.getPort()).isEqualTo(JavaMailSenderImpl.DEFAULT_PORT);
			assertThat(mailSender.getProtocol()).isEqualTo(JavaMailSenderImpl.DEFAULT_PROTOCOL);
		});
	}
	@Test
	void smtpHostWithSettings() {
		String host = '192.168.1.234';
		this.contextRunner
			.withPropertyValues('spring.mail.host:' + host, 'spring.mail.port:42', 'spring.mail.username:john',
					'spring.mail.password:secret', 'spring.mail.default-encoding:US-ASCII',
					'spring.mail.protocol:smtps')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getHost()).isEqualTo(host);
				assertThat(mailSender.getPort()).isEqualTo(42);
				assertThat(mailSender.getUsername()).isEqualTo('john');
				assertThat(mailSender.getPassword()).isEqualTo('secret');
				assertThat(mailSender.getDefaultEncoding()).isEqualTo('US-ASCII');
				assertThat(mailSender.getProtocol()).isEqualTo('smtps');
			});
	}
	@Test
	void smtpHostWithJavaMailProperties() {
		this.contextRunner
			.withPropertyValues('spring.mail.host:localhost', 'spring.mail.properties.mail.smtp.auth:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getJavaMailProperties()).containsEntry('mail.smtp.auth', 'true');
			});
	}
	@Test
	void smtpHostNotSet() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(MailSender.class));
	}
	@Test
	void mailSenderBackOff() {
		this.contextRunner.withUserConfiguration(ManualMailConfiguration.class)
			.withPropertyValues('spring.mail.host:smtp.acme.org', 'spring.mail.user:user',
					'spring.mail.password:secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getUsername()).isNull();
				assertThat(mailSender.getPassword()).isNull();
			});
	}
	@Test
	void jndiSessionAvailable() {
		Session session = configureJndiSession('java:comp/env/foo');
		testJndiSessionLookup(session, 'java:comp/env/foo');
	}
	@Test
	void jndiSessionAvailableWithResourceRef() {
		Session session = configureJndiSession('java:comp/env/foo');
		testJndiSessionLookup(session, 'foo');
	}
	private void testJndiSessionLookup(Session session, String jndiName) {
		this.contextRunner.withPropertyValues('spring.mail.jndi-name:' + jndiName).run((context) -> {
			assertThat(context).hasSingleBean(Session.class);
			Session sessionBean = context.getBean(Session.class);
			assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
			assertThat(sessionBean).isEqualTo(session);
			assertThat(context.getBean(JavaMailSenderImpl.class).getSession()).isEqualTo(sessionBean);
		});
	}
	@Test
	void jndiSessionIgnoredIfJndiNameNotSet() {
		configureJndiSession('foo');
		this.contextRunner.withPropertyValues('spring.mail.host:smtp.acme.org').run((context) -> {
			assertThat(context).doesNotHaveBean(Session.class);
			assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
		});
	}
	@Test
	void jndiSessionNotUsedIfJndiNameNotSet() {
		configureJndiSession('foo');
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(Session.class);
			assertThat(context).doesNotHaveBean(MailSender.class);
		});
	}
	@Test
	void jndiSessionNotAvailableWithJndiName() {
		this.contextRunner.withPropertyValues('spring.mail.jndi-name:foo').run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context.getStartupFailure()).isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('Unable to find Session in JNDI location foo');
		});
	}
	@Test
	void jndiSessionTakesPrecedenceOverProperties() {
		Session session = configureJndiSession('foo');
		this.contextRunner.withPropertyValues('spring.mail.jndi-name:foo', 'spring.mail.host:localhost')
			.run((context) -> {
				assertThat(context).hasSingleBean(Session.class);
				Session sessionBean = context.getBean(Session.class);
				assertThat(sessionBean).isEqualTo(session);
				assertThat(context.getBean(JavaMailSenderImpl.class).getSession()).isEqualTo(sessionBean);
			});
	}
	@Test
	void defaultEncodingWithProperties() {
		this.contextRunner.withPropertyValues('spring.mail.host:localhost', 'spring.mail.default-encoding:UTF-16')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getDefaultEncoding()).isEqualTo('UTF-16');
			});
	}
	@Test
	void defaultEncodingWithJndi() {
		configureJndiSession('foo');
		this.contextRunner.withPropertyValues('spring.mail.jndi-name:foo', 'spring.mail.default-encoding:UTF-16')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getDefaultEncoding()).isEqualTo('UTF-16');
			});
	}
	@Test
	void connectionOnStartup() {
		this.contextRunner.withUserConfiguration(MockMailConfiguration.class)
			.withPropertyValues('spring.mail.host:10.0.0.23', 'spring.mail.test-connection:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				then(mailSender).should().testConnection();
			});
	}
	@Test
	void connectionOnStartupNotCalled() {
		this.contextRunner.withUserConfiguration(MockMailConfiguration.class)
			.withPropertyValues('spring.mail.host:10.0.0.23', 'spring.mail.test-connection:false')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				then(mailSender).should(never()).testConnection();
			});
	}
	@Test
	void smtpSslEnabled() {
		this.contextRunner.withPropertyValues('spring.mail.host:localhost', 'spring.mail.ssl.enabled:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getJavaMailProperties()).containsEntry('mail.smtp.ssl.enable', 'true');
			});
	}
	@Test
	void smtpSslBundle() {
		this.contextRunner
			.withPropertyValues('spring.mail.host:localhost', 'spring.mail.ssl.bundle:test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location:classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password:secret',
					'spring.ssl.bundle.jks.test-bundle.key.password:password')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getJavaMailProperties()).doesNotContainKey('mail.smtp.ssl.enable');
				Object property = mailSender.getJavaMailProperties().get('mail.smtp.ssl.socketFactory');
				assertThat(property).isInstanceOf(SSLSocketFactory.class);
			});
	}
	@Test
	void smtpsSslEnabled() {
		this.contextRunner
			.withPropertyValues('spring.mail.host:localhost', 'spring.mail.protocol:smtps',
					'spring.mail.ssl.enabled:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getJavaMailProperties()).containsEntry('mail.smtps.ssl.enable', 'true');
			});
	}
	@Test
	void smtpsSslBundle() {
		this.contextRunner
			.withPropertyValues('spring.mail.host:localhost', 'spring.mail.protocol:smtps',
					'spring.mail.ssl.bundle:test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location:classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password:secret',
					'spring.ssl.bundle.jks.test-bundle.key.password:password')
			.run((context) -> {
				assertThat(context).hasSingleBean(JavaMailSenderImpl.class);
				JavaMailSenderImpl mailSender = context.getBean(JavaMailSenderImpl.class);
				assertThat(mailSender.getJavaMailProperties()).doesNotContainKey('mail.smtps.ssl.enable');
				Object property = mailSender.getJavaMailProperties().get('mail.smtps.ssl.socketFactory');
				assertThat(property).isInstanceOf(SSLSocketFactory.class);
			});
	}
	private Session configureJndiSession(String name) {
		Properties properties = new Properties();
		Session session = Session.getDefaultInstance(properties);
		TestableInitialContextFactory.bind(name, session);
		return session;
	}
	@Configuration(proxyBeanMethods = false)
	static class ManualMailConfiguration {
		@Bean
		JavaMailSender customMailSender() {
			return new JavaMailSenderImpl();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MockMailConfiguration {
		@Bean
		JavaMailSenderImpl mockMailSender() {
			return mock(JavaMailSenderImpl.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.h2;
/**
class H2ConsoleAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(H2ConsoleAutoConfiguration.class));
	@Test
	void consoleIsDisabledByDefault() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ServletRegistrationBean.class));
	}
	@Test
	void propertyCanEnableConsole() {
		this.contextRunner.withPropertyValues('spring.h2.console.enabled=true').run((context) -> {
			assertThat(context).hasSingleBean(ServletRegistrationBean.class);
			ServletRegistrationBean<?> registrationBean = context.getBean(ServletRegistrationBean.class);
			assertThat(registrationBean.getUrlMappings()).contains('/h2-console/*');
			assertThat(registrationBean.getInitParameters()).doesNotContainKey('trace');
			assertThat(registrationBean.getInitParameters()).doesNotContainKey('webAllowOthers');
			assertThat(registrationBean.getInitParameters()).doesNotContainKey('webAdminPassword');
		});
	}
	@Test
	void customPathMustBeginWithASlash() {
		this.contextRunner.withPropertyValues('spring.h2.console.enabled=true', 'spring.h2.console.path=custom')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).isInstanceOf(BeanCreationException.class)
					.cause()
					.isInstanceOf(ConfigurationPropertiesBindException.class)
					.cause()
					.isInstanceOf(BindException.class)
					.hasMessageContaining('Failed to bind properties under "spring.h2.console"');
			});
	}
	@Test
	void customPathWithTrailingSlash() {
		this.contextRunner.withPropertyValues('spring.h2.console.enabled=true', 'spring.h2.console.path=/custom/')
			.run((context) -> {
				assertThat(context).hasSingleBean(ServletRegistrationBean.class);
				ServletRegistrationBean<?> registrationBean = context.getBean(ServletRegistrationBean.class);
				assertThat(registrationBean.getUrlMappings()).contains('/custom/*');
			});
	}
	@Test
	void customPath() {
		this.contextRunner.withPropertyValues('spring.h2.console.enabled=true', 'spring.h2.console.path=/custom')
			.run((context) -> {
				assertThat(context).hasSingleBean(ServletRegistrationBean.class);
				ServletRegistrationBean<?> registrationBean = context.getBean(ServletRegistrationBean.class);
				assertThat(registrationBean.getUrlMappings()).contains('/custom/*');
			});
	}
	@Test
	void customInitParameters() {
		this.contextRunner
			.withPropertyValues('spring.h2.console.enabled=true', 'spring.h2.console.settings.trace=true',
					'spring.h2.console.settings.web-allow-others=true',
					'spring.h2.console.settings.web-admin-password=abcd')
			.run((context) -> {
				assertThat(context).hasSingleBean(ServletRegistrationBean.class);
				ServletRegistrationBean<?> registrationBean = context.getBean(ServletRegistrationBean.class);
				assertThat(registrationBean.getUrlMappings()).contains('/h2-console/*');
				assertThat(registrationBean.getInitParameters()).containsEntry('trace', '');
				assertThat(registrationBean.getInitParameters()).containsEntry('webAllowOthers', '');
				assertThat(registrationBean.getInitParameters()).containsEntry('webAdminPassword', 'abcd');
			});
	}
	@Test
	@ExtendWith(OutputCaptureExtension.class)
	void singleDataSourceUrlIsLoggedWhenOnlyOneAvailable(CapturedOutput output) {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.withPropertyValues('spring.h2.console.enabled=true')
			.run((context) -> {
				try (Connection connection = context.getBean(DataSource.class).getConnection()) {
					assertThat(output).contains('H2 console available at "/h2-console". Database available at "'
							+ connection.getMetaData().getURL() + '"');
				}
			});
	}
	@Test
	@ExtendWith(OutputCaptureExtension.class)
	void noDataSourceIsLoggedWhenNoneAvailable(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(FailingDataSourceConfiguration.class)
			.withPropertyValues('spring.h2.console.enabled=true')
			.run((context) -> assertThat(output).doesNotContain('H2 console available'));
	}
	@Test
	@ExtendWith(OutputCaptureExtension.class)
	void allDataSourceUrlsAreLoggedWhenMultipleAvailable(CapturedOutput output) {
		ClassLoader webAppClassLoader = new URLClassLoader(new URL[0]);
		this.contextRunner.withClassLoader(webAppClassLoader)
			.withUserConfiguration(FailingDataSourceConfiguration.class, MultiDataSourceConfiguration.class)
			.withPropertyValues('spring.h2.console.enabled=true')
			.run((context) -> assertThat(output).contains(
					'H2 console available at "/h2-console". Databases available at "someJdbcUrl", "anotherJdbcUrl"'));
	}
	@Test
	void h2ConsoleShouldNotFailIfDatabaseConnectionFails() {
		this.contextRunner.withUserConfiguration(FailingDataSourceConfiguration.class)
			.withPropertyValues('spring.h2.console.enabled=true')
			.run((context) -> assertThat(context.isRunning()).isTrue());
	}
	@Configuration(proxyBeanMethods = false)
	static class FailingDataSourceConfiguration {
		@Bean
		DataSource dataSource() throws SQLException {
			DataSource dataSource = mock(DataSource.class);
			given(dataSource.getConnection()).willThrow(IllegalStateException.class);
			return dataSource;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultiDataSourceConfiguration {
		@Bean
		@Order(5)
		DataSource anotherDataSource() throws SQLException {
			return mockDataSource('anotherJdbcUrl');
		}
		@Bean
		@Order(0)
		DataSource someDataSource() throws SQLException {
			return mockDataSource('someJdbcUrl');
		}
		private DataSource mockDataSource(String url) throws SQLException {
			DataSource dataSource = mock(DataSource.class);
			given(dataSource.getConnection()).will((invocation) -> {
				assertThat(Thread.currentThread().getContextClassLoader()).isEqualTo(getClass().getClassLoader());
				Connection connection = mock(Connection.class);
				DatabaseMetaData metadata = mock(DatabaseMetaData.class);
				given(connection.getMetaData()).willReturn(metadata);
				given(metadata.getURL()).willReturn(url);
				return connection;
			});
			return dataSource;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.h2;
/**
class H2ConsolePropertiesTests {
	@Test
	void pathMustNotBeEmpty() {
		H2ConsoleProperties properties = new H2ConsoleProperties();
		assertThatIllegalArgumentException().isThrownBy(() -> properties.setPath(''))
			.withMessageContaining('Path must have length greater than 1');
	}
	@Test
	void pathMustHaveLengthGreaterThanOne() {
		H2ConsoleProperties properties = new H2ConsoleProperties();
		assertThatIllegalArgumentException().isThrownBy(() -> properties.setPath('/'))
			.withMessageContaining('Path must have length greater than 1');
	}
	@Test
	void customPathMustBeginWithASlash() {
		H2ConsoleProperties properties = new H2ConsoleProperties();
		assertThatIllegalArgumentException().isThrownBy(() -> properties.setPath('custom'))
			.withMessageContaining('Path must start with "/"');
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
class OAuth2AuthorizationServerAutoConfigurationTests {
	private static final String PROPERTIES_PREFIX = 'spring.security.oauth2.authorizationserver';
	private static final String CLIENT_PREFIX = PROPERTIES_PREFIX + '.client';
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(OAuth2AuthorizationServerAutoConfiguration.class,
				OAuth2AuthorizationServerJwtAutoConfiguration.class, SecurityAutoConfiguration.class,
				UserDetailsServiceAutoConfiguration.class));
	@Test
	void autoConfigurationConditionalOnClassOauth2Authorization() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(OAuth2Authorization.class))
			.run((context) -> assertThat(context).doesNotHaveBean(OAuth2AuthorizationServerAutoConfiguration.class));
	}
	@Test
	@ClassPathExclusions({ 'spring-security-oauth2-client-*.jar', 'spring-security-oauth2-resource-server-*.jar',
			'spring-security-saml2-service-provider-*.jar' })
	void autoConfigurationDoesNotCauseUserDetailsServiceToBackOff() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(UserDetailsServiceAutoConfiguration.class)
			.hasBean('inMemoryUserDetailsManager'));
	}
	@Test
	void registeredClientRepositoryBeanShouldNotBeCreatedWhenPropertiesAbsent() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(RegisteredClientRepository.class));
	}
	@Test
	void registeredClientRepositoryBeanShouldBeCreatedWhenPropertiesPresent() {
		this.contextRunner
			.withPropertyValues(CLIENT_PREFIX + '.foo.registration.client-id=abcd',
					CLIENT_PREFIX + '.foo.registration.client-secret=secret',
					CLIENT_PREFIX + '.foo.registration.client-authentication-methods=client_secret_basic',
					CLIENT_PREFIX + '.foo.registration.authorization-grant-types=client_credentials',
					CLIENT_PREFIX + '.foo.registration.scopes=test')
			.run((context) -> {
				RegisteredClientRepository registeredClientRepository = context
					.getBean(RegisteredClientRepository.class);
				RegisteredClient registeredClient = registeredClientRepository.findById('foo');
				assertThat(registeredClient).isNotNull();
				assertThat(registeredClient.getClientId()).isEqualTo('abcd');
				assertThat(registeredClient.getClientSecret()).isEqualTo('secret');
				assertThat(registeredClient.getClientAuthenticationMethods())
					.containsOnly(ClientAuthenticationMethod.CLIENT_SECRET_BASIC);
				assertThat(registeredClient.getAuthorizationGrantTypes())
					.containsOnly(AuthorizationGrantType.CLIENT_CREDENTIALS);
				assertThat(registeredClient.getScopes()).containsOnly('test');
			});
	}
	@Test
	void registeredClientRepositoryBacksOffWhenRegisteredClientRepositoryBeanPresent() {
		this.contextRunner.withUserConfiguration(TestRegisteredClientRepositoryConfiguration.class)
			.withPropertyValues(CLIENT_PREFIX + '.foo.registration.client-id=abcd',
					CLIENT_PREFIX + '.foo.registration.client-secret=secret',
					CLIENT_PREFIX + '.foo.registration.client-authentication-methods=client_secret_basic',
					CLIENT_PREFIX + '.foo.registration.authorization-grant-types=client_credentials',
					CLIENT_PREFIX + '.foo.registration.scope=test')
			.run((context) -> {
				RegisteredClientRepository registeredClientRepository = context
					.getBean(RegisteredClientRepository.class);
				RegisteredClient registeredClient = registeredClientRepository.findById('test');
				assertThat(registeredClient).isNotNull();
				assertThat(registeredClient.getClientId()).isEqualTo('abcd');
				assertThat(registeredClient.getClientSecret()).isEqualTo('secret');
				assertThat(registeredClient.getClientAuthenticationMethods())
					.containsOnly(ClientAuthenticationMethod.CLIENT_SECRET_BASIC);
				assertThat(registeredClient.getAuthorizationGrantTypes())
					.containsOnly(AuthorizationGrantType.CLIENT_CREDENTIALS);
				assertThat(registeredClient.getScopes()).containsOnly('test');
			});
	}
	@Test
	void authorizationServerSettingsBeanShouldBeCreatedWhenPropertiesAbsent() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(AuthorizationServerSettings.class));
	}
	@Test
	void authorizationServerSettingsBeanShouldBeCreatedWhenPropertiesPresent() {
		this.contextRunner
			.withPropertyValues(PROPERTIES_PREFIX + '.issuer=https://example.com',
					PROPERTIES_PREFIX + '.endpoint.authorization-uri=/authorize',
					PROPERTIES_PREFIX + '.endpoint.device-authorization-uri=/device_authorization',
					PROPERTIES_PREFIX + '.endpoint.device-verification-uri=/device_verification',
					PROPERTIES_PREFIX + '.endpoint.token-uri=/token', PROPERTIES_PREFIX + '.endpoint.jwk-set-uri=/jwks',
					PROPERTIES_PREFIX + '.endpoint.token-revocation-uri=/revoke',
					PROPERTIES_PREFIX + '.endpoint.token-introspection-uri=/introspect',
					PROPERTIES_PREFIX + '.endpoint.oidc.logout-uri=/logout',
					PROPERTIES_PREFIX + '.endpoint.oidc.client-registration-uri=/register',
					PROPERTIES_PREFIX + '.endpoint.oidc.user-info-uri=/user')
			.run((context) -> {
				AuthorizationServerSettings settings = context.getBean(AuthorizationServerSettings.class);
				assertThat(settings.getIssuer()).isEqualTo('https://example.com');
				assertThat(settings.getAuthorizationEndpoint()).isEqualTo('/authorize');
				assertThat(settings.getDeviceAuthorizationEndpoint()).isEqualTo('/device_authorization');
				assertThat(settings.getDeviceVerificationEndpoint()).isEqualTo('/device_verification');
				assertThat(settings.getTokenEndpoint()).isEqualTo('/token');
				assertThat(settings.getJwkSetEndpoint()).isEqualTo('/jwks');
				assertThat(settings.getTokenRevocationEndpoint()).isEqualTo('/revoke');
				assertThat(settings.getTokenIntrospectionEndpoint()).isEqualTo('/introspect');
				assertThat(settings.getOidcLogoutEndpoint()).isEqualTo('/logout');
				assertThat(settings.getOidcClientRegistrationEndpoint()).isEqualTo('/register');
				assertThat(settings.getOidcUserInfoEndpoint()).isEqualTo('/user');
			});
	}
	@Test
	void authorizationServerSettingsBacksOffWhenAuthorizationServerSettingsBeanPresent() {
		this.contextRunner.withUserConfiguration(TestAuthorizationServerSettingsConfiguration.class)
			.withPropertyValues(PROPERTIES_PREFIX + '.issuer=https://test.com')
			.run((context) -> {
				AuthorizationServerSettings settings = context.getBean(AuthorizationServerSettings.class);
				assertThat(settings.getIssuer()).isEqualTo('https://example.com');
			});
	}
	@Configuration
	static class TestRegisteredClientRepositoryConfiguration {
		@Bean
		RegisteredClientRepository registeredClientRepository() {
			RegisteredClient registeredClient = RegisteredClient.withId('test')
				.clientId('abcd')
				.clientSecret('secret')
				.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
				.authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
				.scope('test')
				.build();
			return new InMemoryRegisteredClientRepository(registeredClient);
		}
	}
	@Configuration
	static class TestAuthorizationServerSettingsConfiguration {
		@Bean
		AuthorizationServerSettings authorizationServerSettings() {
			return AuthorizationServerSettings.builder().issuer('https://example.com').build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
class OAuth2AuthorizationServerWebSecurityConfigurationTests {
	private static final String PROPERTIES_PREFIX = 'spring.security.oauth2.authorizationserver';
	private static final String CLIENT_PREFIX = PROPERTIES_PREFIX + '.client';
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner();
	@Test
	void webSecurityConfigurationConfiguresAuthorizationServerWithFormLogin() {
		this.contextRunner.withUserConfiguration(TestOAuth2AuthorizationServerConfiguration.class)
			.withPropertyValues(CLIENT_PREFIX + '.foo.registration.client-id=abcd',
					CLIENT_PREFIX + '.foo.registration.client-secret=secret',
					CLIENT_PREFIX + '.foo.registration.client-authentication-methods=client_secret_basic',
					CLIENT_PREFIX + '.foo.registration.authorization-grant-types=client_credentials',
					CLIENT_PREFIX + '.foo.registration.scopes=test')
			.run((context) -> {
				assertThat(context).hasBean('authorizationServerSecurityFilterChain');
				assertThat(context).hasBean('defaultSecurityFilterChain');
				assertThat(context).hasBean('registeredClientRepository');
				assertThat(context).hasBean('authorizationServerSettings');
				assertThat(findFilter(context, OAuth2AuthorizationEndpointFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, OAuth2TokenEndpointFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, OAuth2TokenIntrospectionEndpointFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, OAuth2TokenRevocationEndpointFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, OAuth2AuthorizationServerMetadataEndpointFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, OidcProviderConfigurationEndpointFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, OidcUserInfoEndpointFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, BearerTokenAuthenticationFilter.class, 0)).isNotNull();
				assertThat(findFilter(context, OidcClientRegistrationEndpointFilter.class, 0)).isNull();
				assertThat(findFilter(context, UsernamePasswordAuthenticationFilter.class, 0)).isNull();
				assertThat(findFilter(context, DefaultLoginPageGeneratingFilter.class, 1)).isNotNull();
				assertThat(findFilter(context, UsernamePasswordAuthenticationFilter.class, 1)).isNotNull();
			});
	}
	@Test
	void securityFilterChainsBackOffWhenSecurityFilterChainBeanPresent() {
		this.contextRunner
			.withUserConfiguration(TestSecurityFilterChainConfiguration.class,
					TestOAuth2AuthorizationServerConfiguration.class)
			.withPropertyValues(CLIENT_PREFIX + '.foo.registration.client-id=abcd',
					CLIENT_PREFIX + '.foo.registration.client-secret=secret',
					CLIENT_PREFIX + '.foo.registration.client-authentication-methods=client_secret_basic',
					CLIENT_PREFIX + '.foo.registration.authorization-grant-types=client_credentials',
					CLIENT_PREFIX + '.foo.registration.scopes=test')
			.run((context) -> {
				assertThat(context).hasBean('authServerSecurityFilterChain');
				assertThat(context).doesNotHaveBean('authorizationServerSecurityFilterChain');
				assertThat(context).hasBean('securityFilterChain');
				assertThat(context).doesNotHaveBean('defaultSecurityFilterChain');
				assertThat(context).hasBean('registeredClientRepository');
				assertThat(context).hasBean('authorizationServerSettings');
				assertThat(findFilter(context, BearerTokenAuthenticationFilter.class, 0)).isNull();
				assertThat(findFilter(context, UsernamePasswordAuthenticationFilter.class, 1)).isNull();
			});
	}
	private Filter findFilter(AssertableWebApplicationContext context, Class<? extends Filter> filter,
			int filterChainIndex) {
		FilterChainProxy filterChain = (FilterChainProxy) context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN);
		List<SecurityFilterChain> filterChains = filterChain.getFilterChains();
		List<Filter> filters = filterChains.get(filterChainIndex).getFilters();
		return filters.stream().filter(filter::isInstance).findFirst().orElse(null);
	}
	@Configuration
	@EnableWebSecurity
	@Import({ TestRegisteredClientRepositoryConfiguration.class,
			OAuth2AuthorizationServerWebSecurityConfiguration.class,
			OAuth2AuthorizationServerJwtAutoConfiguration.class })
	static class TestOAuth2AuthorizationServerConfiguration {
	}
	@Configuration
	static class TestRegisteredClientRepositoryConfiguration {
		@Bean
		RegisteredClientRepository registeredClientRepository() {
			RegisteredClient registeredClient = RegisteredClient.withId('test')
				.clientId('abcd')
				.clientSecret('secret')
				.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
				.authorizationGrantType(AuthorizationGrantType.CLIENT_CREDENTIALS)
				.scope('test')
				.build();
			return new InMemoryRegisteredClientRepository(registeredClient);
		}
		@Bean
		AuthorizationServerSettings authorizationServerSettings() {
			return AuthorizationServerSettings.builder().issuer('https://example.com').build();
		}
	}
	@Configuration
	@EnableWebSecurity
	static class TestSecurityFilterChainConfiguration {
		@Bean
		@Order(1)
		SecurityFilterChain authServerSecurityFilterChain(HttpSecurity http) throws Exception {
			OAuth2AuthorizationServerConfigurer authorizationServer = OAuth2AuthorizationServerConfigurer
				.authorizationServer();
			http.securityMatcher(authorizationServer.getEndpointsMatcher())
				.with(authorizationServer, Customizer.withDefaults());
			http.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated());
			return http.build();
		}
		@Bean
		@Order(2)
		SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
			return http.httpBasic(withDefaults()).build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
class OAuth2AuthorizationServerPropertiesTests {
	private final OAuth2AuthorizationServerProperties properties = new OAuth2AuthorizationServerProperties();
	@Test
	void clientIdAbsentThrowsException() {
		OAuth2AuthorizationServerProperties.Client client = new OAuth2AuthorizationServerProperties.Client();
		client.getRegistration().getClientAuthenticationMethods().add('client_secret_basic');
		client.getRegistration().getAuthorizationGrantTypes().add('authorization_code');
		this.properties.getClient().put('foo', client);
		assertThatIllegalStateException().isThrownBy(this.properties::validate)
			.withMessage('Client id must not be empty.');
	}
	@Test
	void clientSecretAbsentShouldNotThrowException() {
		OAuth2AuthorizationServerProperties.Client client = new OAuth2AuthorizationServerProperties.Client();
		client.getRegistration().setClientId('foo');
		client.getRegistration().getClientAuthenticationMethods().add('client_secret_basic');
		client.getRegistration().getAuthorizationGrantTypes().add('authorization_code');
		this.properties.getClient().put('foo', client);
		this.properties.validate();
	}
	@Test
	void clientAuthenticationMethodsEmptyThrowsException() {
		OAuth2AuthorizationServerProperties.Client client = new OAuth2AuthorizationServerProperties.Client();
		client.getRegistration().setClientId('foo');
		client.getRegistration().getAuthorizationGrantTypes().add('authorization_code');
		this.properties.getClient().put('foo', client);
		assertThatIllegalStateException().isThrownBy(this.properties::validate)
			.withMessage('Client authentication methods must not be empty.');
	}
	@Test
	void authorizationGrantTypesEmptyThrowsException() {
		OAuth2AuthorizationServerProperties.Client client = new OAuth2AuthorizationServerProperties.Client();
		client.getRegistration().setClientId('foo');
		client.getRegistration().getClientAuthenticationMethods().add('client_secret_basic');
		this.properties.getClient().put('foo', client);
		assertThatIllegalStateException().isThrownBy(this.properties::validate)
			.withMessage('Authorization grant types must not be empty.');
	}
	@Test
	void defaultEndpointPropertiesMatchBuilderDefaults() {
		OAuth2AuthorizationServerProperties.Endpoint properties = new OAuth2AuthorizationServerProperties.Endpoint();
		AuthorizationServerSettings defaults = AuthorizationServerSettings.builder().build();
		assertThat(properties.getAuthorizationUri()).isEqualTo(defaults.getAuthorizationEndpoint());
		assertThat(properties.getDeviceAuthorizationUri()).isEqualTo(defaults.getDeviceAuthorizationEndpoint());
		assertThat(properties.getDeviceVerificationUri()).isEqualTo(defaults.getDeviceVerificationEndpoint());
		assertThat(properties.getTokenUri()).isEqualTo(defaults.getTokenEndpoint());
		assertThat(properties.getJwkSetUri()).isEqualTo(defaults.getJwkSetEndpoint());
		assertThat(properties.getTokenRevocationUri()).isEqualTo(defaults.getTokenRevocationEndpoint());
		assertThat(properties.getTokenIntrospectionUri()).isEqualTo(defaults.getTokenIntrospectionEndpoint());
		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = properties.getOidc();
		assertThat(oidc.getLogoutUri()).isEqualTo(defaults.getOidcLogoutEndpoint());
		assertThat(oidc.getClientRegistrationUri()).isEqualTo(defaults.getOidcClientRegistrationEndpoint());
		assertThat(oidc.getUserInfoUri()).isEqualTo(defaults.getOidcUserInfoEndpoint());
	}
	@Test
	void defaultClientPropertiesMatchBuilderDefaults() {
		OAuth2AuthorizationServerProperties.Client properties = new OAuth2AuthorizationServerProperties.Client();
		ClientSettings defaults = ClientSettings.builder().build();
		assertThat(properties.isRequireProofKey()).isEqualTo(defaults.isRequireProofKey());
		assertThat(properties.isRequireAuthorizationConsent()).isEqualTo(defaults.isRequireAuthorizationConsent());
		assertThat(properties.getJwkSetUri()).isEqualTo(defaults.getJwkSetUrl());
		assertThat(properties.getTokenEndpointAuthenticationSigningAlgorithm())
			.isEqualTo((defaults.getTokenEndpointAuthenticationSigningAlgorithm() != null)
					? defaults.getTokenEndpointAuthenticationSigningAlgorithm().getName() : null);
	}
	@Test
	void defaultTokenPropertiesMatchBuilderDefaults() {
		OAuth2AuthorizationServerProperties.Token properties = new OAuth2AuthorizationServerProperties.Token();
		TokenSettings defaults = TokenSettings.builder().build();
		assertThat(properties.getAuthorizationCodeTimeToLive()).isEqualTo(defaults.getAuthorizationCodeTimeToLive());
		assertThat(properties.getAccessTokenTimeToLive()).isEqualTo(defaults.getAccessTokenTimeToLive());
		assertThat(properties.getAccessTokenFormat()).isEqualTo(defaults.getAccessTokenFormat().getValue());
		assertThat(properties.getDeviceCodeTimeToLive()).isEqualTo(defaults.getDeviceCodeTimeToLive());
		assertThat(properties.isReuseRefreshTokens()).isEqualTo(defaults.isReuseRefreshTokens());
		assertThat(properties.getRefreshTokenTimeToLive()).isEqualTo(defaults.getRefreshTokenTimeToLive());
		assertThat(properties.getIdTokenSignatureAlgorithm())
			.isEqualTo(defaults.getIdTokenSignatureAlgorithm().getName());
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
class OAuth2AuthorizationServerPropertiesMapperTests {
	private final OAuth2AuthorizationServerProperties properties = new OAuth2AuthorizationServerProperties();
	private final OAuth2AuthorizationServerPropertiesMapper mapper = new OAuth2AuthorizationServerPropertiesMapper(
			this.properties);
	@Test
	void getRegisteredClientsWhenValidParametersShouldAdapt() {
		OAuth2AuthorizationServerProperties.Client client = createClient();
		this.properties.getClient().put('foo', client);
		List<RegisteredClient> registeredClients = this.mapper.asRegisteredClients();
		assertThat(registeredClients).hasSize(1);
		RegisteredClient registeredClient = registeredClients.get(0);
		assertThat(registeredClient.getClientId()).isEqualTo('foo');
		assertThat(registeredClient.getClientSecret()).isEqualTo('secret');
		assertThat(registeredClient.getClientAuthenticationMethods())
			.containsExactly(ClientAuthenticationMethod.CLIENT_SECRET_BASIC);
		assertThat(registeredClient.getAuthorizationGrantTypes())
			.containsExactly(AuthorizationGrantType.AUTHORIZATION_CODE);
		assertThat(registeredClient.getRedirectUris()).containsExactly('https://example.com/redirect');
		assertThat(registeredClient.getPostLogoutRedirectUris()).containsExactly('https://example.com/logout');
		assertThat(registeredClient.getScopes()).containsExactly('user.read');
		assertThat(registeredClient.getClientSettings().isRequireProofKey()).isTrue();
		assertThat(registeredClient.getClientSettings().isRequireAuthorizationConsent()).isTrue();
		assertThat(registeredClient.getClientSettings().getJwkSetUrl()).isEqualTo('https://example.com/jwks');
		assertThat(registeredClient.getClientSettings().getTokenEndpointAuthenticationSigningAlgorithm())
			.isEqualTo(SignatureAlgorithm.RS256);
		assertThat(registeredClient.getTokenSettings().getAccessTokenFormat()).isEqualTo(OAuth2TokenFormat.REFERENCE);
		assertThat(registeredClient.getTokenSettings().getAccessTokenTimeToLive()).isEqualTo(Duration.ofSeconds(300));
		assertThat(registeredClient.getTokenSettings().getRefreshTokenTimeToLive()).isEqualTo(Duration.ofHours(24));
		assertThat(registeredClient.getTokenSettings().getDeviceCodeTimeToLive()).isEqualTo(Duration.ofMinutes(30));
		assertThat(registeredClient.getTokenSettings().isReuseRefreshTokens()).isEqualTo(true);
		assertThat(registeredClient.getTokenSettings().getIdTokenSignatureAlgorithm())
			.isEqualTo(SignatureAlgorithm.RS512);
	}
	private OAuth2AuthorizationServerProperties.Client createClient() {
		OAuth2AuthorizationServerProperties.Client client = new OAuth2AuthorizationServerProperties.Client();
		client.setRequireProofKey(true);
		client.setRequireAuthorizationConsent(true);
		client.setJwkSetUri('https://example.com/jwks');
		client.setTokenEndpointAuthenticationSigningAlgorithm('rs256');
		OAuth2AuthorizationServerProperties.Registration registration = client.getRegistration();
		registration.setClientId('foo');
		registration.setClientSecret('secret');
		registration.getClientAuthenticationMethods().add('client_secret_basic');
		registration.getAuthorizationGrantTypes().add('authorization_code');
		registration.getRedirectUris().add('https://example.com/redirect');
		registration.getPostLogoutRedirectUris().add('https://example.com/logout');
		registration.getScopes().add('user.read');
		OAuth2AuthorizationServerProperties.Token token = client.getToken();
		token.setAccessTokenFormat('reference');
		token.setAccessTokenTimeToLive(Duration.ofSeconds(300));
		token.setRefreshTokenTimeToLive(Duration.ofHours(24));
		token.setDeviceCodeTimeToLive(Duration.ofMinutes(30));
		token.setReuseRefreshTokens(true);
		token.setIdTokenSignatureAlgorithm('rs512');
		return client;
	}
	@Test
	void getAuthorizationServerSettingsWhenValidParametersShouldAdapt() {
		this.properties.setIssuer('https://example.com');
		OAuth2AuthorizationServerProperties.Endpoint endpoints = this.properties.getEndpoint();
		endpoints.setAuthorizationUri('/authorize');
		endpoints.setDeviceAuthorizationUri('/device_authorization');
		endpoints.setDeviceVerificationUri('/device_verification');
		endpoints.setTokenUri('/token');
		endpoints.setJwkSetUri('/jwks');
		endpoints.setTokenRevocationUri('/revoke');
		endpoints.setTokenIntrospectionUri('/introspect');
		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = endpoints.getOidc();
		oidc.setLogoutUri('/logout');
		oidc.setClientRegistrationUri('/register');
		oidc.setUserInfoUri('/user');
		AuthorizationServerSettings settings = this.mapper.asAuthorizationServerSettings();
		assertThat(settings.getIssuer()).isEqualTo('https://example.com');
		assertThat(settings.isMultipleIssuersAllowed()).isFalse();
		assertThat(settings.getAuthorizationEndpoint()).isEqualTo('/authorize');
		assertThat(settings.getDeviceAuthorizationEndpoint()).isEqualTo('/device_authorization');
		assertThat(settings.getDeviceVerificationEndpoint()).isEqualTo('/device_verification');
		assertThat(settings.getTokenEndpoint()).isEqualTo('/token');
		assertThat(settings.getJwkSetEndpoint()).isEqualTo('/jwks');
		assertThat(settings.getTokenRevocationEndpoint()).isEqualTo('/revoke');
		assertThat(settings.getTokenIntrospectionEndpoint()).isEqualTo('/introspect');
		assertThat(settings.getOidcLogoutEndpoint()).isEqualTo('/logout');
		assertThat(settings.getOidcClientRegistrationEndpoint()).isEqualTo('/register');
		assertThat(settings.getOidcUserInfoEndpoint()).isEqualTo('/user');
	}
	@Test
	void getAuthorizationServerSettingsWhenMultipleIssuersAllowedShouldAdapt() {
		this.properties.setMultipleIssuersAllowed(true);
		OAuth2AuthorizationServerProperties.Endpoint endpoints = this.properties.getEndpoint();
		endpoints.setAuthorizationUri('/authorize');
		endpoints.setDeviceAuthorizationUri('/device_authorization');
		endpoints.setDeviceVerificationUri('/device_verification');
		endpoints.setTokenUri('/token');
		endpoints.setJwkSetUri('/jwks');
		endpoints.setTokenRevocationUri('/revoke');
		endpoints.setTokenIntrospectionUri('/introspect');
		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = endpoints.getOidc();
		oidc.setLogoutUri('/logout');
		oidc.setClientRegistrationUri('/register');
		oidc.setUserInfoUri('/user');
		AuthorizationServerSettings settings = this.mapper.asAuthorizationServerSettings();
		assertThat(settings.getIssuer()).isNull();
		assertThat(settings.isMultipleIssuersAllowed()).isTrue();
		assertThat(settings.getAuthorizationEndpoint()).isEqualTo('/authorize');
		assertThat(settings.getDeviceAuthorizationEndpoint()).isEqualTo('/device_authorization');
		assertThat(settings.getDeviceVerificationEndpoint()).isEqualTo('/device_verification');
		assertThat(settings.getTokenEndpoint()).isEqualTo('/token');
		assertThat(settings.getJwkSetEndpoint()).isEqualTo('/jwks');
		assertThat(settings.getTokenRevocationEndpoint()).isEqualTo('/revoke');
		assertThat(settings.getTokenIntrospectionEndpoint()).isEqualTo('/introspect');
		assertThat(settings.getOidcLogoutEndpoint()).isEqualTo('/logout');
		assertThat(settings.getOidcClientRegistrationEndpoint()).isEqualTo('/register');
		assertThat(settings.getOidcUserInfoEndpoint()).isEqualTo('/user');
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
class OAuth2AuthorizationServerJwtAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(OAuth2AuthorizationServerJwtAutoConfiguration.class));
	@Test
	void autoConfigurationConditionalOnClassOauth2Authorization() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(OAuth2Authorization.class))
			.run((context) -> assertThat(context).doesNotHaveBean(OAuth2AuthorizationServerJwtAutoConfiguration.class));
	}
	@Test
	void jwtDecoderConditionalOnClassJwtDecoder() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(JwtDecoder.class))
			.run((context) -> assertThat(context).doesNotHaveBean('jwtDecoder'));
	}
	@Test
	void jwtConfigurationConfiguresJwtDecoderWithGeneratedKey() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasBean('jwtDecoder');
			assertThat(context.getBean('jwtDecoder')).isInstanceOf(NimbusJwtDecoder.class);
			assertThat(context).hasBean('jwkSource');
			assertThat(context.getBean('jwkSource')).isInstanceOf(ImmutableJWKSet.class);
		});
	}
	@Test
	void jwtDecoderBacksOffWhenBeanPresent() {
		this.contextRunner.withUserConfiguration(TestJwtDecoderConfiguration.class).run((context) -> {
			assertThat(context).hasBean('jwtDecoder');
			assertThat(context.getBean('jwtDecoder')).isNotInstanceOf(NimbusJwtDecoder.class);
			assertThat(context).hasBean('jwkSource');
			assertThat(context.getBean('jwkSource')).isInstanceOf(ImmutableJWKSet.class);
		});
	}
	@Test
	void jwkSourceBacksOffWhenBeanPresent() {
		this.contextRunner.withUserConfiguration(TestJwkSourceConfiguration.class).run((context) -> {
			assertThat(context).hasBean('jwtDecoder');
			assertThat(context.getBean('jwtDecoder')).isInstanceOf(NimbusJwtDecoder.class);
			assertThat(context).hasBean('jwkSource');
			assertThat(context.getBean('jwkSource')).isNotInstanceOf(ImmutableJWKSet.class);
		});
	}
	@Configuration
	static class TestJwtDecoderConfiguration {
		@Bean
		JwtDecoder jwtDecoder() {
			return (token) -> null;
		}
	}
	@Configuration
	static class TestJwkSourceConfiguration {
		@Bean
		JWKSource<SecurityContext> jwkSource() {
			return (jwkSelector, context) -> null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.servlet;
/**
class OAuth2ResourceServerAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(OAuth2ResourceServerAutoConfiguration.class))
		.withUserConfiguration(TestConfig.class);
	private MockWebServer server;
	private static final String JWK_SET = '{\'keys\':[{\'kty\':\'RSA\',\'e\':\'AQAB\',\'use\':\'sig\','
			+ '\'kid\':\'one\',\'n\':\'oXJ8OyOv_eRnce4akdanR4KYRfnC2zLV4uYNQpcFn6oHL0dj7D6kxQmsXoYgJV8ZVDn71KGm'
			+ 'uLvolxsDncc2UrhyMBY6DVQVgMSVYaPCTgW76iYEKGgzTEw5IBRQL9w3SRJWd3VJTZZQjkXef48Ocz06PGF3lhbz4t5UEZtd'
			+ 'F4rIe7u-977QwHuh7yRPBQ3sII-cVoOUMgaXB9SHcGF2iZCtPzL_IffDUcfhLQteGebhW8A6eUHgpD5A1PQ-JCw_G7UOzZAj'
			+ 'jDjtNM2eqm8j-Ms_gqnm4MiCZ4E-9pDN77CAAPVN7kuX6ejs9KBXpk01z48i9fORYk9u7rAkh1HuQw\'}]}';
	@AfterEach
	void cleanup() throws Exception {
		if (this.server != null) {
			this.server.shutdown();
		}
	}
	@Test
	void autoConfigurationShouldConfigureResourceServer() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				assertThat(getBearerTokenFilter(context)).isNotNull();
				assertJwkSetUriJwtDecoderBuilderCustomization(context);
			});
	}
	private void assertJwkSetUriJwtDecoderBuilderCustomization(AssertableWebApplicationContext context) {
		JwkSetUriJwtDecoderBuilderCustomizer customizer = context.getBean('decoderBuilderCustomizer',
				JwkSetUriJwtDecoderBuilderCustomizer.class);
		JwkSetUriJwtDecoderBuilderCustomizer anotherCustomizer = context.getBean('anotherDecoderBuilderCustomizer',
				JwkSetUriJwtDecoderBuilderCustomizer.class);
		InOrder inOrder = inOrder(customizer, anotherCustomizer);
		inOrder.verify(customizer).customize(any());
		inOrder.verify(anotherCustomizer).customize(any());
	}
	@Test
	void autoConfigurationShouldMatchDefaultJwsAlgorithm() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.run((context) -> {
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				assertThat(jwtDecoder).extracting('jwtProcessor.jwsKeySelector.jwsAlgs')
					.asInstanceOf(InstanceOfAssertFactories.collection(JWSAlgorithm.class))
					.containsExactlyInAnyOrder(JWSAlgorithm.RS256);
			});
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerWithSingleJwsAlgorithm() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RS384')
			.run((context) -> {
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				assertThat(jwtDecoder).extracting('jwtProcessor.jwsKeySelector.jwsAlgs')
					.asInstanceOf(InstanceOfAssertFactories.collection(JWSAlgorithm.class))
					.containsExactlyInAnyOrder(JWSAlgorithm.RS384);
				assertThat(getBearerTokenFilter(context)).isNotNull();
			});
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerWithMultipleJwsAlgorithms() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RS256, RS384, RS512')
			.run((context) -> {
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				assertThat(jwtDecoder).extracting('jwtProcessor.jwsKeySelector.jwsAlgs')
					.asInstanceOf(InstanceOfAssertFactories.collection(JWSAlgorithm.class))
					.containsExactlyInAnyOrder(JWSAlgorithm.RS256, JWSAlgorithm.RS384, JWSAlgorithm.RS512);
				assertThat(getBearerTokenFilter(context)).isNotNull();
			});
	}
	@Test
	void autoConfigurationUsingPublicKeyValueShouldConfigureResourceServerUsingSingleJwsAlgorithm() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RS384')
			.run((context) -> {
				NimbusJwtDecoder nimbusJwtDecoder = context.getBean(NimbusJwtDecoder.class);
				assertThat(nimbusJwtDecoder).extracting('jwtProcessor.jwsKeySelector.expectedJWSAlg')
					.isEqualTo(JWSAlgorithm.RS384);
			});
	}
	@Test
	void autoConfigurationUsingPublicKeyValueWithMultipleJwsAlgorithmsShouldFail() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RSA256,RS384')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).hasRootCauseMessage(
						'Creating a JWT decoder using a public key requires exactly one JWS algorithm but 2 were '
								+ 'configured');
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingOidcIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=http://'
					+ this.server.getHostName() + ':' + this.server.getPort() + '/' + path)
			.run((context) -> {
				assertThat(context).hasSingleBean(SupplierJwtDecoder.class);
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
				SupplierJwtDecoder supplierJwtDecoderBean = context.getBean(SupplierJwtDecoder.class);
				Supplier<JwtDecoder> jwtDecoderSupplier = (Supplier<JwtDecoder>) ReflectionTestUtils
					.getField(supplierJwtDecoderBean, 'delegate');
				jwtDecoderSupplier.get();
				assertJwkSetUriJwtDecoderBuilderCustomization(context);
			});
		// The last request is to the JWK Set endpoint to look up the algorithm
		assertThat(this.server.getRequestCount()).isEqualTo(2);
	}
	@SuppressWarnings('unchecked')
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingOidcRfc8414IssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponsesWithErrors(cleanIssuerPath, 1);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=http://'
					+ this.server.getHostName() + ':' + this.server.getPort() + '/' + path)
			.run((context) -> {
				assertThat(context).hasSingleBean(SupplierJwtDecoder.class);
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
				SupplierJwtDecoder supplierJwtDecoderBean = context.getBean(SupplierJwtDecoder.class);
				Supplier<JwtDecoder> jwtDecoderSupplier = (Supplier<JwtDecoder>) ReflectionTestUtils
					.getField(supplierJwtDecoderBean, 'delegate');
				jwtDecoderSupplier.get();
				assertJwkSetUriJwtDecoderBuilderCustomization(context);
			});
		// The last request is to the JWK Set endpoint to look up the algorithm
		assertThat(this.server.getRequestCount()).isEqualTo(3);
	}
	@SuppressWarnings('unchecked')
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingOAuthIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponsesWithErrors(cleanIssuerPath, 2);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=http://'
					+ this.server.getHostName() + ':' + this.server.getPort() + '/' + path)
			.run((context) -> {
				assertThat(context).hasSingleBean(SupplierJwtDecoder.class);
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
				SupplierJwtDecoder supplierJwtDecoderBean = context.getBean(SupplierJwtDecoder.class);
				Supplier<JwtDecoder> jwtDecoderSupplier = (Supplier<JwtDecoder>) ReflectionTestUtils
					.getField(supplierJwtDecoderBean, 'delegate');
				jwtDecoderSupplier.get();
				assertJwkSetUriJwtDecoderBuilderCustomization(context);
			});
		// The last request is to the JWK Set endpoint to look up the algorithm
		assertThat(this.server.getRequestCount()).isEqualTo(4);
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingPublicKeyValue() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String issuer = this.server.url('').toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				assertThat(getBearerTokenFilter(context)).isNotNull();
			});
	}
	@Test
	void autoConfigurationShouldFailIfPublicKeyLocationDoesNotExist() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:does-not-exist')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.hasMessageContaining('class path resource [does-not-exist]')
				.hasMessageContaining('Public key location does not exist'));
	}
	@Test
	void autoConfigurationShouldFailIfAlgorithmIsInvalid() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=NOT_VALID')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.hasMessageContaining('signatureAlgorithm cannot be null'));
	}
	@Test
	void autoConfigurationWhenSetUriKeyLocationAndIssuerUriPresentShouldUseSetUri() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=https://issuer-uri.com',
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
					'spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				assertThat(getBearerTokenFilter(context)).isNotNull();
				assertThat(context.containsBean('jwtDecoderByJwkKeySetUri')).isTrue();
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isFalse();
			});
	}
	@Test
	void autoConfigurationWhenKeyLocationAndIssuerUriPresentShouldUseIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String issuer = this.server.url('').toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=http://' + this.server.getHostName() + ':'
							+ this.server.getPort(),
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				assertThat(getBearerTokenFilter(context)).isNotNull();
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
			});
	}
	@Test
	void autoConfigurationWhenJwkSetUriNullShouldNotFail() {
		this.contextRunner.run((context) -> assertThat(getBearerTokenFilter(context)).isNull());
	}
	@Test
	void jwtDecoderByJwkSetUriIsConditionalOnMissingBean() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.run((context) -> assertThat(getBearerTokenFilter(context)).isNotNull());
	}
	@Test
	void jwtDecoderByOidcIssuerUriIsConditionalOnMissingBean() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=https://jwk-oidc-issuer-location.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.run((context) -> assertThat(getBearerTokenFilter(context)).isNotNull());
	}
	@Test
	void autoConfigurationShouldBeConditionalOnResourceServerClass() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.withClassLoader(new FilteredClassLoader(BearerTokenAuthenticationToken.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(OAuth2ResourceServerAutoConfiguration.class);
				assertThat(getBearerTokenFilter(context)).isNull();
			});
	}
	@Test
	void autoConfigurationForJwtShouldBeConditionalOnJwtDecoderClass() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.withClassLoader(new FilteredClassLoader(JwtDecoder.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(OAuth2ResourceServerAutoConfiguration.class);
				assertThat(getBearerTokenFilter(context)).isNull();
			});
	}
	@Test
	void jwtSecurityFilterShouldBeConditionalOnSecurityFilterChainClass() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(OAuth2ResourceServerAutoConfiguration.class);
				assertThat(getBearerTokenFilter(context)).isNull();
			});
	}
	@Test
	void opaqueTokenSecurityFilterShouldBeConditionalOnSecurityFilterChainClass() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(OAuth2ResourceServerAutoConfiguration.class);
				assertThat(getBearerTokenFilter(context)).isNull();
			});
	}
	@Test
	void autoConfigurationWhenJwkSetUriAndIntrospectionUriAvailable() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(OpaqueTokenIntrospector.class);
				assertThat(context).hasSingleBean(JwtDecoder.class);
				assertThat(getBearerTokenFilter(context)).extracting('authenticationManagerResolver.arg$1.providers')
					.asInstanceOf(InstanceOfAssertFactories.LIST)
					.hasAtLeastOneElementOfType(JwtAuthenticationProvider.class);
			});
	}
	@Test
	void autoConfigurationWhenIntrospectionUriAvailableShouldConfigureIntrospectionClient() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(OpaqueTokenIntrospector.class);
				assertThat(getBearerTokenFilter(context)).isNotNull();
			});
	}
	@Test
	void opaqueTokenIntrospectorIsConditionalOnMissingBean() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com')
			.withUserConfiguration(OpaqueTokenIntrospectorConfig.class)
			.run((context) -> assertThat(getBearerTokenFilter(context)).isNotNull());
	}
	@Test
	void autoConfigurationWhenIntrospectionUriAvailableShouldBeConditionalOnClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(BearerTokenAuthenticationToken.class))
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.run((context) -> assertThat(context).doesNotHaveBean(OpaqueTokenIntrospector.class));
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingJwkSetUriAndIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=http://' + this.server.getHostName() + ':'
							+ this.server.getPort() + '/' + path)
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				validate(jwt().claim('iss', issuer), jwtDecoder,
						(validators) -> assertThat(validators).hasAtLeastOneElementOfType(JwtIssuerValidator.class));
			});
	}
	@Test
	void autoConfigurationShouldNotConfigureIssuerUriAndAudienceJwtValidatorIfPropertyNotConfigured() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				validate(jwt(), jwtDecoder,
						(validators) -> assertThat(validators).hasSize(2).noneSatisfy(audClaimValidator()));
			});
	}
	@Test
	void autoConfigurationShouldConfigureAudienceAndIssuerJwtValidatorIfPropertyProvided() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner.withPropertyValues(
				'spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
				'spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri,
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,https://test-audience1.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				validate(
						jwt().claim('iss', URI.create(issuerUri).toURL())
							.claim('aud', List.of('https://test-audience.com')),
						jwtDecoder,
						(validators) -> assertThat(validators).hasAtLeastOneElementOfType(JwtIssuerValidator.class)
							.satisfiesOnlyOnce(audClaimValidator()));
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void autoConfigurationShouldConfigureAudienceValidatorIfPropertyProvidedAndIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri,
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,https://test-audience1.com')
			.run((context) -> {
				SupplierJwtDecoder supplierJwtDecoderBean = context.getBean(SupplierJwtDecoder.class);
				Supplier<JwtDecoder> jwtDecoderSupplier = (Supplier<JwtDecoder>) ReflectionTestUtils
					.getField(supplierJwtDecoderBean, 'delegate');
				JwtDecoder jwtDecoder = jwtDecoderSupplier.get();
				validate(
						jwt().claim('iss', URI.create(issuerUri).toURL())
							.claim('aud', List.of('https://test-audience.com')),
						jwtDecoder,
						(validators) -> assertThat(validators).hasAtLeastOneElementOfType(JwtIssuerValidator.class)
							.satisfiesOnlyOnce(audClaimValidator()));
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void autoConfigurationShouldConfigureCustomValidators() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri)
			.withUserConfiguration(CustomJwtClaimValidatorConfig.class)
			.run((context) -> {
				SupplierJwtDecoder supplierJwtDecoderBean = context.getBean(SupplierJwtDecoder.class);
				Supplier<JwtDecoder> jwtDecoderSupplier = (Supplier<JwtDecoder>) ReflectionTestUtils
					.getField(supplierJwtDecoderBean, 'delegate');
				JwtDecoder jwtDecoder = jwtDecoderSupplier.get();
				assertThat(context).hasBean('customJwtClaimValidator');
				OAuth2TokenValidator<Jwt> customValidator = (OAuth2TokenValidator<Jwt>) context
					.getBean('customJwtClaimValidator');
				validate(jwt().claim('iss', URI.create(issuerUri).toURL()).claim('custom_claim', 'custom_claim_value'),
						jwtDecoder, (validators) -> assertThat(validators).contains(customValidator)
							.hasAtLeastOneElementOfType(JwtIssuerValidator.class));
			});
	}
	@Test
	void autoConfigurationShouldConfigureAudienceValidatorIfPropertyProvidedAndPublicKey() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner.withPropertyValues(
				'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,http://test-audience1.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				validate(jwt().claim('aud', List.of('https://test-audience.com')), jwtDecoder,
						(validators) -> assertThat(validators).satisfiesOnlyOnce(audClaimValidator()));
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void audienceValidatorWhenAudienceInvalid() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner.withPropertyValues(
				'spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
				'spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri,
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,https://test-audience1.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(JwtDecoder.class);
				JwtDecoder jwtDecoder = context.getBean(JwtDecoder.class);
				DelegatingOAuth2TokenValidator<Jwt> jwtValidator = (DelegatingOAuth2TokenValidator<Jwt>) ReflectionTestUtils
					.getField(jwtDecoder, 'jwtValidator');
				Jwt jwt = jwt().claim('iss', new URL(issuerUri))
					.claim('aud', Collections.singletonList('https://other-audience.com'))
					.build();
				assertThat(jwtValidator.validate(jwt).hasErrors()).isTrue();
			});
	}
	@Test
	void jwtSecurityConfigurerBacksOffWhenSecurityFilterChainBeanIsPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebMvcAutoConfiguration.class))
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class, TestSecurityFilterChainConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(SecurityFilterChain.class));
	}
	@Test
	void opaqueTokenSecurityConfigurerBacksOffWhenSecurityFilterChainBeanIsPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebMvcAutoConfiguration.class))
			.withUserConfiguration(TestSecurityFilterChainConfig.class)
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.run((context) -> assertThat(context).hasSingleBean(SecurityFilterChain.class));
	}
	@ParameterizedTest(name = '{0}')
	@ArgumentsSource(JwtConverterCustomizationsArgumentsProvider.class)
	void autoConfigurationShouldConfigureResourceServerWithJwtConverterCustomizations(String[] properties, Jwt jwt,
			String expectedPrincipal, String[] expectedAuthorities) {
		this.contextRunner.withPropertyValues(properties).run((context) -> {
			JwtAuthenticationConverter converter = context.getBean(JwtAuthenticationConverter.class);
			AbstractAuthenticationToken token = converter.convert(jwt);
			assertThat(token).isNotNull().extracting(AbstractAuthenticationToken::getName).isEqualTo(expectedPrincipal);
			assertThat(token.getAuthorities()).extracting(GrantedAuthority::getAuthority)
				.containsExactlyInAnyOrder(expectedAuthorities);
			assertThat(context).hasSingleBean(JwtDecoder.class);
			assertThat(getBearerTokenFilter(context)).isNotNull();
		});
	}
	@Test
	void shouldNotConfigureJwtConverterIfNoPropertiesAreSet() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(JwtAuthenticationConverter.class));
	}
	@Test
	void shouldConfigureJwtConverterIfPrincipalClaimNameIsSet() {
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.principal-claim-name=dummy')
			.run((context) -> assertThat(context).hasSingleBean(JwtAuthenticationConverter.class));
	}
	@Test
	void shouldConfigureJwtConverterIfAuthorityPrefixIsSet() {
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.authority-prefix=dummy')
			.run((context) -> assertThat(context).hasSingleBean(JwtAuthenticationConverter.class));
	}
	@Test
	void shouldConfigureJwtConverterIfAuthorityClaimsNameIsSet() {
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.authorities-claim-name=dummy')
			.run((context) -> assertThat(context).hasSingleBean(JwtAuthenticationConverter.class));
	}
	@Test
	void jwtAuthenticationConverterByJwtConfigIsConditionalOnMissingBean() {
		String propertiesPrincipalClaim = 'principal_from_properties';
		String propertiesPrincipalValue = 'from_props';
		String userConfigPrincipalValue = 'from_user_config';
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.principal-claim-name=' + propertiesPrincipalClaim)
			.withUserConfiguration(CustomJwtConverterConfig.class)
			.run((context) -> {
				JwtAuthenticationConverter converter = context.getBean(JwtAuthenticationConverter.class);
				Jwt jwt = jwt().claim(propertiesPrincipalClaim, propertiesPrincipalValue)
					.claim(CustomJwtConverterConfig.PRINCIPAL_CLAIM, userConfigPrincipalValue)
					.build();
				AbstractAuthenticationToken token = converter.convert(jwt);
				assertThat(token).isNotNull()
					.extracting(AbstractAuthenticationToken::getName)
					.isEqualTo(userConfigPrincipalValue)
					.isNotEqualTo(propertiesPrincipalValue);
				assertThat(context).hasSingleBean(JwtDecoder.class);
				assertThat(getBearerTokenFilter(context)).isNotNull();
			});
	}
	private Filter getBearerTokenFilter(AssertableWebApplicationContext context) {
		FilterChainProxy filterChain = (FilterChainProxy) context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN);
		List<SecurityFilterChain> filterChains = filterChain.getFilterChains();
		List<Filter> filters = filterChains.get(0).getFilters();
		return filters.stream().filter((f) -> f instanceof BearerTokenAuthenticationFilter).findFirst().orElse(null);
	}
	private String cleanIssuerPath(String issuer) {
		if (issuer.endsWith('/')) {
			return issuer.substring(0, issuer.length() - 1);
		}
		return issuer;
	}
	private void setupMockResponse(String issuer) throws JsonProcessingException {
		MockResponse mockResponse = new MockResponse().setResponseCode(HttpStatus.OK.value())
			.setBody(new ObjectMapper().writeValueAsString(getResponse(issuer)))
			.setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
		this.server.enqueue(mockResponse);
		this.server.enqueue(
				new MockResponse().setResponseCode(200).setHeader('Content-Type', 'application/json').setBody(JWK_SET));
	}
	private void setupMockResponsesWithErrors(String issuer, int errorResponseCount) throws JsonProcessingException {
		for (int i = 0; i < errorResponseCount; i++) {
			MockResponse emptyResponse = new MockResponse().setResponseCode(HttpStatus.NOT_FOUND.value());
			this.server.enqueue(emptyResponse);
		}
		setupMockResponse(issuer);
	}
	private Map<String, Object> getResponse(String issuer) {
		Map<String, Object> response = new HashMap<>();
		response.put('authorization_endpoint', 'https://example.com/o/oauth2/v2/auth');
		response.put('claims_supported', Collections.emptyList());
		response.put('code_challenge_methods_supported', Collections.emptyList());
		response.put('id_token_signing_alg_values_supported', Collections.emptyList());
		response.put('issuer', issuer);
		response.put('jwks_uri', issuer + '/.well-known/jwks.json');
		response.put('response_types_supported', Collections.emptyList());
		response.put('revocation_endpoint', 'https://example.com/o/oauth2/revoke');
		response.put('scopes_supported', Collections.singletonList('openid'));
		response.put('subject_types_supported', Collections.singletonList('public'));
		response.put('grant_types_supported', Collections.singletonList('authorization_code'));
		response.put('token_endpoint', 'https://example.com/oauth2/v4/token');
		response.put('token_endpoint_auth_methods_supported', Collections.singletonList('client_secret_basic'));
		response.put('userinfo_endpoint', 'https://example.com/oauth2/v3/userinfo');
		return response;
	}
	static Jwt.Builder jwt() {
		return Jwt.withTokenValue('token')
			.header('alg', 'none')
			.expiresAt(Instant.MAX)
			.issuedAt(Instant.MIN)
			.issuer('https://issuer.example.org')
			.jti('jti')
			.notBefore(Instant.MIN)
			.subject('mock-test-subject');
	}
	@SuppressWarnings('unchecked')
	private void validate(Jwt.Builder builder, JwtDecoder jwtDecoder,
			ThrowingConsumer<List<OAuth2TokenValidator<Jwt>>> validatorsConsumer) {
		DelegatingOAuth2TokenValidator<Jwt> jwtValidator = (DelegatingOAuth2TokenValidator<Jwt>) ReflectionTestUtils
			.getField(jwtDecoder, 'jwtValidator');
		assertThat(jwtValidator.validate(builder.build()).hasErrors()).isFalse();
		validatorsConsumer.accept(extractValidators(jwtValidator));
	}
	@SuppressWarnings('unchecked')
	private List<OAuth2TokenValidator<Jwt>> extractValidators(DelegatingOAuth2TokenValidator<Jwt> delegatingValidator) {
		Collection<OAuth2TokenValidator<Jwt>> delegates = (Collection<OAuth2TokenValidator<Jwt>>) ReflectionTestUtils
			.getField(delegatingValidator, 'tokenValidators');
		List<OAuth2TokenValidator<Jwt>> extracted = new ArrayList<>();
		for (OAuth2TokenValidator<Jwt> delegate : delegates) {
			if (delegate instanceof DelegatingOAuth2TokenValidator<Jwt> delegatingDelegate) {
				extracted.addAll(extractValidators(delegatingDelegate));
			}
			else {
				extracted.add(delegate);
			}
		}
		return extracted;
	}
	private Consumer<OAuth2TokenValidator<Jwt>> audClaimValidator() {
		return (validator) -> assertThat(validator).isInstanceOf(JwtClaimValidator.class)
			.extracting('claim')
			.isEqualTo('aud');
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSecurity
	static class TestConfig {
		@Bean
		@Order(1)
		JwkSetUriJwtDecoderBuilderCustomizer decoderBuilderCustomizer() {
			return mock(JwkSetUriJwtDecoderBuilderCustomizer.class);
		}
		@Bean
		@Order(2)
		JwkSetUriJwtDecoderBuilderCustomizer anotherDecoderBuilderCustomizer() {
			return mock(JwkSetUriJwtDecoderBuilderCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSecurity
	static class JwtDecoderConfig {
		@Bean
		JwtDecoder decoder() {
			return mock(JwtDecoder.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSecurity
	static class OpaqueTokenIntrospectorConfig {
		@Bean
		OpaqueTokenIntrospector decoder() {
			return mock(OpaqueTokenIntrospector.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSecurity
	static class TestSecurityFilterChainConfig {
		@Bean
		SecurityFilterChain testSecurityFilterChain(HttpSecurity http) throws Exception {
			http.securityMatcher('/**');
			http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
			return http.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJwtClaimValidatorConfig {
		@Bean
		JwtClaimValidator<String> customJwtClaimValidator() {
			return new JwtClaimValidator<>('custom_claim', 'custom_claim_value'::equals);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJwtConverterConfig {
		static String PRINCIPAL_CLAIM = 'principal_from_user_configuration';
		@Bean
		JwtAuthenticationConverter customJwtAuthenticationConverter() {
			JwtAuthenticationConverter converter = new JwtAuthenticationConverter();
			converter.setPrincipalClaimName(PRINCIPAL_CLAIM);
			return converter;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource;
/**
public final class JwtConverterCustomizationsArgumentsProvider implements ArgumentsProvider {
	@Override
	public Stream<? extends Arguments> provideArguments(ExtensionContext extensionContext) {
		String customPrefix = 'CUSTOM_AUTHORITY_PREFIX_';
		String customDelimiter = '[~,#:]';
		String customAuthoritiesClaim = 'custom_authorities';
		String customPrincipalClaim = 'custom_principal';
		String jwkSetUriProperty = 'spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com';
		String authorityPrefixProperty = 'spring.security.oauth2.resourceserver.jwt.authority-prefix=' + customPrefix;
		String authoritiesDelimiterProperty = 'spring.security.oauth2.resourceserver.jwt.authorities-claim-delimiter='
				+ customDelimiter;
		String authoritiesClaimProperty = 'spring.security.oauth2.resourceserver.jwt.authorities-claim-name='
				+ customAuthoritiesClaim;
		String principalClaimProperty = 'spring.security.oauth2.resourceserver.jwt.principal-claim-name='
				+ customPrincipalClaim;
		String[] customPrefixProps = { jwkSetUriProperty, authorityPrefixProperty };
		String[] customDelimiterProps = { jwkSetUriProperty, authorityPrefixProperty, authoritiesDelimiterProperty };
		String[] customAuthoritiesClaimProps = { jwkSetUriProperty, authoritiesClaimProperty };
		String[] customPrincipalClaimProps = { jwkSetUriProperty, principalClaimProperty };
		String[] allJwtConverterProps = { jwkSetUriProperty, authorityPrefixProperty, authoritiesDelimiterProperty,
				authoritiesClaimProperty, principalClaimProperty };
		String[] jwtScopes = { 'custom_scope0', 'custom_scope1' };
		String subjectValue = UUID.randomUUID().toString();
		String customPrincipalValue = UUID.randomUUID().toString();
		Jwt.Builder jwtBuilder = Jwt.withTokenValue('token')
			.header('alg', 'none')
			.expiresAt(Instant.MAX)
			.issuedAt(Instant.MIN)
			.issuer('https://issuer.example.org')
			.jti('jti')
			.notBefore(Instant.MIN)
			.subject(subjectValue)
			.claim(customPrincipalClaim, customPrincipalValue);
		Jwt noAuthoritiesCustomizationsJwt = jwtBuilder.claim('scp', jwtScopes[0] + ' ' + jwtScopes[1]).build();
		Jwt customAuthoritiesDelimiterJwt = jwtBuilder.claim('scp', jwtScopes[0] + '~' + jwtScopes[1]).build();
		Jwt customAuthoritiesClaimJwt = jwtBuilder.claim('scp', null)
			.claim(customAuthoritiesClaim, jwtScopes[0] + ' ' + jwtScopes[1])
			.build();
		Jwt customAuthoritiesClaimAndDelimiterJwt = jwtBuilder.claim('scp', null)
			.claim(customAuthoritiesClaim, jwtScopes[0] + '~' + jwtScopes[1])
			.build();
		String[] customPrefixAuthorities = { customPrefix + jwtScopes[0], customPrefix + jwtScopes[1] };
		String[] defaultPrefixAuthorities = { 'SCOPE_' + jwtScopes[0], 'SCOPE_' + jwtScopes[1] };
		return Stream.of(
				Arguments.of(Named.named('Custom prefix for GrantedAuthority', customPrefixProps),
						noAuthoritiesCustomizationsJwt, subjectValue, customPrefixAuthorities),
				Arguments.of(Named.named('Custom delimiter for JWT scopes', customDelimiterProps),
						customAuthoritiesDelimiterJwt, subjectValue, customPrefixAuthorities),
				Arguments.of(Named.named('Custom JWT authority claim name', customAuthoritiesClaimProps),
						customAuthoritiesClaimJwt, subjectValue, defaultPrefixAuthorities),
				Arguments.of(Named.named('Custom JWT principal claim name', customPrincipalClaimProps),
						noAuthoritiesCustomizationsJwt, customPrincipalValue, defaultPrefixAuthorities),
				Arguments.of(Named.named('All JWT converter customizations', allJwtConverterProps),
						customAuthoritiesClaimAndDelimiterJwt, customPrincipalValue, customPrefixAuthorities));
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.reactive;
/**
class ReactiveOAuth2ResourceServerAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactiveOAuth2ResourceServerAutoConfiguration.class))
		.withUserConfiguration(TestConfig.class);
	private MockWebServer server;
	private static final Duration TIMEOUT = Duration.ofSeconds(5000000);
	private static final String JWK_SET = '{\'keys\':[{\'kty\':\'RSA\',\'e\':\'AQAB\',\'use\':\'sig\','
			+ '\'kid\':\'one\',\'n\':\'oXJ8OyOv_eRnce4akdanR4KYRfnC2zLV4uYNQpcFn6oHL0dj7D6kxQmsXoYgJV8ZVDn71KGm'
			+ 'uLvolxsDncc2UrhyMBY6DVQVgMSVYaPCTgW76iYEKGgzTEw5IBRQL9w3SRJWd3VJTZZQjkXef48Ocz06PGF3lhbz4t5UEZtd'
			+ 'F4rIe7u-977QwHuh7yRPBQ3sII-cVoOUMgaXB9SHcGF2iZCtPzL_IffDUcfhLQteGebhW8A6eUHgpD5A1PQ-JCw_G7UOzZAj'
			+ 'jDjtNM2eqm8j-Ms_gqnm4MiCZ4E-9pDN77CAAPVN7kuX6ejs9KBXpk01z48i9fORYk9u7rAkh1HuQw\'}]}';
	@AfterEach
	void cleanup() throws Exception {
		if (this.server != null) {
			this.server.shutdown();
		}
	}
	@Test
	void autoConfigurationShouldConfigureResourceServer() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
			});
	}
	@Test
	void autoConfigurationUsingJwkSetUriShouldConfigureResourceServerUsingSingleJwsAlgorithm() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RS512')
			.run((context) -> {
				NimbusReactiveJwtDecoder nimbusReactiveJwtDecoder = context.getBean(NimbusReactiveJwtDecoder.class);
				assertThat(nimbusReactiveJwtDecoder).extracting('jwtProcessor.arg$1.signatureAlgorithms')
					.asInstanceOf(InstanceOfAssertFactories.collection(SignatureAlgorithm.class))
					.containsExactlyInAnyOrder(SignatureAlgorithm.RS512);
				assertJwkSetUriReactiveJwtDecoderBuilderCustomization(context);
			});
	}
	private void assertJwkSetUriReactiveJwtDecoderBuilderCustomization(
			AssertableReactiveWebApplicationContext context) {
		JwkSetUriReactiveJwtDecoderBuilderCustomizer customizer = context.getBean('decoderBuilderCustomizer',
				JwkSetUriReactiveJwtDecoderBuilderCustomizer.class);
		JwkSetUriReactiveJwtDecoderBuilderCustomizer anotherCustomizer = context
			.getBean('anotherDecoderBuilderCustomizer', JwkSetUriReactiveJwtDecoderBuilderCustomizer.class);
		InOrder inOrder = inOrder(customizer, anotherCustomizer);
		inOrder.verify(customizer).customize(any());
		inOrder.verify(anotherCustomizer).customize(any());
	}
	@Test
	void autoConfigurationUsingJwkSetUriShouldConfigureResourceServerUsingMultipleJwsAlgorithms() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RS256, RS384, RS512')
			.run((context) -> {
				NimbusReactiveJwtDecoder nimbusReactiveJwtDecoder = context.getBean(NimbusReactiveJwtDecoder.class);
				assertThat(nimbusReactiveJwtDecoder).extracting('jwtProcessor.arg$1.signatureAlgorithms')
					.asInstanceOf(InstanceOfAssertFactories.collection(SignatureAlgorithm.class))
					.containsExactlyInAnyOrder(SignatureAlgorithm.RS256, SignatureAlgorithm.RS384,
							SignatureAlgorithm.RS512);
				assertJwkSetUriReactiveJwtDecoderBuilderCustomization(context);
			});
	}
	@Test
	void autoConfigurationUsingPublicKeyValueShouldConfigureResourceServerUsingSingleJwsAlgorithm() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RS384')
			.run((context) -> {
				NimbusReactiveJwtDecoder nimbusReactiveJwtDecoder = context.getBean(NimbusReactiveJwtDecoder.class);
				assertThat(nimbusReactiveJwtDecoder).extracting('jwtProcessor.arg$1.jwsKeySelector.expectedJWSAlg')
					.isEqualTo(JWSAlgorithm.RS384);
			});
	}
	@Test
	void autoConfigurationUsingPublicKeyValueWithMultipleJwsAlgorithmsShouldFail() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
					'spring.security.oauth2.resourceserver.jwt.jws-algorithms=RSA256,RS384')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).hasRootCauseMessage(
						'Creating a JWT decoder using a public key requires exactly one JWS algorithm but 2 were '
								+ 'configured');
			});
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingOidcIssuerUri() throws IOException {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=http://'
					+ this.server.getHostName() + ':' + this.server.getPort() + '/' + path)
			.run((context) -> {
				assertThat(context).hasSingleBean(SupplierReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
				// Trigger calls to the issuer by decoding a token
				decodeJwt(context);
				assertJwkSetUriReactiveJwtDecoderBuilderCustomization(context);
			});
		// The last request is to the JWK Set endpoint to look up the algorithm
		assertThat(this.server.getRequestCount()).isEqualTo(2);
	}
	@SuppressWarnings('unchecked')
	private void decodeJwt(AssertableReactiveWebApplicationContext context) {
		SupplierReactiveJwtDecoder supplierReactiveJwtDecoder = context.getBean(SupplierReactiveJwtDecoder.class);
		Mono<ReactiveJwtDecoder> reactiveJwtDecoderSupplier = (Mono<ReactiveJwtDecoder>) ReflectionTestUtils
			.getField(supplierReactiveJwtDecoder, 'jwtDecoderMono');
		try {
			reactiveJwtDecoderSupplier.flatMap((decoder) -> decoder.decode('eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.'
					+ 'eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.'
					+ 'NHVaYe26MbtOYhSKkoKYdFVomg4i8ZJd8_-RU8VNbftc4TSMb4bXP3l3YlNWACwyXPGffz5aXHc6lty1Y2t4SWRqGteragsVdZufDn5BlnJl9pdR_kdVFUsra2rWKEofkZeIC4yWytE58sMIihvo9H1ScmmVwBcQP6XETqYd0aSHp1gOa9RdUPDvoXQ5oqygTqVtxaDr6wUFKrKItgBMzWIdNZ6y7O9E0DhEPTbE9rfBo6KTFsHAZnMg4k68CDp2woYIaXbmYTWcvbzIuHO7_37GT79XdIwkm95QJ7hYC9RiwrV7mesbY4PAahERJawntho0my942XheVLmGwLMBkQ'))
				.block(TIMEOUT);
		}
		catch (Exception ex) {
			// This fails, but it"s enough to check that the expected HTTP calls
			// are made
		}
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingOidcRfc8414IssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String issuer = this.server.url('').toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponsesWithErrors(cleanIssuerPath, 1);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=http://'
					+ this.server.getHostName() + ':' + this.server.getPort())
			.run((context) -> {
				assertThat(context).hasSingleBean(SupplierReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
				// Trigger calls to the issuer by decoding a token
				decodeJwt(context);
				// assertJwkSetUriReactiveJwtDecoderBuilderCustomization(context);
			});
		// The last request is to the JWK Set endpoint to look up the algorithm
		assertThat(this.server.getRequestCount()).isEqualTo(3);
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingOAuthIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String issuer = this.server.url('').toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponsesWithErrors(cleanIssuerPath, 2);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=http://'
					+ this.server.getHostName() + ':' + this.server.getPort())
			.run((context) -> {
				assertThat(context).hasSingleBean(SupplierReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
				// Trigger calls to the issuer by decoding a token
				decodeJwt(context);
				assertJwkSetUriReactiveJwtDecoderBuilderCustomization(context);
			});
		// The last request is to the JWK Set endpoint to look up the algorithm
		assertThat(this.server.getRequestCount()).isEqualTo(4);
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingPublicKeyValue() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location')
			.run((context) -> {
				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
			});
	}
	@Test
	void autoConfigurationShouldFailIfPublicKeyLocationDoesNotExist() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:does-not-exist')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.hasMessageContaining('class path resource [does-not-exist]')
				.hasMessageContaining('Public key location does not exist'));
	}
	@Test
	void autoConfigurationWhenSetUriKeyLocationIssuerUriPresentShouldUseSetUri() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=https://jwk-oidc-issuer-location.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
				assertThat(context.containsBean('jwtDecoder')).isTrue();
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isFalse();
			});
	}
	@Test
	void autoConfigurationWhenKeyLocationAndIssuerUriPresentShouldUseIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String issuer = this.server.url('').toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=http://' + this.server.getHostName() + ':'
							+ this.server.getPort(),
					'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location')
			.run((context) -> {
				assertThat(context).hasSingleBean(SupplierReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
				assertThat(context.containsBean('jwtDecoderByIssuerUri')).isTrue();
			});
	}
	@Test
	void autoConfigurationWhenJwkSetUriNullShouldNotFail() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN));
	}
	@Test
	void jwtDecoderBeanIsConditionalOnMissingBean() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.run((this::assertFilterConfiguredWithJwtAuthenticationManager));
	}
	@Test
	void jwtDecoderByIssuerUriBeanIsConditionalOnMissingBean() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=https://jwk-oidc-issuer-location.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.run((this::assertFilterConfiguredWithJwtAuthenticationManager));
	}
	@Test
	void autoConfigurationShouldBeConditionalOnBearerTokenAuthenticationTokenClass() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.withClassLoader(new FilteredClassLoader(BearerTokenAuthenticationToken.class))
			.run((context) -> assertThat(context).doesNotHaveBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN));
	}
	@Test
	void autoConfigurationShouldBeConditionalOnReactiveJwtDecoderClass() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(JwtDecoderConfig.class)
			.withClassLoader(new FilteredClassLoader(ReactiveJwtDecoder.class))
			.run((context) -> assertThat(context).doesNotHaveBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN));
	}
	@Test
	void autoConfigurationWhenSecurityWebFilterChainConfigPresentShouldNotAddOne() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.withUserConfiguration(SecurityWebFilterChainConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SecurityWebFilterChain.class);
				assertThat(context).hasBean('testSpringSecurityFilterChain');
			});
	}
	@Test
	void autoConfigurationWhenIntrospectionUriAvailableShouldConfigureIntrospectionClient() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveOpaqueTokenIntrospector.class);
				assertFilterConfiguredWithOpaqueTokenAuthenticationManager(context);
			});
	}
	@Test
	void autoConfigurationWhenJwkSetUriAndIntrospectionUriAvailable() {
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveOpaqueTokenIntrospector.class);
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
			});
	}
	@Test
	void opaqueTokenIntrospectorIsConditionalOnMissingBean() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com')
			.withUserConfiguration(OpaqueTokenIntrospectorConfig.class)
			.run((this::assertFilterConfiguredWithOpaqueTokenAuthenticationManager));
	}
	@Test
	void autoConfigurationForOpaqueTokenWhenSecurityWebFilterChainConfigPresentShouldNotAddOne() {
		this.contextRunner
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.withUserConfiguration(SecurityWebFilterChainConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SecurityWebFilterChain.class);
				assertThat(context).hasBean('testSpringSecurityFilterChain');
			});
	}
	@Test
	void autoConfigurationWhenIntrospectionUriAvailableShouldBeConditionalOnClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(BearerTokenAuthenticationToken.class))
			.withPropertyValues(
					'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://check-token.com',
					'spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id',
					'spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveOpaqueTokenIntrospector.class));
	}
	@Test
	void autoConfigurationShouldConfigureResourceServerUsingJwkSetUriAndIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=http://' + this.server.getHostName() + ':'
							+ this.server.getPort() + '/' + path)
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				ReactiveJwtDecoder reactiveJwtDecoder = context.getBean(ReactiveJwtDecoder.class);
				validate(jwt().claim('iss', issuer), reactiveJwtDecoder,
						(validators) -> assertThat(validators).hasAtLeastOneElementOfType(JwtIssuerValidator.class));
			});
	}
	@Test
	void autoConfigurationShouldNotConfigureIssuerUriAndAudienceJwtValidatorIfPropertyNotConfigured() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				ReactiveJwtDecoder reactiveJwtDecoder = context.getBean(ReactiveJwtDecoder.class);
				validate(jwt(), reactiveJwtDecoder,
						(validators) -> assertThat(validators).hasSize(2).noneSatisfy(audClaimValidator()));
			});
	}
	@Test
	void autoConfigurationShouldConfigureIssuerAndAudienceJwtValidatorIfPropertyProvided() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner.withPropertyValues(
				'spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
				'spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri,
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,https://test-audience1.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				ReactiveJwtDecoder reactiveJwtDecoder = context.getBean(ReactiveJwtDecoder.class);
				validate(
						jwt().claim('iss', URI.create(issuerUri).toURL())
							.claim('aud', List.of('https://test-audience.com')),
						reactiveJwtDecoder,
						(validators) -> assertThat(validators).hasAtLeastOneElementOfType(JwtIssuerValidator.class)
							.satisfiesOnlyOnce(audClaimValidator()));
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void autoConfigurationShouldConfigureAudienceValidatorIfPropertyProvidedAndIssuerUri() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri,
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,https://test-audience1.com')
			.run((context) -> {
				SupplierReactiveJwtDecoder supplierJwtDecoderBean = context.getBean(SupplierReactiveJwtDecoder.class);
				Mono<ReactiveJwtDecoder> jwtDecoderSupplier = (Mono<ReactiveJwtDecoder>) ReflectionTestUtils
					.getField(supplierJwtDecoderBean, 'jwtDecoderMono');
				ReactiveJwtDecoder jwtDecoder = jwtDecoderSupplier.block();
				validate(
						jwt().claim('iss', URI.create(issuerUri).toURL())
							.claim('aud', List.of('https://test-audience.com')),
						jwtDecoder,
						(validators) -> assertThat(validators).hasAtLeastOneElementOfType(JwtIssuerValidator.class)
							.satisfiesOnlyOnce(audClaimValidator()));
			});
	}
	@Test
	void autoConfigurationShouldConfigureAudienceValidatorIfPropertyProvidedAndPublicKey() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		this.contextRunner.withPropertyValues(
				'spring.security.oauth2.resourceserver.jwt.public-key-location=classpath:public-key-location',
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,https://test-audience1.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				ReactiveJwtDecoder jwtDecoder = context.getBean(ReactiveJwtDecoder.class);
				validate(jwt().claim('aud', List.of('https://test-audience.com')), jwtDecoder,
						(validators) -> assertThat(validators).satisfiesOnlyOnce(audClaimValidator()));
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void autoConfigurationShouldConfigureCustomValidators() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri)
			.withUserConfiguration(CustomJwtClaimValidatorConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				ReactiveJwtDecoder reactiveJwtDecoder = context.getBean(ReactiveJwtDecoder.class);
				OAuth2TokenValidator<Jwt> customValidator = (OAuth2TokenValidator<Jwt>) context
					.getBean('customJwtClaimValidator');
				validate(jwt().claim('iss', URI.create(issuerUri).toURL()).claim('custom_claim', 'custom_claim_value'),
						reactiveJwtDecoder, (validators) -> assertThat(validators).contains(customValidator)
							.hasAtLeastOneElementOfType(JwtIssuerValidator.class));
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void audienceValidatorWhenAudienceInvalid() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner.withPropertyValues(
				'spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
				'spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri,
				'spring.security.oauth2.resourceserver.jwt.audiences=https://test-audience.com,https://test-audience1.com')
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				ReactiveJwtDecoder jwtDecoder = context.getBean(ReactiveJwtDecoder.class);
				DelegatingOAuth2TokenValidator<Jwt> jwtValidator = (DelegatingOAuth2TokenValidator<Jwt>) ReflectionTestUtils
					.getField(jwtDecoder, 'jwtValidator');
				Jwt jwt = jwt().claim('iss', new URL(issuerUri))
					.claim('aud', Collections.singletonList('https://other-audience.com'))
					.build();
				assertThat(jwtValidator.validate(jwt).hasErrors()).isTrue();
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void customValidatorWhenInvalid() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String path = 'test';
		String issuer = this.server.url(path).toString();
		String cleanIssuerPath = cleanIssuerPath(issuer);
		setupMockResponse(cleanIssuerPath);
		String issuerUri = 'http://' + this.server.getHostName() + ':' + this.server.getPort() + '/' + path;
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.issuer-uri=' + issuerUri)
			.withUserConfiguration(CustomJwtClaimValidatorConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
				ReactiveJwtDecoder jwtDecoder = context.getBean(ReactiveJwtDecoder.class);
				DelegatingOAuth2TokenValidator<Jwt> jwtValidator = (DelegatingOAuth2TokenValidator<Jwt>) ReflectionTestUtils
					.getField(jwtDecoder, 'jwtValidator');
				Jwt jwt = jwt().claim('iss', new URL(issuerUri)).claim('custom_claim', 'invalid_value').build();
				assertThat(jwtValidator.validate(jwt).hasErrors()).isTrue();
			});
	}
	@Test
	void shouldNotConfigureJwtConverterIfNoPropertiesAreSet() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveJwtAuthenticationConverter.class));
	}
	@Test
	void shouldConfigureJwtConverterIfPrincipalClaimNameIsSet() {
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.principal-claim-name=dummy')
			.run((context) -> assertThat(context).hasSingleBean(ReactiveJwtAuthenticationConverter.class));
	}
	@Test
	void shouldConfigureJwtConverterIfAuthorityPrefixIsSet() {
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.authority-prefix=dummy')
			.run((context) -> assertThat(context).hasSingleBean(ReactiveJwtAuthenticationConverter.class));
	}
	@Test
	void shouldConfigureJwtConverterIfAuthorityClaimsNameIsSet() {
		this.contextRunner.withPropertyValues('spring.security.oauth2.resourceserver.jwt.authorities-claim-name=dummy')
			.run((context) -> assertThat(context).hasSingleBean(ReactiveJwtAuthenticationConverter.class));
	}
	@ParameterizedTest(name = '{0}')
	@ArgumentsSource(JwtConverterCustomizationsArgumentsProvider.class)
	void autoConfigurationShouldConfigureResourceServerWithJwtConverterCustomizations(String[] properties, Jwt jwt,
			String expectedPrincipal, String[] expectedAuthorities) {
		this.contextRunner.withPropertyValues(properties).run((context) -> {
			ReactiveJwtAuthenticationConverter converter = context.getBean(ReactiveJwtAuthenticationConverter.class);
			AbstractAuthenticationToken token = converter.convert(jwt).block();
			assertThat(token).isNotNull().extracting(AbstractAuthenticationToken::getName).isEqualTo(expectedPrincipal);
			assertThat(token.getAuthorities()).extracting(GrantedAuthority::getAuthority)
				.containsExactlyInAnyOrder(expectedAuthorities);
			assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class);
			assertFilterConfiguredWithJwtAuthenticationManager(context);
		});
	}
	@Test
	void jwtAuthenticationConverterByJwtConfigIsConditionalOnMissingBean() {
		String propertiesPrincipalClaim = 'principal_from_properties';
		String propertiesPrincipalValue = 'from_props';
		String userConfigPrincipalValue = 'from_user_config';
		this.contextRunner
			.withPropertyValues('spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://jwk-set-uri.com',
					'spring.security.oauth2.resourceserver.jwt.principal-claim-name=' + propertiesPrincipalClaim)
			.withUserConfiguration(CustomJwtConverterConfig.class)
			.run((context) -> {
				ReactiveJwtAuthenticationConverter converter = context
					.getBean(ReactiveJwtAuthenticationConverter.class);
				Jwt jwt = jwt().claim(propertiesPrincipalClaim, propertiesPrincipalValue)
					.claim(CustomJwtConverterConfig.PRINCIPAL_CLAIM, userConfigPrincipalValue)
					.build();
				AbstractAuthenticationToken token = converter.convert(jwt).block();
				assertThat(token).isNotNull()
					.extracting(AbstractAuthenticationToken::getName)
					.isEqualTo(userConfigPrincipalValue)
					.isNotEqualTo(propertiesPrincipalValue);
				assertThat(context).hasSingleBean(NimbusReactiveJwtDecoder.class);
				assertFilterConfiguredWithJwtAuthenticationManager(context);
			});
	}
	private void assertFilterConfiguredWithJwtAuthenticationManager(AssertableReactiveWebApplicationContext context) {
		MatcherSecurityWebFilterChain filterChain = (MatcherSecurityWebFilterChain) context
			.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN);
		Stream<WebFilter> filters = filterChain.getWebFilters().toStream();
		AuthenticationWebFilter webFilter = (AuthenticationWebFilter) filters
			.filter((f) -> f instanceof AuthenticationWebFilter)
			.findFirst()
			.orElse(null);
		ReactiveAuthenticationManagerResolver<?> authenticationManagerResolver = (ReactiveAuthenticationManagerResolver<?>) ReflectionTestUtils
			.getField(webFilter, 'authenticationManagerResolver');
		Object authenticationManager = authenticationManagerResolver.resolve(null).block(TIMEOUT);
		assertThat(authenticationManager).isInstanceOf(JwtReactiveAuthenticationManager.class);
	}
	private void assertFilterConfiguredWithOpaqueTokenAuthenticationManager(
			AssertableReactiveWebApplicationContext context) {
		MatcherSecurityWebFilterChain filterChain = (MatcherSecurityWebFilterChain) context
			.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN);
		Stream<WebFilter> filters = filterChain.getWebFilters().toStream();
		AuthenticationWebFilter webFilter = (AuthenticationWebFilter) filters
			.filter((f) -> f instanceof AuthenticationWebFilter)
			.findFirst()
			.orElse(null);
		ReactiveAuthenticationManagerResolver<?> authenticationManagerResolver = (ReactiveAuthenticationManagerResolver<?>) ReflectionTestUtils
			.getField(webFilter, 'authenticationManagerResolver');
		Object authenticationManager = authenticationManagerResolver.resolve(null).block(TIMEOUT);
		assertThat(authenticationManager).isInstanceOf(OpaqueTokenReactiveAuthenticationManager.class);
	}
	private String cleanIssuerPath(String issuer) {
		if (issuer.endsWith('/')) {
			return issuer.substring(0, issuer.length() - 1);
		}
		return issuer;
	}
	private void setupMockResponse(String issuer) throws JsonProcessingException {
		MockResponse mockResponse = new MockResponse().setResponseCode(HttpStatus.OK.value())
			.setBody(new ObjectMapper().writeValueAsString(getResponse(issuer)))
			.setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
		this.server.enqueue(mockResponse);
		this.server.enqueue(
				new MockResponse().setResponseCode(200).setHeader('Content-Type', 'application/json').setBody(JWK_SET));
	}
	private void setupMockResponsesWithErrors(String issuer, int errorResponseCount) throws JsonProcessingException {
		for (int i = 0; i < errorResponseCount; i++) {
			MockResponse emptyResponse = new MockResponse().setResponseCode(HttpStatus.NOT_FOUND.value());
			this.server.enqueue(emptyResponse);
		}
		setupMockResponse(issuer);
	}
	private Map<String, Object> getResponse(String issuer) {
		Map<String, Object> response = new HashMap<>();
		response.put('authorization_endpoint', 'https://example.com/o/oauth2/v2/auth');
		response.put('claims_supported', Collections.emptyList());
		response.put('code_challenge_methods_supported', Collections.emptyList());
		response.put('id_token_signing_alg_values_supported', Collections.emptyList());
		response.put('issuer', issuer);
		response.put('jwks_uri', issuer + '/.well-known/jwks.json');
		response.put('response_types_supported', Collections.emptyList());
		response.put('revocation_endpoint', 'https://example.com/o/oauth2/revoke');
		response.put('scopes_supported', Collections.singletonList('openid'));
		response.put('subject_types_supported', Collections.singletonList('public'));
		response.put('grant_types_supported', Collections.singletonList('authorization_code'));
		response.put('token_endpoint', 'https://example.com/oauth2/v4/token');
		response.put('token_endpoint_auth_methods_supported', Collections.singletonList('client_secret_basic'));
		response.put('userinfo_endpoint', 'https://example.com/oauth2/v3/userinfo');
		return response;
	}
	static Jwt.Builder jwt() {
		return Jwt.withTokenValue('token')
			.header('alg', 'none')
			.expiresAt(Instant.MAX)
			.issuedAt(Instant.MIN)
			.issuer('https://issuer.example.org')
			.jti('jti')
			.notBefore(Instant.MIN)
			.subject('mock-test-subject');
	}
	@SuppressWarnings('unchecked')
	private void validate(Jwt.Builder builder, ReactiveJwtDecoder jwtDecoder,
			ThrowingConsumer<List<OAuth2TokenValidator<Jwt>>> validatorsConsumer) {
		DelegatingOAuth2TokenValidator<Jwt> jwtValidator = (DelegatingOAuth2TokenValidator<Jwt>) ReflectionTestUtils
			.getField(jwtDecoder, 'jwtValidator');
		assertThat(jwtValidator.validate(builder.build()).hasErrors()).isFalse();
		validatorsConsumer.accept(extractValidators(jwtValidator));
	}
	@SuppressWarnings('unchecked')
	private List<OAuth2TokenValidator<Jwt>> extractValidators(DelegatingOAuth2TokenValidator<Jwt> delegatingValidator) {
		Collection<OAuth2TokenValidator<Jwt>> delegates = (Collection<OAuth2TokenValidator<Jwt>>) ReflectionTestUtils
			.getField(delegatingValidator, 'tokenValidators');
		List<OAuth2TokenValidator<Jwt>> extracted = new ArrayList<>();
		for (OAuth2TokenValidator<Jwt> delegate : delegates) {
			if (delegate instanceof DelegatingOAuth2TokenValidator<Jwt> delegatingDelegate) {
				extracted.addAll(extractValidators(delegatingDelegate));
			}
			else {
				extracted.add(delegate);
			}
		}
		return extracted;
	}
	private Consumer<OAuth2TokenValidator<Jwt>> audClaimValidator() {
		return (validator) -> assertThat(validator).isInstanceOf(JwtClaimValidator.class)
			.extracting('claim')
			.isEqualTo('aud');
	}
	@EnableWebFluxSecurity
	static class TestConfig {
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			return mock(MapReactiveUserDetailsService.class);
		}
		@Bean
		@Order(1)
		JwkSetUriReactiveJwtDecoderBuilderCustomizer decoderBuilderCustomizer() {
			return mock(JwkSetUriReactiveJwtDecoderBuilderCustomizer.class);
		}
		@Bean
		@Order(2)
		JwkSetUriReactiveJwtDecoderBuilderCustomizer anotherDecoderBuilderCustomizer() {
			return mock(JwkSetUriReactiveJwtDecoderBuilderCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JwtDecoderConfig {
		@Bean
		ReactiveJwtDecoder decoder() {
			return mock(ReactiveJwtDecoder.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OpaqueTokenIntrospectorConfig {
		@Bean
		ReactiveOpaqueTokenIntrospector decoder() {
			return mock(ReactiveOpaqueTokenIntrospector.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SecurityWebFilterChainConfig {
		@Bean
		SecurityWebFilterChain testSpringSecurityFilterChain(ServerHttpSecurity http) {
			http.authorizeExchange((exchanges) -> {
				exchanges.pathMatchers('/message/**').hasRole('ADMIN');
				exchanges.anyExchange().authenticated();
			});
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJwtClaimValidatorConfig {
		@Bean
		JwtClaimValidator<String> customJwtClaimValidator() {
			return new JwtClaimValidator<>('custom_claim', 'custom_claim_value'::equals);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJwtConverterConfig {
		static String PRINCIPAL_CLAIM = 'principal_from_user_configuration';
		@Bean
		ReactiveJwtAuthenticationConverter customReactiveJwtAuthenticationConverter() {
			ReactiveJwtAuthenticationConverter converter = new ReactiveJwtAuthenticationConverter();
			converter.setPrincipalClaimName(PRINCIPAL_CLAIM);
			return converter;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client;
/**
class OAuth2ClientPropertiesMapperTests {
	private MockWebServer server;
	@AfterEach
	void cleanup() throws Exception {
		if (this.server != null) {
			this.server.shutdown();
		}
	}
	@Test
	void getClientRegistrationsWhenUsingDefinedProviderShouldAdapt() {
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		Provider provider = createProvider();
		provider.setUserInfoAuthenticationMethod('form');
		OAuth2ClientProperties.Registration registration = createRegistration('provider');
		registration.setClientName('clientName');
		properties.getRegistration().put('registration', registration);
		properties.getProvider().put('provider', provider);
		Map<String, ClientRegistration> registrations = new OAuth2ClientPropertiesMapper(properties)
			.asClientRegistrations();
		ClientRegistration adapted = registrations.get('registration');
		ProviderDetails adaptedProvider = adapted.getProviderDetails();
		assertThat(adaptedProvider.getAuthorizationUri()).isEqualTo('https://example.com/auth');
		assertThat(adaptedProvider.getTokenUri()).isEqualTo('https://example.com/token');
		UserInfoEndpoint userInfoEndpoint = adaptedProvider.getUserInfoEndpoint();
		assertThat(userInfoEndpoint.getUri()).isEqualTo('https://example.com/info');
		assertThat(userInfoEndpoint.getAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.AuthenticationMethod.FORM);
		assertThat(userInfoEndpoint.getUserNameAttributeName()).isEqualTo('sub');
		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo('https://example.com/jwk');
		assertThat(adapted.getRegistrationId()).isEqualTo('registration');
		assertThat(adapted.getClientId()).isEqualTo('clientId');
		assertThat(adapted.getClientSecret()).isEqualTo('clientSecret');
		assertThat(adapted.getClientAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.ClientAuthenticationMethod.CLIENT_SECRET_POST);
		assertThat(adapted.getAuthorizationGrantType())
			.isEqualTo(org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
		assertThat(adapted.getRedirectUri()).isEqualTo('https://example.com/redirect');
		assertThat(adapted.getScopes()).containsExactly('user');
		assertThat(adapted.getClientName()).isEqualTo('clientName');
	}
	@Test
	void getClientRegistrationsWhenUsingCommonProviderShouldAdapt() {
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		OAuth2ClientProperties.Registration registration = new OAuth2ClientProperties.Registration();
		registration.setProvider('google');
		registration.setClientId('clientId');
		registration.setClientSecret('clientSecret');
		properties.getRegistration().put('registration', registration);
		Map<String, ClientRegistration> registrations = new OAuth2ClientPropertiesMapper(properties)
			.asClientRegistrations();
		ClientRegistration adapted = registrations.get('registration');
		ProviderDetails adaptedProvider = adapted.getProviderDetails();
		assertThat(adaptedProvider.getAuthorizationUri()).isEqualTo('https://accounts.google.com/o/oauth2/v2/auth');
		assertThat(adaptedProvider.getTokenUri()).isEqualTo('https://www.googleapis.com/oauth2/v4/token');
		UserInfoEndpoint userInfoEndpoint = adaptedProvider.getUserInfoEndpoint();
		assertThat(userInfoEndpoint.getUri()).isEqualTo('https://www.googleapis.com/oauth2/v3/userinfo');
		assertThat(userInfoEndpoint.getUserNameAttributeName()).isEqualTo(IdTokenClaimNames.SUB);
		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo('https://www.googleapis.com/oauth2/v3/certs');
		assertThat(adapted.getRegistrationId()).isEqualTo('registration');
		assertThat(adapted.getClientId()).isEqualTo('clientId');
		assertThat(adapted.getClientSecret()).isEqualTo('clientSecret');
		assertThat(adapted.getClientAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.ClientAuthenticationMethod.CLIENT_SECRET_BASIC);
		assertThat(adapted.getAuthorizationGrantType())
			.isEqualTo(org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
		assertThat(adapted.getRedirectUri()).isEqualTo('{baseUrl}/{action}/oauth2/code/{registrationId}');
		assertThat(adapted.getScopes()).containsExactly('openid', 'profile', 'email');
		assertThat(adapted.getClientName()).isEqualTo('Google');
	}
	@Test
	void getClientRegistrationsWhenUsingCommonProviderWithOverrideShouldAdapt() {
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		OAuth2ClientProperties.Registration registration = createRegistration('google');
		registration.setClientName('clientName');
		properties.getRegistration().put('registration', registration);
		Map<String, ClientRegistration> registrations = new OAuth2ClientPropertiesMapper(properties)
			.asClientRegistrations();
		ClientRegistration adapted = registrations.get('registration');
		ProviderDetails adaptedProvider = adapted.getProviderDetails();
		assertThat(adaptedProvider.getAuthorizationUri()).isEqualTo('https://accounts.google.com/o/oauth2/v2/auth');
		assertThat(adaptedProvider.getTokenUri()).isEqualTo('https://www.googleapis.com/oauth2/v4/token');
		UserInfoEndpoint userInfoEndpoint = adaptedProvider.getUserInfoEndpoint();
		assertThat(userInfoEndpoint.getUri()).isEqualTo('https://www.googleapis.com/oauth2/v3/userinfo');
		assertThat(userInfoEndpoint.getUserNameAttributeName()).isEqualTo(IdTokenClaimNames.SUB);
		assertThat(userInfoEndpoint.getAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.AuthenticationMethod.HEADER);
		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo('https://www.googleapis.com/oauth2/v3/certs');
		assertThat(adapted.getRegistrationId()).isEqualTo('registration');
		assertThat(adapted.getClientId()).isEqualTo('clientId');
		assertThat(adapted.getClientSecret()).isEqualTo('clientSecret');
		assertThat(adapted.getClientAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.ClientAuthenticationMethod.CLIENT_SECRET_POST);
		assertThat(adapted.getAuthorizationGrantType())
			.isEqualTo(org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
		assertThat(adapted.getRedirectUri()).isEqualTo('https://example.com/redirect');
		assertThat(adapted.getScopes()).containsExactly('user');
		assertThat(adapted.getClientName()).isEqualTo('clientName');
	}
	@Test
	void getClientRegistrationsWhenUnknownProviderShouldThrowException() {
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		OAuth2ClientProperties.Registration registration = new OAuth2ClientProperties.Registration();
		registration.setProvider('missing');
		properties.getRegistration().put('registration', registration);
		assertThatIllegalStateException()
			.isThrownBy(() -> new OAuth2ClientPropertiesMapper(properties).asClientRegistrations())
			.withMessageContaining('Unknown provider ID "missing"');
	}
	@Test
	void getClientRegistrationsWhenProviderNotSpecifiedShouldUseRegistrationId() {
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		OAuth2ClientProperties.Registration registration = new OAuth2ClientProperties.Registration();
		registration.setClientId('clientId');
		registration.setClientSecret('clientSecret');
		properties.getRegistration().put('google', registration);
		Map<String, ClientRegistration> registrations = new OAuth2ClientPropertiesMapper(properties)
			.asClientRegistrations();
		ClientRegistration adapted = registrations.get('google');
		ProviderDetails adaptedProvider = adapted.getProviderDetails();
		assertThat(adaptedProvider.getAuthorizationUri()).isEqualTo('https://accounts.google.com/o/oauth2/v2/auth');
		assertThat(adaptedProvider.getTokenUri()).isEqualTo('https://www.googleapis.com/oauth2/v4/token');
		UserInfoEndpoint userInfoEndpoint = adaptedProvider.getUserInfoEndpoint();
		assertThat(userInfoEndpoint.getUri()).isEqualTo('https://www.googleapis.com/oauth2/v3/userinfo');
		assertThat(userInfoEndpoint.getAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.AuthenticationMethod.HEADER);
		assertThat(adaptedProvider.getJwkSetUri()).isEqualTo('https://www.googleapis.com/oauth2/v3/certs');
		assertThat(adapted.getRegistrationId()).isEqualTo('google');
		assertThat(adapted.getClientId()).isEqualTo('clientId');
		assertThat(adapted.getClientSecret()).isEqualTo('clientSecret');
		assertThat(adapted.getClientAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.ClientAuthenticationMethod.CLIENT_SECRET_BASIC);
		assertThat(adapted.getAuthorizationGrantType())
			.isEqualTo(org.springframework.security.oauth2.core.AuthorizationGrantType.AUTHORIZATION_CODE);
		assertThat(adapted.getRedirectUri()).isEqualTo('{baseUrl}/{action}/oauth2/code/{registrationId}');
		assertThat(adapted.getScopes()).containsExactly('openid', 'profile', 'email');
		assertThat(adapted.getClientName()).isEqualTo('Google');
	}
	@Test
	void getClientRegistrationsWhenProviderNotSpecifiedAndUnknownProviderShouldThrowException() {
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		OAuth2ClientProperties.Registration registration = new OAuth2ClientProperties.Registration();
		properties.getRegistration().put('missing', registration);
		assertThatIllegalStateException()
			.isThrownBy(() -> new OAuth2ClientPropertiesMapper(properties).asClientRegistrations())
			.withMessageContaining('Provider ID must be specified for client registration "missing"');
	}
	@Test
	void oidcProviderConfigurationWhenProviderNotSpecifiedOnRegistration() throws Exception {
		Registration login = new OAuth2ClientProperties.Registration();
		login.setClientId('clientId');
		login.setClientSecret('clientSecret');
		testIssuerConfiguration(login, 'okta', 0, 1);
	}
	@Test
	void oidcProviderConfigurationWhenProviderSpecifiedOnRegistration() throws Exception {
		OAuth2ClientProperties.Registration login = new Registration();
		login.setProvider('okta-oidc');
		login.setClientId('clientId');
		login.setClientSecret('clientSecret');
		testIssuerConfiguration(login, 'okta-oidc', 0, 1);
	}
	@Test
	void issuerUriConfigurationTriesOidcRfc8414UriSecond() throws Exception {
		OAuth2ClientProperties.Registration login = new Registration();
		login.setClientId('clientId');
		login.setClientSecret('clientSecret');
		testIssuerConfiguration(login, 'okta', 1, 2);
	}
	@Test
	void issuerUriConfigurationTriesOAuthMetadataUriThird() throws Exception {
		OAuth2ClientProperties.Registration login = new Registration();
		login.setClientId('clientId');
		login.setClientSecret('clientSecret');
		testIssuerConfiguration(login, 'okta', 2, 3);
	}
	@Test
	void oidcProviderConfigurationWithCustomConfigurationOverridesProviderDefaults() throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String issuer = this.server.url('').toString();
		setupMockResponse(issuer);
		OAuth2ClientProperties.Registration registration = createRegistration('okta-oidc');
		Provider provider = createProvider();
		provider.setIssuerUri(issuer);
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		properties.getProvider().put('okta-oidc', provider);
		properties.getRegistration().put('okta', registration);
		Map<String, ClientRegistration> registrations = new OAuth2ClientPropertiesMapper(properties)
			.asClientRegistrations();
		ClientRegistration adapted = registrations.get('okta');
		ProviderDetails providerDetails = adapted.getProviderDetails();
		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo(ClientAuthenticationMethod.CLIENT_SECRET_POST);
		assertThat(adapted.getAuthorizationGrantType()).isEqualTo(AuthorizationGrantType.AUTHORIZATION_CODE);
		assertThat(adapted.getRegistrationId()).isEqualTo('okta');
		assertThat(adapted.getClientName()).isEqualTo(issuer);
		assertThat(adapted.getScopes()).containsOnly('user');
		assertThat(adapted.getRedirectUri()).isEqualTo('https://example.com/redirect');
		assertThat(providerDetails.getAuthorizationUri()).isEqualTo('https://example.com/auth');
		assertThat(providerDetails.getTokenUri()).isEqualTo('https://example.com/token');
		assertThat(providerDetails.getJwkSetUri()).isEqualTo('https://example.com/jwk');
		UserInfoEndpoint userInfoEndpoint = providerDetails.getUserInfoEndpoint();
		assertThat(userInfoEndpoint.getUri()).isEqualTo('https://example.com/info');
		assertThat(userInfoEndpoint.getUserNameAttributeName()).isEqualTo('sub');
	}
	private Provider createProvider() {
		Provider provider = new Provider();
		provider.setAuthorizationUri('https://example.com/auth');
		provider.setTokenUri('https://example.com/token');
		provider.setUserInfoUri('https://example.com/info');
		provider.setUserNameAttribute('sub');
		provider.setJwkSetUri('https://example.com/jwk');
		return provider;
	}
	private OAuth2ClientProperties.Registration createRegistration(String provider) {
		OAuth2ClientProperties.Registration registration = new OAuth2ClientProperties.Registration();
		registration.setProvider(provider);
		registration.setClientId('clientId');
		registration.setClientSecret('clientSecret');
		registration.setClientAuthenticationMethod('client_secret_post');
		registration.setRedirectUri('https://example.com/redirect');
		registration.setScope(Collections.singleton('user'));
		registration.setAuthorizationGrantType('authorization_code');
		return registration;
	}
	private void testIssuerConfiguration(OAuth2ClientProperties.Registration registration, String providerId,
			int errorResponseCount, int numberOfRequests) throws Exception {
		this.server = new MockWebServer();
		this.server.start();
		String issuer = this.server.url('').toString();
		setupMockResponsesWithErrors(issuer, errorResponseCount);
		OAuth2ClientProperties properties = new OAuth2ClientProperties();
		Provider provider = new Provider();
		provider.setIssuerUri(issuer);
		properties.getProvider().put(providerId, provider);
		properties.getRegistration().put('okta', registration);
		Map<String, ClientRegistration> registrations = new OAuth2ClientPropertiesMapper(properties)
			.asClientRegistrations();
		ClientRegistration adapted = registrations.get('okta');
		ProviderDetails providerDetails = adapted.getProviderDetails();
		assertThat(adapted.getClientAuthenticationMethod()).isEqualTo(ClientAuthenticationMethod.CLIENT_SECRET_BASIC);
		assertThat(adapted.getAuthorizationGrantType()).isEqualTo(AuthorizationGrantType.AUTHORIZATION_CODE);
		assertThat(adapted.getRegistrationId()).isEqualTo('okta');
		assertThat(adapted.getClientName()).isEqualTo(issuer);
		assertThat(adapted.getScopes()).isNull();
		assertThat(providerDetails.getAuthorizationUri()).isEqualTo('https://example.com/o/oauth2/v2/auth');
		assertThat(providerDetails.getTokenUri()).isEqualTo('https://example.com/oauth2/v4/token');
		assertThat(providerDetails.getJwkSetUri()).isEqualTo('https://example.com/oauth2/v3/certs');
		UserInfoEndpoint userInfoEndpoint = providerDetails.getUserInfoEndpoint();
		assertThat(userInfoEndpoint.getUri()).isEqualTo('https://example.com/oauth2/v3/userinfo');
		assertThat(userInfoEndpoint.getAuthenticationMethod())
			.isEqualTo(org.springframework.security.oauth2.core.AuthenticationMethod.HEADER);
		assertThat(this.server.getRequestCount()).isEqualTo(numberOfRequests);
	}
	private void setupMockResponse(String issuer) throws JsonProcessingException {
		MockResponse mockResponse = new MockResponse().setResponseCode(HttpStatus.OK.value())
			.setBody(new ObjectMapper().writeValueAsString(getResponse(issuer)))
			.setHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE);
		this.server.enqueue(mockResponse);
	}
	private void setupMockResponsesWithErrors(String issuer, int errorResponseCount) throws JsonProcessingException {
		for (int i = 0; i < errorResponseCount; i++) {
			MockResponse emptyResponse = new MockResponse().setResponseCode(HttpStatus.NOT_FOUND.value());
			this.server.enqueue(emptyResponse);
		}
		setupMockResponse(issuer);
	}
	private Map<String, Object> getResponse(String issuer) {
		Map<String, Object> response = new HashMap<>();
		response.put('authorization_endpoint', 'https://example.com/o/oauth2/v2/auth');
		response.put('claims_supported', Collections.emptyList());
		response.put('code_challenge_methods_supported', Collections.emptyList());
		response.put('id_token_signing_alg_values_supported', Collections.emptyList());
		response.put('issuer', issuer);
		response.put('jwks_uri', 'https://example.com/oauth2/v3/certs');
		response.put('response_types_supported', Collections.emptyList());
		response.put('revocation_endpoint', 'https://example.com/o/oauth2/revoke');
		response.put('scopes_supported', Collections.singletonList('openid'));
		response.put('subject_types_supported', Collections.singletonList('public'));
		response.put('grant_types_supported', Collections.singletonList('authorization_code'));
		response.put('token_endpoint', 'https://example.com/oauth2/v4/token');
		response.put('token_endpoint_auth_methods_supported', Collections.singletonList('client_secret_basic'));
		response.put('userinfo_endpoint', 'https://example.com/oauth2/v3/userinfo');
		return response;
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client;
/**
class OAuth2ClientPropertiesTests {
	private final OAuth2ClientProperties properties = new OAuth2ClientProperties();
	@Test
	void clientIdAbsentThrowsException() {
		OAuth2ClientProperties.Registration registration = new OAuth2ClientProperties.Registration();
		registration.setClientSecret('secret');
		registration.setProvider('google');
		this.properties.getRegistration().put('foo', registration);
		assertThatIllegalStateException().isThrownBy(this.properties::validate)
			.withMessageContaining('Client id of registration "foo" must not be empty.');
	}
	@Test
	void clientSecretAbsentShouldNotThrowException() {
		OAuth2ClientProperties.Registration registration = new OAuth2ClientProperties.Registration();
		registration.setClientId('foo');
		registration.setProvider('google');
		this.properties.getRegistration().put('foo', registration);
		this.properties.validate();
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.servlet;
/**
class OAuth2ClientRegistrationRepositoryConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	private static final String REGISTRATION_PREFIX = 'spring.security.oauth2.client.registration';
	@Test
	void clientRegistrationRepositoryBeanShouldNotBeCreatedWhenPropertiesAbsent() {
		this.contextRunner.withUserConfiguration(OAuth2ClientRegistrationRepositoryConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ClientRegistrationRepository.class));
	}
	@Test
	void clientRegistrationRepositoryBeanShouldBeCreatedWhenPropertiesPresent() {
		this.contextRunner.withUserConfiguration(OAuth2ClientRegistrationRepositoryConfiguration.class)
			.withPropertyValues(REGISTRATION_PREFIX + '.foo.client-id=abcd',
					REGISTRATION_PREFIX + '.foo.client-secret=secret', REGISTRATION_PREFIX + '.foo.provider=github')
			.run((context) -> {
				ClientRegistrationRepository repository = context.getBean(ClientRegistrationRepository.class);
				ClientRegistration registration = repository.findByRegistrationId('foo');
				assertThat(registration).isNotNull();
				assertThat(registration.getClientSecret()).isEqualTo('secret');
			});
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.servlet;
/**
class OAuth2WebSecurityConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner();
	@Test
	void securityConfigurerConfiguresOAuth2Login() {
		this.contextRunner
			.withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
					OAuth2WebSecurityConfiguration.class)
			.run((context) -> {
				ClientRegistrationRepository expected = context.getBean(ClientRegistrationRepository.class);
				ClientRegistrationRepository actual = (ClientRegistrationRepository) ReflectionTestUtils.getField(
						getSecurityFilters(context, OAuth2LoginAuthenticationFilter.class).get(0),
						'clientRegistrationRepository');
				assertThat(isEqual(expected.findByRegistrationId('first'), actual.findByRegistrationId('first')))
					.isTrue();
				assertThat(isEqual(expected.findByRegistrationId('second'), actual.findByRegistrationId('second')))
					.isTrue();
			});
	}
	@Test
	void securityConfigurerConfiguresAuthorizationCode() {
		this.contextRunner
			.withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
					OAuth2WebSecurityConfiguration.class)
			.run((context) -> {
				ClientRegistrationRepository expected = context.getBean(ClientRegistrationRepository.class);
				ClientRegistrationRepository actual = (ClientRegistrationRepository) ReflectionTestUtils.getField(
						getSecurityFilters(context, OAuth2AuthorizationCodeGrantFilter.class).get(0),
						'clientRegistrationRepository');
				assertThat(isEqual(expected.findByRegistrationId('first'), actual.findByRegistrationId('first')))
					.isTrue();
				assertThat(isEqual(expected.findByRegistrationId('second'), actual.findByRegistrationId('second')))
					.isTrue();
			});
	}
	@Test
	void securityConfigurerBacksOffWhenClientRegistrationBeanAbsent() {
		this.contextRunner.withUserConfiguration(TestConfig.class, OAuth2WebSecurityConfiguration.class)
			.run((context) -> {
				assertThat(getSecurityFilters(context, OAuth2LoginAuthenticationFilter.class)).isEmpty();
				assertThat(getSecurityFilters(context, OAuth2AuthorizationCodeGrantFilter.class)).isEmpty();
			});
	}
	@Test
	void configurationRegistersAuthorizedClientServiceBean() {
		this.contextRunner
			.withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
					OAuth2WebSecurityConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(OAuth2AuthorizedClientService.class));
	}
	@Test
	void configurationRegistersAuthorizedClientRepositoryBean() {
		this.contextRunner
			.withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
					OAuth2WebSecurityConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(OAuth2AuthorizedClientRepository.class));
	}
	@Test
	void securityFilterChainConfigBacksOffWhenOtherSecurityFilterChainBeanPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebMvcAutoConfiguration.class))
			.withUserConfiguration(TestSecurityFilterChainConfiguration.class, OAuth2WebSecurityConfiguration.class)
			.run((context) -> {
				assertThat(getSecurityFilters(context, OAuth2LoginAuthenticationFilter.class)).isEmpty();
				assertThat(getSecurityFilters(context, OAuth2AuthorizationCodeGrantFilter.class)).isEmpty();
				assertThat(context).getBean(OAuth2AuthorizedClientService.class).isNotNull();
			});
	}
	@Test
	void securityFilterChainConfigConditionalOnSecurityFilterChainClass() {
		this.contextRunner
			.withUserConfiguration(ClientRegistrationRepositoryConfiguration.class,
					OAuth2WebSecurityConfiguration.class)
			.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class))
			.run((context) -> {
				assertThat(getSecurityFilters(context, OAuth2LoginAuthenticationFilter.class)).isEmpty();
				assertThat(getSecurityFilters(context, OAuth2AuthorizationCodeGrantFilter.class)).isEmpty();
			});
	}
	@Test
	void authorizedClientServiceBeanIsConditionalOnMissingBean() {
		this.contextRunner
			.withUserConfiguration(OAuth2AuthorizedClientServiceConfiguration.class,
					OAuth2WebSecurityConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(OAuth2AuthorizedClientService.class);
				assertThat(context).hasBean('testAuthorizedClientService');
			});
	}
	@Test
	void authorizedClientRepositoryBeanIsConditionalOnMissingBean() {
		this.contextRunner
			.withUserConfiguration(OAuth2AuthorizedClientRepositoryConfiguration.class,
					OAuth2WebSecurityConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(OAuth2AuthorizedClientRepository.class);
				assertThat(context).hasBean('testAuthorizedClientRepository');
			});
	}
	private List<Filter> getSecurityFilters(AssertableWebApplicationContext context, Class<? extends Filter> filter) {
		return getSecurityFilterChain(context).getFilters().stream().filter(filter::isInstance).toList();
	}
	private SecurityFilterChain getSecurityFilterChain(AssertableWebApplicationContext context) {
		Filter springSecurityFilterChain = context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class);
		FilterChainProxy filterChainProxy = getFilterChainProxy(springSecurityFilterChain);
		SecurityFilterChain securityFilterChain = filterChainProxy.getFilterChains().get(0);
		return securityFilterChain;
	}
	private FilterChainProxy getFilterChainProxy(Filter filter) {
		if (filter instanceof FilterChainProxy filterChainProxy) {
			return filterChainProxy;
		}
		if (filter instanceof CompositeFilter) {
			List<?> filters = (List<?>) ReflectionTestUtils.getField(filter, 'filters');
			return (FilterChainProxy) filters.stream()
				.filter(FilterChainProxy.class::isInstance)
				.findFirst()
				.orElseThrow();
		}
		throw new IllegalStateException('No FilterChainProxy found');
	}
	private boolean isEqual(ClientRegistration reg1, ClientRegistration reg2) {
		boolean result = ObjectUtils.nullSafeEquals(reg1.getClientId(), reg2.getClientId());
		result = result && ObjectUtils.nullSafeEquals(reg1.getClientName(), reg2.getClientName());
		result = result && ObjectUtils.nullSafeEquals(reg1.getClientSecret(), reg2.getClientSecret());
		result = result && ObjectUtils.nullSafeEquals(reg1.getScopes(), reg2.getScopes());
		result = result && ObjectUtils.nullSafeEquals(reg1.getRedirectUri(), reg2.getRedirectUri());
		result = result && ObjectUtils.nullSafeEquals(reg1.getRegistrationId(), reg2.getRegistrationId());
		result = result
				&& ObjectUtils.nullSafeEquals(reg1.getAuthorizationGrantType(), reg2.getAuthorizationGrantType());
		result = result && ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getAuthorizationUri(),
				reg2.getProviderDetails().getAuthorizationUri());
		result = result && ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getUserInfoEndpoint(),
				reg2.getProviderDetails().getUserInfoEndpoint());
		result = result && ObjectUtils.nullSafeEquals(reg1.getProviderDetails().getTokenUri(),
				reg2.getProviderDetails().getTokenUri());
		return result;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSecurity
	static class TestConfig {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestConfig.class)
	static class ClientRegistrationRepositoryConfiguration {
		@Bean
		ClientRegistrationRepository clientRegistrationRepository() {
			List<ClientRegistration> registrations = new ArrayList<>();
			registrations.add(getClientRegistration('first', 'https://user-info-uri.com'));
			registrations.add(getClientRegistration('second', 'https://other-user-info'));
			return new InMemoryClientRegistrationRepository(registrations);
		}
		private ClientRegistration getClientRegistration(String id, String userInfoUri) {
			ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(id);
			builder.clientName('foo')
				.clientId('foo')
				.clientAuthenticationMethod(
						org.springframework.security.oauth2.core.ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
				.scope('read')
				.clientSecret('secret')
				.redirectUri('https://redirect-uri.com')
				.authorizationUri('https://authorization-uri.com')
				.tokenUri('https://token-uri.com')
				.userInfoUri(userInfoUri)
				.userNameAttributeName('login');
			return builder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ClientRegistrationRepositoryConfiguration.class)
	static class TestSecurityFilterChainConfiguration {
		@Bean
		SecurityFilterChain testSecurityFilterChain(HttpSecurity http) throws Exception {
			return http.securityMatcher('/**')
				.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated())
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ClientRegistrationRepositoryConfiguration.class)
	static class OAuth2AuthorizedClientServiceConfiguration {
		@Bean
		OAuth2AuthorizedClientService testAuthorizedClientService(
				ClientRegistrationRepository clientRegistrationRepository) {
			return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ClientRegistrationRepositoryConfiguration.class)
	static class OAuth2AuthorizedClientRepositoryConfiguration {
		@Bean
		OAuth2AuthorizedClientRepository testAuthorizedClientRepository(
				OAuth2AuthorizedClientService authorizedClientService) {
			return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.reactive;
/**
class ReactiveOAuth2ClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactiveOAuth2ClientAutoConfiguration.class,
				ReactiveSecurityAutoConfiguration.class));
	private static final String REGISTRATION_PREFIX = 'spring.security.oauth2.client.registration';
	@Test
	void autoConfigurationShouldBackOffForServletEnvironments() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(ReactiveOAuth2ClientAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveOAuth2ClientAutoConfiguration.class));
	}
	@Test
	void clientRegistrationRepositoryBeanShouldNotBeCreatedWhenPropertiesAbsent() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ClientRegistrationRepository.class));
	}
	@Test
	void clientRegistrationRepositoryBeanShouldBeCreatedWhenPropertiesPresent() {
		this.contextRunner
			.withPropertyValues(REGISTRATION_PREFIX + '.foo.client-id=abcd',
					REGISTRATION_PREFIX + '.foo.client-secret=secret', REGISTRATION_PREFIX + '.foo.provider=github')
			.run((context) -> {
				ReactiveClientRegistrationRepository repository = context
					.getBean(ReactiveClientRegistrationRepository.class);
				ClientRegistration registration = repository.findByRegistrationId('foo').block(Duration.ofSeconds(30));
				assertThat(registration).isNotNull();
				assertThat(registration.getClientSecret()).isEqualTo('secret');
			});
	}
	@Test
	void authorizedClientServiceAndRepositoryBeansAreConditionalOnClientRegistrationRepository() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(ReactiveOAuth2AuthorizedClientService.class);
			assertThat(context).doesNotHaveBean(ServerOAuth2AuthorizedClientRepository.class);
		});
	}
	@Test
	void configurationRegistersAuthorizedClientServiceAndRepositoryBeans() {
		this.contextRunner.withUserConfiguration(ReactiveClientRepositoryConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(InMemoryReactiveOAuth2AuthorizedClientService.class);
			assertThat(context).hasSingleBean(AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository.class);
		});
	}
	@Test
	void authorizedClientServiceBeanIsConditionalOnMissingBean() {
		this.contextRunner.withUserConfiguration(ReactiveOAuth2AuthorizedClientRepositoryConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveOAuth2AuthorizedClientService.class);
				assertThat(context).hasBean('testAuthorizedClientService');
			});
	}
	@Test
	void authorizedClientRepositoryBeanIsConditionalOnAuthorizedClientService() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(ServerOAuth2AuthorizedClientRepository.class));
	}
	@Test
	void configurationRegistersAuthorizedClientRepositoryBean() {
		this.contextRunner.withUserConfiguration(ReactiveOAuth2AuthorizedClientServiceConfiguration.class)
			.run((context) -> assertThat(context)
				.hasSingleBean(AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository.class));
	}
	@Test
	void authorizedClientRepositoryBeanIsConditionalOnMissingBean() {
		this.contextRunner.withUserConfiguration(ReactiveOAuth2AuthorizedClientRepositoryConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ServerOAuth2AuthorizedClientRepository.class);
				assertThat(context).hasBean('testAuthorizedClientRepository');
			});
	}
	@Test
	void securityWebFilterChainBeanConditionalOnWebApplication() {
		this.contextRunner.withUserConfiguration(ReactiveOAuth2AuthorizedClientRepositoryConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(SecurityWebFilterChain.class));
	}
	@Test
	void configurationRegistersSecurityWebFilterChainBean() { // gh-17949
		new ReactiveWebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(ReactiveOAuth2ClientAutoConfiguration.class))
			.withUserConfiguration(ReactiveOAuth2AuthorizedClientServiceConfiguration.class,
					ServerHttpSecurityConfiguration.class)
			.run((context) -> {
				assertThat(hasFilter(context, OAuth2LoginAuthenticationWebFilter.class)).isTrue();
				assertThat(hasFilter(context, OAuth2AuthorizationCodeGrantWebFilter.class)).isTrue();
			});
	}
	@Test
	void autoConfigurationConditionalOnClassFlux() {
		assertWhenClassNotPresent(Flux.class);
	}
	@Test
	void autoConfigurationConditionalOnClassEnableWebFluxSecurity() {
		assertWhenClassNotPresent(EnableWebFluxSecurity.class);
	}
	@Test
	void autoConfigurationConditionalOnClassClientRegistration() {
		assertWhenClassNotPresent(ClientRegistration.class);
	}
	private void assertWhenClassNotPresent(Class<?> classToFilter) {
		FilteredClassLoader classLoader = new FilteredClassLoader(classToFilter);
		this.contextRunner.withClassLoader(classLoader)
			.withPropertyValues(REGISTRATION_PREFIX + '.foo.client-id=abcd',
					REGISTRATION_PREFIX + '.foo.client-secret=secret', REGISTRATION_PREFIX + '.foo.provider=github')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveOAuth2ClientAutoConfiguration.class));
	}
	@SuppressWarnings('unchecked')
	private boolean hasFilter(AssertableReactiveWebApplicationContext context, Class<? extends WebFilter> filter) {
		SecurityWebFilterChain filterChain = (SecurityWebFilterChain) context
			.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN);
		List<WebFilter> filters = (List<WebFilter>) ReflectionTestUtils.getField(filterChain, 'filters');
		return filters.stream().anyMatch(filter::isInstance);
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveClientRepositoryConfiguration {
		@Bean
		ReactiveClientRegistrationRepository clientRegistrationRepository() {
			List<ClientRegistration> registrations = new ArrayList<>();
			registrations.add(getClientRegistration('first', 'https://user-info-uri.com'));
			registrations.add(getClientRegistration('second', 'https://other-user-info'));
			return new InMemoryReactiveClientRegistrationRepository(registrations);
		}
		private ClientRegistration getClientRegistration(String id, String userInfoUri) {
			ClientRegistration.Builder builder = ClientRegistration.withRegistrationId(id);
			builder.clientName('foo')
				.clientId('foo')
				.clientAuthenticationMethod(
						org.springframework.security.oauth2.core.ClientAuthenticationMethod.CLIENT_SECRET_BASIC)
				.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
				.scope('read')
				.clientSecret('secret')
				.redirectUri('https://redirect-uri.com')
				.authorizationUri('https://authorization-uri.com')
				.tokenUri('https://token-uri.com')
				.userInfoUri(userInfoUri)
				.userNameAttributeName('login');
			return builder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ReactiveClientRepositoryConfiguration.class)
	static class ReactiveOAuth2AuthorizedClientServiceConfiguration {
		@Bean
		ReactiveOAuth2AuthorizedClientService testAuthorizedClientService(
				ReactiveClientRegistrationRepository clientRegistrationRepository) {
			return new InMemoryReactiveOAuth2AuthorizedClientService(clientRegistrationRepository);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(ReactiveOAuth2AuthorizedClientServiceConfiguration.class)
	static class ReactiveOAuth2AuthorizedClientRepositoryConfiguration {
		@Bean
		ServerOAuth2AuthorizedClientRepository testAuthorizedClientRepository(
				ReactiveOAuth2AuthorizedClientService authorizedClientService) {
			return new AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository(authorizedClientService);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ServerHttpSecurityConfiguration {
		@Bean
		ServerHttpSecurity http() {
			TestServerHttpSecurity httpSecurity = new TestServerHttpSecurity();
			return httpSecurity;
		}
		static class TestServerHttpSecurity extends ServerHttpSecurity implements ApplicationContextAware {
			@Override
			public void setApplicationContext(ApplicationContext applicationContext) {
				super.setApplicationContext(applicationContext);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.user;
@Entity
public class User {
	@Id
	@GeneratedValue
	private Long id;
	private String email;
	public User() {
	}
	public User(String email) {
		this.email = email;
	}
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getEmail() {
		return this.email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	@Override
	public String toString() {
		return getClass().getSimpleName() + ':' + this.id;
	}
}
/*
package org.springframework.boot.autoconfigure.security.user;
interface UserRepository extends JpaRepository<User, Integer> {
	User findByEmail(String email);
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
class SecurityAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(SecurityAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class));
	@Test
	void testWebConfiguration() {
		this.contextRunner.run((context) -> {
			assertThat(context.getBean(AuthenticationManagerBuilder.class)).isNotNull();
			assertThat(context.getBean(FilterChainProxy.class).getFilterChains()).hasSize(1);
		});
	}
	@Test
	void enableWebSecurityIsConditionalOnClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.springframework.security.config'))
			.run((context) -> assertThat(context).doesNotHaveBean('springSecurityFilterChain'));
	}
	@Test
	void filterChainBeanIsConditionalOnClassSecurityFilterChain() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class))
			.run((context) -> assertThat(context).doesNotHaveBean(SecurityFilterChain.class));
	}
	@Test
	void securityConfigurerBacksOffWhenOtherSecurityFilterChainBeanPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebMvcAutoConfiguration.class))
			.withUserConfiguration(TestSecurityFilterChainConfig.class)
			.run((context) -> {
				assertThat(context.getBeansOfType(SecurityFilterChain.class)).hasSize(1);
				assertThat(context.containsBean('testSecurityFilterChain')).isTrue();
			});
	}
	@Test
	void testFilterIsNotRegisteredInNonWeb() {
		try (AnnotationConfigApplicationContext customContext = new AnnotationConfigApplicationContext()) {
			customContext.register(SecurityAutoConfiguration.class, SecurityFilterAutoConfiguration.class,
					PropertyPlaceholderAutoConfiguration.class);
			customContext.refresh();
			assertThat(customContext.containsBean('securityFilterChainRegistration')).isFalse();
		}
	}
	@Test
	void defaultAuthenticationEventPublisherRegistered() {
		this.contextRunner.run((context) -> assertThat(context.getBean(AuthenticationEventPublisher.class))
			.isInstanceOf(DefaultAuthenticationEventPublisher.class));
	}
	@Test
	void defaultAuthenticationEventPublisherIsConditionalOnMissingBean() {
		this.contextRunner.withUserConfiguration(AuthenticationEventPublisherConfiguration.class)
			.run((context) -> assertThat(context.getBean(AuthenticationEventPublisher.class))
				.isInstanceOf(AuthenticationEventPublisherConfiguration.TestAuthenticationEventPublisher.class));
	}
	@Test
	void testDefaultFilterOrder() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class))
			.run((context) -> assertThat(
					context.getBean('securityFilterChainRegistration', DelegatingFilterProxyRegistrationBean.class)
						.getOrder())
				.isEqualTo(OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER - 100));
	}
	@Test
	void testCustomFilterOrder() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class))
			.withPropertyValues('spring.security.filter.order:12345')
			.run((context) -> assertThat(
					context.getBean('securityFilterChainRegistration', DelegatingFilterProxyRegistrationBean.class)
						.getOrder())
				.isEqualTo(12345));
	}
	@Test
	void testJpaCoexistsHappily() {
		this.contextRunner.withPropertyValues('spring.datasource.url:jdbc:hsqldb:mem:testsecdb')
			.withUserConfiguration(EntityConfiguration.class)
			.withConfiguration(
					AutoConfigurations.of(HibernateJpaAutoConfiguration.class, DataSourceAutoConfiguration.class))
			.run((context) -> assertThat(context.getBean(JpaTransactionManager.class)).isNotNull());
		// This can fail if security @Conditionals force early instantiation of the
		// HibernateJpaAutoConfiguration (e.g. the EntityManagerFactory is not found)
	}
	@Test
	void testSecurityEvaluationContextExtensionSupport() {
		this.contextRunner
			.run((context) -> assertThat(context).getBean(SecurityEvaluationContextExtension.class).isNotNull());
	}
	@Test
	void defaultFilterDispatcherTypes() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class))
			.run((context) -> {
				DelegatingFilterProxyRegistrationBean bean = context.getBean('securityFilterChainRegistration',
						DelegatingFilterProxyRegistrationBean.class);
				assertThat(bean).extracting('dispatcherTypes', InstanceOfAssertFactories.iterable(DispatcherType.class))
					.containsExactlyInAnyOrderElementsOf(EnumSet.allOf(DispatcherType.class));
			});
	}
	@Test
	void customFilterDispatcherTypes() {
		this.contextRunner.withPropertyValues('spring.security.filter.dispatcher-types:INCLUDE,ERROR')
			.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class))
			.run((context) -> {
				DelegatingFilterProxyRegistrationBean bean = context.getBean('securityFilterChainRegistration',
						DelegatingFilterProxyRegistrationBean.class);
				assertThat(bean).extracting('dispatcherTypes', InstanceOfAssertFactories.iterable(DispatcherType.class))
					.containsOnly(DispatcherType.INCLUDE, DispatcherType.ERROR);
			});
	}
	@Test
	void emptyFilterDispatcherTypesDoNotThrowException() {
		this.contextRunner.withPropertyValues('spring.security.filter.dispatcher-types:')
			.withConfiguration(AutoConfigurations.of(SecurityFilterAutoConfiguration.class))
			.run((context) -> {
				DelegatingFilterProxyRegistrationBean bean = context.getBean('securityFilterChainRegistration',
						DelegatingFilterProxyRegistrationBean.class);
				assertThat(bean).extracting('dispatcherTypes', InstanceOfAssertFactories.iterable(DispatcherType.class))
					.isEmpty();
			});
	}
	@Test
	void whenAConfigurationPropertyBindingConverterIsDefinedThenBindingToAnRsaKeySucceeds() {
		this.contextRunner.withUserConfiguration(ConverterConfiguration.class, PropertiesConfiguration.class)
			.withPropertyValues('jwt.public-key=classpath:public-key-location')
			.run((context) -> assertThat(context.getBean(JwtProperties.class).getPublicKey()).isNotNull());
	}
	@Test
	void whenTheBeanFactoryHasAConversionServiceAndAConfigurationPropertyBindingConverterIsDefinedThenBindingToAnRsaKeySucceeds() {
		this.contextRunner
			.withInitializer(
					(context) -> context.getBeanFactory().setConversionService(new ApplicationConversionService()))
			.withUserConfiguration(ConverterConfiguration.class, PropertiesConfiguration.class)
			.withPropertyValues('jwt.public-key=classpath:public-key-location')
			.run((context) -> assertThat(context.getBean(JwtProperties.class).getPublicKey()).isNotNull());
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class EntityConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class AuthenticationEventPublisherConfiguration {
		@Bean
		AuthenticationEventPublisher authenticationEventPublisher() {
			return new TestAuthenticationEventPublisher();
		}
		class TestAuthenticationEventPublisher implements AuthenticationEventPublisher {
			@Override
			public void publishAuthenticationSuccess(Authentication authentication) {
			}
			@Override
			public void publishAuthenticationFailure(AuthenticationException exception, Authentication authentication) {
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestSecurityFilterChainConfig {
		@Bean
		SecurityFilterChain testSecurityFilterChain(HttpSecurity http) throws Exception {
			return http.securityMatcher('/**')
				.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated())
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConverterConfiguration {
		@Bean
		@ConfigurationPropertiesBinding
		Converter<String, TargetType> targetTypeConverter() {
			return new Converter<>() {
				@Override
				public TargetType convert(String input) {
					return new TargetType();
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(JwtProperties.class)
	static class PropertiesConfiguration {
	}
	@ConfigurationProperties('jwt')
	static class JwtProperties {
		private RSAPublicKey publicKey;
		RSAPublicKey getPublicKey() {
			return this.publicKey;
		}
		void setPublicKey(RSAPublicKey publicKey) {
			this.publicKey = publicKey;
		}
	}
	static class TargetType {
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
class PathRequestTests {
	@Test
	void toStaticResourcesShouldReturnStaticResourceRequest() {
		assertThat(PathRequest.toStaticResources()).isInstanceOf(StaticResourceRequest.class);
	}
	@Test
	void toH2ConsoleShouldMatchH2ConsolePath() {
		RequestMatcher matcher = PathRequest.toH2Console();
		assertMatcher(matcher).matches('/h2-console');
		assertMatcher(matcher).matches('/h2-console/subpath');
		assertMatcher(matcher).doesNotMatch('/js/file.js');
	}
	@Test
	void toH2ConsoleWhenManagementContextShouldNeverMatch() {
		RequestMatcher matcher = PathRequest.toH2Console();
		assertMatcher(matcher, 'management').doesNotMatch('/h2-console');
		assertMatcher(matcher, 'management').doesNotMatch('/h2-console/subpath');
		assertMatcher(matcher, 'management').doesNotMatch('/js/file.js');
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher) {
		return assertMatcher(matcher, null);
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String serverNamespace) {
		TestWebApplicationContext context = new TestWebApplicationContext(serverNamespace);
		context.registerBean(ServerProperties.class);
		context.registerBean(H2ConsoleProperties.class);
		return assertThat(new RequestMatcherAssert(context, matcher));
	}
	static class RequestMatcherAssert implements AssertDelegateTarget {
		private final WebApplicationContext context;
		private final RequestMatcher matcher;
		RequestMatcherAssert(WebApplicationContext context, RequestMatcher matcher) {
			this.context = context;
			this.matcher = matcher;
		}
		void matches(String path) {
			matches(mockRequest(path));
		}
		private void matches(HttpServletRequest request) {
			assertThat(this.matcher.matches(request)).as('Matches ' + getRequestPath(request)).isTrue();
		}
		void doesNotMatch(String path) {
			doesNotMatch(mockRequest(path));
		}
		private void doesNotMatch(HttpServletRequest request) {
			assertThat(this.matcher.matches(request)).as('Does not match ' + getRequestPath(request)).isFalse();
		}
		private MockHttpServletRequest mockRequest(String path) {
			MockServletContext servletContext = new MockServletContext();
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
			MockHttpServletRequest request = new MockHttpServletRequest(servletContext);
			request.setPathInfo(path);
			return request;
		}
		private String getRequestPath(HttpServletRequest request) {
			String url = request.getServletPath();
			if (request.getPathInfo() != null) {
				url += request.getPathInfo();
			}
			return url;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
@ExtendWith(OutputCaptureExtension.class)
class UserDetailsServiceAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(TestSecurityConfiguration.class)
		.withConfiguration(AutoConfigurations.of(UserDetailsServiceAutoConfiguration.class));
	@Test
	void testDefaultUsernamePassword(CapturedOutput output) {
		this.contextRunner.with(noOtherFormsOfAuthenticationOnTheClasspath()).run((context) -> {
			UserDetailsService manager = context.getBean(UserDetailsService.class);
			assertThat(output).contains('Using generated security password:');
			assertThat(manager.loadUserByUsername('user')).isNotNull();
		});
	}
	@Test
	void defaultUserNotCreatedIfAuthenticationManagerBeanPresent(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestAuthenticationManagerConfiguration.class).run((context) -> {
			AuthenticationManager manager = context.getBean(AuthenticationManager.class);
			assertThat(manager)
				.isEqualTo(context.getBean(TestAuthenticationManagerConfiguration.class).authenticationManager);
			assertThat(output).doesNotContain('Using generated security password: ');
			TestingAuthenticationToken token = new TestingAuthenticationToken('foo', 'bar');
			assertThat(manager.authenticate(token)).isNotNull();
		});
	}
	@Test
	void defaultUserNotCreatedIfAuthenticationManagerResolverBeanPresent(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestAuthenticationManagerResolverConfiguration.class)
			.run((context) -> assertThat(output).doesNotContain('Using generated security password: '));
	}
	@Test
	void defaultUserNotCreatedIfUserDetailsServiceBeanPresent(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestUserDetailsServiceConfiguration.class).run((context) -> {
			UserDetailsService userDetailsService = context.getBean(UserDetailsService.class);
			assertThat(output).doesNotContain('Using generated security password: ');
			assertThat(userDetailsService.loadUserByUsername('foo')).isNotNull();
		});
	}
	@Test
	void defaultUserNotCreatedIfAuthenticationProviderBeanPresent(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestAuthenticationProviderConfiguration.class).run((context) -> {
			AuthenticationProvider provider = context.getBean(AuthenticationProvider.class);
			assertThat(output).doesNotContain('Using generated security password: ');
			TestingAuthenticationToken token = new TestingAuthenticationToken('foo', 'bar');
			assertThat(provider.authenticate(token)).isNotNull();
		});
	}
	@Test
	void defaultUserNotCreatedIfResourceServerWithOpaqueIsUsed() {
		this.contextRunner.withUserConfiguration(TestConfigWithIntrospectionClient.class).run((context) -> {
			assertThat(context).hasSingleBean(OpaqueTokenIntrospector.class);
			assertThat(context).doesNotHaveBean(UserDetailsService.class);
		});
	}
	@Test
	void defaultUserNotCreatedIfResourceServerWithJWTIsUsed() {
		this.contextRunner.withUserConfiguration(TestConfigWithJwtDecoder.class).run((context) -> {
			assertThat(context).hasSingleBean(JwtDecoder.class);
			assertThat(context).doesNotHaveBean(UserDetailsService.class);
		});
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderAbsentAndDefaultPassword() {
		this.contextRunner.with(noOtherFormsOfAuthenticationOnTheClasspath())
			.withUserConfiguration(TestSecurityConfiguration.class)
			.run(((context) -> {
				InMemoryUserDetailsManager userDetailsService = context.getBean(InMemoryUserDetailsManager.class);
				String password = userDetailsService.loadUserByUsername('user').getPassword();
				assertThat(password).startsWith('{noop}');
			}));
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderAbsentAndRawPassword() {
		testPasswordEncoding(TestSecurityConfiguration.class, 'secret', '{noop}secret');
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderAbsentAndEncodedPassword() {
		String password = '{bcrypt}$2a$10$sCBi9fy9814vUPf2ZRbtp.fR5/VgRk2iBFZ.ypu5IyZ28bZgxrVDa';
		testPasswordEncoding(TestSecurityConfiguration.class, password, password);
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderBeanPresent() {
		testPasswordEncoding(TestConfigWithPasswordEncoder.class, 'secret', 'secret');
	}
	@Test
	void userDetailsServiceWhenClientRegistrationRepositoryPresent() {
		this.contextRunner
			.withClassLoader(
					new FilteredClassLoader(OpaqueTokenIntrospector.class, RelyingPartyRegistrationRepository.class))
			.run(((context) -> assertThat(context).doesNotHaveBean(InMemoryUserDetailsManager.class)));
	}
	@Test
	void userDetailsServiceWhenOpaqueTokenIntrospectorPresent() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader(ClientRegistrationRepository.class,
					RelyingPartyRegistrationRepository.class))
			.run(((context) -> assertThat(context).doesNotHaveBean(InMemoryUserDetailsManager.class)));
	}
	@Test
	void userDetailsServiceWhenRelyingPartyRegistrationRepositoryPresent() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader(ClientRegistrationRepository.class, OpaqueTokenIntrospector.class))
			.run(((context) -> assertThat(context).doesNotHaveBean(InMemoryUserDetailsManager.class)));
	}
	@Test
	void userDetailsServiceWhenRelyingPartyRegistrationRepositoryPresentAndUsernameConfigured() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader(ClientRegistrationRepository.class, OpaqueTokenIntrospector.class))
			.withPropertyValues('spring.security.user.name=alice')
			.run(((context) -> assertThat(context).hasSingleBean(InMemoryUserDetailsManager.class)));
	}
	@Test
	void userDetailsServiceWhenRelyingPartyRegistrationRepositoryPresentAndPasswordConfigured() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader(ClientRegistrationRepository.class, OpaqueTokenIntrospector.class))
			.withPropertyValues('spring.security.user.password=secret')
			.run(((context) -> assertThat(context).hasSingleBean(InMemoryUserDetailsManager.class)));
	}
	private Function<ApplicationContextRunner, ApplicationContextRunner> noOtherFormsOfAuthenticationOnTheClasspath() {
		return (contextRunner) -> contextRunner
			.withClassLoader(new FilteredClassLoader(ClientRegistrationRepository.class, OpaqueTokenIntrospector.class,
					RelyingPartyRegistrationRepository.class));
	}
	private void testPasswordEncoding(Class<?> configClass, String providedPassword, String expectedPassword) {
		this.contextRunner.with(noOtherFormsOfAuthenticationOnTheClasspath())
			.withClassLoader(new FilteredClassLoader(ClientRegistrationRepository.class, OpaqueTokenIntrospector.class,
					RelyingPartyRegistrationRepository.class))
			.withUserConfiguration(configClass)
			.withPropertyValues('spring.security.user.password=' + providedPassword)
			.run(((context) -> {
				InMemoryUserDetailsManager userDetailsService = context.getBean(InMemoryUserDetailsManager.class);
				String password = userDetailsService.loadUserByUsername('user').getPassword();
				assertThat(password).isEqualTo(expectedPassword);
			}));
	}
	@Configuration(proxyBeanMethods = false)
	static class TestAuthenticationManagerConfiguration {
		private AuthenticationManager authenticationManager;
		@Bean
		AuthenticationManager myAuthenticationManager() {
			AuthenticationProvider authenticationProvider = new TestingAuthenticationProvider();
			this.authenticationManager = new ProviderManager(Collections.singletonList(authenticationProvider));
			return this.authenticationManager;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestUserDetailsServiceConfiguration {
		@Bean
		InMemoryUserDetailsManager myUserDetailsManager() {
			return new InMemoryUserDetailsManager(User.withUsername('foo').password('bar').roles('USER').build());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestAuthenticationProviderConfiguration {
		@Bean
		AuthenticationProvider myAuthenticationProvider() {
			return new TestingAuthenticationProvider();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSecurity
	@EnableConfigurationProperties(SecurityProperties.class)
	static class TestSecurityConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestSecurityConfiguration.class)
	static class TestConfigWithPasswordEncoder {
		@Bean
		PasswordEncoder passwordEncoder() {
			return mock(PasswordEncoder.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestSecurityConfiguration.class)
	static class TestConfigWithClientRegistrationRepository {
		@Bean
		ClientRegistrationRepository clientRegistrationRepository() {
			return mock(ClientRegistrationRepository.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestSecurityConfiguration.class)
	static class TestConfigWithJwtDecoder {
		@Bean
		JwtDecoder jwtDecoder() {
			return mock(JwtDecoder.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestSecurityConfiguration.class)
	static class TestConfigWithIntrospectionClient {
		@Bean
		OpaqueTokenIntrospector introspectionClient() {
			return mock(OpaqueTokenIntrospector.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestAuthenticationManagerResolverConfiguration {
		@Bean
		AuthenticationManagerResolver<?> authenticationManagerResolver() {
			return mock(AuthenticationManagerResolver.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
class SecurityFilterAutoConfigurationTests {
	@Test
	void filterAutoConfigurationWorksWithoutSecurityAutoConfiguration() {
		try (AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext()) {
			context.setServletContext(new MockServletContext());
			context.register(Config.class);
			context.refresh();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ DeserializerBean.class, JacksonModuleBean.class, ExampleController.class, ConverterBean.class })
	@ImportAutoConfiguration({ WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,
			HttpMessageConvertersAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			SecurityFilterAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	static class Config {
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
@ExtendWith(OutputCaptureExtension.class)
class SecurityFilterAutoConfigurationEarlyInitializationTests {
	private static final Pattern PASSWORD_PATTERN = Pattern.compile('^Using generated security password: (.*)$',
			Pattern.MULTILINE);
	@Test
	@DirtiesUrlFactories
	@ClassPathExclusions({ 'spring-security-oauth2-client-*.jar', 'spring-security-oauth2-resource-server-*.jar',
			'spring-security-saml2-service-provider-*.jar' })
	void testSecurityFilterDoesNotCauseEarlyInitialization(CapturedOutput output) {
		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext()) {
			TestPropertyValues.of('server.port:0').applyTo(context);
			context.register(Config.class);
			context.refresh();
			int port = context.getWebServer().getPort();
			Matcher password = PASSWORD_PATTERN.matcher(output);
			assertThat(password.find()).isTrue();
			new TestRestTemplate('user', password.group(1)).getForEntity('http://localhost:' + port, Object.class);
			// If early initialization occurred a ConverterNotFoundException is thrown
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ DeserializerBean.class, JacksonModuleBean.class, ExampleController.class, ConverterBean.class })
	@ImportAutoConfiguration({ WebMvcAutoConfiguration.class, JacksonAutoConfiguration.class,
			HttpMessageConvertersAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			SecurityAutoConfiguration.class, UserDetailsServiceAutoConfiguration.class,
			SecurityFilterAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	static class Config {
		@Bean
		TomcatServletWebServerFactory webServerFactory() {
			TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
			factory.setPort(0);
			return factory;
		}
	}
	static class SourceType {
		public String foo;
	}
	static class DestinationType {
		public String bar;
	}
	@Component
	static class JacksonModuleBean extends SimpleModule {
		private static final long serialVersionUID = 1L;
		JacksonModuleBean(DeserializerBean myDeser) {
			addDeserializer(SourceType.class, myDeser);
		}
	}
	@Component
	static class DeserializerBean extends StdDeserializer<SourceType> {
		@Autowired
		ConversionService conversionService;
		DeserializerBean() {
			super(SourceType.class);
		}
		@Override
		public SourceType deserialize(JsonParser p, DeserializationContext ctxt) {
			return new SourceType();
		}
	}
	@RestController
	static class ExampleController {
		@Autowired
		private ConversionService conversionService;
		@RequestMapping('/')
		void convert() {
			this.conversionService.convert(new SourceType(), DestinationType.class);
		}
	}
	@Component
	static class ConverterBean implements Converter<SourceType, DestinationType> {
		@Override
		public DestinationType convert(SourceType source) {
			return new DestinationType();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
class TestWebApplicationContext extends StaticWebApplicationContext implements WebServerApplicationContext {
	private final String serverNamespace;
	TestWebApplicationContext(String serverNamespace) {
		this.serverNamespace = serverNamespace;
	}
	@Override
	public WebServer getWebServer() {
		return null;
	}
	@Override
	public String getServerNamespace() {
		return this.serverNamespace;
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
class StaticResourceRequestTests {
	private final StaticResourceRequest resourceRequest = StaticResourceRequest.INSTANCE;
	@Test
	void atCommonLocationsShouldMatchCommonLocations() {
		RequestMatcher matcher = this.resourceRequest.atCommonLocations();
		assertMatcher(matcher).matches('/css/file.css');
		assertMatcher(matcher).matches('/js/file.js');
		assertMatcher(matcher).matches('/images/file.css');
		assertMatcher(matcher).matches('/webjars/file.css');
		assertMatcher(matcher).matches('/favicon.ico');
		assertMatcher(matcher).matches('/favicon.png');
		assertMatcher(matcher).matches('/icons/icon-48x48.png');
		assertMatcher(matcher).doesNotMatch('/bar');
	}
	@Test
	void atCommonLocationsWhenManagementContextShouldNeverMatch() {
		RequestMatcher matcher = this.resourceRequest.atCommonLocations();
		assertMatcher(matcher, 'management').doesNotMatch('/css/file.css');
		assertMatcher(matcher, 'management').doesNotMatch('/js/file.js');
		assertMatcher(matcher, 'management').doesNotMatch('/images/file.css');
		assertMatcher(matcher, 'management').doesNotMatch('/webjars/file.css');
		assertMatcher(matcher, 'management').doesNotMatch('/foo/favicon.ico');
	}
	@Test
	void atCommonLocationsWithExcludeShouldNotMatchExcluded() {
		RequestMatcher matcher = this.resourceRequest.atCommonLocations().excluding(StaticResourceLocation.CSS);
		assertMatcher(matcher).doesNotMatch('/css/file.css');
		assertMatcher(matcher).matches('/js/file.js');
	}
	@Test
	void atLocationShouldMatchLocation() {
		RequestMatcher matcher = this.resourceRequest.at(StaticResourceLocation.CSS);
		assertMatcher(matcher).matches('/css/file.css');
		assertMatcher(matcher).doesNotMatch('/js/file.js');
	}
	@Test
	void atLocationWhenHasServletPathShouldMatchLocation() {
		RequestMatcher matcher = this.resourceRequest.at(StaticResourceLocation.CSS);
		assertMatcher(matcher, null, '/foo').matches('/foo', '/css/file.css');
		assertMatcher(matcher, null, '/foo').doesNotMatch('/foo', '/js/file.js');
	}
	@Test
	void atLocationsFromSetWhenSetIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.resourceRequest.at(null))
			.withMessageContaining('Locations must not be null');
	}
	@Test
	void excludeFromSetWhenSetIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.resourceRequest.atCommonLocations().excluding(null))
			.withMessageContaining('Locations must not be null');
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher) {
		return assertMatcher(matcher, null, '');
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String serverNamespace) {
		return assertMatcher(matcher, serverNamespace, '');
	}
	private RequestMatcherAssert assertMatcher(RequestMatcher matcher, String serverNamespace, String path) {
		DispatcherServletPath dispatcherServletPath = () -> path;
		TestWebApplicationContext context = new TestWebApplicationContext(serverNamespace);
		context.registerBean(DispatcherServletPath.class, () -> dispatcherServletPath);
		return assertThat(new RequestMatcherAssert(context, matcher));
	}
	static class RequestMatcherAssert implements AssertDelegateTarget {
		private final WebApplicationContext context;
		private final RequestMatcher matcher;
		RequestMatcherAssert(WebApplicationContext context, RequestMatcher matcher) {
			this.context = context;
			this.matcher = matcher;
		}
		void matches(String path) {
			matches(mockRequest(path));
		}
		void matches(String servletPath, String path) {
			matches(mockRequest(servletPath, path));
		}
		private void matches(HttpServletRequest request) {
			assertThat(this.matcher.matches(request)).as('Matches ' + getRequestPath(request)).isTrue();
		}
		void doesNotMatch(String path) {
			doesNotMatch(mockRequest(path));
		}
		void doesNotMatch(String servletPath, String path) {
			doesNotMatch(mockRequest(servletPath, path));
		}
		private void doesNotMatch(HttpServletRequest request) {
			assertThat(this.matcher.matches(request)).as('Does not match ' + getRequestPath(request)).isFalse();
		}
		private MockHttpServletRequest mockRequest(String path) {
			return mockRequest(null, path);
		}
		private MockHttpServletRequest mockRequest(String servletPath, String path) {
			MockServletContext servletContext = new MockServletContext();
			servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
			MockHttpServletRequest request = new MockHttpServletRequest(servletContext);
			if (servletPath != null) {
				request.setServletPath(servletPath);
			}
			request.setPathInfo(path);
			return request;
		}
		private String getRequestPath(HttpServletRequest request) {
			String url = request.getServletPath();
			if (request.getPathInfo() != null) {
				url += request.getPathInfo();
			}
			return url;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.saml2;
/**
class Saml2RelyingPartyPropertiesTests {
	private final Saml2RelyingPartyProperties properties = new Saml2RelyingPartyProperties();
	@Test
	void customizeSsoUrl() {
		bind('spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.url',
				'https://simplesaml-for-spring-saml/SSOService.php');
		assertThat(
				this.properties.getRegistration().get('simplesamlphp').getAssertingparty().getSinglesignon().getUrl())
			.isEqualTo('https://simplesaml-for-spring-saml/SSOService.php');
	}
	@Test
	void customizeSsoBinding() {
		bind('spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.binding',
				'post');
		assertThat(this.properties.getRegistration()
			.get('simplesamlphp')
			.getAssertingparty()
			.getSinglesignon()
			.getBinding()).isEqualTo(Saml2MessageBinding.POST);
	}
	@Test
	void customizeSsoSignRequests() {
		bind('spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.single-sign-on.sign-request',
				'false');
		assertThat(this.properties.getRegistration()
			.get('simplesamlphp')
			.getAssertingparty()
			.getSinglesignon()
			.getSignRequest()).isFalse();
	}
	@Test
	void customizeRelyingPartyEntityId() {
		bind('spring.security.saml2.relyingparty.registration.simplesamlphp.entity-id',
				'{baseUrl}/saml2/custom-entity-id');
		assertThat(this.properties.getRegistration().get('simplesamlphp').getEntityId())
			.isEqualTo('{baseUrl}/saml2/custom-entity-id');
	}
	@Test
	void customizeRelyingPartyEntityIdDefaultsToServiceProviderMetadata() {
		assertThat(RelyingPartyRegistration.withRegistrationId('id')).extracting('entityId')
			.isEqualTo(new Saml2RelyingPartyProperties.Registration().getEntityId());
	}
	@Test
	void customizeAssertingPartyMetadataUri() {
		bind('spring.security.saml2.relyingparty.registration.simplesamlphp.assertingparty.metadata-uri',
				'https://idp.example.org/metadata');
		assertThat(this.properties.getRegistration().get('simplesamlphp').getAssertingparty().getMetadataUri())
			.isEqualTo('https://idp.example.org/metadata');
	}
	@Test
	void customizeSsoSignRequestsIsNullByDefault() {
		this.properties.getRegistration().put('simplesamlphp', new Saml2RelyingPartyProperties.Registration());
		assertThat(this.properties.getRegistration()
			.get('simplesamlphp')
			.getAssertingparty()
			.getSinglesignon()
			.getSignRequest()).isNull();
	}
	@Test
	void customizeNameIdFormat() {
		bind('spring.security.saml2.relyingparty.registration.simplesamlphp.name-id-format', 'sampleNameIdFormat');
		assertThat(this.properties.getRegistration().get('simplesamlphp').getNameIdFormat())
			.isEqualTo('sampleNameIdFormat');
	}
	private void bind(String name, String value) {
		bind(Collections.singletonMap(name, value));
	}
	private void bind(Map<String, String> map) {
		ConfigurationPropertySource source = new MapConfigurationPropertySource(map);
		new Binder(source).bind('spring.security.saml2.relyingparty', Bindable.ofInstance(this.properties));
	}
}
/*
package org.springframework.boot.autoconfigure.security.saml2;
/**
class Saml2RelyingPartyAutoConfigurationTests {
	private static final String PREFIX = 'spring.security.saml2.relyingparty.registration';
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class, SecurityAutoConfiguration.class));
	@Test
	void autoConfigurationShouldBeConditionalOnRelyingPartyRegistrationRepositoryClass() {
		this.contextRunner.withPropertyValues(getPropertyValues())
			.withClassLoader(new FilteredClassLoader(
					'org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository'))
			.run((context) -> assertThat(context).doesNotHaveBean(RelyingPartyRegistrationRepository.class));
	}
	@Test
	void autoConfigurationShouldBeConditionalOnServletWebApplication() {
		new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(Saml2RelyingPartyAutoConfiguration.class))
			.withPropertyValues(getPropertyValues())
			.run((context) -> assertThat(context).doesNotHaveBean(RelyingPartyRegistrationRepository.class));
	}
	@Test
	void relyingPartyRegistrationRepositoryBeanShouldNotBeCreatedWhenPropertiesAbsent() {
		this.contextRunner
			.run((context) -> assertThat(context).doesNotHaveBean(RelyingPartyRegistrationRepository.class));
	}
	@Test
	void relyingPartyRegistrationRepositoryBeanShouldBeCreatedWhenPropertiesPresent() {
		this.contextRunner.withPropertyValues(getPropertyValues()).run((context) -> {
			RelyingPartyRegistrationRepository repository = context.getBean(RelyingPartyRegistrationRepository.class);
			RelyingPartyRegistration registration = repository.findByRegistrationId('foo');
			assertThat(registration.getAssertingPartyMetadata().getSingleSignOnServiceLocation())
				.isEqualTo('https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php');
			assertThat(registration.getAssertingPartyMetadata().getEntityId())
				.isEqualTo('https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php');
			assertThat(registration.getAssertionConsumerServiceLocation())
				.isEqualTo('{baseUrl}/login/saml2/foo-entity-id');
			assertThat(registration.getAssertionConsumerServiceBinding()).isEqualTo(Saml2MessageBinding.REDIRECT);
			assertThat(registration.getAssertingPartyMetadata().getSingleSignOnServiceBinding())
				.isEqualTo(Saml2MessageBinding.POST);
			assertThat(registration.getAssertingPartyMetadata().getWantAuthnRequestsSigned()).isFalse();
			assertThat(registration.getSigningX509Credentials()).hasSize(1);
			assertThat(registration.getDecryptionX509Credentials()).hasSize(1);
			assertThat(registration.getAssertingPartyMetadata().getVerificationX509Credentials()).isNotNull();
			assertThat(registration.getEntityId()).isEqualTo('{baseUrl}/saml2/foo-entity-id');
			assertThat(registration.getSingleLogoutServiceLocation())
				.isEqualTo('https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SLOService.php');
			assertThat(registration.getSingleLogoutServiceResponseLocation())
				.isEqualTo('https://simplesaml-for-spring-saml.cfapps.io/');
			assertThat(registration.getSingleLogoutServiceBinding()).isEqualTo(Saml2MessageBinding.POST);
			assertThat(registration.getAssertingPartyMetadata().getSingleLogoutServiceLocation())
				.isEqualTo('https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SLOService.php');
			assertThat(registration.getAssertingPartyMetadata().getSingleLogoutServiceResponseLocation())
				.isEqualTo('https://simplesaml-for-spring-saml.cfapps.io/');
			assertThat(registration.getAssertingPartyMetadata().getSingleLogoutServiceBinding())
				.isEqualTo(Saml2MessageBinding.POST);
		});
	}
	@Test
	void autoConfigurationWhenSignRequestsTrueAndNoSigningCredentialsShouldThrowException() {
		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSigningCredentials(true)).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context.getStartupFailure()).hasMessageContaining(
					'Signing credentials must not be empty when authentication requests require signing.');
		});
	}
	@Test
	void autoConfigurationWhenSignRequestsFalseAndNoSigningCredentialsShouldNotThrowException() {
		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSigningCredentials(false))
			.run((context) -> assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class));
	}
	@Test
	void autoconfigurationShouldQueryAssertingPartyMetadataWhenMetadataUrlIsPresent() throws Exception {
		try (MockWebServer server = new MockWebServer()) {
			server.start();
			String metadataUrl = server.url('').toString();
			setupMockResponse(server, new ClassPathResource('saml/idp-metadata'));
			this.contextRunner.withPropertyValues(PREFIX + '.foo.assertingparty.metadata-uri=' + metadataUrl)
				.run((context) -> {
					assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class);
					assertThat(server.getRequestCount()).isOne();
				});
		}
	}
	@Test
	void autoconfigurationShouldUseBindingFromMetadataUrlIfPresent() throws Exception {
		try (MockWebServer server = new MockWebServer()) {
			server.start();
			String metadataUrl = server.url('').toString();
			setupMockResponse(server, new ClassPathResource('saml/idp-metadata'));
			this.contextRunner.withPropertyValues(PREFIX + '.foo.assertingparty.metadata-uri=' + metadataUrl)
				.run((context) -> {
					RelyingPartyRegistrationRepository repository = context
						.getBean(RelyingPartyRegistrationRepository.class);
					RelyingPartyRegistration registration = repository.findByRegistrationId('foo');
					assertThat(registration.getAssertingPartyMetadata().getSingleSignOnServiceBinding())
						.isEqualTo(Saml2MessageBinding.POST);
				});
		}
	}
	@Test
	void autoconfigurationWhenMetadataUrlAndPropertyPresentShouldUseBindingFromProperty() throws Exception {
		try (MockWebServer server = new MockWebServer()) {
			server.start();
			String metadataUrl = server.url('').toString();
			setupMockResponse(server, new ClassPathResource('saml/idp-metadata'));
			this.contextRunner
				.withPropertyValues(PREFIX + '.foo.assertingparty.metadata-uri=' + metadataUrl,
						PREFIX + '.foo.assertingparty.singlesignon.binding=redirect')
				.run((context) -> {
					RelyingPartyRegistrationRepository repository = context
						.getBean(RelyingPartyRegistrationRepository.class);
					RelyingPartyRegistration registration = repository.findByRegistrationId('foo');
					assertThat(registration.getAssertingPartyMetadata().getSingleSignOnServiceBinding())
						.isEqualTo(Saml2MessageBinding.REDIRECT);
				});
		}
	}
	@Test
	void autoconfigurationWhenNoMetadataUrlOrPropertyPresentShouldUseRedirectBinding() {
		this.contextRunner.withPropertyValues(getPropertyValuesWithoutSsoBinding()).run((context) -> {
			RelyingPartyRegistrationRepository repository = context.getBean(RelyingPartyRegistrationRepository.class);
			RelyingPartyRegistration registration = repository.findByRegistrationId('foo');
			assertThat(registration.getAssertingPartyMetadata().getSingleSignOnServiceBinding())
				.isEqualTo(Saml2MessageBinding.REDIRECT);
		});
	}
	@Test
	void relyingPartyRegistrationRepositoryShouldBeConditionalOnMissingBean() {
		this.contextRunner.withPropertyValues(getPropertyValues())
			.withUserConfiguration(RegistrationRepositoryConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class);
				assertThat(context).hasBean('testRegistrationRepository');
			});
	}
	@Test
	void samlLoginShouldBeConfigured() {
		this.contextRunner.withPropertyValues(getPropertyValues())
			.run((context) -> assertThat(hasSecurityFilter(context, Saml2WebSsoAuthenticationFilter.class)).isTrue());
	}
	@Test
	void samlLoginShouldBackOffWhenASecurityFilterChainBeanIsPresent() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(WebMvcAutoConfiguration.class))
			.withUserConfiguration(TestSecurityFilterChainConfig.class)
			.withPropertyValues(getPropertyValues())
			.run((context) -> assertThat(hasSecurityFilter(context, Saml2WebSsoAuthenticationFilter.class)).isFalse());
	}
	@Test
	void samlLoginShouldShouldBeConditionalOnSecurityWebFilterClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(SecurityFilterChain.class))
			.withPropertyValues(getPropertyValues())
			.run((context) -> assertThat(context).doesNotHaveBean(SecurityFilterChain.class));
	}
	@Test
	void samlLogoutShouldBeConfigured() {
		this.contextRunner.withPropertyValues(getPropertyValues())
			.run((context) -> assertThat(hasSecurityFilter(context, Saml2LogoutRequestFilter.class)).isTrue());
	}
	private String[] getPropertyValuesWithoutSigningCredentials(boolean signRequests) {
		return new String[] { PREFIX
				+ '.foo.assertingparty.singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php',
				PREFIX + '.foo.assertingparty.singlesignon.binding=post',
				PREFIX + '.foo.assertingparty.singlesignon.sign-request=' + signRequests,
				PREFIX + '.foo.assertingparty.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php',
				PREFIX + '.foo.assertingparty.verification.credentials[0].certificate-location=classpath:saml/certificate-location' };
	}
	@Test
	void autoconfigurationWhenMultipleProvidersAndNoSpecifiedEntityId() throws Exception {
		testMultipleProviders(null, 'https://idp.example.com/idp/shibboleth');
	}
	@Test
	void autoconfigurationWhenMultipleProvidersAndSpecifiedEntityId() throws Exception {
		testMultipleProviders('https://idp.example.com/idp/shibboleth', 'https://idp.example.com/idp/shibboleth');
		testMultipleProviders('https://idp2.example.com/idp/shibboleth', 'https://idp2.example.com/idp/shibboleth');
	}
	@Test
	void signRequestShouldApplyIfMetadataUriIsSet() throws Exception {
		try (MockWebServer server = new MockWebServer()) {
			server.start();
			String metadataUrl = server.url('').toString();
			setupMockResponse(server, new ClassPathResource('saml/idp-metadata'));
			this.contextRunner.withPropertyValues(PREFIX + '.foo.assertingparty.metadata-uri=' + metadataUrl,
					PREFIX + '.foo.assertingparty.singlesignon.sign-request=true',
					PREFIX + '.foo.signing.credentials[0].private-key-location=classpath:org/springframework/boot/autoconfigure/security/saml2/rsa.key',
					PREFIX + '.foo.signing.credentials[0].certificate-location=classpath:org/springframework/boot/autoconfigure/security/saml2/rsa.crt')
				.run((context) -> {
					RelyingPartyRegistrationRepository repository = context
						.getBean(RelyingPartyRegistrationRepository.class);
					RelyingPartyRegistration registration = repository.findByRegistrationId('foo');
					assertThat(registration.getAssertingPartyMetadata().getWantAuthnRequestsSigned()).isTrue();
				});
		}
	}
	@Test
	void autoconfigurationWithInvalidPrivateKeyShouldFail() {
		this.contextRunner.withPropertyValues(
				PREFIX + '.foo.signing.credentials[0].private-key-location=classpath:saml/certificate-location',
				PREFIX + '.foo.signing.credentials[0].certificate-location=classpath:saml/certificate-location',
				PREFIX + '.foo.assertingparty.singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php',
				PREFIX + '.foo.assertingparty.singlesignon.binding=post',
				PREFIX + '.foo.assertingparty.singlesignon.sign-request=false',
				PREFIX + '.foo.assertingparty.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php',
				PREFIX + '.foo.assertingparty.verification.credentials[0].certificate-location=classpath:saml/certificate-location')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.rootCause()
				.hasMessageContaining('Missing private key or unrecognized format'));
	}
	@Test
	void autoconfigurationWithInvalidCertificateShouldFail() {
		this.contextRunner.withPropertyValues(
				PREFIX + '.foo.signing.credentials[0].private-key-location=classpath:saml/private-key-location',
				PREFIX + '.foo.signing.credentials[0].certificate-location=classpath:saml/private-key-location',
				PREFIX + '.foo.assertingparty.singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php',
				PREFIX + '.foo.assertingparty.singlesignon.binding=post',
				PREFIX + '.foo.assertingparty.singlesignon.sign-request=false',
				PREFIX + '.foo.assertingparty.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php',
				PREFIX + '.foo.assertingparty.verification.credentials[0].certificate-location=classpath:saml/certificate-location')
			.run((context) -> assertThat(context).hasFailed()
				.getFailure()
				.rootCause()
				.hasMessageContaining('Missing certificates or unrecognized format'));
	}
	private void testMultipleProviders(String specifiedEntityId, String expected) throws Exception {
		try (MockWebServer server = new MockWebServer()) {
			server.start();
			String metadataUrl = server.url('').toString();
			setupMockResponse(server, new ClassPathResource('saml/idp-metadata-with-multiple-providers'));
			WebApplicationContextRunner contextRunner = this.contextRunner
				.withPropertyValues(PREFIX + '.foo.assertingparty.metadata-uri=' + metadataUrl);
			if (specifiedEntityId != null) {
				contextRunner = contextRunner
					.withPropertyValues(PREFIX + '.foo.assertingparty.entity-id=' + specifiedEntityId);
			}
			contextRunner.run((context) -> {
				assertThat(context).hasSingleBean(RelyingPartyRegistrationRepository.class);
				assertThat(server.getRequestCount()).isOne();
				RelyingPartyRegistrationRepository repository = context
					.getBean(RelyingPartyRegistrationRepository.class);
				RelyingPartyRegistration registration = repository.findByRegistrationId('foo');
				assertThat(registration.getAssertingPartyMetadata().getEntityId()).isEqualTo(expected);
			});
		}
	}
	private String[] getPropertyValuesWithoutSsoBinding() {
		return new String[] { PREFIX
				+ '.foo.assertingparty.singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php',
				PREFIX + '.foo.assertingparty.singlesignon.sign-request=false',
				PREFIX + '.foo.assertingparty.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php',
				PREFIX + '.foo.assertingparty.verification.credentials[0].certificate-location=classpath:saml/certificate-location' };
	}
	private String[] getPropertyValues() {
		return new String[] {
				PREFIX + '.foo.signing.credentials[0].private-key-location=classpath:saml/private-key-location',
				PREFIX + '.foo.signing.credentials[0].certificate-location=classpath:saml/certificate-location',
				PREFIX + '.foo.decryption.credentials[0].private-key-location=classpath:saml/private-key-location',
				PREFIX + '.foo.decryption.credentials[0].certificate-location=classpath:saml/certificate-location',
				PREFIX + '.foo.singlelogout.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SLOService.php',
				PREFIX + '.foo.singlelogout.response-url=https://simplesaml-for-spring-saml.cfapps.io/',
				PREFIX + '.foo.singlelogout.binding=post',
				PREFIX + '.foo.assertingparty.singlesignon.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SSOService.php',
				PREFIX + '.foo.assertingparty.singlesignon.binding=post',
				PREFIX + '.foo.assertingparty.singlesignon.sign-request=false',
				PREFIX + '.foo.assertingparty.entity-id=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/metadata.php',
				PREFIX + '.foo.assertingparty.verification.credentials[0].certificate-location=classpath:saml/certificate-location',
				PREFIX + '.foo.asserting-party.singlelogout.url=https://simplesaml-for-spring-saml.cfapps.io/saml2/idp/SLOService.php',
				PREFIX + '.foo.asserting-party.singlelogout.response-url=https://simplesaml-for-spring-saml.cfapps.io/',
				PREFIX + '.foo.asserting-party.singlelogout.binding=post',
				PREFIX + '.foo.entity-id={baseUrl}/saml2/foo-entity-id',
				PREFIX + '.foo.acs.location={baseUrl}/login/saml2/foo-entity-id',
				PREFIX + '.foo.acs.binding=redirect' };
	}
	private boolean hasSecurityFilter(AssertableWebApplicationContext context, Class<? extends Filter> filter) {
		return getSecurityFilterChain(context).getFilters().stream().anyMatch(filter::isInstance);
	}
	private SecurityFilterChain getSecurityFilterChain(AssertableWebApplicationContext context) {
		Filter springSecurityFilterChain = context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class);
		FilterChainProxy filterChainProxy = getFilterChainProxy(springSecurityFilterChain);
		SecurityFilterChain securityFilterChain = filterChainProxy.getFilterChains().get(0);
		return securityFilterChain;
	}
	private FilterChainProxy getFilterChainProxy(Filter filter) {
		if (filter instanceof FilterChainProxy filterChainProxy) {
			return filterChainProxy;
		}
		if (filter instanceof CompositeFilter) {
			List<?> filters = (List<?>) ReflectionTestUtils.getField(filter, 'filters');
			return (FilterChainProxy) filters.stream()
				.filter(FilterChainProxy.class::isInstance)
				.findFirst()
				.orElseThrow();
		}
		throw new IllegalStateException('No FilterChainProxy found');
	}
	private void setupMockResponse(MockWebServer server, Resource resourceBody) throws Exception {
		try (InputStream metadataSource = resourceBody.getInputStream()) {
			try (Buffer metadataBuffer = new Buffer()) {
				metadataBuffer.readFrom(metadataSource);
				MockResponse metadataResponse = new MockResponse().setBody(metadataBuffer);
				server.enqueue(metadataResponse);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RegistrationRepositoryConfiguration {
		@Bean
		RelyingPartyRegistrationRepository testRegistrationRepository() {
			return mock(RelyingPartyRegistrationRepository.class);
		}
	}
	@EnableWebSecurity
	static class WebSecurityEnablerConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TestSecurityFilterChainConfig {
		@Bean
		SecurityFilterChain testSecurityFilterChain(HttpSecurity http) throws Exception {
			return http.securityMatcher('/**')
				.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated())
				.build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.jpa;
/**
@ContextConfiguration(classes = JpaUserDetailsTests.Main.class, loader = SpringBootContextLoader.class)
@DirtiesContext
class JpaUserDetailsTests {
	@Test
	void contextLoads() {
	}
	@Import({ EmbeddedDataSourceConfiguration.class, DataSourceAutoConfiguration.class,
			HibernateJpaAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
			SecurityAutoConfiguration.class })
	static class Main {
	}
}
/*
package org.springframework.boot.autoconfigure.security.rsocket;
/**
class RSocketSecurityAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RSocketSecurityAutoConfiguration.class,
				RSocketMessagingAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class))
		.withUserConfiguration(UserDetailsServiceConfiguration.class);
	@Test
	void autoConfigurationEnablesRSocketSecurity() {
		this.contextRunner.run((context) -> assertThat(context.getBean(RSocketSecurity.class)).isNotNull());
	}
	@Test
	void autoConfigurationIsConditionalOnSecuritySocketAcceptorInterceptorClass() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(SecuritySocketAcceptorInterceptor.class))
			.run((context) -> assertThat(context).doesNotHaveBean(RSocketSecurity.class));
	}
	@Test
	void autoConfigurationAddsCustomizerForServerRSocketFactory() {
		RSocketServer server = RSocketServer.create();
		this.contextRunner.run((context) -> {
			RSocketServerCustomizer customizer = context.getBean(RSocketServerCustomizer.class);
			customizer.customize(server);
			server.interceptors((registry) -> registry.forSocketAcceptor((interceptors) -> {
				assertThat(interceptors).isNotEmpty();
				assertThat(interceptors)
					.anyMatch((interceptor) -> interceptor instanceof SecuritySocketAcceptorInterceptor);
			}));
		});
	}
	@Test
	void autoConfigurationAddsCustomizerForAuthenticationPrincipalArgumentResolver() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(RSocketMessageHandler.class);
			RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);
			assertThat(handler.getArgumentResolverConfigurer().getCustomResolvers())
				.anyMatch((customResolver) -> customResolver instanceof AuthenticationPrincipalArgumentResolver);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDetailsServiceConfiguration {
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			return new MapReactiveUserDetailsService(
					User.withUsername('alice').password('secret').roles('admin').build());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
class PathRequestTests {
	@Test
	void toStaticResourcesShouldReturnStaticResourceRequest() {
		assertThat(PathRequest.toStaticResources()).isInstanceOf(StaticResourceRequest.class);
	}
}
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
class ReactiveSecurityAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class));
	@Test
	void backsOffWhenWebFilterChainProxyBeanPresent() {
		this.contextRunner.withUserConfiguration(WebFilterChainProxyConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(WebFilterChainProxy.class));
	}
	@Test
	void autoConfiguresDenyAllReactiveAuthenticationManagerWhenNoAlternativeIsAvailable() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ReactiveSecurityAutoConfiguration.class)
			.hasBean('denyAllAuthenticationManager'));
	}
	@Test
	void enablesWebFluxSecurityWhenUserDetailsServiceIsPresent() {
		this.contextRunner.withUserConfiguration(UserDetailsServiceConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(WebFilterChainProxy.class);
			assertThat(context).doesNotHaveBean('denyAllAuthenticationManager');
		});
	}
	@Test
	void enablesWebFluxSecurityWhenReactiveAuthenticationManagerIsPresent() {
		this.contextRunner
			.withBean(ReactiveAuthenticationManager.class, () -> mock(ReactiveAuthenticationManager.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(WebFilterChainProxy.class);
				assertThat(context).doesNotHaveBean('denyAllAuthenticationManager');
			});
	}
	@Test
	void enablesWebFluxSecurityWhenSecurityWebFilterChainIsPresent() {
		this.contextRunner.withBean(SecurityWebFilterChain.class, () -> mock(SecurityWebFilterChain.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(WebFilterChainProxy.class);
				assertThat(context).doesNotHaveBean('denyAllAuthenticationManager');
			});
	}
	@Test
	void autoConfigurationIsConditionalOnClass() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader(Flux.class, EnableWebFluxSecurity.class, WebFilterChainProxy.class,
					WebFluxConfigurer.class))
			.withUserConfiguration(UserDetailsServiceConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(WebFilterChainProxy.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class WebFilterChainProxyConfiguration {
		@Bean
		WebFilterChainProxy webFilterChainProxy() {
			return mock(WebFilterChainProxy.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UserDetailsServiceConfiguration {
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			return new MapReactiveUserDetailsService(
					User.withUsername('alice').password('secret').roles('admin').build());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
class ReactiveUserDetailsServiceAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactiveUserDetailsServiceAutoConfiguration.class));
	@Test
	void configuresADefaultUser() {
		this.contextRunner
			.withClassLoader(
					new FilteredClassLoader(ClientRegistrationRepository.class, ReactiveOpaqueTokenIntrospector.class))
			.withUserConfiguration(TestSecurityConfiguration.class)
			.run((context) -> {
				ReactiveUserDetailsService userDetailsService = context.getBean(ReactiveUserDetailsService.class);
				assertThat(userDetailsService.findByUsername('user').block(Duration.ofSeconds(30))).isNotNull();
			});
	}
	@Test
	void userDetailsServiceWhenRSocketConfigured() {
		new ApplicationContextRunner()
			.withClassLoader(
					new FilteredClassLoader(ClientRegistrationRepository.class, ReactiveOpaqueTokenIntrospector.class))
			.withConfiguration(AutoConfigurations.of(ReactiveUserDetailsServiceAutoConfiguration.class,
					RSocketMessagingAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class))
			.withUserConfiguration(TestRSocketSecurityConfiguration.class)
			.run((context) -> {
				ReactiveUserDetailsService userDetailsService = context.getBean(ReactiveUserDetailsService.class);
				assertThat(userDetailsService.findByUsername('user').block(Duration.ofSeconds(30))).isNotNull();
			});
	}
	@Test
	void doesNotConfigureDefaultUserIfUserDetailsServiceAvailable() {
		this.contextRunner.withUserConfiguration(UserConfig.class, TestSecurityConfiguration.class).run((context) -> {
			ReactiveUserDetailsService userDetailsService = context.getBean(ReactiveUserDetailsService.class);
			assertThat(userDetailsService.findByUsername('user').block(Duration.ofSeconds(30))).isNull();
			assertThat(userDetailsService.findByUsername('foo').block(Duration.ofSeconds(30))).isNotNull();
			assertThat(userDetailsService.findByUsername('admin').block(Duration.ofSeconds(30))).isNotNull();
		});
	}
	@Test
	void doesNotConfigureDefaultUserIfAuthenticationManagerAvailable() {
		this.contextRunner.withUserConfiguration(AuthenticationManagerConfig.class, TestSecurityConfiguration.class)
			.withConfiguration(AutoConfigurations.of(ReactiveSecurityAutoConfiguration.class))
			.run((context) -> assertThat(context).getBean(ReactiveUserDetailsService.class).isNull());
	}
	@Test
	void doesNotConfigureDefaultUserIfAuthenticationManagerResolverAvailable() {
		this.contextRunner.withUserConfiguration(AuthenticationManagerResolverConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveAuthenticationManagerResolver.class)
				.doesNotHaveBean(ReactiveUserDetailsService.class));
	}
	@Test
	void doesNotConfigureDefaultUserIfResourceServerWithJWTIsUsed() {
		this.contextRunner.withUserConfiguration(JwtDecoderConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ReactiveJwtDecoder.class);
			assertThat(context).doesNotHaveBean(ReactiveUserDetailsService.class);
		});
	}
	@Test
	void doesNotConfigureDefaultUserIfResourceServerIsPresent() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ReactiveUserDetailsService.class));
	}
	@Test
	void configuresDefaultUserWhenResourceServerIsPresentAndUsernameIsConfigured() {
		this.contextRunner.withPropertyValues('spring.security.user.name=carol')
			.run((context) -> assertThat(context).hasSingleBean(ReactiveUserDetailsService.class));
	}
	@Test
	void configuresDefaultUserWhenResourceServerIsPresentAndPasswordIsConfigured() {
		this.contextRunner.withPropertyValues('spring.security.user.password=p4ssw0rd')
			.run((context) -> assertThat(context).hasSingleBean(ReactiveUserDetailsService.class));
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderAbsentAndDefaultPassword() {
		this.contextRunner
			.withClassLoader(
					new FilteredClassLoader(ClientRegistrationRepository.class, ReactiveOpaqueTokenIntrospector.class))
			.withUserConfiguration(TestSecurityConfiguration.class)
			.run(((context) -> {
				MapReactiveUserDetailsService userDetailsService = context.getBean(MapReactiveUserDetailsService.class);
				String password = userDetailsService.findByUsername('user').block(Duration.ofSeconds(30)).getPassword();
				assertThat(password).startsWith('{noop}');
			}));
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderAbsentAndRawPassword() {
		testPasswordEncoding(TestSecurityConfiguration.class, 'secret', '{noop}secret');
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderAbsentAndEncodedPassword() {
		String password = '{bcrypt}$2a$10$sCBi9fy9814vUPf2ZRbtp.fR5/VgRk2iBFZ.ypu5IyZ28bZgxrVDa';
		testPasswordEncoding(TestSecurityConfiguration.class, password, password);
	}
	@Test
	void userDetailsServiceWhenPasswordEncoderBeanPresent() {
		testPasswordEncoding(TestConfigWithPasswordEncoder.class, 'secret', 'secret');
	}
	private void testPasswordEncoding(Class<?> configClass, String providedPassword, String expectedPassword) {
		this.contextRunner
			.withClassLoader(
					new FilteredClassLoader(ClientRegistrationRepository.class, ReactiveOpaqueTokenIntrospector.class))
			.withUserConfiguration(configClass)
			.withPropertyValues('spring.security.user.password=' + providedPassword)
			.run(((context) -> {
				MapReactiveUserDetailsService userDetailsService = context.getBean(MapReactiveUserDetailsService.class);
				String password = userDetailsService.findByUsername('user').block(Duration.ofSeconds(30)).getPassword();
				assertThat(password).isEqualTo(expectedPassword);
			}));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebFluxSecurity
	@EnableConfigurationProperties(SecurityProperties.class)
	static class TestSecurityConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableRSocketSecurity
	@EnableConfigurationProperties(SecurityProperties.class)
	static class TestRSocketSecurityConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class UserConfig {
		@Bean
		MapReactiveUserDetailsService userDetailsService() {
			UserDetails foo = User.withUsername('foo').password('foo').roles('USER').build();
			UserDetails admin = User.withUsername('admin').password('admin').roles('USER', 'ADMIN').build();
			return new MapReactiveUserDetailsService(foo, admin);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AuthenticationManagerConfig {
		@Bean
		ReactiveAuthenticationManager reactiveAuthenticationManager() {
			return (authentication) -> null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AuthenticationManagerResolverConfig {
		@Bean
		ReactiveAuthenticationManagerResolver<?> reactiveAuthenticationManagerResolver() {
			return mock(ReactiveAuthenticationManagerResolver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestSecurityConfiguration.class)
	static class TestConfigWithPasswordEncoder {
		@Bean
		PasswordEncoder passwordEncoder() {
			return mock(PasswordEncoder.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JwtDecoderConfiguration {
		@Bean
		ReactiveJwtDecoder jwtDecoder() {
			return mock(ReactiveJwtDecoder.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveOpaqueTokenIntrospectorConfiguration {
		@Bean
		ReactiveOpaqueTokenIntrospector introspectionClient() {
			return mock(ReactiveOpaqueTokenIntrospector.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
class StaticResourceRequestTests {
	private final StaticResourceRequest resourceRequest = StaticResourceRequest.INSTANCE;
	@Test
	void atCommonLocationsShouldMatchCommonLocations() {
		ServerWebExchangeMatcher matcher = this.resourceRequest.atCommonLocations();
		assertMatcher(matcher).matches('/css/file.css');
		assertMatcher(matcher).matches('/js/file.js');
		assertMatcher(matcher).matches('/images/file.css');
		assertMatcher(matcher).matches('/webjars/file.css');
		assertMatcher(matcher).matches('/favicon.ico');
		assertMatcher(matcher).matches('/favicon.png');
		assertMatcher(matcher).matches('/icons/icon-48x48.png');
		assertMatcher(matcher).doesNotMatch('/bar');
	}
	@Test
	void atCommonLocationsWithExcludeShouldNotMatchExcluded() {
		ServerWebExchangeMatcher matcher = this.resourceRequest.atCommonLocations()
			.excluding(StaticResourceLocation.CSS);
		assertMatcher(matcher).doesNotMatch('/css/file.css');
		assertMatcher(matcher).matches('/js/file.js');
	}
	@Test
	void atLocationShouldMatchLocation() {
		ServerWebExchangeMatcher matcher = this.resourceRequest.at(StaticResourceLocation.CSS);
		assertMatcher(matcher).matches('/css/file.css');
		assertMatcher(matcher).doesNotMatch('/js/file.js');
	}
	@Test
	void atLocationsFromSetWhenSetIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.resourceRequest.at(null))
			.withMessageContaining('Locations must not be null');
	}
	@Test
	void excludeFromSetWhenSetIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.resourceRequest.atCommonLocations().excluding(null))
			.withMessageContaining('Locations must not be null');
	}
	private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher) {
		StaticWebApplicationContext context = new StaticWebApplicationContext();
		context.registerBean(ServerProperties.class);
		return assertThat(new RequestMatcherAssert(context, matcher));
	}
	static class RequestMatcherAssert implements AssertDelegateTarget {
		private final StaticApplicationContext context;
		private final ServerWebExchangeMatcher matcher;
		RequestMatcherAssert(StaticApplicationContext context, ServerWebExchangeMatcher matcher) {
			this.context = context;
			this.matcher = matcher;
		}
		void matches(String path) {
			ServerWebExchange exchange = webHandler().createExchange(MockServerHttpRequest.get(path).build(),
					new MockServerHttpResponse());
			matches(exchange);
		}
		private void matches(ServerWebExchange exchange) {
			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30)).isMatch())
				.as('Matches ' + getRequestPath(exchange))
				.isTrue();
		}
		void doesNotMatch(String path) {
			ServerWebExchange exchange = webHandler().createExchange(MockServerHttpRequest.get(path).build(),
					new MockServerHttpResponse());
			doesNotMatch(exchange);
		}
		private void doesNotMatch(ServerWebExchange exchange) {
			assertThat(this.matcher.matches(exchange).block(Duration.ofSeconds(30)).isMatch())
				.as('Does not match ' + getRequestPath(exchange))
				.isFalse();
		}
		private TestHttpWebHandlerAdapter webHandler() {
			TestHttpWebHandlerAdapter adapter = new TestHttpWebHandlerAdapter(mock(WebHandler.class));
			adapter.setApplicationContext(this.context);
			return adapter;
		}
		private String getRequestPath(ServerWebExchange exchange) {
			return exchange.getRequest().getPath().toString();
		}
	}
	static class TestHttpWebHandlerAdapter extends HttpWebHandlerAdapter {
		TestHttpWebHandlerAdapter(WebHandler delegate) {
			super(delegate);
		}
		@Override
		protected ServerWebExchange createExchange(ServerHttpRequest request, ServerHttpResponse response) {
			return super.createExchange(request, response);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security;
/**
class SecurityPropertiesTests {
	private final SecurityProperties security = new SecurityProperties();
	private Binder binder;
	private final MapConfigurationPropertySource source = new MapConfigurationPropertySource();
	@BeforeEach
	void setUp() {
		this.binder = new Binder(this.source);
	}
	@Test
	void validateDefaultFilterOrderMatchesMetadata() {
		assertThat(this.security.getFilter().getOrder()).isEqualTo(-100);
	}
	@Test
	void filterOrderShouldBind() {
		this.source.put('spring.security.filter.order', '55');
		this.binder.bind('spring.security', Bindable.ofInstance(this.security));
		assertThat(this.security.getFilter().getOrder()).isEqualTo(55);
	}
	@Test
	void userWhenNotConfiguredShouldUseDefaultNameAndGeneratedPassword() {
		SecurityProperties.User user = this.security.getUser();
		assertThat(user.getName()).isEqualTo('user');
		assertThat(user.getPassword()).isNotNull();
		assertThat(user.isPasswordGenerated()).isTrue();
		assertThat(user.getRoles()).isEmpty();
	}
	@Test
	void userShouldBindProperly() {
		this.source.put('spring.security.user.name', 'foo');
		this.source.put('spring.security.user.password', 'password');
		this.source.put('spring.security.user.roles', 'ADMIN,USER');
		this.binder.bind('spring.security', Bindable.ofInstance(this.security));
		SecurityProperties.User user = this.security.getUser();
		assertThat(user.getName()).isEqualTo('foo');
		assertThat(user.getPassword()).isEqualTo('password');
		assertThat(user.isPasswordGenerated()).isFalse();
		assertThat(user.getRoles()).containsExactly('ADMIN', 'USER');
	}
	@Test
	void passwordAutogeneratedIfEmpty() {
		this.source.put('spring.security.user.password', '');
		this.binder.bind('spring.security', Bindable.ofInstance(this.security));
		assertThat(this.security.getUser().isPasswordGenerated()).isTrue();
	}
}
/*
package org.springframework.boot.autoconfigure.reactor;
/**
class ReactorAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactorAutoConfiguration.class));
	private static final String THREADLOCAL_KEY = 'ReactorAutoConfigurationTests';
	private static final ThreadLocal<String> THREADLOCAL_VALUE = ThreadLocal.withInitial(() -> 'initial');
	@BeforeEach
	@AfterEach
	void resetStaticState() {
		Hooks.disableAutomaticContextPropagation();
	}
	@BeforeAll
	static void initializeThreadLocalAccessors() {
		ContextRegistry globalRegistry = ContextRegistry.getInstance();
		globalRegistry.registerThreadLocalAccessor(THREADLOCAL_KEY, THREADLOCAL_VALUE);
	}
	@AfterAll
	static void removeThreadLocalAccessors() {
		ContextRegistry globalRegistry = ContextRegistry.getInstance();
		globalRegistry.removeThreadLocalAccessor(THREADLOCAL_KEY);
	}
	@Test
	void shouldNotConfigurePropagationByDefault() {
		AtomicReference<String> threadLocalValue = new AtomicReference<>();
		this.contextRunner.run((applicationContext) -> {
			Mono.just('test')
				.doOnNext((element) -> threadLocalValue.set(THREADLOCAL_VALUE.get()))
				.contextWrite(Context.of(THREADLOCAL_KEY, 'updated'))
				.block();
			assertThat(threadLocalValue.get()).isEqualTo('initial');
		});
	}
	@Test
	void shouldConfigurePropagationIfSetToAuto() {
		AtomicReference<String> threadLocalValue = new AtomicReference<>();
		this.contextRunner.withPropertyValues('spring.reactor.context-propagation=auto').run((applicationContext) -> {
			Mono.just('test')
				.doOnNext((element) -> threadLocalValue.set(THREADLOCAL_VALUE.get()))
				.contextWrite(Context.of(THREADLOCAL_KEY, 'updated'))
				.block();
			assertThat(threadLocalValue.get()).isEqualTo('updated');
		});
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@SuppressWarnings('resource')
class AutoConfigurationPackagesTests {
	@Test
	void setAndGet() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				ConfigWithAutoConfigurationPackage.class);
		assertThat(AutoConfigurationPackages.get(context.getBeanFactory()))
			.containsExactly(getClass().getPackage().getName());
	}
	@Test
	void getWithoutSet() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(EmptyConfig.class);
		assertThatIllegalStateException().isThrownBy(() -> AutoConfigurationPackages.get(context.getBeanFactory()))
			.withMessageContaining('Unable to retrieve @EnableAutoConfiguration base packages');
	}
	@Test
	void detectsMultipleAutoConfigurationPackages() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(FirstConfiguration.class,
				SecondConfiguration.class);
		List<String> packages = AutoConfigurationPackages.get(context.getBeanFactory());
		Package package1 = FirstConfiguration.class.getPackage();
		Package package2 = SecondConfiguration.class.getPackage();
		assertThat(packages).containsOnly(package1.getName(), package2.getName());
	}
	@Test
	void whenBasePackagesAreSpecifiedThenTheyAreRegistered() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				ConfigWithAutoConfigurationBasePackages.class);
		List<String> packages = AutoConfigurationPackages.get(context.getBeanFactory());
		assertThat(packages).containsExactly('com.example.alpha', 'com.example.bravo');
	}
	@Test
	void whenBasePackageClassesAreSpecifiedThenTheirPackagesAreRegistered() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(
				ConfigWithAutoConfigurationBasePackageClasses.class);
		List<String> packages = AutoConfigurationPackages.get(context.getBeanFactory());
		assertThat(packages).containsOnly(FirstConfiguration.class.getPackage().getName(),
				SecondConfiguration.class.getPackage().getName());
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigurationPackage
	static class ConfigWithAutoConfigurationPackage {
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigurationPackage(basePackages = { 'com.example.alpha', 'com.example.bravo' })
	static class ConfigWithAutoConfigurationBasePackages {
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigurationPackage(basePackageClasses = { FirstConfiguration.class, SecondConfiguration.class })
	static class ConfigWithAutoConfigurationBasePackageClasses {
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfig {
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
@ExtendWith(MockitoExtension.class)
class TemplateAvailabilityProvidersTests {
	private TemplateAvailabilityProviders providers;
	@Mock
	private TemplateAvailabilityProvider provider;
	private final String view = 'view';
	private final ClassLoader classLoader = getClass().getClassLoader();
	private final MockEnvironment environment = new MockEnvironment();
	@Mock
	private ResourceLoader resourceLoader;
	@BeforeEach
	void setup() {
		this.providers = new TemplateAvailabilityProviders(Collections.singleton(this.provider));
	}
	@Test
	void createWhenApplicationContextIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TemplateAvailabilityProviders((ApplicationContext) null))
			.withMessageContaining('ClassLoader must not be null');
	}
	@Test
	void createWhenUsingApplicationContextShouldLoadProviders() {
		ApplicationContext applicationContext = mock(ApplicationContext.class);
		given(applicationContext.getClassLoader()).willReturn(this.classLoader);
		TemplateAvailabilityProviders providers = new TemplateAvailabilityProviders(applicationContext);
		assertThat(providers.getProviders()).isNotEmpty();
		then(applicationContext).should().getClassLoader();
	}
	@Test
	void createWhenClassLoaderIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> new TemplateAvailabilityProviders((ClassLoader) null))
			.withMessageContaining('ClassLoader must not be null');
	}
	@Test
	void createWhenUsingClassLoaderShouldLoadProviders() {
		TemplateAvailabilityProviders providers = new TemplateAvailabilityProviders(this.classLoader);
		assertThat(providers.getProviders()).isNotEmpty();
	}
	@Test
	void createWhenProvidersIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new TemplateAvailabilityProviders((Collection<TemplateAvailabilityProvider>) null))
			.withMessageContaining('Providers must not be null');
	}
	@Test
	void createWhenUsingProvidersShouldUseProviders() {
		TemplateAvailabilityProviders providers = new TemplateAvailabilityProviders(
				Collections.singleton(this.provider));
		assertThat(providers.getProviders()).containsOnly(this.provider);
	}
	@Test
	void getProviderWhenApplicationContextIsNullShouldThrowException() {
		assertThatIllegalArgumentException().isThrownBy(() -> this.providers.getProvider(this.view, null))
			.withMessageContaining('ApplicationContext must not be null');
	}
	@Test
	void getProviderWhenViewIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.providers.getProvider(null, this.environment, this.classLoader, this.resourceLoader))
			.withMessageContaining('View must not be null');
	}
	@Test
	void getProviderWhenEnvironmentIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.providers.getProvider(this.view, null, this.classLoader, this.resourceLoader))
			.withMessageContaining('Environment must not be null');
	}
	@Test
	void getProviderWhenClassLoaderIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.providers.getProvider(this.view, this.environment, null, this.resourceLoader))
			.withMessageContaining('ClassLoader must not be null');
	}
	@Test
	void getProviderWhenResourceLoaderIsNullShouldThrowException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> this.providers.getProvider(this.view, this.environment, this.classLoader, null))
			.withMessageContaining('ResourceLoader must not be null');
	}
	@Test
	void getProviderWhenNoneMatchShouldReturnNull() {
		TemplateAvailabilityProvider found = this.providers.getProvider(this.view, this.environment, this.classLoader,
				this.resourceLoader);
		assertThat(found).isNull();
		then(this.provider).should()
			.isTemplateAvailable(this.view, this.environment, this.classLoader, this.resourceLoader);
	}
	@Test
	void getProviderWhenMatchShouldReturnProvider() {
		given(this.provider.isTemplateAvailable(this.view, this.environment, this.classLoader, this.resourceLoader))
			.willReturn(true);
		TemplateAvailabilityProvider found = this.providers.getProvider(this.view, this.environment, this.classLoader,
				this.resourceLoader);
		assertThat(found).isSameAs(this.provider);
	}
	@Test
	void getProviderShouldCacheMatchResult() {
		given(this.provider.isTemplateAvailable(this.view, this.environment, this.classLoader, this.resourceLoader))
			.willReturn(true);
		this.providers.getProvider(this.view, this.environment, this.classLoader, this.resourceLoader);
		this.providers.getProvider(this.view, this.environment, this.classLoader, this.resourceLoader);
		then(this.provider).should()
			.isTemplateAvailable(this.view, this.environment, this.classLoader, this.resourceLoader);
	}
	@Test
	void getProviderShouldCacheNoMatchResult() {
		this.providers.getProvider(this.view, this.environment, this.classLoader, this.resourceLoader);
		this.providers.getProvider(this.view, this.environment, this.classLoader, this.resourceLoader);
		then(this.provider).should()
			.isTemplateAvailable(this.view, this.environment, this.classLoader, this.resourceLoader);
	}
	@Test
	void getProviderWhenCacheDisabledShouldNotUseCache() {
		given(this.provider.isTemplateAvailable(this.view, this.environment, this.classLoader, this.resourceLoader))
			.willReturn(true);
		this.environment.setProperty('spring.template.provider.cache', 'false');
		this.providers.getProvider(this.view, this.environment, this.classLoader, this.resourceLoader);
		this.providers.getProvider(this.view, this.environment, this.classLoader, this.resourceLoader);
		then(this.provider).should(times(2))
			.isTemplateAvailable(this.view, this.environment, this.classLoader, this.resourceLoader);
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
class ViewResolverPropertiesTests {
	@Test
	void defaultContentType() {
		assertThat(new ViewResolverProperties().getContentType()).hasToString('text/html;charset=UTF-8');
	}
	@Test
	void customContentTypeDefaultCharset() {
		ViewResolverProperties properties = new ViewResolverProperties();
		properties.setContentType(MimeTypeUtils.parseMimeType('text/plain'));
		assertThat(properties.getContentType()).hasToString('text/plain;charset=UTF-8');
	}
	@Test
	void defaultContentTypeCustomCharset() {
		ViewResolverProperties properties = new ViewResolverProperties();
		properties.setCharset(StandardCharsets.UTF_16);
		assertThat(properties.getContentType()).hasToString('text/html;charset=UTF-16');
	}
	@Test
	void customContentTypeCustomCharset() {
		ViewResolverProperties properties = new ViewResolverProperties();
		properties.setContentType(MimeTypeUtils.parseMimeType('text/plain'));
		properties.setCharset(StandardCharsets.UTF_16);
		assertThat(properties.getContentType()).hasToString('text/plain;charset=UTF-16');
	}
	@Test
	void customContentTypeWithPropertyAndCustomCharset() {
		ViewResolverProperties properties = new ViewResolverProperties();
		properties.setContentType(MimeTypeUtils.parseMimeType('text/plain;foo=bar'));
		properties.setCharset(StandardCharsets.UTF_16);
		assertThat(properties.getContentType()).hasToString('text/plain;charset=UTF-16;foo=bar');
	}
	static class ViewResolverProperties extends AbstractViewResolverProperties {
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
class TemplateRuntimeHintsTests {
	private static final Predicate<RuntimeHints> TEST_PREDICATE = RuntimeHintsPredicates.resource()
		.forResource('templates/something/hello.html');
	@Test
	void templateRuntimeHintsIsRegistered() {
		Iterable<RuntimeHintsRegistrar> registrar = AotServices.factories().load(RuntimeHintsRegistrar.class);
		assertThat(registrar).anyMatch(TemplateRuntimeHints.class::isInstance);
	}
	@Test
	void contributeWhenTemplateLocationExists() {
		RuntimeHints runtimeHints = contribute(getClass().getClassLoader());
		assertThat(TEST_PREDICATE.test(runtimeHints)).isTrue();
	}
	@Test
	void contributeWhenTemplateLocationDoesNotExist() {
		FilteredClassLoader classLoader = new FilteredClassLoader(new ClassPathResource('templates'));
		RuntimeHints runtimeHints = contribute(classLoader);
		assertThat(TEST_PREDICATE.test(runtimeHints)).isFalse();
	}
	private RuntimeHints contribute(ClassLoader classLoader) {
		RuntimeHints runtimeHints = new RuntimeHints();
		new TemplateRuntimeHints().registerHints(runtimeHints, classLoader);
		return runtimeHints;
	}
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
class CouchbasePropertiesTests {
	@Test
	void ioHaveConsistentDefaults() {
		Io io = new CouchbaseProperties().getEnv().getIo();
		assertThat(io.getMinEndpoints()).isOne();
		assertThat(io.getMaxEndpoints()).isEqualTo(IoConfig.DEFAULT_MAX_HTTP_CONNECTIONS);
		assertThat(io.getIdleHttpConnectionTimeout()).isEqualTo(IoConfig.DEFAULT_IDLE_HTTP_CONNECTION_TIMEOUT);
	}
	@Test
	void timeoutsHaveConsistentDefaults() {
		Timeouts timeouts = new CouchbaseProperties().getEnv().getTimeouts();
		assertThat(timeouts.getConnect()).isEqualTo(TimeoutConfig.DEFAULT_CONNECT_TIMEOUT);
		assertThat(timeouts.getDisconnect()).isEqualTo(TimeoutConfig.DEFAULT_DISCONNECT_TIMEOUT);
		assertThat(timeouts.getKeyValue()).isEqualTo(TimeoutConfig.DEFAULT_KV_TIMEOUT);
		assertThat(timeouts.getKeyValueDurable()).isEqualTo(TimeoutConfig.DEFAULT_KV_DURABLE_TIMEOUT);
		assertThat(timeouts.getQuery()).isEqualTo(TimeoutConfig.DEFAULT_QUERY_TIMEOUT);
		assertThat(timeouts.getView()).isEqualTo(TimeoutConfig.DEFAULT_VIEW_TIMEOUT);
		assertThat(timeouts.getSearch()).isEqualTo(TimeoutConfig.DEFAULT_SEARCH_TIMEOUT);
		assertThat(timeouts.getAnalytics()).isEqualTo(TimeoutConfig.DEFAULT_ANALYTICS_TIMEOUT);
		assertThat(timeouts.getManagement()).isEqualTo(TimeoutConfig.DEFAULT_MANAGEMENT_TIMEOUT);
	}
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
class CouchbaseAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void connectionStringIsRequired() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ClusterEnvironment.class)
			.doesNotHaveBean(Authenticator.class)
			.doesNotHaveBean(Cluster.class));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
			.withPropertyValues('spring.couchbase.connection-string=localhost')
			.run((context) -> assertThat(context).hasSingleBean(PropertiesCouchbaseConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(CouchbaseConnectionDetails.class, this::couchbaseConnectionDetails)
			.run((context) -> {
				assertThat(context).hasSingleBean(ClusterEnvironment.class)
					.hasSingleBean(Cluster.class)
					.hasSingleBean(PasswordAuthenticator.class)
					.hasSingleBean(CouchbaseConnectionDetails.class)
					.doesNotHaveBean(PropertiesCouchbaseConnectionDetails.class);
				Cluster cluster = context.getBean(Cluster.class);
				assertThat(cluster.core()).extracting('connectionString.hosts')
					.asInstanceOf(InstanceOfAssertFactories.LIST)
					.extractingResultOf('host')
					.containsExactly('couchbase.example.com');
			});
	}
	@Test
	void connectionStringCreateEnvironmentAndCluster() {
		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
			.withPropertyValues('spring.couchbase.connection-string=localhost')
			.run((context) -> {
				assertThat(context).hasSingleBean(ClusterEnvironment.class)
					.hasSingleBean(Authenticator.class)
					.hasSingleBean(Cluster.class);
				assertThat(context).doesNotHaveBean('couchbaseAuthenticator');
				assertThat(context.getBean(Cluster.class))
					.isSameAs(context.getBean(CouchbaseTestConfiguration.class).couchbaseCluster());
			});
	}
	@Test
	void connectionDetailsOverridesProperties() {
		this.contextRunner.withBean(CouchbaseConnectionDetails.class, this::couchbaseConnectionDetails)
			.withPropertyValues('spring.couchbase.connection-string=localhost', 'spring.couchbase.username=a-user',
					'spring.couchbase.password=a-password')
			.run((context) -> {
				assertThat(context).hasSingleBean(ClusterEnvironment.class)
					.hasSingleBean(PasswordAuthenticator.class)
					.hasSingleBean(Cluster.class);
				Cluster cluster = context.getBean(Cluster.class);
				assertThat(cluster.core()).extracting('connectionString.hosts')
					.asInstanceOf(InstanceOfAssertFactories.LIST)
					.extractingResultOf('host')
					.containsExactly('couchbase.example.com');
			});
	}
	@Test
	void whenObjectMapperBeanIsDefinedThenClusterEnvironmentObjectMapperIsDerivedFromIt() {
		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
			.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class))
			.withPropertyValues('spring.couchbase.connection-string=localhost')
			.run((context) -> {
				ClusterEnvironment env = context.getBean(ClusterEnvironment.class);
				Set<Object> expectedModuleIds = new HashSet<>(
						context.getBean(ObjectMapper.class).getRegisteredModuleIds());
				expectedModuleIds.add(new JsonValueModule().getTypeId());
				JsonSerializer serializer = env.jsonSerializer();
				assertThat(serializer).extracting('wrapped')
					.isInstanceOf(JacksonJsonSerializer.class)
					.extracting('mapper', as(InstanceOfAssertFactories.type(ObjectMapper.class)))
					.extracting(ObjectMapper::getRegisteredModuleIds)
					.isEqualTo(expectedModuleIds);
			});
	}
	@Test
	void customizeJsonSerializer() {
		JsonSerializer customJsonSerializer = mock(JsonSerializer.class);
		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
			.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class))
			.withBean(ClusterEnvironmentBuilderCustomizer.class,
					() -> (builder) -> builder.jsonSerializer(customJsonSerializer))
			.withPropertyValues('spring.couchbase.connection-string=localhost')
			.run((context) -> {
				ClusterEnvironment env = context.getBean(ClusterEnvironment.class);
				JsonSerializer serializer = env.jsonSerializer();
				assertThat(serializer).extracting('wrapped').isSameAs(customJsonSerializer);
			});
	}
	@Test
	void customizeEnvIo() {
		testClusterEnvironment((env) -> {
			IoConfig ioConfig = env.ioConfig();
			assertThat(ioConfig.numKvConnections()).isEqualTo(2);
			assertThat(ioConfig.maxHttpConnections()).isEqualTo(5);
			assertThat(ioConfig.idleHttpConnectionTimeout()).isEqualTo(Duration.ofSeconds(3));
		}, 'spring.couchbase.env.io.min-endpoints=2', 'spring.couchbase.env.io.max-endpoints=5',
				'spring.couchbase.env.io.idle-http-connection-timeout=3s');
	}
	@Test
	void customizeEnvTimeouts() {
		testClusterEnvironment((env) -> {
			TimeoutConfig timeoutConfig = env.timeoutConfig();
			assertThat(timeoutConfig.connectTimeout()).isEqualTo(Duration.ofSeconds(1));
			assertThat(timeoutConfig.disconnectTimeout()).isEqualTo(Duration.ofSeconds(2));
			assertThat(timeoutConfig.kvTimeout()).isEqualTo(Duration.ofMillis(500));
			assertThat(timeoutConfig.kvDurableTimeout()).isEqualTo(Duration.ofMillis(750));
			assertThat(timeoutConfig.queryTimeout()).isEqualTo(Duration.ofSeconds(3));
			assertThat(timeoutConfig.viewTimeout()).isEqualTo(Duration.ofSeconds(4));
			assertThat(timeoutConfig.searchTimeout()).isEqualTo(Duration.ofSeconds(5));
			assertThat(timeoutConfig.analyticsTimeout()).isEqualTo(Duration.ofSeconds(6));
			assertThat(timeoutConfig.managementTimeout()).isEqualTo(Duration.ofSeconds(7));
		}, 'spring.couchbase.env.timeouts.connect=1s', 'spring.couchbase.env.timeouts.disconnect=2s',
				'spring.couchbase.env.timeouts.key-value=500ms',
				'spring.couchbase.env.timeouts.key-value-durable=750ms', 'spring.couchbase.env.timeouts.query=3s',
				'spring.couchbase.env.timeouts.view=4s', 'spring.couchbase.env.timeouts.search=5s',
				'spring.couchbase.env.timeouts.analytics=6s', 'spring.couchbase.env.timeouts.management=7s');
	}
	@Test
	void enableSsl() {
		testClusterEnvironment((env) -> {
			SecurityConfig securityConfig = env.securityConfig();
			assertThat(securityConfig.tlsEnabled()).isTrue();
			assertThat(securityConfig.trustManagerFactory()).isNull();
		}, 'spring.couchbase.env.ssl.enabled=true');
	}
	@Test
	void enableSslWithBundle() {
		testClusterEnvironment((env) -> {
			SecurityConfig securityConfig = env.securityConfig();
			assertThat(securityConfig.tlsEnabled()).isTrue();
			assertThat(securityConfig.trustManagerFactory()).isNotNull();
		}, 'spring.ssl.bundle.jks.test-bundle.keystore.location=classpath:test.jks',
				'spring.ssl.bundle.jks.test-bundle.keystore.password=secret',
				'spring.couchbase.env.ssl.bundle=test-bundle');
	}
	@Test
	void enableSslWithInvalidBundle() {
		this.contextRunner
			.withPropertyValues('spring.couchbase.connection-string=localhost',
					'spring.couchbase.env.ssl.bundle=test-bundle')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).rootCause()
					.isInstanceOf(NoSuchSslBundleException.class)
					.hasMessageContaining('test-bundle');
			});
	}
	@Test
	void disableSslEvenWithBundle() {
		testClusterEnvironment((env) -> {
			SecurityConfig securityConfig = env.securityConfig();
			assertThat(securityConfig.tlsEnabled()).isFalse();
			assertThat(securityConfig.trustManagerFactory()).isNull();
		}, 'spring.couchbase.env.ssl.enabled=false', 'spring.couchbase.env.ssl.bundle=test-bundle');
	}
	private void testClusterEnvironment(Consumer<ClusterEnvironment> environmentConsumer, String... environment) {
		this.contextRunner.withUserConfiguration(CouchbaseTestConfiguration.class)
			.withPropertyValues('spring.couchbase.connection-string=localhost')
			.withPropertyValues(environment)
			.run((context) -> environmentConsumer.accept(context.getBean(ClusterEnvironment.class)));
	}
	@Test
	void customizeEnvWithCustomCouchbaseConfiguration() {
		this.contextRunner
			.withUserConfiguration(CouchbaseTestConfiguration.class, ClusterEnvironmentCustomizerConfiguration.class)
			.withPropertyValues('spring.couchbase.connection-string=localhost',
					'spring.couchbase.env.timeouts.connect=100')
			.run((context) -> {
				assertThat(context).hasSingleBean(ClusterEnvironment.class);
				ClusterEnvironment env = context.getBean(ClusterEnvironment.class);
				assertThat(env.timeoutConfig().kvTimeout()).isEqualTo(Duration.ofSeconds(5));
				assertThat(env.timeoutConfig().connectTimeout()).isEqualTo(Duration.ofSeconds(2));
			});
	}
	@Test
	void passwordAuthenticationWithUsernameAndPassword() {
		this.contextRunner
			.withPropertyValues('spring.couchbase.connection-string=localhost', 'spring.couchbase.username=user',
					'spring.couchbase.password=secret')
			.run((context) -> assertThat(context).hasSingleBean(PasswordAuthenticator.class));
	}
	@Test
	void certificateAuthenticationWithPemPrivateKeyAndCertificate() {
		this.contextRunner.withPropertyValues('spring.couchbase.connection-string=localhost',
				'spring.couchbase.env.ssl.enabled=true',
				'spring.couchbase.authentication.pem.private-key=classpath:org/springframework/boot/autoconfigure/ssl/key2.pem',
				'spring.couchbase.authentication.pem.certificates=classpath:org/springframework/boot/autoconfigure/ssl/key2.crt')
			.run((context) -> assertThat(context).hasSingleBean(CertificateAuthenticator.class));
	}
	@Test
	void certificateAuthenticationWithJavaKeyStore() {
		this.contextRunner.withPropertyValues('spring.couchbase.connection-string=localhost',
				'spring.couchbase.env.ssl.enabled=true',
				'spring.couchbase.authentication.jks.location=classpath:org/springframework/boot/autoconfigure/ssl/keystore.jks',
				'spring.couchbase.authentication.jks.password=secret')
			.run((context) -> assertThat(context).hasSingleBean(CertificateAuthenticator.class));
	}
	@Test
	void failsWithMissingAuthentication() {
		this.contextRunner.withPropertyValues('spring.couchbase.connection-string=localhost').run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context).getFailure()
				.hasMessageContaining('Couchbase authentication requires username and password, or certificates');
		});
	}
	private CouchbaseConnectionDetails couchbaseConnectionDetails() {
		return new CouchbaseConnectionDetails() {
			@Override
			public String getConnectionString() {
				return 'couchbase.example.com';
			}
			@Override
			public String getUsername() {
				return 'user-1';
			}
			@Override
			public String getPassword() {
				return 'password-1';
			}
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class ClusterEnvironmentCustomizerConfiguration {
		@Bean
		ClusterEnvironmentBuilderCustomizer clusterEnvironmentBuilderCustomizer() {
			return (builder) -> builder.timeoutConfig()
				.kvTimeout(Duration.ofSeconds(5))
				.connectTimeout(Duration.ofSeconds(2));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
@Configuration(proxyBeanMethods = false)
class CouchbaseTestConfiguration {
	private final Cluster cluster = mock(Cluster.class);
	private final Authenticator authenticator = mock(Authenticator.class);
	@Bean
	Cluster couchbaseCluster() {
		return this.cluster;
	}
	@Bean
	Authenticator couchbaseAuth() {
		return this.authenticator;
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
class SessionAutoConfigurationEarlyInitializationIntegrationTests {
	@Test
	void configurationIsFrozenWhenSessionRepositoryAccessed() {
		new WebApplicationContextRunner(AnnotationConfigServletWebServerApplicationContext::new)
			.withSystemProperties('spring.jndi.ignore=true')
			.withPropertyValues('server.port=0')
			.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(MapSessionRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	@ImportAutoConfiguration({ ServletWebServerFactoryAutoConfiguration.class, SessionAutoConfiguration.class })
	static class TestConfiguration {
		@Bean
		MapSessionRepository mapSessionRepository(ConfigurableApplicationContext context) {
			Assert.isTrue(context.getBeanFactory().isConfigurationFrozen(), 'Context should be frozen');
			return new MapSessionRepository(new LinkedHashMap<>());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@ClassPathExclusions('spring-security-*')
class SessionAutoConfigurationWithoutSecurityTests extends AbstractSessionAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SessionAutoConfiguration.class));
	@Test
	void sessionCookieConfigurationIsAppliedToAutoConfiguredCookieSerializer() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).run((context) -> {
			DefaultCookieSerializer cookieSerializer = context.getBean(DefaultCookieSerializer.class);
			assertThat(cookieSerializer).hasFieldOrPropertyWithValue('rememberMeRequestAttribute', null);
		});
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
class SessionAutoConfigurationTests extends AbstractSessionAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SessionAutoConfiguration.class));
	@Test
	void autoConfigurationDisabledIfNoImplementationMatches() {
		this.contextRunner
			.withClassLoader(new FilteredClassLoader(RedisIndexedSessionRepository.class,
					HazelcastIndexedSessionRepository.class, JdbcIndexedSessionRepository.class,
					MongoIndexedSessionRepository.class))
			.run((context) -> assertThat(context).doesNotHaveBean(SessionRepository.class));
	}
	@Test
	void backOffIfSessionRepositoryIsPresent() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).run((context) -> {
			MapSessionRepository repository = validateSessionRepository(context, MapSessionRepository.class);
			assertThat(context).getBean('mySessionRepository').isSameAs(repository);
		});
	}
	@Test
	void backOffIfReactiveSessionRepositoryIsPresent() {
		ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(SessionAutoConfiguration.class));
		contextRunner.withUserConfiguration(ReactiveSessionRepositoryConfiguration.class).run((context) -> {
			ReactiveMapSessionRepository repository = validateSessionRepository(context,
					ReactiveMapSessionRepository.class);
			assertThat(context).getBean('mySessionRepository').isSameAs(repository);
		});
	}
	@Test
	void filterIsRegisteredWithAsyncErrorAndRequestDispatcherTypes() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).run((context) -> {
			AbstractFilterRegistrationBean<?> registration = context.getBean(AbstractFilterRegistrationBean.class);
			DelegatingFilterProxy delegatingFilterProxy = (DelegatingFilterProxy) registration.getFilter();
			try {
				// Trigger actual initialization
				delegatingFilterProxy.doFilter(null, null, null);
			}
			catch (Exception ex) {
				// Ignore
			}
			assertThat(delegatingFilterProxy).extracting('delegate')
				.isSameAs(context.getBean(SessionRepositoryFilter.class));
			assertThat(registration)
				.extracting('dispatcherTypes', InstanceOfAssertFactories.iterable(DispatcherType.class))
				.containsOnly(DispatcherType.ASYNC, DispatcherType.ERROR, DispatcherType.REQUEST);
		});
	}
	@Test
	void filterOrderCanBeCustomizedWithCustomStore() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class)
			.withPropertyValues('spring.session.servlet.filter-order=123')
			.run((context) -> {
				AbstractFilterRegistrationBean<?> registration = context.getBean(AbstractFilterRegistrationBean.class);
				assertThat(registration.getOrder()).isEqualTo(123);
			});
	}
	@Test
	void filterDispatcherTypesCanBeCustomized() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class)
			.withPropertyValues('spring.session.servlet.filter-dispatcher-types=error, request')
			.run((context) -> {
				AbstractFilterRegistrationBean<?> registration = context.getBean(AbstractFilterRegistrationBean.class);
				assertThat(registration)
					.extracting('dispatcherTypes', InstanceOfAssertFactories.iterable(DispatcherType.class))
					.containsOnly(DispatcherType.ERROR, DispatcherType.REQUEST);
			});
	}
	@Test
	void emptyFilterDispatcherTypesDoNotThrowException() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class)
			.withPropertyValues('spring.session.servlet.filter-dispatcher-types=')
			.run((context) -> {
				AbstractFilterRegistrationBean<?> registration = context.getBean(AbstractFilterRegistrationBean.class);
				assertThat(registration)
					.extracting('dispatcherTypes', InstanceOfAssertFactories.iterable(DispatcherType.class))
					.isEmpty();
			});
	}
	@Test
	void sessionCookieConfigurationIsAppliedToAutoConfiguredCookieSerializer() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class)
			.withPropertyValues('server.servlet.session.cookie.name=sid', 'server.servlet.session.cookie.domain=spring',
					'server.servlet.session.cookie.path=/test', 'server.servlet.session.cookie.httpOnly=false',
					'server.servlet.session.cookie.secure=false', 'server.servlet.session.cookie.maxAge=10s',
					'server.servlet.session.cookie.sameSite=strict', 'server.servlet.session.cookie.partitioned=true')
			.run((context) -> {
				DefaultCookieSerializer cookieSerializer = context.getBean(DefaultCookieSerializer.class);
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('cookieName', 'sid');
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('domainName', 'spring');
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('cookiePath', '/test');
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('useHttpOnlyCookie', false);
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('useSecureCookie', false);
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('cookieMaxAge', 10);
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('sameSite', 'Strict');
				assertThat(cookieSerializer).hasFieldOrPropertyWithValue('partitioned', true);
			});
	}
	@Test
	void autoConfiguredCookieSerializerIsUsedBySessionRepositoryFilter() {
		this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class)
			.withPropertyValues('server.port=0')
			.run((context) -> {
				SessionRepositoryFilter<?> filter = context.getBean(SessionRepositoryFilter.class);
				assertThat(filter).extracting('httpSessionIdResolver.cookieSerializer')
					.isSameAs(context.getBean(DefaultCookieSerializer.class));
			});
	}
	@Test
	void autoConfiguredCookieSerializerBacksOffWhenUserConfiguresACookieSerializer() {
		this.contextRunner.withUserConfiguration(UserProvidedCookieSerializerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(DefaultCookieSerializer.class);
			assertThat(context).hasBean('myCookieSerializer');
		});
	}
	@Test
	void cookiesSerializerIsAutoConfiguredWhenUserConfiguresCookieHttpSessionIdResolver() {
		this.contextRunner.withUserConfiguration(UserProvidedCookieHttpSessionStrategyConfiguration.class)
			.run((context) -> assertThat(context.getBeansOfType(DefaultCookieSerializer.class)).isNotEmpty());
	}
	@Test
	void autoConfiguredCookieSerializerBacksOffWhenUserConfiguresHeaderHttpSessionIdResolver() {
		this.contextRunner.withUserConfiguration(UserProvidedHeaderHttpSessionStrategyConfiguration.class)
			.run((context) -> assertThat(context.getBeansOfType(DefaultCookieSerializer.class)).isEmpty());
	}
	@Test
	void autoConfiguredCookieSerializerBacksOffWhenUserConfiguresCustomHttpSessionIdResolver() {
		this.contextRunner.withUserConfiguration(UserProvidedCustomHttpSessionStrategyConfiguration.class)
			.run((context) -> assertThat(context.getBeansOfType(DefaultCookieSerializer.class)).isEmpty());
	}
	@Test
	void autoConfiguredCookieSerializerIsConfiguredWithRememberMeRequestAttribute() {
		this.contextRunner.withBean(SpringSessionRememberMeServicesConfiguration.class).run((context) -> {
			DefaultCookieSerializer cookieSerializer = context.getBean(DefaultCookieSerializer.class);
			assertThat(cookieSerializer).hasFieldOrPropertyWithValue('rememberMeRequestAttribute',
					SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR);
		});
	}
	@Test
	void cookieSerializerCustomization() {
		this.contextRunner.withBean(CookieSerializerCustomization.class).run((context) -> {
			CookieSerializerCustomization customization = context.getBean(CookieSerializerCustomization.class);
			InOrder inOrder = inOrder(customization.customizer1, customization.customizer2);
			inOrder.verify(customization.customizer1).customize(any());
			inOrder.verify(customization.customizer2).customize(any());
		});
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class SessionRepositoryConfiguration {
		@Bean
		MapSessionRepository mySessionRepository() {
			return new MapSessionRepository(Collections.emptyMap());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringWebSession
	static class ReactiveSessionRepositoryConfiguration {
		@Bean
		ReactiveMapSessionRepository mySessionRepository() {
			return new ReactiveMapSessionRepository(Collections.emptyMap());
		}
	}
	@EnableConfigurationProperties(ServerProperties.class)
	static class ServerPropertiesConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class UserProvidedCookieSerializerConfiguration extends SessionRepositoryConfiguration {
		@Bean
		DefaultCookieSerializer myCookieSerializer() {
			return new DefaultCookieSerializer();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class UserProvidedCookieHttpSessionStrategyConfiguration extends SessionRepositoryConfiguration {
		@Bean
		CookieHttpSessionIdResolver httpSessionStrategy() {
			return new CookieHttpSessionIdResolver();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class UserProvidedHeaderHttpSessionStrategyConfiguration extends SessionRepositoryConfiguration {
		@Bean
		HeaderHttpSessionIdResolver httpSessionStrategy() {
			return HeaderHttpSessionIdResolver.xAuthToken();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class UserProvidedCustomHttpSessionStrategyConfiguration extends SessionRepositoryConfiguration {
		@Bean
		HttpSessionIdResolver httpSessionStrategy() {
			return mock(HttpSessionIdResolver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class SpringSessionRememberMeServicesConfiguration extends SessionRepositoryConfiguration {
		@Bean
		SpringSessionRememberMeServices rememberMeServices() {
			return new SpringSessionRememberMeServices();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableSpringHttpSession
	static class CookieSerializerCustomization extends SessionRepositoryConfiguration {
		private final DefaultCookieSerializerCustomizer customizer1 = mock(DefaultCookieSerializerCustomizer.class);
		private final DefaultCookieSerializerCustomizer customizer2 = mock(DefaultCookieSerializerCustomizer.class);
		@Bean
		@Order(1)
		DefaultCookieSerializerCustomizer customizer1() {
			return this.customizer1;
		}
		@Bean
		@Order(2)
		DefaultCookieSerializerCustomizer customizer2() {
			return this.customizer2;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
class SessionAutoConfigurationHazelcastTests extends AbstractSessionAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader(JdbcIndexedSessionRepository.class,
				RedisIndexedSessionRepository.class, MongoIndexedSessionRepository.class))
		.withConfiguration(AutoConfigurations.of(SessionAutoConfiguration.class))
		.withUserConfiguration(HazelcastConfiguration.class);
	@Test
	void defaultConfig() {
		this.contextRunner.run(this::validateDefaultConfig);
	}
	@Test
	void hazelcastTakesPrecedenceOverMongo() {
		this.contextRunner
			.withClassLoader(
					new FilteredClassLoader(RedisIndexedSessionRepository.class, JdbcIndexedSessionRepository.class))
			.run(this::validateDefaultConfig);
	}
	@Test
	void defaultConfigWithCustomTimeout() {
		this.contextRunner.withPropertyValues('spring.session.timeout=1m').run((context) -> {
			HazelcastIndexedSessionRepository repository = validateSessionRepository(context,
					HazelcastIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', Duration.ofMinutes(1));
		});
	}
	private void validateDefaultConfig(AssertableWebApplicationContext context) {
		HazelcastIndexedSessionRepository repository = validateSessionRepository(context,
				HazelcastIndexedSessionRepository.class);
		assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval',
				new ServerProperties().getServlet().getSession().getTimeout());
		HazelcastInstance hazelcastInstance = context.getBean(HazelcastInstance.class);
		then(hazelcastInstance).should().getMap('spring:session:sessions');
	}
	@Test
	void customMapName() {
		this.contextRunner.withPropertyValues('spring.session.hazelcast.map-name=foo:bar:biz').run((context) -> {
			validateSessionRepository(context, HazelcastIndexedSessionRepository.class);
			HazelcastInstance hazelcastInstance = context.getBean(HazelcastInstance.class);
			then(hazelcastInstance).should().getMap('foo:bar:biz');
		});
	}
	@Test
	void customFlushMode() {
		this.contextRunner.withPropertyValues('spring.session.hazelcast.flush-mode=immediate').run((context) -> {
			HazelcastIndexedSessionRepository repository = validateSessionRepository(context,
					HazelcastIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('flushMode', FlushMode.IMMEDIATE);
		});
	}
	@Test
	void customSaveMode() {
		this.contextRunner.withPropertyValues('spring.session.hazelcast.save-mode=on-get-attribute').run((context) -> {
			HazelcastIndexedSessionRepository repository = validateSessionRepository(context,
					HazelcastIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('saveMode', SaveMode.ON_GET_ATTRIBUTE);
		});
	}
	@Test
	void whenTheUserDefinesTheirOwnSessionRepositoryCustomizerThenDefaultConfigurationIsOverwritten() {
		this.contextRunner.withUserConfiguration(CustomizerConfiguration.class)
			.withPropertyValues('spring.session.hazelcast.save-mode=on-get-attribute')
			.run((context) -> {
				HazelcastIndexedSessionRepository repository = validateSessionRepository(context,
						HazelcastIndexedSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('saveMode', SaveMode.ALWAYS);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastConfiguration {
		@Bean
		@SuppressWarnings('unchecked')
		HazelcastInstance hazelcastInstance() {
			IMap<Object, Object> map = mock(IMap.class);
			HazelcastInstance mock = mock(HazelcastInstance.class);
			given(mock.getMap('spring:session:sessions')).willReturn(map);
			given(mock.getMap('foo:bar:biz')).willReturn(map);
			return mock;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		SessionRepositoryCustomizer<HazelcastIndexedSessionRepository> sessionRepositoryCustomizer() {
			return (repository) -> repository.setSaveMode(SaveMode.ALWAYS);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
class JdbcSessionDataSourceScriptDatabaseInitializerTests {
	@Test
	void getSettingsWithPlatformDoesNotTouchDataSource() {
		DataSource dataSource = mock(DataSource.class);
		JdbcSessionProperties properties = new JdbcSessionProperties();
		properties.setPlatform('test');
		DatabaseInitializationSettings settings = JdbcSessionDataSourceScriptDatabaseInitializer.getSettings(dataSource,
				properties);
		assertThat(settings.getSchemaLocations())
			.containsOnly('classpath:org/springframework/session/jdbc/schema-test.sql');
		then(dataSource).shouldHaveNoInteractions();
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
class SessionPropertiesTests {
	@Test
	@SuppressWarnings('unchecked')
	void determineTimeoutWithTimeoutIgnoreFallback() {
		SessionProperties properties = new SessionProperties();
		properties.setTimeout(Duration.ofMinutes(1));
		Supplier<Duration> fallback = mock(Supplier.class);
		assertThat(properties.determineTimeout(fallback)).isEqualTo(Duration.ofMinutes(1));
		then(fallback).shouldHaveNoInteractions();
	}
	@Test
	void determineTimeoutWithNoTimeoutUseFallback() {
		SessionProperties properties = new SessionProperties();
		properties.setTimeout(null);
		Duration fallback = Duration.ofMinutes(2);
		assertThat(properties.determineTimeout(() -> fallback)).isSameAs(fallback);
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
class SessionAutoConfigurationJdbcTests extends AbstractSessionAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withClassLoader(new FilteredClassLoader(HazelcastIndexedSessionRepository.class,
				MongoIndexedSessionRepository.class, RedisIndexedSessionRepository.class))
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
				DataSourceTransactionManagerAutoConfiguration.class, JdbcTemplateAutoConfiguration.class,
				SessionAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void defaultConfig() {
		this.contextRunner.run(this::validateDefaultConfig);
	}
	@Test
	void jdbcTakesPrecedenceOverMongoAndHazelcast() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(RedisIndexedSessionRepository.class))
			.run(this::validateDefaultConfig);
	}
	private void validateDefaultConfig(AssertableWebApplicationContext context) {
		JdbcIndexedSessionRepository repository = validateSessionRepository(context,
				JdbcIndexedSessionRepository.class);
		assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval',
				new ServerProperties().getServlet().getSession().getTimeout());
		assertThat(repository).hasFieldOrPropertyWithValue('tableName', 'SPRING_SESSION');
		assertThat(repository).hasFieldOrPropertyWithValue('cleanupCron', '0 * * * * *');
		assertThat(context.getBean(JdbcSessionProperties.class).getInitializeSchema())
			.isEqualTo(DatabaseInitializationMode.EMBEDDED);
		assertThat(context.getBean(JdbcOperations.class).queryForList('select * from SPRING_SESSION')).isEmpty();
	}
	@Test
	void filterOrderCanBeCustomized() {
		this.contextRunner.withPropertyValues('spring.session.servlet.filter-order=123').run((context) -> {
			AbstractFilterRegistrationBean<?> registration = context.getBean(AbstractFilterRegistrationBean.class);
			assertThat(registration.getOrder()).isEqualTo(123);
		});
	}
	@Test
	void disableDataSourceInitializer() {
		this.contextRunner.withPropertyValues('spring.session.jdbc.initialize-schema=never').run((context) -> {
			assertThat(context).doesNotHaveBean(JdbcSessionDataSourceScriptDatabaseInitializer.class);
			JdbcIndexedSessionRepository repository = validateSessionRepository(context,
					JdbcIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('tableName', 'SPRING_SESSION');
			assertThat(context.getBean(JdbcSessionProperties.class).getInitializeSchema())
				.isEqualTo(DatabaseInitializationMode.NEVER);
			assertThatExceptionOfType(BadSqlGrammarException.class)
				.isThrownBy(() -> context.getBean(JdbcOperations.class).queryForList('select * from SPRING_SESSION'));
		});
	}
	@Test
	void customTimeout() {
		this.contextRunner.withPropertyValues('spring.session.timeout=1m').run((context) -> {
			JdbcIndexedSessionRepository repository = validateSessionRepository(context,
					JdbcIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('defaultMaxInactiveInterval', Duration.ofMinutes(1));
		});
	}
	@Test
	void customTableName() {
		this.contextRunner
			.withPropertyValues('spring.session.jdbc.table-name=FOO_BAR',
					'spring.session.jdbc.schema=classpath:session/custom-schema-h2.sql')
			.run((context) -> {
				JdbcIndexedSessionRepository repository = validateSessionRepository(context,
						JdbcIndexedSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('tableName', 'FOO_BAR');
				assertThat(context.getBean(JdbcSessionProperties.class).getInitializeSchema())
					.isEqualTo(DatabaseInitializationMode.EMBEDDED);
				assertThat(context.getBean(JdbcOperations.class).queryForList('select * from FOO_BAR')).isEmpty();
			});
	}
	@Test
	void customCleanupCron() {
		this.contextRunner.withPropertyValues('spring.session.jdbc.cleanup-cron=0 0 12 * * *').run((context) -> {
			assertThat(context.getBean(JdbcSessionProperties.class).getCleanupCron()).isEqualTo('0 0 12 * * *');
			JdbcIndexedSessionRepository repository = validateSessionRepository(context,
					JdbcIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('cleanupCron', '0 0 12 * * *');
		});
	}
	@Test
	void customFlushMode() {
		this.contextRunner.withPropertyValues('spring.session.jdbc.flush-mode=immediate').run((context) -> {
			JdbcIndexedSessionRepository repository = validateSessionRepository(context,
					JdbcIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('flushMode', FlushMode.IMMEDIATE);
		});
	}
	@Test
	void customSaveMode() {
		this.contextRunner.withPropertyValues('spring.session.jdbc.save-mode=on-get-attribute').run((context) -> {
			JdbcIndexedSessionRepository repository = validateSessionRepository(context,
					JdbcIndexedSessionRepository.class);
			assertThat(repository).hasFieldOrPropertyWithValue('saveMode', SaveMode.ON_GET_ATTRIBUTE);
		});
	}
	@Test
	void sessionDataSourceIsUsedWhenAvailable() {
		this.contextRunner.withUserConfiguration(SessionDataSourceConfiguration.class).run((context) -> {
			JdbcIndexedSessionRepository repository = validateSessionRepository(context,
					JdbcIndexedSessionRepository.class);
			DataSource sessionDataSource = context.getBean('sessionDataSource', DataSource.class);
			assertThat(repository).extracting('jdbcOperations.dataSource').isEqualTo(sessionDataSource);
			assertThat(context.getBean(JdbcSessionDataSourceScriptDatabaseInitializer.class))
				.hasFieldOrPropertyWithValue('dataSource', sessionDataSource);
			assertThatExceptionOfType(BadSqlGrammarException.class)
				.isThrownBy(() -> context.getBean(JdbcOperations.class).queryForList('select * from SPRING_SESSION'));
		});
	}
	@Test
	void sessionRepositoryBeansDependOnJdbcSessionDataSourceInitializer() {
		this.contextRunner.run((context) -> {
			ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
			String[] sessionRepositoryNames = beanFactory.getBeanNamesForType(JdbcIndexedSessionRepository.class);
			assertThat(sessionRepositoryNames).isNotEmpty();
			for (String sessionRepositoryName : sessionRepositoryNames) {
				assertThat(beanFactory.getBeanDefinition(sessionRepositoryName).getDependsOn())
					.contains('jdbcSessionDataSourceScriptDatabaseInitializer');
			}
		});
	}
	@Test
	void sessionRepositoryBeansDependOnFlyway() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
			.withPropertyValues('spring.session.jdbc.initialize-schema=never')
			.run((context) -> {
				ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
				String[] sessionRepositoryNames = beanFactory.getBeanNamesForType(JdbcIndexedSessionRepository.class);
				assertThat(sessionRepositoryNames).isNotEmpty();
				for (String sessionRepositoryName : sessionRepositoryNames) {
					assertThat(beanFactory.getBeanDefinition(sessionRepositoryName).getDependsOn()).contains('flyway',
							'flywayInitializer');
				}
			});
	}
	@Test
	void sessionRepositoryBeansDependOnLiquibase() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class))
			.withPropertyValues('spring.session.jdbc.initialize-schema=never')
			.run((context) -> {
				ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
				String[] sessionRepositoryNames = beanFactory.getBeanNamesForType(JdbcIndexedSessionRepository.class);
				assertThat(sessionRepositoryNames).isNotEmpty();
				for (String sessionRepositoryName : sessionRepositoryNames) {
					assertThat(beanFactory.getBeanDefinition(sessionRepositoryName).getDependsOn())
						.contains('liquibase');
				}
			});
	}
	@Test
	void whenTheUserDefinesTheirOwnJdbcSessionDatabaseInitializerThenTheAutoConfiguredInitializerBacksOff() {
		this.contextRunner.withUserConfiguration(CustomJdbcSessionDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(JdbcSessionDataSourceScriptDatabaseInitializer.class)
				.doesNotHaveBean('jdbcSessionDataSourceScriptDatabaseInitializer')
				.hasBean('customInitializer'));
	}
	@Test
	void whenTheUserDefinesTheirOwnDatabaseInitializerThenTheAutoConfiguredJdbcSessionInitializerRemains() {
		this.contextRunner.withUserConfiguration(CustomDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(JdbcSessionDataSourceScriptDatabaseInitializer.class)
				.hasBean('customInitializer'));
	}
	@Test
	void whenTheUserDefinesTheirOwnJdbcIndexedSessionRepositoryCustomizerThenDefaultConfigurationIsOverwritten() {
		String expectedCreateSessionAttributeQuery = '''
				INSERT INTO SPRING_SESSION_ATTRIBUTES (SESSION_PRIMARY_ID, ATTRIBUTE_NAME, ATTRIBUTE_BYTES)
				VALUES (?, ?, ?)
				ON CONFLICT (SESSION_PRIMARY_ID, ATTRIBUTE_NAME)
				DO UPDATE SET ATTRIBUTE_BYTES = EXCLUDED.ATTRIBUTE_BYTES
				''';
		this.contextRunner.withUserConfiguration(CustomJdbcIndexedSessionRepositoryCustomizerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(JdbcSessionConfiguration.class))
			.run((context) -> {
				JdbcIndexedSessionRepository repository = validateSessionRepository(context,
						JdbcIndexedSessionRepository.class);
				assertThat(repository).hasFieldOrPropertyWithValue('createSessionAttributeQuery',
						expectedCreateSessionAttributeQuery);
			});
	}
	@Configuration
	static class SessionDataSourceConfiguration {
		@Bean
		@SpringSessionDataSource
		DataSource sessionDataSource() {
			BasicDataSource dataSource = new BasicDataSource();
			dataSource.setDriverClassName('org.hsqldb.jdbcDriver');
			dataSource.setUrl('jdbc:hsqldb:mem:sessiondb');
			dataSource.setUsername('sa');
			return dataSource;
		}
		@Bean
		@Primary
		DataSource mainDataSource() {
			BasicDataSource dataSource = new BasicDataSource();
			dataSource.setDriverClassName('org.hsqldb.jdbcDriver');
			dataSource.setUrl('jdbc:hsqldb:mem:maindb');
			dataSource.setUsername('sa');
			return dataSource;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJdbcSessionDatabaseInitializerConfiguration {
		@Bean
		JdbcSessionDataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource,
				JdbcSessionProperties properties) {
			return new JdbcSessionDataSourceScriptDatabaseInitializer(dataSource, properties);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDatabaseInitializerConfiguration {
		@Bean
		DataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource) {
			return new DataSourceScriptDatabaseInitializer(dataSource, new DatabaseInitializationSettings());
		}
	}
	@Configuration
	static class CustomJdbcIndexedSessionRepositoryCustomizerConfiguration {
		@Bean
		PostgreSqlJdbcIndexedSessionRepositoryCustomizer postgreSqlJdbcIndexedSessionRepositoryCustomizer() {
			return new PostgreSqlJdbcIndexedSessionRepositoryCustomizer();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
public abstract class AbstractSessionAutoConfigurationTests {
	private static final MockReactiveWebServerFactory mockReactiveWebServerFactory = new MockReactiveWebServerFactory();
	protected ContextConsumer<ReactiveWebApplicationContext> assertExchangeWithSession(
			Consumer<MockServerWebExchange> exchange) {
		return (context) -> {
			MockServerHttpRequest request = MockServerHttpRequest.get('/').build();
			MockServerWebExchange webExchange = MockServerWebExchange.from(request);
			WebSessionManager webSessionManager = context.getBean(WebSessionManager.class);
			WebSession webSession = webSessionManager.getSession(webExchange).block();
			webSession.start();
			webExchange.getResponse().setComplete().block();
			exchange.accept(webExchange);
		};
	}
	protected <T extends SessionRepository<?>> T validateSessionRepository(AssertableWebApplicationContext context,
			Class<T> type) {
		assertThat(context).hasSingleBean(SessionRepositoryFilter.class);
		assertThat(context).hasSingleBean(SessionRepository.class);
		SessionRepository<?> repository = context.getBean(SessionRepository.class);
		assertThat(repository).as('Wrong session repository type').isInstanceOf(type);
		return type.cast(repository);
	}
	protected <T extends ReactiveSessionRepository<?>> T validateSessionRepository(
			AssertableReactiveWebApplicationContext context, Class<T> type) {
		assertThat(context).hasSingleBean(WebSessionManager.class);
		assertThat(context).hasSingleBean(ReactiveSessionRepository.class);
		ReactiveSessionRepository<?> repository = context.getBean(ReactiveSessionRepository.class);
		assertThat(repository).as('Wrong session repository type').isInstanceOf(type);
		return type.cast(repository);
	}
	@Configuration
	@EnableSpringHttpSession
	static class SessionRepositoryConfiguration {
		@Bean
		MapSessionRepository mySessionRepository() {
			return new MapSessionRepository(Collections.emptyMap());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
		@Bean
		MockReactiveWebServerFactory mockReactiveWebServerFactory() {
			return mockReactiveWebServerFactory;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = 'spring.jackson.default-property-inclusion=non_null')
@DirtiesContext
class JerseyAutoConfigurationCustomObjectMapperProviderTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> response = this.restTemplate.getForEntity('/rest/message', String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat('{\'subject\':\'Jersey\'}').isEqualTo(response.getBody());
	}
	@MinimalWebConfiguration
	@ApplicationPath('/rest')
	@Path('/message')
	public static class Application extends ResourceConfig {
		Application() {
			register(Application.class);
		}
		@GET
		public Message message() {
			return new Message('Jersey', null);
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	public static class Message {
		private String subject;
		private String body;
		Message(String subject, String body) {
			this.subject = subject;
			this.body = body;
		}
		public String getSubject() {
			return this.subject;
		}
		public void setSubject(String subject) {
			this.subject = subject;
		}
		public String getBody() {
			return this.body;
		}
		public void setBody(String body) {
			this.body = body;
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JacksonAutoConfiguration.class,
			JerseyAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'spring.jersey.type=filter', 'server.servlet.register-default-servlet=true' })
@DirtiesContext
class JerseyAutoConfigurationDefaultFilterPathTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@MinimalWebConfiguration
	@Path('/hello')
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(classes = Application.class, webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
@ExtendWith(OutputCaptureExtension.class)
class JerseyAutoConfigurationServletContainerTests {
	@Test
	void existingJerseyServletIsAmended(CapturedOutput output) {
		assertThat(output).contains('Configuring existing registration for Jersey servlet');
		assertThat(output).contains('Servlet ' + Application.class.getName() + ' was not registered');
	}
	@ImportAutoConfiguration({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	@Import(ContainerConfiguration.class)
	@Path('/hello')
	@Configuration(proxyBeanMethods = false)
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ContainerConfiguration {
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory() {
				@Override
				protected void postProcessContext(Context context) {
					Wrapper jerseyServlet = context.createWrapper();
					String servletName = Application.class.getName();
					jerseyServlet.setName(servletName);
					jerseyServlet.setServletClass(ServletContainer.class.getName());
					jerseyServlet.setServlet(new ServletContainer());
					jerseyServlet.setOverridable(false);
					context.addChild(jerseyServlet);
					String pattern = UDecoder.URLDecode('/*', StandardCharsets.UTF_8);
					context.addServletMappingDecoded(pattern, servletName);
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
class JerseyAutoConfigurationCustomServletPathTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/rest/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@MinimalWebConfiguration
	@ApplicationPath('/rest')
	@Path('/hello')
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.jersey.servlet.load-on-startup=5')
@DirtiesContext
class JerseyAutoConfigurationCustomLoadOnStartupTests {
	@Autowired
	private ApplicationContext context;
	@Test
	void contextLoads() {
		assertThat(this.context.getBean('jerseyServletRegistration')).hasFieldOrPropertyWithValue('loadOnStartup', 5);
	}
	@MinimalWebConfiguration
	static class Application extends ResourceConfig {
		Application() {
			register(Application.class);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'spring.jersey.type=filter', 'server.servlet.register-default-servlet=true' })
@DirtiesContext
class JerseyAutoConfigurationCustomFilterPathTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/rest/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@MinimalWebConfiguration
	@ApplicationPath('rest')
	@Path('/hello')
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'server.servlet.contextPath=/app')
@DirtiesContext
class JerseyAutoConfigurationCustomServletContextPathTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/rest/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@MinimalWebConfiguration
	@ApplicationPath('/rest')
	@Path('/hello')
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = { 'spring.jersey.type=filter', 'server.servlet.context-path=/app',
				'server.servlet.register-default-servlet=true' })
@DirtiesContext
class JerseyAutoConfigurationCustomFilterContextPathTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/rest/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@MinimalWebConfiguration
	@ApplicationPath('/rest')
	@Path('/hello')
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.jersey.application-path=/api')
@DirtiesContext
class JerseyAutoConfigurationWithoutApplicationPathTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/api/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@MinimalWebConfiguration
	@Path('/hello')
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
class JerseyAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JerseyAutoConfiguration.class))
		.withUserConfiguration(ResourceConfigConfiguration.class);
	@Test
	void requestContextFilterRegistrationIsAutoConfigured() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(FilterRegistrationBean.class);
			FilterRegistrationBean<?> registration = context.getBean(FilterRegistrationBean.class);
			assertThat(registration.getFilter()).isInstanceOf(RequestContextFilter.class);
		});
	}
	@Test
	void whenUserDefinesARequestContextFilterTheAutoConfiguredRegistrationBacksOff() {
		this.contextRunner.withUserConfiguration(RequestContextFilterConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(FilterRegistrationBean.class);
			assertThat(context).hasSingleBean(RequestContextFilter.class);
		});
	}
	@Test
	void whenUserDefinesARequestContextFilterRegistrationTheAutoConfiguredRegistrationBacksOff() {
		this.contextRunner.withUserConfiguration(RequestContextFilterRegistrationConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(FilterRegistrationBean.class);
			assertThat(context).hasBean('customRequestContextFilterRegistration');
		});
	}
	@Test
	void whenJaxbIsAvailableTheObjectMapperIsCustomizedWithAnAnnotationIntrospector() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class)).run((context) -> {
			ObjectMapper objectMapper = context.getBean(ObjectMapper.class);
			assertThat(objectMapper.getSerializationConfig()
				.getAnnotationIntrospector()
				.allIntrospectors()
				.stream()
				.filter(JakartaXmlBindAnnotationIntrospector.class::isInstance)).hasSize(1);
		});
	}
	@Test
	void whenJaxbIsNotAvailableTheObjectMapperCustomizationBacksOff() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader('jakarta.xml.bind.annotation'))
			.run((context) -> {
				ObjectMapper objectMapper = context.getBean(ObjectMapper.class);
				assertThat(objectMapper.getSerializationConfig()
					.getAnnotationIntrospector()
					.allIntrospectors()
					.stream()
					.filter(JakartaXmlBindAnnotationIntrospector.class::isInstance)).isEmpty();
			});
	}
	@Test
	void whenJacksonJaxbModuleIsNotAvailableTheObjectMapperCustomizationBacksOff() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(JakartaXmlBindAnnotationIntrospector.class))
			.run((context) -> {
				ObjectMapper objectMapper = context.getBean(ObjectMapper.class);
				assertThat(objectMapper.getSerializationConfig()
					.getAnnotationIntrospector()
					.allIntrospectors()
					.stream()
					.filter(JakartaXmlBindAnnotationIntrospector.class::isInstance)).isEmpty();
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class ResourceConfigConfiguration {
		@Bean
		ResourceConfig resourceConfig() {
			return new ResourceConfig();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RequestContextFilterConfiguration {
		@Bean
		RequestContextFilter requestContextFilter() {
			return new RequestContextFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RequestContextFilterRegistrationConfiguration {
		@Bean
		FilterRegistrationBean<RequestContextFilter> customRequestContextFilterRegistration() {
			return new FilterRegistrationBean<>(new RequestContextFilter());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
class JerseyAutoConfigurationCustomApplicationTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/test/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@ApplicationPath('/test')
	static class TestApplication extends Application {
	}
	@Path('/hello')
	public static class TestController {
		@GET
		public String message() {
			return 'Hello World';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	static class TestConfiguration {
		@Configuration(proxyBeanMethods = false)
		public class JerseyConfiguration {
			@Bean
			public TestApplication testApplication() {
				return new TestApplication();
			}
			@Bean
			public ResourceConfig conf(TestApplication app) {
				ResourceConfig config = ResourceConfig.forApplication(app);
				config.register(TestController.class);
				return config;
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@DirtiesContext
class JerseyAutoConfigurationDefaultServletPathTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void contextLoads() {
		ResponseEntity<String> entity = this.restTemplate.getForEntity('/hello', String.class);
		assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.OK);
	}
	@MinimalWebConfiguration
	@Path('/hello')
	public static class Application extends ResourceConfig {
		@Value('${message:World}')
		private String msg;
		Application() {
			register(Application.class);
		}
		@GET
		public String message() {
			return 'Hello ' + this.msg;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JerseyAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT,
		properties = 'spring.jackson.default-property-inclusion:non-null')
@DirtiesContext
class JerseyAutoConfigurationObjectMapperProviderTests {
	@Autowired
	private TestRestTemplate restTemplate;
	@Test
	void responseIsSerializedUsingAutoConfiguredObjectMapper() {
		ResponseEntity<String> response = this.restTemplate.getForEntity('/rest/message', String.class);
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
		assertThat(response.getBody()).isEqualTo('{\'subject\':\'Jersey\'}');
	}
	@MinimalWebConfiguration
	@ApplicationPath('/rest')
	@Path('/message')
	public static class Application extends ResourceConfig {
		Application() {
			register(Application.class);
		}
		@GET
		public Message message() {
			return new Message('Jersey', null);
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	public static class Message {
		private String subject;
		private String body;
		Message() {
		}
		Message(String subject, String body) {
			this.subject = subject;
			this.body = body;
		}
		public String getSubject() {
			return this.subject;
		}
		public void setSubject(String subject) {
			this.subject = subject;
		}
		public String getBody() {
			return this.body;
		}
		public void setBody(String body) {
			this.body = body;
		}
		@XmlTransient
		public String getFoo() {
			return 'foo';
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Configuration
	@Import({ ServletWebServerFactoryAutoConfiguration.class, JacksonAutoConfiguration.class,
			JerseyAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.service.connection;
/**
class ConnectionDetailsFactoriesTests {
	private final MockSpringFactoriesLoader loader = new MockSpringFactoriesLoader();
	@Test
	void getRequiredConnectionDetailsWhenNoFactoryForSourceThrowsException() {
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		assertThatExceptionOfType(ConnectionDetailsFactoryNotFoundException.class)
			.isThrownBy(() -> factories.getConnectionDetails('source', true));
	}
	@Test
	void getOptionalConnectionDetailsWhenNoFactoryForSourceThrowsException() {
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		assertThat(factories.getConnectionDetails('source', false)).isEmpty();
	}
	@Test
	void getConnectionDetailsWhenSourceHasOneMatchReturnsSingleResult() {
		this.loader.addInstance(ConnectionDetailsFactory.class, new TestConnectionDetailsFactory());
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		Map<Class<?>, ConnectionDetails> connectionDetails = factories.getConnectionDetails('source', false);
		assertThat(connectionDetails).hasSize(1);
		assertThat(connectionDetails.get(TestConnectionDetails.class)).isInstanceOf(TestConnectionDetailsImpl.class);
	}
	@Test
	void getRequiredConnectionDetailsWhenSourceHasNoMatchTheowsException() {
		this.loader.addInstance(ConnectionDetailsFactory.class, new NullResultTestConnectionDetailsFactory());
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		assertThatExceptionOfType(ConnectionDetailsNotFoundException.class)
			.isThrownBy(() -> factories.getConnectionDetails('source', true));
	}
	@Test
	void getOptionalConnectionDetailsWhenSourceHasNoMatchReturnsEmptyMap() {
		this.loader.addInstance(ConnectionDetailsFactory.class, new NullResultTestConnectionDetailsFactory());
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		Map<Class<?>, ConnectionDetails> connectionDetails = factories.getConnectionDetails('source', false);
		assertThat(connectionDetails).isEmpty();
	}
	@Test
	void getConnectionDetailsWhenSourceHasMultipleMatchesReturnsMultipleResults() {
		this.loader.addInstance(ConnectionDetailsFactory.class, new TestConnectionDetailsFactory(),
				new OtherConnectionDetailsFactory());
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		Map<Class<?>, ConnectionDetails> connectionDetails = factories.getConnectionDetails('source', false);
		assertThat(connectionDetails).hasSize(2);
	}
	@Test
	void getConnectionDetailsWhenDuplicatesThrowsException() {
		this.loader.addInstance(ConnectionDetailsFactory.class, new TestConnectionDetailsFactory(),
				new TestConnectionDetailsFactory());
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		assertThatIllegalStateException().isThrownBy(() -> factories.getConnectionDetails('source', false))
			.withMessage('Duplicate connection details supplied for ' + TestConnectionDetails.class.getName());
	}
	@Test
	void getRegistrationsReturnsOrderedDelegates() {
		TestConnectionDetailsFactory orderOne = new TestConnectionDetailsFactory(1);
		TestConnectionDetailsFactory orderTwo = new TestConnectionDetailsFactory(2);
		TestConnectionDetailsFactory orderThree = new TestConnectionDetailsFactory(3);
		this.loader.addInstance(ConnectionDetailsFactory.class, orderOne, orderThree, orderTwo);
		ConnectionDetailsFactories factories = new ConnectionDetailsFactories(this.loader);
		List<Registration<String, ?>> registrations = factories.getRegistrations('source', false);
		assertThat(registrations.get(0).factory()).isEqualTo(orderOne);
		assertThat(registrations.get(1).factory()).isEqualTo(orderTwo);
		assertThat(registrations.get(2).factory()).isEqualTo(orderThree);
	}
	@Test
	void factoryLoadFailureDoesNotPreventOtherFactoriesFromLoading() {
		this.loader.add(ConnectionDetailsFactory.class.getName(), 'com.example.NonExistentConnectionDetailsFactory');
		assertThatNoException().isThrownBy(() -> new ConnectionDetailsFactories(this.loader));
	}
	private static final class TestConnectionDetailsFactory
			implements ConnectionDetailsFactory<String, TestConnectionDetails>, Ordered {
		private final int order;
		private TestConnectionDetailsFactory() {
			this(0);
		}
		private TestConnectionDetailsFactory(int order) {
			this.order = order;
		}
		@Override
		public TestConnectionDetails getConnectionDetails(String source) {
			return new TestConnectionDetailsImpl();
		}
		@Override
		public int getOrder() {
			return this.order;
		}
	}
	private static final class NullResultTestConnectionDetailsFactory
			implements ConnectionDetailsFactory<String, TestConnectionDetails> {
		@Override
		public TestConnectionDetails getConnectionDetails(String source) {
			return null;
		}
	}
	private static final class OtherConnectionDetailsFactory
			implements ConnectionDetailsFactory<String, OtherConnectionDetails> {
		@Override
		public OtherConnectionDetails getConnectionDetails(String source) {
			return new OtherConnectionDetailsImpl();
		}
	}
	private interface TestConnectionDetails extends ConnectionDetails {
	}
	private static final class TestConnectionDetailsImpl implements TestConnectionDetails {
	}
	private interface OtherConnectionDetails extends ConnectionDetails {
	}
	private static final class OtherConnectionDetailsImpl implements OtherConnectionDetails {
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarReactiveAutoConfigurationTests {
	private static final String INTERNAL_PULSAR_LISTENER_ANNOTATION_PROCESSOR = 'org.springframework.pulsar.config.internalReactivePulsarListenerAnnotationProcessor';
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(PulsarReactiveAutoConfiguration.class))
		.withBean(PulsarClient.class, () -> mock(PulsarClient.class));
	@Test
	void whenPulsarNotOnClasspathAutoConfigurationIsSkipped() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(PulsarReactiveAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(PulsarClient.class))
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarReactiveAutoConfiguration.class));
	}
	@Test
	void whenReactivePulsarNotOnClasspathAutoConfigurationIsSkipped() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(ReactivePulsarClient.class))
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarReactiveAutoConfiguration.class));
	}
	@Test
	void whenReactiveSpringPulsarNotOnClasspathAutoConfigurationIsSkipped() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(ReactivePulsarTemplate.class))
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarReactiveAutoConfiguration.class));
	}
	@Test
	void whenCustomPulsarListenerAnnotationProcessorDefinedAutoConfigurationIsSkipped() {
		this.contextRunner.withBean(INTERNAL_PULSAR_LISTENER_ANNOTATION_PROCESSOR, String.class, () -> 'bean')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactivePulsarBootstrapConfiguration.class));
	}
	@Test
	void autoConfiguresBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PulsarConfiguration.class)
			.hasSingleBean(PulsarClient.class)
			.hasSingleBean(PulsarTopicBuilder.class)
			.hasSingleBean(PulsarAdministration.class)
			.hasSingleBean(DefaultSchemaResolver.class)
			.hasSingleBean(DefaultTopicResolver.class)
			.hasSingleBean(ReactivePulsarClient.class)
			.hasSingleBean(CaffeineShadedProducerCacheProvider.class)
			.hasSingleBean(ReactiveMessageSenderCache.class)
			.hasSingleBean(DefaultReactivePulsarSenderFactory.class)
			.hasSingleBean(ReactivePulsarTemplate.class)
			.hasSingleBean(DefaultReactivePulsarConsumerFactory.class)
			.hasSingleBean(DefaultReactivePulsarListenerContainerFactory.class)
			.hasSingleBean(ReactivePulsarListenerAnnotationBeanPostProcessor.class)
			.hasSingleBean(ReactivePulsarListenerEndpointRegistry.class));
	}
	@Test
	void topicDefaultsCanBeDisabled() {
		this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarTopicBuilder.class));
	}
	@Test
	@SuppressWarnings('rawtypes')
	void injectsExpectedBeansIntoReactivePulsarClient() {
		this.contextRunner.run((context) -> {
			PulsarClient pulsarClient = context.getBean(PulsarClient.class);
			assertThat(context).hasNotFailed()
				.getBean(ReactivePulsarClient.class)
				.extracting('reactivePulsarResourceAdapter')
				.extracting('pulsarClientSupplier', InstanceOfAssertFactories.type(Supplier.class))
				.extracting(Supplier::get)
				.isSameAs(pulsarClient);
		});
	}
	@ParameterizedTest
	@ValueSource(classes = { ReactivePulsarClient.class, ProducerCacheProvider.class, ReactiveMessageSenderCache.class,
			ReactivePulsarSenderFactory.class, ReactivePulsarConsumerFactory.class, ReactivePulsarReaderFactory.class,
			ReactivePulsarTemplate.class })
	<T> void whenHasUserDefinedBeanDoesNotAutoConfigureBean(Class<T> beanClass) {
		T bean = mock(beanClass);
		this.contextRunner.withBean(beanClass.getName(), beanClass, () -> bean)
			.run((context) -> assertThat(context).getBean(beanClass).isSameAs(bean));
	}
	@Nested
	class SenderFactoryTests {
		private final ApplicationContextRunner contextRunner = PulsarReactiveAutoConfigurationTests.this.contextRunner;
		@Test
		void injectsExpectedBeans() {
			ReactivePulsarClient client = mock(ReactivePulsarClient.class);
			ReactiveMessageSenderCache cache = mock(ReactiveMessageSenderCache.class);
			this.contextRunner.withPropertyValues('spring.pulsar.producer.topic-name=test-topic')
				.withBean('customReactivePulsarClient', ReactivePulsarClient.class, () -> client)
				.withBean('customReactiveMessageSenderCache', ReactiveMessageSenderCache.class, () -> cache)
				.run((context) -> {
					DefaultReactivePulsarSenderFactory<?> senderFactory = context
						.getBean(DefaultReactivePulsarSenderFactory.class);
					assertThat(senderFactory)
						.extracting('reactivePulsarClient', InstanceOfAssertFactories.type(ReactivePulsarClient.class))
						.isSameAs(client);
					assertThat(senderFactory)
						.extracting('reactiveMessageSenderCache',
								InstanceOfAssertFactories.type(ReactiveMessageSenderCache.class))
						.isSameAs(cache);
					assertThat(senderFactory)
						.extracting('topicResolver', InstanceOfAssertFactories.type(TopicResolver.class))
						.isSameAs(context.getBean(TopicResolver.class));
					assertThat(senderFactory).extracting('topicBuilder').isNotNull();
				});
		}
		@Test
		void hasNoTopicBuilderWhenTopicDefaultsAreDisabled() {
			this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
				.run((context) -> assertThat((DefaultReactivePulsarSenderFactory<?>) context
					.getBean(DefaultReactivePulsarSenderFactory.class)).extracting('topicBuilder').isNull());
		}
		@Test
		void injectsExpectedBeansIntoReactiveMessageSenderCache() {
			ProducerCacheProvider provider = mock(ProducerCacheProvider.class);
			this.contextRunner.withBean('customProducerCacheProvider', ProducerCacheProvider.class, () -> provider)
				.run((context) -> assertThat(context).getBean(ReactiveMessageSenderCache.class)
					.extracting('cacheProvider', InstanceOfAssertFactories.type(ProducerCacheProvider.class))
					.isSameAs(provider));
		}
		@Test
		<T> void whenHasUserDefinedCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withPropertyValues('spring.pulsar.producer.name=fromPropsCustomizer')
				.withUserConfiguration(ReactiveMessageSenderBuilderCustomizerConfig.class)
				.run((context) -> {
					DefaultReactivePulsarSenderFactory<?> producerFactory = context
						.getBean(DefaultReactivePulsarSenderFactory.class);
					Customizers<ReactiveMessageSenderBuilderCustomizer<T>, ReactiveMessageSenderBuilder<T>> customizers = Customizers
						.of(ReactiveMessageSenderBuilder.class, ReactiveMessageSenderBuilderCustomizer::customize);
					assertThat(customizers.fromField(producerFactory, 'defaultConfigCustomizers')).callsInOrder(
							ReactiveMessageSenderBuilder::producerName, 'fromPropsCustomizer', 'fromCustomizer1',
							'fromCustomizer2');
				});
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ReactiveMessageSenderBuilderCustomizerConfig {
			@Bean
			@Order(200)
			ReactiveMessageSenderBuilderCustomizer<?> customizerFoo() {
				return (builder) -> builder.producerName('fromCustomizer2');
			}
			@Bean
			@Order(100)
			ReactiveMessageSenderBuilderCustomizer<?> customizerBar() {
				return (builder) -> builder.producerName('fromCustomizer1');
			}
		}
	}
	@Nested
	class TemplateTests {
		private final ApplicationContextRunner contextRunner = PulsarReactiveAutoConfigurationTests.this.contextRunner;
		@Test
		@SuppressWarnings('rawtypes')
		void injectsExpectedBeans() {
			ReactivePulsarSenderFactory senderFactory = mock(ReactivePulsarSenderFactory.class);
			SchemaResolver schemaResolver = mock(SchemaResolver.class);
			this.contextRunner
				.withBean('customReactivePulsarSenderFactory', ReactivePulsarSenderFactory.class, () -> senderFactory)
				.withBean('schemaResolver', SchemaResolver.class, () -> schemaResolver)
				.run((context) -> assertThat(context).getBean(ReactivePulsarTemplate.class).satisfies((template) -> {
					assertThat(template).extracting('reactiveMessageSenderFactory').isSameAs(senderFactory);
					assertThat(template).extracting('schemaResolver').isSameAs(schemaResolver);
				}));
		}
	}
	@Nested
	class ConsumerFactoryTests {
		private final ApplicationContextRunner contextRunner = PulsarReactiveAutoConfigurationTests.this.contextRunner;
		@Test
		void injectsExpectedBeans() {
			ReactivePulsarClient client = mock(ReactivePulsarClient.class);
			PulsarTopicBuilder topicBuilder = mock(PulsarTopicBuilder.class);
			this.contextRunner.withBean('customReactivePulsarClient', ReactivePulsarClient.class, () -> client)
				.withBean('customTopicBuilder', PulsarTopicBuilder.class, () -> topicBuilder)
				.run((context) -> {
					ReactivePulsarConsumerFactory<?> consumerFactory = context
						.getBean(DefaultReactivePulsarConsumerFactory.class);
					assertThat(consumerFactory)
						.extracting('reactivePulsarClient', InstanceOfAssertFactories.type(ReactivePulsarClient.class))
						.isSameAs(client);
					assertThat(consumerFactory)
						.extracting('topicBuilder', InstanceOfAssertFactories.type(PulsarTopicBuilder.class))
						.isSameAs(topicBuilder);
				});
		}
		@Test
		void hasNoTopicBuilderWhenTopicDefaultsAreDisabled() {
			this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
				.run((context) -> assertThat(
						(ReactivePulsarConsumerFactory<?>) context.getBean(DefaultReactivePulsarConsumerFactory.class))
					.extracting('topicBuilder')
					.isNull());
		}
		@Test
		<T> void whenHasUserDefinedCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withPropertyValues('spring.pulsar.consumer.name=fromPropsCustomizer')
				.withUserConfiguration(ReactiveMessageConsumerBuilderCustomizerConfig.class)
				.run((context) -> {
					DefaultReactivePulsarConsumerFactory<?> consumerFactory = context
						.getBean(DefaultReactivePulsarConsumerFactory.class);
					Customizers<ReactiveMessageConsumerBuilderCustomizer<T>, ReactiveMessageConsumerBuilder<T>> customizers = Customizers
						.of(ReactiveMessageConsumerBuilder.class, ReactiveMessageConsumerBuilderCustomizer::customize);
					assertThat(customizers.fromField(consumerFactory, 'defaultConfigCustomizers')).callsInOrder(
							ReactiveMessageConsumerBuilder::consumerName, 'fromPropsCustomizer', 'fromCustomizer1',
							'fromCustomizer2');
				});
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ReactiveMessageConsumerBuilderCustomizerConfig {
			@Bean
			@Order(200)
			ReactiveMessageConsumerBuilderCustomizer<?> customizerFoo() {
				return (builder) -> builder.consumerName('fromCustomizer2');
			}
			@Bean
			@Order(100)
			ReactiveMessageConsumerBuilderCustomizer<?> customizerBar() {
				return (builder) -> builder.consumerName('fromCustomizer1');
			}
		}
	}
	@Nested
	class ListenerTests {
		private final ApplicationContextRunner contextRunner = PulsarReactiveAutoConfigurationTests.this.contextRunner;
		@Test
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			ReactivePulsarListenerContainerFactory<?> listenerContainerFactory = mock(
					ReactivePulsarListenerContainerFactory.class);
			this.contextRunner
				.withBean('reactivePulsarListenerContainerFactory', ReactivePulsarListenerContainerFactory.class,
						() -> listenerContainerFactory)
				.run((context) -> assertThat(context).getBean(ReactivePulsarListenerContainerFactory.class)
					.isSameAs(listenerContainerFactory));
		}
		@Test
		void whenHasUserDefinedReactivePulsarListenerAnnotationBeanPostProcessorDoesNotAutoConfigureBean() {
			ReactivePulsarListenerAnnotationBeanPostProcessor<?> listenerAnnotationBeanPostProcessor = mock(
					ReactivePulsarListenerAnnotationBeanPostProcessor.class);
			this.contextRunner.withBean(INTERNAL_PULSAR_LISTENER_ANNOTATION_PROCESSOR,
					ReactivePulsarListenerAnnotationBeanPostProcessor.class, () -> listenerAnnotationBeanPostProcessor)
				.run((context) -> assertThat(context).getBean(ReactivePulsarListenerAnnotationBeanPostProcessor.class)
					.isSameAs(listenerAnnotationBeanPostProcessor));
		}
		@Test
		void whenHasCustomProperties() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.listener.schema-type=avro');
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new)).run((context) -> {
				DefaultReactivePulsarListenerContainerFactory<?> factory = context
					.getBean(DefaultReactivePulsarListenerContainerFactory.class);
				assertThat(factory.getContainerProperties().getSchemaType()).isEqualTo(SchemaType.AVRO);
			});
		}
		@Test
		void injectsExpectedBeans() {
			ReactivePulsarConsumerFactory<?> consumerFactory = mock(ReactivePulsarConsumerFactory.class);
			SchemaResolver schemaResolver = mock(SchemaResolver.class);
			this.contextRunner
				.withBean('customReactivePulsarConsumerFactory', ReactivePulsarConsumerFactory.class,
						() -> consumerFactory)
				.withBean('schemaResolver', SchemaResolver.class, () -> schemaResolver)
				.run((context) -> {
					DefaultReactivePulsarListenerContainerFactory<?> containerFactory = context
						.getBean(DefaultReactivePulsarListenerContainerFactory.class);
					assertThat(containerFactory).extracting('consumerFactory').isSameAs(consumerFactory);
					assertThat(containerFactory)
						.extracting(DefaultReactivePulsarListenerContainerFactory::getContainerProperties)
						.extracting(ReactivePulsarContainerProperties::getSchemaResolver)
						.isSameAs(schemaResolver);
				});
		}
		@Test
		void whenHasUserDefinedFactoryCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withUserConfiguration(ListenerContainerFactoryCustomizersConfig.class)
				.run((context) -> assertThat(context).getBean(DefaultReactivePulsarListenerContainerFactory.class)
					.hasFieldOrPropertyWithValue('containerProperties.subscriptionName', ':bar:foo'));
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ListenerContainerFactoryCustomizersConfig {
			@Bean
			@Order(50)
			PulsarContainerFactoryCustomizer<ConcurrentPulsarListenerContainerFactory<?>> customizerIgnored() {
				return (containerFactory) -> {
					throw new IllegalStateException('should-not-have-matched');
				};
			}
			@Bean
			@Order(200)
			PulsarContainerFactoryCustomizer<DefaultReactivePulsarListenerContainerFactory<?>> customizerFoo() {
				return (containerFactory) -> appendToSubscriptionName(containerFactory, ':foo');
			}
			@Bean
			@Order(100)
			PulsarContainerFactoryCustomizer<DefaultReactivePulsarListenerContainerFactory<?>> customizerBar() {
				return (containerFactory) -> appendToSubscriptionName(containerFactory, ':bar');
			}
			private void appendToSubscriptionName(DefaultReactivePulsarListenerContainerFactory<?> containerFactory,
					String valueToAppend) {
				String subscriptionName = containerFactory.getContainerProperties().getSubscriptionName();
				String updatedValue = (subscriptionName != null) ? subscriptionName + valueToAppend : valueToAppend;
				containerFactory.getContainerProperties().setSubscriptionName(updatedValue);
			}
		}
	}
	@Nested
	class ReaderFactoryTests {
		private final ApplicationContextRunner contextRunner = PulsarReactiveAutoConfigurationTests.this.contextRunner;
		@Test
		void injectsExpectedBeans() {
			ReactivePulsarClient client = mock(ReactivePulsarClient.class);
			PulsarTopicBuilder topicBuilder = mock(PulsarTopicBuilder.class);
			this.contextRunner.withPropertyValues('spring.pulsar.reader.name=test-reader')
				.withBean('customReactivePulsarClient', ReactivePulsarClient.class, () -> client)
				.withBean('customPulsarTopicBuilder', PulsarTopicBuilder.class, () -> topicBuilder)
				.run((context) -> {
					DefaultReactivePulsarReaderFactory<?> readerFactory = context
						.getBean(DefaultReactivePulsarReaderFactory.class);
					assertThat(readerFactory)
						.extracting('reactivePulsarClient', InstanceOfAssertFactories.type(ReactivePulsarClient.class))
						.isSameAs(client);
					assertThat(readerFactory)
						.extracting('topicBuilder', InstanceOfAssertFactories.type(PulsarTopicBuilder.class))
						.isSameAs(topicBuilder);
				});
		}
		@Test
		void hasNoTopicBuilderWhenTopicDefaultsAreDisabled() {
			this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
				.run((context) -> assertThat((DefaultReactivePulsarReaderFactory<?>) context
					.getBean(DefaultReactivePulsarReaderFactory.class)).extracting('topicBuilder').isNull());
		}
		@Test
		<T> void whenHasUserDefinedCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withPropertyValues('spring.pulsar.reader.name=fromPropsCustomizer')
				.withUserConfiguration(ReactiveMessageReaderBuilderCustomizerConfig.class)
				.run((context) -> {
					DefaultReactivePulsarReaderFactory<?> readerFactory = context
						.getBean(DefaultReactivePulsarReaderFactory.class);
					Customizers<ReactiveMessageReaderBuilderCustomizer<T>, ReactiveMessageReaderBuilder<T>> customizers = Customizers
						.of(ReactiveMessageReaderBuilder.class, ReactiveMessageReaderBuilderCustomizer::customize);
					assertThat(customizers.fromField(readerFactory, 'defaultConfigCustomizers')).callsInOrder(
							ReactiveMessageReaderBuilder::readerName, 'fromPropsCustomizer', 'fromCustomizer1',
							'fromCustomizer2');
				});
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ReactiveMessageReaderBuilderCustomizerConfig {
			@Bean
			@Order(200)
			ReactiveMessageReaderBuilderCustomizer<?> customizerFoo() {
				return (builder) -> builder.readerName('fromCustomizer2');
			}
			@Bean
			@Order(100)
			ReactiveMessageReaderBuilderCustomizer<?> customizerBar() {
				return (builder) -> builder.readerName('fromCustomizer1');
			}
		}
	}
	@Nested
	class SenderCacheAutoConfigurationTests {
		private final ApplicationContextRunner contextRunner = PulsarReactiveAutoConfigurationTests.this.contextRunner;
		@Test
		void whenNoPropertiesEnablesCaching() {
			this.contextRunner.run(this::assertCaffeineProducerCacheProvider);
		}
		@Test
		void whenCachingEnabledEnablesCaching() {
			this.contextRunner.withPropertyValues('spring.pulsar.producer.cache.enabled=true')
				.run(this::assertCaffeineProducerCacheProvider);
		}
		@Test
		void whenCachingDisabledDoesNotEnableCaching() {
			this.contextRunner.withPropertyValues('spring.pulsar.producer.cache.enabled=false')
				.run((context) -> assertThat(context).doesNotHaveBean(ProducerCacheProvider.class)
					.doesNotHaveBean(ReactiveMessageSenderCache.class));
		}
		@Test
		void whenCachingEnabledAndCaffeineNotOnClasspathStillUsesCaffeine() {
			// The reactive client shades Caffeine - it should still be used
			this.contextRunner.withClassLoader(new FilteredClassLoader(Caffeine.class))
				.withPropertyValues('spring.pulsar.producer.cache.enabled=true')
				.run(this::assertCaffeineProducerCacheProvider);
		}
		@Test
		void whenCachingEnabledAndNoCacheProviderAvailable() {
			// The reactive client uses a shaded caffeine cache provider as its internal
			// cache
			this.contextRunner.withClassLoader(new FilteredClassLoader(CaffeineShadedProducerCacheProvider.class))
				.withPropertyValues('spring.pulsar.producer.cache.enabled=true')
				.run((context) -> assertThat(context).doesNotHaveBean(ProducerCacheProvider.class)
					.getBean(ReactiveMessageSenderCache.class)
					.extracting('cacheProvider')
					.isExactlyInstanceOf(CaffeineShadedProducerCacheProvider.class));
		}
		@Test
		void whenCustomCachingPropertiesCreatesConfiguredBean() {
			this.contextRunner
				.withPropertyValues('spring.pulsar.producer.cache.expire-after-access=100s',
						'spring.pulsar.producer.cache.maximum-size=5150',
						'spring.pulsar.producer.cache.initial-capacity=200')
				.run((context) -> assertCaffeineProducerCacheProvider(context).extracting('cache.cache')
					.hasFieldOrPropertyWithValue('expiresAfterAccessNanos', Duration.ofSeconds(100).toNanos())
					.hasFieldOrPropertyWithValue('maximum', 5150L));
		}
		private AbstractObjectAssert<?, ProducerCacheProvider> assertCaffeineProducerCacheProvider(
				AssertableApplicationContext context) {
			return assertThat(context).hasSingleBean(ReactiveMessageSenderCache.class)
				.getBean(ProducerCacheProvider.class)
				.isExactlyInstanceOf(CaffeineShadedProducerCacheProvider.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PropertiesPulsarConnectionDetailsTests {
	@Test
	void getClientServiceUrlReturnsValueFromProperties() {
		PulsarProperties properties = new PulsarProperties();
		properties.getClient().setServiceUrl('foo');
		PulsarConnectionDetails connectionDetails = new PropertiesPulsarConnectionDetails(properties);
		assertThat(connectionDetails.getBrokerUrl()).isEqualTo('foo');
	}
	@Test
	void getAdminServiceHttpUrlReturnsValueFromProperties() {
		PulsarProperties properties = new PulsarProperties();
		properties.getAdmin().setServiceUrl('foo');
		PulsarConnectionDetails connectionDetails = new PropertiesPulsarConnectionDetails(properties);
		assertThat(connectionDetails.getAdminUrl()).isEqualTo('foo');
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class DeadLetterPolicyMapperTests {
	@Test
	void map() {
		PulsarProperties.Consumer.DeadLetterPolicy properties = new PulsarProperties.Consumer.DeadLetterPolicy();
		properties.setMaxRedeliverCount(100);
		properties.setRetryLetterTopic('my-retry-topic');
		properties.setDeadLetterTopic('my-dlt-topic');
		properties.setInitialSubscriptionName('my-initial-subscription');
		DeadLetterPolicy policy = DeadLetterPolicyMapper.map(properties);
		assertThat(policy.getMaxRedeliverCount()).isEqualTo(100);
		assertThat(policy.getRetryLetterTopic()).isEqualTo('my-retry-topic');
		assertThat(policy.getDeadLetterTopic()).isEqualTo('my-dlt-topic');
		assertThat(policy.getInitialSubscriptionName()).isEqualTo('my-initial-subscription');
	}
	@Test
	void mapWhenMaxRedeliverCountIsNotPositiveThrowsException() {
		PulsarProperties.Consumer.DeadLetterPolicy properties = new PulsarProperties.Consumer.DeadLetterPolicy();
		properties.setMaxRedeliverCount(0);
		assertThatIllegalStateException().isThrownBy(() -> DeadLetterPolicyMapper.map(properties))
			.withMessage('Pulsar DeadLetterPolicy must have a positive "max-redelivery-count" property value');
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarAutoConfigurationTests {
	private static final String INTERNAL_PULSAR_LISTENER_ANNOTATION_PROCESSOR = 'org.springframework.pulsar.config.internalPulsarListenerAnnotationProcessor';
	private static final String INTERNAL_PULSAR_READER_ANNOTATION_PROCESSOR = 'org.springframework.pulsar.config.internalPulsarReaderAnnotationProcessor';
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(PulsarAutoConfiguration.class))
		.withBean(PulsarClient.class, () -> mock(PulsarClient.class));
	@Test
	void whenPulsarNotOnClasspathAutoConfigurationIsSkipped() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(PulsarAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader(PulsarClient.class))
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarAutoConfiguration.class));
	}
	@Test
	void whenSpringPulsarNotOnClasspathAutoConfigurationIsSkipped() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(PulsarTemplate.class))
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarAutoConfiguration.class));
	}
	@Test
	void whenCustomPulsarListenerAnnotationProcessorDefinedAutoConfigurationIsSkipped() {
		this.contextRunner.withBean(INTERNAL_PULSAR_LISTENER_ANNOTATION_PROCESSOR, String.class, () -> 'bean')
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarBootstrapConfiguration.class));
	}
	@Test
	void whenCustomPulsarReaderAnnotationProcessorDefinedAutoConfigurationIsSkipped() {
		this.contextRunner.withBean(INTERNAL_PULSAR_READER_ANNOTATION_PROCESSOR, String.class, () -> 'bean')
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarBootstrapConfiguration.class));
	}
	@Test
	void autoConfiguresBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PulsarConfiguration.class)
			.hasSingleBean(PulsarConnectionDetails.class)
			.hasSingleBean(DefaultPulsarClientFactory.class)
			.hasSingleBean(PulsarClient.class)
			.hasSingleBean(PulsarTopicBuilder.class)
			.hasSingleBean(PulsarAdministration.class)
			.hasSingleBean(DefaultSchemaResolver.class)
			.hasSingleBean(DefaultTopicResolver.class)
			.hasSingleBean(CachingPulsarProducerFactory.class)
			.hasSingleBean(PulsarTemplate.class)
			.hasSingleBean(DefaultPulsarConsumerFactory.class)
			.hasSingleBean(ConcurrentPulsarListenerContainerFactory.class)
			.hasSingleBean(DefaultPulsarReaderFactory.class)
			.hasSingleBean(DefaultPulsarReaderContainerFactory.class)
			.hasSingleBean(PulsarListenerAnnotationBeanPostProcessor.class)
			.hasSingleBean(PulsarListenerEndpointRegistry.class)
			.hasSingleBean(PulsarReaderAnnotationBeanPostProcessor.class)
			.hasSingleBean(PulsarReaderEndpointRegistry.class));
	}
	@Test
	void topicDefaultsCanBeDisabled() {
		this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
			.run((context) -> assertThat(context).doesNotHaveBean(PulsarTopicBuilder.class));
	}
	@Nested
	class ProducerFactoryTests {
		private final ApplicationContextRunner contextRunner = PulsarAutoConfigurationTests.this.contextRunner;
		@Test
		@SuppressWarnings('unchecked')
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			PulsarProducerFactory<String> producerFactory = mock(PulsarProducerFactory.class);
			this.contextRunner
				.withBean('customPulsarProducerFactory', PulsarProducerFactory.class, () -> producerFactory)
				.run((context) -> assertThat(context).getBean(PulsarProducerFactory.class).isSameAs(producerFactory));
		}
		@Test
		void whenNoPropertiesUsesCachingPulsarProducerFactory() {
			this.contextRunner.run((context) -> assertThat(context).getBean(PulsarProducerFactory.class)
				.isExactlyInstanceOf(CachingPulsarProducerFactory.class));
		}
		@Test
		void whenCachingDisabledUsesDefaultPulsarProducerFactory() {
			this.contextRunner.withPropertyValues('spring.pulsar.producer.cache.enabled=false')
				.run((context) -> assertThat(context).getBean(PulsarProducerFactory.class)
					.isExactlyInstanceOf(DefaultPulsarProducerFactory.class));
		}
		@Test
		void whenCachingEnabledUsesCachingPulsarProducerFactory() {
			this.contextRunner.withPropertyValues('spring.pulsar.producer.cache.enabled=true')
				.run((context) -> assertThat(context).getBean(PulsarProducerFactory.class)
					.isExactlyInstanceOf(CachingPulsarProducerFactory.class));
		}
		@Test
		void whenCachingEnabledAndCaffeineNotOnClasspathStillUsesCaffeine() {
			this.contextRunner.withClassLoader(new FilteredClassLoader(Caffeine.class))
				.withPropertyValues('spring.pulsar.producer.cache.enabled=true')
				.run((context) -> {
					assertThat(context).getBean(CachingPulsarProducerFactory.class)
						.extracting('producerCache')
						.extracting(Object::getClass)
						.isEqualTo(CaffeineCacheProvider.class);
					assertThat(context).getBean(CachingPulsarProducerFactory.class)
						.extracting('producerCache.cache')
						.extracting(Object::getClass)
						.extracting(Class::getName)
						.asString()
						.startsWith('org.springframework.pulsar.shade.com.github.benmanes.caffeine.cache.');
				});
		}
		@Test
		void whenCustomCachingPropertiesCreatesConfiguredBean() {
			this.contextRunner
				.withPropertyValues('spring.pulsar.producer.cache.expire-after-access=100s',
						'spring.pulsar.producer.cache.maximum-size=5150',
						'spring.pulsar.producer.cache.initial-capacity=200')
				.run((context) -> assertThat(context).getBean(CachingPulsarProducerFactory.class)
					.extracting('producerCache.cache.cache')
					.hasFieldOrPropertyWithValue('maximum', 5150L)
					.hasFieldOrPropertyWithValue('expiresAfterAccessNanos', TimeUnit.SECONDS.toNanos(100)));
		}
		@Test
		void whenHasTopicNamePropertyCreatesConfiguredBean() {
			this.contextRunner.withPropertyValues('spring.pulsar.producer.topic-name=my-topic')
				.run((context) -> assertThat(context).getBean(DefaultPulsarProducerFactory.class)
					.hasFieldOrPropertyWithValue('defaultTopic', 'my-topic'));
		}
		@Test
		void injectsExpectedBeans() {
			this.contextRunner
				.withPropertyValues('spring.pulsar.producer.topic-name=my-topic',
						'spring.pulsar.producer.cache.enabled=false')
				.run((context) -> assertThat(context).getBean(DefaultPulsarProducerFactory.class)
					.hasFieldOrPropertyWithValue('pulsarClient', context.getBean(PulsarClient.class))
					.hasFieldOrPropertyWithValue('topicResolver', context.getBean(TopicResolver.class))
					.extracting('topicBuilder')
					.isNotNull());
		}
		@Test
		void hasNoTopicBuilderWhenTopicDefaultsAreDisabled() {
			this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
				.run((context) -> assertThat(context).getBean(DefaultPulsarProducerFactory.class)
					.extracting('topicBuilder')
					.isNull());
		}
		@ParameterizedTest
		@ValueSource(booleans = { true, false })
		<T> void whenHasUserDefinedCustomizersAppliesInCorrectOrder(boolean cachingEnabled) {
			this.contextRunner
				.withPropertyValues('spring.pulsar.producer.cache.enabled=' + cachingEnabled,
						'spring.pulsar.producer.name=fromPropsCustomizer')
				.withUserConfiguration(ProducerBuilderCustomizersConfig.class)
				.run((context) -> {
					DefaultPulsarProducerFactory<?> producerFactory = context
						.getBean(DefaultPulsarProducerFactory.class);
					Customizers<ProducerBuilderCustomizer<T>, ProducerBuilder<T>> customizers = Customizers
						.of(ProducerBuilder.class, ProducerBuilderCustomizer::customize);
					assertThat(customizers.fromField(producerFactory, 'defaultConfigCustomizers')).callsInOrder(
							ProducerBuilder::producerName, 'fromPropsCustomizer', 'fromCustomizer1', 'fromCustomizer2');
				});
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ProducerBuilderCustomizersConfig {
			@Bean
			@Order(200)
			ProducerBuilderCustomizer<?> customizerFoo() {
				return (builder) -> builder.producerName('fromCustomizer2');
			}
			@Bean
			@Order(100)
			ProducerBuilderCustomizer<?> customizerBar() {
				return (builder) -> builder.producerName('fromCustomizer1');
			}
		}
	}
	@Nested
	class TemplateTests {
		private final ApplicationContextRunner contextRunner = PulsarAutoConfigurationTests.this.contextRunner;
		@Test
		@SuppressWarnings('unchecked')
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			PulsarTemplate<String> template = mock(PulsarTemplate.class);
			this.contextRunner.withBean('customPulsarTemplate', PulsarTemplate.class, () -> template)
				.run((context) -> assertThat(context).getBean(PulsarTemplate.class).isSameAs(template));
		}
		@Test
		void injectsExpectedBeans() {
			PulsarProducerFactory<?> producerFactory = mock(PulsarProducerFactory.class);
			SchemaResolver schemaResolver = mock(SchemaResolver.class);
			TopicResolver topicResolver = mock(TopicResolver.class);
			this.contextRunner
				.withBean('customPulsarProducerFactory', PulsarProducerFactory.class, () -> producerFactory)
				.withBean('schemaResolver', SchemaResolver.class, () -> schemaResolver)
				.withBean('topicResolver', TopicResolver.class, () -> topicResolver)
				.run((context) -> assertThat(context).getBean(PulsarTemplate.class)
					.hasFieldOrPropertyWithValue('producerFactory', producerFactory)
					.hasFieldOrPropertyWithValue('schemaResolver', schemaResolver)
					.hasFieldOrPropertyWithValue('topicResolver', topicResolver));
		}
		@Test
		<T> void whenHasUseDefinedProducerInterceptorInjectsBean() {
			ProducerInterceptor interceptor = mock(ProducerInterceptor.class);
			this.contextRunner.withBean('customProducerInterceptor', ProducerInterceptor.class, () -> interceptor)
				.run((context) -> {
					PulsarTemplate<?> pulsarTemplate = context.getBean(PulsarTemplate.class);
					Customizers<ProducerBuilderCustomizer<T>, ProducerBuilder<T>> customizers = Customizers
						.of(ProducerBuilder.class, ProducerBuilderCustomizer::customize);
					assertThat(customizers.fromField(pulsarTemplate, 'interceptorsCustomizers'))
						.callsInOrder(ProducerBuilder::intercept, interceptor);
				});
		}
		@Test
		<T> void whenHasUseDefinedProducerInterceptorsInjectsBeansInCorrectOrder() {
			this.contextRunner.withUserConfiguration(InterceptorTestConfiguration.class).run((context) -> {
				ProducerInterceptor interceptorFoo = context.getBean('interceptorFoo', ProducerInterceptor.class);
				ProducerInterceptor interceptorBar = context.getBean('interceptorBar', ProducerInterceptor.class);
				PulsarTemplate<?> pulsarTemplate = context.getBean(PulsarTemplate.class);
				Customizers<ProducerBuilderCustomizer<T>, ProducerBuilder<T>> customizers = Customizers
					.of(ProducerBuilder.class, ProducerBuilderCustomizer::customize);
				assertThat(customizers.fromField(pulsarTemplate, 'interceptorsCustomizers'))
					.callsInOrder(ProducerBuilder::intercept, interceptorBar, interceptorFoo);
			});
		}
		@Test
		void whenNoPropertiesEnablesObservation() {
			this.contextRunner.run((context) -> assertThat(context).getBean(PulsarTemplate.class)
				.hasFieldOrPropertyWithValue('observationEnabled', false));
		}
		@Test
		void whenObservationsEnabledEnablesObservation() {
			this.contextRunner.withPropertyValues('spring.pulsar.template.observations-enabled=true')
				.run((context) -> assertThat(context).getBean(PulsarTemplate.class)
					.hasFieldOrPropertyWithValue('observationEnabled', true));
		}
		@Test
		void whenObservationsDisabledDoesNotEnableObservation() {
			this.contextRunner.withPropertyValues('spring.pulsar.template.observations-enabled=false')
				.run((context) -> assertThat(context).getBean(PulsarTemplate.class)
					.hasFieldOrPropertyWithValue('observationEnabled', false));
		}
		@Test
		void whenTransactionEnabledTrueEnablesTransactions() {
			this.contextRunner.withPropertyValues('spring.pulsar.transaction.enabled=true')
				.run((context) -> assertThat(context.getBean(PulsarTemplate.class).transactions().isEnabled())
					.isTrue());
		}
		@Configuration(proxyBeanMethods = false)
		static class InterceptorTestConfiguration {
			@Bean
			@Order(200)
			ProducerInterceptor interceptorFoo() {
				return mock(ProducerInterceptor.class);
			}
			@Bean
			@Order(100)
			ProducerInterceptor interceptorBar() {
				return mock(ProducerInterceptor.class);
			}
		}
	}
	@Nested
	class ConsumerFactoryTests {
		private final ApplicationContextRunner contextRunner = PulsarAutoConfigurationTests.this.contextRunner;
		@Test
		@SuppressWarnings('unchecked')
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			PulsarConsumerFactory<String> consumerFactory = mock(PulsarConsumerFactory.class);
			this.contextRunner
				.withBean('customPulsarConsumerFactory', PulsarConsumerFactory.class, () -> consumerFactory)
				.run((context) -> assertThat(context).getBean(PulsarConsumerFactory.class).isSameAs(consumerFactory));
		}
		@Test
		void injectsExpectedBeans() {
			this.contextRunner.run((context) -> assertThat(context).getBean(DefaultPulsarConsumerFactory.class)
				.hasFieldOrPropertyWithValue('pulsarClient', context.getBean(PulsarClient.class))
				.extracting('topicBuilder')
				.isNotNull());
		}
		@Test
		void hasNoTopicBuilderWhenTopicDefaultsAreDisabled() {
			this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
				.run((context) -> assertThat(context).getBean(DefaultPulsarConsumerFactory.class)
					.hasFieldOrPropertyWithValue('pulsarClient', context.getBean(PulsarClient.class))
					.extracting('topicBuilder')
					.isNull());
		}
		@Test
		<T> void whenHasUserDefinedCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withPropertyValues('spring.pulsar.consumer.name=fromPropsCustomizer')
				.withUserConfiguration(ConsumerBuilderCustomizersConfig.class)
				.run((context) -> {
					DefaultPulsarConsumerFactory<?> consumerFactory = context
						.getBean(DefaultPulsarConsumerFactory.class);
					Customizers<ConsumerBuilderCustomizer<T>, ConsumerBuilder<T>> customizers = Customizers
						.of(ConsumerBuilder.class, ConsumerBuilderCustomizer::customize);
					assertThat(customizers.fromField(consumerFactory, 'defaultConfigCustomizers')).callsInOrder(
							ConsumerBuilder::consumerName, 'fromPropsCustomizer', 'fromCustomizer1', 'fromCustomizer2');
				});
		}
		@Test
		void injectsExpectedBeanWithExplicitGenericType() {
			this.contextRunner.withBean(ExplicitGenericTypeConfig.class)
				.run((context) -> assertThat(context).getBean(ExplicitGenericTypeConfig.class)
					.hasFieldOrPropertyWithValue('consumerFactory', context.getBean(PulsarConsumerFactory.class))
					.hasFieldOrPropertyWithValue('containerFactory',
							context.getBean(ConcurrentPulsarListenerContainerFactory.class)));
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ConsumerBuilderCustomizersConfig {
			@Bean
			@Order(200)
			ConsumerBuilderCustomizer<?> customizerFoo() {
				return (builder) -> builder.consumerName('fromCustomizer2');
			}
			@Bean
			@Order(100)
			ConsumerBuilderCustomizer<?> customizerBar() {
				return (builder) -> builder.consumerName('fromCustomizer1');
			}
		}
		static class ExplicitGenericTypeConfig {
			@Autowired
			PulsarConsumerFactory<TestType> consumerFactory;
			@Autowired
			ConcurrentPulsarListenerContainerFactory<TestType> containerFactory;
			static class TestType {
			}
		}
	}
	@Nested
	class ListenerTests {
		private final ApplicationContextRunner contextRunner = PulsarAutoConfigurationTests.this.contextRunner;
		@Test
		void whenHasUserDefinedListenerContainerFactoryBeanDoesNotAutoConfigureBean() {
			PulsarListenerContainerFactory listenerContainerFactory = mock(PulsarListenerContainerFactory.class);
			this.contextRunner
				.withBean('pulsarListenerContainerFactory', PulsarListenerContainerFactory.class,
						() -> listenerContainerFactory)
				.run((context) -> assertThat(context).getBean(PulsarListenerContainerFactory.class)
					.isSameAs(listenerContainerFactory));
		}
		@Test
		@SuppressWarnings('rawtypes')
		void injectsExpectedBeans() {
			PulsarConsumerFactory<?> consumerFactory = mock(PulsarConsumerFactory.class);
			SchemaResolver schemaResolver = mock(SchemaResolver.class);
			TopicResolver topicResolver = mock(TopicResolver.class);
			this.contextRunner.withBean('pulsarConsumerFactory', PulsarConsumerFactory.class, () -> consumerFactory)
				.withBean('schemaResolver', SchemaResolver.class, () -> schemaResolver)
				.withBean('topicResolver', TopicResolver.class, () -> topicResolver)
				.run((context) -> assertThat(context).getBean(ConcurrentPulsarListenerContainerFactory.class)
					.hasFieldOrPropertyWithValue('consumerFactory', consumerFactory)
					.extracting(ConcurrentPulsarListenerContainerFactory::getContainerProperties)
					.hasFieldOrPropertyWithValue('schemaResolver', schemaResolver)
					.hasFieldOrPropertyWithValue('topicResolver', topicResolver));
		}
		@Test
		@SuppressWarnings('unchecked')
		void whenHasUserDefinedListenerAnnotationBeanPostProcessorBeanDoesNotAutoConfigureBean() {
			PulsarListenerAnnotationBeanPostProcessor<String> listenerAnnotationBeanPostProcessor = mock(
					PulsarListenerAnnotationBeanPostProcessor.class);
			this.contextRunner
				.withBean('org.springframework.pulsar.config.internalPulsarListenerAnnotationProcessor',
						PulsarListenerAnnotationBeanPostProcessor.class, () -> listenerAnnotationBeanPostProcessor)
				.run((context) -> assertThat(context).getBean(PulsarListenerAnnotationBeanPostProcessor.class)
					.isSameAs(listenerAnnotationBeanPostProcessor));
		}
		@Test
		void whenHasCustomProperties() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.listener.schema-type=avro');
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new)).run((context) -> {
				ConcurrentPulsarListenerContainerFactory<?> factory = context
					.getBean(ConcurrentPulsarListenerContainerFactory.class);
				assertThat(factory.getContainerProperties().getSchemaType()).isEqualTo(SchemaType.AVRO);
			});
		}
		@Test
		void whenNoPropertiesEnablesObservation() {
			this.contextRunner
				.run((context) -> assertThat(context).getBean(ConcurrentPulsarListenerContainerFactory.class)
					.hasFieldOrPropertyWithValue('containerProperties.observationEnabled', false));
		}
		@Test
		void whenObservationsEnabledEnablesObservation() {
			this.contextRunner.withPropertyValues('spring.pulsar.listener.observation-enabled=true')
				.run((context) -> assertThat(context).getBean(ConcurrentPulsarListenerContainerFactory.class)
					.hasFieldOrPropertyWithValue('containerProperties.observationEnabled', true));
		}
		@Test
		void whenObservationsDisabledDoesNotEnableObservation() {
			this.contextRunner.withPropertyValues('spring.pulsar.listener.observation-enabled=false')
				.run((context) -> assertThat(context).getBean(ConcurrentPulsarListenerContainerFactory.class)
					.hasFieldOrPropertyWithValue('containerProperties.observationEnabled', false));
		}
		@Test
		@EnabledForJreRange(min = JRE.JAVA_21)
		void whenVirtualThreadsAreEnabledOnJava21AndLaterListenerContainerShouldUseVirtualThreads() {
			this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
				ConcurrentPulsarListenerContainerFactory<?> factory = context
					.getBean(ConcurrentPulsarListenerContainerFactory.class);
				assertThat(factory.getContainerProperties().getConsumerTaskExecutor())
					.isInstanceOf(VirtualThreadTaskExecutor.class);
				Object taskExecutor = factory.getContainerProperties().getConsumerTaskExecutor();
				Object virtualThread = ReflectionTestUtils.getField(taskExecutor, 'virtualThreadFactory');
				Thread threadCreated = ((ThreadFactory) virtualThread).newThread(mock(Runnable.class));
				assertThat(threadCreated.getName()).containsPattern('pulsar-consumer-[0-9]+');
			});
		}
		@Test
		@EnabledForJreRange(max = JRE.JAVA_20)
		void whenVirtualThreadsAreEnabledOnJava20AndEarlierListenerContainerShouldNotUseVirtualThreads() {
			this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
				ConcurrentPulsarListenerContainerFactory<?> factory = context
					.getBean(ConcurrentPulsarListenerContainerFactory.class);
				assertThat(factory.getContainerProperties().getConsumerTaskExecutor()).isNull();
			});
		}
		@Test
		void whenTransactionEnabledTrueListenerContainerShouldUseTransactions() {
			this.contextRunner.withPropertyValues('spring.pulsar.transaction.enabled=true').run((context) -> {
				ConcurrentPulsarListenerContainerFactory<?> factory = context
					.getBean(ConcurrentPulsarListenerContainerFactory.class);
				TransactionSettings transactions = factory.getContainerProperties().transactions();
				assertThat(transactions.isEnabled()).isTrue();
				assertThat(transactions.getTransactionManager()).isNotNull();
			});
		}
		@Test
		void whenTransactionEnabledFalseListenerContainerShouldNotUseTransactions() {
			this.contextRunner.withPropertyValues('spring.pulsar.transaction.enabled=false').run((context) -> {
				ConcurrentPulsarListenerContainerFactory<?> factory = context
					.getBean(ConcurrentPulsarListenerContainerFactory.class);
				TransactionSettings transactions = factory.getContainerProperties().transactions();
				assertThat(transactions.isEnabled()).isFalse();
				assertThat(transactions.getTransactionManager()).isNull();
			});
		}
		@Test
		void whenHasUserDefinedCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withUserConfiguration(ListenerContainerFactoryCustomizersConfig.class)
				.run((context) -> assertThat(context).getBean(ConcurrentPulsarListenerContainerFactory.class)
					.hasFieldOrPropertyWithValue('containerProperties.subscriptionName', ':bar:foo'));
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ListenerContainerFactoryCustomizersConfig {
			@Bean
			@Order(50)
			PulsarContainerFactoryCustomizer<DefaultReactivePulsarListenerContainerFactory<?>> customizerIgnored() {
				return (containerFactory) -> {
					throw new IllegalStateException('should-not-have-matched');
				};
			}
			@Bean
			@Order(200)
			PulsarContainerFactoryCustomizer<ConcurrentPulsarListenerContainerFactory<?>> customizerFoo() {
				return (containerFactory) -> appendToSubscriptionName(containerFactory, ':foo');
			}
			@Bean
			@Order(100)
			PulsarContainerFactoryCustomizer<ConcurrentPulsarListenerContainerFactory<?>> customizerBar() {
				return (containerFactory) -> appendToSubscriptionName(containerFactory, ':bar');
			}
			private void appendToSubscriptionName(ConcurrentPulsarListenerContainerFactory<?> containerFactory,
					String valueToAppend) {
				String subscriptionName = containerFactory.getContainerProperties().getSubscriptionName();
				String updatedValue = (subscriptionName != null) ? subscriptionName + valueToAppend : valueToAppend;
				containerFactory.getContainerProperties().setSubscriptionName(updatedValue);
			}
		}
	}
	@Nested
	class ReaderFactoryTests {
		private final ApplicationContextRunner contextRunner = PulsarAutoConfigurationTests.this.contextRunner;
		@Test
		@SuppressWarnings('unchecked')
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			PulsarReaderFactory<String> readerFactory = mock(PulsarReaderFactory.class);
			this.contextRunner.withBean('customPulsarReaderFactory', PulsarReaderFactory.class, () -> readerFactory)
				.run((context) -> assertThat(context).getBean(PulsarReaderFactory.class).isSameAs(readerFactory));
		}
		@Test
		void injectsExpectedBeans() {
			this.contextRunner.run((context) -> assertThat(context).getBean(DefaultPulsarReaderFactory.class)
				.hasFieldOrPropertyWithValue('pulsarClient', context.getBean(PulsarClient.class))
				.extracting('topicBuilder')
				.isNotNull());
		}
		@Test
		void hasNoTopicBuilderWhenTopicDefaultsAreDisabled() {
			this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
				.run((context) -> assertThat(context).getBean(DefaultPulsarReaderFactory.class)
					.extracting('topicBuilder')
					.isNull());
		}
		@Test
		<T> void whenHasUserDefinedReaderBuilderCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withPropertyValues('spring.pulsar.reader.name=fromPropsCustomizer')
				.withUserConfiguration(ReaderBuilderCustomizersConfig.class)
				.run((context) -> {
					DefaultPulsarReaderFactory<?> readerFactory = context.getBean(DefaultPulsarReaderFactory.class);
					Customizers<ReaderBuilderCustomizer<T>, ReaderBuilder<T>> customizers = Customizers
						.of(ReaderBuilder.class, ReaderBuilderCustomizer::customize);
					assertThat(customizers.fromField(readerFactory, 'defaultConfigCustomizers')).callsInOrder(
							ReaderBuilder::readerName, 'fromPropsCustomizer', 'fromCustomizer1', 'fromCustomizer2');
				});
		}
		@Test
		@EnabledForJreRange(min = JRE.JAVA_21)
		void whenVirtualThreadsAreEnabledOnJava21AndLaterReaderShouldUseVirtualThreads() {
			this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
				DefaultPulsarReaderContainerFactory<?> factory = context
					.getBean(DefaultPulsarReaderContainerFactory.class);
				assertThat(factory.getContainerProperties().getReaderTaskExecutor())
					.isInstanceOf(VirtualThreadTaskExecutor.class);
				Object taskExecutor = factory.getContainerProperties().getReaderTaskExecutor();
				Object virtualThread = ReflectionTestUtils.getField(taskExecutor, 'virtualThreadFactory');
				Thread threadCreated = ((ThreadFactory) virtualThread).newThread(mock(Runnable.class));
				assertThat(threadCreated.getName()).containsPattern('pulsar-reader-[0-9]+');
			});
		}
		@Test
		@EnabledForJreRange(max = JRE.JAVA_20)
		void whenVirtualThreadsAreEnabledOnJava20AndEarlierReaderShouldNotUseVirtualThreads() {
			this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
				DefaultPulsarReaderContainerFactory<?> factory = context
					.getBean(DefaultPulsarReaderContainerFactory.class);
				assertThat(factory.getContainerProperties().getReaderTaskExecutor()).isNull();
			});
		}
		@Test
		void whenHasUserDefinedFactoryCustomizersAppliesInCorrectOrder() {
			this.contextRunner.withUserConfiguration(ReaderContainerFactoryCustomizersConfig.class)
				.run((context) -> assertThat(context).getBean(DefaultPulsarReaderContainerFactory.class)
					.hasFieldOrPropertyWithValue('containerProperties.readerListener', ':bar:foo'));
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ReaderBuilderCustomizersConfig {
			@Bean
			@Order(200)
			ReaderBuilderCustomizer<?> customizerFoo() {
				return (builder) -> builder.readerName('fromCustomizer2');
			}
			@Bean
			@Order(100)
			ReaderBuilderCustomizer<?> customizerBar() {
				return (builder) -> builder.readerName('fromCustomizer1');
			}
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class ReaderContainerFactoryCustomizersConfig {
			@Bean
			@Order(50)
			PulsarContainerFactoryCustomizer<DefaultReactivePulsarListenerContainerFactory<?>> customizerIgnored() {
				return (containerFactory) -> {
					throw new IllegalStateException('should-not-have-matched');
				};
			}
			@Bean
			@Order(200)
			PulsarContainerFactoryCustomizer<DefaultPulsarReaderContainerFactory<?>> customizerFoo() {
				return (containerFactory) -> appendToReaderListener(containerFactory, ':foo');
			}
			@Bean
			@Order(100)
			PulsarContainerFactoryCustomizer<DefaultPulsarReaderContainerFactory<?>> customizerBar() {
				return (containerFactory) -> appendToReaderListener(containerFactory, ':bar');
			}
			private void appendToReaderListener(DefaultPulsarReaderContainerFactory<?> containerFactory,
					String valueToAppend) {
				Object readerListener = containerFactory.getContainerProperties().getReaderListener();
				String updatedValue = (readerListener != null) ? readerListener + valueToAppend : valueToAppend;
				containerFactory.getContainerProperties().setReaderListener(updatedValue);
			}
		}
	}
	@Nested
	class TransactionManagerTests {
		private final ApplicationContextRunner contextRunner = PulsarAutoConfigurationTests.this.contextRunner;
		@Test
		@SuppressWarnings('unchecked')
		void whenUserHasDefinedATransactionManagerTheAutoConfigurationBacksOff() {
			PulsarAwareTransactionManager txnMgr = mock(PulsarAwareTransactionManager.class);
			this.contextRunner.withBean('customTransactionManager', PulsarAwareTransactionManager.class, () -> txnMgr)
				.run((context) -> assertThat(context).getBean(PulsarAwareTransactionManager.class).isSameAs(txnMgr));
		}
		@Test
		void whenNoPropertiesAreSetTransactionManagerShouldNotBeDefined() {
			this.contextRunner
				.run((context) -> assertThat(context).doesNotHaveBean(PulsarAwareTransactionManager.class));
		}
		@Test
		void whenTransactionEnabledFalseTransactionManagerIsNotAutoConfigured() {
			this.contextRunner.withPropertyValues('spring.pulsar.transaction.enabled=false')
				.run((context) -> assertThat(context).doesNotHaveBean(PulsarAwareTransactionManager.class));
		}
		@Test
		void whenTransactionEnabledTrueTransactionManagerIsAutoConfigured() {
			this.contextRunner.withPropertyValues('spring.pulsar.transaction.enabled=true')
				.run((context) -> assertThat(context).hasSingleBean(PulsarAwareTransactionManager.class));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
final class Customizers<C, T> {
	private final BiConsumer<C, T> customizeAction;
	private final Class<T> targetClass;
	@SuppressWarnings('unchecked')
	private Customizers(Class<?> targetClass, BiConsumer<C, T> customizeAction) {
		this.customizeAction = customizeAction;
		this.targetClass = (Class<T>) targetClass;
	}
	/**
	 * Create an instance by getting the value from a field.
	 * @param source the source to extract the customizers from
	 * @param fieldName the field name
	 * @return a new {@link CustomizersAssert} instance
	 */
	@SuppressWarnings('unchecked')
	CustomizersAssert fromField(Object source, String fieldName) {
		return new CustomizersAssert(ReflectionTestUtils.getField(source, fieldName));
	}
	/**
	 * Create a new {@link Customizers} instance.
	 * @param <C> the customizer class
	 * @param <T> the target class that is customized
	 * @param targetClass the target class that is customized
	 * @param customizeAction the customizer action to take
	 * @return a new {@link Customizers} instance
	 */
	static <C, T> Customizers<C, T> of(Class<?> targetClass, BiConsumer<C, T> customizeAction) {
		return new Customizers<>(targetClass, customizeAction);
	}
	/**
	 * Assertions that can be applied to customizers.
	 */
	final class CustomizersAssert implements AssertDelegateTarget {
		private final List<C> customizers;
		@SuppressWarnings('unchecked')
		private CustomizersAssert(Object customizers) {
			this.customizers = (customizers instanceof List) ? (List<C>) customizers : List.of((C) customizers);
		}
		/**
		 * Assert that the customize method is called in a specified order. It is expected
		 * that each customizer has set a unique value so the expected values can be used
		 * as a verify step.
		 * @param <V> the value type
		 * @param call the call the customizer makes
		 * @param expectedValues the expected values
		 */
		@SuppressWarnings('unchecked')
		<V> void callsInOrder(BiConsumer<T, V> call, V... expectedValues) {
			T target = mock(Customizers.this.targetClass);
			BiConsumer<C, T> customizeAction = Customizers.this.customizeAction;
			this.customizers.forEach((customizer) -> customizeAction.accept(customizer, target));
			InOrder ordered = inOrder(target);
			for (V expectedValue : expectedValues) {
				call.accept(ordered.verify(target), expectedValue);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(PulsarConfiguration.class))
		.withBean(PulsarClient.class, () -> mock(PulsarClient.class));
	@Test
	void whenHasUserDefinedConnectionDetailsBeanDoesNotAutoConfigureBean() {
		PulsarConnectionDetails customConnectionDetails = mock(PulsarConnectionDetails.class);
		this.contextRunner
			.withBean('customPulsarConnectionDetails', PulsarConnectionDetails.class, () -> customConnectionDetails)
			.run((context) -> assertThat(context).getBean(PulsarConnectionDetails.class)
				.isSameAs(customConnectionDetails));
	}
	@Test
	void whenHasUserDefinedContainerFactoryCustomizersBeanDoesNotAutoConfigureBean() {
		PulsarContainerFactoryCustomizers customizers = mock(PulsarContainerFactoryCustomizers.class);
		this.contextRunner
			.withBean('customContainerFactoryCustomizers', PulsarContainerFactoryCustomizers.class, () -> customizers)
			.run((context) -> assertThat(context).getBean(PulsarContainerFactoryCustomizers.class)
				.isSameAs(customizers));
	}
	@Nested
	class ClientTests {
		@Test
		void whenHasUserDefinedClientFactoryBeanDoesNotAutoConfigureBean() {
			PulsarClientFactory customFactory = mock(PulsarClientFactory.class);
			new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(PulsarConfiguration.class))
				.withBean('customPulsarClientFactory', PulsarClientFactory.class, () -> customFactory)
				.run((context) -> assertThat(context).getBean(PulsarClientFactory.class).isSameAs(customFactory));
		}
		@Test
		void whenHasUserDefinedClientBeanDoesNotAutoConfigureBean() {
			PulsarClient customClient = mock(PulsarClient.class);
			new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(PulsarConfiguration.class))
				.withBean('customPulsarClient', PulsarClient.class, () -> customClient)
				.run((context) -> assertThat(context).getBean(PulsarClient.class).isSameAs(customClient));
		}
		@Test
		void whenHasUserDefinedCustomizersAppliesInCorrectOrder() {
			PulsarConnectionDetails connectionDetails = mock(PulsarConnectionDetails.class);
			given(connectionDetails.getBrokerUrl()).willReturn('connectiondetails');
			PulsarConfigurationTests.this.contextRunner
				.withUserConfiguration(PulsarClientBuilderCustomizersConfig.class)
				.withBean(PulsarConnectionDetails.class, () -> connectionDetails)
				.withPropertyValues('spring.pulsar.client.service-url=properties')
				.run((context) -> {
					DefaultPulsarClientFactory clientFactory = context.getBean(DefaultPulsarClientFactory.class);
					Customizers<PulsarClientBuilderCustomizer, ClientBuilder> customizers = Customizers
						.of(ClientBuilder.class, PulsarClientBuilderCustomizer::customize);
					assertThat(customizers.fromField(clientFactory, 'customizer')).callsInOrder(
							ClientBuilder::serviceUrl, 'connectiondetails', 'fromCustomizer1', 'fromCustomizer2');
				});
		}
		@Test
		void whenHasUserDefinedFailoverPropertiesAddsToClient() {
			PulsarConnectionDetails connectionDetails = mock(PulsarConnectionDetails.class);
			given(connectionDetails.getBrokerUrl()).willReturn('connectiondetails');
			PulsarConfigurationTests.this.contextRunner.withBean(PulsarConnectionDetails.class, () -> connectionDetails)
				.withPropertyValues('spring.pulsar.client.service-url=properties',
						'spring.pulsar.client.failover.backup-clusters[0].service-url=backup-cluster-1',
						'spring.pulsar.client.failover.delay=15s',
						'spring.pulsar.client.failover.switch-back-delay=30s',
						'spring.pulsar.client.failover.check-interval=5s',
						'spring.pulsar.client.failover.backup-clusters[1].service-url=backup-cluster-2',
						'spring.pulsar.client.failover.backup-clusters[1].authentication.plugin-class-name=org.springframework.boot.autoconfigure.pulsar.MockAuthentication',
						'spring.pulsar.client.failover.backup-clusters[1].authentication.param.token=1234')
				.run((context) -> {
					DefaultPulsarClientFactory clientFactory = context.getBean(DefaultPulsarClientFactory.class);
					PulsarProperties pulsarProperties = context.getBean(PulsarProperties.class);
					ClientBuilder target = mock(ClientBuilder.class);
					BiConsumer<PulsarClientBuilderCustomizer, ClientBuilder> customizeAction = PulsarClientBuilderCustomizer::customize;
					PulsarClientBuilderCustomizer pulsarClientBuilderCustomizer = (PulsarClientBuilderCustomizer) ReflectionTestUtils
						.getField(clientFactory, 'customizer');
					customizeAction.accept(pulsarClientBuilderCustomizer, target);
					InOrder ordered = inOrder(target);
					ordered.verify(target).serviceUrlProvider(Mockito.any(AutoClusterFailover.class));
					assertThat(pulsarProperties.getClient().getFailover().getDelay()).isEqualTo(Duration.ofSeconds(15));
					assertThat(pulsarProperties.getClient().getFailover().getSwitchBackDelay())
						.isEqualTo(Duration.ofSeconds(30));
					assertThat(pulsarProperties.getClient().getFailover().getCheckInterval())
						.isEqualTo(Duration.ofSeconds(5));
					assertThat(pulsarProperties.getClient().getFailover().getBackupClusters().size()).isEqualTo(2);
				});
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class PulsarClientBuilderCustomizersConfig {
			@Bean
			@Order(200)
			PulsarClientBuilderCustomizer customizerFoo() {
				return (builder) -> builder.serviceUrl('fromCustomizer2');
			}
			@Bean
			@Order(100)
			PulsarClientBuilderCustomizer customizerBar() {
				return (builder) -> builder.serviceUrl('fromCustomizer1');
			}
		}
	}
	@Nested
	class AdministrationTests {
		private final ApplicationContextRunner contextRunner = PulsarConfigurationTests.this.contextRunner;
		@Test
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			PulsarAdministration pulsarAdministration = mock(PulsarAdministration.class);
			this.contextRunner
				.withBean('customPulsarAdministration', PulsarAdministration.class, () -> pulsarAdministration)
				.run((context) -> assertThat(context).getBean(PulsarAdministration.class)
					.isSameAs(pulsarAdministration));
		}
		@Test
		void whenHasUserDefinedCustomizersAppliesInCorrectOrder() {
			PulsarConnectionDetails connectionDetails = mock(PulsarConnectionDetails.class);
			given(connectionDetails.getAdminUrl()).willReturn('connectiondetails');
			this.contextRunner.withUserConfiguration(PulsarAdminBuilderCustomizersConfig.class)
				.withBean(PulsarConnectionDetails.class, () -> connectionDetails)
				.withPropertyValues('spring.pulsar.admin.service-url=property')
				.run((context) -> {
					PulsarAdministration pulsarAdmin = context.getBean(PulsarAdministration.class);
					Customizers<PulsarAdminBuilderCustomizer, PulsarAdminBuilder> customizers = Customizers
						.of(PulsarAdminBuilder.class, PulsarAdminBuilderCustomizer::customize);
					assertThat(customizers.fromField(pulsarAdmin, 'adminCustomizers')).callsInOrder(
							PulsarAdminBuilder::serviceHttpUrl, 'connectiondetails', 'fromCustomizer1',
							'fromCustomizer2');
				});
		}
		@TestConfiguration(proxyBeanMethods = false)
		static class PulsarAdminBuilderCustomizersConfig {
			@Bean
			@Order(200)
			PulsarAdminBuilderCustomizer customizerFoo() {
				return (builder) -> builder.serviceHttpUrl('fromCustomizer2');
			}
			@Bean
			@Order(100)
			PulsarAdminBuilderCustomizer customizerBar() {
				return (builder) -> builder.serviceHttpUrl('fromCustomizer1');
			}
		}
	}
	@Nested
	class SchemaResolverTests {
		@SuppressWarnings('rawtypes')
		private static final InstanceOfAssertFactory<Map, MapAssert<Class, Schema>> CLASS_SCHEMA_MAP = InstanceOfAssertFactories
			.map(Class.class, Schema.class);
		private final ApplicationContextRunner contextRunner = PulsarConfigurationTests.this.contextRunner;
		@Test
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			SchemaResolver schemaResolver = mock(SchemaResolver.class);
			this.contextRunner.withBean('customSchemaResolver', SchemaResolver.class, () -> schemaResolver)
				.run((context) -> assertThat(context).getBean(SchemaResolver.class).isSameAs(schemaResolver));
		}
		@Test
		void whenHasUserDefinedSchemaResolverCustomizer() {
			SchemaResolverCustomizer<DefaultSchemaResolver> customizer = (schemaResolver) -> schemaResolver
				.addCustomSchemaMapping(TestRecord.class, Schema.STRING);
			this.contextRunner.withBean('schemaResolverCustomizer', SchemaResolverCustomizer.class, () -> customizer)
				.run((context) -> assertThat(context).getBean(DefaultSchemaResolver.class)
					.extracting(DefaultSchemaResolver::getCustomSchemaMappings, InstanceOfAssertFactories.MAP)
					.containsEntry(TestRecord.class, Schema.STRING));
		}
		@Test
		void whenHasDefaultsTypeMappingForPrimitiveAddsToSchemaResolver() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.defaults.type-mappings[0].message-type=' + TestRecord.CLASS_NAME);
			properties.add('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type=STRING');
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new))
				.run((context) -> assertThat(context).getBean(DefaultSchemaResolver.class)
					.extracting(DefaultSchemaResolver::getCustomSchemaMappings, InstanceOfAssertFactories.MAP)
					.containsOnly(entry(TestRecord.class, Schema.STRING)));
		}
		@Test
		void whenHasDefaultsTypeMappingForStructAddsToSchemaResolver() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.defaults.type-mappings[0].message-type=' + TestRecord.CLASS_NAME);
			properties.add('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type=JSON');
			Schema<?> expectedSchema = Schema.JSON(TestRecord.class);
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new))
				.run((context) -> assertThat(context).getBean(DefaultSchemaResolver.class)
					.extracting(DefaultSchemaResolver::getCustomSchemaMappings, CLASS_SCHEMA_MAP)
					.hasEntrySatisfying(TestRecord.class, schemaEqualTo(expectedSchema)));
		}
		@Test
		void whenHasDefaultsTypeMappingForKeyValueAddsToSchemaResolver() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.defaults.type-mappings[0].message-type=' + TestRecord.CLASS_NAME);
			properties.add('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type=key-value');
			properties.add('spring.pulsar.defaults.type-mappings[0].schema-info.message-key-type=java.lang.String');
			Schema<?> expectedSchema = Schema.KeyValue(Schema.STRING, Schema.JSON(TestRecord.class),
					KeyValueEncodingType.INLINE);
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new))
				.run((context) -> assertThat(context).getBean(DefaultSchemaResolver.class)
					.extracting(DefaultSchemaResolver::getCustomSchemaMappings, CLASS_SCHEMA_MAP)
					.hasEntrySatisfying(TestRecord.class, schemaEqualTo(expectedSchema)));
		}
		@SuppressWarnings('rawtypes')
		private Consumer<Schema> schemaEqualTo(Schema<?> expected) {
			return (actual) -> assertThat(actual.getSchemaInfo()).isEqualTo(expected.getSchemaInfo());
		}
	}
	@Nested
	class TopicResolverTests {
		private final ApplicationContextRunner contextRunner = PulsarConfigurationTests.this.contextRunner;
		@Test
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			TopicResolver topicResolver = mock(TopicResolver.class);
			this.contextRunner.withBean('customTopicResolver', TopicResolver.class, () -> topicResolver)
				.run((context) -> assertThat(context).getBean(TopicResolver.class).isSameAs(topicResolver));
		}
		@Test
		void whenHasDefaultsTypeMappingAddsToSchemaResolver() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.defaults.type-mappings[0].message-type=' + TestRecord.CLASS_NAME);
			properties.add('spring.pulsar.defaults.type-mappings[0].topic-name=foo-topic');
			properties.add('spring.pulsar.defaults.type-mappings[1].message-type=java.lang.String');
			properties.add('spring.pulsar.defaults.type-mappings[1].topic-name=string-topic');
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new))
				.run((context) -> assertThat(context).getBean(TopicResolver.class)
					.asInstanceOf(InstanceOfAssertFactories.type(DefaultTopicResolver.class))
					.extracting(DefaultTopicResolver::getCustomTopicMappings, InstanceOfAssertFactories.MAP)
					.containsOnly(entry(TestRecord.class, 'foo-topic'), entry(String.class, 'string-topic')));
		}
	}
	@Nested
	class TopicBuilderTests {
		private final ApplicationContextRunner contextRunner = PulsarConfigurationTests.this.contextRunner;
		@Test
		void whenHasUserDefinedBeanDoesNotAutoConfigureBean() {
			PulsarTopicBuilder topicBuilder = mock(PulsarTopicBuilder.class);
			this.contextRunner.withBean('customPulsarTopicBuilder', PulsarTopicBuilder.class, () -> topicBuilder)
				.run((context) -> assertThat(context).getBean(PulsarTopicBuilder.class).isSameAs(topicBuilder));
		}
		@Test
		void whenHasDefaultsTopicDisabledPropertyDoesNotCreateBean() {
			this.contextRunner.withPropertyValues('spring.pulsar.defaults.topic.enabled=false')
				.run((context) -> assertThat(context).doesNotHaveBean(PulsarTopicBuilder.class));
		}
		@Test
		void whenHasDefaultsTenantAndNamespaceAppliedToTopicBuilder() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.defaults.topic.tenant=my-tenant');
			properties.add('spring.pulsar.defaults.topic.namespace=my-namespace');
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new))
				.run((context) -> assertThat(context).getBean(PulsarTopicBuilder.class)
					.asInstanceOf(InstanceOfAssertFactories.type(PulsarTopicBuilder.class))
					.satisfies((topicBuilder) -> {
						assertThat(topicBuilder).hasFieldOrPropertyWithValue('defaultTenant', 'my-tenant');
						assertThat(topicBuilder).hasFieldOrPropertyWithValue('defaultNamespace', 'my-namespace');
					}));
		}
		@Test
		void beanHasScopePrototype() {
			this.contextRunner.run((context) -> assertThat(context.getBean(PulsarTopicBuilder.class))
				.isNotSameAs(context.getBean(PulsarTopicBuilder.class)));
		}
	}
	@Nested
	class FunctionAdministrationTests {
		private final ApplicationContextRunner contextRunner = PulsarConfigurationTests.this.contextRunner;
		@Test
		void whenNoPropertiesAddsFunctionAdministrationBean() {
			this.contextRunner.run((context) -> assertThat(context).getBean(PulsarFunctionAdministration.class)
				.hasFieldOrPropertyWithValue('failFast', Boolean.TRUE)
				.hasFieldOrPropertyWithValue('propagateFailures', Boolean.TRUE)
				.hasFieldOrPropertyWithValue('propagateStopFailures', Boolean.FALSE)
				.hasNoNullFieldsOrProperties() // ensures object providers set
				.extracting('pulsarAdministration')
				.isSameAs(context.getBean(PulsarAdministration.class)));
		}
		@Test
		void whenHasFunctionPropertiesAppliesPropertiesToBean() {
			List<String> properties = new ArrayList<>();
			properties.add('spring.pulsar.function.fail-fast=false');
			properties.add('spring.pulsar.function.propagate-failures=false');
			properties.add('spring.pulsar.function.propagate-stop-failures=true');
			this.contextRunner.withPropertyValues(properties.toArray(String[]::new))
				.run((context) -> assertThat(context).getBean(PulsarFunctionAdministration.class)
					.hasFieldOrPropertyWithValue('failFast', Boolean.FALSE)
					.hasFieldOrPropertyWithValue('propagateFailures', Boolean.FALSE)
					.hasFieldOrPropertyWithValue('propagateStopFailures', Boolean.TRUE));
		}
		@Test
		void whenHasFunctionDisabledPropertyDoesNotCreateBean() {
			this.contextRunner.withPropertyValues('spring.pulsar.function.enabled=false')
				.run((context) -> assertThat(context).doesNotHaveBean(PulsarFunctionAdministration.class));
		}
		@Test
		void whenHasCustomFunctionAdministrationBean() {
			PulsarFunctionAdministration functionAdministration = mock(PulsarFunctionAdministration.class);
			this.contextRunner.withBean(PulsarFunctionAdministration.class, () -> functionAdministration)
				.run((context) -> assertThat(context).getBean(PulsarFunctionAdministration.class)
					.isSameAs(functionAdministration));
		}
	}
	record TestRecord() {
		private static final String CLASS_NAME = TestRecord.class.getName();
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarPropertiesMapperTests {
	@Test
	void customizeClientBuilderWhenHasNoAuthentication() {
		PulsarProperties properties = new PulsarProperties();
		properties.getClient().setServiceUrl('https://example.com');
		properties.getClient().setConnectionTimeout(Duration.ofSeconds(1));
		properties.getClient().setOperationTimeout(Duration.ofSeconds(2));
		properties.getClient().setLookupTimeout(Duration.ofSeconds(3));
		properties.getClient().getThreads().setIo(3);
		properties.getClient().getThreads().setListener(10);
		ClientBuilder builder = mock(ClientBuilder.class);
		new PulsarPropertiesMapper(properties).customizeClientBuilder(builder,
				new PropertiesPulsarConnectionDetails(properties));
		then(builder).should().serviceUrl('https://example.com');
		then(builder).should().connectionTimeout(1000, TimeUnit.MILLISECONDS);
		then(builder).should().operationTimeout(2000, TimeUnit.MILLISECONDS);
		then(builder).should().lookupTimeout(3000, TimeUnit.MILLISECONDS);
		then(builder).should().ioThreads(3);
		then(builder).should().listenerThreads(10);
	}
	@Test
	void customizeClientBuilderWhenHasAuthentication() throws UnsupportedAuthenticationException {
		PulsarProperties properties = new PulsarProperties();
		Map<String, String> params = Map.of('simpleParam', 'foo', 'complexParam',
				'{\n\t\'k1\' : \'v1\',\n\t\'k2\':\'v2\'\n}');
		String authParamString = '{\'complexParam\':\'{\\n\\t\\\'k1\\\' : \\\'v1\\\',\\n\\t\\\'k2\\\':\\\'v2\\\'\\n}\''
				+ ',\'simpleParam\':\'foo\'}';
		properties.getClient().getAuthentication().setPluginClassName('myclass');
		properties.getClient().getAuthentication().setParam(params);
		ClientBuilder builder = mock(ClientBuilder.class);
		new PulsarPropertiesMapper(properties).customizeClientBuilder(builder,
				new PropertiesPulsarConnectionDetails(properties));
		then(builder).should().authentication('myclass', authParamString);
	}
	@Test
	void customizeClientBuilderWhenTransactionEnabled() {
		PulsarProperties properties = new PulsarProperties();
		properties.getTransaction().setEnabled(true);
		ClientBuilder builder = mock(ClientBuilder.class);
		new PulsarPropertiesMapper(properties).customizeClientBuilder(builder,
				new PropertiesPulsarConnectionDetails(properties));
		then(builder).should().enableTransaction(true);
	}
	@Test
	void customizeClientBuilderWhenTransactionDisabled() {
		PulsarProperties properties = new PulsarProperties();
		properties.getTransaction().setEnabled(false);
		ClientBuilder builder = mock(ClientBuilder.class);
		new PulsarPropertiesMapper(properties).customizeClientBuilder(builder,
				new PropertiesPulsarConnectionDetails(properties));
		then(builder).should(never()).enableTransaction(anyBoolean());
	}
	@Test
	void customizeClientBuilderWhenHasConnectionDetails() {
		PulsarProperties properties = new PulsarProperties();
		properties.getClient().setServiceUrl('https://ignored.example.com');
		ClientBuilder builder = mock(ClientBuilder.class);
		PulsarConnectionDetails connectionDetails = mock(PulsarConnectionDetails.class);
		given(connectionDetails.getBrokerUrl()).willReturn('https://used.example.com');
		new PulsarPropertiesMapper(properties).customizeClientBuilder(builder, connectionDetails);
		then(builder).should().serviceUrl('https://used.example.com');
	}
	@Test
	void customizeClientBuilderWhenHasFailover() {
		BackupCluster backupCluster1 = new BackupCluster();
		backupCluster1.setServiceUrl('backup-cluster-1');
		Map<String, String> params = Map.of('param', 'name');
		backupCluster1.getAuthentication()
			.setPluginClassName('org.springframework.boot.autoconfigure.pulsar.MockAuthentication');
		backupCluster1.getAuthentication().setParam(params);
		BackupCluster backupCluster2 = new BackupCluster();
		backupCluster2.setServiceUrl('backup-cluster-2');
		PulsarProperties properties = new PulsarProperties();
		properties.getClient().setServiceUrl('https://used.example.com');
		properties.getClient().getFailover().setPolicy(FailoverPolicy.ORDER);
		properties.getClient().getFailover().setCheckInterval(Duration.ofSeconds(5));
		properties.getClient().getFailover().setDelay(Duration.ofSeconds(30));
		properties.getClient().getFailover().setSwitchBackDelay(Duration.ofSeconds(30));
		properties.getClient().getFailover().setBackupClusters(List.of(backupCluster1, backupCluster2));
		PulsarConnectionDetails connectionDetails = mock(PulsarConnectionDetails.class);
		given(connectionDetails.getBrokerUrl()).willReturn('https://used.example.com');
		ClientBuilder builder = mock(ClientBuilder.class);
		new PulsarPropertiesMapper(properties).customizeClientBuilder(builder,
				new PropertiesPulsarConnectionDetails(properties));
		then(builder).should().serviceUrlProvider(any(AutoClusterFailover.class));
	}
	@Test
	void customizeAdminBuilderWhenHasNoAuthentication() {
		PulsarProperties properties = new PulsarProperties();
		properties.getAdmin().setServiceUrl('https://example.com');
		properties.getAdmin().setConnectionTimeout(Duration.ofSeconds(1));
		properties.getAdmin().setReadTimeout(Duration.ofSeconds(2));
		properties.getAdmin().setRequestTimeout(Duration.ofSeconds(3));
		PulsarAdminBuilder builder = mock(PulsarAdminBuilder.class);
		new PulsarPropertiesMapper(properties).customizeAdminBuilder(builder,
				new PropertiesPulsarConnectionDetails(properties));
		then(builder).should().serviceHttpUrl('https://example.com');
		then(builder).should().connectionTimeout(1000, TimeUnit.MILLISECONDS);
		then(builder).should().readTimeout(2000, TimeUnit.MILLISECONDS);
		then(builder).should().requestTimeout(3000, TimeUnit.MILLISECONDS);
	}
	@Test
	void customizeAdminBuilderWhenHasAuthentication() throws UnsupportedAuthenticationException {
		PulsarProperties properties = new PulsarProperties();
		Map<String, String> params = Map.of('simpleParam', 'foo', 'complexParam',
				'{\n\t\'k1\' : \'v1\',\n\t\'k2\':\'v2\'\n}');
		String authParamString = '{\'complexParam\':\'{\\n\\t\\\'k1\\\' : \\\'v1\\\',\\n\\t\\\'k2\\\':\\\'v2\\\'\\n}\''
				+ ',\'simpleParam\':\'foo\'}';
		properties.getAdmin().getAuthentication().setPluginClassName('myclass');
		properties.getAdmin().getAuthentication().setParam(params);
		PulsarAdminBuilder builder = mock(PulsarAdminBuilder.class);
		new PulsarPropertiesMapper(properties).customizeAdminBuilder(builder,
				new PropertiesPulsarConnectionDetails(properties));
		then(builder).should().authentication('myclass', authParamString);
	}
	@Test
	void customizeAdminBuilderWhenHasConnectionDetails() {
		PulsarProperties properties = new PulsarProperties();
		properties.getAdmin().setServiceUrl('https://ignored.example.com');
		PulsarAdminBuilder builder = mock(PulsarAdminBuilder.class);
		PulsarConnectionDetails connectionDetails = mock(PulsarConnectionDetails.class);
		given(connectionDetails.getAdminUrl()).willReturn('https://used.example.com');
		new PulsarPropertiesMapper(properties).customizeAdminBuilder(builder, connectionDetails);
		then(builder).should().serviceHttpUrl('https://used.example.com');
	}
	@Test
	@SuppressWarnings('unchecked')
	void customizeProducerBuilder() {
		PulsarProperties properties = new PulsarProperties();
		properties.getProducer().setName('name');
		properties.getProducer().setTopicName('topicname');
		properties.getProducer().setSendTimeout(Duration.ofSeconds(1));
		properties.getProducer().setMessageRoutingMode(MessageRoutingMode.RoundRobinPartition);
		properties.getProducer().setHashingScheme(HashingScheme.JavaStringHash);
		properties.getProducer().setBatchingEnabled(false);
		properties.getProducer().setChunkingEnabled(true);
		properties.getProducer().setCompressionType(CompressionType.SNAPPY);
		properties.getProducer().setAccessMode(ProducerAccessMode.Exclusive);
		ProducerBuilder<Object> builder = mock(ProducerBuilder.class);
		new PulsarPropertiesMapper(properties).customizeProducerBuilder(builder);
		then(builder).should().producerName('name');
		then(builder).should().topic('topicname');
		then(builder).should().sendTimeout(1000, TimeUnit.MILLISECONDS);
		then(builder).should().messageRoutingMode(MessageRoutingMode.RoundRobinPartition);
		then(builder).should().hashingScheme(HashingScheme.JavaStringHash);
		then(builder).should().enableBatching(false);
		then(builder).should().enableChunking(true);
		then(builder).should().compressionType(CompressionType.SNAPPY);
		then(builder).should().accessMode(ProducerAccessMode.Exclusive);
	}
	@Test
	@SuppressWarnings('unchecked')
	void customizeTemplate() {
		PulsarProperties properties = new PulsarProperties();
		properties.getTransaction().setEnabled(true);
		PulsarTemplate<Object> template = new PulsarTemplate<>(mock(PulsarProducerFactory.class));
		new PulsarPropertiesMapper(properties).customizeTemplate(template);
		assertThat(template.transactions().isEnabled()).isTrue();
	}
	@Test
	@SuppressWarnings('unchecked')
	void customizeConsumerBuilder() {
		PulsarProperties properties = new PulsarProperties();
		List<String> topics = List.of('mytopic');
		Pattern topisPattern = Pattern.compile('my-pattern');
		properties.getConsumer().setName('name');
		properties.getConsumer().setTopics(topics);
		properties.getConsumer().setTopicsPattern(topisPattern);
		properties.getConsumer().setPriorityLevel(123);
		properties.getConsumer().setReadCompacted(true);
		Consumer.DeadLetterPolicy deadLetterPolicy = new Consumer.DeadLetterPolicy();
		deadLetterPolicy.setDeadLetterTopic('my-dlt');
		deadLetterPolicy.setMaxRedeliverCount(1);
		properties.getConsumer().setDeadLetterPolicy(deadLetterPolicy);
		ConsumerBuilder<Object> builder = mock(ConsumerBuilder.class);
		new PulsarPropertiesMapper(properties).customizeConsumerBuilder(builder);
		then(builder).should().consumerName('name');
		then(builder).should().topics(topics);
		then(builder).should().topicsPattern(topisPattern);
		then(builder).should().priorityLevel(123);
		then(builder).should().readCompacted(true);
		then(builder).should().deadLetterPolicy(new DeadLetterPolicy(1, null, 'my-dlt', null));
	}
	@Test
	void customizeContainerProperties() {
		PulsarProperties properties = new PulsarProperties();
		properties.getConsumer().getSubscription().setType(SubscriptionType.Shared);
		properties.getConsumer().getSubscription().setName('my-subscription');
		properties.getListener().setSchemaType(SchemaType.AVRO);
		properties.getListener().setConcurrency(10);
		properties.getListener().setObservationEnabled(true);
		properties.getTransaction().setEnabled(true);
		PulsarContainerProperties containerProperties = new PulsarContainerProperties('my-topic-pattern');
		new PulsarPropertiesMapper(properties).customizeContainerProperties(containerProperties);
		assertThat(containerProperties.getSubscriptionType()).isEqualTo(SubscriptionType.Shared);
		assertThat(containerProperties.getSubscriptionName()).isEqualTo('my-subscription');
		assertThat(containerProperties.getSchemaType()).isEqualTo(SchemaType.AVRO);
		assertThat(containerProperties.getConcurrency()).isEqualTo(10);
		assertThat(containerProperties.isObservationEnabled()).isTrue();
		assertThat(containerProperties.transactions().isEnabled()).isTrue();
	}
	@Test
	@SuppressWarnings('unchecked')
	void customizeReaderBuilder() {
		PulsarProperties properties = new PulsarProperties();
		List<String> topics = List.of('mytopic');
		properties.getReader().setName('name');
		properties.getReader().setTopics(topics);
		properties.getReader().setSubscriptionName('subname');
		properties.getReader().setSubscriptionRolePrefix('subroleprefix');
		properties.getReader().setReadCompacted(true);
		ReaderBuilder<Object> builder = mock(ReaderBuilder.class);
		new PulsarPropertiesMapper(properties).customizeReaderBuilder(builder);
		then(builder).should().readerName('name');
		then(builder).should().topics(topics);
		then(builder).should().subscriptionName('subname');
		then(builder).should().subscriptionRolePrefix('subroleprefix');
		then(builder).should().readCompacted(true);
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarContainerFactoryCustomizersTests {
	@Test
	void customizeWithNullCustomizersShouldDoNothing() {
		PulsarContainerFactory<?, ?> containerFactory = mock(PulsarContainerFactory.class);
		new PulsarContainerFactoryCustomizers(null).customize(containerFactory);
		then(containerFactory).shouldHaveNoInteractions();
	}
	@Test
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	void customizeSimplePulsarContainerFactory() {
		PulsarContainerFactoryCustomizers customizers = new PulsarContainerFactoryCustomizers(
				Collections.singletonList(new SimplePulsarContainerFactoryCustomizer()));
		PulsarContainerProperties containerProperties = new PulsarContainerProperties();
		ConcurrentPulsarListenerContainerFactory<String> pulsarContainerFactory = new ConcurrentPulsarListenerContainerFactory<>(
				mock(PulsarConsumerFactory.class), containerProperties);
		customizers.customize(pulsarContainerFactory);
		assertThat(pulsarContainerFactory.getContainerProperties().getSubscriptionName()).isEqualTo('my-subscription');
	}
	@Test
	void customizeShouldCheckGeneric() {
		List<TestCustomizer<?>> list = new ArrayList<>();
		list.add(new TestCustomizer<>());
		list.add(new TestPulsarListenersContainerFactoryCustomizer());
		list.add(new TestConcurrentPulsarListenerContainerFactoryCustomizer());
		PulsarContainerFactoryCustomizers customizers = new PulsarContainerFactoryCustomizers(list);
		customizers.customize(mock(PulsarContainerFactory.class));
		assertThat(list.get(0).getCount()).isOne();
		assertThat(list.get(1).getCount()).isZero();
		assertThat(list.get(2).getCount()).isZero();
		customizers.customize(mock(ConcurrentPulsarListenerContainerFactory.class));
		assertThat(list.get(0).getCount()).isEqualTo(2);
		assertThat(list.get(1).getCount()).isOne();
		assertThat(list.get(2).getCount()).isOne();
		customizers.customize(mock(DefaultReactivePulsarListenerContainerFactory.class));
		assertThat(list.get(0).getCount()).isEqualTo(3);
		assertThat(list.get(1).getCount()).isEqualTo(2);
		assertThat(list.get(2).getCount()).isOne();
		customizers.customize(mock(DefaultPulsarReaderContainerFactory.class));
		assertThat(list.get(0).getCount()).isEqualTo(4);
		assertThat(list.get(1).getCount()).isEqualTo(2);
		assertThat(list.get(2).getCount()).isOne();
	}
	static class SimplePulsarContainerFactoryCustomizer
			implements PulsarContainerFactoryCustomizer<ConcurrentPulsarListenerContainerFactory<?>> {
		@Override
		public void customize(ConcurrentPulsarListenerContainerFactory<?> containerFactory) {
			containerFactory.getContainerProperties().setSubscriptionName('my-subscription');
		}
	}
	/**
	 * Test customizer that will match all {@link PulsarListenerContainerFactory}.
	 */
	static class TestCustomizer<T extends PulsarContainerFactory<?, ?>> implements PulsarContainerFactoryCustomizer<T> {
		private int count;
		@Override
		public void customize(T pulsarContainerFactory) {
			this.count++;
		}
		int getCount() {
			return this.count;
		}
	}
	/**
	 * Test customizer that will match both
	 * {@link ConcurrentPulsarListenerContainerFactory} and
	 * {@link DefaultReactivePulsarListenerContainerFactory} as they both extend
	 * {@link ListenerContainerFactory}.
	 */
	static class TestPulsarListenersContainerFactoryCustomizer extends TestCustomizer<ListenerContainerFactory<?, ?>> {
	}
	/**
	 * Test customizer that will match only
	 * {@link ConcurrentPulsarListenerContainerFactory}.
	 */
	static class TestConcurrentPulsarListenerContainerFactoryCustomizer
			extends TestCustomizer<ConcurrentPulsarListenerContainerFactory<?>> {
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarPropertiesTests {
	private PulsarProperties bindProperties(Map<String, String> map) {
		return new Binder(new MapConfigurationPropertySource(map)).bind('spring.pulsar', PulsarProperties.class).get();
	}
	@Nested
	class ClientProperties {
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.client.service-url', 'my-service-url');
			map.put('spring.pulsar.client.operation-timeout', '1s');
			map.put('spring.pulsar.client.lookup-timeout', '2s');
			map.put('spring.pulsar.client.connection-timeout', '12s');
			PulsarProperties.Client properties = bindProperties(map).getClient();
			assertThat(properties.getServiceUrl()).isEqualTo('my-service-url');
			assertThat(properties.getOperationTimeout()).isEqualTo(Duration.ofMillis(1000));
			assertThat(properties.getLookupTimeout()).isEqualTo(Duration.ofMillis(2000));
			assertThat(properties.getConnectionTimeout()).isEqualTo(Duration.ofMillis(12000));
		}
		@Test
		void bindAuthentication() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.client.authentication.plugin-class-name', 'com.example.MyAuth');
			map.put('spring.pulsar.client.authentication.param.token', '1234');
			PulsarProperties.Client properties = bindProperties(map).getClient();
			assertThat(properties.getAuthentication().getPluginClassName()).isEqualTo('com.example.MyAuth');
			assertThat(properties.getAuthentication().getParam()).containsEntry('token', '1234');
		}
		@Test
		void bindThread() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.client.threads.io', '3');
			map.put('spring.pulsar.client.threads.listener', '10');
			PulsarProperties.Client properties = bindProperties(map).getClient();
			assertThat(properties.getThreads().getIo()).isEqualTo(3);
			assertThat(properties.getThreads().getListener()).isEqualTo(10);
		}
		@Test
		void bindFailover() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.client.service-url', 'my-service-url');
			map.put('spring.pulsar.client.failover.delay', '30s');
			map.put('spring.pulsar.client.failover.switch-back-delay', '15s');
			map.put('spring.pulsar.client.failover.check-interval', '1s');
			map.put('spring.pulsar.client.failover.backup-clusters[0].service-url', 'backup-service-url-1');
			map.put('spring.pulsar.client.failover.backup-clusters[0].authentication.plugin-class-name',
					'com.example.MyAuth1');
			map.put('spring.pulsar.client.failover.backup-clusters[0].authentication.param.token', '1234');
			map.put('spring.pulsar.client.failover.backup-clusters[1].service-url', 'backup-service-url-2');
			map.put('spring.pulsar.client.failover.backup-clusters[1].authentication.plugin-class-name',
					'com.example.MyAuth2');
			map.put('spring.pulsar.client.failover.backup-clusters[1].authentication.param.token', '5678');
			PulsarProperties.Client properties = bindProperties(map).getClient();
			Failover failoverProperties = properties.getFailover();
			List<BackupCluster> backupClusters = properties.getFailover().getBackupClusters();
			assertThat(properties.getServiceUrl()).isEqualTo('my-service-url');
			assertThat(failoverProperties.getDelay()).isEqualTo(Duration.ofMillis(30000));
			assertThat(failoverProperties.getSwitchBackDelay()).isEqualTo(Duration.ofMillis(15000));
			assertThat(failoverProperties.getCheckInterval()).isEqualTo(Duration.ofMillis(1000));
			assertThat(backupClusters.get(0).getServiceUrl()).isEqualTo('backup-service-url-1');
			assertThat(backupClusters.get(0).getAuthentication().getPluginClassName()).isEqualTo('com.example.MyAuth1');
			assertThat(backupClusters.get(0).getAuthentication().getParam()).containsEntry('token', '1234');
			assertThat(backupClusters.get(1).getServiceUrl()).isEqualTo('backup-service-url-2');
			assertThat(backupClusters.get(1).getAuthentication().getPluginClassName()).isEqualTo('com.example.MyAuth2');
			assertThat(backupClusters.get(1).getAuthentication().getParam()).containsEntry('token', '5678');
		}
	}
	@Nested
	class AdminProperties {
		private final String authPluginClassName = 'org.apache.pulsar.client.impl.auth.AuthenticationToken';
		private final String authToken = '1234';
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.admin.service-url', 'my-service-url');
			map.put('spring.pulsar.admin.connection-timeout', '12s');
			map.put('spring.pulsar.admin.read-timeout', '13s');
			map.put('spring.pulsar.admin.request-timeout', '14s');
			PulsarProperties.Admin properties = bindProperties(map).getAdmin();
			assertThat(properties.getServiceUrl()).isEqualTo('my-service-url');
			assertThat(properties.getConnectionTimeout()).isEqualTo(Duration.ofSeconds(12));
			assertThat(properties.getReadTimeout()).isEqualTo(Duration.ofSeconds(13));
			assertThat(properties.getRequestTimeout()).isEqualTo(Duration.ofSeconds(14));
		}
		@Test
		void bindAuthentication() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.admin.authentication.plugin-class-name', this.authPluginClassName);
			map.put('spring.pulsar.admin.authentication.param.token', this.authToken);
			PulsarProperties.Admin properties = bindProperties(map).getAdmin();
			assertThat(properties.getAuthentication().getPluginClassName()).isEqualTo(this.authPluginClassName);
			assertThat(properties.getAuthentication().getParam()).containsEntry('token', this.authToken);
		}
	}
	@Nested
	class DefaultsTypeMappingProperties {
		@Test
		void bindWhenNoTypeMappings() {
			assertThat(new PulsarProperties().getDefaults().getTypeMappings()).isEmpty();
		}
		@Test
		void bindWhenTypeMappingsWithTopicsOnly() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.type-mappings[0].message-type', TestMessage.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[0].topic-name', 'foo-topic');
			map.put('spring.pulsar.defaults.type-mappings[1].message-type', String.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[1].topic-name', 'string-topic');
			PulsarProperties.Defaults properties = bindProperties(map).getDefaults();
			TypeMapping expectedTopic1 = new TypeMapping(TestMessage.class, 'foo-topic', null);
			TypeMapping expectedTopic2 = new TypeMapping(String.class, 'string-topic', null);
			assertThat(properties.getTypeMappings()).containsExactly(expectedTopic1, expectedTopic2);
		}
		@Test
		void bindWhenTypeMappingsWithSchemaOnly() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.type-mappings[0].message-type', TestMessage.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type', 'JSON');
			PulsarProperties.Defaults properties = bindProperties(map).getDefaults();
			TypeMapping expected = new TypeMapping(TestMessage.class, null, new SchemaInfo(SchemaType.JSON, null));
			assertThat(properties.getTypeMappings()).containsExactly(expected);
		}
		@Test
		void bindWhenTypeMappingsWithTopicAndSchema() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.type-mappings[0].message-type', TestMessage.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[0].topic-name', 'foo-topic');
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type', 'JSON');
			PulsarProperties.Defaults properties = bindProperties(map).getDefaults();
			TypeMapping expected = new TypeMapping(TestMessage.class, 'foo-topic',
					new SchemaInfo(SchemaType.JSON, null));
			assertThat(properties.getTypeMappings()).containsExactly(expected);
		}
		@Test
		void bindWhenTypeMappingsWithKeyValueSchema() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.type-mappings[0].message-type', TestMessage.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type', 'KEY_VALUE');
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.message-key-type', String.class.getName());
			PulsarProperties.Defaults properties = bindProperties(map).getDefaults();
			TypeMapping expected = new TypeMapping(TestMessage.class, null,
					new SchemaInfo(SchemaType.KEY_VALUE, String.class));
			assertThat(properties.getTypeMappings()).containsExactly(expected);
		}
		@Test
		void bindWhenNoSchemaThrowsException() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.type-mappings[0].message-type', TestMessage.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.message-key-type', String.class.getName());
			assertThatExceptionOfType(BindException.class).isThrownBy(() -> bindProperties(map))
				.havingRootCause()
				.withMessageContaining('schemaType must not be null');
		}
		@Test
		void bindWhenSchemaTypeNoneThrowsException() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.type-mappings[0].message-type', TestMessage.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type', 'NONE');
			assertThatExceptionOfType(BindException.class).isThrownBy(() -> bindProperties(map))
				.havingRootCause()
				.withMessageContaining('schemaType "NONE" not supported');
		}
		@Test
		void bindWhenMessageKeyTypeSetOnNonKeyValueSchemaThrowsException() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.type-mappings[0].message-type', TestMessage.class.getName());
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.schema-type', 'JSON');
			map.put('spring.pulsar.defaults.type-mappings[0].schema-info.message-key-type', String.class.getName());
			assertThatExceptionOfType(BindException.class).isThrownBy(() -> bindProperties(map))
				.havingRootCause()
				.withMessageContaining('messageKeyType can only be set when schemaType is KEY_VALUE');
		}
		record TestMessage(String value) {
		}
	}
	@Nested
	class DefaultsTenantNamespaceProperties {
		@Test
		void bindWhenValuesNotSpecified() {
			PulsarTopicBuilder defaultTopicBuilder = new PulsarTopicBuilder();
			assertThat(new PulsarProperties().getDefaults().getTopic()).satisfies((defaults) -> {
				assertThat(defaults.getTenant())
					.isEqualTo(Extractors.byName('defaultTenant').apply(defaultTopicBuilder));
				assertThat(defaults.getNamespace())
					.isEqualTo(Extractors.byName('defaultNamespace').apply(defaultTopicBuilder));
			});
		}
		@Test
		void bindWhenValuesSpecified() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.defaults.topic.tenant', 'my-tenant');
			map.put('spring.pulsar.defaults.topic.namespace', 'my-namespace');
			PulsarProperties.Defaults.Topic properties = bindProperties(map).getDefaults().getTopic();
			assertThat(properties.getTenant()).isEqualTo('my-tenant');
			assertThat(properties.getNamespace()).isEqualTo('my-namespace');
		}
	}
	@Nested
	class FunctionProperties {
		@Test
		void defaults() {
			PulsarProperties.Function properties = new PulsarProperties.Function();
			assertThat(properties.isFailFast()).isTrue();
			assertThat(properties.isPropagateFailures()).isTrue();
			assertThat(properties.isPropagateStopFailures()).isFalse();
		}
		@Test
		void bind() {
			Map<String, String> props = new HashMap<>();
			props.put('spring.pulsar.function.fail-fast', 'false');
			props.put('spring.pulsar.function.propagate-failures', 'false');
			props.put('spring.pulsar.function.propagate-stop-failures', 'true');
			PulsarProperties.Function properties = bindProperties(props).getFunction();
			assertThat(properties.isFailFast()).isFalse();
			assertThat(properties.isPropagateFailures()).isFalse();
			assertThat(properties.isPropagateStopFailures()).isTrue();
		}
	}
	@Nested
	class ProducerProperties {
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.producer.name', 'my-producer');
			map.put('spring.pulsar.producer.topic-name', 'my-topic');
			map.put('spring.pulsar.producer.send-timeout', '2s');
			map.put('spring.pulsar.producer.message-routing-mode', 'custompartition');
			map.put('spring.pulsar.producer.hashing-scheme', 'murmur3_32hash');
			map.put('spring.pulsar.producer.batching-enabled', 'false');
			map.put('spring.pulsar.producer.chunking-enabled', 'true');
			map.put('spring.pulsar.producer.compression-type', 'lz4');
			map.put('spring.pulsar.producer.access-mode', 'exclusive');
			map.put('spring.pulsar.producer.cache.expire-after-access', '2s');
			map.put('spring.pulsar.producer.cache.maximum-size', '3');
			map.put('spring.pulsar.producer.cache.initial-capacity', '5');
			PulsarProperties.Producer properties = bindProperties(map).getProducer();
			assertThat(properties.getName()).isEqualTo('my-producer');
			assertThat(properties.getTopicName()).isEqualTo('my-topic');
			assertThat(properties.getSendTimeout()).isEqualTo(Duration.ofSeconds(2));
			assertThat(properties.getMessageRoutingMode()).isEqualTo(MessageRoutingMode.CustomPartition);
			assertThat(properties.getHashingScheme()).isEqualTo(HashingScheme.Murmur3_32Hash);
			assertThat(properties.isBatchingEnabled()).isFalse();
			assertThat(properties.isChunkingEnabled()).isTrue();
			assertThat(properties.getCompressionType()).isEqualTo(CompressionType.LZ4);
			assertThat(properties.getAccessMode()).isEqualTo(ProducerAccessMode.Exclusive);
			assertThat(properties.getCache().getExpireAfterAccess()).isEqualTo(Duration.ofSeconds(2));
			assertThat(properties.getCache().getMaximumSize()).isEqualTo(3);
			assertThat(properties.getCache().getInitialCapacity()).isEqualTo(5);
		}
	}
	@Nested
	class ConsumerPropertiesTests {
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.consumer.name', 'my-consumer');
			map.put('spring.pulsar.consumer.subscription.initial-position', 'earliest');
			map.put('spring.pulsar.consumer.subscription.mode', 'nondurable');
			map.put('spring.pulsar.consumer.subscription.name', 'my-subscription');
			map.put('spring.pulsar.consumer.subscription.topics-mode', 'all-topics');
			map.put('spring.pulsar.consumer.subscription.type', 'shared');
			map.put('spring.pulsar.consumer.topics[0]', 'my-topic');
			map.put('spring.pulsar.consumer.topics-pattern', 'my-pattern');
			map.put('spring.pulsar.consumer.priority-level', '8');
			map.put('spring.pulsar.consumer.read-compacted', 'true');
			map.put('spring.pulsar.consumer.dead-letter-policy.max-redeliver-count', '4');
			map.put('spring.pulsar.consumer.dead-letter-policy.retry-letter-topic', 'my-retry-topic');
			map.put('spring.pulsar.consumer.dead-letter-policy.dead-letter-topic', 'my-dlt-topic');
			map.put('spring.pulsar.consumer.dead-letter-policy.initial-subscription-name', 'my-initial-subscription');
			map.put('spring.pulsar.consumer.retry-enable', 'true');
			PulsarProperties.Consumer properties = bindProperties(map).getConsumer();
			assertThat(properties.getName()).isEqualTo('my-consumer');
			assertThat(properties.getSubscription()).satisfies((subscription) -> {
				assertThat(subscription.getName()).isEqualTo('my-subscription');
				assertThat(subscription.getType()).isEqualTo(SubscriptionType.Shared);
				assertThat(subscription.getMode()).isEqualTo(SubscriptionMode.NonDurable);
				assertThat(subscription.getInitialPosition()).isEqualTo(SubscriptionInitialPosition.Earliest);
				assertThat(subscription.getTopicsMode()).isEqualTo(RegexSubscriptionMode.AllTopics);
			});
			assertThat(properties.getTopics()).containsExactly('my-topic');
			assertThat(properties.getTopicsPattern().toString()).isEqualTo('my-pattern');
			assertThat(properties.getPriorityLevel()).isEqualTo(8);
			assertThat(properties.isReadCompacted()).isTrue();
			assertThat(properties.getDeadLetterPolicy()).satisfies((policy) -> {
				assertThat(policy.getMaxRedeliverCount()).isEqualTo(4);
				assertThat(policy.getRetryLetterTopic()).isEqualTo('my-retry-topic');
				assertThat(policy.getDeadLetterTopic()).isEqualTo('my-dlt-topic');
				assertThat(policy.getInitialSubscriptionName()).isEqualTo('my-initial-subscription');
			});
			assertThat(properties.isRetryEnable()).isTrue();
		}
	}
	@Nested
	class ListenerProperties {
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.listener.schema-type', 'avro');
			map.put('spring.pulsar.listener.concurrency', '10');
			map.put('spring.pulsar.listener.observation-enabled', 'true');
			PulsarProperties.Listener properties = bindProperties(map).getListener();
			assertThat(properties.getSchemaType()).isEqualTo(SchemaType.AVRO);
			assertThat(properties.getConcurrency()).isEqualTo(10);
			assertThat(properties.isObservationEnabled()).isTrue();
		}
	}
	@Nested
	class ReaderProperties {
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.reader.name', 'my-reader');
			map.put('spring.pulsar.reader.topics', 'my-topic');
			map.put('spring.pulsar.reader.subscription-name', 'my-subscription');
			map.put('spring.pulsar.reader.subscription-role-prefix', 'sub-role');
			map.put('spring.pulsar.reader.read-compacted', 'true');
			PulsarProperties.Reader properties = bindProperties(map).getReader();
			assertThat(properties.getName()).isEqualTo('my-reader');
			assertThat(properties.getTopics()).containsExactly('my-topic');
			assertThat(properties.getSubscriptionName()).isEqualTo('my-subscription');
			assertThat(properties.getSubscriptionRolePrefix()).isEqualTo('sub-role');
			assertThat(properties.isReadCompacted()).isTrue();
		}
	}
	@Nested
	class TemplateProperties {
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.template.observations-enabled', 'true');
			PulsarProperties.Template properties = bindProperties(map).getTemplate();
			assertThat(properties.isObservationsEnabled()).isTrue();
		}
	}
	@Nested
	class TransactionProperties {
		@Test
		void bind() {
			Map<String, String> map = new HashMap<>();
			map.put('spring.pulsar.transaction.enabled', 'true');
			PulsarProperties.Transaction properties = bindProperties(map).getTransaction();
			assertThat(properties.isEnabled()).isTrue();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
class PulsarReactivePropertiesMapperTests {
	@Test
	@SuppressWarnings('unchecked')
	void customizeMessageSenderBuilder() {
		PulsarProperties properties = new PulsarProperties();
		properties.getProducer().setName('name');
		properties.getProducer().setTopicName('topicname');
		properties.getProducer().setSendTimeout(Duration.ofSeconds(1));
		properties.getProducer().setMessageRoutingMode(MessageRoutingMode.RoundRobinPartition);
		properties.getProducer().setHashingScheme(HashingScheme.JavaStringHash);
		properties.getProducer().setBatchingEnabled(false);
		properties.getProducer().setChunkingEnabled(true);
		properties.getProducer().setCompressionType(CompressionType.SNAPPY);
		properties.getProducer().setAccessMode(ProducerAccessMode.Exclusive);
		ReactiveMessageSenderBuilder<Object> builder = mock(ReactiveMessageSenderBuilder.class);
		new PulsarReactivePropertiesMapper(properties).customizeMessageSenderBuilder(builder);
		then(builder).should().producerName('name');
		then(builder).should().topic('topicname');
		then(builder).should().sendTimeout(Duration.ofSeconds(1));
		then(builder).should().messageRoutingMode(MessageRoutingMode.RoundRobinPartition);
		then(builder).should().hashingScheme(HashingScheme.JavaStringHash);
		then(builder).should().batchingEnabled(false);
		then(builder).should().chunkingEnabled(true);
		then(builder).should().compressionType(CompressionType.SNAPPY);
		then(builder).should().accessMode(ProducerAccessMode.Exclusive);
	}
	@Test
	@SuppressWarnings('unchecked')
	void customizeMessageConsumerBuilder() {
		PulsarProperties properties = new PulsarProperties();
		List<String> topics = List.of('mytopic');
		Pattern topisPattern = Pattern.compile('my-pattern');
		properties.getConsumer().setName('name');
		properties.getConsumer().setTopics(topics);
		properties.getConsumer().setTopicsPattern(topisPattern);
		properties.getConsumer().setPriorityLevel(123);
		properties.getConsumer().setReadCompacted(true);
		Consumer.DeadLetterPolicy deadLetterPolicy = new Consumer.DeadLetterPolicy();
		deadLetterPolicy.setDeadLetterTopic('my-dlt');
		deadLetterPolicy.setMaxRedeliverCount(1);
		properties.getConsumer().setDeadLetterPolicy(deadLetterPolicy);
		properties.getConsumer().setRetryEnable(false);
		Subscription subscriptionProperties = properties.getConsumer().getSubscription();
		subscriptionProperties.setName('subname');
		subscriptionProperties.setInitialPosition(SubscriptionInitialPosition.Earliest);
		subscriptionProperties.setMode(SubscriptionMode.NonDurable);
		subscriptionProperties.setTopicsMode(RegexSubscriptionMode.NonPersistentOnly);
		subscriptionProperties.setType(SubscriptionType.Key_Shared);
		ReactiveMessageConsumerBuilder<Object> builder = mock(ReactiveMessageConsumerBuilder.class);
		new PulsarReactivePropertiesMapper(properties).customizeMessageConsumerBuilder(builder);
		then(builder).should().consumerName('name');
		then(builder).should().topics(topics);
		then(builder).should().topicsPattern(topisPattern);
		then(builder).should().priorityLevel(123);
		then(builder).should().readCompacted(true);
		then(builder).should().deadLetterPolicy(new DeadLetterPolicy(1, null, 'my-dlt', null));
		then(builder).should().retryLetterTopicEnable(false);
		then(builder).should().subscriptionName('subname');
		then(builder).should().subscriptionInitialPosition(SubscriptionInitialPosition.Earliest);
		then(builder).should().subscriptionMode(SubscriptionMode.NonDurable);
		then(builder).should().topicsPatternSubscriptionMode(RegexSubscriptionMode.NonPersistentOnly);
		then(builder).should().subscriptionType(SubscriptionType.Key_Shared);
	}
	@Test
	void customizeContainerProperties() {
		PulsarProperties properties = new PulsarProperties();
		properties.getConsumer().getSubscription().setType(SubscriptionType.Shared);
		properties.getConsumer().getSubscription().setName('my-subscription');
		properties.getListener().setSchemaType(SchemaType.AVRO);
		properties.getListener().setConcurrency(10);
		ReactivePulsarContainerProperties<Object> containerProperties = new ReactivePulsarContainerProperties<>();
		new PulsarReactivePropertiesMapper(properties).customizeContainerProperties(containerProperties);
		assertThat(containerProperties.getSubscriptionType()).isEqualTo(SubscriptionType.Shared);
		assertThat(containerProperties.getSubscriptionName()).isEqualTo('my-subscription');
		assertThat(containerProperties.getSchemaType()).isEqualTo(SchemaType.AVRO);
		assertThat(containerProperties.getConcurrency()).isEqualTo(10);
	}
	@Test
	@SuppressWarnings('unchecked')
	void customizeMessageReaderBuilder() {
		List<String> topics = List.of('my-topic');
		PulsarProperties properties = new PulsarProperties();
		properties.getReader().setName('name');
		properties.getReader().setTopics(topics);
		properties.getReader().setSubscriptionName('subname');
		properties.getReader().setSubscriptionRolePrefix('srp');
		ReactiveMessageReaderBuilder<Object> builder = mock(ReactiveMessageReaderBuilder.class);
		new PulsarReactivePropertiesMapper(properties).customizeMessageReaderBuilder(builder);
		then(builder).should().readerName('name');
		then(builder).should().topics(topics);
		then(builder).should().subscriptionName('subname');
		then(builder).should().generatedSubscriptionNamePrefix('srp');
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
@SuppressWarnings('deprecation')
public class MockAuthentication implements Authentication {
	public Map<String, String> authParamsMap = new HashMap<>();
	@Override
	public String getAuthMethodName() {
		return null;
	}
	@Override
	public AuthenticationDataProvider getAuthData() {
		return null;
	}
	@Override
	public void configure(Map<String, String> authParams) {
		this.authParamsMap = authParams;
	}
	@Override
	public void start() throws PulsarClientException {
	}
	@Override
	public void close() throws IOException {
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationSorterTests {
	private static final String DEFAULT = OrderUnspecified.class.getName();
	private static final String LOWEST = OrderLowest.class.getName();
	private static final String HIGHEST = OrderHighest.class.getName();
	private static final String A = AutoConfigureA.class.getName();
	private static final String A2 = AutoConfigureA2.class.getName();
	private static final String A3 = AutoConfigureA3.class.getName();
	private static final String A_WITH_REPLACED = AutoConfigureAWithReplaced.class.getName();
	private static final String B = AutoConfigureB.class.getName();
	private static final String B2 = AutoConfigureB2.class.getName();
	private static final String B_WITH_REPLACED = AutoConfigureBWithReplaced.class.getName();
	private static final String C = AutoConfigureC.class.getName();
	private static final String D = AutoConfigureD.class.getName();
	private static final String E = AutoConfigureE.class.getName();
	private static final String W = AutoConfigureW.class.getName();
	private static final String W2 = AutoConfigureW2.class.getName();
	private static final String X = AutoConfigureX.class.getName();
	private static final String Y = AutoConfigureY.class.getName();
	private static final String Y2 = AutoConfigureY2.class.getName();
	private static final String Z = AutoConfigureZ.class.getName();
	private static final String Z2 = AutoConfigureZ2.class.getName();
	private static final UnaryOperator<String> REPLACEMENT_MAPPER = (name) -> name.replace('Deprecated', '');
	private AutoConfigurationSorter sorter;
	private AutoConfigurationMetadata autoConfigurationMetadata = mock(AutoConfigurationMetadata.class);
	@BeforeEach
	void setup() {
		this.sorter = new AutoConfigurationSorter(new SkipCycleMetadataReaderFactory(), this.autoConfigurationMetadata,
				REPLACEMENT_MAPPER);
	}
	@Test
	void byOrderAnnotation() {
		List<String> actual = getInPriorityOrder(LOWEST, HIGHEST, DEFAULT);
		assertThat(actual).containsExactly(HIGHEST, DEFAULT, LOWEST);
	}
	@Test
	void byAutoConfigureAfter() {
		List<String> actual = getInPriorityOrder(A, B, C);
		assertThat(actual).containsExactly(C, B, A);
	}
	@Test
	void byAutoConfigureAfterAliasFor() {
		List<String> actual = getInPriorityOrder(A3, B2, C);
		assertThat(actual).containsExactly(C, B2, A3);
	}
	@Test
	void byAutoConfigureAfterAliasForWithProperties() throws Exception {
		MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory();
		this.autoConfigurationMetadata = getAutoConfigurationMetadata(A3, B2, C);
		this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata, REPLACEMENT_MAPPER);
		List<String> actual = getInPriorityOrder(A3, B2, C);
		assertThat(actual).containsExactly(C, B2, A3);
	}
	@Test
	void byAutoConfigureAfterWithDeprecated() {
		List<String> actual = getInPriorityOrder(A_WITH_REPLACED, B_WITH_REPLACED, C);
		assertThat(actual).containsExactly(C, B_WITH_REPLACED, A_WITH_REPLACED);
	}
	@Test
	void byAutoConfigureBefore() {
		List<String> actual = getInPriorityOrder(X, Y, Z);
		assertThat(actual).containsExactly(Z, Y, X);
	}
	@Test
	void byAutoConfigureBeforeAliasFor() {
		List<String> actual = getInPriorityOrder(X, Y2, Z2);
		assertThat(actual).containsExactly(Z2, Y2, X);
	}
	@Test
	void byAutoConfigureBeforeAliasForWithProperties() throws Exception {
		MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory();
		this.autoConfigurationMetadata = getAutoConfigurationMetadata(X, Y2, Z2);
		this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata, REPLACEMENT_MAPPER);
		List<String> actual = getInPriorityOrder(X, Y2, Z2);
		assertThat(actual).containsExactly(Z2, Y2, X);
	}
	@Test
	void byAutoConfigureAfterDoubles() {
		List<String> actual = getInPriorityOrder(A, B, C, E);
		assertThat(actual).containsExactly(C, E, B, A);
	}
	@Test
	void byAutoConfigureMixedBeforeAndAfter() {
		List<String> actual = getInPriorityOrder(A, B, C, W, X);
		assertThat(actual).containsExactly(C, W, B, A, X);
	}
	@Test
	void byAutoConfigureMixedBeforeAndAfterWithClassNames() {
		List<String> actual = getInPriorityOrder(A2, B, C, W2, X);
		assertThat(actual).containsExactly(C, W2, B, A2, X);
	}
	@Test
	void byAutoConfigureMixedBeforeAndAfterWithDifferentInputOrder() {
		List<String> actual = getInPriorityOrder(W, X, A, B, C);
		assertThat(actual).containsExactly(C, W, B, A, X);
	}
	@Test
	void byAutoConfigureAfterWithMissing() {
		List<String> actual = getInPriorityOrder(A, B);
		assertThat(actual).containsExactly(B, A);
	}
	@Test
	void byAutoConfigureAfterWithCycle() {
		this.sorter = new AutoConfigurationSorter(new CachingMetadataReaderFactory(), this.autoConfigurationMetadata,
				REPLACEMENT_MAPPER);
		assertThatIllegalStateException().isThrownBy(() -> getInPriorityOrder(A, B, C, D))
			.withMessageContaining('AutoConfigure cycle detected');
	}
	@Test
	void usesAnnotationPropertiesWhenPossible() throws Exception {
		MetadataReaderFactory readerFactory = new SkipCycleMetadataReaderFactory();
		this.autoConfigurationMetadata = getAutoConfigurationMetadata(A2, B, C, W2, X);
		this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata, REPLACEMENT_MAPPER);
		List<String> actual = getInPriorityOrder(A2, B, C, W2, X);
		assertThat(actual).containsExactly(C, W2, B, A2, X);
	}
	@Test
	void useAnnotationWithNoDirectLink() throws Exception {
		MetadataReaderFactory readerFactory = new SkipCycleMetadataReaderFactory();
		this.autoConfigurationMetadata = getAutoConfigurationMetadata(A, B, E);
		this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata, REPLACEMENT_MAPPER);
		List<String> actual = getInPriorityOrder(A, E);
		assertThat(actual).containsExactly(E, A);
	}
	@Test
	void useAnnotationWithNoDirectLinkAndCycle() throws Exception {
		MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory();
		this.autoConfigurationMetadata = getAutoConfigurationMetadata(A, B, D);
		this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata, REPLACEMENT_MAPPER);
		assertThatIllegalStateException().isThrownBy(() -> getInPriorityOrder(D, B))
			.withMessageContaining('AutoConfigure cycle detected');
	}
	@Test // gh-38904
	void byBeforeAnnotationThenOrderAnnotation() {
		String oa = OrderAutoConfigureA.class.getName();
		String oa1 = OrderAutoConfigureASeedR1.class.getName();
		String oa2 = OrderAutoConfigureASeedY2.class.getName();
		String oa3 = OrderAutoConfigureASeedA3.class.getName();
		String oa4 = OrderAutoConfigureAutoConfigureASeedG4.class.getName();
		List<String> actual = getInPriorityOrder(oa4, oa3, oa2, oa1, oa);
		assertThat(actual).containsExactly(oa1, oa2, oa3, oa4, oa);
	}
	private List<String> getInPriorityOrder(String... classNames) {
		return this.sorter.getInPriorityOrder(Arrays.asList(classNames));
	}
	private AutoConfigurationMetadata getAutoConfigurationMetadata(String... classNames) throws Exception {
		Properties properties = new Properties();
		for (String className : classNames) {
			Class<?> type = ClassUtils.forName(className, null);
			properties.put(type.getName(), '');
			AnnotationMetadata annotationMetadata = AnnotationMetadata.introspect(type);
			addAutoConfigureOrder(properties, className, annotationMetadata);
			addAutoConfigureBefore(properties, className, annotationMetadata);
			addAutoConfigureAfter(properties, className, annotationMetadata);
		}
		return AutoConfigurationMetadataLoader.loadMetadata(properties);
	}
	private void addAutoConfigureAfter(Properties properties, String className, AnnotationMetadata annotationMetadata) {
		Map<String, Object> autoConfigureAfter = annotationMetadata
			.getAnnotationAttributes(AutoConfigureAfter.class.getName(), true);
		if (autoConfigureAfter != null) {
			String value = merge((String[]) autoConfigureAfter.get('value'), (String[]) autoConfigureAfter.get('name'));
			if (!value.isEmpty()) {
				properties.put(className + '.AutoConfigureAfter', value);
			}
		}
	}
	private void addAutoConfigureBefore(Properties properties, String className,
			AnnotationMetadata annotationMetadata) {
		Map<String, Object> autoConfigureBefore = annotationMetadata
			.getAnnotationAttributes(AutoConfigureBefore.class.getName(), true);
		if (autoConfigureBefore != null) {
			String value = merge((String[]) autoConfigureBefore.get('value'),
					(String[]) autoConfigureBefore.get('name'));
			if (!value.isEmpty()) {
				properties.put(className + '.AutoConfigureBefore', value);
			}
		}
	}
	private void addAutoConfigureOrder(Properties properties, String className, AnnotationMetadata annotationMetadata) {
		Map<String, Object> autoConfigureOrder = annotationMetadata
			.getAnnotationAttributes(AutoConfigureOrder.class.getName());
		if (autoConfigureOrder != null) {
			Integer order = (Integer) autoConfigureOrder.get('order');
			if (order != null) {
				properties.put(className + '.AutoConfigureOrder', String.valueOf(order));
			}
		}
	}
	private String merge(String[] value, String[] name) {
		Set<String> items = new LinkedHashSet<>();
		Collections.addAll(items, value);
		Collections.addAll(items, name);
		return StringUtils.collectionToCommaDelimitedString(items);
	}
	@AutoConfigureOrder
	static class OrderUnspecified {
	}
	@AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE)
	static class OrderLowest {
	}
	@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
	static class OrderHighest {
	}
	@AutoConfigureAfter(AutoConfigureB.class)
	static class AutoConfigureA {
	}
	@AutoConfigureAfter(name = 'org.springframework.boot.autoconfigure.AutoConfigurationSorterTests$AutoConfigureB')
	static class AutoConfigureA2 {
	}
	@AutoConfiguration(after = AutoConfigureB2.class)
	static class AutoConfigureA3 {
	}
	@AutoConfigureAfter(AutoConfigureBWithReplaced.class)
	public static class AutoConfigureAWithReplaced {
	}
	@AutoConfigureAfter({ AutoConfigureC.class, AutoConfigureD.class, AutoConfigureE.class })
	static class AutoConfigureB {
	}
	@AutoConfiguration(after = { AutoConfigureC.class })
	static class AutoConfigureB2 {
	}
	@AutoConfigureAfter({ DeprecatedAutoConfigureC.class, AutoConfigureD.class, AutoConfigureE.class })
	public static class AutoConfigureBWithReplaced {
	}
	static class AutoConfigureC {
	}
	// @DeprecatedAutoConfiguration(replacement =
	// 'org.springframework.boot.autoconfigure.AutoConfigurationSorterTests$AutoConfigureC')
	public static class DeprecatedAutoConfigureC {
	}
	@AutoConfigureAfter(AutoConfigureA.class)
	static class AutoConfigureD {
	}
	static class AutoConfigureE {
	}
	@AutoConfigureBefore(AutoConfigureB.class)
	static class AutoConfigureW {
	}
	@AutoConfigureBefore(name = 'org.springframework.boot.autoconfigure.AutoConfigurationSorterTests$AutoConfigureB')
	static class AutoConfigureW2 {
	}
	static class AutoConfigureX {
	}
	@AutoConfigureBefore(AutoConfigureX.class)
	static class AutoConfigureY {
	}
	@AutoConfiguration(before = AutoConfigureX.class)
	static class AutoConfigureY2 {
	}
	// @DeprecatedAutoConfiguration(replacement =
	// 'org.springframework.boot.autoconfigure.AutoConfigurationSorterTests$AutoConfigureY')
	public static class DeprecatedAutoConfigureY {
	}
	@AutoConfigureBefore(AutoConfigureY.class)
	static class AutoConfigureZ {
	}
	@AutoConfiguration(before = AutoConfigureY2.class)
	static class AutoConfigureZ2 {
	}
	static class OrderAutoConfigureA {
	}
	// Use seeds in auto-configuration class names to mislead the sort by names done in
	// AutoConfigurationSorter class.
	@AutoConfigureBefore(OrderAutoConfigureA.class)
	@AutoConfigureOrder(1)
	static class OrderAutoConfigureASeedR1 {
	}
	@AutoConfigureBefore(OrderAutoConfigureA.class)
	@AutoConfigureOrder(2)
	static class OrderAutoConfigureASeedY2 {
	}
	@AutoConfigureBefore(OrderAutoConfigureA.class)
	@AutoConfigureOrder(3)
	static class OrderAutoConfigureASeedA3 {
	}
	@AutoConfigureBefore(OrderAutoConfigureA.class)
	@AutoConfigureOrder(4)
	static class OrderAutoConfigureAutoConfigureASeedG4 {
	}
	static class SkipCycleMetadataReaderFactory extends CachingMetadataReaderFactory {
		@Override
		public MetadataReader getMetadataReader(String className) throws IOException {
			if (className.equals(D)) {
				throw new IOException();
			}
			return super.getMetadataReader(className);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
@ExtendWith(OutputCaptureExtension.class)
class FreeMarkerAutoConfigurationTests {
	private final BuildOutput buildOutput = new BuildOutput(getClass());
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(FreeMarkerAutoConfiguration.class));
	@Test
	void renderNonWebAppTemplate() {
		this.contextRunner.run((context) -> {
			freemarker.template.Configuration freemarker = context.getBean(freemarker.template.Configuration.class);
			StringWriter writer = new StringWriter();
			freemarker.getTemplate('message.ftlh').process(new DataModel(), writer);
			assertThat(writer.toString()).contains('Hello World');
		});
	}
	@Test
	void nonExistentTemplateLocation(CapturedOutput output) {
		this.contextRunner
			.withPropertyValues('spring.freemarker.templateLoaderPath:'
					+ 'classpath:/does-not-exist/,classpath:/also-does-not-exist')
			.run((context) -> assertThat(output).contains('Cannot find template location'));
	}
	@Test
	void emptyTemplateLocation(CapturedOutput output) {
		File emptyDirectory = new File(this.buildOutput.getTestResourcesLocation(), 'empty-templates/empty-directory');
		emptyDirectory.mkdirs();
		this.contextRunner
			.withPropertyValues('spring.freemarker.templateLoaderPath:classpath:/empty-templates/empty-directory/')
			.run((context) -> assertThat(output).doesNotContain('Cannot find template location'));
	}
	@Test
	void nonExistentLocationAndEmptyLocation(CapturedOutput output) {
		new File(this.buildOutput.getTestResourcesLocation(), 'empty-templates/empty-directory').mkdirs();
		this.contextRunner
			.withPropertyValues('spring.freemarker.templateLoaderPath:'
					+ 'classpath:/does-not-exist/,classpath:/empty-templates/empty-directory/')
			.run((context) -> assertThat(output).doesNotContain('Cannot find template location'));
	}
	@Test
	void variableCustomizerShouldBeApplied() {
		FreeMarkerVariablesCustomizer customizer = mock(FreeMarkerVariablesCustomizer.class);
		this.contextRunner.withBean(FreeMarkerVariablesCustomizer.class, () -> customizer)
			.run((context) -> then(customizer).should().customizeFreeMarkerVariables(any()));
	}
	@Test
	@SuppressWarnings('unchecked')
	void variableCustomizersShouldBeAppliedInOrder() {
		this.contextRunner.withUserConfiguration(VariablesCustomizersConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(freemarker.template.Configuration.class);
			freemarker.template.Configuration configuration = context.getBean(freemarker.template.Configuration.class);
			assertThat(configuration.getSharedVariableNames()).contains('order', 'one', 'two');
			assertThat(configuration.getSharedVariable('order')).hasToString('5');
		});
	}
	public static class DataModel {
		public String getGreeting() {
			return 'Hello World';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class VariablesCustomizersConfiguration {
		@Bean
		@Order(5)
		FreeMarkerVariablesCustomizer variablesCustomizer() {
			return (variables) -> {
				variables.put('order', 5);
				variables.put('one', 'one');
			};
		}
		@Bean
		@Order(2)
		FreeMarkerVariablesCustomizer anotherVariablesCustomizer() {
			return (variables) -> {
				variables.put('order', 2);
				variables.put('two', 'two');
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
class FreeMarkerAutoConfigurationReactiveIntegrationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(FreeMarkerAutoConfiguration.class));
	@Test
	void defaultConfiguration() {
		this.contextRunner.run((context) -> {
			assertThat(context.getBean(FreeMarkerViewResolver.class)).isNotNull();
			assertThat(context.getBean(FreeMarkerConfigurer.class)).isNotNull();
			assertThat(context.getBean(FreeMarkerConfig.class)).isNotNull();
			assertThat(context.getBean(freemarker.template.Configuration.class)).isNotNull();
		});
	}
	@Test
	void defaultViewResolution() {
		this.contextRunner.run((context) -> {
			MockServerWebExchange exchange = render(context, 'home');
			String result = exchange.getResponse().getBodyAsString().block(Duration.ofSeconds(30));
			assertThat(result).contains('home');
			assertThat(exchange.getResponse().getHeaders().getContentType()).isEqualTo(MediaType.TEXT_HTML);
		});
	}
	@Test
	void customPrefix() {
		this.contextRunner.withPropertyValues('spring.freemarker.prefix:prefix/').run((context) -> {
			MockServerWebExchange exchange = render(context, 'prefixed');
			String result = exchange.getResponse().getBodyAsString().block(Duration.ofSeconds(30));
			assertThat(result).contains('prefixed');
		});
	}
	@Test
	void customSuffix() {
		this.contextRunner.withPropertyValues('spring.freemarker.suffix:.freemarker').run((context) -> {
			MockServerWebExchange exchange = render(context, 'suffixed');
			String result = exchange.getResponse().getBodyAsString().block(Duration.ofSeconds(30));
			assertThat(result).contains('suffixed');
		});
	}
	@Test
	void customTemplateLoaderPath() {
		this.contextRunner.withPropertyValues('spring.freemarker.templateLoaderPath:classpath:/custom-templates/')
			.run((context) -> {
				MockServerWebExchange exchange = render(context, 'custom');
				String result = exchange.getResponse().getBodyAsString().block(Duration.ofSeconds(30));
				assertThat(result).contains('custom');
			});
	}
	@SuppressWarnings('deprecation')
	@Test
	void customFreeMarkerSettings() {
		this.contextRunner.withPropertyValues('spring.freemarker.settings.boolean_format:yup,nope')
			.run((context) -> assertThat(
					context.getBean(FreeMarkerConfigurer.class).getConfiguration().getSetting('boolean_format'))
				.isEqualTo('yup,nope'));
	}
	@Test
	void renderTemplate() {
		this.contextRunner.withPropertyValues().run((context) -> {
			FreeMarkerConfigurer freemarker = context.getBean(FreeMarkerConfigurer.class);
			StringWriter writer = new StringWriter();
			freemarker.getConfiguration().getTemplate('message.ftlh').process(new DataModel(), writer);
			assertThat(writer.toString()).contains('Hello World');
		});
	}
	private MockServerWebExchange render(ApplicationContext context, String viewName) {
		FreeMarkerViewResolver resolver = context.getBean(FreeMarkerViewResolver.class);
		Mono<View> view = resolver.resolveViewName(viewName, Locale.UK);
		MockServerWebExchange exchange = MockServerWebExchange.from(MockServerHttpRequest.get('/path'));
		view.flatMap((v) -> v.render(null, MediaType.TEXT_HTML, exchange)).block(Duration.ofSeconds(30));
		return exchange;
	}
	public static class DataModel {
		public String getGreeting() {
			return 'Hello World';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
class FreeMarkerTemplateAvailabilityProviderTests {
	private final TemplateAvailabilityProvider provider = new FreeMarkerTemplateAvailabilityProvider();
	private final ResourceLoader resourceLoader = new DefaultResourceLoader();
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void availabilityOfTemplateInDefaultLocation() {
		assertThat(this.provider.isTemplateAvailable('home', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateThatDoesNotExist() {
		assertThat(this.provider.isTemplateAvailable('whatever', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isFalse();
	}
	@Test
	void availabilityOfTemplateWithCustomLoaderPath() {
		this.environment.setProperty('spring.freemarker.template-loader-path', 'classpath:/custom-templates/');
		assertThat(this.provider.isTemplateAvailable('custom', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomLoaderPathConfiguredAsAList() {
		this.environment.setProperty('spring.freemarker.template-loader-path[0]', 'classpath:/custom-templates/');
		assertThat(this.provider.isTemplateAvailable('custom', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomPrefix() {
		this.environment.setProperty('spring.freemarker.prefix', 'prefix/');
		assertThat(this.provider.isTemplateAvailable('prefixed', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void availabilityOfTemplateWithCustomSuffix() {
		this.environment.setProperty('spring.freemarker.suffix', '.freemarker');
		assertThat(this.provider.isTemplateAvailable('suffixed', this.environment, getClass().getClassLoader(),
				this.resourceLoader))
			.isTrue();
	}
	@Test
	void shouldRegisterFreeMarkerTemplateAvailabilityPropertiesRuntimeHints() {
		assertThat(AotServices.factories().load(RuntimeHintsRegistrar.class))
			.hasAtLeastOneElementOfType(FreeMarkerTemplateAvailabilityRuntimeHints.class);
		RuntimeHints hints = new RuntimeHints();
		new FreeMarkerTemplateAvailabilityRuntimeHints().registerHints(hints, getClass().getClassLoader());
		TypeHint typeHint = hints.reflection().getTypeHint(FreeMarkerTemplateAvailabilityProperties.class);
		assertThat(typeHint).isNotNull();
	}
}
/*
package org.springframework.boot.autoconfigure.freemarker;
/**
class FreeMarkerAutoConfigurationServletIntegrationTests {
	private AnnotationConfigServletWebApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void defaultConfiguration() {
		load();
		assertThat(this.context.getBean(FreeMarkerViewResolver.class)).isNotNull();
		assertThat(this.context.getBean(FreeMarkerConfigurer.class)).isNotNull();
		assertThat(this.context.getBean(FreeMarkerConfig.class)).isNotNull();
		assertThat(this.context.getBean(freemarker.template.Configuration.class)).isNotNull();
	}
	@Test
	void defaultViewResolution() throws Exception {
		load();
		MockHttpServletResponse response = render('home');
		String result = response.getContentAsString();
		assertThat(result).contains('home');
		assertThat(response.getContentType()).isEqualTo('text/html;charset=UTF-8');
	}
	@Test
	void customContentType() throws Exception {
		load('spring.freemarker.contentType:application/json');
		MockHttpServletResponse response = render('home');
		String result = response.getContentAsString();
		assertThat(result).contains('home');
		assertThat(response.getContentType()).isEqualTo('application/json;charset=UTF-8');
	}
	@Test
	void customPrefix() throws Exception {
		load('spring.freemarker.prefix:prefix/');
		MockHttpServletResponse response = render('prefixed');
		String result = response.getContentAsString();
		assertThat(result).contains('prefixed');
	}
	@Test
	void customSuffix() throws Exception {
		load('spring.freemarker.suffix:.freemarker');
		MockHttpServletResponse response = render('suffixed');
		String result = response.getContentAsString();
		assertThat(result).contains('suffixed');
	}
	@Test
	void customTemplateLoaderPath() throws Exception {
		load('spring.freemarker.templateLoaderPath:classpath:/custom-templates/');
		MockHttpServletResponse response = render('custom');
		String result = response.getContentAsString();
		assertThat(result).contains('custom');
	}
	@Test
	void disableCache() {
		load('spring.freemarker.cache:false');
		assertThat(this.context.getBean(FreeMarkerViewResolver.class).getCacheLimit()).isZero();
	}
	@Test
	void allowSessionOverride() {
		load('spring.freemarker.allow-session-override:true');
		AbstractTemplateViewResolver viewResolver = this.context.getBean(FreeMarkerViewResolver.class);
		assertThat(viewResolver).hasFieldOrPropertyWithValue('allowSessionOverride', true);
	}
	@SuppressWarnings('deprecation')
	@Test
	void customFreeMarkerSettings() {
		load('spring.freemarker.settings.boolean_format:yup,nope');
		assertThat(this.context.getBean(FreeMarkerConfigurer.class).getConfiguration().getSetting('boolean_format'))
			.isEqualTo('yup,nope');
	}
	@Test
	void renderTemplate() throws Exception {
		load();
		FreeMarkerConfigurer freemarker = this.context.getBean(FreeMarkerConfigurer.class);
		StringWriter writer = new StringWriter();
		freemarker.getConfiguration().getTemplate('message.ftlh').process(new DataModel(), writer);
		assertThat(writer.toString()).contains('Hello World');
	}
	@Test
	void registerResourceHandlingFilterDisabledByDefault() {
		load();
		assertThat(this.context.getBeansOfType(FilterRegistrationBean.class)).isEmpty();
	}
	@Test
	void registerResourceHandlingFilterOnlyIfResourceChainIsEnabled() {
		load('spring.web.resources.chain.enabled:true');
		FilterRegistrationBean<?> registration = this.context.getBean(FilterRegistrationBean.class);
		assertThat(registration.getFilter()).isInstanceOf(ResourceUrlEncodingFilter.class);
		assertThat(registration).hasFieldOrPropertyWithValue('dispatcherTypes',
				EnumSet.of(DispatcherType.REQUEST, DispatcherType.ERROR));
	}
	@Test
	@SuppressWarnings('rawtypes')
	void registerResourceHandlingFilterWithOtherRegistrationBean() {
		// gh-14897
		load(FilterRegistrationOtherConfiguration.class, 'spring.web.resources.chain.enabled:true');
		Map<String, FilterRegistrationBean> beans = this.context.getBeansOfType(FilterRegistrationBean.class);
		assertThat(beans).hasSize(2);
		FilterRegistrationBean registration = beans.values()
			.stream()
			.filter((r) -> r.getFilter() instanceof ResourceUrlEncodingFilter)
			.findFirst()
			.get();
		assertThat(registration).hasFieldOrPropertyWithValue('dispatcherTypes',
				EnumSet.of(DispatcherType.REQUEST, DispatcherType.ERROR));
	}
	@Test
	@SuppressWarnings('rawtypes')
	void registerResourceHandlingFilterWithResourceRegistrationBean() {
		// gh-14926
		load(FilterRegistrationResourceConfiguration.class, 'spring.web.resources.chain.enabled:true');
		Map<String, FilterRegistrationBean> beans = this.context.getBeansOfType(FilterRegistrationBean.class);
		assertThat(beans).hasSize(1);
		FilterRegistrationBean registration = beans.values()
			.stream()
			.filter((r) -> r.getFilter() instanceof ResourceUrlEncodingFilter)
			.findFirst()
			.get();
		assertThat(registration).hasFieldOrPropertyWithValue('dispatcherTypes', EnumSet.of(DispatcherType.INCLUDE));
	}
	private void load(String... env) {
		load(BaseConfiguration.class, env);
	}
	private void load(Class<?> config, String... env) {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.setServletContext(new MockServletContext());
		TestPropertyValues.of(env).applyTo(this.context);
		this.context.register(config);
		this.context.refresh();
	}
	private MockHttpServletResponse render(String viewName) throws Exception {
		FreeMarkerViewResolver resolver = this.context.getBean(FreeMarkerViewResolver.class);
		View view = resolver.resolveViewName(viewName, Locale.UK);
		assertThat(view).isNotNull();
		HttpServletRequest request = new MockHttpServletRequest();
		request.setAttribute(RequestContext.WEB_APPLICATION_CONTEXT_ATTRIBUTE, this.context);
		MockHttpServletResponse response = new MockHttpServletResponse();
		view.render(null, request, response);
		return response;
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ FreeMarkerAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	static class BaseConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class FilterRegistrationResourceConfiguration {
		@Bean
		FilterRegistrationBean<ResourceUrlEncodingFilter> filterRegistration() {
			FilterRegistrationBean<ResourceUrlEncodingFilter> bean = new FilterRegistrationBean<>(
					new ResourceUrlEncodingFilter());
			bean.setDispatcherTypes(EnumSet.of(DispatcherType.INCLUDE));
			return bean;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BaseConfiguration.class)
	static class FilterRegistrationOtherConfiguration {
		@Bean
		FilterRegistrationBean<OrderedCharacterEncodingFilter> filterRegistration() {
			return new FilterRegistrationBean<>(new OrderedCharacterEncodingFilter());
		}
	}
	public static class DataModel {
		public String getGreeting() {
			return 'Hello World';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.jdbc;
/**
class JdbcRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JdbcRepositoriesAutoConfiguration.class));
	@Test
	void backsOffWithNoDataSource() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(AbstractJdbcConfiguration.class));
	}
	@Test
	void backsOffWithNoJdbcOperations() {
		this.contextRunner.with(database()).withUserConfiguration(TestConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(DataSource.class);
			assertThat(context).doesNotHaveBean(AbstractJdbcConfiguration.class);
		});
	}
	@Test
	void backsOffWithNoTransactionManager() {
		this.contextRunner.with(database())
			.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class))
			.withUserConfiguration(TestConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(DataSource.class);
				assertThat(context).hasSingleBean(NamedParameterJdbcOperations.class);
				assertThat(context).doesNotHaveBean(AbstractJdbcConfiguration.class);
			});
	}
	@Test
	void basicAutoConfiguration() {
		this.contextRunner.with(database())
			.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withUserConfiguration(TestConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(AbstractJdbcConfiguration.class);
				assertThat(context).hasSingleBean(CityRepository.class);
				assertThat(context.getBean(CityRepository.class).findById(2000L)).isPresent();
			});
	}
	@Test
	void entityScanShouldSetManagedTypes() {
		this.contextRunner.with(database())
			.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withUserConfiguration(TestConfiguration.class)
			.run((context) -> {
				JdbcMappingContext mappingContext = context.getBean(JdbcMappingContext.class);
				ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
				assertThat(managedTypes.toList()).containsOnly(City.class);
			});
	}
	@Test
	void autoConfigurationWithNoRepositories() {
		this.contextRunner.with(database())
			.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(AbstractJdbcConfiguration.class);
				assertThat(context).doesNotHaveBean(Repository.class);
			});
	}
	@Test
	void honoursUsersEnableJdbcRepositoriesConfiguration() {
		this.contextRunner.with(database())
			.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withUserConfiguration(EnableRepositoriesConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(AbstractJdbcConfiguration.class);
				assertThat(context).hasSingleBean(CityRepository.class);
				assertThat(context.getBean(CityRepository.class).findById(2000L)).isPresent();
			});
	}
	@Test
	void allowsUserToDefineCustomRelationalManagedTypes() {
		allowsUserToDefineCustomBean(RelationalManagedTypesConfiguration.class, RelationalManagedTypes.class,
				'customRelationalManagedTypes');
	}
	@Test
	void allowsUserToDefineCustomJdbcMappingContext() {
		allowsUserToDefineCustomBean(JdbcMappingContextConfiguration.class, JdbcMappingContext.class,
				'customJdbcMappingContext');
	}
	@Test
	void allowsUserToDefineCustomJdbcConverter() {
		allowsUserToDefineCustomBean(JdbcConverterConfiguration.class, JdbcConverter.class, 'customJdbcConverter');
	}
	@Test
	void allowsUserToDefineCustomJdbcCustomConversions() {
		allowsUserToDefineCustomBean(JdbcCustomConversionsConfiguration.class, JdbcCustomConversions.class,
				'customJdbcCustomConversions');
	}
	@Test
	void allowsUserToDefineCustomJdbcAggregateTemplate() {
		allowsUserToDefineCustomBean(JdbcAggregateTemplateConfiguration.class, JdbcAggregateTemplate.class,
				'customJdbcAggregateTemplate');
	}
	@Test
	void allowsUserToDefineCustomDataAccessStrategy() {
		allowsUserToDefineCustomBean(DataAccessStrategyConfiguration.class, DataAccessStrategy.class,
				'customDataAccessStrategy');
	}
	@Test
	void allowsUserToDefineCustomDialect() {
		allowsUserToDefineCustomBean(DialectConfiguration.class, Dialect.class, 'customDialect');
	}
	@Test
	void allowsConfigurationOfDialectByProperty() {
		this.contextRunner.with(database())
			.withPropertyValues('spring.data.jdbc.dialect=postgresql')
			.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JdbcPostgresDialect.class));
	}
	private void allowsUserToDefineCustomBean(Class<?> configuration, Class<?> beanType, String beanName) {
		this.contextRunner.with(database())
			.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.withUserConfiguration(configuration, EmptyConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(beanType);
				assertThat(context).hasBean(beanName);
			});
	}
	private Function<ApplicationContextRunner, ApplicationContextRunner> database() {
		return (runner) -> runner
			.withConfiguration(
					AutoConfigurations.of(DataSourceAutoConfiguration.class, SqlInitializationAutoConfiguration.class))
			.withPropertyValues('spring.sql.init.schema-locations=classpath:data-city-schema.sql',
					'spring.sql.init.data-locations=classpath:city.sql', 'spring.datasource.generate-unique-name:true');
	}
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	@EnableJdbcRepositories(basePackageClasses = City.class)
	static class EnableRepositoriesConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class RelationalManagedTypesConfiguration {
		@Bean
		RelationalManagedTypes customRelationalManagedTypes() {
			return RelationalManagedTypes.empty();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JdbcMappingContextConfiguration {
		@Bean
		JdbcMappingContext customJdbcMappingContext() {
			return mock(JdbcMappingContext.class, Answers.RETURNS_MOCKS);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JdbcConverterConfiguration {
		@Bean
		JdbcConverter customJdbcConverter() {
			return mock(JdbcConverter.class, Answers.RETURNS_MOCKS);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JdbcCustomConversionsConfiguration {
		@Bean
		JdbcCustomConversions customJdbcCustomConversions() {
			return mock(JdbcCustomConversions.class, Answers.RETURNS_MOCKS);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JdbcAggregateTemplateConfiguration {
		@Bean
		JdbcAggregateTemplate customJdbcAggregateTemplate() {
			return mock(JdbcAggregateTemplate.class, Answers.RETURNS_MOCKS);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataAccessStrategyConfiguration {
		@Bean
		DataAccessStrategy customDataAccessStrategy() {
			return mock(DataAccessStrategy.class, Answers.RETURNS_MOCKS);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DialectConfiguration {
		@Bean
		Dialect customDialect() {
			return mock(Dialect.class, Answers.RETURNS_MOCKS);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.jdbc.city;
@Table('CITY')
public class City {
	@Id
	private Long id;
	private String name;
	private String state;
	private String country;
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.data.jdbc.city;
public interface CityRepository extends CrudRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.web;
/**
class SpringDataWebAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SpringDataWebAutoConfiguration.class));
	@Test
	void webSupportIsAutoConfiguredInWebApplicationContexts() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(PageableHandlerMethodArgumentResolver.class));
	}
	@Test
	void autoConfigurationBacksOffInNonWebApplicationContexts() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(SpringDataWebAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(PageableHandlerMethodArgumentResolver.class));
	}
	@Test
	void customizePageable() {
		this.contextRunner
			.withPropertyValues('spring.data.web.pageable.page-parameter=p',
					'spring.data.web.pageable.size-parameter=s', 'spring.data.web.pageable.default-page-size=10',
					'spring.data.web.pageable.prefix=abc', 'spring.data.web.pageable.qualifier-delimiter=__',
					'spring.data.web.pageable.max-page-size=100', 'spring.data.web.pageable.serialization-mode=VIA_DTO',
					'spring.data.web.pageable.one-indexed-parameters=true')
			.run((context) -> {
				PageableHandlerMethodArgumentResolver argumentResolver = context
					.getBean(PageableHandlerMethodArgumentResolver.class);
				SpringDataWebSettings springDataWebSettings = context.getBean(SpringDataWebSettings.class);
				assertThat(argumentResolver).hasFieldOrPropertyWithValue('pageParameterName', 'p');
				assertThat(argumentResolver).hasFieldOrPropertyWithValue('sizeParameterName', 's');
				assertThat(argumentResolver).hasFieldOrPropertyWithValue('oneIndexedParameters', true);
				assertThat(argumentResolver).hasFieldOrPropertyWithValue('prefix', 'abc');
				assertThat(argumentResolver).hasFieldOrPropertyWithValue('qualifierDelimiter', '__');
				assertThat(argumentResolver).hasFieldOrPropertyWithValue('fallbackPageable', PageRequest.of(0, 10));
				assertThat(argumentResolver).hasFieldOrPropertyWithValue('maxPageSize', 100);
				assertThat(springDataWebSettings.pageSerializationMode()).isEqualTo(PageSerializationMode.VIA_DTO);
			});
	}
	@Test
	void defaultPageable() {
		this.contextRunner.run((context) -> {
			SpringDataWebProperties.Pageable properties = new SpringDataWebProperties().getPageable();
			PageableHandlerMethodArgumentResolver argumentResolver = context
				.getBean(PageableHandlerMethodArgumentResolver.class);
			SpringDataWebSettings springDataWebSettings = context.getBean(SpringDataWebSettings.class);
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('pageParameterName',
					properties.getPageParameter());
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('sizeParameterName',
					properties.getSizeParameter());
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('oneIndexedParameters',
					properties.isOneIndexedParameters());
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('prefix', properties.getPrefix());
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('qualifierDelimiter',
					properties.getQualifierDelimiter());
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('fallbackPageable',
					PageRequest.of(0, properties.getDefaultPageSize()));
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('maxPageSize', properties.getMaxPageSize());
			assertThat(springDataWebSettings.pageSerializationMode()).isEqualTo(properties.getSerializationMode());
		});
	}
	@Test
	void customizeSort() {
		this.contextRunner.withPropertyValues('spring.data.web.sort.sort-parameter=s').run((context) -> {
			SortHandlerMethodArgumentResolver argumentResolver = context
				.getBean(SortHandlerMethodArgumentResolver.class);
			assertThat(argumentResolver).hasFieldOrPropertyWithValue('sortParameter', 's');
		});
	}
	@Test
	void customizePageSerializationModeViaConfigProps() {
		this.contextRunner.withPropertyValues('spring.data.web.pageable.serialization-mode=VIA_DTO').run((context) -> {
			SpringDataWebSettings springDataWebSettings = context.getBean(SpringDataWebSettings.class);
			assertThat(springDataWebSettings.pageSerializationMode()).isEqualTo(PageSerializationMode.VIA_DTO);
		});
	}
	@Test
	void customizePageSerializationModeViaCustomBean() {
		this.contextRunner
			.withBean('customSpringDataWebSettings', SpringDataWebSettings.class,
					() -> new SpringDataWebSettings(PageSerializationMode.VIA_DTO))
			.run((context) -> {
				assertThat(context).doesNotHaveBean('springDataWebSettings');
				SpringDataWebSettings springDataWebSettings = context.getBean(SpringDataWebSettings.class);
				assertThat(springDataWebSettings.pageSerializationMode()).isEqualTo(PageSerializationMode.VIA_DTO);
			});
	}
}
/*
package org.springframework.boot.autoconfigure.data.empty;
/**
public class EmptyDataPackage {
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
class CassandraDataAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void templateExists() {
		load(CassandraMockConfiguration.class);
		assertThat(this.context.getBeanNamesForType(CassandraTemplate.class)).hasSize(1);
	}
	@Test
	void entityScanShouldSetManagedTypes() {
		load(EntityScanConfig.class);
		CassandraMappingContext mappingContext = this.context.getBean(CassandraMappingContext.class);
		ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
		assertThat(managedTypes.toList()).containsOnly(City.class);
	}
	@Test
	void userTypeResolverShouldBeSet() {
		load();
		CassandraConverter cassandraConverter = this.context.getBean(CassandraConverter.class);
		assertThat(cassandraConverter).extracting('userTypeResolver').isInstanceOf(SimpleUserTypeResolver.class);
	}
	@Test
	void codecRegistryShouldBeSet() {
		load();
		CassandraConverter cassandraConverter = this.context.getBean(CassandraConverter.class);
		assertThat(cassandraConverter.getCodecRegistry())
			.isSameAs(this.context.getBean(CassandraMockConfiguration.class).codecRegistry);
	}
	@Test
	void defaultConversions() {
		load();
		CassandraTemplate template = this.context.getBean(CassandraTemplate.class);
		assertThat(template.getConverter().getConversionService().canConvert(Person.class, String.class)).isFalse();
	}
	@Test
	void customConversions() {
		load(CustomConversionConfig.class);
		CassandraTemplate template = this.context.getBean(CassandraTemplate.class);
		assertThat(template.getConverter().getConversionService().canConvert(Person.class, String.class)).isTrue();
	}
	@Test
	void clusterDoesNotExist() {
		this.context = new AnnotationConfigApplicationContext(CassandraDataAutoConfiguration.class);
		assertThat(this.context.getBeansOfType(CqlSession.class)).isEmpty();
	}
	void load(Class<?>... config) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.cassandra.keyspaceName:boot_test').applyTo(ctx);
		if (!ObjectUtils.isEmpty(config)) {
			ctx.register(config);
		}
		ctx.register(CassandraMockConfiguration.class, CassandraAutoConfiguration.class,
				CassandraDataAutoConfiguration.class);
		ctx.refresh();
		this.context = ctx;
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('org.springframework.boot.autoconfigure.data.cassandra.city')
	static class EntityScanConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConversionConfig {
		@Bean
		CassandraCustomConversions myCassandraCustomConversions() {
			return new CassandraCustomConversions(Collections.singletonList(new MyConverter()));
		}
	}
	static class MyConverter implements Converter<Person, String> {
		@Override
		public String convert(Person o) {
			return null;
		}
	}
	static class Person {
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
class CassandraRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(CassandraAutoConfiguration.class, CassandraRepositoriesAutoConfiguration.class,
					CassandraDataAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class));
	@Test
	void testDefaultRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CityRepository.class);
			assertThat(context).hasSingleBean(CqlSessionBuilder.class);
			assertThat(getManagedTypes(context).toList()).hasSize(1);
		});
	}
	@Test
	void testNoRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CqlSessionBuilder.class);
			assertThat(getManagedTypes(context).toList()).isEmpty();
		});
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.contextRunner.withUserConfiguration(CustomizedConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CityCassandraRepository.class);
			assertThat(getManagedTypes(context).toList()).hasSize(1).containsOnly(City.class);
		});
	}
	@Test
	void enablingReactiveRepositoriesDisablesImperativeRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.cassandra.repositories.type=reactive')
			.run((context) -> assertThat(context).doesNotHaveBean(CityCassandraRepository.class));
	}
	@Test
	void enablingNoRepositoriesDisablesImperativeRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.cassandra.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(CityCassandraRepository.class));
	}
	private ManagedTypes getManagedTypes(AssertableApplicationContext context) {
		CassandraMappingContext mappingContext = context.getBean(CassandraMappingContext.class);
		return (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	@Import(CassandraMockConfiguration.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@Import(CassandraMockConfiguration.class)
	static class DefaultConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(CassandraRepositoriesAutoConfigurationTests.class)
	@EnableCassandraRepositories(basePackageClasses = CityCassandraRepository.class)
	@Import(CassandraMockConfiguration.class)
	static class CustomizedConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
@Configuration(proxyBeanMethods = false)
class CassandraMockConfiguration {
	final CodecRegistry codecRegistry = mock(CodecRegistry.class);
	@Bean
	CqlSession cqlSession() {
		DriverContext context = mock(DriverContext.class);
		given(context.getCodecRegistry()).willReturn(this.codecRegistry);
		CqlSession cqlSession = mock(CqlSession.class);
		given(cqlSession.getContext()).willReturn(context);
		return cqlSession;
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
class CassandraReactiveDataAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void templateExists() {
		load('spring.cassandra.keyspaceName:boot_test');
		assertThat(this.context.getBeanNamesForType(ReactiveCassandraTemplate.class)).hasSize(1);
	}
	@Test
	void entityScanShouldSetManagedTypes() {
		load(EntityScanConfig.class, 'spring.cassandra.keyspaceName:boot_test');
		CassandraMappingContext mappingContext = this.context.getBean(CassandraMappingContext.class);
		ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
		assertThat(managedTypes.toList()).containsOnly(City.class);
	}
	@Test
	void userTypeResolverShouldBeSet() {
		load('spring.cassandra.keyspaceName:boot_test');
		CassandraConverter cassandraConverter = this.context.getBean(CassandraConverter.class);
		assertThat(cassandraConverter).extracting('userTypeResolver').isInstanceOf(SimpleUserTypeResolver.class);
	}
	private void load(String... environment) {
		load(null, environment);
	}
	private void load(Class<?> config, String... environment) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(environment).applyTo(ctx);
		if (config != null) {
			ctx.register(config);
		}
		ctx.register(CassandraMockConfiguration.class, CassandraAutoConfiguration.class,
				CassandraDataAutoConfiguration.class, CassandraReactiveDataAutoConfiguration.class);
		ctx.refresh();
		this.context = ctx;
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('org.springframework.boot.autoconfigure.data.cassandra.city')
	static class EntityScanConfig {
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra;
/**
class CassandraReactiveRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(CassandraAutoConfiguration.class, CassandraRepositoriesAutoConfiguration.class,
					CassandraDataAutoConfiguration.class, CassandraReactiveDataAutoConfiguration.class,
					CassandraReactiveRepositoriesAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class));
	@Test
	void testDefaultRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ReactiveCityRepository.class);
			assertThat(context).hasSingleBean(CqlSessionBuilder.class);
			assertThat(getManagedTypes(context).toList()).hasSize(1);
		});
	}
	@Test
	void testNoRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CqlSessionBuilder.class);
			assertThat(getManagedTypes(context).toList()).isEmpty();
		});
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.contextRunner.withUserConfiguration(CustomizedConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ReactiveCityCassandraRepository.class);
			assertThat(getManagedTypes(context).toList()).hasSize(1).containsOnly(City.class);
		});
	}
	@Test
	void enablingImperativeRepositoriesDisablesReactiveRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.data.cassandra.repositories.type=imperative')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Test
	void enablingNoRepositoriesDisablesReactiveRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.data.cassandra.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	private ManagedTypes getManagedTypes(ApplicationContext context) {
		CassandraMappingContext mappingContext = context.getBean(CassandraMappingContext.class);
		return (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	@Import(CassandraMockConfiguration.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@Import(CassandraMockConfiguration.class)
	static class DefaultConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(CassandraReactiveRepositoriesAutoConfigurationTests.class)
	@EnableReactiveCassandraRepositories(basePackageClasses = ReactiveCityCassandraRepository.class)
	@Import(CassandraMockConfiguration.class)
	static class CustomizedConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra.city;
@Table
public class City {
	@PrimaryKey
	@CassandraType(type = Name.BIGINT)
	private Long id;
	@Column
	private String name;
	@Column
	private String state;
	@Column
	private String country;
	@Column
	private String map;
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public String getState() {
		return this.state;
	}
	public void setState(String state) {
		this.state = state;
	}
	public String getCountry() {
		return this.country;
	}
	public void setCountry(String country) {
		this.country = country;
	}
	public String getMap() {
		return this.map;
	}
	public void setMap(String map) {
		this.map = map;
	}
}
/*
package org.springframework.boot.autoconfigure.data.cassandra.city;
public interface ReactiveCityRepository extends ReactiveCrudRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.cassandra.city;
public interface CityRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.cassandra;
public interface ReactiveCityCassandraRepository extends ReactiveCrudRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.cassandra;
public interface CityCassandraRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.couchbase;
public interface CityCouchbaseRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.couchbase;
public interface ReactiveCityCouchbaseRepository extends ReactiveCrudRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.neo4j;
public interface CityNeo4jRepository extends Neo4jRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.jpa;
public interface CityJpaRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.elasticsearch;
public interface CityElasticsearchDbRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.elasticsearch;
public interface CityReactiveElasticsearchDbRepository extends ReactiveElasticsearchRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.redis;
public interface CityRedisRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.ldap;
public interface PersonLdapRepository extends Repository<Person, Name> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.mongo;
public interface ReactiveCityMongoDbRepository extends ReactiveCrudRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.alt.mongo;
public interface CityMongoDbRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data;
/**
class ConditionalOnRepositoryTypeTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void imperativeRepositoryMatchesWithNoConfiguredType() {
		this.contextRunner.withUserConfiguration(ImperativeRepository.class)
			.run((context) -> assertThat(context).hasSingleBean(ImperativeRepository.class));
	}
	@Test
	void reactiveRepositoryMatchesWithNoConfiguredType() {
		this.contextRunner.withUserConfiguration(ReactiveRepository.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveRepository.class));
	}
	@Test
	void imperativeRepositoryMatchesWithAutoConfiguredType() {
		this.contextRunner.withUserConfiguration(ImperativeRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:auto')
			.run((context) -> assertThat(context).hasSingleBean(ImperativeRepository.class));
	}
	@Test
	void reactiveRepositoryMatchesWithAutoConfiguredType() {
		this.contextRunner.withUserConfiguration(ReactiveRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:auto')
			.run((context) -> assertThat(context).hasSingleBean(ReactiveRepository.class));
	}
	@Test
	void imperativeRepositoryMatchesWithImperativeConfiguredType() {
		this.contextRunner.withUserConfiguration(ImperativeRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:imperative')
			.run((context) -> assertThat(context).hasSingleBean(ImperativeRepository.class));
	}
	@Test
	void reactiveRepositoryMatchesWithReactiveConfiguredType() {
		this.contextRunner.withUserConfiguration(ReactiveRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:reactive')
			.run((context) -> assertThat(context).hasSingleBean(ReactiveRepository.class));
	}
	@Test
	void imperativeRepositoryDoesNotMatchWithReactiveConfiguredType() {
		this.contextRunner.withUserConfiguration(ImperativeRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:reactive')
			.run((context) -> assertThat(context).doesNotHaveBean(ImperativeRepository.class));
	}
	@Test
	void reactiveRepositoryDoesNotMatchWithImperativeConfiguredType() {
		this.contextRunner.withUserConfiguration(ReactiveRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:imperative')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveRepository.class));
	}
	@Test
	void imperativeRepositoryDoesNotMatchWithNoneConfiguredType() {
		this.contextRunner.withUserConfiguration(ImperativeRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:none')
			.run((context) -> assertThat(context).doesNotHaveBean(ImperativeRepository.class));
	}
	@Test
	void reactiveRepositoryDoesNotMatchWithNoneConfiguredType() {
		this.contextRunner.withUserConfiguration(ReactiveRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:none')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveRepository.class));
	}
	@Test
	void failsFastWhenConfiguredTypeIsUnknown() {
		this.contextRunner.withUserConfiguration(ReactiveRepository.class)
			.withPropertyValues('spring.data.test.repositories.type:abcde')
			.run((context) -> assertThat(context).hasFailed());
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnRepositoryType(store = 'test', type = RepositoryType.IMPERATIVE)
	static class ImperativeRepository {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnRepositoryType(store = 'test', type = RepositoryType.REACTIVE)
	static class ReactiveRepository {
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseDataPropertiesTests {
	@Test
	void typeKeyHasConsistentDefault() {
		assertThat(new CouchbaseDataProperties().getTypeKey()).isEqualTo(DefaultCouchbaseTypeMapper.DEFAULT_TYPE_KEY);
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseReactiveAndImperativeRepositoriesAutoConfigurationTests {
	@Test
	void shouldCreateInstancesForReactiveAndImperativeRepositories() {
		new ApplicationContextRunner()
			.withUserConfiguration(ImperativeAndReactiveConfiguration.class, BaseConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CityRepository.class)
				.hasSingleBean(ReactiveCityRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(CouchbaseAutoConfiguration.class)
	@EnableCouchbaseRepositories(basePackageClasses = CityRepository.class)
	@EnableReactiveCouchbaseRepositories(basePackageClasses = ReactiveCityRepository.class)
	static class ImperativeAndReactiveConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ CouchbaseMockConfiguration.class, Registrar.class })
	static class BaseConfiguration {
	}
	static class Registrar implements ImportSelector {
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			List<String> names = new ArrayList<>();
			for (Class<?> type : new Class<?>[] { CouchbaseAutoConfiguration.class,
					CouchbaseDataAutoConfiguration.class, CouchbaseRepositoriesAutoConfiguration.class,
					CouchbaseReactiveDataAutoConfiguration.class,
					CouchbaseReactiveRepositoriesAutoConfiguration.class }) {
				names.add(type.getName());
			}
			return StringUtils.toStringArray(names);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class, CouchbaseAutoConfiguration.class,
				CouchbaseDataAutoConfiguration.class));
	@Test
	void disabledIfCouchbaseIsNotConfigured() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(CouchbaseTemplate.class));
	}
	@Test
	void validatorIsPresent() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
	}
	@Test
	void entityScanShouldSetInitialEntitySet() {
		this.contextRunner.withUserConfiguration(EntityScanConfig.class).run((context) -> {
			CouchbaseMappingContext mappingContext = context.getBean(CouchbaseMappingContext.class);
			ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
			assertThat(managedTypes.toList()).containsOnly(City.class);
		});
	}
	@Test
	void typeKeyDefault() {
		this.contextRunner.withUserConfiguration(CouchbaseMockConfiguration.class)
			.run((context) -> assertThat(context.getBean(MappingCouchbaseConverter.class).getTypeKey())
				.isEqualTo(DefaultCouchbaseTypeMapper.DEFAULT_TYPE_KEY));
	}
	@Test
	void typeKeyCanBeCustomized() {
		this.contextRunner.withUserConfiguration(CouchbaseMockConfiguration.class)
			.withPropertyValues('spring.data.couchbase.type-key=_custom')
			.run((context) -> assertThat(context.getBean(MappingCouchbaseConverter.class).getTypeKey())
				.isEqualTo('_custom'));
	}
	@Test
	void customConversions() {
		this.contextRunner.withUserConfiguration(CustomConversionsConfig.class).run((context) -> {
			CouchbaseTemplate template = context.getBean(CouchbaseTemplate.class);
			assertThat(
					template.getConverter().getConversionService().canConvert(CouchbaseProperties.class, Boolean.class))
				.isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CouchbaseMockConfiguration.class)
	static class CustomConversionsConfig {
		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
		CouchbaseCustomConversions myCustomConversions() {
			return new CouchbaseCustomConversions(Collections.singletonList(new MyConverter()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('org.springframework.boot.autoconfigure.data.couchbase.city')
	@Import(CouchbaseMockConfiguration.class)
	static class EntityScanConfig {
	}
	static class MyConverter implements Converter<CouchbaseProperties, Boolean> {
		@Override
		public Boolean convert(CouchbaseProperties value) {
			return true;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class, CouchbaseDataAutoConfiguration.class,
				CouchbaseRepositoriesAutoConfiguration.class));
	@Test
	void couchbaseNotAvailable() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Test
	void defaultRepository() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CityRepository.class));
	}
	@Test
	void reactiveRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.data.couchbase.repositories.type=reactive')
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Test
	void disabledRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.data.couchbase.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Test
	void noRepositoryAvailable() {
		this.contextRunner.withUserConfiguration(NoRepositoryConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class CouchbaseNotAvailableConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@Import(CouchbaseMockConfiguration.class)
	static class DefaultConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	@Import(CouchbaseMockConfiguration.class)
	static class NoRepositoryConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseReactiveRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CouchbaseAutoConfiguration.class, CouchbaseDataAutoConfiguration.class,
				CouchbaseRepositoriesAutoConfiguration.class, CouchbaseReactiveDataAutoConfiguration.class,
				CouchbaseReactiveRepositoriesAutoConfiguration.class));
	@Test
	void couchbaseNotAvailable() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Test
	void defaultRepository() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveCityRepository.class));
	}
	@Test
	void imperativeRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.data.couchbase.repositories.type=imperative')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Test
	void disabledRepositories() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class)
			.withPropertyValues('spring.data.couchbase.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Test
	void noRepositoryAvailable() {
		this.contextRunner.withUserConfiguration(NoRepositoryConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.contextRunner.withUserConfiguration(CustomizedConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityCouchbaseRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@Import(CouchbaseMockConfiguration.class)
	static class DefaultConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	@Import(CouchbaseMockConfiguration.class)
	static class NoRepositoryConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(CouchbaseReactiveRepositoriesAutoConfigurationTests.class)
	@EnableCouchbaseRepositories(basePackageClasses = CityCouchbaseRepository.class)
	@Import(CouchbaseMockConfiguration.class)
	static class CustomizedConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
class CouchbaseReactiveDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class, CouchbaseAutoConfiguration.class,
				CouchbaseDataAutoConfiguration.class, CouchbaseReactiveDataAutoConfiguration.class));
	@Test
	void disabledIfCouchbaseIsNotConfigured() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCouchbaseTemplate.class));
	}
	@Test
	void validatorIsPresent() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ValidatingCouchbaseEventListener.class));
	}
	@Test
	void entityScanShouldSetInitialEntitySet() {
		this.contextRunner.withUserConfiguration(EntityScanConfig.class).run((context) -> {
			CouchbaseMappingContext mappingContext = context.getBean(CouchbaseMappingContext.class);
			ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
			assertThat(managedTypes.toList()).containsOnly(City.class);
		});
	}
	@Test
	void customConversions() {
		this.contextRunner.withUserConfiguration(CustomConversionsConfig.class).run((context) -> {
			ReactiveCouchbaseTemplate template = context.getBean(ReactiveCouchbaseTemplate.class);
			assertThat(
					template.getConverter().getConversionService().canConvert(CouchbaseProperties.class, Boolean.class))
				.isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	@Import(CouchbaseMockConfiguration.class)
	static class CustomConversionsConfig {
		@Bean(BeanNames.COUCHBASE_CUSTOM_CONVERSIONS)
		CouchbaseCustomConversions myCustomConversions() {
			return new CouchbaseCustomConversions(Collections.singletonList(new MyConverter()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('org.springframework.boot.autoconfigure.data.couchbase.city')
	@Import(CouchbaseMockConfiguration.class)
	static class EntityScanConfig {
	}
	static class MyConverter implements Converter<CouchbaseProperties, Boolean> {
		@Override
		public Boolean convert(CouchbaseProperties value) {
			return true;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.couchbase.city;
@Document
public class City {
	@Id
	private String id;
	@Field
	private String name;
}
/*
package org.springframework.boot.autoconfigure.data.couchbase.city;
public interface ReactiveCityRepository extends Repository<City, Long> {
	Mono<City> save(City city);
	Mono<City> findById(Long id);
}
/*
package org.springframework.boot.autoconfigure.data.couchbase.city;
public interface CityRepository extends Repository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.couchbase;
/**
@Configuration(proxyBeanMethods = false)
class CouchbaseMockConfiguration {
	@Bean
	CouchbaseClientFactory couchbaseClientFactory() {
		return mock(CouchbaseClientFactory.class);
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
class Neo4jDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(MockedDriverConfiguration.class)
		.withConfiguration(AutoConfigurations.of(Neo4jAutoConfiguration.class, Neo4jDataAutoConfiguration.class));
	@Test
	void shouldProvideConversions() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(Neo4jConversions.class));
	}
	@Test
	void shouldProvideDefaultDatabaseNameProvider() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(DatabaseSelectionProvider.class);
			assertThat(context.getBean(DatabaseSelectionProvider.class))
				.isSameAs(DatabaseSelectionProvider.getDefaultSelectionProvider());
		});
	}
	@Test
	void shouldUseDatabaseNameIfSet() {
		this.contextRunner.withPropertyValues('spring.data.neo4j.database=test').run((context) -> {
			assertThat(context).hasSingleBean(DatabaseSelectionProvider.class);
			assertThat(context.getBean(DatabaseSelectionProvider.class).getDatabaseSelection())
				.isEqualTo(DatabaseSelection.byName('test'));
		});
	}
	@Test
	void shouldReuseExistingDatabaseNameProvider() {
		this.contextRunner.withPropertyValues('spring.data.neo4j.database=ignored')
			.withUserConfiguration(CustomDatabaseSelectionProviderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(DatabaseSelectionProvider.class);
				assertThat(context.getBean(DatabaseSelectionProvider.class).getDatabaseSelection())
					.isEqualTo(DatabaseSelection.byName('custom'));
			});
	}
	@Test
	void shouldProvideNeo4jClient() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(Neo4jClient.class));
	}
	@Test
	void shouldProvideNeo4jClientWithCustomDatabaseSelectionProvider() {
		this.contextRunner.withUserConfiguration(CustomDatabaseSelectionProviderConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Neo4jClient.class);
			assertThat(context.getBean(Neo4jClient.class)).extracting('databaseSelectionProvider')
				.isSameAs(context.getBean(DatabaseSelectionProvider.class));
		});
	}
	@Test
	void shouldReuseExistingNeo4jClient() {
		this.contextRunner.withUserConfiguration(Neo4jClientConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(Neo4jClient.class).hasBean('myCustomClient'));
	}
	@Test
	void shouldProvideNeo4jTemplate() {
		this.contextRunner.withUserConfiguration(CustomDatabaseSelectionProviderConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Neo4jTemplate.class));
	}
	@Test
	void shouldReuseExistingNeo4jTemplate() {
		this.contextRunner.withBean('myCustomOperations', Neo4jOperations.class, () -> mock(Neo4jOperations.class))
			.run((context) -> assertThat(context).hasSingleBean(Neo4jOperations.class).hasBean('myCustomOperations'));
	}
	@Test
	void shouldProvideTransactionManager() {
		this.contextRunner.withUserConfiguration(CustomDatabaseSelectionProviderConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Neo4jTransactionManager.class);
			assertThat(context.getBean(Neo4jTransactionManager.class)).extracting('databaseSelectionProvider')
				.isSameAs(context.getBean(DatabaseSelectionProvider.class));
		});
	}
	@Test
	void shouldBackoffIfReactiveTransactionManagerIsSet() {
		this.contextRunner.withBean(ReactiveTransactionManager.class, () -> mock(ReactiveTransactionManager.class))
			.run((context) -> assertThat(context).doesNotHaveBean(Neo4jTransactionManager.class)
				.hasSingleBean(TransactionManager.class));
	}
	@Test
	void shouldReuseExistingTransactionManager() {
		this.contextRunner
			.withBean('myCustomTransactionManager', PlatformTransactionManager.class,
					() -> mock(PlatformTransactionManager.class))
			.run((context) -> assertThat(context).hasSingleBean(PlatformTransactionManager.class)
				.hasBean('myCustomTransactionManager'));
	}
	@Test
	void shouldFilterInitialEntityScanWithKnownAnnotations() {
		this.contextRunner.withUserConfiguration(EntityScanConfig.class).run((context) -> {
			Neo4jMappingContext mappingContext = context.getBean(Neo4jMappingContext.class);
			assertThat(mappingContext.hasPersistentEntityFor(TestNode.class)).isTrue();
			assertThat(mappingContext.hasPersistentEntityFor(TestPersistent.class)).isFalse();
			assertThat(mappingContext.hasPersistentEntityFor(TestRelationshipProperties.class)).isTrue();
			assertThat(mappingContext.hasPersistentEntityFor(TestNonAnnotated.class)).isFalse();
		});
	}
	@Test
	void shouldProvideManagedTypes() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Neo4jManagedTypes.class);
			assertThat(context.getBean(Neo4jMappingContext.class))
				.extracting((mappingContext) -> ReflectionTestUtils.getField(mappingContext, 'managedTypes'))
				.isEqualTo(context.getBean(Neo4jManagedTypes.class));
		});
	}
	@Test
	void shouldReuseExistingManagedTypes() {
		Neo4jManagedTypes managedTypes = Neo4jManagedTypes.from();
		this.contextRunner.withBean('customManagedTypes', Neo4jManagedTypes.class, () -> managedTypes)
			.run((context) -> {
				assertThat(context).hasSingleBean(Neo4jManagedTypes.class);
				assertThat(context).doesNotHaveBean('neo4jManagedTypes');
				assertThat(context.getBean(Neo4jMappingContext.class))
					.extracting((mappingContext) -> ReflectionTestUtils.getField(mappingContext, 'managedTypes'))
					.isSameAs(managedTypes);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDatabaseSelectionProviderConfiguration {
		@Bean
		DatabaseSelectionProvider databaseSelectionProvider() {
			return () -> DatabaseSelection.byName('custom');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(TestPersistent.class)
	static class EntityScanConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class Neo4jClientConfig {
		@Bean
		Neo4jClient myCustomClient(Driver driver) {
			return Neo4jClient.create(driver);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
class Neo4jRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(MockedDriverConfiguration.class)
		.withConfiguration(
				AutoConfigurations.of(Neo4jDataAutoConfiguration.class, Neo4jRepositoriesAutoConfiguration.class));
	@Test
	void configurationWithDefaultRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CityRepository.class));
	}
	@Test
	void configurationWithNoRepositories() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Neo4jTransactionManager.class)
				.doesNotHaveBean(Neo4jRepository.class));
	}
	@Test
	void configurationWithDisabledRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.data.neo4j.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(Neo4jRepository.class));
	}
	@Test
	void autoConfigurationShouldNotKickInEvenIfManualConfigDidNotCreateAnyRepositories() {
		this.contextRunner.withUserConfiguration(SortOfInvalidCustomConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(Neo4jTransactionManager.class)
				.doesNotHaveBean(Neo4jRepository.class));
	}
	@Test
	void shouldRespectAtEnableNeo4jRepositories() {
		this.contextRunner.withUserConfiguration(SortOfInvalidCustomConfiguration.class, WithCustomRepositoryScan.class)
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class)
				.doesNotHaveBean(ReactiveCityRepository.class)
				.hasSingleBean(CountryRepository.class)
				.doesNotHaveBean(ReactiveCountryRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@EnableNeo4jRepositories(basePackageClasses = CountryRepository.class)
	static class WithCustomRepositoryScan {
	}
	@Configuration(proxyBeanMethods = false)
	static class WithFakeEnabledReactiveNeo4jRepositories {
		@Bean
		ReactiveNeo4jRepositoryFactoryBean<?, ?, ?> reactiveNeo4jRepositoryFactoryBean() {
			return mock(ReactiveNeo4jRepositoryFactoryBean.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableNeo4jRepositories('foo.bar')
	@TestAutoConfigurationPackage(Neo4jRepositoriesAutoConfigurationTests.class)
	static class SortOfInvalidCustomConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.empty;
public class EmptyMarker {
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.country;
public interface ReactiveCountryRepository extends ReactiveNeo4jRepository<Country, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.country;
public interface CountryRepository extends Neo4jRepository<Country, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.country;
@Node
public class Country implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	private final String name;
	public Country(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	@Override
	public String toString() {
		return getName();
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
@Configuration(proxyBeanMethods = false)
class MockedDriverConfiguration {
	@Bean
	Driver driver() {
		Driver driver = mock(Driver.class);
		Session session = mock(Session.class);
		given(driver.session(ArgumentMatchers.any(SessionConfig.class))).willReturn(session);
		return driver;
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
class Neo4jReactiveDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(MockedDriverConfiguration.class)
		.withConfiguration(AutoConfigurations.of(Neo4jAutoConfiguration.class, Neo4jDataAutoConfiguration.class,
				Neo4jReactiveDataAutoConfiguration.class));
	@Test
	void shouldProvideDefaultDatabaseNameProvider() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(ReactiveDatabaseSelectionProvider.class);
			assertThat(context.getBean(ReactiveDatabaseSelectionProvider.class))
				.isSameAs(ReactiveDatabaseSelectionProvider.getDefaultSelectionProvider());
		});
	}
	@Test
	void shouldUseDatabaseNameIfSet() {
		this.contextRunner.withPropertyValues('spring.data.neo4j.database=test').run((context) -> {
			assertThat(context).hasSingleBean(ReactiveDatabaseSelectionProvider.class);
			StepVerifier.create(context.getBean(ReactiveDatabaseSelectionProvider.class).getDatabaseSelection())
				.consumeNextWith((databaseSelection) -> assertThat(databaseSelection.getValue()).isEqualTo('test'))
				.expectComplete();
		});
	}
	@Test
	void shouldReuseExistingDatabaseNameProvider() {
		this.contextRunner.withPropertyValues('spring.data.neo4j.database=ignored')
			.withUserConfiguration(CustomReactiveDatabaseSelectionProviderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveDatabaseSelectionProvider.class);
				StepVerifier.create(context.getBean(ReactiveDatabaseSelectionProvider.class).getDatabaseSelection())
					.consumeNextWith(
							(databaseSelection) -> assertThat(databaseSelection.getValue()).isEqualTo('custom'))
					.expectComplete();
			});
	}
	@Test
	void shouldProvideReactiveNeo4jClient() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ReactiveNeo4jClient.class));
	}
	@Test
	void shouldProvideReactiveNeo4jClientWithCustomDatabaseSelectionProvider() {
		this.contextRunner.withUserConfiguration(CustomReactiveDatabaseSelectionProviderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ReactiveNeo4jClient.class);
				assertThat(context.getBean(ReactiveNeo4jClient.class)).extracting('databaseSelectionProvider')
					.isSameAs(context.getBean(ReactiveDatabaseSelectionProvider.class));
			});
	}
	@Test
	void shouldReuseExistingReactiveNeo4jClient() {
		this.contextRunner.withUserConfiguration(ReactiveNeo4jClientConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveNeo4jClient.class)
				.hasBean('myCustomReactiveClient'));
	}
	@Test
	void shouldProvideReactiveNeo4jTemplate() {
		this.contextRunner.withUserConfiguration(CustomReactiveDatabaseSelectionProviderConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveNeo4jTemplate.class));
	}
	@Test
	void shouldReuseExistingReactiveNeo4jTemplate() {
		this.contextRunner
			.withBean('myCustomReactiveOperations', ReactiveNeo4jOperations.class,
					() -> mock(ReactiveNeo4jOperations.class))
			.run((context) -> assertThat(context).hasSingleBean(ReactiveNeo4jOperations.class)
				.hasBean('myCustomReactiveOperations'));
	}
	@Test
	void shouldUseExistingReactiveTransactionManager() {
		this.contextRunner
			.withBean('myCustomReactiveTransactionManager', ReactiveTransactionManager.class,
					() -> mock(ReactiveTransactionManager.class))
			.run((context) -> assertThat(context).hasSingleBean(ReactiveTransactionManager.class)
				.hasSingleBean(TransactionManager.class));
	}
	@Test
	void shouldFilterInitialEntityScanWithKnownAnnotations() {
		this.contextRunner.withUserConfiguration(EntityScanConfig.class).run((context) -> {
			Neo4jMappingContext mappingContext = context.getBean(Neo4jMappingContext.class);
			assertThat(mappingContext.hasPersistentEntityFor(TestNode.class)).isTrue();
			assertThat(mappingContext.hasPersistentEntityFor(TestPersistent.class)).isFalse();
			assertThat(mappingContext.hasPersistentEntityFor(TestRelationshipProperties.class)).isTrue();
			assertThat(mappingContext.hasPersistentEntityFor(TestNonAnnotated.class)).isFalse();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomReactiveDatabaseSelectionProviderConfiguration {
		@Bean
		ReactiveDatabaseSelectionProvider databaseNameProvider() {
			return () -> Mono.just(DatabaseSelection.byName('custom'));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(TestPersistent.class)
	static class EntityScanConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveNeo4jClientConfig {
		@Bean
		ReactiveNeo4jClient myCustomReactiveClient(Driver driver) {
			return ReactiveNeo4jClient.create(driver);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
class MixedNeo4jRepositoriesAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void testDefaultRepositoryConfiguration() {
		load(TestConfiguration.class);
		assertThat(this.context.getBean(CountryRepository.class)).isNotNull();
	}
	@Test
	void testMixedRepositoryConfiguration() {
		load(MixedConfiguration.class);
		assertThat(this.context.getBean(CountryRepository.class)).isNotNull();
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Test
	void testJpaRepositoryConfigurationWithNeo4jTemplate() {
		load(JpaConfiguration.class);
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Test
	@Disabled
	void testJpaRepositoryConfigurationWithNeo4jOverlap() {
		load(OverlapConfiguration.class);
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Test
	void testJpaRepositoryConfigurationWithNeo4jOverlapDisabled() {
		load(OverlapConfiguration.class, 'spring.data.neo4j.repositories.enabled:false');
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	private void load(Class<?> config, String... environment) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(environment).applyTo(context);
		context.register(config);
		context.register(DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class,
				JpaRepositoriesAutoConfiguration.class, Neo4jDataAutoConfiguration.class,
				Neo4jReactiveDataAutoConfiguration.class, Neo4jRepositoriesAutoConfiguration.class,
				Neo4jReactiveRepositoriesAutoConfiguration.class);
		context.refresh();
		this.context = context;
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyMarker.class)
	// Not this package or its parent
	@EnableNeo4jRepositories(basePackageClasses = Country.class)
	static class TestConfiguration extends AbstractNeo4jConfig {
		@Override
		@Bean
		public Driver driver() {
			return GraphDatabase.driver('bolt://neo4j.test:7687',
					Config.builder().withLogging(new Slf4jLogging()).build());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyMarker.class)
	@EnableNeo4jRepositories(basePackageClasses = Country.class)
	@EntityScan(basePackageClasses = City.class)
	@EnableJpaRepositories(basePackageClasses = CityRepository.class)
	static class MixedConfiguration extends AbstractNeo4jConfig {
		@Override
		@Bean
		public Driver driver() {
			return GraphDatabase.driver('bolt://neo4j.test:7687',
					Config.builder().withLogging(new Slf4jLogging()).build());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyMarker.class)
	@EntityScan(basePackageClasses = City.class)
	@EnableJpaRepositories(basePackageClasses = CityRepository.class)
	static class JpaConfiguration {
	}
	// In this one the Jpa repositories and the auto-configuration packages overlap, so
	// Neo4j will try and configure the same repositories
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(CityRepository.class)
	@EnableJpaRepositories(basePackageClasses = CityRepository.class)
	static class OverlapConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j;
/**
class Neo4jReactiveRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(MockedDriverConfiguration.class)
		.withConfiguration(
				AutoConfigurations.of(Neo4jDataAutoConfiguration.class, Neo4jReactiveDataAutoConfiguration.class,
						Neo4jRepositoriesAutoConfiguration.class, Neo4jReactiveRepositoriesAutoConfiguration.class));
	@Test
	void configurationWithDefaultRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveCityRepository.class));
	}
	@Test
	void configurationWithNoRepositories() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveNeo4jTemplate.class)
				.doesNotHaveBean(ReactiveNeo4jRepository.class));
	}
	@Test
	void configurationWithDisabledRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.data.neo4j.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveNeo4jRepository.class));
	}
	@Test
	void autoConfigurationShouldNotKickInEvenIfManualConfigDidNotCreateAnyRepositories() {
		this.contextRunner.withUserConfiguration(SortOfInvalidCustomConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveNeo4jTemplate.class)
				.doesNotHaveBean(ReactiveNeo4jRepository.class));
	}
	@Test
	void shouldRespectAtEnableReactiveNeo4jRepositories() {
		this.contextRunner
			.withUserConfiguration(SortOfInvalidCustomConfiguration.class, WithCustomReactiveRepositoryScan.class)
			.withPropertyValues('spring.data.neo4j.repositories.type=reactive')
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class)
				.doesNotHaveBean(ReactiveCityRepository.class)
				.doesNotHaveBean(CountryRepository.class)
				.hasSingleBean(ReactiveCountryRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableReactiveNeo4jRepositories('foo.bar')
	@TestAutoConfigurationPackage(Neo4jReactiveRepositoriesAutoConfigurationTests.class)
	static class SortOfInvalidCustomConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableReactiveNeo4jRepositories(basePackageClasses = ReactiveCountryRepository.class)
	static class WithCustomReactiveRepositoryScan {
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.scan;
public class TestNonAnnotated {
	@Id
	@GeneratedValue
	private Long id;
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.scan;
@RelationshipProperties
public class TestRelationshipProperties {
	@Id
	@GeneratedValue
	Long id;
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.scan;
@Node
public class TestNode {
	@Id
	@GeneratedValue
	private Long id;
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.scan;
@Persistent
public class TestPersistent {
	@Id
	@GeneratedValue
	private Long id;
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.city;
@Node
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	private final String name;
	private String state;
	private final Country country;
	private String map;
	public City(String name, Country country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public Country getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.city;
public interface ReactiveCityRepository extends ReactiveNeo4jRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.neo4j.city;
public interface CityRepository extends Neo4jRepository<City, Long> {
	@Override
	Page<City> findAll(Pageable pageable);
}
/*
package org.springframework.boot.autoconfigure.data.jpa;
/**
class JpaWebAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class,
				JpaRepositoriesAutoConfiguration.class, SpringDataWebAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void springDataWebIsConfiguredWithJpaRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CityRepository.class);
			assertThat(context).hasSingleBean(PageableHandlerMethodArgumentResolver.class);
			assertThat(context).hasSingleBean(SortHandlerMethodArgumentResolver.class);
			assertThat(context.getBean(FormattingConversionService.class).canConvert(String.class, Distance.class))
				.isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@EnableWebMvc
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.jpa.country;
public interface CountryRepository extends JpaRepository<Country, Long>, RevisionRepository<Country, Long, Integer> {
}
/*
package org.springframework.boot.autoconfigure.data.jpa.country;
@Entity
public class Country implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	@Audited
	@Column
	private String name;
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.autoconfigure.data.jpa;
/**
class EnversRevisionRepositoriesAutoConfigurationTests extends AbstractJpaRepositoriesAutoConfigurationTests {
	@Test
	void autoConfigurationShouldSucceedWithRevisionRepository() {
		this.contextRunner.withUserConfiguration(RevisionRepositoryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CountryRepository.class));
	}
}
/*
package org.springframework.boot.autoconfigure.data.jpa;
/**
@ClassPathExclusions('spring-data-envers-*.jar')
class JpaRepositoriesAutoConfigurationTests extends AbstractJpaRepositoriesAutoConfigurationTests {
	@Test
	void autoConfigurationShouldFailWithRevisionRepository() {
		this.contextRunner.withUserConfiguration(RevisionRepositoryConfiguration.class)
			.run((context) -> assertThat(context).getFailure().isInstanceOf(BeanCreationException.class));
	}
}
/*
package org.springframework.boot.autoconfigure.data.jpa.city;
@Entity
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	@Column(nullable = false)
	private String name;
	@Column(nullable = false)
	private String state;
	@Column(nullable = false)
	private String country;
	@Column(nullable = false)
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.data.jpa.city;
public interface CityRepository extends JpaRepository<City, Long> {
	@Override
	Page<City> findAll(Pageable pageable);
	Page<City> findByNameLikeAndCountryLikeAllIgnoringCase(String name, String country, Pageable pageable);
	City findByNameAndCountryAllIgnoringCase(String name, String country);
}
/*
package org.springframework.boot.autoconfigure.data.jpa;
/**
abstract class AbstractJpaRepositoriesAutoConfigurationTests {
	final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HibernateJpaAutoConfiguration.class,
				JpaRepositoriesAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class))
		.withUserConfiguration(EmbeddedDataSourceConfiguration.class);
	@Test
	void testDefaultRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CityRepository.class);
			assertThat(context).hasSingleBean(PlatformTransactionManager.class);
			assertThat(context).hasSingleBean(EntityManagerFactory.class);
			assertThat(context.getBean(LocalContainerEntityManagerFactoryBean.class).getBootstrapExecutor()).isNull();
		});
	}
	@Test
	void testOverrideRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CityJpaRepository.class);
			assertThat(context).hasSingleBean(PlatformTransactionManager.class);
			assertThat(context).hasSingleBean(EntityManagerFactory.class);
		});
	}
	@Test
	void autoConfigurationShouldNotKickInEvenIfManualConfigDidNotCreateAnyRepositories() {
		this.contextRunner.withUserConfiguration(SortOfInvalidCustomConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Test
	void whenBootstrapModeIsLazyWithMultipleAsyncExecutorBootstrapExecutorIsConfigured() {
		this.contextRunner.withUserConfiguration(MultipleAsyncTaskExecutorConfiguration.class)
			.withConfiguration(
					AutoConfigurations.of(TaskExecutionAutoConfiguration.class, TaskSchedulingAutoConfiguration.class))
			.withPropertyValues('spring.data.jpa.repositories.bootstrap-mode=lazy')
			.run((context) -> assertThat(
					context.getBean(LocalContainerEntityManagerFactoryBean.class).getBootstrapExecutor())
				.isEqualTo(context.getBean('applicationTaskExecutor')));
	}
	@Test
	void whenBootstrapModeIsLazyWithSingleAsyncExecutorBootstrapExecutorIsConfigured() {
		this.contextRunner.withUserConfiguration(SingleAsyncTaskExecutorConfiguration.class)
			.withPropertyValues('spring.data.jpa.repositories.bootstrap-mode=lazy')
			.run((context) -> assertThat(
					context.getBean(LocalContainerEntityManagerFactoryBean.class).getBootstrapExecutor())
				.isEqualTo(context.getBean('testAsyncTaskExecutor')));
	}
	@Test
	void whenBootstrapModeIsDeferredBootstrapExecutorIsConfigured() {
		this.contextRunner.withUserConfiguration(MultipleAsyncTaskExecutorConfiguration.class)
			.withConfiguration(
					AutoConfigurations.of(TaskExecutionAutoConfiguration.class, TaskSchedulingAutoConfiguration.class))
			.withPropertyValues('spring.data.jpa.repositories.bootstrap-mode=deferred')
			.run((context) -> assertThat(
					context.getBean(LocalContainerEntityManagerFactoryBean.class).getBootstrapExecutor())
				.isEqualTo(context.getBean('applicationTaskExecutor')));
	}
	@Test
	void whenBootstrapModeIsDefaultBootstrapExecutorIsNotConfigured() {
		this.contextRunner.withUserConfiguration(MultipleAsyncTaskExecutorConfiguration.class)
			.withConfiguration(
					AutoConfigurations.of(TaskExecutionAutoConfiguration.class, TaskSchedulingAutoConfiguration.class))
			.withPropertyValues('spring.data.jpa.repositories.bootstrap-mode=default')
			.run((context) -> assertThat(
					context.getBean(LocalContainerEntityManagerFactoryBean.class).getBootstrapExecutor())
				.isNull());
	}
	@Test
	void bootstrapModeIsDefaultByDefault() {
		this.contextRunner.withUserConfiguration(MultipleAsyncTaskExecutorConfiguration.class)
			.withConfiguration(
					AutoConfigurations.of(TaskExecutionAutoConfiguration.class, TaskSchedulingAutoConfiguration.class))
			.run((context) -> assertThat(
					context.getBean(LocalContainerEntityManagerFactoryBean.class).getBootstrapExecutor())
				.isNull());
	}
	@Configuration(proxyBeanMethods = false)
	@EnableScheduling
	@Import(TestConfiguration.class)
	static class MultipleAsyncTaskExecutorConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(TestConfiguration.class)
	static class SingleAsyncTaskExecutorConfiguration {
		@Bean
		SimpleAsyncTaskExecutor testAsyncTaskExecutor() {
			return new SimpleAsyncTaskExecutor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableJpaRepositories(
			basePackageClasses = org.springframework.boot.autoconfigure.data.alt.jpa.CityJpaRepository.class,
			excludeFilters = { @Filter(type = FilterType.ASSIGNABLE_TYPE, value = CityMongoDbRepository.class),
					@Filter(type = FilterType.ASSIGNABLE_TYPE, value = CityElasticsearchDbRepository.class) })
	@TestAutoConfigurationPackage(City.class)
	static class CustomConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	// To not find any repositories
	@EnableJpaRepositories('foo.bar')
	@TestAutoConfigurationPackage(City.class)
	static class SortOfInvalidCustomConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(Country.class)
	static class RevisionRepositoryConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.rest;
/**
class RepositoryRestMvcAutoConfigurationTests {
	private AnnotationConfigServletWebApplicationContext context;
	@AfterEach
	void tearDown() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void testDefaultRepositoryConfiguration() {
		load(TestConfiguration.class);
		assertThat(this.context.getBean(RepositoryRestMvcConfiguration.class)).isNotNull();
	}
	@Test
	void testWithCustomBasePath() {
		load(TestConfiguration.class, 'spring.data.rest.base-path:foo');
		assertThat(this.context.getBean(RepositoryRestMvcConfiguration.class)).isNotNull();
		RepositoryRestConfiguration bean = this.context.getBean(RepositoryRestConfiguration.class);
		URI expectedUri = URI.create('/foo');
		assertThat(bean.getBasePath()).as('Custom basePath not set').isEqualTo(expectedUri);
		BaseUri baseUri = this.context.getBean(BaseUri.class);
		assertThat(expectedUri).as('Custom basePath has not been applied to BaseUri bean').isEqualTo(baseUri.getUri());
	}
	@Test
	void testWithCustomSettings() {
		load(TestConfiguration.class, 'spring.data.rest.default-page-size:42', 'spring.data.rest.max-page-size:78',
				'spring.data.rest.page-param-name:_page', 'spring.data.rest.limit-param-name:_limit',
				'spring.data.rest.sort-param-name:_sort', 'spring.data.rest.detection-strategy=visibility',
				'spring.data.rest.default-media-type:application/my-json',
				'spring.data.rest.return-body-on-create:false', 'spring.data.rest.return-body-on-update:false',
				'spring.data.rest.enable-enum-translation:true');
		assertThat(this.context.getBean(RepositoryRestMvcConfiguration.class)).isNotNull();
		RepositoryRestConfiguration bean = this.context.getBean(RepositoryRestConfiguration.class);
		assertThat(bean.getDefaultPageSize()).isEqualTo(42);
		assertThat(bean.getMaxPageSize()).isEqualTo(78);
		assertThat(bean.getPageParamName()).isEqualTo('_page');
		assertThat(bean.getLimitParamName()).isEqualTo('_limit');
		assertThat(bean.getSortParamName()).isEqualTo('_sort');
		assertThat(bean.getRepositoryDetectionStrategy()).isEqualTo(RepositoryDetectionStrategies.VISIBILITY);
		assertThat(bean.getDefaultMediaType()).isEqualTo(MediaType.parseMediaType('application/my-json'));
		assertThat(bean.returnBodyOnCreate(null)).isFalse();
		assertThat(bean.returnBodyOnUpdate(null)).isFalse();
		assertThat(bean.isEnableEnumTranslation()).isTrue();
	}
	@Test
	void testWithCustomConfigurer() {
		load(TestConfigurationWithConfigurer.class, 'spring.data.rest.detection-strategy=visibility',
				'spring.data.rest.default-media-type:application/my-json');
		assertThat(this.context.getBean(RepositoryRestMvcConfiguration.class)).isNotNull();
		RepositoryRestConfiguration bean = this.context.getBean(RepositoryRestConfiguration.class);
		assertThat(bean.getRepositoryDetectionStrategy()).isEqualTo(RepositoryDetectionStrategies.ALL);
		assertThat(bean.getDefaultMediaType()).isEqualTo(MediaType.parseMediaType('application/my-custom-json'));
		assertThat(bean.getMaxPageSize()).isEqualTo(78);
	}
	@Test
	void backOffWithCustomConfiguration() {
		load(TestConfigurationWithRestMvcConfig.class, 'spring.data.rest.base-path:foo');
		assertThat(this.context.getBean(RepositoryRestMvcConfiguration.class)).isNotNull();
		RepositoryRestConfiguration bean = this.context.getBean(RepositoryRestConfiguration.class);
		assertThat(bean.getBasePath()).isEqualTo(URI.create(''));
	}
	private void load(Class<?> config, String... environment) {
		AnnotationConfigServletWebApplicationContext applicationContext = new AnnotationConfigServletWebApplicationContext();
		applicationContext.setServletContext(new MockServletContext());
		applicationContext.register(config, BaseConfiguration.class);
		TestPropertyValues.of(environment).applyTo(applicationContext);
		applicationContext.refresh();
		this.context = applicationContext;
	}
	@Configuration(proxyBeanMethods = false)
	@Import(EmbeddedDataSourceConfiguration.class)
	@ImportAutoConfiguration({ HibernateJpaAutoConfiguration.class, JpaRepositoriesAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class,
			JacksonAutoConfiguration.class })
	static class BaseConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@EnableWebMvc
	static class TestConfiguration {
	}
	@Import({ TestConfiguration.class, TestRepositoryRestConfigurer.class })
	static class TestConfigurationWithConfigurer {
	}
	@Import({ TestConfiguration.class, RepositoryRestMvcConfiguration.class })
	static class TestConfigurationWithRestMvcConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@EnableWebMvc
	static class TestConfigurationWithObjectMapperBuilder {
		@Bean
		Jackson2ObjectMapperBuilder objectMapperBuilder() {
			Jackson2ObjectMapperBuilder objectMapperBuilder = new Jackson2ObjectMapperBuilder();
			objectMapperBuilder.simpleDateFormat('yyyy-MM');
			return objectMapperBuilder;
		}
	}
	static class TestRepositoryRestConfigurer implements RepositoryRestConfigurer {
		@Override
		public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config, CorsRegistry cors) {
			config.setRepositoryDetectionStrategy(RepositoryDetectionStrategies.ALL);
			config.setDefaultMediaType(MediaType.parseMediaType('application/my-custom-json'));
			config.setMaxPageSize(78);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch;
/**
class ElasticsearchDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticsearchRestClientAutoConfiguration.class,
				ElasticsearchClientAutoConfiguration.class, ElasticsearchDataAutoConfiguration.class,
				ReactiveElasticsearchClientAutoConfiguration.class));
	@Test
	void defaultRestBeansRegistered() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ElasticsearchTemplate.class)
			.hasSingleBean(ReactiveElasticsearchTemplate.class)
			.hasSingleBean(ElasticsearchConverter.class)
			.hasSingleBean(ElasticsearchConverter.class)
			.hasSingleBean(ElasticsearchCustomConversions.class));
	}
	@Test
	void defaultConversionsRegisterBigDecimalAsSimpleType() {
		this.contextRunner.run((context) -> {
			SimpleElasticsearchMappingContext mappingContext = context.getBean(SimpleElasticsearchMappingContext.class);
			assertThat(mappingContext)
				.extracting('simpleTypeHolder', InstanceOfAssertFactories.type(SimpleTypeHolder.class))
				.satisfies((simpleTypeHolder) -> assertThat(simpleTypeHolder.isSimpleType(BigDecimal.class)).isTrue());
		});
	}
	@Test
	void customConversionsShouldBeUsed() {
		this.contextRunner.withUserConfiguration(CustomElasticsearchCustomConversions.class).run((context) -> {
			assertThat(context).hasSingleBean(ElasticsearchCustomConversions.class).hasBean('testCustomConversions');
			assertThat(context.getBean(ElasticsearchConverter.class)
				.getConversionService()
				.canConvert(ElasticsearchTemplate.class, Boolean.class)).isTrue();
		});
	}
	@Test
	void customRestTemplateShouldBeUsed() {
		this.contextRunner.withUserConfiguration(CustomRestTemplate.class)
			.run((context) -> assertThat(context).getBeanNames(ElasticsearchTemplate.class)
				.hasSize(1)
				.contains('elasticsearchTemplate'));
	}
	@Test
	void customReactiveRestTemplateShouldBeUsed() {
		this.contextRunner.withUserConfiguration(CustomReactiveElasticsearchTemplate.class)
			.run((context) -> assertThat(context).getBeanNames(ReactiveElasticsearchTemplate.class)
				.hasSize(1)
				.contains('reactiveElasticsearchTemplate'));
	}
	@Test
	void shouldFilterInitialEntityScanWithDocumentAnnotation() {
		this.contextRunner.withUserConfiguration(EntityScanConfig.class).run((context) -> {
			SimpleElasticsearchMappingContext mappingContext = context.getBean(SimpleElasticsearchMappingContext.class);
			assertThat(mappingContext.hasPersistentEntityFor(City.class)).isTrue();
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomElasticsearchCustomConversions {
		@Bean
		ElasticsearchCustomConversions testCustomConversions() {
			return new ElasticsearchCustomConversions(Collections.singletonList(new MyConverter()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRestTemplate {
		@Bean
		ElasticsearchTemplate elasticsearchTemplate() {
			return mock(ElasticsearchTemplate.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomReactiveElasticsearchTemplate {
		@Bean
		ReactiveElasticsearchTemplate reactiveElasticsearchTemplate() {
			return mock(ReactiveElasticsearchTemplate.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class EntityScanConfig {
	}
	static class MyConverter implements Converter<ElasticsearchTemplate, Boolean> {
		@Override
		public Boolean convert(ElasticsearchTemplate source) {
			return null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch.city;
@Document(indexName = 'city')
@Setting(shards = 1, replicas = 0, refreshInterval = '-1')
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	private Long id;
	private String name;
	private String state;
	private String country;
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch.city;
public interface ReactiveCityRepository extends ReactiveCrudRepository<City, String> {
}
/*
package org.springframework.boot.autoconfigure.data.elasticsearch.city;
public interface CityRepository extends Repository<City, Long> {
	Page<City> findAll(Pageable pageable);
	Page<City> findByNameLikeAndCountryLikeAllIgnoringCase(String name, String country, Pageable pageable);
	City findByNameAndCountryAllIgnoringCase(String name, String country);
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class RedisPropertiesTests {
	@Test
	void lettuceDefaultsAreConsistent() {
		Lettuce lettuce = new RedisProperties().getLettuce();
		ClusterTopologyRefreshOptions defaultClusterTopologyRefreshOptions = ClusterTopologyRefreshOptions.builder()
			.build();
		assertThat(lettuce.getCluster().getRefresh().isDynamicRefreshSources())
			.isEqualTo(defaultClusterTopologyRefreshOptions.useDynamicRefreshSources());
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@ClassPathExclusions('commons-pool2-*.jar')
class RedisAutoConfigurationLettuceWithoutCommonsPool2Tests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class));
	@Test
	void poolWithoutCommonsPool2IsDisabledByDefault() {
		this.contextRunner.withPropertyValues('spring.data.redis.host:foo').run((context) -> {
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.getHostName()).isEqualTo('foo');
			assertThat(cf.getClientConfiguration()).isNotInstanceOf(LettucePoolingClientConfiguration.class);
		});
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class RedisUrlSyntaxFailureAnalyzerTests {
	@Test
	void analyzeInvalidUrlSyntax() {
		RedisUrlSyntaxException exception = new RedisUrlSyntaxException('redis://invalid');
		FailureAnalysis analysis = new RedisUrlSyntaxFailureAnalyzer().analyze(exception);
		assertThat(analysis.getDescription()).contains('The URL "redis://invalid" is not valid');
		assertThat(analysis.getAction()).contains('Review the value of the property "spring.data.redis.url"');
	}
	@Test
	void analyzeRedisHttpUrl() {
		RedisUrlSyntaxException exception = new RedisUrlSyntaxException('http://127.0.0.1:26379/mymaster');
		FailureAnalysis analysis = new RedisUrlSyntaxFailureAnalyzer().analyze(exception);
		assertThat(analysis.getDescription()).contains('The URL "http://127.0.0.1:26379/mymaster" is not valid')
			.contains('The scheme "http" is not supported');
		assertThat(analysis.getAction()).contains('Use the scheme "redis://" for insecure or "rediss://" for secure');
	}
	@Test
	void analyzeRedisSentinelUrl() {
		RedisUrlSyntaxException exception = new RedisUrlSyntaxException(
				'redis-sentinel://username:password@127.0.0.1:26379,127.0.0.1:26380/mymaster');
		FailureAnalysis analysis = new RedisUrlSyntaxFailureAnalyzer().analyze(exception);
		assertThat(analysis.getDescription()).contains(
				'The URL "redis-sentinel://username:password@127.0.0.1:26379,127.0.0.1:26380/mymaster" is not valid')
			.contains('The scheme "redis-sentinel" is not supported');
		assertThat(analysis.getAction()).contains('Use spring.data.redis.sentinel properties');
	}
	@Test
	void analyzeRedisSocketUrl() {
		RedisUrlSyntaxException exception = new RedisUrlSyntaxException('redis-socket:///redis/redis.sock');
		FailureAnalysis analysis = new RedisUrlSyntaxFailureAnalyzer().analyze(exception);
		assertThat(analysis.getDescription()).contains('The URL "redis-socket:///redis/redis.sock" is not valid')
			.contains('The scheme "redis-socket" is not supported');
		assertThat(analysis.getAction()).contains('Configure the appropriate Spring Data Redis connection beans');
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class PropertiesRedisConnectionDetailsTests {
	private final RedisProperties properties = new RedisProperties();
	@Test
	void connectionIsConfiguredWithDefaults() {
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		RedisConnectionDetails.Standalone standalone = connectionDetails.getStandalone();
		assertThat(standalone.getHost()).isEqualTo('localhost');
		assertThat(standalone.getPort()).isEqualTo(6379);
		assertThat(standalone.getDatabase()).isEqualTo(0);
		assertThat(connectionDetails.getSentinel()).isNull();
		assertThat(connectionDetails.getCluster()).isNull();
		assertThat(connectionDetails.getUsername()).isNull();
		assertThat(connectionDetails.getPassword()).isNull();
	}
	@Test
	void credentialsAreConfiguredFromUrlWithUsernameAndPassword() {
		this.properties.setUrl('redis://user:secret@example.com');
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		assertThat(connectionDetails.getUsername()).isEqualTo('user');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
	}
	@Test
	void credentialsAreConfiguredFromUrlWithUsernameAndColon() {
		this.properties.setUrl('redis://user:@example.com');
		this.properties.setUsername('notused');
		this.properties.setPassword('notused');
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		assertThat(connectionDetails.getUsername()).isEqualTo('user');
		assertThat(connectionDetails.getPassword()).isEmpty();
	}
	@Test
	void credentialsAreConfiguredFromUrlWithColonAndPassword() {
		this.properties.setUrl('redis://:secret@example.com');
		this.properties.setUsername('notused');
		this.properties.setPassword('notused');
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		assertThat(connectionDetails.getUsername()).isEmpty();
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
	}
	@Test
	void credentialsAreConfiguredFromUrlWithPasswordOnly() {
		this.properties.setUrl('redis://secret@example.com');
		this.properties.setUsername('notused');
		this.properties.setPassword('notused');
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		assertThat(connectionDetails.getUsername()).isNull();
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
	}
	@Test
	void credentialsAreConfiguredFromProperties() {
		this.properties.setUsername('user');
		this.properties.setPassword('secret');
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		assertThat(connectionDetails.getUsername()).isEqualTo('user');
		assertThat(connectionDetails.getPassword()).isEqualTo('secret');
	}
	@Test
	void standaloneIsConfiguredFromUrl() {
		this.properties.setUrl('redis://example.com:1234/9999');
		this.properties.setHost('notused');
		this.properties.setPort(9999);
		this.properties.setDatabase(5);
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		RedisConnectionDetails.Standalone standalone = connectionDetails.getStandalone();
		assertThat(standalone.getHost()).isEqualTo('example.com');
		assertThat(standalone.getPort()).isEqualTo(1234);
		assertThat(standalone.getDatabase()).isEqualTo(5);
	}
	@Test
	void standaloneIsConfiguredFromProperties() {
		this.properties.setHost('example.com');
		this.properties.setPort(1234);
		this.properties.setDatabase(5);
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		RedisConnectionDetails.Standalone standalone = connectionDetails.getStandalone();
		assertThat(standalone.getHost()).isEqualTo('example.com');
