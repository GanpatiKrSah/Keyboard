		assertThat(standalone.getPort()).isEqualTo(1234);
		assertThat(standalone.getDatabase()).isEqualTo(5);
	}
	@Test
	void clusterIsConfigured() {
		RedisProperties.Cluster cluster = new RedisProperties.Cluster();
		cluster.setNodes(List.of('localhost:1111', '127.0.0.1:2222', '[::1]:3333'));
		this.properties.setCluster(cluster);
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		assertThat(connectionDetails.getCluster().getNodes()).containsExactly(new Node('localhost', 1111),
				new Node('127.0.0.1', 2222), new Node('[::1]', 3333));
	}
	@Test
	void sentinelIsConfigured() {
		RedisProperties.Sentinel sentinel = new RedisProperties.Sentinel();
		sentinel.setNodes(List.of('localhost:1111', '127.0.0.1:2222', '[::1]:3333'));
		this.properties.setSentinel(sentinel);
		PropertiesRedisConnectionDetails connectionDetails = new PropertiesRedisConnectionDetails(this.properties);
		assertThat(connectionDetails.getSentinel().getNodes()).containsExactly(new Node('localhost', 1111),
				new Node('127.0.0.1', 2222), new Node('[::1]', 3333));
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class RedisReactiveAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class, RedisReactiveAutoConfiguration.class));
	@Test
	void testDefaultRedisConfiguration() {
		this.contextRunner.run((context) -> {
			Map<String, ?> beans = context.getBeansOfType(ReactiveRedisTemplate.class);
			assertThat(beans).containsOnlyKeys('reactiveRedisTemplate', 'reactiveStringRedisTemplate');
		});
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
@ClassPathExclusions('lettuce-core-*.jar')
class RedisAutoConfigurationJedisTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void connectionFactoryDefaultsToJedis() {
		this.contextRunner.run((context) -> assertThat(context.getBean('redisConnectionFactory'))
			.isInstanceOf(JedisConnectionFactory.class));
	}
	@Test
	void connectionFactoryIsNotCreatedWhenLettuceIsSelected() {
		this.contextRunner.withPropertyValues('spring.data.redis.client-type=lettuce')
			.run((context) -> assertThat(context).doesNotHaveBean(RedisConnectionFactory.class));
	}
	@Test
	void testOverrideRedisConfiguration() {
		this.contextRunner.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.database:1')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getDatabase()).isOne();
				assertThat(getUserName(cf)).isNull();
				assertThat(cf.getPassword()).isNull();
				assertThat(cf.isUseSsl()).isFalse();
			});
	}
	@Test
	void testCustomizeRedisConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
			assertThat(cf.isUseSsl()).isTrue();
		});
	}
	@Test
	void usesConnectionDetailsIfAvailable() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsConfiguration.class).run((context) -> {
			JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
			assertThat(cf.isUseSsl()).isFalse();
		});
	}
	@Test
	void testRedisUrlConfiguration() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.url:redis://user:password@example:33')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('example');
				assertThat(cf.getPort()).isEqualTo(33);
				assertThat(getUserName(cf)).isEqualTo('user');
				assertThat(cf.getPassword()).isEqualTo('password');
				assertThat(cf.isUseSsl()).isFalse();
			});
	}
	@Test
	void testOverrideUrlRedisConfiguration() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.password:xyz',
					'spring.data.redis.port:1000', 'spring.data.redis.ssl.enabled:false',
					'spring.data.redis.url:rediss://user:password@example:33')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('example');
				assertThat(cf.getPort()).isEqualTo(33);
				assertThat(getUserName(cf)).isEqualTo('user');
				assertThat(cf.getPassword()).isEqualTo('password');
				assertThat(cf.isUseSsl()).isTrue();
			});
	}
	@Test
	void testPasswordInUrlWithColon() {
		this.contextRunner.withPropertyValues('spring.data.redis.url:redis://:pass:word@example:33').run((context) -> {
			JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
			assertThat(cf.getHostName()).isEqualTo('example');
			assertThat(cf.getPort()).isEqualTo(33);
			assertThat(getUserName(cf)).isEmpty();
			assertThat(cf.getPassword()).isEqualTo('pass:word');
		});
	}
	@Test
	void testPasswordInUrlStartsWithColon() {
		this.contextRunner.withPropertyValues('spring.data.redis.url:redis://user::pass:word@example:33')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('example');
				assertThat(cf.getPort()).isEqualTo(33);
				assertThat(getUserName(cf)).isEqualTo('user');
				assertThat(cf.getPassword()).isEqualTo(':pass:word');
			});
	}
	@Test
	void testRedisConfigurationWithPool() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.jedis.pool.min-idle:1',
					'spring.data.redis.jedis.pool.max-idle:4', 'spring.data.redis.jedis.pool.max-active:16',
					'spring.data.redis.jedis.pool.max-wait:2000',
					'spring.data.redis.jedis.pool.time-between-eviction-runs:30000')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getPoolConfig().getMinIdle()).isOne();
				assertThat(cf.getPoolConfig().getMaxIdle()).isEqualTo(4);
				assertThat(cf.getPoolConfig().getMaxTotal()).isEqualTo(16);
				assertThat(cf.getPoolConfig().getMaxWaitDuration()).isEqualTo(Duration.ofSeconds(2));
				assertThat(cf.getPoolConfig().getDurationBetweenEvictionRuns()).isEqualTo(Duration.ofSeconds(30));
			});
	}
	@Test
	void testRedisConfigurationDisabledPool() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.jedis.pool.enabled:false')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getClientConfiguration().isUsePooling()).isFalse();
			});
	}
	@Test
	void testRedisConfigurationWithTimeoutAndConnectTimeout() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.timeout:250',
					'spring.data.redis.connect-timeout:1000')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getTimeout()).isEqualTo(250);
				assertThat(cf.getClientConfiguration().getConnectTimeout().toMillis()).isEqualTo(1000);
			});
	}
	@Test
	void testRedisConfigurationWithDefaultTimeouts() {
		this.contextRunner.withPropertyValues('spring.data.redis.host:foo').run((context) -> {
			JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
			assertThat(cf.getHostName()).isEqualTo('foo');
			assertThat(cf.getTimeout()).isEqualTo(2000);
			assertThat(cf.getClientConfiguration().getConnectTimeout().toMillis()).isEqualTo(2000);
		});
	}
	@Test
	void testRedisConfigurationWithClientName() {
		this.contextRunner.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.client-name:spring-boot')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getClientName()).isEqualTo('spring-boot');
			});
	}
	@Test
	void testRedisConfigurationWithSentinel() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:127.0.0.1:26379,127.0.0.1:26380')
			.withUserConfiguration(JedisConnectionFactoryCaptorConfiguration.class)
			.run((context) -> assertThat(JedisConnectionFactoryCaptor.connectionFactory.isRedisSentinelAware())
				.isTrue());
	}
	@Test
	void testRedisConfigurationWithSentinelAndAuthentication() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.username=user', 'spring.data.redis.password=password',
					'spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:127.0.0.1:26379,127.0.0.1:26380')
			.withUserConfiguration(JedisConnectionFactoryCaptorConfiguration.class)
			.run((context) -> {
				assertThat(JedisConnectionFactoryCaptor.connectionFactory.isRedisSentinelAware()).isTrue();
				assertThat(getUserName(JedisConnectionFactoryCaptor.connectionFactory)).isEqualTo('user');
				assertThat(JedisConnectionFactoryCaptor.connectionFactory.getPassword()).isEqualTo('password');
			});
	}
	@Test
	void testRedisConfigurationWithCluster() {
		this.contextRunner.withPropertyValues('spring.data.redis.cluster.nodes=127.0.0.1:27379,127.0.0.1:27380')
			.withUserConfiguration(JedisConnectionFactoryCaptorConfiguration.class)
			.run((context) -> assertThat(JedisConnectionFactoryCaptor.connectionFactory.isRedisClusterAware())
				.isTrue());
	}
	@Test
	void testRedisConfigurationWithSslEnabled() {
		this.contextRunner.withPropertyValues('spring.data.redis.ssl.enabled:true').run((context) -> {
			JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
			assertThat(cf.isUseSsl()).isTrue();
		});
	}
	@Test
	void testRedisConfigurationWithSslBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.ssl.bundle:test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location:classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password:secret',
					'spring.ssl.bundle.jks.test-bundle.key.password:password')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.isUseSsl()).isTrue();
			});
	}
	@Test
	void testRedisConfigurationWithSslDisabledAndBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.ssl.enabled:false', 'spring.data.redis.ssl.bundle:test-bundle')
			.run((context) -> {
				JedisConnectionFactory cf = context.getBean(JedisConnectionFactory.class);
				assertThat(cf.isUseSsl()).isFalse();
			});
	}
	@Test
	void shouldUsePlatformThreadsByDefault() {
		this.contextRunner.run((context) -> {
			JedisConnectionFactory factory = context.getBean(JedisConnectionFactory.class);
			assertThat(factory).extracting('executor').isNull();
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldUseVirtualThreadsIfEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			JedisConnectionFactory factory = context.getBean(JedisConnectionFactory.class);
			assertThat(factory).extracting('executor')
				.satisfies((executor) -> SimpleAsyncTaskExecutorAssert.assertThat((SimpleAsyncTaskExecutor) executor)
					.usesVirtualThreads());
		});
	}
	private String getUserName(JedisConnectionFactory factory) {
		return ReflectionTestUtils.invokeMethod(factory, 'getRedisUsername');
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConfiguration {
		@Bean
		JedisClientConfigurationBuilderCustomizer customizer() {
			return JedisClientConfigurationBuilder::useSsl;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		RedisConnectionDetails redisConnectionDetails() {
			return new RedisConnectionDetails() {
				@Override
				public Standalone getStandalone() {
					return new Standalone() {
						@Override
						public String getHost() {
							return 'localhost';
						}
						@Override
						public int getPort() {
							return 6379;
						}
					};
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JedisConnectionFactoryCaptorConfiguration {
		@Bean
		static JedisConnectionFactoryCaptor jedisConnectionFactoryCaptor() {
			return new JedisConnectionFactoryCaptor();
		}
	}
	static class JedisConnectionFactoryCaptor implements BeanPostProcessor {
		static JedisConnectionFactory connectionFactory;
		@Override
		public Object postProcessBeforeInitialization(Object bean, String beanName) {
			if (bean instanceof JedisConnectionFactory jedisConnectionFactory) {
				connectionFactory = jedisConnectionFactory;
			}
			return bean;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis.city;
@RedisHash('cities')
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	private Long id;
	private String name;
	private String state;
	private String country;
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.data.redis.city;
public interface CityRepository extends Repository<City, Long> {
	Page<City> findAll(Pageable pageable);
	Page<City> findByNameLikeAndCountryLikeAllIgnoringCase(String name, String country, Pageable pageable);
	City findByNameAndCountryAllIgnoringCase(String name, String country);
}
/*
package org.springframework.boot.autoconfigure.data.redis;
/**
class RedisAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RedisAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void testDefaultRedisConfiguration() {
		this.contextRunner.run((context) -> {
			assertThat(context.getBean('redisTemplate')).isInstanceOf(RedisOperations.class);
			assertThat(context).hasSingleBean(StringRedisTemplate.class);
			assertThat(context).hasSingleBean(RedisConnectionFactory.class);
			assertThat(context.getBean(RedisConnectionFactory.class)).isInstanceOf(LettuceConnectionFactory.class);
		});
	}
	@Test
	void testOverrideRedisConfiguration() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.database:1',
					'spring.data.redis.lettuce.shutdown-timeout:500')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getDatabase()).isOne();
				assertThat(getUserName(cf)).isNull();
				assertThat(cf.getPassword()).isNull();
				assertThat(cf.isUseSsl()).isFalse();
				assertThat(cf.getShutdownTimeout()).isEqualTo(500);
			});
	}
	@Test
	void testCustomizeClientResources() {
		Tracing tracing = mock(Tracing.class);
		this.contextRunner.withBean(ClientResourcesBuilderCustomizer.class, () -> (builder) -> builder.tracing(tracing))
			.run((context) -> {
				DefaultClientResources clientResources = context.getBean(DefaultClientResources.class);
				assertThat(clientResources.tracing()).isEqualTo(tracing);
			});
	}
	@Test
	void testCustomizeRedisConfiguration() {
		this.contextRunner.withUserConfiguration(CustomConfiguration.class).run((context) -> {
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.isUseSsl()).isTrue();
			assertThat(cf.getClientConfiguration().getClientOptions())
				.hasValueSatisfying((options) -> assertThat(options.isAutoReconnect()).isFalse());
		});
	}
	@Test
	void testRedisUrlConfiguration() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.url:redis://user:password@example:33')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('example');
				assertThat(cf.getPort()).isEqualTo(33);
				assertThat(getUserName(cf)).isEqualTo('user');
				assertThat(cf.getPassword()).isEqualTo('password');
				assertThat(cf.isUseSsl()).isFalse();
			});
	}
	@Test
	void testOverrideUrlRedisConfiguration() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.redis.data.user:alice',
					'spring.data.redis.password:xyz', 'spring.data.redis.port:1000',
					'spring.data.redis.ssl.enabled:false', 'spring.data.redis.url:rediss://user:password@example:33')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('example');
				assertThat(cf.getPort()).isEqualTo(33);
				assertThat(getUserName(cf)).isEqualTo('user');
				assertThat(cf.getPassword()).isEqualTo('password');
				assertThat(cf.isUseSsl()).isTrue();
			});
	}
	@Test
	void testPasswordInUrlWithColon() {
		this.contextRunner.withPropertyValues('spring.data.redis.url:redis://:pass:word@example:33').run((context) -> {
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.getHostName()).isEqualTo('example');
			assertThat(cf.getPort()).isEqualTo(33);
			assertThat(getUserName(cf)).isEmpty();
			assertThat(cf.getPassword()).isEqualTo('pass:word');
		});
	}
	@Test
	void testPasswordInUrlStartsWithColon() {
		this.contextRunner.withPropertyValues('spring.data.redis.url:redis://user::pass:word@example:33')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('example');
				assertThat(cf.getPort()).isEqualTo(33);
				assertThat(getUserName(cf)).isEqualTo('user');
				assertThat(cf.getPassword()).isEqualTo(':pass:word');
			});
	}
	@Test
	void testRedisConfigurationUsePoolByDefault() {
		Pool defaultPool = new RedisProperties().getLettuce().getPool();
		this.contextRunner.withPropertyValues('spring.data.redis.host:foo').run((context) -> {
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.getHostName()).isEqualTo('foo');
			GenericObjectPoolConfig<?> poolConfig = getPoolingClientConfiguration(cf).getPoolConfig();
			assertThat(poolConfig.getMinIdle()).isEqualTo(defaultPool.getMinIdle());
			assertThat(poolConfig.getMaxIdle()).isEqualTo(defaultPool.getMaxIdle());
			assertThat(poolConfig.getMaxTotal()).isEqualTo(defaultPool.getMaxActive());
			assertThat(poolConfig.getMaxWaitDuration()).isEqualTo(defaultPool.getMaxWait());
		});
	}
	@Test
	void testRedisConfigurationWithCustomPoolSettings() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.lettuce.pool.min-idle:1',
					'spring.data.redis.lettuce.pool.max-idle:4', 'spring.data.redis.lettuce.pool.max-active:16',
					'spring.data.redis.lettuce.pool.max-wait:2000',
					'spring.data.redis.lettuce.pool.time-between-eviction-runs:30000',
					'spring.data.redis.lettuce.shutdown-timeout:1000')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				GenericObjectPoolConfig<?> poolConfig = getPoolingClientConfiguration(cf).getPoolConfig();
				assertThat(poolConfig.getMinIdle()).isOne();
				assertThat(poolConfig.getMaxIdle()).isEqualTo(4);
				assertThat(poolConfig.getMaxTotal()).isEqualTo(16);
				assertThat(poolConfig.getMaxWaitDuration()).isEqualTo(Duration.ofSeconds(2));
				assertThat(poolConfig.getDurationBetweenEvictionRuns()).isEqualTo(Duration.ofSeconds(30));
				assertThat(cf.getShutdownTimeout()).isEqualTo(1000);
			});
	}
	@Test
	void testRedisConfigurationDisabledPool() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.lettuce.pool.enabled:false')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getClientConfiguration()).isNotInstanceOf(LettucePoolingClientConfiguration.class);
			});
	}
	@Test
	void testRedisConfigurationWithTimeoutAndConnectTimeout() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.timeout:250',
					'spring.data.redis.connect-timeout:1000')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getTimeout()).isEqualTo(250);
				assertThat(cf.getClientConfiguration()
					.getClientOptions()
					.get()
					.getSocketOptions()
					.getConnectTimeout()
					.toMillis()).isEqualTo(1000);
			});
	}
	@Test
	void testRedisConfigurationWithDefaultTimeouts() {
		this.contextRunner.withPropertyValues('spring.data.redis.host:foo').run((context) -> {
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.getHostName()).isEqualTo('foo');
			assertThat(cf.getTimeout()).isEqualTo(60000);
			assertThat(cf.getClientConfiguration()
				.getClientOptions()
				.get()
				.getSocketOptions()
				.getConnectTimeout()
				.toMillis()).isEqualTo(10000);
		});
	}
	@Test
	void testRedisConfigurationWithCustomBean() {
		this.contextRunner.withUserConfiguration(RedisStandaloneConfig.class).run((context) -> {
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.getHostName()).isEqualTo('foo');
		});
	}
	@Test
	void testRedisConfigurationWithClientName() {
		this.contextRunner.withPropertyValues('spring.data.redis.host:foo', 'spring.data.redis.client-name:spring-boot')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.getHostName()).isEqualTo('foo');
				assertThat(cf.getClientName()).isEqualTo('spring-boot');
			});
	}
	@Test
	void connectionFactoryWithJedisClientType() {
		this.contextRunner.withPropertyValues('spring.data.redis.client-type:jedis').run((context) -> {
			assertThat(context).hasSingleBean(RedisConnectionFactory.class);
			assertThat(context.getBean(RedisConnectionFactory.class)).isInstanceOf(JedisConnectionFactory.class);
		});
	}
	@Test
	void connectionFactoryWithLettuceClientType() {
		this.contextRunner.withPropertyValues('spring.data.redis.client-type:lettuce').run((context) -> {
			assertThat(context).hasSingleBean(RedisConnectionFactory.class);
			assertThat(context.getBean(RedisConnectionFactory.class)).isInstanceOf(LettuceConnectionFactory.class);
		});
	}
	@Test
	void testRedisConfigurationWithSentinel() {
		List<String> sentinels = Arrays.asList('127.0.0.1:26379', '127.0.0.1:26380');
		this.contextRunner
			.withPropertyValues('spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:' + StringUtils.collectionToCommaDelimitedString(sentinels))
			.run((context) -> assertThat(context.getBean(LettuceConnectionFactory.class).isRedisSentinelAware())
				.isTrue());
	}
	@Test
	void testRedisConfigurationWithIpv6Sentinel() {
		List<String> sentinels = Arrays.asList('[0:0:0:0:0:0:0:1]:26379', '[0:0:0:0:0:0:0:1]:26380');
		this.contextRunner
			.withPropertyValues('spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:' + StringUtils.collectionToCommaDelimitedString(sentinels))
			.run((context) -> {
				LettuceConnectionFactory connectionFactory = context.getBean(LettuceConnectionFactory.class);
				assertThat(connectionFactory.isRedisSentinelAware()).isTrue();
				assertThat(connectionFactory.getSentinelConfiguration().getSentinels()).isNotNull()
					.containsExactlyInAnyOrder(new RedisNode('[0:0:0:0:0:0:0:1]', 26379),
							new RedisNode('[0:0:0:0:0:0:0:1]', 26380));
			});
	}
	@Test
	void testRedisConfigurationWithSentinelAndDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.database:1', 'spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:127.0.0.1:26379, 127.0.0.1:26380')
			.run((context) -> {
				LettuceConnectionFactory connectionFactory = context.getBean(LettuceConnectionFactory.class);
				assertThat(connectionFactory.getDatabase()).isOne();
				assertThat(connectionFactory.isRedisSentinelAware()).isTrue();
			});
	}
	@Test
	void testRedisConfigurationWithSentinelAndAuthentication() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.username=user', 'spring.data.redis.password=password',
					'spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:127.0.0.1:26379,  127.0.0.1:26380')
			.run(assertSentinelConfiguration('user', 'password', (sentinelConfiguration) -> {
				assertThat(sentinelConfiguration.getSentinelPassword().isPresent()).isFalse();
				Set<RedisNode> sentinels = sentinelConfiguration.getSentinels();
				assertThat(sentinels.stream().map(Object::toString).collect(Collectors.toSet()))
					.contains('127.0.0.1:26379', '127.0.0.1:26380');
			}));
	}
	@Test
	void testRedisConfigurationWithSentinelPasswordAndDataNodePassword() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.password=password', 'spring.data.redis.sentinel.password=secret',
					'spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:127.0.0.1:26379,  127.0.0.1:26380')
			.run(assertSentinelConfiguration(null, 'password', (sentinelConfiguration) -> {
				assertThat(sentinelConfiguration.getSentinelUsername()).isNull();
				assertThat(new String(sentinelConfiguration.getSentinelPassword().get())).isEqualTo('secret');
				Set<RedisNode> sentinels = sentinelConfiguration.getSentinels();
				assertThat(sentinels.stream().map(Object::toString).collect(Collectors.toSet()))
					.contains('127.0.0.1:26379', '127.0.0.1:26380');
			}));
	}
	@Test
	void testRedisConfigurationWithSentinelAuthenticationAndDataNodeAuthentication() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.username=username', 'spring.data.redis.password=password',
					'spring.data.redis.sentinel.username=sentinel', 'spring.data.redis.sentinel.password=secret',
					'spring.data.redis.sentinel.master:mymaster',
					'spring.data.redis.sentinel.nodes:127.0.0.1:26379,  127.0.0.1:26380')
			.run(assertSentinelConfiguration('username', 'password', (sentinelConfiguration) -> {
				assertThat(sentinelConfiguration.getSentinelUsername()).isEqualTo('sentinel');
				assertThat(new String(sentinelConfiguration.getSentinelPassword().get())).isEqualTo('secret');
				Set<RedisNode> sentinels = sentinelConfiguration.getSentinels();
				assertThat(sentinels.stream().map(Object::toString).collect(Collectors.toSet()))
					.contains('127.0.0.1:26379', '127.0.0.1:26380');
			}));
	}
	private ContextConsumer<AssertableApplicationContext> assertSentinelConfiguration(String userName, String password,
			Consumer<RedisSentinelConfiguration> sentinelConfiguration) {
		return (context) -> {
			LettuceConnectionFactory connectionFactory = context.getBean(LettuceConnectionFactory.class);
			assertThat(getUserName(connectionFactory)).isEqualTo(userName);
			assertThat(connectionFactory.getPassword()).isEqualTo(password);
			assertThat(connectionFactory.getSentinelConfiguration()).satisfies(sentinelConfiguration);
		};
	}
	@Test
	void testRedisSentinelUrlConfiguration() {
		this.contextRunner
			.withPropertyValues(
					'spring.data.redis.url=redis-sentinel://username:password@127.0.0.1:26379,127.0.0.1:26380/mymaster')
			.run((context) -> assertThatIllegalStateException()
				.isThrownBy(() -> context.getBean(LettuceConnectionFactory.class))
				.withRootCauseInstanceOf(RedisUrlSyntaxException.class)
				.havingRootCause()
				.withMessageContaining(
						'Invalid Redis URL "redis-sentinel://username:password@127.0.0.1:26379,127.0.0.1:26380/mymaster"'));
	}
	@Test
	void testRedisConfigurationWithCluster() {
		List<String> clusterNodes = Arrays.asList('127.0.0.1:27379', '127.0.0.1:27380', '[::1]:27381');
		this.contextRunner
			.withPropertyValues('spring.data.redis.cluster.nodes[0]:' + clusterNodes.get(0),
					'spring.data.redis.cluster.nodes[1]:' + clusterNodes.get(1),
					'spring.data.redis.cluster.nodes[2]:' + clusterNodes.get(2))
			.run((context) -> {
				RedisClusterConfiguration clusterConfiguration = context.getBean(LettuceConnectionFactory.class)
					.getClusterConfiguration();
				assertThat(clusterConfiguration.getClusterNodes()).hasSize(3);
				assertThat(clusterConfiguration.getClusterNodes()).containsExactlyInAnyOrder(
						new RedisNode('127.0.0.1', 27379), new RedisNode('127.0.0.1', 27380),
						new RedisNode('[::1]', 27381));
			});
	}
	@Test
	void testRedisConfigurationWithClusterAndAuthentication() {
		List<String> clusterNodes = Arrays.asList('127.0.0.1:27379', '127.0.0.1:27380');
		this.contextRunner
			.withPropertyValues('spring.data.redis.username=user', 'spring.data.redis.password=password',
					'spring.data.redis.cluster.nodes[0]:' + clusterNodes.get(0),
					'spring.data.redis.cluster.nodes[1]:' + clusterNodes.get(1))
			.run((context) -> {
				LettuceConnectionFactory connectionFactory = context.getBean(LettuceConnectionFactory.class);
				assertThat(getUserName(connectionFactory)).isEqualTo('user');
				assertThat(connectionFactory.getPassword()).isEqualTo('password');
			}
			);
	}
	@Test
	void testRedisConfigurationCreateClientOptionsByDefault() {
		this.contextRunner.run(assertClientOptions(ClientOptions.class, (options) -> {
			assertThat(options.getTimeoutOptions().isApplyConnectionTimeout()).isTrue();
			assertThat(options.getTimeoutOptions().isTimeoutCommands()).isTrue();
		}));
	}
	@Test
	void testRedisConfigurationWithClusterCreateClusterClientOptions() {
		this.contextRunner.withPropertyValues('spring.data.redis.cluster.nodes=127.0.0.1:27379,127.0.0.1:27380')
			.run(assertClientOptions(ClusterClientOptions.class, (options) -> {
				assertThat(options.getTimeoutOptions().isApplyConnectionTimeout()).isTrue();
				assertThat(options.getTimeoutOptions().isTimeoutCommands()).isTrue();
			}));
	}
	@Test
	void testRedisConfigurationWithClusterRefreshPeriod() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.cluster.nodes=127.0.0.1:27379,127.0.0.1:27380',
					'spring.data.redis.lettuce.cluster.refresh.period=30s')
			.run(assertClientOptions(ClusterClientOptions.class,
					(options) -> assertThat(options.getTopologyRefreshOptions().getRefreshPeriod()).hasSeconds(30)));
	}
	@Test
	void testRedisConfigurationWithClusterAdaptiveRefresh() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.cluster.nodes=127.0.0.1:27379,127.0.0.1:27380',
					'spring.data.redis.lettuce.cluster.refresh.adaptive=true')
			.run(assertClientOptions(ClusterClientOptions.class,
					(options) -> assertThat(options.getTopologyRefreshOptions().getAdaptiveRefreshTriggers())
						.isEqualTo(EnumSet.allOf(RefreshTrigger.class))));
	}
	@Test
	void testRedisConfigurationWithClusterRefreshPeriodHasNoEffectWithNonClusteredConfiguration() {
		this.contextRunner.withPropertyValues('spring.data.redis.cluster.refresh.period=30s')
			.run(assertClientOptions(ClientOptions.class,
					(options) -> assertThat(options.getClass()).isEqualTo(ClientOptions.class)));
	}
	@Test
	void testRedisConfigurationWithClusterDynamicRefreshSourcesEnabled() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.cluster.nodes=127.0.0.1:27379,127.0.0.1:27380',
					'spring.data.redis.lettuce.cluster.refresh.dynamic-refresh-sources=true')
			.run(assertClientOptions(ClusterClientOptions.class,
					(options) -> assertThat(options.getTopologyRefreshOptions().useDynamicRefreshSources()).isTrue()));
	}
	@Test
	void testRedisConfigurationWithClusterDynamicRefreshSourcesDisabled() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.cluster.nodes=127.0.0.1:27379,127.0.0.1:27380',
					'spring.data.redis.lettuce.cluster.refresh.dynamic-refresh-sources=false')
			.run(assertClientOptions(ClusterClientOptions.class,
					(options) -> assertThat(options.getTopologyRefreshOptions().useDynamicRefreshSources()).isFalse()));
	}
	@Test
	void testRedisConfigurationWithClusterDynamicSourcesUnspecifiedUsesDefault() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.cluster.nodes=127.0.0.1:27379,127.0.0.1:27380',
					'spring.data.redis.lettuce.cluster.refresh.dynamic-sources=')
			.run(assertClientOptions(ClusterClientOptions.class,
					(options) -> assertThat(options.getTopologyRefreshOptions().useDynamicRefreshSources()).isTrue()));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesRedisConnectionDetails.class));
	}
	@Test
	void usesStandaloneFromCustomConnectionDetails() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsStandaloneConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(RedisConnectionDetails.class)
				.doesNotHaveBean(PropertiesRedisConnectionDetails.class);
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.isUseSsl()).isFalse();
			RedisStandaloneConfiguration configuration = cf.getStandaloneConfiguration();
			assertThat(configuration.getHostName()).isEqualTo('redis.example.com');
			assertThat(configuration.getPort()).isEqualTo(16379);
			assertThat(configuration.getDatabase()).isOne();
			assertThat(configuration.getUsername()).isEqualTo('user-1');
			assertThat(configuration.getPassword()).isEqualTo(RedisPassword.of('password-1'));
		});
	}
	@Test
	void usesSentinelFromCustomConnectionDetails() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsSentinelConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(RedisConnectionDetails.class)
				.doesNotHaveBean(PropertiesRedisConnectionDetails.class);
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.isUseSsl()).isFalse();
			RedisSentinelConfiguration configuration = cf.getSentinelConfiguration();
			assertThat(configuration).isNotNull();
			assertThat(configuration.getSentinelUsername()).isEqualTo('sentinel-1');
			assertThat(configuration.getSentinelPassword().get()).isEqualTo('secret-1'.toCharArray());
			assertThat(configuration.getSentinels()).containsExactly(new RedisNode('node-1', 12345));
			assertThat(configuration.getUsername()).isEqualTo('user-1');
			assertThat(configuration.getPassword()).isEqualTo(RedisPassword.of('password-1'));
			assertThat(configuration.getDatabase()).isOne();
			assertThat(configuration.getMaster().getName()).isEqualTo('master.redis.example.com');
		});
	}
	@Test
	void usesClusterFromCustomConnectionDetails() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsClusterConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(RedisConnectionDetails.class)
				.doesNotHaveBean(PropertiesRedisConnectionDetails.class);
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.isUseSsl()).isFalse();
			RedisClusterConfiguration configuration = cf.getClusterConfiguration();
			assertThat(configuration).isNotNull();
			assertThat(configuration.getUsername()).isEqualTo('user-1');
			assertThat(configuration.getPassword().get()).isEqualTo('password-1'.toCharArray());
			assertThat(configuration.getClusterNodes()).containsExactly(new RedisNode('node-1', 12345),
					new RedisNode('node-2', 23456));
		});
	}
	@Test
	void testRedisConfigurationWithSslEnabled() {
		this.contextRunner.withPropertyValues('spring.data.redis.ssl.enabled:true').run((context) -> {
			LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
			assertThat(cf.isUseSsl()).isTrue();
		});
	}
	@Test
	void testRedisConfigurationWithSslBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.ssl.bundle:test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location:classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password:secret',
					'spring.ssl.bundle.jks.test-bundle.key.password:password')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.isUseSsl()).isTrue();
			});
	}
	@Test
	void testRedisConfigurationWithSslDisabledBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.redis.ssl.enabled:false', 'spring.data.redis.ssl.bundle:test-bundle')
			.run((context) -> {
				LettuceConnectionFactory cf = context.getBean(LettuceConnectionFactory.class);
				assertThat(cf.isUseSsl()).isFalse();
			});
	}
	@Test
	void shouldUsePlatformThreadsByDefault() {
		this.contextRunner.run((context) -> {
			LettuceConnectionFactory factory = context.getBean(LettuceConnectionFactory.class);
			assertThat(factory).extracting('executor').isNull();
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldUseVirtualThreadsIfEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			LettuceConnectionFactory factory = context.getBean(LettuceConnectionFactory.class);
			assertThat(factory).extracting('executor')
				.satisfies((executor) -> SimpleAsyncTaskExecutorAssert.assertThat((SimpleAsyncTaskExecutor) executor)
					.usesVirtualThreads());
		});
	}
	private <T extends ClientOptions> ContextConsumer<AssertableApplicationContext> assertClientOptions(
			Class<T> expectedType, Consumer<T> options) {
		return (context) -> {
			LettuceClientConfiguration clientConfiguration = context.getBean(LettuceConnectionFactory.class)
				.getClientConfiguration();
			assertThat(clientConfiguration.getClientOptions()).isPresent();
			ClientOptions clientOptions = clientConfiguration.getClientOptions().get();
			assertThat(clientOptions.getClass()).isEqualTo(expectedType);
			options.accept(expectedType.cast(clientOptions));
		};
	}
	private LettucePoolingClientConfiguration getPoolingClientConfiguration(LettuceConnectionFactory factory) {
		return (LettucePoolingClientConfiguration) factory.getClientConfiguration();
	}
	private String getUserName(LettuceConnectionFactory factory) {
		return ReflectionTestUtils.invokeMethod(factory, 'getRedisUsername');
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConfiguration {
		@Bean
		LettuceClientConfigurationBuilderCustomizer customizer() {
			return LettuceClientConfigurationBuilder::useSsl;
		}
		@Bean
		LettuceClientOptionsBuilderCustomizer clientOptionsBuilderCustomizer() {
			return (builder) -> builder.autoReconnect(false);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RedisStandaloneConfig {
		@Bean
		RedisStandaloneConfiguration standaloneConfiguration() {
			RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
			config.setHostName('foo');
			return config;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsStandaloneConfiguration {
		@Bean
		RedisConnectionDetails redisConnectionDetails() {
			return new RedisConnectionDetails() {
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'password-1';
				}
				@Override
				public Standalone getStandalone() {
					return new Standalone() {
						@Override
						public int getDatabase() {
							return 1;
						}
						@Override
						public String getHost() {
							return 'redis.example.com';
						}
						@Override
						public int getPort() {
							return 16379;
						}
					};
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsSentinelConfiguration {
		@Bean
		RedisConnectionDetails redisConnectionDetails() {
			return new RedisConnectionDetails() {
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'password-1';
				}
				@Override
				public Sentinel getSentinel() {
					return new Sentinel() {
						@Override
						public int getDatabase() {
							return 1;
						}
						@Override
						public String getMaster() {
							return 'master.redis.example.com';
						}
						@Override
						public List<Node> getNodes() {
							return List.of(new Node('node-1', 12345));
						}
						@Override
						public String getUsername() {
							return 'sentinel-1';
						}
						@Override
						public String getPassword() {
							return 'secret-1';
						}
					};
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsClusterConfiguration {
		@Bean
		RedisConnectionDetails redisConnectionDetails() {
			return new RedisConnectionDetails() {
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'password-1';
				}
				@Override
				public Cluster getCluster() {
					return new Cluster() {
						@Override
						public List<Node> getNodes() {
							return List.of(new Node('node-1', 12345), new Node('node-2', 23456));
						}
					};
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.r2dbc;
/**
class R2dbcDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class, R2dbcDataAutoConfiguration.class));
	@Test
	void r2dbcEntityTemplateIsConfigured() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(R2dbcEntityTemplate.class));
	}
	@Test
	void entityScanShouldSetManagedTypes() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			R2dbcMappingContext mappingContext = context.getBean(R2dbcMappingContext.class);
			ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
			assertThat(managedTypes.toList()).containsOnly(City.class);
		});
	}
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.r2dbc;
/**
class R2dbcRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(R2dbcRepositoriesAutoConfiguration.class));
	@Test
	void backsOffWithNoConnectionFactory() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(R2dbcRepositoryConfigurationExtension.class));
	}
	@Test
	void backsOffWithNoDatabaseClientOperations() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withClassLoader(new FilteredClassLoader('org.springframework.r2dbc'))
			.withUserConfiguration(TestConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(DatabaseClient.class);
				assertThat(context).doesNotHaveBean(R2dbcRepositoryConfigurationExtension.class);
			});
	}
	@Test
	void basicAutoConfiguration() {
		this.contextRunner
			.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class, R2dbcDataAutoConfiguration.class))
			.withUserConfiguration(DatabaseInitializationConfiguration.class, TestConfiguration.class)
			.withPropertyValues('spring.r2dbc.generate-unique-name:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(CityRepository.class);
				context.getBean(CityRepository.class)
					.findById(2000L)
					.as(StepVerifier::create)
					.expectNextCount(1)
					.expectComplete()
					.verify(Duration.ofSeconds(30));
			});
	}
	@Test
	void autoConfigurationWithNoRepositories() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(Repository.class));
	}
	@Test
	void honorsUsersEnableR2dbcRepositoriesConfiguration() {
		this.contextRunner
			.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class, R2dbcDataAutoConfiguration.class))
			.withUserConfiguration(DatabaseInitializationConfiguration.class, EnableRepositoriesConfiguration.class)
			.withPropertyValues('spring.r2dbc.generate-unique-name:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(CityRepository.class);
				context.getBean(CityRepository.class)
					.findById(2000L)
					.as(StepVerifier::create)
					.expectNextCount(1)
					.expectComplete()
					.verify(Duration.ofSeconds(30));
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class DatabaseInitializationConfiguration {
		@Autowired
		void initializeDatabase(ConnectionFactory connectionFactory) {
			ResourceLoader resourceLoader = new DefaultResourceLoader();
			Resource[] scripts = new Resource[] { resourceLoader.getResource('classpath:data-city-schema.sql'),
					resourceLoader.getResource('classpath:city.sql') };
			new ResourceDatabasePopulator(scripts).populate(connectionFactory).block();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableR2dbcRepositories(basePackageClasses = City.class)
	static class EnableRepositoriesConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.r2dbc.city;
@Table('CITY')
public class City {
	@Id
	private Long id;
	private String name;
	private String state;
	private String country;
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.data.r2dbc.city;
public interface CityRepository extends ReactiveCrudRepository<City, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.ldap;
/**
class LdapRepositoriesAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void testDefaultRepositoryConfiguration() {
		load(TestConfiguration.class);
		assertThat(this.context.getBean(PersonRepository.class)).isNotNull();
	}
	@Test
	void testNoRepositoryConfiguration() {
		load(EmptyConfiguration.class);
		assertThat(this.context.getBeanNamesForType(PersonRepository.class)).isEmpty();
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		load(CustomizedConfiguration.class);
		assertThat(this.context.getBean(PersonLdapRepository.class)).isNotNull();
	}
	private void load(Class<?>... configurationClasses) {
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.ldap.urls:ldap://localhost:389').applyTo(this.context);
		this.context.register(configurationClasses);
		this.context.register(LdapAutoConfiguration.class, LdapRepositoriesAutoConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		this.context.refresh();
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(Person.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(LdapRepositoriesAutoConfigurationTests.class)
	@EnableLdapRepositories(basePackageClasses = PersonLdapRepository.class)
	static class CustomizedConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.ldap.person;
@Entry(objectClasses = { 'person', 'top' }, base = 'ou=someOu')
public class Person {
	@Id
	private Name dn;
	@Attribute(name = 'cn')
	@DnAttribute(value = 'cn', index = 1)
	private String fullName;
}
/*
package org.springframework.boot.autoconfigure.data.ldap.person;
public interface PersonRepository extends Repository<Person, Name> {
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MongoReactiveRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
				MongoReactiveAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class,
				MongoReactiveRepositoriesAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class));
	@Test
	void testDefaultRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(ReactiveCityRepository.class);
			assertThat(context).hasSingleBean(MongoClient.class);
			MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
			ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
			assertThat(managedTypes.toList()).hasSize(1);
		});
	}
	@Test
	void testNoRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(MongoClient.class));
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.contextRunner.withUserConfiguration(CustomizedConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityMongoDbRepository.class));
	}
	@Test
	void autoConfigurationShouldNotKickInEvenIfManualConfigDidNotCreateAnyRepositories() {
		this.contextRunner.withUserConfiguration(SortOfInvalidCustomConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Test
	void enablingImperativeRepositoriesDisablesReactiveRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.data.mongodb.repositories.type=imperative')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Test
	void enablingNoRepositoriesDisablesReactiveRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.data.mongodb.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(ReactiveCityRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(MongoReactiveRepositoriesAutoConfigurationTests.class)
	@EnableMongoRepositories(basePackageClasses = CityMongoDbRepository.class)
	static class CustomizedConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	// To not find any repositories
	@EnableReactiveMongoRepositories('foo.bar')
	@TestAutoConfigurationPackage(MongoReactiveRepositoriesAutoConfigurationTests.class)
	static class SortOfInvalidCustomConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MongoReactiveAndBlockingRepositoriesAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		this.context.close();
	}
	@Test
	void shouldCreateInstancesForReactiveAndBlockingRepositories() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(BlockingAndReactiveConfiguration.class, BaseConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
		assertThat(this.context.getBean(ReactiveCityRepository.class)).isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(MongoAutoConfiguration.class)
	@EnableMongoRepositories(basePackageClasses = ReactiveCityRepository.class)
	@EnableReactiveMongoRepositories(basePackageClasses = ReactiveCityRepository.class)
	static class BlockingAndReactiveConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Registrar.class)
	static class BaseConfiguration {
	}
	static class Registrar implements ImportSelector {
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			List<String> names = new ArrayList<>();
			for (Class<?> type : new Class<?>[] { MongoAutoConfiguration.class, MongoReactiveAutoConfiguration.class,
					MongoDataAutoConfiguration.class, MongoRepositoriesAutoConfiguration.class,
					MongoReactiveDataAutoConfiguration.class, MongoReactiveRepositoriesAutoConfiguration.class }) {
				names.add(type.getName());
			}
			return StringUtils.toStringArray(names);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo.country;
public interface CountryRepository extends Repository<Country, Long> {
}
/*
package org.springframework.boot.autoconfigure.data.mongo.country;
@Document
public class Country implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	@Column(nullable = false)
	private String name;
	protected Country() {
	}
	public Country(String name) {
		this.name = name;
	}
	public String getName() {
		return this.name;
	}
	@Override
	public String toString() {
		return getName();
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MongoRepositoriesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
				MongoRepositoriesAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class));
	@Test
	void testDefaultRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(CityRepository.class);
			assertThat(context).hasSingleBean(MongoClient.class);
			MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
			ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
			assertThat(managedTypes.toList()).hasSize(1);
		});
	}
	@Test
	void testNoRepositoryConfiguration() {
		this.contextRunner.withUserConfiguration(EmptyConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(MongoClient.class));
	}
	@Test
	void doesNotTriggerDefaultRepositoryDetectionIfCustomized() {
		this.contextRunner.withUserConfiguration(CustomizedConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(CityMongoDbRepository.class));
	}
	@Test
	void autoConfigurationShouldNotKickInEvenIfManualConfigDidNotCreateAnyRepositories() {
		this.contextRunner.withUserConfiguration(SortOfInvalidCustomConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Test
	void enablingReactiveRepositoriesDisablesImperativeRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.data.mongodb.repositories.type=reactive')
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Test
	void enablingNoRepositoriesDisablesImperativeRepositories() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.data.mongodb.repositories.type=none')
			.run((context) -> assertThat(context).doesNotHaveBean(CityRepository.class));
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(EmptyDataPackage.class)
	static class EmptyConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(MongoRepositoriesAutoConfigurationTests.class)
	@EnableMongoRepositories(basePackageClasses = CityMongoDbRepository.class)
	static class CustomizedConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	// To not find any repositories
	@EnableMongoRepositories('foo.bar')
	@TestAutoConfigurationPackage(MongoRepositoriesAutoConfigurationTests.class)
	static class SortOfInvalidCustomConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MongoDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class,
				MongoAutoConfiguration.class, MongoDataAutoConfiguration.class));
	@Test
	void templateExists() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MongoTemplate.class));
	}
	@Test
	@SuppressWarnings('unchecked')
	void whenGridFsDatabaseIsConfiguredThenGridFsTemplateIsAutoConfiguredAndUsesIt() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.gridfs.database:grid').run((context) -> {
			assertThat(context).hasSingleBean(GridFsTemplate.class);
			GridFsTemplate template = context.getBean(GridFsTemplate.class);
			GridFSBucket bucket = ((Supplier<GridFSBucket>) ReflectionTestUtils.getField(template, 'bucketSupplier'))
				.get();
			assertThat(bucket).extracting('filesCollection', InstanceOfAssertFactories.type(MongoCollection.class))
				.extracting((collection) -> collection.getNamespace().getDatabaseName())
				.isEqualTo('grid');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void usesMongoConnectionDetailsIfAvailable() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(GridFsTemplate.class);
			GridFsTemplate template = context.getBean(GridFsTemplate.class);
			GridFSBucket bucket = ((Supplier<GridFSBucket>) ReflectionTestUtils.getField(template, 'bucketSupplier'))
				.get();
			assertThat(bucket.getBucketName()).isEqualTo('connection-details-bucket');
			assertThat(bucket).extracting('filesCollection', InstanceOfAssertFactories.type(MongoCollection.class))
				.extracting((collection) -> collection.getNamespace().getDatabaseName())
				.isEqualTo('grid-database-1');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void whenGridFsBucketIsConfiguredThenGridFsTemplateIsAutoConfiguredAndUsesIt() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.gridfs.bucket:test-bucket').run((context) -> {
			assertThat(context).hasSingleBean(GridFsTemplate.class);
			GridFsTemplate template = context.getBean(GridFsTemplate.class);
			GridFSBucket bucket = ((Supplier<GridFSBucket>) ReflectionTestUtils.getField(template, 'bucketSupplier'))
				.get();
			assertThat(bucket.getBucketName()).isEqualTo('test-bucket');
		});
	}
	@Test
	void customConversions() {
		this.contextRunner.withUserConfiguration(CustomConversionsConfig.class).run((context) -> {
			MongoTemplate template = context.getBean(MongoTemplate.class);
			assertThat(template.getConverter().getConversionService().canConvert(MongoClient.class, Boolean.class))
				.isTrue();
		});
	}
	@Test
	void usesAutoConfigurationPackageToPickUpDocumentTypes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		String cityPackage = City.class.getPackage().getName();
		AutoConfigurationPackages.register(context, cityPackage);
		context.register(MongoAutoConfiguration.class, MongoDataAutoConfiguration.class);
		try {
			context.refresh();
			assertDomainTypesDiscovered(context.getBean(MongoMappingContext.class), City.class);
		}
		finally {
			context.close();
		}
	}
	@Test
	void defaultFieldNamingStrategy() {
		this.contextRunner.run((context) -> {
			MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
			FieldNamingStrategy fieldNamingStrategy = (FieldNamingStrategy) ReflectionTestUtils.getField(mappingContext,
					'fieldNamingStrategy');
			assertThat(fieldNamingStrategy.getClass()).isEqualTo(PropertyNameFieldNamingStrategy.class);
		});
	}
	@Test
	void customFieldNamingStrategy() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.field-naming-strategy:'
					+ CamelCaseAbbreviatingFieldNamingStrategy.class.getName())
			.run((context) -> {
				MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
				FieldNamingStrategy fieldNamingStrategy = (FieldNamingStrategy) ReflectionTestUtils
					.getField(mappingContext, 'fieldNamingStrategy');
				assertThat(fieldNamingStrategy.getClass()).isEqualTo(CamelCaseAbbreviatingFieldNamingStrategy.class);
			});
	}
	@Test
	void defaultAutoIndexCreation() {
		this.contextRunner.run((context) -> {
			MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
			assertThat(mappingContext.isAutoIndexCreation()).isFalse();
		});
	}
	@Test
	void customAutoIndexCreation() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.autoIndexCreation:true').run((context) -> {
			MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
			assertThat(mappingContext.isAutoIndexCreation()).isTrue();
		});
	}
	@Test
	void interfaceFieldNamingStrategy() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.field-naming-strategy:' + FieldNamingStrategy.class.getName())
			.run((context) -> assertThat(context).getFailure().isInstanceOf(BeanCreationException.class));
	}
	@Test
	void entityScanShouldSetManagedTypes() {
		this.contextRunner.withUserConfiguration(EntityScanConfig.class).run((context) -> {
			MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
			ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
			assertThat(managedTypes.toList()).containsOnly(City.class, Country.class);
		});
	}
	@Test
	void registersDefaultSimpleTypesWithMappingContext() {
		this.contextRunner.run((context) -> {
			MongoMappingContext mappingContext = context.getBean(MongoMappingContext.class);
			MongoPersistentEntity<?> entity = mappingContext.getPersistentEntity(Sample.class);
			MongoPersistentProperty dateProperty = entity.getPersistentProperty('date');
			assertThat(dateProperty.isEntity()).isFalse();
		});
	}
	@Test
	void backsOffIfMongoClientBeanIsNotPresent() {
		ApplicationContextRunner runner = new ApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(MongoDataAutoConfiguration.class));
		runner.run((context) -> assertThat(context).doesNotHaveBean(MongoTemplate.class));
	}
	@Test
	void createsMongoDatabaseFactoryForPreferredMongoClient() {
		this.contextRunner.run((context) -> {
			MongoDatabaseFactory dbFactory = context.getBean(MongoDatabaseFactory.class);
			assertThat(dbFactory).isInstanceOf(SimpleMongoClientDatabaseFactory.class);
		});
	}
	@Test
	void createsMongoDatabaseFactoryForFallbackMongoClient() {
		this.contextRunner.withUserConfiguration(FallbackMongoClientConfiguration.class).run((context) -> {
			MongoDatabaseFactory dbFactory = context.getBean(MongoDatabaseFactory.class);
			assertThat(dbFactory).isInstanceOf(SimpleMongoClientDatabaseFactory.class);
		});
	}
	@Test
	void autoConfiguresIfUserProvidesMongoDatabaseFactoryButNoClient() {
		this.contextRunner.withUserConfiguration(MongoDatabaseFactoryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(MongoTemplate.class));
	}
	@Test
	void databaseHasDefault() {
		this.contextRunner.run((context) -> {
			MongoDatabaseFactory factory = context.getBean(MongoDatabaseFactory.class);
			assertThat(factory).isInstanceOf(SimpleMongoClientDatabaseFactory.class);
			assertThat(factory.getMongoDatabase().getName()).isEqualTo('test');
		});
	}
	@Test
	void databasePropertyIsUsed() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.database=mydb').run((context) -> {
			MongoDatabaseFactory factory = context.getBean(MongoDatabaseFactory.class);
			assertThat(factory).isInstanceOf(SimpleMongoClientDatabaseFactory.class);
			assertThat(factory.getMongoDatabase().getName()).isEqualTo('mydb');
		});
	}
	@Test
	void databaseInUriPropertyIsUsed() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/mydb')
			.run((context) -> {
				MongoDatabaseFactory factory = context.getBean(MongoDatabaseFactory.class);
				assertThat(factory).isInstanceOf(SimpleMongoClientDatabaseFactory.class);
				assertThat(factory.getMongoDatabase().getName()).isEqualTo('mydb');
			});
	}
	@Test
	void databasePropertyOverridesUriProperty() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/notused',
					'spring.data.mongodb.database=mydb')
			.run((context) -> {
				MongoDatabaseFactory factory = context.getBean(MongoDatabaseFactory.class);
				assertThat(factory).isInstanceOf(SimpleMongoClientDatabaseFactory.class);
				assertThat(factory.getMongoDatabase().getName()).isEqualTo('mydb');
			});
	}
	@Test
	void databasePropertyIsUsedWhenNoDatabaseInUri() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/',
					'spring.data.mongodb.database=mydb')
			.run((context) -> {
				MongoDatabaseFactory factory = context.getBean(MongoDatabaseFactory.class);
				assertThat(factory).isInstanceOf(SimpleMongoClientDatabaseFactory.class);
				assertThat(factory.getMongoDatabase().getName()).isEqualTo('mydb');
			});
	}
	@Test
	void contextFailsWhenDatabaseNotSet() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/')
			.run((context) -> assertThat(context).getFailure().hasMessageContaining('Database name must not be empty'));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesMongoConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(MongoConnectionDetails.class, () -> new MongoConnectionDetails() {
			@Override
			public ConnectionString getConnectionString() {
				return new ConnectionString('mongodb://localhost/testdb');
			}
		})
			.run((context) -> assertThat(context).hasSingleBean(MongoConnectionDetails.class)
				.doesNotHaveBean(PropertiesMongoConnectionDetails.class));
	}
	@Test
	void mappingMongoConverterHasADefaultDbRefResolver() {
		this.contextRunner.run((context) -> {
			MappingMongoConverter converter = context.getBean(MappingMongoConverter.class);
			assertThat(converter).extracting('dbRefResolver').isInstanceOf(DefaultDbRefResolver.class);
		});
	}
	private static void assertDomainTypesDiscovered(MongoMappingContext mappingContext, Class<?>... types) {
		ManagedTypes managedTypes = (ManagedTypes) ReflectionTestUtils.getField(mappingContext, 'managedTypes');
		assertThat(managedTypes.toList()).containsOnly(types);
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomConversionsConfig {
		@Bean
		MongoCustomConversions customConversions() {
			return new MongoCustomConversions(Arrays.asList(new MyConverter()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EntityScan('org.springframework.boot.autoconfigure.data.mongo')
	static class EntityScanConfig {
	}
	@Configuration(proxyBeanMethods = false)
	static class FallbackMongoClientConfiguration {
		@Bean
		com.mongodb.client.MongoClient fallbackMongoClient() {
			return MongoClients.create();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MongoDatabaseFactoryConfiguration {
		@Bean
		MongoDatabaseFactory mongoDatabaseFactory() {
			return new SimpleMongoClientDatabaseFactory(MongoClients.create(), 'test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		MongoConnectionDetails mongoConnectionDetails() {
			return new MongoConnectionDetails() {
				@Override
				public ConnectionString getConnectionString() {
					return new ConnectionString('mongodb://localhost/db');
				}
				@Override
				public GridFs getGridFs() {
					return GridFs.of('grid-database-1', 'connection-details-bucket');
				}
			};
		}
	}
	static class MyConverter implements Converter<MongoClient, Boolean> {
		@Override
		public Boolean convert(MongoClient source) {
			return null;
		}
	}
	static class Sample {
		LocalDateTime date;
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo.city;
@Persistent
public class PersistentEntity implements Serializable {
	private static final long serialVersionUID = 1L;
}
/*
package org.springframework.boot.autoconfigure.data.mongo.city;
@Document
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	@Column(nullable = false)
	private String name;
	@Column(nullable = false)
	private String state;
	@Column(nullable = false)
	private String country;
	@Column(nullable = false)
	private String map;
	protected City() {
	}
	public City(String name, String country) {
		this.name = name;
		this.country = country;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo.city;
public interface ReactiveCityRepository extends Repository<City, Long> {
	Flux<City> findAll();
}
/*
package org.springframework.boot.autoconfigure.data.mongo.city;
public interface CityRepository extends Repository<City, Long> {
	Page<City> findAll(Pageable pageable);
	Page<City> findByNameLikeAndCountryLikeAllIgnoringCase(String name, String country, Pageable pageable);
	City findByNameAndCountryAllIgnoringCase(String name, String country);
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MongoReactiveDataAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class,
				MongoReactiveAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class));
	@Test
	void templateExists() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ReactiveMongoTemplate.class));
	}
	@Test
	void whenNoGridFsDatabaseIsConfiguredTheGridFsTemplateUsesTheMainDatabase() {
		this.contextRunner.run((context) -> assertThat(grisFsTemplateDatabaseName(context)).isEqualTo('test'));
	}
	@Test
	void whenGridFsDatabaseIsConfiguredThenGridFsTemplateUsesIt() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.gridfs.database:grid')
			.run((context) -> assertThat(grisFsTemplateDatabaseName(context)).isEqualTo('grid'));
	}
	@Test
	@SuppressWarnings('unchecked')
	void usesMongoConnectionDetailsIfAvailable() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsConfiguration.class).run((context) -> {
			assertThat(grisFsTemplateDatabaseName(context)).isEqualTo('grid-database-1');
			ReactiveGridFsTemplate template = context.getBean(ReactiveGridFsTemplate.class);
			GridFSBucket bucket = ((Mono<GridFSBucket>) ReflectionTestUtils.getField(template, 'bucketSupplier'))
				.block(Duration.ofSeconds(30));
			assertThat(bucket.getBucketName()).isEqualTo('connection-details-bucket');
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void whenGridFsBucketIsConfiguredThenGridFsTemplateUsesIt() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.gridfs.bucket:test-bucket').run((context) -> {
			assertThat(context).hasSingleBean(ReactiveGridFsTemplate.class);
			ReactiveGridFsTemplate template = context.getBean(ReactiveGridFsTemplate.class);
			GridFSBucket bucket = ((Mono<GridFSBucket>) ReflectionTestUtils.getField(template, 'bucketSupplier'))
				.block(Duration.ofSeconds(30));
			assertThat(bucket.getBucketName()).isEqualTo('test-bucket');
		});
	}
	@Test
	void backsOffIfMongoClientBeanIsNotPresent() {
		ApplicationContextRunner runner = new ApplicationContextRunner().withConfiguration(AutoConfigurations
			.of(PropertyPlaceholderAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class));
		runner.run((context) -> assertThat(context).doesNotHaveBean(MongoReactiveDataAutoConfiguration.class));
	}
	@Test
	void databaseHasDefault() {
		this.contextRunner.run((context) -> {
			ReactiveMongoDatabaseFactory factory = context.getBean(ReactiveMongoDatabaseFactory.class);
			assertThat(factory).isInstanceOf(SimpleReactiveMongoDatabaseFactory.class);
			assertThat(factory.getMongoDatabase().block().getName()).isEqualTo('test');
		});
	}
	@Test
	void databasePropertyIsUsed() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.database=mydb').run((context) -> {
			ReactiveMongoDatabaseFactory factory = context.getBean(ReactiveMongoDatabaseFactory.class);
			assertThat(factory).isInstanceOf(SimpleReactiveMongoDatabaseFactory.class);
			assertThat(factory.getMongoDatabase().block().getName()).isEqualTo('mydb');
		});
	}
	@Test
	void databaseInUriPropertyIsUsed() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/mydb')
			.run((context) -> {
				ReactiveMongoDatabaseFactory factory = context.getBean(ReactiveMongoDatabaseFactory.class);
				assertThat(factory).isInstanceOf(SimpleReactiveMongoDatabaseFactory.class);
				assertThat(factory.getMongoDatabase().block().getName()).isEqualTo('mydb');
			});
	}
	@Test
	void databasePropertyOverridesUriProperty() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/notused',
					'spring.data.mongodb.database=mydb')
			.run((context) -> {
				ReactiveMongoDatabaseFactory factory = context.getBean(ReactiveMongoDatabaseFactory.class);
				assertThat(factory).isInstanceOf(SimpleReactiveMongoDatabaseFactory.class);
				assertThat(factory.getMongoDatabase().block().getName()).isEqualTo('mydb');
			});
	}
	@Test
	void databasePropertyIsUsedWhenNoDatabaseInUri() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/',
					'spring.data.mongodb.database=mydb')
			.run((context) -> {
				ReactiveMongoDatabaseFactory factory = context.getBean(ReactiveMongoDatabaseFactory.class);
				assertThat(factory).isInstanceOf(SimpleReactiveMongoDatabaseFactory.class);
				assertThat(factory.getMongoDatabase().block().getName()).isEqualTo('mydb');
			});
	}
	@Test
	void contextFailsWhenDatabaseNotSet() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://mongo.example.com/')
			.run((context) -> assertThat(context).getFailure().hasMessageContaining('Database name must not be empty'));
	}
	@Test
	void mappingMongoConverterHasANoOpDbRefResolver() {
		this.contextRunner.run((context) -> {
			MappingMongoConverter converter = context.getBean(MappingMongoConverter.class);
			assertThat(converter).extracting('dbRefResolver').isInstanceOf(NoOpDbRefResolver.class);
		});
	}
	@SuppressWarnings('unchecked')
	private String grisFsTemplateDatabaseName(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(ReactiveGridFsTemplate.class);
		ReactiveGridFsTemplate template = context.getBean(ReactiveGridFsTemplate.class);
		GridFSBucket bucket = ((Mono<GridFSBucket>) ReflectionTestUtils.getField(template, 'bucketSupplier'))
			.block(Duration.ofSeconds(30));
		MongoCollection<?> collection = (MongoCollection<?>) ReflectionTestUtils.getField(bucket, 'filesCollection');
		return collection.getNamespace().getDatabaseName();
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		MongoConnectionDetails mongoConnectionDetails() {
			return new MongoConnectionDetails() {
				@Override
				public ConnectionString getConnectionString() {
					return new ConnectionString('mongodb://localhost/db');
				}
				@Override
				public GridFs getGridFs() {
					return new GridFs() {
						@Override
						public String getDatabase() {
							return 'grid-database-1';
						}
						@Override
						public String getBucket() {
							return 'connection-details-bucket';
						}
					};
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.data.mongo;
/**
class MixedMongoRepositoriesAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		this.context.close();
	}
	@Test
	void testDefaultRepositoryConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(TestConfiguration.class, BaseConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CountryRepository.class)).isNotNull();
	}
	@Test
	void testMixedRepositoryConfiguration() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(MixedConfiguration.class, BaseConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CountryRepository.class)).isNotNull();
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Test
	void testJpaRepositoryConfigurationWithMongoTemplate() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(JpaConfiguration.class, BaseConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Test
	void testJpaRepositoryConfigurationWithMongoOverlap() {
		this.context = new AnnotationConfigApplicationContext();
		this.context.register(OverlapConfiguration.class, BaseConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Test
	void testJpaRepositoryConfigurationWithMongoOverlapDisabled() {
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.data.mongodb.repositories.type:none').applyTo(this.context);
		this.context.register(OverlapConfiguration.class, BaseConfiguration.class);
		this.context.refresh();
		assertThat(this.context.getBean(CityRepository.class)).isNotNull();
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(MongoAutoConfiguration.class)
	// Not this package or its parent
	@EnableMongoRepositories(basePackageClasses = Country.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(MongoAutoConfiguration.class)
	@EnableMongoRepositories(basePackageClasses = Country.class)
	@EntityScan(basePackageClasses = City.class)
	@EnableJpaRepositories(basePackageClasses = CityRepository.class)
	static class MixedConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(MongoAutoConfiguration.class)
	@EntityScan(basePackageClasses = City.class)
	@EnableJpaRepositories(basePackageClasses = CityRepository.class)
	static class JpaConfiguration {
	}
	// In this one the Jpa repositories and the auto-configuration packages overlap, so
	// Mongo will try and configure the same repositories
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(CityRepository.class)
	@EnableJpaRepositories(basePackageClasses = CityRepository.class)
	static class OverlapConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(Registrar.class)
	static class BaseConfiguration {
	}
	static class Registrar implements ImportSelector {
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			List<String> names = new ArrayList<>();
			for (Class<?> type : new Class<?>[] { DataSourceAutoConfiguration.class,
					HibernateJpaAutoConfiguration.class, JpaRepositoriesAutoConfiguration.class,
					MongoAutoConfiguration.class, MongoDataAutoConfiguration.class,
					MongoRepositoriesAutoConfiguration.class }) {
				names.add(type.getName());
			}
			return StringUtils.toStringArray(names);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.logging;
/**
@ExtendWith(OutputCaptureExtension.class)
class ConditionEvaluationReportLoggerTests {
	@Test
	void noErrorIfNotInitialized(CapturedOutput output) {
		new ConditionEvaluationReportLogger(LogLevel.INFO, () -> null).logReport(true);
		assertThat(output).contains('Unable to provide the condition evaluation report');
	}
	@Test
	void supportsOnlyInfoAndDebugLogLevels() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new ConditionEvaluationReportLogger(LogLevel.TRACE, () -> null))
			.withMessageContaining('LogLevel must be INFO or DEBUG');
	}
	@Test
	void loggerWithInfoLevelShouldLogAtInfo(CapturedOutput output) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			ConditionEvaluationReportLogger logger = new ConditionEvaluationReportLogger(LogLevel.INFO,
					() -> ConditionEvaluationReport.get(context.getBeanFactory()));
			context.register(Config.class);
			context.refresh();
			logger.logReport(false);
			assertThat(output).contains('CONDITIONS EVALUATION REPORT');
		}
	}
	@Test
	void loggerWithDebugLevelShouldLogAtDebug(CapturedOutput output) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			ConditionEvaluationReportLogger logger = new ConditionEvaluationReportLogger(LogLevel.DEBUG,
					() -> ConditionEvaluationReport.get(context.getBeanFactory()));
			context.register(Config.class);
			context.refresh();
			logger.logReport(false);
			assertThat(output).doesNotContain('CONDITIONS EVALUATION REPORT');
			withDebugLogging(() -> logger.logReport(false));
			assertThat(output).contains('CONDITIONS EVALUATION REPORT');
		}
	}
	@Test
	void logsInfoOnErrorIfDebugDisabled(CapturedOutput output) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			ConditionEvaluationReportLogger logger = new ConditionEvaluationReportLogger(LogLevel.DEBUG,
					() -> ConditionEvaluationReport.get(context.getBeanFactory()));
			context.register(Config.class);
			context.refresh();
			logger.logReport(true);
			assertThat(output).contains('Error starting ApplicationContext. To display the condition '
					+ 'evaluation report re-run your application with "debug" enabled.');
		}
	}
	@Test
	void logsOutput(CapturedOutput output) {
		try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext()) {
			ConditionEvaluationReportLogger logger = new ConditionEvaluationReportLogger(LogLevel.DEBUG,
					() -> ConditionEvaluationReport.get(context.getBeanFactory()));
			context.register(Config.class);
			ConditionEvaluationReport.get(context.getBeanFactory()).recordExclusions(Arrays.asList('com.foo.Bar'));
			context.refresh();
			withDebugLogging(() -> logger.logReport(false));
			assertThat(output).contains('not a servlet web application (OnWebApplicationCondition)');
		}
	}
	private void withDebugLogging(Runnable runnable) {
		Logger logger = ((LoggerContext) LoggerFactory.getILoggerFactory())
			.getLogger(ConditionEvaluationReportLogger.class);
		Level currentLevel = logger.getLevel();
		logger.setLevel(Level.DEBUG);
		try {
			runnable.run();
		}
		finally {
			logger.setLevel(currentLevel);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.logging;
/**
@ExtendWith(OutputCaptureExtension.class)
class ConditionEvaluationReportLoggingProcessorTests {
	@Test
	void logsDebugOnProcessAheadOfTime(CapturedOutput output) {
		DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
		ConditionEvaluationReport.get(beanFactory)
			.recordConditionEvaluation('test', mock(Condition.class), ConditionOutcome.match());
		ConditionEvaluationReportLoggingProcessor processor = new ConditionEvaluationReportLoggingProcessor();
		processor.processAheadOfTime(beanFactory);
		assertThat(output).doesNotContain('CONDITIONS EVALUATION REPORT');
		withDebugLogging(() -> processor.processAheadOfTime(beanFactory));
		assertThat(output).contains('CONDITIONS EVALUATION REPORT');
	}
	private void withDebugLogging(Runnable runnable) {
		Logger logger = ((LoggerContext) LoggerFactory.getILoggerFactory())
			.getLogger(ConditionEvaluationReportLogger.class);
		Level currentLevel = logger.getLevel();
		logger.setLevel(Level.DEBUG);
		try {
			runnable.run();
		}
		finally {
			logger.setLevel(currentLevel);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.logging;
/**
@ExtendWith(OutputCaptureExtension.class)
class ConditionEvaluationReportLoggingListenerTests {
	private final ConditionEvaluationReportLoggingListener initializer = new ConditionEvaluationReportLoggingListener();
	@Test
	void logsDebugOnContextRefresh(CapturedOutput output) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(Config.class);
		withDebugLogging(context::refresh);
		assertThat(output).contains('CONDITIONS EVALUATION REPORT');
	}
	@Test
	void logsDebugOnApplicationFailedEvent(CapturedOutput output) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(ErrorConfig.class);
		assertThatException().isThrownBy(context::refresh)
			.satisfies((ex) -> withDebugLogging(() -> context
				.publishEvent(new ApplicationFailedEvent(new SpringApplication(), new String[0], context, ex))));
		assertThat(output).contains('CONDITIONS EVALUATION REPORT');
	}
	@Test
	void logsInfoGuidanceToEnableDebugLoggingOnApplicationFailedEvent(CapturedOutput output) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		this.initializer.initialize(context);
		context.register(ErrorConfig.class);
		assertThatException().isThrownBy(context::refresh)
			.satisfies((ex) -> withInfoLogging(() -> context
				.publishEvent(new ApplicationFailedEvent(new SpringApplication(), new String[0], context, ex))));
		assertThat(output).doesNotContain('CONDITIONS EVALUATION REPORT')
			.contains('re-run your application with "debug" enabled');
	}
	@Test
	void canBeUsedInApplicationContext() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(Config.class);
		new ConditionEvaluationReportLoggingListener().initialize(context);
		context.refresh();
		assertThat(context.getBean(ConditionEvaluationReport.class)).isNotNull();
	}
	@Test
	void canBeUsedInNonGenericApplicationContext() {
		AnnotationConfigServletWebApplicationContext context = new AnnotationConfigServletWebApplicationContext();
		context.setServletContext(new MockServletContext());
		context.register(Config.class);
		new ConditionEvaluationReportLoggingListener().initialize(context);
		context.refresh();
		assertThat(context.getBean(ConditionEvaluationReport.class)).isNotNull();
	}
	private void withDebugLogging(Runnable runnable) {
		withLoggingLevel(Level.DEBUG, runnable);
	}
	private void withInfoLogging(Runnable runnable) {
		withLoggingLevel(Level.INFO, runnable);
	}
	private void withLoggingLevel(Level logLevel, Runnable runnable) {
		Logger logger = ((LoggerContext) LoggerFactory.getILoggerFactory())
			.getLogger(ConditionEvaluationReportLogger.class);
		Level currentLevel = logger.getLevel();
		logger.setLevel(logLevel);
		try {
			runnable.run();
		}
		finally {
			logger.setLevel(currentLevel);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(WebMvcAutoConfiguration.class)
	static class ErrorConfig {
		@Bean
		String iBreak() {
			throw new RuntimeException();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.gson;
/**
class GsonAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(GsonAutoConfiguration.class));
	@Test
	void gsonRegistration() {
		this.contextRunner.run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.toJson(new DataObject())).isEqualTo('{\'data\':1}');
		});
	}
	@Test
	void generateNonExecutableJsonTrue() {
		this.contextRunner.withPropertyValues('spring.gson.generate-non-executable-json:true').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.toJson(new DataObject())).isNotEqualTo('{\'data\':1}');
			assertThat(gson.toJson(new DataObject())).endsWith('{\'data\':1}');
		});
	}
	@Test
	void generateNonExecutableJsonFalse() {
		this.contextRunner.withPropertyValues('spring.gson.generate-non-executable-json:false').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.toJson(new DataObject())).isEqualTo('{\'data\':1}');
		});
	}
	@Test
	void excludeFieldsWithoutExposeAnnotationTrue() {
		this.contextRunner.withPropertyValues('spring.gson.exclude-fields-without-expose-annotation:true')
			.run((context) -> {
				Gson gson = context.getBean(Gson.class);
				assertThat(gson.toJson(new DataObject())).isEqualTo('{}');
			});
	}
	@Test
	void excludeFieldsWithoutExposeAnnotationFalse() {
		this.contextRunner.withPropertyValues('spring.gson.exclude-fields-without-expose-annotation:false')
			.run((context) -> {
				Gson gson = context.getBean(Gson.class);
				assertThat(gson.toJson(new DataObject())).isEqualTo('{\'data\':1}');
			});
	}
	@Test
	void serializeNullsTrue() {
		this.contextRunner.withPropertyValues('spring.gson.serialize-nulls:true').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.serializeNulls()).isTrue();
		});
	}
	@Test
	void serializeNullsFalse() {
		this.contextRunner.withPropertyValues('spring.gson.serialize-nulls:false').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.serializeNulls()).isFalse();
		});
	}
	@Test
	void enableComplexMapKeySerializationTrue() {
		this.contextRunner.withPropertyValues('spring.gson.enable-complex-map-key-serialization:true')
			.run((context) -> {
				Gson gson = context.getBean(Gson.class);
				Map<DataObject, String> original = new LinkedHashMap<>();
				original.put(new DataObject(), 'a');
				assertThat(gson.toJson(original)).isEqualTo('[[{\'data\':1},\'a\']]');
			});
	}
	@Test
	void enableComplexMapKeySerializationFalse() {
		this.contextRunner.withPropertyValues('spring.gson.enable-complex-map-key-serialization:false')
			.run((context) -> {
				Gson gson = context.getBean(Gson.class);
				Map<DataObject, String> original = new LinkedHashMap<>();
				original.put(new DataObject(), 'a');
				assertThat(gson.toJson(original)).contains(DataObject.class.getName()).doesNotContain('\'data\':');
			});
	}
	@Test
	void notDisableInnerClassSerialization() {
		this.contextRunner.run((context) -> {
			Gson gson = context.getBean(Gson.class);
			WrapperObject wrapperObject = new WrapperObject();
			assertThat(gson.toJson(wrapperObject.new NestedObject())).isEqualTo('{\'data\':\'nested\'}');
		});
	}
	@Test
	void disableInnerClassSerializationTrue() {
		this.contextRunner.withPropertyValues('spring.gson.disable-inner-class-serialization:true').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			WrapperObject wrapperObject = new WrapperObject();
			assertThat(gson.toJson(wrapperObject.new NestedObject())).isEqualTo('null');
		});
	}
	@Test
	void disableInnerClassSerializationFalse() {
		this.contextRunner.withPropertyValues('spring.gson.disable-inner-class-serialization:false').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			WrapperObject wrapperObject = new WrapperObject();
			assertThat(gson.toJson(wrapperObject.new NestedObject())).isEqualTo('{\'data\':\'nested\'}');
		});
	}
	@Test
	void withLongSerializationPolicy() {
		this.contextRunner.withPropertyValues('spring.gson.long-serialization-policy:' + LongSerializationPolicy.STRING)
			.run((context) -> {
				Gson gson = context.getBean(Gson.class);
				assertThat(gson.toJson(new DataObject())).isEqualTo('{\'data\':\'1\'}');
			});
	}
	@Test
	void withFieldNamingPolicy() {
		FieldNamingPolicy fieldNamingPolicy = FieldNamingPolicy.UPPER_CAMEL_CASE;
		this.contextRunner.withPropertyValues('spring.gson.field-naming-policy:' + fieldNamingPolicy).run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.fieldNamingStrategy()).isEqualTo(fieldNamingPolicy);
		});
	}
	@Test
	void additionalGsonBuilderCustomization() {
		this.contextRunner.withUserConfiguration(GsonBuilderCustomizerConfig.class).run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.toJson(new DataObject())).isEqualTo('{}');
		});
	}
	@Test
	void customGsonBuilder() {
		this.contextRunner.withUserConfiguration(GsonBuilderConfig.class).run((context) -> {
			Gson gson = context.getBean(Gson.class);
			JSONAssert.assertEquals('{\'data\':1,\'owner\':null}', gson.toJson(new DataObject()), true);
		});
	}
	@Test
	void withPrettyPrintingTrue() {
		this.contextRunner.withPropertyValues('spring.gson.pretty-printing:true').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.toJson(new DataObject())).isEqualTo('{\n  \'data\': 1\n}');
		});
	}
	@Test
	void withPrettyPrintingFalse() {
		this.contextRunner.withPropertyValues('spring.gson.pretty-printing:false').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.toJson(new DataObject())).isEqualTo('{\'data\':1}');
		});
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void withoutLenient() {
		this.contextRunner.run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson).hasFieldOrPropertyWithValue('strictness', null);
		});
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void withLenientTrue() {
		this.contextRunner.withPropertyValues('spring.gson.lenient:true').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson).hasFieldOrPropertyWithValue('strictness', Strictness.LENIENT);
		});
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void withLenientFalse() {
		this.contextRunner.withPropertyValues('spring.gson.lenient:false').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson).hasFieldOrPropertyWithValue('strictness', Strictness.STRICT);
		});
	}
	@Test
	void withoutStrictness() {
		this.contextRunner.run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson).hasFieldOrPropertyWithValue('strictness', null);
		});
	}
	@Test
	void withStrictnessStrict() {
		this.contextRunner.withPropertyValues('spring.gson.strictness:strict').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson).hasFieldOrPropertyWithValue('strictness', Strictness.STRICT);
		});
	}
	@Test
	void withStrictnessLegacyStrict() {
		this.contextRunner.withPropertyValues('spring.gson.strictness:legacy-strict').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson).hasFieldOrPropertyWithValue('strictness', Strictness.LEGACY_STRICT);
		});
	}
	@Test
	void withStrictnessLenient() {
		this.contextRunner.withPropertyValues('spring.gson.strictness:lenient').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson).hasFieldOrPropertyWithValue('strictness', Strictness.LENIENT);
		});
	}
	@Test
	void withoutDisableHtmlEscaping() {
		this.contextRunner.run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.htmlSafe()).isTrue();
		});
	}
	@Test
	void withDisableHtmlEscapingTrue() {
		this.contextRunner.withPropertyValues('spring.gson.disable-html-escaping:true').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.htmlSafe()).isFalse();
		});
	}
	@Test
	void withDisableHtmlEscapingFalse() {
		this.contextRunner.withPropertyValues('spring.gson.disable-html-escaping:false').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			assertThat(gson.htmlSafe()).isTrue();
		});
	}
	@Test
	void customDateFormat() {
		this.contextRunner.withPropertyValues('spring.gson.date-format:H').run((context) -> {
			Gson gson = context.getBean(Gson.class);
			ZonedDateTime dateTime = ZonedDateTime.of(1988, 6, 25, 20, 30, 0, 0, ZoneId.systemDefault());
			assertThat(gson.toJson(Date.from(dateTime.toInstant()))).isEqualTo('\'20\'');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class GsonBuilderCustomizerConfig {
		@Bean
		GsonBuilderCustomizer customSerializationExclusionStrategy() {
			return (gsonBuilder) -> gsonBuilder.addSerializationExclusionStrategy(new ExclusionStrategy() {
				@Override
				public boolean shouldSkipField(FieldAttributes fieldAttributes) {
					return 'data'.equals(fieldAttributes.getName());
				}
				@Override
				public boolean shouldSkipClass(Class<?> aClass) {
					return false;
				}
			});
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class GsonBuilderConfig {
		@Bean
		GsonBuilder customGsonBuilder() {
			return new GsonBuilder().serializeNulls();
		}
	}
	public class DataObject {
		@SuppressWarnings('unused')
		private Long data = 1L;
		@SuppressWarnings('unused')
		private final String owner = null;
		public void setData(Long data) {
			this.data = data;
		}
	}
	public class WrapperObject {
		@SuppressWarnings('unused')
		class NestedObject {
			private final String data = 'nested';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
class HazelcastClientConfigAvailableConditionTests {
	private final HazelcastClientConfigAvailableCondition condition = new HazelcastClientConfigAvailableCondition();
	@Test
	void explicitConfigurationWithClientConfigMatches() {
		ConditionOutcome outcome = getMatchOutcome(new MockEnvironment().withProperty('spring.hazelcast.config',
				'classpath:org/springframework/boot/autoconfigure/hazelcast/hazelcast-client-specific.xml'));
		assertThat(outcome.isMatch()).isTrue();
		assertThat(outcome.getMessage()).contains('Hazelcast client configuration detected');
	}
	@Test
	void explicitConfigurationWithServerConfigDoesNotMatch() {
		ConditionOutcome outcome = getMatchOutcome(new MockEnvironment().withProperty('spring.hazelcast.config',
				'classpath:org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.xml'));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage()).contains('Hazelcast server configuration detected');
	}
	@Test
	void explicitConfigurationWithMissingConfigDoesNotMatch() {
		ConditionOutcome outcome = getMatchOutcome(new MockEnvironment().withProperty('spring.hazelcast.config',
				'classpath:org/springframework/boot/autoconfigure/hazelcast/test-config-does-not-exist.xml'));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage()).contains('Hazelcast configuration does not exist');
	}
	private ConditionOutcome getMatchOutcome(Environment environment) {
		ConditionContext conditionContext = mock(ConditionContext.class);
		given(conditionContext.getEnvironment()).willReturn(environment);
		given(conditionContext.getResourceLoader()).willReturn(new DefaultResourceLoader());
		return this.condition.getMatchOutcome(conditionContext, mock(AnnotatedTypeMetadata.class));
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
class HazelcastAutoConfigurationClientTests {
	/**
	 * Servers the test clients will connect to.
	 */
	private static HazelcastInstance hazelcastServer;
	private static String endpointAddress;
	@BeforeAll
	static void init() {
		Config config = Config.load();
		NetworkConfig networkConfig = config.getNetworkConfig();
		networkConfig.setPort(0);
		networkConfig.setPublicAddress('localhost');
		hazelcastServer = Hazelcast.newHazelcastInstance(config);
		InetSocketAddress inetSocketAddress = (InetSocketAddress) hazelcastServer.getLocalEndpoint().getSocketAddress();
		endpointAddress = inetSocketAddress.getHostString() + ':' + inetSocketAddress.getPort();
	}
	@AfterAll
	static void close() {
		if (hazelcastServer != null) {
			hazelcastServer.shutdown();
		}
	}
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class));
	@Test
	void systemPropertyWithXml() {
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-specific.xml');
		this.contextRunner
			.withSystemProperties(HazelcastClientConfiguration.CONFIG_SYSTEM_PROPERTY + '=' + config.getAbsolutePath())
			.run(assertSpecificHazelcastClient('explicit-xml'));
	}
	@Test
	void systemPropertyWithYaml() {
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-specific.yaml');
		this.contextRunner
			.withSystemProperties(HazelcastClientConfiguration.CONFIG_SYSTEM_PROPERTY + '=' + config.getAbsolutePath())
			.run(assertSpecificHazelcastClient('explicit-yaml'));
	}
	@Test
	void systemPropertyWithYml() {
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-specific.yml');
		this.contextRunner
			.withSystemProperties(HazelcastClientConfiguration.CONFIG_SYSTEM_PROPERTY + '=' + config.getAbsolutePath())
			.run(assertSpecificHazelcastClient('explicit-yml'));
	}
	@Test
	void explicitConfigUrlWithXml() throws MalformedURLException {
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-specific.xml');
		this.contextRunner.withPropertyValues('spring.hazelcast.config=' + config.toURI().toURL())
			.run(assertSpecificHazelcastClient('explicit-xml'));
	}
	@Test
	void explicitConfigUrlWithYaml() throws MalformedURLException {
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-specific.yaml');
		this.contextRunner.withPropertyValues('spring.hazelcast.config=' + config.toURI().toURL())
			.run(assertSpecificHazelcastClient('explicit-yaml'));
	}
	@Test
	void explicitConfigUrlWithYml() throws MalformedURLException {
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-specific.yml');
		this.contextRunner.withPropertyValues('spring.hazelcast.config=' + config.toURI().toURL())
			.run(assertSpecificHazelcastClient('explicit-yml'));
	}
	@Test
	void unknownConfigFile() {
		this.contextRunner.withPropertyValues('spring.hazelcast.config=foo/bar/unknown.xml')
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('foo/bar/unknown.xml'));
	}
	@Test
	void clientConfigTakesPrecedence() {
		this.contextRunner.withUserConfiguration(HazelcastServerAndClientConfig.class)
			.withPropertyValues('spring.hazelcast.config=this-is-ignored.xml')
			.run((context) -> assertThat(context).getBean(HazelcastInstance.class)
				.isInstanceOf(HazelcastClientProxy.class));
	}
	@Test
	void connectionDetailsTakesPrecedenceOverConfigFile() {
		this.contextRunner.withUserConfiguration(HazelcastConnectionDetailsConfig.class)
			.withPropertyValues('spring.hazelcast.config=this-is-ignored.xml')
			.run(assertSpecificHazelcastClient('connection-details'));
	}
	@Test
	void connectionDetailsTakesPrecedenceOverUserDefinedClientConfig() {
		this.contextRunner
			.withUserConfiguration(HazelcastConnectionDetailsConfig.class, HazelcastServerAndClientConfig.class)
			.withPropertyValues('spring.hazelcast.config=this-is-ignored.xml')
			.run(assertSpecificHazelcastClient('connection-details'));
	}
	@Test
	void clientConfigWithInstanceNameCreatesClientIfNecessary() throws MalformedURLException {
		assertThat(HazelcastClient.getHazelcastClientByName('spring-boot')).isNull();
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-instance.xml');
		this.contextRunner.withPropertyValues('spring.hazelcast.config=' + config.toURI().toURL())
			.run((context) -> assertThat(context).getBean(HazelcastInstance.class)
				.extracting(HazelcastInstance::getName)
				.isEqualTo('spring-boot'));
	}
	@Test
	void autoConfiguredClientConfigUsesApplicationClassLoader() throws MalformedURLException {
		File config = prepareConfiguration('src/test/resources/org/springframework/'
				+ 'boot/autoconfigure/hazelcast/hazelcast-client-specific.xml');
		this.contextRunner.withPropertyValues('spring.hazelcast.config=' + config.toURI().toURL()).run((context) -> {
			HazelcastInstance hazelcast = context.getBean(HazelcastInstance.class);
			assertThat(hazelcast).isInstanceOf(HazelcastClientProxy.class);
			ClientConfig clientConfig = ((HazelcastClientProxy) hazelcast).getClientConfig();
			assertThat(clientConfig.getClassLoader()).isSameAs(context.getSourceApplicationContext().getClassLoader());
		});
	}
	private ContextConsumer<AssertableApplicationContext> assertSpecificHazelcastClient(String label) {
		return (context) -> assertThat(context).getBean(HazelcastInstance.class)
			.isInstanceOf(HazelcastInstance.class)
			.has(labelEqualTo(label));
	}
	private static Condition<HazelcastInstance> labelEqualTo(String label) {
		return new Condition<>((o) -> ((HazelcastClientProxy) o).getClientConfig()
			.getLabels()
			.stream()
			.anyMatch((e) -> e.equals(label)), 'Label equals to ' + label);
	}
	private File prepareConfiguration(String input) {
		File configFile = new File(input);
		try {
			String config = FileCopyUtils.copyToString(new FileReader(configFile));
			config = config.replace('${address}', endpointAddress);
			System.out.println(config);
			File outputFile = new File(Files.createTempDirectory(getClass().getSimpleName()).toFile(),
					configFile.getName());
			FileCopyUtils.copy(config, new FileWriter(outputFile));
			return outputFile;
		}
		catch (IOException ex) {
			throw new RuntimeException(ex);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastConnectionDetailsConfig {
		@Bean
		HazelcastConnectionDetails hazelcastConnectionDetails() {
			ClientConfig config = new ClientConfig();
			config.setLabels(Set.of('connection-details'));
			config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(60000);
			config.getNetworkConfig().getAddresses().add(endpointAddress);
			return () -> config;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastServerAndClientConfig {
		@Bean
		Config config() {
			return new Config();
		}
		@Bean
		ClientConfig clientConfig() {
			ClientConfig config = new ClientConfig();
			config.getConnectionStrategyConfig().getConnectionRetryConfig().setClusterConnectTimeoutMillis(60000);
			config.getNetworkConfig().getAddresses().add(endpointAddress);
			return config;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
@ClassPathExclusions('hazelcast-client-*.jar')
class HazelcastAutoConfigurationServerTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class));
	@Test
	void defaultConfigFile() {
		// hazelcast.xml present in root classpath
		this.contextRunner.run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getConfigurationUrl()).isEqualTo(new ClassPathResource('hazelcast.xml').getURL());
		});
	}
	@Test
	void systemPropertyWithXml() {
		this.contextRunner
			.withSystemProperties(HazelcastServerConfiguration.CONFIG_SYSTEM_PROPERTY
					+ '=classpath:org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.xml')
			.run((context) -> {
				Config config = context.getBean(HazelcastInstance.class).getConfig();
				assertThat(config.getMapConfigs().keySet()).containsOnly('foobar');
			});
	}
	@Test
	void systemPropertyWithYaml() {
		this.contextRunner
			.withSystemProperties(HazelcastServerConfiguration.CONFIG_SYSTEM_PROPERTY
					+ '=classpath:org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.yaml')
			.run((context) -> {
				Config config = context.getBean(HazelcastInstance.class).getConfig();
				assertThat(config.getMapConfigs().keySet()).containsOnly('foobar');
			});
	}
	@Test
	void systemPropertyWithYml() {
		this.contextRunner
			.withSystemProperties(HazelcastServerConfiguration.CONFIG_SYSTEM_PROPERTY
					+ '=classpath:org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.yml')
			.run((context) -> {
				Config config = context.getBean(HazelcastInstance.class).getConfig();
				assertThat(config.getMapConfigs().keySet()).containsOnly('foobar');
			});
	}
	@Test
	void explicitConfigFileWithXml() {
		this.contextRunner
			.withPropertyValues('spring.hazelcast.config=org/springframework/boot/autoconfigure/hazelcast/'
					+ 'hazelcast-specific.xml')
			.run(assertSpecificHazelcastServer(
					'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.xml'));
	}
	@Test
	void explicitConfigFileWithYaml() {
		this.contextRunner
			.withPropertyValues('spring.hazelcast.config=org/springframework/boot/autoconfigure/hazelcast/'
					+ 'hazelcast-specific.yaml')
			.run(assertSpecificHazelcastServer(
					'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.yaml'));
	}
	@Test
	void explicitConfigFileWithYml() {
		this.contextRunner
			.withPropertyValues('spring.hazelcast.config=org/springframework/boot/autoconfigure/hazelcast/'
					+ 'hazelcast-specific.yml')
			.run(assertSpecificHazelcastServer(
					'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.yml'));
	}
	@Test
	void explicitConfigUrlWithXml() {
		this.contextRunner
			.withPropertyValues('spring.hazelcast.config=classpath:org/springframework/'
					+ 'boot/autoconfigure/hazelcast/hazelcast-specific.xml')
			.run(assertSpecificHazelcastServer(
					'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.xml'));
	}
	@Test
	void explicitConfigUrlWithYaml() {
		this.contextRunner
			.withPropertyValues('spring.hazelcast.config=classpath:org/springframework/'
					+ 'boot/autoconfigure/hazelcast/hazelcast-specific.yaml')
			.run(assertSpecificHazelcastServer(
					'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.yaml'));
	}
	@Test
	void explicitConfigUrlWithYml() {
		this.contextRunner
			.withPropertyValues('spring.hazelcast.config=classpath:org/springframework/'
					+ 'boot/autoconfigure/hazelcast/hazelcast-specific.yml')
			.run(assertSpecificHazelcastServer(
					'org/springframework/boot/autoconfigure/hazelcast/hazelcast-specific.yml'));
	}
	private ContextConsumer<AssertableApplicationContext> assertSpecificHazelcastServer(String location) {
		return (context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			String configurationLocation = (config.getConfigurationUrl() != null)
					? config.getConfigurationUrl().toString()
					: config.getConfigurationFile().toURI().toURL().toString();
			assertThat(configurationLocation).endsWith(location);
		};
	}
	@Test
	void unknownConfigFile() {
		this.contextRunner.withPropertyValues('spring.hazelcast.config=foo/bar/unknown.xml')
			.run((context) -> assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('foo/bar/unknown.xml'));
	}
	@Test
	void configInstanceWithName() {
		Config config = createTestConfig('my-test-instance');
		HazelcastInstance existing = Hazelcast.newHazelcastInstance(config);
		try {
			this.contextRunner.withUserConfiguration(HazelcastConfigWithName.class)
				.withPropertyValues('spring.hazelcast.config=this-is-ignored.xml')
				.run((context) -> {
					HazelcastInstance hazelcast = context.getBean(HazelcastInstance.class);
					assertThat(hazelcast.getConfig().getInstanceName()).isEqualTo('my-test-instance');
					// Should reuse any existing instance by default.
					assertThat(hazelcast).isEqualTo(existing);
				});
		}
		finally {
			existing.shutdown();
		}
	}
	@Test
	void configInstanceWithoutName() {
		this.contextRunner.withUserConfiguration(HazelcastConfigNoName.class)
			.withPropertyValues('spring.hazelcast.config=this-is-ignored.xml')
			.run((context) -> {
				Config config = context.getBean(HazelcastInstance.class).getConfig();
				Map<String, QueueConfig> queueConfigs = config.getQueueConfigs();
				assertThat(queueConfigs.keySet()).containsOnly('another-queue');
			});
	}
	@Test
	void autoConfiguredConfigUsesApplicationClassLoader() {
		this.contextRunner.run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getClassLoader()).isSameAs(context.getSourceApplicationContext().getClassLoader());
		});
	}
	@Test
	void autoConfiguredConfigUsesSpringManagedContext() {
		this.contextRunner.run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getManagedContext()).isInstanceOf(SpringManagedContext.class);
		});
	}
	@Test
	void autoConfiguredConfigCanUseSpringAwareComponent() {
		this.contextRunner.withPropertyValues('test.hazelcast.key=42').run((context) -> {
			HazelcastInstance hz = context.getBean(HazelcastInstance.class);
			IMap<String, String> map = hz.getMap('test');
			assertThat(map.executeOnKey('test.hazelcast.key', new SpringAwareEntryProcessor<>())).isEqualTo('42');
		});
	}
	@Test
	void autoConfiguredConfigWithoutHazelcastSpringDoesNotUseSpringManagedContext() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(SpringManagedContext.class)).run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getManagedContext()).isNull();
		});
	}
	@Test
	void autoConfiguredContextCanOverrideManagementContextUsingCustomizer() {
		this.contextRunner.withBean(TestHazelcastConfigCustomizer.class).run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getManagedContext()).isNull();
		});
	}
	@Test
	void autoConfiguredConfigSetsHazelcastLoggingToSlf4j() {
		this.contextRunner.run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getProperty(HazelcastServerConfiguration.HAZELCAST_LOGGING_TYPE)).isEqualTo('slf4j');
		});
	}
	@Test
	void autoConfiguredConfigCanOverrideHazelcastLogging() {
		this.contextRunner.withUserConfiguration(HazelcastConfigWithJDKLogging.class).run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getProperty(HazelcastServerConfiguration.HAZELCAST_LOGGING_TYPE)).isEqualTo('jdk');
		});
	}
	private static Config createTestConfig(String instanceName) {
		Config config = new Config(instanceName);
		JoinConfig join = config.getNetworkConfig().getJoin();
		join.getAutoDetectionConfig().setEnabled(false);
		join.getMulticastConfig().setEnabled(false);
		return config;
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastConfigWithName {
		@Bean
		Config myHazelcastConfig() {
			return new Config('my-test-instance');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastConfigNoName {
		@Bean
		Config anotherHazelcastConfig() {
			Config config = createTestConfig('another-test-instance');
			config.addQueueConfig(new QueueConfig('another-queue'));
			return config;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastConfigWithJDKLogging {
		@Bean
		Config anotherHazelcastConfig() {
			Config config = new Config();
			config.setProperty(HazelcastServerConfiguration.HAZELCAST_LOGGING_TYPE, 'jdk');
			return config;
		}
	}
	@SpringAware
	static class SpringAwareEntryProcessor<V> implements EntryProcessor<String, V, String> {
		@Autowired
		private Environment environment;
		@Override
		public String process(Map.Entry<String, V> entry) {
			return this.environment.getProperty(entry.getKey());
		}
	}
	@Order(1)
	static class TestHazelcastConfigCustomizer implements HazelcastConfigCustomizer {
		@Override
		public void customize(Config config) {
			config.setManagedContext(null);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
class HazelcastJpaDependencyAutoConfigurationTests {
	private static final String POST_PROCESSOR_BEAN_NAME = HazelcastInstanceEntityManagerFactoryDependsOnPostProcessor.class
		.getName();
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class,
				HazelcastJpaDependencyAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void registrationIfHazelcastInstanceHasRegularBeanName() {
		this.contextRunner.withUserConfiguration(HazelcastConfiguration.class).run((context) -> {
			assertThat(postProcessors(context)).containsKey(POST_PROCESSOR_BEAN_NAME);
			assertThat(entityManagerFactoryDependencies(context)).contains('hazelcastInstance');
		});
	}
	@Test
	void noRegistrationIfHazelcastInstanceHasCustomBeanName() {
		this.contextRunner.withUserConfiguration(HazelcastCustomNameConfiguration.class).run((context) -> {
			assertThat(entityManagerFactoryDependencies(context)).doesNotContain('hazelcastInstance');
			assertThat(postProcessors(context)).doesNotContainKey(POST_PROCESSOR_BEAN_NAME);
		});
	}
	@Test
	void noRegistrationWithNoHazelcastInstance() {
		this.contextRunner.run((context) -> {
			assertThat(entityManagerFactoryDependencies(context)).doesNotContain('hazelcastInstance');
			assertThat(postProcessors(context)).doesNotContainKey(POST_PROCESSOR_BEAN_NAME);
		});
	}
	@Test
	void noRegistrationWithNoEntityManagerFactory() {
		new ApplicationContextRunner().withUserConfiguration(HazelcastConfiguration.class)
			.withConfiguration(AutoConfigurations.of(HazelcastJpaDependencyAutoConfiguration.class))
			.run((context) -> assertThat(postProcessors(context)).doesNotContainKey(POST_PROCESSOR_BEAN_NAME));
	}
	private Map<String, EntityManagerFactoryDependsOnPostProcessor> postProcessors(
			AssertableApplicationContext context) {
		return context.getBeansOfType(EntityManagerFactoryDependsOnPostProcessor.class);
	}
	private List<String> entityManagerFactoryDependencies(AssertableApplicationContext context) {
		String[] dependsOn = ((BeanDefinitionRegistry) context.getSourceApplicationContext())
			.getBeanDefinition('entityManagerFactory')
			.getDependsOn();
		return (dependsOn != null) ? Arrays.asList(dependsOn) : Collections.emptyList();
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastConfiguration {
		@Bean
		HazelcastInstance hazelcastInstance() {
			return mock(HazelcastInstance.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HazelcastCustomNameConfiguration {
		@Bean
		HazelcastInstance myHazelcastInstance() {
			return mock(HazelcastInstance.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hazelcast;
/**
class HazelcastAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HazelcastAutoConfiguration.class));
	@Test
	void defaultConfigFile() {
		// no hazelcast-client.xml and hazelcast.xml is present in root classpath
		// this also asserts that XML has priority over YAML
		// as hazelcast.yaml, hazelcast.yml, and hazelcast.xml are available.
		this.contextRunner.run((context) -> {
			Config config = context.getBean(HazelcastInstance.class).getConfig();
			assertThat(config.getConfigurationUrl()).isEqualTo(new ClassPathResource('hazelcast.xml').getURL());
		});
	}
}
/*
package org.springframework.boot.autoconfigure.info;
/**
class ProjectInfoAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(PropertyPlaceholderAutoConfiguration.class, ProjectInfoAutoConfiguration.class));
	@Test
	void gitPropertiesUnavailableIfResourceNotAvailable() {
		this.contextRunner.run((context) -> assertThat(context.getBeansOfType(GitProperties.class)).isEmpty());
	}
	@Test
	void gitPropertiesWithNoData() {
		this.contextRunner
			.withPropertyValues('spring.info.git.location='
					+ 'classpath:/org/springframework/boot/autoconfigure/info/git-no-data.properties')
			.run((context) -> {
				GitProperties gitProperties = context.getBean(GitProperties.class);
				assertThat(gitProperties.getBranch()).isNull();
			});
	}
	@Test
	void gitPropertiesFallbackWithGitPropertiesBean() {
		this.contextRunner.withUserConfiguration(CustomInfoPropertiesConfiguration.class)
			.withPropertyValues(
					'spring.info.git.location=classpath:/org/springframework/boot/autoconfigure/info/git.properties')
			.run((context) -> {
				GitProperties gitProperties = context.getBean(GitProperties.class);
				assertThat(gitProperties).isSameAs(context.getBean('customGitProperties'));
			});
	}
	@Test
	void gitPropertiesUsesUtf8ByDefault() {
		this.contextRunner
			.withPropertyValues(
					'spring.info.git.location=classpath:/org/springframework/boot/autoconfigure/info/git.properties')
			.run((context) -> {
				GitProperties gitProperties = context.getBean(GitProperties.class);
				assertThat(gitProperties.get('commit.charset')).isEqualTo('test');
			});
	}
	@Test
	void gitPropertiesEncodingCanBeConfigured() {
		this.contextRunner
			.withPropertyValues('spring.info.git.encoding=US-ASCII',
					'spring.info.git.location=classpath:/org/springframework/boot/autoconfigure/info/git.properties')
			.run((context) -> {
				GitProperties gitProperties = context.getBean(GitProperties.class);
				assertThat(gitProperties.get('commit.charset')).isNotEqualTo('test');
			});
	}
	@Test
	void buildPropertiesDefaultLocation() {
		this.contextRunner.run((context) -> {
			BuildProperties buildProperties = context.getBean(BuildProperties.class);
			assertThat(buildProperties.getGroup()).isEqualTo('com.example');
			assertThat(buildProperties.getArtifact()).isEqualTo('demo');
			assertThat(buildProperties.getName()).isEqualTo('Demo Project');
			assertThat(buildProperties.getVersion()).isEqualTo('0.0.1-SNAPSHOT');
			assertThat(buildProperties.getTime().toEpochMilli()).isEqualTo(1457100965000L);
		});
	}
	@Test
	void buildPropertiesCustomLocation() {
		this.contextRunner
			.withPropertyValues('spring.info.build.location='
					+ 'classpath:/org/springframework/boot/autoconfigure/info/build-info.properties')
			.run((context) -> {
				BuildProperties buildProperties = context.getBean(BuildProperties.class);
				assertThat(buildProperties.getGroup()).isEqualTo('com.example.acme');
				assertThat(buildProperties.getArtifact()).isEqualTo('acme');
				assertThat(buildProperties.getName()).isEqualTo('acme');
				assertThat(buildProperties.getVersion()).isEqualTo('1.0.1-SNAPSHOT');
				assertThat(buildProperties.getTime().toEpochMilli()).isEqualTo(1457088120000L);
			});
	}
	@Test
	void buildPropertiesCustomInvalidLocation() {
		this.contextRunner.withPropertyValues('spring.info.build.location=classpath:/org/acme/no-build-info.properties')
			.run((context) -> assertThat(context.getBeansOfType(BuildProperties.class)).isEmpty());
	}
	@Test
	void buildPropertiesFallbackWithBuildInfoBean() {
		this.contextRunner.withUserConfiguration(CustomInfoPropertiesConfiguration.class).run((context) -> {
			BuildProperties buildProperties = context.getBean(BuildProperties.class);
			assertThat(buildProperties).isSameAs(context.getBean('customBuildProperties'));
		});
	}
	@Test
	void buildPropertiesUsesUtf8ByDefault() {
		this.contextRunner.withPropertyValues(
				'spring.info.build.location=classpath:/org/springframework/boot/autoconfigure/info/build-info.properties')
			.run((context) -> {
				BuildProperties buildProperties = context.getBean(BuildProperties.class);
				assertThat(buildProperties.get('charset')).isEqualTo('test');
			});
	}
	@Test
	void buildPropertiesEncodingCanBeConfigured() {
		this.contextRunner.withPropertyValues('spring.info.build.encoding=US-ASCII',
				'spring.info.build.location=classpath:/org/springframework/boot/autoconfigure/info/build-info.properties')
			.run((context) -> {
				BuildProperties buildProperties = context.getBean(BuildProperties.class);
				assertThat(buildProperties.get('charset')).isNotEqualTo('test');
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomInfoPropertiesConfiguration {
		@Bean
		GitProperties customGitProperties() {
			return new GitProperties(new Properties());
		}
		@Bean
		BuildProperties customBuildProperties() {
			return new BuildProperties(new Properties());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@ClassPathExclusions('hibernate-jpa-*.jar')
class BatchAutoConfigurationWithoutJpaTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(BatchAutoConfiguration.class, TransactionAutoConfiguration.class,
				DataSourceTransactionManagerAutoConfiguration.class));
	@Test
	void jdbcWithDefaultSettings() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.datasource.generate-unique-name=true')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				assertThat(context).hasSingleBean(JobExplorer.class);
				assertThat(context).hasSingleBean(JobRepository.class);
				assertThat(context.getBean(BatchProperties.class).getJdbc().getInitializeSchema())
					.isEqualTo(DatabaseInitializationMode.EMBEDDED);
				assertThat(new JdbcTemplate(context.getBean(DataSource.class))
					.queryForList('select * from BATCH_JOB_EXECUTION')).isEmpty();
				assertThat(context.getBean(JobExplorer.class).findRunningJobExecutions('test')).isEmpty();
				assertThat(context.getBean(JobRepository.class).getLastJobExecution('test', new JobParameters()))
					.isNull();
			});
	}
	@Test
	void jdbcWithCustomPrefix() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.batch.jdbc.schema:classpath:batch/custom-schema.sql',
					'spring.batch.jdbc.tablePrefix:PREFIX_')
			.run((context) -> {
				assertThat(new JdbcTemplate(context.getBean(DataSource.class))
					.queryForList('select * from PREFIX_JOB_EXECUTION')).isEmpty();
				assertThat(context.getBean(JobExplorer.class).findRunningJobExecutions('test')).isEmpty();
				assertThat(context.getBean(JobRepository.class).getLastJobExecution('test', new JobParameters()))
					.isNull();
			});
	}
	@Test
	void jdbcWithCustomIsolationLevel() {
		this.contextRunner.withUserConfiguration(DefaultConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.batch.jdbc.isolation-level-for-create=read_committed')
			.run((context) -> assertThat(
					context.getBean(SpringBootBatchConfiguration.class).getIsolationLevelForCreate())
				.isEqualTo(Isolation.READ_COMMITTED));
	}
	@TestAutoConfigurationPackage(City.class)
	static class DefaultConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
class BatchDataSourceScriptDatabaseInitializerTests {
	@Test
	void getSettingsWithPlatformDoesNotTouchDataSource() {
		DataSource dataSource = mock(DataSource.class);
		BatchProperties properties = new BatchProperties();
		properties.getJdbc().setPlatform('test');
		DatabaseInitializationSettings settings = BatchDataSourceScriptDatabaseInitializer.getSettings(dataSource,
				properties.getJdbc());
		assertThat(settings.getSchemaLocations())
			.containsOnly('classpath:org/springframework/batch/core/schema-test.sql');
		then(dataSource).shouldHaveNoInteractions();
	}
	@ParameterizedTest
	@EnumSource(value = DatabaseDriver.class, mode = Mode.EXCLUDE, names = { 'CLICKHOUSE', 'FIREBIRD', 'INFORMIX',
			'JTDS', 'PHOENIX', 'REDSHIFT', 'TERADATA', 'TESTCONTAINERS', 'UNKNOWN' })
	void batchSchemaCanBeLocated(DatabaseDriver driver) throws SQLException {
		DefaultResourceLoader resourceLoader = new DefaultResourceLoader();
		BatchProperties properties = new BatchProperties();
		DataSource dataSource = mock(DataSource.class);
		Connection connection = mock(Connection.class);
		given(dataSource.getConnection()).willReturn(connection);
		DatabaseMetaData metadata = mock(DatabaseMetaData.class);
		given(connection.getMetaData()).willReturn(metadata);
		String productName = (String) ReflectionTestUtils.getField(driver, 'productName');
		given(metadata.getDatabaseProductName()).willReturn(productName);
		DatabaseInitializationSettings settings = BatchDataSourceScriptDatabaseInitializer.getSettings(dataSource,
				properties.getJdbc());
		List<String> schemaLocations = settings.getSchemaLocations();
		assertThat(schemaLocations).isNotEmpty()
			.allSatisfy((location) -> assertThat(resourceLoader.getResource(location).exists()).isTrue());
	}
	@Test
	void batchHasExpectedBuiltInSchemas() throws IOException {
		PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
		List<String> schemaNames = Stream
			.of(resolver.getResources('classpath:org/springframework/batch/core/schema-*.sql'))
			.map(Resource::getFilename)
			.filter((resourceName) -> !resourceName.contains('-drop-'))
			.toList();
		assertThat(schemaNames).containsExactlyInAnyOrder('schema-derby.sql', 'schema-sqlserver.sql',
				'schema-mariadb.sql', 'schema-mysql.sql', 'schema-sqlite.sql', 'schema-postgresql.sql',
				'schema-hana.sql', 'schema-oracle.sql', 'schema-db2.sql', 'schema-hsqldb.sql', 'schema-sybase.sql',
				'schema-h2.sql');
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
@ExtendWith(OutputCaptureExtension.class)
class BatchAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(BatchAutoConfiguration.class, TransactionManagerCustomizationAutoConfiguration.class,
					TransactionAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class));
	@Test
	void testDefaultContext() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(JobRepository.class);
				assertThat(context).hasSingleBean(JobLauncher.class);
				assertThat(context).hasSingleBean(JobExplorer.class);
				assertThat(context).hasSingleBean(JobRegistry.class);
				assertThat(context).hasSingleBean(JobOperator.class);
				assertThat(context.getBean(BatchProperties.class).getJdbc().getInitializeSchema())
					.isEqualTo(DatabaseInitializationMode.EMBEDDED);
				assertThat(new JdbcTemplate(context.getBean(DataSource.class))
					.queryForList('select * from BATCH_JOB_EXECUTION')).isEmpty();
			});
	}
	@Test
	void autoconfigurationBacksOffEntirelyIfSpringJdbcAbsent() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withClassLoader(new FilteredClassLoader(DatabasePopulator.class))
			.run((context) -> {
				assertThat(context).doesNotHaveBean(JobLauncherApplicationRunner.class);
				assertThat(context).doesNotHaveBean(BatchDataSourceScriptDatabaseInitializer.class);
			});
	}
	@Test
	void autoConfigurationBacksOffWhenUserEnablesBatchProcessing() {
		this.contextRunner
			.withUserConfiguration(EnableBatchProcessingConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withClassLoader(new FilteredClassLoader(DatabasePopulator.class))
			.run((context) -> assertThat(context).doesNotHaveBean(SpringBootBatchConfiguration.class));
	}
	@Test
	void autoConfigurationBacksOffWhenUserProvidesBatchConfiguration() {
		this.contextRunner.withUserConfiguration(CustomBatchConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withClassLoader(new FilteredClassLoader(DatabasePopulator.class))
			.run((context) -> assertThat(context).doesNotHaveBean(SpringBootBatchConfiguration.class));
	}
	@Test
	void testDefinesAndLaunchesJob() {
		this.contextRunner.withUserConfiguration(JobConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				context.getBean(JobLauncherApplicationRunner.class)
					.run(new DefaultApplicationArguments('jobParam=test'));
				JobParameters jobParameters = new JobParametersBuilder().addString('jobParam', 'test')
					.toJobParameters();
				assertThat(context.getBean(JobRepository.class).getLastJobExecution('job', jobParameters)).isNotNull();
			});
	}
	@Test
	void testDefinesAndLaunchesJobIgnoreOptionArguments() {
		this.contextRunner.withUserConfiguration(JobConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				context.getBean(JobLauncherApplicationRunner.class)
					.run(new DefaultApplicationArguments('--spring.property=value', 'jobParam=test'));
				JobParameters jobParameters = new JobParametersBuilder().addString('jobParam', 'test')
					.toJobParameters();
				assertThat(context.getBean(JobRepository.class).getLastJobExecution('job', jobParameters)).isNotNull();
			});
	}
	@Test
	void testDefinesAndLaunchesNamedRegisteredJob() {
		this.contextRunner
			.withUserConfiguration(NamedJobConfigurationWithRegisteredJob.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.batch.job.name:discreteRegisteredJob')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				context.getBean(JobLauncherApplicationRunner.class).run();
				assertThat(context.getBean(JobRepository.class)
					.getLastJobExecution('discreteRegisteredJob', new JobParameters())).isNotNull();
			});
	}
	@Test
	void testRegisteredAndLocalJob() {
		this.contextRunner
			.withUserConfiguration(NamedJobConfigurationWithRegisteredAndLocalJob.class,
					EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.batch.job.name:discreteRegisteredJob')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				context.getBean(JobLauncherApplicationRunner.class).run();
				assertThat(context.getBean(JobRepository.class)
					.getLastJobExecution('discreteRegisteredJob', new JobParameters())
					.getStatus()).isEqualTo(BatchStatus.COMPLETED);
			});
	}
	@Test
	void testDefinesAndLaunchesLocalJob() {
		this.contextRunner
			.withUserConfiguration(NamedJobConfigurationWithLocalJob.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.batch.job.name:discreteLocalJob')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				context.getBean(JobLauncherApplicationRunner.class).run();
				assertThat(context.getBean(JobRepository.class)
					.getLastJobExecution('discreteLocalJob', new JobParameters())).isNotNull();
			});
	}
	@Test
	void testMultipleJobsAndNoJobName() {
		this.contextRunner.withUserConfiguration(MultipleJobConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure().getCause().getMessage())
					.contains('Job name must be specified in case of multiple jobs');
			});
	}
	@Test
	void testMultipleJobsAndJobName() {
		this.contextRunner.withUserConfiguration(MultipleJobConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.batch.job.name:discreteLocalJob')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				context.getBean(JobLauncherApplicationRunner.class).run();
				assertThat(context.getBean(JobRepository.class)
					.getLastJobExecution('discreteLocalJob', new JobParameters())).isNotNull();
			});
	}
	@Test
	void testDisableLaunchesJob() {
		this.contextRunner.withUserConfiguration(JobConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.batch.job.enabled:false')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				assertThat(context).doesNotHaveBean(CommandLineRunner.class);
			});
	}
	@Test
	void testDisableSchemaLoader() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.batch.jdbc.initialize-schema:never')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				assertThat(context.getBean(BatchProperties.class).getJdbc().getInitializeSchema())
					.isEqualTo(DatabaseInitializationMode.NEVER);
				assertThat(context).doesNotHaveBean(BatchDataSourceScriptDatabaseInitializer.class);
				assertThatExceptionOfType(BadSqlGrammarException.class)
					.isThrownBy(() -> new JdbcTemplate(context.getBean(DataSource.class))
						.queryForList('select * from BATCH_JOB_EXECUTION'));
			});
	}
	@Test
	void testUsingJpa() {
		this.contextRunner
			.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class,
					HibernateJpaAutoConfiguration.class)
			.run((context) -> {
				PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);
				// It"s a lazy proxy, but it does render its target if you ask for
				// toString():
				assertThat(transactionManager.toString()).contains('JpaTransactionManager');
				assertThat(context).hasSingleBean(EntityManagerFactory.class);
				// Ensure the JobRepository can be used (no problem with isolation
				// level)
				assertThat(context.getBean(JobRepository.class).getLastJobExecution('job', new JobParameters()))
					.isNull();
			});
	}
	@Test
	void testRenamePrefix() {
		this.contextRunner
			.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class,
					HibernateJpaAutoConfiguration.class)
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.batch.jdbc.schema:classpath:batch/custom-schema.sql',
					'spring.batch.jdbc.tablePrefix:PREFIX_')
			.run((context) -> {
				assertThat(context).hasSingleBean(JobLauncher.class);
				assertThat(context.getBean(BatchProperties.class).getJdbc().getInitializeSchema())
					.isEqualTo(DatabaseInitializationMode.EMBEDDED);
				assertThat(new JdbcTemplate(context.getBean(DataSource.class))
					.queryForList('select * from PREFIX_JOB_EXECUTION')).isEmpty();
				JobExplorer jobExplorer = context.getBean(JobExplorer.class);
				assertThat(jobExplorer.findRunningJobExecutions('test')).isEmpty();
				JobRepository jobRepository = context.getBean(JobRepository.class);
				assertThat(jobRepository.getLastJobExecution('test', new JobParameters())).isNull();
			});
	}
	@Test
	void testCustomizeJpaTransactionManagerUsingProperties() {
		this.contextRunner
			.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class,
					HibernateJpaAutoConfiguration.class)
			.withPropertyValues('spring.transaction.default-timeout:30',
					'spring.transaction.rollback-on-commit-failure:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(BatchAutoConfiguration.class);
				JpaTransactionManager transactionManager = JpaTransactionManager.class
					.cast(context.getBean(SpringBootBatchConfiguration.class).getTransactionManager());
				assertThat(transactionManager.getDefaultTimeout()).isEqualTo(30);
				assertThat(transactionManager.isRollbackOnCommitFailure()).isTrue();
			});
	}
	@Test
	void testCustomizeDataSourceTransactionManagerUsingProperties() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.transaction.default-timeout:30',
					'spring.transaction.rollback-on-commit-failure:true')
			.run((context) -> {
				assertThat(context).hasSingleBean(SpringBootBatchConfiguration.class);
				DataSourceTransactionManager transactionManager = DataSourceTransactionManager.class
					.cast(context.getBean(SpringBootBatchConfiguration.class).getTransactionManager());
				assertThat(transactionManager.getDefaultTimeout()).isEqualTo(30);
				assertThat(transactionManager.isRollbackOnCommitFailure()).isTrue();
			});
	}
	@Test
	void testBatchDataSource() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, BatchDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SpringBootBatchConfiguration.class)
					.hasSingleBean(BatchDataSourceScriptDatabaseInitializer.class)
					.hasBean('batchDataSource');
				DataSource batchDataSource = context.getBean('batchDataSource', DataSource.class);
				assertThat(context.getBean(SpringBootBatchConfiguration.class).getDataSource())
					.isEqualTo(batchDataSource);
				assertThat(context.getBean(BatchDataSourceScriptDatabaseInitializer.class))
					.hasFieldOrPropertyWithValue('dataSource', batchDataSource);
			});
	}
	@Test
	void testBatchTransactionManager() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, BatchTransactionManagerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SpringBootBatchConfiguration.class);
				PlatformTransactionManager batchTransactionManager = context.getBean('batchTransactionManager',
						PlatformTransactionManager.class);
				assertThat(context.getBean(SpringBootBatchConfiguration.class).getTransactionManager())
					.isEqualTo(batchTransactionManager);
			});
	}
	@Test
	void testBatchTaskExecutor() {
		this.contextRunner
			.withUserConfiguration(TestConfiguration.class, BatchTaskExecutorConfiguration.class,
					EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(SpringBootBatchConfiguration.class).hasBean('batchTaskExecutor');
				TaskExecutor batchTaskExecutor = context.getBean('batchTaskExecutor', TaskExecutor.class);
				assertThat(batchTaskExecutor).isInstanceOf(AsyncTaskExecutor.class);
				assertThat(context.getBean(SpringBootBatchConfiguration.class).getTaskExecutor())
					.isEqualTo(batchTaskExecutor);
				assertThat(context.getBean(JobLauncher.class)).hasFieldOrPropertyWithValue('taskExecutor',
						batchTaskExecutor);
			});
	}
	@Test
	void jobRepositoryBeansDependOnBatchDataSourceInitializer() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
				String[] jobRepositoryNames = beanFactory.getBeanNamesForType(JobRepository.class);
				assertThat(jobRepositoryNames).isNotEmpty();
				for (String jobRepositoryName : jobRepositoryNames) {
					assertThat(beanFactory.getBeanDefinition(jobRepositoryName).getDependsOn())
						.contains('batchDataSourceInitializer');
				}
			});
	}
	@Test
	void jobRepositoryBeansDependOnFlyway() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withUserConfiguration(FlywayAutoConfiguration.class)
			.withPropertyValues('spring.batch.initialize-schema=never')
			.run((context) -> {
				ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
				String[] jobRepositoryNames = beanFactory.getBeanNamesForType(JobRepository.class);
				assertThat(jobRepositoryNames).isNotEmpty();
				for (String jobRepositoryName : jobRepositoryNames) {
					assertThat(beanFactory.getBeanDefinition(jobRepositoryName).getDependsOn()).contains('flyway',
							'flywayInitializer');
				}
			});
	}
	@Test
	void jobRepositoryBeansDependOnLiquibase() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withUserConfiguration(LiquibaseAutoConfiguration.class)
			.withPropertyValues('spring.batch.initialize-schema=never')
			.run((context) -> {
				ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
				String[] jobRepositoryNames = beanFactory.getBeanNamesForType(JobRepository.class);
				assertThat(jobRepositoryNames).isNotEmpty();
				for (String jobRepositoryName : jobRepositoryNames) {
					assertThat(beanFactory.getBeanDefinition(jobRepositoryName).getDependsOn()).contains('liquibase');
				}
			});
	}
	@Test
	void whenTheUserDefinesTheirOwnBatchDatabaseInitializerThenTheAutoConfiguredInitializerBacksOff() {
		this.contextRunner
			.withUserConfiguration(TestConfiguration.class, CustomBatchDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(BatchDataSourceScriptDatabaseInitializer.class)
				.doesNotHaveBean('batchDataSourceScriptDatabaseInitializer')
				.hasBean('customInitializer'));
	}
	@Test
	void whenTheUserDefinesTheirOwnDatabaseInitializerThenTheAutoConfiguredBatchInitializerRemains() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, CustomDatabaseInitializerConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(BatchDataSourceScriptDatabaseInitializer.class)
				.hasBean('customInitializer'));
	}
	@Test
	void conversionServiceCustomizersAreCalled() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withUserConfiguration(ConversionServiceCustomizersConfiguration.class)
			.run((context) -> {
				BatchConversionServiceCustomizer customizer = context.getBean('batchConversionServiceCustomizer',
						BatchConversionServiceCustomizer.class);
				BatchConversionServiceCustomizer anotherCustomizer = context
					.getBean('anotherBatchConversionServiceCustomizer', BatchConversionServiceCustomizer.class);
				InOrder inOrder = Mockito.inOrder(customizer, anotherCustomizer);
				ConfigurableConversionService configurableConversionService = context
					.getBean(SpringBootBatchConfiguration.class)
					.getConversionService();
				inOrder.verify(customizer).customize(configurableConversionService);
				inOrder.verify(anotherCustomizer).customize(configurableConversionService);
			});
	}
	@Test
	void whenTheUserDefinesAJobNameAsJobInstanceValidates() {
		JobLauncherApplicationRunner runner = createInstance('another');
		runner.setJobs(Collections.singletonList(mockJob('test')));
		runner.setJobName('test');
		runner.afterPropertiesSet();
	}
	@Test
	void whenTheUserDefinesAJobNameAsRegisteredJobValidates() {
		JobLauncherApplicationRunner runner = createInstance('test');
		runner.setJobName('test');
		runner.afterPropertiesSet();
	}
	@Test
	void whenTheUserDefinesAJobNameThatDoesNotExistWithJobInstancesFailsFast() {
		JobLauncherApplicationRunner runner = createInstance();
		runner.setJobs(Arrays.asList(mockJob('one'), mockJob('two')));
		runner.setJobName('three');
		assertThatIllegalArgumentException().isThrownBy(runner::afterPropertiesSet)
			.withMessage('No job found with name "three"');
	}
	@Test
	void whenTheUserDefinesAJobNameThatDoesNotExistWithRegisteredJobFailsFast() {
		JobLauncherApplicationRunner runner = createInstance('one', 'two');
		runner.setJobName('three');
		assertThatIllegalArgumentException().isThrownBy(runner::afterPropertiesSet)
			.withMessage('No job found with name "three"');
	}
	@Test
	void customExecutionContextSerializerIsUsed() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.withUserConfiguration(CustomExecutionContextConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Jackson2ExecutionContextStringSerializer.class);
				assertThat(context.getBean(SpringBootBatchConfiguration.class).getExecutionContextSerializer())
					.isInstanceOf(Jackson2ExecutionContextStringSerializer.class);
			});
	}
	@Test
	void defaultExecutionContextSerializerIsUsed() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean(ExecutionContextSerializer.class);
				assertThat(context.getBean(SpringBootBatchConfiguration.class).getExecutionContextSerializer())
					.isInstanceOf(DefaultExecutionContextSerializer.class);
			});
	}
	private JobLauncherApplicationRunner createInstance(String... registeredJobNames) {
		JobLauncherApplicationRunner runner = new JobLauncherApplicationRunner(mock(JobLauncher.class),
				mock(JobExplorer.class), mock(JobRepository.class));
		JobRegistry jobRegistry = mock(JobRegistry.class);
		given(jobRegistry.getJobNames()).willReturn(Arrays.asList(registeredJobNames));
		runner.setJobRegistry(jobRegistry);
		return runner;
	}
	private Job mockJob(String name) {
		Job job = mock(Job.class);
		given(job.getName()).willReturn(name);
		return job;
	}
	@Configuration(proxyBeanMethods = false)
	static class BatchDataSourceConfiguration {
		@Bean
		DataSource normalDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:normal').username('sa').build();
		}
		@BatchDataSource
		@Bean(defaultCandidate = false)
		DataSource batchDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:batchdatasource').username('sa').build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BatchTransactionManagerConfiguration {
		@Bean
		DataSource dataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:database').username('sa').build();
		}
		@Bean
		@Primary
		PlatformTransactionManager normalTransactionManager() {
			return mock(PlatformTransactionManager.class);
		}
		@BatchTransactionManager
		@Bean(defaultCandidate = false)
		PlatformTransactionManager batchTransactionManager() {
			return mock(PlatformTransactionManager.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BatchTaskExecutorConfiguration {
		@Bean
		TaskExecutor taskExecutor() {
			return new SyncTaskExecutor();
		}
		@BatchTaskExecutor
		@Bean(defaultCandidate = false)
		TaskExecutor batchTaskExecutor() {
			return new SimpleAsyncTaskExecutor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EmptyConfiguration {
	}
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class EntityManagerFactoryConfiguration {
		@Bean
		EntityManagerFactory entityManagerFactory() {
			return mock(EntityManagerFactory.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NamedJobConfigurationWithRegisteredAndLocalJob {
		@Autowired
		private JobRepository jobRepository;
		@Bean
		Job discreteJob() {
			AbstractJob job = new AbstractJob('discreteRegisteredJob') {
				private static int count = 0;
				@Override
				public Collection<String> getStepNames() {
					return Collections.emptySet();
				}
				@Override
				public Step getStep(String stepName) {
					return null;
				}
				@Override
				protected void doExecute(JobExecution execution) {
					if (count == 0) {
						execution.setStatus(BatchStatus.COMPLETED);
					}
					else {
						execution.setStatus(BatchStatus.FAILED);
					}
					count++;
				}
			};
			job.setJobRepository(this.jobRepository);
			return job;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NamedJobConfigurationWithRegisteredJob {
		@Bean
		static BeanPostProcessor registryProcessor(ApplicationContext applicationContext) {
			return new NamedJobJobRegistryBeanPostProcessor(applicationContext);
		}
	}
	static class NamedJobJobRegistryBeanPostProcessor implements BeanPostProcessor {
		private final ApplicationContext applicationContext;
		NamedJobJobRegistryBeanPostProcessor(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Override
		public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
			if (bean instanceof JobRegistry jobRegistry) {
				try {
					jobRegistry.register(getJobFactory());
				}
				catch (DuplicateJobException ex) {
					// Ignore
				}
			}
			return bean;
		}
		private JobFactory getJobFactory() {
			JobRepository jobRepository = this.applicationContext.getBean(JobRepository.class);
			return new JobFactory() {
				@Override
				public Job createJob() {
					AbstractJob job = new AbstractJob('discreteRegisteredJob') {
						@Override
						public Collection<String> getStepNames() {
							return Collections.emptySet();
						}
						@Override
						public Step getStep(String stepName) {
							return null;
						}
						@Override
						protected void doExecute(JobExecution execution) {
							execution.setStatus(BatchStatus.COMPLETED);
						}
					};
					job.setJobRepository(jobRepository);
					return job;
				}
				@Override
				public String getJobName() {
					return 'discreteRegisteredJob';
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NamedJobConfigurationWithLocalJob {
		@Autowired
		private JobRepository jobRepository;
		@Bean
		Job discreteJob() {
			AbstractJob job = new AbstractJob('discreteLocalJob') {
				@Override
				public Collection<String> getStepNames() {
					return Collections.emptySet();
				}
				@Override
				public Step getStep(String stepName) {
					return null;
				}
				@Override
				protected void doExecute(JobExecution execution) {
					execution.setStatus(BatchStatus.COMPLETED);
				}
			};
			job.setJobRepository(this.jobRepository);
			return job;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleJobConfiguration {
		@Autowired
		private JobRepository jobRepository;
		@Bean
		Job discreteJob() {
			AbstractJob job = new AbstractJob('discreteLocalJob') {
				@Override
				public Collection<String> getStepNames() {
					return Collections.emptySet();
				}
				@Override
				public Step getStep(String stepName) {
					return null;
				}
				@Override
				protected void doExecute(JobExecution execution) {
					execution.setStatus(BatchStatus.COMPLETED);
				}
			};
			job.setJobRepository(this.jobRepository);
			return job;
		}
		@Bean
		Job job2() {
			return new Job() {
				@Override
				public String getName() {
					return 'discreteLocalJob2';
				}
				@Override
				public void execute(JobExecution execution) {
					execution.setStatus(BatchStatus.COMPLETED);
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JobConfiguration {
		@Autowired
		private JobRepository jobRepository;
		@Bean
		Job job() {
			AbstractJob job = new AbstractJob() {
				@Override
				public Collection<String> getStepNames() {
					return Collections.emptySet();
				}
				@Override
				public Step getStep(String stepName) {
					return null;
				}
				@Override
				protected void doExecute(JobExecution execution) {
					execution.setStatus(BatchStatus.COMPLETED);
				}
			};
			job.setJobRepository(this.jobRepository);
			return job;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomBatchDatabaseInitializerConfiguration {
		@Bean
		BatchDataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource, BatchProperties properties) {
			return new BatchDataSourceScriptDatabaseInitializer(dataSource, properties.getJdbc());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDatabaseInitializerConfiguration {
		@Bean
		DataSourceScriptDatabaseInitializer customInitializer(DataSource dataSource) {
			return new DataSourceScriptDatabaseInitializer(dataSource, new DatabaseInitializationSettings());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomBatchConfiguration extends DefaultBatchConfiguration {
	}
	@EnableBatchProcessing
	@Configuration(proxyBeanMethods = false)
	static class EnableBatchProcessingConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class ConversionServiceCustomizersConfiguration {
		@Bean
		@Order(1)
		BatchConversionServiceCustomizer batchConversionServiceCustomizer() {
			return mock(BatchConversionServiceCustomizer.class);
		}
		@Bean
		@Order(2)
		BatchConversionServiceCustomizer anotherBatchConversionServiceCustomizer() {
			return mock(BatchConversionServiceCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomExecutionContextConfiguration {
		@Bean
		ExecutionContextSerializer executionContextSerializer() {
			return new Jackson2ExecutionContextStringSerializer();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
class JobLauncherApplicationRunnerTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class, TransactionAutoConfiguration.class,
				DataSourceTransactionManagerAutoConfiguration.class))
		.withUserConfiguration(BatchConfiguration.class);
	@Test
	void basicExecution() {
		this.contextRunner.run((context) -> {
			JobLauncherApplicationRunnerContext jobLauncherContext = new JobLauncherApplicationRunnerContext(context);
			jobLauncherContext.executeJob(new JobParameters());
			assertThat(jobLauncherContext.jobInstances()).hasSize(1);
			jobLauncherContext.executeJob(new JobParametersBuilder().addLong('id', 1L).toJobParameters());
			assertThat(jobLauncherContext.jobInstances()).hasSize(2);
		});
	}
	@Test
	void incrementExistingExecution() {
		this.contextRunner.run((context) -> {
			JobLauncherApplicationRunnerContext jobLauncherContext = new JobLauncherApplicationRunnerContext(context);
			Job job = jobLauncherContext.configureJob().incrementer(new RunIdIncrementer()).build();
			jobLauncherContext.runner.execute(job, new JobParameters());
			jobLauncherContext.runner.execute(job, new JobParameters());
			assertThat(jobLauncherContext.jobInstances()).hasSize(2);
		});
	}
	@Test
	void retryFailedExecution() {
		this.contextRunner.run((context) -> {
			PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);
			JobLauncherApplicationRunnerContext jobLauncherContext = new JobLauncherApplicationRunnerContext(context);
			Job job = jobLauncherContext.jobBuilder()
				.start(jobLauncherContext.stepBuilder().tasklet(throwingTasklet(), transactionManager).build())
				.incrementer(new RunIdIncrementer())
				.build();
			jobLauncherContext.runner.execute(job, new JobParameters());
			jobLauncherContext.runner.execute(job, new JobParametersBuilder().addLong('run.id', 1L).toJobParameters());
			assertThat(jobLauncherContext.jobInstances()).hasSize(1);
		});
	}
	@Test
	void runDifferentInstances() {
		this.contextRunner.run((context) -> {
			PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);
			JobLauncherApplicationRunnerContext jobLauncherContext = new JobLauncherApplicationRunnerContext(context);
			Job job = jobLauncherContext.jobBuilder()
				.start(jobLauncherContext.stepBuilder().tasklet(throwingTasklet(), transactionManager).build())
				.build();
			// start a job instance
			JobParameters jobParameters = new JobParametersBuilder().addString('name', 'foo').toJobParameters();
			jobLauncherContext.runner.execute(job, jobParameters);
			assertThat(jobLauncherContext.jobInstances()).hasSize(1);
			// start a different job instance
			JobParameters otherJobParameters = new JobParametersBuilder().addString('name', 'bar').toJobParameters();
			jobLauncherContext.runner.execute(job, otherJobParameters);
			assertThat(jobLauncherContext.jobInstances()).hasSize(2);
		});
	}
	@Test
	void retryFailedExecutionOnNonRestartableJob() {
		this.contextRunner.run((context) -> {
			PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);
			JobLauncherApplicationRunnerContext jobLauncherContext = new JobLauncherApplicationRunnerContext(context);
			Job job = jobLauncherContext.jobBuilder()
				.preventRestart()
				.start(jobLauncherContext.stepBuilder().tasklet(throwingTasklet(), transactionManager).build())
				.incrementer(new RunIdIncrementer())
				.build();
			jobLauncherContext.runner.execute(job, new JobParameters());
			jobLauncherContext.runner.execute(job, new JobParameters());
			// A failed job that is not restartable does not re-use the job params of
			// the last execution, but creates a new job instance when running it again.
			assertThat(jobLauncherContext.jobInstances()).hasSize(2);
			assertThatExceptionOfType(JobRestartException.class).isThrownBy(() -> {
				// try to re-run a failed execution
				jobLauncherContext.runner.execute(job,
						new JobParametersBuilder().addLong('run.id', 1L).toJobParameters());
				fail('expected JobRestartException');
			}).withMessageContaining('JobInstance already exists and is not restartable');
		});
	}
	@Test
	void retryFailedExecutionWithNonIdentifyingParameters() {
		this.contextRunner.run((context) -> {
			PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);
			JobLauncherApplicationRunnerContext jobLauncherContext = new JobLauncherApplicationRunnerContext(context);
			Job job = jobLauncherContext.jobBuilder()
				.start(jobLauncherContext.stepBuilder().tasklet(throwingTasklet(), transactionManager).build())
				.incrementer(new RunIdIncrementer())
				.build();
			JobParameters jobParameters = new JobParametersBuilder().addLong('id', 1L, false)
				.addLong('foo', 2L, false)
				.toJobParameters();
			jobLauncherContext.runner.execute(job, jobParameters);
			assertThat(jobLauncherContext.jobInstances()).hasSize(1);
			// try to re-run a failed execution with non identifying parameters
			jobLauncherContext.runner.execute(job,
					new JobParametersBuilder(jobParameters).addLong('run.id', 1L).toJobParameters());
			assertThat(jobLauncherContext.jobInstances()).hasSize(1);
		});
	}
	private Tasklet throwingTasklet() {
		return (contribution, chunkContext) -> {
			throw new RuntimeException('Planned');
		};
	}
	static class JobLauncherApplicationRunnerContext {
		private final JobLauncherApplicationRunner runner;
		private final JobExplorer jobExplorer;
		private final JobBuilder jobBuilder;
		private final Job job;
		private final StepBuilder stepBuilder;
		private final Step step;
		JobLauncherApplicationRunnerContext(ApplicationContext context) {
			JobLauncher jobLauncher = context.getBean(JobLauncher.class);
			JobRepository jobRepository = context.getBean(JobRepository.class);
			PlatformTransactionManager transactionManager = context.getBean(PlatformTransactionManager.class);
			this.stepBuilder = new StepBuilder('step', jobRepository);
			this.step = this.stepBuilder.tasklet((contribution, chunkContext) -> null, transactionManager).build();
			this.jobBuilder = new JobBuilder('job', jobRepository);
			this.job = this.jobBuilder.start(this.step).build();
			this.jobExplorer = context.getBean(JobExplorer.class);
			this.runner = new JobLauncherApplicationRunner(jobLauncher, this.jobExplorer, jobRepository);
		}
		List<JobInstance> jobInstances() {
			return this.jobExplorer.getJobInstances('job', 0, 100);
		}
		void executeJob(JobParameters jobParameters) throws JobExecutionException {
			this.runner.execute(this.job, jobParameters);
		}
		JobBuilder jobBuilder() {
			return this.jobBuilder;
		}
		StepBuilder stepBuilder() {
			return this.stepBuilder;
		}
		SimpleJobBuilder configureJob() {
			return this.jobBuilder.start(this.step);
		}
	}
	@EnableBatchProcessing
	@Configuration(proxyBeanMethods = false)
	static class BatchConfiguration {
		private final DataSource dataSource;
		protected BatchConfiguration(DataSource dataSource) {
			this.dataSource = dataSource;
		}
		@Bean
		DataSourceScriptDatabaseInitializer batchDataSourceInitializer() {
			DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
			settings.setSchemaLocations(Arrays.asList('classpath:org/springframework/batch/core/schema-h2.sql'));
			return new DataSourceScriptDatabaseInitializer(this.dataSource, settings);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.batch;
/**
class JobExecutionExitCodeGeneratorTests {
	private final JobExecutionExitCodeGenerator generator = new JobExecutionExitCodeGenerator();
	@Test
	void testExitCodeForRunning() {
		this.generator.onApplicationEvent(new JobExecutionEvent(new JobExecution(0L)));
		assertThat(this.generator.getExitCode()).isOne();
	}
	@Test
	void testExitCodeForCompleted() {
		JobExecution execution = new JobExecution(0L);
		execution.setStatus(BatchStatus.COMPLETED);
		this.generator.onApplicationEvent(new JobExecutionEvent(execution));
		assertThat(this.generator.getExitCode()).isZero();
	}
	@Test
	void testExitCodeForFailed() {
		JobExecution execution = new JobExecution(0L);
		execution.setStatus(BatchStatus.FAILED);
		this.generator.onApplicationEvent(new JobExecutionEvent(execution));
		assertThat(this.generator.getExitCode()).isEqualTo(5);
	}
}
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
class Neo4jAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(Neo4jAutoConfiguration.class));
	@Test
	void driverNotConfiguredWithoutDriverApi() {
		this.contextRunner.withPropertyValues('spring.neo4j.uri=bolt://localhost:4711')
			.withClassLoader(new FilteredClassLoader(Driver.class))
			.run((ctx) -> assertThat(ctx).doesNotHaveBean(Driver.class));
	}
	@Test
	void driverShouldNotRequireUri() {
		this.contextRunner.run((ctx) -> assertThat(ctx).hasSingleBean(Driver.class));
	}
	@Test
	void driverShouldInvokeConfigBuilderCustomizers() {
		this.contextRunner.withPropertyValues('spring.neo4j.uri=bolt://localhost:4711')
			.withBean(ConfigBuilderCustomizer.class, () -> ConfigBuilder::withEncryption)
			.run((ctx) -> assertThat(ctx.getBean(Driver.class).isEncrypted()).isTrue());
	}
	@ParameterizedTest
	@ValueSource(strings = { 'bolt', 'neo4j' })
	void uriWithSimpleSchemeAreDetected(String scheme) {
		this.contextRunner.withPropertyValues('spring.neo4j.uri=' + scheme + '://localhost:4711').run((ctx) -> {
			assertThat(ctx).hasSingleBean(Driver.class);
			assertThat(ctx.getBean(Driver.class).isEncrypted()).isFalse();
		});
	}
	@ParameterizedTest
	@ValueSource(strings = { 'bolt+s', 'bolt+ssc', 'neo4j+s', 'neo4j+ssc' })
	void uriWithAdvancedSchemesAreDetected(String scheme) {
		this.contextRunner.withPropertyValues('spring.neo4j.uri=' + scheme + '://localhost:4711').run((ctx) -> {
			assertThat(ctx).hasSingleBean(Driver.class);
			Driver driver = ctx.getBean(Driver.class);
			assertThat(driver.isEncrypted()).isTrue();
		});
	}
	@ParameterizedTest
	@ValueSource(strings = { 'bolt+routing', 'bolt+x', 'neo4j+wth' })
	void uriWithInvalidSchemesAreDetected(String invalidScheme) {
		this.contextRunner.withPropertyValues('spring.neo4j.uri=' + invalidScheme + '://localhost:4711')
			.run((ctx) -> assertThat(ctx).hasFailed()
				.getFailure()
				.hasMessageContaining('"%s" is not a supported scheme.', invalidScheme));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesNeo4jConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(Neo4jConnectionDetails.class, () -> new Neo4jConnectionDetails() {
			@Override
			public URI getUri() {
				return URI.create('bolt+ssc://localhost:12345');
			}
		}).run((context) -> {
			assertThat(context).hasSingleBean(Driver.class)
				.hasSingleBean(Neo4jConnectionDetails.class)
				.doesNotHaveBean(PropertiesNeo4jConnectionDetails.class);
			Driver driver = context.getBean(Driver.class);
			assertThat(driver.isEncrypted()).isTrue();
		});
	}
	@Test
	void connectionTimeout() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.setConnectionTimeout(Duration.ofMillis(500));
		assertThat(mapDriverConfig(properties).connectionTimeoutMillis()).isEqualTo(500);
	}
	@Test
	void maxTransactionRetryTime() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.setMaxTransactionRetryTime(Duration.ofSeconds(2));
		assertThat(mapDriverConfig(properties).maxTransactionRetryTimeMillis()).isEqualTo(2000L);
	}
	@Test
	void uriShouldDefaultToLocalhost() {
		assertThat(new PropertiesNeo4jConnectionDetails(new Neo4jProperties(), null).getUri())
			.isEqualTo(URI.create('bolt://localhost:7687'));
	}
	@Test
	void determineServerUriWithCustomUriShouldOverrideDefault() {
		URI customUri = URI.create('bolt://localhost:4242');
		Neo4jProperties properties = new Neo4jProperties();
		properties.setUri(customUri);
		assertThat(new PropertiesNeo4jConnectionDetails(properties, null).getUri()).isEqualTo(customUri);
	}
	@Test
	void authenticationShouldDefaultToNone() {
		assertThat(new PropertiesNeo4jConnectionDetails(new Neo4jProperties(), null).getAuthToken())
			.isEqualTo(AuthTokens.none());
	}
	@Test
	void authenticationWithUsernameShouldEnableBasicAuth() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getAuthentication().setUsername('Farin');
		properties.getAuthentication().setPassword('Urlaub');
		PropertiesNeo4jConnectionDetails connectionDetails = new PropertiesNeo4jConnectionDetails(properties, null);
		assertThat(connectionDetails.getAuthToken()).isEqualTo(AuthTokens.basic('Farin', 'Urlaub'));
		assertThat(connectionDetails.getAuthTokenManager()).isNull();
	}
	@Test
	void authenticationWithUsernameAndRealmShouldEnableBasicAuth() {
		Neo4jProperties properties = new Neo4jProperties();
		Authentication authentication = properties.getAuthentication();
		authentication.setUsername('Farin');
		authentication.setPassword('Urlaub');
		authentication.setRealm('Test Realm');
		PropertiesNeo4jConnectionDetails connectionDetails = new PropertiesNeo4jConnectionDetails(properties, null);
		assertThat(connectionDetails.getAuthToken()).isEqualTo(AuthTokens.basic('Farin', 'Urlaub', 'Test Realm'));
		assertThat(connectionDetails.getAuthTokenManager()).isNull();
	}
	@Test
	void authenticationWithAuthTokenManagerAndUsernameShouldProvideAuthTokenManger() {
		Neo4jProperties properties = new Neo4jProperties();
		Authentication authentication = properties.getAuthentication();
		authentication.setUsername('Farin');
		authentication.setPassword('Urlaub');
		authentication.setRealm('Test Realm');
		assertThat(new PropertiesNeo4jConnectionDetails(properties,
				AuthTokenManagers.bearer(
						() -> AuthTokens.basic('username', 'password').expiringAt(System.currentTimeMillis() + 5000)))
			.getAuthTokenManager()).isNotNull();
	}
	@Test
	void authenticationWithKerberosTicketShouldEnableKerberos() {
		Neo4jProperties properties = new Neo4jProperties();
		Authentication authentication = properties.getAuthentication();
		authentication.setKerberosTicket('AABBCCDDEE');
		assertThat(new PropertiesNeo4jConnectionDetails(properties, null).getAuthToken())
			.isEqualTo(AuthTokens.kerberos('AABBCCDDEE'));
	}
	@Test
	void authenticationWithBothUsernameAndKerberosShouldNotBeAllowed() {
		Neo4jProperties properties = new Neo4jProperties();
		Authentication authentication = properties.getAuthentication();
		authentication.setUsername('Farin');
		authentication.setKerberosTicket('AABBCCDDEE');
		assertThatIllegalStateException()
			.isThrownBy(() -> new PropertiesNeo4jConnectionDetails(properties, null).getAuthToken())
			.withMessage('Cannot specify both username ("Farin") and kerberos ticket ("AABBCCDDEE")');
	}
	@Test
	void poolWithMetricsEnabled() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getPool().setMetricsEnabled(true);
		assertThat(mapDriverConfig(properties).isMetricsEnabled()).isTrue();
	}
	@Test
	void poolWithLogLeakedSessions() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getPool().setLogLeakedSessions(true);
		assertThat(mapDriverConfig(properties).logLeakedSessions()).isTrue();
	}
	@Test
	void poolWithMaxConnectionPoolSize() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getPool().setMaxConnectionPoolSize(4711);
		assertThat(mapDriverConfig(properties).maxConnectionPoolSize()).isEqualTo(4711);
	}
	@Test
	void poolWithIdleTimeBeforeConnectionTest() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getPool().setIdleTimeBeforeConnectionTest(Duration.ofSeconds(23));
		assertThat(mapDriverConfig(properties).idleTimeBeforeConnectionTest()).isEqualTo(23000);
	}
	@Test
	void poolWithMaxConnectionLifetime() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getPool().setMaxConnectionLifetime(Duration.ofSeconds(30));
		assertThat(mapDriverConfig(properties).maxConnectionLifetimeMillis()).isEqualTo(30000);
	}
	@Test
	void poolWithConnectionAcquisitionTimeout() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getPool().setConnectionAcquisitionTimeout(Duration.ofSeconds(5));
		assertThat(mapDriverConfig(properties).connectionAcquisitionTimeoutMillis()).isEqualTo(5000);
	}
	@Test
	void securityWithEncrypted() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getSecurity().setEncrypted(true);
		assertThat(mapDriverConfig(properties).encrypted()).isTrue();
	}
	@Test
	void securityWithTrustSignedCertificates() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getSecurity().setTrustStrategy(TrustStrategy.TRUST_SYSTEM_CA_SIGNED_CERTIFICATES);
		assertThat(mapDriverConfig(properties).trustStrategy().strategy())
			.isEqualTo(Config.TrustStrategy.Strategy.TRUST_SYSTEM_CA_SIGNED_CERTIFICATES);
	}
	@Test
	void securityWithTrustAllCertificates() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getSecurity().setTrustStrategy(TrustStrategy.TRUST_ALL_CERTIFICATES);
		assertThat(mapDriverConfig(properties).trustStrategy().strategy())
			.isEqualTo(Config.TrustStrategy.Strategy.TRUST_ALL_CERTIFICATES);
	}
	@Test
	void securityWitHostnameVerificationEnabled() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getSecurity().setTrustStrategy(TrustStrategy.TRUST_ALL_CERTIFICATES);
		properties.getSecurity().setHostnameVerificationEnabled(true);
		assertThat(mapDriverConfig(properties).trustStrategy().isHostnameVerificationEnabled()).isTrue();
	}
	@Test
	void securityWithCustomCertificates(@TempDir File directory) throws IOException {
		File certFile = new File(directory, 'neo4j-driver.cert');
		assertThat(certFile.createNewFile()).isTrue();
		Neo4jProperties properties = new Neo4jProperties();
		properties.getSecurity().setTrustStrategy(TrustStrategy.TRUST_CUSTOM_CA_SIGNED_CERTIFICATES);
		properties.getSecurity().setCertFile(certFile);
		Config.TrustStrategy trustStrategy = mapDriverConfig(properties).trustStrategy();
		assertThat(trustStrategy.strategy())
			.isEqualTo(Config.TrustStrategy.Strategy.TRUST_CUSTOM_CA_SIGNED_CERTIFICATES);
		assertThat(trustStrategy.certFiles()).containsOnly(certFile);
	}
	@Test
	void securityWithCustomCertificatesShouldFailWithoutCertificate() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getSecurity().setTrustStrategy(TrustStrategy.TRUST_CUSTOM_CA_SIGNED_CERTIFICATES);
		assertThatExceptionOfType(InvalidConfigurationPropertyValueException.class)
			.isThrownBy(() -> mapDriverConfig(properties))
			.withMessage(
					'Property spring.neo4j.security.trust-strategy with value "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES" is invalid: Configured trust strategy requires a certificate file.');
	}
	@Test
	void securityWithTrustSystemCertificates() {
		Neo4jProperties properties = new Neo4jProperties();
		properties.getSecurity().setTrustStrategy(TrustStrategy.TRUST_SYSTEM_CA_SIGNED_CERTIFICATES);
		assertThat(mapDriverConfig(properties).trustStrategy().strategy())
			.isEqualTo(Config.TrustStrategy.Strategy.TRUST_SYSTEM_CA_SIGNED_CERTIFICATES);
	}
	@Test
	void driverConfigShouldBeConfiguredToUseUseSpringJclLogging() {
		assertThat(mapDriverConfig(new Neo4jProperties()).logging()).isInstanceOf(Neo4jSpringJclLogging.class);
	}
	private Config mapDriverConfig(Neo4jProperties properties, ConfigBuilderCustomizer... customizers) {
		return new Neo4jAutoConfiguration().mapDriverConfig(properties,
				new PropertiesNeo4jConnectionDetails(properties, null), Arrays.asList(customizers));
	}
}
/*
package org.springframework.boot.autoconfigure.neo4j;
/**
class Neo4jPropertiesTests {
	@Test
	void poolSettingsHaveConsistentDefaults() {
		Config defaultConfig = Config.defaultConfig();
		Pool pool = new Neo4jProperties().getPool();
		assertThat(pool.isMetricsEnabled()).isEqualTo(defaultConfig.isMetricsEnabled());
		assertThat(pool.isLogLeakedSessions()).isEqualTo(defaultConfig.logLeakedSessions());
		assertThat(pool.getMaxConnectionPoolSize()).isEqualTo(defaultConfig.maxConnectionPoolSize());
		assertDuration(pool.getIdleTimeBeforeConnectionTest(), defaultConfig.idleTimeBeforeConnectionTest());
		assertDuration(pool.getMaxConnectionLifetime(), defaultConfig.maxConnectionLifetimeMillis());
		assertDuration(pool.getConnectionAcquisitionTimeout(), defaultConfig.connectionAcquisitionTimeoutMillis());
	}
	@Test
	void securitySettingsHaveConsistentDefaults() {
		Config defaultConfig = Config.defaultConfig();
		Neo4jProperties properties = new Neo4jProperties();
		assertThat(properties.getSecurity().isEncrypted()).isEqualTo(defaultConfig.encrypted());
		assertThat(properties.getSecurity().getTrustStrategy().name())
			.isEqualTo(defaultConfig.trustStrategy().strategy().name());
		assertThat(properties.getSecurity().isHostnameVerificationEnabled())
			.isEqualTo(defaultConfig.trustStrategy().isHostnameVerificationEnabled());
	}
	@Test
	void driverSettingsHaveConsistentDefaults() {
		Config defaultConfig = Config.defaultConfig();
		Neo4jProperties properties = new Neo4jProperties();
		assertDuration(properties.getConnectionTimeout(), defaultConfig.connectionTimeoutMillis());
		assertDuration(properties.getMaxTransactionRetryTime(), RetrySettings.DEFAULT.maxRetryTimeMs());
	}
	private static void assertDuration(Duration duration, long expectedValueInMillis) {
		if (expectedValueInMillis == org.neo4j.driver.internal.async.pool.PoolSettings.NOT_CONFIGURED) {
			assertThat(duration).isNull();
		}
		else {
			assertThat(duration.toMillis()).isEqualTo(expectedValueInMillis);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.admin;
/**
class SpringApplicationAdminJmxAutoConfigurationTests {
	private static final String ENABLE_ADMIN_PROP = 'spring.application.admin.enabled=true';
	private static final String DEFAULT_JMX_NAME = 'org.springframework.boot:type=Admin,name=SpringApplication';
	private final MBeanServer server = ManagementFactory.getPlatformMBeanServer();
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(SpringApplicationAdminJmxAutoConfiguration.class));
	@Test
	void notRegisteredWhenThereAreNoMBeanExporter() {
		this.contextRunner.withPropertyValues(ENABLE_ADMIN_PROP).run((context) -> {
			ObjectName objectName = createDefaultObjectName();
			ObjectInstance objectInstance = this.server.getObjectInstance(objectName);
			assertThat(objectInstance).as('Lifecycle bean should have been registered').isNotNull();
		});
	}
	@Test
	void notRegisteredByDefaultWhenThereAreMultipleMBeanExporters() {
		this.contextRunner.withUserConfiguration(MultipleMBeanExportersConfiguration.class)
			.run((context) -> assertThatExceptionOfType(InstanceNotFoundException.class)
				.isThrownBy(() -> this.server.getObjectInstance(createDefaultObjectName())));
	}
	@Test
	void registeredWithPropertyWhenThereAreMultipleMBeanExporters() {
		this.contextRunner.withUserConfiguration(MultipleMBeanExportersConfiguration.class)
			.withPropertyValues(ENABLE_ADMIN_PROP)
			.run((context) -> {
				ObjectName objectName = createDefaultObjectName();
				ObjectInstance objectInstance = this.server.getObjectInstance(objectName);
				assertThat(objectInstance).as('Lifecycle bean should have been registered').isNotNull();
			});
	}
	@Test
	void registerWithCustomJmxNameWhenThereAreMultipleMBeanExporters() {
		String customJmxName = 'org.acme:name=FooBar';
		this.contextRunner.withUserConfiguration(MultipleMBeanExportersConfiguration.class)
			.withSystemProperties('spring.application.admin.jmx-name=' + customJmxName)
			.withPropertyValues(ENABLE_ADMIN_PROP)
			.run((context) -> {
				try {
					this.server.getObjectInstance(createObjectName(customJmxName));
				}
				catch (InstanceNotFoundException ex) {
					fail('Admin MBean should have been exposed with custom name');
				}
				assertThatExceptionOfType(InstanceNotFoundException.class)
					.isThrownBy(() -> this.server.getObjectInstance(createDefaultObjectName()));
			});
	}
	@Test
	void registerWithSimpleWebApp() throws Exception {
		try (ConfigurableApplicationContext context = new SpringApplicationBuilder()
			.sources(ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
					MultipleMBeanExportersConfiguration.class, SpringApplicationAdminJmxAutoConfiguration.class)
			.run('--' + ENABLE_ADMIN_PROP, '--server.port=0')) {
			assertThat(context).isInstanceOf(ServletWebServerApplicationContext.class);
			assertThat(this.server.getAttribute(createDefaultObjectName(), 'EmbeddedWebApplication'))
				.isEqualTo(Boolean.TRUE);
			int expected = ((ServletWebServerApplicationContext) context).getWebServer().getPort();
			String actual = getProperty(createDefaultObjectName(), 'local.server.port');
			assertThat(actual).isEqualTo(String.valueOf(expected));
		}
	}
	@Test
	void onlyRegisteredOnceWhenThereIsAChildContext() {
		SpringApplicationBuilder parentBuilder = new SpringApplicationBuilder().web(WebApplicationType.NONE)
			.sources(MultipleMBeanExportersConfiguration.class, SpringApplicationAdminJmxAutoConfiguration.class);
		SpringApplicationBuilder childBuilder = parentBuilder
			.child(MultipleMBeanExportersConfiguration.class, SpringApplicationAdminJmxAutoConfiguration.class)
			.web(WebApplicationType.NONE);
		try (ConfigurableApplicationContext parent = parentBuilder.run('--' + ENABLE_ADMIN_PROP);
				ConfigurableApplicationContext child = childBuilder.run('--' + ENABLE_ADMIN_PROP)) {
			BeanFactoryUtils.beanOfType(parent.getBeanFactory(), SpringApplicationAdminMXBeanRegistrar.class);
			assertThatExceptionOfType(NoSuchBeanDefinitionException.class).isThrownBy(() -> BeanFactoryUtils
				.beanOfType(child.getBeanFactory(), SpringApplicationAdminMXBeanRegistrar.class));
		}
	}
	private ObjectName createDefaultObjectName() {
		return createObjectName(DEFAULT_JMX_NAME);
	}
	private ObjectName createObjectName(String jmxName) {
		try {
			return new ObjectName(jmxName);
		}
		catch (MalformedObjectNameException ex) {
			throw new IllegalStateException('Invalid jmx name ' + jmxName, ex);
		}
	}
	private String getProperty(ObjectName objectName, String key) throws Exception {
		return (String) this.server.invoke(objectName, 'getProperty', new Object[] { key },
				new String[] { String.class.getName() });
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleMBeanExportersConfiguration {
		@Bean
		MBeanExporter firstMBeanExporter() {
			return new MBeanExporter();
		}
		@Bean
		MBeanExporter secondMBeanExporter() {
			return new MBeanExporter();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.aop;
/**
@ClassPathExclusions('aspectjweaver*.jar')
class NonAspectJAopAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(AopAutoConfiguration.class));
	@Test
	void whenAspectJIsAbsentAndProxyTargetClassIsEnabledProxyCreatorBeanIsDefined() {
		this.contextRunner.run((context) -> {
			BeanDefinition autoProxyCreator = context.getBeanFactory()
				.getBeanDefinition(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME);
			assertThat(autoProxyCreator.getPropertyValues().get('proxyTargetClass')).isEqualTo(Boolean.TRUE);
		});
	}
	@Test
	void whenAspectJIsAbsentAndProxyTargetClassIsDisabledNoProxyCreatorBeanIsDefined() {
		this.contextRunner.withPropertyValues('spring.aop.proxy-target-class:false')
			.run((context) -> assertThat(context).doesNotHaveBean(AopConfigUtils.AUTO_PROXY_CREATOR_BEAN_NAME));
	}
}
/*
package org.springframework.boot.autoconfigure.aop;
/**
class AopAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(AopAutoConfiguration.class));
	@Test
	void aopDisabled() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.aop.auto:false')
			.run((context) -> {
				TestAspect aspect = context.getBean(TestAspect.class);
				assertThat(aspect.isCalled()).isFalse();
				TestBean bean = context.getBean(TestBean.class);
				bean.foo();
				assertThat(aspect.isCalled()).isFalse();
			});
	}
	@Test
	void aopWithDefaultSettings() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run(proxyTargetClassEnabled());
	}
	@Test
	void aopWithEnabledProxyTargetClass() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.aop.proxy-target-class:true')
			.run(proxyTargetClassEnabled());
	}
	@Test
	void aopWithDisabledProxyTargetClass() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.aop.proxy-target-class:false')
			.run(proxyTargetClassDisabled());
	}
	@Test
	void customConfigurationWithProxyTargetClassDefaultDoesNotDisableProxying() {
		this.contextRunner.withUserConfiguration(CustomTestConfiguration.class).run(proxyTargetClassEnabled());
	}
	@Test
	void whenGlobalMethodSecurityIsEnabledAndAspectJIsNotAvailableThenClassProxyingIsStillUsedByDefault() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(Advice.class))
			.withUserConfiguration(ExampleController.class, EnableGlobalMethodSecurityConfiguration.class)
			.run((context) -> assertThat(context).getBean(ExampleController.class).matches(AopUtils::isCglibProxy));
	}
	private ContextConsumer<AssertableApplicationContext> proxyTargetClassEnabled() {
		return (context) -> {
			TestAspect aspect = context.getBean(TestAspect.class);
			assertThat(aspect.isCalled()).isFalse();
			TestBean bean = context.getBean(TestBean.class);
			bean.foo();
			assertThat(aspect.isCalled()).isTrue();
		};
	}
	private ContextConsumer<AssertableApplicationContext> proxyTargetClassDisabled() {
		return (context) -> {
			TestAspect aspect = context.getBean(TestAspect.class);
			assertThat(aspect.isCalled()).isFalse();
			TestInterface bean = context.getBean(TestInterface.class);
			bean.foo();
			assertThat(aspect.isCalled()).isTrue();
			assertThat(context).doesNotHaveBean(TestBean.class);
		};
	}
	@EnableAspectJAutoProxy
	@Configuration(proxyBeanMethods = false)
	@Import(TestConfiguration.class)
	static class CustomTestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		TestAspect aspect() {
			return new TestAspect();
		}
		@Bean
		TestInterface bean() {
			return new TestBean();
		}
	}
	static class TestBean implements TestInterface {
		@Override
		public void foo() {
		}
	}
	@Aspect
	static class TestAspect {
		private boolean called;
		boolean isCalled() {
			return this.called;
		}
		@Before('execution(* foo(..))')
		void before() {
			this.called = true;
		}
	}
	interface TestInterface {
		void foo();
	}
	@EnableMethodSecurity(prePostEnabled = true)
	@Configuration(proxyBeanMethods = false)
	static class EnableGlobalMethodSecurityConfiguration {
	}
	public static class ExampleController implements TestInterface {
		@RequestMapping('/test')
		@PreAuthorize('true')
		String demo() {
			return 'test';
		}
		@Override
		public void foo() {
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(TestAutoConfigurationPackageRegistrar.class)
public @interface TestAutoConfigurationPackage {
	Class<?> value();
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
class JooqAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JooqAutoConfiguration.class))
		.withPropertyValues('spring.datasource.name:jooqtest');
	@Test
	void noDataSource() {
		this.contextRunner.run((context) -> assertThat(context.getBeansOfType(DSLContext.class)).isEmpty());
	}
	@Test
	void jooqWithoutTx() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean(PlatformTransactionManager.class);
			assertThat(context).doesNotHaveBean(SpringTransactionProvider.class);
			DSLContext dsl = context.getBean(DSLContext.class);
			dsl.execute('create table jooqtest (name varchar(255) primary key);');
			dsl.transaction(new AssertFetch(dsl, 'select count(*) as total from jooqtest;', '0'));
			dsl.transaction(new ExecuteSql(dsl, 'insert into jooqtest (name) values ("foo");'));
			dsl.transaction(new AssertFetch(dsl, 'select count(*) as total from jooqtest;', '1'));
			assertThatExceptionOfType(DataIntegrityViolationException.class)
				.isThrownBy(() -> dsl.transaction(new ExecuteSql(dsl, 'insert into jooqtest (name) values ("bar");',
						'insert into jooqtest (name) values ("foo");')));
			dsl.transaction(new AssertFetch(dsl, 'select count(*) as total from jooqtest;', '2'));
		});
	}
	@Test
	void jooqWithTx() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class, TxManagerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(PlatformTransactionManager.class);
				DSLContext dsl = context.getBean(DSLContext.class);
				assertThat(dsl.configuration().dialect()).isEqualTo(SQLDialect.HSQLDB);
				dsl.execute('create table jooqtest_tx (name varchar(255) primary key);');
				dsl.transaction(new AssertFetch(dsl, 'select count(*) as total from jooqtest_tx;', '0'));
				dsl.transaction(new ExecuteSql(dsl, 'insert into jooqtest_tx (name) values ("foo");'));
				dsl.transaction(new AssertFetch(dsl, 'select count(*) as total from jooqtest_tx;', '1'));
				assertThatExceptionOfType(DataIntegrityViolationException.class)
					.isThrownBy(() -> dsl.transaction(new ExecuteSql(dsl, 'insert into jooqtest (name) values ("bar");',
							'insert into jooqtest (name) values ("foo");')));
				dsl.transaction(new AssertFetch(dsl, 'select count(*) as total from jooqtest_tx;', '1'));
			});
	}
	@Test
	void jooqWithDefaultConnectionProvider() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class).run((context) -> {
			DSLContext dsl = context.getBean(DSLContext.class);
			ConnectionProvider connectionProvider = dsl.configuration().connectionProvider();
			assertThat(connectionProvider).isInstanceOf(DataSourceConnectionProvider.class);
			DataSource connectionProviderDataSource = ((DataSourceConnectionProvider) connectionProvider).dataSource();
			assertThat(connectionProviderDataSource).isInstanceOf(TransactionAwareDataSourceProxy.class);
		});
	}
	@Test
	void jooqWithDefaultTransactionProvider() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class, TxManagerConfiguration.class)
			.run((context) -> {
				DSLContext dsl = context.getBean(DSLContext.class);
				TransactionProvider expectedTransactionProvider = context.getBean(TransactionProvider.class);
				TransactionProvider transactionProvider = dsl.configuration().transactionProvider();
				assertThat(transactionProvider).isSameAs(expectedTransactionProvider);
			});
	}
	@Test
	void jooqWithDefaultExecuteListenerProvider() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class).run((context) -> {
			DSLContext dsl = context.getBean(DSLContext.class);
			assertThat(dsl.configuration().executeListenerProviders()).hasSize(1);
		});
	}
	@Test
	void jooqWithSeveralExecuteListenerProviders() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class, TestExecuteListenerProvider.class)
			.run((context) -> {
				DSLContext dsl = context.getBean(DSLContext.class);
				ExecuteListenerProvider[] executeListenerProviders = dsl.configuration().executeListenerProviders();
				assertThat(executeListenerProviders).hasSize(2);
				assertThat(executeListenerProviders[0]).isInstanceOf(DefaultExecuteListenerProvider.class);
				assertThat(executeListenerProviders[1]).isInstanceOf(TestExecuteListenerProvider.class);
			});
	}
	@Test
	void dslContextWithConfigurationCustomizersAreApplied() {
		ConverterProvider converterProvider = mock(ConverterProvider.class);
		CharsetProvider charsetProvider = mock(CharsetProvider.class);
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class)
			.withBean('configurationCustomizer1', DefaultConfigurationCustomizer.class,
					() -> (configuration) -> configuration.set(converterProvider))
			.withBean('configurationCustomizer2', DefaultConfigurationCustomizer.class,
					() -> (configuration) -> configuration.set(charsetProvider))
			.run((context) -> {
				DSLContext dsl = context.getBean(DSLContext.class);
				assertThat(dsl.configuration().converterProvider()).isSameAs(converterProvider);
				assertThat(dsl.configuration().charsetProvider()).isSameAs(charsetProvider);
			});
	}
	@Test
	void relaxedBindingOfSqlDialect() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class)
			.withPropertyValues('spring.jooq.sql-dialect:PoSTGrES')
			.run((context) -> assertThat(context.getBean(org.jooq.Configuration.class).dialect())
				.isEqualTo(SQLDialect.POSTGRES));
	}
	@Test
	void transactionProviderBacksOffOnExistingTransactionProvider() {
		this.contextRunner
			.withUserConfiguration(JooqDataSourceConfiguration.class, CustomTransactionProviderConfiguration.class)
			.run((context) -> {
				TransactionProvider transactionProvider = context.getBean(TransactionProvider.class);
				assertThat(transactionProvider).isInstanceOf(CustomTransactionProvider.class);
				DSLContext dsl = context.getBean(DSLContext.class);
				assertThat(dsl.configuration().transactionProvider()).isSameAs(transactionProvider);
			});
	}
	@Test
	void jooqExceptionTranslatorProviderFromConfigurationCustomizerOverridesJooqExceptionTranslatorBean() {
		this.contextRunner
			.withUserConfiguration(JooqDataSourceConfiguration.class, CustomJooqExceptionTranslatorConfiguration.class)
			.run((context) -> {
				assertThat(context.getBean(ExceptionTranslatorExecuteListener.class))
					.isInstanceOf(CustomJooqExceptionTranslator.class);
				assertThat(context.getBean(DefaultExecuteListenerProvider.class).provide())
					.isInstanceOf(CustomJooqExceptionTranslator.class);
			});
	}
	@Test
	void jooqWithDefaultJooqExceptionTranslator() {
		this.contextRunner.withUserConfiguration(JooqDataSourceConfiguration.class).run((context) -> {
			ExceptionTranslatorExecuteListener translator = context.getBean(ExceptionTranslatorExecuteListener.class);
			assertThat(translator).isInstanceOf(DefaultExceptionTranslatorExecuteListener.class);
		});
	}
	@Test
	void transactionProviderFromConfigurationCustomizerOverridesTransactionProviderBean() {
		this.contextRunner
			.withUserConfiguration(JooqDataSourceConfiguration.class, TxManagerConfiguration.class,
					CustomTransactionProviderFromCustomizerConfiguration.class)
			.run((context) -> {
				TransactionProvider transactionProvider = context.getBean(TransactionProvider.class);
				assertThat(transactionProvider).isInstanceOf(SpringTransactionProvider.class);
				DSLContext dsl = context.getBean(DSLContext.class);
				assertThat(dsl.configuration().transactionProvider()).isInstanceOf(CustomTransactionProvider.class);
			});
	}
	@Test
	void autoConfiguredJooqConfigurationCanBeUsedToCreateCustomDslContext() {
		this.contextRunner.withUserConfiguration(CustomDslContextConfiguration.class, JooqDataSourceConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(DSLContext.class).hasBean('customDslContext'));
	}
	static class AssertFetch implements TransactionalRunnable {
		private final DSLContext dsl;
		private final String sql;
		private final String expected;
		AssertFetch(DSLContext dsl, String sql, String expected) {
			this.dsl = dsl;
			this.sql = sql;
			this.expected = expected;
		}
		@Override
		public void run(org.jooq.Configuration configuration) {
			assertThat(this.dsl.fetch(this.sql).getValue(0, 0)).hasToString(this.expected);
		}
	}
	static class ExecuteSql implements TransactionalRunnable {
		private final DSLContext dsl;
		private final String[] sql;
		ExecuteSql(DSLContext dsl, String... sql) {
			this.dsl = dsl;
			this.sql = sql;
		}
		@Override
		public void run(org.jooq.Configuration configuration) {
			for (String statement : this.sql) {
				this.dsl.execute(statement);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JooqDataSourceConfiguration {
		@Bean
		DataSource jooqDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:jooqtest').username('sa').build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTransactionProviderConfiguration {
		@Bean
		TransactionProvider transactionProvider() {
			return new CustomTransactionProvider();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomJooqExceptionTranslatorConfiguration {
		@Bean
		ExceptionTranslatorExecuteListener jooqExceptionTranslator() {
			return new CustomJooqExceptionTranslator();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomTransactionProviderFromCustomizerConfiguration {
		@Bean
		DefaultConfigurationCustomizer transactionProviderCustomizer() {
			return (configuration) -> configuration.setTransactionProvider(new CustomTransactionProvider());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TxManagerConfiguration {
		@Bean
		PlatformTransactionManager transactionManager(DataSource dataSource) {
			return new DataSourceTransactionManager(dataSource);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDslContextConfiguration {
		@Bean
		DSLContext customDslContext(org.jooq.Configuration configuration) {
			return new DefaultDSLContext(configuration);
		}
	}
	@Order(100)
	static class TestExecuteListenerProvider implements ExecuteListenerProvider {
		@Override
		public ExecuteListener provide() {
			return null;
		}
	}
	static class CustomTransactionProvider implements TransactionProvider {
		@Override
		public void begin(TransactionContext ctx) {
		}
		@Override
		public void commit(TransactionContext ctx) {
		}
		@Override
		public void rollback(TransactionContext ctx) {
		}
	}
	static class CustomJooqExceptionTranslator implements ExceptionTranslatorExecuteListener {
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
class DefaultExceptionTranslatorExecuteListenerTests {
	private final ExceptionTranslatorExecuteListener listener = new DefaultExceptionTranslatorExecuteListener();
	@Test
	void createWhenTranslatorFactoryIsNullThrowsException() {
		assertThatIllegalArgumentException()
			.isThrownBy(() -> new DefaultExceptionTranslatorExecuteListener(
					(Function<ExecuteContext, SQLExceptionTranslator>) null))
			.withMessage('TranslatorFactory must not be null');
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource
	void exceptionTranslatesSqlExceptions(SQLDialect dialect, SQLException sqlException) {
		ExecuteContext context = mockContext(dialect, sqlException);
		this.listener.exception(context);
		then(context).should().exception(assertArg((ex) -> assertThat(ex).isInstanceOf(BadSqlGrammarException.class)));
	}
	@Test
	void exceptionWhenExceptionCannotBeTranslatedDoesNotCallExecuteContextException() {
		ExecuteContext context = mockContext(SQLDialect.POSTGRES, new SQLException(null, null, 123456789));
		this.listener.exception(context);
		then(context).should(never()).exception(any());
	}
	@Test
	void exceptionWhenHasCustomTranslatorFactory() {
		SQLExceptionTranslator translator = BadSqlGrammarException::new;
		ExceptionTranslatorExecuteListener listener = new DefaultExceptionTranslatorExecuteListener(
				(context) -> translator);
		SQLException sqlException = sqlException(123);
		ExecuteContext context = mockContext(SQLDialect.DUCKDB, sqlException);
		listener.exception(context);
		then(context).should().exception(assertArg((ex) -> assertThat(ex).isInstanceOf(BadSqlGrammarException.class)));
	}
	private ExecuteContext mockContext(SQLDialect dialect, SQLException sqlException) {
		ExecuteContext context = mock(ExecuteContext.class);
		Configuration configuration = mock(Configuration.class);
		given(context.configuration()).willReturn(configuration);
		given(configuration.dialect()).willReturn(dialect);
		given(context.sqlException()).willReturn(sqlException);
		return context;
	}
	static Object[] exceptionTranslatesSqlExceptions() {
		return new Object[] { new Object[] { SQLDialect.DERBY, sqlException('42802') },
				new Object[] { SQLDialect.H2, sqlException(42000) },
				new Object[] { SQLDialect.HSQLDB, sqlException(-22) },
				new Object[] { SQLDialect.MARIADB, sqlException(1054) },
				new Object[] { SQLDialect.MYSQL, sqlException(1054) },
				new Object[] { SQLDialect.POSTGRES, sqlException('03000') },
				new Object[] { SQLDialect.SQLITE, sqlException('21000') } };
	}
	private static SQLException sqlException(String sqlState) {
		return new SQLException(null, sqlState);
	}
	private static SQLException sqlException(int vendorCode) {
		return new SQLException(null, null, vendorCode);
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
class SqlDialectLookupTests {
	@Test
	void getSqlDialectWhenDataSourceIsNullShouldReturnDefault() {
		assertThat(SqlDialectLookup.getDialect(null)).isEqualTo(SQLDialect.DEFAULT);
	}
	@Test
	void getSqlDialectWhenDataSourceIsUnknownShouldReturnDefault() throws Exception {
		testGetSqlDialect('jdbc:idontexist:', SQLDialect.DEFAULT);
	}
	@Test
	void getSqlDialectWhenDerbyShouldReturnDerby() throws Exception {
		testGetSqlDialect('jdbc:derby:', SQLDialect.DERBY);
	}
	@Test
	void getSqlDialectWhenH2ShouldReturnH2() throws Exception {
		testGetSqlDialect('jdbc:h2:', SQLDialect.H2);
	}
	@Test
	void getSqlDialectWhenHsqldbShouldReturnHsqldb() throws Exception {
		testGetSqlDialect('jdbc:hsqldb:', SQLDialect.HSQLDB);
	}
	@Test
	void getSqlDialectWhenMysqlShouldReturnMysql() throws Exception {
		testGetSqlDialect('jdbc:mysql:', SQLDialect.MYSQL);
	}
	@Test
	void getSqlDialectWhenOracleShouldReturnDefault() throws Exception {
		testGetSqlDialect('jdbc:oracle:', SQLDialect.DEFAULT);
	}
	@Test
	void getSqlDialectWhenPostgresShouldReturnPostgres() throws Exception {
		testGetSqlDialect('jdbc:postgresql:', SQLDialect.POSTGRES);
	}
	@Test
	void getSqlDialectWhenSqlserverShouldReturnDefault() throws Exception {
		testGetSqlDialect('jdbc:sqlserver:', SQLDialect.DEFAULT);
	}
	@Test
	void getSqlDialectWhenDb2ShouldReturnDefault() throws Exception {
		testGetSqlDialect('jdbc:db2:', SQLDialect.DEFAULT);
	}
	@Test
	void getSqlDialectWhenInformixShouldReturnDefault() throws Exception {
		testGetSqlDialect('jdbc:informix-sqli:', SQLDialect.DEFAULT);
	}
	private void testGetSqlDialect(String url, SQLDialect expected) throws Exception {
		DataSource dataSource = mock(DataSource.class);
		Connection connection = mock(Connection.class);
		DatabaseMetaData metaData = mock(DatabaseMetaData.class);
		given(dataSource.getConnection()).willReturn(connection);
		given(connection.getMetaData()).willReturn(metaData);
		given(metaData.getURL()).willReturn(url);
		SQLDialect sqlDialect = SqlDialectLookup.getDialect(dataSource);
		assertThat(sqlDialect).isEqualTo(expected);
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
class JooqPropertiesTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void determineSqlDialectNoCheckIfDialectIsSet() throws SQLException {
		JooqProperties properties = load('spring.jooq.sql-dialect=postgres');
		DataSource dataSource = mockStandaloneDataSource();
		SQLDialect sqlDialect = properties.determineSqlDialect(dataSource);
		assertThat(sqlDialect).isEqualTo(SQLDialect.POSTGRES);
		then(dataSource).should(never()).getConnection();
	}
	@Test
	void determineSqlDialectWithKnownUrl() {
		JooqProperties properties = load();
		SQLDialect sqlDialect = properties.determineSqlDialect(mockDataSource('jdbc:h2:mem:testdb'));
		assertThat(sqlDialect).isEqualTo(SQLDialect.H2);
	}
	@Test
	void determineSqlDialectWithKnownUrlAndUserConfig() {
		JooqProperties properties = load('spring.jooq.sql-dialect=mysql');
		SQLDialect sqlDialect = properties.determineSqlDialect(mockDataSource('jdbc:h2:mem:testdb'));
		assertThat(sqlDialect).isEqualTo(SQLDialect.MYSQL);
	}
	@Test
	void determineSqlDialectWithUnknownUrl() {
		JooqProperties properties = load();
		SQLDialect sqlDialect = properties.determineSqlDialect(mockDataSource('jdbc:unknown://localhost'));
		assertThat(sqlDialect).isEqualTo(SQLDialect.DEFAULT);
	}
	private DataSource mockStandaloneDataSource() throws SQLException {
		DataSource ds = mock(DataSource.class);
		given(ds.getConnection()).willThrow(SQLException.class);
		return ds;
	}
	private DataSource mockDataSource(String jdbcUrl) {
		DataSource ds = mock(DataSource.class);
		try {
			DatabaseMetaData metadata = mock(DatabaseMetaData.class);
			given(metadata.getURL()).willReturn(jdbcUrl);
			Connection connection = mock(Connection.class);
			given(connection.getMetaData()).willReturn(metadata);
			given(ds.getConnection()).willReturn(connection);
		}
		catch (SQLException ex) {
			// Do nothing
		}
		return ds;
	}
	private JooqProperties load(String... environment) {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(environment).applyTo(ctx);
		ctx.register(TestConfiguration.class);
		ctx.refresh();
		this.context = ctx;
		return this.context.getBean(JooqProperties.class);
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(JooqProperties.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
class NoDslContextBeanFailureAnalyzerTests {
	@Test
	void noAnalysisWithoutR2dbcAutoConfiguration() {
		new ApplicationContextRunner().run((context) -> {
			NoDslContextBeanFailureAnalyzer failureAnalyzer = new NoDslContextBeanFailureAnalyzer(
					context.getBeanFactory());
			assertThat(failureAnalyzer.analyze(new NoSuchBeanDefinitionException(DSLContext.class))).isNull();
		});
	}
	@Test
	void analysisWithR2dbcAutoConfiguration() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class))
			.run((context) -> {
				NoDslContextBeanFailureAnalyzer failureAnalyzer = new NoDslContextBeanFailureAnalyzer(
						context.getBeanFactory());
				assertThat(failureAnalyzer.analyze(new NoSuchBeanDefinitionException(DSLContext.class))).isNotNull();
			});
	}
}
/*
package org.springframework.boot.autoconfigure.jooq;
/**
@Deprecated(since = '3.3.0')
@SuppressWarnings('removal')
class JooqExceptionTranslatorTests {
	private final JooqExceptionTranslator exceptionTranslator = new JooqExceptionTranslator();
	@ParameterizedTest(name = '{0}')
	@MethodSource
	void exceptionTranslation(SQLDialect dialect, SQLException sqlException) {
		ExecuteContext context = mock(ExecuteContext.class);
		Configuration configuration = mock(Configuration.class);
		given(context.configuration()).willReturn(configuration);
		given(configuration.dialect()).willReturn(dialect);
		given(context.sqlException()).willReturn(sqlException);
		this.exceptionTranslator.exception(context);
		then(context).should().exception(assertArg((ex) -> assertThat(ex).isInstanceOf(BadSqlGrammarException.class)));
	}
	@Test
	void whenExceptionCannotBeTranslatedThenExecuteContextExceptionIsNotCalled() {
		ExecuteContext context = mock(ExecuteContext.class);
		Configuration configuration = mock(Configuration.class);
		given(context.configuration()).willReturn(configuration);
		given(configuration.dialect()).willReturn(SQLDialect.POSTGRES);
		given(context.sqlException()).willReturn(new SQLException(null, null, 123456789));
		this.exceptionTranslator.exception(context);
		then(context).should(never()).exception(any());
	}
	static Object[] exceptionTranslation() {
		return new Object[] { new Object[] { SQLDialect.DERBY, sqlException('42802') },
				new Object[] { SQLDialect.H2, sqlException(42000) },
				new Object[] { SQLDialect.HSQLDB, sqlException(-22) },
				new Object[] { SQLDialect.MARIADB, sqlException(1054) },
				new Object[] { SQLDialect.MYSQL, sqlException(1054) },
				new Object[] { SQLDialect.POSTGRES, sqlException('03000') },
				new Object[] { SQLDialect.SQLITE, sqlException('21000') } };
	}
	private static SQLException sqlException(String sqlState) {
		return new SQLException(null, sqlState);
	}
	private static SQLException sqlException(int vendorCode) {
		return new SQLException(null, null, vendorCode);
	}
}
/*
package org.springframework.boot.autoconfigure.dao;
/**
class PersistenceExceptionTranslationAutoConfigurationTests {
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void exceptionTranslationPostProcessorUsesCglibByDefault() {
		this.context = new AnnotationConfigApplicationContext(PersistenceExceptionTranslationAutoConfiguration.class);
		Map<String, PersistenceExceptionTranslationPostProcessor> beans = this.context
			.getBeansOfType(PersistenceExceptionTranslationPostProcessor.class);
		assertThat(beans).hasSize(1);
		assertThat(beans.values().iterator().next().isProxyTargetClass()).isTrue();
	}
	@Test
	void exceptionTranslationPostProcessorCanBeConfiguredToUseJdkProxy() {
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.aop.proxy-target-class=false').applyTo(this.context);
		this.context.register(PersistenceExceptionTranslationAutoConfiguration.class);
		this.context.refresh();
		Map<String, PersistenceExceptionTranslationPostProcessor> beans = this.context
			.getBeansOfType(PersistenceExceptionTranslationPostProcessor.class);
		assertThat(beans).hasSize(1);
		assertThat(beans.values().iterator().next().isProxyTargetClass()).isFalse();
	}
	@Test
	void exceptionTranslationPostProcessorCanBeDisabled() {
		this.context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.dao.exceptiontranslation.enabled=false').applyTo(this.context);
		this.context.register(PersistenceExceptionTranslationAutoConfiguration.class);
		this.context.refresh();
		Map<String, PersistenceExceptionTranslationPostProcessor> beans = this.context
			.getBeansOfType(PersistenceExceptionTranslationPostProcessor.class);
		assertThat(beans).isEmpty();
	}
	@Test
	void persistOfNullThrowsIllegalArgumentExceptionWithoutExceptionTranslation() {
		this.context = new AnnotationConfigApplicationContext(EmbeddedDataSourceConfiguration.class,
				HibernateJpaAutoConfiguration.class, TestConfiguration.class);
		assertThatIllegalArgumentException().isThrownBy(() -> this.context.getBean(TestRepository.class).doSomething());
	}
	@Test
	void persistOfNullThrowsInvalidDataAccessApiUsageExceptionWithExceptionTranslation() {
		this.context = new AnnotationConfigApplicationContext(EmbeddedDataSourceConfiguration.class,
				HibernateJpaAutoConfiguration.class, TestConfiguration.class,
				PersistenceExceptionTranslationAutoConfiguration.class);
		assertThatExceptionOfType(InvalidDataAccessApiUsageException.class)
			.isThrownBy(() -> this.context.getBean(TestRepository.class).doSomething());
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@Bean
		TestRepository testRepository(EntityManagerFactory entityManagerFactory) {
			return new TestRepository(entityManagerFactory.createEntityManager());
		}
	}
	@Repository
	static class TestRepository {
		private final EntityManager entityManager;
		TestRepository(EntityManager entityManager) {
			this.entityManager = entityManager;
		}
		void doSomething() {
			this.entityManager.persist(null);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
class RabbitPropertiesTests {
	private final RabbitProperties properties = new RabbitProperties();
	@Test
	void hostDefaultsToLocalhost() {
		assertThat(this.properties.getHost()).isEqualTo('localhost');
	}
	@Test
	void customHost() {
		this.properties.setHost('rabbit.example.com');
		assertThat(this.properties.getHost()).isEqualTo('rabbit.example.com');
	}
	@Test
	void hostIsDeterminedFromFirstAddress() {
		this.properties.setAddresses(List.of('rabbit1.example.com:1234', 'rabbit2.example.com:2345'));
		assertThat(this.properties.determineHost()).isEqualTo('rabbit1.example.com');
	}
	@Test
	void determineHostReturnsHostPropertyWhenNoAddresses() {
		this.properties.setHost('rabbit.example.com');
		assertThat(this.properties.determineHost()).isEqualTo('rabbit.example.com');
	}
	@Test
	void portDefaultsToNull() {
		assertThat(this.properties.getPort()).isNull();
	}
	@Test
	void customPort() {
		this.properties.setPort(1234);
		assertThat(this.properties.getPort()).isEqualTo(1234);
	}
	@Test
	void determinePortReturnsPortOfFirstAddress() {
		this.properties.setAddresses(List.of('rabbit1.example.com:1234', 'rabbit2.example.com:2345'));
		assertThat(this.properties.determinePort()).isEqualTo(1234);
	}
	@Test
	void determinePortReturnsDefaultPortWhenNoAddresses() {
		assertThat(this.properties.determinePort()).isEqualTo(5672);
	}
	@Test
	void determinePortWithSslReturnsDefaultSslPortWhenNoAddresses() {
		this.properties.getSsl().setEnabled(true);
		assertThat(this.properties.determinePort()).isEqualTo(5671);
	}
	@Test
	void determinePortReturnsPortPropertyWhenNoAddresses() {
		this.properties.setPort(1234);
		assertThat(this.properties.determinePort()).isEqualTo(1234);
	}
	@Test
	void determinePortReturnsDefaultAmqpPortWhenFirstAddressHasNoExplicitPort() {
		this.properties.setPort(1234);
		this.properties.setAddresses(List.of('rabbit1.example.com', 'rabbit2.example.com:2345'));
		assertThat(this.properties.determinePort()).isEqualTo(5672);
	}
	@Test
	void determinePortUsingAmqpReturnsPortOfFirstAddress() {
		this.properties.setAddresses(List.of('amqp://root:password@otherhost', 'amqps://root:password2@otherhost2'));
		assertThat(this.properties.determinePort()).isEqualTo(5672);
	}
	@Test
	void determinePortUsingAmqpsReturnsPortOfFirstAddress() {
		this.properties.setAddresses(List.of('amqps://root:password@otherhost', 'amqp://root:password2@otherhost2'));
		assertThat(this.properties.determinePort()).isEqualTo(5671);
	}
	@Test
	void determinePortReturnsDefaultAmqpsPortWhenFirstAddressHasNoExplicitPortButSslEnabled() {
		this.properties.getSsl().setEnabled(true);
		this.properties.setPort(1234);
		this.properties.setAddresses(List.of('rabbit1.example.com', 'rabbit2.example.com:2345'));
		assertThat(this.properties.determinePort()).isEqualTo(5671);
	}
	@Test
	void virtualHostDefaultsToNull() {
		assertThat(this.properties.getVirtualHost()).isNull();
	}
	@Test
	void customVirtualHost() {
		this.properties.setVirtualHost('alpha');
		assertThat(this.properties.getVirtualHost()).isEqualTo('alpha');
	}
	@Test
	void virtualHostRetainsALeadingSlash() {
		this.properties.setVirtualHost('/alpha');
		assertThat(this.properties.getVirtualHost()).isEqualTo('/alpha');
	}
	@Test
	void determineVirtualHostReturnsVirtualHostOfFirstAddress() {
		this.properties.setAddresses(List.of('rabbit1.example.com:1234/alpha', 'rabbit2.example.com:2345/bravo'));
		assertThat(this.properties.determineVirtualHost()).isEqualTo('alpha');
	}
	@Test
	void determineVirtualHostReturnsPropertyWhenNoAddresses() {
		this.properties.setVirtualHost('alpha');
		assertThat(this.properties.determineVirtualHost()).isEqualTo('alpha');
	}
	@Test
	void determineVirtualHostReturnsPropertyWhenFirstAddressHasNoVirtualHost() {
		this.properties.setVirtualHost('alpha');
		this.properties.setAddresses(List.of('rabbit1.example.com:1234', 'rabbit2.example.com:2345/bravo'));
		assertThat(this.properties.determineVirtualHost()).isEqualTo('alpha');
	}
	@Test
	void determineVirtualHostIsSlashWhenAddressHasTrailingSlash() {
		this.properties.setAddresses(List.of('amqp://root:password@otherhost:1111/'));
		assertThat(this.properties.determineVirtualHost()).isEqualTo('/');
	}
	@Test
	void emptyVirtualHostIsCoercedToASlash() {
		this.properties.setVirtualHost('');
		assertThat(this.properties.getVirtualHost()).isEqualTo('/');
	}
	@Test
	void usernameDefaultsToGuest() {
		assertThat(this.properties.getUsername()).isEqualTo('guest');
	}
	@Test
	void customUsername() {
		this.properties.setUsername('user');
		assertThat(this.properties.getUsername()).isEqualTo('user');
	}
	@Test
	void determineUsernameReturnsUsernameOfFirstAddress() {
		this.properties
			.setAddresses(List.of('user:secret@rabbit1.example.com:1234/alpha', 'rabbit2.example.com:2345/bravo'));
		assertThat(this.properties.determineUsername()).isEqualTo('user');
	}
	@Test
	void determineUsernameReturnsPropertyWhenNoAddresses() {
		this.properties.setUsername('alice');
		assertThat(this.properties.determineUsername()).isEqualTo('alice');
	}
	@Test
	void determineUsernameReturnsPropertyWhenFirstAddressHasNoUsername() {
		this.properties.setUsername('alice');
		this.properties
			.setAddresses(List.of('rabbit1.example.com:1234/alpha', 'user:secret@rabbit2.example.com:2345/bravo'));
		assertThat(this.properties.determineUsername()).isEqualTo('alice');
	}
	@Test
	void passwordDefaultsToGuest() {
		assertThat(this.properties.getPassword()).isEqualTo('guest');
	}
	@Test
	void customPassword() {
		this.properties.setPassword('secret');
		assertThat(this.properties.getPassword()).isEqualTo('secret');
	}
	@Test
	void determinePasswordReturnsPasswordOfFirstAddress() {
		this.properties
			.setAddresses(List.of('user:secret@rabbit1.example.com:1234/alpha', 'rabbit2.example.com:2345/bravo'));
		assertThat(this.properties.determinePassword()).isEqualTo('secret');
	}
	@Test
	void determinePasswordReturnsPropertyWhenNoAddresses() {
		this.properties.setPassword('secret');
		assertThat(this.properties.determinePassword()).isEqualTo('secret');
	}
	@Test
	void determinePasswordReturnsPropertyWhenFirstAddressHasNoPassword() {
		this.properties.setPassword('12345678');
		this.properties
			.setAddresses(List.of('rabbit1.example.com:1234/alpha', 'user:secret@rabbit2.example.com:2345/bravo'));
		assertThat(this.properties.determinePassword()).isEqualTo('12345678');
	}
	@Test
	void addressesDefaultsToNull() {
		assertThat(this.properties.getAddresses()).isNull();
	}
	@Test
	void customAddresses() {
		this.properties.setAddresses(List.of('user:secret@rabbit1.example.com:1234/alpha', 'rabbit2.example.com'));
		assertThat(this.properties.getAddresses()).containsExactly('user:secret@rabbit1.example.com:1234/alpha',
				'rabbit2.example.com');
	}
	@Test
	void ipv6Address() {
		this.properties.setAddresses(List.of('amqp://foo:bar@[aaaa:bbbb:cccc::d]:1234'));
		assertThat(this.properties.determineHost()).isEqualTo('[aaaa:bbbb:cccc::d]');
		assertThat(this.properties.determinePort()).isEqualTo(1234);
	}
	@Test
	void ipv6AddressDefaultPort() {
		this.properties.setAddresses(List.of('amqp://foo:bar@[aaaa:bbbb:cccc::d]'));
		assertThat(this.properties.determineHost()).isEqualTo('[aaaa:bbbb:cccc::d]');
		assertThat(this.properties.determinePort()).isEqualTo(5672);
	}
	@Test
	void determineAddressesReturnsAddressesWithJustHostAndPort() {
		this.properties.setAddresses(List.of('user:secret@rabbit1.example.com:1234/alpha', 'rabbit2.example.com'));
		assertThat(this.properties.determineAddresses()).containsExactly('rabbit1.example.com:1234',
				'rabbit2.example.com:5672');
	}
	@Test
	void determineAddressesUsesDefaultWhenNoAddressesSet() {
		assertThat(this.properties.determineAddresses()).containsExactly('localhost:5672');
	}
	@Test
	void determineAddressesWithSslUsesDefaultWhenNoAddressesSet() {
		this.properties.getSsl().setEnabled(true);
		assertThat(this.properties.determineAddresses()).containsExactly('localhost:5671');
	}
	@Test
	void determineAddressesUsesHostAndPortPropertiesWhenNoAddressesSet() {
		this.properties.setHost('rabbit.example.com');
		this.properties.setPort(1234);
		assertThat(this.properties.determineAddresses()).containsExactly('rabbit.example.com:1234');
	}
	@Test
	void determineAddressesUsesIpv6HostAndPortPropertiesWhenNoAddressesSet() {
		this.properties.setHost('[::1]');
		this.properties.setPort(32863);
		assertThat(this.properties.determineAddresses()).containsExactly('[::1]:32863');
	}
	@Test
	void determineSslUsingAmqpsReturnsStateOfFirstAddress() {
		this.properties.setAddresses(List.of('amqps://root:password@otherhost', 'amqp://root:password2@otherhost2'));
		assertThat(this.properties.getSsl().determineEnabled()).isTrue();
	}
	@Test
	void sslDetermineEnabledIsTrueWhenAddressHasNoProtocolAndSslIsEnabled() {
		this.properties.getSsl().setEnabled(true);
		this.properties.setAddresses(List.of('root:password@otherhost'));
		assertThat(this.properties.getSsl().determineEnabled()).isTrue();
	}
	@Test
	void sslDetermineEnabledIsFalseWhenAddressHasNoProtocolAndSslIsDisabled() {
		this.properties.getSsl().setEnabled(false);
		this.properties.setAddresses(List.of('root:password@otherhost'));
		assertThat(this.properties.getSsl().determineEnabled()).isFalse();
	}
	@Test
	void determineSslUsingAmqpReturnsStateOfFirstAddress() {
		this.properties.setAddresses(List.of('amqp://root:password@otherhost', 'amqps://root:password2@otherhost2'));
		assertThat(this.properties.getSsl().determineEnabled()).isFalse();
	}
	@Test
	void determineSslReturnFlagPropertyWhenNoAddresses() {
		this.properties.getSsl().setEnabled(true);
		assertThat(this.properties.getSsl().determineEnabled()).isTrue();
	}
	@Test
	void determineSslEnabledIsTrueWhenBundleIsSetAndNoAddresses() {
		this.properties.getSsl().setBundle('test');
		assertThat(this.properties.getSsl().determineEnabled()).isTrue();
	}
	@Test
	void propertiesUseConsistentDefaultValues() {
		ConnectionFactory connectionFactory = new ConnectionFactory();
		assertThat(connectionFactory).hasFieldOrPropertyWithValue('maxInboundMessageBodySize',
				(int) this.properties.getMaxInboundMessageBodySize().toBytes());
	}
	@Test
	void simpleContainerUseConsistentDefaultValues() {
		SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
		SimpleMessageListenerContainer container = factory.createListenerContainer();
		RabbitProperties.SimpleContainer simple = this.properties.getListener().getSimple();
		assertThat(simple.isAutoStartup()).isEqualTo(container.isAutoStartup());
		assertThat(container).hasFieldOrPropertyWithValue('missingQueuesFatal', simple.isMissingQueuesFatal());
		assertThat(container).hasFieldOrPropertyWithValue('deBatchingEnabled', simple.isDeBatchingEnabled());
		assertThat(container).hasFieldOrPropertyWithValue('consumerBatchEnabled', simple.isConsumerBatchEnabled());
		assertThat(container).hasFieldOrPropertyWithValue('forceStop', simple.isForceStop());
	}
	@Test
	void directContainerUseConsistentDefaultValues() {
		DirectRabbitListenerContainerFactory factory = new DirectRabbitListenerContainerFactory();
		DirectMessageListenerContainer container = factory.createListenerContainer();
		RabbitProperties.DirectContainer direct = this.properties.getListener().getDirect();
		assertThat(direct.isAutoStartup()).isEqualTo(container.isAutoStartup());
		assertThat(container).hasFieldOrPropertyWithValue('missingQueuesFatal', direct.isMissingQueuesFatal());
		assertThat(container).hasFieldOrPropertyWithValue('deBatchingEnabled', direct.isDeBatchingEnabled());
		assertThat(container).hasFieldOrPropertyWithValue('forceStop', direct.isForceStop());
	}
	@Test
	void determineUsernameWithoutPassword() {
		this.properties.setAddresses(List.of('user@rabbit1.example.com:1234/alpha'));
		assertThat(this.properties.determineUsername()).isEqualTo('user');
		assertThat(this.properties.determinePassword()).isEqualTo('guest');
	}
	@Test
	void hostPropertyMustBeSingleHost() {
		this.properties.setHost('my-rmq-host.net,my-rmq-host-2.net');
		assertThat(this.properties.getHost()).isEqualTo('my-rmq-host.net,my-rmq-host-2.net');
		assertThatExceptionOfType(InvalidConfigurationPropertyValueException.class)
			.isThrownBy(this.properties::determineAddresses)
			.withMessageContaining('spring.rabbitmq.host');
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
class RabbitStreamConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RabbitAutoConfiguration.class));
	@Test
	@SuppressWarnings('unchecked')
	void whenListenerTypeIsStreamThenStreamListenerContainerAndEnvironmentAreAutoConfigured() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.type:stream')
			.run((context) -> {
				RabbitListenerEndpointRegistry registry = context.getBean(RabbitListenerEndpointRegistry.class);
				MessageListenerContainer listenerContainer = registry.getListenerContainer('test');
				assertThat(listenerContainer).isInstanceOf(StreamListenerContainer.class);
				assertThat(listenerContainer).extracting('consumerCustomizer').isNotNull();
				assertThat(context.getBean(StreamRabbitListenerContainerFactory.class))
					.extracting('nativeListener', InstanceOfAssertFactories.BOOLEAN)
					.isFalse();
				then(context.getBean(ContainerCustomizer.class)).should().configure(listenerContainer);
				assertThat(context).hasSingleBean(Environment.class);
			});
	}
	@Test
	void whenNativeListenerIsEnabledThenContainerFactoryIsConfiguredToUseNativeListeners() {
		this.contextRunner
			.withPropertyValues('spring.rabbitmq.listener.type:stream',
					'spring.rabbitmq.listener.stream.native-listener:true')
			.run((context) -> assertThat(context.getBean(StreamRabbitListenerContainerFactory.class))
				.extracting('nativeListener', InstanceOfAssertFactories.BOOLEAN)
				.isTrue());
	}
	@Test
	void shouldConfigureObservations() {
		this.contextRunner
			.withPropertyValues('spring.rabbitmq.listener.type:stream',
					'spring.rabbitmq.listener.stream.observation-enabled:true')
			.run((context) -> assertThat(context.getBean(StreamRabbitListenerContainerFactory.class))
				.extracting('observationEnabled', InstanceOfAssertFactories.BOOLEAN)
				.isTrue());
	}
	@Test
	void environmentIsAutoConfiguredByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(Environment.class));
	}
	@Test
	void whenCustomEnvironmentIsDefinedThenAutoConfiguredEnvironmentBacksOff() {
		this.contextRunner.withUserConfiguration(CustomEnvironmentConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Environment.class);
			assertThat(context.getBean(Environment.class))
				.isSameAs(context.getBean(CustomEnvironmentConfiguration.class).environment);
		});
	}
	@Test
	void whenCustomMessageListenerContainerFactoryIsDefinedThenAutoConfiguredContainerFactoryBacksOff() {
		this.contextRunner.withUserConfiguration(CustomMessageListenerContainerFactoryConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(RabbitListenerContainerFactory.class);
				assertThat(context.getBean(RabbitListenerContainerFactory.class)).isSameAs(context
					.getBean(CustomMessageListenerContainerFactoryConfiguration.class).listenerContainerFactory);
			});
	}
	@Test
	void environmentUsesConnectionDetailsByDefault() {
		EnvironmentBuilder builder = mock(EnvironmentBuilder.class);
		RabbitProperties properties = new RabbitProperties();
		RabbitStreamConfiguration.configure(builder, properties,
				new TestRabbitConnectionDetails('guest', 'guest', 'vhost'));
		then(builder).should().port(5552);
		then(builder).should().host('localhost');
		then(builder).should().virtualHost('vhost');
		then(builder).should().lazyInitialization(true);
		then(builder).should().username('guest');
		then(builder).should().password('guest');
		then(builder).shouldHaveNoMoreInteractions();
	}
	@Test
	void whenStreamPortIsSetThenEnvironmentUsesCustomPort() {
		EnvironmentBuilder builder = mock(EnvironmentBuilder.class);
		RabbitProperties properties = new RabbitProperties();
		properties.getStream().setPort(5553);
		RabbitStreamConfiguration.configure(builder, properties,
				new TestRabbitConnectionDetails('guest', 'guest', 'vhost'));
		then(builder).should().port(5553);
	}
	@Test
	void whenStreamHostIsSetThenEnvironmentUsesCustomHost() {
		EnvironmentBuilder builder = mock(EnvironmentBuilder.class);
		RabbitProperties properties = new RabbitProperties();
		properties.getStream().setHost('stream.rabbit.example.com');
		RabbitStreamConfiguration.configure(builder, properties,
				new TestRabbitConnectionDetails('guest', 'guest', 'vhost'));
		then(builder).should().host('stream.rabbit.example.com');
	}
	@Test
	void whenStreamVirtualHostIsSetThenEnvironmentUsesCustomVirtualHost() {
		EnvironmentBuilder builder = mock(EnvironmentBuilder.class);
		RabbitProperties properties = new RabbitProperties();
		properties.getStream().setVirtualHost('stream-virtual-host');
		RabbitStreamConfiguration.configure(builder, properties,
				new TestRabbitConnectionDetails('guest', 'guest', 'vhost'));
		then(builder).should().virtualHost('stream-virtual-host');
	}
	@Test
	void whenStreamVirtualHostIsNotSetButDefaultVirtualHostIsSetThenEnvironmentUsesDefaultVirtualHost() {
		EnvironmentBuilder builder = mock(EnvironmentBuilder.class);
		RabbitProperties properties = new RabbitProperties();
		properties.setVirtualHost('properties-virtual-host');
		RabbitStreamConfiguration.configure(builder, properties,
				new TestRabbitConnectionDetails('guest', 'guest', 'default-virtual-host'));
		then(builder).should().virtualHost('default-virtual-host');
	}
	@Test
	void whenStreamCredentialsAreNotSetThenEnvironmentUsesConnectionDetailsCredentials() {
		EnvironmentBuilder builder = mock(EnvironmentBuilder.class);
		RabbitProperties properties = new RabbitProperties();
		properties.setUsername('alice');
		properties.setPassword('secret');
		RabbitStreamConfiguration.configure(builder, properties,
				new TestRabbitConnectionDetails('bob', 'password', 'vhost'));
		then(builder).should().username('bob');
		then(builder).should().password('password');
	}
	@Test
	void whenStreamCredentialsAreSetThenEnvironmentUsesStreamCredentials() {
		EnvironmentBuilder builder = mock(EnvironmentBuilder.class);
		RabbitProperties properties = new RabbitProperties();
		properties.setUsername('alice');
		properties.setPassword('secret');
		properties.getStream().setUsername('bob');
		properties.getStream().setPassword('confidential');
		RabbitStreamConfiguration.configure(builder, properties,
				new TestRabbitConnectionDetails('charlotte', 'hidden', 'vhost'));
		then(builder).should().username('bob');
		then(builder).should().password('confidential');
	}
	@Test
	void testDefaultRabbitStreamTemplateConfiguration() {
		this.contextRunner.withPropertyValues('spring.rabbitmq.stream.name:stream-test').run((context) -> {
			assertThat(context).hasSingleBean(RabbitStreamTemplate.class);
			assertThat(context.getBean(RabbitStreamTemplate.class)).hasFieldOrPropertyWithValue('streamName',
					'stream-test');
		});
	}
	@Test
	void testDefaultRabbitStreamTemplateConfigurationWithoutStreamName() {
		this.contextRunner.withPropertyValues('spring.rabbitmq.listener.type:stream')
			.run((context) -> assertThat(context).doesNotHaveBean(RabbitStreamTemplate.class));
	}
	@Test
	void testRabbitStreamTemplateConfigurationWithCustomMessageConverter() {
		this.contextRunner.withUserConfiguration(MessageConvertersConfiguration.class)
			.withPropertyValues('spring.rabbitmq.stream.name:stream-test')
			.run((context) -> {
				assertThat(context).hasSingleBean(RabbitStreamTemplate.class);
				RabbitStreamTemplate streamTemplate = context.getBean(RabbitStreamTemplate.class);
				assertThat(streamTemplate).hasFieldOrPropertyWithValue('streamName', 'stream-test');
				assertThat(streamTemplate).extracting('messageConverter')
					.isSameAs(context.getBean(MessageConverter.class));
			});
	}
	@Test
	void testRabbitStreamTemplateConfigurationWithCustomStreamMessageConverter() {
		this.contextRunner
			.withBean('myStreamMessageConverter', StreamMessageConverter.class,
					() -> mock(StreamMessageConverter.class))
			.withPropertyValues('spring.rabbitmq.stream.name:stream-test')
			.run((context) -> {
				assertThat(context).hasSingleBean(RabbitStreamTemplate.class);
				assertThat(context.getBean(RabbitStreamTemplate.class)).extracting('messageConverter')
					.isSameAs(context.getBean('myStreamMessageConverter'));
			});
	}
	@Test
	void testRabbitStreamTemplateConfigurationWithCustomProducerCustomizer() {
		this.contextRunner
			.withBean('myProducerCustomizer', ProducerCustomizer.class, () -> mock(ProducerCustomizer.class))
			.withPropertyValues('spring.rabbitmq.stream.name:stream-test')
			.run((context) -> {
				assertThat(context).hasSingleBean(RabbitStreamTemplate.class);
				assertThat(context.getBean(RabbitStreamTemplate.class)).extracting('producerCustomizer')
					.isSameAs(context.getBean('myProducerCustomizer'));
			});
	}
	@Test
	void environmentCreatedByBuilderCanBeCustomized() {
		this.contextRunner.withUserConfiguration(EnvironmentBuilderCustomizers.class).run((context) -> {
			Environment environment = context.getBean(Environment.class);
			assertThat(environment).extracting('codec')
				.isEqualTo(context.getBean(EnvironmentBuilderCustomizers.class).codec);
			assertThat(environment).extracting('recoveryBackOffDelayPolicy')
				.isEqualTo(context.getBean(EnvironmentBuilderCustomizers.class).recoveryBackOffDelayPolicy);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
		@RabbitListener(id = 'test', queues = 'stream', autoStartup = 'false')
		void listen(String in) {
		}
		@Bean
		ConsumerCustomizer consumerCustomizer() {
			return mock(ConsumerCustomizer.class);
		}
		@Bean
		@SuppressWarnings('unchecked')
		ContainerCustomizer<StreamListenerContainer> containerCustomizer() {
			return mock(ContainerCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomEnvironmentConfiguration {
		private final Environment environment = Environment.builder().lazyInitialization(true).build();
		@Bean
		Environment rabbitStreamEnvironment() {
			return this.environment;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomMessageListenerContainerFactoryConfiguration {
		@SuppressWarnings('rawtypes')
		private final RabbitListenerContainerFactory listenerContainerFactory = mock(
				RabbitListenerContainerFactory.class);
		@Bean
		@SuppressWarnings('unchecked')
		RabbitListenerContainerFactory<MessageListenerContainer> rabbitListenerContainerFactory() {
			return this.listenerContainerFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MessageConvertersConfiguration {
		@Bean
		@Primary
		MessageConverter myMessageConverter() {
			return mock(MessageConverter.class);
		}
		@Bean
		MessageConverter anotherMessageConverter() {
			return mock(MessageConverter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EnvironmentBuilderCustomizers {
		private final Codec codec = mock(Codec.class);
		private final BackOffDelayPolicy recoveryBackOffDelayPolicy = BackOffDelayPolicy.fixed(Duration.ofSeconds(5));
		@Bean
		@Order(1)
		EnvironmentBuilderCustomizer customizerA() {
			return (builder) -> builder.codec(this.codec);
		}
		@Bean
		@Order(0)
		EnvironmentBuilderCustomizer customizerB() {
			return (builder) -> builder.codec(mock(Codec.class))
				.recoveryBackOffDelayPolicy(this.recoveryBackOffDelayPolicy);
		}
	}
	private static final class TestRabbitConnectionDetails implements RabbitConnectionDetails {
		private final String username;
		private final String password;
		private final String virtualHost;
		private TestRabbitConnectionDetails(String username, String password, String virtualHost) {
			this.username = username;
			this.password = password;
			this.virtualHost = virtualHost;
		}
		@Override
		public String getUsername() {
			return this.username;
		}
		@Override
		public String getPassword() {
			return this.password;
		}
		@Override
		public String getVirtualHost() {
			return this.virtualHost;
		}
		@Override
		public List<Address> getAddresses() {
			throw new UnsupportedOperationException();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
@ExtendWith(OutputCaptureExtension.class)
class RabbitAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RabbitAutoConfiguration.class, SslAutoConfiguration.class))
		.withClassLoader(new FilteredClassLoader('org.springframework.rabbit.stream')); // gh-38750
	@Test
	void testDefaultRabbitConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
			RabbitMessagingTemplate messagingTemplate = context.getBean(RabbitMessagingTemplate.class);
			CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
			RabbitAdmin amqpAdmin = context.getBean(RabbitAdmin.class);
			assertThat(rabbitTemplate.getConnectionFactory()).isEqualTo(connectionFactory);
			assertThat(getMandatory(rabbitTemplate)).isFalse();
			assertThat(messagingTemplate.getRabbitTemplate()).isEqualTo(rabbitTemplate);
			assertThat(amqpAdmin).isNotNull();
			assertThat(connectionFactory.getHost()).isEqualTo('localhost');
			assertThat(getTargetConnectionFactory(context).getRequestedChannelMax())
				.isEqualTo(com.rabbitmq.client.ConnectionFactory.DEFAULT_CHANNEL_MAX);
			assertThat(connectionFactory.isPublisherConfirms()).isFalse();
			assertThat(connectionFactory.isPublisherReturns()).isFalse();
			assertThat(connectionFactory.getRabbitConnectionFactory().getChannelRpcTimeout())
				.isEqualTo(com.rabbitmq.client.ConnectionFactory.DEFAULT_CHANNEL_RPC_TIMEOUT);
			assertThat(context.containsBean('rabbitListenerContainerFactory'))
				.as('Listener container factory should be created by default')
				.isTrue();
		});
	}
	@Test
	void testDefaultRabbitTemplateConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
			RabbitTemplate defaultRabbitTemplate = new RabbitTemplate();
			assertThat(rabbitTemplate.getRoutingKey()).isEqualTo(defaultRabbitTemplate.getRoutingKey());
			assertThat(rabbitTemplate.getExchange()).isEqualTo(defaultRabbitTemplate.getExchange());
		});
	}
	@Test
	void testDefaultConnectionFactoryConfiguration() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			RabbitProperties properties = new RabbitProperties();
			com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
			assertThat(rabbitConnectionFactory.getUsername()).isEqualTo(properties.getUsername());
			assertThat(rabbitConnectionFactory.getPassword()).isEqualTo(properties.getPassword());
			assertThat(rabbitConnectionFactory).extracting('maxInboundMessageBodySize')
				.isEqualTo((int) properties.getMaxInboundMessageBodySize().toBytes());
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testConnectionFactoryWithOverrides() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.host:remote-server', 'spring.rabbitmq.port:9000',
					'spring.rabbitmq.address-shuffle-mode=random', 'spring.rabbitmq.username:alice',
					'spring.rabbitmq.password:secret', 'spring.rabbitmq.virtual_host:/vhost',
					'spring.rabbitmq.connection-timeout:123', 'spring.rabbitmq.channel-rpc-timeout:140',
					'spring.rabbitmq.max-inbound-message-body-size:128MB')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.getHost()).isEqualTo('remote-server');
				assertThat(connectionFactory.getPort()).isEqualTo(9000);
				assertThat(connectionFactory).hasFieldOrPropertyWithValue('addressShuffleMode',
						AddressShuffleMode.RANDOM);
				assertThat(connectionFactory.getVirtualHost()).isEqualTo('/vhost');
				com.rabbitmq.client.ConnectionFactory rcf = connectionFactory.getRabbitConnectionFactory();
				assertThat(rcf.getConnectionTimeout()).isEqualTo(123);
				assertThat(rcf.getChannelRpcTimeout()).isEqualTo(140);
				assertThat((List<Address>) ReflectionTestUtils.getField(connectionFactory, 'addresses')).hasSize(1);
				assertThat(rcf).hasFieldOrPropertyWithValue('maxInboundMessageBodySize', 1024 * 1024 * 128);
			});
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesRabbitConnectionDetails.class));
	}
	@Test
	@SuppressWarnings('unchecked')
	void testConnectionFactoryWithOverridesWhenUsingCustomConnectionDetails() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class, ConnectionDetailsConfiguration.class)
			.withPropertyValues('spring.rabbitmq.host:remote-server', 'spring.rabbitmq.port:9000',
					'spring.rabbitmq.username:alice', 'spring.rabbitmq.password:secret',
					'spring.rabbitmq.virtual_host:/vhost')
			.run((context) -> {
				assertThat(context).hasSingleBean(RabbitConnectionDetails.class)
					.doesNotHaveBean(PropertiesRabbitConnectionDetails.class);
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.getHost()).isEqualTo('rabbit.example.com');
				assertThat(connectionFactory.getPort()).isEqualTo(12345);
				assertThat(connectionFactory.getVirtualHost()).isEqualTo('/vhost-1');
				assertThat(connectionFactory.getUsername()).isEqualTo('user-1');
				assertThat(connectionFactory.getRabbitConnectionFactory().getPassword()).isEqualTo('password-1');
				List<Address> addresses = (List<Address>) ReflectionTestUtils.getField(connectionFactory, 'addresses');
				assertThat(addresses).containsExactly(new Address('rabbit.example.com', 12345),
						new Address('rabbit2.example.com', 23456));
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testConnectionFactoryWithCustomConnectionNameStrategy() {
		this.contextRunner.withUserConfiguration(ConnectionNameStrategyConfiguration.class).run((context) -> {
			CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
			List<Address> addresses = (List<Address>) ReflectionTestUtils.getField(connectionFactory, 'addresses');
			assertThat(addresses).hasSize(1);
			com.rabbitmq.client.ConnectionFactory rcf = mock(com.rabbitmq.client.ConnectionFactory.class);
			given(rcf.newConnection(isNull(), eq(addresses), anyString())).willReturn(mock(Connection.class));
			ReflectionTestUtils.setField(connectionFactory, 'rabbitConnectionFactory', rcf);
			try (org.springframework.amqp.rabbit.connection.Connection connection = connectionFactory
				.createConnection()) {
				then(rcf).should().newConnection(isNull(), eq(addresses), eq('test#0'));
			}
			connectionFactory.resetConnection();
			try (org.springframework.amqp.rabbit.connection.Connection connection = connectionFactory
				.createConnection()) {
				then(rcf).should().newConnection(isNull(), eq(addresses), eq('test#1'));
			}
		});
	}
	@Test
	void testConnectionFactoryEmptyVirtualHost() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.virtual_host:')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.getVirtualHost()).isEqualTo('/');
			});
	}
	@Test
	void testConnectionFactoryVirtualHostNoLeadingSlash() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.virtual_host:foo')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.getVirtualHost()).isEqualTo('foo');
			});
	}
	@Test
	void testConnectionFactoryVirtualHostMultiLeadingSlashes() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.virtual_host:///foo')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.getVirtualHost()).isEqualTo('///foo');
			});
	}
	@Test
	void testConnectionFactoryDefaultVirtualHost() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.virtual_host:/')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.getVirtualHost()).isEqualTo('/');
			});
	}
	@Test
	void testConnectionFactoryPublisherConfirmTypeCorrelated() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.publisher-confirm-type=correlated')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.isPublisherConfirms()).isTrue();
				assertThat(connectionFactory.isSimplePublisherConfirms()).isFalse();
			});
	}
	@Test
	void testConnectionFactoryPublisherConfirmTypeSimple() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.publisher-confirm-type=simple')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.isPublisherConfirms()).isFalse();
				assertThat(connectionFactory.isSimplePublisherConfirms()).isTrue();
			});
	}
	@Test
	void testConnectionFactoryPublisherReturns() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.publisher-returns=true')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				assertThat(connectionFactory.isPublisherReturns()).isTrue();
				assertThat(getMandatory(rabbitTemplate)).isTrue();
			});
	}
	@Test
	void testRabbitTemplateMessageConverters() {
		this.contextRunner.withUserConfiguration(MessageConvertersConfiguration.class).run((context) -> {
			RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
			assertThat(rabbitTemplate.getMessageConverter()).isSameAs(context.getBean('myMessageConverter'));
			assertThat(rabbitTemplate).hasFieldOrPropertyWithValue('retryTemplate', null);
		});
	}
	@Test
	void testRabbitTemplateRetry() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.retry.enabled:true',
					'spring.rabbitmq.template.retry.max-attempts:4',
					'spring.rabbitmq.template.retry.initial-interval:2000',
					'spring.rabbitmq.template.retry.multiplier:1.5', 'spring.rabbitmq.template.retry.max-interval:5000',
					'spring.rabbitmq.template.receive-timeout:123', 'spring.rabbitmq.template.reply-timeout:456')
			.run((context) -> {
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				assertThat(rabbitTemplate).hasFieldOrPropertyWithValue('receiveTimeout', 123L);
				assertThat(rabbitTemplate).hasFieldOrPropertyWithValue('replyTimeout', 456L);
				RetryTemplate retryTemplate = (RetryTemplate) ReflectionTestUtils.getField(rabbitTemplate,
						'retryTemplate');
				assertThat(retryTemplate).isNotNull();
				SimpleRetryPolicy retryPolicy = (SimpleRetryPolicy) ReflectionTestUtils.getField(retryTemplate,
						'retryPolicy');
				ExponentialBackOffPolicy backOffPolicy = (ExponentialBackOffPolicy) ReflectionTestUtils
					.getField(retryTemplate, 'backOffPolicy');
				assertThat(retryPolicy.getMaxAttempts()).isEqualTo(4);
				assertThat(backOffPolicy.getInitialInterval()).isEqualTo(2000);
				assertThat(backOffPolicy.getMultiplier()).isEqualTo(1.5);
				assertThat(backOffPolicy.getMaxInterval()).isEqualTo(5000);
			});
	}
	@Test
	void testRabbitTemplateRetryWithCustomizer() {
		this.contextRunner.withUserConfiguration(RabbitRetryTemplateCustomizerConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.retry.enabled:true',
					'spring.rabbitmq.template.retry.initial-interval:2000')
			.run((context) -> {
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				RetryTemplate retryTemplate = (RetryTemplate) ReflectionTestUtils.getField(rabbitTemplate,
						'retryTemplate');
				assertThat(retryTemplate).isNotNull();
				ExponentialBackOffPolicy backOffPolicy = (ExponentialBackOffPolicy) ReflectionTestUtils
					.getField(retryTemplate, 'backOffPolicy');
				assertThat(backOffPolicy)
					.isSameAs(context.getBean(RabbitRetryTemplateCustomizerConfiguration.class).backOffPolicy);
				assertThat(backOffPolicy.getInitialInterval()).isEqualTo(100);
			});
	}
	@Test
	void testRabbitTemplateExchangeAndRoutingKey() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.exchange:my-exchange',
					'spring.rabbitmq.template.routing-key:my-routing-key')
			.run((context) -> {
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				assertThat(rabbitTemplate.getExchange()).isEqualTo('my-exchange');
				assertThat(rabbitTemplate.getRoutingKey()).isEqualTo('my-routing-key');
			});
	}
	@Test
	void shouldConfigureObservationEnabledOnTemplate() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.observation-enabled:true')
			.run((context) -> {
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				assertThat(rabbitTemplate).extracting('observationEnabled', InstanceOfAssertFactories.BOOLEAN).isTrue();
			});
	}
	@Test
	void testRabbitTemplateDefaultReceiveQueue() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.default-receive-queue:default-queue')
			.run((context) -> {
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				assertThat(rabbitTemplate).hasFieldOrPropertyWithValue('defaultReceiveQueue', 'default-queue');
			});
	}
	@Test
	void testRabbitTemplateMandatory() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.mandatory:true')
			.run((context) -> {
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				assertThat(getMandatory(rabbitTemplate)).isTrue();
			});
	}
	@Test
	void testRabbitTemplateMandatoryDisabledEvenIfPublisherReturnsIsSet() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.mandatory:false', 'spring.rabbitmq.publisher-returns=true')
			.run((context) -> {
				RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
				assertThat(getMandatory(rabbitTemplate)).isFalse();
			});
	}
	@Test
	void testRabbitTemplateConfigurersIsAvailable() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(RabbitTemplateConfigurer.class));
	}
	@Test
	void testRabbitTemplateConfigurerUsesConfig() {
		this.contextRunner.withUserConfiguration(MessageConvertersConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.exchange:my-exchange',
					'spring.rabbitmq.template.routing-key:my-routing-key',
					'spring.rabbitmq.template.default-receive-queue:default-queue')
			.run((context) -> {
				RabbitTemplateConfigurer configurer = context.getBean(RabbitTemplateConfigurer.class);
				RabbitTemplate template = mock(RabbitTemplate.class);
				ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
				configurer.configure(template, connectionFactory);
				then(template).should()
					.setMessageConverter(context.getBean('myMessageConverter', MessageConverter.class));
				then(template).should().setExchange('my-exchange');
				then(template).should().setRoutingKey('my-routing-key');
				then(template).should().setDefaultReceiveQueue('default-queue');
			});
	}
	@Test
	void whenMultipleRabbitTemplateCustomizersAreDefinedThenTheyAreCalledInOrder() {
		this.contextRunner.withUserConfiguration(MultipleRabbitTemplateCustomizersConfiguration.class)
			.run((context) -> {
				RabbitTemplateCustomizer firstCustomizer = context.getBean('firstCustomizer',
						RabbitTemplateCustomizer.class);
				RabbitTemplateCustomizer secondCustomizer = context.getBean('secondCustomizer',
						RabbitTemplateCustomizer.class);
				InOrder inOrder = inOrder(firstCustomizer, secondCustomizer);
				RabbitTemplate template = context.getBean(RabbitTemplate.class);
				then(firstCustomizer).should(inOrder).customize(template);
				then(secondCustomizer).should(inOrder).customize(template);
				inOrder.verifyNoMoreInteractions();
			});
	}
	@Test
	void testConnectionFactoryBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration2.class).run((context) -> {
			RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
			CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
			assertThat(connectionFactory).isEqualTo(rabbitTemplate.getConnectionFactory());
			assertThat(connectionFactory.getHost()).isEqualTo('otherserver');
			assertThat(connectionFactory.getPort()).isEqualTo(8001);
		});
	}
	@Test
	void testConnectionFactoryCacheSettings() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.cache.channel.size=23',
					'spring.rabbitmq.cache.channel.checkout-timeout=1000',
					'spring.rabbitmq.cache.connection.mode=CONNECTION', 'spring.rabbitmq.cache.connection.size=2')
			.run((context) -> {
				CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
				assertThat(connectionFactory.getChannelCacheSize()).isEqualTo(23);
				assertThat(connectionFactory.getCacheMode()).isEqualTo(CacheMode.CONNECTION);
				assertThat(connectionFactory.getConnectionCacheSize()).isEqualTo(2);
				assertThat(connectionFactory).hasFieldOrPropertyWithValue('channelCheckoutTimeout', 1000L);
			});
	}
	@Test
	void testRabbitTemplateBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration3.class).run((context) -> {
			RabbitTemplate rabbitTemplate = context.getBean(RabbitTemplate.class);
			assertThat(rabbitTemplate.getMessageConverter()).isEqualTo(context.getBean('testMessageConverter'));
		});
	}
	@Test
	void testRabbitMessagingTemplateBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration4.class).run((context) -> {
			RabbitMessagingTemplate messagingTemplate = context.getBean(RabbitMessagingTemplate.class);
			assertThat(messagingTemplate.getDefaultDestination()).isEqualTo('fooBar');
		});
	}
	@Test
	void testStaticQueues() {
		// There should NOT be an AmqpAdmin bean when dynamic is switch to false
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.dynamic:false')
			.run((context) -> assertThatExceptionOfType(NoSuchBeanDefinitionException.class)
				.isThrownBy(() -> context.getBean(AmqpAdmin.class))
				.withMessageContaining('No qualifying bean of type "' + AmqpAdmin.class.getName() + '"'));
	}
	@Test
	void testEnableRabbitCreateDefaultContainerFactory() {
		this.contextRunner.withUserConfiguration(EnableRabbitConfiguration.class).run((context) -> {
			RabbitListenerContainerFactory<?> rabbitListenerContainerFactory = context
				.getBean('rabbitListenerContainerFactory', RabbitListenerContainerFactory.class);
			assertThat(rabbitListenerContainerFactory.getClass()).isEqualTo(SimpleRabbitListenerContainerFactory.class);
		});
	}
	@Test
	void testRabbitListenerContainerFactoryBackOff() {
		this.contextRunner.withUserConfiguration(TestConfiguration5.class).run((context) -> {
			SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory = context
				.getBean('rabbitListenerContainerFactory', SimpleRabbitListenerContainerFactory.class);
			rabbitListenerContainerFactory.setBatchSize(10);
			then(rabbitListenerContainerFactory).should().setBatchSize(10);
			assertThat(rabbitListenerContainerFactory.getAdviceChain()).isNull();
		});
	}
	@Test
	void testSimpleRabbitListenerContainerFactoryWithCustomSettings() {
		this.contextRunner
			.withUserConfiguration(MessageConvertersConfiguration.class, MessageRecoverersConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.simple.retry.enabled:true',
					'spring.rabbitmq.listener.simple.retry.max-attempts:4',
					'spring.rabbitmq.listener.simple.retry.initial-interval:2000',
					'spring.rabbitmq.listener.simple.retry.multiplier:1.5',
					'spring.rabbitmq.listener.simple.retry.max-interval:5000',
					'spring.rabbitmq.listener.simple.auto-startup:false',
					'spring.rabbitmq.listener.simple.acknowledge-mode:manual',
					'spring.rabbitmq.listener.simple.concurrency:5',
					'spring.rabbitmq.listener.simple.max-concurrency:10', 'spring.rabbitmq.listener.simple.prefetch:40',
					'spring.rabbitmq.listener.simple.default-requeue-rejected:false',
					'spring.rabbitmq.listener.simple.idle-event-interval:5',
					'spring.rabbitmq.listener.simple.batch-size:20',
					'spring.rabbitmq.listener.simple.missing-queues-fatal:false',
					'spring.rabbitmq.listener.simple.force-stop:true',
					'spring.rabbitmq.listener.simple.observation-enabled:true')
			.run((context) -> {
				SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory = context
					.getBean('rabbitListenerContainerFactory', SimpleRabbitListenerContainerFactory.class);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('concurrentConsumers', 5);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('maxConcurrentConsumers', 10);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('batchSize', 20);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('missingQueuesFatal', false);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('observationEnabled', true);
				checkCommonProps(context, rabbitListenerContainerFactory);
			});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldConfigureVirtualThreadsForSimpleListener() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory = context
				.getBean('rabbitListenerContainerFactory', SimpleRabbitListenerContainerFactory.class);
			assertThat(rabbitListenerContainerFactory).extracting('taskExecutor')
				.isInstanceOf(VirtualThreadTaskExecutor.class);
			Object taskExecutor = ReflectionTestUtils.getField(rabbitListenerContainerFactory, 'taskExecutor');
			Object virtualThread = ReflectionTestUtils.getField(taskExecutor, 'virtualThreadFactory');
			Thread threadCreated = ((ThreadFactory) virtualThread).newThread(mock(Runnable.class));
			assertThat(threadCreated.getName()).containsPattern('rabbit-simple-[0-9]+');
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldConfigureVirtualThreadsForDirectListener() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			DirectRabbitListenerContainerFactoryConfigurer rabbitListenerContainerFactory = context.getBean(
					'directRabbitListenerContainerFactoryConfigurer',
					DirectRabbitListenerContainerFactoryConfigurer.class);
			assertThat(rabbitListenerContainerFactory).extracting('taskExecutor')
				.isInstanceOf(VirtualThreadTaskExecutor.class);
			Object taskExecutor = ReflectionTestUtils.getField(rabbitListenerContainerFactory, 'taskExecutor');
			Object virtualThread = ReflectionTestUtils.getField(taskExecutor, 'virtualThreadFactory');
			Thread threadCreated = ((ThreadFactory) virtualThread).newThread(mock(Runnable.class));
			assertThat(threadCreated.getName()).containsPattern('rabbit-direct-[0-9]+');
		});
	}
	@Test
	void testSimpleRabbitListenerContainerFactoryWithDefaultForceStop() {
		this.contextRunner
			.withUserConfiguration(MessageConvertersConfiguration.class, MessageRecoverersConfiguration.class)
			.run((context) -> {
				SimpleRabbitListenerContainerFactory containerFactory = context
					.getBean('rabbitListenerContainerFactory', SimpleRabbitListenerContainerFactory.class);
				assertThat(containerFactory).hasFieldOrPropertyWithValue('forceStop', false);
			});
	}
	@Test
	void testDirectRabbitListenerContainerFactoryWithCustomSettings() {
		this.contextRunner
			.withUserConfiguration(MessageConvertersConfiguration.class, MessageRecoverersConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.type:direct',
					'spring.rabbitmq.listener.direct.retry.enabled:true',
					'spring.rabbitmq.listener.direct.retry.max-attempts:4',
					'spring.rabbitmq.listener.direct.retry.initial-interval:2000',
					'spring.rabbitmq.listener.direct.retry.multiplier:1.5',
					'spring.rabbitmq.listener.direct.retry.max-interval:5000',
					'spring.rabbitmq.listener.direct.auto-startup:false',
					'spring.rabbitmq.listener.direct.acknowledge-mode:manual',
					'spring.rabbitmq.listener.direct.consumers-per-queue:5',
					'spring.rabbitmq.listener.direct.prefetch:40',
					'spring.rabbitmq.listener.direct.default-requeue-rejected:false',
					'spring.rabbitmq.listener.direct.idle-event-interval:5',
					'spring.rabbitmq.listener.direct.missing-queues-fatal:true',
					'spring.rabbitmq.listener.direct.force-stop:true',
					'spring.rabbitmq.listener.direct.observation-enabled:true')
			.run((context) -> {
				DirectRabbitListenerContainerFactory rabbitListenerContainerFactory = context
					.getBean('rabbitListenerContainerFactory', DirectRabbitListenerContainerFactory.class);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('consumersPerQueue', 5);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('missingQueuesFatal', true);
				assertThat(rabbitListenerContainerFactory).hasFieldOrPropertyWithValue('observationEnabled', true);
				checkCommonProps(context, rabbitListenerContainerFactory);
			});
	}
	@Test
	void testDirectRabbitListenerContainerFactoryWithDefaultForceStop() {
		this.contextRunner
			.withUserConfiguration(MessageConvertersConfiguration.class, MessageRecoverersConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.type:direct')
			.run((context) -> {
				DirectRabbitListenerContainerFactory containerFactory = context
					.getBean('rabbitListenerContainerFactory', DirectRabbitListenerContainerFactory.class);
				assertThat(containerFactory).hasFieldOrPropertyWithValue('forceStop', false);
			});
	}
	@Test
	void testSimpleRabbitListenerContainerFactoryRetryWithCustomizer() {
		this.contextRunner.withUserConfiguration(RabbitRetryTemplateCustomizerConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.simple.retry.enabled:true',
					'spring.rabbitmq.listener.simple.retry.max-attempts:4')
			.run((context) -> {
				SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory = context
					.getBean('rabbitListenerContainerFactory', SimpleRabbitListenerContainerFactory.class);
				assertListenerRetryTemplate(rabbitListenerContainerFactory,
						context.getBean(RabbitRetryTemplateCustomizerConfiguration.class).retryPolicy);
			});
	}
	@Test
	void testDirectRabbitListenerContainerFactoryRetryWithCustomizer() {
		this.contextRunner.withUserConfiguration(RabbitRetryTemplateCustomizerConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.type:direct',
					'spring.rabbitmq.listener.direct.retry.enabled:true',
					'spring.rabbitmq.listener.direct.retry.max-attempts:4')
			.run((context) -> {
				DirectRabbitListenerContainerFactory rabbitListenerContainerFactory = context
					.getBean('rabbitListenerContainerFactory', DirectRabbitListenerContainerFactory.class);
				assertListenerRetryTemplate(rabbitListenerContainerFactory,
						context.getBean(RabbitRetryTemplateCustomizerConfiguration.class).retryPolicy);
			});
	}
	private void assertListenerRetryTemplate(AbstractRabbitListenerContainerFactory<?> rabbitListenerContainerFactory,
			RetryPolicy retryPolicy) {
		Advice[] adviceChain = rabbitListenerContainerFactory.getAdviceChain();
		assertThat(adviceChain).isNotNull();
		assertThat(adviceChain).hasSize(1);
		Advice advice = adviceChain[0];
		RetryTemplate retryTemplate = (RetryTemplate) ReflectionTestUtils.getField(advice, 'retryOperations');
		assertThat(retryTemplate).hasFieldOrPropertyWithValue('retryPolicy', retryPolicy);
	}
	@Test
	void testRabbitListenerContainerFactoryConfigurersAreAvailable() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.simple.concurrency:5',
					'spring.rabbitmq.listener.simple.max-concurrency:10', 'spring.rabbitmq.listener.simple.prefetch:40',
					'spring.rabbitmq.listener.direct.consumers-per-queue:5',
					'spring.rabbitmq.listener.direct.prefetch:40')
			.run((context) -> {
				assertThat(context).hasSingleBean(SimpleRabbitListenerContainerFactoryConfigurer.class);
				assertThat(context).hasSingleBean(DirectRabbitListenerContainerFactoryConfigurer.class);
			});
	}
	@Test
	void testSimpleRabbitListenerContainerFactoryConfigurerUsesConfig() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.simple.concurrency:5',
					'spring.rabbitmq.listener.simple.max-concurrency:10', 'spring.rabbitmq.listener.simple.prefetch:40')
			.run((context) -> {
				SimpleRabbitListenerContainerFactoryConfigurer configurer = context
					.getBean(SimpleRabbitListenerContainerFactoryConfigurer.class);
				SimpleRabbitListenerContainerFactory factory = mock(SimpleRabbitListenerContainerFactory.class);
				configurer.configure(factory, mock(ConnectionFactory.class));
				then(factory).should().setConcurrentConsumers(5);
				then(factory).should().setMaxConcurrentConsumers(10);
				then(factory).should().setPrefetchCount(40);
			});
	}
	@Test
	void testSimpleRabbitListenerContainerFactoryConfigurerEnableDeBatchingWithConsumerBatchEnabled() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.simple.consumer-batch-enabled:true')
			.run((context) -> {
				SimpleRabbitListenerContainerFactoryConfigurer configurer = context
					.getBean(SimpleRabbitListenerContainerFactoryConfigurer.class);
				SimpleRabbitListenerContainerFactory factory = mock(SimpleRabbitListenerContainerFactory.class);
				configurer.configure(factory, mock(ConnectionFactory.class));
				then(factory).should().setConsumerBatchEnabled(true);
			});
	}
	@Test
	void testDirectRabbitListenerContainerFactoryConfigurerUsesConfig() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.direct.consumers-per-queue:5',
					'spring.rabbitmq.listener.direct.prefetch:40',
					'spring.rabbitmq.listener.direct.de-batching-enabled:false')
			.run((context) -> {
				DirectRabbitListenerContainerFactoryConfigurer configurer = context
					.getBean(DirectRabbitListenerContainerFactoryConfigurer.class);
				DirectRabbitListenerContainerFactory factory = mock(DirectRabbitListenerContainerFactory.class);
				configurer.configure(factory, mock(ConnectionFactory.class));
				then(factory).should().setConsumersPerQueue(5);
				then(factory).should().setPrefetchCount(40);
				then(factory).should().setDeBatchingEnabled(false);
			});
	}
	private void checkCommonProps(AssertableApplicationContext context,
			AbstractRabbitListenerContainerFactory<?> containerFactory) {
		assertThat(containerFactory).hasFieldOrPropertyWithValue('autoStartup', Boolean.FALSE);
		assertThat(containerFactory).hasFieldOrPropertyWithValue('acknowledgeMode', AcknowledgeMode.MANUAL);
		assertThat(containerFactory).hasFieldOrPropertyWithValue('prefetchCount', 40);
		assertThat(containerFactory).hasFieldOrPropertyWithValue('messageConverter',
				context.getBean('myMessageConverter'));
		assertThat(containerFactory).hasFieldOrPropertyWithValue('defaultRequeueRejected', Boolean.FALSE);
		assertThat(containerFactory).hasFieldOrPropertyWithValue('idleEventInterval', 5L);
		assertThat(containerFactory).hasFieldOrPropertyWithValue('forceStop', true);
		Advice[] adviceChain = containerFactory.getAdviceChain();
		assertThat(adviceChain).isNotNull();
		assertThat(adviceChain).hasSize(1);
		Advice advice = adviceChain[0];
		MessageRecoverer messageRecoverer = context.getBean('myMessageRecoverer', MessageRecoverer.class);
		MethodInvocationRecoverer<?> mir = (MethodInvocationRecoverer<?>) ReflectionTestUtils.getField(advice,
				'recoverer');
		Message message = mock(Message.class);
		Exception ex = new Exception('test');
		mir.recover(new Object[] { 'foo', message }, ex);
		then(messageRecoverer).should().recover(message, ex);
		RetryTemplate retryTemplate = (RetryTemplate) ReflectionTestUtils.getField(advice, 'retryOperations');
		assertThat(retryTemplate).isNotNull();
		SimpleRetryPolicy retryPolicy = (SimpleRetryPolicy) ReflectionTestUtils.getField(retryTemplate, 'retryPolicy');
		ExponentialBackOffPolicy backOffPolicy = (ExponentialBackOffPolicy) ReflectionTestUtils.getField(retryTemplate,
				'backOffPolicy');
		assertThat(retryPolicy.getMaxAttempts()).isEqualTo(4);
		assertThat(backOffPolicy.getInitialInterval()).isEqualTo(2000);
		assertThat(backOffPolicy.getMultiplier()).isEqualTo(1.5);
		assertThat(backOffPolicy.getMaxInterval()).isEqualTo(5000);
	}
	@Test
	void enableRabbitAutomatically() {
		this.contextRunner.withUserConfiguration(NoEnableRabbitConfiguration.class).run((context) -> {
			assertThat(context).hasBean(RabbitListenerConfigUtils.RABBIT_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME);
			assertThat(context).hasBean(RabbitListenerConfigUtils.RABBIT_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME);
		});
	}
	@Test
	void customizeRequestedHeartBeat() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.requested-heartbeat:20')
			.run((context) -> {
				com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
				assertThat(rabbitConnectionFactory.getRequestedHeartbeat()).isEqualTo(20);
			});
	}
	@Test
	void customizeRequestedChannelMax() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.requested-channel-max:12')
			.run((context) -> {
				com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
				assertThat(rabbitConnectionFactory.getRequestedChannelMax()).isEqualTo(12);
			});
	}
	@ParameterizedTest
	@ValueSource(classes = { TestConfiguration.class, TestConfiguration6.class })
	@SuppressWarnings('unchecked')
	void customizeAllowedListPatterns(Class<?> configuration) {
		this.contextRunner.withUserConfiguration(configuration)
			.withPropertyValues('spring.rabbitmq.template.allowed-list-patterns:*')
			.run((context) -> {
				MessageConverter messageConverter = context.getBean(RabbitTemplate.class).getMessageConverter();
				assertThat(messageConverter).extracting('allowedListPatterns')
					.isInstanceOfSatisfying(Collection.class, (set) -> assertThat(set).contains('*'));
			});
	}
	@Test
	void customizeAllowedListPatternsWhenHasNoAllowedListDeserializingMessageConverter() {
		this.contextRunner.withUserConfiguration(CustomMessageConverterConfiguration.class)
			.withPropertyValues('spring.rabbitmq.template.allowed-list-patterns:*')
			.run((context) -> assertThat(context).getFailure()
				.hasRootCauseInstanceOf(InvalidConfigurationPropertyValueException.class));
	}
	@Test
	void noSslByDefault() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class).run((context) -> {
			com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
			assertThat(rabbitConnectionFactory.getSocketFactory()).isNull();
			assertThat(rabbitConnectionFactory.isSSL()).isFalse();
		});
	}
	@Test
	void enableSsl() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true')
			.run((context) -> {
				com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
				assertThat(rabbitConnectionFactory.isSSL()).isTrue();
				assertThat(rabbitConnectionFactory.getSocketFactory()).as('SocketFactory must use SSL')
					.isInstanceOf(SSLSocketFactory.class);
			});
	}
	@Test
	void enableSslWithInvalidSslBundleFails() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.bundle=invalid')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasMessageContaining('SSL bundle name "invalid" cannot be found');
			});
	}
	@Test
	// Make sure that we at least attempt to load the store
	void enableSslWithNonExistingKeystoreShouldFail() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true', 'spring.rabbitmq.ssl.key-store=foo',
					'spring.rabbitmq.ssl.key-store-password=secret')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasMessageContaining('foo');
				assertThat(context).getFailure().hasMessageContaining('does not exist');
			});
	}
	@Test
	// Make sure that we at least attempt to load the store
	void enableSslWithNonExistingTrustStoreShouldFail() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true', 'spring.rabbitmq.ssl.trust-store=bar',
					'spring.rabbitmq.ssl.trust-store-password=secret')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasMessageContaining('bar');
				assertThat(context).getFailure().hasMessageContaining('does not exist');
			});
	}
	@Test
	void enableSslWithInvalidKeystoreTypeShouldFail() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true', 'spring.rabbitmq.ssl.key-store=foo',
					'spring.rabbitmq.ssl.key-store-type=fooType')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasMessageContaining('fooType');
				assertThat(context).getFailure().hasRootCauseInstanceOf(NoSuchAlgorithmException.class);
			});
	}
	@Test
	void enableSslWithInvalidTrustStoreTypeShouldFail() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true', 'spring.rabbitmq.ssl.trust-store=bar',
					'spring.rabbitmq.ssl.trust-store-type=barType')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasMessageContaining('barType');
				assertThat(context).getFailure().hasRootCauseInstanceOf(NoSuchAlgorithmException.class);
			});
	}
	@Test
	void enableSslWithBundle() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.bundle=test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location=classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password=secret',
					'spring.ssl.bundle.jks.test-bundle.key.password=password')
			.run((context) -> {
				com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
				assertThat(rabbitConnectionFactory.isSSL()).isTrue();
			});
	}
	@Test
	void enableSslWithKeystoreTypeAndTrustStoreTypeShouldWork() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true',
					'spring.rabbitmq.ssl.key-store=/org/springframework/boot/autoconfigure/amqp/test.jks',
					'spring.rabbitmq.ssl.key-store-type=jks', 'spring.rabbitmq.ssl.key-store-password=secret',
					'spring.rabbitmq.ssl.trust-store=/org/springframework/boot/autoconfigure/amqp/test.jks',
					'spring.rabbitmq.ssl.trust-store-type=jks', 'spring.rabbitmq.ssl.trust-store-password=secret')
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void enableSslWithValidateServerCertificateFalse(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true',
					'spring.rabbitmq.ssl.validate-server-certificate=false')
			.run((context) -> {
				com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
				assertThat(rabbitConnectionFactory.isSSL()).isTrue();
				assertThat(output).contains('TrustEverythingTrustManager', 'SECURITY ALERT');
			});
	}
	@Test
	void enableSslWithValidateServerCertificateDefault(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true')
			.run((context) -> {
				com.rabbitmq.client.ConnectionFactory rabbitConnectionFactory = getTargetConnectionFactory(context);
				assertThat(rabbitConnectionFactory.isSSL()).isTrue();
				assertThat(output).doesNotContain('TrustEverythingTrustManager', 'SECURITY ALERT');
			});
	}
	@Test
	void enableSslWithValidStoreAlgorithmShouldWork() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true',
					'spring.rabbitmq.ssl.key-store=/org/springframework/boot/autoconfigure/amqp/test.jks',
					'spring.rabbitmq.ssl.key-store-type=jks', 'spring.rabbitmq.ssl.key-store-password=secret',
					'spring.rabbitmq.ssl.key-store-algorithm=PKIX',
					'spring.rabbitmq.ssl.trust-store=/org/springframework/boot/autoconfigure/amqp/test.jks',
					'spring.rabbitmq.ssl.trust-store-type=jks', 'spring.rabbitmq.ssl.trust-store-password=secret',
					'spring.rabbitmq.ssl.trust-store-algorithm=PKIX')
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void enableSslWithInvalidKeyStoreAlgorithmShouldFail() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true',
					'spring.rabbitmq.ssl.key-store=/org/springframework/boot/autoconfigure/amqp/test.jks',
					'spring.rabbitmq.ssl.key-store-type=jks', 'spring.rabbitmq.ssl.key-store-password=secret',
					'spring.rabbitmq.ssl.key-store-algorithm=test-invalid-algo')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasMessageContaining('test-invalid-algo');
				assertThat(context).getFailure().hasRootCauseInstanceOf(NoSuchAlgorithmException.class);
			});
	}
	@Test
	void enableSslWithInvalidTrustStoreAlgorithmShouldFail() {
		this.contextRunner.withUserConfiguration(TestConfiguration.class)
			.withPropertyValues('spring.rabbitmq.ssl.enabled:true',
					'spring.rabbitmq.ssl.trust-store=/org/springframework/boot/autoconfigure/amqp/test.jks',
					'spring.rabbitmq.ssl.trust-store-type=jks', 'spring.rabbitmq.ssl.trust-store-password=secret',
					'spring.rabbitmq.ssl.trust-store-algorithm=test-invalid-algo')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().hasMessageContaining('test-invalid-algo');
				assertThat(context).getFailure().hasRootCauseInstanceOf(NoSuchAlgorithmException.class);
			});
	}
	@Test
	void whenACredentialsProviderIsAvailableThenConnectionFactoryIsConfiguredToUseIt() {
		this.contextRunner.withUserConfiguration(CredentialsProviderConfiguration.class)
			.run((context) -> assertThat(getTargetConnectionFactory(context).params(null).getCredentialsProvider())
				.isEqualTo(CredentialsProviderConfiguration.credentialsProvider));
	}
	@Test
	void whenAPrimaryCredentialsProviderIsAvailableThenConnectionFactoryIsConfiguredToUseIt() {
		this.contextRunner.withUserConfiguration(PrimaryCredentialsProviderConfiguration.class)
			.run((context) -> assertThat(getTargetConnectionFactory(context).params(null).getCredentialsProvider())
				.isEqualTo(PrimaryCredentialsProviderConfiguration.credentialsProvider));
	}
	@Test
	void whenMultipleCredentialsProvidersAreAvailableThenConnectionFactoryUsesDefaultProvider() {
		this.contextRunner.withUserConfiguration(MultipleCredentialsProvidersConfiguration.class)
			.run((context) -> assertThat(getTargetConnectionFactory(context).params(null).getCredentialsProvider())
				.isInstanceOf(DefaultCredentialsProvider.class));
	}
	@Test
	void whenACredentialsRefreshServiceIsAvailableThenConnectionFactoryIsConfiguredToUseIt() {
		this.contextRunner.withUserConfiguration(CredentialsRefreshServiceConfiguration.class)
			.run((context) -> assertThat(
					getTargetConnectionFactory(context).params(null).getCredentialsRefreshService())
				.isEqualTo(CredentialsRefreshServiceConfiguration.credentialsRefreshService));
	}
	@Test
	void whenAPrimaryCredentialsRefreshServiceIsAvailableThenConnectionFactoryIsConfiguredToUseIt() {
		this.contextRunner.withUserConfiguration(PrimaryCredentialsRefreshServiceConfiguration.class)
			.run((context) -> assertThat(
					getTargetConnectionFactory(context).params(null).getCredentialsRefreshService())
				.isEqualTo(PrimaryCredentialsRefreshServiceConfiguration.credentialsRefreshService));
	}
	@Test
	void whenMultipleCredentialsRefreshServiceAreAvailableThenConnectionFactoryHasNoCredentialsRefreshService() {
		this.contextRunner.withUserConfiguration(MultipleCredentialsRefreshServicesConfiguration.class)
			.run((context) -> assertThat(
					getTargetConnectionFactory(context).params(null).getCredentialsRefreshService())
				.isNull());
	}
	@Test
	void whenAConnectionFactoryCustomizerIsDefinedThenItCustomizesTheConnectionFactory() {
		this.contextRunner.withUserConfiguration(SaslConfigCustomizerConfiguration.class)
			.run((context) -> assertThat(getTargetConnectionFactory(context).getSaslConfig())
				.isInstanceOf(JDKSaslConfig.class));
	}
	@Test
	void whenMultipleConnectionFactoryCustomizersAreDefinedThenTheyAreCalledInOrder() {
		this.contextRunner.withUserConfiguration(MultipleConnectionFactoryCustomizersConfiguration.class)
			.run((context) -> {
				ConnectionFactoryCustomizer firstCustomizer = context.getBean('firstCustomizer',
						ConnectionFactoryCustomizer.class);
				ConnectionFactoryCustomizer secondCustomizer = context.getBean('secondCustomizer',
						ConnectionFactoryCustomizer.class);
				InOrder inOrder = inOrder(firstCustomizer, secondCustomizer);
				com.rabbitmq.client.ConnectionFactory targetConnectionFactory = getTargetConnectionFactory(context);
				then(firstCustomizer).should(inOrder).customize(targetConnectionFactory);
				then(secondCustomizer).should(inOrder).customize(targetConnectionFactory);
				inOrder.verifyNoMoreInteractions();
			});
	}
	@Test
	@SuppressWarnings('unchecked')
	void whenASimpleContainerCustomizerIsDefinedThenItIsCalledToConfigureTheContainer() {
		this.contextRunner.withUserConfiguration(SimpleContainerCustomizerConfiguration.class)
			.run((context) -> then(context.getBean(ContainerCustomizer.class)).should()
				.configure(any(SimpleMessageListenerContainer.class)));
	}
	@Test
	@SuppressWarnings('unchecked')
	void whenADirectContainerCustomizerIsDefinedThenItIsCalledToConfigureTheContainer() {
		this.contextRunner.withUserConfiguration(DirectContainerCustomizerConfiguration.class)
			.withPropertyValues('spring.rabbitmq.listener.type:direct')
			.run((context) -> then(context.getBean(ContainerCustomizer.class)).should()
				.configure(any(DirectMessageListenerContainer.class)));
	}
	private com.rabbitmq.client.ConnectionFactory getTargetConnectionFactory(AssertableApplicationContext context) {
		CachingConnectionFactory connectionFactory = context.getBean(CachingConnectionFactory.class);
		return connectionFactory.getRabbitConnectionFactory();
	}
	private boolean getMandatory(RabbitTemplate rabbitTemplate) {
		return rabbitTemplate.isMandatoryFor(mock(Message.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration2 {
		@Bean
		ConnectionFactory aDifferentConnectionFactory() {
			return new CachingConnectionFactory('otherserver', 8001);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration3 {
		@Bean
		RabbitTemplate rabbitTemplate(ConnectionFactory connectionFactory, MessageConverter messageConverter) {
			RabbitTemplate rabbitTemplate = new RabbitTemplate(connectionFactory);
			rabbitTemplate.setMessageConverter(messageConverter);
			return rabbitTemplate;
		}
		@Bean
		MessageConverter testMessageConverter() {
			return mock(MessageConverter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration4 {
		@Bean
		RabbitMessagingTemplate messagingTemplate(RabbitTemplate rabbitTemplate) {
			RabbitMessagingTemplate messagingTemplate = new RabbitMessagingTemplate(rabbitTemplate);
			messagingTemplate.setDefaultDestination('fooBar');
			return messagingTemplate;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration5 {
		@Bean
		RabbitListenerContainerFactory<?> rabbitListenerContainerFactory() {
			return mock(SimpleRabbitListenerContainerFactory.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfiguration6 {
		@Bean
		MessageConverter messageConverter() {
			return new SerializerMessageConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MessageConvertersConfiguration {
		@Bean
		@Primary
		MessageConverter myMessageConverter() {
			return mock(MessageConverter.class);
		}
		@Bean
		MessageConverter anotherMessageConverter() {
			return mock(MessageConverter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MessageRecoverersConfiguration {
		@Bean
		@Primary
		MessageRecoverer myMessageRecoverer() {
			return mock(MessageRecoverer.class);
		}
		@Bean
		MessageRecoverer anotherMessageRecoverer() {
			return mock(MessageRecoverer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleRabbitTemplateCustomizersConfiguration {
		@Bean
		@Order(Ordered.LOWEST_PRECEDENCE)
		RabbitTemplateCustomizer secondCustomizer() {
			return mock(RabbitTemplateCustomizer.class);
		}
		@Bean
		@Order(0)
		RabbitTemplateCustomizer firstCustomizer() {
			return mock(RabbitTemplateCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionNameStrategyConfiguration {
		private final AtomicInteger counter = new AtomicInteger();
		@Bean
		ConnectionNameStrategy myConnectionNameStrategy() {
			return (connectionFactory) -> 'test#' + this.counter.getAndIncrement();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RabbitRetryTemplateCustomizerConfiguration {
		private final BackOffPolicy backOffPolicy = new ExponentialBackOffPolicy();
		private final RetryPolicy retryPolicy = new NeverRetryPolicy();
		@Bean
		RabbitRetryTemplateCustomizer rabbitTemplateRetryTemplateCustomizer() {
			return (target, template) -> {
				if (target.equals(RabbitRetryTemplateCustomizer.Target.SENDER)) {
					template.setBackOffPolicy(this.backOffPolicy);
				}
			};
		}
		@Bean
		RabbitRetryTemplateCustomizer rabbitListenerRetryTemplateCustomizer() {
			return (target, template) -> {
				if (target.equals(RabbitRetryTemplateCustomizer.Target.LISTENER)) {
					template.setRetryPolicy(this.retryPolicy);
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableRabbit
	static class EnableRabbitConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class NoEnableRabbitConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class CredentialsProviderConfiguration {
		private static final CredentialsProvider credentialsProvider = mock(CredentialsProvider.class);
		@Bean
		CredentialsProvider credentialsProvider() {
			return credentialsProvider;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PrimaryCredentialsProviderConfiguration {
		private static final CredentialsProvider credentialsProvider = mock(CredentialsProvider.class);
		@Bean
		@Primary
		CredentialsProvider credentialsProvider() {
			return credentialsProvider;
		}
		@Bean
		CredentialsProvider credentialsProvider1() {
			return mock(CredentialsProvider.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleCredentialsProvidersConfiguration {
		@Bean
		CredentialsProvider credentialsProvider1() {
			return mock(CredentialsProvider.class);
		}
		@Bean
		CredentialsProvider credentialsProvider2() {
			return mock(CredentialsProvider.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CredentialsRefreshServiceConfiguration {
		private static final CredentialsRefreshService credentialsRefreshService = mock(
				CredentialsRefreshService.class);
		@Bean
		CredentialsRefreshService credentialsRefreshService() {
			return credentialsRefreshService;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PrimaryCredentialsRefreshServiceConfiguration {
		private static final CredentialsRefreshService credentialsRefreshService = mock(
				CredentialsRefreshService.class);
		@Bean
		@Primary
		CredentialsRefreshService credentialsRefreshService1() {
			return credentialsRefreshService;
		}
		@Bean
		CredentialsRefreshService credentialsRefreshService2() {
			return mock(CredentialsRefreshService.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleCredentialsRefreshServicesConfiguration {
		@Bean
		CredentialsRefreshService credentialsRefreshService1() {
			return mock(CredentialsRefreshService.class);
		}
		@Bean
		CredentialsRefreshService credentialsRefreshService2() {
			return mock(CredentialsRefreshService.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SaslConfigCustomizerConfiguration {
		@Bean
		ConnectionFactoryCustomizer connectionFactoryCustomizer() {
			return (connectionFactory) -> connectionFactory.setSaslConfig(new JDKSaslConfig(connectionFactory));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MultipleConnectionFactoryCustomizersConfiguration {
		@Bean
		@Order(Ordered.LOWEST_PRECEDENCE)
		ConnectionFactoryCustomizer secondCustomizer() {
			return mock(ConnectionFactoryCustomizer.class);
		}
		@Bean
		@Order(0)
		ConnectionFactoryCustomizer firstCustomizer() {
			return mock(ConnectionFactoryCustomizer.class);
		}
	}
	@Import(TestListener.class)
	@Configuration(proxyBeanMethods = false)
	static class SimpleContainerCustomizerConfiguration {
		@Bean
		@SuppressWarnings('unchecked')
		ContainerCustomizer<SimpleMessageListenerContainer> customizer() {
			return mock(ContainerCustomizer.class);
		}
	}
	@Import(TestListener.class)
	@Configuration(proxyBeanMethods = false)
	static class DirectContainerCustomizerConfiguration {
		@Bean
		@SuppressWarnings('unchecked')
		ContainerCustomizer<DirectMessageListenerContainer> customizer() {
			return mock(ContainerCustomizer.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		RabbitConnectionDetails rabbitConnectionDetails() {
			return new RabbitConnectionDetails() {
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'password-1';
				}
				@Override
				public String getVirtualHost() {
					return '/vhost-1';
				}
				@Override
				public List<Address> getAddresses() {
					return List.of(new Address('rabbit.example.com', 12345), new Address('rabbit2.example.com', 23456));
				}
			};
		}
	}
	@Configuration
	static class CustomMessageConverterConfiguration {
		@Bean
		MessageConverter messageConverter() {
			return new MessageConverter() {
				@Override
				public Message toMessage(Object object, MessageProperties messageProperties)
						throws MessageConversionException {
					return new Message(object.toString().getBytes());
				}
				@Override
				public Object fromMessage(Message message) throws MessageConversionException {
					return new String(message.getBody());
				}
			};
		}
	}
	static class TestListener {
		@RabbitListener(queues = 'test', autoStartup = 'false')
		void listen(String in) {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.amqp;
/**
class PropertiesRabbitConnectionDetailsTests {
	private static final int DEFAULT_PORT = 5672;
	@Test
	void getAddresses() {
		RabbitProperties properties = new RabbitProperties();
		properties.setAddresses(List.of('localhost', 'localhost:1234', '[::1]', '[::1]:32863'));
		PropertiesRabbitConnectionDetails propertiesRabbitConnectionDetails = new PropertiesRabbitConnectionDetails(
				properties);
		List<Address> addresses = propertiesRabbitConnectionDetails.getAddresses();
		assertThat(addresses.size()).isEqualTo(4);
		assertThat(addresses.get(0).host()).isEqualTo('localhost');
		assertThat(addresses.get(0).port()).isEqualTo(DEFAULT_PORT);
		assertThat(addresses.get(1).host()).isEqualTo('localhost');
		assertThat(addresses.get(1).port()).isEqualTo(1234);
		assertThat(addresses.get(2).host()).isEqualTo('[::1]');
		assertThat(addresses.get(2).port()).isEqualTo(DEFAULT_PORT);
		assertThat(addresses.get(3).host()).isEqualTo('[::1]');
		assertThat(addresses.get(3).port()).isEqualTo(32863);
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public class TestAutoConfigurationSorter extends AutoConfigurationSorter {
	public TestAutoConfigurationSorter(MetadataReaderFactory metadataReaderFactory,
			UnaryOperator<String> replacementMapper) {
		super(metadataReaderFactory, AutoConfigurationMetadataLoader.loadMetadata(new Properties()), replacementMapper);
	}
	@Override
	public List<String> getInPriorityOrder(Collection<String> classNames) {
		return super.getInPriorityOrder(classNames);
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationMetadataLoaderTests {
	@Test
	void loadShouldLoadProperties() {
		assertThat(load()).isNotNull();
	}
	@Test
	void wasProcessedWhenProcessedShouldReturnTrue() {
		assertThat(load().wasProcessed('test')).isTrue();
	}
	@Test
	void wasProcessedWhenNotProcessedShouldReturnFalse() {
		assertThat(load().wasProcessed('testx')).isFalse();
	}
	@Test
	void getIntegerShouldReturnValue() {
		assertThat(load().getInteger('test', 'int')).isEqualTo(123);
	}
	@Test
	void getIntegerWhenMissingShouldReturnNull() {
		assertThat(load().getInteger('test', 'intx')).isNull();
	}
	@Test
	void getIntegerWithDefaultWhenMissingShouldReturnDefault() {
		assertThat(load().getInteger('test', 'intx', 345)).isEqualTo(345);
	}
	@Test
	void getSetShouldReturnValue() {
		assertThat(load().getSet('test', 'set')).containsExactly('a', 'b', 'c');
	}
	@Test
	void getSetWhenMissingShouldReturnNull() {
		assertThat(load().getSet('test', 'setx')).isNull();
	}
	@Test
	void getSetWithDefaultWhenMissingShouldReturnDefault() {
		assertThat(load().getSet('test', 'setx', Collections.singleton('x'))).containsExactly('x');
	}
	@Test
	void getShouldReturnValue() {
		assertThat(load().get('test', 'string')).isEqualTo('abc');
	}
	@Test
	void getWhenMissingShouldReturnNull() {
		assertThat(load().get('test', 'stringx')).isNull();
	}
	@Test
	void getWithDefaultWhenMissingShouldReturnDefault() {
		assertThat(load().get('test', 'stringx', 'xyz')).isEqualTo('xyz');
	}
	private AutoConfigurationMetadata load() {
		return AutoConfigurationMetadataLoader.loadMetadata(null,
				'META-INF/AutoConfigurationMetadataLoaderTests.properties');
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@DirtiesContext
@SpringBootTest
class SpringJUnitTests {
	@Autowired
	private ApplicationContext context;
	@Value('${foo:spam}')
	private String foo = 'bar';
	@Test
	void testContextCreated() {
		assertThat(this.context).isNotNull();
	}
	@Test
	void testContextInitialized() {
		assertThat(this.foo).isEqualTo('bucket');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ PropertyPlaceholderAutoConfiguration.class })
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
@DisabledOnOs(OS.WINDOWS)
@EmbeddedKafka(topics = KafkaAutoConfigurationIntegrationTests.TEST_TOPIC)
class KafkaAutoConfigurationIntegrationTests {
	static final String TEST_TOPIC = 'testTopic';
	static final String TEST_RETRY_TOPIC = 'testRetryTopic';
	private static final String ADMIN_CREATED_TOPIC = 'adminCreatedTopic';
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void close() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@SuppressWarnings({ 'unchecked', 'rawtypes' })
	@Test
	void testEndToEnd() throws Exception {
		load(KafkaConfig.class, 'spring.kafka.bootstrap-servers:' + getEmbeddedKafkaBrokersAsString(),
				'spring.kafka.consumer.group-id=testGroup', 'spring.kafka.consumer.auto-offset-reset=earliest');
		KafkaTemplate<String, String> template = this.context.getBean(KafkaTemplate.class);
		template.send(TEST_TOPIC, 'foo', 'bar');
		Listener listener = this.context.getBean(Listener.class);
		assertThat(listener.latch.await(30, TimeUnit.SECONDS)).isTrue();
		assertThat(listener.key).isEqualTo('foo');
		assertThat(listener.received).isEqualTo('bar');
		DefaultKafkaProducerFactory producerFactory = this.context.getBean(DefaultKafkaProducerFactory.class);
		Producer producer = producerFactory.createProducer();
		assertThat(producer.partitionsFor(ADMIN_CREATED_TOPIC)).hasSize(10);
		producer.close();
	}
	@SuppressWarnings('unchecked')
	@Test
	void testEndToEndWithRetryTopics() throws Exception {
		load(KafkaConfig.class, 'spring.kafka.bootstrap-servers:' + getEmbeddedKafkaBrokersAsString(),
				'spring.kafka.consumer.group-id=testGroup', 'spring.kafka.retry.topic.enabled=true',
				'spring.kafka.retry.topic.attempts=5', 'spring.kafka.retry.topic.delay=100ms',
				'spring.kafka.retry.topic.multiplier=2', 'spring.kafka.retry.topic.max-delay=300ms',
				'spring.kafka.consumer.auto-offset-reset=earliest');
		RetryTopicConfiguration configuration = this.context.getBean(RetryTopicConfiguration.class);
		assertThat(configuration.getDestinationTopicProperties()).extracting(DestinationTopic.Properties::delay)
			.containsExactly(0L, 100L, 200L, 300L, 0L);
		KafkaTemplate<String, String> template = this.context.getBean(KafkaTemplate.class);
		template.send(TEST_RETRY_TOPIC, 'foo', 'bar');
		RetryListener listener = this.context.getBean(RetryListener.class);
		assertThat(listener.latch.await(30, TimeUnit.SECONDS)).isTrue();
		assertThat(listener).extracting(RetryListener::getKey, RetryListener::getReceived)
			.containsExactly('foo', 'bar');
		assertThat(listener).extracting(RetryListener::getTopics)
			.asInstanceOf(InstanceOfAssertFactories.LIST)
			.hasSize(5)
			.containsSequence('testRetryTopic', 'testRetryTopic-retry-0', 'testRetryTopic-retry-1',
					'testRetryTopic-retry-2');
	}
	@Test
	void testStreams() {
		load(KafkaStreamsConfig.class, 'spring.application.name:my-app',
				'spring.kafka.bootstrap-servers:' + getEmbeddedKafkaBrokersAsString());
		assertThat(this.context.getBean(StreamsBuilderFactoryBean.class).isAutoStartup()).isTrue();
	}
	private void load(Class<?> config, String... environment) {
		this.context = doLoad(new Class<?>[] { config }, environment);
	}
	private AnnotationConfigApplicationContext doLoad(Class<?>[] configs, String... environment) {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		applicationContext.register(configs);
		applicationContext.register(SslAutoConfiguration.class);
		applicationContext.register(KafkaAutoConfiguration.class);
		TestPropertyValues.of(environment).applyTo(applicationContext);
		applicationContext.refresh();
		return applicationContext;
	}
	private String getEmbeddedKafkaBrokersAsString() {
		return EmbeddedKafkaCondition.getBroker().getBrokersAsString();
	}
	@Configuration(proxyBeanMethods = false)
	static class KafkaConfig {
		@Bean
		Listener listener() {
			return new Listener();
		}
		@Bean
		RetryListener retryListener() {
			return new RetryListener();
		}
		@Bean
		NewTopic adminCreated() {
			return TopicBuilder.name(ADMIN_CREATED_TOPIC).partitions(10).replicas(1).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableKafkaStreams
	static class KafkaStreamsConfig {
		@Bean
		KTable<?, ?> table(StreamsBuilder builder) {
			KStream<Object, Object> stream = builder.stream(Pattern.compile('test'));
			return stream.groupByKey().count(Materialized.as('store'));
		}
	}
	static class Listener {
		private final CountDownLatch latch = new CountDownLatch(1);
		private volatile String received;
		private volatile String key;
		@KafkaListener(topics = TEST_TOPIC)
		void listen(String foo, @Header(KafkaHeaders.RECEIVED_KEY) String key) {
			this.received = foo;
			this.key = key;
			this.latch.countDown();
		}
	}
	static class RetryListener {
		private final CountDownLatch latch = new CountDownLatch(5);
		private final List<String> topics = new ArrayList<>();
		private volatile String received;
		private volatile String key;
		@KafkaListener(topics = TEST_RETRY_TOPIC)
		void listen(String foo, @Header(KafkaHeaders.RECEIVED_KEY) String key,
				@Header(KafkaHeaders.RECEIVED_TOPIC) String topic) {
			this.received = foo;
			this.key = key;
			this.topics.add(topic);
			this.latch.countDown();
			throw new RuntimeException('Test exception');
		}
		private List<String> getTopics() {
			return this.topics;
		}
		private String getReceived() {
			return this.received;
		}
		private String getKey() {
			return this.key;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
class KafkaAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(KafkaAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void consumerProperties() {
		this.contextRunner.withPropertyValues('spring.kafka.bootstrap-servers=foo:1234',
				'spring.kafka.properties.foo=bar', 'spring.kafka.properties.baz=qux',
				'spring.kafka.properties.foo.bar.baz=qux.fiz.buz', 'spring.kafka.ssl.key-password=p1',
				'spring.kafka.ssl.key-store-location=classpath:ksLoc', 'spring.kafka.ssl.key-store-password=p2',
				'spring.kafka.ssl.key-store-type=PKCS12', 'spring.kafka.ssl.trust-store-location=classpath:tsLoc',
				'spring.kafka.ssl.trust-store-password=p3', 'spring.kafka.ssl.trust-store-type=PKCS12',
				'spring.kafka.ssl.protocol=TLSv1.2', 'spring.kafka.consumer.auto-commit-interval=123',
				'spring.kafka.consumer.max-poll-records=42', 'spring.kafka.consumer.auto-offset-reset=earliest',
				'spring.kafka.consumer.client-id=ccid', // test override common
				'spring.kafka.consumer.enable-auto-commit=false', 'spring.kafka.consumer.fetch-max-wait=456',
				'spring.kafka.consumer.properties.fiz.buz=fix.fox', 'spring.kafka.consumer.fetch-min-size=1KB',
				'spring.kafka.consumer.group-id=bar', 'spring.kafka.consumer.heartbeat-interval=234',
				'spring.kafka.consumer.isolation-level = read-committed',
				'spring.kafka.consumer.security.protocol = SSL',
				'spring.kafka.consumer.key-deserializer = org.apache.kafka.common.serialization.LongDeserializer',
				'spring.kafka.consumer.value-deserializer = org.apache.kafka.common.serialization.IntegerDeserializer')
			.run((context) -> {
				DefaultKafkaConsumerFactory<?, ?> consumerFactory = context.getBean(DefaultKafkaConsumerFactory.class);
				Map<String, Object> configs = consumerFactory.getConfigurationProperties();
				// common
				assertThat(configs).containsEntry(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('foo:1234'));
				assertThat(configs).containsEntry(SslConfigs.SSL_KEY_PASSWORD_CONFIG, 'p1');
				assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'ksLoc');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, 'p2');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'tsLoc');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, 'p3');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat(configs).containsEntry(SslConfigs.SSL_PROTOCOL_CONFIG, 'TLSv1.2');
				// consumer
				assertThat(configs).containsEntry(ConsumerConfig.CLIENT_ID_CONFIG, 'ccid'); // override
				assertThat(configs).containsEntry(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, Boolean.FALSE);
				assertThat(configs).containsEntry(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, 123);
				assertThat(configs).containsEntry(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, 'earliest');
				assertThat(configs).containsEntry(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG, 456);
				assertThat(configs).containsEntry(ConsumerConfig.FETCH_MIN_BYTES_CONFIG, 1024);
				assertThat(configs).containsEntry(ConsumerConfig.GROUP_ID_CONFIG, 'bar');
				assertThat(configs).containsEntry(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, 234);
				assertThat(configs).containsEntry(ConsumerConfig.ISOLATION_LEVEL_CONFIG, 'read_committed');
				assertThat(configs).containsEntry(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, LongDeserializer.class);
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'SSL');
				assertThat(configs).containsEntry(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG,
						IntegerDeserializer.class);
				assertThat(configs).containsEntry(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 42);
				assertThat(configs).containsEntry('foo', 'bar');
				assertThat(configs).containsEntry('baz', 'qux');
				assertThat(configs).containsEntry('foo.bar.baz', 'qux.fiz.buz');
				assertThat(configs).containsEntry('fiz.buz', 'fix.fox');
			});
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesKafkaConnectionDetails.class));
	}
	@Test
	void connectionDetailsAreAppliedToConsumer() {
		this.contextRunner
			.withPropertyValues('spring.kafka.bootstrap-servers=foo:1234',
					'spring.kafka.consumer.bootstrap-servers=foo:1234', 'spring.kafka.security.protocol=SSL',
					'spring.kafka.consumer.security.protocol=SSL')
			.withBean(KafkaConnectionDetails.class, this::kafkaConnectionDetails)
			.run((context) -> {
				assertThat(context).hasSingleBean(KafkaConnectionDetails.class)
					.doesNotHaveBean(PropertiesKafkaConnectionDetails.class);
				DefaultKafkaConsumerFactory<?, ?> consumerFactory = context.getBean(DefaultKafkaConsumerFactory.class);
				Map<String, Object> configs = consumerFactory.getConfigurationProperties();
				assertThat(configs).containsEntry(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
			});
	}
	@Test
	void producerProperties() {
		this.contextRunner.withPropertyValues('spring.kafka.clientId=cid',
				'spring.kafka.properties.foo.bar.baz=qux.fiz.buz', 'spring.kafka.producer.acks=all',
				'spring.kafka.producer.batch-size=2KB', 'spring.kafka.producer.bootstrap-servers=bar:1234', // test
				// override
				'spring.kafka.producer.buffer-memory=4KB', 'spring.kafka.producer.compression-type=gzip',
				'spring.kafka.producer.key-serializer=org.apache.kafka.common.serialization.LongSerializer',
				'spring.kafka.producer.retries=2', 'spring.kafka.producer.properties.fiz.buz=fix.fox',
				'spring.kafka.producer.security.protocol=SSL', 'spring.kafka.producer.ssl.key-password=p4',
				'spring.kafka.producer.ssl.key-store-location=classpath:ksLocP',
				'spring.kafka.producer.ssl.key-store-password=p5', 'spring.kafka.producer.ssl.key-store-type=PKCS12',
				'spring.kafka.producer.ssl.trust-store-location=classpath:tsLocP',
				'spring.kafka.producer.ssl.trust-store-password=p6',
				'spring.kafka.producer.ssl.trust-store-type=PKCS12', 'spring.kafka.producer.ssl.protocol=TLSv1.2',
				'spring.kafka.producer.value-serializer=org.apache.kafka.common.serialization.IntegerSerializer')
			.run((context) -> {
				DefaultKafkaProducerFactory<?, ?> producerFactory = context.getBean(DefaultKafkaProducerFactory.class);
				Map<String, Object> configs = producerFactory.getConfigurationProperties();
				// common
				assertThat(configs).containsEntry(ProducerConfig.CLIENT_ID_CONFIG, 'cid');
				// producer
				assertThat(configs).containsEntry(ProducerConfig.ACKS_CONFIG, 'all');
				assertThat(configs).containsEntry(ProducerConfig.BATCH_SIZE_CONFIG, 2048);
				assertThat(configs).containsEntry(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('bar:1234')); // override
				assertThat(configs).containsEntry(ProducerConfig.BUFFER_MEMORY_CONFIG, 4096L);
				assertThat(configs).containsEntry(ProducerConfig.COMPRESSION_TYPE_CONFIG, 'gzip');
				assertThat(configs).containsEntry(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, LongSerializer.class);
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'SSL');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEY_PASSWORD_CONFIG, 'p4');
				assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'ksLocP');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, 'p5');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'tsLocP');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, 'p6');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat(configs).containsEntry(SslConfigs.SSL_PROTOCOL_CONFIG, 'TLSv1.2');
				assertThat(configs).containsEntry(ProducerConfig.RETRIES_CONFIG, 2);
				assertThat(configs).containsEntry(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG,
						IntegerSerializer.class);
				assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty();
				assertThat(context.getBeansOfType(KafkaTransactionManager.class)).isEmpty();
				assertThat(configs).containsEntry('foo.bar.baz', 'qux.fiz.buz');
				assertThat(configs).containsEntry('fiz.buz', 'fix.fox');
			});
	}
	@Test
	void connectionDetailsAreAppliedToProducer() {
		this.contextRunner
			.withPropertyValues('spring.kafka.bootstrap-servers=foo:1234',
					'spring.kafka.producer.bootstrap-servers=foo:1234', 'spring.kafka.security.protocol=SSL',
					'spring.kafka.producer.security.protocol=SSL')
			.withBean(KafkaConnectionDetails.class, this::kafkaConnectionDetails)
			.run((context) -> {
				assertThat(context).hasSingleBean(KafkaConnectionDetails.class)
					.doesNotHaveBean(PropertiesKafkaConnectionDetails.class);
				DefaultKafkaProducerFactory<?, ?> producerFactory = context.getBean(DefaultKafkaProducerFactory.class);
				Map<String, Object> configs = producerFactory.getConfigurationProperties();
				assertThat(configs).containsEntry(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
			});
	}
	@Test
	void adminProperties() {
		this.contextRunner
			.withPropertyValues('spring.kafka.clientId=cid', 'spring.kafka.properties.foo.bar.baz=qux.fiz.buz',
					'spring.kafka.admin.fail-fast=true', 'spring.kafka.admin.properties.fiz.buz=fix.fox',
					'spring.kafka.admin.security.protocol=SSL', 'spring.kafka.admin.ssl.key-password=p4',
					'spring.kafka.admin.ssl.key-store-location=classpath:ksLocP',
					'spring.kafka.admin.ssl.key-store-password=p5', 'spring.kafka.admin.ssl.key-store-type=PKCS12',
					'spring.kafka.admin.ssl.trust-store-location=classpath:tsLocP',
					'spring.kafka.admin.ssl.trust-store-password=p6', 'spring.kafka.admin.ssl.trust-store-type=PKCS12',
					'spring.kafka.admin.ssl.protocol=TLSv1.2', 'spring.kafka.admin.close-timeout=35s',
					'spring.kafka.admin.operation-timeout=60s', 'spring.kafka.admin.modify-topic-configs=true',
					'spring.kafka.admin.auto-create=false')
			.run((context) -> {
				KafkaAdmin admin = context.getBean(KafkaAdmin.class);
				Map<String, Object> configs = admin.getConfigurationProperties();
				// common
				assertThat(configs).containsEntry(AdminClientConfig.CLIENT_ID_CONFIG, 'cid');
				// admin
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'SSL');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEY_PASSWORD_CONFIG, 'p4');
				assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'ksLocP');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, 'p5');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'tsLocP');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, 'p6');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat(configs).containsEntry(SslConfigs.SSL_PROTOCOL_CONFIG, 'TLSv1.2');
				assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty();
				assertThat(configs).containsEntry('foo.bar.baz', 'qux.fiz.buz');
				assertThat(configs).containsEntry('fiz.buz', 'fix.fox');
				assertThat(admin).hasFieldOrPropertyWithValue('closeTimeout', Duration.ofSeconds(35));
				assertThat(admin).hasFieldOrPropertyWithValue('operationTimeout', 60);
				assertThat(admin).hasFieldOrPropertyWithValue('fatalIfBrokerNotAvailable', true);
				assertThat(admin).hasFieldOrPropertyWithValue('modifyTopicConfigs', true);
				assertThat(admin).hasFieldOrPropertyWithValue('autoCreate', false);
			});
	}
	@Test
	void connectionDetailsAreAppliedToAdmin() {
		this.contextRunner
			.withPropertyValues('spring.kafka.bootstrap-servers=foo:1234', 'spring.kafka.security.protocol=SSL',
					'spring.kafka.admin.security.protocol=SSL')
			.withBean(KafkaConnectionDetails.class, this::kafkaConnectionDetails)
			.run((context) -> {
				assertThat(context).hasSingleBean(KafkaConnectionDetails.class)
					.doesNotHaveBean(PropertiesKafkaConnectionDetails.class);
				KafkaAdmin admin = context.getBean(KafkaAdmin.class);
				Map<String, Object> configs = admin.getConfigurationProperties();
				assertThat(configs).containsEntry(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
				assertThat(configs).containsEntry(AdminClientConfig.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void streamsProperties() {
		this.contextRunner.withUserConfiguration(EnableKafkaStreamsConfiguration.class)
			.withPropertyValues('spring.kafka.client-id=cid',
					'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.application.name=appName',
					'spring.kafka.properties.foo.bar.baz=qux.fiz.buz', 'spring.kafka.streams.auto-startup=false',
					'spring.kafka.streams.state-store-cache-max-size=1KB', 'spring.kafka.streams.client-id=override',
					'spring.kafka.streams.properties.fiz.buz=fix.fox', 'spring.kafka.streams.replication-factor=2',
					'spring.kafka.streams.state-dir=/tmp/state', 'spring.kafka.streams.security.protocol=SSL',
					'spring.kafka.streams.ssl.key-password=p7',
					'spring.kafka.streams.ssl.key-store-location=classpath:ksLocP',
					'spring.kafka.streams.ssl.key-store-password=p8', 'spring.kafka.streams.ssl.key-store-type=PKCS12',
					'spring.kafka.streams.ssl.trust-store-location=classpath:tsLocP',
					'spring.kafka.streams.ssl.trust-store-password=p9',
					'spring.kafka.streams.ssl.trust-store-type=PKCS12', 'spring.kafka.streams.ssl.protocol=TLSv1.2')
			.run((context) -> {
				Properties configs = context
					.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME,
							KafkaStreamsConfiguration.class)
					.asProperties();
				assertThat((List<String>) configs.get(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG))
					.containsExactly('localhost:9092', 'localhost:9093');
				assertThat(configs).containsEntry(StreamsConfig.STATESTORE_CACHE_MAX_BYTES_CONFIG, 1024);
				assertThat(configs).containsEntry(StreamsConfig.CLIENT_ID_CONFIG, 'override');
				assertThat(configs).containsEntry(StreamsConfig.REPLICATION_FACTOR_CONFIG, 2);
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'SSL');
				assertThat(configs).containsEntry(StreamsConfig.STATE_DIR_CONFIG, '/tmp/state');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEY_PASSWORD_CONFIG, 'p7');
				assertThat((String) configs.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'ksLocP');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, 'p8');
				assertThat(configs).containsEntry(SslConfigs.SSL_KEYSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat((String) configs.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG))
					.endsWith(File.separator + 'tsLocP');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG, 'p9');
				assertThat(configs).containsEntry(SslConfigs.SSL_TRUSTSTORE_TYPE_CONFIG, 'PKCS12');
				assertThat(configs).containsEntry(SslConfigs.SSL_PROTOCOL_CONFIG, 'TLSv1.2');
				assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).isEmpty();
				assertThat(configs).containsEntry('foo.bar.baz', 'qux.fiz.buz');
				assertThat(configs).containsEntry('fiz.buz', 'fix.fox');
				assertThat(context.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_BUILDER_BEAN_NAME))
					.isNotNull();
			});
	}
	@Test
	void connectionDetailsAreAppliedToStreams() {
		this.contextRunner.withUserConfiguration(EnableKafkaStreamsConfiguration.class)
			.withPropertyValues('spring.kafka.streams.auto-startup=false', 'spring.kafka.streams.application-id=test',
					'spring.kafka.bootstrap-servers=foo:1234', 'spring.kafka.streams.bootstrap-servers=foo:1234',
					'spring.kafka.security.protocol=SSL', 'spring.kafka.streams.security.protocol=SSL')
			.withBean(KafkaConnectionDetails.class, this::kafkaConnectionDetails)
			.run((context) -> {
				assertThat(context).hasSingleBean(KafkaConnectionDetails.class)
					.doesNotHaveBean(PropertiesKafkaConnectionDetails.class);
				Properties configs = context
					.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME,
							KafkaStreamsConfiguration.class)
					.asProperties();
				assertThat(configs).containsEntry(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,
						Collections.singletonList('kafka.example.com:12345'));
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
				assertThat(configs).containsEntry(StreamsConfig.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
			});
	}
	@SuppressWarnings('unchecked')
	@Test
	void streamsApplicationIdUsesMainApplicationNameByDefault() {
		this.contextRunner.withUserConfiguration(EnableKafkaStreamsConfiguration.class)
			.withPropertyValues('spring.application.name=my-test-app',
					'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093',
					'spring.kafka.streams.auto-startup=false')
			.run((context) -> {
				Properties configs = context
					.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME,
							KafkaStreamsConfiguration.class)
					.asProperties();
				assertThat((List<String>) configs.get(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG))
					.containsExactly('localhost:9092', 'localhost:9093');
				assertThat(configs).containsEntry(StreamsConfig.APPLICATION_ID_CONFIG, 'my-test-app');
			});
	}
	@Test
	void streamsWithCustomKafkaConfiguration() {
		this.contextRunner
			.withUserConfiguration(EnableKafkaStreamsConfiguration.class, TestKafkaStreamsConfiguration.class)
			.withPropertyValues('spring.application.name=my-test-app',
					'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093',
					'spring.kafka.streams.auto-startup=false')
			.run((context) -> {
				Properties configs = context
					.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME,
							KafkaStreamsConfiguration.class)
					.asProperties();
				assertThat(configs).containsEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG,
						'localhost:9094, localhost:9095');
				assertThat(configs).containsEntry(StreamsConfig.APPLICATION_ID_CONFIG, 'test-id');
			});
	}
	@Test
	void retryTopicConfigurationIsNotEnabledByDefault() {
		this.contextRunner
			.withPropertyValues('spring.application.name=my-test-app',
					'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093')
			.run((context) -> assertThat(context).doesNotHaveBean(RetryTopicConfiguration.class));
	}
	@Test
	void retryTopicConfigurationWithExponentialBackOff() {
		this.contextRunner.withPropertyValues('spring.application.name=my-test-app',
				'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.kafka.retry.topic.enabled=true',
				'spring.kafka.retry.topic.attempts=5', 'spring.kafka.retry.topic.backoff.delay=100ms',
				'spring.kafka.retry.topic.backoff.multiplier=2', 'spring.kafka.retry.topic.backoff.max-delay=300ms')
			.run((context) -> {
				RetryTopicConfiguration configuration = context.getBean(RetryTopicConfiguration.class);
				assertThat(configuration.getDestinationTopicProperties()).hasSize(5)
					.extracting(DestinationTopic.Properties::delay, DestinationTopic.Properties::suffix)
					.containsExactly(tuple(0L, ''), tuple(100L, '-retry-0'), tuple(200L, '-retry-1'),
							tuple(300L, '-retry-2'), tuple(0L, '-dlt'));
			});
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void retryTopicConfigurationWithExponentialBackOffUsingDeprecatedProperties() {
		this.contextRunner.withPropertyValues('spring.application.name=my-test-app',
				'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.kafka.retry.topic.enabled=true',
				'spring.kafka.retry.topic.attempts=5', 'spring.kafka.retry.topic.delay=100ms',
				'spring.kafka.retry.topic.multiplier=2', 'spring.kafka.retry.topic.max-delay=300ms')
			.run((context) -> {
				RetryTopicConfiguration configuration = context.getBean(RetryTopicConfiguration.class);
				assertThat(configuration.getDestinationTopicProperties()).hasSize(5)
					.extracting(DestinationTopic.Properties::delay, DestinationTopic.Properties::suffix)
					.containsExactly(tuple(0L, ''), tuple(100L, '-retry-0'), tuple(200L, '-retry-1'),
							tuple(300L, '-retry-2'), tuple(0L, '-dlt'));
			});
	}
	@Test
	void retryTopicConfigurationWithDefaultProperties() {
		this.contextRunner.withPropertyValues('spring.application.name=my-test-app',
				'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.kafka.retry.topic.enabled=true')
			.run(assertRetryTopicConfiguration((configuration) -> {
				assertThat(configuration.getDestinationTopicProperties()).hasSize(3)
					.extracting(DestinationTopic.Properties::delay, DestinationTopic.Properties::suffix)
					.containsExactly(tuple(0L, ''), tuple(1000L, '-retry'), tuple(0L, '-dlt'));
				assertThat(configuration.forKafkaTopicAutoCreation()).extracting('shouldCreateTopics')
					.asInstanceOf(InstanceOfAssertFactories.BOOLEAN)
					.isFalse();
			}));
	}
	@Test
	void retryTopicConfigurationWithFixedBackOff() {
		this.contextRunner.withPropertyValues('spring.application.name=my-test-app',
				'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.kafka.retry.topic.enabled=true',
				'spring.kafka.retry.topic.attempts=4', 'spring.kafka.retry.topic.backoff.delay=2s')
			.run(assertRetryTopicConfiguration(
					(configuration) -> assertThat(configuration.getDestinationTopicProperties()).hasSize(3)
						.extracting(DestinationTopic.Properties::delay)
						.containsExactly(0L, 2000L, 0L)));
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void retryTopicConfigurationWithFixedBackOffUsingDeprecatedProperties() {
		this.contextRunner.withPropertyValues('spring.application.name=my-test-app',
				'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.kafka.retry.topic.enabled=true',
				'spring.kafka.retry.topic.attempts=4', 'spring.kafka.retry.topic.delay=2s')
			.run(assertRetryTopicConfiguration(
					(configuration) -> assertThat(configuration.getDestinationTopicProperties()).hasSize(3)
						.extracting(DestinationTopic.Properties::delay)
						.containsExactly(0L, 2000L, 0L)));
	}
	@Test
	void retryTopicConfigurationWithNoBackOff() {
		this.contextRunner.withPropertyValues('spring.application.name=my-test-app',
				'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.kafka.retry.topic.enabled=true',
				'spring.kafka.retry.topic.attempts=4', 'spring.kafka.retry.topic.backoff.delay=0')
			.run(assertRetryTopicConfiguration(
					(configuration) -> assertThat(configuration.getDestinationTopicProperties()).hasSize(3)
						.extracting(DestinationTopic.Properties::delay)
						.containsExactly(0L, 0L, 0L)));
	}
	@Test
	@Deprecated(since = '3.4.0', forRemoval = true)
	void retryTopicConfigurationWithNoBackOffUsingDeprecatedProperties() {
		this.contextRunner.withPropertyValues('spring.application.name=my-test-app',
				'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093', 'spring.kafka.retry.topic.enabled=true',
				'spring.kafka.retry.topic.attempts=4', 'spring.kafka.retry.topic.delay=0')
			.run(assertRetryTopicConfiguration(
					(configuration) -> assertThat(configuration.getDestinationTopicProperties()).hasSize(3)
						.extracting(DestinationTopic.Properties::delay)
						.containsExactly(0L, 0L, 0L)));
	}
	private ContextConsumer<AssertableApplicationContext> assertRetryTopicConfiguration(
			Consumer<RetryTopicConfiguration> configuration) {
		return (context) -> {
			assertThat(context).hasSingleBean(RetryTopicConfiguration.class);
			configuration.accept(context.getBean(RetryTopicConfiguration.class));
		};
	}
	@SuppressWarnings('unchecked')
	@Test
	void streamsWithSeveralStreamsBuilderFactoryBeans() {
		this.contextRunner
			.withUserConfiguration(EnableKafkaStreamsConfiguration.class,
					TestStreamsBuilderFactoryBeanConfiguration.class)
			.withPropertyValues('spring.application.name=my-test-app',
					'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093',
					'spring.kafka.streams.auto-startup=false')
			.run((context) -> {
				Properties configs = context
					.getBean(KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME,
							KafkaStreamsConfiguration.class)
					.asProperties();
				assertThat((List<String>) configs.get(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG))
					.containsExactly('localhost:9092', 'localhost:9093');
				then(context.getBean('&firstStreamsBuilderFactoryBean', StreamsBuilderFactoryBean.class))
					.should(never())
					.setAutoStartup(false);
				then(context.getBean('&secondStreamsBuilderFactoryBean', StreamsBuilderFactoryBean.class))
					.should(never())
					.setAutoStartup(false);
			});
	}
	@Test
	void streamsWithCleanupConfig() {
		this.contextRunner
			.withUserConfiguration(EnableKafkaStreamsConfiguration.class, TestKafkaStreamsConfiguration.class)
			.withPropertyValues('spring.application.name=my-test-app',
					'spring.kafka.bootstrap-servers=localhost:9092,localhost:9093',
					'spring.kafka.streams.auto-startup=false', 'spring.kafka.streams.cleanup.on-startup=true',
					'spring.kafka.streams.cleanup.on-shutdown=false')
			.run((context) -> {
				StreamsBuilderFactoryBean streamsBuilderFactoryBean = context.getBean(StreamsBuilderFactoryBean.class);
				assertThat(streamsBuilderFactoryBean)
					.extracting('cleanupConfig', InstanceOfAssertFactories.type(CleanupConfig.class))
					.satisfies((cleanupConfig) -> {
						assertThat(cleanupConfig.cleanupOnStart()).isTrue();
						assertThat(cleanupConfig.cleanupOnStop()).isFalse();
					});
			});
	}
	@Test
	void streamsApplicationIdIsMandatory() {
		this.contextRunner.withUserConfiguration(EnableKafkaStreamsConfiguration.class).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context).getFailure()
				.hasMessageContaining('spring.kafka.streams.application-id')
				.hasMessageContaining(
						'This property is mandatory and fallback "spring.application.name" is not set either.');
		});
	}
	@Test
	void streamsApplicationIdIsNotMandatoryIfEnableKafkaStreamsIsNotSet() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasNotFailed();
			assertThat(context).doesNotHaveBean(StreamsBuilder.class);
		});
	}
	@Test
	void shouldUsePlatformThreadsByDefault() {
		this.contextRunner.run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory).isNotNull();
			AsyncTaskExecutor listenerTaskExecutor = factory.getContainerProperties().getListenerTaskExecutor();
			assertThat(listenerTaskExecutor).isNull();
		});
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void shouldUseVirtualThreadsIfEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true').run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory).isNotNull();
			AsyncTaskExecutor listenerTaskExecutor = factory.getContainerProperties().getListenerTaskExecutor();
			assertThat(listenerTaskExecutor).isInstanceOf(SimpleAsyncTaskExecutor.class);
			SimpleAsyncTaskExecutorAssert.assertThat((SimpleAsyncTaskExecutor) listenerTaskExecutor)
				.usesVirtualThreads();
		});
	}
	@SuppressWarnings('unchecked')
	@Test
	void listenerProperties() {
		this.contextRunner
			.withPropertyValues('spring.kafka.template.default-topic=testTopic',
					'spring.kafka.template.transaction-id-prefix=txOverride', 'spring.kafka.listener.ack-mode=MANUAL',
					'spring.kafka.listener.client-id=client', 'spring.kafka.listener.ack-count=123',
					'spring.kafka.listener.ack-time=456', 'spring.kafka.listener.concurrency=3',
					'spring.kafka.listener.poll-timeout=2000', 'spring.kafka.listener.no-poll-threshold=2.5',
					'spring.kafka.listener.type=batch', 'spring.kafka.listener.idle-between-polls=1s',
					'spring.kafka.listener.idle-event-interval=1s',
					'spring.kafka.listener.idle-partition-event-interval=1s',
					'spring.kafka.listener.monitor-interval=45', 'spring.kafka.listener.log-container-config=true',
					'spring.kafka.listener.missing-topics-fatal=true', 'spring.kafka.jaas.enabled=true',
					'spring.kafka.listener.immediate-stop=true', 'spring.kafka.producer.transaction-id-prefix=foo',
					'spring.kafka.jaas.login-module=foo', 'spring.kafka.jaas.control-flag=REQUISITE',
					'spring.kafka.jaas.options.useKeyTab=true', 'spring.kafka.listener.async-acks=true',
					'spring.kafka.template.observation-enabled=true', 'spring.kafka.listener.observation-enabled=true')
			.run((context) -> {
				DefaultKafkaProducerFactory<?, ?> producerFactory = context.getBean(DefaultKafkaProducerFactory.class);
				DefaultKafkaConsumerFactory<?, ?> consumerFactory = context.getBean(DefaultKafkaConsumerFactory.class);
				KafkaTemplate<?, ?> kafkaTemplate = context.getBean(KafkaTemplate.class);
				AbstractKafkaListenerContainerFactory<?, ?, ?> kafkaListenerContainerFactory = (AbstractKafkaListenerContainerFactory<?, ?, ?>) context
					.getBean(KafkaListenerContainerFactory.class);
				assertThat(kafkaTemplate.getMessageConverter()).isInstanceOf(MessagingMessageConverter.class);
				assertThat(kafkaTemplate).hasFieldOrPropertyWithValue('producerFactory', producerFactory);
				assertThat(kafkaTemplate.getDefaultTopic()).isEqualTo('testTopic');
				assertThat(kafkaTemplate).hasFieldOrPropertyWithValue('transactionIdPrefix', 'txOverride');
				assertThat(kafkaTemplate).hasFieldOrPropertyWithValue('observationEnabled', true);
				assertThat(kafkaListenerContainerFactory.getConsumerFactory()).isEqualTo(consumerFactory);
				ContainerProperties containerProperties = kafkaListenerContainerFactory.getContainerProperties();
				assertThat(containerProperties.getAckMode()).isEqualTo(AckMode.MANUAL);
				assertThat(containerProperties.isAsyncAcks()).isTrue();
				assertThat(containerProperties.getClientId()).isEqualTo('client');
				assertThat(containerProperties.getAckCount()).isEqualTo(123);
				assertThat(containerProperties.getAckTime()).isEqualTo(456L);
				assertThat(containerProperties.getPollTimeout()).isEqualTo(2000L);
				assertThat(containerProperties.getNoPollThreshold()).isEqualTo(2.5f);
				assertThat(containerProperties.getIdleBetweenPolls()).isEqualTo(1000L);
				assertThat(containerProperties.getIdleEventInterval()).isEqualTo(1000L);
				assertThat(containerProperties.getIdlePartitionEventInterval()).isEqualTo(1000L);
				assertThat(containerProperties.getMonitorInterval()).isEqualTo(45);
				assertThat(containerProperties.isLogContainerConfig()).isTrue();
				assertThat(containerProperties.isMissingTopicsFatal()).isTrue();
				assertThat(containerProperties.isStopImmediate()).isTrue();
				assertThat(containerProperties.isObservationEnabled()).isTrue();
				assertThat(kafkaListenerContainerFactory).extracting('concurrency').isEqualTo(3);
				assertThat(kafkaListenerContainerFactory.isBatchListener()).isTrue();
				assertThat(kafkaListenerContainerFactory).hasFieldOrPropertyWithValue('autoStartup', true);
				assertThat(context.getBeansOfType(KafkaJaasLoginModuleInitializer.class)).hasSize(1);
				KafkaJaasLoginModuleInitializer jaas = context.getBean(KafkaJaasLoginModuleInitializer.class);
				assertThat(jaas).hasFieldOrPropertyWithValue('loginModule', 'foo');
				assertThat(jaas).hasFieldOrPropertyWithValue('controlFlag',
						AppConfigurationEntry.LoginModuleControlFlag.REQUISITE);
				assertThat(context.getBeansOfType(KafkaTransactionManager.class)).hasSize(1);
				assertThat(((Map<String, String>) ReflectionTestUtils.getField(jaas, 'options')))
					.containsExactly(entry('useKeyTab', 'true'));
			});
	}
	@Test
	void testKafkaTemplateRecordMessageConverters() {
		this.contextRunner.withUserConfiguration(MessageConverterConfiguration.class)
			.withPropertyValues('spring.kafka.producer.transaction-id-prefix=test')
			.run((context) -> {
				KafkaTemplate<?, ?> kafkaTemplate = context.getBean(KafkaTemplate.class);
				assertThat(kafkaTemplate.getMessageConverter()).isSameAs(context.getBean('myMessageConverter'));
			});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomMessageConverter() {
		this.contextRunner.withUserConfiguration(MessageConverterConfiguration.class).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(kafkaListenerContainerFactory).hasFieldOrPropertyWithValue('recordMessageConverter',
					context.getBean('myMessageConverter'));
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryInBatchModeWithCustomMessageConverter() {
		this.contextRunner
			.withUserConfiguration(BatchMessageConverterConfiguration.class, MessageConverterConfiguration.class)
			.withPropertyValues('spring.kafka.listener.type=batch')
			.run((context) -> {
				ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory = context
					.getBean(ConcurrentKafkaListenerContainerFactory.class);
				assertThat(kafkaListenerContainerFactory).hasFieldOrPropertyWithValue('batchMessageConverter',
						context.getBean('myBatchMessageConverter'));
			});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryInBatchModeWrapsCustomMessageConverter() {
		this.contextRunner.withUserConfiguration(MessageConverterConfiguration.class)
			.withPropertyValues('spring.kafka.listener.type=batch')
			.run((context) -> {
				ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory = context
					.getBean(ConcurrentKafkaListenerContainerFactory.class);
				Object messageConverter = ReflectionTestUtils.getField(kafkaListenerContainerFactory,
						'batchMessageConverter');
				assertThat(messageConverter).isInstanceOf(BatchMessagingMessageConverter.class);
				assertThat(((BatchMessageConverter) messageConverter).getRecordMessageConverter())
					.isSameAs(context.getBean('myMessageConverter'));
			});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryInBatchModeWithNoMessageConverter() {
		this.contextRunner.withPropertyValues('spring.kafka.listener.type=batch').run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			Object messageConverter = ReflectionTestUtils.getField(kafkaListenerContainerFactory,
					'batchMessageConverter');
			assertThat(messageConverter).isInstanceOf(BatchMessagingMessageConverter.class);
			assertThat(((BatchMessageConverter) messageConverter).getRecordMessageConverter()).isNull();
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithDefaultRecordFilterStrategy() {
		this.contextRunner.run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory).hasFieldOrPropertyWithValue('recordFilterStrategy', null);
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomRecordFilterStrategy() {
		this.contextRunner.withUserConfiguration(RecordFilterStrategyConfiguration.class).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory).hasFieldOrPropertyWithValue('recordFilterStrategy',
					context.getBean('recordFilterStrategy'));
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomCommonErrorHandler() {
		this.contextRunner.withBean('errorHandler', CommonErrorHandler.class, () -> mock(CommonErrorHandler.class))
			.run((context) -> {
				ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
					.getBean(ConcurrentKafkaListenerContainerFactory.class);
				assertThat(factory).hasFieldOrPropertyWithValue('commonErrorHandler', context.getBean('errorHandler'));
			});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithDefaultTransactionManager() {
		this.contextRunner.withPropertyValues('spring.kafka.producer.transaction-id-prefix=test').run((context) -> {
			assertThat(context).hasSingleBean(KafkaAwareTransactionManager.class);
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory.getContainerProperties().getKafkaAwareTransactionManager())
				.isSameAs(context.getBean(KafkaAwareTransactionManager.class));
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void testConcurrentKafkaListenerContainerFactoryWithCustomTransactionManager() {
		KafkaTransactionManager<Object, Object> customTransactionManager = mock(KafkaTransactionManager.class);
		this.contextRunner
			.withBean('customTransactionManager', KafkaTransactionManager.class, () -> customTransactionManager)
			.withPropertyValues('spring.kafka.producer.transaction-id-prefix=test')
			.run((context) -> {
				ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
					.getBean(ConcurrentKafkaListenerContainerFactory.class);
				assertThat(factory.getContainerProperties().getKafkaAwareTransactionManager())
					.isSameAs(context.getBean('customTransactionManager'));
			});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomAfterRollbackProcessor() {
		this.contextRunner.withUserConfiguration(AfterRollbackProcessorConfiguration.class).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory).hasFieldOrPropertyWithValue('afterRollbackProcessor',
					context.getBean('afterRollbackProcessor'));
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomRecordInterceptor() {
		this.contextRunner.withUserConfiguration(RecordInterceptorConfiguration.class).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory).hasFieldOrPropertyWithValue('recordInterceptor', context.getBean('recordInterceptor'));
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomBatchInterceptor() {
		this.contextRunner.withUserConfiguration(BatchInterceptorConfiguration.class).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory).hasFieldOrPropertyWithValue('batchInterceptor', context.getBean('batchInterceptor'));
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomRebalanceListener() {
		this.contextRunner.withUserConfiguration(RebalanceListenerConfiguration.class).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(factory.getContainerProperties()).hasFieldOrPropertyWithValue('consumerRebalanceListener',
					context.getBean('rebalanceListener'));
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithKafkaTemplate() {
		this.contextRunner.run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(kafkaListenerContainerFactory).hasFieldOrPropertyWithValue('replyTemplate',
					context.getBean(KafkaTemplate.class));
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomConsumerFactory() {
		this.contextRunner.withUserConfiguration(ConsumerFactoryConfiguration.class).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(kafkaListenerContainerFactory.getConsumerFactory())
				.isNotSameAs(context.getBean(ConsumerFactoryConfiguration.class).consumerFactory);
		});
	}
	@ParameterizedTest(name = '{0}')
	@ValueSource(booleans = { true, false })
	void testConcurrentKafkaListenerContainerFactoryAutoStartup(boolean autoStartup) {
		this.contextRunner.withPropertyValues('spring.kafka.listener.auto-startup=' + autoStartup).run((context) -> {
			ConcurrentKafkaListenerContainerFactory<?, ?> kafkaListenerContainerFactory = context
				.getBean(ConcurrentKafkaListenerContainerFactory.class);
			assertThat(kafkaListenerContainerFactory).hasFieldOrPropertyWithValue('autoStartup', autoStartup);
		});
	}
	@Test
	void testConcurrentKafkaListenerContainerFactoryWithCustomContainerCustomizer() {
		this.contextRunner.withUserConfiguration(ObservationEnabledContainerCustomizerConfiguration.class)
			.run((context) -> {
				ConcurrentKafkaListenerContainerFactory<?, ?> factory = context
					.getBean(ConcurrentKafkaListenerContainerFactory.class);
				ConcurrentMessageListenerContainer<?, ?> container = factory.createContainer('someTopic');
				assertThat(container.getContainerProperties().isObservationEnabled()).isEqualTo(true);
			});
	}
	@Test
	void specificSecurityProtocolOverridesCommonSecurityProtocol() {
		this.contextRunner
			.withPropertyValues('spring.kafka.security.protocol=SSL', 'spring.kafka.admin.security.protocol=PLAINTEXT')
			.run((context) -> {
				DefaultKafkaProducerFactory<?, ?> producerFactory = context.getBean(DefaultKafkaProducerFactory.class);
				Map<String, Object> producerConfigs = producerFactory.getConfigurationProperties();
				assertThat(producerConfigs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'SSL');
				KafkaAdmin admin = context.getBean(KafkaAdmin.class);
				Map<String, Object> configs = admin.getConfigurationProperties();
				assertThat(configs).containsEntry(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG, 'PLAINTEXT');
			});
	}
	private KafkaConnectionDetails kafkaConnectionDetails() {
		return new KafkaConnectionDetails() {
			@Override
			public List<String> getBootstrapServers() {
				return List.of('kafka.example.com:12345');
			}
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class MessageConverterConfiguration {
		@Bean
		RecordMessageConverter myMessageConverter() {
			return mock(RecordMessageConverter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BatchMessageConverterConfiguration {
		@Bean
		BatchMessageConverter myBatchMessageConverter() {
			return mock(BatchMessageConverter.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RecordFilterStrategyConfiguration {
		@Bean
		RecordFilterStrategy<Object, Object> recordFilterStrategy() {
			return (record) -> false;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AfterRollbackProcessorConfiguration {
		@Bean
		AfterRollbackProcessor<Object, Object> afterRollbackProcessor() {
			return (records, consumer, container, ex, recoverable, eosMode) -> {
				// no-op
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConsumerFactoryConfiguration {
		@SuppressWarnings('unchecked')
		private final ConsumerFactory<String, Object> consumerFactory = mock(ConsumerFactory.class);
		@Bean
		ConsumerFactory<String, Object> myConsumerFactory() {
			return this.consumerFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ObservationEnabledContainerCustomizerConfiguration {
		@Bean
		ContainerCustomizer<Object, Object, ConcurrentMessageListenerContainer<Object, Object>> myContainerCustomizer() {
			return (container) -> container.getContainerProperties().setObservationEnabled(true);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RecordInterceptorConfiguration {
		@Bean
		RecordInterceptor<Object, Object> recordInterceptor() {
			return (record, consumer) -> record;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BatchInterceptorConfiguration {
		@Bean
		BatchInterceptor<Object, Object> batchInterceptor() {
			return (batch, consumer) -> batch;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RebalanceListenerConfiguration {
		@Bean
		ConsumerAwareRebalanceListener rebalanceListener() {
			return mock(ConsumerAwareRebalanceListener.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableKafkaStreams
	static class EnableKafkaStreamsConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TestKafkaStreamsConfiguration {
		@Bean(name = KafkaStreamsDefaultConfiguration.DEFAULT_STREAMS_CONFIG_BEAN_NAME)
		KafkaStreamsConfiguration kafkaStreamsConfiguration() {
			Map<String, Object> streamsProperties = new HashMap<>();
			streamsProperties.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, 'localhost:9094, localhost:9095');
			streamsProperties.put(StreamsConfig.APPLICATION_ID_CONFIG, 'test-id');
			return new KafkaStreamsConfiguration(streamsProperties);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestStreamsBuilderFactoryBeanConfiguration {
		@Bean
		StreamsBuilderFactoryBean firstStreamsBuilderFactoryBean() {
			return mock(StreamsBuilderFactoryBean.class);
		}
		@Bean
		StreamsBuilderFactoryBean secondStreamsBuilderFactoryBean() {
			return mock(StreamsBuilderFactoryBean.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
class ConcurrentKafkaListenerContainerFactoryConfigurerTests {
	private ConcurrentKafkaListenerContainerFactoryConfigurer configurer;
	private ConcurrentKafkaListenerContainerFactory<Object, Object> factory;
	private ConsumerFactory<Object, Object> consumerFactory;
	private KafkaProperties properties;
	@BeforeEach
	@SuppressWarnings('unchecked')
	void setUp() {
		this.configurer = new ConcurrentKafkaListenerContainerFactoryConfigurer();
		this.properties = new KafkaProperties();
		this.configurer.setKafkaProperties(this.properties);
		this.factory = spy(new ConcurrentKafkaListenerContainerFactory<>());
		this.consumerFactory = mock(ConsumerFactory.class);
	}
	@Test
	void shouldApplyThreadNameSupplier() {
		Function<MessageListenerContainer, String> function = (container) -> 'thread-1';
		this.configurer.setThreadNameSupplier(function);
		this.configurer.configure(this.factory, this.consumerFactory);
		then(this.factory).should().setThreadNameSupplier(function);
	}
	@Test
	void shouldApplyChangeConsumerThreadName() {
		this.properties.getListener().setChangeConsumerThreadName(true);
		this.configurer.configure(this.factory, this.consumerFactory);
		then(this.factory).should().setChangeConsumerThreadName(true);
	}
	@Test
	void shouldApplyListenerTaskExecutor() {
		SimpleAsyncTaskExecutor executor = new SimpleAsyncTaskExecutor();
		this.configurer.setListenerTaskExecutor(executor);
		this.configurer.configure(this.factory, this.consumerFactory);
		assertThat(this.factory.getContainerProperties().getListenerTaskExecutor()).isEqualTo(executor);
	}
}
/*
package org.springframework.boot.autoconfigure.kafka;
/**
class KafkaPropertiesTests {
	private final SslBundle sslBundle = mock(SslBundle.class);
	@Test
	void isolationLevelEnumConsistentWithKafkaVersion() {
		org.apache.kafka.common.IsolationLevel[] original = org.apache.kafka.common.IsolationLevel.values();
		assertThat(original).extracting(Enum::name)
			.containsExactly(IsolationLevel.READ_UNCOMMITTED.name(), IsolationLevel.READ_COMMITTED.name());
		assertThat(original).extracting('id')
			.containsExactly(IsolationLevel.READ_UNCOMMITTED.id(), IsolationLevel.READ_COMMITTED.id());
		assertThat(original).hasSameSizeAs(IsolationLevel.values());
	}
	@Test
	void adminDefaultValuesAreConsistent() {
		KafkaAdmin admin = new KafkaAdmin(Collections.emptyMap());
		Admin adminProperties = new KafkaProperties().getAdmin();
		assertThat(admin).hasFieldOrPropertyWithValue('fatalIfBrokerNotAvailable', adminProperties.isFailFast());
		assertThat(admin).hasFieldOrPropertyWithValue('modifyTopicConfigs', adminProperties.isModifyTopicConfigs());
	}
	@Test
	void listenerDefaultValuesAreConsistent() {
		ContainerProperties container = new ContainerProperties('test');
		Listener listenerProperties = new KafkaProperties().getListener();
		assertThat(listenerProperties.isMissingTopicsFatal()).isEqualTo(container.isMissingTopicsFatal());
	}
	@Test
	void sslPemConfiguration() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setKeyStoreKey('-----BEGINkey');
		properties.getSsl().setTrustStoreCertificates('-----BEGINtrust');
		properties.getSsl().setKeyStoreCertificateChain('-----BEGINchain');
		Map<String, Object> consumerProperties = properties.buildConsumerProperties(null);
		assertThat(consumerProperties).containsEntry(SslConfigs.SSL_KEYSTORE_KEY_CONFIG, '-----BEGINkey');
		assertThat(consumerProperties).containsEntry(SslConfigs.SSL_TRUSTSTORE_CERTIFICATES_CONFIG, '-----BEGINtrust');
		assertThat(consumerProperties).containsEntry(SslConfigs.SSL_KEYSTORE_CERTIFICATE_CHAIN_CONFIG,
				'-----BEGINchain');
	}
	@Test
	void sslBundleConfiguration() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setBundle('myBundle');
		Map<String, Object> consumerProperties = properties
			.buildConsumerProperties(new DefaultSslBundleRegistry('myBundle', this.sslBundle));
		assertThat(consumerProperties).containsEntry(SslConfigs.SSL_ENGINE_FACTORY_CLASS_CONFIG,
				SslBundleSslEngineFactory.class.getName());
	}
	@Test
	void sslPropertiesWhenKeyStoreLocationAndKeySetShouldThrowException() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setKeyStoreKey('-----BEGIN');
		properties.getSsl().setKeyStoreLocation(new ClassPathResource('ksLoc'));
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class)
			.isThrownBy(() -> properties.buildConsumerProperties(null));
	}
	@Test
	void sslPropertiesWhenTrustStoreLocationAndCertificatesSetShouldThrowException() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setTrustStoreLocation(new ClassPathResource('tsLoc'));
		properties.getSsl().setTrustStoreCertificates('-----BEGIN');
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class)
			.isThrownBy(() -> properties.buildConsumerProperties(null));
	}
	@Test
	void sslPropertiesWhenKeyStoreLocationAndBundleSetShouldThrowException() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setBundle('myBundle');
		properties.getSsl().setKeyStoreLocation(new ClassPathResource('ksLoc'));
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class).isThrownBy(
				() -> properties.buildConsumerProperties(new DefaultSslBundleRegistry('myBundle', this.sslBundle)));
	}
	@Test
	void sslPropertiesWhenKeyStoreKeyAndBundleSetShouldThrowException() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setBundle('myBundle');
		properties.getSsl().setKeyStoreKey('-----BEGIN');
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class).isThrownBy(
				() -> properties.buildConsumerProperties(new DefaultSslBundleRegistry('myBundle', this.sslBundle)));
	}
	@Test
	void sslPropertiesWhenTrustStoreLocationAndBundleSetShouldThrowException() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setBundle('myBundle');
		properties.getSsl().setTrustStoreLocation(new ClassPathResource('tsLoc'));
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class).isThrownBy(
				() -> properties.buildConsumerProperties(new DefaultSslBundleRegistry('myBundle', this.sslBundle)));
	}
	@Test
	void sslPropertiesWhenTrustStoreCertificatesAndBundleSetShouldThrowException() {
		KafkaProperties properties = new KafkaProperties();
		properties.getSsl().setBundle('myBundle');
		properties.getSsl().setTrustStoreCertificates('-----BEGIN');
		assertThatExceptionOfType(MutuallyExclusiveConfigurationPropertiesException.class).isThrownBy(
				() -> properties.buildConsumerProperties(new DefaultSslBundleRegistry('myBundle', this.sslBundle)));
	}
	@Test
	void cleanupConfigDefaultValuesAreConsistent() {
		CleanupConfig cleanupConfig = new CleanupConfig();
		Cleanup cleanup = new KafkaProperties().getStreams().getCleanup();
		assertThat(cleanup.isOnStartup()).isEqualTo(cleanupConfig.cleanupOnStart());
		assertThat(cleanup.isOnShutdown()).isEqualTo(cleanupConfig.cleanupOnStop());
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
class ElasticsearchClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ElasticsearchClientAutoConfiguration.class));
	@Test
	void withoutRestClientThenAutoConfigurationShouldBackOff() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ElasticsearchTransport.class)
			.doesNotHaveBean(JsonpMapper.class)
			.doesNotHaveBean(ElasticsearchClient.class));
	}
	@Test
	void withRestClientAutoConfigurationShouldDefineClientAndSupportingBeans() {
		this.contextRunner.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JsonpMapper.class)
				.hasSingleBean(RestClientTransport.class)
				.hasSingleBean(ElasticsearchClient.class));
	}
	@Test
	void withoutJsonbOrJacksonShouldDefineSimpleMapper() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(ObjectMapper.class))
			.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JsonpMapper.class)
				.hasSingleBean(SimpleJsonpMapper.class));
	}
	@Test
	void withJsonbShouldDefineJsonbMapper() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(ObjectMapper.class))
			.withConfiguration(AutoConfigurations.of(JsonbAutoConfiguration.class))
			.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JsonpMapper.class)
				.hasSingleBean(JsonbJsonpMapper.class));
	}
	@Test
	void withJacksonShouldDefineJacksonMapper() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class))
			.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JsonpMapper.class)
				.hasSingleBean(JacksonJsonpMapper.class));
	}
	@Test
	void withJacksonAndJsonbShouldDefineJacksonMapper() {
		this.contextRunner
			.withConfiguration(AutoConfigurations.of(JsonbAutoConfiguration.class, JacksonAutoConfiguration.class))
			.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(JsonpMapper.class)
				.hasSingleBean(JacksonJsonpMapper.class));
	}
	@Test
	void withCustomMapperTransportShouldUseIt() {
		this.contextRunner.withUserConfiguration(JsonpMapperConfiguration.class)
			.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(JsonpMapper.class).hasBean('customJsonpMapper');
				JsonpMapper mapper = context.getBean(JsonpMapper.class);
				assertThat(context.getBean(ElasticsearchTransport.class).jsonpMapper()).isSameAs(mapper);
			});
	}
	@Test
	void withCustomTransportClientShouldUseIt() {
		this.contextRunner.withUserConfiguration(TransportConfiguration.class)
			.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ElasticsearchTransport.class).hasBean('customElasticsearchTransport');
				ElasticsearchTransport transport = context.getBean(ElasticsearchTransport.class);
				assertThat(context.getBean(ElasticsearchClient.class)._transport()).isSameAs(transport);
			});
	}
	@Test
	void jacksonJsonpMapperDoesNotUseGlobalObjectMapper() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class))
			.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> {
				ObjectMapper objectMapper = context.getBean(ObjectMapper.class);
				JacksonJsonpMapper jacksonJsonpMapper = context.getBean(JacksonJsonpMapper.class);
				assertThat(jacksonJsonpMapper.objectMapper()).isNotSameAs(objectMapper);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class RestClientConfiguration {
		@Bean
		RestClient restClient() {
			return mock(RestClient.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JsonpMapperConfiguration {
		@Bean
		JsonpMapper customJsonpMapper() {
			return mock(JsonpMapper.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TransportConfiguration {
		@Bean
		ElasticsearchTransport customElasticsearchTransport(JsonpMapper mapper) {
			return mock(ElasticsearchTransport.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
class ReactiveElasticsearchClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(ReactiveElasticsearchClientAutoConfiguration.class));
	@Test
	void configureWithoutRestClientShouldBackOff() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ReactiveElasticsearchClient.class));
	}
	@Test
	void configureWithRestClientShouldCreateTransportAndClient() {
		this.contextRunner.withUserConfiguration(RestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveElasticsearchClient.class));
	}
	@Test
	void configureWhenCustomClientShouldBackOff() {
		this.contextRunner.withUserConfiguration(RestClientConfiguration.class, CustomClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(ReactiveElasticsearchClient.class)
				.hasBean('customClient'));
	}
	@Configuration(proxyBeanMethods = false)
	static class RestClientConfiguration {
		@Bean
		RestClient restClient() {
			return mock(RestClient.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomClientConfiguration {
		@Bean
		ReactiveElasticsearchClient customClient() {
			return mock(ReactiveElasticsearchClient.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.elasticsearch;
/**
class ElasticsearchRestClientAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(ElasticsearchRestClientAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void configureShouldCreateRestClientBuilderAndRestClient() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(RestClient.class)
			.hasSingleBean(RestClientBuilder.class));
	}
	@Test
	void configureWhenCustomRestClientShouldBackOff() {
		this.contextRunner.withUserConfiguration(CustomRestClientConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(RestClientBuilder.class)
				.hasSingleBean(RestClient.class)
				.hasBean('customRestClient'));
	}
	@Test
	void configureWhenBuilderCustomizerShouldApply() {
		this.contextRunner.withUserConfiguration(BuilderCustomizerConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(RestClient.class);
			RestClient restClient = context.getBean(RestClient.class);
			assertThat(restClient).hasFieldOrPropertyWithValue('pathPrefix', '/test');
			assertThat(restClient).extracting('client.connmgr.pool.maxTotal').isEqualTo(100);
			assertThat(restClient).extracting('client.defaultConfig.cookieSpec').isEqualTo('rfc6265-lax');
		});
	}
	@Test
	void configureWithNoTimeoutsApplyDefaults() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(RestClient.class);
			RestClient restClient = context.getBean(RestClient.class);
			assertTimeouts(restClient, Duration.ofMillis(RestClientBuilder.DEFAULT_CONNECT_TIMEOUT_MILLIS),
					Duration.ofMillis(RestClientBuilder.DEFAULT_SOCKET_TIMEOUT_MILLIS));
		});
	}
	@Test
	void configureWithCustomTimeouts() {
		this.contextRunner
			.withPropertyValues('spring.elasticsearch.connection-timeout=15s', 'spring.elasticsearch.socket-timeout=1m')
			.run((context) -> {
				assertThat(context).hasSingleBean(RestClient.class);
				RestClient restClient = context.getBean(RestClient.class);
				assertTimeouts(restClient, Duration.ofSeconds(15), Duration.ofMinutes(1));
			});
	}
	private static void assertTimeouts(RestClient restClient, Duration connectTimeout, Duration readTimeout) {
		assertThat(restClient).extracting('client.defaultConfig.socketTimeout')
			.isEqualTo(Math.toIntExact(readTimeout.toMillis()));
		assertThat(restClient).extracting('client.defaultConfig.connectTimeout')
			.isEqualTo(Math.toIntExact(connectTimeout.toMillis()));
	}
	@Test
	void configureUriWithNoScheme() {
		this.contextRunner.withPropertyValues('spring.elasticsearch.uris=localhost:9876').run((context) -> {
			RestClient client = context.getBean(RestClient.class);
			assertThat(client.getNodes().stream().map(Node::getHost).map(HttpHost::toString))
				.containsExactly('http://localhost:9876');
		});
	}
	@Test
	void configureUriWithUsernameOnly() {
		this.contextRunner.withPropertyValues('spring.elasticsearch.uris=http://user@localhost:9200').run((context) -> {
			RestClient client = context.getBean(RestClient.class);
			assertThat(client.getNodes().stream().map(Node::getHost).map(HttpHost::toString))
				.containsExactly('http://localhost:9200');
			assertThat(client)
				.extracting('client.credentialsProvider', InstanceOfAssertFactories.type(CredentialsProvider.class))
				.satisfies((credentialsProvider) -> {
					Credentials credentials = credentialsProvider.getCredentials(new AuthScope('localhost', 9200));
					assertThat(credentials.getUserPrincipal().getName()).isEqualTo('user');
					assertThat(credentials.getPassword()).isNull();
				});
		});
	}
	@Test
	void configureUriWithUsernameAndEmptyPassword() {
		this.contextRunner.withPropertyValues('spring.elasticsearch.uris=http://user:@localhost:9200')
			.run((context) -> {
				RestClient client = context.getBean(RestClient.class);
				assertThat(client.getNodes().stream().map(Node::getHost).map(HttpHost::toString))
					.containsExactly('http://localhost:9200');
				assertThat(client)
					.extracting('client.credentialsProvider', InstanceOfAssertFactories.type(CredentialsProvider.class))
					.satisfies((credentialsProvider) -> {
						Credentials credentials = credentialsProvider.getCredentials(new AuthScope('localhost', 9200));
						assertThat(credentials.getUserPrincipal().getName()).isEqualTo('user');
						assertThat(credentials.getPassword()).isEmpty();
					});
			});
	}
	@Test
	void configureUriWithUsernameAndPasswordWhenUsernameAndPasswordPropertiesSet() {
		this.contextRunner
			.withPropertyValues('spring.elasticsearch.uris=http://user:password@localhost:9200,localhost:9201',
					'spring.elasticsearch.username=admin', 'spring.elasticsearch.password=admin')
			.run((context) -> {
				RestClient client = context.getBean(RestClient.class);
				assertThat(client.getNodes().stream().map(Node::getHost).map(HttpHost::toString))
					.containsExactly('http://localhost:9200', 'http://localhost:9201');
				assertThat(client)
					.extracting('client.credentialsProvider', InstanceOfAssertFactories.type(CredentialsProvider.class))
					.satisfies((credentialsProvider) -> {
						Credentials uriCredentials = credentialsProvider
							.getCredentials(new AuthScope('localhost', 9200));
						assertThat(uriCredentials.getUserPrincipal().getName()).isEqualTo('user');
						assertThat(uriCredentials.getPassword()).isEqualTo('password');
						Credentials defaultCredentials = credentialsProvider
							.getCredentials(new AuthScope('localhost', 9201));
						assertThat(defaultCredentials.getUserPrincipal().getName()).isEqualTo('admin');
						assertThat(defaultCredentials.getPassword()).isEqualTo('admin');
					});
			});
	}
	@Test
	void configureWithCustomPathPrefix() {
		this.contextRunner.withPropertyValues('spring.elasticsearch.path-prefix=/some/prefix').run((context) -> {
			RestClient client = context.getBean(RestClient.class);
			assertThat(client).extracting('pathPrefix').isEqualTo('/some/prefix');
		});
	}
	@Test
	void configureWithNoSocketKeepAliveApplyDefault() {
		RestClient client = RestClient.builder(new HttpHost('localhost', 9201, 'http')).build();
		assertThat(client.getHttpClient()).extracting('connmgr.ioReactor.config.soKeepAlive').isEqualTo(Boolean.FALSE);
	}
	@Test
	void configureWithCustomSocketKeepAlive() {
		this.contextRunner.withPropertyValues('spring.elasticsearch.socket-keep-alive=true').run((context) -> {
			assertThat(context).hasSingleBean(RestClient.class);
			RestClient client = context.getBean(RestClient.class);
			assertThat(client.getHttpClient()).extracting('connmgr.ioReactor.config.soKeepAlive')
				.isEqualTo(Boolean.TRUE);
		});
	}
	@Test
	void configureWithoutSnifferLibraryShouldNotCreateSniffer() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.elasticsearch.client.sniff'))
			.run((context) -> assertThat(context).hasSingleBean(RestClient.class).doesNotHaveBean(Sniffer.class));
	}
	@Test
	void configureShouldCreateSnifferUsingRestClient() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Sniffer.class);
			assertThat(context.getBean(Sniffer.class)).hasFieldOrPropertyWithValue('restClient',
					context.getBean(RestClient.class));
			// Validate shutdown order as the sniffer must be shutdown before the
			// client
			assertThat(context.getBeanFactory().getDependentBeans('elasticsearchRestClient'))
				.contains('elasticsearchSniffer');
		});
	}
	@Test
	void configureWithCustomSnifferSettings() {
		this.contextRunner
			.withPropertyValues('spring.elasticsearch.restclient.sniffer.interval=180s',
					'spring.elasticsearch.restclient.sniffer.delay-after-failure=30s')
			.run((context) -> {
				assertThat(context).hasSingleBean(Sniffer.class);
				Sniffer sniffer = context.getBean(Sniffer.class);
				assertThat(sniffer).hasFieldOrPropertyWithValue('sniffIntervalMillis',
						Duration.ofMinutes(3).toMillis());
				assertThat(sniffer).hasFieldOrPropertyWithValue('sniffAfterFailureDelayMillis',
						Duration.ofSeconds(30).toMillis());
			});
	}
	@Test
	void configureWhenCustomSnifferShouldBackOff() {
		Sniffer customSniffer = mock(Sniffer.class);
		this.contextRunner.withBean(Sniffer.class, () -> customSniffer).run((context) -> {
			assertThat(context).hasSingleBean(Sniffer.class);
			Sniffer sniffer = context.getBean(Sniffer.class);
			assertThat(sniffer).isSameAs(customSniffer);
			then(customSniffer).shouldHaveNoInteractions();
		});
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(PropertiesElasticsearchConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(RestClient.class)
				.hasSingleBean(ElasticsearchConnectionDetails.class)
				.doesNotHaveBean(PropertiesElasticsearchConnectionDetails.class);
			RestClient restClient = context.getBean(RestClient.class);
			assertThat(restClient).hasFieldOrPropertyWithValue('pathPrefix', '/some-path');
			assertThat(restClient.getNodes().stream().map(Node::getHost).map(HttpHost::toString))
				.containsExactly('http://elastic.example.com:9200');
			assertThat(restClient)
				.extracting('client.credentialsProvider', InstanceOfAssertFactories.type(CredentialsProvider.class))
				.satisfies((credentialsProvider) -> {
					Credentials uriCredentials = credentialsProvider
						.getCredentials(new AuthScope('any.elastic.example.com', 80));
					assertThat(uriCredentials.getUserPrincipal().getName()).isEqualTo('user-1');
					assertThat(uriCredentials.getPassword()).isEqualTo('password-1');
				})
				.satisfies((credentialsProvider) -> {
					Credentials uriCredentials = credentialsProvider
						.getCredentials(new AuthScope('elastic.example.com', 9200));
					assertThat(uriCredentials.getUserPrincipal().getName()).isEqualTo('node-user-1');
					assertThat(uriCredentials.getPassword()).isEqualTo('node-password-1');
				});
		});
	}
	@Test
	@SuppressWarnings('unchecked')
	void configureWithSslBundle() {
		List<String> properties = new ArrayList<>();
		properties.add('spring.elasticsearch.restclient.ssl.bundle=mybundle');
		properties.add('spring.ssl.bundle.jks.mybundle.truststore.location=classpath:test.jks');
		properties.add('spring.ssl.bundle.jks.mybundle.options.ciphers=DESede');
		properties.add('spring.ssl.bundle.jks.mybundle.options.enabled-protocols=TLSv1.3');
		this.contextRunner.withPropertyValues(properties.toArray(String[]::new)).run((context) -> {
			assertThat(context).hasSingleBean(RestClient.class);
			RestClient restClient = context.getBean(RestClient.class);
			Object client = ReflectionTestUtils.getField(restClient, 'client');
			Object connmgr = ReflectionTestUtils.getField(client, 'connmgr');
			Registry<SchemeIOSessionStrategy> registry = (Registry<SchemeIOSessionStrategy>) ReflectionTestUtils
				.getField(connmgr, 'ioSessionFactoryRegistry');
			SchemeIOSessionStrategy strategy = registry.lookup('https');
			assertThat(strategy).extracting('sslContext').isNotNull();
			assertThat(strategy).extracting('supportedCipherSuites')
				.asInstanceOf(InstanceOfAssertFactories.ARRAY)
				.containsExactly('DESede');
			assertThat(strategy).extracting('supportedProtocols')
				.asInstanceOf(InstanceOfAssertFactories.ARRAY)
				.containsExactly('TLSv1.3');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		ElasticsearchConnectionDetails elasticsearchConnectionDetails() {
			return new ElasticsearchConnectionDetails() {
				@Override
				public List<Node> getNodes() {
					return List
						.of(new Node('elastic.example.com', 9200, Protocol.HTTP, 'node-user-1', 'node-password-1'));
				}
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'password-1';
				}
				@Override
				public String getPathPrefix() {
					return '/some-path';
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BuilderCustomizerConfiguration {
		@Bean
		RestClientBuilderCustomizer myCustomizer() {
			return new RestClientBuilderCustomizer() {
				@Override
				public void customize(RestClientBuilder builder) {
					builder.setPathPrefix('/test');
				}
				@Override
				public void customize(HttpAsyncClientBuilder builder) {
					builder.setMaxConnTotal(100);
				}
				@Override
				public void customize(RequestConfig.Builder builder) {
					builder.setCookieSpec('rfc6265-lax');
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRestClientConfiguration {
		@Bean
		RestClient customRestClient(RestClientBuilder builder) {
			return builder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TwoCustomRestClientConfiguration {
		@Bean
		RestClient customRestClient(RestClientBuilder builder) {
			return builder.build();
		}
		@Bean
		RestClient customRestClient1(RestClientBuilder builder) {
			return builder.build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnCloudPlatformTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void outcomeWhenCloudfoundryPlatformNotPresentShouldNotMatch() {
		this.contextRunner.withUserConfiguration(CloudFoundryPlatformConfig.class)
			.run((context) -> assertThat(context).doesNotHaveBean('foo'));
	}
	@Test
	void outcomeWhenCloudfoundryPlatformPresentShouldMatch() {
		this.contextRunner.withUserConfiguration(CloudFoundryPlatformConfig.class)
			.withPropertyValues('VCAP_APPLICATION:---')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Test
	void outcomeWhenCloudfoundryPlatformPresentAndMethodTargetShouldMatch() {
		this.contextRunner.withUserConfiguration(CloudFoundryPlatformOnMethodConfig.class)
			.withPropertyValues('VCAP_APPLICATION:---')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)
	static class CloudFoundryPlatformConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CloudFoundryPlatformOnMethodConfig {
		@Bean
		@ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)
		String foo() {
			return 'foo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnJavaTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	private final OnJavaCondition condition = new OnJavaCondition();
	@Test
	@EnabledOnJre(JRE.JAVA_17)
	void doesNotMatchIfBetterVersionIsRequired() {
		this.contextRunner.withUserConfiguration(Java18Required.class)
			.run((context) -> assertThat(context).doesNotHaveBean(String.class));
	}
	@Test
	@EnabledOnJre(JRE.JAVA_18)
	void doesNotMatchIfLowerIsRequired() {
		this.contextRunner.withUserConfiguration(OlderThan18Required.class)
			.run((context) -> assertThat(context).doesNotHaveBean(String.class));
	}
	@Test
	void matchesIfVersionIsInRange() {
		this.contextRunner.withUserConfiguration(Java17Required.class)
			.run((context) -> assertThat(context).hasSingleBean(String.class));
	}
	@Test
	void boundsTests() {
		testBounds(Range.EQUAL_OR_NEWER, JavaVersion.EIGHTEEN, JavaVersion.SEVENTEEN, true);
		testBounds(Range.EQUAL_OR_NEWER, JavaVersion.SEVENTEEN, JavaVersion.SEVENTEEN, true);
		testBounds(Range.EQUAL_OR_NEWER, JavaVersion.SEVENTEEN, JavaVersion.EIGHTEEN, false);
		testBounds(Range.OLDER_THAN, JavaVersion.EIGHTEEN, JavaVersion.SEVENTEEN, false);
		testBounds(Range.OLDER_THAN, JavaVersion.SEVENTEEN, JavaVersion.SEVENTEEN, false);
		testBounds(Range.OLDER_THAN, JavaVersion.SEVENTEEN, JavaVersion.EIGHTEEN, true);
	}
	@Test
	void equalOrNewerMessage() {
		ConditionOutcome outcome = this.condition.getMatchOutcome(Range.EQUAL_OR_NEWER, JavaVersion.EIGHTEEN,
				JavaVersion.SEVENTEEN);
		assertThat(outcome.getMessage()).isEqualTo('@ConditionalOnJava (17 or newer) found 18');
	}
	@Test
	void olderThanMessage() {
		ConditionOutcome outcome = this.condition.getMatchOutcome(Range.OLDER_THAN, JavaVersion.EIGHTEEN,
				JavaVersion.SEVENTEEN);
		assertThat(outcome.getMessage()).isEqualTo('@ConditionalOnJava (older than 17) found 18');
	}
	@Test
	@EnabledOnJre(JRE.JAVA_17)
	void java17IsDetected() throws Exception {
		assertThat(getJavaVersion()).isEqualTo('17');
	}
	@Test
	@EnabledOnJre(JRE.JAVA_17)
	void java17IsTheFallback() throws Exception {
		assertThat(getJavaVersion(Console.class)).isEqualTo('17');
	}
	private String getJavaVersion(Class<?>... hiddenClasses) throws Exception {
		FilteredClassLoader classLoader = new FilteredClassLoader(hiddenClasses);
		Class<?> javaVersionClass = Class.forName(JavaVersion.class.getName(), false, classLoader);
		Method getJavaVersionMethod = ReflectionUtils.findMethod(javaVersionClass, 'getJavaVersion');
		Object javaVersion = ReflectionUtils.invokeMethod(getJavaVersionMethod, null);
		classLoader.close();
		return javaVersion.toString();
	}
	private void testBounds(Range range, JavaVersion runningVersion, JavaVersion version, boolean expected) {
		ConditionOutcome outcome = this.condition.getMatchOutcome(range, runningVersion, version);
		assertThat(outcome.isMatch()).as(outcome.getMessage()).isEqualTo(expected);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnJava(JavaVersion.SEVENTEEN)
	static class Java17Required {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnJava(range = Range.OLDER_THAN, value = JavaVersion.EIGHTEEN)
	static class OlderThan18Required {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnJava(JavaVersion.EIGHTEEN)
	static class Java18Required {
		@Bean
		String foo() {
			return 'foo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnPropertyTests {
	private ConfigurableApplicationContext context;
	private final ConfigurableEnvironment environment = new StandardEnvironment();
	@AfterEach
	void tearDown() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void allPropertiesAreDefined() {
		load(MultiplePropertiesRequiredConfiguration.class, 'property1=value1', 'property2=value2');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void notAllPropertiesAreDefined() {
		load(MultiplePropertiesRequiredConfiguration.class, 'property1=value1');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void propertyValueEqualsFalse() {
		load(MultiplePropertiesRequiredConfiguration.class, 'property1=false', 'property2=value2');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void propertyValueEqualsFALSE() {
		load(MultiplePropertiesRequiredConfiguration.class, 'property1=FALSE', 'property2=value2');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void relaxedName() {
		load(RelaxedPropertiesRequiredConfiguration.class, 'spring.theRelaxedProperty=value1');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void prefixWithoutPeriod() {
		load(RelaxedPropertiesRequiredConfigurationWithShortPrefix.class, 'spring.property=value1');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	// Enabled by default
	void enabledIfNotConfiguredOtherwise() {
		load(EnabledIfNotConfiguredOtherwiseConfig.class);
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void enabledIfNotConfiguredOtherwiseWithConfig() {
		load(EnabledIfNotConfiguredOtherwiseConfig.class, 'simple.myProperty:false');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void enabledIfNotConfiguredOtherwiseWithConfigDifferentCase() {
		load(EnabledIfNotConfiguredOtherwiseConfig.class, 'simple.my-property:FALSE');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	// Disabled by default
	void disableIfNotConfiguredOtherwise() {
		load(DisabledIfNotConfiguredOtherwiseConfig.class);
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void disableIfNotConfiguredOtherwiseWithConfig() {
		load(DisabledIfNotConfiguredOtherwiseConfig.class, 'simple.myProperty:true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void disableIfNotConfiguredOtherwiseWithConfigDifferentCase() {
		load(DisabledIfNotConfiguredOtherwiseConfig.class, 'simple.myproperty:TrUe');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void simpleValueIsSet() {
		load(SimpleValueConfig.class, 'simple.myProperty:bar');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void caseInsensitive() {
		load(SimpleValueConfig.class, 'simple.myProperty:BaR');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void defaultValueIsSet() {
		load(DefaultValueConfig.class, 'simple.myProperty:bar');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void defaultValueIsNotSet() {
		load(DefaultValueConfig.class);
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void defaultValueIsSetDifferentValue() {
		load(DefaultValueConfig.class, 'simple.myProperty:another');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void prefix() {
		load(PrefixValueConfig.class, 'simple.myProperty:bar');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void relaxedEnabledByDefault() {
		load(PrefixValueConfig.class, 'simple.myProperty:bar');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void multiValuesAllSet() {
		load(MultiValuesConfig.class, 'simple.my-property:bar', 'simple.my-another-property:bar');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void multiValuesOnlyOneSet() {
		load(MultiValuesConfig.class, 'simple.my-property:bar');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void usingValueAttribute() {
		load(ValueAttribute.class, 'some.property');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void nameOrValueMustBeSpecified() {
		assertThatIllegalStateException().isThrownBy(() -> load(NoNameOrValueAttribute.class, 'some.property'))
			.satisfies(
					causeMessageContaining('The name or value attribute of @ConditionalOnProperty must be specified'));
	}
	@Test
	void nameAndValueMustNotBeSpecified() {
		assertThatIllegalStateException().isThrownBy(() -> load(NameAndValueAttribute.class, 'some.property'))
			.satisfies(causeMessageContaining('The name and value attributes of @ConditionalOnProperty are exclusive'));
	}
	private <T extends Exception> Consumer<T> causeMessageContaining(String message) {
		return (ex) -> assertThat(ex.getCause()).hasMessageContaining(message);
	}
	@Test
	void metaAnnotationConditionMatchesWhenPropertyIsSet() {
		load(MetaAnnotation.class, 'my.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void metaAnnotationConditionDoesNotMatchWhenPropertyIsNotSet() {
		load(MetaAnnotation.class);
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void metaAndDirectAnnotationConditionDoesNotMatchWhenOnlyDirectPropertyIsSet() {
		load(MetaAnnotationAndDirectAnnotation.class, 'my.other.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void metaAndDirectAnnotationConditionDoesNotMatchWhenOnlyMetaPropertyIsSet() {
		load(MetaAnnotationAndDirectAnnotation.class, 'my.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void metaAndDirectAnnotationConditionDoesNotMatchWhenNeitherPropertyIsSet() {
		load(MetaAnnotationAndDirectAnnotation.class);
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void metaAndDirectAnnotationConditionMatchesWhenBothPropertiesAreSet() {
		load(MetaAnnotationAndDirectAnnotation.class, 'my.feature.enabled=true', 'my.other.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void metaAnnotationWithAliasConditionMatchesWhenPropertyIsSet() {
		load(MetaAnnotationWithAlias.class, 'my.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void metaAndDirectAnnotationWithAliasConditionDoesNotMatchWhenOnlyMetaPropertyIsSet() {
		load(MetaAnnotationAndDirectAnnotationWithAlias.class, 'my.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void metaAndDirectAnnotationWithAliasConditionDoesNotMatchWhenOnlyDirectPropertyIsSet() {
		load(MetaAnnotationAndDirectAnnotationWithAlias.class, 'my.other.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void metaAndDirectAnnotationWithAliasConditionMatchesWhenBothPropertiesAreSet() {
		load(MetaAnnotationAndDirectAnnotationWithAlias.class, 'my.feature.enabled=true',
				'my.other.feature.enabled=true');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	private void load(Class<?> config, String... environment) {
		TestPropertyValues.of(environment).applyTo(this.environment);
		this.context = new SpringApplicationBuilder(config).environment(this.environment)
			.web(WebApplicationType.NONE)
			.run();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(name = { 'property1', 'property2' })
	static class MultiplePropertiesRequiredConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.', name = 'the-relaxed-property')
	static class RelaxedPropertiesRequiredConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring', name = 'property')
	static class RelaxedPropertiesRequiredConfigurationWithShortPrefix {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	// i.e ${simple.myProperty:true}
	@ConditionalOnProperty(prefix = 'simple', name = 'my-property', havingValue = 'true', matchIfMissing = true)
	static class EnabledIfNotConfiguredOtherwiseConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	// i.e ${simple.myProperty:false}
	@ConditionalOnProperty(prefix = 'simple', name = 'my-property', havingValue = 'true')
	static class DisabledIfNotConfiguredOtherwiseConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'simple', name = 'my-property', havingValue = 'bar')
	static class SimpleValueConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(name = 'simple.myProperty', havingValue = 'bar', matchIfMissing = true)
	static class DefaultValueConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'simple', name = 'my-property', havingValue = 'bar')
	static class PrefixValueConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'simple', name = { 'my-property', 'my-another-property' }, havingValue = 'bar')
	static class MultiValuesConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty('some.property')
	static class ValueAttribute {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty
	static class NoNameOrValueAttribute {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(value = 'x', name = 'y')
	static class NameAndValueAttribute {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMyFeature
	static class MetaAnnotation {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMyFeature
	@ConditionalOnProperty(prefix = 'my.other.feature', name = 'enabled', havingValue = 'true')
	static class MetaAnnotationAndDirectAnnotation {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Retention(RetentionPolicy.RUNTIME)
	@Target({ ElementType.TYPE, ElementType.METHOD })
	@ConditionalOnProperty(prefix = 'my.feature', name = 'enabled', havingValue = 'true')
	@interface ConditionalOnMyFeature {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMyFeatureWithAlias('my.feature')
	static class MetaAnnotationWithAlias {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMyFeatureWithAlias('my.feature')
	@ConditionalOnProperty(prefix = 'my.other.feature', name = 'enabled', havingValue = 'true')
	static class MetaAnnotationAndDirectAnnotationWithAlias {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Retention(RetentionPolicy.RUNTIME)
	@Target({ ElementType.TYPE, ElementType.METHOD })
	@ConditionalOnProperty(name = 'enabled', havingValue = 'true')
	@interface ConditionalOnMyFeatureWithAlias {
		@AliasFor(annotation = ConditionalOnProperty.class, attribute = 'prefix')
		String value();
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnSingleCandidateTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void singleCandidateNoCandidate() {
		this.contextRunner.withUserConfiguration(OnBeanSingleCandidateConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('consumer'));
	}
	@Test
	void singleCandidateOneCandidate() {
		this.contextRunner.withUserConfiguration(AlphaConfiguration.class, OnBeanSingleCandidateConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('consumer');
				assertThat(context.getBean('consumer')).isEqualTo('alpha');
			});
	}
	@Test
	void singleCandidateOneScopedProxyCandidate() {
		this.contextRunner
			.withUserConfiguration(AlphaScopedProxyConfiguration.class, OnBeanSingleCandidateConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('consumer');
				assertThat(context.getBean('consumer')).hasToString('alpha');
			});
	}
	@Test
	void singleCandidateInAncestorsOneCandidateInCurrent() {
		this.contextRunner.run((parent) -> this.contextRunner
			.withUserConfiguration(AlphaConfiguration.class, OnBeanSingleCandidateInAncestorsConfiguration.class)
			.withParent(parent)
			.run((child) -> assertThat(child).doesNotHaveBean('consumer')));
	}
	@Test
	void singleCandidateInAncestorsOneCandidateInParent() {
		this.contextRunner.withUserConfiguration(AlphaConfiguration.class)
			.run((parent) -> this.contextRunner
				.withUserConfiguration(OnBeanSingleCandidateInAncestorsConfiguration.class)
				.withParent(parent)
				.run((child) -> {
					assertThat(child).hasBean('consumer');
					assertThat(child.getBean('consumer')).isEqualTo('alpha');
				}));
	}
	@Test
	void singleCandidateInAncestorsOneCandidateInGrandparent() {
		this.contextRunner.withUserConfiguration(AlphaConfiguration.class)
			.run((grandparent) -> this.contextRunner.withParent(grandparent)
				.run((parent) -> this.contextRunner
					.withUserConfiguration(OnBeanSingleCandidateInAncestorsConfiguration.class)
					.withParent(parent)
					.run((child) -> {
						assertThat(child).hasBean('consumer');
						assertThat(child.getBean('consumer')).isEqualTo('alpha');
					})));
	}
	@Test
	void singleCandidateMultipleCandidates() {
		this.contextRunner
			.withUserConfiguration(AlphaConfiguration.class, BravoConfiguration.class,
					OnBeanSingleCandidateConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('consumer'));
	}
	@Test
	void singleCandidateMultipleCandidatesOnePrimary() {
		this.contextRunner
			.withUserConfiguration(AlphaPrimaryConfiguration.class, BravoConfiguration.class,
					OnBeanSingleCandidateConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('consumer');
				assertThat(context.getBean('consumer')).isEqualTo('alpha');
			});
	}
	@Test
	void singleCandidateTwoCandidatesOneNormalOneFallback() {
		this.contextRunner
			.withUserConfiguration(AlphaFallbackConfiguration.class, BravoConfiguration.class,
					OnBeanSingleCandidateConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('consumer');
				assertThat(context.getBean('consumer')).isEqualTo('bravo');
			});
	}
	@Test
	void singleCandidateMultipleCandidatesMultiplePrimary() {
		this.contextRunner
			.withUserConfiguration(AlphaPrimaryConfiguration.class, BravoPrimaryConfiguration.class,
					OnBeanSingleCandidateConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('consumer'));
	}
	@Test
	void singleCandidateMultipleCandidatesAllFallback() {
		this.contextRunner
			.withUserConfiguration(AlphaFallbackConfiguration.class, BravoFallbackConfiguration.class,
					OnBeanSingleCandidateConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('consumer'));
	}
	@Test
	void invalidAnnotationTwoTypes() {
		this.contextRunner.withUserConfiguration(OnBeanSingleCandidateTwoTypesConfiguration.class).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context).getFailure()
				.hasCauseInstanceOf(IllegalArgumentException.class)
				.hasMessageContaining(OnBeanSingleCandidateTwoTypesConfiguration.class.getName());
		});
	}
	@Test
	void invalidAnnotationNoType() {
		this.contextRunner.withUserConfiguration(OnBeanSingleCandidateNoTypeConfiguration.class).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context).getFailure()
				.hasCauseInstanceOf(IllegalArgumentException.class)
				.hasMessageContaining(OnBeanSingleCandidateNoTypeConfiguration.class.getName());
		});
	}
	@Test
	void singleCandidateMultipleCandidatesInContextHierarchy() {
		this.contextRunner.withUserConfiguration(AlphaPrimaryConfiguration.class, BravoConfiguration.class)
			.run((parent) -> this.contextRunner.withUserConfiguration(OnBeanSingleCandidateConfiguration.class)
				.withParent(parent)
				.run((child) -> {
					assertThat(child).hasBean('consumer');
					assertThat(child.getBean('consumer')).isEqualTo('alpha');
				}));
	}
	@Test
	void singleCandidateMultipleCandidatesOneAutowireCandidate() {
		this.contextRunner
			.withUserConfiguration(AlphaConfiguration.class, BravoNonAutowireConfiguration.class,
					OnBeanSingleCandidateConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('consumer');
				assertThat(context.getBean('consumer')).isEqualTo('alpha');
			});
	}
	@Test
	void singleCandidateMultipleCandidatesOneDefaultCandidate() {
		this.contextRunner
			.withUserConfiguration(AlphaConfiguration.class, BravoNonDefaultConfiguration.class,
					OnBeanSingleCandidateConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('consumer');
				assertThat(context.getBean('consumer')).isEqualTo('alpha');
			});
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(String.class)
	static class OnBeanSingleCandidateConfiguration {
		@Bean
		CharSequence consumer(CharSequence s) {
			return s;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(value = String.class, search = SearchStrategy.ANCESTORS)
	static class OnBeanSingleCandidateInAncestorsConfiguration {
		@Bean
		CharSequence consumer(CharSequence s) {
			return s;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(value = String.class, type = 'java.lang.Integer')
	static class OnBeanSingleCandidateTwoTypesConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate
	static class OnBeanSingleCandidateNoTypeConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class AlphaConfiguration {
		@Bean
		String alpha() {
			return 'alpha';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AlphaPrimaryConfiguration {
		@Bean
		@Primary
		String alpha() {
			return 'alpha';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AlphaFallbackConfiguration {
		@Bean
		@Fallback
		String alpha() {
			return 'alpha';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AlphaScopedProxyConfiguration {
		@Bean
		@Scope(proxyMode = ScopedProxyMode.INTERFACES)
		String alpha() {
			return 'alpha';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BravoConfiguration {
		@Bean
		String bravo() {
			return 'bravo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BravoPrimaryConfiguration {
		@Bean
		@Primary
		String bravo() {
			return 'bravo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BravoFallbackConfiguration {
		@Bean
		@Fallback
		String bravo() {
			return 'bravo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BravoNonAutowireConfiguration {
		@Bean(autowireCandidate = false)
		String bravo() {
			return 'bravo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class BravoNonDefaultConfiguration {
		@Bean(defaultCandidate = false)
		String bravo() {
			return 'bravo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@ClassPathExclusions('jackson-core-*.jar')
class OnBeanConditionTypeDeductionFailureTests {
	@Test
	void conditionalOnMissingBeanWithDeducedTypeThatIsPartiallyMissingFromClassPath() {
		assertThatException()
			.isThrownBy(() -> new AnnotationConfigApplicationContext(ImportingConfiguration.class).close())
			.satisfies((ex) -> {
				Throwable beanTypeDeductionException = findNestedCause(ex, BeanTypeDeductionException.class);
				assertThat(beanTypeDeductionException).hasMessage('Failed to deduce bean type for '
						+ OnMissingBeanConfiguration.class.getName() + '.objectMapper');
				assertThat(findNestedCause(beanTypeDeductionException, NoClassDefFoundError.class)).isNotNull();
			});
	}
	private Throwable findNestedCause(Throwable ex, Class<? extends Throwable> target) {
		Throwable candidate = ex;
		while (candidate != null) {
			if (target.isInstance(candidate)) {
				return candidate;
			}
			candidate = candidate.getCause();
		}
		return null;
	}
	@Configuration(proxyBeanMethods = false)
	@Import(OnMissingBeanImportSelector.class)
	static class ImportingConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class OnMissingBeanConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ObjectMapper objectMapper() {
			return new ObjectMapper();
		}
	}
	static class OnMissingBeanImportSelector implements ImportSelector {
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			return new String[] { OnMissingBeanConfiguration.class.getName() };
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnWarDeploymentTests {
	@Test
	void nonWebApplicationShouldNotMatch() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner();
		contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('forWar'));
	}
	@Test
	void reactiveWebApplicationShouldNotMatch() {
		ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner();
		contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('forWar'));
	}
	@Test
	void embeddedServletWebApplicationShouldNotMatch() {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
				AnnotationConfigServletWebApplicationContext::new);
		contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('forWar'));
	}
	@Test
	void warDeployedServletWebApplicationShouldMatch() {
		// sets a mock servletContext before context refresh which is what the
		// SpringBootServletInitializer does for WAR deployments.
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner();
		contextRunner.withUserConfiguration(TestConfiguration.class)
			.run((context) -> assertThat(context).hasBean('forWar'));
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWarDeployment
	static class TestConfiguration {
		@Bean
		String forWar() {
			return 'forWar';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnBeanTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void testNameOnBeanCondition() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnBeanNameConfiguration.class)
			.run(this::hasBarBean);
	}
	@Test
	void testNameAndTypeOnBeanCondition() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnBeanNameAndTypeConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void testNameOnBeanConditionReverseOrder() {
		// Ideally this should be true
		this.contextRunner.withUserConfiguration(OnBeanNameConfiguration.class, FooConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void testClassOnBeanCondition() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnBeanClassConfiguration.class)
			.run(this::hasBarBean);
	}
	@Test
	void testClassOnBeanClassNameCondition() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnBeanClassNameConfiguration.class)
			.run(this::hasBarBean);
	}
	@Test
	void testOnBeanConditionWithXml() {
		this.contextRunner.withUserConfiguration(XmlConfiguration.class, OnBeanNameConfiguration.class)
			.run(this::hasBarBean);
	}
	@Test
	void testOnBeanConditionWithCombinedXml() {
		// Ideally this should be true
		this.contextRunner.withUserConfiguration(CombinedXmlConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void testAnnotationOnBeanCondition() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnAnnotationConfiguration.class)
			.run(this::hasBarBean);
	}
	@Test
	void testOnMissingBeanType() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnBeanMissingClassConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void withPropertyPlaceholderClassName() {
		this.contextRunner
			.withUserConfiguration(PropertySourcesPlaceholderConfigurer.class, WithPropertyPlaceholderClassName.class,
					OnBeanClassConfiguration.class)
			.withPropertyValues('mybeanclass=java.lang.String')
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void beanProducedByFactoryBeanIsConsideredWhenMatchingOnAnnotation() {
		this.contextRunner
			.withUserConfiguration(FactoryBeanConfiguration.class, OnAnnotationWithFactoryBeanConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('bar');
				assertThat(context).hasSingleBean(ExampleBean.class);
			});
	}
	@Test
	void beanProducedByFactoryBeanIsConsideredWhenMatchingOnAnnotation2() {
		this.contextRunner
			.withUserConfiguration(EarlyInitializationFactoryBeanConfiguration.class,
					EarlyInitializationOnAnnotationFactoryBeanConfiguration.class)
			.run((context) -> {
				assertThat(EarlyInitializationFactoryBeanConfiguration.calledWhenNoFrozen).as('calledWhenNoFrozen')
					.isFalse();
				assertThat(context).hasBean('bar');
				assertThat(context).hasSingleBean(ExampleBean.class);
			});
	}
	private void hasBarBean(AssertableApplicationContext context) {
		assertThat(context).hasBean('bar');
		assertThat(context.getBean('bar')).isEqualTo('bar');
	}
	@Test
	void onBeanConditionOutputShouldNotContainConditionalOnMissingBeanClassInMessage() {
		this.contextRunner.withUserConfiguration(OnBeanNameConfiguration.class).run((context) -> {
			Collection<ConditionAndOutcomes> conditionAndOutcomes = ConditionEvaluationReport
				.get(context.getSourceApplicationContext().getBeanFactory())
				.getConditionAndOutcomesBySource()
				.values();
			String message = conditionAndOutcomes.iterator().next().iterator().next().getOutcome().getMessage();
			assertThat(message).doesNotContain('@ConditionalOnMissingBean');
		});
	}
	@Test
	void conditionEvaluationConsidersChangeInTypeWhenBeanIsOverridden() {
		this.contextRunner.withAllowBeanDefinitionOverriding(true)
			.withUserConfiguration(OriginalDefinition.class, OverridingDefinition.class, ConsumingConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('testBean');
				assertThat(context).hasSingleBean(Integer.class);
				assertThat(context).doesNotHaveBean(ConsumingConfiguration.class);
			});
	}
	@Test
	void parameterizedContainerWhenValueIsOfMissingBeanDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithoutCustomConfig.class, ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('otherExampleBean')));
	}
	@Test
	void parameterizedContainerWhenValueIsOfExistingBeanMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomConfig.class, ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('customExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void parameterizedContainerWhenValueIsOfMissingBeanRegistrationDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithoutCustomContainerConfig.class,
					ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('otherExampleBean')));
	}
	@Test
	void parameterizedContainerWhenValueIsOfExistingBeanRegistrationMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomContainerConfig.class,
					ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('customExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnTypeIsOfExistingBeanMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomConfig.class,
					ParameterizedConditionWithReturnTypeConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('customExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnTypeIsOfExistingBeanRegistrationMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomContainerConfig.class,
					ParameterizedConditionWithReturnTypeConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('customExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnRegistrationTypeIsOfExistingBeanMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomConfig.class,
					ParameterizedConditionWithReturnRegistrationTypeConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('customExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnRegistrationTypeIsOfExistingBeanRegistrationMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomContainerConfig.class,
					ParameterizedConditionWithReturnRegistrationTypeConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('customExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void conditionalOnBeanTypeIgnoresNotAutowireCandidateBean() {
		this.contextRunner
			.withUserConfiguration(NotAutowireCandidateConfiguration.class, OnBeanClassConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void conditionalOnBeanNameMatchesNotAutowireCandidateBean() {
		this.contextRunner.withUserConfiguration(NotAutowireCandidateConfiguration.class, OnBeanNameConfiguration.class)
			.run((context) -> assertThat(context).hasBean('bar'));
	}
	@Test
	void conditionalOnAnnotatedBeanIgnoresNotAutowireCandidateBean() {
		this.contextRunner
			.withUserConfiguration(AnnotatedNotAutowireCandidateConfig.class, OnAnnotationConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void conditionalOnBeanTypeIgnoresNotDefaultCandidateBean() {
		this.contextRunner.withUserConfiguration(NotDefaultCandidateConfiguration.class, OnBeanClassConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void conditionalOnBeanNameMatchesNotDefaultCandidateBean() {
		this.contextRunner.withUserConfiguration(NotDefaultCandidateConfiguration.class, OnBeanNameConfiguration.class)
			.run((context) -> assertThat(context).hasBean('bar'));
	}
	@Test
	void conditionalOnAnnotatedBeanIgnoresNotDefaultCandidateBean() {
		this.contextRunner
			.withUserConfiguration(AnnotatedNotDefaultCandidateConfig.class, OnAnnotationConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	private Consumer<ConfigurableApplicationContext> exampleBeanRequirement(String... names) {
		return (context) -> {
			String[] beans = context.getBeanNamesForType(ExampleBean.class);
			String[] containers = context.getBeanNamesForType(TestParameterizedContainer.class);
			assertThat(StringUtils.concatenateStringArrays(beans, containers)).containsOnly(names);
		};
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(name = 'foo')
	static class OnBeanNameConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(name = 'foo', value = Date.class)
	static class OnBeanNameAndTypeConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(annotation = TestAnnotation.class)
	static class OnAnnotationConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(String.class)
	static class OnBeanClassConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(type = 'java.lang.String')
	static class OnBeanClassNameConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(type = 'some.type.Missing')
	static class OnBeanMissingClassConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAnnotation
	static class FooConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NotAutowireCandidateConfiguration {
		@Bean(autowireCandidate = false)
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NotDefaultCandidateConfiguration {
		@Bean(defaultCandidate = false)
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportResource('org/springframework/boot/autoconfigure/condition/foo.xml')
	static class XmlConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportResource('org/springframework/boot/autoconfigure/condition/foo.xml')
	@Import(OnBeanNameConfiguration.class)
	static class CombinedXmlConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(WithPropertyPlaceholderClassNameRegistrar.class)
	static class WithPropertyPlaceholderClassName {
	}
	@Configuration(proxyBeanMethods = false)
	static class FactoryBeanConfiguration {
		@Bean
		ExampleFactoryBean exampleBeanFactoryBean() {
			return new ExampleFactoryBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(annotation = TestAnnotation.class)
	static class OnAnnotationWithFactoryBeanConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class EarlyInitializationFactoryBeanConfiguration {
		static boolean calledWhenNoFrozen;
		@Bean
		@TestAnnotation
		static FactoryBean<?> exampleBeanFactoryBean(ApplicationContext applicationContext) {
			// NOTE: must be static and return raw FactoryBean and not the subclass so
			// Spring can"t guess type
			ConfigurableListableBeanFactory beanFactory = ((ConfigurableApplicationContext) applicationContext)
				.getBeanFactory();
			calledWhenNoFrozen = calledWhenNoFrozen || !beanFactory.isConfigurationFrozen();
			return new ExampleFactoryBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(annotation = TestAnnotation.class)
	static class EarlyInitializationOnAnnotationFactoryBeanConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	static class WithPropertyPlaceholderClassNameRegistrar implements ImportBeanDefinitionRegistrar {
		@Override
		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {
			RootBeanDefinition bd = new RootBeanDefinition();
			bd.setBeanClassName('${mybeanclass}');
			registry.registerBeanDefinition('mybean', bd);
		}
	}
	static class ExampleFactoryBean implements FactoryBean<ExampleBean> {
		@Override
		public ExampleBean getObject() {
			return new ExampleBean('fromFactory');
		}
		@Override
		public Class<?> getObjectType() {
			return ExampleBean.class;
		}
		@Override
		public boolean isSingleton() {
			return false;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OriginalDefinition {
		@Bean
		String testBean() {
			return 'test';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(String.class)
	static class OverridingDefinition {
		@Bean
		Integer testBean() {
			return 1;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(String.class)
	static class ConsumingConfiguration {
		ConsumingConfiguration(String testBean) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithCustomConfig {
		@Bean
		CustomExampleBean customExampleBean() {
			return new CustomExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithoutCustomConfig {
		@Bean
		OtherExampleBean otherExampleBean() {
			return new OtherExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithoutCustomContainerConfig {
		@Bean
		TestParameterizedContainer<OtherExampleBean> otherExampleBean() {
			return new TestParameterizedContainer<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithCustomContainerConfig {
		@Bean
		TestParameterizedContainer<CustomExampleBean> customExampleBean() {
			return new TestParameterizedContainer<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedConditionWithValueConfig {
		@Bean
		@ConditionalOnBean(value = CustomExampleBean.class, parameterizedContainer = TestParameterizedContainer.class)
		CustomExampleBean conditionalCustomExampleBean() {
			return new CustomExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedConditionWithReturnTypeConfig {
		@Bean
		@ConditionalOnBean(parameterizedContainer = TestParameterizedContainer.class)
		CustomExampleBean conditionalCustomExampleBean() {
			return new CustomExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedConditionWithReturnRegistrationTypeConfig {
		@Bean
		@ConditionalOnBean(parameterizedContainer = TestParameterizedContainer.class)
		TestParameterizedContainer<CustomExampleBean> conditionalCustomExampleBean() {
			return new TestParameterizedContainer<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnnotatedNotAutowireCandidateConfig {
		@Bean(autowireCandidate = false)
		ExampleBean exampleBean() {
			return new ExampleBean('value');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnnotatedNotDefaultCandidateConfig {
		@Bean(defaultCandidate = false)
		ExampleBean exampleBean() {
			return new ExampleBean('value');
		}
	}
	@TestAnnotation
	static class ExampleBean {
		private final String value;
		ExampleBean(String value) {
			this.value = value;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
	static class CustomExampleBean extends ExampleBean {
		CustomExampleBean() {
			super('custom subclass');
		}
	}
	static class OtherExampleBean extends ExampleBean {
		OtherExampleBean() {
			super('other subclass');
		}
	}
	@Target({ ElementType.TYPE, ElementType.METHOD })
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@interface TestAnnotation {
	}
}
/*
package org.springframework.boot.autoconfigure.condition.config.second;
/**
@AutoConfiguration('autoConfigTwo')
@ConditionalOnProperty('sample.second')
public class SampleAutoConfiguration {
	@Bean
	public String two() {
		return 'two';
	}
}
/*
package org.springframework.boot.autoconfigure.condition.config.first;
/**
@AutoConfiguration('autoConfigOne')
@ConditionalOnProperty('sample.first')
public class SampleAutoConfiguration {
	@Bean
	public String one() {
		return 'one';
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnResourceTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@Test
	void testResourceExists() {
		this.context.register(BasicConfiguration.class);
		this.context.refresh();
		assertThat(this.context.containsBean('foo')).isTrue();
		assertThat(this.context.getBean('foo')).isEqualTo('foo');
	}
	@Test
	void testResourceExistsWithPlaceholder() {
		TestPropertyValues.of('schema=schema.sql').applyTo(this.context);
		this.context.register(PlaceholderConfiguration.class);
		this.context.refresh();
		assertThat(this.context.containsBean('foo')).isTrue();
		assertThat(this.context.getBean('foo')).isEqualTo('foo');
	}
	@Test
	void testResourceNotExists() {
		this.context.register(MissingConfiguration.class);
		this.context.refresh();
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnResource(resources = 'foo')
	static class MissingConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnResource(resources = 'schema.sql')
	static class BasicConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnResource(resources = '${schema}')
	static class PlaceholderConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnMissingClassTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	@Test
	void testVanillaOnClassCondition() {
		this.context.register(BasicConfiguration.class, FooConfiguration.class);
		this.context.refresh();
		assertThat(this.context.containsBean('bar')).isFalse();
		assertThat(this.context.getBean('foo')).isEqualTo('foo');
	}
	@Test
	void testMissingOnClassCondition() {
		this.context.register(MissingConfiguration.class, FooConfiguration.class);
		this.context.refresh();
		assertThat(this.context.containsBean('bar')).isTrue();
		assertThat(this.context.getBean('foo')).isEqualTo('foo');
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingClass('org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClassTests')
	static class BasicConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingClass('FOO')
	static class MissingConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FooConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnClassTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void testVanillaOnClassCondition() {
		this.contextRunner.withUserConfiguration(BasicConfiguration.class, FooConfiguration.class)
			.run(this::hasBarBean);
	}
	@Test
	void testMissingOnClassCondition() {
		this.contextRunner.withUserConfiguration(MissingConfiguration.class, FooConfiguration.class).run((context) -> {
			assertThat(context).doesNotHaveBean('bar');
			assertThat(context).hasBean('foo');
			assertThat(context.getBean('foo')).isEqualTo('foo');
		});
	}
	@Test
	void testOnClassConditionWithXml() {
		this.contextRunner.withUserConfiguration(BasicConfiguration.class, XmlConfiguration.class)
			.run(this::hasBarBean);
	}
	@Test
	void testOnClassConditionWithCombinedXml() {
		this.contextRunner.withUserConfiguration(CombinedXmlConfiguration.class).run(this::hasBarBean);
	}
	@Test
	void onClassConditionOutputShouldNotContainConditionalOnMissingClassInMessage() {
		this.contextRunner.withUserConfiguration(BasicConfiguration.class).run((context) -> {
			Collection<ConditionEvaluationReport.ConditionAndOutcomes> conditionAndOutcomes = ConditionEvaluationReport
				.get(context.getSourceApplicationContext().getBeanFactory())
				.getConditionAndOutcomesBySource()
				.values();
			String message = conditionAndOutcomes.iterator().next().iterator().next().getOutcome().getMessage();
			assertThat(message).doesNotContain('@ConditionalOnMissingClass did not find unwanted class');
		});
	}
	private void hasBarBean(AssertableApplicationContext context) {
		assertThat(context).hasBean('bar');
		assertThat(context.getBean('bar')).isEqualTo('bar');
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ConditionalOnClassTests.class)
	static class BasicConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(name = 'FOO')
	static class MissingConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FooConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportResource('org/springframework/boot/autoconfigure/condition/foo.xml')
	static class XmlConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BasicConfiguration.class)
	@ImportResource('org/springframework/boot/autoconfigure/condition/foo.xml')
	static class CombinedXmlConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class AnyNestedConditionTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void neither() {
		this.contextRunner.withUserConfiguration(Config.class).run(match(false));
	}
	@Test
	void propertyA() {
		this.contextRunner.withUserConfiguration(Config.class).withPropertyValues('a:a').run(match(true));
	}
	@Test
	void propertyB() {
		this.contextRunner.withUserConfiguration(Config.class).withPropertyValues('b:b').run(match(true));
	}
	@Test
	void both() {
		this.contextRunner.withUserConfiguration(Config.class).withPropertyValues('a:a', 'b:b').run(match(true));
	}
	private ContextConsumer<AssertableApplicationContext> match(boolean expected) {
		return (context) -> {
			if (expected) {
				assertThat(context).hasBean('myBean');
			}
			else {
				assertThat(context).doesNotHaveBean('myBean');
			}
		};
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(OnPropertyAorBCondition.class)
	static class Config {
		@Bean
		String myBean() {
			return 'myBean';
		}
	}
	static class OnPropertyAorBCondition extends AnyNestedCondition {
		OnPropertyAorBCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty('a')
		static class HasPropertyA {
		}
		@ConditionalOnExpression('true')
		@ConditionalOnProperty('b')
		static class HasPropertyB {
		}
		@Conditional(NonSpringBootCondition.class)
		static class SubclassC {
		}
	}
	static class NonSpringBootCondition implements Condition {
		@Override
		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
			return false;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnCheckpointRestoreTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(BasicConfiguration.class);
	@Test
	void whenCracIsUnavailableThenConditionDoesNotMatch() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean('someBean'));
	}
	@Test
	@ClassPathOverrides('org.crac:crac:1.3.0')
	void whenCracIsAvailableThenConditionMatches() {
		this.contextRunner.run((context) -> assertThat(context).hasBean('someBean'));
	}
	@Configuration(proxyBeanMethods = false)
	static class BasicConfiguration {
		@Bean
		@ConditionalOnCheckpointRestore
		String someBean() {
			return 'someBean';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class NoneNestedConditionsTests {
	@Test
	void neither() {
		AnnotationConfigApplicationContext context = load(Config.class);
		assertThat(context.containsBean('myBean')).isTrue();
		context.close();
	}
	@Test
	void propertyA() {
		AnnotationConfigApplicationContext context = load(Config.class, 'a:a');
		assertThat(context.containsBean('myBean')).isFalse();
		context.close();
	}
	@Test
	void propertyB() {
		AnnotationConfigApplicationContext context = load(Config.class, 'b:b');
		assertThat(context.containsBean('myBean')).isFalse();
		context.close();
	}
	@Test
	void both() {
		AnnotationConfigApplicationContext context = load(Config.class, 'a:a', 'b:b');
		assertThat(context.containsBean('myBean')).isFalse();
		context.close();
	}
	private AnnotationConfigApplicationContext load(Class<?> config, String... env) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(env).applyTo(context);
		context.register(config);
		context.refresh();
		return context;
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(NeitherPropertyANorPropertyBCondition.class)
	static class Config {
		@Bean
		String myBean() {
			return 'myBean';
		}
	}
	static class NeitherPropertyANorPropertyBCondition extends NoneNestedConditions {
		NeitherPropertyANorPropertyBCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty('a')
		static class HasPropertyA {
		}
		@ConditionalOnProperty('b')
		static class HasPropertyB {
		}
		@Conditional(NonSpringBootCondition.class)
		static class SubClassC {
		}
	}
	static class NonSpringBootCondition implements Condition {
		@Override
		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
			return false;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnJndiTests {
	private ClassLoader threadContextClassLoader;
	private String initialContextFactory;
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	private final MockableOnJndi condition = new MockableOnJndi();
	@BeforeEach
	void setupThreadContextClassLoader() {
		this.threadContextClassLoader = Thread.currentThread().getContextClassLoader();
		Thread.currentThread().setContextClassLoader(new JndiPropertiesHidingClassLoader(getClass().getClassLoader()));
	}
	@AfterEach
	void close() {
		TestableInitialContextFactory.clearAll();
		if (this.initialContextFactory != null) {
			System.setProperty(Context.INITIAL_CONTEXT_FACTORY, this.initialContextFactory);
		}
		else {
			System.clearProperty(Context.INITIAL_CONTEXT_FACTORY);
		}
		Thread.currentThread().setContextClassLoader(this.threadContextClassLoader);
	}
	@Test
	void jndiNotAvailable() {
		this.contextRunner.withUserConfiguration(JndiAvailableConfiguration.class, JndiConditionConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(String.class));
	}
	@Test
	void jndiAvailable() {
		setupJndi();
		this.contextRunner.withUserConfiguration(JndiAvailableConfiguration.class, JndiConditionConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(String.class));
	}
	@Test
	void jndiLocationNotBound() {
		setupJndi();
		this.contextRunner.withUserConfiguration(JndiConditionConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(String.class));
	}
	@Test
	void jndiLocationBound() {
		setupJndi();
		TestableInitialContextFactory.bind('java:/FooManager', new Object());
		this.contextRunner.withUserConfiguration(JndiConditionConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(String.class));
	}
	@Test
	void jndiLocationNotFound() {
		ConditionOutcome outcome = this.condition.getMatchOutcome(null, mockMetadata('java:/a'));
		assertThat(outcome.isMatch()).isFalse();
	}
	@Test
	void jndiLocationFound() {
		this.condition.setFoundLocation('java:/b');
		ConditionOutcome outcome = this.condition.getMatchOutcome(null, mockMetadata('java:/a', 'java:/b'));
		assertThat(outcome.isMatch()).isTrue();
	}
	private void setupJndi() {
		this.initialContextFactory = System.getProperty(Context.INITIAL_CONTEXT_FACTORY);
		System.setProperty(Context.INITIAL_CONTEXT_FACTORY, TestableInitialContextFactory.class.getName());
	}
	private AnnotatedTypeMetadata mockMetadata(String... value) {
		AnnotatedTypeMetadata metadata = mock(AnnotatedTypeMetadata.class);
		Map<String, Object> attributes = new HashMap<>();
		attributes.put('value', value);
		given(metadata.getAnnotationAttributes(ConditionalOnJndi.class.getName())).willReturn(attributes);
		return metadata;
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnJndi
	static class JndiAvailableConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnJndi('java:/FooManager')
	static class JndiConditionConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	static class MockableOnJndi extends OnJndiCondition {
		private final boolean jndiAvailable = true;
		private String foundLocation;
		@Override
		protected boolean isJndiAvailable() {
			return this.jndiAvailable;
		}
		@Override
		protected JndiLocator getJndiLocator(String[] locations) {
			return new JndiLocator(locations) {
				@Override
				public String lookupFirstLocation() {
					return MockableOnJndi.this.foundLocation;
				}
			};
		}
		void setFoundLocation(String foundLocation) {
			this.foundLocation = foundLocation;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnThreadingTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(BasicConfiguration.class);
	@Test
	@EnabledForJreRange(max = JRE.JAVA_20)
	void platformThreadsOnJdkBelow21IfVirtualThreadsPropertyIsEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.run((context) -> assertThat(context.getBean(ThreadType.class)).isEqualTo(ThreadType.PLATFORM));
	}
	@Test
	@EnabledForJreRange(max = JRE.JAVA_20)
	void platformThreadsOnJdkBelow21IfVirtualThreadsPropertyIsDisabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=false')
			.run((context) -> assertThat(context.getBean(ThreadType.class)).isEqualTo(ThreadType.PLATFORM));
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void virtualThreadsOnJdk21IfVirtualThreadsPropertyIsEnabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=true')
			.run((context) -> assertThat(context.getBean(ThreadType.class)).isEqualTo(ThreadType.VIRTUAL));
	}
	@Test
	@EnabledForJreRange(min = JRE.JAVA_21)
	void platformThreadsOnJdk21IfVirtualThreadsPropertyIsDisabled() {
		this.contextRunner.withPropertyValues('spring.threads.virtual.enabled=false')
			.run((context) -> assertThat(context.getBean(ThreadType.class)).isEqualTo(ThreadType.PLATFORM));
	}
	private enum ThreadType {
		PLATFORM, VIRTUAL
	}
	@Configuration(proxyBeanMethods = false)
	static class BasicConfiguration {
		@Bean
		@ConditionalOnThreading(Threading.VIRTUAL)
		ThreadType virtual() {
			return ThreadType.VIRTUAL;
		}
		@Bean
		@ConditionalOnThreading(Threading.PLATFORM)
		ThreadType platform() {
			return ThreadType.PLATFORM;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@SuppressWarnings('resource')
class SpringBootConditionTests {
	@Test
	void sensibleClassException() {
		assertThatIllegalStateException().isThrownBy(() -> new AnnotationConfigApplicationContext(ErrorOnClass.class))
			.withMessageContaining('Error processing condition on ' + ErrorOnClass.class.getName());
	}
	@Test
	void sensibleMethodException() {
		assertThatIllegalStateException().isThrownBy(() -> new AnnotationConfigApplicationContext(ErrorOnMethod.class))
			.withMessageContaining('Error processing condition on ' + ErrorOnMethod.class.getName() + '.myBean');
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(AlwaysThrowsCondition.class)
	static class ErrorOnClass {
	}
	@Configuration(proxyBeanMethods = false)
	static class ErrorOnMethod {
		@Bean
		@Conditional(AlwaysThrowsCondition.class)
		String myBean() {
			return 'bean';
		}
	}
	static class AlwaysThrowsCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			throw new RuntimeException('Oh no!');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@ExtendWith(MockitoExtension.class)
class ConditionEvaluationReportTests {
	private DefaultListableBeanFactory beanFactory;
	private ConditionEvaluationReport report;
	@Mock
	private Condition condition1;
	@Mock
	private Condition condition2;
	@Mock
	private Condition condition3;
	private ConditionOutcome outcome1;
	private ConditionOutcome outcome2;
	private ConditionOutcome outcome3;
	@BeforeEach
	void setup() {
		this.beanFactory = new DefaultListableBeanFactory();
		this.report = ConditionEvaluationReport.get(this.beanFactory);
	}
	@Test
	void get() {
		assertThat(this.report).isNotNull();
		assertThat(this.report).isSameAs(ConditionEvaluationReport.get(this.beanFactory));
	}
	@Test
	void parent() {
		this.beanFactory.setParentBeanFactory(new DefaultListableBeanFactory());
		ConditionEvaluationReport.get((ConfigurableListableBeanFactory) this.beanFactory.getParentBeanFactory());
		assertThat(this.report).isSameAs(ConditionEvaluationReport.get(this.beanFactory));
		assertThat(this.report).isNotNull();
		assertThat(this.report.getParent()).isNotNull();
		ConditionEvaluationReport.get((ConfigurableListableBeanFactory) this.beanFactory.getParentBeanFactory());
		assertThat(this.report).isSameAs(ConditionEvaluationReport.get(this.beanFactory));
		assertThat(this.report.getParent()).isSameAs(ConditionEvaluationReport
			.get((ConfigurableListableBeanFactory) this.beanFactory.getParentBeanFactory()));
	}
	@Test
	void parentBottomUp() {
		this.beanFactory = new DefaultListableBeanFactory(); // NB: overrides setup
		this.beanFactory.setParentBeanFactory(new DefaultListableBeanFactory());
		ConditionEvaluationReport.get((ConfigurableListableBeanFactory) this.beanFactory.getParentBeanFactory());
		this.report = ConditionEvaluationReport.get(this.beanFactory);
		assertThat(this.report).isNotNull();
		assertThat(this.report).isNotSameAs(this.report.getParent());
		assertThat(this.report.getParent()).isNotNull();
		assertThat(this.report.getParent().getParent()).isNull();
	}
	@Test
	void recordConditionEvaluations() {
		this.outcome1 = new ConditionOutcome(false, 'm1');
		this.outcome2 = new ConditionOutcome(false, 'm2');
		this.outcome3 = new ConditionOutcome(false, 'm3');
		this.report.recordConditionEvaluation('a', this.condition1, this.outcome1);
		this.report.recordConditionEvaluation('a', this.condition2, this.outcome2);
		this.report.recordConditionEvaluation('b', this.condition3, this.outcome3);
		Map<String, ConditionAndOutcomes> map = this.report.getConditionAndOutcomesBySource();
		assertThat(map).hasSize(2);
		Iterator<ConditionAndOutcome> iterator = map.get('a').iterator();
		ConditionAndOutcome conditionAndOutcome = iterator.next();
		assertThat(conditionAndOutcome.getCondition()).isEqualTo(this.condition1);
		assertThat(conditionAndOutcome.getOutcome()).isEqualTo(this.outcome1);
		conditionAndOutcome = iterator.next();
		assertThat(conditionAndOutcome.getCondition()).isEqualTo(this.condition2);
		assertThat(conditionAndOutcome.getOutcome()).isEqualTo(this.outcome2);
		assertThat(iterator.hasNext()).isFalse();
		iterator = map.get('b').iterator();
		conditionAndOutcome = iterator.next();
		assertThat(conditionAndOutcome.getCondition()).isEqualTo(this.condition3);
		assertThat(conditionAndOutcome.getOutcome()).isEqualTo(this.outcome3);
		assertThat(iterator.hasNext()).isFalse();
	}
	@Test
	void fullMatch() {
		prepareMatches(true, true, true);
		assertThat(this.report.getConditionAndOutcomesBySource().get('a').isFullMatch()).isTrue();
	}
	@Test
	void notFullMatch() {
		prepareMatches(true, false, true);
		assertThat(this.report.getConditionAndOutcomesBySource().get('a').isFullMatch()).isFalse();
	}
	private void prepareMatches(boolean m1, boolean m2, boolean m3) {
		this.outcome1 = new ConditionOutcome(m1, 'm1');
		this.outcome2 = new ConditionOutcome(m2, 'm2');
		this.outcome3 = new ConditionOutcome(m3, 'm3');
		this.report.recordConditionEvaluation('a', this.condition1, this.outcome1);
		this.report.recordConditionEvaluation('a', this.condition2, this.outcome2);
		this.report.recordConditionEvaluation('a', this.condition3, this.outcome3);
	}
	@Test
	@SuppressWarnings('resource')
	void springBootConditionPopulatesReport() {
		ConditionEvaluationReport report = ConditionEvaluationReport
			.get(new AnnotationConfigApplicationContext(Config.class).getBeanFactory());
		assertThat(report.getConditionAndOutcomesBySource()).isNotEmpty();
	}
	@Test
	void testDuplicateConditionAndOutcomes() {
		ConditionAndOutcome outcome1 = new ConditionAndOutcome(this.condition1,
				new ConditionOutcome(true, 'Message 1'));
		ConditionAndOutcome outcome2 = new ConditionAndOutcome(this.condition2,
				new ConditionOutcome(true, 'Message 2'));
		ConditionAndOutcome outcome3 = new ConditionAndOutcome(this.condition3,
				new ConditionOutcome(true, 'Message 2'));
		assertThat(outcome1).isNotEqualTo(outcome2);
		assertThat(outcome2).isEqualTo(outcome3);
		ConditionAndOutcomes outcomes = new ConditionAndOutcomes();
		outcomes.add(this.condition1, new ConditionOutcome(true, 'Message 1'));
		outcomes.add(this.condition2, new ConditionOutcome(true, 'Message 2'));
		outcomes.add(this.condition3, new ConditionOutcome(true, 'Message 2'));
		assertThat(outcomes).hasSize(2);
	}
	@Test
	void duplicateOutcomes() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(DuplicateConfig.class);
		ConditionEvaluationReport report = ConditionEvaluationReport.get(context.getBeanFactory());
		String autoconfigKey = MultipartAutoConfiguration.class.getName();
		ConditionAndOutcomes outcomes = report.getConditionAndOutcomesBySource().get(autoconfigKey);
		assertThat(outcomes).isNotNull();
		assertThat(outcomes).hasSize(2);
		List<String> messages = new ArrayList<>();
		for (ConditionAndOutcome outcome : outcomes) {
			messages.add(outcome.getOutcome().getMessage());
		}
		assertThat(messages).anyMatch((message) -> message.contains('@ConditionalOnClass found required classes '
				+ '"jakarta.servlet.Servlet", "org.springframework.web.multipart.'
				+ 'support.StandardServletMultipartResolver", "jakarta.servlet.MultipartConfigElement"'));
		context.close();
	}
	@Test
	void negativeOuterPositiveInnerBean() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('test.present=true').applyTo(context);
		context.register(NegativeOuterConfig.class);
		context.refresh();
		ConditionEvaluationReport report = ConditionEvaluationReport.get(context.getBeanFactory());
		Map<String, ConditionAndOutcomes> sourceOutcomes = report.getConditionAndOutcomesBySource();
		assertThat(context.containsBean('negativeOuterPositiveInnerBean')).isFalse();
		String negativeConfig = NegativeOuterConfig.class.getName();
		assertThat(sourceOutcomes.get(negativeConfig).isFullMatch()).isFalse();
		String positiveConfig = NegativeOuterConfig.PositiveInnerConfig.class.getName();
		assertThat(sourceOutcomes.get(positiveConfig).isFullMatch()).isFalse();
	}
	@Test
	void reportWhenSameShortNamePresentMoreThanOnceShouldUseFullyQualifiedName() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(WebMvcAutoConfiguration.class,
				org.springframework.boot.autoconfigure.condition.config.first.SampleAutoConfiguration.class,
				org.springframework.boot.autoconfigure.condition.config.second.SampleAutoConfiguration.class);
		context.refresh();
		ConditionEvaluationReport report = ConditionEvaluationReport.get(context.getBeanFactory());
		assertThat(report.getConditionAndOutcomesBySource()).containsKeys(
				'org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration',
				'org.springframework.boot.autoconfigure.condition.config.first.SampleAutoConfiguration',
				'org.springframework.boot.autoconfigure.condition.config.second.SampleAutoConfiguration');
		context.close();
	}
	@Test
	void reportMessageWhenSameShortNamePresentMoreThanOnceShouldUseFullyQualifiedName() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		context.register(WebMvcAutoConfiguration.class,
				org.springframework.boot.autoconfigure.condition.config.first.SampleAutoConfiguration.class,
				org.springframework.boot.autoconfigure.condition.config.second.SampleAutoConfiguration.class);
		context.refresh();
		ConditionEvaluationReport report = ConditionEvaluationReport.get(context.getBeanFactory());
		String reportMessage = new ConditionEvaluationReportMessage(report).toString();
		assertThat(reportMessage).contains('WebMvcAutoConfiguration',
				'org.springframework.boot.autoconfigure.condition.config.first.SampleAutoConfiguration',
				'org.springframework.boot.autoconfigure.condition.config.second.SampleAutoConfiguration');
		assertThat(reportMessage)
			.doesNotContain('org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration');
		context.close();
	}
	@Configuration(proxyBeanMethods = false)
	@Import(WebMvcAutoConfiguration.class)
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(MultipartAutoConfiguration.class)
	static class DuplicateConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional({ ConditionEvaluationReportTests.MatchParseCondition.class,
			ConditionEvaluationReportTests.NoMatchBeanCondition.class })
	static class NegativeOuterConfig {
		@Configuration(proxyBeanMethods = false)
		@Conditional({ ConditionEvaluationReportTests.MatchParseCondition.class })
		static class PositiveInnerConfig {
			@Bean
			String negativeOuterPositiveInnerBean() {
				return 'negativeOuterPositiveInnerBean';
			}
		}
	}
	static class TestMatchCondition extends SpringBootCondition implements ConfigurationCondition {
		private final ConfigurationPhase phase;
		private final boolean match;
		TestMatchCondition(ConfigurationPhase phase, boolean match) {
			this.phase = phase;
			this.match = match;
		}
		@Override
		public ConfigurationPhase getConfigurationPhase() {
			return this.phase;
		}
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			return new ConditionOutcome(this.match, ClassUtils.getShortName(getClass()));
		}
	}
	static class MatchParseCondition extends TestMatchCondition {
		MatchParseCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION, true);
		}
	}
	static class MatchBeanCondition extends TestMatchCondition {
		MatchBeanCondition() {
			super(ConfigurationPhase.REGISTER_BEAN, true);
		}
	}
	static class NoMatchParseCondition extends TestMatchCondition {
		NoMatchParseCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION, false);
		}
	}
	static class NoMatchBeanCondition extends TestMatchCondition {
		NoMatchBeanCondition() {
			super(ConfigurationPhase.REGISTER_BEAN, false);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionMessageTests {
	@Test
	void isEmptyWhenEmptyShouldReturnTrue() {
		ConditionMessage message = ConditionMessage.empty();
		assertThat(message.isEmpty()).isTrue();
	}
	@Test
	void isEmptyWhenNotEmptyShouldReturnFalse() {
		ConditionMessage message = ConditionMessage.of('Test');
		assertThat(message.isEmpty()).isFalse();
	}
	@Test
	void toStringWhenEmptyShouldReturnEmptyString() {
		ConditionMessage message = ConditionMessage.empty();
		assertThat(message).hasToString('');
	}
	@Test
	void toStringWhenHasMessageShouldReturnMessage() {
		ConditionMessage message = ConditionMessage.of('Test');
		assertThat(message).hasToString('Test');
	}
	@Test
	void appendWhenHasExistingMessageShouldAddSpace() {
		ConditionMessage message = ConditionMessage.of('a').append('b');
		assertThat(message).hasToString('a b');
	}
	@Test
	void appendWhenAppendingNullShouldDoNothing() {
		ConditionMessage message = ConditionMessage.of('a').append(null);
		assertThat(message).hasToString('a');
	}
	@Test
	void appendWhenNoMessageShouldNotAddSpace() {
		ConditionMessage message = ConditionMessage.empty().append('b');
		assertThat(message).hasToString('b');
	}
	@Test
	void andConditionWhenUsingClassShouldIncludeCondition() {
		ConditionMessage message = ConditionMessage.empty().andCondition(Test.class).because('OK');
		assertThat(message).hasToString('@Test OK');
	}
	@Test
	void andConditionWhenUsingStringShouldIncludeCondition() {
		ConditionMessage message = ConditionMessage.empty().andCondition('@Test').because('OK');
		assertThat(message).hasToString('@Test OK');
	}
	@Test
	void andConditionWhenIncludingDetailsShouldIncludeCondition() {
		ConditionMessage message = ConditionMessage.empty().andCondition(Test.class, '(a=b)').because('OK');
		assertThat(message).hasToString('@Test (a=b) OK');
	}
	@Test
	void ofCollectionShouldCombine() {
		List<ConditionMessage> messages = new ArrayList<>();
		messages.add(ConditionMessage.of('a'));
		messages.add(ConditionMessage.of('b'));
		ConditionMessage message = ConditionMessage.of(messages);
		assertThat(message).hasToString('a; b');
	}
	@Test
	void ofCollectionWhenNullShouldReturnEmpty() {
		ConditionMessage message = ConditionMessage.of((List<ConditionMessage>) null);
		assertThat(message.isEmpty()).isTrue();
	}
	@Test
	void forConditionShouldIncludeCondition() {
		ConditionMessage message = ConditionMessage.forCondition('@Test').because('OK');
		assertThat(message).hasToString('@Test OK');
	}
	@Test
	void forConditionShouldNotAddExtraSpaceWithEmptyCondition() {
		ConditionMessage message = ConditionMessage.forCondition('').because('OK');
		assertThat(message).hasToString('OK');
	}
	@Test
	void forConditionWhenClassShouldIncludeCondition() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class, '(a=b)').because('OK');
		assertThat(message).hasToString('@Test (a=b) OK');
	}
	@Test
	void foundExactlyShouldConstructMessage() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class).foundExactly('abc');
		assertThat(message).hasToString('@Test found abc');
	}
	@Test
	void foundWhenSingleElementShouldUseSingular() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class).found('bean', 'beans').items('a');
		assertThat(message).hasToString('@Test found bean a');
	}
	@Test
	void foundNoneAtAllShouldConstructMessage() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class).found('no beans').atAll();
		assertThat(message).hasToString('@Test found no beans');
	}
	@Test
	void foundWhenMultipleElementsShouldUsePlural() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class)
			.found('bean', 'beans')
			.items('a', 'b', 'c');
		assertThat(message).hasToString('@Test found beans a, b, c');
	}
	@Test
	void foundWhenQuoteStyleShouldQuote() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class)
			.found('bean', 'beans')
			.items(Style.QUOTE, 'a', 'b', 'c');
		assertThat(message).hasToString('@Test found beans "a", "b", "c"');
	}
	@Test
	void didNotFindWhenSingleElementShouldUseSingular() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class).didNotFind('class', 'classes').items('a');
		assertThat(message).hasToString('@Test did not find class a');
	}
	@Test
	void didNotFindWhenMultipleElementsShouldUsePlural() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class)
			.didNotFind('class', 'classes')
			.items('a', 'b', 'c');
		assertThat(message).hasToString('@Test did not find classes a, b, c');
	}
	@Test
	void resultedInShouldConstructMessage() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class).resultedIn('Green');
		assertThat(message).hasToString('@Test resulted in Green');
	}
	@Test
	void notAvailableShouldConstructMessage() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class).notAvailable('JMX');
		assertThat(message).hasToString('@Test JMX is not available');
	}
	@Test
	void availableShouldConstructMessage() {
		ConditionMessage message = ConditionMessage.forCondition(Test.class).available('JMX');
		assertThat(message).hasToString('@Test JMX is available');
	}
	@Test
	void itemsTolerateNullInput() {
		Collection<?> items = null;
		ConditionMessage message = ConditionMessage.forCondition(Test.class).didNotFind('item').items(items);
		assertThat(message).hasToString('@Test did not find item');
	}
	@Test
	void quotedItemsTolerateNullInput() {
		Collection<?> items = null;
		ConditionMessage message = ConditionMessage.forCondition(Test.class)
			.didNotFind('item')
			.items(Style.QUOTE, items);
		assertThat(message).hasToString('@Test did not find item');
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnWebApplicationTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void closeContext() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void testWebApplicationWithServletContext() {
		AnnotationConfigServletWebApplicationContext ctx = new AnnotationConfigServletWebApplicationContext();
		ctx.register(AnyWebApplicationConfiguration.class, ServletWebApplicationConfiguration.class,
				ReactiveWebApplicationConfiguration.class);
		ctx.setServletContext(new MockServletContext());
		ctx.refresh();
		this.context = ctx;
		assertThat(this.context.getBeansOfType(String.class)).containsExactly(entry('any', 'any'),
				entry('servlet', 'servlet'));
	}
	@Test
	void testWebApplicationWithReactiveContext() {
		AnnotationConfigReactiveWebApplicationContext context = new AnnotationConfigReactiveWebApplicationContext();
		context.register(AnyWebApplicationConfiguration.class, ServletWebApplicationConfiguration.class,
				ReactiveWebApplicationConfiguration.class);
		context.refresh();
		this.context = context;
		assertThat(this.context.getBeansOfType(String.class)).containsExactly(entry('any', 'any'),
				entry('reactive', 'reactive'));
	}
	@Test
	void testNonWebApplication() {
		AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
		ctx.register(AnyWebApplicationConfiguration.class, ServletWebApplicationConfiguration.class,
				ReactiveWebApplicationConfiguration.class);
		ctx.refresh();
		this.context = ctx;
		assertThat(this.context.getBeansOfType(String.class)).isEmpty();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication
	static class AnyWebApplicationConfiguration {
		@Bean
		String any() {
			return 'any';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	static class ServletWebApplicationConfiguration {
		@Bean
		String servlet() {
			return 'servlet';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	static class ReactiveWebApplicationConfiguration {
		@Bean
		String reactive() {
			return 'reactive';
		}
		@Bean
		ReactiveWebServerFactory reactiveWebServerFactory() {
			return new MockReactiveWebServerFactory();
		}
		@Bean
		HttpHandler httpHandler() {
			return (request, response) -> Mono.empty();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@ClassPathExclusions('spring-context-support-*.jar')
class ConditionalOnMissingBeanWithFilteredClasspathTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(OnBeanTypeConfiguration.class);
	@Test
	void testNameOnMissingBeanTypeWithMissingImport() {
		this.contextRunner.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Configuration(proxyBeanMethods = false)
	static class OnBeanTypeConfiguration {
		@Bean
		@ConditionalOnMissingBean(
				type = 'org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBeanWithFilteredClasspathTests.TestCacheManager')
		String foo() {
			return 'foo';
		}
	}
	static class TestCacheManager extends CaffeineCacheManager {
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class AbstractNestedConditionTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void validPhase() {
		this.contextRunner.withUserConfiguration(ValidConfig.class)
			.run((context) -> assertThat(context).hasBean('myBean'));
	}
	@Test
	void invalidMemberPhase() {
		this.contextRunner.withUserConfiguration(InvalidConfig.class).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context.getStartupFailure().getCause()).isInstanceOf(IllegalStateException.class)
				.hasMessageContaining('Nested condition ' + InvalidNestedCondition.class.getName()
						+ ' uses a configuration phase that is inappropriate for class '
						+ OnBeanCondition.class.getName());
		});
	}
	@Test
	void invalidNestedMemberPhase() {
		this.contextRunner.withUserConfiguration(DoubleNestedConfig.class).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context.getStartupFailure().getCause()).isInstanceOf(IllegalStateException.class)
				.hasMessageContaining('Nested condition ' + DoubleNestedCondition.class.getName()
						+ ' uses a configuration phase that is inappropriate for class '
						+ ValidNestedCondition.class.getName());
		});
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(ValidNestedCondition.class)
	static class ValidConfig {
		@Bean
		String myBean() {
			return 'myBean';
		}
	}
	static class ValidNestedCondition extends AbstractNestedCondition {
		ValidNestedCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@Override
		protected ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes) {
			return ConditionOutcome.match();
		}
		@ConditionalOnMissingBean(name = 'myBean')
		static class MissingMyBean {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(InvalidNestedCondition.class)
	static class InvalidConfig {
		@Bean
		String myBean() {
			return 'myBean';
		}
	}
	static class InvalidNestedCondition extends AbstractNestedCondition {
		InvalidNestedCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@Override
		protected ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes) {
			return ConditionOutcome.match();
		}
		@ConditionalOnMissingBean(name = 'myBean')
		static class MissingMyBean {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(DoubleNestedCondition.class)
	static class DoubleNestedConfig {
	}
	static class DoubleNestedCondition extends AbstractNestedCondition {
		DoubleNestedCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@Override
		protected ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes) {
			return ConditionOutcome.match();
		}
		@Conditional(ValidNestedCondition.class)
		static class NestedConditionThatIsValid {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnNotWebApplicationTests {
	@Test
	void testNotWebApplicationWithServletContext() {
		new WebApplicationContextRunner().withUserConfiguration(NotWebApplicationConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(String.class));
	}
	@Test
	void testNotWebApplicationWithReactiveContext() {
		new ReactiveWebApplicationContextRunner()
			.withUserConfiguration(ReactiveApplicationConfig.class, NotWebApplicationConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(String.class));
	}
	@Test
	void testNotWebApplication() {
		new ApplicationContextRunner().withUserConfiguration(NotWebApplicationConfiguration.class)
			.run((context) -> assertThat(context).getBeans(String.class).containsExactly(entry('none', 'none')));
	}
	@Configuration(proxyBeanMethods = false)
	static class ReactiveApplicationConfig {
		@Bean
		ReactiveWebServerFactory reactiveWebServerFactory() {
			return new MockReactiveWebServerFactory();
		}
		@Bean
		HttpHandler httpHandler() {
			return (request, response) -> Mono.empty();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnNotWebApplication
	static class NotWebApplicationConfiguration {
		@Bean
		String none() {
			return 'none';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnNotWarDeploymentTests {
	@Test
	void nonWebApplicationShouldMatch() {
		ApplicationContextRunner contextRunner = new ApplicationContextRunner();
		contextRunner.withUserConfiguration(NotWarDeploymentConfiguration.class)
			.run((context) -> assertThat(context).hasBean('notForWar'));
	}
	@Test
	void reactiveWebApplicationShouldMatch() {
		ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner();
		contextRunner.withUserConfiguration(NotWarDeploymentConfiguration.class)
			.run((context) -> assertThat(context).hasBean('notForWar'));
	}
	@Test
	void embeddedServletWebApplicationShouldMatch() {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner(
				AnnotationConfigServletWebApplicationContext::new);
		contextRunner.withUserConfiguration(NotWarDeploymentConfiguration.class)
			.run((context) -> assertThat(context).hasBean('notForWar'));
	}
	@Test
	void warDeployedServletWebApplicationShouldNotMatch() {
		WebApplicationContextRunner contextRunner = new WebApplicationContextRunner();
		contextRunner.withUserConfiguration(NotWarDeploymentConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('notForWar'));
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnNotWarDeployment
	static class NotWarDeploymentConfiguration {
		@Bean
		String notForWar() {
			return 'notForWar';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class OnClassConditionAutoConfigurationImportFilterTests {
	private final OnClassCondition filter = new OnClassCondition();
	private final DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	@BeforeEach
	void setup() {
		this.filter.setBeanClassLoader(getClass().getClassLoader());
		this.filter.setBeanFactory(this.beanFactory);
	}
	@Test
	void shouldBeRegistered() {
		assertThat(SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, null))
			.hasAtLeastOneElementOfType(OnClassCondition.class);
	}
	@Test
	void matchShouldMatchClasses() {
		String[] autoConfigurationClasses = new String[] { 'test.match', 'test.nomatch' };
		boolean[] result = this.filter.match(autoConfigurationClasses, getAutoConfigurationMetadata());
		assertThat(result).containsExactly(true, false);
	}
	@Test
	void matchShouldRecordOutcome() {
		String[] autoConfigurationClasses = new String[] { 'test.match', 'test.nomatch' };
		this.filter.match(autoConfigurationClasses, getAutoConfigurationMetadata());
		ConditionEvaluationReport report = ConditionEvaluationReport.get(this.beanFactory);
		assertThat(report.getConditionAndOutcomesBySource()).hasSize(1).containsKey('test.nomatch');
	}
	private AutoConfigurationMetadata getAutoConfigurationMetadata() {
		AutoConfigurationMetadata metadata = mock(AutoConfigurationMetadata.class);
		given(metadata.wasProcessed('test.match')).willReturn(true);
		given(metadata.get('test.match', 'ConditionalOnClass')).willReturn('java.io.InputStream');
		given(metadata.wasProcessed('test.nomatch')).willReturn(true);
		given(metadata.get('test.nomatch', 'ConditionalOnClass')).willReturn('java.io.DoesNotExist');
		return metadata;
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
@SuppressWarnings('resource')
class ConditionalOnMissingBeanTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void testNameOnMissingBeanCondition() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnBeanNameConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean('bar');
				assertThat(context.getBean('foo')).isEqualTo('foo');
			});
	}
	@Test
	void testNameOnMissingBeanConditionReverseOrder() {
		this.contextRunner.withUserConfiguration(OnBeanNameConfiguration.class, FooConfiguration.class)
			.run((context) -> {
				// Ideally this would be doesNotHaveBean, but the ordering is a
				// problem
				assertThat(context).hasBean('bar');
				assertThat(context.getBean('foo')).isEqualTo('foo');
			});
	}
	@Test
	void testNameAndTypeOnMissingBeanCondition() {
		// Arguably this should be hasBean, but as things are implemented the conditions
		// specified in the different attributes of @ConditionalOnBean are combined with
		// logical OR (not AND) so if any of them match the condition is true.
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnBeanNameAndTypeConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void hierarchyConsidered() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class)
			.run((parent) -> new ApplicationContextRunner().withParent(parent)
				.withUserConfiguration(HierarchyConsidered.class)
				.run((context) -> assertThat(context.containsLocalBean('bar')).isFalse()));
	}
	@Test
	void hierarchyNotConsidered() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class)
			.run((parent) -> new ApplicationContextRunner().withParent(parent)
				.withUserConfiguration(HierarchyNotConsidered.class)
				.run((context) -> assertThat(context.containsLocalBean('bar')).isTrue()));
	}
	@Test
	void impliedOnBeanMethod() {
		this.contextRunner.withUserConfiguration(ExampleBeanConfiguration.class, ImpliedOnBeanMethod.class)
			.run((context) -> assertThat(context).hasSingleBean(ExampleBean.class));
	}
	@Test
	void testAnnotationOnMissingBeanCondition() {
		this.contextRunner.withUserConfiguration(FooConfiguration.class, OnAnnotationConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean('bar');
				assertThat(context.getBean('foo')).isEqualTo('foo');
			});
	}
	@Test
	void testAnnotationOnMissingBeanConditionWithEagerFactoryBean() {
		// Rigorous test for SPR-11069
		this.contextRunner
			.withUserConfiguration(FooConfiguration.class, OnAnnotationConfiguration.class,
					FactoryBeanXmlConfiguration.class, PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean('bar');
				assertThat(context).hasBean('example');
				assertThat(context.getBean('foo')).isEqualTo('foo');
			});
	}
	@Test // gh-42484
	void testAnnotationOnMissingBeanConditionOnMethodWhenNoAnnotatedBeans() {
		// There are no beans with @TestAnnotation but there is an UnrelatedExampleBean
		this.contextRunner
			.withUserConfiguration(UnrelatedExampleBeanConfiguration.class, OnAnnotationMethodConfiguration.class)
			.run((context) -> assertThat(context).hasBean('conditional'));
	}
	@Test
	void testOnMissingBeanConditionOutputShouldNotContainConditionalOnBeanClassInMessage() {
		this.contextRunner.withUserConfiguration(OnBeanNameConfiguration.class).run((context) -> {
			Collection<ConditionEvaluationReport.ConditionAndOutcomes> conditionAndOutcomes = ConditionEvaluationReport
				.get(context.getSourceApplicationContext().getBeanFactory())
				.getConditionAndOutcomesBySource()
				.values();
			String message = conditionAndOutcomes.iterator().next().iterator().next().getOutcome().getMessage();
			assertThat(message).doesNotContain('@ConditionalOnBean');
		});
	}
	@Test
	void testOnMissingBeanConditionWithFactoryBean() {
		this.contextRunner
			.withUserConfiguration(FactoryBeanConfiguration.class, ConditionalOnFactoryBean.class,
					PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ExampleBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithComponentScannedFactoryBean() {
		this.contextRunner
			.withUserConfiguration(ComponentScannedFactoryBeanBeanMethodConfiguration.class,
					ConditionalOnFactoryBean.class, PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ScanBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithComponentScannedFactoryBeanWithBeanMethodArguments() {
		this.contextRunner
			.withUserConfiguration(ComponentScannedFactoryBeanBeanMethodWithArgumentsConfiguration.class,
					ConditionalOnFactoryBean.class, PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ScanBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithFactoryBeanWithBeanMethodArguments() {
		this.contextRunner
			.withUserConfiguration(FactoryBeanWithBeanMethodArgumentsConfiguration.class,
					ConditionalOnFactoryBean.class, PropertyPlaceholderAutoConfiguration.class)
			.withPropertyValues('theValue=foo')
			.run((context) -> assertThat(context.getBean(ExampleBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithConcreteFactoryBean() {
		this.contextRunner
			.withUserConfiguration(ConcreteFactoryBeanConfiguration.class, ConditionalOnFactoryBean.class,
					PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ExampleBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithUnhelpfulFactoryBean() {
		// We could not tell that the FactoryBean would ultimately create an ExampleBean
		this.contextRunner
			.withUserConfiguration(UnhelpfulFactoryBeanConfiguration.class, ConditionalOnFactoryBean.class,
					PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context).getBeans(ExampleBean.class).hasSize(2));
	}
	@Test
	void testOnMissingBeanConditionWithRegisteredFactoryBean() {
		this.contextRunner
			.withUserConfiguration(RegisteredFactoryBeanConfiguration.class, ConditionalOnFactoryBean.class,
					PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ExampleBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithNonspecificFactoryBeanWithClassAttribute() {
		this.contextRunner
			.withUserConfiguration(NonspecificFactoryBeanClassAttributeConfiguration.class,
					ConditionalOnFactoryBean.class, PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ExampleBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithNonspecificFactoryBeanWithStringAttribute() {
		this.contextRunner
			.withUserConfiguration(NonspecificFactoryBeanStringAttributeConfiguration.class,
					ConditionalOnFactoryBean.class, PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ExampleBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithFactoryBeanInXml() {
		this.contextRunner
			.withUserConfiguration(FactoryBeanXmlConfiguration.class, ConditionalOnFactoryBean.class,
					PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> assertThat(context.getBean(ExampleBean.class)).hasToString('fromFactory'));
	}
	@Test
	void testOnMissingBeanConditionWithIgnoredSubclass() {
		this.contextRunner
			.withUserConfiguration(CustomExampleBeanConfiguration.class, ConditionalOnIgnoredSubclass.class,
					PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> {
				assertThat(context).getBeans(ExampleBean.class).hasSize(2);
				assertThat(context).getBeans(CustomExampleBean.class).hasSize(1);
			});
	}
	@Test
	void testOnMissingBeanConditionWithIgnoredSubclassByName() {
		this.contextRunner
			.withUserConfiguration(CustomExampleBeanConfiguration.class, ConditionalOnIgnoredSubclassByName.class,
					PropertyPlaceholderAutoConfiguration.class)
			.run((context) -> {
				assertThat(context).getBeans(ExampleBean.class).hasSize(2);
				assertThat(context).getBeans(CustomExampleBean.class).hasSize(1);
			});
	}
	@Test
	void grandparentIsConsideredWhenUsingAncestorsStrategy() {
		this.contextRunner.withUserConfiguration(ExampleBeanConfiguration.class)
			.run((grandparent) -> new ApplicationContextRunner().withParent(grandparent)
				.run((parent) -> new ApplicationContextRunner().withParent(parent)
					.withUserConfiguration(ExampleBeanConfiguration.class, OnBeanInAncestorsConfiguration.class)
					.run((context) -> assertThat(context).getBeans(ExampleBean.class).hasSize(1))));
	}
	@Test
	void currentContextIsIgnoredWhenUsingAncestorsStrategy() {
		this.contextRunner.run((parent) -> new ApplicationContextRunner().withParent(parent)
			.withUserConfiguration(ExampleBeanConfiguration.class, OnBeanInAncestorsConfiguration.class)
			.run((context) -> assertThat(context).getBeans(ExampleBean.class).hasSize(2)));
	}
	@Test
	void beanProducedByFactoryBeanIsConsideredWhenMatchingOnAnnotation() {
		this.contextRunner
			.withUserConfiguration(ConcreteFactoryBeanConfiguration.class,
					OnAnnotationWithFactoryBeanConfiguration.class)
			.run((context) -> {
				assertThat(context).doesNotHaveBean('bar');
				assertThat(context).hasSingleBean(ExampleBean.class);
			});
	}
	@Test
	void parameterizedContainerWhenValueIsOfMissingBeanMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithoutCustomConfig.class, ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('otherExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void parameterizedContainerWhenValueIsOfExistingBeanDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomConfig.class, ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('customExampleBean')));
	}
	@Test
	void parameterizedContainerWhenValueIsOfMissingBeanRegistrationMatches() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithoutCustomContainerConfig.class,
					ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context)
				.satisfies(exampleBeanRequirement('otherExampleBean', 'conditionalCustomExampleBean')));
	}
	@Test
	void parameterizedContainerWhenValueIsOfExistingBeanRegistrationDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomContainerConfig.class,
					ParameterizedConditionWithValueConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('customExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnTypeIsOfExistingBeanDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomConfig.class,
					ParameterizedConditionWithReturnTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('customExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnTypeIsOfExistingBeanRegistrationDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomContainerConfig.class,
					ParameterizedConditionWithReturnTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('customExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnRegistrationTypeIsOfExistingBeanDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomConfig.class,
					ParameterizedConditionWithReturnRegistrationTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('customExampleBean')));
	}
	@Test
	void parameterizedContainerWhenReturnRegistrationTypeIsOfExistingBeanRegistrationDoesNotMatch() {
		this.contextRunner
			.withUserConfiguration(ParameterizedWithCustomContainerConfig.class,
					ParameterizedConditionWithReturnRegistrationTypeConfig.class)
			.run((context) -> assertThat(context).satisfies(exampleBeanRequirement('customExampleBean')));
	}
	@Test
	void typeBasedMatchingIgnoresBeanThatIsNotAutowireCandidate() {
		this.contextRunner.withUserConfiguration(NotAutowireCandidateConfig.class, OnBeanTypeConfiguration.class)
			.run((context) -> assertThat(context).hasBean('bar'));
	}
	@Test
	void nameBasedMatchingConsidersBeanThatIsNotAutowireCandidate() {
		this.contextRunner.withUserConfiguration(NotAutowireCandidateConfig.class, OnBeanNameConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void annotationBasedMatchingIgnoresBeanThatIsNotAutowireCandidateBean() {
		this.contextRunner
			.withUserConfiguration(AnnotatedNotAutowireCandidateConfig.class, OnAnnotationConfiguration.class)
			.run((context) -> assertThat(context).hasBean('bar'));
	}
	@Test
	void typeBasedMatchingIgnoresBeanThatIsNotDefaultCandidate() {
		this.contextRunner.withUserConfiguration(NotDefaultCandidateConfig.class, OnBeanTypeConfiguration.class)
			.run((context) -> assertThat(context).hasBean('bar'));
	}
	@Test
	void nameBasedMatchingConsidersBeanThatIsNotDefaultCandidate() {
		this.contextRunner.withUserConfiguration(NotDefaultCandidateConfig.class, OnBeanNameConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('bar'));
	}
	@Test
	void annotationBasedMatchingIgnoresBeanThatIsNotDefaultCandidateBean() {
		this.contextRunner
			.withUserConfiguration(AnnotatedNotDefaultCandidateConfig.class, OnAnnotationConfiguration.class)
			.run((context) -> assertThat(context).hasBean('bar'));
	}
	private Consumer<ConfigurableApplicationContext> exampleBeanRequirement(String... names) {
		return (context) -> {
			String[] beans = context.getBeanNamesForType(ExampleBean.class);
			String[] containers = context.getBeanNamesForType(TestParameterizedContainer.class);
			assertThat(StringUtils.concatenateStringArrays(beans, containers)).containsOnly(names);
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class OnBeanInAncestorsConfiguration {
		@Bean
		@ConditionalOnMissingBean(search = SearchStrategy.ANCESTORS)
		ExampleBean exampleBean2() {
			return new ExampleBean('test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(name = 'foo')
	static class OnBeanNameConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(type = 'java.lang.String')
	static class OnBeanTypeConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(name = 'foo', value = Date.class)
	@ConditionalOnBean(name = 'foo', value = Date.class)
	static class OnBeanNameAndTypeConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FactoryBeanConfiguration {
		@Bean
		FactoryBean<ExampleBean> exampleBeanFactoryBean() {
			return new ExampleFactoryBean('foo');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ComponentScan(basePackages = 'org.springframework.boot.autoconfigure.condition.scan', useDefaultFilters = false,
			includeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE,
					classes = ScannedFactoryBeanConfiguration.class))
	static class ComponentScannedFactoryBeanBeanMethodConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ComponentScan(basePackages = 'org.springframework.boot.autoconfigure.condition.scan', useDefaultFilters = false,
			includeFilters = @Filter(type = FilterType.ASSIGNABLE_TYPE,
					classes = ScannedFactoryBeanWithBeanMethodArgumentsConfiguration.class))
	static class ComponentScannedFactoryBeanBeanMethodWithArgumentsConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class FactoryBeanWithBeanMethodArgumentsConfiguration {
		@Bean
		FactoryBean<ExampleBean> exampleBeanFactoryBean(@Value('${theValue}') String value) {
			return new ExampleFactoryBean(value);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConcreteFactoryBeanConfiguration {
		@Bean
		ExampleFactoryBean exampleBeanFactoryBean() {
			return new ExampleFactoryBean('foo');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UnhelpfulFactoryBeanConfiguration {
		@Bean
		@SuppressWarnings('rawtypes')
		FactoryBean exampleBeanFactoryBean() {
			return new ExampleFactoryBean('foo');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(NonspecificFactoryBeanClassAttributeRegistrar.class)
	static class NonspecificFactoryBeanClassAttributeConfiguration {
	}
	static class NonspecificFactoryBeanClassAttributeRegistrar implements ImportBeanDefinitionRegistrar {
		@Override
		public void registerBeanDefinitions(AnnotationMetadata meta, BeanDefinitionRegistry registry) {
			BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(NonspecificFactoryBean.class);
			builder.addConstructorArgValue('foo');
			builder.getBeanDefinition().setAttribute(FactoryBean.OBJECT_TYPE_ATTRIBUTE, ExampleBean.class);
			registry.registerBeanDefinition('exampleBeanFactoryBean', builder.getBeanDefinition());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(NonspecificFactoryBeanClassAttributeRegistrar.class)
	static class NonspecificFactoryBeanStringAttributeConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import(FactoryBeanRegistrar.class)
	static class RegisteredFactoryBeanConfiguration {
	}
	static class FactoryBeanRegistrar implements ImportBeanDefinitionRegistrar {
		@Override
		public void registerBeanDefinitions(AnnotationMetadata meta, BeanDefinitionRegistry registry) {
			BeanDefinitionBuilder builder = BeanDefinitionBuilder.rootBeanDefinition(ExampleFactoryBean.class);
			builder.addConstructorArgValue('foo');
			registry.registerBeanDefinition('exampleBeanFactoryBean', builder.getBeanDefinition());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportResource('org/springframework/boot/autoconfigure/condition/factorybean.xml')
	static class FactoryBeanXmlConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class ConditionalOnFactoryBean {
		@Bean
		@ConditionalOnMissingBean(ExampleBean.class)
		ExampleBean createExampleBean() {
			return new ExampleBean('direct');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConditionalOnIgnoredSubclass {
		@Bean
		@ConditionalOnMissingBean(value = ExampleBean.class, ignored = CustomExampleBean.class)
		ExampleBean exampleBean() {
			return new ExampleBean('test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConditionalOnIgnoredSubclassByName {
		@Bean
		@ConditionalOnMissingBean(value = ExampleBean.class,
				ignoredType = 'org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBeanTests$CustomExampleBean')
		ExampleBean exampleBean() {
			return new ExampleBean('test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomExampleBeanConfiguration {
		@Bean
		CustomExampleBean customExampleBean() {
			return new CustomExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(annotation = TestAnnotation.class)
	static class OnAnnotationConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class OnAnnotationMethodConfiguration {
		@Bean
		@ConditionalOnMissingBean(annotation = TestAnnotation.class)
		UnrelatedExampleBean conditional() {
			return new UnrelatedExampleBean('conditional');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(annotation = TestAnnotation.class)
	static class OnAnnotationWithFactoryBeanConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAnnotation
	static class FooConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NotAutowireCandidateConfig {
		@Bean(autowireCandidate = false)
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NotDefaultCandidateConfig {
		@Bean(defaultCandidate = false)
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(name = 'foo')
	static class HierarchyConsidered {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(name = 'foo', search = SearchStrategy.CURRENT)
	static class HierarchyNotConsidered {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ExampleBeanConfiguration {
		@Bean
		ExampleBean exampleBean() {
			return new ExampleBean('test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class UnrelatedExampleBeanConfiguration {
		@Bean
		UnrelatedExampleBean unrelatedExampleBean() {
			return new UnrelatedExampleBean('test');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ImpliedOnBeanMethod {
		@Bean
		@ConditionalOnMissingBean
		ExampleBean exampleBean2() {
			return new ExampleBean('test');
		}
	}
	static class ExampleFactoryBean implements FactoryBean<ExampleBean> {
		ExampleFactoryBean(String value) {
			Assert.state(!value.contains('$'), 'value should not contain "$"');
		}
		@Override
		public ExampleBean getObject() {
			return new ExampleBean('fromFactory');
		}
		@Override
		public Class<?> getObjectType() {
			return ExampleBean.class;
		}
		@Override
		public boolean isSingleton() {
			return false;
		}
	}
	static class NonspecificFactoryBean implements FactoryBean<Object> {
		NonspecificFactoryBean(String value) {
			Assert.state(!value.contains('$'), 'value should not contain "$"');
		}
		@Override
		public ExampleBean getObject() {
			return new ExampleBean('fromFactory');
		}
		@Override
		public Class<?> getObjectType() {
			return ExampleBean.class;
		}
		@Override
		public boolean isSingleton() {
			return false;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithCustomConfig {
		@Bean
		CustomExampleBean customExampleBean() {
			return new CustomExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithoutCustomConfig {
		@Bean
		OtherExampleBean otherExampleBean() {
			return new OtherExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithoutCustomContainerConfig {
		@Bean
		TestParameterizedContainer<OtherExampleBean> otherExampleBean() {
			return new TestParameterizedContainer<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedWithCustomContainerConfig {
		@Bean
		TestParameterizedContainer<CustomExampleBean> customExampleBean() {
			return new TestParameterizedContainer<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedConditionWithValueConfig {
		@Bean
		@ConditionalOnMissingBean(value = CustomExampleBean.class,
				parameterizedContainer = TestParameterizedContainer.class)
		CustomExampleBean conditionalCustomExampleBean() {
			return new CustomExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedConditionWithReturnTypeConfig {
		@Bean
		@ConditionalOnMissingBean(parameterizedContainer = TestParameterizedContainer.class)
		CustomExampleBean conditionalCustomExampleBean() {
			return new CustomExampleBean();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterizedConditionWithReturnRegistrationTypeConfig {
		@Bean
		@ConditionalOnMissingBean(parameterizedContainer = TestParameterizedContainer.class)
		TestParameterizedContainer<CustomExampleBean> conditionalCustomExampleBean() {
			return new TestParameterizedContainer<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnnotatedNotAutowireCandidateConfig {
		@Bean(autowireCandidate = false)
		ExampleBean exampleBean() {
			return new ExampleBean('value');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnnotatedNotDefaultCandidateConfig {
		@Bean(autowireCandidate = false)
		ExampleBean exampleBean() {
			return new ExampleBean('value');
		}
	}
	@TestAnnotation
	static class ExampleBean {
		private final String value;
		ExampleBean(String value) {
			this.value = value;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
	static class CustomExampleBean extends ExampleBean {
		CustomExampleBean() {
			super('custom subclass');
		}
	}
	static class OtherExampleBean extends ExampleBean {
		OtherExampleBean() {
			super('other subclass');
		}
	}
	static class UnrelatedExampleBean {
		private final String value;
		UnrelatedExampleBean(String value) {
			this.value = value;
		}
		@Override
		public String toString() {
			return this.value;
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@interface TestAnnotation {
	}
}
/*
package org.springframework.boot.autoconfigure.condition.scan;
/**
@Configuration(proxyBeanMethods = false)
public class ScannedFactoryBeanConfiguration {
	@Bean
	public FactoryBean<ScanBean> exampleBeanFactoryBean() {
		return new ScanFactoryBean('foo');
	}
}
/*
package org.springframework.boot.autoconfigure.condition.scan;
/**
@Configuration(proxyBeanMethods = false)
public class ScannedFactoryBeanWithBeanMethodArgumentsConfiguration {
	@Bean
	public Foo foo() {
		return new Foo();
	}
	@Bean
	public ScanFactoryBean exampleBeanFactoryBean(Foo foo) {
		return new ScanFactoryBean('foo');
	}
	static class Foo {
	}
}
/*
package org.springframework.boot.autoconfigure.condition.scan;
class ScanFactoryBean implements FactoryBean<ScanBean> {
	ScanFactoryBean(String value) {
		Assert.state(!value.contains('$'), 'value should not contain "$"');
	}
	@Override
	public ScanBean getObject() {
		return new ScanBean('fromFactory');
	}
	@Override
	public Class<?> getObjectType() {
		return ScanBean.class;
	}
	@Override
	public boolean isSingleton() {
		return false;
	}
}
/*
package org.springframework.boot.autoconfigure.condition.scan;
public class ScanBean {
	private final String value;
	public ScanBean(String value) {
		this.value = value;
	}
	@Override
	public String toString() {
		return this.value;
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class OnPropertyListConditionTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(TestConfig.class);
	@Test
	void propertyNotDefined() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean('foo'));
	}
	@Test
	void propertyDefinedAsCommaSeparated() {
		this.contextRunner.withPropertyValues('spring.test.my-list=value1')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Test
	void propertyDefinedAsList() {
		this.contextRunner.withPropertyValues('spring.test.my-list[0]=value1')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Test
	void propertyDefinedAsCommaSeparatedRelaxed() {
		this.contextRunner.withPropertyValues('spring.test.myList=value1')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Test
	void propertyDefinedAsListRelaxed() {
		this.contextRunner.withPropertyValues('spring.test.myList[0]=value1')
			.run((context) -> assertThat(context).hasBean('foo'));
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(TestPropertyListCondition.class)
	static class TestConfig {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	static class TestPropertyListCondition extends OnPropertyListCondition {
		TestPropertyListCondition() {
			super('spring.test.my-list', () -> ConditionMessage.forCondition('test'));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionEvaluationReportAutoConfigurationImportListenerTests {
	private ConditionEvaluationReportAutoConfigurationImportListener listener;
	private final ConfigurableListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	@BeforeEach
	void setup() {
		this.listener = new ConditionEvaluationReportAutoConfigurationImportListener();
		this.listener.setBeanFactory(this.beanFactory);
	}
	@Test
	void shouldBeInSpringFactories() {
		List<AutoConfigurationImportListener> factories = SpringFactoriesLoader
			.loadFactories(AutoConfigurationImportListener.class, null);
		assertThat(factories)
			.hasAtLeastOneElementOfType(ConditionEvaluationReportAutoConfigurationImportListener.class);
	}
	@Test
	void onAutoConfigurationImportEventShouldRecordCandidates() {
		List<String> candidateConfigurations = Collections.singletonList('Test');
		Set<String> exclusions = Collections.emptySet();
		AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, candidateConfigurations,
				exclusions);
		this.listener.onAutoConfigurationImportEvent(event);
		ConditionEvaluationReport report = ConditionEvaluationReport.get(this.beanFactory);
		assertThat(report.getUnconditionalClasses()).containsExactlyElementsOf(candidateConfigurations);
	}
	@Test
	void onAutoConfigurationImportEventShouldRecordExclusions() {
		List<String> candidateConfigurations = Collections.emptyList();
		Set<String> exclusions = Collections.singleton('Test');
		AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, candidateConfigurations,
				exclusions);
		this.listener.onAutoConfigurationImportEvent(event);
		ConditionEvaluationReport report = ConditionEvaluationReport.get(this.beanFactory);
		assertThat(report.getExclusions()).containsExactlyElementsOf(exclusions);
	}
	@Test
	void onAutoConfigurationImportEventShouldApplyExclusionsGlobally() {
		AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, Arrays.asList('First', 'Second'),
				Collections.emptySet());
		this.listener.onAutoConfigurationImportEvent(event);
		AutoConfigurationImportEvent anotherEvent = new AutoConfigurationImportEvent(this, Collections.emptyList(),
				Collections.singleton('First'));
		this.listener.onAutoConfigurationImportEvent(anotherEvent);
		ConditionEvaluationReport report = ConditionEvaluationReport.get(this.beanFactory);
		assertThat(report.getUnconditionalClasses()).containsExactly('Second');
		assertThat(report.getExclusions()).containsExactly('First');
	}
	@Test
	void onAutoConfigurationImportEventShouldApplyExclusionsGloballyWhenExclusionIsAlreadyApplied() {
		AutoConfigurationImportEvent excludeEvent = new AutoConfigurationImportEvent(this, Collections.emptyList(),
				Collections.singleton('First'));
		this.listener.onAutoConfigurationImportEvent(excludeEvent);
		AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, Arrays.asList('First', 'Second'),
				Collections.emptySet());
		this.listener.onAutoConfigurationImportEvent(event);
		ConditionEvaluationReport report = ConditionEvaluationReport.get(this.beanFactory);
		assertThat(report.getUnconditionalClasses()).containsExactly('Second');
		assertThat(report.getExclusions()).containsExactly('First');
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ResourceConditionTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void tearDown() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void defaultResourceAndNoExplicitKey() {
		load(DefaultLocationConfiguration.class);
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	@Test
	void unknownDefaultLocationAndNoExplicitKey() {
		load(UnknownDefaultLocationConfiguration.class);
		assertThat(this.context.containsBean('foo')).isFalse();
	}
	@Test
	void unknownDefaultLocationAndExplicitKeyToResource() {
		load(UnknownDefaultLocationConfiguration.class, 'spring.foo.test.config=logging.properties');
		assertThat(this.context.containsBean('foo')).isTrue();
	}
	private void load(Class<?> config, String... environment) {
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();
		TestPropertyValues.of(environment).applyTo(applicationContext);
		applicationContext.register(config);
		applicationContext.refresh();
		this.context = applicationContext;
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(DefaultLocationResourceCondition.class)
	static class DefaultLocationConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(UnknownDefaultLocationResourceCondition.class)
	static class UnknownDefaultLocationConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	static class DefaultLocationResourceCondition extends ResourceCondition {
		DefaultLocationResourceCondition() {
			super('test', 'spring.foo.test.config', 'classpath:/logging.properties');
		}
	}
	static class UnknownDefaultLocationResourceCondition extends ResourceCondition {
		UnknownDefaultLocationResourceCondition() {
			super('test', 'spring.foo.test.config', 'classpath:/this-file-does-not-exist.xml');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class AllNestedConditionsTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void neither() {
		this.contextRunner.withUserConfiguration(Config.class).run(match(false));
	}
	@Test
	void propertyA() {
		this.contextRunner.withUserConfiguration(Config.class).withPropertyValues('a:a').run(match(false));
	}
	@Test
	void propertyB() {
		this.contextRunner.withUserConfiguration(Config.class).withPropertyValues('b:b').run(match(false));
	}
	@Test
	void both() {
		this.contextRunner.withUserConfiguration(Config.class).withPropertyValues('a:a', 'b:b').run(match(true));
	}
	private ContextConsumer<AssertableApplicationContext> match(boolean expected) {
		return (context) -> {
			if (expected) {
				assertThat(context).hasBean('myBean');
			}
			else {
				assertThat(context).doesNotHaveBean('myBean');
			}
		};
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(OnPropertyAAndBCondition.class)
	static class Config {
		@Bean
		String myBean() {
			return 'myBean';
		}
	}
	static class OnPropertyAAndBCondition extends AllNestedConditions {
		OnPropertyAAndBCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty('a')
		static class HasPropertyA {
		}
		@ConditionalOnProperty('b')
		static class HasPropertyB {
		}
		@Conditional(NonSpringBootCondition.class)
		static class SubclassC {
		}
	}
	static class NonSpringBootCondition implements Condition {
		@Override
		public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
			return true;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
public class TestParameterizedContainer<T> {
}
/*
package org.springframework.boot.autoconfigure.condition;
/**
class ConditionalOnExpressionTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void expressionIsTrue() {
		this.contextRunner.withUserConfiguration(BasicConfiguration.class)
			.run((context) -> assertThat(context.getBean('foo')).isEqualTo('foo'));
	}
	@Test
	void expressionEvaluatesToTrueRegistersBean() {
		this.contextRunner.withUserConfiguration(MissingConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('foo'));
	}
	@Test
	void expressionEvaluatesToFalseDoesNotRegisterBean() {
		this.contextRunner.withUserConfiguration(NullConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean('foo'));
	}
	@Test
	void expressionEvaluationWithNoBeanFactoryDoesNotMatch() {
		OnExpressionCondition condition = new OnExpressionCondition();
		MockEnvironment environment = new MockEnvironment();
		ConditionContext conditionContext = mock(ConditionContext.class);
		given(conditionContext.getEnvironment()).willReturn(environment);
		ConditionOutcome outcome = condition.getMatchOutcome(conditionContext, mockMetadata('invalid-spel'));
		assertThat(outcome.isMatch()).isFalse();
		assertThat(outcome.getMessage()).contains('invalid-spel').contains('no BeanFactory available');
	}
	private AnnotatedTypeMetadata mockMetadata(String value) {
		AnnotatedTypeMetadata metadata = mock(AnnotatedTypeMetadata.class);
		given(metadata.getAnnotationAttributes(ConditionalOnExpression.class.getName()))
			.willReturn(Collections.singletonMap('value', value));
		return metadata;
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnExpression('false')
	static class MissingConfiguration {
		@Bean
		String bar() {
			return 'bar';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnExpression('true')
	static class BasicConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnExpression('true ? null : false')
	static class NullConfiguration {
		@Bean
		String foo() {
			return 'foo';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.hateoas;
/**
class HypermediaAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withUserConfiguration(BaseConfig.class);
	@Test
	void autoConfigurationWhenSpringMvcNotOnClasspathShouldBackOff() {
		this.contextRunner.withClassLoader(new FilteredClassLoader(RequestMappingHandlerAdapter.class))
			.run((context) -> assertThat(context.getBeansOfType(HypermediaConfiguration.class)).isEmpty());
	}
	@Test
	void linkDiscoverersCreated() {
		this.contextRunner.run((context) -> {
			LinkDiscoverers discoverers = context.getBean(LinkDiscoverers.class);
			assertThat(discoverers).isNotNull();
			Optional<LinkDiscoverer> discoverer = discoverers.getLinkDiscovererFor(MediaTypes.HAL_JSON);
			assertThat(discoverer).containsInstanceOf(HalLinkDiscoverer.class);
		});
	}
	@Test
	void entityLinksCreated() {
		this.contextRunner.run((context) -> {
			EntityLinks discoverers = context.getBean(EntityLinks.class);
			assertThat(discoverers).isNotNull();
		});
	}
	@Test
	void doesBackOffIfEnableHypermediaSupportIsDeclaredManually() {
		this.contextRunner.withUserConfiguration(EnableHypermediaSupportConfig.class)
			.withPropertyValues('spring.jackson.serialization.INDENT_OUTPUT:true')
			.run((context) -> assertThat(context.getBeansOfType(HypermediaConfiguration.class)).isEmpty());
	}
	@Test
	void whenUsingTheDefaultConfigurationThenMappingJacksonConverterCanWriteHateoasTypeAsApplicationJson() {
		this.contextRunner.run((context) -> {
			RequestMappingHandlerAdapter handlerAdapter = context.getBean(RequestMappingHandlerAdapter.class);
			Optional<HttpMessageConverter<?>> mappingJacksonConverter = handlerAdapter.getMessageConverters()
				.stream()
				.filter(MappingJackson2HttpMessageConverter.class::isInstance)
				.findFirst();
			assertThat(mappingJacksonConverter).hasValueSatisfying(
					(converter) -> assertThat(converter.canWrite(RepresentationModel.class, MediaType.APPLICATION_JSON))
						.isTrue());
		});
	}
	@Test
	void whenHalIsNotTheDefaultJsonMediaTypeThenMappingJacksonConverterCannotWriteHateoasTypeAsApplicationJson() {
		this.contextRunner.withPropertyValues('spring.hateoas.use-hal-as-default-json-media-type:false')
			.run((context) -> {
				RequestMappingHandlerAdapter handlerAdapter = context.getBean(RequestMappingHandlerAdapter.class);
				Optional<HttpMessageConverter<?>> mappingJacksonConverter = handlerAdapter.getMessageConverters()
					.stream()
					.filter(MappingJackson2HttpMessageConverter.class::isInstance)
					.findFirst();
				assertThat(mappingJacksonConverter).hasValueSatisfying((converter) -> assertThat(
						converter.canWrite(RepresentationModel.class, MediaType.APPLICATION_JSON))
					.isFalse());
			});
	}
	@ImportAutoConfiguration({ HttpMessageConvertersAutoConfiguration.class, WebMvcAutoConfiguration.class,
			JacksonAutoConfiguration.class, HypermediaAutoConfiguration.class })
	static class BaseConfig {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableHypermediaSupport(type = HypermediaType.HAL)
	static class EnableHypermediaSupportConfig {
	}
}
/*
package org.springframework.boot.autoconfigure.hateoas;
/**
@ClassPathExclusions('jackson-*.jar')
class HypermediaAutoConfigurationWithoutJacksonTests {
	private AnnotationConfigServletWebApplicationContext context;
	@Test
	void jacksonRelatedConfigurationBacksOff() {
		this.context = new AnnotationConfigServletWebApplicationContext();
		this.context.register(BaseConfig.class);
		this.context.setServletContext(new MockServletContext());
		this.context.refresh();
	}
	@ImportAutoConfiguration({ HttpMessageConvertersAutoConfiguration.class, WebMvcAutoConfiguration.class,
			HypermediaAutoConfiguration.class })
	static class BaseConfig {
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class MultipleConnectionPoolConfigurationsFailureAnalyzerTests {
	private final MultipleConnectionPoolConfigurationsFailureAnalyzer failureAnalyzer = new MultipleConnectionPoolConfigurationsFailureAnalyzer();
	@Test
	void analyzeWhenDifferentFailureShouldReturnNull() {
		assertThat(this.failureAnalyzer.analyze(new Exception())).isNull();
	}
	@Test
	void analyzeWhenMultipleConnectionPoolConfigurationsShouldReturnAnalysis() {
		assertThat(this.failureAnalyzer.analyze(new MultipleConnectionPoolConfigurationsException())).isNotNull();
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class MissingR2dbcPoolDependencyFailureAnalyzerTests {
	private final MissingR2dbcPoolDependencyFailureAnalyzer failureAnalyzer = new MissingR2dbcPoolDependencyFailureAnalyzer();
	@Test
	void analyzeWhenDifferentFailureShouldReturnNull() {
		assertThat(this.failureAnalyzer.analyze(new Exception())).isNull();
	}
	@Test
	void analyzeWhenMissingR2dbcPoolDependencyShouldReturnAnalysis() {
		assertThat(this.failureAnalyzer.analyze(new MissingR2dbcPoolDependencyException())).isNotNull();
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class R2dbcTransactionManagerAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(R2dbcTransactionManagerAutoConfiguration.class, TransactionAutoConfiguration.class));
	@Test
	void noTransactionManager() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(ReactiveTransactionManager.class));
	}
	@Test
	void singleTransactionManager() {
		this.contextRunner.withUserConfiguration(SingleConnectionFactoryConfiguration.class)
			.run((context) -> assertThat(context).hasSingleBean(TransactionalOperator.class)
				.hasSingleBean(ReactiveTransactionManager.class));
	}
	@Test
	void transactionManagerEnabled() {
		this.contextRunner.withUserConfiguration(SingleConnectionFactoryConfiguration.class, BaseConfiguration.class)
			.run((context) -> {
				TransactionalService bean = context.getBean(TransactionalService.class);
				bean.isTransactionActive()
					.as(StepVerifier::create)
					.expectNext(true)
					.expectComplete()
					.verify(Duration.ofSeconds(30));
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class SingleConnectionFactoryConfiguration {
		@Bean
		ConnectionFactory connectionFactory() {
			ConnectionFactory connectionFactory = mock(ConnectionFactory.class);
			Connection connection = mock(Connection.class);
			given(connectionFactory.create()).willAnswer((invocation) -> Mono.just(connection));
			given(connection.beginTransaction(any(TransactionDefinition.class))).willReturn(Mono.empty());
			given(connection.commitTransaction()).willReturn(Mono.empty());
			given(connection.close()).willReturn(Mono.empty());
			return connectionFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableTransactionManagement
	static class BaseConfiguration {
		@Bean
		TransactionalService transactionalService() {
			return new TransactionalServiceImpl();
		}
	}
	interface TransactionalService {
		@Transactional
		Mono<Boolean> isTransactionActive();
	}
	static class TransactionalServiceImpl implements TransactionalService {
		@Override
		public Mono<Boolean> isTransactionActive() {
			return TransactionSynchronizationManager.forCurrentTransaction()
				.map(TransactionSynchronizationManager::isActualTransactionActive);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
public class SimpleBindMarkerFactoryProvider implements BindMarkerFactoryProvider {
	@Override
	public BindMarkersFactory getBindMarkers(ConnectionFactory connectionFactory) {
		if (unwrapIfNecessary(connectionFactory) instanceof SimpleTestConnectionFactory) {
			return BindMarkersFactory.anonymous('?');
		}
		return null;
	}
	@SuppressWarnings('unchecked')
	private ConnectionFactory unwrapIfNecessary(ConnectionFactory connectionFactory) {
		if (connectionFactory instanceof Wrapped) {
			return unwrapIfNecessary(((Wrapped<ConnectionFactory>) connectionFactory).unwrap());
		}
		return connectionFactory;
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class NoConnectionFactoryBeanFailureAnalyzerTests {
	@Test
	void analyzeWhenNotNoSuchBeanDefinitionExceptionShouldReturnNull() {
		assertThat(new NoConnectionFactoryBeanFailureAnalyzer().analyze(new Exception())).isNull();
	}
	@Test
	void analyzeWhenNoSuchBeanDefinitionExceptionForDifferentTypeShouldReturnNull() {
		assertThat(
				new NoConnectionFactoryBeanFailureAnalyzer().analyze(new NoSuchBeanDefinitionException(String.class)))
			.isNull();
	}
	@Test
	void analyzeWhenNoSuchBeanDefinitionExceptionButProviderIsAvailableShouldReturnNull() {
		assertThat(new NoConnectionFactoryBeanFailureAnalyzer()
			.analyze(new NoSuchBeanDefinitionException(ConnectionFactory.class))).isNull();
	}
	@Test
	void analyzeWhenNoSuchBeanDefinitionExceptionAndNoProviderShouldAnalyze() {
		assertThat(new NoConnectionFactoryBeanFailureAnalyzer(
				new FilteredClassLoader(('META-INF/services/' + ConnectionFactoryProvider.class.getName())::equals))
			.analyze(new NoSuchBeanDefinitionException(ConnectionFactory.class))).isNotNull();
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
@ClassPathExclusions('r2dbc-pool-*.jar')
class R2dbcAutoConfigurationWithoutConnectionPoolTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class));
	@Test
	void configureWithoutR2dbcPoolCreateGenericConnectionFactory() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName()
					+ '?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class);
				assertThat(context.getBean(ConnectionFactory.class))
					.asInstanceOf(type(OptionsCapableConnectionFactory.class))
					.extracting(Wrapped<ConnectionFactory>::unwrap)
					.isExactlyInstanceOf(H2ConnectionFactory.class);
			});
	}
	@Test
	void configureWithoutR2dbcPoolAndPoolEnabledShouldFail() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.pool.enabled=true',
					'spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName()
							+ '?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
			.run((context) -> assertThat(context).getFailure()
				.rootCause()
				.isInstanceOf(MissingR2dbcPoolDependencyException.class));
	}
	@Test
	void configureWithoutR2dbcPoolAndPoolUrlShouldFail() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.url:r2dbc:pool:h2:mem:///' + randomDatabaseName()
					+ '?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
			.run((context) -> assertThat(context).getFailure()
				.rootCause()
				.isInstanceOf(MissingR2dbcPoolDependencyException.class));
	}
	private <T> InstanceOfAssertFactory<T, ObjectAssert<T>> type(Class<T> type) {
		return InstanceOfAssertFactories.type(type);
	}
	private String randomDatabaseName() {
		return 'testdb-' + UUID.randomUUID();
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class R2dbcAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(R2dbcAutoConfiguration.class));
	@Test
	void configureWithUrlCreateConnectionPoolByDefault() {
		this.contextRunner.withPropertyValues('spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName())
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class).hasSingleBean(ConnectionPool.class);
				assertThat(context.getBean(ConnectionPool.class)).extracting(ConnectionPool::unwrap)
					.satisfies((connectionFactory) -> assertThat(connectionFactory)
						.asInstanceOf(type(OptionsCapableConnectionFactory.class))
						.extracting(Wrapped::unwrap)
						.isExactlyInstanceOf(H2ConnectionFactory.class));
			});
	}
	@Test
	void configureWithUrlAndPoolPropertiesApplyProperties() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName(),
					'spring.r2dbc.pool.max-size=15', 'spring.r2dbc.pool.max-acquire-time=3m',
					'spring.r2dbc.pool.min-idle=1', 'spring.r2dbc.pool.max-validation-time=1s',
					'spring.r2dbc.pool.initial-size=0')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(ConnectionPool.class)
					.hasSingleBean(R2dbcProperties.class);
				ConnectionPool connectionPool = context.getBean(ConnectionPool.class);
				connectionPool.warmup().block();
				try {
					PoolMetrics poolMetrics = connectionPool.getMetrics().get();
					assertThat(poolMetrics.idleSize()).isEqualTo(1);
					assertThat(poolMetrics.getMaxAllocatedSize()).isEqualTo(15);
					assertThat(connectionPool).hasFieldOrPropertyWithValue('maxAcquireTime', Duration.ofMinutes(3));
					assertThat(connectionPool).hasFieldOrPropertyWithValue('maxValidationTime', Duration.ofSeconds(1));
				}
				finally {
					connectionPool.close().block();
				}
			});
	}
	@Test
	void configureWithUrlAndDefaultDoNotOverrideDefaultTimeouts() {
		this.contextRunner.withPropertyValues('spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName())
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class)
					.hasSingleBean(ConnectionPool.class)
					.hasSingleBean(R2dbcProperties.class);
				ConnectionPool connectionPool = context.getBean(ConnectionPool.class);
				assertThat(connectionPool).hasFieldOrPropertyWithValue('maxAcquireTime', Duration.ofMillis(-1));
			});
	}
	@Test
	void configureWithUrlPoolAndPoolPropertiesFails() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.url:r2dbc:pool:h2:mem:///' + randomDatabaseName() + '?maxSize=12',
					'spring.r2dbc.pool.max-size=15')
			.run((context) -> assertThat(context).getFailure()
				.rootCause()
				.isInstanceOf(MultipleConnectionPoolConfigurationsException.class));
	}
	@Test
	void configureWithUrlPoolAndPropertyBasedPoolingDisabledFails() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.url:r2dbc:pool:h2:mem:///' + randomDatabaseName() + '?maxSize=12',
					'spring.r2dbc.pool.enabled=false')
			.run((context) -> assertThat(context).getFailure()
				.rootCause()
				.isInstanceOf(MultipleConnectionPoolConfigurationsException.class));
	}
	@Test
	void configureWithUrlPoolAndNoPoolPropertiesCreatesPool() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.url:r2dbc:pool:h2:mem:///' + randomDatabaseName() + '?maxSize=12')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class).hasSingleBean(ConnectionPool.class);
				ConnectionPool connectionPool = context.getBean(ConnectionPool.class);
				assertThat(connectionPool.getMetrics().get().getMaxAllocatedSize()).isEqualTo(12);
			});
	}
	@Test
	void configureWithPoolEnabledCreateConnectionPool() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.pool.enabled=true',
					'spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName()
							+ '?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
			.run((context) -> assertThat(context).hasSingleBean(ConnectionFactory.class)
				.hasSingleBean(ConnectionPool.class));
	}
	@Test
	void configureWithPoolDisabledCreateGenericConnectionFactory() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.pool.enabled=false',
					'spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName()
							+ '?options=DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class).doesNotHaveBean(ConnectionPool.class);
				assertThat(context.getBean(ConnectionFactory.class))
					.asInstanceOf(type(OptionsCapableConnectionFactory.class))
					.extracting(Wrapped<ConnectionFactory>::unwrap)
					.isExactlyInstanceOf(H2ConnectionFactory.class);
			});
	}
	@Test
	void configureWithoutPoolInvokeOptionCustomizer() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.pool.enabled=false', 'spring.r2dbc.url:r2dbc:simple://host/database')
			.withUserConfiguration(CustomizerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class).doesNotHaveBean(ConnectionPool.class);
				ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
				assertThat(connectionFactory).asInstanceOf(type(OptionsCapableConnectionFactory.class))
					.extracting(OptionsCapableConnectionFactory::getOptions)
					.satisfies((options) -> assertThat(options.getRequiredValue(Option.valueOf('customized')))
						.isEqualTo(Boolean.TRUE));
			});
	}
	@Test
	void configureWithPoolInvokeOptionCustomizer() {
		this.contextRunner.withPropertyValues('spring.r2dbc.url:r2dbc:simple://host/database')
			.withUserConfiguration(CustomizerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class).hasSingleBean(ConnectionPool.class);
				ConnectionFactory pool = context.getBean(ConnectionFactory.class);
				ConnectionFactory connectionFactory = ((ConnectionPool) pool).unwrap();
				assertThat(connectionFactory).asInstanceOf(type(OptionsCapableConnectionFactory.class))
					.extracting(OptionsCapableConnectionFactory::getOptions)
					.satisfies((options) -> assertThat(options.getRequiredValue(Option.valueOf('customized')))
						.isEqualTo(Boolean.TRUE));
			});
	}
	@Test
	void configureWithInvalidUrlThrowsAppropriateException() {
		this.contextRunner.withPropertyValues('spring.r2dbc.url:r2dbc:not-going-to-work')
			.run((context) -> assertThat(context).getFailure().isInstanceOf(BeanCreationException.class));
	}
	@Test
	void configureWithoutSpringJdbcCreateConnectionFactory() {
		this.contextRunner.withPropertyValues('spring.r2dbc.pool.enabled=false', 'spring.r2dbc.url:r2dbc:simple://foo')
			.withClassLoader(new FilteredClassLoader('org.springframework.jdbc'))
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class);
				assertThat(context.getBean(ConnectionFactory.class))
					.asInstanceOf(type(OptionsCapableConnectionFactory.class))
					.extracting(Wrapped<ConnectionFactory>::unwrap)
					.isExactlyInstanceOf(SimpleTestConnectionFactory.class);
			});
	}
	@Test
	void configureWithoutPoolShouldApplyAdditionalProperties() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.pool.enabled=false', 'spring.r2dbc.url:r2dbc:simple://foo',
					'spring.r2dbc.properties.test=value', 'spring.r2dbc.properties.another=2')
			.run((context) -> {
				ConnectionFactory connectionFactory = context.getBean(ConnectionFactory.class);
				assertThat(connectionFactory).asInstanceOf(type(OptionsCapableConnectionFactory.class))
					.extracting(OptionsCapableConnectionFactory::getOptions)
					.satisfies((options) -> {
						assertThat(options.getRequiredValue(Option.<String>valueOf('test'))).isEqualTo('value');
						assertThat(options.getRequiredValue(Option.<String>valueOf('another'))).isEqualTo('2');
					});
			});
	}
	@Test
	void configureWithPoolShouldApplyAdditionalProperties() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.url:r2dbc:simple://foo', 'spring.r2dbc.properties.test=value',
					'spring.r2dbc.properties.another=2')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class).hasSingleBean(ConnectionPool.class);
				ConnectionFactory connectionFactory = context.getBean(ConnectionPool.class).unwrap();
				assertThat(connectionFactory).asInstanceOf(type(OptionsCapableConnectionFactory.class))
					.extracting(OptionsCapableConnectionFactory::getOptions)
					.satisfies((options) -> {
						assertThat(options.getRequiredValue(Option.<String>valueOf('test'))).isEqualTo('value');
						assertThat(options.getRequiredValue(Option.<String>valueOf('another'))).isEqualTo('2');
					});
			});
	}
	@Test
	void configureWithoutUrlShouldCreateEmbeddedConnectionPoolByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ConnectionFactory.class)
			.hasSingleBean(ConnectionPool.class));
	}
	@Test
	void configureWithoutUrlAndPollPoolDisabledCreateGenericConnectionFactory() {
		this.contextRunner.withPropertyValues('spring.r2dbc.pool.enabled=false').run((context) -> {
			assertThat(context).hasSingleBean(ConnectionFactory.class).doesNotHaveBean(ConnectionPool.class);
			assertThat(context.getBean(ConnectionFactory.class))
				.asInstanceOf(type(OptionsCapableConnectionFactory.class))
				.extracting(Wrapped<ConnectionFactory>::unwrap)
				.isExactlyInstanceOf(H2ConnectionFactory.class);
		});
	}
	@Test
	void configureWithoutUrlAndSprigJdbcCreateEmbeddedConnectionFactory() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.springframework.jdbc'))
			.run((context) -> assertThat(context).hasSingleBean(ConnectionFactory.class)
				.hasSingleBean(ConnectionPool.class));
	}
	@Test
	void configureWithoutUrlAndEmbeddedCandidateFails() {
		this.contextRunner.withClassLoader(new DisableEmbeddedDatabaseClassLoader()).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context).getFailure()
				.isInstanceOf(BeanCreationException.class)
				.hasMessageContaining('Failed to determine a suitable R2DBC Connection URL');
		});
	}
	@Test
	void configureWithoutUrlAndNoConnectionFactoryProviderBacksOff() {
		this.contextRunner
			.withClassLoader(
					new FilteredClassLoader(('META-INF/services/' + ConnectionFactoryProvider.class.getName())::equals))
			.run((context) -> assertThat(context).doesNotHaveBean(R2dbcAutoConfiguration.class));
	}
	@Test
	void configureWithDataSourceAutoConfigurationDoesNotCreateDataSource() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(ConnectionFactory.class)
				.doesNotHaveBean(DataSource.class));
	}
	@Test
	void databaseClientIsConfigured() {
		this.contextRunner.withPropertyValues('spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName())
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class).hasSingleBean(DatabaseClient.class);
				assertThat(context.getBean(DatabaseClient.class).getConnectionFactory())
					.isSameAs(context.getBean(ConnectionFactory.class));
			});
	}
	@Test
	void databaseClientBacksOffIfSpringR2dbcIsNotAvailable() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('org.springframework.r2dbc'))
			.withPropertyValues('spring.r2dbc.url:r2dbc:h2:mem:///' + randomDatabaseName())
			.run((context) -> assertThat(context).hasSingleBean(ConnectionFactory.class)
				.doesNotHaveBean(DatabaseClient.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsIfAvailable() {
		this.contextRunner.withPropertyValues('spring.r2dbc.pool.enabled=false')
			.withUserConfiguration(ConnectionDetailsConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class);
				OptionsCapableConnectionFactory connectionFactory = context
					.getBean(OptionsCapableConnectionFactory.class);
				ConnectionFactoryOptions options = connectionFactory.getOptions();
				assertThat(options.getValue(ConnectionFactoryOptions.DRIVER)).isEqualTo('postgresql');
				assertThat(options.getValue(ConnectionFactoryOptions.HOST)).isEqualTo('postgres.example.com');
				assertThat(options.getValue(ConnectionFactoryOptions.PORT)).isEqualTo(12345);
				assertThat(options.getValue(ConnectionFactoryOptions.DATABASE)).isEqualTo('database-1');
				assertThat(options.getValue(ConnectionFactoryOptions.USER)).isEqualTo('user-1');
				assertThat(options.getValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('password-1');
			});
	}
	@Test
	void configureWithUsernamePasswordAndUrlWithoutUserInfoUsesUsernameAndPassword() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.pool.enabled=false',
					'spring.r2dbc.url:r2dbc:postgresql://postgres.example.com:4321/db', 'spring.r2dbc.username=alice',
					'spring.r2dbc.password=secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class);
				OptionsCapableConnectionFactory connectionFactory = context
					.getBean(OptionsCapableConnectionFactory.class);
				ConnectionFactoryOptions options = connectionFactory.getOptions();
				assertThat(options.getValue(ConnectionFactoryOptions.DRIVER)).isEqualTo('postgresql');
				assertThat(options.getValue(ConnectionFactoryOptions.HOST)).isEqualTo('postgres.example.com');
				assertThat(options.getValue(ConnectionFactoryOptions.PORT)).isEqualTo(4321);
				assertThat(options.getValue(ConnectionFactoryOptions.DATABASE)).isEqualTo('db');
				assertThat(options.getValue(ConnectionFactoryOptions.USER)).isEqualTo('alice');
				assertThat(options.getValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('secret');
			});
	}
	@Test
	void configureWithUsernamePasswordAndUrlWithUserInfoUsesUserInfo() {
		this.contextRunner
			.withPropertyValues('spring.r2dbc.pool.enabled=false',
					'spring.r2dbc.url:r2dbc:postgresql://bob:password@postgres.example.com:9876/db',
					'spring.r2dbc.username=alice', 'spring.r2dbc.password=secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(ConnectionFactory.class);
				OptionsCapableConnectionFactory connectionFactory = context
					.getBean(OptionsCapableConnectionFactory.class);
				ConnectionFactoryOptions options = connectionFactory.getOptions();
				assertThat(options.getValue(ConnectionFactoryOptions.DRIVER)).isEqualTo('postgresql');
				assertThat(options.getValue(ConnectionFactoryOptions.HOST)).isEqualTo('postgres.example.com');
				assertThat(options.getValue(ConnectionFactoryOptions.PORT)).isEqualTo(9876);
				assertThat(options.getValue(ConnectionFactoryOptions.DATABASE)).isEqualTo('db');
				assertThat(options.getValue(ConnectionFactoryOptions.USER)).isEqualTo('bob');
				assertThat(options.getValue(ConnectionFactoryOptions.PASSWORD)).isEqualTo('password');
			});
	}
	private <T> InstanceOfAssertFactory<T, ObjectAssert<T>> type(Class<T> type) {
		return InstanceOfAssertFactories.type(type);
	}
	private String randomDatabaseName() {
		return 'testdb-' + UUID.randomUUID();
	}
	private static class DisableEmbeddedDatabaseClassLoader extends URLClassLoader {
		DisableEmbeddedDatabaseClassLoader() {
			super(new URL[0], DisableEmbeddedDatabaseClassLoader.class.getClassLoader());
		}
		@Override
		protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
			for (EmbeddedDatabaseConnection candidate : EmbeddedDatabaseConnection.values()) {
				if (name.equals(candidate.getDriverClassName())) {
					throw new ClassNotFoundException();
				}
			}
			return super.loadClass(name, resolve);
		}
	}
	@Configuration(proxyBeanMethods = false)
	private static final class CustomizerConfiguration {
		@Bean
		ConnectionFactoryOptionsBuilderCustomizer customizer() {
			return (builder) -> builder.option(Option.valueOf('customized'), true);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		R2dbcConnectionDetails r2dbcConnectionDetails() {
			return new R2dbcConnectionDetails() {
				@Override
				public ConnectionFactoryOptions getConnectionFactoryOptions() {
					return ConnectionFactoryOptions
						.parse('r2dbc:postgresql://user-1:password-1@postgres.example.com:12345/database-1');
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class ConnectionFactoryBeanCreationFailureAnalyzerTests {
	private final MockEnvironment environment = new MockEnvironment();
	@Test
	void failureAnalysisIsPerformed() {
		FailureAnalysis failureAnalysis = performAnalysis(TestConfiguration.class);
		assertThat(failureAnalysis.getDescription()).contains('"url" attribute is not specified',
				'no embedded database could be configured');
		assertThat(failureAnalysis.getAction()).contains(
				'If you want an embedded database (H2), please put it on the classpath',
				'If you have database settings to be loaded from a particular profile you may need to activate it',
				'(no profiles are currently active)');
	}
	@Test
	void failureAnalysisIsPerformedWithActiveProfiles() {
		this.environment.setActiveProfiles('first', 'second');
		FailureAnalysis failureAnalysis = performAnalysis(TestConfiguration.class);
		assertThat(failureAnalysis.getAction()).contains('(the profiles first,second are currently active)');
	}
	private FailureAnalysis performAnalysis(Class<?> configuration) {
		BeanCreationException failure = createFailure(configuration);
		assertThat(failure).isNotNull();
		ConnectionFactoryBeanCreationFailureAnalyzer failureAnalyzer = new ConnectionFactoryBeanCreationFailureAnalyzer(
				this.environment);
		return failureAnalyzer.analyze(failure);
	}
	private BeanCreationException createFailure(Class<?> configuration) {
		try {
			AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
			context.setClassLoader(new FilteredClassLoader('io.r2dbc.h2', 'io.r2dbc.pool'));
			context.setEnvironment(this.environment);
			context.register(configuration);
			context.refresh();
			context.close();
			return null;
		}
		catch (BeanCreationException ex) {
			return ex;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(R2dbcAutoConfiguration.class)
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
class R2dbcProxyAutoConfigurationTests {
	private final ApplicationContextRunner runner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(R2dbcProxyAutoConfiguration.class));
	@Test
	void shouldSupplyConnectionFactoryDecorator() {
		this.runner.run((context) -> assertThat(context).hasSingleBean(ConnectionFactoryDecorator.class));
	}
	@Test
	void shouldNotSupplyBeansIfR2dbcSpiIsNotOnClasspath() {
		this.runner.withClassLoader(new FilteredClassLoader('io.r2dbc.spi'))
			.run((context) -> assertThat(context).doesNotHaveBean(ConnectionFactoryDecorator.class));
	}
	@Test
	void shouldNotSupplyBeansIfR2dbcProxyIsNotOnClasspath() {
		this.runner.withClassLoader(new FilteredClassLoader('io.r2dbc.proxy'))
			.run((context) -> assertThat(context).doesNotHaveBean(ConnectionFactoryDecorator.class));
	}
	@Test
	void shouldApplyCustomizers() {
		this.runner.withUserConfiguration(ProxyConnectionFactoryCustomizerConfig.class).run((context) -> {
			ConnectionFactoryDecorator decorator = context.getBean(ConnectionFactoryDecorator.class);
			ConnectionFactory connectionFactory = ConnectionFactoryBuilder
				.withUrl('r2dbc:h2:mem:///' + UUID.randomUUID())
				.build();
			decorator.decorate(connectionFactory);
			assertThat(context.getBean(ProxyConnectionFactoryCustomizerConfig.class).called).containsExactly('first',
					'second');
		});
	}
	@Configuration(proxyBeanMethods = false)
	private static final class ProxyConnectionFactoryCustomizerConfig {
		private final List<String> called = new ArrayList<>();
		@Bean
		@Order(1)
		ProxyConnectionFactoryCustomizer first() {
			return (builder) -> this.called.add('first');
		}
		@Bean
		@Order(2)
		ProxyConnectionFactoryCustomizer second() {
			return (builder) -> this.called.add('second');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.r2dbc;
/**
public class SimpleConnectionFactoryProvider implements ConnectionFactoryProvider {
	@Override
	public ConnectionFactory create(ConnectionFactoryOptions connectionFactoryOptions) {
		return new SimpleTestConnectionFactory();
	}
	@Override
	public boolean supports(ConnectionFactoryOptions connectionFactoryOptions) {
		return connectionFactoryOptions.getRequiredValue(ConnectionFactoryOptions.DRIVER).equals('simple');
	}
	@Override
	public String getDriver() {
		return 'simple';
	}
	public static class SimpleTestConnectionFactory implements ConnectionFactory {
		@Override
		public Publisher<? extends Connection> create() {
			return Mono.error(new UnsupportedOperationException());
		}
		@Override
		public ConnectionFactoryMetadata getMetadata() {
			return SimpleConnectionFactoryProvider.class::getName;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT, properties = 'spring.main.web-application-type=reactive')
class MustacheAutoConfigurationReactiveIntegrationTests {
	@Autowired
	private WebTestClient client;
	@Test
	void testHomePage() {
		String result = this.client.get()
			.uri('/')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.returnResult()
			.getResponseBody();
		assertThat(result).contains('Hello App').contains('Hello World');
	}
	@Test
	void testPartialPage() {
		String result = this.client.get()
			.uri('/partial')
			.exchange()
			.expectStatus()
			.isOk()
			.expectBody(String.class)
			.returnResult()
			.getResponseBody();
		assertThat(result).contains('Hello App').contains('Hello World');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ ReactiveWebServerFactoryAutoConfiguration.class, WebFluxAutoConfiguration.class,
			HttpHandlerAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	@Controller
	static class Application {
		@RequestMapping('/')
		String home(Model model) {
			model.addAttribute('time', new Date());
			model.addAttribute('message', 'Hello World');
			model.addAttribute('title', 'Hello App');
			return 'home';
		}
		@RequestMapping('/partial')
		String layout(Model model) {
			model.addAttribute('time', new Date());
			model.addAttribute('message', 'Hello World');
			model.addAttribute('title', 'Hello App');
			return 'partial';
		}
		@Bean
		MustacheViewResolver viewResolver() {
			Mustache.Compiler compiler = Mustache.compiler()
				.withLoader(new MustacheResourceTemplateLoader('classpath:/mustache-templates/', '.html'));
			MustacheViewResolver resolver = new MustacheViewResolver(compiler);
			resolver.setPrefix('classpath:/mustache-templates/');
			resolver.setSuffix('.html');
			return resolver;
		}
		static void main(String[] args) {
			SpringApplication application = new SpringApplication(Application.class);
			application.setWebApplicationType(WebApplicationType.REACTIVE);
			application.run(args);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
class MustacheAutoConfigurationServletIntegrationTests {
	@Autowired
	private ServletWebServerApplicationContext context;
	private int port;
	@BeforeEach
	void init() {
		this.port = this.context.getWebServer().getPort();
	}
	@Test
	void contextLoads() {
		String source = 'Hello {{arg}}!';
		Template tmpl = Mustache.compiler().compile(source);
		Map<String, String> context = new HashMap<>();
		context.put('arg', 'world');
		assertThat(tmpl.execute(context)).isEqualTo('Hello world!');
	}
	@Test
	void testHomePage() {
		String body = new TestRestTemplate().getForObject('http://localhost:' + this.port, String.class);
		assertThat(body).contains('Hello World');
	}
	@Test
	void testPartialPage() {
		String body = new TestRestTemplate().getForObject('http://localhost:' + this.port + '/partial', String.class);
		assertThat(body).contains('Hello World');
	}
	@Configuration(proxyBeanMethods = false)
	@MinimalWebConfiguration
	@Controller
	static class Application {
		@RequestMapping('/')
		String home(Map<String, Object> model) {
			model.put('time', new Date());
			model.put('message', 'Hello World');
			model.put('title', 'Hello App');
			return 'home';
		}
		@RequestMapping('/partial')
		String layout(Map<String, Object> model) {
			model.put('time', new Date());
			model.put('message', 'Hello World');
			model.put('title', 'Hello App');
			return 'partial';
		}
		@Bean
		MustacheViewResolver viewResolver() {
			Mustache.Compiler compiler = Mustache.compiler()
				.withLoader(new MustacheResourceTemplateLoader('classpath:/mustache-templates/', '.html'));
			MustacheViewResolver resolver = new MustacheViewResolver(compiler);
			resolver.setPrefix('classpath:/mustache-templates/');
			resolver.setSuffix('.html');
			return resolver;
		}
		static void main(String[] args) {
			SpringApplication.run(Application.class, args);
		}
	}
	@Target(ElementType.TYPE)
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Import({ ServletWebServerFactoryAutoConfiguration.class, DispatcherServletAutoConfiguration.class,
			PropertyPlaceholderAutoConfiguration.class })
	protected @interface MinimalWebConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
class MustacheAutoConfigurationTests {
	@Test
	void registerBeansForServletApp() {
		configure(new WebApplicationContextRunner()).run((context) -> {
			assertThat(context).hasSingleBean(Mustache.Compiler.class);
			assertThat(context).hasSingleBean(MustacheResourceTemplateLoader.class);
			assertThat(context).hasSingleBean(MustacheViewResolver.class);
		});
	}
	@Test
	void servletViewResolverCanBeDisabled() {
		configure(new WebApplicationContextRunner()).withPropertyValues('spring.mustache.enabled=false')
			.run((context) -> {
				assertThat(context).hasSingleBean(Mustache.Compiler.class);
				assertThat(context).hasSingleBean(MustacheResourceTemplateLoader.class);
				assertThat(context).doesNotHaveBean(MustacheViewResolver.class);
			});
	}
	@Test
	void registerCompilerForServletApp() {
		configure(new WebApplicationContextRunner()).withUserConfiguration(CustomCompilerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Mustache.Compiler.class);
				assertThat(context).hasSingleBean(MustacheResourceTemplateLoader.class);
				assertThat(context).hasSingleBean(MustacheViewResolver.class);
				assertThat(context.getBean(Mustache.Compiler.class).standardsMode).isTrue();
			});
	}
	@Test
	void registerBeansForReactiveApp() {
		configure(new ReactiveWebApplicationContextRunner()).run((context) -> {
			assertThat(context).hasSingleBean(Mustache.Compiler.class);
			assertThat(context).hasSingleBean(MustacheResourceTemplateLoader.class);
			assertThat(context).doesNotHaveBean(MustacheViewResolver.class);
			assertThat(context)
				.hasSingleBean(org.springframework.boot.web.reactive.result.view.MustacheViewResolver.class);
		});
	}
	@Test
	void reactiveViewResolverCanBeDisabled() {
		configure(new ReactiveWebApplicationContextRunner()).withPropertyValues('spring.mustache.enabled=false')
			.run((context) -> {
				assertThat(context).hasSingleBean(Mustache.Compiler.class);
				assertThat(context).hasSingleBean(MustacheResourceTemplateLoader.class);
				assertThat(context)
					.doesNotHaveBean(org.springframework.boot.web.reactive.result.view.MustacheViewResolver.class);
			});
	}
	@Test
	void registerCompilerForReactiveApp() {
		configure(new ReactiveWebApplicationContextRunner()).withUserConfiguration(CustomCompilerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Mustache.Compiler.class);
				assertThat(context).hasSingleBean(MustacheResourceTemplateLoader.class);
				assertThat(context).doesNotHaveBean(MustacheViewResolver.class);
				assertThat(context)
					.hasSingleBean(org.springframework.boot.web.reactive.result.view.MustacheViewResolver.class);
				assertThat(context.getBean(Mustache.Compiler.class).standardsMode).isTrue();
			});
	}
	@Test
	void defaultServletViewResolverConfiguration() {
		configure(new WebApplicationContextRunner()).run((context) -> {
			MustacheViewResolver viewResolver = context.getBean(MustacheViewResolver.class);
			assertThat(viewResolver).extracting('allowRequestOverride', InstanceOfAssertFactories.BOOLEAN).isFalse();
			assertThat(viewResolver).extracting('allowSessionOverride', InstanceOfAssertFactories.BOOLEAN).isFalse();
			assertThat(viewResolver).extracting('cache', InstanceOfAssertFactories.BOOLEAN).isFalse();
			assertThat(viewResolver).extracting('charset').isEqualTo('UTF-8');
			assertThat(viewResolver).extracting('exposeRequestAttributes', InstanceOfAssertFactories.BOOLEAN).isFalse();
			assertThat(viewResolver).extracting('exposeSessionAttributes', InstanceOfAssertFactories.BOOLEAN).isFalse();
			assertThat(viewResolver).extracting('exposeSpringMacroHelpers', InstanceOfAssertFactories.BOOLEAN).isTrue();
			assertThat(viewResolver).extracting('prefix').isEqualTo('classpath:/templates/');
			assertThat(viewResolver).extracting('requestContextAttribute').isNull();
			assertThat(viewResolver).extracting('suffix').isEqualTo('.mustache');
		});
	}
	@Test
	void defaultReactiveViewResolverConfiguration() {
		configure(new ReactiveWebApplicationContextRunner()).run((context) -> {
			org.springframework.boot.web.reactive.result.view.MustacheViewResolver viewResolver = context
				.getBean(org.springframework.boot.web.reactive.result.view.MustacheViewResolver.class);
			assertThat(viewResolver).extracting('charset').isEqualTo('UTF-8');
			assertThat(viewResolver).extracting('prefix').isEqualTo('classpath:/templates/');
			assertThat(viewResolver).extracting('requestContextAttribute').isNull();
			assertThat(viewResolver).extracting('suffix').isEqualTo('.mustache');
			assertThat(viewResolver.getSupportedMediaTypes())
				.containsExactly(MediaType.parseMediaType('text/html;charset=UTF-8'));
		});
	}
	@Test
	void allowRequestOverrideCanBeCustomizedOnServletViewResolver() {
		assertViewResolverProperty(ViewResolverKind.SERVLET, 'spring.mustache.servlet.allow-request-override=true',
				'allowRequestOverride', true);
	}
	@Test
	void allowSessionOverrideCanBeCustomizedOnServletViewResolver() {
		assertViewResolverProperty(ViewResolverKind.SERVLET, 'spring.mustache.servlet.allow-session-override=true',
				'allowSessionOverride', true);
	}
	@Test
	void cacheCanBeCustomizedOnServletViewResolver() {
		assertViewResolverProperty(ViewResolverKind.SERVLET, 'spring.mustache.servlet.cache=true', 'cache', true);
	}
	@ParameterizedTest
	@EnumSource(ViewResolverKind.class)
	void charsetCanBeCustomizedOnViewResolver(ViewResolverKind kind) {
		assertViewResolverProperty(kind, 'spring.mustache.charset=UTF-16', 'charset', 'UTF-16');
	}
	@Test
	void exposeRequestAttributesCanBeCustomizedOnServletViewResolver() {
		assertViewResolverProperty(ViewResolverKind.SERVLET, 'spring.mustache.servlet.expose-request-attributes=true',
				'exposeRequestAttributes', true);
	}
	@Test
	void exposeSessionAttributesCanBeCustomizedOnServletViewResolver() {
		assertViewResolverProperty(ViewResolverKind.SERVLET, 'spring.mustache.servlet.expose-session-attributes=true',
				'exposeSessionAttributes', true);
	}
	@Test
	void exposeSpringMacroHelpersCanBeCustomizedOnServletViewResolver() {
		assertViewResolverProperty(ViewResolverKind.SERVLET, 'spring.mustache.servlet.expose-spring-macro-helpers=true',
				'exposeSpringMacroHelpers', true);
	}
	@ParameterizedTest
	@EnumSource(ViewResolverKind.class)
	void prefixCanBeCustomizedOnViewResolver(ViewResolverKind kind) {
		assertViewResolverProperty(kind, 'spring.mustache.prefix=classpath:/mustache-templates/', 'prefix',
				'classpath:/mustache-templates/');
	}
	@ParameterizedTest
	@EnumSource(ViewResolverKind.class)
	void requestContextAttributeCanBeCustomizedOnViewResolver(ViewResolverKind kind) {
		assertViewResolverProperty(kind, 'spring.mustache.request-context-attribute=test', 'requestContextAttribute',
				'test');
	}
	@ParameterizedTest
	@EnumSource(ViewResolverKind.class)
	void suffixCanBeCustomizedOnViewResolver(ViewResolverKind kind) {
		assertViewResolverProperty(kind, 'spring.mustache.suffix=.tache', 'suffix', '.tache');
	}
	@Test
	void mediaTypesCanBeCustomizedOnReactiveViewResolver() {
		assertViewResolverProperty(ViewResolverKind.REACTIVE,
				'spring.mustache.reactive.media-types=text/xml;charset=UTF-8,text/plain;charset=UTF-16', 'mediaTypes',
				Arrays.asList(MediaType.parseMediaType('text/xml;charset=UTF-8'),
						MediaType.parseMediaType('text/plain;charset=UTF-16')));
	}
	private void assertViewResolverProperty(ViewResolverKind kind, String property, String field,
			Object expectedValue) {
		kind.runner()
			.withConfiguration(AutoConfigurations.of(MustacheAutoConfiguration.class))
			.withPropertyValues(property)
			.run((context) -> assertThat(context.getBean(kind.viewResolverClass())).extracting(field)
				.isEqualTo(expectedValue));
	}
	private <T extends AbstractApplicationContextRunner<T, ?, ?>> T configure(T runner) {
		return runner.withConfiguration(AutoConfigurations.of(MustacheAutoConfiguration.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomCompilerConfiguration {
		@Bean
		Mustache.Compiler compiler(Mustache.TemplateLoader mustacheTemplateLoader) {
			return Mustache.compiler().standardsMode(true).withLoader(mustacheTemplateLoader);
		}
	}
	private enum ViewResolverKind {
		/**
		 * Servlet MustacheViewResolver
		 */
		SERVLET(WebApplicationContextRunner::new, MustacheViewResolver.class),
		/**
		 * Reactive MustacheViewResolver
		 */
		REACTIVE(ReactiveWebApplicationContextRunner::new,
				org.springframework.boot.web.reactive.result.view.MustacheViewResolver.class);
		private final Supplier<AbstractApplicationContextRunner<?, ?, ?>> runner;
		private final Class<?> viewResolverClass;
		ViewResolverKind(Supplier<AbstractApplicationContextRunner<?, ?, ?>> runner, Class<?> viewResolverClass) {
			this.runner = runner;
			this.viewResolverClass = viewResolverClass;
		}
		private AbstractApplicationContextRunner<?, ?, ?> runner() {
			return this.runner.get();
		}
		private Class<?> viewResolverClass() {
			return this.viewResolverClass;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
@ClassPathExclusions('spring-webmvc-*.jar')
class MustacheAutoConfigurationWithoutWebMvcTests {
	@Test
	void registerBeansForServletAppWithoutMvc() {
		new WebApplicationContextRunner().withConfiguration(AutoConfigurations.of(MustacheAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(Mustache.Compiler.class);
				assertThat(context).hasSingleBean(MustacheResourceTemplateLoader.class);
			});
	}
}
/*
package org.springframework.boot.autoconfigure.mustache;
/**
@DirtiesContext
@SpringBootTest(webEnvironment = WebEnvironment.NONE)
class MustacheStandaloneIntegrationTests {
	@Autowired
	private Mustache.Compiler compiler;
	@Test
	void directCompilation() {
		assertThat(this.compiler.compile('Hello: {{world}}').execute(Collections.singletonMap('world', 'World')))
			.isEqualTo('Hello: World');
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ MustacheAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class })
	static class Application {
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
class RSocketServerAutoConfigurationTests {
	@Test
	void shouldNotCreateBeansByDefault() {
		contextRunner().run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
			.doesNotHaveBean(RSocketServerFactory.class)
			.doesNotHaveBean(RSocketServerBootstrap.class));
	}
	@Test
	void shouldNotCreateDefaultBeansForReactiveWebAppWithoutMapping() {
		reactiveWebContextRunner()
			.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
				.doesNotHaveBean(RSocketServerFactory.class)
				.doesNotHaveBean(RSocketServerBootstrap.class));
	}
	@Test
	void shouldNotCreateDefaultBeansForReactiveWebAppWithWrongTransport() {
		reactiveWebContextRunner()
			.withPropertyValues('spring.rsocket.server.transport=tcp', 'spring.rsocket.server.mapping-path=/rsocket')
			.run((context) -> assertThat(context).doesNotHaveBean(WebServerFactoryCustomizer.class)
				.doesNotHaveBean(RSocketServerFactory.class)
				.doesNotHaveBean(RSocketServerBootstrap.class));
	}
	@Test
	void shouldCreateDefaultBeansForReactiveWebApp() {
		reactiveWebContextRunner()
			.withPropertyValues('spring.rsocket.server.transport=websocket',
					'spring.rsocket.server.mapping-path=/rsocket')
			.run((context) -> assertThat(context).hasSingleBean(RSocketWebSocketNettyRouteProvider.class));
	}
	@Test
	void shouldCreateDefaultBeansForRSocketServerWhenPortIsSet() {
		reactiveWebContextRunner().withPropertyValues('spring.rsocket.server.port=0')
			.run((context) -> assertThat(context).hasSingleBean(RSocketServerFactory.class)
				.hasSingleBean(RSocketServerBootstrap.class)
				.hasSingleBean(RSocketServerCustomizer.class));
	}
	@Test
	void shouldSetLocalServerPortWhenRSocketServerPortIsSet() {
		reactiveWebContextRunner().withPropertyValues('spring.rsocket.server.port=0')
			.withInitializer(new RSocketPortInfoApplicationContextInitializer())
			.run((context) -> {
				assertThat(context).hasSingleBean(RSocketServerFactory.class)
					.hasSingleBean(RSocketServerBootstrap.class)
					.hasSingleBean(RSocketServerCustomizer.class);
				assertThat(context.getEnvironment().getProperty('local.rsocket.server.port')).isNotNull();
			});
	}
	@Test
	void shouldSetFragmentWhenRSocketServerFragmentSizeIsSet() {
		reactiveWebContextRunner()
			.withPropertyValues('spring.rsocket.server.port=0', 'spring.rsocket.server.fragment-size=12KB')
			.run((context) -> {
				assertThat(context).hasSingleBean(RSocketServerFactory.class);
				RSocketServerFactory factory = context.getBean(RSocketServerFactory.class);
				assertThat(factory).hasFieldOrPropertyWithValue('fragmentSize', DataSize.ofKilobytes(12));
			});
	}
	@Test
	void shouldFailToSetFragmentWhenRSocketServerFragmentSizeIsBelow64() {
		reactiveWebContextRunner()
			.withPropertyValues('spring.rsocket.server.port=0', 'spring.rsocket.server.fragment-size=60B')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure())
					.hasMessageContaining('The smallest allowed mtu size is 64 bytes, provided: 60');
			});
	}
	@Test
	void shouldUseSslWhenRocketServerSslIsConfigured() {
		reactiveWebContextRunner()
			.withPropertyValues('spring.rsocket.server.ssl.keyStore=classpath:rsocket/test.jks',
					'spring.rsocket.server.ssl.keyPassword=password', 'spring.rsocket.server.port=0')
			.run((context) -> assertThat(context).hasSingleBean(RSocketServerFactory.class)
				.hasSingleBean(RSocketServerBootstrap.class)
				.hasSingleBean(RSocketServerCustomizer.class)
				.getBean(RSocketServerFactory.class)
				.hasFieldOrPropertyWithValue('ssl.keyStore', 'classpath:rsocket/test.jks')
				.hasFieldOrPropertyWithValue('ssl.keyPassword', 'password'));
	}
	@Test
	@Disabled
	void shouldUseSslWhenRocketServerSslIsConfiguredWithSslBundle() {
		reactiveWebContextRunner()
			.withPropertyValues('spring.rsocket.server.port=0', 'spring.rsocket.server.ssl.bundle=test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location=classpath:rsocket/test.jks',
					'spring.ssl.bundle.jks.test-bundle.key.password=password')
			.run((context) -> assertThat(context).hasSingleBean(RSocketServerFactory.class)
				.hasSingleBean(RSocketServerBootstrap.class)
				.hasSingleBean(RSocketServerCustomizer.class)
				.getBean(RSocketServerFactory.class)
				.hasFieldOrPropertyWithValue('sslBundle.details.keyStore', 'classpath:rsocket/test.jks')
				.hasFieldOrPropertyWithValue('sslBundle.details.keyPassword', 'password'));
	}
	@Test
	void shouldFailWhenSslIsConfiguredWithMissingBundle() {
		reactiveWebContextRunner()
			.withPropertyValues('spring.rsocket.server.port=0', 'spring.rsocket.server.ssl.bundle=test-bundle')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).hasRootCauseInstanceOf(NoSuchSslBundleException.class)
					.withFailMessage('SSL bundle name "test-bundle" is not valid');
			});
	}
	@Test
	void shouldUseCustomServerBootstrap() {
		contextRunner().withUserConfiguration(CustomServerBootstrapConfig.class)
			.run((context) -> assertThat(context).getBeanNames(RSocketServerBootstrap.class)
				.containsExactly('customServerBootstrap'));
	}
	@Test
	void shouldUseCustomNettyRouteProvider() {
		reactiveWebContextRunner().withUserConfiguration(CustomNettyRouteProviderConfig.class)
			.withPropertyValues('spring.rsocket.server.transport=websocket',
					'spring.rsocket.server.mapping-path=/rsocket')
			.run((context) -> assertThat(context).getBeanNames(RSocketWebSocketNettyRouteProvider.class)
				.containsExactly('customNettyRouteProvider'));
	}
	@Test
	void whenSpringWebIsNotPresentThenEmbeddedServerConfigurationBacksOff() {
		contextRunner().withClassLoader(new FilteredClassLoader(ReactorResourceFactory.class))
			.withPropertyValues('spring.rsocket.server.port=0')
			.run((context) -> assertThat(context).doesNotHaveBean(RSocketServerFactory.class));
	}
	private ApplicationContextRunner contextRunner() {
		return new ApplicationContextRunner().withUserConfiguration(BaseConfiguration.class)
			.withConfiguration(AutoConfigurations.of(RSocketServerAutoConfiguration.class));
	}
	private ReactiveWebApplicationContextRunner reactiveWebContextRunner() {
		return new ReactiveWebApplicationContextRunner().withUserConfiguration(BaseConfiguration.class)
			.withConfiguration(AutoConfigurations.of(RSocketServerAutoConfiguration.class, SslAutoConfiguration.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		RSocketMessageHandler messageHandler() {
			RSocketMessageHandler messageHandler = new RSocketMessageHandler();
			messageHandler.setRSocketStrategies(RSocketStrategies.builder()
				.encoder(CharSequenceEncoder.textPlainOnly())
				.decoder(StringDecoder.allMimeTypes())
				.build());
			return messageHandler;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomServerBootstrapConfig {
		@Bean
		RSocketServerBootstrap customServerBootstrap() {
			return mock(RSocketServerBootstrap.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomNettyRouteProviderConfig {
		@Bean
		RSocketWebSocketNettyRouteProvider customNettyRouteProvider() {
			return mock(RSocketWebSocketNettyRouteProvider.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
class RSocketPropertiesTests {
	@Test
	void defaultServerSpecValuesAreConsistent() {
		WebsocketServerSpec spec = WebsocketServerSpec.builder().build();
		Spec properties = new RSocketProperties().getServer().getSpec();
		assertThat(properties.getProtocols()).isEqualTo(spec.protocols());
		assertThat(properties.getMaxFramePayloadLength().toBytes()).isEqualTo(spec.maxFramePayloadLength());
		assertThat(properties.isHandlePing()).isEqualTo(spec.handlePing());
		assertThat(properties.isCompress()).isEqualTo(spec.compress());
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
class RSocketMessagingAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RSocketMessagingAutoConfiguration.class))
		.withUserConfiguration(BaseConfiguration.class);
	@Test
	void shouldCreateDefaultBeans() {
		this.contextRunner.run((context) -> assertThat(context).getBeans(RSocketMessageHandler.class).hasSize(1));
	}
	@Test
	void shouldFailOnMissingStrategies() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(RSocketMessagingAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure().getMessage()).contains('No qualifying bean of type '
						+ '"org.springframework.messaging.rsocket.RSocketStrategies" available');
			});
	}
	@Test
	void shouldUseCustomSocketAcceptor() {
		this.contextRunner.withUserConfiguration(CustomMessageHandler.class)
			.run((context) -> assertThat(context).getBeanNames(RSocketMessageHandler.class)
				.containsOnly('customMessageHandler'));
	}
	@Test
	void shouldApplyMessageHandlerCustomizers() {
		this.contextRunner.withUserConfiguration(CustomizerConfiguration.class).run((context) -> {
			RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class);
			assertThat(handler.getDefaultDataMimeType()).isEqualTo(MimeType.valueOf('application/json'));
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class BaseConfiguration {
		@Bean
		RSocketStrategies rSocketStrategies() {
			return RSocketStrategies.builder()
				.encoder(CharSequenceEncoder.textPlainOnly())
				.decoder(StringDecoder.allMimeTypes())
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomMessageHandler {
		@Bean
		RSocketMessageHandler customMessageHandler() {
			RSocketMessageHandler messageHandler = new RSocketMessageHandler();
			RSocketStrategies strategies = RSocketStrategies.builder()
				.encoder(CharSequenceEncoder.textPlainOnly())
				.decoder(StringDecoder.allMimeTypes())
				.build();
			messageHandler.setRSocketStrategies(strategies);
			return messageHandler;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		RSocketMessageHandlerCustomizer customizer() {
			return (messageHandler) -> messageHandler.setDefaultDataMimeType(MimeType.valueOf('application/json'));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
class RSocketWebSocketNettyRouteProviderTests {
	@Test
	void webEndpointsShouldWork() {
		new ReactiveWebApplicationContextRunner(AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class,
					ErrorWebFluxAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
					JacksonAutoConfiguration.class, CodecsAutoConfiguration.class,
					RSocketStrategiesAutoConfiguration.class, RSocketServerAutoConfiguration.class,
					RSocketMessagingAutoConfiguration.class, RSocketRequesterAutoConfiguration.class))
			.withUserConfiguration(WebConfiguration.class)
			.withPropertyValues('spring.rsocket.server.transport=websocket',
					'spring.rsocket.server.mapping-path=/rsocket')
			.run((context) -> {
				ReactiveWebServerApplicationContext serverContext = (ReactiveWebServerApplicationContext) context
					.getSourceApplicationContext();
				RSocketRequester requester = createRSocketRequester(context, serverContext.getWebServer());
				TestProtocol rsocketResponse = requester.route('websocket')
					.data(new TestProtocol('rsocket'))
					.retrieveMono(TestProtocol.class)
					.block(Duration.ofSeconds(3));
				assertThat(rsocketResponse.getName()).isEqualTo('rsocket');
				WebTestClient client = createWebTestClient(serverContext.getWebServer());
				client.get()
					.uri('/protocol')
					.exchange()
					.expectStatus()
					.isOk()
					.expectBody()
					.jsonPath('name')
					.isEqualTo('http');
			});
	}
	private WebTestClient createWebTestClient(WebServer server) {
		return WebTestClient.bindToServer()
			.baseUrl('http://localhost:' + server.getPort())
			.responseTimeout(Duration.ofMinutes(5))
			.build();
	}
	private RSocketRequester createRSocketRequester(ApplicationContext context, WebServer server) {
		int port = server.getPort();
		RSocketRequester.Builder builder = context.getBean(RSocketRequester.Builder.class);
		return builder.dataMimeType(MediaType.APPLICATION_CBOR)
			.websocket(URI.create('ws://localhost:' + port + '/rsocket'));
	}
	@Configuration(proxyBeanMethods = false)
	static class WebConfiguration {
		@Bean
		WebController webController() {
			return new WebController();
		}
		@Bean
		NettyReactiveWebServerFactory customServerFactory(RSocketWebSocketNettyRouteProvider routeProvider) {
			NettyReactiveWebServerFactory serverFactory = new NettyReactiveWebServerFactory(0);
			serverFactory.addRouteProviders(routeProvider);
			return serverFactory;
		}
	}
	@Controller
	static class WebController {
		@GetMapping(path = '/protocol', produces = MediaType.APPLICATION_JSON_VALUE)
		@ResponseBody
		TestProtocol testWebEndpoint() {
			return new TestProtocol('http');
		}
		@MessageMapping('websocket')
		TestProtocol testRSocketEndpoint() {
			return new TestProtocol('rsocket');
		}
	}
	public static class TestProtocol {
		private String name;
		TestProtocol() {
		}
		TestProtocol(String name) {
			this.name = name;
		}
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
class RSocketRequesterAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(RSocketStrategiesAutoConfiguration.class, RSocketRequesterAutoConfiguration.class));
	@Test
	void shouldCreateBuilder() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(RSocketRequester.Builder.class));
	}
	@Test
	void shouldGetPrototypeScopedBean() {
		this.contextRunner.run((context) -> {
			RSocketRequester.Builder first = context.getBean(RSocketRequester.Builder.class);
			RSocketRequester.Builder second = context.getBean(RSocketRequester.Builder.class);
			assertThat(first).isNotEqualTo(second);
		});
	}
	@Test
	void shouldNotCreateBuilderIfAlreadyPresent() {
		this.contextRunner.withUserConfiguration(CustomRSocketRequesterBuilder.class).run((context) -> {
			RSocketRequester.Builder builder = context.getBean(RSocketRequester.Builder.class);
			assertThat(builder).isInstanceOf(MyRSocketRequesterBuilder.class);
		});
	}
	@Test
	void shouldCreateBuilderWithAvailableRSocketConnectorConfigurers() {
		RSocketConnectorConfigurer first = mock(RSocketConnectorConfigurer.class);
		RSocketConnectorConfigurer second = mock(RSocketConnectorConfigurer.class);
		this.contextRunner.withBean('first', RSocketConnectorConfigurer.class, () -> first)
			.withBean('second', RSocketConnectorConfigurer.class, () -> second)
			.run((context) -> {
				assertThat(context).getBeans(RSocketConnectorConfigurer.class).hasSize(2);
				RSocketRequester.Builder builder = context.getBean(RSocketRequester.Builder.class);
				assertThat(builder).extracting('rsocketConnectorConfigurers', as(InstanceOfAssertFactories.LIST))
					.containsExactly(first, second);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRSocketRequesterBuilder {
		@Bean
		MyRSocketRequesterBuilder myRSocketRequesterBuilder() {
			return mock(MyRSocketRequesterBuilder.class);
		}
	}
	interface MyRSocketRequesterBuilder extends RSocketRequester.Builder {
	}
}
/*
package org.springframework.boot.autoconfigure.rsocket;
/**
class RSocketStrategiesAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner().withConfiguration(
			AutoConfigurations.of(JacksonAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class));
	@Test
	void shouldCreateDefaultBeans() {
		this.contextRunner.run((context) -> {
			assertThat(context).getBeans(RSocketStrategies.class).hasSize(1);
			RSocketStrategies strategies = context.getBean(RSocketStrategies.class);
			assertThat(strategies.decoders()).hasAtLeastOneElementOfType(Jackson2CborDecoder.class)
				.hasAtLeastOneElementOfType(Jackson2JsonDecoder.class);
			assertThat(strategies.encoders()).hasAtLeastOneElementOfType(Jackson2CborEncoder.class)
				.hasAtLeastOneElementOfType(Jackson2JsonEncoder.class);
			assertThat(strategies.routeMatcher()).isInstanceOf(PathPatternRouteMatcher.class);
		});
	}
	@Test
	void shouldUseCustomStrategies() {
		this.contextRunner.withUserConfiguration(UserStrategies.class).run((context) -> {
			assertThat(context).getBeans(RSocketStrategies.class).hasSize(1);
			assertThat(context.getBeanNamesForType(RSocketStrategies.class)).contains('customRSocketStrategies');
		});
	}
	@Test
	void shouldUseStrategiesCustomizer() {
		this.contextRunner.withUserConfiguration(StrategiesCustomizer.class).run((context) -> {
			assertThat(context).getBeans(RSocketStrategies.class).hasSize(1);
			RSocketStrategies strategies = context.getBean(RSocketStrategies.class);
			assertThat(strategies.decoders()).hasAtLeastOneElementOfType(CustomDecoder.class);
			assertThat(strategies.encoders()).hasAtLeastOneElementOfType(CustomEncoder.class);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class UserStrategies {
		@Bean
		RSocketStrategies customRSocketStrategies() {
			return RSocketStrategies.builder()
				.encoder(CharSequenceEncoder.textPlainOnly())
				.decoder(StringDecoder.textPlainOnly())
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class StrategiesCustomizer {
		@Bean
		RSocketStrategiesCustomizer myCustomizer() {
			return (strategies) -> strategies.encoder(mock(CustomEncoder.class)).decoder(mock(CustomDecoder.class));
		}
	}
	interface CustomEncoder extends Encoder<String> {
	}
	interface CustomDecoder extends Decoder<String> {
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.servlet;
/**
class WebSocketMessagingAutoConfigurationTests {
	private final AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext();
	private SockJsClient sockJsClient;
	@BeforeEach
	void setup() {
		List<Transport> transports = Arrays.asList(
				new WebSocketTransport(new StandardWebSocketClient(new WsWebSocketContainer())),
				new RestTemplateXhrTransport(new RestTemplate()));
		this.sockJsClient = new SockJsClient(transports);
	}
	@AfterEach
	void tearDown() {
		if (this.context.isActive()) {
			this.context.close();
		}
		this.sockJsClient.stop();
	}
	@Test
	void basicMessagingWithJsonResponse() throws Throwable {
		Object result = performStompSubscription('/app/json');
		JSONAssert.assertEquals('{\'foo\' : 5,\'bar\' : \'baz\'}', new String((byte[]) result), true);
	}
	@Test
	void basicMessagingWithStringResponse() throws Throwable {
		Object result = performStompSubscription('/app/string');
		assertThat(new String((byte[]) result)).isEqualTo('string data');
	}
	@Test
	void whenLazyInitializationIsEnabledThenBasicMessagingWorks() throws Throwable {
		this.context.register(LazyInitializationBeanFactoryPostProcessor.class);
		Object result = performStompSubscription('/app/string');
		assertThat(new String((byte[]) result)).isEqualTo('string data');
	}
	@Test
	void customizedConverterTypesMatchDefaultConverterTypes() {
		List<MessageConverter> customizedConverters = getCustomizedConverters();
		List<MessageConverter> defaultConverters = getDefaultConverters();
		assertThat(customizedConverters).hasSameSizeAs(defaultConverters);
		Iterator<MessageConverter> customizedIterator = customizedConverters.iterator();
		Iterator<MessageConverter> defaultIterator = defaultConverters.iterator();
		while (customizedIterator.hasNext()) {
			assertThat(customizedIterator.next()).isInstanceOf(defaultIterator.next().getClass());
		}
	}
	@Test
	void predefinedThreadExecutorIsSelectedForInboundChannel() throws Throwable {
		AsyncTaskExecutor expectedExecutor = new SimpleAsyncTaskExecutor();
		ChannelRegistration registration = new ChannelRegistration();
		WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration configuration = new WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration(
				new ObjectMapper(),
				Map.of(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME, expectedExecutor));
		configuration.configureClientInboundChannel(registration);
		TaskExecutor executor = (TaskExecutor) FieldUtils.getFieldValue(registration, 'executor');
		assertThat(executor).isEqualTo(expectedExecutor);
	}
	@Test
	void predefinedThreadExecutorIsSelectedForOutboundChannel() throws Throwable {
		AsyncTaskExecutor expectedExecutor = new SimpleAsyncTaskExecutor();
		ChannelRegistration registration = new ChannelRegistration();
		WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration configuration = new WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration(
				new ObjectMapper(),
				Map.of(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME, expectedExecutor));
		configuration.configureClientOutboundChannel(registration);
		TaskExecutor executor = (TaskExecutor) FieldUtils.getFieldValue(registration, 'executor');
		assertThat(executor).isEqualTo(expectedExecutor);
	}
	private List<MessageConverter> getCustomizedConverters() {
		List<MessageConverter> customizedConverters = new ArrayList<>();
		WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration configuration = new WebSocketMessagingAutoConfiguration.WebSocketMessageConverterConfiguration(
				new ObjectMapper(), Collections.emptyMap());
		configuration.configureMessageConverters(customizedConverters);
		return customizedConverters;
	}
	private List<MessageConverter> getDefaultConverters() {
		DelegatingWebSocketMessageBrokerConfiguration configuration = new DelegatingWebSocketMessageBrokerConfiguration();
		CompositeMessageConverter compositeDefaultConverter = configuration.brokerMessageConverter();
		return compositeDefaultConverter.getConverters();
	}
	private Object performStompSubscription(String topic) throws Throwable {
		TestPropertyValues.of('server.port:0', 'spring.jackson.serialization.indent-output:true').applyTo(this.context);
		this.context.register(WebSocketMessagingConfiguration.class);
		this.context.refresh();
		WebSocketStompClient stompClient = new WebSocketStompClient(this.sockJsClient);
		final AtomicReference<Throwable> failure = new AtomicReference<>();
		final AtomicReference<Object> result = new AtomicReference<>();
		final CountDownLatch latch = new CountDownLatch(1);
		StompSessionHandler handler = new StompSessionHandlerAdapter() {
			@Override
			public void afterConnected(StompSession session, StompHeaders connectedHeaders) {
				session.subscribe(topic, new StompFrameHandler() {
					@Override
					public void handleFrame(StompHeaders headers, Object payload) {
						result.set(payload);
						latch.countDown();
					}
					@Override
					public Type getPayloadType(StompHeaders headers) {
						return Object.class;
					}
				});
			}
			@Override
			public void handleFrame(StompHeaders headers, Object payload) {
				latch.countDown();
			}
			@Override
			public void handleException(StompSession session, StompCommand command, StompHeaders headers,
					byte[] payload, Throwable exception) {
				failure.set(exception);
				latch.countDown();
			}
			@Override
			public void handleTransportError(StompSession session, Throwable exception) {
				failure.set(exception);
				latch.countDown();
			}
		};
		stompClient.setMessageConverter(new SimpleMessageConverter());
		stompClient.connectAsync('ws://localhost:{port}/messaging', handler, this.context.getWebServer().getPort());
		if (!latch.await(30, TimeUnit.SECONDS)) {
			if (failure.get() != null) {
				throw failure.get();
			}
			fail('Response was not received within 30 seconds');
		}
		return result.get();
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSocket
	@EnableConfigurationProperties
	@EnableWebSocketMessageBroker
	@ImportAutoConfiguration({ JacksonAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class,
			WebSocketMessagingAutoConfiguration.class, DispatcherServletAutoConfiguration.class })
	static class WebSocketMessagingConfiguration implements WebSocketMessageBrokerConfigurer {
		@Override
		public void registerStompEndpoints(StompEndpointRegistry registry) {
			registry.addEndpoint('/messaging').withSockJS();
		}
		@Override
		public void configureMessageBroker(MessageBrokerRegistry registry) {
			registry.setApplicationDestinationPrefixes('/app');
		}
		@Bean
		MessagingController messagingController() {
			return new MessagingController();
		}
		@Bean
		TomcatServletWebServerFactory tomcat() {
			return new TomcatServletWebServerFactory(0);
		}
		@Bean
		TomcatWebSocketServletWebServerCustomizer tomcatCustomizer() {
			return new TomcatWebSocketServletWebServerCustomizer();
		}
	}
	@Controller
	static class MessagingController {
		@SubscribeMapping('/json')
		Data json() {
			return new Data(5, 'baz');
		}
		@SubscribeMapping('/string')
		String string() {
			return 'string data';
		}
	}
	public static class Data {
		private final int foo;
		private final String bar;
		Data(int foo, String bar) {
			this.foo = foo;
			this.bar = bar;
		}
		public int getFoo() {
			return this.foo;
		}
		public String getBar() {
			return this.bar;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.servlet;
/**
@DirtiesUrlFactories
class WebSocketServletAutoConfigurationTests {
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void serverContainerIsAvailableFromTheServletContext(String server, Class<?>... configuration) {
		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
				configuration)) {
			Object serverContainer = context.getServletContext()
				.getAttribute('jakarta.websocket.server.ServerContainer');
			assertThat(serverContainer).isInstanceOf(ServerContainer.class);
		}
	}
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void webSocketUpgradeDoesNotPreventAFilterFromRejectingTheRequest(String server, Class<?>... configuration)
			throws DeploymentException {
		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
				configuration)) {
			ServerContainer serverContainer = (ServerContainer) context.getServletContext()
				.getAttribute('jakarta.websocket.server.ServerContainer');
			serverContainer.addEndpoint(TestEndpoint.class);
			WebServer webServer = context.getWebServer();
			int port = webServer.getPort();
			TestRestTemplate rest = new TestRestTemplate();
			RequestEntity<Void> request = RequestEntity.get('http://localhost:' + port)
				.header('Upgrade', 'websocket')
				.header('Connection', 'upgrade')
				.header('Sec-WebSocket-Version', '13')
				.header('Sec-WebSocket-Key', 'key')
				.build();
			ResponseEntity<Void> response = rest.exchange(request, Void.class);
			assertThat(response.getStatusCode()).isEqualTo(HttpStatus.UNAUTHORIZED);
		}
	}
	@Test
	void jettyWebSocketUpgradeFilterIsAddedToServletContextOfJettyServer() {
		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
				JettyConfiguration.class, WebSocketServletAutoConfiguration.JettyWebSocketConfiguration.class)) {
			assertThat(context.getServletContext().getFilterRegistration(WebSocketUpgradeFilter.class.getName()))
				.isNotNull();
		}
	}
	@Test
	void jettyWebSocketUpgradeFilterIsNotAddedToServletContextOfTomcatServer() {
		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
				TomcatConfiguration.class, WebSocketServletAutoConfiguration.JettyWebSocketConfiguration.class)) {
			assertThat(context.getServletContext().getFilterRegistration(WebSocketUpgradeFilter.class.getName()))
				.isNull();
		}
	}
	@Test
	@SuppressWarnings('rawtypes')
	void jettyWebSocketUpgradeFilterIsNotExposedAsABean() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(JettyConfiguration.class,
					WebSocketServletAutoConfiguration.JettyWebSocketConfiguration.class))
			.run((context) -> {
				Map<String, Filter> filters = context.getBeansOfType(Filter.class);
				assertThat(filters.values()).noneMatch(WebSocketUpgradeFilter.class::isInstance);
				Map<String, AbstractFilterRegistrationBean> filterRegistrations = context
					.getBeansOfType(AbstractFilterRegistrationBean.class);
				assertThat(filterRegistrations.values()).extracting(AbstractFilterRegistrationBean::getFilter)
					.noneMatch(WebSocketUpgradeFilter.class::isInstance);
			});
	}
	@Test
	void jettyWebSocketUpgradeFilterServletContextInitializerBacksOffWhenBeanWithSameNameIsDefined() {
		try (AnnotationConfigServletWebServerApplicationContext context = new AnnotationConfigServletWebServerApplicationContext(
				JettyConfiguration.class, CustomWebSocketUpgradeFilterServletContextInitializerConfiguration.class,
				WebSocketServletAutoConfiguration.JettyWebSocketConfiguration.class)) {
			BeanDefinition definition = context.getBeanFactory()
				.getBeanDefinition('websocketUpgradeFilterServletContextInitializer');
			assertThat(definition.getFactoryBeanName())
				.contains('CustomWebSocketUpgradeFilterServletContextInitializerConfiguration');
		}
	}
	static Stream<Arguments> testConfiguration() {
		String response = 'Tomcat';
		return Stream.of(
				Arguments.of('Jetty',
						new Class<?>[] { JettyConfiguration.class, DispatcherServletAutoConfiguration.class,
								WebSocketServletAutoConfiguration.JettyWebSocketConfiguration.class }),
				Arguments.of(response,
						new Class<?>[] { TomcatConfiguration.class, DispatcherServletAutoConfiguration.class,
								WebSocketServletAutoConfiguration.TomcatWebSocketConfiguration.class }));
	}
	@Configuration(proxyBeanMethods = false)
	static class CommonConfiguration {
		@Bean
		FilterRegistrationBean<Filter> unauthorizedFilter() {
			FilterRegistrationBean<Filter> registration = new FilterRegistrationBean<>(new Filter() {
				@Override
				public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
						throws IOException, ServletException {
					((HttpServletResponse) response).sendError(HttpStatus.UNAUTHORIZED.value());
				}
			});
			registration.setOrder(Ordered.HIGHEST_PRECEDENCE);
			registration.addUrlPatterns('/*');
			registration.setDispatcherTypes(DispatcherType.REQUEST);
			return registration;
		}
		@Bean
		WebServerFactoryCustomizerBeanPostProcessor ServletWebServerCustomizerBeanPostProcessor() {
			return new WebServerFactoryCustomizerBeanPostProcessor();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatConfiguration extends CommonConfiguration {
		@Bean
		ServletWebServerFactory webServerFactory() {
			TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
			factory.setPort(0);
			return factory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JettyConfiguration extends CommonConfiguration {
		@Bean
		ServletWebServerFactory webServerFactory() {
			JettyServletWebServerFactory JettyServletWebServerFactory = new JettyServletWebServerFactory();
			JettyServletWebServerFactory.setPort(0);
			return JettyServletWebServerFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebSocketUpgradeFilterServletContextInitializerConfiguration {
		@Bean
		ServletContextInitializer websocketUpgradeFilterServletContextInitializer() {
			return (servletContext) -> {
			};
		}
	}
	@ServerEndpoint('/')
	public static class TestEndpoint {
	}
}
/*
package org.springframework.boot.autoconfigure.websocket.reactive;
/**
@DirtiesUrlFactories
class WebSocketReactiveAutoConfigurationTests {
	@ParameterizedTest(name = '{0}')
	@MethodSource('testConfiguration')
	@ForkedClassPath
	void serverContainerIsAvailableFromTheServletContext(String server,
			Function<AnnotationConfigReactiveWebServerApplicationContext, ServletContext> servletContextAccessor,
			Class<?>... configuration) {
		try (AnnotationConfigReactiveWebServerApplicationContext context = new AnnotationConfigReactiveWebServerApplicationContext(
				configuration)) {
			Object serverContainer = servletContextAccessor.apply(context)
				.getAttribute('jakarta.websocket.server.ServerContainer');
			assertThat(serverContainer).isInstanceOf(ServerContainer.class);
		}
	}
	static Stream<Arguments> testConfiguration() {
		return Stream.of(Arguments.of('Jetty',
				(Function<AnnotationConfigReactiveWebServerApplicationContext, ServletContext>) WebSocketReactiveAutoConfigurationTests::getJettyServletContext,
				new Class<?>[] { JettyConfiguration.class,
						WebSocketReactiveAutoConfiguration.JettyWebSocketConfiguration.class }),
				Arguments.of('Tomcat',
						(Function<AnnotationConfigReactiveWebServerApplicationContext, ServletContext>) WebSocketReactiveAutoConfigurationTests::getTomcatServletContext,
						new Class<?>[] { TomcatConfiguration.class,
								WebSocketReactiveAutoConfiguration.TomcatWebSocketConfiguration.class }));
	}
	private static ServletContext getJettyServletContext(AnnotationConfigReactiveWebServerApplicationContext context) {
		return ((ServletContextHandler) ((JettyWebServer) context.getWebServer()).getServer().getHandler())
			.getServletContext();
	}
	private static ServletContext getTomcatServletContext(AnnotationConfigReactiveWebServerApplicationContext context) {
		return findContext(((TomcatWebServer) context.getWebServer()).getTomcat()).getServletContext();
	}
	private static Context findContext(Tomcat tomcat) {
		for (Container child : tomcat.getHost().findChildren()) {
			if (child instanceof Context context) {
				return context;
			}
		}
		throw new IllegalStateException('The host does not contain a Context');
	}
	@Configuration(proxyBeanMethods = false)
	static class CommonConfiguration {
		@Bean
		static WebServerFactoryCustomizerBeanPostProcessor webServerFactoryCustomizerBeanPostProcessor() {
			return new WebServerFactoryCustomizerBeanPostProcessor();
		}
		@Bean
		HttpHandler echoHandler() {
			return (request, response) -> response.writeWith(request.getBody());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TomcatConfiguration extends CommonConfiguration {
		@Bean
		ReactiveWebServerFactory webServerFactory() {
			TomcatReactiveWebServerFactory factory = new TomcatReactiveWebServerFactory();
			factory.setPort(0);
			return factory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JettyConfiguration extends CommonConfiguration {
		@Bean
		ReactiveWebServerFactory webServerFactory() {
			JettyReactiveWebServerFactory factory = new JettyReactiveWebServerFactory();
			factory.setPort(0);
			return factory;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jsonb;
/**
class JsonbAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JsonbAutoConfiguration.class));
	@Test
	void jsonbRegistration() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(Jsonb.class);
			Jsonb jsonb = context.getBean(Jsonb.class);
			assertThat(jsonb.toJson(new DataObject())).isEqualTo('{\'data\':\'hello\'}');
		});
	}
	public class DataObject {
		private String data = 'hello';
		public String getData() {
			return this.data;
		}
		public void setData(String data) {
			this.data = data;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jsonb;
/**
@ClassPathExclusions('yasson-*.jar')
class JsonbAutoConfigurationWithNoProviderTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JsonbAutoConfiguration.class));
	@Test
	void jsonbBacksOffWhenThereIsNoProvider() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(Jsonb.class));
	}
}
/*
package org.springframework.boot.autoconfigure.diagnostics.analyzer;
/**
class NoSuchBeanDefinitionFailureAnalyzerTests {
	private final AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
	private final NoSuchBeanDefinitionFailureAnalyzer analyzer = new NoSuchBeanDefinitionFailureAnalyzer(
			this.context.getBeanFactory());
	@Test
	void failureAnalysisForMultipleBeans() {
		FailureAnalysis analysis = analyzeFailure(new NoUniqueBeanDefinitionException(String.class, 2, 'Test'));
		assertThat(analysis).isNull();
	}
	@Test
	void failureAnalysisForNoMatchType() {
		FailureAnalysis analysis = analyzeFailure(createFailure(StringHandler.class));
		assertDescriptionConstructorMissingType(analysis, StringHandler.class, 0, String.class);
		assertThat(analysis.getDescription())
			.doesNotContain('No matching auto-configuration has been found for this type.');
		assertThat(analysis.getAction()).startsWith(
				String.format('Consider defining a bean of type "%s" in your configuration.', String.class.getName()));
	}
	@Test
	void failureAnalysisForMissingPropertyExactType() {
		FailureAnalysis analysis = analyzeFailure(createFailure(StringPropertyTypeConfiguration.class));
		assertDescriptionConstructorMissingType(analysis, StringHandler.class, 0, String.class);
		assertBeanMethodDisabled(analysis, 'did not find property "spring.string.enabled"',
				TestPropertyAutoConfiguration.class, 'string');
		assertActionMissingType(analysis, String.class);
	}
	@Test
	void failureAnalysisForMissingPropertySubType() {
		FailureAnalysis analysis = analyzeFailure(createFailure(IntegerPropertyTypeConfiguration.class));
		assertThat(analysis).isNotNull();
		assertDescriptionConstructorMissingType(analysis, NumberHandler.class, 0, Number.class);
		assertBeanMethodDisabled(analysis, 'did not find property "spring.integer.enabled"',
				TestPropertyAutoConfiguration.class, 'integer');
		assertActionMissingType(analysis, Number.class);
	}
	@Test
	void failureAnalysisForMissingClassOnAutoConfigurationType() {
		FailureAnalysis analysis = analyzeFailure(createFailure(MissingClassOnAutoConfigurationConfiguration.class));
		assertDescriptionConstructorMissingType(analysis, StringHandler.class, 0, String.class);
		assertClassDisabled(analysis, 'did not find required class "com.example.FooBar"', 'string',
				ClassUtils.getShortName(TestTypeClassAutoConfiguration.class));
		assertActionMissingType(analysis, String.class);
	}
	@Test
	void failureAnalysisForExcludedAutoConfigurationType() {
		FatalBeanException failure = createFailure(StringHandler.class);
		addExclusions(this.analyzer, TestPropertyAutoConfiguration.class);
		FailureAnalysis analysis = analyzeFailure(failure);
		assertDescriptionConstructorMissingType(analysis, StringHandler.class, 0, String.class);
		String configClass = ClassUtils.getShortName(TestPropertyAutoConfiguration.class.getName());
		assertClassDisabled(analysis, String.format('auto-configuration "%s" was excluded', configClass), 'string',
				ClassUtils.getShortName(TestPropertyAutoConfiguration.class));
		assertActionMissingType(analysis, String.class);
	}
	@Test
	void failureAnalysisForSeveralConditionsType() {
		FailureAnalysis analysis = analyzeFailure(createFailure(SeveralAutoConfigurationTypeConfiguration.class));
		assertDescriptionConstructorMissingType(analysis, StringHandler.class, 0, String.class);
		assertBeanMethodDisabled(analysis, 'did not find property "spring.string.enabled"',
				TestPropertyAutoConfiguration.class, 'string');
		assertClassDisabled(analysis, 'did not find required class "com.example.FooBar"', 'string',
				ClassUtils.getShortName(TestPropertyAutoConfiguration.class));
		assertActionMissingType(analysis, String.class);
	}
	@Test
	void failureAnalysisForNoMatchName() {
		FailureAnalysis analysis = analyzeFailure(createFailure(StringNameHandler.class));
		assertThat(analysis.getDescription())
			.startsWith(String.format('Constructor in %s required a bean named "%s" that could not be found',
					StringNameHandler.class.getName(), 'test-string'));
		assertThat(analysis.getAction())
			.startsWith(String.format('Consider defining a bean named "%s" in your configuration.', 'test-string'));
	}
	@Test
	void failureAnalysisForMissingBeanName() {
		FailureAnalysis analysis = analyzeFailure(createFailure(StringMissingBeanNameConfiguration.class));
		assertThat(analysis.getDescription())
			.startsWith(String.format('Constructor in %s required a bean named "%s" that could not be found',
					StringNameHandler.class.getName(), 'test-string'));
		assertBeanMethodDisabled(analysis,
				'@ConditionalOnBean (types: java.lang.Integer; SearchStrategy: all) did not find any beans',
				TestMissingBeanAutoConfiguration.class, 'string');
		assertActionMissingName(analysis, 'test-string');
	}
	@Test
	void failureAnalysisForNullBeanByType() {
		FailureAnalysis analysis = analyzeFailure(createFailure(StringNullBeanConfiguration.class));
		assertDescriptionConstructorMissingType(analysis, StringHandler.class, 0, String.class);
		assertUserDefinedBean(analysis, 'as the bean value is null', TestNullBeanConfiguration.class, 'string');
		assertActionMissingType(analysis, String.class);
	}
	@Test
	void failureAnalysisForUnmatchedQualifier() {
		FailureAnalysis analysis = analyzeFailure(createFailure(QualifiedBeanConfiguration.class));
		assertThat(analysis.getDescription())
			.containsPattern('@org.springframework.beans.factory.annotation.Qualifier\\(\'*alpha\'*\\)');
	}
	private void assertDescriptionConstructorMissingType(FailureAnalysis analysis, Class<?> component, int index,
			Class<?> type) {
		String expected = String.format(
				'Parameter %s of constructor in %s required a bean of type "%s" that could not be found.', index,
				component.getName(), type.getName());
		assertThat(analysis.getDescription()).startsWith(expected);
	}
	private void assertActionMissingType(FailureAnalysis analysis, Class<?> type) {
		assertThat(analysis.getAction()).startsWith(String.format(
				'Consider revisiting the entries above or defining a bean of type "%s" in your configuration.',
				type.getName()));
		assertThat(analysis.getAction()).doesNotContain('@ConstructorBinding');
	}
	private void assertActionMissingName(FailureAnalysis analysis, String name) {
		assertThat(analysis.getAction()).startsWith(String.format(
				'Consider revisiting the entries above or defining a bean named "%s" in your configuration.', name));
	}
	private void assertBeanMethodDisabled(FailureAnalysis analysis, String description, Class<?> target,
			String methodName) {
		String expected = String.format('Bean method "%s" in "%s" not loaded because', methodName,
				ClassUtils.getShortName(target));
		assertThat(analysis.getDescription()).contains(expected);
		assertThat(analysis.getDescription()).contains(description);
	}
	private void assertClassDisabled(FailureAnalysis analysis, String description, String methodName,
			String className) {
		String expected = String.format('Bean method "%s" in "%s" not loaded because', methodName, className);
		assertThat(analysis.getDescription()).contains(expected);
		assertThat(analysis.getDescription()).contains(description);
	}
	private void assertUserDefinedBean(FailureAnalysis analysis, String description, Class<?> target,
			String methodName) {
		String expected = String.format('User-defined bean method "%s" in "%s" ignored', methodName,
				ClassUtils.getShortName(target));
		assertThat(analysis.getDescription()).contains(expected);
		assertThat(analysis.getDescription()).contains(description);
	}
	private static void addExclusions(NoSuchBeanDefinitionFailureAnalyzer analyzer, Class<?>... classes) {
		ConditionEvaluationReport report = (ConditionEvaluationReport) ReflectionTestUtils.getField(analyzer, 'report');
		List<String> exclusions = new ArrayList<>(report.getExclusions());
		for (Class<?> c : classes) {
			exclusions.add(c.getName());
		}
		report.recordExclusions(exclusions);
	}
	private FatalBeanException createFailure(Class<?> config, String... environment) {
		try {
			TestPropertyValues.of(environment).applyTo(this.context);
			this.context.register(config);
			this.context.refresh();
			return null;
		}
		catch (FatalBeanException ex) {
			return ex;
		}
	}
	private FailureAnalysis analyzeFailure(Exception failure) {
		FailureAnalysis analysis = this.analyzer.analyze(failure);
		if (analysis != null) {
			new LoggingFailureAnalysisReporter().report(analysis);
		}
		return analysis;
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(TestPropertyAutoConfiguration.class)
	@Import(StringHandler.class)
	static class StringPropertyTypeConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(TestPropertyAutoConfiguration.class)
	@Import(NumberHandler.class)
	static class IntegerPropertyTypeConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(TestTypeClassAutoConfiguration.class)
	@Import(StringHandler.class)
	static class MissingClassOnAutoConfigurationConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration({ TestPropertyAutoConfiguration.class, TestTypeClassAutoConfiguration.class })
	@Import(StringHandler.class)
	static class SeveralAutoConfigurationTypeConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(TestMissingBeanAutoConfiguration.class)
	@Import(StringNameHandler.class)
	static class StringMissingBeanNameConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportAutoConfiguration(TestNullBeanConfiguration.class)
	@Import(StringHandler.class)
	static class StringNullBeanConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class TestPropertyAutoConfiguration {
		@ConditionalOnProperty('spring.string.enabled')
		@Bean
		String string() {
			return 'Test';
		}
		@ConditionalOnProperty('spring.integer.enabled')
		@Bean
		Integer integer() {
			return 42;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(name = 'com.example.FooBar')
	static class TestTypeClassAutoConfiguration {
		@Bean
		String string() {
			return 'Test';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestMissingBeanAutoConfiguration {
		@ConditionalOnBean(Integer.class)
		@Bean(name = 'test-string')
		String string() {
			return 'Test';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestNullBeanConfiguration {
		@Bean
		String string() {
			return null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class QualifiedBeanConfiguration {
		@Bean
		String consumer(@Qualifier('alpha') Thing thing) {
			return 'consumer';
		}
		@Bean
		Thing producer() {
			return new Thing();
		}
		class Thing {
		}
	}
	static class StringHandler {
		StringHandler(String foo) {
		}
	}
	static class NumberHandler {
		NumberHandler(Number foo) {
		}
	}
	static class StringNameHandler {
		StringNameHandler(BeanFactory beanFactory) {
			beanFactory.getBean('test-string');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
@ClassPathOverrides('org.liquibase:liquibase-core:4.23.1')
class Liquibase423AutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void defaultSpringLiquibase() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.run(assertLiquibase((liquibase) -> {
				assertThat(liquibase.getChangeLog()).isEqualTo('classpath:/db/changelog/db.changelog-master.yaml');
				assertThat(liquibase.getContexts()).isNull();
				assertThat(liquibase.getDefaultSchema()).isNull();
				assertThat(liquibase.isDropFirst()).isFalse();
				assertThat(liquibase.isClearCheckSums()).isFalse();
			}));
	}
	private ContextConsumer<AssertableApplicationContext> assertLiquibase(Consumer<SpringLiquibase> consumer) {
		return (context) -> {
			assertThat(context).hasSingleBean(SpringLiquibase.class);
			SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
			consumer.accept(liquibase);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
class LiquibasePropertiesTests {
	@Test
	void valuesOfShowSummaryMatchValuesOfUpdateSummaryEnum() {
		assertThat(namesOf(ShowSummary.values())).isEqualTo(namesOf(UpdateSummaryEnum.values()));
	}
	@Test
	void valuesOfShowSummaryOutputMatchValuesOfUpdateSummaryOutputEnum() {
		assertThat(namesOf(ShowSummaryOutput.values())).isEqualTo(namesOf(UpdateSummaryOutputEnum.values()));
	}
	@Test
	void valuesOfUiServiceMatchValuesOfUiServiceEnum() {
		assertThat(namesOf(UiService.values())).isEqualTo(namesOf(UIServiceEnum.values()));
	}
	private List<String> namesOf(Enum<?>[] input) {
		return Stream.of(input).map(Enum::name).toList();
	}
}
/*
package org.springframework.boot.autoconfigure.liquibase;
/**
@ExtendWith(OutputCaptureExtension.class)
class LiquibaseAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void backsOffWithNoDataSourceBeanAndNoLiquibaseUrl() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(SpringLiquibase.class));
	}
	@Test
	void createsDataSourceWithNoDataSourceBeanAndLiquibaseUrl() {
		String jdbcUrl = 'jdbc:hsqldb:mem:liquibase' + UUID.randomUUID();
		this.contextRunner.withPropertyValues('spring.liquibase.url:' + jdbcUrl).run(assertLiquibase((liquibase) -> {
			SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
			assertThat(dataSource.getUrl()).isEqualTo(jdbcUrl);
		}));
	}
	@Test
	void backsOffWithLiquibaseUrlAndNoSpringJdbc() {
		this.contextRunner.withPropertyValues('spring.liquibase.url:jdbc:hsqldb:mem:' + UUID.randomUUID())
			.withClassLoader(new FilteredClassLoader('org.springframework.jdbc'))
			.run((context) -> assertThat(context).doesNotHaveBean(SpringLiquibase.class));
	}
	@Test
	void defaultSpringLiquibase() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.run(assertLiquibase((liquibase) -> {
				assertThat(liquibase.getChangeLog()).isEqualTo('classpath:/db/changelog/db.changelog-master.yaml');
				assertThat(liquibase.getContexts()).isNull();
				assertThat(liquibase.getDefaultSchema()).isNull();
				assertThat(liquibase.isDropFirst()).isFalse();
				assertThat(liquibase.isClearCheckSums()).isFalse();
			}));
	}
	@Test
	void shouldUseMainDataSourceWhenThereIsNoLiquibaseSpecificConfiguration() {
		this.contextRunner.withSystemProperties('shouldRun=false')
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, JdbcConnectionDetailsConfiguration.class)
			.run((context) -> {
				SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
				assertThat(liquibase.getDataSource()).isSameAs(context.getBean(DataSource.class));
			});
	}
	@Test
	void liquibaseDataSourceIsUsedOverJdbcConnectionDetails() {
		this.contextRunner
			.withUserConfiguration(LiquibaseDataSourceConfiguration.class, JdbcConnectionDetailsConfiguration.class)
			.run(assertLiquibase((liquibase) -> {
				HikariDataSource dataSource = (HikariDataSource) liquibase.getDataSource();
				assertThat(dataSource.getJdbcUrl()).startsWith('jdbc:hsqldb:mem:liquibasetest');
				assertThat(dataSource.getUsername()).isEqualTo('sa');
				assertThat(dataSource.getPassword()).isNull();
			}));
	}
	@Test
	void liquibaseDataSourceIsUsedOverLiquibaseConnectionDetails() {
		this.contextRunner
			.withUserConfiguration(LiquibaseDataSourceConfiguration.class,
					LiquibaseConnectionDetailsConfiguration.class)
			.run(assertLiquibase((liquibase) -> {
				HikariDataSource dataSource = (HikariDataSource) liquibase.getDataSource();
				assertThat(dataSource.getJdbcUrl()).startsWith('jdbc:hsqldb:mem:liquibasetest');
				assertThat(dataSource.getUsername()).isEqualTo('sa');
				assertThat(dataSource.getPassword()).isNull();
			}));
	}
	@Test
	void liquibasePropertiesAreUsedOverJdbcConnectionDetails() {
		this.contextRunner
			.withPropertyValues('spring.liquibase.url=jdbc:hsqldb:mem:liquibasetest', 'spring.liquibase.user=some-user',
					'spring.liquibase.password=some-password',
					'spring.liquibase.driver-class-name=org.hsqldb.jdbc.JDBCDriver')
			.withUserConfiguration(JdbcConnectionDetailsConfiguration.class)
			.run(assertLiquibase((liquibase) -> {
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUrl()).startsWith('jdbc:hsqldb:mem:liquibasetest');
				assertThat(dataSource.getUsername()).isEqualTo('some-user');
				assertThat(dataSource.getPassword()).isEqualTo('some-password');
			}));
	}
	@Test
	void liquibaseConnectionDetailsAreUsedOverLiquibaseProperties() {
		this.contextRunner.withSystemProperties('shouldRun=false')
			.withPropertyValues('spring.liquibase.url=jdbc:hsqldb:mem:liquibasetest', 'spring.liquibase.user=some-user',
					'spring.liquibase.password=some-password',
					'spring.liquibase.driver-class-name=org.hsqldb.jdbc.JDBCDriver')
			.withUserConfiguration(LiquibaseConnectionDetailsConfiguration.class)
			.run(assertLiquibase((liquibase) -> {
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUrl()).isEqualTo('jdbc:postgresql://database.example.com:12345/database-1');
				assertThat(dataSource.getUsername()).isEqualTo('user-1');
				assertThat(dataSource.getPassword()).isEqualTo('secret-1');
			}));
	}
	@Test
	void changelogXml() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.change-log:classpath:/db/changelog/db.changelog-override.xml')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getChangeLog())
				.isEqualTo('classpath:/db/changelog/db.changelog-override.xml')));
	}
	@Test
	void changelogJson() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.change-log:classpath:/db/changelog/db.changelog-override.json')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getChangeLog())
				.isEqualTo('classpath:/db/changelog/db.changelog-override.json')));
	}
	@Test
	void changelogSql() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.change-log:classpath:/db/changelog/db.changelog-override.sql')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getChangeLog())
				.isEqualTo('classpath:/db/changelog/db.changelog-override.sql')));
	}
	@Test
	void defaultValues() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.run(assertLiquibase((liquibase) -> {
				LiquibaseProperties properties = new LiquibaseProperties();
				assertThat(liquibase.getDatabaseChangeLogTable()).isEqualTo(properties.getDatabaseChangeLogTable());
				assertThat(liquibase.getDatabaseChangeLogLockTable())
					.isEqualTo(properties.getDatabaseChangeLogLockTable());
				assertThat(liquibase.isDropFirst()).isEqualTo(properties.isDropFirst());
				assertThat(liquibase.isClearCheckSums()).isEqualTo(properties.isClearChecksums());
				assertThat(liquibase.isTestRollbackOnUpdate()).isEqualTo(properties.isTestRollbackOnUpdate());
				assertThat(liquibase).extracting('showSummary').isNull();
				assertThat(ShowSummaryArgument.SHOW_SUMMARY.getDefaultValue()).isEqualTo(UpdateSummaryEnum.SUMMARY);
				assertThat(liquibase).extracting('showSummaryOutput').isEqualTo(UpdateSummaryOutputEnum.LOG);
				assertThat(liquibase).extracting('uiService').isEqualTo(UIServiceEnum.LOGGER);
			}));
	}
	@Test
	void overrideContexts() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.contexts:test, production')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getContexts()).isEqualTo('test,production')));
	}
	@Test
	void overrideDefaultSchema() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.default-schema:public')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getDefaultSchema()).isEqualTo('public')));
	}
	@Test
	void overrideLiquibaseInfrastructure() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.liquibase-schema:public',
					'spring.liquibase.liquibase-tablespace:infra',
					'spring.liquibase.database-change-log-table:LIQUI_LOG',
					'spring.liquibase.database-change-log-lock-table:LIQUI_LOCK')
			.run((context) -> {
				SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
				assertThat(liquibase.getLiquibaseSchema()).isEqualTo('public');
				assertThat(liquibase.getLiquibaseTablespace()).isEqualTo('infra');
				assertThat(liquibase.getDatabaseChangeLogTable()).isEqualTo('LIQUI_LOG');
				assertThat(liquibase.getDatabaseChangeLogLockTable()).isEqualTo('LIQUI_LOCK');
				JdbcTemplate jdbcTemplate = new JdbcTemplate(context.getBean(DataSource.class));
				assertThat(jdbcTemplate.queryForObject('SELECT COUNT(*) FROM public.LIQUI_LOG', Integer.class)).isOne();
				assertThat(jdbcTemplate.queryForObject('SELECT COUNT(*) FROM public.LIQUI_LOCK', Integer.class))
					.isOne();
			});
	}
	@Test
	void overrideDropFirst() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.drop-first:true')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.isDropFirst()).isTrue()));
	}
	@Test
	void overrideClearChecksums() {
		String jdbcUrl = 'jdbc:hsqldb:mem:liquibase' + UUID.randomUUID();
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.url:' + jdbcUrl)
			.run((context) -> assertThat(context).hasNotFailed());
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.clear-checksums:true', 'spring.liquibase.url:' + jdbcUrl)
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.isClearCheckSums()).isTrue()));
	}
	@Test
	void overrideDataSource() {
		String jdbcUrl = 'jdbc:hsqldb:mem:liquibase' + UUID.randomUUID();
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.url:' + jdbcUrl)
			.run(assertLiquibase((liquibase) -> {
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUrl()).isEqualTo(jdbcUrl);
				assertThat(dataSource.getDriver().getClass().getName()).isEqualTo('org.hsqldb.jdbc.JDBCDriver');
			}));
	}
	@Test
	void overrideDataSourceAndDriverClassName() {
		String jdbcUrl = 'jdbc:hsqldb:mem:liquibase' + UUID.randomUUID();
		String driverClassName = 'org.hsqldb.jdbcDriver';
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.url:' + jdbcUrl,
					'spring.liquibase.driver-class-name:' + driverClassName)
			.run(assertLiquibase((liquibase) -> {
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUrl()).isEqualTo(jdbcUrl);
				assertThat(dataSource.getDriver().getClass().getName()).isEqualTo(driverClassName);
			}));
	}
	@Test
	void overrideUser() {
		String databaseName = 'normal' + UUID.randomUUID();
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.datasource.generate-unique-name:false',
					'spring.datasource.name:' + databaseName, 'spring.datasource.username:not-sa',
					'spring.liquibase.user:sa')
			.run(assertLiquibase((liquibase) -> {
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUrl()).contains('jdbc:h2:mem:' + databaseName);
				assertThat(dataSource.getUsername()).isEqualTo('sa');
			}));
	}
	@Test
	void overrideUserWhenCustom() {
		this.contextRunner.withUserConfiguration(CustomDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.user:test', 'spring.liquibase.password:secret')
			.run((context) -> {
				String expectedName = context.getBean(CustomDataSourceConfiguration.class).name;
				SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUrl()).contains(expectedName);
				assertThat(dataSource.getUsername()).isEqualTo('test');
			});
	}
	@Test
	void createDataSourceDoesNotFallbackToEmbeddedProperties() {
		String jdbcUrl = 'jdbc:hsqldb:mem:liquibase' + UUID.randomUUID();
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.url:' + jdbcUrl)
			.run(assertLiquibase((liquibase) -> {
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUsername()).isNull();
				assertThat(dataSource.getPassword()).isNull();
			}));
	}
	@Test
	void overrideUserAndFallbackToEmbeddedProperties() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.user:sa')
			.run(assertLiquibase((liquibase) -> {
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) liquibase.getDataSource();
				assertThat(dataSource.getUrl()).startsWith('jdbc:h2:mem:');
			}));
	}
	@Test
	void overrideTestRollbackOnUpdate() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.test-rollback-on-update:true')
			.run((context) -> {
				SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
				assertThat(liquibase.isTestRollbackOnUpdate()).isTrue();
			});
	}
	@Test
	void changeLogDoesNotExist() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.change-log:classpath:/no-such-changelog.yaml')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().isInstanceOf(BeanCreationException.class);
			});
	}
	@Test
	void logging(CapturedOutput output) {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.run(assertLiquibase((liquibase) -> assertThat(output).doesNotContain(': liquibase:')));
	}
	@Test
	void overrideLabelFilter() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.label-filter:test, production')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getLabelFilter()).isEqualTo('test,production')));
	}
	@Test
	void overrideShowSummary() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.show-summary=off')
			.run(assertLiquibase((liquibase) -> {
				UpdateSummaryEnum showSummary = (UpdateSummaryEnum) ReflectionTestUtils.getField(liquibase,
						'showSummary');
				assertThat(showSummary).isEqualTo(UpdateSummaryEnum.OFF);
			}));
	}
	@Test
	void overrideShowSummaryOutput() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.show-summary-output=all')
			.run(assertLiquibase((liquibase) -> {
				UpdateSummaryOutputEnum showSummaryOutput = (UpdateSummaryOutputEnum) ReflectionTestUtils
					.getField(liquibase, 'showSummaryOutput');
				assertThat(showSummaryOutput).isEqualTo(UpdateSummaryOutputEnum.ALL);
			}));
	}
	@Test
	void overrideUiService() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.ui-service=console')
			.run(assertLiquibase(
					(liquibase) -> assertThat(liquibase).extracting('uiService').isEqualTo(UIServiceEnum.CONSOLE)));
	}
	@Test
	@SuppressWarnings('unchecked')
	void testOverrideParameters() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.parameters.foo:bar')
			.run(assertLiquibase((liquibase) -> {
				Map<String, String> parameters = (Map<String, String>) ReflectionTestUtils.getField(liquibase,
						'parameters');
				assertThat(parameters).containsKey('foo');
				assertThat(parameters).containsEntry('foo', 'bar');
			}));
	}
	@Test
	void rollbackFile(@TempDir Path temp) throws IOException {
		File file = Files.createTempFile(temp, 'rollback-file', 'sql').toFile();
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.rollback-file:' + file.getAbsolutePath())
			.run((context) -> {
				SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
				File actualFile = (File) ReflectionTestUtils.getField(liquibase, 'rollbackFile');
				assertThat(actualFile).isEqualTo(file).exists();
				assertThat(contentOf(file)).contains('DROP TABLE PUBLIC.customer;');
			});
	}
	@Test
	void liquibaseDataSource() {
		this.contextRunner
			.withUserConfiguration(LiquibaseDataSourceConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
				assertThat(liquibase.getDataSource()).isEqualTo(context.getBean('liquibaseDataSource'));
			});
	}
	@Test
	void liquibaseDataSourceWithoutDataSourceAutoConfiguration() {
		this.contextRunner.withUserConfiguration(LiquibaseDataSourceConfiguration.class).run((context) -> {
			SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
			assertThat(liquibase.getDataSource()).isEqualTo(context.getBean('liquibaseDataSource'));
		});
	}
	@Test
	void userConfigurationBeans() {
		this.contextRunner
			.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasBean('springLiquibase');
				assertThat(context).doesNotHaveBean('liquibase');
			});
	}
	@Test
	void userConfigurationEntityManagerFactoryDependency() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(HibernateJpaAutoConfiguration.class))
			.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition('entityManagerFactory');
				assertThat(beanDefinition.getDependsOn()).containsExactly('springLiquibase');
			});
	}
	@Test
	void userConfigurationJdbcTemplateDependency() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JdbcTemplateAutoConfiguration.class))
			.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition('jdbcTemplate');
				assertThat(beanDefinition.getDependsOn()).containsExactly('springLiquibase');
			});
	}
	@Test
	void overrideTag() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.liquibase.tag:1.0.0')
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getTag()).isEqualTo('1.0.0')));
	}
	@Test
	void whenLiquibaseIsAutoConfiguredThenJooqDslContextDependsOnSpringLiquibaseBeans() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JooqAutoConfiguration.class))
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition('dslContext');
				assertThat(beanDefinition.getDependsOn()).containsExactly('liquibase');
			});
	}
	@Test
	void whenCustomSpringLiquibaseIsDefinedThenJooqDslContextDependsOnSpringLiquibaseBeans() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JooqAutoConfiguration.class))
			.withUserConfiguration(LiquibaseUserConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition('dslContext');
				assertThat(beanDefinition.getDependsOn()).containsExactly('springLiquibase');
			});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new LiquibaseAutoConfigurationRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('db/changelog/')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('db/changelog/db.changelog-master.yaml'))
			.accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('db/changelog/tables/init.sql')).accepts(hints);
	}
	@Test
	void whenCustomizerBeanIsDefinedThenItIsConfiguredOnSpringLiquibase() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomizerConfiguration.class)
			.run(assertLiquibase((liquibase) -> assertThat(liquibase.getCustomizer()).isNotNull()));
	}
	private ContextConsumer<AssertableApplicationContext> assertLiquibase(Consumer<SpringLiquibase> consumer) {
		return (context) -> {
			assertThat(context).hasSingleBean(SpringLiquibase.class);
			SpringLiquibase liquibase = context.getBean(SpringLiquibase.class);
			consumer.accept(liquibase);
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class LiquibaseDataSourceConfiguration {
		@Bean
		@Primary
		DataSource normalDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:normal' + UUID.randomUUID()).username('sa').build();
		}
		@LiquibaseDataSource
		@Bean
		DataSource liquibaseDataSource() {
			return DataSourceBuilder.create()
				.url('jdbc:hsqldb:mem:liquibasetest' + UUID.randomUUID())
				.username('sa')
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class LiquibaseUserConfiguration {
		@Bean
		SpringLiquibase springLiquibase(DataSource dataSource) {
			SpringLiquibase liquibase = new SpringLiquibase();
			liquibase.setChangeLog('classpath:/db/changelog/db.changelog-master.yaml');
			liquibase.setShouldRun(true);
			liquibase.setDataSource(dataSource);
			return liquibase;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDataSourceConfiguration {
		private final String name = UUID.randomUUID().toString();
		@Bean(destroyMethod = 'shutdown')
		EmbeddedDatabase dataSource() throws SQLException {
			EmbeddedDatabase database = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2)
				.setName(this.name)
				.build();
			insertUser(database);
			return database;
		}
		private void insertUser(EmbeddedDatabase database) throws SQLException {
			try (Connection connection = database.getConnection()) {
				connection.prepareStatement('CREATE USER test password "secret"').execute();
				connection.prepareStatement('ALTER USER test ADMIN TRUE').execute();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDriverConfiguration {
		private final String name = UUID.randomUUID().toString();
		@Bean
		SimpleDriverDataSource dataSource() {
			SimpleDriverDataSource dataSource = new SimpleDriverDataSource();
			dataSource.setDriverClass(CustomH2Driver.class);
			dataSource.setUrl(String.format('jdbc:h2:mem:%s;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=false', this.name));
			dataSource.setUsername('sa');
			dataSource.setPassword('');
			return dataSource;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JdbcConnectionDetailsConfiguration {
		@Bean
		JdbcConnectionDetails jdbcConnectionDetails() {
			return new JdbcConnectionDetails() {
				@Override
				public String getJdbcUrl() {
					return 'jdbc:postgresql://database.example.com:12345/database-1';
				}
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'secret-1';
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class LiquibaseConnectionDetailsConfiguration {
		@Bean
		LiquibaseConnectionDetails liquibaseConnectionDetails() {
			return new LiquibaseConnectionDetails() {
				@Override
				public String getJdbcUrl() {
					return 'jdbc:postgresql://database.example.com:12345/database-1';
				}
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'secret-1';
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomizerConfiguration {
		@Bean
		Customizer<Liquibase> customizer() {
			return (liquibase) -> liquibase.setChangeLogParameter('some key', 'some value');
		}
	}
	static class CustomH2Driver extends org.h2.Driver {
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class NativeImageResourceProviderCustomizerTests {
	private final NativeImageResourceProviderCustomizer customizer = new NativeImageResourceProviderCustomizer();
	@Test
	void shouldInstallNativeImageResourceProvider() {
		FluentConfiguration configuration = new FluentConfiguration();
		assertThat(configuration.getResourceProvider()).isNull();
		this.customizer.customize(configuration);
		assertThat(configuration.getResourceProvider()).isInstanceOf(NativeImageResourceProvider.class);
	}
	@Test
	void nativeImageResourceProviderShouldFindMigrations() {
		FluentConfiguration configuration = new FluentConfiguration();
		this.customizer.customize(configuration);
		ResourceProvider resourceProvider = configuration.getResourceProvider();
		Collection<LoadableResource> migrations = resourceProvider.getResources('V', new String[] { '.sql' });
		LoadableResource migration = resourceProvider.getResource('V1__init.sql');
		assertThat(migrations).containsExactly(migration);
	}
	@Test
	void shouldBackOffOnCustomResourceProvider() {
		FluentConfiguration configuration = new FluentConfiguration();
		configuration.resourceProvider(NoopResourceProvider.INSTANCE);
		this.customizer.customize(configuration);
		assertThat(configuration.getResourceProvider()).isEqualTo(NoopResourceProvider.INSTANCE);
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
@ExtendWith(OutputCaptureExtension.class)
class FlywayAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void backsOffWithNoDataSourceBeanAndNoFlywayUrl() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean(Flyway.class));
	}
	@Test
	void createsDataSourceWithNoDataSourceBeanAndFlywayUrl() {
		this.contextRunner.withPropertyValues('spring.flyway.url:jdbc:hsqldb:mem:' + UUID.randomUUID())
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource()).isNotNull();
			});
	}
	@Test
	void backsOffWithFlywayUrlAndNoSpringJdbc() {
		this.contextRunner.withPropertyValues('spring.flyway.url:jdbc:hsqldb:mem:' + UUID.randomUUID())
			.withClassLoader(new FilteredClassLoader('org.springframework.jdbc'))
			.run((context) -> assertThat(context).doesNotHaveBean(Flyway.class));
	}
	@Test
	void createDataSourceWithUrl() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.url:jdbc:hsqldb:mem:flywaytest')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource()).isNotNull();
			});
	}
	@Test
	void flywayPropertiesAreUsedOverJdbcConnectionDetails() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, JdbcConnectionDetailsConfiguration.class,
					MockFlywayMigrationStrategy.class)
			.withPropertyValues('spring.flyway.url=jdbc:hsqldb:mem:flywaytest', 'spring.flyway.user=some-user',
					'spring.flyway.password=some-password',
					'spring.flyway.driver-class-name=org.hsqldb.jdbc.JDBCDriver')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				DataSource dataSource = flyway.getConfiguration().getDataSource();
				assertThat(dataSource).isInstanceOf(SimpleDriverDataSource.class);
				SimpleDriverDataSource simpleDriverDataSource = (SimpleDriverDataSource) dataSource;
				assertThat(simpleDriverDataSource.getUrl()).isEqualTo('jdbc:hsqldb:mem:flywaytest');
				assertThat(simpleDriverDataSource.getUsername()).isEqualTo('some-user');
				assertThat(simpleDriverDataSource.getPassword()).isEqualTo('some-password');
				assertThat(simpleDriverDataSource.getDriver()).isInstanceOf(org.hsqldb.jdbc.JDBCDriver.class);
			});
	}
	@Test
	void flywayConnectionDetailsAreUsedOverFlywayProperties() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, FlywayConnectionDetailsConfiguration.class,
					MockFlywayMigrationStrategy.class)
			.withPropertyValues('spring.flyway.url=jdbc:hsqldb:mem:flywaytest', 'spring.flyway.user=some-user',
					'spring.flyway.password=some-password',
					'spring.flyway.driver-class-name=org.hsqldb.jdbc.JDBCDriver')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				DataSource dataSource = flyway.getConfiguration().getDataSource();
				assertThat(dataSource).isInstanceOf(SimpleDriverDataSource.class);
				SimpleDriverDataSource simpleDriverDataSource = (SimpleDriverDataSource) dataSource;
				assertThat(simpleDriverDataSource.getUrl())
					.isEqualTo('jdbc:postgresql://database.example.com:12345/database-1');
				assertThat(simpleDriverDataSource.getUsername()).isEqualTo('user-1');
				assertThat(simpleDriverDataSource.getPassword()).isEqualTo('secret-1');
				assertThat(simpleDriverDataSource.getDriver()).isInstanceOf(Driver.class);
			});
	}
	@Test
	void shouldUseMainDataSourceWhenThereIsNoFlywaySpecificConfiguration() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, JdbcConnectionDetailsConfiguration.class,
					MockFlywayMigrationStrategy.class)
			.withPropertyValues('spring.datasource.url=jdbc:hsqldb:mem:flywaytest', 'spring.datasource.user=some-user',
					'spring.datasource.password=some-password',
					'spring.datasource.driver-class-name=org.hsqldb.jdbc.JDBCDriver')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getDataSource()).isSameAs(context.getBean(DataSource.class));
			});
	}
	@Test
	void createDataSourceWithUser() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.datasource.url:jdbc:hsqldb:mem:' + UUID.randomUUID(), 'spring.flyway.user:sa')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource()).isNotNull();
			});
	}
	@Test
	void createDataSourceDoesNotFallbackToEmbeddedProperties() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.url:jdbc:hsqldb:mem:flywaytest')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				DataSource dataSource = context.getBean(Flyway.class).getConfiguration().getDataSource();
				assertThat(dataSource).isNotNull();
				assertThat(dataSource).hasFieldOrPropertyWithValue('username', null);
				assertThat(dataSource).hasFieldOrPropertyWithValue('password', null);
			});
	}
	@Test
	void createDataSourceWithUserAndFallbackToEmbeddedProperties() {
		this.contextRunner.withUserConfiguration(PropertiesBackedH2DataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.user:test', 'spring.flyway.password:secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				DataSource dataSource = context.getBean(Flyway.class).getConfiguration().getDataSource();
				assertThat(dataSource).isNotNull();
				assertThat(dataSource).extracting('url').asString().startsWith('jdbc:h2:mem:');
				assertThat(dataSource).extracting('username').asString().isEqualTo('test');
			});
	}
	@Test
	void createDataSourceWithUserAndCustomEmbeddedProperties() {
		this.contextRunner.withUserConfiguration(CustomBackedH2DataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.user:test', 'spring.flyway.password:secret')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				String expectedName = context.getBean(CustomBackedH2DataSourceConfiguration.class).name;
				String propertiesName = context.getBean(DataSourceProperties.class).determineDatabaseName();
				assertThat(expectedName).isNotEqualTo(propertiesName);
				DataSource dataSource = context.getBean(Flyway.class).getConfiguration().getDataSource();
				assertThat(dataSource).isNotNull();
				assertThat(dataSource).extracting('url').asString().startsWith('jdbc:h2:mem:').contains(expectedName);
				assertThat(dataSource).extracting('username').asString().isEqualTo('test');
			});
	}
	@Test
	void flywayDataSource() {
		this.contextRunner
			.withUserConfiguration(FlywayDataSourceConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource())
					.isEqualTo(context.getBean('flywayDataSource'));
			});
	}
	@Test
	void flywayDataSourceIsUsedWhenJdbcConnectionDetailsIsAvailable() {
		this.contextRunner
			.withUserConfiguration(FlywayDataSourceConfiguration.class, EmbeddedDataSourceConfiguration.class,
					JdbcConnectionDetailsConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(JdbcConnectionDetails.class);
				assertThat(context).hasSingleBean(Flyway.class);
				assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource())
					.isEqualTo(context.getBean('flywayDataSource'));
			});
	}
	@Test
	void flywayDataSourceIsUsedWhenFlywayConnectionDetailsIsAvailable() {
		this.contextRunner
			.withUserConfiguration(FlywayDataSourceConfiguration.class, EmbeddedDataSourceConfiguration.class,
					FlywayConnectionDetailsConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(FlywayConnectionDetails.class);
				assertThat(context).hasSingleBean(Flyway.class);
				assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource())
					.isEqualTo(context.getBean('flywayDataSource'));
			});
	}
	@Test
	void flywayDataSourceWithoutDataSourceAutoConfiguration() {
		this.contextRunner.withUserConfiguration(FlywayDataSourceConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Flyway.class);
			assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource())
				.isEqualTo(context.getBean('flywayDataSource'));
		});
	}
	@Test
	void flywayMultipleDataSources() {
		this.contextRunner.withUserConfiguration(FlywayMultipleDataSourcesConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Flyway.class);
			assertThat(context.getBean(Flyway.class).getConfiguration().getDataSource())
				.isEqualTo(context.getBean('flywayDataSource'));
		});
	}
	@Test
	void schemaManagementProviderDetectsDataSource() {
		this.contextRunner
			.withUserConfiguration(FlywayDataSourceConfiguration.class, EmbeddedDataSourceConfiguration.class)
			.run((context) -> {
				FlywaySchemaManagementProvider schemaManagementProvider = context
					.getBean(FlywaySchemaManagementProvider.class);
				assertThat(schemaManagementProvider
					.getSchemaManagement(context.getBean('normalDataSource', DataSource.class)))
					.isEqualTo(SchemaManagement.UNMANAGED);
				assertThat(schemaManagementProvider
					.getSchemaManagement(context.getBean('flywayDataSource', DataSource.class)))
					.isEqualTo(SchemaManagement.MANAGED);
			});
	}
	@Test
	void defaultFlyway() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Flyway.class);
			Flyway flyway = context.getBean(Flyway.class);
			assertThat(flyway.getConfiguration().getLocations())
				.containsExactly(new Location('classpath:db/migration'));
		});
	}
	@Test
	void overrideLocations() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.locations:classpath:db/changelog,classpath:db/migration')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getLocations())
					.containsExactly(new Location('classpath:db/changelog'), new Location('classpath:db/migration'));
			});
	}
	@Test
	void overrideLocationsList() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.locations[0]:classpath:db/changelog',
					'spring.flyway.locations[1]:classpath:db/migration')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getLocations())
					.containsExactly(new Location('classpath:db/changelog'), new Location('classpath:db/migration'));
			});
	}
	@Test
	void overrideSchemas() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.schemas:public')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(Arrays.asList(flyway.getConfiguration().getSchemas())).hasToString('[public]');
			});
	}
	@Test
	void overrideDataSourceAndDriverClassName() {
		String jdbcUrl = 'jdbc:hsqldb:mem:flyway' + UUID.randomUUID();
		String driverClassName = 'org.hsqldb.jdbcDriver';
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.url:' + jdbcUrl, 'spring.flyway.driver-class-name:' + driverClassName)
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				SimpleDriverDataSource dataSource = (SimpleDriverDataSource) flyway.getConfiguration().getDataSource();
				assertThat(dataSource.getUrl()).isEqualTo(jdbcUrl);
				assertThat(dataSource.getDriver().getClass().getName()).isEqualTo(driverClassName);
			});
	}
	@Test
	void changeLogDoesNotExist() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.fail-on-missing-locations=true',
					'spring.flyway.locations:filesystem:no-such-dir')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().isInstanceOf(BeanCreationException.class);
			});
	}
	@Test
	void failOnMissingLocationsAllMissing() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.fail-on-missing-locations=true')
			.withPropertyValues('spring.flyway.locations:classpath:db/missing1,classpath:db/migration2')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context).getFailure().isInstanceOf(BeanCreationException.class);
				assertThat(context).getFailure().hasMessageContaining('Unable to resolve location');
			});
	}
	@Test
	void failOnMissingLocationsAllExist() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.fail-on-missing-locations=true')
			.withPropertyValues('spring.flyway.locations:classpath:db/changelog,classpath:db/migration')
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void failOnMissingLocationsAllExistWithImplicitClasspathPrefix() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.fail-on-missing-locations=true')
			.withPropertyValues('spring.flyway.locations:db/changelog,db/migration')
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void failOnMissingLocationsAllExistWithFilesystemPrefix() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.fail-on-missing-locations=true')
			.withPropertyValues('spring.flyway.locations:filesystem:src/test/resources/db/migration')
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void customFlywayMigrationStrategy() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, MockFlywayMigrationStrategy.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				context.getBean(MockFlywayMigrationStrategy.class).assertCalled();
			});
	}
	@Test
	void flywayJavaMigrations() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, FlywayJavaMigrationsConfiguration.class)
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getJavaMigrations()).hasSize(2);
			});
	}
	@Test
	void customFlywayMigrationInitializer() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayMigrationInitializer.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				FlywayMigrationInitializer initializer = context.getBean(FlywayMigrationInitializer.class);
				assertThat(initializer.getOrder()).isEqualTo(Ordered.HIGHEST_PRECEDENCE);
			});
	}
	@Test
	void customFlywayWithJpa() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayWithJpaConfiguration.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void customFlywayWithJdbc() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CustomFlywayWithJdbcConfiguration.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void customFlywayMigrationInitializerWithJpa() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
					CustomFlywayMigrationInitializerWithJpaConfiguration.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void customFlywayMigrationInitializerWithJdbc() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class,
					CustomFlywayMigrationInitializerWithJdbcConfiguration.class)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void overrideBaselineVersionString() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.baseline-version=0')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getBaselineVersion()).isEqualTo(MigrationVersion.fromVersion('0'));
			});
	}
	@Test
	void overrideBaselineVersionNumber() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.baseline-version=1')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getBaselineVersion()).isEqualTo(MigrationVersion.fromVersion('1'));
			});
	}
	@Test
	void useVendorDirectory() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.locations=classpath:db/vendors/{vendor},classpath:db/changelog')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getLocations()).containsExactlyInAnyOrder(
						new Location('classpath:db/vendors/h2'), new Location('classpath:db/changelog'));
			});
	}
	@Test
	void useOneLocationWithVendorDirectory() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.locations=classpath:db/vendors/{vendor}')
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getLocations())
					.containsExactly(new Location('classpath:db/vendors/h2'));
			});
	}
	@Test
	void callbacksAreConfiguredAndOrderedByName() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, CallbackConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				Callback callbackOne = context.getBean('callbackOne', Callback.class);
				Callback callbackTwo = context.getBean('callbackTwo', Callback.class);
				assertThat(flyway.getConfiguration().getCallbacks()).hasSize(2);
				InOrder orderedCallbacks = inOrder(callbackOne, callbackTwo);
				orderedCallbacks.verify(callbackTwo).handle(any(Event.class), any(Context.class));
				orderedCallbacks.verify(callbackOne).handle(any(Event.class), any(Context.class));
			});
	}
	@Test
	void configurationCustomizersAreConfiguredAndOrdered() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, ConfigurationCustomizerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getConnectRetries()).isEqualTo(5);
				assertThat(flyway.getConfiguration().getBaselineDescription()).isEqualTo('<< Custom baseline >>');
				assertThat(flyway.getConfiguration().getBaselineVersion()).isEqualTo(MigrationVersion.fromVersion('1'));
			});
	}
	@Test
	void callbackAndMigrationBeansAreAppliedToConfigurationBeforeCustomizersAreCalled() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, FlywayJavaMigrationsConfiguration.class,
					CallbackConfiguration.class)
			.withBean(FlywayConfigurationCustomizer.class, () -> (configuration) -> {
				assertThat(configuration.getCallbacks()).isNotEmpty();
				assertThat(configuration.getJavaMigrations()).isNotEmpty();
			})
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void batchIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.batch=true')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getModernConfig().getFlyway().getBatch()).isTrue();
			});
	}
	@Test
	void dryRunOutputIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.dryRunOutput=dryrun.sql')
			.run(validateFlywayTeamsPropertyOnly('dryRunOutput'));
	}
	@Test
	void errorOverridesIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.errorOverrides=D12345')
			.run(validateFlywayTeamsPropertyOnly('errorOverrides'));
	}
	@Test
	void oracleExtensionIsNotLoadedByDefault() {
		FluentConfiguration configuration = mock(FluentConfiguration.class);
		new OracleFlywayConfigurationCustomizer(new FlywayProperties()).customize(configuration);
		then(configuration).shouldHaveNoInteractions();
	}
	@Test
	void oracleSqlplusIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle.sqlplus=true')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getSqlplus()).isTrue());
	}
	@Test
	@Deprecated(since = '3.2.0', forRemoval = true)
	void oracleSqlplusIsCorrectlyMappedWithDeprecatedProperty() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle-sqlplus=true')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getSqlplus()).isTrue());
	}
	@Test
	void oracleSqlplusWarnIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle.sqlplus-warn=true')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getSqlplusWarn()).isTrue());
	}
	@Test
	@Deprecated(since = '3.2.0', forRemoval = true)
	void oracleSqlplusWarnIsCorrectlyMappedWithDeprecatedProperty() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle-sqlplus-warn=true')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getSqlplusWarn()).isTrue());
	}
	@Test
	void oracleWallerLocationIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle.wallet-location=/tmp/my.wallet')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getWalletLocation()).isEqualTo('/tmp/my.wallet'));
	}
	@Test
	@Deprecated(since = '3.2.0', forRemoval = true)
	void oracleWallerLocationIsCorrectlyMappedWithDeprecatedProperty() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle-wallet-location=/tmp/my.wallet')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getWalletLocation()).isEqualTo('/tmp/my.wallet'));
	}
	@Test
	void oracleKerberosCacheFileIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle.kerberos-cache-file=/tmp/cache')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getKerberosCacheFile()).isEqualTo('/tmp/cache'));
	}
	@Test
	@Deprecated(since = '3.2.0', forRemoval = true)
	void oracleKerberosCacheFileIsCorrectlyMappedWithDeprecatedProperty() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.oracle-kerberos-cache-file=/tmp/cache')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(OracleConfigurationExtension.class)
				.getKerberosCacheFile()).isEqualTo('/tmp/cache'));
	}
	@Test
	void streamIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.stream=true')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getModernConfig().getFlyway().getStream()).isTrue();
			});
	}
	@Test
	void customFlywayClassLoader() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, ResourceLoaderConfiguration.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(Flyway.class);
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getClassLoader()).isInstanceOf(CustomClassLoader.class);
			});
	}
	@Test
	void initSqlsWithDataSource() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.init-sqls=SELECT 1')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getInitSql()).isEqualTo('SELECT 1');
			});
	}
	@Test
	void initSqlsWithFlywayUrl() {
		this.contextRunner
			.withPropertyValues('spring.flyway.url:jdbc:h2:mem:' + UUID.randomUUID(),
					'spring.flyway.init-sqls=SELECT 1')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getInitSql()).isEqualTo('SELECT 1');
			});
	}
	@Test
	void jdbcPropertiesAreCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.jdbc-properties.prop=value')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration()
					.getCachedResolvedEnvironments()
					.get(flyway.getConfiguration().getCurrentEnvironmentName())
					.getJdbcProperties()).containsEntry('prop', 'value');
			});
	}
	@Test
	void kerberosConfigFileIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.kerberos-config-file=/tmp/config')
			.run(validateFlywayTeamsPropertyOnly('kerberosConfigFile'));
	}
	@Test
	void outputQueryResultsIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.output-query-results=false')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getModernConfig().getFlyway().getOutputQueryResults()).isFalse();
			});
	}
	@Test
	void postgresqlExtensionIsNotLoadedByDefault() {
		FluentConfiguration configuration = mock(FluentConfiguration.class);
		new PostgresqlFlywayConfigurationCustomizer(new FlywayProperties()).customize(configuration);
		then(configuration).shouldHaveNoInteractions();
	}
	@Test
	void postgresqlTransactionalLockIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.postgresql.transactional-lock=false')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(PostgreSQLConfigurationExtension.class)
				.isTransactionalLock()).isFalse());
	}
	@Test
	void sqlServerExtensionIsNotLoadedByDefault() {
		FluentConfiguration configuration = mock(FluentConfiguration.class);
		new SqlServerFlywayConfigurationCustomizer(new FlywayProperties()).customize(configuration);
		then(configuration).shouldHaveNoInteractions();
	}
	@Test
	void sqlServerKerberosLoginFileIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.sqlserver.kerberos-login-file=/tmp/config')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(SQLServerConfigurationExtension.class)
				.getKerberos()
				.getLogin()
				.getFile()).isEqualTo('/tmp/config'));
	}
	@Test
	@Deprecated(since = '3.2.0', forRemoval = true)
	void sqlServerKerberosLoginFileIsCorrectlyMappedWithDeprecatedProperty() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.sql-server-kerberos-login-file=/tmp/config')
			.run((context) -> assertThat(context.getBean(Flyway.class)
				.getConfiguration()
				.getPluginRegister()
				.getPlugin(SQLServerConfigurationExtension.class)
				.getKerberos()
				.getLogin()
				.getFile()).isEqualTo('/tmp/config'));
	}
	@Test
	void skipExecutingMigrationsIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.skip-executing-migrations=true')
			.run((context) -> {
				Flyway flyway = context.getBean(Flyway.class);
				assertThat(flyway.getConfiguration().getModernConfig().getFlyway().getSkipExecutingMigrations())
					.isTrue();
			});
	}
	@Test
	void whenFlywayIsAutoConfiguredThenJooqDslContextDependsOnFlywayBeans() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class, JooqConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition('dslContext');
				assertThat(beanDefinition.getDependsOn()).containsExactlyInAnyOrder('flywayInitializer', 'flyway');
			});
	}
	@Test
	void whenCustomMigrationInitializerIsDefinedThenJooqDslContextDependsOnIt() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, JooqConfiguration.class,
					CustomFlywayMigrationInitializer.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition('dslContext');
				assertThat(beanDefinition.getDependsOn()).containsExactlyInAnyOrder('flywayMigrationInitializer',
						'flyway');
			});
	}
	@Test
	void whenCustomFlywayIsDefinedThenJooqDslContextDependsOnIt() {
		this.contextRunner
			.withUserConfiguration(EmbeddedDataSourceConfiguration.class, JooqConfiguration.class, CustomFlyway.class)
			.run((context) -> {
				BeanDefinition beanDefinition = context.getBeanFactory().getBeanDefinition('dslContext');
				assertThat(beanDefinition.getDependsOn()).containsExactlyInAnyOrder('customFlyway');
			});
	}
	@Test
	void scriptPlaceholderPrefixIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.script-placeholder-prefix=SPP')
			.run((context) -> assertThat(context.getBean(Flyway.class).getConfiguration().getScriptPlaceholderPrefix())
				.isEqualTo('SPP'));
	}
	@Test
	void scriptPlaceholderSuffixIsCorrectlyMapped() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.script-placeholder-suffix=SPS')
			.run((context) -> assertThat(context.getBean(Flyway.class).getConfiguration().getScriptPlaceholderSuffix())
				.isEqualTo('SPS'));
	}
	@Test
	void containsResourceProviderCustomizer() {
		this.contextRunner.withPropertyValues('spring.flyway.url:jdbc:hsqldb:mem:' + UUID.randomUUID())
			.run((context) -> assertThat(context).hasSingleBean(ResourceProviderCustomizer.class));
	}
	@Test
	void loggers() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.run((context) -> assertThat(context.getBean(Flyway.class).getConfiguration().getLoggers())
				.containsExactly('slf4j'));
	}
	@Test
	void overrideLoggers() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class)
			.withPropertyValues('spring.flyway.loggers=log4j2')
			.run((context) -> assertThat(context.getBean(Flyway.class).getConfiguration().getLoggers())
				.containsExactly('log4j2'));
	}
	@Test
	void shouldRegisterResourceHints() {
		RuntimeHints runtimeHints = new RuntimeHints();
		new FlywayAutoConfigurationRuntimeHints().registerHints(runtimeHints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('db/migration/')).accepts(runtimeHints);
		assertThat(RuntimeHintsPredicates.resource().forResource('db/migration/V1__init.sql')).accepts(runtimeHints);
	}
	private ContextConsumer<AssertableApplicationContext> validateFlywayTeamsPropertyOnly(String propertyName) {
		return (context) -> {
			assertThat(context).hasFailed();
			Throwable failure = context.getStartupFailure();
			assertThat(failure).hasRootCauseInstanceOf(FlywayEditionUpgradeRequiredException.class);
			assertThat(failure).hasMessageContaining(String.format(' %s ', propertyName));
		};
	}
	@Configuration(proxyBeanMethods = false)
	static class FlywayDataSourceConfiguration {
		@Bean
		DataSource normalDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:normal').username('sa').build();
		}
		@FlywayDataSource
		@Bean(defaultCandidate = false)
		DataSource flywayDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:flywaytest').username('sa').build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FlywayMultipleDataSourcesConfiguration {
		@Bean
		DataSource firstDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:first').username('sa').build();
		}
		@Bean
		DataSource secondDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:second').username('sa').build();
		}
		@FlywayDataSource
		@Bean(defaultCandidate = false)
		DataSource flywayDataSource() {
			return DataSourceBuilder.create().url('jdbc:hsqldb:mem:flywaytest').username('sa').build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FlywayJavaMigrationsConfiguration {
		@Bean
		TestMigration migration1() {
			return new TestMigration('2', 'M1');
		}
		@Bean
		TestMigration migration2() {
			return new TestMigration('3', 'M2');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ResourceLoaderConfiguration {
		@Bean
		@Primary
		ResourceLoader customClassLoader() {
			return new DefaultResourceLoader(new CustomClassLoader(getClass().getClassLoader()));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomFlywayMigrationInitializer {
		@Bean
		FlywayMigrationInitializer flywayMigrationInitializer(Flyway flyway) {
			FlywayMigrationInitializer initializer = new FlywayMigrationInitializer(flyway);
			initializer.setOrder(Ordered.HIGHEST_PRECEDENCE);
			return initializer;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomFlyway {
		@Bean
		Flyway customFlyway() {
			return Flyway.configure().load();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomFlywayMigrationInitializerWithJpaConfiguration {
		@Bean
		FlywayMigrationInitializer customFlywayMigrationInitializer(Flyway flyway) {
			return new FlywayMigrationInitializer(flyway);
		}
		@Bean
		LocalContainerEntityManagerFactoryBean entityManagerFactoryBean(DataSource dataSource) {
			Map<String, Object> properties = new HashMap<>();
			properties.put('configured', 'manually');
			properties.put('hibernate.transaction.jta.platform', NoJtaPlatform.INSTANCE);
			return new EntityManagerFactoryBuilder(new HibernateJpaVendorAdapter(), properties, null)
				.dataSource(dataSource)
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomFlywayWithJpaConfiguration {
		private final DataSource dataSource;
		protected CustomFlywayWithJpaConfiguration(DataSource dataSource) {
			this.dataSource = dataSource;
		}
		@Bean
		Flyway customFlyway() {
			return Flyway.configure().load();
		}
		@Bean
		LocalContainerEntityManagerFactoryBean entityManagerFactoryBean() {
			Map<String, Object> properties = new HashMap<>();
			properties.put('configured', 'manually');
			properties.put('hibernate.transaction.jta.platform', NoJtaPlatform.INSTANCE);
			return new EntityManagerFactoryBuilder(new HibernateJpaVendorAdapter(), properties, null)
				.dataSource(this.dataSource)
				.build();
		}
	}
	@Configuration
	static class CustomFlywayWithJdbcConfiguration {
		private final DataSource dataSource;
		protected CustomFlywayWithJdbcConfiguration(DataSource dataSource) {
			this.dataSource = dataSource;
		}
		@Bean
		Flyway customFlyway() {
			return Flyway.configure().load();
		}
		@Bean
		JdbcOperations jdbcOperations() {
			return new JdbcTemplate(this.dataSource);
		}
		@Bean
		NamedParameterJdbcOperations namedParameterJdbcOperations() {
			return new NamedParameterJdbcTemplate(this.dataSource);
		}
	}
	@Configuration
	protected static class CustomFlywayMigrationInitializerWithJdbcConfiguration {
		private final DataSource dataSource;
		protected CustomFlywayMigrationInitializerWithJdbcConfiguration(DataSource dataSource) {
			this.dataSource = dataSource;
		}
		@Bean
		public FlywayMigrationInitializer customFlywayMigrationInitializer(Flyway flyway) {
			return new FlywayMigrationInitializer(flyway);
		}
		@Bean
		public JdbcOperations jdbcOperations() {
			return new JdbcTemplate(this.dataSource);
		}
		@Bean
		public NamedParameterJdbcOperations namedParameterJdbcOperations() {
			return new NamedParameterJdbcTemplate(this.dataSource);
		}
	}
	@Component
	static class MockFlywayMigrationStrategy implements FlywayMigrationStrategy {
		private boolean called = false;
		@Override
		public void migrate(Flyway flyway) {
			this.called = true;
		}
		void assertCalled() {
			assertThat(this.called).isTrue();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CallbackConfiguration {
		@Bean
		Callback callbackOne() {
			return mockCallback('b');
		}
		@Bean
		Callback callbackTwo() {
			return mockCallback('a');
		}
		private Callback mockCallback(String name) {
			Callback callback = mock(Callback.class);
			given(callback.supports(any(Event.class), any(Context.class))).willReturn(true);
			given(callback.getCallbackName()).willReturn(name);
			return callback;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigurationCustomizerConfiguration {
		@Bean
		@Order(1)
		FlywayConfigurationCustomizer customizerOne() {
			return (configuration) -> configuration.connectRetries(5).baselineVersion('1');
		}
		@Bean
		@Order(0)
		FlywayConfigurationCustomizer customizerTwo() {
			return (configuration) -> configuration.connectRetries(10).baselineDescription('<< Custom baseline >>');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JooqConfiguration {
		@Bean
		DSLContext dslContext() {
			return new DefaultDSLContext(SQLDialect.H2);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(DataSourceProperties.class)
	abstract static class AbstractUserH2DataSourceConfiguration {
		@Bean(destroyMethod = 'shutdown')
		EmbeddedDatabase dataSource(DataSourceProperties properties) throws SQLException {
			EmbeddedDatabase database = new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseType.H2)
				.setName(getDatabaseName(properties))
				.build();
			insertUser(database);
			return database;
		}
		protected abstract String getDatabaseName(DataSourceProperties properties);
		private void insertUser(EmbeddedDatabase database) throws SQLException {
			try (Connection connection = database.getConnection()) {
				connection.prepareStatement('CREATE USER test password "secret"').execute();
				connection.prepareStatement('ALTER USER test ADMIN TRUE').execute();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PropertiesBackedH2DataSourceConfiguration extends AbstractUserH2DataSourceConfiguration {
		@Override
		protected String getDatabaseName(DataSourceProperties properties) {
			return properties.determineDatabaseName();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomBackedH2DataSourceConfiguration extends AbstractUserH2DataSourceConfiguration {
		private final String name = UUID.randomUUID().toString();
		@Override
		protected String getDatabaseName(DataSourceProperties properties) {
			return this.name;
		}
	}
	static final class CustomClassLoader extends ClassLoader {
		private CustomClassLoader(ClassLoader parent) {
			super(parent);
		}
	}
	private static final class TestMigration implements JavaMigration {
		private final MigrationVersion version;
		private final String description;
		private TestMigration(String version, String description) {
			this.version = MigrationVersion.fromVersion(version);
			this.description = description;
		}
		@Override
		public MigrationVersion getVersion() {
			return this.version;
		}
		@Override
		public String getDescription() {
			return this.description;
		}
		@Override
		public Integer getChecksum() {
			return 1;
		}
		@Override
		public boolean canExecuteInTransaction() {
			return true;
		}
		@Override
		public void migrate(org.flywaydb.core.api.migration.Context context) {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JdbcConnectionDetailsConfiguration {
		@Bean
		JdbcConnectionDetails jdbcConnectionDetails() {
			return new JdbcConnectionDetails() {
				@Override
				public String getJdbcUrl() {
					return 'jdbc:postgresql://database.example.com:12345/database-1';
				}
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'secret-1';
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FlywayConnectionDetailsConfiguration {
		@Bean
		FlywayConnectionDetails flywayConnectionDetails() {
			return new FlywayConnectionDetails() {
				@Override
				public String getJdbcUrl() {
					return 'jdbc:postgresql://database.example.com:12345/database-1';
				}
				@Override
				public String getUsername() {
					return 'user-1';
				}
				@Override
				public String getPassword() {
					return 'secret-1';
				}
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class ResourceProviderCustomizerBeanRegistrationAotProcessorTests {
	private final DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory();
	private final ResourceProviderCustomizerBeanRegistrationAotProcessor processor = new ResourceProviderCustomizerBeanRegistrationAotProcessor();
	@Test
	void beanRegistrationAotProcessorIsRegistered() {
		assertThat(AotServices.factories().load(BeanRegistrationAotProcessor.class))
			.anyMatch(ResourceProviderCustomizerBeanRegistrationAotProcessor.class::isInstance);
	}
	@Test
	void shouldIgnoreNonResourceProviderCustomizerBeans() {
		RootBeanDefinition beanDefinition = new RootBeanDefinition(String.class);
		this.beanFactory.registerBeanDefinition('test', beanDefinition);
		BeanRegistrationAotContribution contribution = this.processor
			.processAheadOfTime(RegisteredBean.of(this.beanFactory, 'test'));
		assertThat(contribution).isNull();
	}
	@Test
	@CompileWithForkedClassLoader
	void shouldReplaceResourceProviderCustomizer() {
		compile(createContext(ResourceProviderCustomizerConfiguration.class), (freshContext) -> {
			freshContext.refresh();
			ResourceProviderCustomizer bean = freshContext.getBean(ResourceProviderCustomizer.class);
			assertThat(bean).isInstanceOf(NativeImageResourceProviderCustomizer.class);
		});
	}
	private GenericApplicationContext createContext(Class<?>... types) {
		GenericApplicationContext context = new AnnotationConfigApplicationContext();
		Arrays.stream(types).forEach((type) -> context.registerBean(type));
		return context;
	}
	@SuppressWarnings('unchecked')
	private void compile(GenericApplicationContext context, Consumer<GenericApplicationContext> freshContext) {
		TestGenerationContext generationContext = new TestGenerationContext(TestTarget.class);
		ClassName className = new ApplicationContextAotGenerator().processAheadOfTime(context, generationContext);
		generationContext.writeGeneratedContent();
		TestCompiler.forSystem().with(generationContext).compile((compiled) -> {
			GenericApplicationContext freshApplicationContext = new GenericApplicationContext();
			ApplicationContextInitializer<GenericApplicationContext> initializer = compiled
				.getInstance(ApplicationContextInitializer.class, className.toString());
			initializer.initialize(freshApplicationContext);
			freshContext.accept(freshApplicationContext);
		});
	}
	static class TestTarget {
	}
	@Configuration(proxyBeanMethods = false)
	static class ResourceProviderCustomizerConfiguration {
		@Bean
		ResourceProviderCustomizer resourceProviderCustomizer() {
			return new ResourceProviderCustomizer();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
@ClassPathExclusions({ 'flyway-core-*.jar', 'flyway-sqlserver-*.jar' })
@ClassPathOverrides({ 'org.flywaydb:flyway-core:10.0.0', 'com.h2database:h2:2.1.210' })
class Flyway100AutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
		.withPropertyValues('spring.datasource.generate-unique-name=true');
	@Test
	void defaultFlyway() {
		this.contextRunner.withUserConfiguration(EmbeddedDataSourceConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(Flyway.class);
			Flyway flyway = context.getBean(Flyway.class);
			assertThat(flyway.getConfiguration().getLocations())
				.containsExactly(new Location('classpath:db/migration'));
		});
	}
}
/*
package org.springframework.boot.autoconfigure.flyway;
/**
class FlywayPropertiesTests {
	@Test
	@SuppressWarnings('removal')
	void defaultValuesAreConsistent() {
		FlywayProperties properties = new FlywayProperties();
		Configuration configuration = new FluentConfiguration();
		assertThat(properties.isFailOnMissingLocations()).isEqualTo(configuration.isFailOnMissingLocations());
		assertThat(properties.getLocations().stream().map(Location::new).toArray(Location[]::new))
			.isEqualTo(configuration.getLocations());
		assertThat(properties.getEncoding()).isEqualTo(configuration.getEncoding());
		assertThat(properties.getConnectRetries()).isEqualTo(configuration.getConnectRetries());
		assertThat(properties.getConnectRetriesInterval()).extracting(Duration::getSeconds)
			.extracting(Long::intValue)
			.isEqualTo(configuration.getConnectRetriesInterval());
		assertThat(properties.getLockRetryCount()).isEqualTo(configuration.getLockRetryCount());
		assertThat(properties.getDefaultSchema()).isEqualTo(configuration.getDefaultSchema());
		assertThat(properties.getSchemas()).isEqualTo(Arrays.asList(configuration.getSchemas()));
		assertThat(properties.isCreateSchemas()).isEqualTo(configuration.isCreateSchemas());
		assertThat(properties.getTable()).isEqualTo(configuration.getTable());
		assertThat(properties.getBaselineDescription()).isEqualTo(configuration.getBaselineDescription());
		assertThat(MigrationVersion.fromVersion(properties.getBaselineVersion()))
			.isEqualTo(configuration.getBaselineVersion());
		assertThat(properties.getInstalledBy()).isEqualTo(configuration.getInstalledBy());
		assertThat(properties.getPlaceholders()).isEqualTo(configuration.getPlaceholders());
		assertThat(properties.getPlaceholderPrefix()).isEqualToIgnoringWhitespace(configuration.getPlaceholderPrefix());
		assertThat(properties.getPlaceholderSuffix()).isEqualTo(configuration.getPlaceholderSuffix());
		assertThat(properties.isPlaceholderReplacement()).isEqualTo(configuration.isPlaceholderReplacement());
		assertThat(properties.getSqlMigrationPrefix()).isEqualTo(configuration.getSqlMigrationPrefix());
		assertThat(properties.getSqlMigrationSuffixes()).containsExactly(configuration.getSqlMigrationSuffixes());
		assertThat(properties.getSqlMigrationSeparator()).isEqualTo(configuration.getSqlMigrationSeparator());
		assertThat(properties.getRepeatableSqlMigrationPrefix())
			.isEqualTo(configuration.getRepeatableSqlMigrationPrefix());
		assertThat(MigrationVersion.fromVersion(properties.getTarget())).isEqualTo(configuration.getTarget());
		assertThat(configuration.getInitSql()).isNull();
		assertThat(properties.getInitSqls()).isEmpty();
		assertThat(properties.isBaselineOnMigrate()).isEqualTo(configuration.isBaselineOnMigrate());
		assertThat(properties.isCleanDisabled()).isEqualTo(configuration.isCleanDisabled());
		assertThat(properties.isCleanOnValidationError()).isEqualTo(configuration.isCleanOnValidationError());
		assertThat(properties.isGroup()).isEqualTo(configuration.isGroup());
		assertThat(properties.isMixed()).isEqualTo(configuration.isMixed());
		assertThat(properties.isOutOfOrder()).isEqualTo(configuration.isOutOfOrder());
		assertThat(properties.isSkipDefaultCallbacks()).isEqualTo(configuration.isSkipDefaultCallbacks());
		assertThat(properties.isSkipDefaultResolvers()).isEqualTo(configuration.isSkipDefaultResolvers());
		assertThat(properties.isValidateMigrationNaming()).isEqualTo(configuration.isValidateMigrationNaming());
		assertThat(properties.isValidateOnMigrate()).isEqualTo(configuration.isValidateOnMigrate());
		assertThat(properties.getDetectEncoding()).isNull();
		assertThat(properties.getPlaceholderSeparator()).isEqualTo(configuration.getPlaceholderSeparator());
		assertThat(properties.getScriptPlaceholderPrefix()).isEqualTo(configuration.getScriptPlaceholderPrefix());
		assertThat(properties.getScriptPlaceholderSuffix()).isEqualTo(configuration.getScriptPlaceholderSuffix());
		assertThat(properties.isExecuteInTransaction()).isEqualTo(configuration.isExecuteInTransaction());
		assertThat(properties.getCommunityDbSupportEnabled()).isNull();
	}
	@Test
	void loggersIsOverriddenToSlf4j() {
		assertThat(new FluentConfiguration().getLoggers()).containsExactly('auto');
		assertThat(new FlywayProperties().getLoggers()).containsExactly('slf4j');
	}
	@Test
	void expectedPropertiesAreManaged() {
		Map<String, PropertyDescriptor> properties = indexProperties(
				PropertyAccessorFactory.forBeanPropertyAccess(new FlywayProperties()));
		Map<String, PropertyDescriptor> configuration = indexProperties(
				PropertyAccessorFactory.forBeanPropertyAccess(new ClassicConfiguration()));
		// Properties specific settings
		ignoreProperties(properties, 'url', 'driverClassName', 'user', 'password', 'enabled');
		// Deprecated properties
		ignoreProperties(properties, 'oracleKerberosCacheFile', 'oracleSqlplus', 'oracleSqlplusWarn',
				'oracleWalletLocation', 'sqlServerKerberosLoginFile');
		// Properties that are managed by specific extensions
		ignoreProperties(properties, 'oracle', 'postgresql', 'sqlserver');
		// Properties that are only used on the command line
		ignoreProperties(configuration, 'jarDirs');
		// https://github.com/flyway/flyway/issues/3732
		ignoreProperties(configuration, 'environment');
		// High level object we can"t set with properties
		ignoreProperties(configuration, 'callbacks', 'classLoader', 'dataSource', 'javaMigrations',
				'javaMigrationClassProvider', 'pluginRegister', 'resourceProvider', 'resolvers');
		// Properties we don"t want to expose
		ignoreProperties(configuration, 'resolversAsClassNames', 'callbacksAsClassNames', 'driver', 'modernConfig',
				'currentResolvedEnvironment', 'reportFilename', 'reportEnabled', 'workingDirectory',
				'cachedDataSources', 'cachedResolvedEnvironments', 'currentEnvironmentName', 'allEnvironments',
				'environmentProvisionMode', 'provisionMode');
		// Handled by the conversion service
		ignoreProperties(configuration, 'baselineVersionAsString', 'encodingAsString', 'locationsAsStrings',
				'targetAsString');
		// Handled as initSql array
		ignoreProperties(configuration, 'initSql');
		ignoreProperties(properties, 'initSqls');
		// Handled as dryRunOutput
		ignoreProperties(configuration, 'dryRunOutputAsFile', 'dryRunOutputAsFileName');
		// Handled as createSchemas
		ignoreProperties(configuration, 'shouldCreateSchemas');
		// Getters for the DataSource settings rather than actual properties
		ignoreProperties(configuration, 'databaseType', 'password', 'url', 'user');
		// Properties not exposed by Flyway
		ignoreProperties(configuration, 'failOnMissingTarget');
		// Properties managed by a proprietary extension
		ignoreProperties(configuration, 'cherryPick');
		aliasProperty(configuration, 'communityDBSupportEnabled', 'communityDbSupportEnabled');
		List<String> configurationKeys = new ArrayList<>(configuration.keySet());
		Collections.sort(configurationKeys);
		List<String> propertiesKeys = new ArrayList<>(properties.keySet());
		Collections.sort(propertiesKeys);
		assertThat(configurationKeys).containsExactlyElementsOf(propertiesKeys);
	}
	private void ignoreProperties(Map<String, ?> index, String... propertyNames) {
		for (String propertyName : propertyNames) {
			assertThat(index.remove(propertyName)).describedAs('Property to ignore should be present ' + propertyName)
				.isNotNull();
		}
	}
	private void aliasProperty(Map<String, PropertyDescriptor> index, String originalName, String alias) {
		PropertyDescriptor descriptor = index.remove(originalName);
		assertThat(descriptor).describedAs('Property to alias should be present ' + originalName).isNotNull();
		index.put(alias, descriptor);
	}
	private Map<String, PropertyDescriptor> indexProperties(BeanWrapper beanWrapper) {
		Map<String, PropertyDescriptor> descriptor = new HashMap<>();
		for (PropertyDescriptor propertyDescriptor : beanWrapper.getPropertyDescriptors()) {
			descriptor.put(propertyDescriptor.getName(), propertyDescriptor);
		}
		ignoreProperties(descriptor, 'class');
		return descriptor;
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class ImportAutoConfigurationTests {
	@Test
	void multipleAnnotationsShouldMergeCorrectly() {
		assertThat(getImportedConfigBeans(Config.class)).containsExactly('ConfigA', 'ConfigB', 'ConfigC', 'ConfigD');
		assertThat(getImportedConfigBeans(AnotherConfig.class)).containsExactly('ConfigA', 'ConfigB', 'ConfigC',
				'ConfigD');
	}
	@Test
	void classesAsAnAlias() {
		assertThat(getImportedConfigBeans(AnotherConfigUsingClasses.class)).containsExactly('ConfigA', 'ConfigB',
				'ConfigC', 'ConfigD');
	}
	@Test
	void excluding() {
		assertThat(getImportedConfigBeans(ExcludingConfig.class)).containsExactly('ConfigA', 'ConfigB', 'ConfigD');
	}
	@Test
	void excludeAppliedGlobally() {
		assertThat(getImportedConfigBeans(ExcludeDConfig.class, ImportADConfig.class)).containsExactly('ConfigA');
	}
	@Test
	void excludeWithRedundancy() {
		assertThat(getImportedConfigBeans(ExcludeADConfig.class, ExcludeDConfig.class, ImportADConfig.class)).isEmpty();
	}
	private List<String> getImportedConfigBeans(Class<?>... config) {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(config);
		String shortName = ClassUtils.getShortName(ImportAutoConfigurationTests.class);
		int beginIndex = shortName.length() + 1;
		List<String> orderedConfigBeans = new ArrayList<>();
		for (String bean : context.getBeanDefinitionNames()) {
			if (bean.contains('$Config')) {
				String shortBeanName = ClassUtils.getShortName(bean);
				orderedConfigBeans.add(shortBeanName.substring(beginIndex));
			}
		}
		context.close();
		return orderedConfigBeans;
	}
	@ImportAutoConfiguration({ ConfigD.class, ConfigB.class })
	@MetaImportAutoConfiguration
	static class Config {
	}
	@MetaImportAutoConfiguration
	@ImportAutoConfiguration({ ConfigB.class, ConfigD.class })
	static class AnotherConfig {
	}
	@MetaImportAutoConfiguration
	@ImportAutoConfiguration(classes = { ConfigB.class, ConfigD.class })
	static class AnotherConfigUsingClasses {
	}
	@ImportAutoConfiguration(classes = { ConfigD.class, ConfigB.class }, exclude = ConfigC.class)
	@MetaImportAutoConfiguration
	static class ExcludingConfig {
	}
	@ImportAutoConfiguration(classes = { ConfigA.class, ConfigD.class })
	static class ImportADConfig {
	}
	@ImportAutoConfiguration(exclude = { ConfigA.class, ConfigD.class })
	static class ExcludeADConfig {
	}
	@ImportAutoConfiguration(exclude = ConfigD.class)
	static class ExcludeDConfig {
	}
	@Retention(RetentionPolicy.RUNTIME)
	@ImportAutoConfiguration({ ConfigC.class, ConfigA.class })
	@interface MetaImportAutoConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class ConfigA {
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigureAfter(ConfigA.class)
	static class ConfigB {
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigureAfter(ConfigB.class)
	static class ConfigC {
	}
	@Configuration(proxyBeanMethods = false)
	@AutoConfigureAfter(ConfigC.class)
	static class ConfigD {
	}
}
/*
package org.springframework.boot.autoconfigure.container;
/**
class ContainerImageMetadataTests {
	private ContainerImageMetadata metadata = new ContainerImageMetadata('test');
	private AttributeAccessor attributes = new AttributeAccessorSupport() {
	};
	@Test
	void addToWhenAttributesIsNullDoesNothing() {
		this.metadata.addTo(null);
	}
	@Test
	void addToAddsMetadata() {
		this.metadata.addTo(this.attributes);
		assertThat(this.attributes.getAttribute(ContainerImageMetadata.NAME)).isSameAs(this.metadata);
	}
	@Test
	void isPresentWhenPresentReturnsTrue() {
		this.metadata.addTo(this.attributes);
		assertThat(ContainerImageMetadata.isPresent(this.attributes)).isTrue();
	}
	@Test
	void isPresentWhenNotPresentReturnsFalse() {
		assertThat(ContainerImageMetadata.isPresent(this.attributes)).isFalse();
	}
	@Test
	void isPresentWhenNullAttributesReturnsFalse() {
		assertThat(ContainerImageMetadata.isPresent(null)).isFalse();
	}
	@Test
	void getFromWhenPresentReturnsMetadata() {
		this.metadata.addTo(this.attributes);
		assertThat(ContainerImageMetadata.getFrom(this.attributes)).isSameAs(this.metadata);
	}
	@Test
	void getFromWhenNotPresentReturnsNull() {
		assertThat(ContainerImageMetadata.getFrom(this.attributes)).isNull();
	}
	@Test
	void getFromWhenNullAttributesReturnsNull() {
		assertThat(ContainerImageMetadata.getFrom(null)).isNull();
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class SharedMetadataReaderFactoryContextInitializerTests {
	@Test
	@SuppressWarnings('unchecked')
	void checkOrderOfInitializer() {
		SpringApplication application = new SpringApplication(TestConfig.class);
		application.setWebApplicationType(WebApplicationType.NONE);
		List<ApplicationContextInitializer<?>> initializers = (List<ApplicationContextInitializer<?>>) ReflectionTestUtils
			.getField(application, 'initializers');
		// Simulate what would happen if an initializer was added using spring.factories
		// and happened to be loaded first
		initializers.add(0, new Initializer());
		GenericApplicationContext context = (GenericApplicationContext) application.run();
		BeanDefinition definition = context.getBeanDefinition(SharedMetadataReaderFactoryContextInitializer.BEAN_NAME);
		assertThat(definition.getAttribute('seen')).isEqualTo(true);
	}
	@Test
	void initializeWhenUsingSupplierDecorates() {
		GenericApplicationContext context = new GenericApplicationContext();
		BeanDefinitionRegistry registry = (BeanDefinitionRegistry) context.getBeanFactory();
		ConfigurationClassPostProcessor configurationAnnotationPostProcessor = mock(
				ConfigurationClassPostProcessor.class);
		BeanDefinition beanDefinition = BeanDefinitionBuilder
			.rootBeanDefinition(ConfigurationClassPostProcessor.class, () -> configurationAnnotationPostProcessor)
			.getBeanDefinition();
		registry.registerBeanDefinition(AnnotationConfigUtils.CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME,
				beanDefinition);
		CachingMetadataReaderFactoryPostProcessor postProcessor = new CachingMetadataReaderFactoryPostProcessor(
				context);
		postProcessor.postProcessBeanDefinitionRegistry(registry);
		context.refresh();
		ConfigurationClassPostProcessor bean = context.getBean(ConfigurationClassPostProcessor.class);
		assertThat(bean).isSameAs(configurationAnnotationPostProcessor);
		then(configurationAnnotationPostProcessor).should()
			.setMetadataReaderFactory(assertArg((metadataReaderFactory) -> assertThat(metadataReaderFactory)
				.isInstanceOf(ConcurrentReferenceCachingMetadataReaderFactory.class)));
	}
	static class TestConfig {
	}
	static class Initializer implements ApplicationContextInitializer<GenericApplicationContext> {
		@Override
		public void initialize(GenericApplicationContext applicationContext) {
			applicationContext.addBeanFactoryPostProcessor(new PostProcessor());
		}
	}
	static class PostProcessor implements BeanDefinitionRegistryPostProcessor {
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) {
			for (String name : registry.getBeanDefinitionNames()) {
				BeanDefinition definition = registry.getBeanDefinition(name);
				definition.setAttribute('seen', true);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.packagestest.one;
/**
@Configuration(proxyBeanMethods = false)
@AutoConfigurationPackage
public class FirstConfiguration {
}
/*
package org.springframework.boot.autoconfigure.packagestest.two;
/**
@Configuration(proxyBeanMethods = false)
@AutoConfigurationPackage
public class SecondConfiguration {
}
/*
package org.springframework.boot.autoconfigure.jndi;
/**
public class JndiPropertiesHidingClassLoader extends ClassLoader {
	public JndiPropertiesHidingClassLoader(ClassLoader parent) {
		super(parent);
	}
	@Override
	public Enumeration<URL> getResources(String name) throws IOException {
		if ('jndi.properties'.equals(name)) {
			return Collections.emptyEnumeration();
		}
		return super.getResources(name);
	}
}
/*
package org.springframework.boot.autoconfigure.jndi;
/**
public class TestableInitialContextFactory implements InitialContextFactory {
	private static TestableContext context;
	@Override
	public Context getInitialContext(Hashtable<?, ?> environment) {
		return getContext();
	}
	public static void bind(String name, Object obj) {
		try {
			getContext().bind(name, obj);
		}
		catch (NamingException ex) {
			throw new IllegalStateException(ex);
		}
	}
	public static void clearAll() {
		getContext().clearAll();
	}
	private static TestableContext getContext() {
		if (context == null) {
			try {
				context = new TestableContext();
			}
			catch (NamingException ex) {
				throw new IllegalStateException(ex);
			}
		}
		return context;
	}
	private static final class TestableContext extends InitialContext {
		private final Map<String, Object> bindings = new HashMap<>();
		private TestableContext() throws NamingException {
			super(true);
		}
		@Override
		public void bind(String name, Object obj) throws NamingException {
			this.bindings.put(name, obj);
		}
		@Override
		public Object lookup(String name) {
			return this.bindings.get(name);
		}
		@Override
		public Hashtable<?, ?> getEnvironment() throws NamingException {
			return new Hashtable<>(); // Used to detect if JNDI is
										// available
		}
		void clearAll() {
			this.bindings.clear();
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationExcludeFilterTests {
	private static final Class<?> FILTERED = ExampleFilteredAutoConfiguration.class;
	private AnnotationConfigApplicationContext context;
	@AfterEach
	void cleanUp() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void filterExcludeAutoConfiguration() {
		this.context = new AnnotationConfigApplicationContext(Config.class);
		assertThat(this.context.getBeansOfType(String.class)).hasSize(1);
		assertThat(this.context.getBean(String.class)).isEqualTo('test');
		assertThatExceptionOfType(NoSuchBeanDefinitionException.class).isThrownBy(() -> this.context.getBean(FILTERED));
	}
	@Configuration(proxyBeanMethods = false)
	@ComponentScan(basePackageClasses = ExampleConfiguration.class,
			excludeFilters = @ComponentScan.Filter(type = FilterType.CUSTOM,
					classes = TestAutoConfigurationExcludeFilter.class))
	static class Config {
	}
	static class TestAutoConfigurationExcludeFilter extends AutoConfigurationExcludeFilter {
		@Override
		protected List<String> getAutoConfigurations() {
			return Collections.singletonList(FILTERED.getName());
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationsTests {
	@Test
	void ofShouldCreateOrderedConfigurations() {
		Configurations configurations = AutoConfigurations.of(AutoConfigureA.class, AutoConfigureB.class);
		assertThat(Configurations.getClasses(configurations)).containsExactly(AutoConfigureB.class,
				AutoConfigureA.class);
	}
	@Test
	void whenHasReplacementForAutoConfigureAfterShouldCreateOrderedConfigurations() {
		Configurations configurations = new AutoConfigurations(this::replaceB,
				Arrays.asList(AutoConfigureA.class, AutoConfigureB2.class));
		assertThat(Configurations.getClasses(configurations)).containsExactly(AutoConfigureB2.class,
				AutoConfigureA.class);
	}
	@Test
	void whenHasReplacementForClassShouldReplaceClass() {
		Configurations configurations = new AutoConfigurations(this::replaceB,
				Arrays.asList(AutoConfigureA.class, AutoConfigureB.class));
		assertThat(Configurations.getClasses(configurations)).containsExactly(AutoConfigureB2.class,
				AutoConfigureA.class);
	}
	private String replaceB(String className) {
		return (!AutoConfigureB.class.getName().equals(className)) ? className : AutoConfigureB2.class.getName();
	}
	@AutoConfigureAfter(AutoConfigureB.class)
	static class AutoConfigureA {
	}
	static class AutoConfigureB {
	}
	static class AutoConfigureB2 {
	}
}
/*
package org.springframework.boot.autoconfigure.netty;
/**
class NettyPropertiesTests {
	@Test
	void defaultValueShouldBeConsistent() {
		ResourceLeakDetector.Level defaultLevel = (Level) ReflectionTestUtils.getField(ResourceLeakDetector.class,
				'DEFAULT_LEVEL');
		assertThat(defaultLevel).isEqualTo(Level.SIMPLE);
	}
}
/*
package org.springframework.boot.autoconfigure.netty;
/**
class NettyAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(NettyAutoConfiguration.class));
	@Test
	void leakDetectionShouldBeConfigured() {
		this.contextRunner.withPropertyValues('spring.netty.leak-detection=paranoid').run((context) -> {
			assertThat(ResourceLeakDetector.getLevel()).isEqualTo(ResourceLeakDetector.Level.PARANOID);
			// reset configuration for the following tests.
			ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.DISABLED);
		});
	}
}
/*
package org.springframework.boot.autoconfigure.ldap;
/**
class LdapAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(LdapAutoConfiguration.class));
	@Test
	void contextSourceWithDefaultUrl() {
		this.contextRunner.run((context) -> {
			LdapContextSource contextSource = context.getBean(LdapContextSource.class);
			assertThat(contextSource.getUrls()).containsExactly('ldap://localhost:389');
			assertThat(contextSource.isAnonymousReadOnly()).isTrue();
		});
	}
	@Test
	void contextSourceWithSingleUrl() {
		this.contextRunner.withPropertyValues('spring.ldap.urls:ldap://localhost:123').run((context) -> {
			LdapContextSource contextSource = context.getBean(LdapContextSource.class);
			assertThat(contextSource.getUrls()).containsExactly('ldap://localhost:123');
		});
	}
	@Test
	void contextSourceWithSeveralUrls() {
		this.contextRunner.withPropertyValues('spring.ldap.urls:ldap://localhost:123,ldap://mycompany:123')
			.run((context) -> {
				LdapContextSource contextSource = context.getBean(LdapContextSource.class);
				LdapProperties ldapProperties = context.getBean(LdapProperties.class);
				assertThat(contextSource.getUrls()).containsExactly('ldap://localhost:123', 'ldap://mycompany:123');
				assertThat(ldapProperties.getUrls()).hasSize(2);
			});
	}
	@Test
	void contextSourceWithUserDoesNotEnableAnonymousReadOnly() {
		this.contextRunner.withPropertyValues('spring.ldap.username:root').run((context) -> {
			LdapContextSource contextSource = context.getBean(LdapContextSource.class);
			assertThat(contextSource.getUserDn()).isEqualTo('root');
			assertThat(contextSource.isAnonymousReadOnly()).isFalse();
		});
	}
	@Test
	void contextSourceWithExtraCustomization() {
		this.contextRunner
			.withPropertyValues('spring.ldap.urls:ldap://localhost:123', 'spring.ldap.username:root',
					'spring.ldap.password:secret', 'spring.ldap.anonymous-read-only:true',
					'spring.ldap.base:cn=SpringDevelopers',
					'spring.ldap.baseEnvironment.java.naming.security.authentication:DIGEST-MD5')
			.run((context) -> {
				LdapContextSource contextSource = context.getBean(LdapContextSource.class);
				assertThat(contextSource.getUserDn()).isEqualTo('root');
				assertThat(contextSource.getPassword()).isEqualTo('secret');
				assertThat(contextSource.isAnonymousReadOnly()).isTrue();
				assertThat(contextSource.getBaseLdapPathAsString()).isEqualTo('cn=SpringDevelopers');
				LdapProperties ldapProperties = context.getBean(LdapProperties.class);
				assertThat(ldapProperties.getBaseEnvironment()).containsEntry('java.naming.security.authentication',
						'DIGEST-MD5');
			});
	}
	@Test
	void contextSourceWithNoCustomization() {
		this.contextRunner.run((context) -> {
			LdapContextSource contextSource = context.getBean(LdapContextSource.class);
			assertThat(contextSource.getUserDn()).isEmpty();
			assertThat(contextSource.getPassword()).isEmpty();
			assertThat(contextSource.isAnonymousReadOnly()).isTrue();
			assertThat(contextSource.getBaseLdapPathAsString()).isEmpty();
		});
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesLdapConnectionDetails.class));
	}
	@Test
	void usesCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withUserConfiguration(ConnectionDetailsConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(LdapContextSource.class)
				.hasSingleBean(LdapConnectionDetails.class)
				.doesNotHaveBean(PropertiesLdapConnectionDetails.class);
			LdapContextSource contextSource = context.getBean(LdapContextSource.class);
			assertThat(contextSource.getUrls()).isEqualTo(new String[] { 'ldaps://ldap.example.com' });
			assertThat(contextSource.getBaseLdapName()).isEqualTo(LdapUtils.newLdapName('dc=base'));
			assertThat(contextSource.getUserDn()).isEqualTo('ldap-user');
			assertThat(contextSource.getPassword()).isEqualTo('ldap-password');
		});
	}
	@Test
	void templateExists() {
		this.contextRunner.withPropertyValues('spring.ldap.urls:ldap://localhost:389').run((context) -> {
			assertThat(context).hasSingleBean(LdapTemplate.class);
			LdapTemplate ldapTemplate = context.getBean(LdapTemplate.class);
			assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignorePartialResultException', false);
			assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignoreNameNotFoundException', false);
			assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignoreSizeLimitExceededException', true);
		});
	}
	@Test
	void templateConfigurationCanBeCustomized() {
		this.contextRunner
			.withPropertyValues('spring.ldap.urls:ldap://localhost:389',
					'spring.ldap.template.ignorePartialResultException=true',
					'spring.ldap.template.ignoreNameNotFoundException=true',
					'spring.ldap.template.ignoreSizeLimitExceededException=false')
			.run((context) -> {
				assertThat(context).hasSingleBean(LdapTemplate.class);
				LdapTemplate ldapTemplate = context.getBean(LdapTemplate.class);
				assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignorePartialResultException', true);
				assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignoreNameNotFoundException', true);
				assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignoreSizeLimitExceededException', false);
			});
	}
	@Test
	void contextSourceWithUserProvidedPooledContextSource() {
		this.contextRunner.withUserConfiguration(PooledContextSourceConfig.class).run((context) -> {
			LdapContextSource contextSource = context.getBean(LdapContextSource.class);
			assertThat(contextSource.getUrls()).containsExactly('ldap://localhost:389');
			assertThat(contextSource.isAnonymousReadOnly()).isTrue();
		});
	}
	@Test
	void contextSourceWithCustomUniqueDirContextAuthenticationStrategy() {
		this.contextRunner.withUserConfiguration(CustomDirContextAuthenticationStrategy.class).run((context) -> {
			assertThat(context).hasSingleBean(DirContextAuthenticationStrategy.class);
			LdapContextSource contextSource = context.getBean(LdapContextSource.class);
			assertThat(contextSource).extracting('authenticationStrategy')
				.isSameAs(context.getBean('customDirContextAuthenticationStrategy'));
		});
	}
	@Test
	void contextSourceWithCustomNonUniqueDirContextAuthenticationStrategy() {
		this.contextRunner
			.withUserConfiguration(CustomDirContextAuthenticationStrategy.class,
					AnotherCustomDirContextAuthenticationStrategy.class)
			.run((context) -> {
				assertThat(context).hasBean('customDirContextAuthenticationStrategy')
					.hasBean('anotherCustomDirContextAuthenticationStrategy');
				LdapContextSource contextSource = context.getBean(LdapContextSource.class);
				assertThat(contextSource).extracting('authenticationStrategy')
					.isNotSameAs(context.getBean('customDirContextAuthenticationStrategy'))
					.isNotSameAs(context.getBean('anotherCustomDirContextAuthenticationStrategy'))
					.isInstanceOf(SimpleDirContextAuthenticationStrategy.class);
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class ConnectionDetailsConfiguration {
		@Bean
		LdapConnectionDetails ldapConnectionDetails() {
			return new LdapConnectionDetails() {
				@Override
				public String[] getUrls() {
					return new String[] { 'ldaps://ldap.example.com' };
				}
				@Override
				public String getBase() {
					return 'dc=base';
				}
				@Override
				public String getUsername() {
					return 'ldap-user';
				}
				@Override
				public String getPassword() {
					return 'ldap-password';
				}
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class PooledContextSourceConfig {
		@Bean
		@Primary
		PooledContextSource pooledContextSource(LdapContextSource ldapContextSource) {
			PooledContextSource pooledContextSource = new PooledContextSource(new PoolConfig());
			pooledContextSource.setContextSource(ldapContextSource);
			return pooledContextSource;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomDirContextAuthenticationStrategy {
		@Bean
		DirContextAuthenticationStrategy customDirContextAuthenticationStrategy() {
			return mock(DirContextAuthenticationStrategy.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AnotherCustomDirContextAuthenticationStrategy {
		@Bean
		DirContextAuthenticationStrategy anotherCustomDirContextAuthenticationStrategy() {
			return mock(DirContextAuthenticationStrategy.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ldap;
/**
class LdapPropertiesTests {
	@Test
	void ldapTemplatePropertiesUseConsistentLdapTemplateDefaultValues() {
		Template templateProperties = new LdapProperties().getTemplate();
		LdapTemplate ldapTemplate = new LdapTemplate();
		assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignorePartialResultException',
				templateProperties.isIgnorePartialResultException());
		assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignoreNameNotFoundException',
				templateProperties.isIgnoreNameNotFoundException());
		assertThat(ldapTemplate).hasFieldOrPropertyWithValue('ignoreSizeLimitExceededException',
				templateProperties.isIgnoreSizeLimitExceededException());
	}
}
/*
package org.springframework.boot.autoconfigure.ldap.embedded;
/**
class EmbeddedLdapAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(EmbeddedLdapAutoConfiguration.class));
	@Test
	void testSetDefaultPort() {
		this.contextRunner
			.withPropertyValues('spring.ldap.embedded.port:1234', 'spring.ldap.embedded.base-dn:dc=spring,dc=org')
			.run((context) -> {
				InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
				assertThat(server.getListenPort()).isEqualTo(1234);
			});
	}
	@Test
	void testRandomPortWithEnvironment() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org').run((context) -> {
			InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
			assertThat(server.getListenPort())
				.isEqualTo(context.getEnvironment().getProperty('local.ldap.port', Integer.class));
		});
	}
	@Test
	void testRandomPortWithValueAnnotation() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.ldap.embedded.base-dn:dc=spring,dc=org').applyTo(context);
		context.register(EmbeddedLdapAutoConfiguration.class, LdapClientConfiguration.class,
				PropertyPlaceholderAutoConfiguration.class);
		context.refresh();
		LDAPConnection connection = context.getBean(LDAPConnection.class);
		assertThat(connection.getConnectedPort())
			.isEqualTo(context.getEnvironment().getProperty('local.ldap.port', Integer.class));
	}
	@Test
	void testSetCredentials() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org',
				'spring.ldap.embedded.credential.username:uid=root', 'spring.ldap.embedded.credential.password:boot')
			.run((context) -> {
				InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
				BindResult result = server.bind('uid=root', 'boot');
				assertThat(result).isNotNull();
			});
	}
	@Test
	void testSetPartitionSuffix() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org').run((context) -> {
			InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
			assertThat(server.getBaseDNs()).containsExactly(new DN('dc=spring,dc=org'));
		});
	}
	@Test
	void testSetLdifFile() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org').run((context) -> {
			InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
			assertThat(server.countEntriesBelow('ou=company1,c=Sweden,dc=spring,dc=org')).isEqualTo(5);
		});
	}
	@Test
	void testQueryEmbeddedLdap() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org')
			.withConfiguration(AutoConfigurations.of(LdapAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(LdapTemplate.class);
				LdapTemplate ldapTemplate = context.getBean(LdapTemplate.class);
				assertThat(ldapTemplate.list('ou=company1,c=Sweden,dc=spring,dc=org')).hasSize(4);
			});
	}
	@Test
	void testDisableSchemaValidation() {
		this.contextRunner
			.withPropertyValues('spring.ldap.embedded.validation.enabled:false',
					'spring.ldap.embedded.base-dn:dc=spring,dc=org')
			.run((context) -> {
				InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
				assertThat(server.getSchema()).isNull();
			});
	}
	@Test
	void testCustomSchemaValidation() {
		this.contextRunner
			.withPropertyValues('spring.ldap.embedded.validation.schema:classpath:custom-schema.ldif',
					'spring.ldap.embedded.ldif:classpath:custom-schema-sample.ldif',
					'spring.ldap.embedded.base-dn:dc=spring,dc=org')
			.run((context) -> {
				InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
				assertThat(server.getSchema().getObjectClass('exampleAuxiliaryClass')).isNotNull();
				assertThat(server.getSchema().getAttributeType('exampleAttributeName')).isNotNull();
			});
	}
	@Test
	void testMultiBaseDn() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.ldif:classpath:schema-multi-basedn.ldif',
				'spring.ldap.embedded.base-dn[0]:dc=spring,dc=org', 'spring.ldap.embedded.base-dn[1]:dc=vmware,dc=com')
			.run((context) -> {
				InMemoryDirectoryServer server = context.getBean(InMemoryDirectoryServer.class);
				assertThat(server.countEntriesBelow('ou=company1,c=Sweden,dc=spring,dc=org')).isEqualTo(5);
				assertThat(server.countEntriesBelow('c=Sweden,dc=vmware,dc=com')).isEqualTo(2);
			});
	}
	@Test
	void ldapContextSourceWithCredentialsIsCreated() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org',
				'spring.ldap.embedded.credential.username:uid=root', 'spring.ldap.embedded.credential.password:boot')
			.run((context) -> {
				LdapContextSource ldapContextSource = context.getBean(LdapContextSource.class);
				assertThat(ldapContextSource.getUrls()).isNotEmpty();
				assertThat(ldapContextSource.getUserDn()).isEqualTo('uid=root');
			});
	}
	@Test
	void ldapContextSourceWithoutCredentialsIsCreated() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org').run((context) -> {
			LdapContextSource ldapContextSource = context.getBean(LdapContextSource.class);
			assertThat(ldapContextSource.getUrls()).isNotEmpty();
			assertThat(ldapContextSource.getUserDn()).isEmpty();
		});
	}
	@Test
	void ldapContextWithoutSpringLdapIsNotCreated() {
		this.contextRunner.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org')
			.withClassLoader(new FilteredClassLoader(ContextSource.class))
			.run((context) -> {
				assertThat(context).hasNotFailed();
				assertThat(context).doesNotHaveBean(LdapContextSource.class);
			});
	}
	@Test
	void ldapContextIsCreatedWithBase() {
		this.contextRunner
			.withPropertyValues('spring.ldap.embedded.base-dn:dc=spring,dc=org', 'spring.ldap.base:dc=spring,dc=org')
			.run((context) -> {
				LdapContextSource ldapContextSource = context.getBean(LdapContextSource.class);
				assertThat(ldapContextSource.getBaseLdapPathAsString()).isEqualTo('dc=spring,dc=org');
			});
	}
	@Configuration(proxyBeanMethods = false)
	static class LdapClientConfiguration {
		@Bean
		LDAPConnection ldapConnection(@Value('${local.ldap.port}') int port) throws LDAPException {
			LDAPConnection con = new LDAPConnection();
			con.connect('localhost', port);
			return con;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
class ReactiveMongoClientFactoryTests extends MongoClientFactorySupportTests<MongoClient> {
	@Override
	protected MongoClient createMongoClient(List<MongoClientSettingsBuilderCustomizer> customizers,
			MongoClientSettings settings) {
		return new ReactiveMongoClientFactory(customizers).createMongoClient(settings);
	}
	@Override
	protected MongoClientSettings getClientSettings(MongoClient client) {
		return ((MongoClientImpl) client).getSettings();
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
class MongoAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MongoAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void clientExists() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MongoClient.class));
	}
	@Test
	void settingsAdded() {
		this.contextRunner.withUserConfiguration(SettingsConfig.class)
			.run((context) -> assertThat(
					getSettings(context).getSocketSettings().getConnectTimeout(TimeUnit.MILLISECONDS))
				.isEqualTo(300));
	}
	@Test
	void settingsAddedButNoHost() {
		this.contextRunner.withUserConfiguration(SettingsConfig.class)
			.run((context) -> assertThat(
					getSettings(context).getSocketSettings().getConnectTimeout(TimeUnit.MILLISECONDS))
				.isEqualTo(300));
	}
	@Test
	void settingsSslConfig() {
		this.contextRunner.withUserConfiguration(SslSettingsConfig.class)
			.run((context) -> assertThat(getSettings(context).getSslSettings().isEnabled()).isTrue());
	}
	@Test
	void configuresSslWhenEnabled() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.ssl.enabled=true').run((context) -> {
			SslSettings sslSettings = getSettings(context).getSslSettings();
			assertThat(sslSettings.isEnabled()).isTrue();
			assertThat(sslSettings.getContext()).isNull();
		});
	}
	@Test
	void configuresSslWithBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.ssl.bundle=test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location=classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password=secret',
					'spring.ssl.bundle.jks.test-bundle.key.password=password')
			.run((context) -> {
				SslSettings sslSettings = getSettings(context).getSslSettings();
				assertThat(sslSettings.isEnabled()).isTrue();
				assertThat(sslSettings.getContext()).isNotNull();
			});
	}
	@Test
	void configuresWithoutSslWhenDisabledWithBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.ssl.enabled=false', 'spring.data.mongodb.ssl.bundle=test-bundle')
			.run((context) -> {
				SslSettings sslSettings = getSettings(context).getSslSettings();
				assertThat(sslSettings.isEnabled()).isFalse();
			});
	}
	@Test
	void doesNotConfigureCredentialsWithoutUsername() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.password=secret',
					'spring.data.mongodb.authentication-database=authdb')
			.run((context) -> assertThat(getSettings(context).getCredential()).isNull());
	}
	@Test
	void configuresCredentialsFromPropertiesWithDefaultDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.username=user', 'spring.data.mongodb.password=secret')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('test');
			});
	}
	@Test
	void configuresCredentialsFromPropertiesWithDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.username=user', 'spring.data.mongodb.password=secret',
					'spring.data.mongodb.database=mydb')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('mydb');
			});
	}
	@Test
	void configuresCredentialsFromPropertiesWithAuthDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.username=user', 'spring.data.mongodb.password=secret',
					'spring.data.mongodb.database=mydb', 'spring.data.mongodb.authentication-database=authdb')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('authdb');
			});
	}
	@Test
	void configuresCredentialsFromPropertiesWithSpecialCharacters() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.username=us:er', 'spring.data.mongodb.password=sec@ret')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('us:er');
				assertThat(credential.getPassword()).isEqualTo('sec@ret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('test');
			});
	}
	@Test
	void doesNotConfigureCredentialsWithoutUsernameInUri() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://localhost/mydb?authSource=authdb')
			.run((context) -> assertThat(getSettings(context).getCredential()).isNull());
	}
	@Test
	void configuresCredentialsFromUriPropertyWithDefaultDatabase() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://user:secret@localhost/')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('admin');
			});
	}
	@Test
	void configuresCredentialsFromUriPropertyWithDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://user:secret@localhost/mydb',
					'spring.data.mongodb.database=notused', 'spring.data.mongodb.authentication-database=notused')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('mydb');
			});
	}
	@Test
	void configuresCredentialsFromUriPropertyWithAuthDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://user:secret@localhost/mydb?authSource=authdb',
					'spring.data.mongodb.database=notused', 'spring.data.mongodb.authentication-database=notused')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('authdb');
			});
	}
	@Test
	void configuresSingleClient() {
		this.contextRunner.withUserConfiguration(FallbackMongoClientConfig.class)
			.run((context) -> assertThat(context).hasSingleBean(MongoClient.class));
	}
	@Test
	void customizerOverridesAutoConfig() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri:mongodb://localhost/test?appname=auto-config')
			.withUserConfiguration(SimpleCustomizerConfig.class)
			.run((context) -> assertThat(getSettings(context).getApplicationName()).isEqualTo('overridden-name'));
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesMongoConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(MongoConnectionDetails.class, () -> new MongoConnectionDetails() {
			@Override
			public ConnectionString getConnectionString() {
				return new ConnectionString('mongodb://localhost');
			}
		})
			.run((context) -> assertThat(context).hasSingleBean(MongoConnectionDetails.class)
				.doesNotHaveBean(PropertiesMongoConnectionDetails.class));
	}
	@Test
	void uuidRepresentationDefaultsAreAligned() {
		this.contextRunner.run((context) -> assertThat(getSettings(context).getUuidRepresentation())
			.isEqualTo(new MongoProperties().getUuidRepresentation()));
	}
	private MongoClientSettings getSettings(AssertableApplicationContext context) {
		assertThat(context).hasSingleBean(MongoClient.class);
		MongoClientImpl client = (MongoClientImpl) context.getBean(MongoClient.class);
		return client.getSettings();
	}
	@Configuration(proxyBeanMethods = false)
	static class SettingsConfig {
		@Bean
		MongoClientSettings mongoClientSettings() {
			return MongoClientSettings.builder()
				.applyToSocketSettings((socketSettings) -> socketSettings.connectTimeout(300, TimeUnit.MILLISECONDS))
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SslSettingsConfig {
		@Bean
		MongoClientSettings mongoClientSettings() {
			return MongoClientSettings.builder().applyToSslSettings((ssl) -> ssl.enabled(true)).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class FallbackMongoClientConfig {
		@Bean
		MongoClient fallbackMongoClient() {
			return MongoClients.create();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SimpleCustomizerConfig {
		@Bean
		MongoClientSettingsBuilderCustomizer customizer() {
			return (clientSettingsBuilder) -> clientSettingsBuilder.applicationName('overridden-name');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
class MongoClientFactoryTests extends MongoClientFactorySupportTests<MongoClient> {
	@Override
	protected MongoClient createMongoClient(List<MongoClientSettingsBuilderCustomizer> customizers,
			MongoClientSettings settings) {
		return new MongoClientFactory(customizers).createMongoClient(settings);
	}
	@Override
	protected MongoClientSettings getClientSettings(MongoClient client) {
		return ((MongoClientImpl) client).getSettings();
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
class MongoReactiveAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(MongoReactiveAutoConfiguration.class, SslAutoConfiguration.class));
	@Test
	void clientExists() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(MongoClient.class));
	}
	@Test
	void settingsAdded() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.host:localhost')
			.withUserConfiguration(SettingsConfig.class)
			.run((context) -> assertThat(getSettings(context).getSocketSettings().getReadTimeout(TimeUnit.SECONDS))
				.isEqualTo(300));
	}
	@Test
	void settingsAddedButNoHost() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri:mongodb://localhost/test')
			.withUserConfiguration(SettingsConfig.class)
			.run((context) -> assertThat(getSettings(context).getReadPreference()).isEqualTo(ReadPreference.nearest()));
	}
	@Test
	void settingsSslConfig() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri:mongodb://localhost/test')
			.withUserConfiguration(SslSettingsConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(MongoClient.class);
				MongoClientSettings settings = getSettings(context);
				assertThat(settings.getApplicationName()).isEqualTo('test-config');
				assertThat(settings.getTransportSettings()).isSameAs(context.getBean('myTransportSettings'));
			});
	}
	@Test
	void configuresSslWhenEnabled() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.ssl.enabled=true').run((context) -> {
			SslSettings sslSettings = getSettings(context).getSslSettings();
			assertThat(sslSettings.isEnabled()).isTrue();
			assertThat(sslSettings.getContext()).isNull();
		});
	}
	@Test
	void configuresSslWithBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.ssl.bundle=test-bundle',
					'spring.ssl.bundle.jks.test-bundle.keystore.location=classpath:test.jks',
					'spring.ssl.bundle.jks.test-bundle.keystore.password=secret',
					'spring.ssl.bundle.jks.test-bundle.key.password=password')
			.run((context) -> {
				SslSettings sslSettings = getSettings(context).getSslSettings();
				assertThat(sslSettings.isEnabled()).isTrue();
				assertThat(sslSettings.getContext()).isNotNull();
			});
	}
	@Test
	void configuresWithoutSslWhenDisabledWithBundle() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.ssl.enabled=false', 'spring.data.mongodb.ssl.bundle=test-bundle')
			.run((context) -> {
				SslSettings sslSettings = getSettings(context).getSslSettings();
				assertThat(sslSettings.isEnabled()).isFalse();
			});
	}
	@Test
	void doesNotConfigureCredentialsWithoutUsername() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.password=secret',
					'spring.data.mongodb.authentication-database=authdb')
			.run((context) -> assertThat(getSettings(context).getCredential()).isNull());
	}
	@Test
	void configuresCredentialsFromPropertiesWithDefaultDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.username=user', 'spring.data.mongodb.password=secret')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('test');
			});
	}
	@Test
	void configuresCredentialsFromPropertiesWithDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.username=user', 'spring.data.mongodb.password=secret',
					'spring.data.mongodb.database=mydb')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('mydb');
			});
	}
	@Test
	void configuresCredentialsFromPropertiesWithAuthDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.username=user', 'spring.data.mongodb.password=secret',
					'spring.data.mongodb.database=mydb', 'spring.data.mongodb.authentication-database=authdb')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('authdb');
			});
	}
	@Test
	void doesNotConfigureCredentialsWithoutUsernameInUri() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://localhost/mydb?authSource=authdb')
			.run((context) -> assertThat(getSettings(context).getCredential()).isNull());
	}
	@Test
	void configuresCredentialsFromUriPropertyWithDefaultDatabase() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri=mongodb://user:secret@localhost/')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('admin');
			});
	}
	@Test
	void configuresCredentialsFromUriPropertyWithDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://user:secret@localhost/mydb',
					'spring.data.mongodb.database=notused', 'spring.data.mongodb.authentication-database=notused')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('mydb');
			});
	}
	@Test
	void configuresCredentialsFromUriPropertyWithAuthDatabase() {
		this.contextRunner
			.withPropertyValues('spring.data.mongodb.uri=mongodb://user:secret@localhost/mydb?authSource=authdb',
					'spring.data.mongodb.database=notused', 'spring.data.mongodb.authentication-database=notused')
			.run((context) -> {
				MongoCredential credential = getSettings(context).getCredential();
				assertThat(credential.getUserName()).isEqualTo('user');
				assertThat(credential.getPassword()).isEqualTo('secret'.toCharArray());
				assertThat(credential.getSource()).isEqualTo('authdb');
			});
	}
	@Test
	void nettyTransportSettingsAreConfiguredAutomatically() {
		AtomicReference<EventLoopGroup> eventLoopGroupReference = new AtomicReference<>();
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(MongoClient.class);
			TransportSettings transportSettings = getSettings(context).getTransportSettings();
			assertThat(transportSettings).isInstanceOf(NettyTransportSettings.class);
			EventLoopGroup eventLoopGroup = ((NettyTransportSettings) transportSettings).getEventLoopGroup();
			assertThat(eventLoopGroup.isShutdown()).isFalse();
			eventLoopGroupReference.set(eventLoopGroup);
		});
		assertThat(eventLoopGroupReference.get().isShutdown()).isTrue();
	}
	@Test
	@SuppressWarnings('deprecation')
	void customizerWithTransportSettingsOverridesAutoConfig() {
		this.contextRunner.withPropertyValues('spring.data.mongodb.uri:mongodb://localhost/test?appname=auto-config')
			.withUserConfiguration(SimpleTransportSettingsCustomizerConfig.class)
			.run((context) -> {
				assertThat(context).hasSingleBean(MongoClient.class);
				MongoClientSettings settings = getSettings(context);
				assertThat(settings.getApplicationName()).isEqualTo('custom-transport-settings');
				assertThat(settings.getTransportSettings())
					.isSameAs(SimpleTransportSettingsCustomizerConfig.transportSettings);
			});
	}
	@Test
	void definesPropertiesBasedConnectionDetailsByDefault() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(PropertiesMongoConnectionDetails.class));
	}
	@Test
	void shouldUseCustomConnectionDetailsWhenDefined() {
		this.contextRunner.withBean(MongoConnectionDetails.class, () -> new MongoConnectionDetails() {
			@Override
			public ConnectionString getConnectionString() {
				return new ConnectionString('mongodb://localhost');
			}
		})
			.run((context) -> assertThat(context).hasSingleBean(MongoConnectionDetails.class)
				.doesNotHaveBean(PropertiesMongoConnectionDetails.class));
	}
	@Test
	void uuidRepresentationDefaultsAreAligned() {
		this.contextRunner.run((context) -> assertThat(getSettings(context).getUuidRepresentation())
			.isEqualTo(new MongoProperties().getUuidRepresentation()));
	}
	private MongoClientSettings getSettings(ApplicationContext context) {
		MongoClientImpl client = (MongoClientImpl) context.getBean(MongoClient.class);
		return client.getSettings();
	}
	@Configuration(proxyBeanMethods = false)
	static class SettingsConfig {
		@Bean
		MongoClientSettings mongoClientSettings() {
			return MongoClientSettings.builder()
				.readPreference(ReadPreference.nearest())
				.applyToSocketSettings((socket) -> socket.readTimeout(300, TimeUnit.SECONDS))
				.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SslSettingsConfig {
		@Bean
		MongoClientSettings mongoClientSettings(TransportSettings transportSettings) {
			return MongoClientSettings.builder()
				.applicationName('test-config')
				.transportSettings(transportSettings)
				.build();
		}
		@Bean
		TransportSettings myTransportSettings() {
			return TransportSettings.nettyBuilder().build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SimpleTransportSettingsCustomizerConfig {
		private static final TransportSettings transportSettings = TransportSettings.nettyBuilder().build();
		@Bean
		MongoClientSettingsBuilderCustomizer customizer() {
			return (clientSettingsBuilder) -> clientSettingsBuilder.applicationName('custom-transport-settings')
				.transportSettings(transportSettings);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
abstract class MongoClientFactorySupportTests<T> {
	@Test
	void canBindCharArrayPassword() {
		// gh-1572
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.data.mongodb.password:word').applyTo(context);
		context.register(Config.class);
		context.refresh();
		MongoProperties properties = context.getBean(MongoProperties.class);
		assertThat(properties.getPassword()).isEqualTo('word'.toCharArray());
	}
	@Test
	void allMongoClientSettingsCanBeSet() {
		MongoClientSettings.Builder builder = MongoClientSettings.builder();
		builder.applyToSocketSettings((settings) -> {
			settings.connectTimeout(1000, TimeUnit.MILLISECONDS);
			settings.readTimeout(1000, TimeUnit.MILLISECONDS);
		}).applyToServerSettings((settings) -> {
			settings.heartbeatFrequency(10001, TimeUnit.MILLISECONDS);
			settings.minHeartbeatFrequency(501, TimeUnit.MILLISECONDS);
		}).applyToConnectionPoolSettings((settings) -> {
			settings.maxWaitTime(120001, TimeUnit.MILLISECONDS);
			settings.maxConnectionLifeTime(60000, TimeUnit.MILLISECONDS);
			settings.maxConnectionIdleTime(60000, TimeUnit.MILLISECONDS);
		}).applyToSslSettings((settings) -> settings.enabled(true)).applicationName('test');
		MongoClientSettings settings = builder.build();
		T client = createMongoClient(settings);
		MongoClientSettings wrapped = getClientSettings(client);
		assertThat(wrapped.getSocketSettings().getConnectTimeout(TimeUnit.MILLISECONDS))
			.isEqualTo(settings.getSocketSettings().getConnectTimeout(TimeUnit.MILLISECONDS));
		assertThat(wrapped.getSocketSettings().getReadTimeout(TimeUnit.MILLISECONDS))
			.isEqualTo(settings.getSocketSettings().getReadTimeout(TimeUnit.MILLISECONDS));
		assertThat(wrapped.getServerSettings().getHeartbeatFrequency(TimeUnit.MILLISECONDS))
			.isEqualTo(settings.getServerSettings().getHeartbeatFrequency(TimeUnit.MILLISECONDS));
		assertThat(wrapped.getServerSettings().getMinHeartbeatFrequency(TimeUnit.MILLISECONDS))
			.isEqualTo(settings.getServerSettings().getMinHeartbeatFrequency(TimeUnit.MILLISECONDS));
		assertThat(wrapped.getApplicationName()).isEqualTo(settings.getApplicationName());
		assertThat(wrapped.getConnectionPoolSettings().getMaxWaitTime(TimeUnit.MILLISECONDS))
			.isEqualTo(settings.getConnectionPoolSettings().getMaxWaitTime(TimeUnit.MILLISECONDS));
		assertThat(wrapped.getConnectionPoolSettings().getMaxConnectionLifeTime(TimeUnit.MILLISECONDS))
			.isEqualTo(settings.getConnectionPoolSettings().getMaxConnectionLifeTime(TimeUnit.MILLISECONDS));
		assertThat(wrapped.getConnectionPoolSettings().getMaxConnectionIdleTime(TimeUnit.MILLISECONDS))
			.isEqualTo(settings.getConnectionPoolSettings().getMaxConnectionIdleTime(TimeUnit.MILLISECONDS));
		assertThat(wrapped.getSslSettings().isEnabled()).isEqualTo(settings.getSslSettings().isEnabled());
	}
	@Test
	void customizerIsInvoked() {
		MongoClientSettingsBuilderCustomizer customizer = mock(MongoClientSettingsBuilderCustomizer.class);
		createMongoClient(customizer);
		then(customizer).should().customize(any(MongoClientSettings.Builder.class));
	}
	@Test
	void canBindAutoIndexCreation() {
		AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
		TestPropertyValues.of('spring.data.mongodb.autoIndexCreation:true').applyTo(context);
		context.register(Config.class);
		context.refresh();
		MongoProperties properties = context.getBean(MongoProperties.class);
		assertThat(properties.isAutoIndexCreation()).isTrue();
	}
	protected T createMongoClient(MongoClientSettings settings) {
		return createMongoClient(null, settings);
	}
	protected void createMongoClient(MongoClientSettingsBuilderCustomizer... customizers) {
		createMongoClient((customizers != null) ? Arrays.asList(customizers) : null,
				MongoClientSettings.builder().build());
	}
	protected abstract T createMongoClient(List<MongoClientSettingsBuilderCustomizer> customizers,
			MongoClientSettings settings);
	protected abstract MongoClientSettings getClientSettings(T client);
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(MongoProperties.class)
	static class Config {
	}
}
/*
package org.springframework.boot.autoconfigure.mongo;
/**
class PropertiesMongoConnectionDetailsTests {
	private final MongoProperties properties = new MongoProperties();
	@Test
	void credentialsCanBeConfiguredWithUsername() {
		this.properties.setUsername('user');
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getUsername()).isEqualTo('user');
		assertThat(connectionString.getPassword()).isEmpty();
		assertThat(connectionString.getCredential().getUserName()).isEqualTo('user');
		assertThat(connectionString.getCredential().getPassword()).isEmpty();
		assertThat(connectionString.getCredential().getSource()).isEqualTo('test');
	}
	@Test
	void credentialsCanBeConfiguredWithUsernameAndPassword() {
		this.properties.setUsername('user');
		this.properties.setPassword('secret'.toCharArray());
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getUsername()).isEqualTo('user');
		assertThat(connectionString.getPassword()).isEqualTo('secret'.toCharArray());
		assertThat(connectionString.getCredential().getUserName()).isEqualTo('user');
		assertThat(connectionString.getCredential().getPassword()).isEqualTo('secret'.toCharArray());
		assertThat(connectionString.getCredential().getSource()).isEqualTo('test');
	}
	@Test
	void databaseCanBeConfigured() {
		this.properties.setDatabase('db');
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getDatabase()).isEqualTo('db');
	}
	@Test
	void databaseHasDefaultWhenNotConfigured() {
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getDatabase()).isEqualTo('test');
	}
	@Test
	void authenticationDatabaseCanBeConfigured() {
		this.properties.setUsername('user');
		this.properties.setDatabase('db');
		this.properties.setAuthenticationDatabase('authdb');
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getDatabase()).isEqualTo('db');
		assertThat(connectionString.getCredential().getSource()).isEqualTo('authdb');
		assertThat(connectionString.getCredential().getUserName()).isEqualTo('user');
	}
	@Test
	void authenticationDatabaseIsNotConfiguredWhenUsernameIsNotConfigured() {
		this.properties.setAuthenticationDatabase('authdb');
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getCredential()).isNull();
	}
	@Test
	void replicaSetCanBeConfigured() {
		this.properties.setReplicaSetName('test');
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getRequiredReplicaSetName()).isEqualTo('test');
	}
	@Test
	void replicaSetCanBeConfiguredWithDatabase() {
		this.properties.setUsername('user');
		this.properties.setDatabase('db');
		this.properties.setReplicaSetName('test');
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getDatabase()).isEqualTo('db');
		assertThat(connectionString.getRequiredReplicaSetName()).isEqualTo('test');
	}
	@Test
	void replicaSetCanBeNull() {
		this.properties.setReplicaSetName(null);
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getRequiredReplicaSetName()).isNull();
	}
	@Test
	void replicaSetCanBeBlank() {
		this.properties.setReplicaSetName('');
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getRequiredReplicaSetName()).isNull();
	}
	@Test
	void whenAdditionalHostsAreConfiguredThenTheyAreIncludedInHostsOfConnectionString() {
		this.properties.setHost('mongo1.example.com');
		this.properties.setAdditionalHosts(List.of('mongo2.example.com', 'mongo3.example.com'));
		ConnectionString connectionString = getConnectionString();
		assertThat(connectionString.getHosts()).containsExactly('mongo1.example.com', 'mongo2.example.com',
				'mongo3.example.com');
	}
	private PropertiesMongoConnectionDetails createConnectionDetails() {
		return new PropertiesMongoConnectionDetails(this.properties);
	}
	private ConnectionString getConnectionString() {
		PropertiesMongoConnectionDetails connectionDetails = createConnectionDetails();
		return connectionDetails.getConnectionString();
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
public final class GraphQlTestDataFetchers {
	private static final List<Book> books = Arrays.asList(
			new Book('book-1', 'GraphQL for beginners', 100, 'John GraphQL'),
			new Book('book-2', 'Harry Potter and the Philosopher"s Stone', 223, 'Joanne Rowling'),
			new Book('book-3', 'Moby Dick', 635, 'Moby Dick'), new Book('book-3', 'Moby Dick', 635, 'Moby Dick'));
	private GraphQlTestDataFetchers() {
	}
	public static DataFetcher<Book> getBookByIdDataFetcher() {
		return (environment) -> getBookById(environment.getArgument('id'));
	}
	public static DataFetcher<Flux<Book>> getBooksOnSaleDataFetcher() {
		return (environment) -> getBooksOnSale(environment.getArgument('minPages'));
	}
	@Nullable
	public static Book getBookById(String id) {
		return books.stream().filter((book) -> book.getId().equals(id)).findFirst().orElse(null);
	}
	public static Flux<Book> getBooksOnSale(int minPages) {
		return Flux.fromIterable(books).filter((book) -> book.getPageCount() >= minPages);
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.security;
/**
class GraphQlWebMvcSecurityAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DispatcherServletAutoConfiguration.class,
				WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
				JacksonAutoConfiguration.class, GraphQlAutoConfiguration.class, GraphQlWebMvcAutoConfiguration.class,
				GraphQlWebMvcSecurityAutoConfiguration.class, SecurityAutoConfiguration.class))
		.withUserConfiguration(DataFetchersConfiguration.class, SecurityConfig.class)
		.withPropertyValues('spring.main.web-application-type=servlet');
	@Test
	void contributesSecurityComponents() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(SecurityDataFetcherExceptionResolver.class));
	}
	@Test
	void anonymousUserShouldBeUnauthorized() {
		withMockMvc((mvc) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author }}';
			assertThat(mvc.post().uri('/graphql').content('{\'query\': \'' + query + '\'}')).satisfies((result) -> {
				assertThat(result).hasStatusOk().hasContentTypeCompatibleWith(MediaType.APPLICATION_JSON);
				assertThat(result).bodyJson()
					.doesNotHavePath('data.bookById.name')
					.extractingPath('errors[0].extensions.classification')
					.asString()
					.isEqualTo(ErrorType.UNAUTHORIZED.toString());
			});
		});
	}
	@Test
	void authenticatedUserShouldGetData() {
		withMockMvc((mvc) -> {
			String query = '{  bookById(id: \\\'book-1\\\'){ id name pageCount author }}';
			assertThat(mvc.post().uri('/graphql').content('{\'query\': \'' + query + '\'}').with(user('rob')))
				.satisfies((result) -> {
					assertThat(result).hasStatusOk().hasContentTypeCompatibleWith(MediaType.APPLICATION_JSON);
					assertThat(result).bodyJson()
						.doesNotHavePath('errors')
						.extractingPath('data.bookById.name')
						.asString()
						.isEqualTo('GraphQL for beginners');
				});
		});
	}
	private void withMockMvc(ThrowingConsumer<MockMvcTester> mvc) {
		this.contextRunner.run((context) -> {
			MediaType mediaType = MediaType.APPLICATION_JSON;
			MockMvcTester mockMVc = MockMvcTester.from(context,
					(builder) -> builder.defaultRequest(post('/graphql').contentType(mediaType).accept(mediaType))
						.apply(springSecurity())
						.build());
			mvc.accept(mockMVc);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class DataFetchersConfiguration {
		@Bean
		RuntimeWiringConfigurer bookDataFetcher(BookService bookService) {
			return (builder) -> builder.type(TypeRuntimeWiring.newTypeWiring('Query')
				.dataFetcher('bookById', (env) -> bookService.getBookdById(env.getArgument('id'))));
		}
		@Bean
		BookService bookService() {
			return new BookService();
		}
	}
	static class BookService {
		@PreAuthorize('hasRole("USER")')
		@Nullable
		Book getBookdById(String id) {
			return GraphQlTestDataFetchers.getBookById(id);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebSecurity
	@EnableMethodSecurity(prePostEnabled = true)
	@SuppressWarnings('deprecation')
	static class SecurityConfig {
		@Bean
		DefaultSecurityFilterChain springWebFilterChain(HttpSecurity http) throws Exception {
			return http.csrf(CsrfConfigurer::disable)
				// Demonstrate that method security works
				// Best practice to use both for defense in depth
				.authorizeHttpRequests((requests) -> requests.anyRequest().permitAll())
				.httpBasic(withDefaults())
				.build();
		}
		@Bean
		InMemoryUserDetailsManager userDetailsService() {
			User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
			UserDetails rob = userBuilder.username('rob').password('rob').roles('USER').build();
			UserDetails admin = userBuilder.username('admin').password('admin').roles('USER', 'ADMIN').build();
			return new InMemoryUserDetailsManager(rob, admin);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.security;
/**
class GraphQlWebFluxSecurityAutoConfigurationTests {
	private static final String BASE_URL = 'https://spring.example.org/graphql';
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class,
				CodecsAutoConfiguration.class, JacksonAutoConfiguration.class, GraphQlAutoConfiguration.class,
				GraphQlWebFluxAutoConfiguration.class, GraphQlWebFluxSecurityAutoConfiguration.class,
				ReactiveSecurityAutoConfiguration.class))
		.withUserConfiguration(DataFetchersConfiguration.class, SecurityConfig.class)
		.withPropertyValues('spring.main.web-application-type=reactive');
	@Test
	void contributesExceptionResolver() {
		this.contextRunner
			.run((context) -> assertThat(context).hasSingleBean(ReactiveSecurityDataFetcherExceptionResolver.class));
	}
	@Test
	void anonymousUserShouldBeUnauthorized() {
		testWithWebClient((client) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author }}';
			client.post()
				.uri('')
				.bodyValue('{  \'query\': \'' + query + '\'}')
				.exchange()
				.expectStatus()
				.isOk()
				.expectBody()
				.jsonPath('data.bookById.name')
				.doesNotExist()
				.jsonPath('errors[0].extensions.classification')
				.isEqualTo(ErrorType.UNAUTHORIZED.toString());
		});
	}
	@Test
	void authenticatedUserShouldGetData() {
		testWithWebClient((client) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author }}';
			client.post()
				.uri('')
				.headers((headers) -> headers.setBasicAuth('rob', 'rob'))
				.bodyValue('{  \'query\': \'' + query + '\'}')
				.exchange()
				.expectStatus()
				.isOk()
				.expectBody()
				.jsonPath('data.bookById.name')
				.isEqualTo('GraphQL for beginners')
				.jsonPath('errors[0].extensions.classification')
				.doesNotExist();
		});
	}
	private void testWithWebClient(Consumer<WebTestClient> consumer) {
		this.contextRunner.run((context) -> {
			WebTestClient client = WebTestClient.bindToApplicationContext(context)
				.configureClient()
				.defaultHeaders((headers) -> {
					headers.setContentType(MediaType.APPLICATION_JSON);
					headers.setAccept(Collections.singletonList(MediaType.APPLICATION_JSON));
				})
				.baseUrl(BASE_URL)
				.build();
			consumer.accept(client);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class DataFetchersConfiguration {
		@Bean
		RuntimeWiringConfigurer bookDataFetcher(BookService bookService) {
			return (builder) -> builder.type(TypeRuntimeWiring.newTypeWiring('Query')
				.dataFetcher('bookById', (env) -> bookService.getBookdById(env.getArgument('id'))));
		}
		@Bean
		BookService bookService() {
			return new BookService();
		}
	}
	static class BookService {
		@PreAuthorize('hasRole("USER")')
		@Nullable
		Mono<Book> getBookdById(String id) {
			return Mono.justOrEmpty(GraphQlTestDataFetchers.getBookById(id));
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWebFluxSecurity
	@EnableReactiveMethodSecurity
	static class SecurityConfig {
		@Bean
		SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) {
			return http.csrf(CsrfSpec::disable)
				// Demonstrate that method security works
				// Best practice to use both for defense in depth
				.authorizeExchange((requests) -> requests.anyExchange().permitAll())
				.httpBasic(withDefaults())
				.build();
		}
		@Bean
		@SuppressWarnings('deprecation')
		MapReactiveUserDetailsService userDetailsService() {
			User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
			UserDetails rob = userBuilder.username('rob').password('rob').roles('USER').build();
			UserDetails admin = userBuilder.username('admin').password('admin').roles('USER', 'ADMIN').build();
			return new MapReactiveUserDetailsService(rob, admin);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
class DefaultGraphQlSchemaConditionTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner();
	@Test
	void matchesWhenSchemaFilesAreDetected() {
		this.contextRunner.withUserConfiguration(TestingConfiguration.class).run((context) -> {
			didMatch(context);
			assertThat(conditionReportMessage(context)).contains('@ConditionalOnGraphQlSchema found schemas')
				.contains('@ConditionalOnGraphQlSchema did not find GraphQlSourceBuilderCustomizer');
		});
	}
	@Test
	void matchesWhenCustomizerIsDetected() {
		this.contextRunner.withUserConfiguration(CustomCustomizerConfiguration.class, TestingConfiguration.class)
			.withPropertyValues('spring.graphql.schema.locations=classpath:graphql/missing')
			.run((context) -> {
				didMatch(context);
				assertThat(conditionReportMessage(context)).contains(
						'@ConditionalOnGraphQlSchema did not find schema files in locations "classpath:graphql/missing/"')
					.contains('@ConditionalOnGraphQlSchema found customizer myBuilderCustomizer');
			});
	}
	@Test
	void doesNotMatchWhenBothAreMissing() {
		this.contextRunner.withUserConfiguration(TestingConfiguration.class)
			.withPropertyValues('spring.graphql.schema.locations=classpath:graphql/missing')
			.run((context) -> {
				assertThat(context).doesNotHaveBean('success');
				assertThat(conditionReportMessage(context)).contains(
						'@ConditionalOnGraphQlSchema did not find schema files in locations "classpath:graphql/missing/"')
					.contains('@ConditionalOnGraphQlSchema did not find GraphQlSourceBuilderCustomizer');
			});
	}
	private void didMatch(AssertableApplicationContext context) {
		assertThat(context).hasBean('success');
		assertThat(context.getBean('success')).isEqualTo('success');
	}
	private String conditionReportMessage(AssertableApplicationContext context) {
		Collection<ConditionEvaluationReport.ConditionAndOutcomes> conditionAndOutcomes = ConditionEvaluationReport
			.get(context.getSourceApplicationContext().getBeanFactory())
			.getConditionAndOutcomesBySource()
			.values();
		return conditionAndOutcomes.iterator().next().iterator().next().getOutcome().getMessage();
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnGraphQlSchema
	static class TestingConfiguration {
		@Bean
		String success() {
			return 'success';
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomCustomizerConfiguration {
		@Bean
		GraphQlSourceBuilderCustomizer myBuilderCustomizer() {
			return (builder) -> {
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
class GraphQlReactiveQueryByExampleAutoConfigurationTests {
	private static final Mono<Book> bookPublisher = Mono.just(new Book('42', 'Test title', 42, 'Test Author'));
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(GraphQlAutoConfiguration.class,
				GraphQlReactiveQueryByExampleAutoConfiguration.class))
		.withUserConfiguration(MockRepositoryConfig.class)
		.withPropertyValues('spring.main.web-application-type=reactive');
	@Test
	void shouldRegisterDataFetcherForQueryByExampleRepositories() {
		this.contextRunner.run((context) -> {
			ExecutionGraphQlService graphQlService = context.getBean(ExecutionGraphQlService.class);
			GraphQlTester graphQlTester = ExecutionGraphQlServiceTester.create(graphQlService);
			graphQlTester.document('{ bookById(id: 1) {name}}')
				.execute()
				.path('bookById.name')
				.entity(String.class)
				.isEqualTo('Test title');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class MockRepositoryConfig {
		@Bean
		MockRepository mockRepository() {
			MockRepository mockRepository = mock(MockRepository.class);
			given(mockRepository.findBy(any(), any())).willReturn(bookPublisher);
			return mockRepository;
		}
	}
	@GraphQlRepository
	interface MockRepository extends ReactiveCrudRepository<Book, Long>, ReactiveQueryByExampleExecutor<Book> {
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
class GraphQlReactiveQuerydslAutoConfigurationTests {
	private static final Mono<Book> bookPublisher = Mono.just(new Book('42', 'Test title', 42, 'Test Author'));
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(GraphQlAutoConfiguration.class, GraphQlReactiveQuerydslAutoConfiguration.class))
		.withUserConfiguration(MockRepositoryConfig.class)
		.withPropertyValues('spring.main.web-application-type=reactive');
	@Test
	void shouldRegisterDataFetcherForQueryDslRepositories() {
		this.contextRunner.run((context) -> {
			ExecutionGraphQlService graphQlService = context.getBean(ExecutionGraphQlService.class);
			GraphQlTester graphQlTester = ExecutionGraphQlServiceTester.create(graphQlService);
			graphQlTester.document('{ bookById(id: 1) {name}}')
				.execute()
				.path('bookById.name')
				.entity(String.class)
				.isEqualTo('Test title');
		});
	}
	@Test
	void shouldBackOffWithoutQueryDsl() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('com.querydsl.core'))
			.run((context) -> assertThat(context).doesNotHaveBean('querydslRegistrar')
				.doesNotHaveBean(GraphQlReactiveQuerydslAutoConfiguration.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class MockRepositoryConfig {
		@Bean
		MockRepository mockRepository() {
			MockRepository mockRepository = mock(MockRepository.class);
			given(mockRepository.findBy(any(), any())).willReturn(bookPublisher);
			return mockRepository;
		}
	}
	@GraphQlRepository
	interface MockRepository extends ReactiveCrudRepository<Book, Long>, ReactiveQuerydslPredicateExecutor<Book> {
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
class GraphQlQueryByExampleAutoConfigurationTests {
	private static final Book book = new Book('42', 'Test title', 42, 'Test Author');
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(GraphQlAutoConfiguration.class, GraphQlQueryByExampleAutoConfiguration.class))
		.withUserConfiguration(MockRepositoryConfig.class)
		.withPropertyValues('spring.main.web-application-type=servlet');
	@Test
	void shouldRegisterDataFetcherForQueryByExampleRepositories() {
		this.contextRunner.run((context) -> {
			ExecutionGraphQlService graphQlService = context.getBean(ExecutionGraphQlService.class);
			ExecutionGraphQlServiceTester graphQlTester = ExecutionGraphQlServiceTester.create(graphQlService);
			graphQlTester.document('{ bookById(id: 1) {name}}')
				.execute()
				.path('bookById.name')
				.entity(String.class)
				.isEqualTo('Test title');
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class MockRepositoryConfig {
		@Bean
		MockRepository mockRepository() {
			MockRepository mockRepository = mock(MockRepository.class);
			given(mockRepository.findBy(any(), any())).willReturn(Optional.of(book));
			return mockRepository;
		}
	}
	@GraphQlRepository
	interface MockRepository extends CrudRepository<Book, Long>, QueryByExampleExecutor<Book> {
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.data;
/**
class GraphQlQuerydslAutoConfigurationTests {
	private static final Book book = new Book('42', 'Test title', 42, 'Test Author');
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(GraphQlAutoConfiguration.class, GraphQlQuerydslAutoConfiguration.class))
		.withUserConfiguration(MockRepositoryConfig.class)
		.withPropertyValues('spring.main.web-application-type=servlet');
	@Test
	void shouldRegisterDataFetcherForQueryDslRepositories() {
		this.contextRunner.run((context) -> {
			ExecutionGraphQlService graphQlService = context.getBean(ExecutionGraphQlService.class);
			GraphQlTester graphQlTester = ExecutionGraphQlServiceTester.create(graphQlService);
			graphQlTester.document('{ bookById(id: 1) {name}}')
				.execute()
				.path('bookById.name')
				.entity(String.class)
				.isEqualTo('Test title');
		});
	}
	@Test
	void shouldBackOffWithoutQueryDsl() {
		this.contextRunner.withClassLoader(new FilteredClassLoader('com.querydsl.core'))
			.run((context) -> assertThat(context).doesNotHaveBean('querydslRegistrar')
				.doesNotHaveBean(GraphQlQuerydslAutoConfiguration.class));
	}
	@Configuration(proxyBeanMethods = false)
	static class MockRepositoryConfig {
		@Bean
		MockRepository mockRepository() {
			MockRepository mockRepository = mock(MockRepository.class);
			given(mockRepository.findBy(any(), any())).willReturn(Optional.of(book));
			return mockRepository;
		}
	}
	@GraphQlRepository
	interface MockRepository extends CrudRepository<Book, Long>, QuerydslPredicateExecutor<Book> {
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
@ExtendWith(OutputCaptureExtension.class)
class GraphQlAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(GraphQlAutoConfiguration.class));
	@Test
	void shouldContributeDefaultBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(GraphQlSource.class)
			.hasSingleBean(BatchLoaderRegistry.class)
			.hasSingleBean(ExecutionGraphQlService.class)
			.hasSingleBean(AnnotatedControllerConfigurer.class)
			.hasSingleBean(EncodingCursorStrategy.class));
	}
	@Test
	void schemaShouldScanNestedFolders() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(GraphQlSource.class);
			GraphQlSource graphQlSource = context.getBean(GraphQlSource.class);
			GraphQLSchema schema = graphQlSource.schema();
			assertThat(schema.getObjectType('Book')).isNotNull();
		});
	}
	@Test
	void shouldBackoffWhenSchemaFileIsMissing() {
		this.contextRunner.withPropertyValues('spring.graphql.schema.locations:classpath:missing/')
			.run((context) -> assertThat(context).hasNotFailed().doesNotHaveBean(GraphQlSource.class));
	}
	@Test
	void shouldUseProgrammaticallyDefinedBuilder() {
		this.contextRunner.withUserConfiguration(CustomGraphQlBuilderConfiguration.class).run((context) -> {
			assertThat(context).hasBean('customGraphQlSourceBuilder');
			assertThat(context).hasSingleBean(GraphQlSource.Builder.class);
		});
	}
	@Test
	void shouldScanLocationsWithCustomExtension() {
		this.contextRunner.withPropertyValues('spring.graphql.schema.file-extensions:.graphqls,.custom')
			.run((context) -> {
				assertThat(context).hasSingleBean(GraphQlSource.class);
				GraphQlSource graphQlSource = context.getBean(GraphQlSource.class);
				GraphQLSchema schema = graphQlSource.schema();
				assertThat(schema.getObjectType('Book')).isNotNull();
				assertThat(schema.getObjectType('Person')).isNotNull();
			});
	}
	@Test
	void shouldBackOffWithCustomGraphQlSource() {
		this.contextRunner.withUserConfiguration(CustomGraphQlSourceConfiguration.class).run((context) -> {
			assertThat(context).getBeanNames(GraphQlSource.class).containsOnly('customGraphQlSource');
			assertThat(context).hasSingleBean(GraphQlProperties.class);
		});
	}
	@Test
	void shouldConfigureDataFetcherExceptionResolvers() {
		this.contextRunner.withUserConfiguration(DataFetcherExceptionResolverConfiguration.class).run((context) -> {
			GraphQlSource graphQlSource = context.getBean(GraphQlSource.class);
			GraphQL graphQL = graphQlSource.graphQl();
			assertThat(graphQL.getQueryStrategy()).extracting('dataFetcherExceptionHandler')
				.satisfies((exceptionHandler) -> {
					assertThat(exceptionHandler.getClass().getName()).endsWith('ExceptionResolversExceptionHandler');
					assertThat(exceptionHandler).extracting('resolvers')
						.asInstanceOf(InstanceOfAssertFactories.LIST)
						.hasSize(2);
				});
		});
	}
	@Test
	void shouldConfigureInstrumentation() {
		this.contextRunner.withUserConfiguration(InstrumentationConfiguration.class).run((context) -> {
			GraphQlSource graphQlSource = context.getBean(GraphQlSource.class);
			Instrumentation customInstrumentation = context.getBean('customInstrumentation', Instrumentation.class);
			GraphQL graphQL = graphQlSource.graphQl();
			assertThat(graphQL).extracting('instrumentation')
				.isInstanceOf(ChainedInstrumentation.class)
				.extracting('instrumentations', InstanceOfAssertFactories.iterable(Instrumentation.class))
				.contains(customInstrumentation);
		});
	}
	@Test
	void shouldApplyRuntimeWiringConfigurers() {
		this.contextRunner.withUserConfiguration(RuntimeWiringConfigurerConfiguration.class).run((context) -> {
			RuntimeWiringConfigurerConfiguration.CustomRuntimeWiringConfigurer configurer = context
				.getBean(RuntimeWiringConfigurerConfiguration.CustomRuntimeWiringConfigurer.class);
			assertThat(configurer.applied).isTrue();
		});
	}
	@Test
	void shouldApplyGraphQlSourceBuilderCustomizer() {
		this.contextRunner.withUserConfiguration(GraphQlSourceBuilderCustomizerConfiguration.class).run((context) -> {
			GraphQlSourceBuilderCustomizerConfiguration.CustomGraphQlSourceBuilderCustomizer customizer = context
				.getBean(GraphQlSourceBuilderCustomizerConfiguration.CustomGraphQlSourceBuilderCustomizer.class);
			assertThat(customizer.applied).isTrue();
		});
	}
	@Test
	void schemaInspectionShouldBeEnabledByDefault(CapturedOutput output) {
		this.contextRunner.run((context) -> assertThat(output).contains('GraphQL schema inspection'));
	}
	@Test
	void fieldIntrospectionShouldBeEnabledByDefault() {
		this.contextRunner.run((context) -> assertThat(Introspection.isEnabledJvmWide()).isTrue());
	}
	@Test
	void shouldDisableFieldIntrospection() {
		this.contextRunner.withPropertyValues('spring.graphql.schema.introspection.enabled:false')
			.run((context) -> assertThat(Introspection.isEnabledJvmWide()).isFalse());
	}
	@Test
	void shouldConfigureCustomBatchLoaderRegistry() {
		this.contextRunner
			.withBean('customBatchLoaderRegistry', BatchLoaderRegistry.class, () -> mock(BatchLoaderRegistry.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(BatchLoaderRegistry.class);
				assertThat(context.getBean('customBatchLoaderRegistry'))
					.isSameAs(context.getBean(BatchLoaderRegistry.class));
				assertThat(context.getBean(ExecutionGraphQlService.class))
					.extracting('dataLoaderRegistrars', InstanceOfAssertFactories.list(DataLoaderRegistrar.class))
					.containsOnly(context.getBean(BatchLoaderRegistry.class));
			});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new GraphQlResourcesRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('graphql/sample/schema.gqls')).accepts(hints);
		assertThat(RuntimeHintsPredicates.resource().forResource('graphql/other.graphqls')).accepts(hints);
	}
	@Test
	void shouldContributeConnectionTypeDefinitionConfigurer() {
		this.contextRunner.withUserConfiguration(CustomGraphQlBuilderConfiguration.class).run((context) -> {
			GraphQlSource graphQlSource = context.getBean(GraphQlSource.class);
			GraphQLSchema schema = graphQlSource.schema();
			GraphQLOutputType bookConnection = schema.getQueryType().getField('books').getType();
			assertThat(bookConnection).isInstanceOf(GraphQLObjectType.class);
			assertThat((GraphQLObjectType) bookConnection)
				.satisfies((connection) -> assertThat(connection.getFieldDefinition('edges')).isNotNull());
		});
	}
	@Test
	void whenApplicationTaskExecutorIsDefinedThenAnnotatedControllerConfigurerShouldUseIt() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(TaskExecutionAutoConfiguration.class))
			.run((context) -> {
				AnnotatedControllerConfigurer annotatedControllerConfigurer = context
					.getBean(AnnotatedControllerConfigurer.class);
				assertThat(annotatedControllerConfigurer).extracting('executor')
					.isSameAs(context.getBean('applicationTaskExecutor'));
			});
	}
	@Test
	void whenCustomExecutorIsDefinedThenAnnotatedControllerConfigurerDoesNotUseIt() {
		this.contextRunner.withUserConfiguration(CustomExecutorConfiguration.class).run((context) -> {
			AnnotatedControllerConfigurer annotatedControllerConfigurer = context
				.getBean(AnnotatedControllerConfigurer.class);
			assertThat(annotatedControllerConfigurer).extracting('executor').isNull();
		});
	}
	@Test
	void whenAHandlerMethodArgumentResolverIsDefinedThenAnnotatedControllerConfigurerShouldUseIt() {
		this.contextRunner.withUserConfiguration(CustomHandlerMethodArgumentResolverConfiguration.class)
			.run((context) -> assertThat(context.getBean(AnnotatedControllerConfigurer.class))
				.extracting('customArgumentResolvers')
				.asInstanceOf(InstanceOfAssertFactories.LIST)
				.hasSize(1));
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomGraphQlBuilderConfiguration {
		@Bean
		GraphQlSource.SchemaResourceBuilder customGraphQlSourceBuilder() {
			return GraphQlSource.schemaResourceBuilder()
				.schemaResources(new ClassPathResource('graphql/schema.graphqls'),
						new ClassPathResource('graphql/types/book.graphqls'));
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomGraphQlSourceConfiguration {
		@Bean
		GraphQlSource customGraphQlSource() {
			ByteArrayResource schemaResource = new ByteArrayResource(
					'type Query { greeting: String }'.getBytes(StandardCharsets.UTF_8));
			return GraphQlSource.schemaResourceBuilder().schemaResources(schemaResource).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataFetcherExceptionResolverConfiguration {
		@Bean
		DataFetcherExceptionResolver customDataFetcherExceptionResolver() {
			return mock(DataFetcherExceptionResolver.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class InstrumentationConfiguration {
		@Bean
		Instrumentation customInstrumentation() {
			return mock(Instrumentation.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class RuntimeWiringConfigurerConfiguration {
		@Bean
		CustomRuntimeWiringConfigurer customRuntimeWiringConfigurer() {
			return new CustomRuntimeWiringConfigurer();
		}
		public static class CustomRuntimeWiringConfigurer implements RuntimeWiringConfigurer {
			public boolean applied = false;
			@Override
			public void configure(RuntimeWiring.Builder builder) {
				this.applied = true;
			}
		}
	}
	static class GraphQlSourceBuilderCustomizerConfiguration {
		@Bean
		CustomGraphQlSourceBuilderCustomizer customGraphQlSourceBuilderCustomizer() {
			return new CustomGraphQlSourceBuilderCustomizer();
		}
		public static class CustomGraphQlSourceBuilderCustomizer implements GraphQlSourceBuilderCustomizer {
			public boolean applied = false;
			@Override
			public void customize(GraphQlSource.SchemaResourceBuilder builder) {
				this.applied = true;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomExecutorConfiguration {
		@Bean
		Executor customExecutor() {
			return mock(Executor.class);
		}
	}
	static class CustomHandlerMethodArgumentResolverConfiguration {
		@Bean
		HandlerMethodArgumentResolver customHandlerMethodArgumentResolver() {
			return mock(HandlerMethodArgumentResolver.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.servlet;
/**
class GraphQlWebMvcAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(DispatcherServletAutoConfiguration.class,
				WebMvcAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
				JacksonAutoConfiguration.class, GraphQlAutoConfiguration.class, GraphQlWebMvcAutoConfiguration.class))
		.withUserConfiguration(DataFetchersConfiguration.class, CustomWebInterceptor.class)
		.withPropertyValues('spring.main.web-application-type=servlet', 'spring.graphql.graphiql.enabled=true',
				'spring.graphql.schema.printer.enabled=true', 'spring.graphql.cors.allowed-origins=https://example.com',
				'spring.graphql.cors.allowed-methods=POST', 'spring.graphql.cors.allow-credentials=true');
	@Test
	void shouldContributeDefaultBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(GraphQlHttpHandler.class)
			.hasSingleBean(WebGraphQlHandler.class)
			.doesNotHaveBean(GraphQlWebSocketHandler.class));
	}
	@Test
	void simpleQueryShouldWork() {
		withMockMvc((mvc) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			assertThat(mvc.post().uri('/graphql').content('{\'query\': \'' + query + '\'}')).satisfies((result) -> {
				assertThat(result).hasStatusOk().hasContentTypeCompatibleWith(MediaType.APPLICATION_GRAPHQL_RESPONSE);
				assertThat(result).bodyJson()
					.extractingPath('data.bookById.name')
					.asString()
					.isEqualTo('GraphQL for beginners');
			});
		});
	}
	@Test
	void SseSubscriptionShouldWork() {
		withMockMvc((mvc) -> {
			String query = '{ booksOnSale(minPages: 50){ id name pageCount author } }';
			assertThat(mvc.post()
				.uri('/graphql')
				.accept(MediaType.TEXT_EVENT_STREAM)
				.content('{\'query\': \'subscription TestSubscription ' + query + '\'}')).satisfies((result) -> {
					assertThat(result).hasStatusOk().hasContentTypeCompatibleWith(MediaType.TEXT_EVENT_STREAM);
					assertThat(result).bodyText()
						.containsSubsequence('event:next',
								'data:{\'data\':{\'booksOnSale\':{\'id\':\'book-1\',\'name\':\'GraphQL for beginners\',\'pageCount\':100,\'author\':\'John GraphQL\'}}}',
								'event:next',
								'data:{\'data\':{\'booksOnSale\':{\'id\':\'book-2\',\'name\':\'Harry Potter and the Philosopher"s Stone\',\'pageCount\':223,\'author\':\'Joanne Rowling\'}}}');
				});
		});
	}
	@Test
	void unsupportedContentTypeShouldBeRejected() {
		withMockMvc((mvc) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			assertThat(mvc.post()
				.uri('/graphql')
				.content('{\'query\': \'' + query + '\'}')
				.contentType(MediaType.TEXT_PLAIN)).hasStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE)
				.headers()
				.hasValue('Accept', 'application/json');
		});
	}
	@Test
	void httpGetQueryShouldBeRejected() {
		withMockMvc((mvc) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			assertThat(mvc.get().uri('/graphql?query={query}', '{\'query\': \'' + query + '\'}'))
				.hasStatus(HttpStatus.METHOD_NOT_ALLOWED)
				.headers()
				.hasValue('Allow', 'POST');
		});
	}
	@Test
	void shouldRejectMissingQuery() {
		withMockMvc((mvc) -> assertThat(mvc.post().uri('/graphql').content('{}')).hasStatus(HttpStatus.BAD_REQUEST));
	}
	@Test
	void shouldRejectQueryWithInvalidJson() {
		withMockMvc((mvc) -> assertThat(mvc.post().uri('/graphql').content(':)')).hasStatus(HttpStatus.BAD_REQUEST));
	}
	@Test
	void shouldConfigureWebInterceptors() {
		withMockMvc((mvc) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			assertThat(mvc.post().uri('/graphql').content('{\'query\': \'' + query + '\'}')).hasStatusOk()
				.headers()
				.hasValue('X-Custom-Header', '42');
		});
	}
	@Test
	void shouldExposeSchemaEndpoint() {
		withMockMvc((mvc) -> assertThat(mvc.get().uri('/graphql/schema')).hasStatusOk()
			.hasContentType(MediaType.TEXT_PLAIN)
			.bodyText()
			.contains('type Book'));
	}
	@Test
	void shouldExposeGraphiqlEndpoint() {
		withMockMvc((mvc) -> {
			assertThat(mvc.get().uri('/graphiql')).hasStatus3xxRedirection()
				.hasRedirectedUrl('http://localhost/graphiql?path=/graphql');
			assertThat(mvc.get().uri('/graphiql?path=/graphql')).hasStatusOk()
				.contentType()
				.isEqualTo(MediaType.TEXT_HTML);
		});
	}
	@Test
	void shouldSupportCors() {
		withMockMvc((mvc) -> {
			String query = '{' + '  bookById(id: \\\'book-1\\\'){ ' + '    id' + '    name' + '    pageCount'
					+ '    author' + '  }' + '}';
			assertThat(mvc.post()
				.uri('/graphql')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'POST')
				.header(HttpHeaders.ORIGIN, 'https://example.com')
				.content('{\'query\': \'' + query + '\'}'))
				.satisfies((result) -> assertThat(result).hasStatusOk()
					.headers()
					.containsEntry(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, List.of('https://example.com'))
					.containsEntry(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, List.of('true')));
		});
	}
	@Test
	void shouldConfigureWebSocketBeans() {
		this.contextRunner.withPropertyValues('spring.graphql.websocket.path=/ws').run((context) -> {
			assertThat(context).hasSingleBean(GraphQlWebSocketHandler.class);
			assertThat(context.getBeanProvider(HandlerMapping.class).orderedStream().toList()).containsSubsequence(
					context.getBean(WebSocketHandlerMapping.class), context.getBean(RouterFunctionMapping.class),
					context.getBean(RequestMappingHandlerMapping.class));
		});
	}
	@Test
	void shouldConfigureWebSocketProperties() {
		this.contextRunner
			.withPropertyValues('spring.graphql.websocket.path=/ws',
					'spring.graphql.websocket.connection-init-timeout=120s', 'spring.graphql.websocket.keep-alive=30s')
			.run((context) -> {
				assertThat(context).hasSingleBean(GraphQlWebSocketHandler.class);
				GraphQlWebSocketHandler graphQlWebSocketHandler = context.getBean(GraphQlWebSocketHandler.class);
				assertThat(graphQlWebSocketHandler).extracting('initTimeoutDuration')
					.isEqualTo(Duration.ofSeconds(120));
				assertThat(graphQlWebSocketHandler).extracting('keepAliveDuration').isEqualTo(Duration.ofSeconds(30));
			});
	}
	@Test
	void routerFunctionShouldHaveOrderZero() {
		this.contextRunner.withUserConfiguration(CustomRouterFunctions.class).run((context) -> {
			Map<String, ?> beans = context.getBeansOfType(RouterFunction.class);
			Object[] ordered = context.getBeanProvider(RouterFunction.class).orderedStream().toArray();
			assertThat(beans.get('before')).isSameAs(ordered[0]);
			assertThat(beans.get('graphQlRouterFunction')).isSameAs(ordered[1]);
			assertThat(beans.get('after')).isSameAs(ordered[2]);
		});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new GraphQlWebMvcAutoConfiguration.GraphiQlResourceHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('graphiql/index.html')).accepts(hints);
	}
	private void withMockMvc(ThrowingConsumer<MockMvcTester> mvc) {
		this.contextRunner.run((context) -> {
			MockMvcTester mockMVc = MockMvcTester.from(context,
					(builder) -> builder
						.defaultRequest(post('/graphql').contentType(MediaType.APPLICATION_JSON)
							.accept(MediaType.APPLICATION_GRAPHQL_RESPONSE))
						.build());
			mvc.accept(mockMVc);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class DataFetchersConfiguration {
		@Bean
		RuntimeWiringConfigurer bookDataFetcher() {
			return (builder) -> {
				builder.type(TypeRuntimeWiring.newTypeWiring('Query')
					.dataFetcher('bookById', GraphQlTestDataFetchers.getBookByIdDataFetcher()));
				builder.type(TypeRuntimeWiring.newTypeWiring('Subscription')
					.dataFetcher('booksOnSale', GraphQlTestDataFetchers.getBooksOnSaleDataFetcher()));
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebInterceptor {
		@Bean
		WebGraphQlInterceptor customWebGraphQlInterceptor() {
			return (webInput, interceptorChain) -> interceptorChain.next(webInput)
				.doOnNext((output) -> output.getResponseHeaders().add('X-Custom-Header', '42'));
		}
	}
	@Configuration
	static class CustomRouterFunctions {
		@Bean
		@Order(-1)
		RouterFunction<?> before() {
			return (r) -> null;
		}
		@Bean
		@Order(1)
		RouterFunction<?> after() {
			return (r) -> null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
public class Book {
	@Id
	String id;
	String name;
	int pageCount;
	String author;
	public Book() {
	}
	public Book(String id, String name, int pageCount, String author) {
		this.id = id;
		this.name = name;
		this.pageCount = pageCount;
		this.author = author;
	}
	public String getId() {
		return this.id;
	}
	public void setId(String id) {
		this.id = id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getPageCount() {
		return this.pageCount;
	}
	public void setPageCount(int pageCount) {
		this.pageCount = pageCount;
	}
	public String getAuthor() {
		return this.author;
	}
	public void setAuthor(String author) {
		this.author = author;
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.rsocket;
/**
class GraphQlRSocketAutoConfigurationTests {
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(JacksonAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class,
						RSocketMessagingAutoConfiguration.class, RSocketServerAutoConfiguration.class,
						GraphQlAutoConfiguration.class, GraphQlRSocketAutoConfiguration.class))
		.withUserConfiguration(DataFetchersConfiguration.class)
		.withPropertyValues('spring.main.web-application-type=reactive', 'spring.graphql.rsocket.mapping=graphql');
	@Test
	void shouldContributeDefaultBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(GraphQlRSocketHandler.class)
			.hasSingleBean(GraphQlRSocketController.class));
	}
	@Test
	void simpleQueryShouldWorkWithTcpServer() {
		testWithRSocketTcp(this::assertThatSimpleQueryWorks);
	}
	@Test
	void simpleQueryShouldWorkWithWebSocketServer() {
		testWithRSocketWebSocket(this::assertThatSimpleQueryWorks);
	}
	private void assertThatSimpleQueryWorks(RSocketGraphQlClient client) {
		String document = '{ bookById(id: \'book-1\'){ id name pageCount author } }';
		String bookName = client.document(document)
			.retrieve('bookById.name')
			.toEntity(String.class)
			.block(Duration.ofSeconds(5));
		assertThat(bookName).isEqualTo('GraphQL for beginners');
	}
	private void testWithRSocketTcp(Consumer<RSocketGraphQlClient> consumer) {
		ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
			.withConfiguration(
					AutoConfigurations.of(JacksonAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class,
							RSocketMessagingAutoConfiguration.class, RSocketServerAutoConfiguration.class,
							GraphQlAutoConfiguration.class, GraphQlRSocketAutoConfiguration.class))
			.withUserConfiguration(DataFetchersConfiguration.class)
			.withPropertyValues('spring.main.web-application-type=reactive', 'spring.graphql.rsocket.mapping=graphql');
		contextRunner.withInitializer(new RSocketPortInfoApplicationContextInitializer())
			.withPropertyValues('spring.rsocket.server.port=0')
			.run((context) -> {
				String serverPort = context.getEnvironment().getProperty('local.rsocket.server.port');
				RSocketGraphQlClient client = RSocketGraphQlClient.builder()
					.tcp('localhost', Integer.parseInt(serverPort))
					.route('graphql')
					.build();
				consumer.accept(client);
			});
	}
	private void testWithRSocketWebSocket(Consumer<RSocketGraphQlClient> consumer) {
		ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner(
				AnnotationConfigReactiveWebServerApplicationContext::new)
			.withConfiguration(AutoConfigurations.of(HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class,
					ErrorWebFluxAutoConfiguration.class, PropertyPlaceholderAutoConfiguration.class,
					JacksonAutoConfiguration.class, RSocketStrategiesAutoConfiguration.class,
					RSocketMessagingAutoConfiguration.class, RSocketServerAutoConfiguration.class,
					GraphQlAutoConfiguration.class, GraphQlRSocketAutoConfiguration.class))
			.withInitializer(new ServerPortInfoApplicationContextInitializer())
			.withUserConfiguration(DataFetchersConfiguration.class, NettyServerConfiguration.class)
			.withPropertyValues('spring.main.web-application-type=reactive', 'server.port=0',
					'spring.graphql.rsocket.mapping=graphql', 'spring.rsocket.server.transport=websocket',
					'spring.rsocket.server.mapping-path=/rsocket');
		contextRunner.run((context) -> {
			String serverPort = context.getEnvironment().getProperty('local.server.port');
			RSocketGraphQlClient client = RSocketGraphQlClient.builder()
				.webSocket(URI.create('ws://localhost:' + serverPort + '/rsocket'))
				.route('graphql')
				.build();
			consumer.accept(client);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class NettyServerConfiguration {
		@Bean
		NettyReactiveWebServerFactory serverFactory(NettyRouteProvider routeProvider) {
			NettyReactiveWebServerFactory serverFactory = new NettyReactiveWebServerFactory(0);
			serverFactory.addRouteProviders(routeProvider);
			return serverFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DataFetchersConfiguration {
		@Bean
		RuntimeWiringConfigurer bookDataFetcher() {
			return (builder) -> builder.type(TypeRuntimeWiring.newTypeWiring('Query')
				.dataFetcher('bookById', GraphQlTestDataFetchers.getBookByIdDataFetcher()));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.rsocket;
/**
class RSocketGraphQlClientAutoConfigurationTests {
	private static final RSocketGraphQlClient.Builder<?> builderInstance = RSocketGraphQlClient.builder();
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(RSocketStrategiesAutoConfiguration.class,
				RSocketRequesterAutoConfiguration.class, RSocketGraphQlClientAutoConfiguration.class));
	@Test
	void shouldCreateBuilder() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(RSocketGraphQlClient.Builder.class));
	}
	@Test
	void shouldGetPrototypeScopedBean() {
		this.contextRunner.run((context) -> {
			RSocketGraphQlClient.Builder<?> first = context.getBean(RSocketGraphQlClient.Builder.class);
			RSocketGraphQlClient.Builder<?> second = context.getBean(RSocketGraphQlClient.Builder.class);
			assertThat(first).isNotEqualTo(second);
		});
	}
	@Test
	void shouldNotCreateBuilderIfAlreadyPresent() {
		this.contextRunner.withUserConfiguration(CustomRSocketGraphQlClientBuilder.class).run((context) -> {
			RSocketGraphQlClient.Builder<?> builder = context.getBean(RSocketGraphQlClient.Builder.class);
			assertThat(builder).isEqualTo(builderInstance);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomRSocketGraphQlClientBuilder {
		@Bean
		RSocketGraphQlClient.Builder<?> myRSocketGraphQlClientBuilder() {
			return builderInstance;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.graphql;
/**
public class QBook extends EntityPathBase<Book> {
	private static final long serialVersionUID = -1932588188L;
	public static final QBook book = new QBook('book');
	public final StringPath author = createString('author');
	public final StringPath id = createString('id');
	public final StringPath name = createString('name');
	public final NumberPath<Integer> pageCount = createNumber('pageCount', Integer.class);
	public QBook(String variable) {
		super(Book.class, PathMetadataFactory.forVariable(variable));
	}
	public QBook(Path<? extends Book> path) {
		super(path.getType(), path.getMetadata());
	}
	public QBook(PathMetadata metadata) {
		super(Book.class, metadata);
	}
}
/*
package org.springframework.boot.autoconfigure.graphql.reactive;
/**
class GraphQlWebFluxAutoConfigurationTests {
	private static final String BASE_URL = 'https://spring.example.org/';
	private final ReactiveWebApplicationContextRunner contextRunner = new ReactiveWebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class,
				CodecsAutoConfiguration.class, JacksonAutoConfiguration.class, GraphQlAutoConfiguration.class,
				GraphQlWebFluxAutoConfiguration.class))
		.withUserConfiguration(DataFetchersConfiguration.class, CustomWebInterceptor.class)
		.withPropertyValues('spring.main.web-application-type=reactive', 'spring.graphql.graphiql.enabled=true',
				'spring.graphql.schema.printer.enabled=true', 'spring.graphql.cors.allowed-origins=https://example.com',
				'spring.graphql.cors.allowed-methods=POST', 'spring.graphql.cors.allow-credentials=true');
	@Test
	void shouldContributeDefaultBeans() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(GraphQlHttpHandler.class)
			.hasSingleBean(WebGraphQlHandler.class)
			.doesNotHaveBean(GraphQlWebSocketHandler.class));
	}
	@Test
	void simpleQueryShouldWork() {
		testWithWebClient((client) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			client.post()
				.uri('/graphql')
				.bodyValue('{  \'query\': \'' + query + '\'}')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.contentType(MediaType.APPLICATION_GRAPHQL_RESPONSE_VALUE)
				.expectBody()
				.jsonPath('data.bookById.name')
				.isEqualTo('GraphQL for beginners');
		});
	}
	@Test
	void SseSubscriptionShouldWork() {
		testWithWebClient((client) -> {
			String query = '{ booksOnSale(minPages: 50){ id name pageCount author } }';
			EntityExchangeResult<String> result = client.post()
				.uri('/graphql')
				.accept(MediaType.TEXT_EVENT_STREAM)
				.bodyValue('{  \'query\': \'subscription TestSubscription ' + query + '\'}')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.contentTypeCompatibleWith(MediaType.TEXT_EVENT_STREAM)
				.expectBody(String.class)
				.returnResult();
			assertThat(result.getResponseBody()).contains('event:next',
					'data:{\'data\':{\'booksOnSale\':{\'id\':\'book-1\',\'name\':\'GraphQL for beginners\',\'pageCount\':100,\'author\':\'John GraphQL\'}}}',
					'event:next',
					'data:{\'data\':{\'booksOnSale\':{\'id\':\'book-2\',\'name\':\'Harry Potter and the Philosopher"s Stone\',\'pageCount\':223,\'author\':\'Joanne Rowling\'}}}',
					'event:complete');
		});
	}
	@Test
	void unsupportedContentTypeShouldBeRejected() {
		testWithWebClient((client) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			client.post()
				.uri('/graphql')
				.contentType(MediaType.TEXT_PLAIN)
				.bodyValue('{  \'query\': \'' + query + '\'}')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.UNSUPPORTED_MEDIA_TYPE)
				.expectHeader()
				.valueEquals('Accept', 'application/json');
		});
	}
	@Test
	void httpGetQueryShouldBeRejected() {
		testWithWebClient((client) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			client.get()
				.uri('/graphql?query={query}', '{  \'query\': \'' + query + '\'}')
				.exchange()
				.expectStatus()
				.isEqualTo(HttpStatus.METHOD_NOT_ALLOWED)
				.expectHeader()
				.valueEquals('Allow', 'POST');
		});
	}
	@Test
	void shouldRejectMissingQuery() {
		testWithWebClient(
				(client) -> client.post().uri('/graphql').bodyValue('{}').exchange().expectStatus().isBadRequest());
	}
	@Test
	void shouldRejectQueryWithInvalidJson() {
		testWithWebClient(
				(client) -> client.post().uri('/graphql').bodyValue(':)').exchange().expectStatus().isBadRequest());
	}
	@Test
	void shouldConfigureWebInterceptors() {
		testWithWebClient((client) -> {
			String query = '{ bookById(id: \\\'book-1\\\'){ id name pageCount author } }';
			client.post()
				.uri('/graphql')
				.bodyValue('{  \'query\': \'' + query + '\'}')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.valueEquals('X-Custom-Header', '42');
		});
	}
	@Test
	void shouldExposeSchemaEndpoint() {
		testWithWebClient((client) -> client.get()
			.uri('/graphql/schema')
			.accept(MediaType.ALL)
			.exchange()
			.expectStatus()
			.isOk()
			.expectHeader()
			.contentType(MediaType.TEXT_PLAIN)
			.expectBody(String.class)
			.value(containsString('type Book')));
	}
	@Test
	void shouldExposeGraphiqlEndpoint() {
		testWithWebClient((client) -> {
			client.get()
				.uri('/graphiql')
				.exchange()
				.expectStatus()
				.is3xxRedirection()
				.expectHeader()
				.location('https://spring.example.org/graphiql?path=/graphql');
			client.get()
				.uri('/graphiql?path=/graphql')
				.accept(MediaType.ALL)
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.contentType(MediaType.TEXT_HTML);
		});
	}
	@Test
	void shouldSupportCors() {
		testWithWebClient((client) -> {
			String query = '{' + '  bookById(id: \\\'book-1\\\'){ ' + '    id' + '    name' + '    pageCount'
					+ '    author' + '  }' + '}';
			client.post()
				.uri('/graphql')
				.bodyValue('{  \'query\': \'' + query + '\'}')
				.header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, 'POST')
				.header(HttpHeaders.ORIGIN, 'https://example.com')
				.exchange()
				.expectStatus()
				.isOk()
				.expectHeader()
				.valueEquals(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN, 'https://example.com')
				.expectHeader()
				.valueEquals(HttpHeaders.ACCESS_CONTROL_ALLOW_CREDENTIALS, 'true');
		});
	}
	@Test
	void shouldConfigureWebSocketBeans() {
		this.contextRunner.withPropertyValues('spring.graphql.websocket.path=/ws')
			.run((context) -> assertThat(context).hasSingleBean(GraphQlWebSocketHandler.class));
	}
	@Test
	void shouldConfigureWebSocketProperties() {
		this.contextRunner
			.withPropertyValues('spring.graphql.websocket.path=/ws',
					'spring.graphql.websocket.connection-init-timeout=120s', 'spring.graphql.websocket.keep-alive=30s')
			.run((context) -> {
				assertThat(context).hasSingleBean(GraphQlWebSocketHandler.class);
				GraphQlWebSocketHandler graphQlWebSocketHandler = context.getBean(GraphQlWebSocketHandler.class);
				assertThat(graphQlWebSocketHandler).extracting('initTimeoutDuration')
					.isEqualTo(Duration.ofSeconds(120));
				assertThat(graphQlWebSocketHandler).extracting('keepAliveDuration').isEqualTo(Duration.ofSeconds(30));
			});
	}
	@Test
	void routerFunctionShouldHaveOrderZero() {
		this.contextRunner.withUserConfiguration(CustomRouterFunctions.class).run((context) -> {
			Map<String, ?> beans = context.getBeansOfType(RouterFunction.class);
			Object[] ordered = context.getBeanProvider(RouterFunction.class).orderedStream().toArray();
			assertThat(beans.get('before')).isSameAs(ordered[0]);
			assertThat(beans.get('graphQlRouterFunction')).isSameAs(ordered[1]);
			assertThat(beans.get('after')).isSameAs(ordered[2]);
		});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new GraphQlWebFluxAutoConfiguration.GraphiQlResourceHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.resource().forResource('graphiql/index.html')).accepts(hints);
	}
	private void testWithWebClient(Consumer<WebTestClient> consumer) {
		this.contextRunner.run((context) -> {
			WebTestClient client = WebTestClient.bindToApplicationContext(context)
				.configureClient()
				.defaultHeaders((headers) -> {
					headers.setContentType(MediaType.APPLICATION_JSON);
					headers.setAccept(Collections.singletonList(MediaType.APPLICATION_GRAPHQL_RESPONSE));
				})
				.baseUrl(BASE_URL)
				.build();
			consumer.accept(client);
		});
	}
	@Configuration(proxyBeanMethods = false)
	static class DataFetchersConfiguration {
		@Bean
		RuntimeWiringConfigurer bookDataFetcher() {
			return (builder) -> {
				builder.type(TypeRuntimeWiring.newTypeWiring('Query')
					.dataFetcher('bookById', GraphQlTestDataFetchers.getBookByIdDataFetcher()));
				builder.type(TypeRuntimeWiring.newTypeWiring('Subscription')
					.dataFetcher('booksOnSale', GraphQlTestDataFetchers.getBooksOnSaleDataFetcher()));
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CustomWebInterceptor {
		@Bean
		WebGraphQlInterceptor customWebGraphQlInterceptor() {
			return (webInput, interceptorChain) -> interceptorChain.next(webInput)
				.doOnNext((output) -> output.getResponseHeaders().add('X-Custom-Header', '42'));
		}
	}
	@Configuration
	static class CustomRouterFunctions {
		@Bean
		@Order(-1)
		RouterFunction<?> before() {
			return (r) -> null;
		}
		@Bean
		@Order(1)
		RouterFunction<?> after() {
			return (r) -> null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jackson;
/**
class JacksonAutoConfigurationTests {
	protected final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(JacksonAutoConfiguration.class));
	@Test
	void doubleModuleRegistration() {
		this.contextRunner.withUserConfiguration(DoubleModulesConfig.class)
			.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(mapper.writeValueAsString(new Foo())).isEqualTo('{\'foo\':\'bar\'}');
			});
	}
	@Test
	void jsonMixinModuleShouldBeAutoConfiguredWithBasePackages() {
		this.contextRunner.withUserConfiguration(MixinConfiguration.class).run((context) -> {
			assertThat(context).hasSingleBean(JsonMixinModule.class).hasSingleBean(JsonMixinModuleEntries.class);
			JsonMixinModuleEntries moduleEntries = context.getBean(JsonMixinModuleEntries.class);
			assertThat(moduleEntries).extracting('entries', InstanceOfAssertFactories.MAP)
				.contains(entry(Person.class, EmptyMixin.class));
		});
	}
	@Test
	void noCustomDateFormat() {
		this.contextRunner.run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(mapper.getDateFormat()).isInstanceOf(StdDateFormat.class);
		});
	}
	@Test
	void customDateFormat() {
		this.contextRunner.withPropertyValues('spring.jackson.date-format:yyyyMMddHHmmss').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			DateFormat dateFormat = mapper.getDateFormat();
			assertThat(dateFormat).isInstanceOf(SimpleDateFormat.class);
			assertThat(((SimpleDateFormat) dateFormat).toPattern()).isEqualTo('yyyyMMddHHmmss');
		});
	}
	@Test
	void customDateFormatClass() {
		this.contextRunner.withPropertyValues(
				'spring.jackson.date-format:org.springframework.boot.autoconfigure.jackson.JacksonAutoConfigurationTests.MyDateFormat')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(mapper.getDateFormat()).isInstanceOf(MyDateFormat.class);
			});
	}
	@Test
	void noCustomPropertyNamingStrategy() {
		this.contextRunner.run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(mapper.getPropertyNamingStrategy()).isNull();
		});
	}
	@Test
	void customPropertyNamingStrategyField() {
		this.contextRunner.withPropertyValues('spring.jackson.property-naming-strategy:SNAKE_CASE').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(mapper.getPropertyNamingStrategy()).isInstanceOf(SnakeCaseStrategy.class);
		});
	}
	@Test
	void customPropertyNamingStrategyClass() {
		this.contextRunner.withPropertyValues(
				'spring.jackson.property-naming-strategy:com.fasterxml.jackson.databind.PropertyNamingStrategies.SnakeCaseStrategy')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(mapper.getPropertyNamingStrategy()).isInstanceOf(SnakeCaseStrategy.class);
			});
	}
	@Test
	void enableSerializationFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.serialization.indent_output:true').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(SerializationFeature.INDENT_OUTPUT.enabledByDefault()).isFalse();
			assertThat(mapper.getSerializationConfig()
				.hasSerializationFeatures(SerializationFeature.INDENT_OUTPUT.getMask())).isTrue();
		});
	}
	@Test
	void disableSerializationFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.serialization.write_dates_as_timestamps:false')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS.enabledByDefault()).isTrue();
				assertThat(mapper.getSerializationConfig()
					.hasSerializationFeatures(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS.getMask())).isFalse();
			});
	}
	@Test
	void enableDeserializationFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.deserialization.use_big_decimal_for_floats:true')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS.enabledByDefault()).isFalse();
				assertThat(mapper.getDeserializationConfig()
					.hasDeserializationFeatures(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS.getMask())).isTrue();
			});
	}
	@Test
	void disableDeserializationFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.deserialization.fail-on-unknown-properties:false')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES.enabledByDefault()).isTrue();
				assertThat(mapper.getDeserializationConfig()
					.hasDeserializationFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES.getMask())).isFalse();
			});
	}
	@Test
	void enableMapperFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.mapper.require_setters_for_getters:true')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS.enabledByDefault()).isFalse();
				assertThat(mapper.getSerializationConfig().isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS))
					.isTrue();
				assertThat(mapper.getDeserializationConfig().isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS))
					.isTrue();
			});
	}
	@Test
	void disableMapperFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.mapper.use_annotations:false').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(MapperFeature.USE_ANNOTATIONS.enabledByDefault()).isTrue();
			assertThat(mapper.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS)).isFalse();
			assertThat(mapper.getSerializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS)).isFalse();
		});
	}
	@Test
	void enableParserFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.parser.allow_single_quotes:true').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(JsonParser.Feature.ALLOW_SINGLE_QUOTES.enabledByDefault()).isFalse();
			assertThat(mapper.getFactory().isEnabled(JsonParser.Feature.ALLOW_SINGLE_QUOTES)).isTrue();
		});
	}
	@Test
	void disableParserFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.parser.auto_close_source:false').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(JsonParser.Feature.AUTO_CLOSE_SOURCE.enabledByDefault()).isTrue();
			assertThat(mapper.getFactory().isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)).isFalse();
		});
	}
	@Test
	void enableGeneratorFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.generator.strict_duplicate_detection:true')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				JsonGenerator.Feature feature = JsonGenerator.Feature.STRICT_DUPLICATE_DETECTION;
				assertThat(feature.enabledByDefault()).isFalse();
				assertThat(mapper.getFactory().isEnabled(feature)).isTrue();
			});
	}
	@Test
	void disableGeneratorFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.generator.auto_close_target:false').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(JsonGenerator.Feature.AUTO_CLOSE_TARGET.enabledByDefault()).isTrue();
			assertThat(mapper.getFactory().isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)).isFalse();
		});
	}
	@Test
	void defaultObjectMapperBuilder() {
		this.contextRunner.run((context) -> {
			Jackson2ObjectMapperBuilder builder = context.getBean(Jackson2ObjectMapperBuilder.class);
			ObjectMapper mapper = builder.build();
			assertThat(MapperFeature.DEFAULT_VIEW_INCLUSION.enabledByDefault()).isTrue();
			assertThat(mapper.getDeserializationConfig().isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)).isFalse();
			assertThat(MapperFeature.DEFAULT_VIEW_INCLUSION.enabledByDefault()).isTrue();
			assertThat(mapper.getDeserializationConfig().isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)).isFalse();
			assertThat(mapper.getSerializationConfig().isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)).isFalse();
			assertThat(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES.enabledByDefault()).isTrue();
			assertThat(mapper.getDeserializationConfig().isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES))
				.isFalse();
		});
	}
	@Test
	void enableEnumFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.datatype.enum.write-enums-to-lowercase=true')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(EnumFeature.WRITE_ENUMS_TO_LOWERCASE.enabledByDefault()).isFalse();
				assertThat(mapper.getSerializationConfig().isEnabled(EnumFeature.WRITE_ENUMS_TO_LOWERCASE)).isTrue();
			});
	}
	@Test
	void disableJsonNodeFeature() {
		this.contextRunner.withPropertyValues('spring.jackson.datatype.json-node.write-null-properties:false')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				assertThat(JsonNodeFeature.WRITE_NULL_PROPERTIES.enabledByDefault()).isTrue();
				assertThat(mapper.getDeserializationConfig().isEnabled(JsonNodeFeature.WRITE_NULL_PROPERTIES))
					.isFalse();
			});
	}
	@Test
	void moduleBeansAndWellKnownModulesAreRegisteredWithTheObjectMapperBuilder() {
		this.contextRunner.withUserConfiguration(ModuleConfig.class).run((context) -> {
			ObjectMapper objectMapper = context.getBean(Jackson2ObjectMapperBuilder.class).build();
			assertThat(context.getBean(CustomModule.class).getOwners()).contains(objectMapper);
			assertThat(((DefaultSerializerProvider) objectMapper.getSerializerProviderInstance())
				.hasSerializerFor(Baz.class, null)).isTrue();
		});
	}
	@Test
	void defaultSerializationInclusion() {
		this.contextRunner.run((context) -> {
			ObjectMapper objectMapper = context.getBean(Jackson2ObjectMapperBuilder.class).build();
			assertThat(objectMapper.getSerializationConfig().getDefaultPropertyInclusion().getValueInclusion())
				.isEqualTo(JsonInclude.Include.USE_DEFAULTS);
		});
	}
	@Test
	void customSerializationInclusion() {
		this.contextRunner.withPropertyValues('spring.jackson.default-property-inclusion:non_null').run((context) -> {
			ObjectMapper objectMapper = context.getBean(Jackson2ObjectMapperBuilder.class).build();
			assertThat(objectMapper.getSerializationConfig().getDefaultPropertyInclusion().getValueInclusion())
				.isEqualTo(JsonInclude.Include.NON_NULL);
		});
	}
	@Test
	void customTimeZoneFormattingADate() {
		this.contextRunner.withPropertyValues('spring.jackson.time-zone:GMT+10', 'spring.jackson.date-format:z')
			.run((context) -> {
				ObjectMapper objectMapper = context.getBean(Jackson2ObjectMapperBuilder.class).build();
				Date date = new Date(1436966242231L);
				assertThat(objectMapper.writeValueAsString(date)).isEqualTo('\'GMT+10:00\'');
			});
	}
	@Test
	void enableDefaultLeniency() {
		this.contextRunner.withPropertyValues('spring.jackson.default-leniency:true').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			Person person = mapper.readValue('{\'birthDate\': \'2010-12-30\'}', Person.class);
			assertThat(person.getBirthDate()).isNotNull();
		});
	}
	@Test
	void disableDefaultLeniency() {
		this.contextRunner.withPropertyValues('spring.jackson.default-leniency:false').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThatExceptionOfType(InvalidFormatException.class)
				.isThrownBy(() -> mapper.readValue('{\'birthDate\': \'2010-12-30\'}', Person.class))
				.withMessageContaining('expected format')
				.withMessageContaining('yyyyMMdd');
		});
	}
	@Test
	void constructorDetectorWithNoStrategyUseDefault() {
		this.contextRunner.run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			ConstructorDetector cd = mapper.getDeserializationConfig().getConstructorDetector();
			assertThat(cd.singleArgMode()).isEqualTo(SingleArgConstructor.HEURISTIC);
			assertThat(cd.requireCtorAnnotation()).isFalse();
			assertThat(cd.allowJDKTypeConstructors()).isFalse();
		});
	}
	@Test
	void constructorDetectorWithDefaultStrategy() {
		this.contextRunner.withPropertyValues('spring.jackson.constructor-detector=default').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			ConstructorDetector cd = mapper.getDeserializationConfig().getConstructorDetector();
			assertThat(cd.singleArgMode()).isEqualTo(SingleArgConstructor.HEURISTIC);
			assertThat(cd.requireCtorAnnotation()).isFalse();
			assertThat(cd.allowJDKTypeConstructors()).isFalse();
		});
	}
	@Test
	void constructorDetectorWithUsePropertiesBasedStrategy() {
		this.contextRunner.withPropertyValues('spring.jackson.constructor-detector=use-properties-based')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				ConstructorDetector cd = mapper.getDeserializationConfig().getConstructorDetector();
				assertThat(cd.singleArgMode()).isEqualTo(SingleArgConstructor.PROPERTIES);
				assertThat(cd.requireCtorAnnotation()).isFalse();
				assertThat(cd.allowJDKTypeConstructors()).isFalse();
			});
	}
	@Test
	void constructorDetectorWithUseDelegatingStrategy() {
		this.contextRunner.withPropertyValues('spring.jackson.constructor-detector=use-delegating').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			ConstructorDetector cd = mapper.getDeserializationConfig().getConstructorDetector();
			assertThat(cd.singleArgMode()).isEqualTo(SingleArgConstructor.DELEGATING);
			assertThat(cd.requireCtorAnnotation()).isFalse();
			assertThat(cd.allowJDKTypeConstructors()).isFalse();
		});
	}
	@Test
	void constructorDetectorWithExplicitOnlyStrategy() {
		this.contextRunner.withPropertyValues('spring.jackson.constructor-detector=explicit-only').run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			ConstructorDetector cd = mapper.getDeserializationConfig().getConstructorDetector();
			assertThat(cd.singleArgMode()).isEqualTo(SingleArgConstructor.REQUIRE_MODE);
			assertThat(cd.requireCtorAnnotation()).isFalse();
			assertThat(cd.allowJDKTypeConstructors()).isFalse();
		});
	}
	@Test
	void additionalJacksonBuilderCustomization() {
		this.contextRunner.withUserConfiguration(ObjectMapperBuilderCustomConfig.class).run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			assertThat(mapper.getDateFormat()).isInstanceOf(MyDateFormat.class);
		});
	}
	@Test
	void parameterNamesModuleIsAutoConfigured() {
		assertParameterNamesModuleCreatorBinding(Mode.DEFAULT, JacksonAutoConfiguration.class);
	}
	@Test
	void customParameterNamesModuleCanBeConfigured() {
		assertParameterNamesModuleCreatorBinding(Mode.DELEGATING, ParameterNamesModuleConfig.class,
				JacksonAutoConfiguration.class);
	}
	@Test
	void writeDurationAsTimestampsDefault() {
		this.contextRunner.run((context) -> {
			ObjectMapper mapper = context.getBean(ObjectMapper.class);
			Duration duration = Duration.ofHours(2);
			assertThat(mapper.writeValueAsString(duration)).isEqualTo('\'PT2H\'');
		});
	}
	@Test
	void writeWithVisibility() {
		this.contextRunner
			.withPropertyValues('spring.jackson.visibility.getter:none', 'spring.jackson.visibility.field:any')
			.run((context) -> {
				ObjectMapper mapper = context.getBean(ObjectMapper.class);
				String json = mapper.writeValueAsString(new VisibilityBean());
				assertThat(json).contains('property1');
				assertThat(json).contains('property2');
				assertThat(json).doesNotContain('property3');
			});
	}
	@Test
	void builderIsNotSharedAcrossMultipleInjectionPoints() {
		this.contextRunner.withUserConfiguration(ObjectMapperBuilderConsumerConfig.class).run((context) -> {
			ObjectMapperBuilderConsumerConfig consumer = context.getBean(ObjectMapperBuilderConsumerConfig.class);
			assertThat(consumer.builderOne).isNotNull();
			assertThat(consumer.builderTwo).isNotNull();
			assertThat(consumer.builderOne).isNotSameAs(consumer.builderTwo);
		});
	}
	@Test
	void jsonComponentThatInjectsObjectMapperCausesBeanCurrentlyInCreationException() {
		this.contextRunner.withUserConfiguration(CircularDependencySerializerConfiguration.class).run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context).getFailure().hasRootCauseInstanceOf(BeanCurrentlyInCreationException.class);
		});
	}
	@Test
	void shouldRegisterPropertyNamingStrategyHints() {
		shouldRegisterPropertyNamingStrategyHints(PropertyNamingStrategies.class, 'LOWER_CAMEL_CASE',
				'UPPER_CAMEL_CASE', 'SNAKE_CASE', 'UPPER_SNAKE_CASE', 'LOWER_CASE', 'KEBAB_CASE', 'LOWER_DOT_CASE');
	}
	private void shouldRegisterPropertyNamingStrategyHints(Class<?> type, String... fieldNames) {
		RuntimeHints hints = new RuntimeHints();
		new JacksonAutoConfigurationRuntimeHints().registerHints(hints, getClass().getClassLoader());
		ReflectionHintsPredicates reflection = RuntimeHintsPredicates.reflection();
		Stream.of(fieldNames)
			.map((name) -> reflection.onField(type, name))
			.forEach((predicate) -> assertThat(predicate).accepts(hints));
	}
	private void assertParameterNamesModuleCreatorBinding(Mode expectedMode, Class<?>... configClasses) {
		this.contextRunner.withUserConfiguration(configClasses).run((context) -> {
			DeserializationConfig deserializationConfig = context.getBean(ObjectMapper.class)
				.getDeserializationConfig();
			AnnotationIntrospector annotationIntrospector = deserializationConfig.getAnnotationIntrospector()
				.allIntrospectors()
				.iterator()
				.next();
			assertThat(annotationIntrospector).hasFieldOrPropertyWithValue('creatorBinding', expectedMode);
		});
	}
	static class MyDateFormat extends SimpleDateFormat {
		MyDateFormat() {
			super('yyyy-MM-dd HH:mm:ss');
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class MockObjectMapperConfig {
		@Bean
		@Primary
		ObjectMapper objectMapper() {
			return mock(ObjectMapper.class);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Import(BazSerializer.class)
	static class ModuleConfig {
		@Bean
		CustomModule jacksonModule() {
			return new CustomModule();
		}
	}
	@Configuration
	static class DoubleModulesConfig {
		@Bean
		Module jacksonModule() {
			SimpleModule module = new SimpleModule();
			module.addSerializer(Foo.class, new JsonSerializer<>() {
				@Override
				public void serialize(Foo value, JsonGenerator jgen, SerializerProvider provider) throws IOException {
					jgen.writeStartObject();
					jgen.writeStringField('foo', 'bar');
					jgen.writeEndObject();
				}
			});
			return module;
		}
		@Bean
		@Primary
		ObjectMapper objectMapper() {
			ObjectMapper mapper = new ObjectMapper();
			mapper.registerModule(jacksonModule());
			return mapper;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ParameterNamesModuleConfig {
		@Bean
		ParameterNamesModule parameterNamesModule() {
			return new ParameterNamesModule(JsonCreator.Mode.DELEGATING);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ObjectMapperBuilderCustomConfig {
		@Bean
		Jackson2ObjectMapperBuilderCustomizer customDateFormat() {
			return (builder) -> builder.dateFormat(new MyDateFormat());
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ObjectMapperBuilderConsumerConfig {
		Jackson2ObjectMapperBuilder builderOne;
		Jackson2ObjectMapperBuilder builderTwo;
		@Bean
		String consumerOne(Jackson2ObjectMapperBuilder builder) {
			this.builderOne = builder;
			return 'one';
		}
		@Bean
		String consumerTwo(Jackson2ObjectMapperBuilder builder) {
			this.builderTwo = builder;
			return 'two';
		}
	}
	protected static final class Foo {
		private String name;
		private Foo() {
		}
		static Foo create() {
			return new Foo();
		}
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
	}
	static class Bar {
		private String propertyName;
		String getPropertyName() {
			return this.propertyName;
		}
		void setPropertyName(String propertyName) {
			this.propertyName = propertyName;
		}
	}
	@JsonComponent
	static class BazSerializer extends JsonObjectSerializer<Baz> {
		@Override
		protected void serializeObject(Baz value, JsonGenerator jgen, SerializerProvider provider) {
		}
	}
	static class Baz {
	}
	static class CustomModule extends SimpleModule {
		private final Set<ObjectCodec> owners = new HashSet<>();
		@Override
		public void setupModule(SetupContext context) {
			this.owners.add(context.getOwner());
		}
		Set<ObjectCodec> getOwners() {
			return this.owners;
		}
	}
	@SuppressWarnings('unused')
	static class VisibilityBean {
		private String property1;
		public String property2;
		String getProperty3() {
			return null;
		}
	}
	static class Person {
		@JsonFormat(pattern = 'yyyyMMdd')
		private Date birthDate;
		Date getBirthDate() {
			return this.birthDate;
		}
		void setBirthDate(Date birthDate) {
			this.birthDate = birthDate;
		}
	}
	@JsonMixin(type = Person.class)
	static class EmptyMixin {
	}
	@AutoConfigurationPackage
	static class MixinConfiguration {
	}
	@JsonComponent
	static class CircularDependencySerializer extends JsonSerializer<String> {
		CircularDependencySerializer(ObjectMapper objectMapper) {
		}
		@Override
		public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException {
		}
	}
	@Import(CircularDependencySerializer.class)
	@Configuration(proxyBeanMethods = false)
	static class CircularDependencySerializerConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa.mapping;
/**
public class NonAnnotatedEntity {
	private Long id;
	private String item;
	protected NonAnnotatedEntity() {
	}
	public NonAnnotatedEntity(String item) {
		this.item = item;
	}
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getItem() {
		return this.item;
	}
	public void setItem(String value) {
		this.item = value;
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa.domain.country;
@Entity
public class Country implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	@Audited
	@Column
	private String name;
	public Long getId() {
		return this.id;
	}
	public void setId(Long id) {
		this.id = id;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa.test;
public class CityListener {
	private ConfigurableBeanFactory beanFactory;
	public CityListener() {
	}
	@Autowired
	public CityListener(ConfigurableBeanFactory beanFactory) {
		this.beanFactory = beanFactory;
	}
	@PostLoad
	public void postLoad(City city) {
		if (this.beanFactory != null) {
			this.beanFactory.registerSingleton(City.class.getName(), city);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa.test;
@Entity
@EntityListeners(CityListener.class)
public class City implements Serializable {
	private static final long serialVersionUID = 1L;
	@Id
	@GeneratedValue
	private Long id;
	@Column(nullable = false)
	private String name;
	@Column(nullable = false)
	private String state;
	@Column(nullable = false)
	private String country;
	@Column(nullable = false)
	private String map;
	protected City() {
	}
	public City(String name, String state, String country, String map) {
		this.name = name;
		this.state = state;
		this.country = country;
		this.map = map;
	}
	public String getName() {
		return this.name;
	}
	public String getState() {
		return this.state;
	}
	public String getCountry() {
		return this.country;
	}
	public String getMap() {
		return this.map;
	}
	@Override
	public String toString() {
		return getName() + ',' + getState() + ',' + getCountry();
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
class Hibernate2ndLevelCacheIntegrationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CacheAutoConfiguration.class, DataSourceAutoConfiguration.class,
				HibernateJpaAutoConfiguration.class))
		.withUserConfiguration(TestConfiguration.class);
	@Test
	void hibernate2ndLevelCacheWithJCacheAndHazelcast() {
		String cachingProviderFqn = HazelcastServerCachingProvider.class.getName();
		String configLocation = 'classpath:hazelcast.xml';
		this.contextRunner
			.withPropertyValues('spring.cache.type=jcache', 'spring.cache.jcache.provider=' + cachingProviderFqn,
					'spring.cache.jcache.config=' + configLocation,
					'spring.jpa.properties.hibernate.cache.region.factory_class=jcache',
					'spring.jpa.properties.hibernate.cache.provider=' + cachingProviderFqn,
					'spring.jpa.properties.hibernate.javax.cache.uri=' + configLocation)
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Configuration(proxyBeanMethods = false)
	@EnableCaching
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
class HibernateJpaAutoConfigurationTests extends AbstractJpaAutoConfigurationTests {
	HibernateJpaAutoConfigurationTests() {
		super(HibernateJpaAutoConfiguration.class);
	}
	@Test
	void testDmlScriptWithMissingDdl() {
		contextRunner().withPropertyValues('spring.sql.init.data-locations:classpath:/city.sql',
				// Missing:
				'spring.sql.init.schema-locations:classpath:/ddl.sql')
			.run((context) -> {
				assertThat(context).hasFailed();
				assertThat(context.getStartupFailure()).hasMessageContaining('ddl.sql');
			});
	}
	@Test
	void testDmlScript() {
		// This can"t succeed because the data SQL is executed immediately after the
		// schema and Hibernate hasn"t initialized yet at that point
		contextRunner().withPropertyValues('spring.sql.init.data-locations:/city.sql').run((context) -> {
			assertThat(context).hasFailed();
			assertThat(context.getStartupFailure()).isInstanceOf(BeanCreationException.class);
		});
	}
	@Test
	void testDmlScriptRunsEarly() {
		contextRunner().withUserConfiguration(TestInitializedJpaConfiguration.class)
			.withClassLoader(new HideDataScriptClassLoader())
			.withPropertyValues('spring.jpa.show-sql=true', 'spring.jpa.properties.hibernate.format_sql=true',
					'spring.jpa.properties.hibernate.highlight_sql=true', 'spring.jpa.hibernate.ddl-auto:create-drop',
					'spring.sql.init.data-locations:/city.sql', 'spring.jpa.defer-datasource-initialization=true')
			.run((context) -> assertThat(context.getBean(TestInitializedJpaConfiguration.class).called).isTrue());
	}
	@Test
	void testFlywaySwitchOffDdlAuto() {
		contextRunner().withPropertyValues('spring.sql.init.mode:never', 'spring.flyway.locations:classpath:db/city')
			.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void testFlywayPlusValidation() {
		contextRunner()
			.withPropertyValues('spring.sql.init.mode:never', 'spring.flyway.locations:classpath:db/city',
					'spring.jpa.hibernate.ddl-auto:validate')
			.withConfiguration(AutoConfigurations.of(FlywayAutoConfiguration.class))
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void testLiquibasePlusValidation() {
		contextRunner()
			.withPropertyValues('spring.liquibase.change-log:classpath:db/changelog/db.changelog-city.yaml',
					'spring.jpa.hibernate.ddl-auto:validate')
			.withConfiguration(AutoConfigurations.of(LiquibaseAutoConfiguration.class))
			.run((context) -> assertThat(context).hasNotFailed());
	}
	@Test
	void hibernateDialectIsNotSetByDefault() {
		contextRunner().run(assertJpaVendorAdapter(
				(adapter) -> assertThat(adapter.getJpaPropertyMap()).doesNotContainKeys('hibernate.dialect')));
	}
	@Test
	void hibernateDialectIsSetWhenDatabaseIsSet() {
		contextRunner().withPropertyValues('spring.jpa.database=H2')
			.run(assertJpaVendorAdapter((adapter) -> assertThat(adapter.getJpaPropertyMap())
				.contains(entry('hibernate.dialect', H2Dialect.class.getName()))));
	}
	@Test
	void hibernateDialectIsSetWhenDatabasePlatformIsSet() {
		String databasePlatform = TestH2Dialect.class.getName();
		contextRunner().withPropertyValues('spring.jpa.database-platform=' + databasePlatform)
			.run(assertJpaVendorAdapter((adapter) -> assertThat(adapter.getJpaPropertyMap())
				.contains(entry('hibernate.dialect', databasePlatform))));
	}
	private ContextConsumer<AssertableApplicationContext> assertJpaVendorAdapter(
			Consumer<HibernateJpaVendorAdapter> adapter) {
		return (context) -> {
			assertThat(context).hasSingleBean(JpaVendorAdapter.class);
			assertThat(context).hasSingleBean(HibernateJpaVendorAdapter.class);
			adapter.accept(context.getBean(HibernateJpaVendorAdapter.class));
		};
	}
	@Test
	void jtaDefaultPlatform() {
		contextRunner().withUserConfiguration(JtaTransactionManagerConfiguration.class)
			.run(assertJtaPlatform(SpringJtaPlatform.class));
	}
	@Test
	void jtaCustomPlatform() {
		contextRunner()
			.withPropertyValues(
					'spring.jpa.properties.hibernate.transaction.jta.platform:' + TestJtaPlatform.class.getName())
			.withConfiguration(AutoConfigurations.of(JtaAutoConfiguration.class))
			.run(assertJtaPlatform(TestJtaPlatform.class));
	}
	@Test
	void jtaNotUsedByTheApplication() {
		contextRunner().run(assertJtaPlatform(NoJtaPlatform.class));
	}
	private ContextConsumer<AssertableApplicationContext> assertJtaPlatform(Class<? extends JtaPlatform> expectedType) {
		return (context) -> {
			SessionFactoryImpl sessionFactory = context.getBean(LocalContainerEntityManagerFactoryBean.class)
				.getNativeEntityManagerFactory()
				.unwrap(SessionFactoryImpl.class);
			assertThat(sessionFactory.getServiceRegistry().getService(JtaPlatform.class)).isInstanceOf(expectedType);
		};
	}
	@Test
	void jtaCustomTransactionManagerUsingProperties() {
		contextRunner()
			.withPropertyValues('spring.transaction.default-timeout:30',
					'spring.transaction.rollback-on-commit-failure:true')
			.run((context) -> {
				JpaTransactionManager transactionManager = context.getBean(JpaTransactionManager.class);
				assertThat(transactionManager.getDefaultTimeout()).isEqualTo(30);
				assertThat(transactionManager.isRollbackOnCommitFailure()).isTrue();
			});
	}
	@Test
	void autoConfigurationBacksOffWithSeveralDataSources() {
		contextRunner()
			.withConfiguration(AutoConfigurations.of(DataSourceTransactionManagerAutoConfiguration.class,
					XADataSourceAutoConfiguration.class, JtaAutoConfiguration.class))
			.withUserConfiguration(TestTwoDataSourcesConfiguration.class)
			.run((context) -> {
				assertThat(context).hasNotFailed();
				assertThat(context).doesNotHaveBean(EntityManagerFactory.class);
			});
	}
	@Test
	void providerDisablesAutoCommitIsConfigured() {
		contextRunner()
			.withPropertyValues('spring.datasource.type:' + HikariDataSource.class.getName(),
					'spring.datasource.hikari.auto-commit:false')
			.run((context) -> {
				Map<String, Object> jpaProperties = context.getBean(LocalContainerEntityManagerFactoryBean.class)
					.getJpaPropertyMap();
				assertThat(jpaProperties).contains(entry('hibernate.connection.provider_disables_autocommit', 'true'));
			});
	}
	@Test
	void providerDisablesAutoCommitIsNotConfiguredIfAutoCommitIsEnabled() {
		contextRunner()
			.withPropertyValues('spring.datasource.type:' + HikariDataSource.class.getName(),
					'spring.datasource.hikari.auto-commit:true')
			.run((context) -> {
				Map<String, Object> jpaProperties = context.getBean(LocalContainerEntityManagerFactoryBean.class)
					.getJpaPropertyMap();
				assertThat(jpaProperties).doesNotContainKeys('hibernate.connection.provider_disables_autocommit');
			});
	}
	@Test
	void providerDisablesAutoCommitIsNotConfiguredIfPropertyIsSet() {
		contextRunner()
			.withPropertyValues('spring.datasource.type:' + HikariDataSource.class.getName(),
					'spring.datasource.hikari.auto-commit:false',
					'spring.jpa.properties.hibernate.connection.provider_disables_autocommit=false')
			.run((context) -> {
				Map<String, Object> jpaProperties = context.getBean(LocalContainerEntityManagerFactoryBean.class)
					.getJpaPropertyMap();
				assertThat(jpaProperties).contains(entry('hibernate.connection.provider_disables_autocommit', 'false'));
			});
	}
	@Test
	void providerDisablesAutoCommitIsNotConfiguredWithJta() {
		contextRunner().withUserConfiguration(JtaTransactionManagerConfiguration.class)
			.withPropertyValues('spring.datasource.type:' + HikariDataSource.class.getName(),
					'spring.datasource.hikari.auto-commit:false')
			.run((context) -> {
				Map<String, Object> jpaProperties = context.getBean(LocalContainerEntityManagerFactoryBean.class)
					.getJpaPropertyMap();
				assertThat(jpaProperties).doesNotContainKeys('hibernate.connection.provider_disables_autocommit');
			});
	}
	@Test
	void customResourceMapping() {
		contextRunner().withClassLoader(new HideDataScriptClassLoader())
			.withPropertyValues('spring.sql.init.data-locations:classpath:/db/non-annotated-data.sql',
					'spring.jpa.mapping-resources=META-INF/mappings/non-annotated.xml',
					'spring.jpa.defer-datasource-initialization=true')
			.run((context) -> {
				EntityManager em = context.getBean(EntityManagerFactory.class).createEntityManager();
				NonAnnotatedEntity found = em.find(NonAnnotatedEntity.class, 2000L);
				assertThat(found).isNotNull();
				assertThat(found.getItem()).isEqualTo('Test');
			});
	}
	@Test
	void physicalNamingStrategyCanBeUsed() {
		contextRunner().withUserConfiguration(TestPhysicalNamingStrategyConfiguration.class).run((context) -> {
			Map<String, Object> hibernateProperties = context.getBean(HibernateJpaConfiguration.class)
				.getVendorProperties();
			assertThat(hibernateProperties)
				.contains(entry('hibernate.physical_naming_strategy', context.getBean('testPhysicalNamingStrategy')));
			assertThat(hibernateProperties).doesNotContainKeys('hibernate.ejb.naming_strategy');
		});
	}
	@Test
	void implicitNamingStrategyCanBeUsed() {
		contextRunner().withUserConfiguration(TestImplicitNamingStrategyConfiguration.class).run((context) -> {
			Map<String, Object> hibernateProperties = context.getBean(HibernateJpaConfiguration.class)
				.getVendorProperties();
			assertThat(hibernateProperties)
				.contains(entry('hibernate.implicit_naming_strategy', context.getBean('testImplicitNamingStrategy')));
			assertThat(hibernateProperties).doesNotContainKeys('hibernate.ejb.naming_strategy');
		});
	}
	@Test
	void namingStrategyInstancesTakePrecedenceOverNamingStrategyProperties() {
		contextRunner()
			.withUserConfiguration(TestPhysicalNamingStrategyConfiguration.class,
					TestImplicitNamingStrategyConfiguration.class)
			.withPropertyValues('spring.jpa.hibernate.naming.physical-strategy:com.example.Physical',
					'spring.jpa.hibernate.naming.implicit-strategy:com.example.Implicit')
			.run((context) -> {
				Map<String, Object> hibernateProperties = context.getBean(HibernateJpaConfiguration.class)
					.getVendorProperties();
				assertThat(hibernateProperties).contains(
						entry('hibernate.physical_naming_strategy', context.getBean('testPhysicalNamingStrategy')),
						entry('hibernate.implicit_naming_strategy', context.getBean('testImplicitNamingStrategy')));
				assertThat(hibernateProperties).doesNotContainKeys('hibernate.ejb.naming_strategy');
			});
	}
	@Test
	void hibernatePropertiesCustomizerTakesPrecedenceOverStrategyInstancesAndNamingStrategyProperties() {
		contextRunner()
			.withUserConfiguration(TestHibernatePropertiesCustomizerConfiguration.class,
					TestPhysicalNamingStrategyConfiguration.class, TestImplicitNamingStrategyConfiguration.class)
			.withPropertyValues('spring.jpa.hibernate.naming.physical-strategy:com.example.Physical',
					'spring.jpa.hibernate.naming.implicit-strategy:com.example.Implicit')
			.run((context) -> {
				Map<String, Object> hibernateProperties = context.getBean(HibernateJpaConfiguration.class)
					.getVendorProperties();
				TestHibernatePropertiesCustomizerConfiguration configuration = context
					.getBean(TestHibernatePropertiesCustomizerConfiguration.class);
				assertThat(hibernateProperties).contains(
						entry('hibernate.physical_naming_strategy', configuration.physicalNamingStrategy),
						entry('hibernate.implicit_naming_strategy', configuration.implicitNamingStrategy));
				assertThat(hibernateProperties).doesNotContainKeys('hibernate.ejb.naming_strategy');
			});
	}
	@Test
	void eventListenerCanBeRegisteredAsBeans() {
		contextRunner().withUserConfiguration(TestInitializedJpaConfiguration.class)
			.withClassLoader(new HideDataScriptClassLoader())
			.withPropertyValues('spring.jpa.show-sql=true', 'spring.jpa.hibernate.ddl-auto:create-drop',
					'spring.sql.init.data-locations:classpath:/city.sql',
					'spring.jpa.defer-datasource-initialization=true')
			.run((context) -> {
				// See CityListener
				assertThat(context).hasSingleBean(City.class);
				assertThat(context.getBean(City.class).getName()).isEqualTo('Washington');
			});
	}
	@Test
	void hibernatePropertiesCustomizerCanDisableBeanContainer() {
		contextRunner().withUserConfiguration(DisableBeanContainerConfiguration.class)
			.run((context) -> assertThat(context).doesNotHaveBean(City.class));
	}
	@Test
	void vendorPropertiesWithEmbeddedDatabaseAndNoDdlProperty() {
		contextRunner().run(vendorProperties((vendorProperties) -> {
			assertThat(vendorProperties).doesNotContainKeys(SchemaToolingSettings.JAKARTA_HBM2DDL_DATABASE_ACTION);
			assertThat(vendorProperties).containsEntry(SchemaToolingSettings.HBM2DDL_AUTO, 'create-drop');
		}));
	}
	@Test
	void vendorPropertiesWhenDdlAutoPropertyIsSet() {
		contextRunner().withPropertyValues('spring.jpa.hibernate.ddl-auto=update')
			.run(vendorProperties((vendorProperties) -> {
				assertThat(vendorProperties).doesNotContainKeys(SchemaToolingSettings.JAKARTA_HBM2DDL_DATABASE_ACTION);
				assertThat(vendorProperties).containsEntry(SchemaToolingSettings.HBM2DDL_AUTO, 'update');
			}));
	}
	@Test
	void vendorPropertiesWhenDdlAutoPropertyAndHibernatePropertiesAreSet() {
		contextRunner()
			.withPropertyValues('spring.jpa.hibernate.ddl-auto=update',
					'spring.jpa.properties.hibernate.hbm2ddl.auto=create-drop')
			.run(vendorProperties((vendorProperties) -> {
				assertThat(vendorProperties).doesNotContainKeys(SchemaToolingSettings.JAKARTA_HBM2DDL_DATABASE_ACTION);
				assertThat(vendorProperties).containsEntry(SchemaToolingSettings.HBM2DDL_AUTO, 'create-drop');
			}));
	}
	@Test
	void vendorPropertiesWhenDdlAutoPropertyIsSetToNone() {
		contextRunner().withPropertyValues('spring.jpa.hibernate.ddl-auto=none')
			.run(vendorProperties((vendorProperties) -> assertThat(vendorProperties).doesNotContainKeys(
					SchemaToolingSettings.JAKARTA_HBM2DDL_DATABASE_ACTION, SchemaToolingSettings.HBM2DDL_AUTO)));
	}
	@Test
	void vendorPropertiesWhenJpaDdlActionIsSet() {
		contextRunner()
			.withPropertyValues('spring.jpa.properties.jakarta.persistence.schema-generation.database.action=create')
			.run(vendorProperties((vendorProperties) -> {
				assertThat(vendorProperties).containsEntry(SchemaToolingSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,
						'create');
				assertThat(vendorProperties).doesNotContainKeys(SchemaToolingSettings.HBM2DDL_AUTO);
			}));
	}
	@Test
	void vendorPropertiesWhenBothDdlAutoPropertiesAreSet() {
		contextRunner()
			.withPropertyValues('spring.jpa.properties.jakarta.persistence.schema-generation.database.action=create',
					'spring.jpa.hibernate.ddl-auto=create-only')
			.run(vendorProperties((vendorProperties) -> {
				assertThat(vendorProperties).containsEntry(SchemaToolingSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,
						'create');
				assertThat(vendorProperties).containsEntry(SchemaToolingSettings.HBM2DDL_AUTO, 'create-only');
			}));
	}
	private ContextConsumer<AssertableApplicationContext> vendorProperties(
			Consumer<Map<String, Object>> vendorProperties) {
		return (context) -> vendorProperties
			.accept(context.getBean(HibernateJpaConfiguration.class).getVendorProperties());
	}
	@Test
	void withSyncBootstrappingAnApplicationListenerThatUsesJpaDoesNotTriggerABeanCurrentlyInCreationException() {
		contextRunner().withUserConfiguration(JpaUsingApplicationListenerConfiguration.class).run((context) -> {
			assertThat(context).hasNotFailed();
			EventCapturingApplicationListener listener = context.getBean(EventCapturingApplicationListener.class);
			assertThat(listener.events).hasSize(1);
			assertThat(listener.events).hasOnlyElementsOfType(ContextRefreshedEvent.class);
		});
	}
	@Test
	void withAsyncBootstrappingAnApplicationListenerThatUsesJpaDoesNotTriggerABeanCurrentlyInCreationException() {
		contextRunner()
			.withUserConfiguration(AsyncBootstrappingConfiguration.class,
					JpaUsingApplicationListenerConfiguration.class)
			.run((context) -> {
				assertThat(context).hasNotFailed();
				EventCapturingApplicationListener listener = context.getBean(EventCapturingApplicationListener.class);
				assertThat(listener.events).hasSize(1);
				assertThat(listener.events).hasOnlyElementsOfType(ContextRefreshedEvent.class);
				// createEntityManager requires Hibernate bootstrapping to be complete
				assertThatNoException()
					.isThrownBy(() -> context.getBean(EntityManagerFactory.class).createEntityManager());
			});
	}
	@Test
	void whenLocalContainerEntityManagerFactoryBeanHasNoJpaVendorAdapterAutoConfigurationSucceeds() {
		contextRunner()
			.withUserConfiguration(
					TestConfigurationWithLocalContainerEntityManagerFactoryBeanWithNoJpaVendorAdapter.class)
			.run((context) -> {
				EntityManagerFactory factoryBean = context.getBean(EntityManagerFactory.class);
				Map<String, Object> map = factoryBean.getProperties();
				assertThat(map).containsEntry('configured', 'manually');
			});
	}
	@Test
	void registersHintsForJtaClasses() {
		RuntimeHints hints = new RuntimeHints();
		new HibernateRuntimeHints().registerHints(hints, getClass().getClassLoader());
		for (String noJtaPlatformClass : Arrays.asList(
				'org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform',
				'org.hibernate.service.jta.platform.internal.NoJtaPlatform')) {
			assertThat(RuntimeHintsPredicates.reflection()
				.onType(TypeReference.of(noJtaPlatformClass))
				.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(hints);
		}
	}
	@Test
	void registersHintsForNamingClasses() {
		RuntimeHints hints = new RuntimeHints();
		new HibernateRuntimeHints().registerHints(hints, getClass().getClassLoader());
		for (Class<?> noJtaPlatformClass : Arrays.asList(SpringImplicitNamingStrategy.class,
				CamelCaseToUnderscoresNamingStrategy.class)) {
			assertThat(RuntimeHintsPredicates.reflection()
				.onType(noJtaPlatformClass)
				.withMemberCategories(MemberCategory.INVOKE_DECLARED_CONSTRUCTORS)).accepts(hints);
		}
	}
	@Test
	@Disabled('gh-40177')
	void whenSpringJpaGenerateDdlIsNotSetThenTableIsNotCreated() {
		// spring.jpa.generated-ddl defaults to false but this test still fails because
		// we"re using an embedded database which means that HibernateProperties defaults
		// hibernate.hbm2ddl.auto to create-drop, replacing the
		// hibernate.hbm2ddl.auto=none that comes from generate-ddl being false.
		contextRunner().run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	@Test
	void whenSpringJpaGenerateDdlIsTrueThenTableIsCreated() {
		contextRunner().withPropertyValues('spring.jpa.generate-ddl=true')
			.run((context) -> assertThat(tablesFrom(context)).contains('CITY'));
	}
	@Test
	@Disabled('gh-40177')
	void whenSpringJpaGenerateDdlIsFalseThenTableIsNotCreated() {
		// This test fails because we"re using an embedded database which means that
		// HibernateProperties defaults hibernate.hbm2ddl.auto to create-drop, replacing
		// the hibernate.hbm2ddl.auto=none that comes from setting generate-ddl to false.
		contextRunner().withPropertyValues('spring.jpa.generate-ddl=false')
			.run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	@Test
	void whenHbm2DdlAutoIsNoneThenTableIsNotCreated() {
		contextRunner().withPropertyValues('spring.jpa.properties.hibernate.hbm2ddl.auto=none')
			.run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	@Test
	void whenSpringJpaHibernateDdlAutoIsNoneThenTableIsNotCreated() {
		contextRunner().withPropertyValues('spring.jpa.hibernate.ddl-auto=none')
			.run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	@Test
	@Disabled('gh-40177')
	void whenSpringJpaGenerateDdlIsTrueAndSpringJpaHibernateDdlAutoIsNoneThenTableIsNotCreated() {
		// This test fails because when ddl-auto is set to none, we remove
		// hibernate.hbm2ddl.auto from Hibernate properties. This then allows
		// spring.jpa.generate-ddl to set it to create-drop
		contextRunner().withPropertyValues('spring.jpa.generate-ddl=true', 'spring.jpa.hibernate.ddl-auto=none')
			.run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	@Test
	void whenSpringJpaGenerateDdlIsTrueAndSpringJpaHibernateDdlAutoIsDropThenTableIsNotCreated() {
		contextRunner().withPropertyValues('spring.jpa.generate-ddl=true', 'spring.jpa.hibernate.ddl-auto=drop')
			.run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	@Test
	void whenSpringJpaGenerateDdlIsTrueAndJakartaSchemaGenerationIsNoneThenTableIsNotCreated() {
		contextRunner()
			.withPropertyValues('spring.jpa.generate-ddl=true',
					'spring.jpa.properties.jakarta.persistence.schema-generation.database.action=none')
			.run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	@Test
	void whenSpringJpaGenerateDdlIsTrueSpringJpaHibernateDdlAutoIsCreateAndJakartaSchemaGenerationIsNoneThenTableIsNotCreated() {
		contextRunner()
			.withPropertyValues('spring.jpa.generate-ddl=true', 'spring.jpa.hibernate.ddl-auto=create',
					'spring.jpa.properties.jakarta.persistence.schema-generation.database.action=none')
			.run((context) -> assertThat(tablesFrom(context)).doesNotContain('CITY'));
	}
	private List<String> tablesFrom(AssertableApplicationContext context) {
		DataSource dataSource = context.getBean(DataSource.class);
		JdbcTemplate jdbc = new JdbcTemplate(dataSource);
		List<String> tables = jdbc.query('SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES',
				(results, row) -> results.getString(1));
		return tables;
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	@DependsOnDatabaseInitialization
	static class TestInitializedJpaConfiguration {
		private boolean called;
		@Autowired
		void validateDataSourceIsInitialized(EntityManagerFactory entityManagerFactory) {
			// Inject the entity manager to validate it is initialized at the injection
			// point
			EntityManager entityManager = entityManagerFactory.createEntityManager();
			City city = entityManager.find(City.class, 2000L);
			assertThat(city).isNotNull();
			assertThat(city.getName()).isEqualTo('Washington');
			this.called = true;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestImplicitNamingStrategyConfiguration {
		@Bean
		ImplicitNamingStrategy testImplicitNamingStrategy() {
			return new SpringImplicitNamingStrategy();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestPhysicalNamingStrategyConfiguration {
		@Bean
		PhysicalNamingStrategy testPhysicalNamingStrategy() {
			return new CamelCaseToUnderscoresNamingStrategy();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestHibernatePropertiesCustomizerConfiguration {
		private final PhysicalNamingStrategy physicalNamingStrategy = new CamelCaseToUnderscoresNamingStrategy();
		private final ImplicitNamingStrategy implicitNamingStrategy = new SpringImplicitNamingStrategy();
		@Bean
		HibernatePropertiesCustomizer testHibernatePropertiesCustomizer() {
			return (hibernateProperties) -> {
				hibernateProperties.put('hibernate.physical_naming_strategy', this.physicalNamingStrategy);
				hibernateProperties.put('hibernate.implicit_naming_strategy', this.implicitNamingStrategy);
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class DisableBeanContainerConfiguration {
		@Bean
		HibernatePropertiesCustomizer disableBeanContainerHibernatePropertiesCustomizer() {
			return (hibernateProperties) -> hibernateProperties.remove(ManagedBeanSettings.BEAN_CONTAINER);
		}
	}
	public static class TestJtaPlatform implements JtaPlatform {
		@Override
		public TransactionManager retrieveTransactionManager() {
			return mock(TransactionManager.class);
		}
		@Override
		public UserTransaction retrieveUserTransaction() {
			throw new UnsupportedOperationException();
		}
		@Override
		public Object getTransactionIdentifier(Transaction transaction) {
			throw new UnsupportedOperationException();
		}
		@Override
		public boolean canRegisterSynchronization() {
			throw new UnsupportedOperationException();
		}
		@Override
		public void registerSynchronization(Synchronization synchronization) {
			throw new UnsupportedOperationException();
		}
		@Override
		public int getCurrentStatus() {
			throw new UnsupportedOperationException();
		}
	}
	static class HideDataScriptClassLoader extends URLClassLoader {
		private static final List<String> HIDDEN_RESOURCES = Arrays.asList('schema-all.sql', 'schema.sql');
		HideDataScriptClassLoader() {
			super(new URL[0], HideDataScriptClassLoader.class.getClassLoader());
		}
		@Override
		public Enumeration<URL> getResources(String name) throws IOException {
			if (HIDDEN_RESOURCES.contains(name)) {
				return Collections.emptyEnumeration();
			}
			return super.getResources(name);
		}
	}
	@org.springframework.context.annotation.Configuration(proxyBeanMethods = false)
	static class JpaUsingApplicationListenerConfiguration {
		@Bean
		EventCapturingApplicationListener jpaUsingApplicationListener(EntityManagerFactory emf) {
			return new EventCapturingApplicationListener();
		}
		static class EventCapturingApplicationListener implements ApplicationListener<ApplicationEvent> {
			private final List<ApplicationEvent> events = new ArrayList<>();
			@Override
			public void onApplicationEvent(ApplicationEvent event) {
				this.events.add(event);
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class AsyncBootstrappingConfiguration {
		@Bean
		ThreadPoolTaskExecutor ThreadPoolTaskExecutor() {
			return new ThreadPoolTaskExecutor();
		}
		@Bean
		EntityManagerFactoryBuilderCustomizer asyncBootstrappingCustomizer(ThreadPoolTaskExecutor executor) {
			return (builder) -> builder.setBootstrapExecutor(executor);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfigurationWithLocalContainerEntityManagerFactoryBeanWithNoJpaVendorAdapter
			extends TestConfiguration {
		@Bean
		LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource) {
			LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
			factoryBean.setDataSource(dataSource);
			factoryBean.setPersistenceUnitName('manually-configured');
			factoryBean.setPersistenceProviderClass(HibernatePersistenceProvider.class);
			Map<String, Object> properties = new HashMap<>();
			properties.put('configured', 'manually');
			properties.put('hibernate.transaction.jta.platform', NoJtaPlatform.INSTANCE);
			factoryBean.setJpaPropertyMap(properties);
			return factoryBean;
		}
	}
	public static class TestH2Dialect extends H2Dialect {
	}
	@Configuration(proxyBeanMethods = false)
	static class JtaTransactionManagerConfiguration {
		@Bean
		JtaTransactionManager jtaTransactionManager() {
			JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
			jtaTransactionManager.setUserTransaction(mock(UserTransaction.class));
			jtaTransactionManager.setTransactionManager(mock(TransactionManager.class));
			return jtaTransactionManager;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
abstract class AbstractJpaAutoConfigurationTests {
	private final Class<?> autoConfiguredClass;
	private final ApplicationContextRunner contextRunner;
	protected AbstractJpaAutoConfigurationTests(Class<?> autoConfiguredClass) {
		this.autoConfiguredClass = autoConfiguredClass;
		this.contextRunner = new ApplicationContextRunner()
			.withPropertyValues('spring.datasource.generate-unique-name=true',
					'spring.jta.log-dir=' + new File(new BuildOutput(getClass()).getRootLocation(), 'transaction-logs'))
			.withUserConfiguration(TestConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					TransactionAutoConfiguration.class, TransactionManagerCustomizationAutoConfiguration.class,
					SqlInitializationAutoConfiguration.class, autoConfiguredClass));
	}
	protected ApplicationContextRunner contextRunner() {
		return this.contextRunner;
	}
	@Test
	void notConfiguredIfDataSourceIsNotAvailable() {
		new ApplicationContextRunner().withConfiguration(AutoConfigurations.of(this.autoConfiguredClass))
			.run(assertJpaIsNotAutoConfigured());
	}
	@Test
	void notConfiguredIfNoSingleDataSourceCandidateIsAvailable() {
		new ApplicationContextRunner().withUserConfiguration(TestTwoDataSourcesConfiguration.class)
			.withConfiguration(AutoConfigurations.of(this.autoConfiguredClass))
			.run(assertJpaIsNotAutoConfigured());
	}
	protected ContextConsumer<AssertableApplicationContext> assertJpaIsNotAutoConfigured() {
		return (context) -> {
			assertThat(context).hasNotFailed();
			assertThat(context).hasSingleBean(JpaProperties.class);
			assertThat(context).doesNotHaveBean(TransactionManager.class);
			assertThat(context).doesNotHaveBean(EntityManagerFactory.class);
		};
	}
	@Test
	void configuredWithAutoConfiguredDataSource() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(DataSource.class);
			assertThat(context).hasSingleBean(JpaTransactionManager.class);
			assertThat(context).hasSingleBean(EntityManagerFactory.class);
			assertThat(context).hasSingleBean(PersistenceManagedTypes.class);
		});
	}
	@Test
	void configuredWithSingleCandidateDataSource() {
		this.contextRunner.withUserConfiguration(TestTwoDataSourcesAndPrimaryConfiguration.class).run((context) -> {
			assertThat(context).getBeans(DataSource.class).hasSize(2);
			assertThat(context).hasSingleBean(JpaTransactionManager.class);
			assertThat(context).hasSingleBean(EntityManagerFactory.class);
			assertThat(context).hasSingleBean(PersistenceManagedTypes.class);
		});
	}
	@Test
	void jpaTransactionManagerTakesPrecedenceOverSimpleDataSourceOne() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceTransactionManagerAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(DataSource.class);
				assertThat(context).hasSingleBean(JpaTransactionManager.class);
				assertThat(context).getBean('transactionManager').isInstanceOf(JpaTransactionManager.class);
			});
	}
	@Test
	void openEntityManagerInViewInterceptorIsCreated() {
		new WebApplicationContextRunner().withPropertyValues('spring.datasource.generate-unique-name=true')
			.withUserConfiguration(TestConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					TransactionAutoConfiguration.class, this.autoConfiguredClass))
			.run((context) -> assertThat(context).hasSingleBean(OpenEntityManagerInViewInterceptor.class));
	}
	@Test
	void openEntityManagerInViewInterceptorIsNotRegisteredWhenFilterPresent() {
		new WebApplicationContextRunner().withPropertyValues('spring.datasource.generate-unique-name=true')
			.withUserConfiguration(TestFilterConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					TransactionAutoConfiguration.class, this.autoConfiguredClass))
			.run((context) -> assertThat(context).doesNotHaveBean(OpenEntityManagerInViewInterceptor.class));
	}
	@Test
	void openEntityManagerInViewInterceptorIsNotRegisteredWhenFilterRegistrationPresent() {
		new WebApplicationContextRunner().withPropertyValues('spring.datasource.generate-unique-name=true')
			.withUserConfiguration(TestFilterRegistrationConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					TransactionAutoConfiguration.class, this.autoConfiguredClass))
			.run((context) -> assertThat(context).doesNotHaveBean(OpenEntityManagerInViewInterceptor.class));
	}
	@Test
	void openEntityManagerInViewInterceptorAutoConfigurationBacksOffWhenManuallyRegistered() {
		new WebApplicationContextRunner().withPropertyValues('spring.datasource.generate-unique-name=true')
			.withUserConfiguration(TestInterceptorManualConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					TransactionAutoConfiguration.class, this.autoConfiguredClass))
			.run((context) -> assertThat(context).getBean(OpenEntityManagerInViewInterceptor.class)
				.isExactlyInstanceOf(
						TestInterceptorManualConfiguration.ManualOpenEntityManagerInViewInterceptor.class));
	}
	@Test
	void openEntityManagerInViewInterceptorIsNotRegisteredWhenExplicitlyOff() {
		new WebApplicationContextRunner()
			.withPropertyValues('spring.datasource.generate-unique-name=true', 'spring.jpa.open-in-view=false')
			.withUserConfiguration(TestConfiguration.class)
			.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class,
					TransactionAutoConfiguration.class, this.autoConfiguredClass))
			.run((context) -> assertThat(context).doesNotHaveBean(OpenEntityManagerInViewInterceptor.class));
	}
	@Test
	void customJpaProperties() {
		this.contextRunner
			.withPropertyValues('spring.jpa.properties.a:b', 'spring.jpa.properties.a.b:c', 'spring.jpa.properties.c:d')
			.run((context) -> {
				LocalContainerEntityManagerFactoryBean bean = context
					.getBean(LocalContainerEntityManagerFactoryBean.class);
				Map<String, Object> map = bean.getJpaPropertyMap();
				assertThat(map).containsEntry('a', 'b');
				assertThat(map).containsEntry('c', 'd');
				assertThat(map).containsEntry('a.b', 'c');
			});
	}
	@Test
	void usesManuallyDefinedLocalContainerEntityManagerFactoryBeanUsingBuilder() {
		this.contextRunner.withPropertyValues('spring.jpa.properties.a=b')
			.withUserConfiguration(TestConfigurationWithEntityManagerFactoryBuilder.class)
			.run((context) -> {
				LocalContainerEntityManagerFactoryBean factoryBean = context
					.getBean(LocalContainerEntityManagerFactoryBean.class);
				Map<String, Object> map = factoryBean.getJpaPropertyMap();
				assertThat(map).containsEntry('configured', 'manually').containsEntry('a', 'b');
			});
	}
	@Test
	void usesManuallyDefinedLocalContainerEntityManagerFactoryBeanIfAvailable() {
		this.contextRunner.withUserConfiguration(TestConfigurationWithLocalContainerEntityManagerFactoryBean.class)
			.run((context) -> {
				LocalContainerEntityManagerFactoryBean factoryBean = context
					.getBean(LocalContainerEntityManagerFactoryBean.class);
				Map<String, Object> map = factoryBean.getJpaPropertyMap();
				assertThat(map).containsEntry('configured', 'manually');
			});
	}
	@Test
	void usesManuallyDefinedEntityManagerFactoryIfAvailable() {
		this.contextRunner.withUserConfiguration(TestConfigurationWithLocalContainerEntityManagerFactoryBean.class)
			.run((context) -> {
				EntityManagerFactory factoryBean = context.getBean(EntityManagerFactory.class);
				Map<String, Object> map = factoryBean.getProperties();
				assertThat(map).containsEntry('configured', 'manually');
			});
	}
	@Test
	void usesManuallyDefinedTransactionManagerBeanIfAvailable() {
		this.contextRunner.withUserConfiguration(TestConfigurationWithTransactionManager.class).run((context) -> {
			assertThat(context).hasSingleBean(TransactionManager.class);
			TransactionManager txManager = context.getBean(TransactionManager.class);
			assertThat(txManager).isInstanceOf(CustomJpaTransactionManager.class);
		});
	}
	@Test
	void defaultPersistenceManagedTypes() {
		this.contextRunner.run((context) -> {
			assertThat(context).hasSingleBean(PersistenceManagedTypes.class);
			EntityManager entityManager = context.getBean(EntityManagerFactory.class).createEntityManager();
			assertThat(getManagedJavaTypes(entityManager)).contains(City.class).doesNotContain(Country.class);
		});
	}
	@Test
	void customPersistenceManagedTypes() {
		this.contextRunner
			.withBean(PersistenceManagedTypes.class, () -> PersistenceManagedTypes.of(Country.class.getName()))
			.run((context) -> {
				assertThat(context).hasSingleBean(PersistenceManagedTypes.class);
				EntityManager entityManager = context.getBean(EntityManagerFactory.class).createEntityManager();
				assertThat(getManagedJavaTypes(entityManager)).contains(Country.class).doesNotContain(City.class);
			});
	}
	@Test
	void customPersistenceUnitManager() {
		this.contextRunner.withUserConfiguration(TestConfigurationWithCustomPersistenceUnitManager.class)
			.run((context) -> {
				LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = context
					.getBean(LocalContainerEntityManagerFactoryBean.class);
				assertThat(entityManagerFactoryBean).hasFieldOrPropertyWithValue('persistenceUnitManager',
						context.getBean(PersistenceUnitManager.class));
			});
	}
	@Test
	void customPersistenceUnitPostProcessors() {
		this.contextRunner.withUserConfiguration(TestConfigurationWithCustomPersistenceUnitPostProcessors.class)
			.run((context) -> {
				LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = context
					.getBean(LocalContainerEntityManagerFactoryBean.class);
				PersistenceUnitInfo persistenceUnitInfo = entityManagerFactoryBean.getPersistenceUnitInfo();
				assertThat(persistenceUnitInfo).isNotNull();
				assertThat(persistenceUnitInfo.getManagedClassNames())
					.contains('customized.attribute.converter.class.name');
			});
	}
	@Test
	void customManagedClassNameFilter() {
		this.contextRunner.withBean(ManagedClassNameFilter.class, () -> (s) -> !s.endsWith('City'))
			.withUserConfiguration(AutoConfigurePackageForCountry.class)
			.run((context) -> {
				EntityManager entityManager = context.getBean(EntityManagerFactory.class).createEntityManager();
				assertThat(getManagedJavaTypes(entityManager)).contains(Country.class).doesNotContain(City.class);
			});
	}
	private Class<?>[] getManagedJavaTypes(EntityManager entityManager) {
		Set<ManagedType<?>> managedTypes = entityManager.getMetamodel().getManagedTypes();
		return managedTypes.stream().map(ManagedType::getJavaType).toArray(Class<?>[]::new);
	}
	@Configuration(proxyBeanMethods = false)
	static class TestTwoDataSourcesConfiguration {
		@Bean
		DataSource firstDataSource() {
			return createRandomDataSource();
		}
		@Bean
		DataSource secondDataSource() {
			return createRandomDataSource();
		}
		private DataSource createRandomDataSource() {
			String url = 'jdbc:h2:mem:init-' + UUID.randomUUID();
			return DataSourceBuilder.create().url(url).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestTwoDataSourcesAndPrimaryConfiguration {
		@Bean
		@Primary
		DataSource firstDataSource() {
			return createRandomDataSource();
		}
		@Bean
		DataSource secondDataSource() {
			return createRandomDataSource();
		}
		private DataSource createRandomDataSource() {
			String url = 'jdbc:h2:mem:init-' + UUID.randomUUID();
			return DataSourceBuilder.create().url(url).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestFilterConfiguration {
		@Bean
		OpenEntityManagerInViewFilter openEntityManagerInViewFilter() {
			return new OpenEntityManagerInViewFilter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestFilterRegistrationConfiguration {
		@Bean
		FilterRegistrationBean<OpenEntityManagerInViewFilter> openEntityManagerInViewFilterFilterRegistrationBean() {
			return new FilterRegistrationBean<>();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestInterceptorManualConfiguration {
		@Bean
		OpenEntityManagerInViewInterceptor openEntityManagerInViewInterceptor() {
			return new ManualOpenEntityManagerInViewInterceptor();
		}
		static class ManualOpenEntityManagerInViewInterceptor extends OpenEntityManagerInViewInterceptor {
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfigurationWithEntityManagerFactoryBuilder extends TestConfiguration {
		@Bean
		LocalContainerEntityManagerFactoryBean entityManagerFactoryBean(EntityManagerFactoryBuilder builder,
				DataSource dataSource) {
			return builder.dataSource(dataSource).properties(Map.of('configured', 'manually')).build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfigurationWithLocalContainerEntityManagerFactoryBean extends TestConfiguration {
		@Bean
		LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource, JpaVendorAdapter adapter) {
			LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
			factoryBean.setJpaVendorAdapter(adapter);
			factoryBean.setDataSource(dataSource);
			factoryBean.setPersistenceUnitName('manually-configured');
			Map<String, Object> properties = new HashMap<>();
			properties.put('configured', 'manually');
			properties.put('hibernate.transaction.jta.platform', NoJtaPlatform.INSTANCE);
			factoryBean.setJpaPropertyMap(properties);
			return factoryBean;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TestConfigurationWithEntityManagerFactory extends TestConfiguration {
		@Bean
		EntityManagerFactory entityManagerFactory(DataSource dataSource, JpaVendorAdapter adapter) {
			LocalContainerEntityManagerFactoryBean factoryBean = new LocalContainerEntityManagerFactoryBean();
			factoryBean.setJpaVendorAdapter(adapter);
			factoryBean.setDataSource(dataSource);
			factoryBean.setPersistenceUnitName('manually-configured');
			Map<String, Object> properties = new HashMap<>();
			properties.put('configured', 'manually');
			properties.put('hibernate.transaction.jta.platform', NoJtaPlatform.INSTANCE);
			factoryBean.setJpaPropertyMap(properties);
			factoryBean.afterPropertiesSet();
			return factoryBean.getObject();
		}
		@Bean
		PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
			JpaTransactionManager transactionManager = new JpaTransactionManager();
			transactionManager.setEntityManagerFactory(emf);
			return transactionManager;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfigurationWithTransactionManager {
		@Bean
		TransactionManager testTransactionManager() {
			return new CustomJpaTransactionManager();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(Country.class)
	static class AutoConfigurePackageForCountry {
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(AbstractJpaAutoConfigurationTests.class)
	static class TestConfigurationWithCustomPersistenceUnitManager {
		private final DataSource dataSource;
		TestConfigurationWithCustomPersistenceUnitManager(DataSource dataSource) {
			this.dataSource = dataSource;
		}
		@Bean
		PersistenceUnitManager persistenceUnitManager() {
			DefaultPersistenceUnitManager persistenceUnitManager = new DefaultPersistenceUnitManager();
			persistenceUnitManager.setDefaultDataSource(this.dataSource);
			persistenceUnitManager.setPackagesToScan(City.class.getPackage().getName());
			return persistenceUnitManager;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(AbstractJpaAutoConfigurationTests.class)
	static class TestConfigurationWithCustomPersistenceUnitPostProcessors {
		@Bean
		EntityManagerFactoryBuilderCustomizer entityManagerFactoryBuilderCustomizer() {
			return (builder) -> builder.setPersistenceUnitPostProcessors(
					(pui) -> pui.addManagedClassName('customized.attribute.converter.class.name'));
		}
	}
	static class CustomJpaTransactionManager extends JpaTransactionManager {
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
@ExtendWith(MockitoExtension.class)
class HibernatePropertiesTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withUserConfiguration(TestConfiguration.class);
	@Mock
	private Supplier<String> ddlAutoSupplier;
	@Test
	void noCustomNamingStrategy() {
		this.contextRunner.run(assertHibernateProperties((hibernateProperties) -> {
			assertThat(hibernateProperties).doesNotContainKeys('hibernate.ejb.naming_strategy');
			assertThat(hibernateProperties).containsEntry(AvailableSettings.PHYSICAL_NAMING_STRATEGY,
					CamelCaseToUnderscoresNamingStrategy.class.getName());
			assertThat(hibernateProperties).containsEntry(AvailableSettings.IMPLICIT_NAMING_STRATEGY,
					SpringImplicitNamingStrategy.class.getName());
		}));
	}
	@Test
	void hibernate5CustomNamingStrategies() {
		this.contextRunner
			.withPropertyValues('spring.jpa.hibernate.naming.implicit-strategy:com.example.Implicit',
					'spring.jpa.hibernate.naming.physical-strategy:com.example.Physical')
			.run(assertHibernateProperties((hibernateProperties) -> {
				assertThat(hibernateProperties).contains(
						entry(AvailableSettings.IMPLICIT_NAMING_STRATEGY, 'com.example.Implicit'),
						entry(AvailableSettings.PHYSICAL_NAMING_STRATEGY, 'com.example.Physical'));
				assertThat(hibernateProperties).doesNotContainKeys('hibernate.ejb.naming_strategy');
			}));
	}
	@Test
	void hibernate5CustomNamingStrategiesViaJpaProperties() {
		this.contextRunner
			.withPropertyValues('spring.jpa.properties.hibernate.implicit_naming_strategy:com.example.Implicit',
					'spring.jpa.properties.hibernate.physical_naming_strategy:com.example.Physical')
			.run(assertHibernateProperties((hibernateProperties) -> {
				// You can override them as we don"t provide any default
				assertThat(hibernateProperties).contains(
						entry(AvailableSettings.IMPLICIT_NAMING_STRATEGY, 'com.example.Implicit'),
						entry(AvailableSettings.PHYSICAL_NAMING_STRATEGY, 'com.example.Physical'));
				assertThat(hibernateProperties).doesNotContainKeys('hibernate.ejb.naming_strategy');
			}));
	}
	@Test
	void scannerUsesDisabledScannerByDefault() {
		this.contextRunner.run(assertHibernateProperties((hibernateProperties) -> assertThat(hibernateProperties)
			.containsEntry(AvailableSettings.SCANNER, 'org.hibernate.boot.archive.scan.internal.DisabledScanner')));
	}
	@Test
	void scannerCanBeCustomized() {
		this.contextRunner.withPropertyValues(
				'spring.jpa.properties.hibernate.archive.scanner:org.hibernate.boot.archive.scan.internal.StandardScanner')
			.run(assertHibernateProperties((hibernateProperties) -> assertThat(hibernateProperties)
				.containsEntry(AvailableSettings.SCANNER, 'org.hibernate.boot.archive.scan.internal.StandardScanner')));
	}
	@Test
	void defaultDdlAutoIsNotInvokedIfPropertyIsSet() {
		this.contextRunner.withPropertyValues('spring.jpa.hibernate.ddl-auto=validate')
			.run(assertDefaultDdlAutoNotInvoked('validate'));
	}
	@Test
	void defaultDdlAutoIsNotInvokedIfHibernateSpecificPropertyIsSet() {
		this.contextRunner.withPropertyValues('spring.jpa.properties.hibernate.hbm2ddl.auto=create')
			.run(assertDefaultDdlAutoNotInvoked('create'));
	}
	@Test
	void defaultDdlAutoIsNotInvokedAndDdlAutoIsNotSetIfJpaDbActionPropertyIsSet() {
		this.contextRunner
			.withPropertyValues(
					'spring.jpa.properties.jakarta.persistence.schema-generation.database.action=drop-and-create')
			.run(assertHibernateProperties((hibernateProperties) -> {
				assertThat(hibernateProperties).doesNotContainKey(AvailableSettings.HBM2DDL_AUTO);
				assertThat(hibernateProperties).containsEntry(AvailableSettings.JAKARTA_HBM2DDL_DATABASE_ACTION,
						'drop-and-create');
				then(this.ddlAutoSupplier).should(never()).get();
			}));
	}
	private ContextConsumer<AssertableApplicationContext> assertDefaultDdlAutoNotInvoked(String expectedDdlAuto) {
		return assertHibernateProperties((hibernateProperties) -> {
			assertThat(hibernateProperties).containsEntry(AvailableSettings.HBM2DDL_AUTO, expectedDdlAuto);
			then(this.ddlAutoSupplier).should(never()).get();
		});
	}
	private ContextConsumer<AssertableApplicationContext> assertHibernateProperties(
			Consumer<Map<String, Object>> consumer) {
		return (context) -> {
			assertThat(context).hasSingleBean(JpaProperties.class);
			assertThat(context).hasSingleBean(HibernateProperties.class);
			Map<String, Object> hibernateProperties = context.getBean(HibernateProperties.class)
				.determineHibernateProperties(context.getBean(JpaProperties.class).getProperties(),
						new HibernateSettings().ddlAuto(this.ddlAutoSupplier));
			consumer.accept(hibernateProperties);
		};
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties({ JpaProperties.class, HibernateProperties.class })
	static class TestConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
class CustomHibernateJpaAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withPropertyValues('spring.datasource.generate-unique-name=true')
		.withUserConfiguration(TestConfiguration.class)
		.withConfiguration(
				AutoConfigurations.of(DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class));
	@Test
	void namingStrategyDelegatorTakesPrecedence() {
		this.contextRunner
			.withPropertyValues('spring.jpa.properties.hibernate.ejb.naming_strategy_delegator:'
					+ 'org.hibernate.cfg.naming.ImprovedNamingStrategyDelegator')
			.run((context) -> {
				JpaProperties jpaProperties = context.getBean(JpaProperties.class);
				HibernateProperties hibernateProperties = context.getBean(HibernateProperties.class);
				Map<String, Object> properties = hibernateProperties
					.determineHibernateProperties(jpaProperties.getProperties(), new HibernateSettings());
				assertThat(properties).doesNotContainKey('hibernate.ejb.naming_strategy');
			});
	}
	@Test
	void namingStrategyBeansAreUsed() {
		this.contextRunner.withUserConfiguration(NamingStrategyConfiguration.class)
			.withPropertyValues('spring.datasource.url:jdbc:h2:mem:naming-strategy-beans')
			.run((context) -> {
				HibernateJpaConfiguration jpaConfiguration = context.getBean(HibernateJpaConfiguration.class);
				Map<String, Object> hibernateProperties = jpaConfiguration.getVendorProperties();
				assertThat(hibernateProperties).containsEntry('hibernate.implicit_naming_strategy',
						NamingStrategyConfiguration.implicitNamingStrategy);
				assertThat(hibernateProperties).containsEntry('hibernate.physical_naming_strategy',
						NamingStrategyConfiguration.physicalNamingStrategy);
			});
	}
	@Test
	void hibernatePropertiesCustomizersAreAppliedInOrder() {
		this.contextRunner.withUserConfiguration(HibernatePropertiesCustomizerConfiguration.class).run((context) -> {
			HibernateJpaConfiguration jpaConfiguration = context.getBean(HibernateJpaConfiguration.class);
			Map<String, Object> hibernateProperties = jpaConfiguration.getVendorProperties();
			assertThat(hibernateProperties).containsEntry('test.counter', 2);
		});
	}
	@Test
	void defaultDatabaseIsSet() {
		this.contextRunner.withPropertyValues('spring.datasource.url:jdbc:h2:mem:testdb').run((context) -> {
			HibernateJpaVendorAdapter bean = context.getBean(HibernateJpaVendorAdapter.class);
			Database database = (Database) ReflectionTestUtils.getField(bean, 'database');
			assertThat(database).isEqualTo(Database.DEFAULT);
		});
	}
	@Configuration(proxyBeanMethods = false)
	@TestAutoConfigurationPackage(City.class)
	static class TestConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	static class MockDataSourceConfiguration {
		@Bean
		DataSource dataSource() {
			DataSource dataSource = mock(DataSource.class);
			try {
				given(dataSource.getConnection()).willReturn(mock(Connection.class));
				given(dataSource.getConnection().getMetaData()).willReturn(mock(DatabaseMetaData.class));
			}
			catch (SQLException ex) {
				// Do nothing
			}
			return dataSource;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class NamingStrategyConfiguration {
		static final ImplicitNamingStrategy implicitNamingStrategy = new ImplicitNamingStrategyJpaCompliantImpl();
		static final PhysicalNamingStrategy physicalNamingStrategy = new PhysicalNamingStrategyStandardImpl();
		@Bean
		ImplicitNamingStrategy implicitNamingStrategy() {
			return implicitNamingStrategy;
		}
		@Bean
		PhysicalNamingStrategy physicalNamingStrategy() {
			return physicalNamingStrategy;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class HibernatePropertiesCustomizerConfiguration {
		@Bean
		@Order(2)
		HibernatePropertiesCustomizer sampleCustomizer() {
			return ((hibernateProperties) -> hibernateProperties.put('test.counter', 2));
		}
		@Bean
		@Order(1)
		HibernatePropertiesCustomizer anotherCustomizer() {
			return ((hibernateProperties) -> hibernateProperties.put('test.counter', 1));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.orm.jpa;
/**
class HibernateDefaultDdlAutoProviderTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(
				AutoConfigurations.of(DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class))
		.withPropertyValues('spring.sql.init.mode:never');
	@Test
	void defaultDDlAutoForEmbedded() {
		this.contextRunner.run((context) -> {
			HibernateDefaultDdlAutoProvider ddlAutoProvider = new HibernateDefaultDdlAutoProvider(
					Collections.emptyList());
			assertThat(ddlAutoProvider.getDefaultDdlAuto(context.getBean(DataSource.class))).isEqualTo('create-drop');
		});
	}
	@Test
	void defaultDDlAutoForEmbeddedWithPositiveContributor() {
		this.contextRunner.run((context) -> {
			DataSource dataSource = context.getBean(DataSource.class);
			SchemaManagementProvider provider = mock(SchemaManagementProvider.class);
			given(provider.getSchemaManagement(dataSource)).willReturn(SchemaManagement.MANAGED);
			HibernateDefaultDdlAutoProvider ddlAutoProvider = new HibernateDefaultDdlAutoProvider(
					Collections.singletonList(provider));
			assertThat(ddlAutoProvider.getDefaultDdlAuto(dataSource)).isEqualTo('none');
		});
	}
	@Test
	void defaultDDlAutoForEmbeddedWithNegativeContributor() {
		this.contextRunner.run((context) -> {
			DataSource dataSource = context.getBean(DataSource.class);
			SchemaManagementProvider provider = mock(SchemaManagementProvider.class);
			given(provider.getSchemaManagement(dataSource)).willReturn(SchemaManagement.UNMANAGED);
			HibernateDefaultDdlAutoProvider ddlAutoProvider = new HibernateDefaultDdlAutoProvider(
					Collections.singletonList(provider));
			assertThat(ddlAutoProvider.getDefaultDdlAuto(dataSource)).isEqualTo('create-drop');
		});
	}
}
/*
package org.springframework.boot.autoconfigure.http;
/**
@ClassPathExclusions('jackson-*.jar')
class HttpMessageConvertersAutoConfigurationWithoutJacksonTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class));
	@Test
	void autoConfigurationWorksWithSpringHateoasButWithoutJackson() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(HttpMessageConverters.class));
	}
}
/*
package org.springframework.boot.autoconfigure.http;
/**
class HttpMessageConvertersTests {
	@Test
	void containsDefaults() {
		HttpMessageConverters converters = new HttpMessageConverters();
		List<Class<?>> converterClasses = new ArrayList<>();
		for (HttpMessageConverter<?> converter : converters) {
			converterClasses.add(converter.getClass());
		}
		assertThat(converterClasses).containsExactly(ByteArrayHttpMessageConverter.class,
				StringHttpMessageConverter.class, ResourceHttpMessageConverter.class,
				ResourceRegionHttpMessageConverter.class, AllEncompassingFormHttpMessageConverter.class,
				MappingJackson2HttpMessageConverter.class, MappingJackson2CborHttpMessageConverter.class,
				MappingJackson2XmlHttpMessageConverter.class);
	}
	@Test
	void addBeforeExistingConverter() {
		MappingJackson2HttpMessageConverter converter1 = new MappingJackson2HttpMessageConverter();
		MappingJackson2HttpMessageConverter converter2 = new MappingJackson2HttpMessageConverter();
		HttpMessageConverters converters = new HttpMessageConverters(converter1, converter2);
		assertThat(converters.getConverters()).contains(converter1);
		assertThat(converters.getConverters()).contains(converter2);
		List<MappingJackson2HttpMessageConverter> httpConverters = new ArrayList<>();
		for (HttpMessageConverter<?> candidate : converters) {
			if (candidate instanceof MappingJackson2HttpMessageConverter) {
				httpConverters.add((MappingJackson2HttpMessageConverter) candidate);
			}
		}
		// The existing converter is still there, but with a lower priority
		assertThat(httpConverters).hasSize(3);
		assertThat(httpConverters.indexOf(converter1)).isZero();
		assertThat(httpConverters.indexOf(converter2)).isOne();
		assertThat(converters.getConverters().indexOf(converter1)).isNotZero();
	}
	@Test
	void addBeforeExistingEquivalentConverter() {
		GsonHttpMessageConverter converter1 = new GsonHttpMessageConverter();
		HttpMessageConverters converters = new HttpMessageConverters(converter1);
		Stream<Class<?>> converterClasses = converters.getConverters().stream().map(HttpMessageConverter::getClass);
		assertThat(converterClasses).containsSequence(GsonHttpMessageConverter.class,
				MappingJackson2HttpMessageConverter.class);
	}
	@Test
	void addNewConverters() {
		HttpMessageConverter<?> converter1 = mock(HttpMessageConverter.class);
		HttpMessageConverter<?> converter2 = mock(HttpMessageConverter.class);
		HttpMessageConverters converters = new HttpMessageConverters(converter1, converter2);
		assertThat(converters.getConverters().get(0)).isEqualTo(converter1);
		assertThat(converters.getConverters().get(1)).isEqualTo(converter2);
	}
	@Test
	void convertersAreAddedToFormPartConverter() {
		HttpMessageConverter<?> converter1 = mock(HttpMessageConverter.class);
		HttpMessageConverter<?> converter2 = mock(HttpMessageConverter.class);
		List<HttpMessageConverter<?>> converters = new HttpMessageConverters(converter1, converter2).getConverters();
		List<HttpMessageConverter<?>> partConverters = extractFormPartConverters(converters);
		assertThat(partConverters.get(0)).isEqualTo(converter1);
		assertThat(partConverters.get(1)).isEqualTo(converter2);
	}
	@Test
	void postProcessConverters() {
		HttpMessageConverters converters = new HttpMessageConverters() {
			@Override
			protected List<HttpMessageConverter<?>> postProcessConverters(List<HttpMessageConverter<?>> converters) {
				converters.removeIf(MappingJackson2XmlHttpMessageConverter.class::isInstance);
				return converters;
			}
		};
		List<Class<?>> converterClasses = new ArrayList<>();
		for (HttpMessageConverter<?> converter : converters) {
			converterClasses.add(converter.getClass());
		}
		assertThat(converterClasses).containsExactly(ByteArrayHttpMessageConverter.class,
				StringHttpMessageConverter.class, ResourceHttpMessageConverter.class,
				ResourceRegionHttpMessageConverter.class, AllEncompassingFormHttpMessageConverter.class,
				MappingJackson2HttpMessageConverter.class, MappingJackson2CborHttpMessageConverter.class);
	}
	@Test
	void postProcessPartConverters() {
		HttpMessageConverters converters = new HttpMessageConverters() {
			@Override
			protected List<HttpMessageConverter<?>> postProcessPartConverters(
					List<HttpMessageConverter<?>> converters) {
				converters.removeIf(MappingJackson2XmlHttpMessageConverter.class::isInstance);
				return converters;
			}
		};
		List<Class<?>> converterClasses = new ArrayList<>();
		for (HttpMessageConverter<?> converter : extractFormPartConverters(converters.getConverters())) {
			converterClasses.add(converter.getClass());
		}
		assertThat(converterClasses).containsExactly(ByteArrayHttpMessageConverter.class,
				StringHttpMessageConverter.class, ResourceHttpMessageConverter.class,
				MappingJackson2HttpMessageConverter.class, MappingJackson2CborHttpMessageConverter.class);
	}
	private List<HttpMessageConverter<?>> extractFormPartConverters(List<HttpMessageConverter<?>> converters) {
		AllEncompassingFormHttpMessageConverter formConverter = findFormConverter(converters);
		return formConverter.getPartConverters();
	}
	private AllEncompassingFormHttpMessageConverter findFormConverter(Collection<HttpMessageConverter<?>> converters) {
		for (HttpMessageConverter<?> converter : converters) {
			if (converter instanceof AllEncompassingFormHttpMessageConverter allEncompassingConverter) {
				return allEncompassingConverter;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.autoconfigure.http.codec;
/**
class CodecsAutoConfigurationTests {
	private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(CodecsAutoConfiguration.class));
	@Test
	void autoConfigShouldProvideALoggingRequestDetailsCustomizer() {
		this.contextRunner.run((context) -> {
			CodecCustomizer customizer = context.getBean(CodecCustomizer.class);
			CodecConfigurer configurer = new DefaultClientCodecConfigurer();
			customizer.customize(configurer);
			assertThat(configurer.defaultCodecs()).hasFieldOrPropertyWithValue('enableLoggingRequestDetails', false);
		});
	}
	@Test
	void loggingRequestDetailsCustomizerShouldUseHttpProperties() {
		this.contextRunner.withPropertyValues('spring.codec.log-request-details=true').run((context) -> {
			CodecCustomizer customizer = context.getBean(CodecCustomizer.class);
			CodecConfigurer configurer = new DefaultClientCodecConfigurer();
			customizer.customize(configurer);
			assertThat(configurer.defaultCodecs()).hasFieldOrPropertyWithValue('enableLoggingRequestDetails', true);
		});
	}
	@Test
	void defaultCodecCustomizerBeanShouldHaveOrderZero() {
		this.contextRunner.run((context) -> {
			Method customizerMethod = ReflectionUtils.findMethod(
					CodecsAutoConfiguration.DefaultCodecsConfiguration.class, 'defaultCodecCustomizer',
					CodecProperties.class);
			Integer order = new TestAnnotationAwareOrderComparator().findOrder(customizerMethod);
			assertThat(order).isZero();
		});
	}
	@Test
	void jacksonCodecCustomizerBacksOffWhenThereIsNoObjectMapper() {
		this.contextRunner.run((context) -> assertThat(context).doesNotHaveBean('jacksonCodecCustomizer'));
	}
	@Test
	void jacksonCodecCustomizerIsAutoConfiguredWhenObjectMapperIsPresent() {
		this.contextRunner.withUserConfiguration(ObjectMapperConfiguration.class)
			.run((context) -> assertThat(context).hasBean('jacksonCodecCustomizer'));
	}
	@Test
	void userProvidedCustomizerCanOverrideJacksonCodecCustomizer() {
		this.contextRunner.withUserConfiguration(ObjectMapperConfiguration.class, CodecCustomizerConfiguration.class)
			.run((context) -> {
				List<CodecCustomizer> codecCustomizers = context.getBean(CodecCustomizers.class).codecCustomizers;
				assertThat(codecCustomizers).hasSize(3);
				assertThat(codecCustomizers.get(2)).isInstanceOf(TestCodecCustomizer.class);
			});
	}
	@Test
	void maxInMemorySizeEnforcedInDefaultCodecs() {
		this.contextRunner.withPropertyValues('spring.codec.max-in-memory-size=1MB').run((context) -> {
			CodecCustomizer customizer = context.getBean(CodecCustomizer.class);
			CodecConfigurer configurer = new DefaultClientCodecConfigurer();
			customizer.customize(configurer);
			assertThat(configurer.defaultCodecs()).hasFieldOrPropertyWithValue('maxInMemorySize', 1048576);
		});
	}
	static class TestAnnotationAwareOrderComparator extends AnnotationAwareOrderComparator {
		@Override
		public Integer findOrder(Object obj) {
			return super.findOrder(obj);
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ObjectMapperConfiguration {
		@Bean
		ObjectMapper objectMapper() {
			return new ObjectMapper();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class CodecCustomizerConfiguration {
		@Bean
		CodecCustomizer codecCustomizer() {
			return new TestCodecCustomizer();
		}
		@Bean
		CodecCustomizers codecCustomizers(List<CodecCustomizer> customizers) {
			return new CodecCustomizers(customizers);
		}
	}
	private static final class TestCodecCustomizer implements CodecCustomizer {
		@Override
		public void customize(CodecConfigurer configurer) {
		}
	}
	private static final class CodecCustomizers {
		private final List<CodecCustomizer> codecCustomizers;
		private CodecCustomizers(List<CodecCustomizer> codecCustomizers) {
			this.codecCustomizers = codecCustomizers;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http;
/**
class HttpMessageConvertersAutoConfigurationTests {
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class));
	@Test
	void jacksonNotAvailable() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(ObjectMapper.class);
			assertThat(context).doesNotHaveBean(MappingJackson2HttpMessageConverter.class);
			assertThat(context).doesNotHaveBean(MappingJackson2XmlHttpMessageConverter.class);
		});
	}
	@Test
	void jacksonDefaultConverter() {
		this.contextRunner.withUserConfiguration(JacksonObjectMapperConfig.class)
			.run(assertConverter(MappingJackson2HttpMessageConverter.class, 'mappingJackson2HttpMessageConverter'));
	}
	@Test
	void jacksonConverterWithBuilder() {
		this.contextRunner.withUserConfiguration(JacksonObjectMapperBuilderConfig.class)
			.run(assertConverter(MappingJackson2HttpMessageConverter.class, 'mappingJackson2HttpMessageConverter'));
	}
	@Test
	void jacksonXmlConverterWithBuilder() {
		this.contextRunner.withUserConfiguration(JacksonObjectMapperBuilderConfig.class)
			.run(assertConverter(MappingJackson2XmlHttpMessageConverter.class,
					'mappingJackson2XmlHttpMessageConverter'));
	}
	@Test
	void jacksonCustomConverter() {
		this.contextRunner.withUserConfiguration(JacksonObjectMapperConfig.class, JacksonConverterConfig.class)
			.run(assertConverter(MappingJackson2HttpMessageConverter.class, 'customJacksonMessageConverter'));
	}
	@Test
	void gsonNotAvailable() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(Gson.class);
			assertThat(context).doesNotHaveBean(GsonHttpMessageConverter.class);
		});
	}
	@Test
	void gsonDefaultConverter() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(GsonAutoConfiguration.class))
			.run(assertConverter(GsonHttpMessageConverter.class, 'gsonHttpMessageConverter'));
	}
	@Test
	void gsonCustomConverter() {
		this.contextRunner.withUserConfiguration(GsonConverterConfig.class)
			.withConfiguration(AutoConfigurations.of(GsonAutoConfiguration.class))
			.run(assertConverter(GsonHttpMessageConverter.class, 'customGsonMessageConverter'));
	}
	@Test
	void gsonCanBePreferred() {
		allOptionsRunner().withPropertyValues('spring.mvc.converters.preferred-json-mapper:gson').run((context) -> {
			assertConverterBeanExists(context, GsonHttpMessageConverter.class, 'gsonHttpMessageConverter');
			assertConverterBeanRegisteredWithHttpMessageConverters(context, GsonHttpMessageConverter.class);
			assertThat(context).doesNotHaveBean(JsonbHttpMessageConverter.class);
			assertThat(context).doesNotHaveBean(MappingJackson2HttpMessageConverter.class);
		});
	}
	@Test
	void jsonbNotAvailable() {
		this.contextRunner.run((context) -> {
			assertThat(context).doesNotHaveBean(Jsonb.class);
			assertThat(context).doesNotHaveBean(JsonbHttpMessageConverter.class);
		});
	}
	@Test
	void jsonbDefaultConverter() {
		this.contextRunner.withConfiguration(AutoConfigurations.of(JsonbAutoConfiguration.class))
			.run(assertConverter(JsonbHttpMessageConverter.class, 'jsonbHttpMessageConverter'));
	}
	@Test
	void jsonbCustomConverter() {
		this.contextRunner.withUserConfiguration(JsonbConverterConfig.class)
			.withConfiguration(AutoConfigurations.of(JsonbAutoConfiguration.class))
			.run(assertConverter(JsonbHttpMessageConverter.class, 'customJsonbMessageConverter'));
	}
	@Test
	void jsonbCanBePreferred() {
		allOptionsRunner().withPropertyValues('spring.mvc.converters.preferred-json-mapper:jsonb').run((context) -> {
			assertConverterBeanExists(context, JsonbHttpMessageConverter.class, 'jsonbHttpMessageConverter');
			assertConverterBeanRegisteredWithHttpMessageConverters(context, JsonbHttpMessageConverter.class);
			assertThat(context).doesNotHaveBean(GsonHttpMessageConverter.class);
			assertThat(context).doesNotHaveBean(MappingJackson2HttpMessageConverter.class);
		});
	}
	@Test
	void stringDefaultConverter() {
		this.contextRunner.run(assertConverter(StringHttpMessageConverter.class, 'stringHttpMessageConverter'));
	}
	@Test
	void stringCustomConverter() {
		this.contextRunner.withUserConfiguration(StringConverterConfig.class)
			.run(assertConverter(StringHttpMessageConverter.class, 'customStringMessageConverter'));
	}
	@Test
	void typeConstrainedConverterDoesNotPreventAutoConfigurationOfJacksonConverter() {
		this.contextRunner
			.withUserConfiguration(JacksonObjectMapperBuilderConfig.class, TypeConstrainedConverterConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = ((GenericApplicationContext) context.getSourceApplicationContext())
					.getBeanDefinition('mappingJackson2HttpMessageConverter');
				assertThat(beanDefinition.getFactoryBeanName())
					.isEqualTo(MappingJackson2HttpMessageConverterConfiguration.class.getName());
			});
	}
	@Test
	void typeConstrainedConverterFromSpringDataDoesNotPreventAutoConfigurationOfJacksonConverter() {
		this.contextRunner
			.withUserConfiguration(JacksonObjectMapperBuilderConfig.class, RepositoryRestMvcConfiguration.class)
			.run((context) -> {
				BeanDefinition beanDefinition = ((GenericApplicationContext) context.getSourceApplicationContext())
					.getBeanDefinition('mappingJackson2HttpMessageConverter');
				assertThat(beanDefinition.getFactoryBeanName())
					.isEqualTo(MappingJackson2HttpMessageConverterConfiguration.class.getName());
			});
	}
	@Test
	void jacksonIsPreferredByDefault() {
		allOptionsRunner().run((context) -> {
			assertConverterBeanExists(context, MappingJackson2HttpMessageConverter.class,
					'mappingJackson2HttpMessageConverter');
			assertConverterBeanRegisteredWithHttpMessageConverters(context, MappingJackson2HttpMessageConverter.class);
			assertThat(context).doesNotHaveBean(GsonHttpMessageConverter.class);
			assertThat(context).doesNotHaveBean(JsonbHttpMessageConverter.class);
		});
	}
	@Test
	void gsonIsPreferredIfJacksonIsNotAvailable() {
		allOptionsRunner().withClassLoader(new FilteredClassLoader(ObjectMapper.class.getPackage().getName()))
			.run((context) -> {
				assertConverterBeanExists(context, GsonHttpMessageConverter.class, 'gsonHttpMessageConverter');
				assertConverterBeanRegisteredWithHttpMessageConverters(context, GsonHttpMessageConverter.class);
				assertThat(context).doesNotHaveBean(JsonbHttpMessageConverter.class);
			});
	}
	@Test
	void jsonbIsPreferredIfJacksonAndGsonAreNotAvailable() {
		allOptionsRunner()
			.withClassLoader(new FilteredClassLoader(ObjectMapper.class.getPackage().getName(),
					Gson.class.getPackage().getName()))
			.run(assertConverter(JsonbHttpMessageConverter.class, 'jsonbHttpMessageConverter'));
	}
	@Test
	void whenServletWebApplicationHttpMessageConvertersIsConfigured() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.run((context) -> assertThat(context).hasSingleBean(HttpMessageConverters.class));
	}
	@Test
	void whenReactiveWebApplicationHttpMessageConvertersIsNotConfigured() {
		new ReactiveWebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.run((context) -> assertThat(context).doesNotHaveBean(HttpMessageConverters.class));
	}
	@Test
	void whenEncodingCharsetIsNotConfiguredThenStringMessageConverterUsesUtf8() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(StringHttpMessageConverter.class);
				assertThat(context.getBean(StringHttpMessageConverter.class).getDefaultCharset())
					.isEqualTo(StandardCharsets.UTF_8);
			});
	}
	@Test
	void whenEncodingCharsetIsConfiguredThenStringMessageConverterUsesSpecificCharset() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.withPropertyValues('server.servlet.encoding.charset=UTF-16')
			.run((context) -> {
				assertThat(context).hasSingleBean(StringHttpMessageConverter.class);
				assertThat(context.getBean(StringHttpMessageConverter.class).getDefaultCharset())
					.isEqualTo(StandardCharsets.UTF_16);
			});
	}
	@Test // gh-21789
	void whenAutoConfigurationIsActiveThenServerPropertiesConfigurationPropertiesAreNotEnabled() {
		new WebApplicationContextRunner()
			.withConfiguration(AutoConfigurations.of(HttpMessageConvertersAutoConfiguration.class))
			.run((context) -> {
				assertThat(context).hasSingleBean(HttpMessageConverters.class);
				assertThat(context).doesNotHaveBean(ServerProperties.class);
			});
	}
	@Test
	void shouldRegisterHints() {
		RuntimeHints hints = new RuntimeHints();
		new HttpMessageConvertersAutoConfigurationRuntimeHints().registerHints(hints, getClass().getClassLoader());
		assertThat(RuntimeHintsPredicates.reflection().onType(Encoding.class)).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(Encoding.class, 'getCharset')).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(Encoding.class, 'setCharset')).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(Encoding.class, 'isForce')).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(Encoding.class, 'setForce')).accepts(hints);
		assertThat(RuntimeHintsPredicates.reflection().onMethod(Encoding.class, 'shouldForce')).rejects(hints);
	}
	private ApplicationContextRunner allOptionsRunner() {
		return this.contextRunner.withConfiguration(AutoConfigurations.of(GsonAutoConfiguration.class,
				JacksonAutoConfiguration.class, JsonbAutoConfiguration.class));
	}
	private ContextConsumer<AssertableApplicationContext> assertConverter(
			Class<? extends HttpMessageConverter<?>> converterType, String beanName) {
		return (context) -> {
			assertConverterBeanExists(context, converterType, beanName);
			assertConverterBeanRegisteredWithHttpMessageConverters(context, converterType);
		};
	}
	private void assertConverterBeanExists(AssertableApplicationContext context, Class<?> type, String beanName) {
		assertThat(context).hasSingleBean(type);
		assertThat(context).hasBean(beanName);
	}
	private void assertConverterBeanRegisteredWithHttpMessageConverters(AssertableApplicationContext context,
			Class<? extends HttpMessageConverter<?>> type) {
		HttpMessageConverter<?> converter = context.getBean(type);
		HttpMessageConverters converters = context.getBean(HttpMessageConverters.class);
		assertThat(converters.getConverters()).contains(converter);
	}
	@Configuration(proxyBeanMethods = false)
	static class JacksonObjectMapperConfig {
		@Bean
		ObjectMapper objectMapper() {
			return new ObjectMapper();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JacksonObjectMapperBuilderConfig {
		@Bean
		ObjectMapper objectMapper() {
			return new ObjectMapper();
		}
		@Bean
		Jackson2ObjectMapperBuilder builder() {
			return new Jackson2ObjectMapperBuilder();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JacksonConverterConfig {
		@Bean
		MappingJackson2HttpMessageConverter customJacksonMessageConverter(ObjectMapper objectMapper) {
			MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
			converter.setObjectMapper(objectMapper);
			return converter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class GsonConverterConfig {
		@Bean
		GsonHttpMessageConverter customGsonMessageConverter(Gson gson) {
			GsonHttpMessageConverter converter = new GsonHttpMessageConverter();
			converter.setGson(gson);
			return converter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class JsonbConverterConfig {
		@Bean
		JsonbHttpMessageConverter customJsonbMessageConverter(Jsonb jsonb) {
			JsonbHttpMessageConverter converter = new JsonbHttpMessageConverter();
			converter.setJsonb(jsonb);
			return converter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class StringConverterConfig {
		@Bean
		StringHttpMessageConverter customStringMessageConverter() {
			return new StringHttpMessageConverter();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class TypeConstrainedConverterConfiguration {
		@Bean
		TypeConstrainedMappingJackson2HttpMessageConverter typeConstrainedConverter() {
			return new TypeConstrainedMappingJackson2HttpMessageConverter(RepresentationModel.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http.client;
/**
class HttpClientPropertiesTests {
	@Nested
	class FactoryTests {
		@Test
		void httpComponentsBuilder() {
			assertThat(Factory.HTTP_COMPONENTS.builder())
				.isInstanceOf(HttpComponentsClientHttpRequestFactoryBuilder.class);
		}
		@Test
		void jettyBuilder() {
			assertThat(Factory.JETTY.builder()).isInstanceOf(JettyClientHttpRequestFactoryBuilder.class);
		}
		@Test
		void reactorBuilder() {
			assertThat(Factory.REACTOR.builder()).isInstanceOf(ReactorClientHttpRequestFactoryBuilder.class);
		}
		@Test
		void jdkBuilder() {
			assertThat(Factory.JDK.builder()).isInstanceOf(JdkClientHttpRequestFactoryBuilder.class);
		}
		@Test
		void simpleBuilder() {
			assertThat(Factory.SIMPLE.builder()).isInstanceOf(SimpleClientHttpRequestFactoryBuilder.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.http.client;
/**
class HttpClientAutoConfigurationTests {
	private static final AutoConfigurations autoConfigurations = AutoConfigurations
		.of(HttpClientAutoConfiguration.class, SslAutoConfiguration.class);
	private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
		.withConfiguration(autoConfigurations);
	@Test
	void configuresDetectedClientHttpRequestFactoryBuilder() {
		this.contextRunner.run((context) -> assertThat(context).hasSingleBean(ClientHttpRequestFactoryBuilder.class));
	}
	@Test
	void configuresDefinedClientHttpRequestFactoryBuilder() {
		this.contextRunner.withPropertyValues('spring.http.client.factory=simple')
			.run((context) -> assertThat(context.getBean(ClientHttpRequestFactoryBuilder.class))
				.isInstanceOf(SimpleClientHttpRequestFactoryBuilder.class));
	}
	@Test
	void configuresClientHttpRequestFactorySettings() {
		this.contextRunner.withPropertyValues(sslPropertyValues().toArray(String[]::new))
			.withPropertyValues('spring.http.client.redirects=dont-follow', 'spring.http.client.connect-timeout=10s',
					'spring.http.client.read-timeout=20s', 'spring.http.client.ssl.bundle=test')
			.run((context) -> {
				ClientHttpRequestFactorySettings settings = context.getBean(ClientHttpRequestFactorySettings.class);
				assertThat(settings.redirects()).isEqualTo(Redirects.DONT_FOLLOW);
				assertThat(settings.connectTimeout()).isEqualTo(Duration.ofSeconds(10));
				assertThat(settings.readTimeout()).isEqualTo(Duration.ofSeconds(20));
				assertThat(settings.sslBundle().getKey().getAlias()).isEqualTo('alias1');
			});
	}
	private List<String> sslPropertyValues() {
		List<String> propertyValues = new ArrayList<>();
		String location = 'classpath:org/springframework/boot/autoconfigure/ssl/';
		propertyValues.add('spring.ssl.bundle.pem.test.key.alias=alias1');
		propertyValues.add('spring.ssl.bundle.pem.test.truststore.type=PKCS12');
		propertyValues.add('spring.ssl.bundle.pem.test.truststore.certificate=' + location + 'rsa-cert.pem');
		propertyValues.add('spring.ssl.bundle.pem.test.truststore.private-key=' + location + 'rsa-key.pem');
		return propertyValues;
	}
	@Test
	void whenReactiveWebApplicationBeansAreNotConfigured() {
		new ReactiveWebApplicationContextRunner().withConfiguration(autoConfigurations)
			.run((context) -> assertThat(context).doesNotHaveBean(ClientHttpRequestFactoryBuilder.class)
				.doesNotHaveBean(ClientHttpRequestFactorySettings.class));
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationReproTests {
	private ConfigurableApplicationContext context;
	@AfterEach
	void cleanup() {
		if (this.context != null) {
			this.context.close();
		}
	}
	@Test
	void doesNotEarlyInitializeFactoryBeans() {
		SpringApplication application = new SpringApplication(EarlyInitConfig.class,
				PropertySourcesPlaceholderConfigurer.class, ServletWebServerFactoryAutoConfiguration.class);
		this.context = application.run('--server.port=0');
		String bean = (String) this.context.getBean('earlyInit');
		assertThat(bean).isEqualTo('bucket');
	}
	@Configuration(proxyBeanMethods = false)
	static class Config {
	}
	@Configuration(proxyBeanMethods = false)
	@ImportResource('classpath:/early-init-test.xml')
	static class EarlyInitConfig {
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class BundleContentNotWatchableFailureAnalyzer extends AbstractFailureAnalyzer<BundleContentNotWatchableException> {
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, BundleContentNotWatchableException cause) {
		return new FailureAnalysis(cause.getMessage(), 'Update your application to correct the invalid configuration:\n'
				+ 'Either use a watchable resource, or disable bundle reloading by setting reload-on-update = false on the bundle.',
				cause);
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class CertificateMatcher {
	private static final byte[] DATA = new byte[256];
	static {
		for (int i = 0; i < DATA.length; i++) {
			DATA[i] = (byte) i;
		}
	}
	private final PrivateKey privateKey;
	private final Signature signature;
	private final byte[] generatedSignature;
	CertificateMatcher(PrivateKey privateKey) {
		Assert.notNull(privateKey, 'Private key must not be null');
		this.privateKey = privateKey;
		this.signature = createSignature(privateKey);
		Assert.notNull(this.signature, 'Failed to create signature');
		this.generatedSignature = sign(this.signature, privateKey);
	}
	private Signature createSignature(PrivateKey privateKey) {
		try {
			String algorithm = getSignatureAlgorithm(privateKey);
			return (algorithm != null) ? Signature.getInstance(algorithm) : null;
		}
		catch (NoSuchAlgorithmException ex) {
			return null;
		}
	}
	private static String getSignatureAlgorithm(PrivateKey privateKey) {
		// https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#signature-algorithms
		// https://docs.oracle.com/en/java/javase/17/docs/specs/security/standard-names.html#keypairgenerator-algorithms
		return switch (privateKey.getAlgorithm()) {
			case 'RSA' -> 'SHA256withRSA';
			case 'DSA' -> 'SHA256withDSA';
			case 'EC' -> 'SHA256withECDSA';
			case 'EdDSA' -> 'EdDSA';
			default -> null;
		};
	}
	boolean matchesAny(List<? extends Certificate> certificates) {
		return (this.generatedSignature != null) && certificates.stream().anyMatch(this::matches);
	}
	boolean matches(Certificate certificate) {
		return matches(certificate.getPublicKey());
	}
	private boolean matches(PublicKey publicKey) {
		return (this.generatedSignature != null)
				&& Objects.equals(this.privateKey.getAlgorithm(), publicKey.getAlgorithm()) && verify(publicKey);
	}
	private boolean verify(PublicKey publicKey) {
		try {
			this.signature.initVerify(publicKey);
			this.signature.update(DATA);
			return this.signature.verify(this.generatedSignature);
		}
		catch (InvalidKeyException | SignatureException ex) {
			return false;
		}
	}
	private static byte[] sign(Signature signature, PrivateKey privateKey) {
		try {
			signature.initSign(privateKey);
			signature.update(DATA);
			return signature.sign();
		}
		catch (InvalidKeyException | SignatureException ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
@ConfigurationProperties(prefix = 'spring.ssl')
public class SslProperties {
	/**
	 * SSL bundles.
	 */
	private final Bundles bundle = new Bundles();
	public Bundles getBundle() {
		return this.bundle;
	}
	/**
	 * Properties to define SSL Bundles.
	 */
	public static class Bundles {
		/**
		 * PEM-encoded SSL trust material.
		 */
		private final Map<String, PemSslBundleProperties> pem = new LinkedHashMap<>();
		/**
		 * Java keystore SSL trust material.
		 */
		private final Map<String, JksSslBundleProperties> jks = new LinkedHashMap<>();
		/**
		 * Trust material watching.
		 */
		private final Watch watch = new Watch();
		public Map<String, PemSslBundleProperties> getPem() {
			return this.pem;
		}
		public Map<String, JksSslBundleProperties> getJks() {
			return this.jks;
		}
		public Watch getWatch() {
			return this.watch;
		}
		public static class Watch {
			/**
			 * File watching.
			 */
			private final File file = new File();
			public File getFile() {
				return this.file;
			}
			public static class File {
				/**
				 * Quiet period, after which changes are detected.
				 */
				private Duration quietPeriod = Duration.ofSeconds(10);
				public Duration getQuietPeriod() {
					return this.quietPeriod;
				}
				public void setQuietPeriod(Duration quietPeriod) {
					this.quietPeriod = quietPeriod;
				}
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
record BundleContentProperty(String name, String value) {
	/**
	 * Return if the property value is PEM content.
	 * @return if the value is PEM content
	 */
	boolean isPemContent() {
		return PemContent.isPresentInText(this.value);
	}
	/**
	 * Return if there is any property value present.
	 * @return if the value is present
	 */
	boolean hasValue() {
		return StringUtils.hasText(this.value);
	}
	Path toWatchPath(ResourceLoader resourceLoader) {
		try {
			Assert.state(!isPemContent(), 'Value contains PEM content');
			Resource resource = resourceLoader.getResource(this.value);
			if (!resource.isFile()) {
				throw new BundleContentNotWatchableException(this);
			}
			return Path.of(resource.getFile().getAbsolutePath());
		}
		catch (Exception ex) {
			if (ex instanceof BundleContentNotWatchableException bundleContentNotWatchableException) {
				throw bundleContentNotWatchableException;
			}
			throw new IllegalStateException('Unable to convert value of property "%s" to a path'.formatted(this.name),
					ex);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
@FunctionalInterface
public interface SslBundleRegistrar {
	/**
	 * Callback method for registering {@link SslBundle}s with an
	 * {@link SslBundleRegistry}.
	 * @param registry the registry that accepts {@code SslBundle}s
	 */
	void registerBundles(SslBundleRegistry registry);
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
@AutoConfiguration
@EnableConfigurationProperties(SslProperties.class)
public class SslAutoConfiguration {
	private final ResourceLoader resourceLoader;
	private final SslProperties sslProperties;
	SslAutoConfiguration(ResourceLoader resourceLoader, SslProperties sslProperties) {
		this.resourceLoader = ApplicationResourceLoader.get(resourceLoader);
		this.sslProperties = sslProperties;
	}
	@Bean
	FileWatcher fileWatcher() {
		return new FileWatcher(this.sslProperties.getBundle().getWatch().getFile().getQuietPeriod());
	}
	@Bean
	SslPropertiesBundleRegistrar sslPropertiesSslBundleRegistrar(FileWatcher fileWatcher) {
		return new SslPropertiesBundleRegistrar(this.sslProperties, fileWatcher, this.resourceLoader);
	}
	@Bean
	@ConditionalOnMissingBean({ SslBundleRegistry.class, SslBundles.class })
	DefaultSslBundleRegistry sslBundleRegistry(ObjectProvider<SslBundleRegistrar> sslBundleRegistrars) {
		DefaultSslBundleRegistry registry = new DefaultSslBundleRegistry();
		sslBundleRegistrars.orderedStream().forEach((registrar) -> registrar.registerBundles(registry));
		return registry;
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class BundleContentNotWatchableException extends RuntimeException {
	private final BundleContentProperty property;
	BundleContentNotWatchableException(BundleContentProperty property) {
		super('The content of "%s" is not watchable. Only "file:" resources are watchable, but "%s" has been set'
			.formatted(property.name(), property.value()));
		this.property = property;
	}
	private BundleContentNotWatchableException(String bundleName, BundleContentProperty property, Throwable cause) {
		super('The content of "%s" from bundle "%s" is not watchable". Only "file:" resources are watchable, but "%s" has been set'
			.formatted(property.name(), bundleName, property.value()), cause);
		this.property = property;
	}
	BundleContentNotWatchableException withBundleName(String bundleName) {
		return new BundleContentNotWatchableException(bundleName, this.property, this);
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
public class JksSslBundleProperties extends SslBundleProperties {
	/**
	 * Keystore properties.
	 */
	private final Store keystore = new Store();
	/**
	 * Truststore properties.
	 */
	private final Store truststore = new Store();
	public Store getKeystore() {
		return this.keystore;
	}
	public Store getTruststore() {
		return this.truststore;
	}
	/**
	 * Store properties.
	 */
	public static class Store {
		/**
		 * Type of the store to create, e.g. JKS.
		 */
		private String type;
		/**
		 * Provider for the store.
		 */
		private String provider;
		/**
		 * Location of the resource containing the store content.
		 */
		private String location;
		/**
		 * Password used to access the store.
		 */
		private String password;
		public String getType() {
			return this.type;
		}
		public void setType(String type) {
			this.type = type;
		}
		public String getProvider() {
			return this.provider;
		}
		public void setProvider(String provider) {
			this.provider = provider;
		}
		public String getLocation() {
			return this.location;
		}
		public void setLocation(String location) {
			this.location = location;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
public final class PropertiesSslBundle implements SslBundle {
	private final SslStoreBundle stores;
	private final SslBundleKey key;
	private final SslOptions options;
	private final String protocol;
	private final SslManagerBundle managers;
	private PropertiesSslBundle(SslStoreBundle stores, SslBundleProperties properties) {
		this.stores = stores;
		this.key = asSslKeyReference(properties.getKey());
		this.options = asSslOptions(properties.getOptions());
		this.protocol = properties.getProtocol();
		this.managers = SslManagerBundle.from(this.stores, this.key);
	}
	private static SslBundleKey asSslKeyReference(Key key) {
		return (key != null) ? SslBundleKey.of(key.getPassword(), key.getAlias()) : SslBundleKey.NONE;
	}
	private static SslOptions asSslOptions(SslBundleProperties.Options options) {
		return (options != null) ? SslOptions.of(options.getCiphers(), options.getEnabledProtocols()) : SslOptions.NONE;
	}
	@Override
	public SslStoreBundle getStores() {
		return this.stores;
	}
	@Override
	public SslBundleKey getKey() {
		return this.key;
	}
	@Override
	public SslOptions getOptions() {
		return this.options;
	}
	@Override
	public String getProtocol() {
		return this.protocol;
	}
	@Override
	public SslManagerBundle getManagers() {
		return this.managers;
	}
	/**
	 * Get an {@link SslBundle} for the given {@link PemSslBundleProperties}.
	 * @param properties the source properties
	 * @return an {@link SslBundle} instance
	 */
	public static SslBundle get(PemSslBundleProperties properties) {
		return get(properties, ApplicationResourceLoader.get());
	}
	/**
	 * Get an {@link SslBundle} for the given {@link PemSslBundleProperties}.
	 * @param properties the source properties
	 * @param resourceLoader the resource loader used to load content
	 * @return an {@link SslBundle} instance
	 * @since 3.3.5
	 */
	public static SslBundle get(PemSslBundleProperties properties, ResourceLoader resourceLoader) {
		PemSslStore keyStore = getPemSslStore('keystore', properties.getKeystore(), resourceLoader);
		if (keyStore != null) {
			keyStore = keyStore.withAlias(properties.getKey().getAlias())
				.withPassword(properties.getKey().getPassword());
		}
		PemSslStore trustStore = getPemSslStore('truststore', properties.getTruststore(), resourceLoader);
		SslStoreBundle storeBundle = new PemSslStoreBundle(keyStore, trustStore);
		return new PropertiesSslBundle(storeBundle, properties);
	}
	private static PemSslStore getPemSslStore(String propertyName, PemSslBundleProperties.Store properties,
			ResourceLoader resourceLoader) {
		PemSslStoreDetails details = asPemSslStoreDetails(properties);
		PemSslStore pemSslStore = PemSslStore.load(details, resourceLoader);
		if (properties.isVerifyKeys()) {
			CertificateMatcher certificateMatcher = new CertificateMatcher(pemSslStore.privateKey());
			Assert.state(certificateMatcher.matchesAny(pemSslStore.certificates()),
					'Private key in %s matches none of the certificates in the chain'.formatted(propertyName));
		}
		return pemSslStore;
	}
	private static PemSslStoreDetails asPemSslStoreDetails(PemSslBundleProperties.Store properties) {
		return new PemSslStoreDetails(properties.getType(), properties.getCertificate(), properties.getPrivateKey(),
				properties.getPrivateKeyPassword());
	}
	/**
	 * Get an {@link SslBundle} for the given {@link JksSslBundleProperties}.
	 * @param properties the source properties
	 * @return an {@link SslBundle} instance
	 */
	public static SslBundle get(JksSslBundleProperties properties) {
		return get(properties, ApplicationResourceLoader.get());
	}
	/**
	 * Get an {@link SslBundle} for the given {@link JksSslBundleProperties}.
	 * @param properties the source properties
	 * @param resourceLoader the resource loader used to load content
	 * @return an {@link SslBundle} instance
	 * @since 3.3.5
	 */
	public static SslBundle get(JksSslBundleProperties properties, ResourceLoader resourceLoader) {
		SslStoreBundle storeBundle = asSslStoreBundle(properties, resourceLoader);
		return new PropertiesSslBundle(storeBundle, properties);
	}
	private static SslStoreBundle asSslStoreBundle(JksSslBundleProperties properties, ResourceLoader resourceLoader) {
		JksSslStoreDetails keyStoreDetails = asStoreDetails(properties.getKeystore());
		JksSslStoreDetails trustStoreDetails = asStoreDetails(properties.getTruststore());
		return new JksSslStoreBundle(keyStoreDetails, trustStoreDetails, resourceLoader);
	}
	private static JksSslStoreDetails asStoreDetails(JksSslBundleProperties.Store properties) {
		return new JksSslStoreDetails(properties.getType(), properties.getProvider(), properties.getLocation(),
				properties.getPassword());
	}
	@Override
	public String toString() {
		ToStringCreator creator = new ToStringCreator(this);
		creator.append('key', this.key);
		creator.append('options', this.options);
		creator.append('protocol', this.protocol);
		creator.append('stores', this.stores);
		return creator.toString();
	}
}
/*
/**
package org.springframework.boot.autoconfigure.ssl;
/*
package org.springframework.boot.autoconfigure.ssl;
/**
public abstract class SslBundleProperties {
	/**
	 * Key details for the bundle.
	 */
	private final Key key = new Key();
	/**
	 * Options for the SSL connection.
	 */
	private final Options options = new Options();
	/**
	 * SSL Protocol to use.
	 */
	private String protocol = SslBundle.DEFAULT_PROTOCOL;
	/**
	 * Whether to reload the SSL bundle.
	 */
	private boolean reloadOnUpdate;
	public Key getKey() {
		return this.key;
	}
	public Options getOptions() {
		return this.options;
	}
	public String getProtocol() {
		return this.protocol;
	}
	public void setProtocol(String protocol) {
		this.protocol = protocol;
	}
	public boolean isReloadOnUpdate() {
		return this.reloadOnUpdate;
	}
	public void setReloadOnUpdate(boolean reloadOnUpdate) {
		this.reloadOnUpdate = reloadOnUpdate;
	}
	public static class Options {
		/**
		 * Supported SSL ciphers.
		 */
		private Set<String> ciphers;
		/**
		 * Enabled SSL protocols.
		 */
		private Set<String> enabledProtocols;
		public Set<String> getCiphers() {
			return this.ciphers;
		}
		public void setCiphers(Set<String> ciphers) {
			this.ciphers = ciphers;
		}
		public Set<String> getEnabledProtocols() {
			return this.enabledProtocols;
		}
		public void setEnabledProtocols(Set<String> enabledProtocols) {
			this.enabledProtocols = enabledProtocols;
		}
	}
	public static class Key {
		/**
		 * The password used to access the key in the key store.
		 */
		private String password;
		/**
		 * The alias that identifies the key in the key store.
		 */
		private String alias;
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			this.password = password;
		}
		public String getAlias() {
			return this.alias;
		}
		public void setAlias(String alias) {
			this.alias = alias;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class SslPropertiesBundleRegistrar implements SslBundleRegistrar {
	private final SslProperties.Bundles properties;
	private final FileWatcher fileWatcher;
	private final ResourceLoader resourceLoader;
	SslPropertiesBundleRegistrar(SslProperties properties, FileWatcher fileWatcher, ResourceLoader resourceLoader) {
		this.properties = properties.getBundle();
		this.fileWatcher = fileWatcher;
		this.resourceLoader = resourceLoader;
	}
	@Override
	public void registerBundles(SslBundleRegistry registry) {
		registerBundles(registry, this.properties.getPem(), PropertiesSslBundle::get, this::watchedPemPaths);
		registerBundles(registry, this.properties.getJks(), PropertiesSslBundle::get, this::watchedJksPaths);
	}
	private <P extends SslBundleProperties> void registerBundles(SslBundleRegistry registry, Map<String, P> properties,
			BiFunction<P, ResourceLoader, SslBundle> bundleFactory, Function<Bundle<P>, Set<Path>> watchedPaths) {
		properties.forEach((bundleName, bundleProperties) -> {
			Supplier<SslBundle> bundleSupplier = () -> bundleFactory.apply(bundleProperties, this.resourceLoader);
			try {
				registry.registerBundle(bundleName, bundleSupplier.get());
				if (bundleProperties.isReloadOnUpdate()) {
					Supplier<Set<Path>> pathsSupplier = () -> watchedPaths
						.apply(new Bundle<>(bundleName, bundleProperties));
					watchForUpdates(registry, bundleName, pathsSupplier, bundleSupplier);
				}
			}
			catch (IllegalStateException ex) {
				throw new IllegalStateException('Unable to register SSL bundle "%s"'.formatted(bundleName), ex);
			}
		});
	}
	private void watchForUpdates(SslBundleRegistry registry, String bundleName, Supplier<Set<Path>> pathsSupplier,
			Supplier<SslBundle> bundleSupplier) {
		try {
			this.fileWatcher.watch(pathsSupplier.get(), () -> registry.updateBundle(bundleName, bundleSupplier.get()));
		}
		catch (RuntimeException ex) {
			throw new IllegalStateException('Unable to watch for reload on update', ex);
		}
	}
	private Set<Path> watchedJksPaths(Bundle<JksSslBundleProperties> bundle) {
		List<BundleContentProperty> watched = new ArrayList<>();
		watched.add(new BundleContentProperty('keystore.location', bundle.properties().getKeystore().getLocation()));
		watched
			.add(new BundleContentProperty('truststore.location', bundle.properties().getTruststore().getLocation()));
		return watchedPaths(bundle.name(), watched);
	}
	private Set<Path> watchedPemPaths(Bundle<PemSslBundleProperties> bundle) {
		List<BundleContentProperty> watched = new ArrayList<>();
		watched
			.add(new BundleContentProperty('keystore.private-key', bundle.properties().getKeystore().getPrivateKey()));
		watched
			.add(new BundleContentProperty('keystore.certificate', bundle.properties().getKeystore().getCertificate()));
		watched.add(new BundleContentProperty('truststore.private-key',
				bundle.properties().getTruststore().getPrivateKey()));
		watched.add(new BundleContentProperty('truststore.certificate',
				bundle.properties().getTruststore().getCertificate()));
		return watchedPaths(bundle.name(), watched);
	}
	private Set<Path> watchedPaths(String bundleName, List<BundleContentProperty> properties) {
		try {
			return properties.stream()
				.filter(BundleContentProperty::hasValue)
				.map((content) -> content.toWatchPath(this.resourceLoader))
				.collect(Collectors.toSet());
		}
		catch (BundleContentNotWatchableException ex) {
			throw ex.withBundleName(bundleName);
		}
	}
	private record Bundle<P>(String name, P properties) {
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
public class PemSslBundleProperties extends SslBundleProperties {
	/**
	 * Keystore properties.
	 */
	private final Store keystore = new Store();
	/**
	 * Truststore properties.
	 */
	private final Store truststore = new Store();
	public Store getKeystore() {
		return this.keystore;
	}
	public Store getTruststore() {
		return this.truststore;
	}
	/**
	 * Store properties.
	 */
	public static class Store {
		/**
		 * Type of the store to create, e.g. JKS.
		 */
		private String type;
		/**
		 * Location or content of the certificate or certificate chain in PEM format.
		 */
		private String certificate;
		/**
		 * Location or content of the private key in PEM format.
		 */
		private String privateKey;
		/**
		 * Password used to decrypt an encrypted private key.
		 */
		private String privateKeyPassword;
		/**
		 * Whether to verify that the private key matches the public key.
		 */
		private boolean verifyKeys;
		public String getType() {
			return this.type;
		}
		public void setType(String type) {
			this.type = type;
		}
		public String getCertificate() {
			return this.certificate;
		}
		public void setCertificate(String certificate) {
			this.certificate = certificate;
		}
		public String getPrivateKey() {
			return this.privateKey;
		}
		public void setPrivateKey(String privateKey) {
			this.privateKey = privateKey;
		}
		public String getPrivateKeyPassword() {
			return this.privateKeyPassword;
		}
		public void setPrivateKeyPassword(String privateKeyPassword) {
			this.privateKeyPassword = privateKeyPassword;
		}
		public boolean isVerifyKeys() {
			return this.verifyKeys;
		}
		public void setVerifyKeys(boolean verifyKeys) {
			this.verifyKeys = verifyKeys;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.ssl;
/**
class FileWatcher implements Closeable {
	private static final Log logger = LogFactory.getLog(FileWatcher.class);
	private final Duration quietPeriod;
	private final Object lock = new Object();
	private WatcherThread thread;
	/**
	 * Create a new {@link FileWatcher} instance.
	 * @param quietPeriod the duration that no file changes should occur before triggering
	 * actions
	 */
	FileWatcher(Duration quietPeriod) {
		Assert.notNull(quietPeriod, 'QuietPeriod must not be null');
		this.quietPeriod = quietPeriod;
	}
	/**
	 * Watch the given files or directories for changes.
	 * @param paths the files or directories to watch
	 * @param action the action to take when changes are detected
	 */
	void watch(Set<Path> paths, Runnable action) {
		Assert.notNull(paths, 'Paths must not be null');
		Assert.notNull(action, 'Action must not be null');
		if (paths.isEmpty()) {
			return;
		}
		synchronized (this.lock) {
			try {
				if (this.thread == null) {
					this.thread = new WatcherThread();
					this.thread.start();
				}
				this.thread.register(new Registration(paths, action));
			}
			catch (IOException ex) {
				throw new UncheckedIOException('Failed to register paths for watching: ' + paths, ex);
			}
		}
	}
	@Override
	public void close() throws IOException {
		synchronized (this.lock) {
			if (this.thread != null) {
				this.thread.close();
				this.thread.interrupt();
				try {
					this.thread.join();
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
				this.thread = null;
			}
		}
	}
	/**
	 * The watcher thread used to check for changes.
	 */
	private class WatcherThread extends Thread implements Closeable {
		private final WatchService watchService = FileSystems.getDefault().newWatchService();
		private final Map<WatchKey, List<Registration>> registrations = new ConcurrentHashMap<>();
		private volatile boolean running = true;
		WatcherThread() throws IOException {
			setName('ssl-bundle-watcher');
			setDaemon(true);
			setUncaughtExceptionHandler(this::onThreadException);
		}
		private void onThreadException(Thread thread, Throwable throwable) {
			logger.error('Uncaught exception in file watcher thread', throwable);
		}
		void register(Registration registration) throws IOException {
			for (Path path : registration.paths()) {
				if (!Files.isRegularFile(path) && !Files.isDirectory(path)) {
					throw new IOException('"%s" is neither a file nor a directory'.formatted(path));
				}
				Path directory = Files.isDirectory(path) ? path : path.getParent();
				WatchKey watchKey = register(directory);
				this.registrations.computeIfAbsent(watchKey, (key) -> new CopyOnWriteArrayList<>()).add(registration);
			}
		}
		private WatchKey register(Path directory) throws IOException {
			logger.debug(LogMessage.format('Registering "%s"', directory));
			return directory.register(this.watchService, StandardWatchEventKinds.ENTRY_CREATE,
					StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);
		}
		@Override
		public void run() {
			logger.debug('Watch thread started');
			Set<Runnable> actions = new HashSet<>();
			while (this.running) {
				try {
					long timeout = FileWatcher.this.quietPeriod.toMillis();
					WatchKey key = this.watchService.poll(timeout, TimeUnit.MILLISECONDS);
					if (key == null) {
						actions.forEach(this::runSafely);
						actions.clear();
					}
					else {
						accumulate(key, actions);
						key.reset();
					}
				}
				catch (InterruptedException ex) {
					Thread.currentThread().interrupt();
				}
				catch (ClosedWatchServiceException ex) {
					logger.debug('File watcher has been closed');
					this.running = false;
				}
			}
			logger.debug('Watch thread stopped');
		}
		private void runSafely(Runnable action) {
			try {
				action.run();
			}
			catch (Throwable ex) {
				logger.error('Unexpected SSL reload error', ex);
			}
		}
		private void accumulate(WatchKey key, Set<Runnable> actions) {
			List<Registration> registrations = this.registrations.get(key);
			Path directory = (Path) key.watchable();
			for (WatchEvent<?> event : key.pollEvents()) {
				Path file = directory.resolve((Path) event.context());
				for (Registration registration : registrations) {
					if (registration.manages(file)) {
						actions.add(registration.action());
					}
				}
			}
		}
		@Override
		public void close() throws IOException {
			this.running = false;
			this.watchService.close();
		}
	}
	/**
	 * An individual watch registration.
	 */
	private record Registration(Set<Path> paths, Runnable action) {
		Registration {
			paths = paths.stream().map(Path::toAbsolutePath).collect(Collectors.toSet());
		}
		boolean manages(Path file) {
			Path absolutePath = file.toAbsolutePath();
			return this.paths.contains(absolutePath) || isInDirectories(absolutePath);
		}
		private boolean isInDirectories(Path file) {
			return this.paths.stream().filter(Files::isDirectory).anyMatch(file::startsWith);
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@Retention(RetentionPolicy.RUNTIME)
@Target({ ElementType.TYPE })
@Documented
public @interface AutoConfigureBefore {
	/**
	 * The auto-configure classes that should have not yet been applied.
	 * @return the classes
	 */
	Class<?>[] value() default {};
	/**
	 * The names of the auto-configure classes that should have not yet been applied.
	 * @return the class names
	 * @since 1.2.2
	 */
	String[] name() default {};
}
/*
package org.springframework.boot.autoconfigure.groovy.template;
/**
@AutoConfiguration(after = WebMvcAutoConfiguration.class)
@ConditionalOnClass(MarkupTemplateEngine.class)
@EnableConfigurationProperties(GroovyTemplateProperties.class)
public class GroovyTemplateAutoConfiguration {
	private static final Log logger = LogFactory.getLog(GroovyTemplateAutoConfiguration.class);
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(GroovyMarkupConfigurer.class)
	public static class GroovyMarkupConfiguration {
		private final ApplicationContext applicationContext;
		private final GroovyTemplateProperties properties;
		public GroovyMarkupConfiguration(ApplicationContext applicationContext, GroovyTemplateProperties properties) {
			this.applicationContext = applicationContext;
			this.properties = properties;
			checkTemplateLocationExists();
		}
		public void checkTemplateLocationExists() {
			if (this.properties.isCheckTemplateLocation() && !isUsingGroovyAllJar()) {
				TemplateLocation location = new TemplateLocation(this.properties.getResourceLoaderPath());
				if (!location.exists(this.applicationContext)) {
					logger.warn(LogMessage.format(
							'Cannot find template location: %s (please add some templates, check your Groovy '
									+ 'configuration, or set spring.groovy.template.check-template-location=false)',
							location));
				}
			}
		}
		/**
		 * MarkupTemplateEngine could be loaded from groovy-templates or groovy-all.
		 * Unfortunately it"s quite common for people to use groovy-all and not actually
		 * need templating support. This method attempts to check the source jar so that
		 * we can skip the {@code /template} directory check for such cases.
		 * @return true if the groovy-all jar is used
		 */
		private boolean isUsingGroovyAllJar() {
			try {
				ProtectionDomain domain = MarkupTemplateEngine.class.getProtectionDomain();
				CodeSource codeSource = domain.getCodeSource();
				return codeSource != null && codeSource.getLocation().toString().contains('-all');
			}
			catch (Exception ex) {
				return false;
			}
		}
		@Bean
		@ConditionalOnMissingBean(GroovyMarkupConfig.class)
		@ConfigurationProperties(prefix = 'spring.groovy.template.configuration')
		public GroovyMarkupConfigurer groovyMarkupConfigurer(ObjectProvider<MarkupTemplateEngine> templateEngine) {
			GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();
			configurer.setResourceLoaderPath(this.properties.getResourceLoaderPath());
			configurer.setCacheTemplates(this.properties.isCache());
			templateEngine.ifAvailable(configurer::setTemplateEngine);
			return configurer;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Servlet.class, LocaleContextHolder.class, UrlBasedViewResolver.class })
	@ConditionalOnWebApplication(type = Type.SERVLET)
	@ConditionalOnProperty(name = 'spring.groovy.template.enabled', matchIfMissing = true)
	public static class GroovyWebConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'groovyMarkupViewResolver')
		public GroovyMarkupViewResolver groovyMarkupViewResolver(GroovyTemplateProperties properties) {
			GroovyMarkupViewResolver resolver = new GroovyMarkupViewResolver();
			properties.applyToMvcViewResolver(resolver);
			return resolver;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.groovy.template;
/*
package org.springframework.boot.autoconfigure.groovy.template;
/**
public class GroovyTemplateAvailabilityProvider extends PathBasedTemplateAvailabilityProvider {
	private static final String REQUIRED_CLASS_NAME = 'groovy.text.TemplateEngine';
	public GroovyTemplateAvailabilityProvider() {
		super(REQUIRED_CLASS_NAME, GroovyTemplateAvailabilityProperties.class, 'spring.groovy.template');
	}
	protected static final class GroovyTemplateAvailabilityProperties extends TemplateAvailabilityProperties {
		private List<String> resourceLoaderPath = new ArrayList<>(
				Arrays.asList(GroovyTemplateProperties.DEFAULT_RESOURCE_LOADER_PATH));
		GroovyTemplateAvailabilityProperties() {
			super(GroovyTemplateProperties.DEFAULT_PREFIX, GroovyTemplateProperties.DEFAULT_SUFFIX);
		}
		@Override
		protected List<String> getLoaderPath() {
			return this.resourceLoaderPath;
		}
		public List<String> getResourceLoaderPath() {
			return this.resourceLoaderPath;
		}
		public void setResourceLoaderPath(List<String> resourceLoaderPath) {
			this.resourceLoaderPath = resourceLoaderPath;
		}
	}
	static class GroovyTemplateAvailabilityRuntimeHints extends BindableRuntimeHintsRegistrar {
		GroovyTemplateAvailabilityRuntimeHints() {
			super(GroovyTemplateAvailabilityProperties.class);
		}
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			if (ClassUtils.isPresent(REQUIRED_CLASS_NAME, classLoader)) {
				super.registerHints(hints, classLoader);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.groovy.template;
/**
@ConfigurationProperties(prefix = 'spring.groovy.template', ignoreUnknownFields = true)
public class GroovyTemplateProperties extends AbstractTemplateViewResolverProperties {
	public static final String DEFAULT_RESOURCE_LOADER_PATH = 'classpath:/templates/';
	public static final String DEFAULT_PREFIX = '';
	public static final String DEFAULT_SUFFIX = '.tpl';
	public static final String DEFAULT_REQUEST_CONTEXT_ATTRIBUTE = 'spring';
	/**
	 * Template path.
	 */
	private String resourceLoaderPath = DEFAULT_RESOURCE_LOADER_PATH;
	public GroovyTemplateProperties() {
		super(DEFAULT_PREFIX, DEFAULT_SUFFIX);
		setRequestContextAttribute(DEFAULT_REQUEST_CONTEXT_ATTRIBUTE);
	}
	public String getResourceLoaderPath() {
		return this.resourceLoaderPath;
	}
	public void setResourceLoaderPath(String resourceLoaderPath) {
		this.resourceLoaderPath = resourceLoaderPath;
	}
}
/*
package org.springframework.boot.autoconfigure.jmx;
/**
public class ParentAwareNamingStrategy extends MetadataNamingStrategy implements ApplicationContextAware {
	private ApplicationContext applicationContext;
	private boolean ensureUniqueRuntimeObjectNames;
	public ParentAwareNamingStrategy(JmxAttributeSource attributeSource) {
		super(attributeSource);
	}
	/**
	 * Set if unique runtime object names should be ensured.
	 * @param ensureUniqueRuntimeObjectNames {@code true} if unique names should be
	 * ensured.
	 */
	public void setEnsureUniqueRuntimeObjectNames(boolean ensureUniqueRuntimeObjectNames) {
		this.ensureUniqueRuntimeObjectNames = ensureUniqueRuntimeObjectNames;
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		this.applicationContext = applicationContext;
	}
	@Override
	public ObjectName getObjectName(Object managedBean, String beanKey) throws MalformedObjectNameException {
		ObjectName name = super.getObjectName(managedBean, beanKey);
		if (this.ensureUniqueRuntimeObjectNames) {
			return JmxUtils.appendIdentityToObjectName(name, managedBean);
		}
		if (parentContextContainsSameBean(this.applicationContext, beanKey)) {
			return appendToObjectName(name, 'context', ObjectUtils.getIdentityHexString(this.applicationContext));
		}
		return name;
	}
	private boolean parentContextContainsSameBean(ApplicationContext context, String beanKey) {
		if (context.getParent() == null) {
			return false;
		}
		try {
			this.applicationContext.getParent().getBean(beanKey);
			return true;
		}
		catch (BeansException ex) {
			return parentContextContainsSameBean(context.getParent(), beanKey);
		}
	}
	private ObjectName appendToObjectName(ObjectName name, String key, String value)
			throws MalformedObjectNameException {
		Hashtable<String, String> keyProperties = name.getKeyPropertyList();
		keyProperties.put(key, value);
		return ObjectNameManager.getInstance(name.getDomain(), keyProperties);
	}
}
/*
package org.springframework.boot.autoconfigure.jmx;
/**
@AutoConfiguration
@EnableConfigurationProperties(JmxProperties.class)
@ConditionalOnClass({ MBeanExporter.class })
@ConditionalOnProperty(prefix = 'spring.jmx', name = 'enabled', havingValue = 'true')
public class JmxAutoConfiguration {
	private final JmxProperties properties;
	public JmxAutoConfiguration(JmxProperties properties) {
		this.properties = properties;
	}
	@Bean
	@Primary
	@ConditionalOnMissingBean(value = MBeanExporter.class, search = SearchStrategy.CURRENT)
	public AnnotationMBeanExporter mbeanExporter(ObjectNamingStrategy namingStrategy, BeanFactory beanFactory) {
		AnnotationMBeanExporter exporter = new AnnotationMBeanExporter();
		exporter.setRegistrationPolicy(this.properties.getRegistrationPolicy());
		exporter.setNamingStrategy(namingStrategy);
		String serverBean = this.properties.getServer();
		if (StringUtils.hasLength(serverBean)) {
			exporter.setServer(beanFactory.getBean(serverBean, MBeanServer.class));
		}
		exporter.setEnsureUniqueRuntimeObjectNames(this.properties.isUniqueNames());
		return exporter;
	}
	@Bean
	@ConditionalOnMissingBean(value = ObjectNamingStrategy.class, search = SearchStrategy.CURRENT)
	public ParentAwareNamingStrategy objectNamingStrategy() {
		ParentAwareNamingStrategy namingStrategy = new ParentAwareNamingStrategy(new AnnotationJmxAttributeSource());
		String defaultDomain = this.properties.getDefaultDomain();
		if (StringUtils.hasLength(defaultDomain)) {
			namingStrategy.setDefaultDomain(defaultDomain);
		}
		namingStrategy.setEnsureUniqueRuntimeObjectNames(this.properties.isUniqueNames());
		return namingStrategy;
	}
	@Bean
	@ConditionalOnMissingBean
	public MBeanServer mbeanServer() {
		MBeanServerFactoryBean factory = new MBeanServerFactoryBean();
		factory.setLocateExistingServerIfPossible(true);
		factory.afterPropertiesSet();
		return factory.getObject();
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jmx;
/*
package org.springframework.boot.autoconfigure.jmx;
/**
@ConfigurationProperties(prefix = 'spring.jmx')
public class JmxProperties {
	/**
	 * Expose Spring"s management beans to the JMX domain.
	 */
	private boolean enabled = false;
	/**
	 * Whether unique runtime object names should be ensured.
	 */
	private boolean uniqueNames = false;
	/**
	 * MBeanServer bean name.
	 */
	private String server = 'mbeanServer';
	/**
	 * JMX domain name.
	 */
	private String defaultDomain;
	/**
	 * JMX Registration policy.
	 */
	private RegistrationPolicy registrationPolicy = RegistrationPolicy.FAIL_ON_EXISTING;
	public boolean getEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public boolean isUniqueNames() {
		return this.uniqueNames;
	}
	public void setUniqueNames(boolean uniqueNames) {
		this.uniqueNames = uniqueNames;
	}
	public String getServer() {
		return this.server;
	}
	public void setServer(String server) {
		this.server = server;
	}
	public String getDefaultDomain() {
		return this.defaultDomain;
	}
	public void setDefaultDomain(String defaultDomain) {
		this.defaultDomain = defaultDomain;
	}
	public RegistrationPolicy getRegistrationPolicy() {
		return this.registrationPolicy;
	}
	public void setRegistrationPolicy(RegistrationPolicy registrationPolicy) {
		this.registrationPolicy = registrationPolicy;
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class SharedMetadataReaderFactoryContextInitializer implements
		ApplicationContextInitializer<ConfigurableApplicationContext>, Ordered, BeanRegistrationExcludeFilter {
	public static final String BEAN_NAME = 'org.springframework.boot.autoconfigure.'
			+ 'internalCachingMetadataReaderFactory';
	@Override
	public void initialize(ConfigurableApplicationContext applicationContext) {
		if (AotDetector.useGeneratedArtifacts()) {
			return;
		}
		BeanFactoryPostProcessor postProcessor = new CachingMetadataReaderFactoryPostProcessor(applicationContext);
		applicationContext.addBeanFactoryPostProcessor(postProcessor);
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public boolean isExcludedFromAotProcessing(RegisteredBean registeredBean) {
		return BEAN_NAME.equals(registeredBean.getBeanName());
	}
	/**
	 * {@link BeanDefinitionRegistryPostProcessor} to register the
	 * {@link CachingMetadataReaderFactory} and configure the
	 * {@link ConfigurationClassPostProcessor}.
	 */
	static class CachingMetadataReaderFactoryPostProcessor
			implements BeanDefinitionRegistryPostProcessor, PriorityOrdered {
		private final ConfigurableApplicationContext context;
		CachingMetadataReaderFactoryPostProcessor(ConfigurableApplicationContext context) {
			this.context = context;
		}
		@Override
		public int getOrder() {
			// Must happen before the ConfigurationClassPostProcessor is created
			return Ordered.HIGHEST_PRECEDENCE;
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			register(registry);
			configureConfigurationClassPostProcessor(registry);
		}
		private void register(BeanDefinitionRegistry registry) {
			if (!registry.containsBeanDefinition(BEAN_NAME)) {
				BeanDefinition definition = BeanDefinitionBuilder
					.rootBeanDefinition(SharedMetadataReaderFactoryBean.class, SharedMetadataReaderFactoryBean::new)
					.getBeanDefinition();
				registry.registerBeanDefinition(BEAN_NAME, definition);
			}
		}
		private void configureConfigurationClassPostProcessor(BeanDefinitionRegistry registry) {
			try {
				configureConfigurationClassPostProcessor(
						registry.getBeanDefinition(AnnotationConfigUtils.CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));
			}
			catch (NoSuchBeanDefinitionException ex) {
				// Ignore
			}
		}
		private void configureConfigurationClassPostProcessor(BeanDefinition definition) {
			if (definition instanceof AbstractBeanDefinition abstractBeanDefinition) {
				configureConfigurationClassPostProcessor(abstractBeanDefinition);
				return;
			}
			configureConfigurationClassPostProcessor(definition.getPropertyValues());
		}
		private void configureConfigurationClassPostProcessor(AbstractBeanDefinition definition) {
			Supplier<?> instanceSupplier = definition.getInstanceSupplier();
			if (instanceSupplier != null) {
				definition.setInstanceSupplier(
						new ConfigurationClassPostProcessorCustomizingSupplier(this.context, instanceSupplier));
				return;
			}
			configureConfigurationClassPostProcessor(definition.getPropertyValues());
		}
		private void configureConfigurationClassPostProcessor(MutablePropertyValues propertyValues) {
			propertyValues.add('metadataReaderFactory', new RuntimeBeanReference(BEAN_NAME));
		}
	}
	/**
	 * {@link Supplier} used to customize the {@link ConfigurationClassPostProcessor} when
	 * it"s first created.
	 */
	static class ConfigurationClassPostProcessorCustomizingSupplier implements Supplier<Object> {
		private final ConfigurableApplicationContext context;
		private final Supplier<?> instanceSupplier;
		ConfigurationClassPostProcessorCustomizingSupplier(ConfigurableApplicationContext context,
				Supplier<?> instanceSupplier) {
			this.context = context;
			this.instanceSupplier = instanceSupplier;
		}
		@Override
		public Object get() {
			Object instance = this.instanceSupplier.get();
			if (instance instanceof ConfigurationClassPostProcessor postProcessor) {
				configureConfigurationClassPostProcessor(postProcessor);
			}
			return instance;
		}
		private void configureConfigurationClassPostProcessor(ConfigurationClassPostProcessor instance) {
			instance.setMetadataReaderFactory(this.context.getBean(BEAN_NAME, MetadataReaderFactory.class));
		}
	}
	/**
	 * {@link FactoryBean} to create the shared {@link MetadataReaderFactory}.
	 */
	static class SharedMetadataReaderFactoryBean
			implements FactoryBean<ConcurrentReferenceCachingMetadataReaderFactory>, ResourceLoaderAware,
			ApplicationListener<ContextRefreshedEvent> {
		private ConcurrentReferenceCachingMetadataReaderFactory metadataReaderFactory;
		@Override
		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.metadataReaderFactory = new ConcurrentReferenceCachingMetadataReaderFactory(resourceLoader);
		}
		@Override
		public ConcurrentReferenceCachingMetadataReaderFactory getObject() throws Exception {
			return this.metadataReaderFactory;
		}
		@Override
		public Class<?> getObjectType() {
			return CachingMetadataReaderFactory.class;
		}
		@Override
		public boolean isSingleton() {
			return true;
		}
		@Override
		public void onApplicationEvent(ContextRefreshedEvent event) {
			this.metadataReaderFactory.clearCache();
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public abstract class AutoConfigurationPackages {
	private static final Log logger = LogFactory.getLog(AutoConfigurationPackages.class);
	private static final String BEAN = AutoConfigurationPackages.class.getName();
	/**
	 * Determine if the auto-configuration base packages for the given bean factory are
	 * available.
	 * @param beanFactory the source bean factory
	 * @return true if there are auto-config packages available
	 */
	public static boolean has(BeanFactory beanFactory) {
		return beanFactory.containsBean(BEAN) && !get(beanFactory).isEmpty();
	}
	/**
	 * Return the auto-configuration base packages for the given bean factory.
	 * @param beanFactory the source bean factory
	 * @return a list of auto-configuration packages
	 * @throws IllegalStateException if auto-configuration is not enabled
	 */
	public static List<String> get(BeanFactory beanFactory) {
		try {
			return beanFactory.getBean(BEAN, BasePackages.class).get();
		}
		catch (NoSuchBeanDefinitionException ex) {
			throw new IllegalStateException('Unable to retrieve @EnableAutoConfiguration base packages');
		}
	}
	/**
	 * Programmatically registers the auto-configuration package names. Subsequent
	 * invocations will add the given package names to those that have already been
	 * registered. You can use this method to manually define the base packages that will
	 * be used for a given {@link BeanDefinitionRegistry}. Generally it"s recommended that
	 * you don"t call this method directly, but instead rely on the default convention
	 * where the package name is set from your {@code @EnableAutoConfiguration}
	 * configuration class or classes.
	 * @param registry the bean definition registry
	 * @param packageNames the package names to set
	 */
	public static void register(BeanDefinitionRegistry registry, String... packageNames) {
		if (registry.containsBeanDefinition(BEAN)) {
			addBasePackages(registry.getBeanDefinition(BEAN), packageNames);
		}
		else {
			RootBeanDefinition beanDefinition = new RootBeanDefinition(BasePackages.class);
			beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
			addBasePackages(beanDefinition, packageNames);
			registry.registerBeanDefinition(BEAN, beanDefinition);
		}
	}
	private static void addBasePackages(BeanDefinition beanDefinition, String[] additionalBasePackages) {
		ConstructorArgumentValues constructorArgumentValues = beanDefinition.getConstructorArgumentValues();
		if (constructorArgumentValues.hasIndexedArgumentValue(0)) {
			String[] existingPackages = (String[]) constructorArgumentValues.getIndexedArgumentValue(0, String[].class)
				.getValue();
			constructorArgumentValues.addIndexedArgumentValue(0,
					Stream.concat(Stream.of(existingPackages), Stream.of(additionalBasePackages))
						.distinct()
						.toArray(String[]::new));
		}
		else {
			constructorArgumentValues.addIndexedArgumentValue(0, additionalBasePackages);
		}
	}
	/**
	 * {@link ImportBeanDefinitionRegistrar} to store the base package from the importing
	 * configuration.
	 */
	static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports {
		@Override
		public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
			register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0]));
		}
		@Override
		public Set<Object> determineImports(AnnotationMetadata metadata) {
			return Collections.singleton(new PackageImports(metadata));
		}
	}
	/**
	 * Wrapper for a package import.
	 */
	private static final class PackageImports {
		private final List<String> packageNames;
		PackageImports(AnnotationMetadata metadata) {
			AnnotationAttributes attributes = AnnotationAttributes
				.fromMap(metadata.getAnnotationAttributes(AutoConfigurationPackage.class.getName(), false));
			List<String> packageNames = new ArrayList<>(Arrays.asList(attributes.getStringArray('basePackages')));
			for (Class<?> basePackageClass : attributes.getClassArray('basePackageClasses')) {
				packageNames.add(basePackageClass.getPackage().getName());
			}
			if (packageNames.isEmpty()) {
				packageNames.add(ClassUtils.getPackageName(metadata.getClassName()));
			}
			this.packageNames = Collections.unmodifiableList(packageNames);
		}
		List<String> getPackageNames() {
			return this.packageNames;
		}
		@Override
		public boolean equals(Object obj) {
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.packageNames.equals(((PackageImports) obj).packageNames);
		}
		@Override
		public int hashCode() {
			return this.packageNames.hashCode();
		}
		@Override
		public String toString() {
			return 'Package Imports ' + this.packageNames;
		}
	}
	/**
	 * Holder for the base package (name may be null to indicate no scanning).
	 */
	static final class BasePackages {
		private final List<String> packages;
		private boolean loggedBasePackageInfo;
		BasePackages(String... names) {
			List<String> packages = new ArrayList<>();
			for (String name : names) {
				if (StringUtils.hasText(name)) {
					packages.add(name);
				}
			}
			this.packages = packages;
		}
		List<String> get() {
			if (!this.loggedBasePackageInfo) {
				if (this.packages.isEmpty()) {
					if (logger.isWarnEnabled()) {
						logger.warn('@EnableAutoConfiguration was declared on a class '
								+ 'in the default package. Automatic @Repository and '
								+ '@Entity scanning is not enabled.');
					}
				}
				else {
					if (logger.isDebugEnabled()) {
						String packageNames = StringUtils.collectionToCommaDelimitedString(this.packages);
						logger.debug('@EnableAutoConfiguration was declared on a class in the package "' + packageNames
								+ '". Automatic @Repository and @Entity scanning is enabled.');
					}
				}
				this.loggedBasePackageInfo = true;
			}
			return this.packages;
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public class AutoConfigurationImportEvent extends EventObject {
	private final List<String> candidateConfigurations;
	private final Set<String> exclusions;
	public AutoConfigurationImportEvent(Object source, List<String> candidateConfigurations, Set<String> exclusions) {
		super(source);
		this.candidateConfigurations = Collections.unmodifiableList(candidateConfigurations);
		this.exclusions = Collections.unmodifiableSet(exclusions);
	}
	/**
	 * Return the auto-configuration candidate configurations that are going to be
	 * imported.
	 * @return the auto-configuration candidates
	 */
	public List<String> getCandidateConfigurations() {
		return this.candidateConfigurations;
	}
	/**
	 * Return the exclusions that were applied.
	 * @return the exclusions applied
	 */
	public Set<String> getExclusions() {
		return this.exclusions;
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
final class AutoConfigurationMetadataLoader {
	protected static final String PATH = 'META-INF/spring-autoconfigure-metadata.properties';
	private AutoConfigurationMetadataLoader() {
	}
	static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) {
		return loadMetadata(classLoader, PATH);
	}
	static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) {
		try {
			Enumeration<URL> urls = (classLoader != null) ? classLoader.getResources(path)
					: ClassLoader.getSystemResources(path);
			Properties properties = new Properties();
			while (urls.hasMoreElements()) {
				properties.putAll(PropertiesLoaderUtils.loadProperties(new UrlResource(urls.nextElement())));
			}
			return loadMetadata(properties);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException('Unable to load @ConditionalOnClass location [' + path + ']', ex);
		}
	}
	static AutoConfigurationMetadata loadMetadata(Properties properties) {
		return new PropertiesAutoConfigurationMetadata(properties);
	}
	/**
	 * {@link AutoConfigurationMetadata} implementation backed by a properties file.
	 */
	private static class PropertiesAutoConfigurationMetadata implements AutoConfigurationMetadata {
		private final Properties properties;
		PropertiesAutoConfigurationMetadata(Properties properties) {
			this.properties = properties;
		}
		@Override
		public boolean wasProcessed(String className) {
			return this.properties.containsKey(className);
		}
		@Override
		public Integer getInteger(String className, String key) {
			return getInteger(className, key, null);
		}
		@Override
		public Integer getInteger(String className, String key, Integer defaultValue) {
			String value = get(className, key);
			return (value != null) ? Integer.valueOf(value) : defaultValue;
		}
		@Override
		public Set<String> getSet(String className, String key) {
			return getSet(className, key, null);
		}
		@Override
		public Set<String> getSet(String className, String key, Set<String> defaultValue) {
			String value = get(className, key);
			return (value != null) ? StringUtils.commaDelimitedListToSet(value) : defaultValue;
		}
		@Override
		public String get(String className, String key) {
			return get(className, key, null);
		}
		@Override
		public String get(String className, String key, String defaultValue) {
			String value = this.properties.getProperty(className + '.' + key);
			return (value != null) ? value : defaultValue;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.webservices;
/**
@AutoConfiguration(after = ServletWebServerFactoryAutoConfiguration.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(MessageDispatcherServlet.class)
@ConditionalOnMissingBean(WsConfigurationSupport.class)
@EnableConfigurationProperties(WebServicesProperties.class)
public class WebServicesAutoConfiguration {
	@Bean
	public ServletRegistrationBean<MessageDispatcherServlet> messageDispatcherServlet(
			ApplicationContext applicationContext, WebServicesProperties properties) {
		MessageDispatcherServlet servlet = new MessageDispatcherServlet();
		servlet.setApplicationContext(applicationContext);
		String path = properties.getPath();
		String urlMapping = path + (path.endsWith('/') ? '*' : '/*');
		ServletRegistrationBean<MessageDispatcherServlet> registration = new ServletRegistrationBean<>(servlet,
				urlMapping);
		WebServicesProperties.Servlet servletProperties = properties.getServlet();
		registration.setLoadOnStartup(servletProperties.getLoadOnStartup());
		servletProperties.getInit().forEach(registration::addInitParameter);
		return registration;
	}
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	@Conditional(OnWsdlLocationsCondition.class)
	public static WsdlDefinitionBeanFactoryPostProcessor wsdlDefinitionBeanFactoryPostProcessor() {
		return new WsdlDefinitionBeanFactoryPostProcessor();
	}
	@Configuration(proxyBeanMethods = false)
	@EnableWs
	protected static class WsConfiguration {
	}
	static class WsdlDefinitionBeanFactoryPostProcessor
			implements BeanDefinitionRegistryPostProcessor, ApplicationContextAware {
		private ApplicationContext applicationContext;
		@Override
		public void setApplicationContext(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Override
		public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {
			Binder binder = Binder.get(this.applicationContext.getEnvironment());
			List<String> wsdlLocations = binder.bind('spring.webservices.wsdl-locations', Bindable.listOf(String.class))
				.orElse(Collections.emptyList());
			for (String wsdlLocation : wsdlLocations) {
				registerBeans(wsdlLocation, '*.wsdl', SimpleWsdl11Definition.class, SimpleWsdl11Definition::new,
						registry);
				registerBeans(wsdlLocation, '*.xsd', SimpleXsdSchema.class, SimpleXsdSchema::new, registry);
			}
		}
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
		}
		private <T> void registerBeans(String location, String pattern, Class<T> type,
				Function<Resource, T> beanSupplier, BeanDefinitionRegistry registry) {
			for (Resource resource : getResources(location, pattern)) {
				BeanDefinition beanDefinition = BeanDefinitionBuilder
					.rootBeanDefinition(type, () -> beanSupplier.apply(resource))
					.getBeanDefinition();
				registry.registerBeanDefinition(StringUtils.stripFilenameExtension(resource.getFilename()),
						beanDefinition);
			}
		}
		private Resource[] getResources(String location, String pattern) {
			try {
				return this.applicationContext.getResources(ensureTrailingSlash(location) + pattern);
			}
			catch (IOException ex) {
				return new Resource[0];
			}
		}
		private String ensureTrailingSlash(String path) {
			return path.endsWith('/') ? path : path + '/';
		}
	}
}
/*
package org.springframework.boot.autoconfigure.webservices.client;
/**
@AutoConfiguration(after = HttpClientAutoConfiguration.class)
@ConditionalOnClass({ WebServiceTemplate.class, Unmarshaller.class, Marshaller.class })
public class WebServiceTemplateAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public WebServiceMessageSenderFactory webServiceHttpMessageSenderFactory(
			ObjectProvider<ClientHttpRequestFactoryBuilder<?>> clientHttpRequestFactoryBuilder,
			ObjectProvider<ClientHttpRequestFactorySettings> clientHttpRequestFactorySettings) {
		return WebServiceMessageSenderFactory.http(
				clientHttpRequestFactoryBuilder.getIfAvailable(ClientHttpRequestFactoryBuilder::detect),
				clientHttpRequestFactorySettings.getIfAvailable());
	}
	@Bean
	@ConditionalOnMissingBean
	public WebServiceTemplateBuilder webServiceTemplateBuilder(
			ObjectProvider<WebServiceMessageSenderFactory> httpWebServiceMessageSenderBuilder,
			ObjectProvider<WebServiceTemplateCustomizer> webServiceTemplateCustomizers) {
		WebServiceTemplateBuilder templateBuilder = new WebServiceTemplateBuilder();
		WebServiceMessageSenderFactory httpMessageSenderFactory = httpWebServiceMessageSenderBuilder.getIfAvailable();
		if (httpMessageSenderFactory != null) {
			templateBuilder = templateBuilder.httpMessageSenderFactory(httpMessageSenderFactory);
		}
		List<WebServiceTemplateCustomizer> customizers = webServiceTemplateCustomizers.orderedStream().toList();
		if (!customizers.isEmpty()) {
			templateBuilder = templateBuilder.customizers(customizers);
		}
		return templateBuilder;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.webservices.client;
/*
package org.springframework.boot.autoconfigure.webservices;
/**
@ConfigurationProperties(prefix = 'spring.webservices')
public class WebServicesProperties {
	/**
	 * Path that serves as the base URI for the services.
	 */
	private String path = '/services';
	private final Servlet servlet = new Servlet();
	public String getPath() {
		return this.path;
	}
	public void setPath(String path) {
		Assert.notNull(path, 'Path must not be null');
		Assert.isTrue(path.length() > 1, 'Path must have length greater than 1');
		Assert.isTrue(path.startsWith('/'), 'Path must start with "/"');
		this.path = path;
	}
	public Servlet getServlet() {
		return this.servlet;
	}
	public static class Servlet {
		/**
		 * Servlet init parameters to pass to Spring Web Services.
		 */
		private Map<String, String> init = new HashMap<>();
		/**
		 * Load on startup priority of the Spring Web Services servlet.
		 */
		private int loadOnStartup = -1;
		public Map<String, String> getInit() {
			return this.init;
		}
		public void setInit(Map<String, String> init) {
			this.init = init;
		}
		public int getLoadOnStartup() {
			return this.loadOnStartup;
		}
		public void setLoadOnStartup(int loadOnStartup) {
			this.loadOnStartup = loadOnStartup;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.webservices;
/*
package org.springframework.boot.autoconfigure.webservices;
/**
class OnWsdlLocationsCondition extends OnPropertyListCondition {
	OnWsdlLocationsCondition() {
		super('spring.webservices.wsdl-locations', () -> ConditionMessage.forCondition('WSDL locations'));
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class HikariJdbcConnectionDetailsBeanPostProcessor extends JdbcConnectionDetailsBeanPostProcessor<HikariDataSource> {
	HikariJdbcConnectionDetailsBeanPostProcessor(ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
		super(HikariDataSource.class, connectionDetailsProvider);
	}
	@Override
	protected Object processDataSource(HikariDataSource dataSource, JdbcConnectionDetails connectionDetails) {
		dataSource.setJdbcUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClassName(connectionDetails.getDriverClassName());
		return dataSource;
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
final class PropertiesJdbcConnectionDetails implements JdbcConnectionDetails {
	private final DataSourceProperties properties;
	PropertiesJdbcConnectionDetails(DataSourceProperties properties) {
		this.properties = properties;
	}
	@Override
	public String getUsername() {
		return this.properties.determineUsername();
	}
	@Override
	public String getPassword() {
		return this.properties.determinePassword();
	}
	@Override
	public String getJdbcUrl() {
		return this.properties.determineUrl();
	}
	@Override
	public String getDriverClassName() {
		return this.properties.determineDriverClassName();
	}
	@Override
	public String getXaDataSourceClassName() {
		return (this.properties.getXa().getDataSourceClassName() != null)
				? this.properties.getXa().getDataSourceClassName()
				: JdbcConnectionDetails.super.getXaDataSourceClassName();
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class OracleUcpJdbcConnectionDetailsBeanPostProcessor
		extends JdbcConnectionDetailsBeanPostProcessor<PoolDataSourceImpl> {
	OracleUcpJdbcConnectionDetailsBeanPostProcessor(ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
		super(PoolDataSourceImpl.class, connectionDetailsProvider);
	}
	@Override
	protected Object processDataSource(PoolDataSourceImpl dataSource, JdbcConnectionDetails connectionDetails) {
		try {
			dataSource.setURL(connectionDetails.getJdbcUrl());
			dataSource.setUser(connectionDetails.getUsername());
			dataSource.setPassword(connectionDetails.getPassword());
			dataSource.setConnectionFactoryClassName(connectionDetails.getDriverClassName());
			return dataSource;
		}
		catch (SQLException ex) {
			throw new RuntimeException('Failed to set URL / user / password of datasource', ex);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(JdbcOperations.class)
class JdbcTemplateConfiguration {
	@Bean
	@Primary
	JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) {
		JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
		JdbcProperties.Template template = properties.getTemplate();
		jdbcTemplate.setFetchSize(template.getFetchSize());
		jdbcTemplate.setMaxRows(template.getMaxRows());
		if (template.getQueryTimeout() != null) {
			jdbcTemplate.setQueryTimeout((int) template.getQueryTimeout().getSeconds());
		}
		return jdbcTemplate;
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
abstract class DataSourceConfiguration {
	@SuppressWarnings('unchecked')
	private static <T> T createDataSource(JdbcConnectionDetails connectionDetails, Class<? extends DataSource> type,
			ClassLoader classLoader) {
		return (T) DataSourceBuilder.create(classLoader)
			.type(type)
			.driverClassName(connectionDetails.getDriverClassName())
			.url(connectionDetails.getJdbcUrl())
			.username(connectionDetails.getUsername())
			.password(connectionDetails.getPassword())
			.build();
	}
	/**
	 * Tomcat Pool DataSource configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)
	@ConditionalOnMissingBean(DataSource.class)
	@ConditionalOnProperty(name = 'spring.datasource.type', havingValue = 'org.apache.tomcat.jdbc.pool.DataSource',
			matchIfMissing = true)
	static class Tomcat {
		@Bean
		@ConditionalOnMissingBean(PropertiesJdbcConnectionDetails.class)
		static TomcatJdbcConnectionDetailsBeanPostProcessor tomcatJdbcConnectionDetailsBeanPostProcessor(
				ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
			return new TomcatJdbcConnectionDetailsBeanPostProcessor(connectionDetailsProvider);
		}
		@Bean
		@ConfigurationProperties(prefix = 'spring.datasource.tomcat')
		org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties,
				JdbcConnectionDetails connectionDetails) {
			Class<? extends DataSource> dataSourceType = org.apache.tomcat.jdbc.pool.DataSource.class;
			org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(connectionDetails, dataSourceType,
					properties.getClassLoader());
			String validationQuery;
			DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(connectionDetails.getJdbcUrl());
			validationQuery = databaseDriver.getValidationQuery();
			if (validationQuery != null) {
				dataSource.setTestOnBorrow(true);
				dataSource.setValidationQuery(validationQuery);
			}
			return dataSource;
		}
	}
	/**
	 * Hikari DataSource configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HikariDataSource.class)
	@ConditionalOnMissingBean(DataSource.class)
	@ConditionalOnProperty(name = 'spring.datasource.type', havingValue = 'com.zaxxer.hikari.HikariDataSource',
			matchIfMissing = true)
	static class Hikari {
		@Bean
		static HikariJdbcConnectionDetailsBeanPostProcessor jdbcConnectionDetailsHikariBeanPostProcessor(
				ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
			return new HikariJdbcConnectionDetailsBeanPostProcessor(connectionDetailsProvider);
		}
		@Bean
		@ConfigurationProperties(prefix = 'spring.datasource.hikari')
		HikariDataSource dataSource(DataSourceProperties properties, JdbcConnectionDetails connectionDetails) {
			HikariDataSource dataSource = createDataSource(connectionDetails, HikariDataSource.class,
					properties.getClassLoader());
			if (StringUtils.hasText(properties.getName())) {
				dataSource.setPoolName(properties.getName());
			}
			return dataSource;
		}
	}
	/**
	 * DBCP DataSource configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(org.apache.commons.dbcp2.BasicDataSource.class)
	@ConditionalOnMissingBean(DataSource.class)
	@ConditionalOnProperty(name = 'spring.datasource.type', havingValue = 'org.apache.commons.dbcp2.BasicDataSource',
			matchIfMissing = true)
	static class Dbcp2 {
		@Bean
		static Dbcp2JdbcConnectionDetailsBeanPostProcessor dbcp2JdbcConnectionDetailsBeanPostProcessor(
				ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
			return new Dbcp2JdbcConnectionDetailsBeanPostProcessor(connectionDetailsProvider);
		}
		@Bean
		@ConfigurationProperties(prefix = 'spring.datasource.dbcp2')
		org.apache.commons.dbcp2.BasicDataSource dataSource(DataSourceProperties properties,
				JdbcConnectionDetails connectionDetails) {
			Class<? extends DataSource> dataSourceType = org.apache.commons.dbcp2.BasicDataSource.class;
			return createDataSource(connectionDetails, dataSourceType, properties.getClassLoader());
		}
	}
	/**
	 * Oracle UCP DataSource configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ PoolDataSourceImpl.class, OracleConnection.class })
	@ConditionalOnMissingBean(DataSource.class)
	@ConditionalOnProperty(name = 'spring.datasource.type', havingValue = 'oracle.ucp.jdbc.PoolDataSource',
			matchIfMissing = true)
	static class OracleUcp {
		@Bean
		static OracleUcpJdbcConnectionDetailsBeanPostProcessor oracleUcpJdbcConnectionDetailsBeanPostProcessor(
				ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
			return new OracleUcpJdbcConnectionDetailsBeanPostProcessor(connectionDetailsProvider);
		}
		@Bean
		@ConfigurationProperties(prefix = 'spring.datasource.oracleucp')
		PoolDataSourceImpl dataSource(DataSourceProperties properties, JdbcConnectionDetails connectionDetails)
				throws SQLException {
			PoolDataSourceImpl dataSource = createDataSource(connectionDetails, PoolDataSourceImpl.class,
					properties.getClassLoader());
			if (StringUtils.hasText(properties.getName())) {
				dataSource.setConnectionPoolName(properties.getName());
			}
			return dataSource;
		}
	}
	/**
	 * Generic DataSource configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(DataSource.class)
	@ConditionalOnProperty(name = 'spring.datasource.type')
	static class Generic {
		@Bean
		DataSource dataSource(DataSourceProperties properties, JdbcConnectionDetails connectionDetails) {
			return createDataSource(connectionDetails, properties.getType(), properties.getClassLoader());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnCheckpointRestore
@ConditionalOnBean(DataSource.class)
class DataSourceCheckpointRestoreConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HikariDataSource.class)
	static class Hikari {
		@Bean
		@ConditionalOnMissingBean
		HikariCheckpointRestoreLifecycle hikariCheckpointRestoreLifecycle(DataSource dataSource) {
			return new HikariCheckpointRestoreLifecycle(dataSource);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@ConfigurationProperties(prefix = 'spring.datasource')
public class DataSourceProperties implements BeanClassLoaderAware, InitializingBean {
	private ClassLoader classLoader;
	/**
	 * Whether to generate a random datasource name.
	 */
	private boolean generateUniqueName = true;
	/**
	 * Datasource name to use if 'generate-unique-name' is false. Defaults to 'testdb'
	 * when using an embedded database, otherwise null.
	 */
	private String name;
	/**
	 * Fully qualified name of the connection pool implementation to use. By default, it
	 * is auto-detected from the classpath.
	 */
	private Class<? extends DataSource> type;
	/**
	 * Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.
	 */
	private String driverClassName;
	/**
	 * JDBC URL of the database.
	 */
	private String url;
	/**
	 * Login username of the database.
	 */
	private String username;
	/**
	 * Login password of the database.
	 */
	private String password;
	/**
	 * JNDI location of the datasource. Class, url, username and password are ignored when
	 * set.
	 */
	private String jndiName;
	/**
	 * Connection details for an embedded database. Defaults to the most suitable embedded
	 * database that is available on the classpath.
	 */
	private EmbeddedDatabaseConnection embeddedDatabaseConnection;
	private Xa xa = new Xa();
	private String uniqueName;
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		if (this.embeddedDatabaseConnection == null) {
			this.embeddedDatabaseConnection = EmbeddedDatabaseConnection.get(this.classLoader);
		}
	}
	/**
	 * Initialize a {@link DataSourceBuilder} with the state of this instance.
	 * @return a {@link DataSourceBuilder} initialized with the customizations defined on
	 * this instance
	 */
	public DataSourceBuilder<?> initializeDataSourceBuilder() {
		return DataSourceBuilder.create(getClassLoader())
			.type(getType())
			.driverClassName(determineDriverClassName())
			.url(determineUrl())
			.username(determineUsername())
			.password(determinePassword());
	}
	public boolean isGenerateUniqueName() {
		return this.generateUniqueName;
	}
	public void setGenerateUniqueName(boolean generateUniqueName) {
		this.generateUniqueName = generateUniqueName;
	}
	public String getName() {
		return this.name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public Class<? extends DataSource> getType() {
		return this.type;
	}
	public void setType(Class<? extends DataSource> type) {
		this.type = type;
	}
	/**
	 * Return the configured driver or {@code null} if none was configured.
	 * @return the configured driver
	 * @see #determineDriverClassName()
	 */
	public String getDriverClassName() {
		return this.driverClassName;
	}
	public void setDriverClassName(String driverClassName) {
		this.driverClassName = driverClassName;
	}
	/**
	 * Determine the driver to use based on this configuration and the environment.
	 * @return the driver to use
	 * @since 1.4.0
	 */
	public String determineDriverClassName() {
		if (StringUtils.hasText(this.driverClassName)) {
			Assert.state(driverClassIsLoadable(), () -> 'Cannot load driver class: ' + this.driverClassName);
			return this.driverClassName;
		}
		String driverClassName = null;
		if (StringUtils.hasText(this.url)) {
			driverClassName = DatabaseDriver.fromJdbcUrl(this.url).getDriverClassName();
		}
		if (!StringUtils.hasText(driverClassName)) {
			driverClassName = this.embeddedDatabaseConnection.getDriverClassName();
		}
		if (!StringUtils.hasText(driverClassName)) {
			throw new DataSourceBeanCreationException('Failed to determine a suitable driver class', this,
					this.embeddedDatabaseConnection);
		}
		return driverClassName;
	}
	private boolean driverClassIsLoadable() {
		try {
			ClassUtils.forName(this.driverClassName, null);
			return true;
		}
		catch (UnsupportedClassVersionError ex) {
			// Driver library has been compiled with a later JDK, propagate error
			throw ex;
		}
		catch (Throwable ex) {
			return false;
		}
	}
	/**
	 * Return the configured url or {@code null} if none was configured.
	 * @return the configured url
	 * @see #determineUrl()
	 */
	public String getUrl() {
		return this.url;
	}
	public void setUrl(String url) {
		this.url = url;
	}
	/**
	 * Determine the url to use based on this configuration and the environment.
	 * @return the url to use
	 * @since 1.4.0
	 */
	public String determineUrl() {
		if (StringUtils.hasText(this.url)) {
			return this.url;
		}
		String databaseName = determineDatabaseName();
		String url = (databaseName != null) ? this.embeddedDatabaseConnection.getUrl(databaseName) : null;
		if (!StringUtils.hasText(url)) {
			throw new DataSourceBeanCreationException('Failed to determine suitable jdbc url', this,
					this.embeddedDatabaseConnection);
		}
		return url;
	}
	/**
	 * Determine the name to used based on this configuration.
	 * @return the database name to use or {@code null}
	 * @since 2.0.0
	 */
	public String determineDatabaseName() {
		if (this.generateUniqueName) {
			if (this.uniqueName == null) {
				this.uniqueName = UUID.randomUUID().toString();
			}
			return this.uniqueName;
		}
		if (StringUtils.hasLength(this.name)) {
			return this.name;
		}
		if (this.embeddedDatabaseConnection != EmbeddedDatabaseConnection.NONE) {
			return 'testdb';
		}
		return null;
	}
	/**
	 * Return the configured username or {@code null} if none was configured.
	 * @return the configured username
	 * @see #determineUsername()
	 */
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	/**
	 * Determine the username to use based on this configuration and the environment.
	 * @return the username to use
	 * @since 1.4.0
	 */
	public String determineUsername() {
		if (StringUtils.hasText(this.username)) {
			return this.username;
		}
		if (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName(), determineUrl())) {
			return 'sa';
		}
		return null;
	}
	/**
	 * Return the configured password or {@code null} if none was configured.
	 * @return the configured password
	 * @see #determinePassword()
	 */
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	/**
	 * Determine the password to use based on this configuration and the environment.
	 * @return the password to use
	 * @since 1.4.0
	 */
	public String determinePassword() {
		if (StringUtils.hasText(this.password)) {
			return this.password;
		}
		if (EmbeddedDatabaseConnection.isEmbedded(determineDriverClassName(), determineUrl())) {
			return '';
		}
		return null;
	}
	public String getJndiName() {
		return this.jndiName;
	}
	/**
	 * Allows the DataSource to be managed by the container and obtained through JNDI. The
	 * {@code URL}, {@code driverClassName}, {@code username} and {@code password} fields
	 * will be ignored when using JNDI lookups.
	 * @param jndiName the JNDI name
	 */
	public void setJndiName(String jndiName) {
		this.jndiName = jndiName;
	}
	public EmbeddedDatabaseConnection getEmbeddedDatabaseConnection() {
		return this.embeddedDatabaseConnection;
	}
	public void setEmbeddedDatabaseConnection(EmbeddedDatabaseConnection embeddedDatabaseConnection) {
		this.embeddedDatabaseConnection = embeddedDatabaseConnection;
	}
	public ClassLoader getClassLoader() {
		return this.classLoader;
	}
	public Xa getXa() {
		return this.xa;
	}
	public void setXa(Xa xa) {
		this.xa = xa;
	}
	/**
	 * XA Specific datasource settings.
	 */
	public static class Xa {
		/**
		 * XA datasource fully qualified name.
		 */
		private String dataSourceClassName;
		/**
		 * Properties to pass to the XA data source.
		 */
		private Map<String, String> properties = new LinkedHashMap<>();
		public String getDataSourceClassName() {
			return this.dataSourceClassName;
		}
		public void setDataSourceClassName(String dataSourceClassName) {
			this.dataSourceClassName = dataSourceClassName;
		}
		public Map<String, String> getProperties() {
			return this.properties;
		}
		public void setProperties(Map<String, String> properties) {
			this.properties = properties;
		}
	}
	static class DataSourceBeanCreationException extends BeanCreationException {
		private final DataSourceProperties properties;
		private final EmbeddedDatabaseConnection connection;
		DataSourceBeanCreationException(String message, DataSourceProperties properties,
				EmbeddedDatabaseConnection connection) {
			super(message);
			this.properties = properties;
			this.connection = connection;
		}
		DataSourceProperties getProperties() {
			return this.properties;
		}
		EmbeddedDatabaseConnection getConnection() {
			return this.connection;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(DataSourceProperties.class)
public class EmbeddedDataSourceConfiguration implements BeanClassLoaderAware {
	private ClassLoader classLoader;
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	@Bean(destroyMethod = 'shutdown')
	public EmbeddedDatabase dataSource(DataSourceProperties properties) {
		return new EmbeddedDatabaseBuilder().setType(EmbeddedDatabaseConnection.get(this.classLoader).getType())
			.setName(properties.determineDatabaseName())
			.build();
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnProperty(prefix = 'spring.jmx', name = 'enabled', havingValue = 'true', matchIfMissing = true)
class DataSourceJmxConfiguration {
	private static final Log logger = LogFactory.getLog(DataSourceJmxConfiguration.class);
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HikariDataSource.class)
	@ConditionalOnSingleCandidate(DataSource.class)
	static class Hikari {
		private final DataSource dataSource;
		private final ObjectProvider<MBeanExporter> mBeanExporter;
		Hikari(DataSource dataSource, ObjectProvider<MBeanExporter> mBeanExporter) {
			this.dataSource = dataSource;
			this.mBeanExporter = mBeanExporter;
			validateMBeans();
		}
		private void validateMBeans() {
			HikariDataSource hikariDataSource = DataSourceUnwrapper.unwrap(this.dataSource, HikariConfigMXBean.class,
					HikariDataSource.class);
			if (hikariDataSource != null && hikariDataSource.isRegisterMbeans()) {
				this.mBeanExporter.ifUnique((exporter) -> exporter.addExcludedBean('dataSource'));
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.datasource.tomcat', name = 'jmx-enabled')
	@ConditionalOnClass(DataSourceProxy.class)
	@ConditionalOnSingleCandidate(DataSource.class)
	static class TomcatDataSourceJmxConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'dataSourceMBean')
		Object dataSourceMBean(DataSource dataSource) {
			DataSourceProxy dataSourceProxy = DataSourceUnwrapper.unwrap(dataSource, PoolConfiguration.class,
					DataSourceProxy.class);
			if (dataSourceProxy != null) {
				try {
					return dataSourceProxy.createPool().getJmxPool();
				}
				catch (SQLException ex) {
					logger.warn('Cannot expose DataSource to JMX (could not connect)');
				}
			}
			return null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class DataSourceBeanCreationFailureAnalyzer extends AbstractFailureAnalyzer<DataSourceBeanCreationException> {
	private final Environment environment;
	DataSourceBeanCreationFailureAnalyzer(Environment environment) {
		this.environment = environment;
	}
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, DataSourceBeanCreationException cause) {
		return getFailureAnalysis(cause);
	}
	private FailureAnalysis getFailureAnalysis(DataSourceBeanCreationException cause) {
		String description = getDescription(cause);
		String action = getAction(cause);
		return new FailureAnalysis(description, action, cause);
	}
	private String getDescription(DataSourceBeanCreationException cause) {
		StringBuilder description = new StringBuilder();
		description.append('Failed to configure a DataSource: ');
		if (!StringUtils.hasText(cause.getProperties().getUrl())) {
			description.append('"url" attribute is not specified and ');
		}
		description.append(String.format('no embedded datasource could be configured.%n'));
		description.append(String.format('%nReason: %s%n', cause.getMessage()));
		return description.toString();
	}
	private String getAction(DataSourceBeanCreationException cause) {
		StringBuilder action = new StringBuilder();
		action.append(String.format('Consider the following:%n'));
		if (EmbeddedDatabaseConnection.NONE == cause.getConnection()) {
			action.append(String
				.format('\tIf you want an embedded database (H2, HSQL or Derby), please put it on the classpath.%n'));
		}
		else {
			action.append(String.format('\tReview the configuration of %s%n.', cause.getConnection()));
		}
		action
			.append('\tIf you have database settings to be loaded from a particular '
					+ 'profile you may need to activate it')
			.append(getActiveProfiles());
		return action.toString();
	}
	private String getActiveProfiles() {
		StringBuilder message = new StringBuilder();
		String[] profiles = this.environment.getActiveProfiles();
		if (ObjectUtils.isEmpty(profiles)) {
			message.append(' (no profiles are currently active).');
		}
		else {
			message.append(' (the profiles ');
			message.append(StringUtils.arrayToCommaDelimitedString(profiles));
			message.append(' are currently active).');
		}
		return message.toString();
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
public interface JdbcConnectionDetails extends ConnectionDetails {
	/**
	 * Username for the database.
	 * @return the username for the database
	 */
	String getUsername();
	/**
	 * Password for the database.
	 * @return the password for the database
	 */
	String getPassword();
	/**
	 * JDBC url for the database.
	 * @return the JDBC url for the database
	 */
	String getJdbcUrl();
	/**
	 * The name of the JDBC driver class. Defaults to the class name of the driver
	 * specified in the JDBC URL.
	 * @return the JDBC driver class name
	 * @see #getJdbcUrl()
	 * @see DatabaseDriver#fromJdbcUrl(String)
	 * @see DatabaseDriver#getDriverClassName()
	 */
	default String getDriverClassName() {
		return DatabaseDriver.fromJdbcUrl(getJdbcUrl()).getDriverClassName();
	}
	/**
	 * Returns the name of the XA DataSource class. Defaults to the class name from the
	 * driver specified in the JDBC URL.
	 * @return the XA DataSource class name
	 * @see #getJdbcUrl()
	 * @see DatabaseDriver#fromJdbcUrl(String)
	 * @see DatabaseDriver#getXaDataSourceClassName()
	 */
	default String getXaDataSourceClassName() {
		return DatabaseDriver.fromJdbcUrl(getJdbcUrl()).getXaDataSourceClassName();
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@ConfigurationProperties(prefix = 'spring.jdbc')
public class JdbcProperties {
	private final Template template = new Template();
	public Template getTemplate() {
		return this.template;
	}
	/**
	 * {@code JdbcTemplate} settings.
	 */
	public static class Template {
		/**
		 * Number of rows that should be fetched from the database when more rows are
		 * needed. Use -1 to use the JDBC driver"s default configuration.
		 */
		private int fetchSize = -1;
		/**
		 * Maximum number of rows. Use -1 to use the JDBC driver"s default configuration.
		 */
		private int maxRows = -1;
		/**
		 * Query timeout. Default is to use the JDBC driver"s default configuration. If a
		 * duration suffix is not specified, seconds will be used.
		 */
		@DurationUnit(ChronoUnit.SECONDS)
		private Duration queryTimeout;
		public int getFetchSize() {
			return this.fetchSize;
		}
		public void setFetchSize(int fetchSize) {
			this.fetchSize = fetchSize;
		}
		public int getMaxRows() {
			return this.maxRows;
		}
		public void setMaxRows(int maxRows) {
			this.maxRows = maxRows;
		}
		public Duration getQueryTimeout() {
			return this.queryTimeout;
		}
		public void setQueryTimeout(Duration queryTimeout) {
			this.queryTimeout = queryTimeout;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class TomcatJdbcConnectionDetailsBeanPostProcessor extends JdbcConnectionDetailsBeanPostProcessor<DataSource> {
	TomcatJdbcConnectionDetailsBeanPostProcessor(ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
		super(DataSource.class, connectionDetailsProvider);
	}
	@Override
	protected Object processDataSource(DataSource dataSource, JdbcConnectionDetails connectionDetails) {
		dataSource.setUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClassName(connectionDetails.getDriverClassName());
		return dataSource;
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnSingleCandidate(JdbcTemplate.class)
@ConditionalOnMissingBean(NamedParameterJdbcOperations.class)
class NamedParameterJdbcTemplateConfiguration {
	@Bean
	@Primary
	NamedParameterJdbcTemplate namedParameterJdbcTemplate(JdbcTemplate jdbcTemplate) {
		return new NamedParameterJdbcTemplate(jdbcTemplate);
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@AutoConfiguration(after = JdbcTemplateAutoConfiguration.class)
@ConditionalOnSingleCandidate(NamedParameterJdbcTemplate.class)
@ConditionalOnMissingBean(JdbcClient.class)
@Import(DatabaseInitializationDependencyConfigurer.class)
public class JdbcClientAutoConfiguration {
	@Bean
	JdbcClient jdbcClient(NamedParameterJdbcTemplate jdbcTemplate) {
		return JdbcClient.create(jdbcTemplate);
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class HikariDriverConfigurationFailureAnalyzer extends AbstractFailureAnalyzer<CannotGetJdbcConnectionException> {
	private static final String EXPECTED_MESSAGE = 'cannot use driverClassName and dataSourceClassName together.';
	@Override
	protected FailureAnalysis analyze(Throwable rootFailure, CannotGetJdbcConnectionException cause) {
		Throwable subCause = cause.getCause();
		if (subCause == null || !EXPECTED_MESSAGE.equals(subCause.getMessage())) {
			return null;
		}
		return new FailureAnalysis(
				'Configuration of the Hikari connection pool failed: "dataSourceClassName" is not supported.',
				'Spring Boot auto-configures only a driver and can"t specify a custom '
						+ 'DataSource. Consider configuring the Hikari DataSource in your own configuration.',
				cause);
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@AutoConfiguration(after = DataSourceAutoConfiguration.class)
@ConditionalOnClass({ DataSource.class, JdbcTemplate.class })
@ConditionalOnSingleCandidate(DataSource.class)
@EnableConfigurationProperties(JdbcProperties.class)
@Import({ DatabaseInitializationDependencyConfigurer.class, JdbcTemplateConfiguration.class,
		NamedParameterJdbcTemplateConfiguration.class })
public class JdbcTemplateAutoConfiguration {
}
/*
/**
package org.springframework.boot.autoconfigure.jdbc;
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@AutoConfiguration(before = { XADataSourceAutoConfiguration.class, DataSourceAutoConfiguration.class })
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@ConditionalOnProperty(prefix = 'spring.datasource', name = 'jndi-name')
@EnableConfigurationProperties(DataSourceProperties.class)
public class JndiDataSourceAutoConfiguration {
	@Bean(destroyMethod = '')
	@ConditionalOnMissingBean
	public DataSource dataSource(DataSourceProperties properties, ApplicationContext context) {
		JndiDataSourceLookup dataSourceLookup = new JndiDataSourceLookup();
		DataSource dataSource = dataSourceLookup.getDataSource(properties.getJndiName());
		excludeMBeanIfNecessary(dataSource, 'dataSource', context);
		return dataSource;
	}
	private void excludeMBeanIfNecessary(Object candidate, String beanName, ApplicationContext context) {
		for (MBeanExporter mbeanExporter : context.getBeansOfType(MBeanExporter.class).values()) {
			if (JmxUtils.isMBean(candidate.getClass())) {
				mbeanExporter.addExcludedBean(beanName);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
abstract class JdbcConnectionDetailsBeanPostProcessor<T> implements BeanPostProcessor, PriorityOrdered {
	private final Class<T> dataSourceClass;
	private final ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider;
	JdbcConnectionDetailsBeanPostProcessor(Class<T> dataSourceClass,
			ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
		this.dataSourceClass = dataSourceClass;
		this.connectionDetailsProvider = connectionDetailsProvider;
	}
	@Override
	@SuppressWarnings('unchecked')
	public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
		if (this.dataSourceClass.isAssignableFrom(bean.getClass()) && 'dataSource'.equals(beanName)) {
			JdbcConnectionDetails connectionDetails = this.connectionDetailsProvider.getObject();
			if (!(connectionDetails instanceof PropertiesJdbcConnectionDetails)) {
				return processDataSource((T) bean, connectionDetails);
			}
		}
		return bean;
	}
	protected abstract Object processDataSource(T dataSource, JdbcConnectionDetails connectionDetails);
	@Override
	public int getOrder() {
		// Runs after ConfigurationPropertiesBindingPostProcessor
		return Ordered.HIGHEST_PRECEDENCE + 2;
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc.metadata;
/**
@Configuration(proxyBeanMethods = false)
public class DataSourcePoolMetadataProvidersConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)
	static class TomcatDataSourcePoolMetadataProviderConfiguration {
		@Bean
		DataSourcePoolMetadataProvider tomcatPoolDataSourceMetadataProvider() {
			return (dataSource) -> {
				org.apache.tomcat.jdbc.pool.DataSource tomcatDataSource = DataSourceUnwrapper.unwrap(dataSource,
						ConnectionPoolMBean.class, org.apache.tomcat.jdbc.pool.DataSource.class);
				if (tomcatDataSource != null) {
					return new TomcatDataSourcePoolMetadata(tomcatDataSource);
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HikariDataSource.class)
	static class HikariPoolDataSourceMetadataProviderConfiguration {
		@Bean
		DataSourcePoolMetadataProvider hikariPoolDataSourceMetadataProvider() {
			return (dataSource) -> {
				HikariDataSource hikariDataSource = DataSourceUnwrapper.unwrap(dataSource, HikariConfigMXBean.class,
						HikariDataSource.class);
				if (hikariDataSource != null) {
					return new HikariDataSourcePoolMetadata(hikariDataSource);
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(BasicDataSource.class)
	static class CommonsDbcp2PoolDataSourceMetadataProviderConfiguration {
		@Bean
		DataSourcePoolMetadataProvider commonsDbcp2PoolDataSourceMetadataProvider() {
			return (dataSource) -> {
				BasicDataSource dbcpDataSource = DataSourceUnwrapper.unwrap(dataSource, BasicDataSourceMXBean.class,
						BasicDataSource.class);
				if (dbcpDataSource != null) {
					return new CommonsDbcp2DataSourcePoolMetadata(dbcpDataSource);
				}
				return null;
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ PoolDataSource.class, OracleConnection.class })
	static class OracleUcpPoolDataSourceMetadataProviderConfiguration {
		@Bean
		DataSourcePoolMetadataProvider oracleUcpPoolDataSourceMetadataProvider() {
			return (dataSource) -> {
				PoolDataSource ucpDataSource = DataSourceUnwrapper.unwrap(dataSource, PoolDataSource.class);
				if (ucpDataSource != null) {
					return new OracleUcpDataSourcePoolMetadata(ucpDataSource);
				}
				return null;
			};
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jdbc.metadata;
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@AutoConfiguration(before = DataSourceAutoConfiguration.class)
@EnableConfigurationProperties(DataSourceProperties.class)
@ConditionalOnClass({ DataSource.class, TransactionManager.class, EmbeddedDatabaseType.class })
@ConditionalOnBean(XADataSourceWrapper.class)
@ConditionalOnMissingBean(DataSource.class)
public class XADataSourceAutoConfiguration implements BeanClassLoaderAware {
	private ClassLoader classLoader;
	@Bean
	@ConditionalOnMissingBean(JdbcConnectionDetails.class)
	PropertiesJdbcConnectionDetails jdbcConnectionDetails(DataSourceProperties properties) {
		return new PropertiesJdbcConnectionDetails(properties);
	}
	@Bean
	public DataSource dataSource(XADataSourceWrapper wrapper, DataSourceProperties properties,
			JdbcConnectionDetails connectionDetails, ObjectProvider<XADataSource> xaDataSource) throws Exception {
		return wrapper
			.wrapDataSource(xaDataSource.getIfAvailable(() -> createXaDataSource(properties, connectionDetails)));
	}
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.classLoader = classLoader;
	}
	private XADataSource createXaDataSource(DataSourceProperties properties, JdbcConnectionDetails connectionDetails) {
		String className = connectionDetails.getXaDataSourceClassName();
		Assert.state(StringUtils.hasLength(className), 'No XA DataSource class name specified');
		XADataSource dataSource = createXaDataSourceInstance(className);
		bindXaProperties(dataSource, properties, connectionDetails);
		return dataSource;
	}
	private XADataSource createXaDataSourceInstance(String className) {
		try {
			Class<?> dataSourceClass = ClassUtils.forName(className, this.classLoader);
			Object instance = BeanUtils.instantiateClass(dataSourceClass);
			Assert.isInstanceOf(XADataSource.class, instance);
			return (XADataSource) instance;
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to create XADataSource instance from "' + className + '"');
		}
	}
	private void bindXaProperties(XADataSource target, DataSourceProperties dataSourceProperties,
			JdbcConnectionDetails connectionDetails) {
		Binder binder = new Binder(getBinderSource(dataSourceProperties, connectionDetails));
		binder.bind(ConfigurationPropertyName.EMPTY, Bindable.ofInstance(target));
	}
	private ConfigurationPropertySource getBinderSource(DataSourceProperties dataSourceProperties,
			JdbcConnectionDetails connectionDetails) {
		Map<Object, Object> properties = new HashMap<>(dataSourceProperties.getXa().getProperties());
		properties.computeIfAbsent('user', (key) -> connectionDetails.getUsername());
		properties.computeIfAbsent('password', (key) -> connectionDetails.getPassword());
		try {
			properties.computeIfAbsent('url', (key) -> connectionDetails.getJdbcUrl());
		}
		catch (DataSourceBeanCreationException ex) {
			// Continue as not all XA DataSource"s require a URL
		}
		MapConfigurationPropertySource source = new MapConfigurationPropertySource(properties);
		ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();
		aliases.addAliases('user', 'username');
		return source.withAliases(aliases);
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
class Dbcp2JdbcConnectionDetailsBeanPostProcessor extends JdbcConnectionDetailsBeanPostProcessor<BasicDataSource> {
	Dbcp2JdbcConnectionDetailsBeanPostProcessor(ObjectProvider<JdbcConnectionDetails> connectionDetailsProvider) {
		super(BasicDataSource.class, connectionDetailsProvider);
	}
	@Override
	protected Object processDataSource(BasicDataSource dataSource, JdbcConnectionDetails connectionDetails) {
		dataSource.setUrl(connectionDetails.getJdbcUrl());
		dataSource.setUsername(connectionDetails.getUsername());
		dataSource.setPassword(connectionDetails.getPassword());
		dataSource.setDriverClassName(connectionDetails.getDriverClassName());
		return dataSource;
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@AutoConfiguration(before = SqlInitializationAutoConfiguration.class)
@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })
@ConditionalOnMissingBean(type = 'io.r2dbc.spi.ConnectionFactory')
@EnableConfigurationProperties(DataSourceProperties.class)
@Import({ DataSourcePoolMetadataProvidersConfiguration.class, DataSourceCheckpointRestoreConfiguration.class })
public class DataSourceAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@Conditional(EmbeddedDatabaseCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import(EmbeddedDataSourceConfiguration.class)
	protected static class EmbeddedDatabaseConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(PooledDataSourceCondition.class)
	@ConditionalOnMissingBean({ DataSource.class, XADataSource.class })
	@Import({ DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,
			DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.OracleUcp.class,
			DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class })
	protected static class PooledDataSourceConfiguration {
		@Bean
		@ConditionalOnMissingBean(JdbcConnectionDetails.class)
		PropertiesJdbcConnectionDetails jdbcConnectionDetails(DataSourceProperties properties) {
			return new PropertiesJdbcConnectionDetails(properties);
		}
	}
	/**
	 * {@link AnyNestedCondition} that checks that either {@code spring.datasource.type}
	 * is set or {@link PooledDataSourceAvailableCondition} applies.
	 */
	static class PooledDataSourceCondition extends AnyNestedCondition {
		PooledDataSourceCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty(prefix = 'spring.datasource', name = 'type')
		static class ExplicitType {
		}
		@Conditional(PooledDataSourceAvailableCondition.class)
		static class PooledDataSourceAvailable {
		}
	}
	/**
	 * {@link Condition} to test if a supported connection pool is available.
	 */
	static class PooledDataSourceAvailableCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('PooledDataSource');
			if (DataSourceBuilder.findType(context.getClassLoader()) != null) {
				return ConditionOutcome.match(message.foundExactly('supported DataSource'));
			}
			return ConditionOutcome.noMatch(message.didNotFind('supported DataSource').atAll());
		}
	}
	/**
	 * {@link Condition} to detect when an embedded {@link DataSource} type can be used.
	 * If a pooled {@link DataSource} is available, it will always be preferred to an
	 * {@code EmbeddedDatabase}.
	 */
	static class EmbeddedDatabaseCondition extends SpringBootCondition {
		private static final String DATASOURCE_URL_PROPERTY = 'spring.datasource.url';
		private final SpringBootCondition pooledCondition = new PooledDataSourceCondition();
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('EmbeddedDataSource');
			if (hasDataSourceUrlProperty(context)) {
				return ConditionOutcome.noMatch(message.because(DATASOURCE_URL_PROPERTY + ' is set'));
			}
			if (anyMatches(context, metadata, this.pooledCondition)) {
				return ConditionOutcome.noMatch(message.foundExactly('supported pooled data source'));
			}
			EmbeddedDatabaseType type = EmbeddedDatabaseConnection.get(context.getClassLoader()).getType();
			if (type == null) {
				return ConditionOutcome.noMatch(message.didNotFind('embedded database').atAll());
			}
			return ConditionOutcome.match(message.found('embedded database').items(type));
		}
		private boolean hasDataSourceUrlProperty(ConditionContext context) {
			Environment environment = context.getEnvironment();
			if (environment.containsProperty(DATASOURCE_URL_PROPERTY)) {
				try {
					return StringUtils.hasText(environment.getProperty(DATASOURCE_URL_PROPERTY));
				}
				catch (IllegalArgumentException ex) {
					// NOTE: This should be PlaceholderResolutionException
					// Ignore unresolvable placeholder errors
				}
			}
			return false;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jdbc;
/**
@AutoConfiguration(before = TransactionAutoConfiguration.class,
		after = TransactionManagerCustomizationAutoConfiguration.class)
@ConditionalOnClass({ DataSource.class, JdbcTemplate.class, TransactionManager.class })
@AutoConfigureOrder(Ordered.LOWEST_PRECEDENCE)
@EnableConfigurationProperties(DataSourceProperties.class)
public class DataSourceTransactionManagerAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(DataSource.class)
	static class JdbcTransactionManagerConfiguration {
		@Bean
		@ConditionalOnMissingBean(TransactionManager.class)
		DataSourceTransactionManager transactionManager(Environment environment, DataSource dataSource,
				ObjectProvider<TransactionManagerCustomizers> transactionManagerCustomizers) {
			DataSourceTransactionManager transactionManager = createTransactionManager(environment, dataSource);
			transactionManagerCustomizers.ifAvailable((customizers) -> customizers.customize(transactionManager));
			return transactionManager;
		}
		private DataSourceTransactionManager createTransactionManager(Environment environment, DataSource dataSource) {
			return environment.getProperty('spring.dao.exceptiontranslation.enabled', Boolean.class, Boolean.TRUE)
					? new JdbcTransactionManager(dataSource) : new DataSourceTransactionManager(dataSource);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
@AutoConfiguration(before = JmsAutoConfiguration.class)
@ConditionalOnClass(JmsTemplate.class)
@ConditionalOnMissingBean(ConnectionFactory.class)
@Conditional(JndiOrPropertyCondition.class)
@EnableConfigurationProperties(JmsProperties.class)
public class JndiConnectionFactoryAutoConfiguration {
	// Keep these in sync with the condition below
	private static final String[] JNDI_LOCATIONS = { 'java:/JmsXA', 'java:/XAConnectionFactory' };
	@Bean
	public ConnectionFactory jmsConnectionFactory(JmsProperties properties) throws NamingException {
		JndiLocatorDelegate jndiLocatorDelegate = JndiLocatorDelegate.createDefaultResourceRefLocator();
		if (StringUtils.hasLength(properties.getJndiName())) {
			return jndiLocatorDelegate.lookup(properties.getJndiName(), ConnectionFactory.class);
		}
		return findJndiConnectionFactory(jndiLocatorDelegate);
	}
	private ConnectionFactory findJndiConnectionFactory(JndiLocatorDelegate jndiLocatorDelegate) {
		for (String name : JNDI_LOCATIONS) {
			try {
				return jndiLocatorDelegate.lookup(name, ConnectionFactory.class);
			}
			catch (NamingException ex) {
				// Swallow and continue
			}
		}
		throw new IllegalStateException(
				'Unable to find ConnectionFactory in JNDI locations ' + Arrays.asList(JNDI_LOCATIONS));
	}
	/**
	 * Condition for JNDI name or a specific property.
	 */
	static class JndiOrPropertyCondition extends AnyNestedCondition {
		JndiOrPropertyCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnJndi({ 'java:/JmsXA', 'java:/XAConnectionFactory' })
		static class Jndi {
		}
		@ConditionalOnProperty(prefix = 'spring.jms', name = 'jndi-name')
		static class Property {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
@ConfigurationProperties(prefix = 'spring.jms')
public class JmsProperties {
	/**
	 * Whether the default destination type is topic.
	 */
	private boolean pubSubDomain = false;
	/**
	 * Connection factory JNDI name. When set, takes precedence to others connection
	 * factory auto-configurations.
	 */
	private String jndiName;
	/**
	 * Whether the subscription is durable.
	 */
	private boolean subscriptionDurable = false;
	/**
	 * Client id of the connection.
	 */
	private String clientId;
	private final Cache cache = new Cache();
	private final Listener listener = new Listener();
	private final Template template = new Template();
	public boolean isPubSubDomain() {
		return this.pubSubDomain;
	}
	public void setPubSubDomain(boolean pubSubDomain) {
		this.pubSubDomain = pubSubDomain;
	}
	public boolean isSubscriptionDurable() {
		return this.subscriptionDurable;
	}
	public void setSubscriptionDurable(boolean subscriptionDurable) {
		this.subscriptionDurable = subscriptionDurable;
	}
	public String getClientId() {
		return this.clientId;
	}
	public void setClientId(String clientId) {
		this.clientId = clientId;
	}
	public String getJndiName() {
		return this.jndiName;
	}
	public void setJndiName(String jndiName) {
		this.jndiName = jndiName;
	}
	public Cache getCache() {
		return this.cache;
	}
	public Listener getListener() {
		return this.listener;
	}
	public Template getTemplate() {
		return this.template;
	}
	public static class Cache {
		/**
		 * Whether to cache sessions.
		 */
		private boolean enabled = true;
		/**
		 * Whether to cache message consumers.
		 */
		private boolean consumers = false;
		/**
		 * Whether to cache message producers.
		 */
		private boolean producers = true;
		/**
		 * Size of the session cache (per JMS Session type).
		 */
		private int sessionCacheSize = 1;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public boolean isConsumers() {
			return this.consumers;
		}
		public void setConsumers(boolean consumers) {
			this.consumers = consumers;
		}
		public boolean isProducers() {
			return this.producers;
		}
		public void setProducers(boolean producers) {
			this.producers = producers;
		}
		public int getSessionCacheSize() {
			return this.sessionCacheSize;
		}
		public void setSessionCacheSize(int sessionCacheSize) {
			this.sessionCacheSize = sessionCacheSize;
		}
	}
	public static class Listener {
		/**
		 * Start the container automatically on startup.
		 */
		private boolean autoStartup = true;
		/**
		 * Minimum number of concurrent consumers. When max-concurrency is not specified
		 * the minimum will also be used as the maximum.
		 */
		private Integer minConcurrency;
		/**
		 * Maximum number of concurrent consumers.
		 */
		private Integer maxConcurrency;
		/**
		 * Timeout to use for receive calls. Use -1 for a no-wait receive or 0 for no
		 * timeout at all. The latter is only feasible if not running within a transaction
		 * manager and is generally discouraged since it prevents clean shutdown.
		 */
		private Duration receiveTimeout = Duration.ofSeconds(1);
		/**
		 * Specify the maximum number of messages to process in one task. By default,
		 * unlimited unless a SchedulingTaskExecutor is configured on the listener (10
		 * messages), as it indicates a preference for short-lived tasks.
		 */
		private Integer maxMessagesPerTask;
		private final Session session = new Session();
		public boolean isAutoStartup() {
			return this.autoStartup;
		}
		public void setAutoStartup(boolean autoStartup) {
			this.autoStartup = autoStartup;
		}
		@Deprecated(since = '3.2.0', forRemoval = true)
		@DeprecatedConfigurationProperty(replacement = 'spring.jms.listener.session.acknowledge-mode', since = '3.2.0')
		public AcknowledgeMode getAcknowledgeMode() {
			return this.session.getAcknowledgeMode();
		}
		@Deprecated(since = '3.2.0', forRemoval = true)
		public void setAcknowledgeMode(AcknowledgeMode acknowledgeMode) {
			this.session.setAcknowledgeMode(acknowledgeMode);
		}
		@DeprecatedConfigurationProperty(replacement = 'spring.jms.listener.min-concurrency', since = '3.2.0')
		@Deprecated(since = '3.2.0', forRemoval = true)
		public Integer getConcurrency() {
			return this.minConcurrency;
		}
		@Deprecated(since = '3.2.0', forRemoval = true)
		public void setConcurrency(Integer concurrency) {
			this.minConcurrency = concurrency;
		}
		public Integer getMinConcurrency() {
			return this.minConcurrency;
		}
		public void setMinConcurrency(Integer minConcurrency) {
			this.minConcurrency = minConcurrency;
		}
		public Integer getMaxConcurrency() {
			return this.maxConcurrency;
		}
		public void setMaxConcurrency(Integer maxConcurrency) {
			this.maxConcurrency = maxConcurrency;
		}
		public String formatConcurrency() {
			if (this.minConcurrency == null) {
				return (this.maxConcurrency != null) ? '1-' + this.maxConcurrency : null;
			}
			return this.minConcurrency + '-'
					+ ((this.maxConcurrency != null) ? this.maxConcurrency : this.minConcurrency);
		}
		public Duration getReceiveTimeout() {
			return this.receiveTimeout;
		}
		public void setReceiveTimeout(Duration receiveTimeout) {
			this.receiveTimeout = receiveTimeout;
		}
		public Integer getMaxMessagesPerTask() {
			return this.maxMessagesPerTask;
		}
		public void setMaxMessagesPerTask(Integer maxMessagesPerTask) {
			this.maxMessagesPerTask = maxMessagesPerTask;
		}
		public Session getSession() {
			return this.session;
		}
		public static class Session {
			/**
			 * Acknowledge mode of the listener container.
			 */
			private AcknowledgeMode acknowledgeMode = AcknowledgeMode.AUTO;
			/**
			 * Whether the listener container should use transacted JMS sessions. Defaults
			 * to false in the presence of a JtaTransactionManager and true otherwise.
			 */
			private Boolean transacted;
			public AcknowledgeMode getAcknowledgeMode() {
				return this.acknowledgeMode;
			}
			public void setAcknowledgeMode(AcknowledgeMode acknowledgeMode) {
				this.acknowledgeMode = acknowledgeMode;
			}
			public Boolean getTransacted() {
				return this.transacted;
			}
			public void setTransacted(Boolean transacted) {
				this.transacted = transacted;
			}
		}
	}
	public static class Template {
		/**
		 * Default destination to use on send and receive operations that do not have a
		 * destination parameter.
		 */
		private String defaultDestination;
		/**
		 * Delivery delay to use for send calls.
		 */
		private Duration deliveryDelay;
		/**
		 * Delivery mode. Enables QoS (Quality of Service) when set.
		 */
		private DeliveryMode deliveryMode;
		/**
		 * Priority of a message when sending. Enables QoS (Quality of Service) when set.
		 */
		private Integer priority;
		/**
		 * Time-to-live of a message when sending. Enables QoS (Quality of Service) when
		 * set.
		 */
		private Duration timeToLive;
		/**
		 * Whether to enable explicit QoS (Quality of Service) when sending a message.
		 * When enabled, the delivery mode, priority and time-to-live properties will be
		 * used when sending a message. QoS is automatically enabled when at least one of
		 * those settings is customized.
		 */
		private Boolean qosEnabled;
		/**
		 * Timeout to use for receive calls.
		 */
		private Duration receiveTimeout;
		private final Session session = new Session();
		public String getDefaultDestination() {
			return this.defaultDestination;
		}
		public void setDefaultDestination(String defaultDestination) {
			this.defaultDestination = defaultDestination;
		}
		public Duration getDeliveryDelay() {
			return this.deliveryDelay;
		}
		public void setDeliveryDelay(Duration deliveryDelay) {
			this.deliveryDelay = deliveryDelay;
		}
		public DeliveryMode getDeliveryMode() {
			return this.deliveryMode;
		}
		public void setDeliveryMode(DeliveryMode deliveryMode) {
			this.deliveryMode = deliveryMode;
		}
		public Integer getPriority() {
			return this.priority;
		}
		public void setPriority(Integer priority) {
			this.priority = priority;
		}
		public Duration getTimeToLive() {
			return this.timeToLive;
		}
		public void setTimeToLive(Duration timeToLive) {
			this.timeToLive = timeToLive;
		}
		public boolean determineQosEnabled() {
			if (this.qosEnabled != null) {
				return this.qosEnabled;
			}
			return (getDeliveryMode() != null || getPriority() != null || getTimeToLive() != null);
		}
		public Boolean getQosEnabled() {
			return this.qosEnabled;
		}
		public void setQosEnabled(Boolean qosEnabled) {
			this.qosEnabled = qosEnabled;
		}
		public Duration getReceiveTimeout() {
			return this.receiveTimeout;
		}
		public void setReceiveTimeout(Duration receiveTimeout) {
			this.receiveTimeout = receiveTimeout;
		}
		public Session getSession() {
			return this.session;
		}
		public static class Session {
			/**
			 * Acknowledge mode used when creating sessions.
			 */
			private AcknowledgeMode acknowledgeMode = AcknowledgeMode.AUTO;
			/**
			 * Whether to use transacted sessions.
			 */
			private boolean transacted = false;
			public AcknowledgeMode getAcknowledgeMode() {
				return this.acknowledgeMode;
			}
			public void setAcknowledgeMode(AcknowledgeMode acknowledgeMode) {
				this.acknowledgeMode = acknowledgeMode;
			}
			public boolean isTransacted() {
				return this.transacted;
			}
			public void setTransacted(boolean transacted) {
				this.transacted = transacted;
			}
		}
	}
	public enum DeliveryMode {
		/**
		 * Does not require that the message be logged to stable storage. This is the
		 * lowest-overhead delivery mode but can lead to lost of message if the broker
		 * goes down.
		 */
		NON_PERSISTENT(1),
		/*
		 * Instructs the JMS provider to log the message to stable storage as part of the
		 * client"s send operation.
		 */
		PERSISTENT(2);
		private final int value;
		DeliveryMode(int value) {
			this.value = value;
		}
		public int getValue() {
			return this.value;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
public class JmsPoolConnectionFactoryFactory {
	private final JmsPoolConnectionFactoryProperties properties;
	public JmsPoolConnectionFactoryFactory(JmsPoolConnectionFactoryProperties properties) {
		this.properties = properties;
	}
	/**
	 * Create a{@link JmsPoolConnectionFactory} based on the specified
	 * {@link ConnectionFactory}.
	 * @param connectionFactory the connection factory to wrap
	 * @return a pooled connection factory
	 */
	public JmsPoolConnectionFactory createPooledConnectionFactory(ConnectionFactory connectionFactory) {
		JmsPoolConnectionFactory pooledConnectionFactory = new JmsPoolConnectionFactory();
		pooledConnectionFactory.setConnectionFactory(connectionFactory);
		pooledConnectionFactory.setBlockIfSessionPoolIsFull(this.properties.isBlockIfFull());
		if (this.properties.getBlockIfFullTimeout() != null) {
			pooledConnectionFactory
				.setBlockIfSessionPoolIsFullTimeout(this.properties.getBlockIfFullTimeout().toMillis());
		}
		if (this.properties.getIdleTimeout() != null) {
			pooledConnectionFactory.setConnectionIdleTimeout((int) this.properties.getIdleTimeout().toMillis());
		}
		pooledConnectionFactory.setMaxConnections(this.properties.getMaxConnections());
		pooledConnectionFactory.setMaxSessionsPerConnection(this.properties.getMaxSessionsPerConnection());
		if (this.properties.getTimeBetweenExpirationCheck() != null) {
			pooledConnectionFactory
				.setConnectionCheckInterval(this.properties.getTimeBetweenExpirationCheck().toMillis());
		}
		pooledConnectionFactory.setUseAnonymousProducers(this.properties.isUseAnonymousProducers());
		return pooledConnectionFactory;
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
public class JmsPoolConnectionFactoryProperties {
	/**
	 * Whether a JmsPoolConnectionFactory should be created, instead of a regular
	 * ConnectionFactory.
	 */
	private boolean enabled;
	/**
	 * Whether to block when a connection is requested and the pool is full. Set it to
	 * false to throw a 'JMSException' instead.
	 */
	private boolean blockIfFull = true;
	/**
	 * Blocking period before throwing an exception if the pool is still full.
	 */
	private Duration blockIfFullTimeout = Duration.ofMillis(-1);
	/**
	 * Connection idle timeout.
	 */
	private Duration idleTimeout = Duration.ofSeconds(30);
	/**
	 * Maximum number of pooled connections.
	 */
	private int maxConnections = 1;
	/**
	 * Maximum number of pooled sessions per connection in the pool.
	 */
	private int maxSessionsPerConnection = 500;
	/**
	 * Time to sleep between runs of the idle connection eviction thread. When negative,
	 * no idle connection eviction thread runs.
	 */
	private Duration timeBetweenExpirationCheck = Duration.ofMillis(-1);
	/**
	 * Whether to use only one anonymous 'MessageProducer' instance. Set it to false to
	 * create one 'MessageProducer' every time one is required.
	 */
	private boolean useAnonymousProducers = true;
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public boolean isBlockIfFull() {
		return this.blockIfFull;
	}
	public void setBlockIfFull(boolean blockIfFull) {
		this.blockIfFull = blockIfFull;
	}
	public Duration getBlockIfFullTimeout() {
		return this.blockIfFullTimeout;
	}
	public void setBlockIfFullTimeout(Duration blockIfFullTimeout) {
		this.blockIfFullTimeout = blockIfFullTimeout;
	}
	public Duration getIdleTimeout() {
		return this.idleTimeout;
	}
	public void setIdleTimeout(Duration idleTimeout) {
		this.idleTimeout = idleTimeout;
	}
	public int getMaxConnections() {
		return this.maxConnections;
	}
	public void setMaxConnections(int maxConnections) {
		this.maxConnections = maxConnections;
	}
	public int getMaxSessionsPerConnection() {
		return this.maxSessionsPerConnection;
	}
	public void setMaxSessionsPerConnection(int maxSessionsPerConnection) {
		this.maxSessionsPerConnection = maxSessionsPerConnection;
	}
	public Duration getTimeBetweenExpirationCheck() {
		return this.timeBetweenExpirationCheck;
	}
	public void setTimeBetweenExpirationCheck(Duration timeBetweenExpirationCheck) {
		this.timeBetweenExpirationCheck = timeBetweenExpirationCheck;
	}
	public boolean isUseAnonymousProducers() {
		return this.useAnonymousProducers;
	}
	public void setUseAnonymousProducers(boolean useAnonymousProducers) {
		this.useAnonymousProducers = useAnonymousProducers;
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
@AutoConfiguration
@ConditionalOnClass({ Message.class, JmsTemplate.class })
@ConditionalOnBean(ConnectionFactory.class)
@EnableConfigurationProperties(JmsProperties.class)
@Import(JmsAnnotationDrivenConfiguration.class)
@ImportRuntimeHints(JmsRuntimeHints.class)
public class JmsAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	protected static class JmsTemplateConfiguration {
		private final JmsProperties properties;
		private final ObjectProvider<DestinationResolver> destinationResolver;
		private final ObjectProvider<MessageConverter> messageConverter;
		private final ObjectProvider<ObservationRegistry> observationRegistry;
		public JmsTemplateConfiguration(JmsProperties properties,
				ObjectProvider<DestinationResolver> destinationResolver,
				ObjectProvider<MessageConverter> messageConverter,
				ObjectProvider<ObservationRegistry> observationRegistry) {
			this.properties = properties;
			this.destinationResolver = destinationResolver;
			this.messageConverter = messageConverter;
			this.observationRegistry = observationRegistry;
		}
		@Bean
		@ConditionalOnMissingBean(JmsOperations.class)
		@ConditionalOnSingleCandidate(ConnectionFactory.class)
		public JmsTemplate jmsTemplate(ConnectionFactory connectionFactory) {
			PropertyMapper map = PropertyMapper.get();
			JmsTemplate template = new JmsTemplate(connectionFactory);
			template.setPubSubDomain(this.properties.isPubSubDomain());
			map.from(this.destinationResolver::getIfUnique).whenNonNull().to(template::setDestinationResolver);
			map.from(this.messageConverter::getIfUnique).whenNonNull().to(template::setMessageConverter);
			map.from(this.observationRegistry::getIfUnique).whenNonNull().to(template::setObservationRegistry);
			mapTemplateProperties(this.properties.getTemplate(), template);
			return template;
		}
		private void mapTemplateProperties(Template properties, JmsTemplate template) {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(properties.getSession().getAcknowledgeMode()::getMode).to(template::setSessionAcknowledgeMode);
			map.from(properties.getSession()::isTransacted).to(template::setSessionTransacted);
			map.from(properties::getDefaultDestination).whenNonNull().to(template::setDefaultDestinationName);
			map.from(properties::getDeliveryDelay).whenNonNull().as(Duration::toMillis).to(template::setDeliveryDelay);
			map.from(properties::determineQosEnabled).to(template::setExplicitQosEnabled);
			map.from(properties::getDeliveryMode).as(DeliveryMode::getValue).to(template::setDeliveryMode);
			map.from(properties::getPriority).whenNonNull().to(template::setPriority);
			map.from(properties::getTimeToLive).whenNonNull().as(Duration::toMillis).to(template::setTimeToLive);
			map.from(properties::getReceiveTimeout).as(Duration::toMillis).to(template::setReceiveTimeout);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(JmsMessagingTemplate.class)
	@Import(JmsTemplateConfiguration.class)
	protected static class MessagingTemplateConfiguration {
		@Bean
		@ConditionalOnMissingBean(JmsMessageOperations.class)
		@ConditionalOnSingleCandidate(JmsTemplate.class)
		public JmsMessagingTemplate jmsMessagingTemplate(JmsProperties properties, JmsTemplate jmsTemplate) {
			JmsMessagingTemplate messagingTemplate = new JmsMessagingTemplate(jmsTemplate);
			mapTemplateProperties(properties.getTemplate(), messagingTemplate);
			return messagingTemplate;
		}
		private void mapTemplateProperties(Template properties, JmsMessagingTemplate messagingTemplate) {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(properties::getDefaultDestination).to(messagingTemplate::setDefaultDestinationName);
		}
	}
	static class JmsRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.reflection()
				.registerType(TypeReference.of(AcknowledgeMode.class), (type) -> type.withMethod('of',
						List.of(TypeReference.of(String.class)), ExecutableMode.INVOKE));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
@FunctionalInterface
public interface ArtemisConfigurationCustomizer {
	/**
	 * Customize the configuration.
	 * @param configuration the configuration to customize
	 */
	void customize(Configuration configuration);
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
public class ArtemisNoOpBindingRegistry implements BindingRegistry {
	@Override
	public Object lookup(String s) {
		return null;
	}
	@Override
	public boolean bind(String s, Object o) {
		return false;
	}
	@Override
	public void unbind(String s) {
	}
	@Override
	public void close() {
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(ConnectionFactory.class)
class ArtemisConnectionFactoryConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.artemis.pool', name = 'enabled', havingValue = 'false',
			matchIfMissing = true)
	static class SimpleConnectionFactoryConfiguration {
		@Bean(name = 'jmsConnectionFactory')
		@ConditionalOnProperty(prefix = 'spring.jms.cache', name = 'enabled', havingValue = 'false')
		ActiveMQConnectionFactory jmsConnectionFactory(ArtemisProperties properties, ListableBeanFactory beanFactory,
				ArtemisConnectionDetails connectionDetails) {
			return createJmsConnectionFactory(properties, connectionDetails, beanFactory);
		}
		private static ActiveMQConnectionFactory createJmsConnectionFactory(ArtemisProperties properties,
				ArtemisConnectionDetails connectionDetails, ListableBeanFactory beanFactory) {
			return new ArtemisConnectionFactoryFactory(beanFactory, properties, connectionDetails)
				.createConnectionFactory(ActiveMQConnectionFactory::new, ActiveMQConnectionFactory::new);
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(CachingConnectionFactory.class)
		@ConditionalOnProperty(prefix = 'spring.jms.cache', name = 'enabled', havingValue = 'true',
				matchIfMissing = true)
		static class CachingConnectionFactoryConfiguration {
			@Bean(name = 'jmsConnectionFactory')
			CachingConnectionFactory cachingJmsConnectionFactory(JmsProperties jmsProperties,
					ArtemisProperties properties, ArtemisConnectionDetails connectionDetails,
					ListableBeanFactory beanFactory) {
				JmsProperties.Cache cacheProperties = jmsProperties.getCache();
				CachingConnectionFactory connectionFactory = new CachingConnectionFactory(
						createJmsConnectionFactory(properties, connectionDetails, beanFactory));
				connectionFactory.setCacheConsumers(cacheProperties.isConsumers());
				connectionFactory.setCacheProducers(cacheProperties.isProducers());
				connectionFactory.setSessionCacheSize(cacheProperties.getSessionCacheSize());
				return connectionFactory;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ JmsPoolConnectionFactory.class, PooledObject.class })
	@ConditionalOnProperty(prefix = 'spring.artemis.pool', name = 'enabled', havingValue = 'true')
	static class PooledConnectionFactoryConfiguration {
		@Bean(destroyMethod = 'stop')
		JmsPoolConnectionFactory jmsConnectionFactory(ListableBeanFactory beanFactory, ArtemisProperties properties,
				ArtemisConnectionDetails connectionDetails) {
			ActiveMQConnectionFactory connectionFactory = new ArtemisConnectionFactoryFactory(beanFactory, properties,
					connectionDetails)
				.createConnectionFactory(ActiveMQConnectionFactory::new, ActiveMQConnectionFactory::new);
			return new JmsPoolConnectionFactoryFactory(properties.getPool())
				.createPooledConnectionFactory(connectionFactory);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
@ConfigurationProperties(prefix = 'spring.artemis')
public class ArtemisProperties {
	/**
	 * Artemis deployment mode, auto-detected by default.
	 */
	private ArtemisMode mode;
	/**
	 * Artemis broker url.
	 */
	private String brokerUrl;
	/**
	 * Login user of the broker.
	 */
	private String user;
	/**
	 * Login password of the broker.
	 */
	private String password;
	private final Embedded embedded = new Embedded();
	@NestedConfigurationProperty
	private final JmsPoolConnectionFactoryProperties pool = new JmsPoolConnectionFactoryProperties();
	public ArtemisMode getMode() {
		return this.mode;
	}
	public void setMode(ArtemisMode mode) {
		this.mode = mode;
	}
	public String getBrokerUrl() {
		return this.brokerUrl;
	}
	public void setBrokerUrl(String brokerUrl) {
		this.brokerUrl = brokerUrl;
	}
	public String getUser() {
		return this.user;
	}
	public void setUser(String user) {
		this.user = user;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Embedded getEmbedded() {
		return this.embedded;
	}
	public JmsPoolConnectionFactoryProperties getPool() {
		return this.pool;
	}
	/**
	 * Configuration for an embedded Artemis server.
	 */
	public static class Embedded {
		private static final AtomicInteger serverIdCounter = new AtomicInteger();
		/**
		 * Server ID. By default, an auto-incremented counter is used.
		 */
		private int serverId = serverIdCounter.getAndIncrement();
		/**
		 * Whether to enable embedded mode if the Artemis server APIs are available.
		 */
		private boolean enabled = true;
		/**
		 * Whether to enable persistent store.
		 */
		private boolean persistent;
		/**
		 * Journal file directory. Not necessary if persistence is turned off.
		 */
		private String dataDirectory;
		/**
		 * List of queues to create on startup.
		 */
		private String[] queues = new String[0];
		/**
		 * List of topics to create on startup.
		 */
		private String[] topics = new String[0];
		/**
		 * Cluster password. Randomly generated on startup by default.
		 */
		private String clusterPassword = UUID.randomUUID().toString();
		private boolean defaultClusterPassword = true;
		public int getServerId() {
			return this.serverId;
		}
		public void setServerId(int serverId) {
			this.serverId = serverId;
		}
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public boolean isPersistent() {
			return this.persistent;
		}
		public void setPersistent(boolean persistent) {
			this.persistent = persistent;
		}
		public String getDataDirectory() {
			return this.dataDirectory;
		}
		public void setDataDirectory(String dataDirectory) {
			this.dataDirectory = dataDirectory;
		}
		public String[] getQueues() {
			return this.queues;
		}
		public void setQueues(String[] queues) {
			this.queues = queues;
		}
		public String[] getTopics() {
			return this.topics;
		}
		public void setTopics(String[] topics) {
			this.topics = topics;
		}
		public String getClusterPassword() {
			return this.clusterPassword;
		}
		public void setClusterPassword(String clusterPassword) {
			this.clusterPassword = clusterPassword;
			this.defaultClusterPassword = false;
		}
		public boolean isDefaultClusterPassword() {
			return this.defaultClusterPassword;
		}
		/**
		 * Creates the minimal transport parameters for an embedded transport
		 * configuration.
		 * @return the transport parameters
		 * @see TransportConstants#SERVER_ID_PROP_NAME
		 */
		public Map<String, Object> generateTransportParameters() {
			Map<String, Object> parameters = new HashMap<>();
			parameters.put(TransportConstants.SERVER_ID_PROP_NAME, getServerId());
			return parameters;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
@AutoConfiguration(before = JmsAutoConfiguration.class, after = JndiConnectionFactoryAutoConfiguration.class)
@ConditionalOnClass({ ConnectionFactory.class, ActiveMQConnectionFactory.class })
@ConditionalOnMissingBean(ConnectionFactory.class)
@EnableConfigurationProperties({ ArtemisProperties.class, JmsProperties.class })
@Import({ ArtemisEmbeddedServerConfiguration.class, ArtemisXAConnectionFactoryConfiguration.class,
		ArtemisConnectionFactoryConfiguration.class })
public class ArtemisAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(ArtemisConnectionDetails.class)
	ArtemisConnectionDetails artemisConnectionDetails(ArtemisProperties properties) {
		return new PropertiesArtemisConnectionDetails(properties);
	}
	/**
	 * Adapts {@link ArtemisProperties} to {@link ArtemisConnectionDetails}.
	 */
	static class PropertiesArtemisConnectionDetails implements ArtemisConnectionDetails {
		private final ArtemisProperties properties;
		PropertiesArtemisConnectionDetails(ArtemisProperties properties) {
			this.properties = properties;
		}
		@Override
		public ArtemisMode getMode() {
			return this.properties.getMode();
		}
		@Override
		public String getBrokerUrl() {
			return this.properties.getBrokerUrl();
		}
		@Override
		public String getUser() {
			return this.properties.getUser();
		}
		@Override
		public String getPassword() {
			return this.properties.getPassword();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
public enum ArtemisMode {
	/**
	 * Connect to a broker using the native Artemis protocol (i.e. netty).
	 */
	NATIVE,
	/**
	 * Embed (i.e. start) the broker in the application.
	 */
	EMBEDDED
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
class ArtemisEmbeddedConfigurationFactory {
	private static final Log logger = LogFactory.getLog(ArtemisEmbeddedConfigurationFactory.class);
	private final ArtemisProperties.Embedded properties;
	ArtemisEmbeddedConfigurationFactory(ArtemisProperties properties) {
		this.properties = properties.getEmbedded();
	}
	Configuration createConfiguration() {
		ConfigurationImpl configuration = new ConfigurationImpl();
		configuration.setSecurityEnabled(false);
		configuration.setPersistenceEnabled(this.properties.isPersistent());
		String dataDir = getDataDir();
		configuration.setJournalDirectory(dataDir + '/journal');
		if (this.properties.isPersistent()) {
			configuration.setJournalType(JournalType.NIO);
			configuration.setLargeMessagesDirectory(dataDir + '/largemessages');
			configuration.setBindingsDirectory(dataDir + '/bindings');
			configuration.setPagingDirectory(dataDir + '/paging');
		}
		TransportConfiguration transportConfiguration = new TransportConfiguration(InVMAcceptorFactory.class.getName(),
				this.properties.generateTransportParameters());
		configuration.getAcceptorConfigurations().add(transportConfiguration);
		if (this.properties.isDefaultClusterPassword() && logger.isDebugEnabled()) {
			logger.debug('Using default Artemis cluster password: ' + this.properties.getClusterPassword());
		}
		configuration.setClusterPassword(this.properties.getClusterPassword());
		configuration.addAddressConfiguration(createAddressConfiguration('DLQ'));
		configuration.addAddressConfiguration(createAddressConfiguration('ExpiryQueue'));
		configuration.addAddressSetting('#', new AddressSettings().setDeadLetterAddress(SimpleString.of('DLQ'))
			.setExpiryAddress(SimpleString.of('ExpiryQueue')));
		return configuration;
	}
	private CoreAddressConfiguration createAddressConfiguration(String name) {
		return new CoreAddressConfiguration().setName(name)
			.addRoutingType(RoutingType.ANYCAST)
			.addQueueConfiguration(QueueConfiguration.of(name).setRoutingType(RoutingType.ANYCAST).setAddress(name));
	}
	private String getDataDir() {
		if (this.properties.getDataDirectory() != null) {
			return this.properties.getDataDirectory();
		}
		String tempDirectory = System.getProperty('java.io.tmpdir');
		return new File(tempDirectory, 'artemis-data').getAbsolutePath();
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
public interface ArtemisConnectionDetails extends ConnectionDetails {
	/**
	 * Artemis deployment mode, auto-detected by default.
	 * @return the Artemis deployment mode, auto-detected by default
	 */
	ArtemisMode getMode();
	/**
	 * Artemis broker url.
	 * @return the Artemis broker url
	 */
	String getBrokerUrl();
	/**
	 * Login user of the broker.
	 * @return the login user of the broker
	 */
	String getUser();
	/**
	 * Login password of the broker.
	 * @return the login password of the broker
	 */
	String getPassword();
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(ConnectionFactory.class)
@ConditionalOnClass(TransactionManager.class)
@ConditionalOnBean(XAConnectionFactoryWrapper.class)
class ArtemisXAConnectionFactoryConfiguration {
	@Primary
	@Bean(name = { 'jmsConnectionFactory', 'xaJmsConnectionFactory' })
	ConnectionFactory jmsConnectionFactory(ListableBeanFactory beanFactory, ArtemisProperties properties,
			ArtemisConnectionDetails connectionDetails, XAConnectionFactoryWrapper wrapper) throws Exception {
		return wrapper
			.wrapConnectionFactory(new ArtemisConnectionFactoryFactory(beanFactory, properties, connectionDetails)
				.createConnectionFactory(ActiveMQXAConnectionFactory::new, ActiveMQXAConnectionFactory::new));
	}
	@Bean
	ActiveMQXAConnectionFactory nonXaJmsConnectionFactory(ListableBeanFactory beanFactory, ArtemisProperties properties,
			ArtemisConnectionDetails connectionDetails) {
		return new ArtemisConnectionFactoryFactory(beanFactory, properties, connectionDetails)
			.createConnectionFactory(ActiveMQXAConnectionFactory::new, ActiveMQXAConnectionFactory::new);
	}
}
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
class ArtemisConnectionFactoryFactory {
	private static final String DEFAULT_BROKER_URL = 'tcp://localhost:61616';
	static final String[] EMBEDDED_JMS_CLASSES = { 'org.apache.activemq.artemis.jms.server.embedded.EmbeddedJMS',
			'org.apache.activemq.artemis.core.server.embedded.EmbeddedActiveMQ' };
	private final ArtemisProperties properties;
	private final ArtemisConnectionDetails connectionDetails;
	private final ListableBeanFactory beanFactory;
	ArtemisConnectionFactoryFactory(ListableBeanFactory beanFactory, ArtemisProperties properties,
			ArtemisConnectionDetails connectionDetails) {
		Assert.notNull(beanFactory, 'BeanFactory must not be null');
		Assert.notNull(properties, 'Properties must not be null');
		Assert.notNull(connectionDetails, 'ConnectionDetails must not be null');
		this.beanFactory = beanFactory;
		this.properties = properties;
		this.connectionDetails = connectionDetails;
	}
	<T extends ActiveMQConnectionFactory> T createConnectionFactory(Function<String, T> nativeFactoryCreator,
			Function<ServerLocator, T> embeddedFactoryCreator) {
		try {
			startEmbeddedJms();
			return doCreateConnectionFactory(nativeFactoryCreator, embeddedFactoryCreator);
		}
		catch (Exception ex) {
			throw new IllegalStateException('Unable to create ActiveMQConnectionFactory', ex);
		}
	}
	private void startEmbeddedJms() {
		for (String embeddedJmsClass : EMBEDDED_JMS_CLASSES) {
			if (ClassUtils.isPresent(embeddedJmsClass, null)) {
				try {
					this.beanFactory.getBeansOfType(Class.forName(embeddedJmsClass));
				}
				catch (Exception ex) {
					// Ignore
				}
			}
		}
	}
	private <T extends ActiveMQConnectionFactory> T doCreateConnectionFactory(Function<String, T> nativeFactoryCreator,
			Function<ServerLocator, T> embeddedFactoryCreator) throws Exception {
		ArtemisMode mode = this.connectionDetails.getMode();
		if (mode == null) {
			mode = deduceMode();
		}
		if (mode == ArtemisMode.EMBEDDED) {
			return createEmbeddedConnectionFactory(embeddedFactoryCreator);
		}
		return createNativeConnectionFactory(nativeFactoryCreator);
	}
	/**
	 * Deduce the {@link ArtemisMode} to use if none has been set.
	 * @return the mode
	 */
	private ArtemisMode deduceMode() {
		if (this.properties.getEmbedded().isEnabled() && isEmbeddedJmsClassPresent()) {
			return ArtemisMode.EMBEDDED;
		}
		return ArtemisMode.NATIVE;
	}
	private boolean isEmbeddedJmsClassPresent() {
		for (String embeddedJmsClass : EMBEDDED_JMS_CLASSES) {
			if (ClassUtils.isPresent(embeddedJmsClass, null)) {
				return true;
			}
		}
		return false;
	}
	private <T extends ActiveMQConnectionFactory> T createEmbeddedConnectionFactory(
			Function<ServerLocator, T> factoryCreator) throws Exception {
		try {
			TransportConfiguration transportConfiguration = new TransportConfiguration(
					InVMConnectorFactory.class.getName(), this.properties.getEmbedded().generateTransportParameters());
			ServerLocator serverLocator = ActiveMQClient.createServerLocatorWithoutHA(transportConfiguration);
			return factoryCreator.apply(serverLocator);
		}
		catch (NoClassDefFoundError ex) {
			throw new IllegalStateException('Unable to create InVM '
					+ 'Artemis connection, ensure that artemis-jms-server.jar is in the classpath', ex);
		}
	}
	private <T extends ActiveMQConnectionFactory> T createNativeConnectionFactory(Function<String, T> factoryCreator) {
		T connectionFactory = newNativeConnectionFactory(factoryCreator);
		String user = this.connectionDetails.getUser();
		if (StringUtils.hasText(user)) {
			connectionFactory.setUser(user);
			connectionFactory.setPassword(this.connectionDetails.getPassword());
		}
		return connectionFactory;
	}
	private <T extends ActiveMQConnectionFactory> T newNativeConnectionFactory(Function<String, T> factoryCreator) {
		String brokerUrl = StringUtils.hasText(this.connectionDetails.getBrokerUrl())
				? this.connectionDetails.getBrokerUrl() : DEFAULT_BROKER_URL;
		return factoryCreator.apply(brokerUrl);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jms.artemis;
/*
package org.springframework.boot.autoconfigure.jms.artemis;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(EmbeddedActiveMQ.class)
@ConditionalOnProperty(prefix = 'spring.artemis.embedded', name = 'enabled', havingValue = 'true',
		matchIfMissing = true)
class ArtemisEmbeddedServerConfiguration {
	private final ArtemisProperties properties;
	ArtemisEmbeddedServerConfiguration(ArtemisProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	org.apache.activemq.artemis.core.config.Configuration artemisConfiguration() {
		return new ArtemisEmbeddedConfigurationFactory(this.properties).createConfiguration();
	}
	@Bean(initMethod = 'start', destroyMethod = 'stop')
	@ConditionalOnMissingBean
	EmbeddedActiveMQ embeddedActiveMq(org.apache.activemq.artemis.core.config.Configuration configuration,
			JMSConfiguration jmsConfiguration,
			ObjectProvider<ArtemisConfigurationCustomizer> configurationCustomizers) {
		for (JMSQueueConfiguration queueConfiguration : jmsConfiguration.getQueueConfigurations()) {
			String queueName = queueConfiguration.getName();
			configuration.addAddressConfiguration(new CoreAddressConfiguration().setName(queueName)
				.addRoutingType(RoutingType.ANYCAST)
				.addQueueConfiguration(QueueConfiguration.of(queueName)
					.setAddress(queueName)
					.setFilterString(queueConfiguration.getSelector())
					.setDurable(queueConfiguration.isDurable())
					.setRoutingType(RoutingType.ANYCAST)));
		}
		for (TopicConfiguration topicConfiguration : jmsConfiguration.getTopicConfigurations()) {
			configuration.addAddressConfiguration(new CoreAddressConfiguration().setName(topicConfiguration.getName())
				.addRoutingType(RoutingType.MULTICAST));
		}
		configurationCustomizers.orderedStream().forEach((customizer) -> customizer.customize(configuration));
		EmbeddedActiveMQ embeddedActiveMq = new EmbeddedActiveMQ();
		embeddedActiveMq.setConfiguration(configuration);
		return embeddedActiveMq;
	}
	@Bean
	@ConditionalOnMissingBean
	JMSConfiguration artemisJmsConfiguration(ObjectProvider<JMSQueueConfiguration> queuesConfiguration,
			ObjectProvider<TopicConfiguration> topicsConfiguration) {
		JMSConfiguration configuration = new JMSConfigurationImpl();
		configuration.getQueueConfigurations().addAll(queuesConfiguration.orderedStream().toList());
		configuration.getTopicConfigurations().addAll(topicsConfiguration.orderedStream().toList());
		addQueues(configuration, this.properties.getEmbedded().getQueues());
		addTopics(configuration, this.properties.getEmbedded().getTopics());
		return configuration;
	}
	private void addQueues(JMSConfiguration configuration, String[] queues) {
		boolean persistent = this.properties.getEmbedded().isPersistent();
		for (String queue : queues) {
			JMSQueueConfigurationImpl jmsQueueConfiguration = new JMSQueueConfigurationImpl();
			jmsQueueConfiguration.setName(queue);
			jmsQueueConfiguration.setDurable(persistent);
			jmsQueueConfiguration.setBindings('/queue/' + queue);
			configuration.getQueueConfigurations().add(jmsQueueConfiguration);
		}
	}
	private void addTopics(JMSConfiguration configuration, String[] topics) {
		for (String topic : topics) {
			TopicConfigurationImpl topicConfiguration = new TopicConfigurationImpl();
			topicConfiguration.setName(topic);
			topicConfiguration.setBindings('/topic/' + topic);
			configuration.getTopicConfigurations().add(topicConfiguration);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
public final class AcknowledgeMode {
	private static final Map<String, AcknowledgeMode> knownModes = new HashMap<>(3);
	/**
	 * Messages sent or received from the session are automatically acknowledged. This is
	 * the simplest mode and enables once-only message delivery guarantee.
	 */
	public static final AcknowledgeMode AUTO = new AcknowledgeMode(Session.AUTO_ACKNOWLEDGE);
	/**
	 * Messages are acknowledged once the message listener implementation has called
	 * {@link jakarta.jms.Message#acknowledge()}. This mode gives the application (rather
	 * than the JMS provider) complete control over message acknowledgement.
	 */
	public static final AcknowledgeMode CLIENT = new AcknowledgeMode(Session.CLIENT_ACKNOWLEDGE);
	/**
	 * Similar to auto acknowledgment except that said acknowledgment is lazy. As a
	 * consequence, the messages might be delivered more than once. This mode enables
	 * at-least-once message delivery guarantee.
	 */
	public static final AcknowledgeMode DUPS_OK = new AcknowledgeMode(Session.DUPS_OK_ACKNOWLEDGE);
	static {
		knownModes.put('auto', AUTO);
		knownModes.put('client', CLIENT);
		knownModes.put('dupsok', DUPS_OK);
	}
	private final int mode;
	private AcknowledgeMode(int mode) {
		this.mode = mode;
	}
	public int getMode() {
		return this.mode;
	}
	/**
	 * Creates an {@code AcknowledgeMode} of the given {@code mode}. The mode may be
	 * {@code auto}, {@code client}, {@code dupsok} or a non-standard acknowledge mode
	 * that can be {@link Integer#parseInt parsed as an integer}.
	 * @param mode the mode
	 * @return the acknowledge mode
	 */
	public static AcknowledgeMode of(String mode) {
		String canonicalMode = canonicalize(mode);
		AcknowledgeMode knownMode = knownModes.get(canonicalMode);
		try {
			return (knownMode != null) ? knownMode : new AcknowledgeMode(Integer.parseInt(canonicalMode));
		}
		catch (NumberFormatException ex) {
			throw new IllegalArgumentException('"' + mode
					+ '" is neither a known acknowledge mode (auto, client, or dups_ok) nor an integer value');
		}
	}
	private static String canonicalize(String input) {
		StringBuilder canonicalName = new StringBuilder(input.length());
		input.chars()
			.filter(Character::isLetterOrDigit)
			.map(Character::toLowerCase)
			.forEach((c) -> canonicalName.append((char) c));
		return canonicalName.toString();
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
public final class DefaultJmsListenerContainerFactoryConfigurer {
	private DestinationResolver destinationResolver;
	private MessageConverter messageConverter;
	private ExceptionListener exceptionListener;
	private JtaTransactionManager transactionManager;
	private JmsProperties jmsProperties;
	private ObservationRegistry observationRegistry;
	/**
	 * Set the {@link DestinationResolver} to use or {@code null} if no destination
	 * resolver should be associated with the factory by default.
	 * @param destinationResolver the {@link DestinationResolver}
	 */
	void setDestinationResolver(DestinationResolver destinationResolver) {
		this.destinationResolver = destinationResolver;
	}
	/**
	 * Set the {@link MessageConverter} to use or {@code null} if the out-of-the-box
	 * converter should be used.
	 * @param messageConverter the {@link MessageConverter}
	 */
	void setMessageConverter(MessageConverter messageConverter) {
		this.messageConverter = messageConverter;
	}
	/**
	 * Set the {@link ExceptionListener} to use or {@code null} if no exception listener
	 * should be associated by default.
	 * @param exceptionListener the {@link ExceptionListener}
	 */
	void setExceptionListener(ExceptionListener exceptionListener) {
		this.exceptionListener = exceptionListener;
	}
	/**
	 * Set the {@link JtaTransactionManager} to use or {@code null} if the JTA support
	 * should not be used.
	 * @param transactionManager the {@link JtaTransactionManager}
	 */
	void setTransactionManager(JtaTransactionManager transactionManager) {
		this.transactionManager = transactionManager;
	}
	/**
	 * Set the {@link JmsProperties} to use.
	 * @param jmsProperties the {@link JmsProperties}
	 */
	void setJmsProperties(JmsProperties jmsProperties) {
		this.jmsProperties = jmsProperties;
	}
	/**
	 * Set the {@link ObservationRegistry} to use.
	 * @param observationRegistry the {@link ObservationRegistry}
	 * @since 3.2.1
	 */
	public void setObservationRegistry(ObservationRegistry observationRegistry) {
		this.observationRegistry = observationRegistry;
	}
	/**
	 * Configure the specified jms listener container factory. The factory can be further
	 * tuned and default settings can be overridden.
	 * @param factory the {@link DefaultJmsListenerContainerFactory} instance to configure
	 * @param connectionFactory the {@link ConnectionFactory} to use
	 */
	public void configure(DefaultJmsListenerContainerFactory factory, ConnectionFactory connectionFactory) {
		Assert.notNull(factory, 'Factory must not be null');
		Assert.notNull(connectionFactory, 'ConnectionFactory must not be null');
		JmsProperties.Listener listenerProperties = this.jmsProperties.getListener();
		Session sessionProperties = listenerProperties.getSession();
		factory.setConnectionFactory(connectionFactory);
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.jmsProperties::isPubSubDomain).to(factory::setPubSubDomain);
		map.from(this.jmsProperties::isSubscriptionDurable).to(factory::setSubscriptionDurable);
		map.from(this.jmsProperties::getClientId).to(factory::setClientId);
		map.from(this.transactionManager).to(factory::setTransactionManager);
		map.from(this.destinationResolver).to(factory::setDestinationResolver);
		map.from(this.messageConverter).to(factory::setMessageConverter);
		map.from(this.exceptionListener).to(factory::setExceptionListener);
		map.from(sessionProperties.getAcknowledgeMode()::getMode).to(factory::setSessionAcknowledgeMode);
		if (this.transactionManager == null && sessionProperties.getTransacted() == null) {
			factory.setSessionTransacted(true);
		}
		map.from(this.observationRegistry).to(factory::setObservationRegistry);
		map.from(sessionProperties::getTransacted).to(factory::setSessionTransacted);
		map.from(listenerProperties::isAutoStartup).to(factory::setAutoStartup);
		map.from(listenerProperties::formatConcurrency).to(factory::setConcurrency);
		map.from(listenerProperties::getReceiveTimeout).as(Duration::toMillis).to(factory::setReceiveTimeout);
		map.from(listenerProperties::getMaxMessagesPerTask).to(factory::setMaxMessagesPerTask);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jms;
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
@FunctionalInterface
public interface ActiveMQConnectionFactoryCustomizer {
	/**
	 * Customize the {@link ActiveMQConnectionFactory}.
	 * @param factory the factory to customize
	 */
	void customize(ActiveMQConnectionFactory factory);
}
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
public interface ActiveMQConnectionDetails extends ConnectionDetails {
	/**
	 * Broker URL to use.
	 * @return the url of the broker
	 */
	String getBrokerUrl();
	/**
	 * Login user to authenticate to the broker.
	 * @return the login user to authenticate to the broker or {@code null}
	 */
	String getUser();
	/**
	 * Login to authenticate against the broker.
	 * @return the login to authenticate against the broker or {@code null}
	 */
	String getPassword();
}
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(ConnectionFactory.class)
class ActiveMQConnectionFactoryConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.activemq.pool', name = 'enabled', havingValue = 'false',
			matchIfMissing = true)
	static class SimpleConnectionFactoryConfiguration {
		@Bean
		@ConditionalOnProperty(prefix = 'spring.jms.cache', name = 'enabled', havingValue = 'false')
		ActiveMQConnectionFactory jmsConnectionFactory(ActiveMQProperties properties,
				ObjectProvider<ActiveMQConnectionFactoryCustomizer> factoryCustomizers,
				ActiveMQConnectionDetails connectionDetails) {
			return createJmsConnectionFactory(properties, factoryCustomizers, connectionDetails);
		}
		private static ActiveMQConnectionFactory createJmsConnectionFactory(ActiveMQProperties properties,
				ObjectProvider<ActiveMQConnectionFactoryCustomizer> factoryCustomizers,
				ActiveMQConnectionDetails connectionDetails) {
			ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(connectionDetails.getUser(),
					connectionDetails.getPassword(), connectionDetails.getBrokerUrl());
			new ActiveMQConnectionFactoryConfigurer(properties, factoryCustomizers.orderedStream().toList())
				.configure(connectionFactory);
			return connectionFactory;
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(CachingConnectionFactory.class)
		@ConditionalOnProperty(prefix = 'spring.jms.cache', name = 'enabled', havingValue = 'true',
				matchIfMissing = true)
		static class CachingConnectionFactoryConfiguration {
			@Bean
			CachingConnectionFactory jmsConnectionFactory(JmsProperties jmsProperties, ActiveMQProperties properties,
					ObjectProvider<ActiveMQConnectionFactoryCustomizer> factoryCustomizers,
					ActiveMQConnectionDetails connectionDetails) {
				JmsProperties.Cache cacheProperties = jmsProperties.getCache();
				CachingConnectionFactory connectionFactory = new CachingConnectionFactory(
						createJmsConnectionFactory(properties, factoryCustomizers, connectionDetails));
				connectionFactory.setCacheConsumers(cacheProperties.isConsumers());
				connectionFactory.setCacheProducers(cacheProperties.isProducers());
				connectionFactory.setSessionCacheSize(cacheProperties.getSessionCacheSize());
				return connectionFactory;
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ JmsPoolConnectionFactory.class, PooledObject.class })
	static class PooledConnectionFactoryConfiguration {
		@Bean(destroyMethod = 'stop')
		@ConditionalOnProperty(prefix = 'spring.activemq.pool', name = 'enabled', havingValue = 'true')
		JmsPoolConnectionFactory jmsConnectionFactory(ActiveMQProperties properties,
				ObjectProvider<ActiveMQConnectionFactoryCustomizer> factoryCustomizers,
				ActiveMQConnectionDetails connectionDetails) {
			ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(connectionDetails.getUser(),
					connectionDetails.getPassword(), connectionDetails.getBrokerUrl());
			new ActiveMQConnectionFactoryConfigurer(properties, factoryCustomizers.orderedStream().toList())
				.configure(connectionFactory);
			return new JmsPoolConnectionFactoryFactory(properties.getPool())
				.createPooledConnectionFactory(connectionFactory);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
@ConfigurationProperties(prefix = 'spring.activemq')
public class ActiveMQProperties {
	private static final String DEFAULT_EMBEDDED_BROKER_URL = 'vm://localhost?broker.persistent=false';
	private static final String DEFAULT_NETWORK_BROKER_URL = 'tcp://localhost:61616';
	/**
	 * URL of the ActiveMQ broker. Auto-generated by default.
	 */
	private String brokerUrl;
	/**
	 * Login user of the broker.
	 */
	private String user;
	/**
	 * Login password of the broker.
	 */
	private String password;
	private final Embedded embedded = new Embedded();
	/**
	 * Time to wait before considering a close complete.
	 */
	private Duration closeTimeout = Duration.ofSeconds(15);
	/**
	 * Whether to stop message delivery before re-delivering messages from a rolled back
	 * transaction. This implies that message order is not preserved when this is enabled.
	 */
	private boolean nonBlockingRedelivery = false;
	/**
	 * Time to wait on message sends for a response. Set it to 0 to wait forever.
	 */
	private Duration sendTimeout = Duration.ofMillis(0);
	@NestedConfigurationProperty
	private final JmsPoolConnectionFactoryProperties pool = new JmsPoolConnectionFactoryProperties();
	private final Packages packages = new Packages();
	public String getBrokerUrl() {
		return this.brokerUrl;
	}
	public void setBrokerUrl(String brokerUrl) {
		this.brokerUrl = brokerUrl;
	}
	public String getUser() {
		return this.user;
	}
	public void setUser(String user) {
		this.user = user;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Embedded getEmbedded() {
		return this.embedded;
	}
	public Duration getCloseTimeout() {
		return this.closeTimeout;
	}
	public void setCloseTimeout(Duration closeTimeout) {
		this.closeTimeout = closeTimeout;
	}
	public boolean isNonBlockingRedelivery() {
		return this.nonBlockingRedelivery;
	}
	public void setNonBlockingRedelivery(boolean nonBlockingRedelivery) {
		this.nonBlockingRedelivery = nonBlockingRedelivery;
	}
	public Duration getSendTimeout() {
		return this.sendTimeout;
	}
	public void setSendTimeout(Duration sendTimeout) {
		this.sendTimeout = sendTimeout;
	}
	public JmsPoolConnectionFactoryProperties getPool() {
		return this.pool;
	}
	public Packages getPackages() {
		return this.packages;
	}
	String determineBrokerUrl() {
		if (this.brokerUrl != null) {
			return this.brokerUrl;
		}
		if (this.embedded.isEnabled()) {
			return DEFAULT_EMBEDDED_BROKER_URL;
		}
		return DEFAULT_NETWORK_BROKER_URL;
	}
	/**
	 * Configuration for an embedded ActiveMQ broker.
	 */
	public static class Embedded {
		/**
		 * Whether to enable embedded mode if the ActiveMQ Broker is available.
		 */
		private boolean enabled = true;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
	public static class Packages {
		/**
		 * Whether to trust all packages.
		 */
		private Boolean trustAll;
		/**
		 * List of specific packages to trust (when not trusting all packages).
		 */
		private List<String> trusted = new ArrayList<>();
		public Boolean getTrustAll() {
			return this.trustAll;
		}
		public void setTrustAll(Boolean trustAll) {
			this.trustAll = trustAll;
		}
		public List<String> getTrusted() {
			return this.trusted;
		}
		public void setTrusted(List<String> trusted) {
			this.trusted = trusted;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
class ActiveMQConnectionFactoryConfigurer {
	private final ActiveMQProperties properties;
	private final List<ActiveMQConnectionFactoryCustomizer> factoryCustomizers;
	ActiveMQConnectionFactoryConfigurer(ActiveMQProperties properties,
			List<ActiveMQConnectionFactoryCustomizer> factoryCustomizers) {
		Assert.notNull(properties, 'Properties must not be null');
		this.properties = properties;
		this.factoryCustomizers = (factoryCustomizers != null) ? factoryCustomizers : Collections.emptyList();
	}
	void configure(ActiveMQConnectionFactory factory) {
		if (this.properties.getCloseTimeout() != null) {
			factory.setCloseTimeout((int) this.properties.getCloseTimeout().toMillis());
		}
		factory.setNonBlockingRedelivery(this.properties.isNonBlockingRedelivery());
		if (this.properties.getSendTimeout() != null) {
			factory.setSendTimeout((int) this.properties.getSendTimeout().toMillis());
		}
		Packages packages = this.properties.getPackages();
		if (packages.getTrustAll() != null) {
			factory.setTrustAllPackages(packages.getTrustAll());
		}
		if (!packages.getTrusted().isEmpty()) {
			factory.setTrustedPackages(packages.getTrusted());
		}
		customize(factory);
	}
	private void customize(ActiveMQConnectionFactory connectionFactory) {
		for (ActiveMQConnectionFactoryCustomizer factoryCustomizer : this.factoryCustomizers) {
			factoryCustomizer.customize(connectionFactory);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(TransactionManager.class)
@ConditionalOnBean(XAConnectionFactoryWrapper.class)
@ConditionalOnMissingBean(ConnectionFactory.class)
class ActiveMQXAConnectionFactoryConfiguration {
	@Primary
	@Bean(name = { 'jmsConnectionFactory', 'xaJmsConnectionFactory' })
	ConnectionFactory jmsConnectionFactory(ActiveMQProperties properties,
			ObjectProvider<ActiveMQConnectionFactoryCustomizer> factoryCustomizers, XAConnectionFactoryWrapper wrapper,
			ActiveMQConnectionDetails connectionDetails) throws Exception {
		ActiveMQXAConnectionFactory connectionFactory = new ActiveMQXAConnectionFactory(connectionDetails.getUser(),
				connectionDetails.getPassword(), connectionDetails.getBrokerUrl());
		new ActiveMQConnectionFactoryConfigurer(properties, factoryCustomizers.orderedStream().toList())
			.configure(connectionFactory);
		return wrapper.wrapConnectionFactory(connectionFactory);
	}
	@Bean
	@ConditionalOnProperty(prefix = 'spring.activemq.pool', name = 'enabled', havingValue = 'false',
			matchIfMissing = true)
	ActiveMQConnectionFactory nonXaJmsConnectionFactory(ActiveMQProperties properties,
			ObjectProvider<ActiveMQConnectionFactoryCustomizer> factoryCustomizers,
			ActiveMQConnectionDetails connectionDetails) {
		ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(connectionDetails.getUser(),
				connectionDetails.getPassword(), connectionDetails.getBrokerUrl());
		new ActiveMQConnectionFactoryConfigurer(properties, factoryCustomizers.orderedStream().toList())
			.configure(connectionFactory);
		return connectionFactory;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jms.activemq;
/*
package org.springframework.boot.autoconfigure.jms.activemq;
/**
@AutoConfiguration(before = JmsAutoConfiguration.class, after = JndiConnectionFactoryAutoConfiguration.class)
@ConditionalOnClass({ ConnectionFactory.class, ActiveMQConnectionFactory.class })
@ConditionalOnMissingBean(ConnectionFactory.class)
@EnableConfigurationProperties({ ActiveMQProperties.class, JmsProperties.class })
@Import({ ActiveMQXAConnectionFactoryConfiguration.class, ActiveMQConnectionFactoryConfiguration.class })
public class ActiveMQAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(ActiveMQConnectionDetails.class)
	ActiveMQConnectionDetails activemqConnectionDetails(ActiveMQProperties properties) {
		return new PropertiesActiveMQConnectionDetails(properties);
	}
	/**
	 * Adapts {@link ActiveMQProperties} to {@link ActiveMQConnectionDetails}.
	 */
	static class PropertiesActiveMQConnectionDetails implements ActiveMQConnectionDetails {
		private final ActiveMQProperties properties;
		PropertiesActiveMQConnectionDetails(ActiveMQProperties properties) {
			this.properties = properties;
		}
		@Override
		public String getBrokerUrl() {
			return this.properties.determineBrokerUrl();
		}
		@Override
		public String getUser() {
			return this.properties.getUser();
		}
		@Override
		public String getPassword() {
			return this.properties.getPassword();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.jms;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(EnableJms.class)
class JmsAnnotationDrivenConfiguration {
	private final ObjectProvider<DestinationResolver> destinationResolver;
	private final ObjectProvider<JtaTransactionManager> transactionManager;
	private final ObjectProvider<MessageConverter> messageConverter;
	private final ObjectProvider<ExceptionListener> exceptionListener;
	private final ObjectProvider<ObservationRegistry> observationRegistry;
	private final JmsProperties properties;
	JmsAnnotationDrivenConfiguration(ObjectProvider<DestinationResolver> destinationResolver,
			ObjectProvider<JtaTransactionManager> transactionManager, ObjectProvider<MessageConverter> messageConverter,
			ObjectProvider<ExceptionListener> exceptionListener,
			ObjectProvider<ObservationRegistry> observationRegistry, JmsProperties properties) {
		this.destinationResolver = destinationResolver;
		this.transactionManager = transactionManager;
		this.messageConverter = messageConverter;
		this.exceptionListener = exceptionListener;
		this.observationRegistry = observationRegistry;
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean
	DefaultJmsListenerContainerFactoryConfigurer jmsListenerContainerFactoryConfigurer() {
		DefaultJmsListenerContainerFactoryConfigurer configurer = new DefaultJmsListenerContainerFactoryConfigurer();
		configurer.setDestinationResolver(this.destinationResolver.getIfUnique());
		configurer.setTransactionManager(this.transactionManager.getIfUnique());
		configurer.setMessageConverter(this.messageConverter.getIfUnique());
		configurer.setExceptionListener(this.exceptionListener.getIfUnique());
		configurer.setObservationRegistry(this.observationRegistry.getIfUnique());
		configurer.setJmsProperties(this.properties);
		return configurer;
	}
	@Bean
	@ConditionalOnSingleCandidate(ConnectionFactory.class)
	@ConditionalOnMissingBean(name = 'jmsListenerContainerFactory')
	DefaultJmsListenerContainerFactory jmsListenerContainerFactory(
			DefaultJmsListenerContainerFactoryConfigurer configurer, ConnectionFactory connectionFactory) {
		DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
		configurer.configure(factory, ConnectionFactoryUnwrapper.unwrap(connectionFactory));
		return factory;
	}
	@Configuration(proxyBeanMethods = false)
	@EnableJms
	@ConditionalOnMissingBean(name = JmsListenerConfigUtils.JMS_LISTENER_ANNOTATION_PROCESSOR_BEAN_NAME)
	static class EnableJmsConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnJndi
	static class JndiConfiguration {
		@Bean
		@ConditionalOnMissingBean(DestinationResolver.class)
		JndiDestinationResolver destinationResolver() {
			JndiDestinationResolver resolver = new JndiDestinationResolver();
			resolver.setFallbackToDynamicDestination(true);
			return resolver;
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public abstract class AbstractDependsOnBeanFactoryPostProcessor implements BeanFactoryPostProcessor, Ordered {
	private final Class<?> beanClass;
	private final Class<? extends FactoryBean<?>> factoryBeanClass;
	private final Function<ListableBeanFactory, Set<String>> dependsOn;
	/**
	 * Create an instance with target bean, factory bean classes, and dependency names.
	 * @param beanClass target bean class
	 * @param factoryBeanClass target factory bean class
	 * @param dependsOn dependency names
	 */
	protected AbstractDependsOnBeanFactoryPostProcessor(Class<?> beanClass,
			Class<? extends FactoryBean<?>> factoryBeanClass, String... dependsOn) {
		this.beanClass = beanClass;
		this.factoryBeanClass = factoryBeanClass;
		this.dependsOn = (beanFactory) -> new HashSet<>(Arrays.asList(dependsOn));
	}
	/**
	 * Create an instance with target bean, factory bean classes, and dependency types.
	 * @param beanClass target bean class
	 * @param factoryBeanClass target factory bean class
	 * @param dependencyTypes dependency types
	 * @since 2.1.7
	 */
	protected AbstractDependsOnBeanFactoryPostProcessor(Class<?> beanClass,
			Class<? extends FactoryBean<?>> factoryBeanClass, Class<?>... dependencyTypes) {
		this.beanClass = beanClass;
		this.factoryBeanClass = factoryBeanClass;
		this.dependsOn = (beanFactory) -> Arrays.stream(dependencyTypes)
			.flatMap((dependencyType) -> getBeanNames(beanFactory, dependencyType).stream())
			.collect(Collectors.toSet());
	}
	/**
	 * Create an instance with target bean class and dependency names.
	 * @param beanClass target bean class
	 * @param dependsOn dependency names
	 * @since 2.0.4
	 */
	protected AbstractDependsOnBeanFactoryPostProcessor(Class<?> beanClass, String... dependsOn) {
		this(beanClass, null, dependsOn);
	}
	/**
	 * Create an instance with target bean class and dependency types.
	 * @param beanClass target bean class
	 * @param dependencyTypes dependency types
	 * @since 2.1.7
	 */
	protected AbstractDependsOnBeanFactoryPostProcessor(Class<?> beanClass, Class<?>... dependencyTypes) {
		this(beanClass, null, dependencyTypes);
	}
	@Override
	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		for (String beanName : getBeanNames(beanFactory)) {
			BeanDefinition definition = getBeanDefinition(beanName, beanFactory);
			String[] dependencies = definition.getDependsOn();
			for (String dependencyName : this.dependsOn.apply(beanFactory)) {
				dependencies = StringUtils.addStringToArray(dependencies, dependencyName);
			}
			definition.setDependsOn(dependencies);
		}
	}
	@Override
	public int getOrder() {
		return 0;
	}
	private Set<String> getBeanNames(ListableBeanFactory beanFactory) {
		Set<String> names = getBeanNames(beanFactory, this.beanClass);
		if (this.factoryBeanClass != null) {
			names.addAll(getBeanNames(beanFactory, this.factoryBeanClass));
		}
		return names;
	}
	private static Set<String> getBeanNames(ListableBeanFactory beanFactory, Class<?> beanClass) {
		String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(beanFactory, beanClass, true, false);
		return Arrays.stream(names).map(BeanFactoryUtils::transformedBeanName).collect(Collectors.toSet());
	}
	private static BeanDefinition getBeanDefinition(String beanName, ConfigurableListableBeanFactory beanFactory) {
		try {
			return beanFactory.getBeanDefinition(beanName);
		}
		catch (NoSuchBeanDefinitionException ex) {
			BeanFactory parentBeanFactory = beanFactory.getParentBeanFactory();
			if (parentBeanFactory instanceof ConfigurableListableBeanFactory listableBeanFactory) {
				return getBeanDefinition(beanName, listableBeanFactory);
			}
			throw ex;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@AutoConfiguration
@EnableConfigurationProperties
public class ConfigurationPropertiesAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@ConfigurationProperties(prefix = 'spring.messages')
public class MessageSourceProperties {
	/**
	 * List of basenames (essentially a fully-qualified classpath location), each
	 * following the ResourceBundle convention with relaxed support for slash based
	 * locations. If it doesn"t contain a package qualifier (such as 'org.mypackage'), it
	 * will be resolved from the classpath root.
	 */
	private List<String> basename = new ArrayList<>(List.of('messages'));
	/**
	 * List of locale-independent property file resources containing common messages.
	 */
	private List<Resource> commonMessages;
	/**
	 * Message bundles encoding.
	 */
	private Charset encoding = StandardCharsets.UTF_8;
	/**
	 * Loaded resource bundle files cache duration. When not set, bundles are cached
	 * forever. If a duration suffix is not specified, seconds will be used.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration cacheDuration;
	/**
	 * Whether to fall back to the system Locale if no files for a specific Locale have
	 * been found. if this is turned off, the only fallback will be the default file (e.g.
	 * 'messages.properties' for basename 'messages').
	 */
	private boolean fallbackToSystemLocale = true;
	/**
	 * Whether to always apply the MessageFormat rules, parsing even messages without
	 * arguments.
	 */
	private boolean alwaysUseMessageFormat = false;
	/**
	 * Whether to use the message code as the default message instead of throwing a
	 * 'NoSuchMessageException'. Recommended during development only.
	 */
	private boolean useCodeAsDefaultMessage = false;
	public List<String> getBasename() {
		return this.basename;
	}
	public void setBasename(List<String> basename) {
		this.basename = basename;
	}
	public Charset getEncoding() {
		return this.encoding;
	}
	public void setEncoding(Charset encoding) {
		this.encoding = encoding;
	}
	public Duration getCacheDuration() {
		return this.cacheDuration;
	}
	public void setCacheDuration(Duration cacheDuration) {
		this.cacheDuration = cacheDuration;
	}
	public boolean isFallbackToSystemLocale() {
		return this.fallbackToSystemLocale;
	}
	public void setFallbackToSystemLocale(boolean fallbackToSystemLocale) {
		this.fallbackToSystemLocale = fallbackToSystemLocale;
	}
	public boolean isAlwaysUseMessageFormat() {
		return this.alwaysUseMessageFormat;
	}
	public void setAlwaysUseMessageFormat(boolean alwaysUseMessageFormat) {
		this.alwaysUseMessageFormat = alwaysUseMessageFormat;
	}
	public boolean isUseCodeAsDefaultMessage() {
		return this.useCodeAsDefaultMessage;
	}
	public void setUseCodeAsDefaultMessage(boolean useCodeAsDefaultMessage) {
		this.useCodeAsDefaultMessage = useCodeAsDefaultMessage;
	}
	public List<Resource> getCommonMessages() {
		return this.commonMessages;
	}
	public void setCommonMessages(List<Resource> commonMessages) {
		this.commonMessages = commonMessages;
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@ConfigurationProperties(prefix = 'spring.lifecycle')
public class LifecycleProperties {
	/**
	 * Timeout for the shutdown of any phase (group of SmartLifecycle beans with the same
	 * "phase" value).
	 */
	private Duration timeoutPerShutdownPhase = Duration.ofSeconds(30);
	public Duration getTimeoutPerShutdownPhase() {
		return this.timeoutPerShutdownPhase;
	}
	public void setTimeoutPerShutdownPhase(Duration timeoutPerShutdownPhase) {
		this.timeoutPerShutdownPhase = timeoutPerShutdownPhase;
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@AutoConfiguration
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
public class PropertyPlaceholderAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(search = SearchStrategy.CURRENT)
	public static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {
		return new PropertySourcesPlaceholderConfigurer();
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@AutoConfiguration
@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Conditional(ResourceBundleCondition.class)
@EnableConfigurationProperties(MessageSourceProperties.class)
@ImportRuntimeHints(MessageSourceRuntimeHints.class)
public class MessageSourceAutoConfiguration {
	private static final Resource[] NO_RESOURCES = {};
	@Bean
	public MessageSource messageSource(MessageSourceProperties properties) {
		ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();
		if (!CollectionUtils.isEmpty(properties.getBasename())) {
			messageSource.setBasenames(properties.getBasename().toArray(new String[0]));
		}
		if (properties.getEncoding() != null) {
			messageSource.setDefaultEncoding(properties.getEncoding().name());
		}
		messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());
		Duration cacheDuration = properties.getCacheDuration();
		if (cacheDuration != null) {
			messageSource.setCacheMillis(cacheDuration.toMillis());
		}
		messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());
		messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());
		messageSource.setCommonMessages(loadCommonMessages(properties.getCommonMessages()));
		return messageSource;
	}
	private Properties loadCommonMessages(List<Resource> resources) {
		if (CollectionUtils.isEmpty(resources)) {
			return null;
		}
		Properties properties = CollectionFactory.createSortedProperties(false);
		for (Resource resource : resources) {
			try {
				PropertiesLoaderUtils.fillProperties(properties, resource);
			}
			catch (IOException ex) {
				throw new UncheckedIOException('Failed to load common messages from "%s"'.formatted(resource), ex);
			}
		}
		return properties;
	}
	protected static class ResourceBundleCondition extends SpringBootCondition {
		private static final ConcurrentReferenceHashMap<String, ConditionOutcome> cache = new ConcurrentReferenceHashMap<>();
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			String basename = context.getEnvironment().getProperty('spring.messages.basename', 'messages');
			ConditionOutcome outcome = cache.get(basename);
			if (outcome == null) {
				outcome = getMatchOutcomeForBasename(context, basename);
				cache.put(basename, outcome);
			}
			return outcome;
		}
		private ConditionOutcome getMatchOutcomeForBasename(ConditionContext context, String basename) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('ResourceBundle');
			for (String name : StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(basename))) {
				for (Resource resource : getResources(context.getClassLoader(), name)) {
					if (resource.exists()) {
						return ConditionOutcome.match(message.found('bundle').items(resource));
					}
				}
			}
			return ConditionOutcome.noMatch(message.didNotFind('bundle with basename ' + basename).atAll());
		}
		private Resource[] getResources(ClassLoader classLoader, String name) {
			String target = name.replace(".", "/");
			try {
				return new PathMatchingResourcePatternResolver(classLoader)
					.getResources('classpath*:' + target + '.properties');
			}
			catch (Exception ex) {
				return NO_RESOURCES;
			}
		}
	}
	static class MessageSourceRuntimeHints implements RuntimeHintsRegistrar {
		@Override
		public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
			hints.resources().registerPattern('messages.properties').registerPattern('messages_*.properties');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.context;
/**
@AutoConfiguration
@EnableConfigurationProperties(LifecycleProperties.class)
public class LifecycleAutoConfiguration {
	@Bean(name = AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME)
	@ConditionalOnMissingBean(name = AbstractApplicationContext.LIFECYCLE_PROCESSOR_BEAN_NAME,
			search = SearchStrategy.CURRENT)
	public DefaultLifecycleProcessor defaultLifecycleProcessor(LifecycleProperties properties) {
		DefaultLifecycleProcessor lifecycleProcessor = new DefaultLifecycleProcessor();
		lifecycleProcessor.setTimeoutPerShutdownPhase(properties.getTimeoutPerShutdownPhase().toMillis());
		return lifecycleProcessor;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.context;
/*
package org.springframework.boot.autoconfigure.task;
/**
@ConditionalOnClass(ThreadPoolTaskExecutor.class)
@AutoConfiguration
@EnableConfigurationProperties(TaskExecutionProperties.class)
@Import({ TaskExecutorConfigurations.ThreadPoolTaskExecutorBuilderConfiguration.class,
		TaskExecutorConfigurations.SimpleAsyncTaskExecutorBuilderConfiguration.class,
		TaskExecutorConfigurations.TaskExecutorConfiguration.class })
public class TaskExecutionAutoConfiguration {
	/**
	 * Bean name of the application {@link TaskExecutor}.
	 */
	public static final String APPLICATION_TASK_EXECUTOR_BEAN_NAME = 'applicationTaskExecutor';
}
/*
package org.springframework.boot.autoconfigure.task;
/**
@ConfigurationProperties('spring.task.execution')
public class TaskExecutionProperties {
	private final Pool pool = new Pool();
	private final Simple simple = new Simple();
	private final Shutdown shutdown = new Shutdown();
	/**
	 * Prefix to use for the names of newly created threads.
	 */
	private String threadNamePrefix = 'task-';
	public Simple getSimple() {
		return this.simple;
	}
	public Pool getPool() {
		return this.pool;
	}
	public Shutdown getShutdown() {
		return this.shutdown;
	}
	public String getThreadNamePrefix() {
		return this.threadNamePrefix;
	}
	public void setThreadNamePrefix(String threadNamePrefix) {
		this.threadNamePrefix = threadNamePrefix;
	}
	public static class Simple {
		/**
		 * Set the maximum number of parallel accesses allowed. -1 indicates no
		 * concurrency limit at all.
		 */
		private Integer concurrencyLimit;
		public Integer getConcurrencyLimit() {
			return this.concurrencyLimit;
		}
		public void setConcurrencyLimit(Integer concurrencyLimit) {
			this.concurrencyLimit = concurrencyLimit;
		}
	}
	public static class Pool {
		/**
		 * Queue capacity. An unbounded capacity does not increase the pool and therefore
		 * ignores the 'max-size' property. Doesn"t have an effect if virtual threads are
		 * enabled.
		 */
		private int queueCapacity = Integer.MAX_VALUE;
		/**
		 * Core number of threads. Doesn"t have an effect if virtual threads are enabled.
		 */
		private int coreSize = 8;
		/**
		 * Maximum allowed number of threads. If tasks are filling up the queue, the pool
		 * can expand up to that size to accommodate the load. Ignored if the queue is
		 * unbounded. Doesn"t have an effect if virtual threads are enabled.
		 */
		private int maxSize = Integer.MAX_VALUE;
		/**
		 * Whether core threads are allowed to time out. This enables dynamic growing and
		 * shrinking of the pool. Doesn"t have an effect if virtual threads are enabled.
		 */
		private boolean allowCoreThreadTimeout = true;
		/**
		 * Time limit for which threads may remain idle before being terminated. Doesn"t
		 * have an effect if virtual threads are enabled.
		 */
		private Duration keepAlive = Duration.ofSeconds(60);
		private final Shutdown shutdown = new Shutdown();
		public int getQueueCapacity() {
			return this.queueCapacity;
		}
		public void setQueueCapacity(int queueCapacity) {
			this.queueCapacity = queueCapacity;
		}
		public int getCoreSize() {
			return this.coreSize;
		}
		public void setCoreSize(int coreSize) {
			this.coreSize = coreSize;
		}
		public int getMaxSize() {
			return this.maxSize;
		}
		public void setMaxSize(int maxSize) {
			this.maxSize = maxSize;
		}
		public boolean isAllowCoreThreadTimeout() {
			return this.allowCoreThreadTimeout;
		}
		public void setAllowCoreThreadTimeout(boolean allowCoreThreadTimeout) {
			this.allowCoreThreadTimeout = allowCoreThreadTimeout;
		}
		public Duration getKeepAlive() {
			return this.keepAlive;
		}
		public void setKeepAlive(Duration keepAlive) {
			this.keepAlive = keepAlive;
		}
		public Shutdown getShutdown() {
			return this.shutdown;
		}
		public static class Shutdown {
			/**
			 * Whether to accept further tasks after the application context close phase
			 * has begun.
			 */
			private boolean acceptTasksAfterContextClose;
			public boolean isAcceptTasksAfterContextClose() {
				return this.acceptTasksAfterContextClose;
			}
			public void setAcceptTasksAfterContextClose(boolean acceptTasksAfterContextClose) {
				this.acceptTasksAfterContextClose = acceptTasksAfterContextClose;
			}
		}
	}
	public static class Shutdown {
		/**
		 * Whether the executor should wait for scheduled tasks to complete on shutdown.
		 */
		private boolean awaitTermination;
		/**
		 * Maximum time the executor should wait for remaining tasks to complete.
		 */
		private Duration awaitTerminationPeriod;
		public boolean isAwaitTermination() {
			return this.awaitTermination;
		}
		public void setAwaitTermination(boolean awaitTermination) {
			this.awaitTermination = awaitTermination;
		}
		public Duration getAwaitTerminationPeriod() {
			return this.awaitTerminationPeriod;
		}
		public void setAwaitTerminationPeriod(Duration awaitTerminationPeriod) {
			this.awaitTerminationPeriod = awaitTerminationPeriod;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.task;
/**
@ConfigurationProperties('spring.task.scheduling')
public class TaskSchedulingProperties {
	private final Pool pool = new Pool();
	private final Simple simple = new Simple();
	private final Shutdown shutdown = new Shutdown();
	/**
	 * Prefix to use for the names of newly created threads.
	 */
	private String threadNamePrefix = 'scheduling-';
	public Pool getPool() {
		return this.pool;
	}
	public Simple getSimple() {
		return this.simple;
	}
	public Shutdown getShutdown() {
		return this.shutdown;
	}
	public String getThreadNamePrefix() {
		return this.threadNamePrefix;
	}
	public void setThreadNamePrefix(String threadNamePrefix) {
		this.threadNamePrefix = threadNamePrefix;
	}
	public static class Pool {
		/**
		 * Maximum allowed number of threads. Doesn"t have an effect if virtual threads
		 * are enabled.
		 */
		private int size = 1;
		public int getSize() {
			return this.size;
		}
		public void setSize(int size) {
			this.size = size;
		}
	}
	public static class Simple {
		/**
		 * Set the maximum number of parallel accesses allowed. -1 indicates no
		 * concurrency limit at all.
		 */
		private Integer concurrencyLimit;
		public Integer getConcurrencyLimit() {
			return this.concurrencyLimit;
		}
		public void setConcurrencyLimit(Integer concurrencyLimit) {
			this.concurrencyLimit = concurrencyLimit;
		}
	}
	public static class Shutdown {
		/**
		 * Whether the executor should wait for scheduled tasks to complete on shutdown.
		 */
		private boolean awaitTermination;
		/**
		 * Maximum time the executor should wait for remaining tasks to complete.
		 */
		private Duration awaitTerminationPeriod;
		public boolean isAwaitTermination() {
			return this.awaitTermination;
		}
		public void setAwaitTermination(boolean awaitTermination) {
			this.awaitTermination = awaitTermination;
		}
		public Duration getAwaitTerminationPeriod() {
			return this.awaitTerminationPeriod;
		}
		public void setAwaitTerminationPeriod(Duration awaitTerminationPeriod) {
			this.awaitTerminationPeriod = awaitTerminationPeriod;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.task;
/**
class TaskSchedulingConfigurations {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)
	@ConditionalOnMissingBean({ TaskScheduler.class, ScheduledExecutorService.class })
	static class TaskSchedulerConfiguration {
		@Bean(name = 'taskScheduler')
		@ConditionalOnThreading(Threading.VIRTUAL)
		SimpleAsyncTaskScheduler taskSchedulerVirtualThreads(SimpleAsyncTaskSchedulerBuilder builder) {
			return builder.build();
		}
		@Bean
		@ConditionalOnThreading(Threading.PLATFORM)
		ThreadPoolTaskScheduler taskScheduler(ThreadPoolTaskSchedulerBuilder threadPoolTaskSchedulerBuilder) {
			return threadPoolTaskSchedulerBuilder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ThreadPoolTaskSchedulerBuilderConfiguration {
		@Bean
		@ConditionalOnMissingBean(ThreadPoolTaskSchedulerBuilder.class)
		ThreadPoolTaskSchedulerBuilder threadPoolTaskSchedulerBuilder(TaskSchedulingProperties properties,
				ObjectProvider<ThreadPoolTaskSchedulerCustomizer> threadPoolTaskSchedulerCustomizers) {
			TaskSchedulingProperties.Shutdown shutdown = properties.getShutdown();
			ThreadPoolTaskSchedulerBuilder builder = new ThreadPoolTaskSchedulerBuilder();
			builder = builder.poolSize(properties.getPool().getSize());
			builder = builder.awaitTermination(shutdown.isAwaitTermination());
			builder = builder.awaitTerminationPeriod(shutdown.getAwaitTerminationPeriod());
			builder = builder.threadNamePrefix(properties.getThreadNamePrefix());
			builder = builder.customizers(threadPoolTaskSchedulerCustomizers);
			return builder;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SimpleAsyncTaskSchedulerBuilderConfiguration {
		private final TaskSchedulingProperties properties;
		private final ObjectProvider<SimpleAsyncTaskSchedulerCustomizer> taskSchedulerCustomizers;
		SimpleAsyncTaskSchedulerBuilderConfiguration(TaskSchedulingProperties properties,
				ObjectProvider<SimpleAsyncTaskSchedulerCustomizer> taskSchedulerCustomizers) {
			this.properties = properties;
			this.taskSchedulerCustomizers = taskSchedulerCustomizers;
		}
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnThreading(Threading.PLATFORM)
		SimpleAsyncTaskSchedulerBuilder simpleAsyncTaskSchedulerBuilder() {
			return builder();
		}
		@Bean(name = 'simpleAsyncTaskSchedulerBuilder')
		@ConditionalOnMissingBean
		@ConditionalOnThreading(Threading.VIRTUAL)
		SimpleAsyncTaskSchedulerBuilder simpleAsyncTaskSchedulerBuilderVirtualThreads() {
			SimpleAsyncTaskSchedulerBuilder builder = builder();
			builder = builder.virtualThreads(true);
			return builder;
		}
		private SimpleAsyncTaskSchedulerBuilder builder() {
			SimpleAsyncTaskSchedulerBuilder builder = new SimpleAsyncTaskSchedulerBuilder();
			builder = builder.threadNamePrefix(this.properties.getThreadNamePrefix());
			builder = builder.customizers(this.taskSchedulerCustomizers.orderedStream()::iterator);
			TaskSchedulingProperties.Simple simple = this.properties.getSimple();
			builder = builder.concurrencyLimit(simple.getConcurrencyLimit());
			TaskSchedulingProperties.Shutdown shutdown = this.properties.getShutdown();
			if (shutdown.isAwaitTermination()) {
				builder = builder.taskTerminationTimeout(shutdown.getAwaitTerminationPeriod());
			}
			return builder;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.task;
/**
class ScheduledBeanLazyInitializationExcludeFilter implements LazyInitializationExcludeFilter {
	private final Set<Class<?>> nonAnnotatedClasses = ConcurrentHashMap.newKeySet(64);
	ScheduledBeanLazyInitializationExcludeFilter() {
		// Ignore AOP infrastructure such as scoped proxies.
		this.nonAnnotatedClasses.add(AopInfrastructureBean.class);
		this.nonAnnotatedClasses.add(TaskScheduler.class);
		this.nonAnnotatedClasses.add(ScheduledExecutorService.class);
	}
	@Override
	public boolean isExcluded(String beanName, BeanDefinition beanDefinition, Class<?> beanType) {
		return hasScheduledTask(beanType);
	}
	private boolean hasScheduledTask(Class<?> type) {
		Class<?> targetType = ClassUtils.getUserClass(type);
		if (!this.nonAnnotatedClasses.contains(targetType)
				&& AnnotationUtils.isCandidateClass(targetType, Arrays.asList(Scheduled.class, Schedules.class))) {
			Map<Method, Set<Scheduled>> annotatedMethods = MethodIntrospector.selectMethods(targetType,
					(MethodIntrospector.MetadataLookup<Set<Scheduled>>) (method) -> {
						Set<Scheduled> scheduledAnnotations = AnnotatedElementUtils
							.getMergedRepeatableAnnotations(method, Scheduled.class, Schedules.class);
						return (!scheduledAnnotations.isEmpty() ? scheduledAnnotations : null);
					});
			if (annotatedMethods.isEmpty()) {
				this.nonAnnotatedClasses.add(targetType);
			}
			return !annotatedMethods.isEmpty();
		}
		return false;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.task;
/*
package org.springframework.boot.autoconfigure.task;
/**
@ConditionalOnClass(ThreadPoolTaskScheduler.class)
@AutoConfiguration(after = TaskExecutionAutoConfiguration.class)
@EnableConfigurationProperties(TaskSchedulingProperties.class)
@Import({ TaskSchedulingConfigurations.ThreadPoolTaskSchedulerBuilderConfiguration.class,
		TaskSchedulingConfigurations.SimpleAsyncTaskSchedulerBuilderConfiguration.class,
		TaskSchedulingConfigurations.TaskSchedulerConfiguration.class })
public class TaskSchedulingAutoConfiguration {
	@Bean
	@ConditionalOnBean(name = TaskManagementConfigUtils.SCHEDULED_ANNOTATION_PROCESSOR_BEAN_NAME)
	public static LazyInitializationExcludeFilter scheduledBeanLazyInitializationExcludeFilter() {
		return new ScheduledBeanLazyInitializationExcludeFilter();
	}
}
/*
package org.springframework.boot.autoconfigure.task;
/**
class TaskExecutorConfigurations {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(Executor.class)
	static class TaskExecutorConfiguration {
		@Bean(name = { TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME,
				AsyncAnnotationBeanPostProcessor.DEFAULT_TASK_EXECUTOR_BEAN_NAME })
		@ConditionalOnThreading(Threading.VIRTUAL)
		SimpleAsyncTaskExecutor applicationTaskExecutorVirtualThreads(SimpleAsyncTaskExecutorBuilder builder) {
			return builder.build();
		}
		@Lazy
		@Bean(name = { TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME,
				AsyncAnnotationBeanPostProcessor.DEFAULT_TASK_EXECUTOR_BEAN_NAME })
		@ConditionalOnThreading(Threading.PLATFORM)
		ThreadPoolTaskExecutor applicationTaskExecutor(ThreadPoolTaskExecutorBuilder threadPoolTaskExecutorBuilder) {
			return threadPoolTaskExecutorBuilder.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class ThreadPoolTaskExecutorBuilderConfiguration {
		@Bean
		@ConditionalOnMissingBean(ThreadPoolTaskExecutorBuilder.class)
		ThreadPoolTaskExecutorBuilder threadPoolTaskExecutorBuilder(TaskExecutionProperties properties,
				ObjectProvider<ThreadPoolTaskExecutorCustomizer> threadPoolTaskExecutorCustomizers,
				ObjectProvider<TaskDecorator> taskDecorator) {
			TaskExecutionProperties.Pool pool = properties.getPool();
			ThreadPoolTaskExecutorBuilder builder = new ThreadPoolTaskExecutorBuilder();
			builder = builder.queueCapacity(pool.getQueueCapacity());
			builder = builder.corePoolSize(pool.getCoreSize());
			builder = builder.maxPoolSize(pool.getMaxSize());
			builder = builder.allowCoreThreadTimeOut(pool.isAllowCoreThreadTimeout());
			builder = builder.keepAlive(pool.getKeepAlive());
			builder = builder.acceptTasksAfterContextClose(pool.getShutdown().isAcceptTasksAfterContextClose());
			TaskExecutionProperties.Shutdown shutdown = properties.getShutdown();
			builder = builder.awaitTermination(shutdown.isAwaitTermination());
			builder = builder.awaitTerminationPeriod(shutdown.getAwaitTerminationPeriod());
			builder = builder.threadNamePrefix(properties.getThreadNamePrefix());
			builder = builder.customizers(threadPoolTaskExecutorCustomizers.orderedStream()::iterator);
			builder = builder.taskDecorator(taskDecorator.getIfUnique());
			return builder;
		}
	}
	@Configuration(proxyBeanMethods = false)
	static class SimpleAsyncTaskExecutorBuilderConfiguration {
		private final TaskExecutionProperties properties;
		private final ObjectProvider<SimpleAsyncTaskExecutorCustomizer> taskExecutorCustomizers;
		private final ObjectProvider<TaskDecorator> taskDecorator;
		SimpleAsyncTaskExecutorBuilderConfiguration(TaskExecutionProperties properties,
				ObjectProvider<SimpleAsyncTaskExecutorCustomizer> taskExecutorCustomizers,
				ObjectProvider<TaskDecorator> taskDecorator) {
			this.properties = properties;
			this.taskExecutorCustomizers = taskExecutorCustomizers;
			this.taskDecorator = taskDecorator;
		}
		@Bean
		@ConditionalOnMissingBean
		@ConditionalOnThreading(Threading.PLATFORM)
		SimpleAsyncTaskExecutorBuilder simpleAsyncTaskExecutorBuilder() {
			return builder();
		}
		@Bean(name = 'simpleAsyncTaskExecutorBuilder')
		@ConditionalOnMissingBean
		@ConditionalOnThreading(Threading.VIRTUAL)
		SimpleAsyncTaskExecutorBuilder simpleAsyncTaskExecutorBuilderVirtualThreads() {
			SimpleAsyncTaskExecutorBuilder builder = builder();
			builder = builder.virtualThreads(true);
			return builder;
		}
		private SimpleAsyncTaskExecutorBuilder builder() {
			SimpleAsyncTaskExecutorBuilder builder = new SimpleAsyncTaskExecutorBuilder();
			builder = builder.threadNamePrefix(this.properties.getThreadNamePrefix());
			builder = builder.customizers(this.taskExecutorCustomizers.orderedStream()::iterator);
			builder = builder.taskDecorator(this.taskDecorator.getIfUnique());
			TaskExecutionProperties.Simple simple = this.properties.getSimple();
			builder = builder.concurrencyLimit(simple.getConcurrencyLimit());
			TaskExecutionProperties.Shutdown shutdown = this.properties.getShutdown();
			if (shutdown.isAwaitTermination()) {
				builder = builder.taskTerminationTimeout(shutdown.getAwaitTerminationPeriod());
			}
			return builder;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
@AutoConfiguration(after = { DataSourceAutoConfiguration.class, HibernateJpaAutoConfiguration.class,
		LiquibaseAutoConfiguration.class, FlywayAutoConfiguration.class })
@ConditionalOnClass({ Scheduler.class, SchedulerFactoryBean.class, PlatformTransactionManager.class })
@EnableConfigurationProperties(QuartzProperties.class)
public class QuartzAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public SchedulerFactoryBean quartzScheduler(QuartzProperties properties,
			ObjectProvider<SchedulerFactoryBeanCustomizer> customizers, ObjectProvider<JobDetail> jobDetails,
			Map<String, Calendar> calendars, ObjectProvider<Trigger> triggers, ApplicationContext applicationContext) {
		SchedulerFactoryBean schedulerFactoryBean = new SchedulerFactoryBean();
		SpringBeanJobFactory jobFactory = new SpringBeanJobFactory();
		jobFactory.setApplicationContext(applicationContext);
		schedulerFactoryBean.setJobFactory(jobFactory);
		if (properties.getSchedulerName() != null) {
			schedulerFactoryBean.setSchedulerName(properties.getSchedulerName());
		}
		schedulerFactoryBean.setAutoStartup(properties.isAutoStartup());
		schedulerFactoryBean.setStartupDelay((int) properties.getStartupDelay().getSeconds());
		schedulerFactoryBean.setWaitForJobsToCompleteOnShutdown(properties.isWaitForJobsToCompleteOnShutdown());
		schedulerFactoryBean.setOverwriteExistingJobs(properties.isOverwriteExistingJobs());
		if (!properties.getProperties().isEmpty()) {
			schedulerFactoryBean.setQuartzProperties(asProperties(properties.getProperties()));
		}
		schedulerFactoryBean.setJobDetails(jobDetails.orderedStream().toArray(JobDetail[]::new));
		schedulerFactoryBean.setCalendars(calendars);
		schedulerFactoryBean.setTriggers(triggers.orderedStream().toArray(Trigger[]::new));
		customizers.orderedStream().forEach((customizer) -> customizer.customize(schedulerFactoryBean));
		return schedulerFactoryBean;
	}
	private Properties asProperties(Map<String, String> source) {
		Properties properties = new Properties();
		properties.putAll(source);
		return properties;
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(DataSource.class)
	@ConditionalOnProperty(prefix = 'spring.quartz', name = 'job-store-type', havingValue = 'jdbc')
	@Import(DatabaseInitializationDependencyConfigurer.class)
	protected static class JdbcStoreTypeConfiguration {
		@Bean
		@Order(0)
		public SchedulerFactoryBeanCustomizer dataSourceCustomizer(QuartzProperties properties, DataSource dataSource,
				@QuartzDataSource ObjectProvider<DataSource> quartzDataSource,
				ObjectProvider<PlatformTransactionManager> transactionManager,
				@QuartzTransactionManager ObjectProvider<PlatformTransactionManager> quartzTransactionManager) {
			return (schedulerFactoryBean) -> {
				DataSource dataSourceToUse = getDataSource(dataSource, quartzDataSource);
				schedulerFactoryBean.setDataSource(dataSourceToUse);
				PlatformTransactionManager txManager = getTransactionManager(transactionManager,
						quartzTransactionManager);
				if (txManager != null) {
					schedulerFactoryBean.setTransactionManager(txManager);
				}
			};
		}
		private DataSource getDataSource(DataSource dataSource, ObjectProvider<DataSource> quartzDataSource) {
			DataSource dataSourceIfAvailable = quartzDataSource.getIfAvailable();
			return (dataSourceIfAvailable != null) ? dataSourceIfAvailable : dataSource;
		}
		private PlatformTransactionManager getTransactionManager(
				ObjectProvider<PlatformTransactionManager> transactionManager,
				ObjectProvider<PlatformTransactionManager> quartzTransactionManager) {
			PlatformTransactionManager transactionManagerIfAvailable = quartzTransactionManager.getIfAvailable();
			return (transactionManagerIfAvailable != null) ? transactionManagerIfAvailable
					: transactionManager.getIfUnique();
		}
		@Bean
		@ConditionalOnMissingBean(QuartzDataSourceScriptDatabaseInitializer.class)
		@Conditional(OnQuartzDatasourceInitializationCondition.class)
		public QuartzDataSourceScriptDatabaseInitializer quartzDataSourceScriptDatabaseInitializer(
				DataSource dataSource, @QuartzDataSource ObjectProvider<DataSource> quartzDataSource,
				QuartzProperties properties) {
			DataSource dataSourceToUse = getDataSource(dataSource, quartzDataSource);
			return new QuartzDataSourceScriptDatabaseInitializer(dataSourceToUse, properties);
		}
		static class OnQuartzDatasourceInitializationCondition extends OnDatabaseInitializationCondition {
			OnQuartzDatasourceInitializationCondition() {
				super('Quartz', 'spring.quartz.jdbc.initialize-schema');
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface QuartzTransactionManager {
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
class SchedulerDependsOnDatabaseInitializationDetector
		extends AbstractBeansOfTypeDependsOnDatabaseInitializationDetector {
	@Override
	protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
		return new HashSet<>(Arrays.asList(Scheduler.class, SchedulerFactoryBean.class));
	}
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
public enum JobStoreType {
	/**
	 * Store jobs in memory.
	 */
	MEMORY,
	/**
	 * Store jobs in the database.
	 */
	JDBC
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
@FunctionalInterface
public interface SchedulerFactoryBeanCustomizer {
	/**
	 * Customize the {@link SchedulerFactoryBean}.
	 * @param schedulerFactoryBean the scheduler to customize
	 */
	void customize(SchedulerFactoryBean schedulerFactoryBean);
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
@Target({ ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Qualifier
public @interface QuartzDataSource {
}
/*
/**
package org.springframework.boot.autoconfigure.quartz;
/*
package org.springframework.boot.autoconfigure.quartz;
/**
public class QuartzDataSourceScriptDatabaseInitializer extends DataSourceScriptDatabaseInitializer {
	private final List<String> commentPrefixes;
	/**
	 * Create a new {@link QuartzDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Quartz Scheduler data source
	 * @param properties the Quartz properties
	 * @see #getSettings
	 */
	public QuartzDataSourceScriptDatabaseInitializer(DataSource dataSource, QuartzProperties properties) {
		this(dataSource, getSettings(dataSource, properties), properties.getJdbc().getCommentPrefix());
	}
	/**
	 * Create a new {@link QuartzDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Quartz Scheduler data source
	 * @param settings the database initialization settings
	 * @see #getSettings
	 */
	public QuartzDataSourceScriptDatabaseInitializer(DataSource dataSource, DatabaseInitializationSettings settings) {
		this(dataSource, settings, null);
	}
	private QuartzDataSourceScriptDatabaseInitializer(DataSource dataSource, DatabaseInitializationSettings settings,
			List<String> commentPrefixes) {
		super(dataSource, settings);
		this.commentPrefixes = commentPrefixes;
	}
	@Override
	protected void customize(ResourceDatabasePopulator populator) {
		if (!ObjectUtils.isEmpty(this.commentPrefixes)) {
			populator.setCommentPrefixes(this.commentPrefixes.toArray(new String[0]));
		}
	}
	/**
	 * Adapts {@link QuartzProperties Quartz properties} to
	 * {@link DatabaseInitializationSettings} replacing any {@literal @@platform@@}
	 * placeholders.
	 * @param dataSource the Quartz Scheduler data source
	 * @param properties the Quartz properties
	 * @return a new {@link DatabaseInitializationSettings} instance
	 * @see #QuartzDataSourceScriptDatabaseInitializer(DataSource,
	 * DatabaseInitializationSettings)
	 */
	public static DatabaseInitializationSettings getSettings(DataSource dataSource, QuartzProperties properties) {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(resolveSchemaLocations(dataSource, properties.getJdbc()));
		settings.setMode(properties.getJdbc().getInitializeSchema());
		settings.setContinueOnError(true);
		return settings;
	}
	private static List<String> resolveSchemaLocations(DataSource dataSource, QuartzProperties.Jdbc properties) {
		PlatformPlaceholderDatabaseDriverResolver platformResolver = new PlatformPlaceholderDatabaseDriverResolver();
		platformResolver = platformResolver.withDriverPlatform(DatabaseDriver.DB2, 'db2_v95');
		platformResolver = platformResolver.withDriverPlatform(DatabaseDriver.MYSQL, 'mysql_innodb');
		platformResolver = platformResolver.withDriverPlatform(DatabaseDriver.MARIADB, 'mysql_innodb');
		platformResolver = platformResolver.withDriverPlatform(DatabaseDriver.POSTGRESQL, 'postgres');
		platformResolver = platformResolver.withDriverPlatform(DatabaseDriver.SQLSERVER, 'sqlServer');
		if (StringUtils.hasText(properties.getPlatform())) {
			return platformResolver.resolveAll(properties.getPlatform(), properties.getSchema());
		}
		return platformResolver.resolveAll(dataSource, properties.getSchema());
	}
}
/*
package org.springframework.boot.autoconfigure.quartz;
/**
@ConfigurationProperties('spring.quartz')
public class QuartzProperties {
	/**
	 * Quartz job store type.
	 */
	private JobStoreType jobStoreType = JobStoreType.MEMORY;
	/**
	 * Name of the scheduler.
	 */
	private String schedulerName;
	/**
	 * Whether to automatically start the scheduler after initialization.
	 */
	private boolean autoStartup = true;
	/**
	 * Delay after which the scheduler is started once initialization completes. Setting
	 * this property makes sense if no jobs should be run before the entire application
	 * has started up.
	 */
	private Duration startupDelay = Duration.ofSeconds(0);
	/**
	 * Whether to wait for running jobs to complete on shutdown.
	 */
	private boolean waitForJobsToCompleteOnShutdown = false;
	/**
	 * Whether configured jobs should overwrite existing job definitions.
	 */
	private boolean overwriteExistingJobs = false;
	/**
	 * Additional Quartz Scheduler properties.
	 */
	private final Map<String, String> properties = new HashMap<>();
	private final Jdbc jdbc = new Jdbc();
	public JobStoreType getJobStoreType() {
		return this.jobStoreType;
	}
	public void setJobStoreType(JobStoreType jobStoreType) {
		this.jobStoreType = jobStoreType;
	}
	public String getSchedulerName() {
		return this.schedulerName;
	}
	public void setSchedulerName(String schedulerName) {
		this.schedulerName = schedulerName;
	}
	public boolean isAutoStartup() {
		return this.autoStartup;
	}
	public void setAutoStartup(boolean autoStartup) {
		this.autoStartup = autoStartup;
	}
	public Duration getStartupDelay() {
		return this.startupDelay;
	}
	public void setStartupDelay(Duration startupDelay) {
		this.startupDelay = startupDelay;
	}
	public boolean isWaitForJobsToCompleteOnShutdown() {
		return this.waitForJobsToCompleteOnShutdown;
	}
	public void setWaitForJobsToCompleteOnShutdown(boolean waitForJobsToCompleteOnShutdown) {
		this.waitForJobsToCompleteOnShutdown = waitForJobsToCompleteOnShutdown;
	}
	public boolean isOverwriteExistingJobs() {
		return this.overwriteExistingJobs;
	}
	public void setOverwriteExistingJobs(boolean overwriteExistingJobs) {
		this.overwriteExistingJobs = overwriteExistingJobs;
	}
	public Map<String, String> getProperties() {
		return this.properties;
	}
	public Jdbc getJdbc() {
		return this.jdbc;
	}
	public static class Jdbc {
		private static final String DEFAULT_SCHEMA_LOCATION = 'classpath:org/quartz/impl/'
				+ 'jdbcjobstore/tables_@@platform@@.sql';
		/**
		 * Path to the SQL file to use to initialize the database schema.
		 */
		private String schema = DEFAULT_SCHEMA_LOCATION;
		/**
		 * Platform to use in initialization scripts if the @@platform@@ placeholder is
		 * used. Auto-detected by default.
		 */
		private String platform;
		/**
		 * Database schema initialization mode.
		 */
		private DatabaseInitializationMode initializeSchema = DatabaseInitializationMode.EMBEDDED;
		/**
		 * Prefixes for single-line comments in SQL initialization scripts.
		 */
		private List<String> commentPrefix = new ArrayList<>(Arrays.asList('#', '--'));
		public String getSchema() {
			return this.schema;
		}
		public void setSchema(String schema) {
			this.schema = schema;
		}
		public String getPlatform() {
			return this.platform;
		}
		public void setPlatform(String platform) {
			this.platform = platform;
		}
		public DatabaseInitializationMode getInitializeSchema() {
			return this.initializeSchema;
		}
		public void setInitializeSchema(DatabaseInitializationMode initializeSchema) {
			this.initializeSchema = initializeSchema;
		}
		public List<String> getCommentPrefix() {
			return this.commentPrefix;
		}
		public void setCommentPrefix(List<String> commentPrefix) {
			this.commentPrefix = commentPrefix;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.codec;
/**
@ConfigurationProperties(prefix = 'spring.codec')
public class CodecProperties {
	/**
	 * Whether to log form data at DEBUG level, and headers at TRACE level.
	 */
	private boolean logRequestDetails;
	/**
	 * Limit on the number of bytes that can be buffered whenever the input stream needs
	 * to be aggregated. This applies only to the auto-configured WebFlux server and
	 * WebClient instances. By default this is not set, in which case individual codec
	 * defaults apply. Most codecs are limited to 256K by default.
	 */
	private DataSize maxInMemorySize;
	public boolean isLogRequestDetails() {
		return this.logRequestDetails;
	}
	public void setLogRequestDetails(boolean logRequestDetails) {
		this.logRequestDetails = logRequestDetails;
	}
	public DataSize getMaxInMemorySize() {
		return this.maxInMemorySize;
	}
	public void setMaxInMemorySize(DataSize maxInMemorySize) {
		this.maxInMemorySize = maxInMemorySize;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.codec;
/*
package org.springframework.boot.autoconfigure.cache;
/**
class CacheCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		String sourceClass = '';
		if (metadata instanceof ClassMetadata classMetadata) {
			sourceClass = classMetadata.getClassName();
		}
		ConditionMessage.Builder message = ConditionMessage.forCondition('Cache', sourceClass);
		Environment environment = context.getEnvironment();
		try {
			BindResult<CacheType> specified = Binder.get(environment).bind('spring.cache.type', CacheType.class);
			if (!specified.isBound()) {
				return ConditionOutcome.match(message.because('automatic cache type'));
			}
			CacheType required = CacheConfigurations.getType(((AnnotationMetadata) metadata).getClassName());
			if (specified.get() == required) {
				return ConditionOutcome.match(message.because(specified.get() + ' cache type'));
			}
		}
		catch (BindException ex) {
			// Ignore
		}
		return ConditionOutcome.noMatch(message.because('unknown cache type'));
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(SpringEmbeddedCacheManager.class)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
public class InfinispanCacheConfiguration {
	@Bean
	public SpringEmbeddedCacheManager cacheManager(CacheManagerCustomizers customizers,
			EmbeddedCacheManager embeddedCacheManager) {
		SpringEmbeddedCacheManager cacheManager = new SpringEmbeddedCacheManager(embeddedCacheManager);
		return customizers.customize(cacheManager);
	}
	@Bean(destroyMethod = 'stop')
	@ConditionalOnMissingBean
	public EmbeddedCacheManager infinispanCacheManager(CacheProperties cacheProperties,
			ObjectProvider<ConfigurationBuilder> defaultConfigurationBuilder) throws IOException {
		EmbeddedCacheManager cacheManager = createEmbeddedCacheManager(cacheProperties);
		List<String> cacheNames = cacheProperties.getCacheNames();
		if (!CollectionUtils.isEmpty(cacheNames)) {
			cacheNames.forEach((cacheName) -> cacheManager.defineConfiguration(cacheName,
					getDefaultCacheConfiguration(defaultConfigurationBuilder.getIfAvailable())));
		}
		return cacheManager;
	}
	private EmbeddedCacheManager createEmbeddedCacheManager(CacheProperties cacheProperties) throws IOException {
		Resource location = cacheProperties.resolveConfigLocation(cacheProperties.getInfinispan().getConfig());
		if (location != null) {
			try (InputStream in = location.getInputStream()) {
				return new DefaultCacheManager(in);
			}
		}
		return new DefaultCacheManager();
	}
	private org.infinispan.configuration.cache.Configuration getDefaultCacheConfiguration(
			ConfigurationBuilder defaultConfigurationBuilder) {
		if (defaultConfigurationBuilder != null) {
			return defaultConfigurationBuilder.build();
		}
		return new ConfigurationBuilder().build();
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class NoOpCacheConfiguration {
	@Bean
	NoOpCacheManager cacheManager() {
		return new NoOpCacheManager();
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
public interface Cache2kBuilderCustomizer {
	/**
	 * Customize the default cache settings.
	 * @param builder the builder to customize
	 */
	void customize(Cache2kBuilder<?, ?> builder);
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
final class CacheConfigurations {
	private static final Map<CacheType, String> MAPPINGS;
	static {
		Map<CacheType, String> mappings = new EnumMap<>(CacheType.class);
		mappings.put(CacheType.GENERIC, GenericCacheConfiguration.class.getName());
		mappings.put(CacheType.HAZELCAST, HazelcastCacheConfiguration.class.getName());
		mappings.put(CacheType.INFINISPAN, InfinispanCacheConfiguration.class.getName());
		mappings.put(CacheType.JCACHE, JCacheCacheConfiguration.class.getName());
		mappings.put(CacheType.COUCHBASE, CouchbaseCacheConfiguration.class.getName());
		mappings.put(CacheType.REDIS, RedisCacheConfiguration.class.getName());
		mappings.put(CacheType.CAFFEINE, CaffeineCacheConfiguration.class.getName());
		mappings.put(CacheType.CACHE2K, Cache2kCacheConfiguration.class.getName());
		mappings.put(CacheType.SIMPLE, SimpleCacheConfiguration.class.getName());
		mappings.put(CacheType.NONE, NoOpCacheConfiguration.class.getName());
		MAPPINGS = Collections.unmodifiableMap(mappings);
	}
	private CacheConfigurations() {
	}
	static String getConfigurationClass(CacheType cacheType) {
		String configurationClassName = MAPPINGS.get(cacheType);
		Assert.state(configurationClassName != null, () -> 'Unknown cache type ' + cacheType);
		return configurationClassName;
	}
	static CacheType getType(String configurationClassName) {
		for (Map.Entry<CacheType, String> entry : MAPPINGS.entrySet()) {
			if (entry.getValue().equals(configurationClassName)) {
				return entry.getKey();
			}
		}
		throw new IllegalStateException('Unknown configuration class ' + configurationClassName);
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisConnectionFactory.class)
@AutoConfigureAfter(RedisAutoConfiguration.class)
@ConditionalOnBean(RedisConnectionFactory.class)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class RedisCacheConfiguration {
	@Bean
	RedisCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,
			ObjectProvider<org.springframework.data.redis.cache.RedisCacheConfiguration> redisCacheConfiguration,
			ObjectProvider<RedisCacheManagerBuilderCustomizer> redisCacheManagerBuilderCustomizers,
			RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) {
		RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory)
			.cacheDefaults(
					determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));
		List<String> cacheNames = cacheProperties.getCacheNames();
		if (!cacheNames.isEmpty()) {
			builder.initialCacheNames(new LinkedHashSet<>(cacheNames));
		}
		if (cacheProperties.getRedis().isEnableStatistics()) {
			builder.enableStatistics();
		}
		redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return cacheManagerCustomizers.customize(builder.build());
	}
	private org.springframework.data.redis.cache.RedisCacheConfiguration determineConfiguration(
			CacheProperties cacheProperties,
			ObjectProvider<org.springframework.data.redis.cache.RedisCacheConfiguration> redisCacheConfiguration,
			ClassLoader classLoader) {
		return redisCacheConfiguration.getIfAvailable(() -> createConfiguration(cacheProperties, classLoader));
	}
	private org.springframework.data.redis.cache.RedisCacheConfiguration createConfiguration(
			CacheProperties cacheProperties, ClassLoader classLoader) {
		Redis redisProperties = cacheProperties.getRedis();
		org.springframework.data.redis.cache.RedisCacheConfiguration config = org.springframework.data.redis.cache.RedisCacheConfiguration
			.defaultCacheConfig();
		config = config
			.serializeValuesWith(SerializationPair.fromSerializer(new JdkSerializationRedisSerializer(classLoader)));
		if (redisProperties.getTimeToLive() != null) {
			config = config.entryTtl(redisProperties.getTimeToLive());
		}
		if (redisProperties.getKeyPrefix() != null) {
			config = config.prefixCacheNameWith(redisProperties.getKeyPrefix());
		}
		if (!redisProperties.isCacheNullValues()) {
			config = config.disableCachingNullValues();
		}
		if (!redisProperties.isUseKeyPrefix()) {
			config = config.disableKeyPrefix();
		}
		return config;
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ HazelcastInstance.class, HazelcastCacheManager.class })
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
@ConditionalOnSingleCandidate(HazelcastInstance.class)
class HazelcastCacheConfiguration {
	@Bean
	HazelcastCacheManager cacheManager(CacheManagerCustomizers customizers,
			HazelcastInstance existingHazelcastInstance) {
		HazelcastCacheManager cacheManager = new HazelcastCacheManager(existingHazelcastInstance);
		return customizers.customize(cacheManager);
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
public enum CacheType {
	/**
	 * Generic caching using "Cache" beans from the context.
	 */
	GENERIC,
	/**
	 * JCache (JSR-107) backed caching.
	 */
	JCACHE,
	/**
	 * Hazelcast backed caching.
	 */
	HAZELCAST,
	/**
	 * Couchbase backed caching.
	 */
	COUCHBASE,
	/**
	 * Infinispan backed caching.
	 */
	INFINISPAN,
	/**
	 * Redis backed caching.
	 */
	REDIS,
	/**
	 * Cache2k backed caching.
	 */
	CACHE2K,
	/**
	 * Caffeine backed caching.
	 */
	CAFFEINE,
	/**
	 * Simple in-memory caching.
	 */
	SIMPLE,
	/**
	 * No caching.
	 */
	NONE
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@FunctionalInterface
public interface JCacheManagerCustomizer {
	/**
	 * Customize the cache manager.
	 * @param cacheManager the {@code javax.cache.CacheManager} to customize
	 */
	void customize(CacheManager cacheManager);
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@AutoConfiguration(after = { CouchbaseDataAutoConfiguration.class, HazelcastAutoConfiguration.class,
		HibernateJpaAutoConfiguration.class, RedisAutoConfiguration.class })
@ConditionalOnClass(CacheManager.class)
@ConditionalOnBean(CacheAspectSupport.class)
@ConditionalOnMissingBean(value = CacheManager.class, name = 'cacheResolver')
@EnableConfigurationProperties(CacheProperties.class)
@Import({ CacheConfigurationImportSelector.class, CacheManagerEntityManagerFactoryDependsOnPostProcessor.class })
public class CacheAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public CacheManagerCustomizers cacheManagerCustomizers(ObjectProvider<CacheManagerCustomizer<?>> customizers) {
		return new CacheManagerCustomizers(customizers.orderedStream().toList());
	}
	@Bean
	public CacheManagerValidator cacheAutoConfigurationValidator(CacheProperties cacheProperties,
			ObjectProvider<CacheManager> cacheManager) {
		return new CacheManagerValidator(cacheProperties, cacheManager);
	}
	@ConditionalOnClass(LocalContainerEntityManagerFactoryBean.class)
	@ConditionalOnBean(AbstractEntityManagerFactoryBean.class)
	static class CacheManagerEntityManagerFactoryDependsOnPostProcessor
			extends EntityManagerFactoryDependsOnPostProcessor {
		CacheManagerEntityManagerFactoryDependsOnPostProcessor() {
			super('cacheManager');
		}
	}
	/**
	 * Bean used to validate that a CacheManager exists and provide a more meaningful
	 * exception.
	 */
	static class CacheManagerValidator implements InitializingBean {
		private final CacheProperties cacheProperties;
		private final ObjectProvider<CacheManager> cacheManager;
		CacheManagerValidator(CacheProperties cacheProperties, ObjectProvider<CacheManager> cacheManager) {
			this.cacheProperties = cacheProperties;
			this.cacheManager = cacheManager;
		}
		@Override
		public void afterPropertiesSet() {
			Assert.notNull(this.cacheManager.getIfAvailable(),
					() -> 'No cache manager could be auto-configured, check your configuration (caching type is "'
							+ this.cacheProperties.getType() + '")');
		}
	}
	/**
	 * {@link ImportSelector} to add {@link CacheType} configuration classes.
	 */
	static class CacheConfigurationImportSelector implements ImportSelector {
		@Override
		public String[] selectImports(AnnotationMetadata importingClassMetadata) {
			CacheType[] types = CacheType.values();
			String[] imports = new String[types.length];
			for (int i = 0; i < types.length; i++) {
				imports[i] = CacheConfigurations.getConfigurationClass(types[i]);
			}
			return imports;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(HazelcastInstance.class)
class HazelcastJCacheCustomizationConfiguration {
	@Bean
	HazelcastPropertiesCustomizer hazelcastPropertiesCustomizer(ObjectProvider<HazelcastInstance> hazelcastInstance,
			CacheProperties cacheProperties) {
		return new HazelcastPropertiesCustomizer(hazelcastInstance.getIfUnique(), cacheProperties);
	}
	static class HazelcastPropertiesCustomizer implements JCachePropertiesCustomizer {
		private final HazelcastInstance hazelcastInstance;
		private final CacheProperties cacheProperties;
		HazelcastPropertiesCustomizer(HazelcastInstance hazelcastInstance, CacheProperties cacheProperties) {
			this.hazelcastInstance = hazelcastInstance;
			this.cacheProperties = cacheProperties;
		}
		@Override
		public void customize(Properties properties) {
			Resource configLocation = this.cacheProperties
				.resolveConfigLocation(this.cacheProperties.getJcache().getConfig());
			if (configLocation != null) {
				// Hazelcast does not use the URI as a mean to specify a custom config.
				properties.setProperty('hazelcast.config.location', toUri(configLocation).toString());
			}
			else if (this.hazelcastInstance != null) {
				properties.put('hazelcast.instance.itself', this.hazelcastInstance);
			}
		}
		private static URI toUri(Resource config) {
			try {
				return config.getURI();
			}
			catch (IOException ex) {
				throw new IllegalArgumentException('Could not get URI from ' + config, ex);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@FunctionalInterface
public interface RedisCacheManagerBuilderCustomizer {
	/**
	 * Customize the {@link RedisCacheManagerBuilder}.
	 * @param builder the builder to customize
	 */
	void customize(RedisCacheManagerBuilder builder);
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
public interface JCachePropertiesCustomizer {
	/**
	 * Customize the properties.
	 * @param properties the current properties
	 */
	void customize(Properties properties);
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@ConfigurationProperties(prefix = 'spring.cache')
public class CacheProperties {
	/**
	 * Cache type. By default, auto-detected according to the environment.
	 */
	private CacheType type;
	/**
	 * List of cache names to create if supported by the underlying cache manager.
	 * Usually, this disables the ability to create additional caches on-the-fly.
	 */
	private List<String> cacheNames = new ArrayList<>();
	private final Caffeine caffeine = new Caffeine();
	private final Couchbase couchbase = new Couchbase();
	private final Infinispan infinispan = new Infinispan();
	private final JCache jcache = new JCache();
	private final Redis redis = new Redis();
	public CacheType getType() {
		return this.type;
	}
	public void setType(CacheType mode) {
		this.type = mode;
	}
	public List<String> getCacheNames() {
		return this.cacheNames;
	}
	public void setCacheNames(List<String> cacheNames) {
		this.cacheNames = cacheNames;
	}
	public Caffeine getCaffeine() {
		return this.caffeine;
	}
	public Couchbase getCouchbase() {
		return this.couchbase;
	}
	public Infinispan getInfinispan() {
		return this.infinispan;
	}
	public JCache getJcache() {
		return this.jcache;
	}
	public Redis getRedis() {
		return this.redis;
	}
	/**
	 * Resolve the config location if set.
	 * @param config the config resource
	 * @return the location or {@code null} if it is not set
	 * @throws IllegalArgumentException if the config attribute is set to an unknown
	 * location
	 */
	public Resource resolveConfigLocation(Resource config) {
		if (config != null) {
			Assert.isTrue(config.exists(),
					() -> 'Cache configuration does not exist "' + config.getDescription() + '"');
			return config;
		}
		return null;
	}
	/**
	 * Caffeine specific cache properties.
	 */
	public static class Caffeine {
		/**
		 * The spec to use to create caches. See CaffeineSpec for more details on the spec
		 * format.
		 */
		private String spec;
		public String getSpec() {
			return this.spec;
		}
		public void setSpec(String spec) {
			this.spec = spec;
		}
	}
	/**
	 * Couchbase specific cache properties.
	 */
	public static class Couchbase {
		/**
		 * Entry expiration. By default the entries never expire. Note that this value is
		 * ultimately converted to seconds.
		 */
		private Duration expiration;
		public Duration getExpiration() {
			return this.expiration;
		}
		public void setExpiration(Duration expiration) {
			this.expiration = expiration;
		}
	}
	/**
	 * Infinispan specific cache properties.
	 */
	public static class Infinispan {
		/**
		 * The location of the configuration file to use to initialize Infinispan.
		 */
		private Resource config;
		public Resource getConfig() {
			return this.config;
		}
		public void setConfig(Resource config) {
			this.config = config;
		}
	}
	/**
	 * JCache (JSR-107) specific cache properties.
	 */
	public static class JCache {
		/**
		 * The location of the configuration file to use to initialize the cache manager.
		 * The configuration file is dependent of the underlying cache implementation.
		 */
		private Resource config;
		/**
		 * Fully qualified name of the CachingProvider implementation to use to retrieve
		 * the JSR-107 compliant cache manager. Needed only if more than one JSR-107
		 * implementation is available on the classpath.
		 */
		private String provider;
		public String getProvider() {
			return this.provider;
		}
		public void setProvider(String provider) {
			this.provider = provider;
		}
		public Resource getConfig() {
			return this.config;
		}
		public void setConfig(Resource config) {
			this.config = config;
		}
	}
	/**
	 * Redis-specific cache properties.
	 */
	public static class Redis {
		/**
		 * Entry expiration. By default the entries never expire.
		 */
		private Duration timeToLive;
		/**
		 * Allow caching null values.
		 */
		private boolean cacheNullValues = true;
		/**
		 * Key prefix.
		 */
		private String keyPrefix;
		/**
		 * Whether to use the key prefix when writing to Redis.
		 */
		private boolean useKeyPrefix = true;
		/**
		 * Whether to enable cache statistics.
		 */
		private boolean enableStatistics;
		public Duration getTimeToLive() {
			return this.timeToLive;
		}
		public void setTimeToLive(Duration timeToLive) {
			this.timeToLive = timeToLive;
		}
		public boolean isCacheNullValues() {
			return this.cacheNullValues;
		}
		public void setCacheNullValues(boolean cacheNullValues) {
			this.cacheNullValues = cacheNullValues;
		}
		public String getKeyPrefix() {
			return this.keyPrefix;
		}
		public void setKeyPrefix(String keyPrefix) {
			this.keyPrefix = keyPrefix;
		}
		public boolean isUseKeyPrefix() {
			return this.useKeyPrefix;
		}
		public void setUseKeyPrefix(boolean useKeyPrefix) {
			this.useKeyPrefix = useKeyPrefix;
		}
		public boolean isEnableStatistics() {
			return this.enableStatistics;
		}
		public void setEnableStatistics(boolean enableStatistics) {
			this.enableStatistics = enableStatistics;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
public class CacheManagerCustomizers {
	private final List<CacheManagerCustomizer<?>> customizers;
	public CacheManagerCustomizers(List<? extends CacheManagerCustomizer<?>> customizers) {
		this.customizers = (customizers != null) ? new ArrayList<>(customizers) : Collections.emptyList();
	}
	/**
	 * Customize the specified {@link CacheManager}. Locates all
	 * {@link CacheManagerCustomizer} beans able to handle the specified instance and
	 * invoke {@link CacheManagerCustomizer#customize(CacheManager)} on them.
	 * @param <T> the type of cache manager
	 * @param cacheManager the cache manager to customize
	 * @return the cache manager
	 */
	@SuppressWarnings('unchecked')
	public <T extends CacheManager> T customize(T cacheManager) {
		LambdaSafe.callbacks(CacheManagerCustomizer.class, this.customizers, cacheManager)
			.withLogger(CacheManagerCustomizers.class)
			.invoke((customizer) -> customizer.customize(cacheManager));
		return cacheManager;
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ Cache2kBuilder.class, SpringCache2kCacheManager.class })
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class Cache2kCacheConfiguration {
	@Bean
	SpringCache2kCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers customizers,
			ObjectProvider<Cache2kBuilderCustomizer> cache2kBuilderCustomizers) {
		SpringCache2kCacheManager cacheManager = new SpringCache2kCacheManager();
		cacheManager.defaultSetup(configureDefaults(cache2kBuilderCustomizers));
		Collection<String> cacheNames = cacheProperties.getCacheNames();
		if (!CollectionUtils.isEmpty(cacheNames)) {
			cacheManager.setDefaultCacheNames(cacheNames);
		}
		return customizers.customize(cacheManager);
	}
	private Function<Cache2kBuilder<?, ?>, Cache2kBuilder<?, ?>> configureDefaults(
			ObjectProvider<Cache2kBuilderCustomizer> cache2kBuilderCustomizers) {
		return (builder) -> {
			cache2kBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
			return builder;
		};
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ Caching.class, JCacheCacheManager.class })
@ConditionalOnMissingBean(org.springframework.cache.CacheManager.class)
@Conditional({ CacheCondition.class, JCacheCacheConfiguration.JCacheAvailableCondition.class })
@Import(HazelcastJCacheCustomizationConfiguration.class)
class JCacheCacheConfiguration implements BeanClassLoaderAware {
	private ClassLoader beanClassLoader;
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.beanClassLoader = classLoader;
	}
	@Bean
	JCacheCacheManager cacheManager(CacheManagerCustomizers customizers, CacheManager jCacheCacheManager) {
		JCacheCacheManager cacheManager = new JCacheCacheManager(jCacheCacheManager);
		return customizers.customize(cacheManager);
	}
	@Bean
	@ConditionalOnMissingBean
	CacheManager jCacheCacheManager(CacheProperties cacheProperties,
			ObjectProvider<javax.cache.configuration.Configuration<?, ?>> defaultCacheConfiguration,
			ObjectProvider<JCacheManagerCustomizer> cacheManagerCustomizers,
			ObjectProvider<JCachePropertiesCustomizer> cachePropertiesCustomizers) throws IOException {
		CacheManager jCacheCacheManager = createCacheManager(cacheProperties, cachePropertiesCustomizers);
		List<String> cacheNames = cacheProperties.getCacheNames();
		if (!CollectionUtils.isEmpty(cacheNames)) {
			for (String cacheName : cacheNames) {
				jCacheCacheManager.createCache(cacheName,
						defaultCacheConfiguration.getIfAvailable(MutableConfiguration::new));
			}
		}
		cacheManagerCustomizers.orderedStream().forEach((customizer) -> customizer.customize(jCacheCacheManager));
		return jCacheCacheManager;
	}
	private CacheManager createCacheManager(CacheProperties cacheProperties,
			ObjectProvider<JCachePropertiesCustomizer> cachePropertiesCustomizers) throws IOException {
		CachingProvider cachingProvider = getCachingProvider(cacheProperties.getJcache().getProvider());
		Properties properties = createCacheManagerProperties(cachePropertiesCustomizers);
		Resource configLocation = cacheProperties.resolveConfigLocation(cacheProperties.getJcache().getConfig());
		if (configLocation != null) {
			return cachingProvider.getCacheManager(configLocation.getURI(), this.beanClassLoader, properties);
		}
		return cachingProvider.getCacheManager(null, this.beanClassLoader, properties);
	}
	private CachingProvider getCachingProvider(String cachingProviderFqn) {
		if (StringUtils.hasText(cachingProviderFqn)) {
			return Caching.getCachingProvider(cachingProviderFqn);
		}
		return Caching.getCachingProvider();
	}
	private Properties createCacheManagerProperties(
			ObjectProvider<JCachePropertiesCustomizer> cachePropertiesCustomizers) {
		Properties properties = new Properties();
		cachePropertiesCustomizers.orderedStream().forEach((customizer) -> customizer.customize(properties));
		return properties;
	}
	/**
	 * Determine if JCache is available. This either kicks in if a provider is available
	 * as defined per {@link JCacheProviderAvailableCondition} or if a
	 * {@link CacheManager} has already been defined.
	 */
	@Order(Ordered.LOWEST_PRECEDENCE)
	static class JCacheAvailableCondition extends AnyNestedCondition {
		JCacheAvailableCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@Conditional(JCacheProviderAvailableCondition.class)
		static class JCacheProvider {
		}
		@ConditionalOnSingleCandidate(CacheManager.class)
		static class CustomJCacheCacheManager {
		}
	}
	/**
	 * Determine if a JCache provider is available. This either kicks in if a default
	 * {@link CachingProvider} has been found or if the property referring to the provider
	 * to use has been set.
	 */
	@Order(Ordered.LOWEST_PRECEDENCE)
	static class JCacheProviderAvailableCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('JCache');
			String providerProperty = 'spring.cache.jcache.provider';
			if (context.getEnvironment().containsProperty(providerProperty)) {
				return ConditionOutcome.match(message.because('JCache provider specified'));
			}
			Iterator<CachingProvider> providers = Caching.getCachingProviders().iterator();
			if (!providers.hasNext()) {
				return ConditionOutcome.noMatch(message.didNotFind('JSR-107 provider').atAll());
			}
			providers.next();
			if (providers.hasNext()) {
				return ConditionOutcome.noMatch(message.foundExactly('multiple JSR-107 providers'));
			}
			return ConditionOutcome.match(message.foundExactly('single JSR-107 provider'));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean(Cache.class)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class GenericCacheConfiguration {
	@Bean
	SimpleCacheManager cacheManager(CacheManagerCustomizers customizers, Collection<Cache> caches) {
		SimpleCacheManager cacheManager = new SimpleCacheManager();
		cacheManager.setCaches(caches);
		return customizers.customize(cacheManager);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.cache;
/*
package org.springframework.boot.autoconfigure.cache;
/**
@FunctionalInterface
public interface CouchbaseCacheManagerBuilderCustomizer {
	/**
	 * Customize the {@link CouchbaseCacheManagerBuilder}.
	 * @param builder the builder to customize
	 */
	void customize(CouchbaseCacheManagerBuilder builder);
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ Caffeine.class, CaffeineCacheManager.class })
@ConditionalOnMissingBean(CacheManager.class)
@Conditional({ CacheCondition.class })
class CaffeineCacheConfiguration {
	@Bean
	CaffeineCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers customizers,
			ObjectProvider<Caffeine<Object, Object>> caffeine, ObjectProvider<CaffeineSpec> caffeineSpec,
			ObjectProvider<CacheLoader<Object, Object>> cacheLoader) {
		CaffeineCacheManager cacheManager = createCacheManager(cacheProperties, caffeine, caffeineSpec, cacheLoader);
		List<String> cacheNames = cacheProperties.getCacheNames();
		if (!CollectionUtils.isEmpty(cacheNames)) {
			cacheManager.setCacheNames(cacheNames);
		}
		return customizers.customize(cacheManager);
	}
	private CaffeineCacheManager createCacheManager(CacheProperties cacheProperties,
			ObjectProvider<Caffeine<Object, Object>> caffeine, ObjectProvider<CaffeineSpec> caffeineSpec,
			ObjectProvider<CacheLoader<Object, Object>> cacheLoader) {
		CaffeineCacheManager cacheManager = new CaffeineCacheManager();
		setCacheBuilder(cacheProperties, caffeineSpec.getIfAvailable(), caffeine.getIfAvailable(), cacheManager);
		cacheLoader.ifAvailable(cacheManager::setCacheLoader);
		return cacheManager;
	}
	private void setCacheBuilder(CacheProperties cacheProperties, CaffeineSpec caffeineSpec,
			Caffeine<Object, Object> caffeine, CaffeineCacheManager cacheManager) {
		String specification = cacheProperties.getCaffeine().getSpec();
		if (StringUtils.hasText(specification)) {
			cacheManager.setCacheSpecification(specification);
		}
		else if (caffeineSpec != null) {
			cacheManager.setCaffeineSpec(caffeineSpec);
		}
		else if (caffeine != null) {
			cacheManager.setCaffeine(caffeine);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@FunctionalInterface
public interface CacheManagerCustomizer<T extends CacheManager> {
	/**
	 * Customize the cache manager.
	 * @param cacheManager the {@code CacheManager} to customize
	 */
	void customize(T cacheManager);
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class SimpleCacheConfiguration {
	@Bean
	ConcurrentMapCacheManager cacheManager(CacheProperties cacheProperties,
			CacheManagerCustomizers cacheManagerCustomizers) {
		ConcurrentMapCacheManager cacheManager = new ConcurrentMapCacheManager();
		List<String> cacheNames = cacheProperties.getCacheNames();
		if (!cacheNames.isEmpty()) {
			cacheManager.setCacheNames(cacheNames);
		}
		return cacheManagerCustomizers.customize(cacheManager);
	}
}
/*
package org.springframework.boot.autoconfigure.cache;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ Cluster.class, CouchbaseClientFactory.class, CouchbaseCacheManager.class })
@ConditionalOnMissingBean(CacheManager.class)
@ConditionalOnSingleCandidate(CouchbaseClientFactory.class)
@Conditional(CacheCondition.class)
class CouchbaseCacheConfiguration {
	@Bean
	CouchbaseCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers customizers,
			ObjectProvider<CouchbaseCacheManagerBuilderCustomizer> couchbaseCacheManagerBuilderCustomizers,
			CouchbaseClientFactory clientFactory) {
		List<String> cacheNames = cacheProperties.getCacheNames();
		CouchbaseCacheManagerBuilder builder = CouchbaseCacheManager.builder(clientFactory);
		Couchbase couchbase = cacheProperties.getCouchbase();
		org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration config = org.springframework.data.couchbase.cache.CouchbaseCacheConfiguration
			.defaultCacheConfig();
		if (couchbase.getExpiration() != null) {
			config = config.entryExpiry(couchbase.getExpiration());
		}
		builder.cacheDefaults(config);
		if (!ObjectUtils.isEmpty(cacheNames)) {
			builder.initialCacheNames(new LinkedHashSet<>(cacheNames));
		}
		couchbaseCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		CouchbaseCacheManager cacheManager = builder.build();
		return customizers.customize(cacheManager);
	}
}
/*
package org.springframework.boot.autoconfigure.transaction.jta;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(JtaTransactionManager.class)
@ConditionalOnJndi({ JtaTransactionManager.DEFAULT_USER_TRANSACTION_NAME, 'java:comp/TransactionManager',
		'java:appserver/TransactionManager', 'java:pm/TransactionManager', 'java:/TransactionManager' })
@ConditionalOnMissingBean(org.springframework.transaction.TransactionManager.class)
class JndiJtaConfiguration {
	@Bean
	JtaTransactionManager transactionManager(
			ObjectProvider<TransactionManagerCustomizers> transactionManagerCustomizers) {
		JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
		transactionManagerCustomizers.ifAvailable((customizers) -> customizers.customize(jtaTransactionManager));
		return jtaTransactionManager;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.transaction.jta;
/*
package org.springframework.boot.autoconfigure.transaction.jta;
/**
@AutoConfiguration(before = { XADataSourceAutoConfiguration.class, ActiveMQAutoConfiguration.class,
		ArtemisAutoConfiguration.class, HibernateJpaAutoConfiguration.class, TransactionAutoConfiguration.class,
		TransactionManagerCustomizationAutoConfiguration.class })
@ConditionalOnClass(jakarta.transaction.Transaction.class)
@ConditionalOnProperty(prefix = 'spring.jta', value = 'enabled', matchIfMissing = true)
@Import(JndiJtaConfiguration.class)
public class JtaAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
@AutoConfiguration
@ConditionalOnClass(PlatformTransactionManager.class)
public class TransactionAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnSingleCandidate(ReactiveTransactionManager.class)
	public TransactionalOperator transactionalOperator(ReactiveTransactionManager transactionManager) {
		return TransactionalOperator.create(transactionManager);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnSingleCandidate(PlatformTransactionManager.class)
	public static class TransactionTemplateConfiguration {
		@Bean
		@ConditionalOnMissingBean(TransactionOperations.class)
		public TransactionTemplate transactionTemplate(PlatformTransactionManager transactionManager) {
			return new TransactionTemplate(transactionManager);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(TransactionManager.class)
	@ConditionalOnMissingBean(AbstractTransactionManagementConfiguration.class)
	public static class EnableTransactionManagementConfiguration {
		@Configuration(proxyBeanMethods = false)
		@EnableTransactionManagement(proxyTargetClass = false)
		@ConditionalOnProperty(prefix = 'spring.aop', name = 'proxy-target-class', havingValue = 'false')
		public static class JdkDynamicAutoProxyConfiguration {
		}
		@Configuration(proxyBeanMethods = false)
		@EnableTransactionManagement(proxyTargetClass = true)
		@ConditionalOnProperty(prefix = 'spring.aop', name = 'proxy-target-class', havingValue = 'true',
				matchIfMissing = true)
		public static class CglibAutoProxyConfiguration {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(AbstractTransactionAspect.class)
	static class AspectJTransactionManagementConfiguration {
		@Bean
		static LazyInitializationExcludeFilter eagerTransactionAspect() {
			return LazyInitializationExcludeFilter.forBeanTypes(AbstractTransactionAspect.class);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
public interface TransactionManagerCustomizer<T extends TransactionManager> {
	/**
	 * Customize the given transaction manager.
	 * @param transactionManager the transaction manager to customize
	 */
	void customize(T transactionManager);
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
@ConditionalOnClass(PlatformTransactionManager.class)
@AutoConfiguration(before = TransactionAutoConfiguration.class)
@EnableConfigurationProperties(TransactionProperties.class)
public class TransactionManagerCustomizationAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	TransactionManagerCustomizers platformTransactionManagerCustomizers(
			ObjectProvider<TransactionManagerCustomizer<?>> customizers) {
		return TransactionManagerCustomizers.of(customizers.orderedStream().toList());
	}
	@Bean
	ExecutionListenersTransactionManagerCustomizer transactionExecutionListeners(
			ObjectProvider<TransactionExecutionListener> listeners) {
		return new ExecutionListenersTransactionManagerCustomizer(listeners.orderedStream().toList());
	}
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
public final class TransactionManagerCustomizers {
	private final List<? extends TransactionManagerCustomizer<?>> customizers;
	private TransactionManagerCustomizers(List<? extends TransactionManagerCustomizer<?>> customizers) {
		this.customizers = customizers;
	}
	/**
	 * Customize the given {@code transactionManager}.
	 * @param transactionManager the transaction manager to customize
	 * @since 3.2.0
	 */
	@SuppressWarnings('unchecked')
	public void customize(TransactionManager transactionManager) {
		LambdaSafe.callbacks(TransactionManagerCustomizer.class, this.customizers, transactionManager)
			.withLogger(TransactionManagerCustomizers.class)
			.invoke((customizer) -> customizer.customize(transactionManager));
	}
	/**
	 * Returns a new {@code TransactionManagerCustomizers} instance containing the given
	 * {@code customizers}.
	 * @param customizers the customizers
	 * @return the new instance
	 * @since 3.2.0
	 */
	public static TransactionManagerCustomizers of(Collection<? extends TransactionManagerCustomizer<?>> customizers) {
		return new TransactionManagerCustomizers(
				(customizers != null) ? new ArrayList<>(customizers) : Collections.emptyList());
	}
}
/*
package org.springframework.boot.autoconfigure.transaction;
/**
@ConfigurationProperties(prefix = 'spring.transaction')
public class TransactionProperties implements TransactionManagerCustomizer<AbstractPlatformTransactionManager> {
	/**
	 * Default transaction timeout. If a duration suffix is not specified, seconds will be
	 * used.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration defaultTimeout;
	/**
	 * Whether to roll back on commit failures.
	 */
	private Boolean rollbackOnCommitFailure;
	public Duration getDefaultTimeout() {
		return this.defaultTimeout;
	}
	public void setDefaultTimeout(Duration defaultTimeout) {
		this.defaultTimeout = defaultTimeout;
	}
	public Boolean getRollbackOnCommitFailure() {
		return this.rollbackOnCommitFailure;
	}
	public void setRollbackOnCommitFailure(Boolean rollbackOnCommitFailure) {
		this.rollbackOnCommitFailure = rollbackOnCommitFailure;
	}
	@Override
	public void customize(AbstractPlatformTransactionManager transactionManager) {
		if (this.defaultTimeout != null) {
			transactionManager.setDefaultTimeout((int) this.defaultTimeout.getSeconds());
		}
		if (this.rollbackOnCommitFailure != null) {
			transactionManager.setRollbackOnCommitFailure(this.rollbackOnCommitFailure);
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.transaction;
/*
package org.springframework.boot.autoconfigure.transaction;
/**
class ExecutionListenersTransactionManagerCustomizer
		implements TransactionManagerCustomizer<ConfigurableTransactionManager> {
	private final List<TransactionExecutionListener> listeners;
	ExecutionListenersTransactionManagerCustomizer(List<TransactionExecutionListener> listeners) {
		this.listeners = listeners;
	}
	@Override
	public void customize(ConfigurableTransactionManager transactionManager) {
		this.listeners.forEach(transactionManager::addListener);
	}
}
/*
package org.springframework.boot.autoconfigure.thread;
/**
public enum Threading {
	/**
	 * Platform threads. Active if virtual threads are not active.
	 */
	PLATFORM {
		@Override
		public boolean isActive(Environment environment) {
			return !VIRTUAL.isActive(environment);
		}
	},
	/**
	 * Virtual threads. Active if {@code spring.threads.virtual.enabled} is {@code true}
	 * and running on Java 21 or later.
	 */
	VIRTUAL {
		@Override
		public boolean isActive(Environment environment) {
			return environment.getProperty('spring.threads.virtual.enabled', boolean.class, false)
					&& JavaVersion.getJavaVersion().isEqualOrNewerThan(JavaVersion.TWENTY_ONE);
		}
	};
	/**
	 * Determines whether the threading is active.
	 * @param environment the environment
	 * @return whether the threading is active
	 */
	public abstract boolean isActive(Environment environment);
}
/*
/**
package org.springframework.boot.autoconfigure.thread;
/*
package org.springframework.boot.autoconfigure.web;
/**
class OnEnabledResourceChainCondition extends SpringBootCondition {
	private static final String WEBJAR_ASSET_LOCATOR = 'org.webjars.WebJarAssetLocator';
	private static final String WEBJAR_VERSION_LOCATOR = 'org.webjars.WebJarVersionLocator';
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConfigurableEnvironment environment = (ConfigurableEnvironment) context.getEnvironment();
		boolean fixed = getEnabledProperty(environment, 'strategy.fixed.', false);
		boolean content = getEnabledProperty(environment, 'strategy.content.', false);
		Boolean chain = getEnabledProperty(environment, '', null);
		Boolean match = Chain.getEnabled(fixed, content, chain);
		ConditionMessage.Builder message = ConditionMessage.forCondition(ConditionalOnEnabledResourceChain.class);
		if (match == null) {
			if (ClassUtils.isPresent(WEBJAR_VERSION_LOCATOR, getClass().getClassLoader())) {
				return ConditionOutcome.match(message.found('class').items(WEBJAR_VERSION_LOCATOR));
			}
			if (ClassUtils.isPresent(WEBJAR_ASSET_LOCATOR, getClass().getClassLoader())) {
				return ConditionOutcome.match(message.found('class').items(WEBJAR_ASSET_LOCATOR));
			}
			return ConditionOutcome.noMatch(message.didNotFind('class').items(WEBJAR_VERSION_LOCATOR));
		}
		if (match) {
			return ConditionOutcome.match(message.because('enabled'));
		}
		return ConditionOutcome.noMatch(message.because('disabled'));
	}
	private Boolean getEnabledProperty(ConfigurableEnvironment environment, String key, Boolean defaultValue) {
		String name = 'spring.web.resources.chain.' + key + 'enabled';
		return environment.getProperty(name, Boolean.class, defaultValue);
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
public class TomcatWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableTomcatWebServerFactory>, Ordered {
	static final int ORDER = 0;
	private final Environment environment;
	private final ServerProperties serverProperties;
	public TomcatWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
		this.environment = environment;
		this.serverProperties = serverProperties;
	}
	@Override
	public int getOrder() {
		return ORDER;
	}
	@Override
	@SuppressWarnings('removal')
	public void customize(ConfigurableTomcatWebServerFactory factory) {
		ServerProperties.Tomcat properties = this.serverProperties.getTomcat();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getBasedir).to(factory::setBaseDirectory);
		map.from(properties::getBackgroundProcessorDelay)
			.as(Duration::getSeconds)
			.as(Long::intValue)
			.to(factory::setBackgroundProcessorDelay);
		customizeRemoteIpValve(factory);
		ServerProperties.Tomcat.Threads threadProperties = properties.getThreads();
		map.from(threadProperties::getMax)
			.when(this::isPositive)
			.to((maxThreads) -> customizeMaxThreads(factory, maxThreads));
		map.from(threadProperties::getMinSpare)
			.when(this::isPositive)
			.to((minSpareThreads) -> customizeMinThreads(factory, minSpareThreads));
		map.from(threadProperties::getMaxQueueCapacity)
			.when(this::isPositive)
			.to((maxQueueCapacity) -> customizeMaxQueueCapacity(factory, maxQueueCapacity));
		map.from(this.serverProperties.getMaxHttpRequestHeaderSize())
			.asInt(DataSize::toBytes)
			.when(this::isPositive)
			.to((maxHttpRequestHeaderSize) -> customizeMaxHttpRequestHeaderSize(factory, maxHttpRequestHeaderSize));
		map.from(properties::getMaxHttpResponseHeaderSize)
			.asInt(DataSize::toBytes)
			.when(this::isPositive)
			.to((maxHttpResponseHeaderSize) -> customizeMaxHttpResponseHeaderSize(factory, maxHttpResponseHeaderSize));
		map.from(properties::getMaxSwallowSize)
			.asInt(DataSize::toBytes)
			.to((maxSwallowSize) -> customizeMaxSwallowSize(factory, maxSwallowSize));
		map.from(properties::getMaxHttpFormPostSize)
			.asInt(DataSize::toBytes)
			.when((maxHttpFormPostSize) -> maxHttpFormPostSize != 0)
			.to((maxHttpFormPostSize) -> customizeMaxHttpFormPostSize(factory, maxHttpFormPostSize));
		map.from(properties::getAccesslog)
			.when(ServerProperties.Tomcat.Accesslog::isEnabled)
			.to((enabled) -> customizeAccessLog(factory));
		map.from(properties::getUriEncoding).to(factory::setUriEncoding);
		map.from(properties::getConnectionTimeout)
			.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
		map.from(properties::getMaxConnections)
			.when(this::isPositive)
			.to((maxConnections) -> customizeMaxConnections(factory, maxConnections));
		map.from(properties::getAcceptCount)
			.when(this::isPositive)
			.to((acceptCount) -> customizeAcceptCount(factory, acceptCount));
		map.from(properties::getProcessorCache)
			.to((processorCache) -> customizeProcessorCache(factory, processorCache));
		map.from(properties::getKeepAliveTimeout)
			.to((keepAliveTimeout) -> customizeKeepAliveTimeout(factory, keepAliveTimeout));
		map.from(properties::getMaxKeepAliveRequests)
			.to((maxKeepAliveRequests) -> customizeMaxKeepAliveRequests(factory, maxKeepAliveRequests));
		map.from(properties::getRelaxedPathChars)
			.as(this::joinCharacters)
			.whenHasText()
			.to((relaxedChars) -> customizeRelaxedPathChars(factory, relaxedChars));
		map.from(properties::getRelaxedQueryChars)
			.as(this::joinCharacters)
			.whenHasText()
			.to((relaxedChars) -> customizeRelaxedQueryChars(factory, relaxedChars));
		customizeStaticResources(factory);
		customizeErrorReportValve(this.serverProperties.getError(), factory);
	}
	private boolean isPositive(int value) {
		return value > 0;
	}
	@SuppressWarnings('rawtypes')
	private void customizeMaxThreads(ConfigurableTomcatWebServerFactory factory, int maxThreads) {
		customizeHandler(factory, maxThreads, AbstractProtocol.class, AbstractProtocol::setMaxThreads);
	}
	@SuppressWarnings('rawtypes')
	private void customizeMinThreads(ConfigurableTomcatWebServerFactory factory, int minSpareThreads) {
		customizeHandler(factory, minSpareThreads, AbstractProtocol.class, AbstractProtocol::setMinSpareThreads);
	}
	@SuppressWarnings('rawtypes')
	private void customizeMaxQueueCapacity(ConfigurableTomcatWebServerFactory factory, int maxQueueCapacity) {
		customizeHandler(factory, maxQueueCapacity, AbstractProtocol.class, AbstractProtocol::setMaxQueueSize);
	}
	@SuppressWarnings('rawtypes')
	private void customizeAcceptCount(ConfigurableTomcatWebServerFactory factory, int acceptCount) {
		customizeHandler(factory, acceptCount, AbstractProtocol.class, AbstractProtocol::setAcceptCount);
	}
	@SuppressWarnings('rawtypes')
	private void customizeProcessorCache(ConfigurableTomcatWebServerFactory factory, int processorCache) {
		customizeHandler(factory, processorCache, AbstractProtocol.class, AbstractProtocol::setProcessorCache);
	}
	private void customizeKeepAliveTimeout(ConfigurableTomcatWebServerFactory factory, Duration keepAliveTimeout) {
		factory.addConnectorCustomizers((connector) -> {
			ProtocolHandler handler = connector.getProtocolHandler();
			for (UpgradeProtocol upgradeProtocol : handler.findUpgradeProtocols()) {
				if (upgradeProtocol instanceof Http2Protocol protocol) {
					protocol.setKeepAliveTimeout(keepAliveTimeout.toMillis());
				}
			}
			if (handler instanceof AbstractProtocol<?> protocol) {
				protocol.setKeepAliveTimeout((int) keepAliveTimeout.toMillis());
			}
		});
	}
	@SuppressWarnings('rawtypes')
	private void customizeMaxKeepAliveRequests(ConfigurableTomcatWebServerFactory factory, int maxKeepAliveRequests) {
		customizeHandler(factory, maxKeepAliveRequests, AbstractHttp11Protocol.class,
				AbstractHttp11Protocol::setMaxKeepAliveRequests);
	}
	@SuppressWarnings('rawtypes')
	private void customizeMaxConnections(ConfigurableTomcatWebServerFactory factory, int maxConnections) {
		customizeHandler(factory, maxConnections, AbstractProtocol.class, AbstractProtocol::setMaxConnections);
	}
	@SuppressWarnings('rawtypes')
	private void customizeConnectionTimeout(ConfigurableTomcatWebServerFactory factory, Duration connectionTimeout) {
		customizeHandler(factory, (int) connectionTimeout.toMillis(), AbstractProtocol.class,
				AbstractProtocol::setConnectionTimeout);
	}
	private void customizeRelaxedPathChars(ConfigurableTomcatWebServerFactory factory, String relaxedChars) {
		factory.addConnectorCustomizers((connector) -> connector.setProperty('relaxedPathChars', relaxedChars));
	}
	private void customizeRelaxedQueryChars(ConfigurableTomcatWebServerFactory factory, String relaxedChars) {
		factory.addConnectorCustomizers((connector) -> connector.setProperty('relaxedQueryChars', relaxedChars));
	}
	private String joinCharacters(List<Character> content) {
		return content.stream().map(String::valueOf).collect(Collectors.joining());
	}
	private void customizeRemoteIpValve(ConfigurableTomcatWebServerFactory factory) {
		Remoteip remoteIpProperties = this.serverProperties.getTomcat().getRemoteip();
		String protocolHeader = remoteIpProperties.getProtocolHeader();
		String remoteIpHeader = remoteIpProperties.getRemoteIpHeader();
		// For back compatibility the valve is also enabled if protocol-header is set
		if (StringUtils.hasText(protocolHeader) || StringUtils.hasText(remoteIpHeader)
				|| getOrDeduceUseForwardHeaders()) {
			RemoteIpValve valve = new RemoteIpValve();
			valve.setProtocolHeader(StringUtils.hasLength(protocolHeader) ? protocolHeader : 'X-Forwarded-Proto');
			if (StringUtils.hasLength(remoteIpHeader)) {
				valve.setRemoteIpHeader(remoteIpHeader);
			}
			valve.setTrustedProxies(remoteIpProperties.getTrustedProxies());
			// The internal proxies default to a list of 'safe' internal IP addresses
			valve.setInternalProxies(remoteIpProperties.getInternalProxies());
			try {
				valve.setHostHeader(remoteIpProperties.getHostHeader());
			}
			catch (NoSuchMethodError ex) {
				// Avoid failure with war deployments to Tomcat 8.5 before 8.5.44 and
				// Tomcat 9 before 9.0.23
			}
			valve.setPortHeader(remoteIpProperties.getPortHeader());
			valve.setProtocolHeaderHttpsValue(remoteIpProperties.getProtocolHeaderHttpsValue());
			// ... so it"s safe to add this valve by default.
			factory.addEngineValves(valve);
		}
	}
	private boolean getOrDeduceUseForwardHeaders() {
		if (this.serverProperties.getForwardHeadersStrategy() == null) {
			CloudPlatform platform = CloudPlatform.getActive(this.environment);
			return platform != null && platform.isUsingForwardHeaders();
		}
		return this.serverProperties.getForwardHeadersStrategy() == ServerProperties.ForwardHeadersStrategy.NATIVE;
	}
	@SuppressWarnings('rawtypes')
	private void customizeMaxHttpRequestHeaderSize(ConfigurableTomcatWebServerFactory factory,
			int maxHttpRequestHeaderSize) {
		customizeHandler(factory, maxHttpRequestHeaderSize, AbstractHttp11Protocol.class,
				AbstractHttp11Protocol::setMaxHttpRequestHeaderSize);
	}
	@SuppressWarnings('rawtypes')
	private void customizeMaxHttpResponseHeaderSize(ConfigurableTomcatWebServerFactory factory,
			int maxHttpResponseHeaderSize) {
		customizeHandler(factory, maxHttpResponseHeaderSize, AbstractHttp11Protocol.class,
				AbstractHttp11Protocol::setMaxHttpResponseHeaderSize);
	}
	@SuppressWarnings('rawtypes')
	private void customizeMaxSwallowSize(ConfigurableTomcatWebServerFactory factory, int maxSwallowSize) {
		customizeHandler(factory, maxSwallowSize, AbstractHttp11Protocol.class,
				AbstractHttp11Protocol::setMaxSwallowSize);
	}
	private <T extends ProtocolHandler> void customizeHandler(ConfigurableTomcatWebServerFactory factory, int value,
			Class<T> type, ObjIntConsumer<T> consumer) {
		factory.addConnectorCustomizers((connector) -> {
			ProtocolHandler handler = connector.getProtocolHandler();
			if (type.isAssignableFrom(handler.getClass())) {
				consumer.accept(type.cast(handler), value);
			}
		});
	}
	private void customizeMaxHttpFormPostSize(ConfigurableTomcatWebServerFactory factory, int maxHttpFormPostSize) {
		factory.addConnectorCustomizers((connector) -> connector.setMaxPostSize(maxHttpFormPostSize));
	}
	private void customizeAccessLog(ConfigurableTomcatWebServerFactory factory) {
		ServerProperties.Tomcat tomcatProperties = this.serverProperties.getTomcat();
		AccessLogValve valve = new AccessLogValve();
		PropertyMapper map = PropertyMapper.get();
		Accesslog accessLogConfig = tomcatProperties.getAccesslog();
		map.from(accessLogConfig.getConditionIf()).to(valve::setConditionIf);
		map.from(accessLogConfig.getConditionUnless()).to(valve::setConditionUnless);
		map.from(accessLogConfig.getPattern()).to(valve::setPattern);
		map.from(accessLogConfig.getDirectory()).to(valve::setDirectory);
		map.from(accessLogConfig.getPrefix()).to(valve::setPrefix);
		map.from(accessLogConfig.getSuffix()).to(valve::setSuffix);
		map.from(accessLogConfig.getEncoding()).whenHasText().to(valve::setEncoding);
		map.from(accessLogConfig.getLocale()).whenHasText().to(valve::setLocale);
		map.from(accessLogConfig.isCheckExists()).to(valve::setCheckExists);
		map.from(accessLogConfig.isRotate()).to(valve::setRotatable);
		map.from(accessLogConfig.isRenameOnRotate()).to(valve::setRenameOnRotate);
		map.from(accessLogConfig.getMaxDays()).to(valve::setMaxDays);
		map.from(accessLogConfig.getFileDateFormat()).to(valve::setFileDateFormat);
		map.from(accessLogConfig.isIpv6Canonical()).to(valve::setIpv6Canonical);
		map.from(accessLogConfig.isRequestAttributesEnabled()).to(valve::setRequestAttributesEnabled);
		map.from(accessLogConfig.isBuffered()).to(valve::setBuffered);
		factory.addEngineValves(valve);
	}
	private void customizeStaticResources(ConfigurableTomcatWebServerFactory factory) {
		ServerProperties.Tomcat.Resource resource = this.serverProperties.getTomcat().getResource();
		factory.addContextCustomizers((context) -> context.addLifecycleListener((event) -> {
			if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {
				context.getResources().setCachingAllowed(resource.isAllowCaching());
				if (resource.getCacheTtl() != null) {
					long ttl = resource.getCacheTtl().toMillis();
					context.getResources().setCacheTtl(ttl);
				}
			}
		}));
	}
	private void customizeErrorReportValve(ErrorProperties error, ConfigurableTomcatWebServerFactory factory) {
		if (error.getIncludeStacktrace() == IncludeAttribute.NEVER) {
			factory.addContextCustomizers((context) -> {
				ErrorReportValve valve = new ErrorReportValve();
				valve.setShowServerInfo(false);
				valve.setShowReport(false);
				context.getParent().getPipeline().addValve(valve);
			});
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
@AutoConfiguration
@ConditionalOnNotWarDeployment
@ConditionalOnWebApplication
@EnableConfigurationProperties(ServerProperties.class)
public class EmbeddedWebServerFactoryCustomizerAutoConfiguration {
	/**
	 * Nested configuration if Tomcat is being used.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Tomcat.class, UpgradeProtocol.class })
	public static class TomcatWebServerFactoryCustomizerConfiguration {
		@Bean
		public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment,
				ServerProperties serverProperties) {
			return new TomcatWebServerFactoryCustomizer(environment, serverProperties);
		}
		@Bean
		@ConditionalOnThreading(Threading.VIRTUAL)
		TomcatVirtualThreadsWebServerFactoryCustomizer tomcatVirtualThreadsProtocolHandlerCustomizer() {
			return new TomcatVirtualThreadsWebServerFactoryCustomizer();
		}
	}
	/**
	 * Nested configuration if Jetty is being used.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Server.class, Loader.class, WebAppContext.class })
	public static class JettyWebServerFactoryCustomizerConfiguration {
		@Bean
		public JettyWebServerFactoryCustomizer jettyWebServerFactoryCustomizer(Environment environment,
				ServerProperties serverProperties) {
			return new JettyWebServerFactoryCustomizer(environment, serverProperties);
		}
		@Bean
		@ConditionalOnThreading(Threading.VIRTUAL)
		JettyVirtualThreadsWebServerFactoryCustomizer jettyVirtualThreadsWebServerFactoryCustomizer(
				ServerProperties serverProperties) {
			return new JettyVirtualThreadsWebServerFactoryCustomizer(serverProperties);
		}
	}
	/**
	 * Nested configuration if Undertow is being used.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Undertow.class, SslClientAuthMode.class })
	public static class UndertowWebServerFactoryCustomizerConfiguration {
		@Bean
		public UndertowWebServerFactoryCustomizer undertowWebServerFactoryCustomizer(Environment environment,
				ServerProperties serverProperties) {
			return new UndertowWebServerFactoryCustomizer(environment, serverProperties);
		}
		@Bean
		@ConditionalOnThreading(Threading.VIRTUAL)
		UndertowDeploymentInfoCustomizer virtualThreadsUndertowDeploymentInfoCustomizer() {
			return (deploymentInfo) -> deploymentInfo.setExecutor(new VirtualThreadTaskExecutor('undertow-'));
		}
	}
	/**
	 * Nested configuration if Netty is being used.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(HttpServer.class)
	public static class NettyWebServerFactoryCustomizerConfiguration {
		@Bean
		public NettyWebServerFactoryCustomizer nettyWebServerFactoryCustomizer(Environment environment,
				ServerProperties serverProperties) {
			return new NettyWebServerFactoryCustomizer(environment, serverProperties);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
final class JettyThreadPool {
	private JettyThreadPool() {
	}
	static QueuedThreadPool create(ServerProperties.Jetty.Threads properties) {
		BlockingQueue<Runnable> queue = determineBlockingQueue(properties.getMaxQueueCapacity());
		int maxThreadCount = (properties.getMax() > 0) ? properties.getMax() : 200;
		int minThreadCount = (properties.getMin() > 0) ? properties.getMin() : 8;
		int threadIdleTimeout = (properties.getIdleTimeout() != null) ? (int) properties.getIdleTimeout().toMillis()
				: 60000;
		return new QueuedThreadPool(maxThreadCount, minThreadCount, threadIdleTimeout, queue);
	}
	private static BlockingQueue<Runnable> determineBlockingQueue(Integer maxQueueCapacity) {
		if (maxQueueCapacity == null) {
			return null;
		}
		if (maxQueueCapacity == 0) {
			return new SynchronousQueue<>();
		}
		return new BlockingArrayQueue<>(maxQueueCapacity);
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
public class JettyVirtualThreadsWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableJettyWebServerFactory>, Ordered {
	private final ServerProperties serverProperties;
	public JettyVirtualThreadsWebServerFactoryCustomizer(ServerProperties serverProperties) {
		this.serverProperties = serverProperties;
	}
	@Override
	public void customize(ConfigurableJettyWebServerFactory factory) {
		Assert.state(VirtualThreads.areSupported(), 'Virtual threads are not supported');
		QueuedThreadPool threadPool = JettyThreadPool.create(this.serverProperties.getJetty().getThreads());
		threadPool.setVirtualThreadsExecutor(VirtualThreads.getNamedVirtualThreadsExecutor('jetty-'));
		factory.setThreadPool(threadPool);
	}
	@Override
	public int getOrder() {
		return JettyWebServerFactoryCustomizer.ORDER + 1;
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
public class JettyWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableJettyWebServerFactory>, Ordered {
	static final int ORDER = 0;
	private final Environment environment;
	private final ServerProperties serverProperties;
	public JettyWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
		this.environment = environment;
		this.serverProperties = serverProperties;
	}
	@Override
	public int getOrder() {
		return ORDER;
	}
	@Override
	public void customize(ConfigurableJettyWebServerFactory factory) {
		ServerProperties.Jetty properties = this.serverProperties.getJetty();
		factory.setUseForwardHeaders(getOrDeduceUseForwardHeaders());
		ServerProperties.Jetty.Threads threadProperties = properties.getThreads();
		factory.setThreadPool(JettyThreadPool.create(properties.getThreads()));
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getMaxConnections).to(factory::setMaxConnections);
		map.from(threadProperties::getAcceptors).to(factory::setAcceptors);
		map.from(threadProperties::getSelectors).to(factory::setSelectors);
		map.from(this.serverProperties::getMaxHttpRequestHeaderSize)
			.asInt(DataSize::toBytes)
			.when(this::isPositive)
			.to(customizeHttpConfigurations(factory, HttpConfiguration::setRequestHeaderSize));
		map.from(properties::getMaxHttpResponseHeaderSize)
			.asInt(DataSize::toBytes)
			.when(this::isPositive)
			.to(customizeHttpConfigurations(factory, HttpConfiguration::setResponseHeaderSize));
		map.from(properties::getMaxHttpFormPostSize)
			.asInt(DataSize::toBytes)
			.when(this::isPositive)
			.to(customizeServletContextHandler(factory, ServletContextHandler::setMaxFormContentSize));
		map.from(properties::getMaxFormKeys)
			.when(this::isPositive)
			.to(customizeServletContextHandler(factory, ServletContextHandler::setMaxFormKeys));
		map.from(properties::getConnectionIdleTimeout)
			.as(Duration::toMillis)
			.to(customizeAbstractConnectors(factory, AbstractConnector::setIdleTimeout));
		map.from(properties::getAccesslog)
			.when(ServerProperties.Jetty.Accesslog::isEnabled)
			.to((accesslog) -> customizeAccessLog(factory, accesslog));
	}
	private boolean isPositive(Integer value) {
		return value > 0;
	}
	private boolean getOrDeduceUseForwardHeaders() {
		if (this.serverProperties.getForwardHeadersStrategy() == null) {
			CloudPlatform platform = CloudPlatform.getActive(this.environment);
			return platform != null && platform.isUsingForwardHeaders();
		}
		return this.serverProperties.getForwardHeadersStrategy().equals(ServerProperties.ForwardHeadersStrategy.NATIVE);
	}
	private <T> Consumer<T> customizeHttpConfigurations(ConfigurableJettyWebServerFactory factory,
			BiConsumer<HttpConfiguration, T> action) {
		return customizeConnectionFactories(factory, HttpConfiguration.ConnectionFactory.class,
				(connectionFactory, value) -> action.accept(connectionFactory.getHttpConfiguration(), value));
	}
	private <V, F> Consumer<V> customizeConnectionFactories(ConfigurableJettyWebServerFactory factory,
			Class<F> connectionFactoryType, BiConsumer<F, V> action) {
		return customizeConnectors(factory, Connector.class, (connector, value) -> {
			Stream<ConnectionFactory> connectionFactories = connector.getConnectionFactories().stream();
			forEach(connectionFactories, connectionFactoryType, action, value);
		});
	}
	private <V> Consumer<V> customizeAbstractConnectors(ConfigurableJettyWebServerFactory factory,
			BiConsumer<AbstractConnector, V> action) {
		return customizeConnectors(factory, AbstractConnector.class, action);
	}
	private <V, C> Consumer<V> customizeConnectors(ConfigurableJettyWebServerFactory factory, Class<C> connectorType,
			BiConsumer<C, V> action) {
		return (value) -> factory.addServerCustomizers((server) -> {
			Stream<Connector> connectors = Arrays.stream(server.getConnectors());
			forEach(connectors, connectorType, action, value);
		});
	}
	private <V> Consumer<V> customizeServletContextHandler(ConfigurableJettyWebServerFactory factory,
			BiConsumer<ServletContextHandler, V> action) {
		return customizeHandlers(factory, ServletContextHandler.class, action);
	}
	private <V, H> Consumer<V> customizeHandlers(ConfigurableJettyWebServerFactory factory, Class<H> handlerType,
			BiConsumer<H, V> action) {
		return (value) -> factory.addServerCustomizers((server) -> {
			List<Handler> handlers = server.getHandlers();
			forEachHandler(handlers, handlerType, action, value);
		});
	}
	@SuppressWarnings('unchecked')
	private <V, H> void forEachHandler(List<Handler> handlers, Class<H> handlerType, BiConsumer<H, V> action, V value) {
		for (Handler handler : handlers) {
			if (handlerType.isInstance(handler)) {
				action.accept((H) handler, value);
			}
			if (handler instanceof Handler.Wrapper wrapper) {
				forEachHandler(wrapper.getHandlers(), handlerType, action, value);
			}
			if (handler instanceof Handler.Collection collection) {
				forEachHandler(collection.getHandlers(), handlerType, action, value);
			}
		}
	}
	private <T, V> void forEach(Stream<?> elements, Class<T> type, BiConsumer<T, V> action, V value) {
		elements.filter(type::isInstance).map(type::cast).forEach((element) -> action.accept(element, value));
	}
	private void customizeAccessLog(ConfigurableJettyWebServerFactory factory,
			ServerProperties.Jetty.Accesslog properties) {
		factory.addServerCustomizers((server) -> {
			RequestLogWriter logWriter = new RequestLogWriter();
			String format = getLogFormat(properties);
			CustomRequestLog log = new CustomRequestLog(logWriter, format);
			if (!CollectionUtils.isEmpty(properties.getIgnorePaths())) {
				log.setIgnorePaths(properties.getIgnorePaths().toArray(new String[0]));
			}
			if (properties.getFilename() != null) {
				logWriter.setFilename(properties.getFilename());
			}
			if (properties.getFileDateFormat() != null) {
				logWriter.setFilenameDateFormat(properties.getFileDateFormat());
			}
			logWriter.setRetainDays(properties.getRetentionPeriod());
			logWriter.setAppend(properties.isAppend());
			server.setRequestLog(log);
		});
	}
	private String getLogFormat(ServerProperties.Jetty.Accesslog properties) {
		if (properties.getCustomFormat() != null) {
			return properties.getCustomFormat();
		}
		if (ServerProperties.Jetty.Accesslog.FORMAT.EXTENDED_NCSA.equals(properties.getFormat())) {
			return CustomRequestLog.EXTENDED_NCSA_FORMAT;
		}
		return CustomRequestLog.NCSA_FORMAT;
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
public class TomcatVirtualThreadsWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableTomcatWebServerFactory>, Ordered {
	@Override
	public void customize(ConfigurableTomcatWebServerFactory factory) {
		factory.addProtocolHandlerCustomizers(
				(protocolHandler) -> protocolHandler.setExecutor(new VirtualThreadExecutor('tomcat-handler-')));
	}
	@Override
	public int getOrder() {
		return TomcatWebServerFactoryCustomizer.ORDER + 1;
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
public class UndertowWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableUndertowWebServerFactory>, Ordered {
	private final Environment environment;
	private final ServerProperties serverProperties;
	public UndertowWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
		this.environment = environment;
		this.serverProperties = serverProperties;
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public void customize(ConfigurableUndertowWebServerFactory factory) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		ServerOptions options = new ServerOptions(factory);
		map.from(this.serverProperties::getMaxHttpRequestHeaderSize)
			.asInt(DataSize::toBytes)
			.when(this::isPositive)
			.to(options.option(UndertowOptions.MAX_HEADER_SIZE));
		mapUndertowProperties(factory, options);
		mapAccessLogProperties(factory);
		map.from(this::getOrDeduceUseForwardHeaders).to(factory::setUseForwardHeaders);
	}
	private void mapUndertowProperties(ConfigurableUndertowWebServerFactory factory, ServerOptions serverOptions) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		Undertow properties = this.serverProperties.getUndertow();
		map.from(properties::getBufferSize).whenNonNull().asInt(DataSize::toBytes).to(factory::setBufferSize);
		ServerProperties.Undertow.Threads threadProperties = properties.getThreads();
		map.from(threadProperties::getIo).to(factory::setIoThreads);
		map.from(threadProperties::getWorker).to(factory::setWorkerThreads);
		map.from(properties::getDirectBuffers).to(factory::setUseDirectBuffers);
		map.from(properties::getMaxHttpPostSize)
			.as(DataSize::toBytes)
			.when(this::isPositive)
			.to(serverOptions.option(UndertowOptions.MAX_ENTITY_SIZE));
		map.from(properties::getMaxParameters).to(serverOptions.option(UndertowOptions.MAX_PARAMETERS));
		map.from(properties::getMaxHeaders).to(serverOptions.option(UndertowOptions.MAX_HEADERS));
		map.from(properties::getMaxCookies).to(serverOptions.option(UndertowOptions.MAX_COOKIES));
		mapSlashProperties(properties, serverOptions);
		map.from(properties::isDecodeUrl).to(serverOptions.option(UndertowOptions.DECODE_URL));
		map.from(properties::getUrlCharset).as(Charset::name).to(serverOptions.option(UndertowOptions.URL_CHARSET));
		map.from(properties::isAlwaysSetKeepAlive).to(serverOptions.option(UndertowOptions.ALWAYS_SET_KEEP_ALIVE));
		map.from(properties::getNoRequestTimeout)
			.asInt(Duration::toMillis)
			.to(serverOptions.option(UndertowOptions.NO_REQUEST_TIMEOUT));
		map.from(properties.getOptions()::getServer).to(serverOptions.forEach(serverOptions::option));
		SocketOptions socketOptions = new SocketOptions(factory);
		map.from(properties.getOptions()::getSocket).to(socketOptions.forEach(socketOptions::option));
	}
	@SuppressWarnings({ 'deprecation', 'removal' })
	private void mapSlashProperties(Undertow properties, ServerOptions serverOptions) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::isAllowEncodedSlash).to(serverOptions.option(UndertowOptions.ALLOW_ENCODED_SLASH));
		map.from(properties::getDecodeSlash).to(serverOptions.option(UndertowOptions.DECODE_SLASH));
	}
	private boolean isPositive(Number value) {
		return value.longValue() > 0;
	}
	private void mapAccessLogProperties(ConfigurableUndertowWebServerFactory factory) {
		Accesslog properties = this.serverProperties.getUndertow().getAccesslog();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::isEnabled).to(factory::setAccessLogEnabled);
		map.from(properties::getDir).to(factory::setAccessLogDirectory);
		map.from(properties::getPattern).to(factory::setAccessLogPattern);
		map.from(properties::getPrefix).to(factory::setAccessLogPrefix);
		map.from(properties::getSuffix).to(factory::setAccessLogSuffix);
		map.from(properties::isRotate).to(factory::setAccessLogRotate);
	}
	private boolean getOrDeduceUseForwardHeaders() {
		if (this.serverProperties.getForwardHeadersStrategy() == null) {
			CloudPlatform platform = CloudPlatform.getActive(this.environment);
			return platform != null && platform.isUsingForwardHeaders();
		}
		return this.serverProperties.getForwardHeadersStrategy().equals(ServerProperties.ForwardHeadersStrategy.NATIVE);
	}
	private abstract static class AbstractOptions {
		private final Class<?> source;
		private final Map<String, Option<?>> nameLookup;
		private final ConfigurableUndertowWebServerFactory factory;
		AbstractOptions(Class<?> source, ConfigurableUndertowWebServerFactory factory) {
			Map<String, Option<?>> lookup = new HashMap<>();
			ReflectionUtils.doWithLocalFields(source, (field) -> {
				int modifiers = field.getModifiers();
				if (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers)
						&& Option.class.isAssignableFrom(field.getType())) {
					try {
						Option<?> option = (Option<?>) field.get(null);
						lookup.put(getCanonicalName(field.getName()), option);
					}
					catch (IllegalAccessException ex) {
						// Ignore
					}
				}
			});
			this.source = source;
			this.nameLookup = Collections.unmodifiableMap(lookup);
			this.factory = factory;
		}
		protected ConfigurableUndertowWebServerFactory getFactory() {
			return this.factory;
		}
		@SuppressWarnings('unchecked')
		<T> Consumer<Map<String, String>> forEach(Function<Option<T>, Consumer<T>> function) {
			return (map) -> map.forEach((key, value) -> {
				Option<T> option = (Option<T>) this.nameLookup.get(getCanonicalName(key));
				Assert.state(option != null,
						() -> 'Unable to find "' + key + '" in ' + ClassUtils.getShortName(this.source));
				T parsed = option.parseValue(value, getClass().getClassLoader());
				function.apply(option).accept(parsed);
			});
		}
		private static String getCanonicalName(String name) {
			StringBuilder canonicalName = new StringBuilder(name.length());
			name.chars()
				.filter(Character::isLetterOrDigit)
				.map(Character::toLowerCase)
				.forEach((c) -> canonicalName.append((char) c));
			return canonicalName.toString();
		}
	}
	/**
	 * {@link ConfigurableUndertowWebServerFactory} wrapper that makes it easier to apply
	 * {@link UndertowOptions server options}.
	 */
	private static class ServerOptions extends AbstractOptions {
		ServerOptions(ConfigurableUndertowWebServerFactory factory) {
			super(UndertowOptions.class, factory);
		}
		<T> Consumer<T> option(Option<T> option) {
			return (value) -> getFactory().addBuilderCustomizers((builder) -> builder.setServerOption(option, value));
		}
	}
	/**
	 * {@link ConfigurableUndertowWebServerFactory} wrapper that makes it easier to apply
	 * {@link Options socket options}.
	 */
	private static class SocketOptions extends AbstractOptions {
		SocketOptions(ConfigurableUndertowWebServerFactory factory) {
			super(Options.class, factory);
		}
		<T> Consumer<T> option(Option<T> option) {
			return (value) -> getFactory().addBuilderCustomizers((builder) -> builder.setSocketOption(option, value));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.embedded;
/**
public class NettyWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<NettyReactiveWebServerFactory>, Ordered {
	private final Environment environment;
	private final ServerProperties serverProperties;
	public NettyWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
		this.environment = environment;
		this.serverProperties = serverProperties;
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public void customize(NettyReactiveWebServerFactory factory) {
		factory.setUseForwardHeaders(getOrDeduceUseForwardHeaders());
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		ServerProperties.Netty nettyProperties = this.serverProperties.getNetty();
		map.from(nettyProperties::getConnectionTimeout)
			.to((connectionTimeout) -> customizeConnectionTimeout(factory, connectionTimeout));
		map.from(nettyProperties::getIdleTimeout).to((idleTimeout) -> customizeIdleTimeout(factory, idleTimeout));
		map.from(nettyProperties::getMaxKeepAliveRequests)
			.to((maxKeepAliveRequests) -> customizeMaxKeepAliveRequests(factory, maxKeepAliveRequests));
		if (this.serverProperties.getHttp2() != null && this.serverProperties.getHttp2().isEnabled()) {
			map.from(this.serverProperties.getMaxHttpRequestHeaderSize())
				.to((size) -> customizeHttp2MaxHeaderSize(factory, size.toBytes()));
		}
		customizeRequestDecoder(factory, map);
	}
	private boolean getOrDeduceUseForwardHeaders() {
		if (this.serverProperties.getForwardHeadersStrategy() == null) {
			CloudPlatform platform = CloudPlatform.getActive(this.environment);
			return platform != null && platform.isUsingForwardHeaders();
		}
		return this.serverProperties.getForwardHeadersStrategy().equals(ServerProperties.ForwardHeadersStrategy.NATIVE);
	}
	private void customizeConnectionTimeout(NettyReactiveWebServerFactory factory, Duration connectionTimeout) {
		factory.addServerCustomizers((httpServer) -> httpServer.option(ChannelOption.CONNECT_TIMEOUT_MILLIS,
				(int) connectionTimeout.toMillis()));
	}
	private void customizeRequestDecoder(NettyReactiveWebServerFactory factory, PropertyMapper propertyMapper) {
		factory.addServerCustomizers((httpServer) -> httpServer.httpRequestDecoder((httpRequestDecoderSpec) -> {
			propertyMapper.from(this.serverProperties.getMaxHttpRequestHeaderSize())
				.to((maxHttpRequestHeader) -> httpRequestDecoderSpec
					.maxHeaderSize((int) maxHttpRequestHeader.toBytes()));
			ServerProperties.Netty nettyProperties = this.serverProperties.getNetty();
			propertyMapper.from(nettyProperties.getMaxInitialLineLength())
				.to((maxInitialLineLength) -> httpRequestDecoderSpec
					.maxInitialLineLength((int) maxInitialLineLength.toBytes()));
			propertyMapper.from(nettyProperties.getH2cMaxContentLength())
				.to((h2cMaxContentLength) -> httpRequestDecoderSpec
					.h2cMaxContentLength((int) h2cMaxContentLength.toBytes()));
			propertyMapper.from(nettyProperties.getInitialBufferSize())
				.to((initialBufferSize) -> httpRequestDecoderSpec.initialBufferSize((int) initialBufferSize.toBytes()));
			propertyMapper.from(nettyProperties.isValidateHeaders()).to(httpRequestDecoderSpec::validateHeaders);
			return httpRequestDecoderSpec;
		}));
	}
	private void customizeIdleTimeout(NettyReactiveWebServerFactory factory, Duration idleTimeout) {
		factory.addServerCustomizers((httpServer) -> httpServer.idleTimeout(idleTimeout));
	}
	private void customizeMaxKeepAliveRequests(NettyReactiveWebServerFactory factory, int maxKeepAliveRequests) {
		factory.addServerCustomizers((httpServer) -> httpServer.maxKeepAliveRequests(maxKeepAliveRequests));
	}
	private void customizeHttp2MaxHeaderSize(NettyReactiveWebServerFactory factory, long size) {
		factory.addServerCustomizers(
				((httpServer) -> httpServer.http2Settings((settings) -> settings.maxHeaderListSize(size))));
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.embedded;
/*
package org.springframework.boot.autoconfigure.web;
/**
@ConfigurationProperties('spring.web')
public class WebProperties {
	/**
	 * Locale to use. By default, this locale is overridden by the 'Accept-Language'
	 * header.
	 */
	private Locale locale;
	/**
	 * Define how the locale should be resolved.
	 */
	private LocaleResolver localeResolver = LocaleResolver.ACCEPT_HEADER;
	private final Resources resources = new Resources();
	public Locale getLocale() {
		return this.locale;
	}
	public void setLocale(Locale locale) {
		this.locale = locale;
	}
	public LocaleResolver getLocaleResolver() {
		return this.localeResolver;
	}
	public void setLocaleResolver(LocaleResolver localeResolver) {
		this.localeResolver = localeResolver;
	}
	public Resources getResources() {
		return this.resources;
	}
	public enum LocaleResolver {
		/**
		 * Always use the configured locale.
		 */
		FIXED,
		/**
		 * Use the 'Accept-Language' header or the configured locale if the header is not
		 * set.
		 */
		ACCEPT_HEADER
	}
	public static class Resources {
		private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { 'classpath:/META-INF/resources/',
				'classpath:/resources/', 'classpath:/static/', 'classpath:/public/' };
		/**
		 * Locations of static resources. Defaults to classpath:[/META-INF/resources/,
		 * /resources/, /static/, /public/].
		 */
		private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;
		/**
		 * Whether to enable default resource handling.
		 */
		private boolean addMappings = true;
		private boolean customized = false;
		private final Chain chain = new Chain();
		private final Cache cache = new Cache();
		public String[] getStaticLocations() {
			return this.staticLocations;
		}
		public void setStaticLocations(String[] staticLocations) {
			this.staticLocations = appendSlashIfNecessary(staticLocations);
			this.customized = true;
		}
		private String[] appendSlashIfNecessary(String[] staticLocations) {
			String[] normalized = new String[staticLocations.length];
			for (int i = 0; i < staticLocations.length; i++) {
				String location = staticLocations[i];
				normalized[i] = location.endsWith('/') ? location : location + '/';
			}
			return normalized;
		}
		public boolean isAddMappings() {
			return this.addMappings;
		}
		public void setAddMappings(boolean addMappings) {
			this.customized = true;
			this.addMappings = addMappings;
		}
		public Chain getChain() {
			return this.chain;
		}
		public Cache getCache() {
			return this.cache;
		}
		public boolean hasBeenCustomized() {
			return this.customized || getChain().hasBeenCustomized() || getCache().hasBeenCustomized();
		}
		/**
		 * Configuration for the Spring Resource Handling chain.
		 */
		public static class Chain {
			boolean customized = false;
			/**
			 * Whether to enable the Spring Resource Handling chain. By default, disabled
			 * unless at least one strategy has been enabled.
			 */
			private Boolean enabled;
			/**
			 * Whether to enable caching in the Resource chain.
			 */
			private boolean cache = true;
			/**
			 * Whether to enable resolution of already compressed resources (gzip,
			 * brotli). Checks for a resource name with the ".gz" or ".br" file
			 * extensions.
			 */
			private boolean compressed = false;
			private final Strategy strategy = new Strategy();
			/**
			 * Return whether the resource chain is enabled. Return {@code null} if no
			 * specific settings are present.
			 * @return whether the resource chain is enabled or {@code null} if no
			 * specified settings are present.
			 */
			public Boolean getEnabled() {
				return getEnabled(getStrategy().getFixed().isEnabled(), getStrategy().getContent().isEnabled(),
						this.enabled);
			}
			private boolean hasBeenCustomized() {
				return this.customized || getStrategy().hasBeenCustomized();
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
				this.customized = true;
			}
			public boolean isCache() {
				return this.cache;
			}
			public void setCache(boolean cache) {
				this.cache = cache;
				this.customized = true;
			}
			public Strategy getStrategy() {
				return this.strategy;
			}
			public boolean isCompressed() {
				return this.compressed;
			}
			public void setCompressed(boolean compressed) {
				this.compressed = compressed;
				this.customized = true;
			}
			static Boolean getEnabled(boolean fixedEnabled, boolean contentEnabled, Boolean chainEnabled) {
				return (fixedEnabled || contentEnabled) ? Boolean.TRUE : chainEnabled;
			}
			/**
			 * Strategies for extracting and embedding a resource version in its URL path.
			 */
			public static class Strategy {
				private final Fixed fixed = new Fixed();
				private final Content content = new Content();
				public Fixed getFixed() {
					return this.fixed;
				}
				public Content getContent() {
					return this.content;
				}
				private boolean hasBeenCustomized() {
					return getFixed().hasBeenCustomized() || getContent().hasBeenCustomized();
				}
				/**
				 * Version Strategy based on content hashing.
				 */
				public static class Content {
					private boolean customized = false;
					/**
					 * Whether to enable the content Version Strategy.
					 */
					private boolean enabled;
					/**
					 * List of patterns to apply to the content Version Strategy.
					 */
					private String[] paths = new String[] { '/**' };
					public boolean isEnabled() {
						return this.enabled;
					}
					public void setEnabled(boolean enabled) {
						this.customized = true;
						this.enabled = enabled;
					}
					public String[] getPaths() {
						return this.paths;
					}
					public void setPaths(String[] paths) {
						this.customized = true;
						this.paths = paths;
					}
					private boolean hasBeenCustomized() {
						return this.customized;
					}
				}
				/**
				 * Version Strategy based on a fixed version string.
				 */
				public static class Fixed {
					private boolean customized = false;
					/**
					 * Whether to enable the fixed Version Strategy.
					 */
					private boolean enabled;
					/**
					 * List of patterns to apply to the fixed Version Strategy.
					 */
					private String[] paths = new String[] { '/**' };
					/**
					 * Version string to use for the fixed Version Strategy.
					 */
					private String version;
					public boolean isEnabled() {
						return this.enabled;
					}
					public void setEnabled(boolean enabled) {
						this.customized = true;
						this.enabled = enabled;
					}
					public String[] getPaths() {
						return this.paths;
					}
					public void setPaths(String[] paths) {
						this.customized = true;
						this.paths = paths;
					}
					public String getVersion() {
						return this.version;
					}
					public void setVersion(String version) {
						this.customized = true;
						this.version = version;
					}
					private boolean hasBeenCustomized() {
						return this.customized;
					}
				}
			}
		}
		/**
		 * Cache configuration.
		 */
		public static class Cache {
			private boolean customized = false;
			/**
			 * Cache period for the resources served by the resource handler. If a
			 * duration suffix is not specified, seconds will be used. Can be overridden
			 * by the "spring.web.resources.cache.cachecontrol" properties.
			 */
			@DurationUnit(ChronoUnit.SECONDS)
			private Duration period;
			/**
			 * Cache control HTTP headers, only allows valid directive combinations.
			 * Overrides the "spring.web.resources.cache.period" property.
			 */
			private final Cachecontrol cachecontrol = new Cachecontrol();
			/**
			 * Whether we should use the 'lastModified' metadata of the files in HTTP
			 * caching headers.
			 */
			private boolean useLastModified = true;
			public Duration getPeriod() {
				return this.period;
			}
			public void setPeriod(Duration period) {
				this.customized = true;
				this.period = period;
			}
			public Cachecontrol getCachecontrol() {
				return this.cachecontrol;
			}
			public boolean isUseLastModified() {
				return this.useLastModified;
			}
			public void setUseLastModified(boolean useLastModified) {
				this.useLastModified = useLastModified;
			}
			private boolean hasBeenCustomized() {
				return this.customized || getCachecontrol().hasBeenCustomized();
			}
			/**
			 * Cache Control HTTP header configuration.
			 */
			public static class Cachecontrol {
				private boolean customized = false;
				/**
				 * Maximum time the response should be cached, in seconds if no duration
				 * suffix is not specified.
				 */
				@DurationUnit(ChronoUnit.SECONDS)
				private Duration maxAge;
				/**
				 * Indicate that the cached response can be reused only if re-validated
				 * with the server.
				 */
				private Boolean noCache;
				/**
				 * Indicate to not cache the response in any case.
				 */
				private Boolean noStore;
				/**
				 * Indicate that once it has become stale, a cache must not use the
				 * response without re-validating it with the server.
				 */
				private Boolean mustRevalidate;
				/**
				 * Indicate intermediaries (caches and others) that they should not
				 * transform the response content.
				 */
				private Boolean noTransform;
				/**
				 * Indicate that any cache may store the response.
				 */
				private Boolean cachePublic;
				/**
				 * Indicate that the response message is intended for a single user and
				 * must not be stored by a shared cache.
				 */
				private Boolean cachePrivate;
				/**
				 * Same meaning as the 'must-revalidate' directive, except that it does
				 * not apply to private caches.
				 */
				private Boolean proxyRevalidate;
				/**
				 * Maximum time the response can be served after it becomes stale, in
				 * seconds if no duration suffix is not specified.
				 */
				@DurationUnit(ChronoUnit.SECONDS)
				private Duration staleWhileRevalidate;
				/**
				 * Maximum time the response may be used when errors are encountered, in
				 * seconds if no duration suffix is not specified.
				 */
				@DurationUnit(ChronoUnit.SECONDS)
				private Duration staleIfError;
				/**
				 * Maximum time the response should be cached by shared caches, in seconds
				 * if no duration suffix is not specified.
				 */
				@DurationUnit(ChronoUnit.SECONDS)
				private Duration sMaxAge;
				public Duration getMaxAge() {
					return this.maxAge;
				}
				public void setMaxAge(Duration maxAge) {
					this.customized = true;
					this.maxAge = maxAge;
				}
				public Boolean getNoCache() {
					return this.noCache;
				}
				public void setNoCache(Boolean noCache) {
					this.customized = true;
					this.noCache = noCache;
				}
				public Boolean getNoStore() {
					return this.noStore;
				}
				public void setNoStore(Boolean noStore) {
					this.customized = true;
					this.noStore = noStore;
				}
				public Boolean getMustRevalidate() {
					return this.mustRevalidate;
				}
				public void setMustRevalidate(Boolean mustRevalidate) {
					this.customized = true;
					this.mustRevalidate = mustRevalidate;
				}
				public Boolean getNoTransform() {
					return this.noTransform;
				}
				public void setNoTransform(Boolean noTransform) {
					this.customized = true;
					this.noTransform = noTransform;
				}
				public Boolean getCachePublic() {
					return this.cachePublic;
				}
				public void setCachePublic(Boolean cachePublic) {
					this.customized = true;
					this.cachePublic = cachePublic;
				}
				public Boolean getCachePrivate() {
					return this.cachePrivate;
				}
				public void setCachePrivate(Boolean cachePrivate) {
					this.customized = true;
					this.cachePrivate = cachePrivate;
				}
				public Boolean getProxyRevalidate() {
					return this.proxyRevalidate;
				}
				public void setProxyRevalidate(Boolean proxyRevalidate) {
					this.customized = true;
					this.proxyRevalidate = proxyRevalidate;
				}
				public Duration getStaleWhileRevalidate() {
					return this.staleWhileRevalidate;
				}
				public void setStaleWhileRevalidate(Duration staleWhileRevalidate) {
					this.customized = true;
					this.staleWhileRevalidate = staleWhileRevalidate;
				}
				public Duration getStaleIfError() {
					return this.staleIfError;
				}
				public void setStaleIfError(Duration staleIfError) {
					this.customized = true;
					this.staleIfError = staleIfError;
				}
				public Duration getSMaxAge() {
					return this.sMaxAge;
				}
				public void setSMaxAge(Duration sMaxAge) {
					this.customized = true;
					this.sMaxAge = sMaxAge;
				}
				public CacheControl toHttpCacheControl() {
					PropertyMapper map = PropertyMapper.get();
					CacheControl control = createCacheControl();
					map.from(this::getMustRevalidate).whenTrue().toCall(control::mustRevalidate);
					map.from(this::getNoTransform).whenTrue().toCall(control::noTransform);
					map.from(this::getCachePublic).whenTrue().toCall(control::cachePublic);
					map.from(this::getCachePrivate).whenTrue().toCall(control::cachePrivate);
					map.from(this::getProxyRevalidate).whenTrue().toCall(control::proxyRevalidate);
					map.from(this::getStaleWhileRevalidate)
						.whenNonNull()
						.to((duration) -> control.staleWhileRevalidate(duration.getSeconds(), TimeUnit.SECONDS));
					map.from(this::getStaleIfError)
						.whenNonNull()
						.to((duration) -> control.staleIfError(duration.getSeconds(), TimeUnit.SECONDS));
					map.from(this::getSMaxAge)
						.whenNonNull()
						.to((duration) -> control.sMaxAge(duration.getSeconds(), TimeUnit.SECONDS));
					// check if cacheControl remained untouched
					if (control.getHeaderValue() == null) {
						return null;
					}
					return control;
				}
				private CacheControl createCacheControl() {
					if (Boolean.TRUE.equals(this.noStore)) {
						return CacheControl.noStore();
					}
					if (Boolean.TRUE.equals(this.noCache)) {
						return CacheControl.noCache();
					}
					if (this.maxAge != null) {
						return CacheControl.maxAge(this.maxAge.getSeconds(), TimeUnit.SECONDS);
					}
					return CacheControl.empty();
				}
				private boolean hasBeenCustomized() {
					return this.customized;
				}
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnEnabledResourceChainCondition.class)
public @interface ConditionalOnEnabledResourceChain {
}
/*
package org.springframework.boot.autoconfigure.web.format;
/**
public class WebConversionService extends DefaultFormattingConversionService {
	private static final boolean JSR_354_PRESENT = ClassUtils.isPresent('javax.money.MonetaryAmount',
			WebConversionService.class.getClassLoader());
	/**
	 * Create a new WebConversionService that configures formatters with the provided
	 * date, time, and date-time formats, or registers the default if no custom format is
	 * provided.
	 * @param dateTimeFormatters the formatters to use for date, time, and date-time
	 * formatting
	 * @since 2.3.0
	 */
	public WebConversionService(DateTimeFormatters dateTimeFormatters) {
		super(false);
		if (dateTimeFormatters.isCustomized()) {
			addFormatters(dateTimeFormatters);
		}
		else {
			addDefaultFormatters(this);
		}
	}
	private void addFormatters(DateTimeFormatters dateTimeFormatters) {
		addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory());
		if (JSR_354_PRESENT) {
			addFormatter(new CurrencyUnitFormatter());
			addFormatter(new MonetaryAmountFormatter());
			addFormatterForFieldAnnotation(new Jsr354NumberFormatAnnotationFormatterFactory());
		}
		registerJsr310(dateTimeFormatters);
		registerJavaDate(dateTimeFormatters);
	}
	private void registerJsr310(DateTimeFormatters dateTimeFormatters) {
		DateTimeFormatterRegistrar dateTime = new DateTimeFormatterRegistrar();
		configure(dateTimeFormatters::getDateFormatter, dateTime::setDateFormatter);
		configure(dateTimeFormatters::getTimeFormatter, dateTime::setTimeFormatter);
		configure(dateTimeFormatters::getDateTimeFormatter, dateTime::setDateTimeFormatter);
		dateTime.registerFormatters(this);
	}
	private void configure(Supplier<DateTimeFormatter> supplier, Consumer<DateTimeFormatter> consumer) {
		DateTimeFormatter formatter = supplier.get();
		if (formatter != null) {
			consumer.accept(formatter);
		}
	}
	private void registerJavaDate(DateTimeFormatters dateTimeFormatters) {
		DateFormatterRegistrar dateFormatterRegistrar = new DateFormatterRegistrar();
		String datePattern = dateTimeFormatters.getDatePattern();
		if (datePattern != null) {
			DateFormatter dateFormatter = new DateFormatter(datePattern);
			dateFormatterRegistrar.setFormatter(dateFormatter);
		}
		dateFormatterRegistrar.registerFormatters(this);
	}
}
/*
package org.springframework.boot.autoconfigure.web.format;
/**
public class DateTimeFormatters {
	private DateTimeFormatter dateFormatter;
	private String datePattern;
	private DateTimeFormatter timeFormatter;
	private DateTimeFormatter dateTimeFormatter;
	/**
	 * Configures the date format using the given {@code pattern}.
	 * @param pattern the pattern for formatting dates
	 * @return {@code this} for chained method invocation
	 */
	public DateTimeFormatters dateFormat(String pattern) {
		if (isIso(pattern)) {
			this.dateFormatter = DateTimeFormatter.ISO_LOCAL_DATE;
			this.datePattern = 'yyyy-MM-dd';
		}
		else {
			this.dateFormatter = formatter(pattern);
			this.datePattern = pattern;
		}
		return this;
	}
	/**
	 * Configures the time format using the given {@code pattern}.
	 * @param pattern the pattern for formatting times
	 * @return {@code this} for chained method invocation
	 */
	public DateTimeFormatters timeFormat(String pattern) {
		this.timeFormatter = isIso(pattern) ? DateTimeFormatter.ISO_LOCAL_TIME
				: (isIsoOffset(pattern) ? DateTimeFormatter.ISO_OFFSET_TIME : formatter(pattern));
		return this;
	}
	/**
	 * Configures the date-time format using the given {@code pattern}.
	 * @param pattern the pattern for formatting date-times
	 * @return {@code this} for chained method invocation
	 */
	public DateTimeFormatters dateTimeFormat(String pattern) {
		this.dateTimeFormatter = isIso(pattern) ? DateTimeFormatter.ISO_LOCAL_DATE_TIME
				: (isIsoOffset(pattern) ? DateTimeFormatter.ISO_OFFSET_DATE_TIME : formatter(pattern));
		return this;
	}
	DateTimeFormatter getDateFormatter() {
		return this.dateFormatter;
	}
	String getDatePattern() {
		return this.datePattern;
	}
	DateTimeFormatter getTimeFormatter() {
		return this.timeFormatter;
	}
	DateTimeFormatter getDateTimeFormatter() {
		return this.dateTimeFormatter;
	}
	boolean isCustomized() {
		return this.dateFormatter != null || this.timeFormatter != null || this.dateTimeFormatter != null;
	}
	private static DateTimeFormatter formatter(String pattern) {
		return StringUtils.hasText(pattern)
				? DateTimeFormatter.ofPattern(pattern).withResolverStyle(ResolverStyle.SMART) : null;
	}
	private static boolean isIso(String pattern) {
		return 'iso'.equalsIgnoreCase(pattern);
	}
	private static boolean isIsoOffset(String pattern) {
		return 'isooffset'.equalsIgnoreCase(pattern) || 'iso-offset'.equalsIgnoreCase(pattern);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.format;
/*
package org.springframework.boot.autoconfigure.web.client;
/**
public final class RestTemplateBuilderConfigurer {
	private ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder;
	private ClientHttpRequestFactorySettings requestFactorySettings;
	private HttpMessageConverters httpMessageConverters;
	private List<RestTemplateCustomizer> restTemplateCustomizers;
	private List<RestTemplateRequestCustomizer<?>> restTemplateRequestCustomizers;
	void setRequestFactoryBuilder(ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder) {
		this.requestFactoryBuilder = requestFactoryBuilder;
	}
	void setRequestFactorySettings(ClientHttpRequestFactorySettings requestFactorySettings) {
		this.requestFactorySettings = requestFactorySettings;
	}
	void setHttpMessageConverters(HttpMessageConverters httpMessageConverters) {
		this.httpMessageConverters = httpMessageConverters;
	}
	void setRestTemplateCustomizers(List<RestTemplateCustomizer> restTemplateCustomizers) {
		this.restTemplateCustomizers = restTemplateCustomizers;
	}
	void setRestTemplateRequestCustomizers(List<RestTemplateRequestCustomizer<?>> restTemplateRequestCustomizers) {
		this.restTemplateRequestCustomizers = restTemplateRequestCustomizers;
	}
	/**
	 * Configure the specified {@link RestTemplateBuilder}. The builder can be further
	 * tuned and default settings can be overridden.
	 * @param builder the {@link RestTemplateBuilder} instance to configure
	 * @return the configured builder
	 */
	public RestTemplateBuilder configure(RestTemplateBuilder builder) {
		if (this.requestFactoryBuilder != null) {
			builder = builder.requestFactoryBuilder(this.requestFactoryBuilder);
		}
		if (this.requestFactorySettings != null) {
			builder = builder.requestFactorySettings(this.requestFactorySettings);
		}
		if (this.httpMessageConverters != null) {
			builder = builder.messageConverters(this.httpMessageConverters.getConverters());
		}
		builder = addCustomizers(builder, this.restTemplateCustomizers, RestTemplateBuilder::customizers);
		builder = addCustomizers(builder, this.restTemplateRequestCustomizers, RestTemplateBuilder::requestCustomizers);
		return builder;
	}
	private <T> RestTemplateBuilder addCustomizers(RestTemplateBuilder builder, List<T> customizers,
			BiFunction<RestTemplateBuilder, Collection<T>, RestTemplateBuilder> method) {
		if (!ObjectUtils.isEmpty(customizers)) {
			return method.apply(builder, customizers);
		}
		return builder;
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
@AutoConfiguration(after = { HttpClientAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class })
@ConditionalOnClass(RestTemplate.class)
@Conditional(NotReactiveWebApplicationCondition.class)
public class RestTemplateAutoConfiguration {
	@Bean
	@Lazy
	public RestTemplateBuilderConfigurer restTemplateBuilderConfigurer(
			ObjectProvider<ClientHttpRequestFactoryBuilder<?>> clientHttpRequestFactoryBuilder,
			ObjectProvider<ClientHttpRequestFactorySettings> clientHttpRequestFactorySettings,
			ObjectProvider<HttpMessageConverters> messageConverters,
			ObjectProvider<RestTemplateCustomizer> restTemplateCustomizers,
			ObjectProvider<RestTemplateRequestCustomizer<?>> restTemplateRequestCustomizers) {
		RestTemplateBuilderConfigurer configurer = new RestTemplateBuilderConfigurer();
		configurer.setRequestFactoryBuilder(clientHttpRequestFactoryBuilder.getIfAvailable());
		configurer.setRequestFactorySettings(clientHttpRequestFactorySettings.getIfAvailable());
		configurer.setHttpMessageConverters(messageConverters.getIfUnique());
		configurer.setRestTemplateCustomizers(restTemplateCustomizers.orderedStream().toList());
		configurer.setRestTemplateRequestCustomizers(restTemplateRequestCustomizers.orderedStream().toList());
		return configurer;
	}
	@Bean
	@Lazy
	@ConditionalOnMissingBean
	public RestTemplateBuilder restTemplateBuilder(RestTemplateBuilderConfigurer restTemplateBuilderConfigurer) {
		return restTemplateBuilderConfigurer.configure(new RestTemplateBuilder());
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
public class RestClientBuilderConfigurer {
	private ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder;
	private ClientHttpRequestFactorySettings requestFactorySettings;
	private List<RestClientCustomizer> customizers;
	void setRequestFactoryBuilder(ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder) {
		this.requestFactoryBuilder = requestFactoryBuilder;
	}
	void setRequestFactorySettings(ClientHttpRequestFactorySettings requestFactorySettings) {
		this.requestFactorySettings = requestFactorySettings;
	}
	void setRestClientCustomizers(List<RestClientCustomizer> customizers) {
		this.customizers = customizers;
	}
	/**
	 * Configure the specified {@link Builder RestClient.Builder}. The builder can be
	 * further tuned and default settings can be overridden.
	 * @param builder the {@link Builder RestClient.Builder} instance to configure
	 * @return the configured builder
	 */
	public RestClient.Builder configure(RestClient.Builder builder) {
		ClientHttpRequestFactoryBuilder<?> requestFactoryBuilder = (this.requestFactoryBuilder != null)
				? this.requestFactoryBuilder : ClientHttpRequestFactoryBuilder.detect();
		builder.requestFactory(requestFactoryBuilder.build(this.requestFactorySettings));
		applyCustomizers(builder);
		return builder;
	}
	private void applyCustomizers(Builder builder) {
		if (this.customizers != null) {
			for (RestClientCustomizer customizer : this.customizers) {
				customizer.customize(builder);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
public class HttpMessageConvertersRestClientCustomizer implements RestClientCustomizer {
	private final Iterable<? extends HttpMessageConverter<?>> messageConverters;
	public HttpMessageConvertersRestClientCustomizer(HttpMessageConverter<?>... messageConverters) {
		Assert.notNull(messageConverters, 'MessageConverters must not be null');
		this.messageConverters = Arrays.asList(messageConverters);
	}
	HttpMessageConvertersRestClientCustomizer(HttpMessageConverters messageConverters) {
		this.messageConverters = messageConverters;
	}
	@Override
	public void customize(RestClient.Builder restClientBuilder) {
		restClientBuilder.messageConverters(this::configureMessageConverters);
	}
	private void configureMessageConverters(List<HttpMessageConverter<?>> messageConverters) {
		if (this.messageConverters != null) {
			messageConverters.clear();
			this.messageConverters.forEach(messageConverters::add);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
class NotReactiveWebApplicationCondition extends NoneNestedConditions {
	NotReactiveWebApplicationCondition() {
		super(ConfigurationPhase.PARSE_CONFIGURATION);
	}
	@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
	private static final class ReactiveWebApplication {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.client;
/*
package org.springframework.boot.autoconfigure.web.client;
/**
class AutoConfiguredRestClientSsl implements RestClientSsl {
	private final ClientHttpRequestFactoryBuilder<?> clientHttpRequestFactoryBuilder;
	private final SslBundles sslBundles;
	AutoConfiguredRestClientSsl(ClientHttpRequestFactoryBuilder<?> clientHttpRequestFactoryBuilder,
			SslBundles sslBundles) {
		this.clientHttpRequestFactoryBuilder = clientHttpRequestFactoryBuilder;
		this.sslBundles = sslBundles;
	}
	@Override
	public Consumer<RestClient.Builder> fromBundle(String bundleName) {
		return fromBundle(this.sslBundles.getBundle(bundleName));
	}
	@Override
	public Consumer<RestClient.Builder> fromBundle(SslBundle bundle) {
		return (builder) -> {
			ClientHttpRequestFactorySettings settings = ClientHttpRequestFactorySettings.ofSslBundle(bundle);
			ClientHttpRequestFactory requestFactory = this.clientHttpRequestFactoryBuilder.build(settings);
			builder.requestFactory(requestFactory);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
@AutoConfiguration(after = { HttpClientAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class,
		SslAutoConfiguration.class })
@ConditionalOnClass(RestClient.class)
@Conditional(NotReactiveWebApplicationCondition.class)
public class RestClientAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean
	@Order(Ordered.LOWEST_PRECEDENCE)
	HttpMessageConvertersRestClientCustomizer httpMessageConvertersRestClientCustomizer(
			ObjectProvider<HttpMessageConverters> messageConverters) {
		return new HttpMessageConvertersRestClientCustomizer(messageConverters.getIfUnique());
	}
	@Bean
	@ConditionalOnMissingBean(RestClientSsl.class)
	@ConditionalOnBean(SslBundles.class)
	AutoConfiguredRestClientSsl restClientSsl(
			ObjectProvider<ClientHttpRequestFactoryBuilder<?>> clientHttpRequestFactoryBuilder, SslBundles sslBundles) {
		return new AutoConfiguredRestClientSsl(
				clientHttpRequestFactoryBuilder.getIfAvailable(ClientHttpRequestFactoryBuilder::detect), sslBundles);
	}
	@Bean
	@ConditionalOnMissingBean
	RestClientBuilderConfigurer restClientBuilderConfigurer(
			ObjectProvider<ClientHttpRequestFactoryBuilder<?>> clientHttpRequestFactoryBuilder,
			ObjectProvider<ClientHttpRequestFactorySettings> clientHttpRequestFactorySettings,
			ObjectProvider<RestClientCustomizer> customizerProvider) {
		RestClientBuilderConfigurer configurer = new RestClientBuilderConfigurer();
		configurer.setRequestFactoryBuilder(clientHttpRequestFactoryBuilder.getIfAvailable());
		configurer.setRequestFactorySettings(clientHttpRequestFactorySettings.getIfAvailable());
		configurer.setRestClientCustomizers(customizerProvider.orderedStream().toList());
		return configurer;
	}
	@Bean
	@Scope('prototype')
	@ConditionalOnMissingBean
	RestClient.Builder restClientBuilder(RestClientBuilderConfigurer restClientBuilderConfigurer) {
		return restClientBuilderConfigurer.configure(RestClient.builder());
	}
}
/*
package org.springframework.boot.autoconfigure.web.client;
/**
public interface RestClientSsl {
	/**
	 * Return a {@link Consumer} that will apply SSL configuration for the named
	 * {@link SslBundle} to a {@link org.springframework.web.client.RestClient.Builder
	 * RestClient.Builder}.
	 * @param bundleName the name of the SSL bundle to apply
	 * @return a {@link Consumer} to apply the configuration
	 * @throws NoSuchSslBundleException if a bundle with the provided name does not exist
	 */
	Consumer<RestClient.Builder> fromBundle(String bundleName) throws NoSuchSslBundleException;
	/**
	 * Return a {@link Consumer} that will apply SSL configuration for the
	 * {@link SslBundle} to a {@link org.springframework.web.client.RestClient.Builder
	 * RestClient.Builder}.
	 * @param bundle the SSL bundle to apply
	 * @return a {@link Consumer} to apply the configuration
	 */
	Consumer<RestClient.Builder> fromBundle(SslBundle bundle);
}
/*
package org.springframework.boot.autoconfigure.web;
/**
public class ErrorProperties {
	/**
	 * Path of the error controller.
	 */
	@Value('${error.path:/error}')
	private String path = '/error';
	/**
	 * Include the 'exception' attribute.
	 */
	private boolean includeException;
	/**
	 * When to include the 'trace' attribute.
	 */
	private IncludeAttribute includeStacktrace = IncludeAttribute.NEVER;
	/**
	 * When to include 'message' attribute.
	 */
	private IncludeAttribute includeMessage = IncludeAttribute.NEVER;
	/**
	 * When to include 'errors' attribute.
	 */
	private IncludeAttribute includeBindingErrors = IncludeAttribute.NEVER;
	/**
	 * When to include 'path' attribute.
	 */
	private IncludeAttribute includePath = IncludeAttribute.ALWAYS;
	private final Whitelabel whitelabel = new Whitelabel();
	public String getPath() {
		return this.path;
	}
	public void setPath(String path) {
		this.path = path;
	}
	public boolean isIncludeException() {
		return this.includeException;
	}
	public void setIncludeException(boolean includeException) {
		this.includeException = includeException;
	}
	public IncludeAttribute getIncludeStacktrace() {
		return this.includeStacktrace;
	}
	public void setIncludeStacktrace(IncludeAttribute includeStacktrace) {
		this.includeStacktrace = includeStacktrace;
	}
	public IncludeAttribute getIncludeMessage() {
		return this.includeMessage;
	}
	public void setIncludeMessage(IncludeAttribute includeMessage) {
		this.includeMessage = includeMessage;
	}
	public IncludeAttribute getIncludeBindingErrors() {
		return this.includeBindingErrors;
	}
	public void setIncludeBindingErrors(IncludeAttribute includeBindingErrors) {
		this.includeBindingErrors = includeBindingErrors;
	}
	public IncludeAttribute getIncludePath() {
		return this.includePath;
	}
	public void setIncludePath(IncludeAttribute includePath) {
		this.includePath = includePath;
	}
	public Whitelabel getWhitelabel() {
		return this.whitelabel;
	}
	/**
	 * Include Stacktrace attribute options.
	 */
	public enum IncludeStacktrace {
		/**
		 * Never add stacktrace information.
		 */
		NEVER,
		/**
		 * Always add stacktrace information.
		 */
		ALWAYS,
		/**
		 * Add stacktrace attribute when the appropriate request parameter is not 'false'.
		 */
		ON_PARAM
	}
	/**
	 * Include error attributes options.
	 */
	public enum IncludeAttribute {
		/**
		 * Never add error attribute.
		 */
		NEVER,
		/**
		 * Always add error attribute.
		 */
		ALWAYS,
		/**
		 * Add error attribute when the appropriate request parameter is not 'false'.
		 */
		ON_PARAM
	}
	public static class Whitelabel {
		/**
		 * Whether to enable the default error page displayed in browsers in case of a
		 * server error.
		 */
		private boolean enabled = true;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@AutoConfiguration(after = { DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,
		ValidationAutoConfiguration.class })
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@ImportRuntimeHints(WebResourcesRuntimeHints.class)
public class WebMvcAutoConfiguration {
	/**
	 * The default Spring MVC view prefix.
	 */
	public static final String DEFAULT_PREFIX = '';
	/**
	 * The default Spring MVC view suffix.
	 */
	public static final String DEFAULT_SUFFIX = '';
	private static final String SERVLET_LOCATION = '/';
	@Bean
	@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
	@ConditionalOnProperty(prefix = 'spring.mvc.hiddenmethod.filter', name = 'enabled')
	public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
		return new OrderedHiddenHttpMethodFilter();
	}
	@Bean
	@ConditionalOnMissingBean(FormContentFilter.class)
	@ConditionalOnProperty(prefix = 'spring.mvc.formcontent.filter', name = 'enabled', matchIfMissing = true)
	public OrderedFormContentFilter formContentFilter() {
		return new OrderedFormContentFilter();
	}
	// Defined as a nested config to ensure WebMvcConfigurer is not read when not
	// on the classpath
	@Configuration(proxyBeanMethods = false)
	@Import(EnableWebMvcConfiguration.class)
	@EnableConfigurationProperties({ WebMvcProperties.class, WebProperties.class })
	@Order(0)
	public static class WebMvcAutoConfigurationAdapter implements WebMvcConfigurer, ServletContextAware {
		private static final Log logger = LogFactory.getLog(WebMvcConfigurer.class);
		private final Resources resourceProperties;
		private final WebMvcProperties mvcProperties;
		private final ListableBeanFactory beanFactory;
		private final ObjectProvider<HttpMessageConverters> messageConvertersProvider;
		private final ObjectProvider<DispatcherServletPath> dispatcherServletPath;
		private final ObjectProvider<ServletRegistrationBean<?>> servletRegistrations;
		private final ResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer;
		private ServletContext servletContext;
		public WebMvcAutoConfigurationAdapter(WebProperties webProperties, WebMvcProperties mvcProperties,
				ListableBeanFactory beanFactory, ObjectProvider<HttpMessageConverters> messageConvertersProvider,
				ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider,
				ObjectProvider<DispatcherServletPath> dispatcherServletPath,
				ObjectProvider<ServletRegistrationBean<?>> servletRegistrations) {
			this.resourceProperties = webProperties.getResources();
			this.mvcProperties = mvcProperties;
			this.beanFactory = beanFactory;
			this.messageConvertersProvider = messageConvertersProvider;
			this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
			this.dispatcherServletPath = dispatcherServletPath;
			this.servletRegistrations = servletRegistrations;
		}
		@Override
		public void setServletContext(ServletContext servletContext) {
			this.servletContext = servletContext;
		}
		@Override
		public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
			this.messageConvertersProvider
				.ifAvailable((customConverters) -> converters.addAll(customConverters.getConverters()));
		}
		@Override
		public void configureAsyncSupport(AsyncSupportConfigurer configurer) {
			if (this.beanFactory.containsBean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)) {
				Object taskExecutor = this.beanFactory
					.getBean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME);
				if (taskExecutor instanceof AsyncTaskExecutor asyncTaskExecutor) {
					configurer.setTaskExecutor(asyncTaskExecutor);
				}
			}
			Duration timeout = this.mvcProperties.getAsync().getRequestTimeout();
			if (timeout != null) {
				configurer.setDefaultTimeout(timeout.toMillis());
			}
		}
		@Override
		public void configurePathMatch(PathMatchConfigurer configurer) {
			if (this.mvcProperties.getPathmatch()
				.getMatchingStrategy() == WebMvcProperties.MatchingStrategy.ANT_PATH_MATCHER) {
				configurer.setPathMatcher(new AntPathMatcher());
				this.dispatcherServletPath.ifAvailable((dispatcherPath) -> {
					String servletUrlMapping = dispatcherPath.getServletUrlMapping();
					if (servletUrlMapping.equals('/') && singleDispatcherServlet()) {
						UrlPathHelper urlPathHelper = new UrlPathHelper();
						urlPathHelper.setAlwaysUseFullPath(true);
						configurer.setUrlPathHelper(urlPathHelper);
					}
				});
			}
		}
		private boolean singleDispatcherServlet() {
			return this.servletRegistrations.stream()
				.map(ServletRegistrationBean::getServlet)
				.filter(DispatcherServlet.class::isInstance)
				.count() == 1;
		}
		@Override
		public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
			WebMvcProperties.Contentnegotiation contentnegotiation = this.mvcProperties.getContentnegotiation();
			configurer.favorParameter(contentnegotiation.isFavorParameter());
			if (contentnegotiation.getParameterName() != null) {
				configurer.parameterName(contentnegotiation.getParameterName());
			}
			Map<String, MediaType> mediaTypes = this.mvcProperties.getContentnegotiation().getMediaTypes();
			mediaTypes.forEach(configurer::mediaType);
		}
		@Bean
		@ConditionalOnMissingBean
		public InternalResourceViewResolver defaultViewResolver() {
			InternalResourceViewResolver resolver = new InternalResourceViewResolver();
			resolver.setPrefix(this.mvcProperties.getView().getPrefix());
			resolver.setSuffix(this.mvcProperties.getView().getSuffix());
			return resolver;
		}
		@Bean
		@ConditionalOnBean(View.class)
		@ConditionalOnMissingBean
		public BeanNameViewResolver beanNameViewResolver() {
			BeanNameViewResolver resolver = new BeanNameViewResolver();
			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
			return resolver;
		}
		@Bean
		@ConditionalOnBean(ViewResolver.class)
		@ConditionalOnMissingBean(name = 'viewResolver', value = ContentNegotiatingViewResolver.class)
		public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) {
			ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver();
			resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class));
			// ContentNegotiatingViewResolver uses all the other view resolvers to locate
			// a view so it should have a high precedence
			resolver.setOrder(Ordered.HIGHEST_PRECEDENCE);
			return resolver;
		}
		@Override
		public MessageCodesResolver getMessageCodesResolver() {
			if (this.mvcProperties.getMessageCodesResolverFormat() != null) {
				DefaultMessageCodesResolver resolver = new DefaultMessageCodesResolver();
				resolver.setMessageCodeFormatter(this.mvcProperties.getMessageCodesResolverFormat());
				return resolver;
			}
			return null;
		}
		@Override
		public void addFormatters(FormatterRegistry registry) {
			ApplicationConversionService.addBeans(registry, this.beanFactory);
		}
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			if (!this.resourceProperties.isAddMappings()) {
				logger.debug('Default resource handling disabled');
				return;
			}
			addResourceHandler(registry, this.mvcProperties.getWebjarsPathPattern(),
					'classpath:/META-INF/resources/webjars/');
			addResourceHandler(registry, this.mvcProperties.getStaticPathPattern(), (registration) -> {
				registration.addResourceLocations(this.resourceProperties.getStaticLocations());
				if (this.servletContext != null) {
					ServletContextResource resource = new ServletContextResource(this.servletContext, SERVLET_LOCATION);
					registration.addResourceLocations(resource);
				}
			});
		}
		private void addResourceHandler(ResourceHandlerRegistry registry, String pattern, String... locations) {
			addResourceHandler(registry, pattern, (registration) -> registration.addResourceLocations(locations));
		}
		private void addResourceHandler(ResourceHandlerRegistry registry, String pattern,
				Consumer<ResourceHandlerRegistration> customizer) {
			if (registry.hasMappingForPattern(pattern)) {
				return;
			}
			ResourceHandlerRegistration registration = registry.addResourceHandler(pattern);
			customizer.accept(registration);
			registration.setCachePeriod(getSeconds(this.resourceProperties.getCache().getPeriod()));
			registration.setCacheControl(this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl());
			registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());
			customizeResourceHandlerRegistration(registration);
		}
		private Integer getSeconds(Duration cachePeriod) {
			return (cachePeriod != null) ? (int) cachePeriod.getSeconds() : null;
		}
		private void customizeResourceHandlerRegistration(ResourceHandlerRegistration registration) {
			if (this.resourceHandlerRegistrationCustomizer != null) {
				this.resourceHandlerRegistrationCustomizer.customize(registration);
			}
		}
		@Bean
		@ConditionalOnMissingBean({ RequestContextListener.class, RequestContextFilter.class })
		@ConditionalOnMissingFilterBean(RequestContextFilter.class)
		public static RequestContextFilter requestContextFilter() {
			return new OrderedRequestContextFilter();
		}
	}
	/**
	 * Configuration equivalent to {@code @EnableWebMvc}.
	 */
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(WebProperties.class)
	public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration implements ResourceLoaderAware {
		private final Resources resourceProperties;
		private final WebMvcProperties mvcProperties;
		private final WebProperties webProperties;
		private final ListableBeanFactory beanFactory;
		private final WebMvcRegistrations mvcRegistrations;
		private ResourceLoader resourceLoader;
		public EnableWebMvcConfiguration(WebMvcProperties mvcProperties, WebProperties webProperties,
				ObjectProvider<WebMvcRegistrations> mvcRegistrationsProvider,
				ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizerProvider,
				ListableBeanFactory beanFactory) {
			this.resourceProperties = webProperties.getResources();
			this.mvcProperties = mvcProperties;
			this.webProperties = webProperties;
			this.mvcRegistrations = mvcRegistrationsProvider.getIfUnique();
			this.beanFactory = beanFactory;
		}
		@Override
		protected RequestMappingHandlerAdapter createRequestMappingHandlerAdapter() {
			if (this.mvcRegistrations != null) {
				RequestMappingHandlerAdapter adapter = this.mvcRegistrations.getRequestMappingHandlerAdapter();
				if (adapter != null) {
					return adapter;
				}
			}
			return super.createRequestMappingHandlerAdapter();
		}
		@Bean
		public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext,
				FormattingConversionService mvcConversionService, ResourceUrlProvider mvcResourceUrlProvider) {
			return createWelcomePageHandlerMapping(applicationContext, mvcConversionService, mvcResourceUrlProvider,
					WelcomePageHandlerMapping::new);
		}
		@Bean
		public WelcomePageNotAcceptableHandlerMapping welcomePageNotAcceptableHandlerMapping(
				ApplicationContext applicationContext, FormattingConversionService mvcConversionService,
				ResourceUrlProvider mvcResourceUrlProvider) {
			return createWelcomePageHandlerMapping(applicationContext, mvcConversionService, mvcResourceUrlProvider,
					WelcomePageNotAcceptableHandlerMapping::new);
		}
		private <T extends AbstractUrlHandlerMapping> T createWelcomePageHandlerMapping(
				ApplicationContext applicationContext, FormattingConversionService mvcConversionService,
				ResourceUrlProvider mvcResourceUrlProvider, WelcomePageHandlerMappingFactory<T> factory) {
			TemplateAvailabilityProviders templateAvailabilityProviders = new TemplateAvailabilityProviders(
					applicationContext);
			String staticPathPattern = this.mvcProperties.getStaticPathPattern();
			T handlerMapping = factory.create(templateAvailabilityProviders, applicationContext, getIndexHtmlResource(),
					staticPathPattern);
			handlerMapping.setInterceptors(getInterceptors(mvcConversionService, mvcResourceUrlProvider));
			handlerMapping.setCorsConfigurations(getCorsConfigurations());
			return handlerMapping;
		}
		@Override
		@Bean
		@ConditionalOnMissingBean(name = DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME)
		public LocaleResolver localeResolver() {
			if (this.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) {
				return new FixedLocaleResolver(this.webProperties.getLocale());
			}
			AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();
			localeResolver.setDefaultLocale(this.webProperties.getLocale());
			return localeResolver;
		}
		@Override
		@Bean
		@ConditionalOnMissingBean(name = DispatcherServlet.THEME_RESOLVER_BEAN_NAME)
		@Deprecated(since = '3.0.0', forRemoval = false)
		@SuppressWarnings('deprecation')
		public org.springframework.web.servlet.ThemeResolver themeResolver() {
			return super.themeResolver();
		}
		@Override
		@Bean
		@ConditionalOnMissingBean(name = DispatcherServlet.FLASH_MAP_MANAGER_BEAN_NAME)
		public FlashMapManager flashMapManager() {
			return super.flashMapManager();
		}
		@Override
		@Bean
		@ConditionalOnMissingBean(name = DispatcherServlet.REQUEST_TO_VIEW_NAME_TRANSLATOR_BEAN_NAME)
		public RequestToViewNameTranslator viewNameTranslator() {
			return super.viewNameTranslator();
		}
		private Resource getIndexHtmlResource() {
			for (String location : this.resourceProperties.getStaticLocations()) {
				Resource indexHtml = getIndexHtmlResource(location);
				if (indexHtml != null) {
					return indexHtml;
				}
			}
			ServletContext servletContext = getServletContext();
			if (servletContext != null) {
				return getIndexHtmlResource(new ServletContextResource(servletContext, SERVLET_LOCATION));
			}
			return null;
		}
		private Resource getIndexHtmlResource(String location) {
			return getIndexHtmlResource(this.resourceLoader.getResource(location));
		}
		private Resource getIndexHtmlResource(Resource location) {
			try {
				Resource resource = location.createRelative('index.html');
				if (resource.exists() && (resource.getURL() != null)) {
					return resource;
				}
			}
			catch (Exception ex) {
				// Ignore
			}
			return null;
		}
		@Bean
		@Override
		public FormattingConversionService mvcConversionService() {
			Format format = this.mvcProperties.getFormat();
			WebConversionService conversionService = new WebConversionService(
					new DateTimeFormatters().dateFormat(format.getDate())
						.timeFormat(format.getTime())
						.dateTimeFormat(format.getDateTime()));
			addFormatters(conversionService);
			return conversionService;
		}
		@Bean
		@Override
		public Validator mvcValidator() {
			if (!ClassUtils.isPresent('jakarta.validation.Validator', getClass().getClassLoader())) {
				return super.mvcValidator();
			}
			return ValidatorAdapter.get(getApplicationContext(), getValidator());
		}
		@Override
		protected RequestMappingHandlerMapping createRequestMappingHandlerMapping() {
			if (this.mvcRegistrations != null) {
				RequestMappingHandlerMapping mapping = this.mvcRegistrations.getRequestMappingHandlerMapping();
				if (mapping != null) {
					return mapping;
				}
			}
			return super.createRequestMappingHandlerMapping();
		}
		@Override
		protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer(
				FormattingConversionService mvcConversionService, Validator mvcValidator) {
			try {
				return this.beanFactory.getBean(ConfigurableWebBindingInitializer.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				return super.getConfigurableWebBindingInitializer(mvcConversionService, mvcValidator);
			}
		}
		@Override
		protected ExceptionHandlerExceptionResolver createExceptionHandlerExceptionResolver() {
			if (this.mvcRegistrations != null) {
				ExceptionHandlerExceptionResolver resolver = this.mvcRegistrations
					.getExceptionHandlerExceptionResolver();
				if (resolver != null) {
					return resolver;
				}
			}
			return super.createExceptionHandlerExceptionResolver();
		}
		@Override
		protected void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {
			super.extendHandlerExceptionResolvers(exceptionResolvers);
			if (this.mvcProperties.isLogResolvedException()) {
				for (HandlerExceptionResolver resolver : exceptionResolvers) {
					if (resolver instanceof AbstractHandlerExceptionResolver abstractResolver) {
						abstractResolver.setWarnLogCategory(resolver.getClass().getName());
					}
				}
			}
		}
		@Bean
		@Override
		@SuppressWarnings('deprecation')
		public ContentNegotiationManager mvcContentNegotiationManager() {
			ContentNegotiationManager manager = super.mvcContentNegotiationManager();
			List<ContentNegotiationStrategy> strategies = manager.getStrategies();
			ListIterator<ContentNegotiationStrategy> iterator = strategies.listIterator();
			while (iterator.hasNext()) {
				ContentNegotiationStrategy strategy = iterator.next();
				if (strategy instanceof org.springframework.web.accept.PathExtensionContentNegotiationStrategy) {
					iterator.set(new OptionalPathExtensionContentNegotiationStrategy(strategy));
				}
			}
			return manager;
		}
		@Override
		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnEnabledResourceChain
	static class ResourceChainCustomizerConfiguration {
		@Bean
		ResourceChainResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer(
				WebProperties webProperties) {
			return new ResourceChainResourceHandlerRegistrationCustomizer(webProperties.getResources());
		}
	}
	@FunctionalInterface
	interface WelcomePageHandlerMappingFactory<T extends AbstractUrlHandlerMapping> {
		T create(TemplateAvailabilityProviders templateAvailabilityProviders, ApplicationContext applicationContext,
				Resource indexHtmlResource, String staticPathPattern);
	}
	@FunctionalInterface
	interface ResourceHandlerRegistrationCustomizer {
		void customize(ResourceHandlerRegistration registration);
	}
	static class ResourceChainResourceHandlerRegistrationCustomizer implements ResourceHandlerRegistrationCustomizer {
		private final Resources resourceProperties;
		ResourceChainResourceHandlerRegistrationCustomizer(Resources resourceProperties) {
			this.resourceProperties = resourceProperties;
		}
		@Override
		public void customize(ResourceHandlerRegistration registration) {
			Resources.Chain properties = this.resourceProperties.getChain();
			configureResourceChain(properties, registration.resourceChain(properties.isCache()));
		}
		private void configureResourceChain(Resources.Chain properties, ResourceChainRegistration chain) {
			Strategy strategy = properties.getStrategy();
			if (properties.isCompressed()) {
				chain.addResolver(new EncodedResourceResolver());
			}
			if (strategy.getFixed().isEnabled() || strategy.getContent().isEnabled()) {
				chain.addResolver(getVersionResourceResolver(strategy));
			}
		}
		private ResourceResolver getVersionResourceResolver(Strategy properties) {
			VersionResourceResolver resolver = new VersionResourceResolver();
			if (properties.getFixed().isEnabled()) {
				String version = properties.getFixed().getVersion();
				String[] paths = properties.getFixed().getPaths();
				resolver.addFixedVersionStrategy(version, paths);
			}
			if (properties.getContent().isEnabled()) {
				String[] paths = properties.getContent().getPaths();
				resolver.addContentVersionStrategy(paths);
			}
			return resolver;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.mvc.problemdetails', name = 'enabled', havingValue = 'true')
	static class ProblemDetailsErrorHandlingConfiguration {
		@Bean
		@ConditionalOnMissingBean(ResponseEntityExceptionHandler.class)
		@Order(0)
		ProblemDetailsExceptionHandler problemDetailsExceptionHandler() {
			return new ProblemDetailsExceptionHandler();
		}
	}
	/**
	 * Decorator to make
	 * {@link org.springframework.web.accept.PathExtensionContentNegotiationStrategy}
	 * optional depending on a request attribute.
	 */
	static class OptionalPathExtensionContentNegotiationStrategy implements ContentNegotiationStrategy {
		@SuppressWarnings('deprecation')
		private static final String SKIP_ATTRIBUTE = org.springframework.web.accept.PathExtensionContentNegotiationStrategy.class
			.getName() + '.SKIP';
		private final ContentNegotiationStrategy delegate;
		OptionalPathExtensionContentNegotiationStrategy(ContentNegotiationStrategy delegate) {
			this.delegate = delegate;
		}
		@Override
		public List<MediaType> resolveMediaTypes(NativeWebRequest webRequest)
				throws HttpMediaTypeNotAcceptableException {
			Object skip = webRequest.getAttribute(SKIP_ATTRIBUTE, RequestAttributes.SCOPE_REQUEST);
			if (skip != null && Boolean.parseBoolean(skip.toString())) {
				return MEDIA_TYPE_ALL_LIST;
			}
			return this.delegate.resolveMediaTypes(webRequest);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@ConfigurationProperties(prefix = 'spring.mvc')
public class WebMvcProperties {
	/**
	 * Formatting strategy for message codes. For instance, "PREFIX_ERROR_CODE".
	 */
	private DefaultMessageCodesResolver.Format messageCodesResolverFormat;
	private final Format format = new Format();
	/**
	 * Whether to dispatch TRACE requests to the FrameworkServlet doService method.
	 */
	private boolean dispatchTraceRequest = false;
	/**
	 * Whether to dispatch OPTIONS requests to the FrameworkServlet doService method.
	 */
	private boolean dispatchOptionsRequest = true;
	/**
	 * Whether to publish a ServletRequestHandledEvent at the end of each request.
	 */
	private boolean publishRequestHandledEvents = true;
	/**
	 * Whether logging of (potentially sensitive) request details at DEBUG and TRACE level
	 * is allowed.
	 */
	private boolean logRequestDetails;
	/**
	 * Whether to enable warn logging of exceptions resolved by a
	 * 'HandlerExceptionResolver', except for 'DefaultHandlerExceptionResolver'.
	 */
	private boolean logResolvedException = false;
	/**
	 * Path pattern used for static resources.
	 */
	private String staticPathPattern = '/**';
	/**
	 * Path pattern used for WebJar assets.
	 */
	private String webjarsPathPattern = '/webjars/**';
	private final Async async = new Async();
	private final Servlet servlet = new Servlet();
	private final View view = new View();
	private final Contentnegotiation contentnegotiation = new Contentnegotiation();
	private final Pathmatch pathmatch = new Pathmatch();
	private final Problemdetails problemdetails = new Problemdetails();
	public DefaultMessageCodesResolver.Format getMessageCodesResolverFormat() {
		return this.messageCodesResolverFormat;
	}
	public void setMessageCodesResolverFormat(DefaultMessageCodesResolver.Format messageCodesResolverFormat) {
		this.messageCodesResolverFormat = messageCodesResolverFormat;
	}
	public Format getFormat() {
		return this.format;
	}
	public boolean isPublishRequestHandledEvents() {
		return this.publishRequestHandledEvents;
	}
	public void setPublishRequestHandledEvents(boolean publishRequestHandledEvents) {
		this.publishRequestHandledEvents = publishRequestHandledEvents;
	}
	public boolean isLogRequestDetails() {
		return this.logRequestDetails;
	}
	public void setLogRequestDetails(boolean logRequestDetails) {
		this.logRequestDetails = logRequestDetails;
	}
	public boolean isLogResolvedException() {
		return this.logResolvedException;
	}
	public void setLogResolvedException(boolean logResolvedException) {
		this.logResolvedException = logResolvedException;
	}
	public boolean isDispatchOptionsRequest() {
		return this.dispatchOptionsRequest;
	}
	public void setDispatchOptionsRequest(boolean dispatchOptionsRequest) {
		this.dispatchOptionsRequest = dispatchOptionsRequest;
	}
	public boolean isDispatchTraceRequest() {
		return this.dispatchTraceRequest;
	}
	public void setDispatchTraceRequest(boolean dispatchTraceRequest) {
		this.dispatchTraceRequest = dispatchTraceRequest;
	}
	public String getStaticPathPattern() {
		return this.staticPathPattern;
	}
	public void setStaticPathPattern(String staticPathPattern) {
		this.staticPathPattern = staticPathPattern;
	}
	public String getWebjarsPathPattern() {
		return this.webjarsPathPattern;
	}
	public void setWebjarsPathPattern(String webjarsPathPattern) {
		this.webjarsPathPattern = webjarsPathPattern;
	}
	public Async getAsync() {
		return this.async;
	}
	public Servlet getServlet() {
		return this.servlet;
	}
	public View getView() {
		return this.view;
	}
	public Contentnegotiation getContentnegotiation() {
		return this.contentnegotiation;
	}
	public Pathmatch getPathmatch() {
		return this.pathmatch;
	}
	public Problemdetails getProblemdetails() {
		return this.problemdetails;
	}
	public static class Async {
		/**
		 * Amount of time before asynchronous request handling times out. If this value is
		 * not set, the default timeout of the underlying implementation is used.
		 */
		private Duration requestTimeout;
		public Duration getRequestTimeout() {
			return this.requestTimeout;
		}
		public void setRequestTimeout(Duration requestTimeout) {
			this.requestTimeout = requestTimeout;
		}
	}
	public static class Servlet {
		/**
		 * Path of the dispatcher servlet. Setting a custom value for this property is not
		 * compatible with the PathPatternParser matching strategy.
		 */
		private String path = '/';
		/**
		 * Load on startup priority of the dispatcher servlet.
		 */
		private int loadOnStartup = -1;
		public String getPath() {
			return this.path;
		}
		public void setPath(String path) {
			Assert.notNull(path, 'Path must not be null');
			Assert.isTrue(!path.contains('*'), 'Path must not contain wildcards');
			this.path = path;
		}
		public int getLoadOnStartup() {
			return this.loadOnStartup;
		}
		public void setLoadOnStartup(int loadOnStartup) {
			this.loadOnStartup = loadOnStartup;
		}
		public String getServletMapping() {
			if (this.path.isEmpty() || this.path.equals('/')) {
				return '/';
			}
			if (this.path.endsWith('/')) {
				return this.path + '*';
			}
			return this.path + '/*';
		}
		public String getPath(String path) {
			String prefix = getServletPrefix();
			if (!path.startsWith('/')) {
				path = '/' + path;
			}
			return prefix + path;
		}
		public String getServletPrefix() {
			String result = this.path;
			int index = result.indexOf("*");
			if (index != -1) {
				result = result.substring(0, index);
			}
			if (result.endsWith('/')) {
				result = result.substring(0, result.length() - 1);
			}
			return result;
		}
	}
	public static class View {
		/**
		 * Spring MVC view prefix.
		 */
		private String prefix;
		/**
		 * Spring MVC view suffix.
		 */
		private String suffix;
		public String getPrefix() {
			return this.prefix;
		}
		public void setPrefix(String prefix) {
			this.prefix = prefix;
		}
		public String getSuffix() {
			return this.suffix;
		}
		public void setSuffix(String suffix) {
			this.suffix = suffix;
		}
	}
	public static class Contentnegotiation {
		/**
		 * Whether a request parameter ('format' by default) should be used to determine
		 * the requested media type.
		 */
		private boolean favorParameter = false;
		/**
		 * Map file extensions to media types for content negotiation. For instance, yml
		 * to text/yaml.
		 */
		private Map<String, MediaType> mediaTypes = new LinkedHashMap<>();
		/**
		 * Query parameter name to use when 'favor-parameter' is enabled.
		 */
		private String parameterName;
		public boolean isFavorParameter() {
			return this.favorParameter;
		}
		public void setFavorParameter(boolean favorParameter) {
			this.favorParameter = favorParameter;
		}
		public Map<String, MediaType> getMediaTypes() {
			return this.mediaTypes;
		}
		public void setMediaTypes(Map<String, MediaType> mediaTypes) {
			this.mediaTypes = mediaTypes;
		}
		public String getParameterName() {
			return this.parameterName;
		}
		public void setParameterName(String parameterName) {
			this.parameterName = parameterName;
		}
	}
	public static class Pathmatch {
		/**
		 * Choice of strategy for matching request paths against registered mappings.
		 */
		private MatchingStrategy matchingStrategy = MatchingStrategy.PATH_PATTERN_PARSER;
		public MatchingStrategy getMatchingStrategy() {
			return this.matchingStrategy;
		}
		public void setMatchingStrategy(MatchingStrategy matchingStrategy) {
			this.matchingStrategy = matchingStrategy;
		}
	}
	public static class Format {
		/**
		 * Date format to use, for example "dd/MM/yyyy". Used for formatting of
		 * java.util.Date and java.time.LocalDate.
		 */
		private String date;
		/**
		 * Time format to use, for example "HH:mm:ss". Used for formatting of java.time"s
		 * LocalTime and OffsetTime.
		 */
		private String time;
		/**
		 * Date-time format to use, for example "yyyy-MM-dd HH:mm:ss". Used for formatting
		 * of java.time"s LocalDateTime, OffsetDateTime, and ZonedDateTime.
		 */
		private String dateTime;
		public String getDate() {
			return this.date;
		}
		public void setDate(String date) {
			this.date = date;
		}
		public String getTime() {
			return this.time;
		}
		public void setTime(String time) {
			this.time = time;
		}
		public String getDateTime() {
			return this.dateTime;
		}
		public void setDateTime(String dateTime) {
			this.dateTime = dateTime;
		}
	}
	/**
	 * Matching strategy options.
	 *
	 * @since 2.4.0
	 */
	public enum MatchingStrategy {
		/**
		 * Use the {@code AntPathMatcher} implementation.
		 */
		ANT_PATH_MATCHER,
		/**
		 * Use the {@code PathPatternParser} implementation.
		 */
		PATH_PATTERN_PARSER
	}
	public static class Problemdetails {
		/**
		 * Whether RFC 9457 Problem Details support should be enabled.
		 */
		private boolean enabled = false;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@FunctionalInterface
public interface DispatcherServletPath {
	/**
	 * Returns the configured path of the dispatcher servlet.
	 * @return the configured path
	 */
	String getPath();
	/**
	 * Return a form of the given path that"s relative to the dispatcher servlet path.
	 * @param path the path to make relative
	 * @return the relative path
	 */
	default String getRelativePath(String path) {
		String prefix = getPrefix();
		if (!path.startsWith('/')) {
			path = '/' + path;
		}
		return prefix + path;
	}
	/**
	 * Return a cleaned up version of the path that can be used as a prefix for URLs. The
	 * resulting path will have path will not have a trailing slash.
	 * @return the prefix
	 * @see #getRelativePath(String)
	 */
	default String getPrefix() {
		String result = getPath();
		int index = result.indexOf("*");
		if (index != -1) {
			result = result.substring(0, index);
		}
		if (result.endsWith('/')) {
			result = result.substring(0, result.length() - 1);
		}
		return result;
	}
	/**
	 * Return a URL mapping pattern that can be used with a
	 * {@link ServletRegistrationBean} to map the dispatcher servlet.
	 * @return the path as a servlet URL mapping
	 */
	default String getServletUrlMapping() {
		if (getPath().isEmpty() || getPath().equals('/')) {
			return '/';
		}
		if (getPath().contains('*')) {
			return getPath();
		}
		if (getPath().endsWith('/')) {
			return getPath() + '*';
		}
		return getPath() + '/*';
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
@Controller
@RequestMapping('${server.error.path:${error.path:/error}}')
public class BasicErrorController extends AbstractErrorController {
	private final ErrorProperties errorProperties;
	/**
	 * Create a new {@link BasicErrorController} instance.
	 * @param errorAttributes the error attributes
	 * @param errorProperties configuration properties
	 */
	public BasicErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties) {
		this(errorAttributes, errorProperties, Collections.emptyList());
	}
	/**
	 * Create a new {@link BasicErrorController} instance.
	 * @param errorAttributes the error attributes
	 * @param errorProperties configuration properties
	 * @param errorViewResolvers error view resolvers
	 */
	public BasicErrorController(ErrorAttributes errorAttributes, ErrorProperties errorProperties,
			List<ErrorViewResolver> errorViewResolvers) {
		super(errorAttributes, errorViewResolvers);
		Assert.notNull(errorProperties, 'ErrorProperties must not be null');
		this.errorProperties = errorProperties;
	}
	@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)
	public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {
		HttpStatus status = getStatus(request);
		Map<String, Object> model = Collections
			.unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));
		response.setStatus(status.value());
		ModelAndView modelAndView = resolveErrorView(request, response, status, model);
		return (modelAndView != null) ? modelAndView : new ModelAndView('error', model);
	}
	@RequestMapping
	public ResponseEntity<Map<String, Object>> error(HttpServletRequest request) {
		HttpStatus status = getStatus(request);
		if (status == HttpStatus.NO_CONTENT) {
			return new ResponseEntity<>(status);
		}
		Map<String, Object> body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL));
		return new ResponseEntity<>(body, status);
	}
	@ExceptionHandler(HttpMediaTypeNotAcceptableException.class)
	public ResponseEntity<String> mediaTypeNotAcceptable(HttpServletRequest request) {
		HttpStatus status = getStatus(request);
		return ResponseEntity.status(status).build();
	}
	protected ErrorAttributeOptions getErrorAttributeOptions(HttpServletRequest request, MediaType mediaType) {
		ErrorAttributeOptions options = ErrorAttributeOptions.defaults();
		if (this.errorProperties.isIncludeException()) {
			options = options.including(Include.EXCEPTION);
		}
		if (isIncludeStackTrace(request, mediaType)) {
			options = options.including(Include.STACK_TRACE);
		}
		if (isIncludeMessage(request, mediaType)) {
			options = options.including(Include.MESSAGE);
		}
		if (isIncludeBindingErrors(request, mediaType)) {
			options = options.including(Include.BINDING_ERRORS);
		}
		options = isIncludePath(request, mediaType) ? options.including(Include.PATH) : options.excluding(Include.PATH);
		return options;
	}
	/**
	 * Determine if the stacktrace attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the stacktrace attribute should be included
	 */
	protected boolean isIncludeStackTrace(HttpServletRequest request, MediaType produces) {
		return switch (getErrorProperties().getIncludeStacktrace()) {
			case ALWAYS -> true;
			case ON_PARAM -> getTraceParameter(request);
			case NEVER -> false;
		};
	}
	/**
	 * Determine if the message attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the message attribute should be included
	 */
	protected boolean isIncludeMessage(HttpServletRequest request, MediaType produces) {
		return switch (getErrorProperties().getIncludeMessage()) {
			case ALWAYS -> true;
			case ON_PARAM -> getMessageParameter(request);
			case NEVER -> false;
		};
	}
	/**
	 * Determine if the errors attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the errors attribute should be included
	 */
	protected boolean isIncludeBindingErrors(HttpServletRequest request, MediaType produces) {
		return switch (getErrorProperties().getIncludeBindingErrors()) {
			case ALWAYS -> true;
			case ON_PARAM -> getErrorsParameter(request);
			case NEVER -> false;
		};
	}
	/**
	 * Determine if the path attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the path attribute should be included
	 * @since 3.3.0
	 */
	protected boolean isIncludePath(HttpServletRequest request, MediaType produces) {
		return switch (getErrorProperties().getIncludePath()) {
			case ALWAYS -> true;
			case ON_PARAM -> getPathParameter(request);
			case NEVER -> false;
		};
	}
	/**
	 * Provide access to the error properties.
	 * @return the error properties
	 */
	protected ErrorProperties getErrorProperties() {
		return this.errorProperties;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
// Load before the main WebMvcAutoConfiguration so that the error View is available
@AutoConfiguration(before = WebMvcAutoConfiguration.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class })
@EnableConfigurationProperties({ ServerProperties.class, WebMvcProperties.class })
public class ErrorMvcAutoConfiguration {
	private final ServerProperties serverProperties;
	public ErrorMvcAutoConfiguration(ServerProperties serverProperties) {
		this.serverProperties = serverProperties;
	}
	@Bean
	@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)
	public DefaultErrorAttributes errorAttributes() {
		return new DefaultErrorAttributes();
	}
	@Bean
	@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)
	public BasicErrorController basicErrorController(ErrorAttributes errorAttributes,
			ObjectProvider<ErrorViewResolver> errorViewResolvers) {
		return new BasicErrorController(errorAttributes, this.serverProperties.getError(),
				errorViewResolvers.orderedStream().toList());
	}
	@Bean
	public ErrorPageCustomizer errorPageCustomizer(DispatcherServletPath dispatcherServletPath) {
		return new ErrorPageCustomizer(this.serverProperties, dispatcherServletPath);
	}
	@Bean
	public static PreserveErrorControllerTargetClassPostProcessor preserveErrorControllerTargetClassPostProcessor() {
		return new PreserveErrorControllerTargetClassPostProcessor();
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties({ WebProperties.class, WebMvcProperties.class })
	static class DefaultErrorViewResolverConfiguration {
		private final ApplicationContext applicationContext;
		private final Resources resources;
		DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext, WebProperties webProperties) {
			this.applicationContext = applicationContext;
			this.resources = webProperties.getResources();
		}
		@Bean
		@ConditionalOnBean(DispatcherServlet.class)
		@ConditionalOnMissingBean(ErrorViewResolver.class)
		DefaultErrorViewResolver conventionErrorViewResolver() {
			return new DefaultErrorViewResolver(this.applicationContext, this.resources);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'server.error.whitelabel', name = 'enabled', matchIfMissing = true)
	@Conditional(ErrorTemplateMissingCondition.class)
	protected static class WhitelabelErrorViewConfiguration {
		private final StaticView defaultErrorView = new StaticView();
		@Bean(name = 'error')
		@ConditionalOnMissingBean(name = 'error')
		public View defaultErrorView() {
			return this.defaultErrorView;
		}
		// If the user adds @EnableWebMvc then the bean name view resolver from
		// WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.
		@Bean
		@ConditionalOnMissingBean
		public BeanNameViewResolver beanNameViewResolver() {
			BeanNameViewResolver resolver = new BeanNameViewResolver();
			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10);
			return resolver;
		}
	}
	/**
	 * {@link SpringBootCondition} that matches when no error template view is detected.
	 */
	private static final class ErrorTemplateMissingCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('ErrorTemplate Missing');
			TemplateAvailabilityProviders providers = new TemplateAvailabilityProviders(context.getClassLoader());
			TemplateAvailabilityProvider provider = providers.getProvider('error', context.getEnvironment(),
					context.getClassLoader(), context.getResourceLoader());
			if (provider != null) {
				return ConditionOutcome.noMatch(message.foundExactly('template from ' + provider));
			}
			return ConditionOutcome.match(message.didNotFind('error template view').atAll());
		}
	}
	/**
	 * Simple {@link View} implementation that writes a default HTML error page.
	 */
	private static final class StaticView implements View {
		private static final MediaType TEXT_HTML_UTF8 = new MediaType('text', 'html', StandardCharsets.UTF_8);
		private static final Log logger = LogFactory.getLog(StaticView.class);
		@Override
		public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)
				throws Exception {
			if (response.isCommitted()) {
				String message = getMessage(model);
				logger.error(message);
				return;
			}
			response.setContentType(TEXT_HTML_UTF8.toString());
			StringBuilder builder = new StringBuilder();
			Object timestamp = model.get('timestamp');
			Object message = model.get('message');
			Object trace = model.get('trace');
			if (response.getContentType() == null) {
				response.setContentType(getContentType());
			}
			builder.append('<html><body><h1>Whitelabel Error Page</h1>')
				.append('<p>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p>')
				.append('<div id="created">')
				.append(timestamp)
				.append('</div>')
				.append('<div>There was an unexpected error (type=')
				.append(htmlEscape(model.get('error')))
				.append(', status=')
				.append(htmlEscape(model.get('status')))
				.append(').</div>');
			if (message != null) {
				builder.append('<div>').append(htmlEscape(message)).append('</div>');
			}
			if (trace != null) {
				builder.append('<div style="white-space:pre-wrap;">').append(htmlEscape(trace)).append('</div>');
			}
			builder.append('</body></html>');
			response.getWriter().append(builder.toString());
		}
		private String htmlEscape(Object input) {
			return (input != null) ? HtmlUtils.htmlEscape(input.toString()) : null;
		}
		private String getMessage(Map<String, ?> model) {
			Object path = model.get('path');
			String message = 'Cannot render error page for request [' + path + ']';
			if (model.get('message') != null) {
				message += ' and exception [' + model.get('message') + ']';
			}
			message += ' as the response has already been committed.';
			message += ' As a result, the response may have the wrong status code.';
			return message;
		}
		@Override
		public String getContentType() {
			return 'text/html';
		}
	}
	/**
	 * {@link WebServerFactoryCustomizer} that configures the server"s error pages.
	 */
	static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered {
		private final ServerProperties properties;
		private final DispatcherServletPath dispatcherServletPath;
		protected ErrorPageCustomizer(ServerProperties properties, DispatcherServletPath dispatcherServletPath) {
			this.properties = properties;
			this.dispatcherServletPath = dispatcherServletPath;
		}
		@Override
		public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {
			ErrorPage errorPage = new ErrorPage(
					this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath()));
			errorPageRegistry.addErrorPages(errorPage);
		}
		@Override
		public int getOrder() {
			return 0;
		}
	}
	/**
	 * {@link BeanFactoryPostProcessor} to ensure that the target class of ErrorController
	 * MVC beans are preserved when using AOP.
	 */
	static class PreserveErrorControllerTargetClassPostProcessor implements BeanFactoryPostProcessor {
		@Override
		public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
			String[] errorControllerBeans = beanFactory.getBeanNamesForType(ErrorController.class, false, false);
			for (String errorControllerBean : errorControllerBeans) {
				try {
					beanFactory.getBeanDefinition(errorControllerBean)
						.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);
				}
				catch (Throwable ex) {
					// Ignore
				}
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
@FunctionalInterface
public interface ErrorViewResolver {
	/**
	 * Resolve an error view for the specified details.
	 * @param request the source request
	 * @param status the http status of the error
	 * @param model the suggested model to be used with the view
	 * @return a resolved {@link ModelAndView} or {@code null}
	 */
	ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model);
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
public abstract class AbstractErrorController implements ErrorController {
	private final ErrorAttributes errorAttributes;
	private final List<ErrorViewResolver> errorViewResolvers;
	public AbstractErrorController(ErrorAttributes errorAttributes) {
		this(errorAttributes, null);
	}
	public AbstractErrorController(ErrorAttributes errorAttributes, List<ErrorViewResolver> errorViewResolvers) {
		Assert.notNull(errorAttributes, 'ErrorAttributes must not be null');
		this.errorAttributes = errorAttributes;
		this.errorViewResolvers = sortErrorViewResolvers(errorViewResolvers);
	}
	private List<ErrorViewResolver> sortErrorViewResolvers(List<ErrorViewResolver> resolvers) {
		List<ErrorViewResolver> sorted = new ArrayList<>();
		if (resolvers != null) {
			sorted.addAll(resolvers);
			AnnotationAwareOrderComparator.sortIfNecessary(sorted);
		}
		return sorted;
	}
	protected Map<String, Object> getErrorAttributes(HttpServletRequest request, ErrorAttributeOptions options) {
		WebRequest webRequest = new ServletWebRequest(request);
		return this.errorAttributes.getErrorAttributes(webRequest, options);
	}
	/**
	 * Returns whether the trace parameter is set.
	 * @param request the request
	 * @return whether the trace parameter is set
	 */
	protected boolean getTraceParameter(HttpServletRequest request) {
		return getBooleanParameter(request, 'trace');
	}
	/**
	 * Returns whether the message parameter is set.
	 * @param request the request
	 * @return whether the message parameter is set
	 */
	protected boolean getMessageParameter(HttpServletRequest request) {
		return getBooleanParameter(request, 'message');
	}
	/**
	 * Returns whether the errors parameter is set.
	 * @param request the request
	 * @return whether the errors parameter is set
	 */
	protected boolean getErrorsParameter(HttpServletRequest request) {
		return getBooleanParameter(request, 'errors');
	}
	/**
	 * Returns whether the path parameter is set.
	 * @param request the request
	 * @return whether the path parameter is set
	 * @since 3.3.0
	 */
	protected boolean getPathParameter(HttpServletRequest request) {
		return getBooleanParameter(request, 'path');
	}
	protected boolean getBooleanParameter(HttpServletRequest request, String parameterName) {
		String parameter = request.getParameter(parameterName);
		if (parameter == null) {
			return false;
		}
		return !'false'.equalsIgnoreCase(parameter);
	}
	protected HttpStatus getStatus(HttpServletRequest request) {
		Integer statusCode = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
		if (statusCode == null) {
			return HttpStatus.INTERNAL_SERVER_ERROR;
		}
		try {
			return HttpStatus.valueOf(statusCode);
		}
		catch (Exception ex) {
			return HttpStatus.INTERNAL_SERVER_ERROR;
		}
	}
	/**
	 * Resolve any specific error views. By default this method delegates to
	 * {@link ErrorViewResolver ErrorViewResolvers}.
	 * @param request the request
	 * @param response the response
	 * @param status the HTTP status
	 * @param model the suggested model
	 * @return a specific {@link ModelAndView} or {@code null} if the default should be
	 * used
	 * @since 1.4.0
	 */
	protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status,
			Map<String, Object> model) {
		for (ErrorViewResolver resolver : this.errorViewResolvers) {
			ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);
			if (modelAndView != null) {
				return modelAndView;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet.error;
/**
public class DefaultErrorViewResolver implements ErrorViewResolver, Ordered {
	private static final Map<Series, String> SERIES_VIEWS;
	static {
		Map<Series, String> views = new EnumMap<>(Series.class);
		views.put(Series.CLIENT_ERROR, '4xx');
		views.put(Series.SERVER_ERROR, '5xx');
		SERIES_VIEWS = Collections.unmodifiableMap(views);
	}
	private final ApplicationContext applicationContext;
	private final Resources resources;
	private final TemplateAvailabilityProviders templateAvailabilityProviders;
	private int order = Ordered.LOWEST_PRECEDENCE;
	/**
	 * Create a new {@link DefaultErrorViewResolver} instance.
	 * @param applicationContext the source application context
	 * @param resources resource properties
	 * @since 2.4.0
	 */
	public DefaultErrorViewResolver(ApplicationContext applicationContext, Resources resources) {
		Assert.notNull(applicationContext, 'ApplicationContext must not be null');
		Assert.notNull(resources, 'Resources must not be null');
		this.applicationContext = applicationContext;
		this.resources = resources;
		this.templateAvailabilityProviders = new TemplateAvailabilityProviders(applicationContext);
	}
	DefaultErrorViewResolver(ApplicationContext applicationContext, Resources resourceProperties,
			TemplateAvailabilityProviders templateAvailabilityProviders) {
		Assert.notNull(applicationContext, 'ApplicationContext must not be null');
		Assert.notNull(resourceProperties, 'Resources must not be null');
		this.applicationContext = applicationContext;
		this.resources = resourceProperties;
		this.templateAvailabilityProviders = templateAvailabilityProviders;
	}
	@Override
	public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map<String, Object> model) {
		ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);
		if (modelAndView == null && SERIES_VIEWS.containsKey(status.series())) {
			modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
		}
		return modelAndView;
	}
	private ModelAndView resolve(String viewName, Map<String, Object> model) {
		String errorViewName = 'error/' + viewName;
		TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,
				this.applicationContext);
		if (provider != null) {
			return new ModelAndView(errorViewName, model);
		}
		return resolveResource(errorViewName, model);
	}
	private ModelAndView resolveResource(String viewName, Map<String, Object> model) {
		for (String location : this.resources.getStaticLocations()) {
			try {
				Resource resource = this.applicationContext.getResource(location);
				resource = resource.createRelative(viewName + '.html');
				if (resource.exists()) {
					return new ModelAndView(new HtmlResourceView(resource), model);
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return null;
	}
	@Override
	public int getOrder() {
		return this.order;
	}
	public void setOrder(int order) {
		this.order = order;
	}
	/**
	 * {@link View} backed by an HTML resource.
	 */
	private static class HtmlResourceView implements View {
		private final Resource resource;
		HtmlResourceView(Resource resource) {
			this.resource = resource;
		}
		@Override
		public String getContentType() {
			return MediaType.TEXT_HTML_VALUE;
		}
		@Override
		public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)
				throws Exception {
			response.setContentType(getContentType());
			FileCopyUtils.copy(this.resource.getInputStream(), response.getOutputStream());
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.servlet.error;
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@ControllerAdvice
class ProblemDetailsExceptionHandler extends ResponseEntityExceptionHandler {
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@ConfigurationProperties(prefix = 'spring.servlet.multipart', ignoreUnknownFields = false)
public class MultipartProperties {
	/**
	 * Whether to enable support of multipart uploads.
	 */
	private boolean enabled = true;
	/**
	 * Intermediate location of uploaded files.
	 */
	private String location;
	/**
	 * Max file size.
	 */
	private DataSize maxFileSize = DataSize.ofMegabytes(1);
	/**
	 * Max request size.
	 */
	private DataSize maxRequestSize = DataSize.ofMegabytes(10);
	/**
	 * Threshold after which files are written to disk.
	 */
	private DataSize fileSizeThreshold = DataSize.ofBytes(0);
	/**
	 * Whether to resolve the multipart request lazily at the time of file or parameter
	 * access.
	 */
	private boolean resolveLazily = false;
	/**
	 * Whether to resolve the multipart request strictly complying with the Servlet
	 * specification, only to be used for 'multipart/form-data' requests.
	 */
	private boolean strictServletCompliance = false;
	public boolean getEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public String getLocation() {
		return this.location;
	}
	public void setLocation(String location) {
		this.location = location;
	}
	public DataSize getMaxFileSize() {
		return this.maxFileSize;
	}
	public void setMaxFileSize(DataSize maxFileSize) {
		this.maxFileSize = maxFileSize;
	}
	public DataSize getMaxRequestSize() {
		return this.maxRequestSize;
	}
	public void setMaxRequestSize(DataSize maxRequestSize) {
		this.maxRequestSize = maxRequestSize;
	}
	public DataSize getFileSizeThreshold() {
		return this.fileSizeThreshold;
	}
	public void setFileSizeThreshold(DataSize fileSizeThreshold) {
		this.fileSizeThreshold = fileSizeThreshold;
	}
	public boolean isResolveLazily() {
		return this.resolveLazily;
	}
	public void setResolveLazily(boolean resolveLazily) {
		this.resolveLazily = resolveLazily;
	}
	public boolean isStrictServletCompliance() {
		return this.strictServletCompliance;
	}
	public void setStrictServletCompliance(boolean strictServletCompliance) {
		this.strictServletCompliance = strictServletCompliance;
	}
	/**
	 * Create a new {@link MultipartConfigElement} using the properties.
	 * @return a new {@link MultipartConfigElement} configured using there properties
	 */
	public MultipartConfigElement createMultipartConfig() {
		MultipartConfigFactory factory = new MultipartConfigFactory();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.fileSizeThreshold).to(factory::setFileSizeThreshold);
		map.from(this.location).whenHasText().to(factory::setLocation);
		map.from(this.maxRequestSize).to(factory::setMaxRequestSize);
		map.from(this.maxFileSize).to(factory::setMaxFileSize);
		return factory.createMultipartConfig();
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public class TomcatServletWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<TomcatServletWebServerFactory>, Ordered {
	private final ServerProperties serverProperties;
	public TomcatServletWebServerFactoryCustomizer(ServerProperties serverProperties) {
		this.serverProperties = serverProperties;
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public void customize(TomcatServletWebServerFactory factory) {
		ServerProperties.Tomcat tomcatProperties = this.serverProperties.getTomcat();
		if (!ObjectUtils.isEmpty(tomcatProperties.getAdditionalTldSkipPatterns())) {
			factory.getTldSkipPatterns().addAll(tomcatProperties.getAdditionalTldSkipPatterns());
		}
		if (tomcatProperties.getRedirectContextRoot() != null) {
			customizeRedirectContextRoot(factory, tomcatProperties.getRedirectContextRoot());
		}
		customizeUseRelativeRedirects(factory, tomcatProperties.isUseRelativeRedirects());
		factory.setDisableMBeanRegistry(!tomcatProperties.getMbeanregistry().isEnabled());
	}
	private void customizeRedirectContextRoot(ConfigurableTomcatWebServerFactory factory, boolean redirectContextRoot) {
		factory.addContextCustomizers((context) -> context.setMapperContextRootRedirectEnabled(redirectContextRoot));
	}
	private void customizeUseRelativeRedirects(ConfigurableTomcatWebServerFactory factory,
			boolean useRelativeRedirects) {
		factory.addContextCustomizers((context) -> context.setUseRelativeRedirects(useRelativeRedirects));
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@AutoConfiguration
@ConditionalOnClass({ Servlet.class, StandardServletMultipartResolver.class, MultipartConfigElement.class })
@ConditionalOnProperty(prefix = 'spring.servlet.multipart', name = 'enabled', matchIfMissing = true)
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties(MultipartProperties.class)
public class MultipartAutoConfiguration {
	private final MultipartProperties multipartProperties;
	public MultipartAutoConfiguration(MultipartProperties multipartProperties) {
		this.multipartProperties = multipartProperties;
	}
	@Bean
	@ConditionalOnMissingBean(MultipartConfigElement.class)
	public MultipartConfigElement multipartConfigElement() {
		return this.multipartProperties.createMultipartConfig();
	}
	@Bean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
	@ConditionalOnMissingBean(MultipartResolver.class)
	public StandardServletMultipartResolver multipartResolver() {
		StandardServletMultipartResolver multipartResolver = new StandardServletMultipartResolver();
		multipartResolver.setResolveLazily(this.multipartProperties.isResolveLazily());
		multipartResolver.setStrictServletCompliance(this.multipartProperties.isStrictServletCompliance());
		return multipartResolver;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public class JspTemplateAvailabilityProvider implements TemplateAvailabilityProvider {
	@Override
	public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader,
			ResourceLoader resourceLoader) {
		if (ClassUtils.isPresent('org.apache.jasper.compiler.JspConfig', classLoader)) {
			String resourceName = getResourceName(view, environment);
			if (resourceLoader.getResource(resourceName).exists()) {
				return true;
			}
			return new File('src/main/webapp', resourceName).exists();
		}
		return false;
	}
	private String getResourceName(String view, Environment environment) {
		String prefix = environment.getProperty('spring.mvc.view.prefix', WebMvcAutoConfiguration.DEFAULT_PREFIX);
		String suffix = environment.getProperty('spring.mvc.view.suffix', WebMvcAutoConfiguration.DEFAULT_SUFFIX);
		return prefix + view + suffix;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@AutoConfiguration
@EnableConfigurationProperties(ServerProperties.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(CharacterEncodingFilter.class)
@ConditionalOnProperty(prefix = 'server.servlet.encoding', value = 'enabled', matchIfMissing = true)
public class HttpEncodingAutoConfiguration {
	private final Encoding properties;
	public HttpEncodingAutoConfiguration(ServerProperties properties) {
		this.properties = properties.getServlet().getEncoding();
	}
	@Bean
	@ConditionalOnMissingBean
	public CharacterEncodingFilter characterEncodingFilter() {
		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
		filter.setEncoding(this.properties.getCharset().name());
		filter.setForceRequestEncoding(this.properties.shouldForce(Encoding.Type.REQUEST));
		filter.setForceResponseEncoding(this.properties.shouldForce(Encoding.Type.RESPONSE));
		return filter;
	}
	@Bean
	public LocaleCharsetMappingsCustomizer localeCharsetMappingsCustomizer() {
		return new LocaleCharsetMappingsCustomizer(this.properties);
	}
	static class LocaleCharsetMappingsCustomizer
			implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory>, Ordered {
		private final Encoding properties;
		LocaleCharsetMappingsCustomizer(Encoding properties) {
			this.properties = properties;
		}
		@Override
		public void customize(ConfigurableServletWebServerFactory factory) {
			if (this.properties.getMapping() != null) {
				factory.setLocaleCharsetMappings(this.properties.getMapping());
			}
		}
		@Override
		public int getOrder() {
			return 0;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
class WelcomePageNotAcceptableHandlerMapping extends AbstractUrlHandlerMapping {
	WelcomePageNotAcceptableHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,
			ApplicationContext applicationContext, Resource indexHtmlResource, String staticPathPattern) {
		setOrder(LOWEST_PRECEDENCE - 10); // Before ResourceHandlerRegistry
		WelcomePage welcomePage = WelcomePage.resolve(templateAvailabilityProviders, applicationContext,
				indexHtmlResource, staticPathPattern);
		if (welcomePage != WelcomePage.UNRESOLVED) {
			setRootHandler((Controller) this::handleRequest);
		}
	}
	private ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
		response.setStatus(HttpStatus.NOT_ACCEPTABLE.value());
		return null;
	}
	@Override
	protected Object getHandlerInternal(HttpServletRequest request) throws Exception {
		return super.getHandlerInternal(request);
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public class DefaultJerseyApplicationPath implements JerseyApplicationPath {
	private final String applicationPath;
	private final ResourceConfig config;
	public DefaultJerseyApplicationPath(String applicationPath, ResourceConfig config) {
		this.applicationPath = applicationPath;
		this.config = config;
	}
	@Override
	public String getPath() {
		return resolveApplicationPath();
	}
	private String resolveApplicationPath() {
		if (StringUtils.hasLength(this.applicationPath)) {
			return this.applicationPath;
		}
		// Jersey doesn"t like to be the default servlet, so map to /* as a fallback
		return MergedAnnotations.from(this.config.getApplication().getClass(), SearchStrategy.TYPE_HIERARCHY)
			.get(ApplicationPath.class)
			.getValue(MergedAnnotation.VALUE, String.class)
			.orElse('/*');
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@AutoConfiguration(after = SslAutoConfiguration.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@ConditionalOnClass(ServletRequest.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties(ServerProperties.class)
@Import({ ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
		ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,
		ServletWebServerFactoryConfiguration.EmbeddedJetty.class,
		ServletWebServerFactoryConfiguration.EmbeddedUndertow.class })
public class ServletWebServerFactoryAutoConfiguration {
	@Bean
	public ServletWebServerFactoryCustomizer servletWebServerFactoryCustomizer(ServerProperties serverProperties,
			ObjectProvider<WebListenerRegistrar> webListenerRegistrars,
			ObjectProvider<CookieSameSiteSupplier> cookieSameSiteSuppliers, ObjectProvider<SslBundles> sslBundles) {
		return new ServletWebServerFactoryCustomizer(serverProperties, webListenerRegistrars.orderedStream().toList(),
				cookieSameSiteSuppliers.orderedStream().toList(), sslBundles.getIfAvailable());
	}
	@Bean
	@ConditionalOnClass(name = 'org.apache.catalina.startup.Tomcat')
	public TomcatServletWebServerFactoryCustomizer tomcatServletWebServerFactoryCustomizer(
			ServerProperties serverProperties) {
		return new TomcatServletWebServerFactoryCustomizer(serverProperties);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(value = 'server.forward-headers-strategy', havingValue = 'framework')
	@ConditionalOnMissingFilterBean(ForwardedHeaderFilter.class)
	static class ForwardedHeaderFilterConfiguration {
		@Bean
		@ConditionalOnClass(name = 'org.apache.catalina.startup.Tomcat')
		ForwardedHeaderFilterCustomizer tomcatForwardedHeaderFilterCustomizer(ServerProperties serverProperties) {
			return (filter) -> filter.setRelativeRedirects(serverProperties.getTomcat().isUseRelativeRedirects());
		}
		@Bean
		FilterRegistrationBean<ForwardedHeaderFilter> forwardedHeaderFilter(
				ObjectProvider<ForwardedHeaderFilterCustomizer> customizerProvider) {
			ForwardedHeaderFilter filter = new ForwardedHeaderFilter();
			customizerProvider.ifAvailable((customizer) -> customizer.customize(filter));
			FilterRegistrationBean<ForwardedHeaderFilter> registration = new FilterRegistrationBean<>(filter);
			registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC, DispatcherType.ERROR);
			registration.setOrder(Ordered.HIGHEST_PRECEDENCE);
			return registration;
		}
	}
	interface ForwardedHeaderFilterCustomizer {
		void customize(ForwardedHeaderFilter filter);
	}
	/**
	 * Registers a {@link WebServerFactoryCustomizerBeanPostProcessor}. Registered via
	 * {@link ImportBeanDefinitionRegistrar} for early registration.
	 */
	public static class BeanPostProcessorsRegistrar implements ImportBeanDefinitionRegistrar, BeanFactoryAware {
		private ConfigurableListableBeanFactory beanFactory;
		@Override
		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			if (beanFactory instanceof ConfigurableListableBeanFactory listableBeanFactory) {
				this.beanFactory = listableBeanFactory;
			}
		}
		@Override
		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {
			if (this.beanFactory == null) {
				return;
			}
			registerSyntheticBeanIfMissing(registry, 'webServerFactoryCustomizerBeanPostProcessor',
					WebServerFactoryCustomizerBeanPostProcessor.class);
			registerSyntheticBeanIfMissing(registry, 'errorPageRegistrarBeanPostProcessor',
					ErrorPageRegistrarBeanPostProcessor.class);
		}
		private <T> void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry, String name,
				Class<T> beanClass) {
			if (ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(beanClass, true, false))) {
				RootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass);
				beanDefinition.setSynthetic(true);
				registry.registerBeanDefinition(name, beanDefinition);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public class ServletWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableServletWebServerFactory>, Ordered {
	private final ServerProperties serverProperties;
	private final List<WebListenerRegistrar> webListenerRegistrars;
	private final List<CookieSameSiteSupplier> cookieSameSiteSuppliers;
	private final SslBundles sslBundles;
	public ServletWebServerFactoryCustomizer(ServerProperties serverProperties) {
		this(serverProperties, Collections.emptyList());
	}
	public ServletWebServerFactoryCustomizer(ServerProperties serverProperties,
			List<WebListenerRegistrar> webListenerRegistrars) {
		this(serverProperties, webListenerRegistrars, null, null);
	}
	ServletWebServerFactoryCustomizer(ServerProperties serverProperties,
			List<WebListenerRegistrar> webListenerRegistrars, List<CookieSameSiteSupplier> cookieSameSiteSuppliers,
			SslBundles sslBundles) {
		this.serverProperties = serverProperties;
		this.webListenerRegistrars = webListenerRegistrars;
		this.cookieSameSiteSuppliers = cookieSameSiteSuppliers;
		this.sslBundles = sslBundles;
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public void customize(ConfigurableServletWebServerFactory factory) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.serverProperties::getPort).to(factory::setPort);
		map.from(this.serverProperties::getAddress).to(factory::setAddress);
		map.from(this.serverProperties.getServlet()::getContextPath).to(factory::setContextPath);
		map.from(this.serverProperties.getServlet()::getApplicationDisplayName).to(factory::setDisplayName);
		map.from(this.serverProperties.getServlet()::isRegisterDefaultServlet).to(factory::setRegisterDefaultServlet);
		map.from(this.serverProperties.getServlet()::getSession).to(factory::setSession);
		map.from(this.serverProperties::getSsl).to(factory::setSsl);
		map.from(this.serverProperties.getServlet()::getJsp).to(factory::setJsp);
		map.from(this.serverProperties::getCompression).to(factory::setCompression);
		map.from(this.serverProperties::getHttp2).to(factory::setHttp2);
		map.from(this.serverProperties::getServerHeader).to(factory::setServerHeader);
		map.from(this.serverProperties.getServlet()::getContextParameters).to(factory::setInitParameters);
		map.from(this.serverProperties.getShutdown()).to(factory::setShutdown);
		map.from(() -> this.sslBundles).to(factory::setSslBundles);
		map.from(() -> this.cookieSameSiteSuppliers)
			.whenNot(CollectionUtils::isEmpty)
			.to(factory::setCookieSameSiteSuppliers);
		map.from(this.serverProperties::getMimeMappings).to(factory::addMimeMappings);
		this.webListenerRegistrars.forEach((registrar) -> registrar.register(factory));
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public class DispatcherServletRegistrationBean extends ServletRegistrationBean<DispatcherServlet>
		implements DispatcherServletPath {
	private final String path;
	/**
	 * Create a new {@link DispatcherServletRegistrationBean} instance for the given
	 * servlet and path.
	 * @param servlet the dispatcher servlet
	 * @param path the dispatcher servlet path
	 */
	public DispatcherServletRegistrationBean(DispatcherServlet servlet, String path) {
		super(servlet);
		Assert.notNull(path, 'Path must not be null');
		this.path = path;
		super.addUrlMappings(getServletUrlMapping());
	}
	@Override
	public String getPath() {
		return this.path;
	}
	@Override
	public void setUrlMappings(Collection<String> urlMappings) {
		throw new UnsupportedOperationException('URL Mapping cannot be changed on a DispatcherServlet registration');
	}
	@Override
	public void addUrlMappings(String... urlMappings) {
		throw new UnsupportedOperationException('URL Mapping cannot be changed on a DispatcherServlet registration');
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.servlet;
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@AutoConfiguration(after = ServletWebServerFactoryAutoConfiguration.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(DispatcherServlet.class)
public class DispatcherServletAutoConfiguration {
	/**
	 * The bean name for a DispatcherServlet that will be mapped to the root URL '/'.
	 */
	public static final String DEFAULT_DISPATCHER_SERVLET_BEAN_NAME = 'dispatcherServlet';
	/**
	 * The bean name for a ServletRegistrationBean for the DispatcherServlet '/'.
	 */
	public static final String DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME = 'dispatcherServletRegistration';
	@Configuration(proxyBeanMethods = false)
	@Conditional(DefaultDispatcherServletCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	@EnableConfigurationProperties(WebMvcProperties.class)
	protected static class DispatcherServletConfiguration {
		@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) {
			DispatcherServlet dispatcherServlet = new DispatcherServlet();
			dispatcherServlet.setDispatchOptionsRequest(webMvcProperties.isDispatchOptionsRequest());
			dispatcherServlet.setDispatchTraceRequest(webMvcProperties.isDispatchTraceRequest());
			dispatcherServlet.setPublishEvents(webMvcProperties.isPublishRequestHandledEvents());
			dispatcherServlet.setEnableLoggingRequestDetails(webMvcProperties.isLogRequestDetails());
			return dispatcherServlet;
		}
		@Bean
		@ConditionalOnBean(MultipartResolver.class)
		@ConditionalOnMissingBean(name = DispatcherServlet.MULTIPART_RESOLVER_BEAN_NAME)
		public MultipartResolver multipartResolver(MultipartResolver resolver) {
			// Detect if the user has created a MultipartResolver but named it incorrectly
			return resolver;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@Conditional(DispatcherServletRegistrationCondition.class)
	@ConditionalOnClass(ServletRegistration.class)
	@EnableConfigurationProperties(WebMvcProperties.class)
	@Import(DispatcherServletConfiguration.class)
	protected static class DispatcherServletRegistrationConfiguration {
		@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
		@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
		public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet,
				WebMvcProperties webMvcProperties, ObjectProvider<MultipartConfigElement> multipartConfig) {
			DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet,
					webMvcProperties.getServlet().getPath());
			registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
			registration.setLoadOnStartup(webMvcProperties.getServlet().getLoadOnStartup());
			multipartConfig.ifAvailable(registration::setMultipartConfig);
			return registration;
		}
	}
	@Order(Ordered.LOWEST_PRECEDENCE - 10)
	private static final class DefaultDispatcherServletCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConditionMessage.Builder message = ConditionMessage.forCondition('Default DispatcherServlet');
			ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
			List<String> dispatchServletBeans = Arrays
				.asList(beanFactory.getBeanNamesForType(DispatcherServlet.class, false, false));
			if (dispatchServletBeans.contains(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)) {
				return ConditionOutcome
					.noMatch(message.found('dispatcher servlet bean').items(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME));
			}
			if (beanFactory.containsBean(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)) {
				return ConditionOutcome
					.noMatch(message.found('non dispatcher servlet bean').items(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME));
			}
			if (dispatchServletBeans.isEmpty()) {
				return ConditionOutcome.match(message.didNotFind('dispatcher servlet beans').atAll());
			}
			return ConditionOutcome.match(message.found('dispatcher servlet bean', 'dispatcher servlet beans')
				.items(Style.QUOTE, dispatchServletBeans)
				.append('and none is named ' + DEFAULT_DISPATCHER_SERVLET_BEAN_NAME));
		}
	}
	@Order(Ordered.LOWEST_PRECEDENCE - 10)
	private static final class DispatcherServletRegistrationCondition extends SpringBootCondition {
		@Override
		public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
			ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
			ConditionOutcome outcome = checkDefaultDispatcherName(beanFactory);
			if (!outcome.isMatch()) {
				return outcome;
			}
			return checkServletRegistration(beanFactory);
		}
		private ConditionOutcome checkDefaultDispatcherName(ConfigurableListableBeanFactory beanFactory) {
			boolean containsDispatcherBean = beanFactory.containsBean(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
			if (!containsDispatcherBean) {
				return ConditionOutcome.match();
			}
			List<String> servlets = Arrays
				.asList(beanFactory.getBeanNamesForType(DispatcherServlet.class, false, false));
			if (!servlets.contains(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)) {
				return ConditionOutcome.noMatch(
						startMessage().found('non dispatcher servlet').items(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME));
			}
			return ConditionOutcome.match();
		}
		private ConditionOutcome checkServletRegistration(ConfigurableListableBeanFactory beanFactory) {
			ConditionMessage.Builder message = startMessage();
			List<String> registrations = Arrays
				.asList(beanFactory.getBeanNamesForType(ServletRegistrationBean.class, false, false));
			boolean containsDispatcherRegistrationBean = beanFactory
				.containsBean(DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME);
			if (registrations.isEmpty()) {
				if (containsDispatcherRegistrationBean) {
					return ConditionOutcome.noMatch(message.found('non servlet registration bean')
						.items(DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME));
				}
				return ConditionOutcome.match(message.didNotFind('servlet registration bean').atAll());
			}
			if (registrations.contains(DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)) {
				return ConditionOutcome.noMatch(message.found('servlet registration bean')
					.items(DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME));
			}
			if (containsDispatcherRegistrationBean) {
				return ConditionOutcome.noMatch(message.found('non servlet registration bean')
					.items(DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME));
			}
			return ConditionOutcome.match(message.found('servlet registration beans')
				.items(Style.QUOTE, registrations)
				.append('and none is named ' + DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME));
		}
		private ConditionMessage.Builder startMessage() {
			return ConditionMessage.forCondition('DispatcherServlet Registration');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@Configuration(proxyBeanMethods = false)
class ServletWebServerFactoryConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Servlet.class, Tomcat.class, UpgradeProtocol.class })
	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
	static class EmbeddedTomcat {
		@Bean
		TomcatServletWebServerFactory tomcatServletWebServerFactory(
				ObjectProvider<TomcatConnectorCustomizer> connectorCustomizers,
				ObjectProvider<TomcatContextCustomizer> contextCustomizers,
				ObjectProvider<TomcatProtocolHandlerCustomizer<?>> protocolHandlerCustomizers) {
			TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory();
			factory.getTomcatConnectorCustomizers().addAll(connectorCustomizers.orderedStream().toList());
			factory.getTomcatContextCustomizers().addAll(contextCustomizers.orderedStream().toList());
			factory.getTomcatProtocolHandlerCustomizers().addAll(protocolHandlerCustomizers.orderedStream().toList());
			return factory;
		}
	}
	/**
	 * Nested configuration if Jetty is being used.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Servlet.class, Server.class, Loader.class, WebAppContext.class })
	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
	static class EmbeddedJetty {
		@Bean
		JettyServletWebServerFactory jettyServletWebServerFactory(
				ObjectProvider<JettyServerCustomizer> serverCustomizers) {
			JettyServletWebServerFactory factory = new JettyServletWebServerFactory();
			factory.getServerCustomizers().addAll(serverCustomizers.orderedStream().toList());
			return factory;
		}
	}
	/**
	 * Nested configuration if Undertow is being used.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ Servlet.class, Undertow.class, SslClientAuthMode.class })
	@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)
	static class EmbeddedUndertow {
		@Bean
		UndertowServletWebServerFactory undertowServletWebServerFactory(
				ObjectProvider<UndertowDeploymentInfoCustomizer> deploymentInfoCustomizers,
				ObjectProvider<UndertowBuilderCustomizer> builderCustomizers) {
			UndertowServletWebServerFactory factory = new UndertowServletWebServerFactory();
			factory.getDeploymentInfoCustomizers().addAll(deploymentInfoCustomizers.orderedStream().toList());
			factory.getBuilderCustomizers().addAll(builderCustomizers.orderedStream().toList());
			return factory;
		}
		@Bean
		UndertowServletWebServerFactoryCustomizer undertowServletWebServerFactoryCustomizer(
				ServerProperties serverProperties) {
			return new UndertowServletWebServerFactoryCustomizer(serverProperties);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
final class WelcomePageHandlerMapping extends AbstractUrlHandlerMapping {
	private static final Log logger = LogFactory.getLog(WelcomePageHandlerMapping.class);
	private static final List<MediaType> MEDIA_TYPES_ALL = Collections.singletonList(MediaType.ALL);
	WelcomePageHandlerMapping(TemplateAvailabilityProviders templateAvailabilityProviders,
			ApplicationContext applicationContext, Resource indexHtmlResource, String staticPathPattern) {
		setOrder(2);
		WelcomePage welcomePage = WelcomePage.resolve(templateAvailabilityProviders, applicationContext,
				indexHtmlResource, staticPathPattern);
		if (welcomePage != WelcomePage.UNRESOLVED) {
			logger.info(LogMessage.of(() -> (!welcomePage.isTemplated()) ? 'Adding welcome page: ' + indexHtmlResource
					: 'Adding welcome page template: index'));
			ParameterizableViewController controller = new ParameterizableViewController();
			controller.setViewName(welcomePage.getViewName());
			setRootHandler(controller);
		}
	}
	@Override
	public Object getHandlerInternal(HttpServletRequest request) throws Exception {
		return (!isHtmlTextAccepted(request)) ? null : super.getHandlerInternal(request);
	}
	private boolean isHtmlTextAccepted(HttpServletRequest request) {
		for (MediaType mediaType : getAcceptedMediaTypes(request)) {
			if (mediaType.includes(MediaType.TEXT_HTML)) {
				return true;
			}
		}
		return false;
	}
	private List<MediaType> getAcceptedMediaTypes(HttpServletRequest request) {
		String acceptHeader = request.getHeader(HttpHeaders.ACCEPT);
		if (StringUtils.hasText(acceptHeader)) {
			try {
				return MediaType.parseMediaTypes(acceptHeader);
			}
			catch (InvalidMediaTypeException ex) {
				logger.warn('Received invalid Accept header. Assuming all media types are accepted',
						logger.isDebugEnabled() ? ex : null);
			}
		}
		return MEDIA_TYPES_ALL;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@FunctionalInterface
public interface JerseyApplicationPath {
	/**
	 * Returns the configured path of the application.
	 * @return the configured path
	 */
	String getPath();
	/**
	 * Return a form of the given path that"s relative to the Jersey application path.
	 * @param path the path to make relative
	 * @return the relative path
	 */
	default String getRelativePath(String path) {
		String prefix = getPrefix();
		if (!path.startsWith('/')) {
			path = '/' + path;
		}
		return prefix + path;
	}
	/**
	 * Return a cleaned up version of the path that can be used as a prefix for URLs. The
	 * resulting path will have path will not have a trailing slash.
	 * @return the prefix
	 * @see #getRelativePath(String)
	 */
	default String getPrefix() {
		String result = getPath();
		int index = result.indexOf("*");
		if (index != -1) {
			result = result.substring(0, index);
		}
		if (result.endsWith('/')) {
			result = result.substring(0, result.length() - 1);
		}
		return result;
	}
	/**
	 * Return a URL mapping pattern that can be used with a
	 * {@link ServletRegistrationBean} to map Jersey"s servlet.
	 * @return the path as a servlet URL mapping
	 */
	default String getUrlMapping() {
		String path = getPath();
		if (!path.startsWith('/')) {
			path = '/' + path;
		}
		if (path.equals('/')) {
			return '/*';
		}
		if (path.contains('*')) {
			return path;
		}
		if (path.endsWith('/')) {
			return path + '*';
		}
		return path + '/*';
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public interface WebMvcRegistrations {
	/**
	 * Return the custom {@link RequestMappingHandlerMapping} that should be used and
	 * processed by the MVC configuration.
	 * @return the custom {@link RequestMappingHandlerMapping} instance
	 */
	default RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
		return null;
	}
	/**
	 * Return the custom {@link RequestMappingHandlerAdapter} that should be used and
	 * processed by the MVC configuration.
	 * @return the custom {@link RequestMappingHandlerAdapter} instance
	 */
	default RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
		return null;
	}
	/**
	 * Return the custom {@link ExceptionHandlerExceptionResolver} that should be used and
	 * processed by the MVC configuration.
	 * @return the custom {@link ExceptionHandlerExceptionResolver} instance
	 */
	default ExceptionHandlerExceptionResolver getExceptionHandlerExceptionResolver() {
		return null;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
final class WelcomePage {
	/**
	 * Value used for an unresolved welcome page.
	 */
	static final WelcomePage UNRESOLVED = new WelcomePage(null, false);
	private final String viewName;
	private final boolean templated;
	private WelcomePage(String viewName, boolean templated) {
		this.viewName = viewName;
		this.templated = templated;
	}
	/**
	 * Return the view name of the welcome page.
	 * @return the view name
	 */
	String getViewName() {
		return this.viewName;
	}
	/**
	 * Return if the welcome page is from a template.
	 * @return if the welcome page is templated
	 */
	boolean isTemplated() {
		return this.templated;
	}
	/**
	 * Resolve the {@link WelcomePage} to use.
	 * @param templateAvailabilityProviders the template availability providers
	 * @param applicationContext the application context
	 * @param indexHtmlResource the index HTML resource to use or {@code null}
	 * @param staticPathPattern the static path pattern being used
	 * @return a resolved {@link WelcomePage} instance or {@link #UNRESOLVED}
	 */
	static WelcomePage resolve(TemplateAvailabilityProviders templateAvailabilityProviders,
			ApplicationContext applicationContext, Resource indexHtmlResource, String staticPathPattern) {
		if (indexHtmlResource != null && '/**'.equals(staticPathPattern)) {
			return new WelcomePage('forward:index.html', false);
		}
		if (templateAvailabilityProviders.getProvider('index', applicationContext) != null) {
			return new WelcomePage('index', true);
		}
		return UNRESOLVED;
	}
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@ConditionalOnMissingBean(parameterizedContainer = FilterRegistrationBean.class)
public @interface ConditionalOnMissingFilterBean {
	/**
	 * The filter bean type that must not be present.
	 * @return the bean type
	 */
	@AliasFor(annotation = ConditionalOnMissingBean.class)
	Class<? extends Filter>[] value() default {};
}
/*
package org.springframework.boot.autoconfigure.web.servlet;
/**
public class UndertowServletWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<UndertowServletWebServerFactory> {
	private final ServerProperties serverProperties;
	public UndertowServletWebServerFactoryCustomizer(ServerProperties serverProperties) {
		this.serverProperties = serverProperties;
	}
	@Override
	public void customize(UndertowServletWebServerFactory factory) {
		factory.setEagerFilterInit(this.serverProperties.getUndertow().isEagerFilterInit());
		factory.setPreservePathOnForward(this.serverProperties.getUndertow().isPreservePathOnForward());
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
@ConfigurationProperties(prefix = 'server', ignoreUnknownFields = true)
public class ServerProperties {
	/**
	 * Server HTTP port.
	 */
	private Integer port;
	/**
	 * Network address to which the server should bind.
	 */
	private InetAddress address;
	@NestedConfigurationProperty
	private final ErrorProperties error = new ErrorProperties();
	/**
	 * Strategy for handling X-Forwarded-* headers.
	 */
	private ForwardHeadersStrategy forwardHeadersStrategy;
	/**
	 * Value to use for the Server response header (if empty, no header is sent).
	 */
	private String serverHeader;
	/**
	 * Maximum size of the HTTP request header. Refer to the documentation for your chosen
	 * embedded server for details of exactly how this limit is applied. For example,
	 * Netty applies the limit separately to each individual header in the request whereas
	 * Tomcat applies the limit to the combined size of the request line and all of the
	 * header names and values in the request.
	 */
	private DataSize maxHttpRequestHeaderSize = DataSize.ofKilobytes(8);
	/**
	 * Type of shutdown that the server will support.
	 */
	private Shutdown shutdown = Shutdown.GRACEFUL;
	@NestedConfigurationProperty
	private Ssl ssl;
	@NestedConfigurationProperty
	private final Compression compression = new Compression();
	/**
	 * Custom MIME mappings in addition to the default MIME mappings.
	 */
	private final MimeMappings mimeMappings = new MimeMappings();
	@NestedConfigurationProperty
	private final Http2 http2 = new Http2();
	private final Servlet servlet = new Servlet();
	private final Reactive reactive = new Reactive();
	private final Tomcat tomcat = new Tomcat();
	private final Jetty jetty = new Jetty();
	private final Netty netty = new Netty();
	private final Undertow undertow = new Undertow();
	public Integer getPort() {
		return this.port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
	public InetAddress getAddress() {
		return this.address;
	}
	public void setAddress(InetAddress address) {
		this.address = address;
	}
	public String getServerHeader() {
		return this.serverHeader;
	}
	public void setServerHeader(String serverHeader) {
		this.serverHeader = serverHeader;
	}
	public DataSize getMaxHttpRequestHeaderSize() {
		return this.maxHttpRequestHeaderSize;
	}
	public void setMaxHttpRequestHeaderSize(DataSize maxHttpRequestHeaderSize) {
		this.maxHttpRequestHeaderSize = maxHttpRequestHeaderSize;
	}
	public Shutdown getShutdown() {
		return this.shutdown;
	}
	public void setShutdown(Shutdown shutdown) {
		this.shutdown = shutdown;
	}
	public ErrorProperties getError() {
		return this.error;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public void setSsl(Ssl ssl) {
		this.ssl = ssl;
	}
	public Compression getCompression() {
		return this.compression;
	}
	public MimeMappings getMimeMappings() {
		return this.mimeMappings;
	}
	public void setMimeMappings(Map<String, String> customMappings) {
		customMappings.forEach(this.mimeMappings::add);
	}
	public Http2 getHttp2() {
		return this.http2;
	}
	public Servlet getServlet() {
		return this.servlet;
	}
	public Reactive getReactive() {
		return this.reactive;
	}
	public Tomcat getTomcat() {
		return this.tomcat;
	}
	public Jetty getJetty() {
		return this.jetty;
	}
	public Netty getNetty() {
		return this.netty;
	}
	public Undertow getUndertow() {
		return this.undertow;
	}
	public ForwardHeadersStrategy getForwardHeadersStrategy() {
		return this.forwardHeadersStrategy;
	}
	public void setForwardHeadersStrategy(ForwardHeadersStrategy forwardHeadersStrategy) {
		this.forwardHeadersStrategy = forwardHeadersStrategy;
	}
	/**
	 * Servlet server properties.
	 */
	public static class Servlet {
		/**
		 * Servlet context init parameters.
		 */
		private final Map<String, String> contextParameters = new HashMap<>();
		/**
		 * Context path of the application.
		 */
		private String contextPath;
		/**
		 * Display name of the application.
		 */
		private String applicationDisplayName = 'application';
		/**
		 * Whether to register the default Servlet with the container.
		 */
		private boolean registerDefaultServlet = false;
		@NestedConfigurationProperty
		private final Encoding encoding = new Encoding();
		@NestedConfigurationProperty
		private final Jsp jsp = new Jsp();
		@NestedConfigurationProperty
		private final Session session = new Session();
		public String getContextPath() {
			return this.contextPath;
		}
		public void setContextPath(String contextPath) {
			this.contextPath = cleanContextPath(contextPath);
		}
		private String cleanContextPath(String contextPath) {
			String candidate = null;
			if (StringUtils.hasLength(contextPath)) {
				candidate = contextPath.strip();
			}
			if (StringUtils.hasText(candidate) && candidate.endsWith('/')) {
				return candidate.substring(0, candidate.length() - 1);
			}
			return candidate;
		}
		public String getApplicationDisplayName() {
			return this.applicationDisplayName;
		}
		public void setApplicationDisplayName(String displayName) {
			this.applicationDisplayName = displayName;
		}
		public boolean isRegisterDefaultServlet() {
			return this.registerDefaultServlet;
		}
		public void setRegisterDefaultServlet(boolean registerDefaultServlet) {
			this.registerDefaultServlet = registerDefaultServlet;
		}
		public Map<String, String> getContextParameters() {
			return this.contextParameters;
		}
		public Encoding getEncoding() {
			return this.encoding;
		}
		public Jsp getJsp() {
			return this.jsp;
		}
		public Session getSession() {
			return this.session;
		}
	}
	/**
	 * Reactive server properties.
	 */
	public static class Reactive {
		private final Session session = new Session();
		public Session getSession() {
			return this.session;
		}
		public static class Session {
			/**
			 * Session timeout. If a duration suffix is not specified, seconds will be
			 * used.
			 */
			@DurationUnit(ChronoUnit.SECONDS)
			private Duration timeout = Duration.ofMinutes(30);
			/**
			 * Maximum number of sessions that can be stored.
			 */
			private int maxSessions = 10000;
			@NestedConfigurationProperty
			private final Cookie cookie = new Cookie();
			public Duration getTimeout() {
				return this.timeout;
			}
			public void setTimeout(Duration timeout) {
				this.timeout = timeout;
			}
			public int getMaxSessions() {
				return this.maxSessions;
			}
			public void setMaxSessions(int maxSessions) {
				this.maxSessions = maxSessions;
			}
			public Cookie getCookie() {
				return this.cookie;
			}
		}
	}
	/**
	 * Tomcat properties.
	 */
	public static class Tomcat {
		/**
		 * Access log configuration.
		 */
		private final Accesslog accesslog = new Accesslog();
		/**
		 * Thread related configuration.
		 */
		private final Threads threads = new Threads();
		/**
		 * Tomcat base directory. If not specified, a temporary directory is used.
		 */
		private File basedir;
		/**
		 * Delay between the invocation of backgroundProcess methods. If a duration suffix
		 * is not specified, seconds will be used.
		 */
		@DurationUnit(ChronoUnit.SECONDS)
		private Duration backgroundProcessorDelay = Duration.ofSeconds(10);
		/**
		 * Maximum size of the form content in any HTTP post request.
		 */
		private DataSize maxHttpFormPostSize = DataSize.ofMegabytes(2);
		/**
		 * Maximum amount of request body to swallow.
		 */
		private DataSize maxSwallowSize = DataSize.ofMegabytes(2);
		/**
		 * Whether requests to the context root should be redirected by appending a / to
		 * the path. When using SSL terminated at a proxy, this property should be set to
		 * false.
		 */
		private Boolean redirectContextRoot = true;
		/**
		 * Whether HTTP 1.1 and later location headers generated by a call to sendRedirect
		 * will use relative or absolute redirects.
		 */
		private boolean useRelativeRedirects;
		/**
		 * Character encoding to use to decode the URI.
		 */
		private Charset uriEncoding = StandardCharsets.UTF_8;
		/**
		 * Maximum number of connections that the server accepts and processes at any
		 * given time. Once the limit has been reached, the operating system may still
		 * accept connections based on the 'acceptCount' property.
		 */
		private int maxConnections = 8192;
		/**
		 * Maximum queue length for incoming connection requests when all possible request
		 * processing threads are in use.
		 */
		private int acceptCount = 100;
		/**
		 * Maximum number of idle processors that will be retained in the cache and reused
		 * with a subsequent request. When set to -1 the cache will be unlimited with a
		 * theoretical maximum size equal to the maximum number of connections.
		 */
		private int processorCache = 200;
		/**
		 * Time to wait for another HTTP request before the connection is closed. When not
		 * set the connectionTimeout is used. When set to -1 there will be no timeout.
		 */
		private Duration keepAliveTimeout;
		/**
		 * Maximum number of HTTP requests that can be pipelined before the connection is
		 * closed. When set to 0 or 1, keep-alive and pipelining are disabled. When set to
		 * -1, an unlimited number of pipelined or keep-alive requests are allowed.
		 */
		private int maxKeepAliveRequests = 100;
		/**
		 * List of additional patterns that match jars to ignore for TLD scanning. The
		 * special "?" and "*" characters can be used in the pattern to match one and only
		 * one character and zero or more characters respectively.
		 */
		private List<String> additionalTldSkipPatterns = new ArrayList<>();
		/**
		 * List of additional unencoded characters that should be allowed in URI paths.
		 * Only '< > [ \ ] ^ ` { | }' are allowed.
		 */
		private List<Character> relaxedPathChars = new ArrayList<>();
		/**
		 * List of additional unencoded characters that should be allowed in URI query
		 * strings. Only '< > [ \ ] ^ ` { | }' are allowed.
		 */
		private List<Character> relaxedQueryChars = new ArrayList<>();
		/**
		 * Amount of time the connector will wait, after accepting a connection, for the
		 * request URI line to be presented.
		 */
		private Duration connectionTimeout;
		/**
		 * Static resource configuration.
		 */
		private final Resource resource = new Resource();
		/**
		 * Modeler MBean Registry configuration.
		 */
		private final Mbeanregistry mbeanregistry = new Mbeanregistry();
		/**
		 * Remote Ip Valve configuration.
		 */
		private final Remoteip remoteip = new Remoteip();
		/**
		 * Maximum size of the HTTP response header.
		 */
		private DataSize maxHttpResponseHeaderSize = DataSize.ofKilobytes(8);
		public DataSize getMaxHttpFormPostSize() {
			return this.maxHttpFormPostSize;
		}
		public void setMaxHttpFormPostSize(DataSize maxHttpFormPostSize) {
			this.maxHttpFormPostSize = maxHttpFormPostSize;
		}
		public Accesslog getAccesslog() {
			return this.accesslog;
		}
		public Threads getThreads() {
			return this.threads;
		}
		public Duration getBackgroundProcessorDelay() {
			return this.backgroundProcessorDelay;
		}
		public void setBackgroundProcessorDelay(Duration backgroundProcessorDelay) {
			this.backgroundProcessorDelay = backgroundProcessorDelay;
		}
		public File getBasedir() {
			return this.basedir;
		}
		public void setBasedir(File basedir) {
			this.basedir = basedir;
		}
		public Boolean getRedirectContextRoot() {
			return this.redirectContextRoot;
		}
		public void setRedirectContextRoot(Boolean redirectContextRoot) {
			this.redirectContextRoot = redirectContextRoot;
		}
		public boolean isUseRelativeRedirects() {
			return this.useRelativeRedirects;
		}
		public void setUseRelativeRedirects(boolean useRelativeRedirects) {
			this.useRelativeRedirects = useRelativeRedirects;
		}
		public Charset getUriEncoding() {
			return this.uriEncoding;
		}
		public void setUriEncoding(Charset uriEncoding) {
			this.uriEncoding = uriEncoding;
		}
		public int getMaxConnections() {
			return this.maxConnections;
		}
		public void setMaxConnections(int maxConnections) {
			this.maxConnections = maxConnections;
		}
		public DataSize getMaxSwallowSize() {
			return this.maxSwallowSize;
		}
		public void setMaxSwallowSize(DataSize maxSwallowSize) {
			this.maxSwallowSize = maxSwallowSize;
		}
		public int getAcceptCount() {
			return this.acceptCount;
		}
		public void setAcceptCount(int acceptCount) {
			this.acceptCount = acceptCount;
		}
		public int getProcessorCache() {
			return this.processorCache;
		}
		public void setProcessorCache(int processorCache) {
			this.processorCache = processorCache;
		}
		public Duration getKeepAliveTimeout() {
			return this.keepAliveTimeout;
		}
		public void setKeepAliveTimeout(Duration keepAliveTimeout) {
			this.keepAliveTimeout = keepAliveTimeout;
		}
		public int getMaxKeepAliveRequests() {
			return this.maxKeepAliveRequests;
		}
		public void setMaxKeepAliveRequests(int maxKeepAliveRequests) {
			this.maxKeepAliveRequests = maxKeepAliveRequests;
		}
		public List<String> getAdditionalTldSkipPatterns() {
			return this.additionalTldSkipPatterns;
		}
		public void setAdditionalTldSkipPatterns(List<String> additionalTldSkipPatterns) {
			this.additionalTldSkipPatterns = additionalTldSkipPatterns;
		}
		public List<Character> getRelaxedPathChars() {
			return this.relaxedPathChars;
		}
		public void setRelaxedPathChars(List<Character> relaxedPathChars) {
			this.relaxedPathChars = relaxedPathChars;
		}
		public List<Character> getRelaxedQueryChars() {
			return this.relaxedQueryChars;
		}
		public void setRelaxedQueryChars(List<Character> relaxedQueryChars) {
			this.relaxedQueryChars = relaxedQueryChars;
		}
		public Duration getConnectionTimeout() {
			return this.connectionTimeout;
		}
		public void setConnectionTimeout(Duration connectionTimeout) {
			this.connectionTimeout = connectionTimeout;
		}
		public Resource getResource() {
			return this.resource;
		}
		public Mbeanregistry getMbeanregistry() {
			return this.mbeanregistry;
		}
		public Remoteip getRemoteip() {
			return this.remoteip;
		}
		public DataSize getMaxHttpResponseHeaderSize() {
			return this.maxHttpResponseHeaderSize;
		}
		public void setMaxHttpResponseHeaderSize(DataSize maxHttpResponseHeaderSize) {
			this.maxHttpResponseHeaderSize = maxHttpResponseHeaderSize;
		}
		/**
		 * Tomcat access log properties.
		 */
		public static class Accesslog {
			/**
			 * Enable access log.
			 */
			private boolean enabled = false;
			/**
			 * Whether logging of the request will only be enabled if
			 * 'ServletRequest.getAttribute(conditionIf)' does not yield null.
			 */
			private String conditionIf;
			/**
			 * Whether logging of the request will only be enabled if
			 * 'ServletRequest.getAttribute(conditionUnless)' yield null.
			 */
			private String conditionUnless;
			/**
			 * Format pattern for access logs.
			 */
			private String pattern = 'common';
			/**
			 * Directory in which log files are created. Can be absolute or relative to
			 * the Tomcat base dir.
			 */
			private String directory = 'logs';
			/**
			 * Log file name prefix.
			 */
			protected String prefix = 'access_log';
			/**
			 * Log file name suffix.
			 */
			private String suffix = '.log';
			/**
			 * Character set used by the log file. Default to the system default character
			 * set.
			 */
			private String encoding;
			/**
			 * Locale used to format timestamps in log entries and in log file name
			 * suffix. Default to the default locale of the Java process.
			 */
			private String locale;
			/**
			 * Whether to check for log file existence so it can be recreated if an
			 * external process has renamed it.
			 */
			private boolean checkExists = false;
			/**
			 * Whether to enable access log rotation.
			 */
			private boolean rotate = true;
			/**
			 * Whether to defer inclusion of the date stamp in the file name until rotate
			 * time.
			 */
			private boolean renameOnRotate = false;
			/**
			 * Number of days to retain the access log files before they are removed.
			 */
			private int maxDays = -1;
			/**
			 * Date format to place in the log file name.
			 */
			private String fileDateFormat = '.yyyy-MM-dd';
			/**
			 * Whether to use IPv6 canonical representation format as defined by RFC 5952.
			 */
			private boolean ipv6Canonical = false;
			/**
			 * Set request attributes for the IP address, Hostname, protocol, and port
			 * used for the request.
			 */
			private boolean requestAttributesEnabled = false;
			/**
			 * Whether to buffer output such that it is flushed only periodically.
			 */
			private boolean buffered = true;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
			public String getConditionIf() {
				return this.conditionIf;
			}
			public void setConditionIf(String conditionIf) {
				this.conditionIf = conditionIf;
			}
			public String getConditionUnless() {
				return this.conditionUnless;
			}
			public void setConditionUnless(String conditionUnless) {
				this.conditionUnless = conditionUnless;
			}
			public String getPattern() {
				return this.pattern;
			}
			public void setPattern(String pattern) {
				this.pattern = pattern;
			}
			public String getDirectory() {
				return this.directory;
			}
			public void setDirectory(String directory) {
				this.directory = directory;
			}
			public String getPrefix() {
				return this.prefix;
			}
			public void setPrefix(String prefix) {
				this.prefix = prefix;
			}
			public String getSuffix() {
				return this.suffix;
			}
			public void setSuffix(String suffix) {
				this.suffix = suffix;
			}
			public String getEncoding() {
				return this.encoding;
			}
			public void setEncoding(String encoding) {
				this.encoding = encoding;
			}
			public String getLocale() {
				return this.locale;
			}
			public void setLocale(String locale) {
				this.locale = locale;
			}
			public boolean isCheckExists() {
				return this.checkExists;
			}
			public void setCheckExists(boolean checkExists) {
				this.checkExists = checkExists;
			}
			public boolean isRotate() {
				return this.rotate;
			}
			public void setRotate(boolean rotate) {
				this.rotate = rotate;
			}
			public boolean isRenameOnRotate() {
				return this.renameOnRotate;
			}
			public void setRenameOnRotate(boolean renameOnRotate) {
				this.renameOnRotate = renameOnRotate;
			}
			public int getMaxDays() {
				return this.maxDays;
			}
			public void setMaxDays(int maxDays) {
				this.maxDays = maxDays;
			}
			public String getFileDateFormat() {
				return this.fileDateFormat;
			}
			public void setFileDateFormat(String fileDateFormat) {
				this.fileDateFormat = fileDateFormat;
			}
			public boolean isIpv6Canonical() {
				return this.ipv6Canonical;
			}
			public void setIpv6Canonical(boolean ipv6Canonical) {
				this.ipv6Canonical = ipv6Canonical;
			}
			public boolean isRequestAttributesEnabled() {
				return this.requestAttributesEnabled;
			}
			public void setRequestAttributesEnabled(boolean requestAttributesEnabled) {
				this.requestAttributesEnabled = requestAttributesEnabled;
			}
			public boolean isBuffered() {
				return this.buffered;
			}
			public void setBuffered(boolean buffered) {
				this.buffered = buffered;
			}
		}
		/**
		 * Tomcat thread properties.
		 */
		public static class Threads {
			/**
			 * Maximum amount of worker threads. Doesn"t have an effect if virtual threads
			 * are enabled.
			 */
			private int max = 200;
			/**
			 * Minimum amount of worker threads. Doesn"t have an effect if virtual threads
			 * are enabled.
			 */
			private int minSpare = 10;
			/**
			 * Maximum capacity of the thread pool"s backing queue. This setting only has
			 * an effect if the value is greater than 0.
			 */
			private int maxQueueCapacity = 2147483647;
			public int getMax() {
				return this.max;
			}
			public void setMax(int max) {
				this.max = max;
			}
			public int getMinSpare() {
				return this.minSpare;
			}
			public void setMinSpare(int minSpare) {
				this.minSpare = minSpare;
			}
			public int getMaxQueueCapacity() {
				return this.maxQueueCapacity;
			}
			public void setMaxQueueCapacity(int maxQueueCapacity) {
				this.maxQueueCapacity = maxQueueCapacity;
			}
		}
		/**
		 * Tomcat static resource properties.
		 */
		public static class Resource {
			/**
			 * Whether static resource caching is permitted for this web application.
			 */
			private boolean allowCaching = true;
			/**
			 * Time-to-live of the static resource cache.
			 */
			private Duration cacheTtl;
			public boolean isAllowCaching() {
				return this.allowCaching;
			}
			public void setAllowCaching(boolean allowCaching) {
				this.allowCaching = allowCaching;
			}
			public Duration getCacheTtl() {
				return this.cacheTtl;
			}
			public void setCacheTtl(Duration cacheTtl) {
				this.cacheTtl = cacheTtl;
			}
		}
		public static class Mbeanregistry {
			/**
			 * Whether Tomcat"s MBean Registry should be enabled.
			 */
			private boolean enabled;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
		}
		public static class Remoteip {
			/**
			 * Regular expression that matches proxies that are to be trusted.
			 */
			private String internalProxies = '10\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|' // 10/8
					+ '192\\.168\\.\\d{1,3}\\.\\d{1,3}|' // 192.168/16
					+ '169\\.254\\.\\d{1,3}\\.\\d{1,3}|' // 169.254/16
					+ '127\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|' // 127/8
					+ '100\\.6[4-9]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
					+ '100\\.[7-9]{1}\\d{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
					+ '100\\.1[0-1]{1}\\d{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
					+ '100\\.12[0-7]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 100.64.0.0/10
					+ '172\\.1[6-9]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 172.16/12
					+ '172\\.2[0-9]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 172.16/12
					+ '172\\.3[0-1]{1}\\.\\d{1,3}\\.\\d{1,3}|' // 172.16/12
					+ '0:0:0:0:0:0:0:1|::1';
			/**
			 * Header that holds the incoming protocol, usually named 'X-Forwarded-Proto'.
			 */
			private String protocolHeader;
			/**
			 * Value of the protocol header indicating whether the incoming request uses
			 * SSL.
			 */
			private String protocolHeaderHttpsValue = 'https';
			/**
			 * Name of the HTTP header from which the remote host is extracted.
			 */
			private String hostHeader = 'X-Forwarded-Host';
			/**
			 * Name of the HTTP header used to override the original port value.
			 */
			private String portHeader = 'X-Forwarded-Port';
			/**
			 * Name of the HTTP header from which the remote IP is extracted. For
			 * instance, "X-FORWARDED-FOR".
			 */
			private String remoteIpHeader;
			/**
			 * Regular expression defining proxies that are trusted when they appear in
			 * the 'remote-ip-header' header.
			 */
			private String trustedProxies;
			public String getInternalProxies() {
				return this.internalProxies;
			}
			public void setInternalProxies(String internalProxies) {
				this.internalProxies = internalProxies;
			}
			public String getProtocolHeader() {
				return this.protocolHeader;
			}
			public void setProtocolHeader(String protocolHeader) {
				this.protocolHeader = protocolHeader;
			}
			public String getProtocolHeaderHttpsValue() {
				return this.protocolHeaderHttpsValue;
			}
			public String getHostHeader() {
				return this.hostHeader;
			}
			public void setHostHeader(String hostHeader) {
				this.hostHeader = hostHeader;
			}
			public void setProtocolHeaderHttpsValue(String protocolHeaderHttpsValue) {
				this.protocolHeaderHttpsValue = protocolHeaderHttpsValue;
			}
			public String getPortHeader() {
				return this.portHeader;
			}
			public void setPortHeader(String portHeader) {
				this.portHeader = portHeader;
			}
			public String getRemoteIpHeader() {
				return this.remoteIpHeader;
			}
			public void setRemoteIpHeader(String remoteIpHeader) {
				this.remoteIpHeader = remoteIpHeader;
			}
			public String getTrustedProxies() {
				return this.trustedProxies;
			}
			public void setTrustedProxies(String trustedProxies) {
				this.trustedProxies = trustedProxies;
			}
		}
	}
	/**
	 * Jetty properties.
	 */
	public static class Jetty {
		/**
		 * Access log configuration.
		 */
		private final Accesslog accesslog = new Accesslog();
		/**
		 * Thread related configuration.
		 */
		private final Threads threads = new Threads();
		/**
		 * Maximum size of the form content in any HTTP post request.
		 */
		private DataSize maxHttpFormPostSize = DataSize.ofBytes(200000);
		/**
		 * Maximum number of form keys.
		 */
		private int maxFormKeys = 1000;
		/**
		 * Time that the connection can be idle before it is closed.
		 */
		private Duration connectionIdleTimeout;
		/**
		 * Maximum size of the HTTP response header.
		 */
		private DataSize maxHttpResponseHeaderSize = DataSize.ofKilobytes(8);
		/**
		 * Maximum number of connections that the server accepts and processes at any
		 * given time.
		 */
		private int maxConnections = -1;
		public Accesslog getAccesslog() {
			return this.accesslog;
		}
		public Threads getThreads() {
			return this.threads;
		}
		public DataSize getMaxHttpFormPostSize() {
			return this.maxHttpFormPostSize;
		}
		public void setMaxHttpFormPostSize(DataSize maxHttpFormPostSize) {
			this.maxHttpFormPostSize = maxHttpFormPostSize;
		}
		public int getMaxFormKeys() {
			return this.maxFormKeys;
		}
		public void setMaxFormKeys(int maxFormKeys) {
			this.maxFormKeys = maxFormKeys;
		}
		public Duration getConnectionIdleTimeout() {
			return this.connectionIdleTimeout;
		}
		public void setConnectionIdleTimeout(Duration connectionIdleTimeout) {
			this.connectionIdleTimeout = connectionIdleTimeout;
		}
		public DataSize getMaxHttpResponseHeaderSize() {
			return this.maxHttpResponseHeaderSize;
		}
		public void setMaxHttpResponseHeaderSize(DataSize maxHttpResponseHeaderSize) {
			this.maxHttpResponseHeaderSize = maxHttpResponseHeaderSize;
		}
		public int getMaxConnections() {
			return this.maxConnections;
		}
		public void setMaxConnections(int maxConnections) {
			this.maxConnections = maxConnections;
		}
		/**
		 * Jetty access log properties.
		 */
		public static class Accesslog {
			/**
			 * Enable access log.
			 */
			private boolean enabled = false;
			/**
			 * Log format.
			 */
			private FORMAT format = FORMAT.NCSA;
			/**
			 * Custom log format, see org.eclipse.jetty.server.CustomRequestLog. If
			 * defined, overrides the 'format' configuration key.
			 */
			private String customFormat;
			/**
			 * Log filename. If not specified, logs redirect to 'System.err'.
			 */
			private String filename;
			/**
			 * Date format to place in log file name.
			 */
			private String fileDateFormat;
			/**
			 * Number of days before rotated log files are deleted.
			 */
			private int retentionPeriod = 31; // no days
			/**
			 * Append to log.
			 */
			private boolean append;
			/**
			 * Request paths that should not be logged.
			 */
			private List<String> ignorePaths;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
			public FORMAT getFormat() {
				return this.format;
			}
			public void setFormat(FORMAT format) {
				this.format = format;
			}
			public String getCustomFormat() {
				return this.customFormat;
			}
			public void setCustomFormat(String customFormat) {
				this.customFormat = customFormat;
			}
			public String getFilename() {
				return this.filename;
			}
			public void setFilename(String filename) {
				this.filename = filename;
			}
			public String getFileDateFormat() {
				return this.fileDateFormat;
			}
			public void setFileDateFormat(String fileDateFormat) {
				this.fileDateFormat = fileDateFormat;
			}
			public int getRetentionPeriod() {
				return this.retentionPeriod;
			}
			public void setRetentionPeriod(int retentionPeriod) {
				this.retentionPeriod = retentionPeriod;
			}
			public boolean isAppend() {
				return this.append;
			}
			public void setAppend(boolean append) {
				this.append = append;
			}
			public List<String> getIgnorePaths() {
				return this.ignorePaths;
			}
			public void setIgnorePaths(List<String> ignorePaths) {
				this.ignorePaths = ignorePaths;
			}
			/**
			 * Log format for Jetty access logs.
			 */
			public enum FORMAT {
				/**
				 * NCSA format, as defined in CustomRequestLog#NCSA_FORMAT.
				 */
				NCSA,
				/**
				 * Extended NCSA format, as defined in
				 * CustomRequestLog#EXTENDED_NCSA_FORMAT.
				 */
				EXTENDED_NCSA
			}
		}
		/**
		 * Jetty thread properties.
		 */
		public static class Threads {
			/**
			 * Number of acceptor threads to use. When the value is -1, the default, the
			 * number of acceptors is derived from the operating environment.
			 */
			private Integer acceptors = -1;
			/**
			 * Number of selector threads to use. When the value is -1, the default, the
			 * number of selectors is derived from the operating environment.
			 */
			private Integer selectors = -1;
			/**
			 * Maximum number of threads. Doesn"t have an effect if virtual threads are
			 * enabled.
			 */
			private Integer max = 200;
			/**
			 * Minimum number of threads. Doesn"t have an effect if virtual threads are
			 * enabled.
			 */
			private Integer min = 8;
			/**
			 * Maximum capacity of the thread pool"s backing queue. A default is computed
			 * based on the threading configuration.
			 */
			private Integer maxQueueCapacity;
			/**
			 * Maximum thread idle time.
			 */
			private Duration idleTimeout = Duration.ofMillis(60000);
			public Integer getAcceptors() {
				return this.acceptors;
			}
			public void setAcceptors(Integer acceptors) {
				this.acceptors = acceptors;
			}
			public Integer getSelectors() {
				return this.selectors;
			}
			public void setSelectors(Integer selectors) {
				this.selectors = selectors;
			}
			public void setMin(Integer min) {
				this.min = min;
			}
			public Integer getMin() {
				return this.min;
			}
			public void setMax(Integer max) {
				this.max = max;
			}
			public Integer getMax() {
				return this.max;
			}
			public Integer getMaxQueueCapacity() {
				return this.maxQueueCapacity;
			}
			public void setMaxQueueCapacity(Integer maxQueueCapacity) {
				this.maxQueueCapacity = maxQueueCapacity;
			}
			public void setIdleTimeout(Duration idleTimeout) {
				this.idleTimeout = idleTimeout;
			}
			public Duration getIdleTimeout() {
				return this.idleTimeout;
			}
		}
	}
	/**
	 * Netty properties.
	 */
	public static class Netty {
		/**
		 * Connection timeout of the Netty channel.
		 */
		private Duration connectionTimeout;
		/**
		 * Maximum content length of an H2C upgrade request.
		 */
		private DataSize h2cMaxContentLength = DataSize.ofBytes(0);
		/**
		 * Initial buffer size for HTTP request decoding.
		 */
		private DataSize initialBufferSize = DataSize.ofBytes(128);
		/**
		 * Maximum length that can be decoded for an HTTP request"s initial line.
		 */
		private DataSize maxInitialLineLength = DataSize.ofKilobytes(4);
		/**
		 * Maximum number of requests that can be made per connection. By default, a
		 * connection serves unlimited number of requests.
		 */
		private Integer maxKeepAliveRequests;
		/**
		 * Whether to validate headers when decoding requests.
		 */
		private boolean validateHeaders = true;
		/**
		 * Idle timeout of the Netty channel. When not specified, an infinite timeout is
		 * used.
		 */
		private Duration idleTimeout;
		public Duration getConnectionTimeout() {
			return this.connectionTimeout;
		}
		public void setConnectionTimeout(Duration connectionTimeout) {
			this.connectionTimeout = connectionTimeout;
		}
		public DataSize getH2cMaxContentLength() {
			return this.h2cMaxContentLength;
		}
		public void setH2cMaxContentLength(DataSize h2cMaxContentLength) {
			this.h2cMaxContentLength = h2cMaxContentLength;
		}
		public DataSize getInitialBufferSize() {
			return this.initialBufferSize;
		}
		public void setInitialBufferSize(DataSize initialBufferSize) {
			this.initialBufferSize = initialBufferSize;
		}
		public DataSize getMaxInitialLineLength() {
			return this.maxInitialLineLength;
		}
		public void setMaxInitialLineLength(DataSize maxInitialLineLength) {
			this.maxInitialLineLength = maxInitialLineLength;
		}
		public Integer getMaxKeepAliveRequests() {
			return this.maxKeepAliveRequests;
		}
		public void setMaxKeepAliveRequests(Integer maxKeepAliveRequests) {
			this.maxKeepAliveRequests = maxKeepAliveRequests;
		}
		public boolean isValidateHeaders() {
			return this.validateHeaders;
		}
		public void setValidateHeaders(boolean validateHeaders) {
			this.validateHeaders = validateHeaders;
		}
		public Duration getIdleTimeout() {
			return this.idleTimeout;
		}
		public void setIdleTimeout(Duration idleTimeout) {
			this.idleTimeout = idleTimeout;
		}
	}
	/**
	 * Undertow properties.
	 */
	public static class Undertow {
		/**
		 * Maximum size of the HTTP post content. When the value is -1, the default, the
		 * size is unlimited.
		 */
		private DataSize maxHttpPostSize = DataSize.ofBytes(-1);
		/**
		 * Size of each buffer. The default is derived from the maximum amount of memory
		 * that is available to the JVM.
		 */
		private DataSize bufferSize;
		/**
		 * Whether to allocate buffers outside the Java heap. The default is derived from
		 * the maximum amount of memory that is available to the JVM.
		 */
		private Boolean directBuffers;
		/**
		 * Whether servlet filters should be initialized on startup.
		 */
		private boolean eagerFilterInit = true;
		/**
		 * Maximum number of query or path parameters that are allowed. This limit exists
		 * to prevent hash collision based DOS attacks.
		 */
		private int maxParameters = UndertowOptions.DEFAULT_MAX_PARAMETERS;
		/**
		 * Maximum number of headers that are allowed. This limit exists to prevent hash
		 * collision based DOS attacks.
		 */
		private int maxHeaders = UndertowOptions.DEFAULT_MAX_HEADERS;
		/**
		 * Maximum number of cookies that are allowed. This limit exists to prevent hash
		 * collision based DOS attacks.
		 */
		private int maxCookies = 200;
		/**
		 * Whether the server should decode percent encoded slash characters. Enabling
		 * encoded slashes can have security implications due to different servers
		 * interpreting the slash differently. Only enable this if you have a legacy
		 * application that requires it. Has no effect when server.undertow.decode-slash
		 * is set.
		 */
		private boolean allowEncodedSlash = false;
		/**
		 * Whether encoded slash characters (%2F) should be decoded. Decoding can cause
		 * security problems if a front-end proxy does not perform the same decoding. Only
		 * enable this if you have a legacy application that requires it. When set,
		 * server.undertow.allow-encoded-slash has no effect.
		 */
		private Boolean decodeSlash;
		/**
		 * Whether the URL should be decoded. When disabled, percent-encoded characters in
		 * the URL will be left as-is.
		 */
		private boolean decodeUrl = true;
		/**
		 * Charset used to decode URLs.
		 */
		private Charset urlCharset = StandardCharsets.UTF_8;
		/**
		 * Whether the "Connection: keep-alive" header should be added to all responses,
		 * even if not required by the HTTP specification.
		 */
		private boolean alwaysSetKeepAlive = true;
		/**
		 * Amount of time a connection can sit idle without processing a request, before
		 * it is closed by the server.
		 */
		private Duration noRequestTimeout;
		/**
		 * Whether to preserve the path of a request when it is forwarded.
		 */
		private boolean preservePathOnForward = false;
		private final Accesslog accesslog = new Accesslog();
		/**
		 * Thread related configuration.
		 */
		private final Threads threads = new Threads();
		private final Options options = new Options();
		public DataSize getMaxHttpPostSize() {
			return this.maxHttpPostSize;
		}
		public void setMaxHttpPostSize(DataSize maxHttpPostSize) {
			this.maxHttpPostSize = maxHttpPostSize;
		}
		public DataSize getBufferSize() {
			return this.bufferSize;
		}
		public void setBufferSize(DataSize bufferSize) {
			this.bufferSize = bufferSize;
		}
		public Boolean getDirectBuffers() {
			return this.directBuffers;
		}
		public void setDirectBuffers(Boolean directBuffers) {
			this.directBuffers = directBuffers;
		}
		public boolean isEagerFilterInit() {
			return this.eagerFilterInit;
		}
		public void setEagerFilterInit(boolean eagerFilterInit) {
			this.eagerFilterInit = eagerFilterInit;
		}
		public int getMaxParameters() {
			return this.maxParameters;
		}
		public void setMaxParameters(Integer maxParameters) {
			this.maxParameters = maxParameters;
		}
		public int getMaxHeaders() {
			return this.maxHeaders;
		}
		public void setMaxHeaders(int maxHeaders) {
			this.maxHeaders = maxHeaders;
		}
		public Integer getMaxCookies() {
			return this.maxCookies;
		}
		public void setMaxCookies(Integer maxCookies) {
			this.maxCookies = maxCookies;
		}
		@DeprecatedConfigurationProperty(replacement = 'server.undertow.decode-slash', since = '3.0.3')
		@Deprecated(forRemoval = true, since = '3.0.3')
		public boolean isAllowEncodedSlash() {
			return this.allowEncodedSlash;
		}
		@Deprecated(forRemoval = true, since = '3.0.3')
		public void setAllowEncodedSlash(boolean allowEncodedSlash) {
			this.allowEncodedSlash = allowEncodedSlash;
		}
		public Boolean getDecodeSlash() {
			return this.decodeSlash;
		}
		public void setDecodeSlash(Boolean decodeSlash) {
			this.decodeSlash = decodeSlash;
		}
		public boolean isDecodeUrl() {
			return this.decodeUrl;
		}
		public void setDecodeUrl(Boolean decodeUrl) {
			this.decodeUrl = decodeUrl;
		}
		public Charset getUrlCharset() {
			return this.urlCharset;
		}
		public void setUrlCharset(Charset urlCharset) {
			this.urlCharset = urlCharset;
		}
		public boolean isAlwaysSetKeepAlive() {
			return this.alwaysSetKeepAlive;
		}
		public void setAlwaysSetKeepAlive(boolean alwaysSetKeepAlive) {
			this.alwaysSetKeepAlive = alwaysSetKeepAlive;
		}
		public Duration getNoRequestTimeout() {
			return this.noRequestTimeout;
		}
		public void setNoRequestTimeout(Duration noRequestTimeout) {
			this.noRequestTimeout = noRequestTimeout;
		}
		public boolean isPreservePathOnForward() {
			return this.preservePathOnForward;
		}
		public void setPreservePathOnForward(boolean preservePathOnForward) {
			this.preservePathOnForward = preservePathOnForward;
		}
		public Accesslog getAccesslog() {
			return this.accesslog;
		}
		public Threads getThreads() {
			return this.threads;
		}
		public Options getOptions() {
			return this.options;
		}
		/**
		 * Undertow access log properties.
		 */
		public static class Accesslog {
			/**
			 * Whether to enable the access log.
			 */
			private boolean enabled = false;
			/**
			 * Format pattern for access logs.
			 */
			private String pattern = 'common';
			/**
			 * Log file name prefix.
			 */
			protected String prefix = 'access_log.';
			/**
			 * Log file name suffix.
			 */
			private String suffix = 'log';
			/**
			 * Undertow access log directory.
			 */
			private File dir = new File('logs');
			/**
			 * Whether to enable access log rotation.
			 */
			private boolean rotate = true;
			public boolean isEnabled() {
				return this.enabled;
			}
			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}
			public String getPattern() {
				return this.pattern;
			}
			public void setPattern(String pattern) {
				this.pattern = pattern;
			}
			public String getPrefix() {
				return this.prefix;
			}
			public void setPrefix(String prefix) {
				this.prefix = prefix;
			}
			public String getSuffix() {
				return this.suffix;
			}
			public void setSuffix(String suffix) {
				this.suffix = suffix;
			}
			public File getDir() {
				return this.dir;
			}
			public void setDir(File dir) {
				this.dir = dir;
			}
			public boolean isRotate() {
				return this.rotate;
			}
			public void setRotate(boolean rotate) {
				this.rotate = rotate;
			}
		}
		/**
		 * Undertow thread properties.
		 */
		public static class Threads {
			/**
			 * Number of I/O threads to create for the worker. The default is derived from
			 * the number of available processors.
			 */
			private Integer io;
			/**
			 * Number of worker threads. The default is 8 times the number of I/O threads.
			 */
			private Integer worker;
			public Integer getIo() {
				return this.io;
			}
			public void setIo(Integer io) {
				this.io = io;
			}
			public Integer getWorker() {
				return this.worker;
			}
			public void setWorker(Integer worker) {
				this.worker = worker;
			}
		}
		public static class Options {
			/**
			 * Socket options as defined in org.xnio.Options.
			 */
			private final Map<String, String> socket = new LinkedHashMap<>();
			/**
			 * Server options as defined in io.undertow.UndertowOptions.
			 */
			private final Map<String, String> server = new LinkedHashMap<>();
			public Map<String, String> getServer() {
				return this.server;
			}
			public Map<String, String> getSocket() {
				return this.socket;
			}
		}
	}
	/**
	 * Strategies for supporting forward headers.
	 */
	public enum ForwardHeadersStrategy {
		/**
		 * Use the underlying container"s native support for forwarded headers.
		 */
		NATIVE,
		/**
		 * Use Spring"s support for handling forwarded headers.
		 */
		FRAMEWORK,
		/**
		 * Ignore X-Forwarded-* headers.
		 */
		NONE
	}
}
/*
package org.springframework.boot.autoconfigure.web;
/**
public class WebResourcesRuntimeHints implements RuntimeHintsRegistrar {
	private static final List<String> DEFAULT_LOCATIONS = List.of('META-INF/resources/', 'resources/', 'static/',
			'public/');
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		ClassLoader classLoaderToUse = (classLoader != null) ? classLoader : getClass().getClassLoader();
		String[] locations = DEFAULT_LOCATIONS.stream()
			.filter((candidate) -> classLoaderToUse.getResource(candidate) != null)
			.map((location) -> location + '*')
			.toArray(String[]::new);
		if (locations.length > 0) {
			hints.resources().registerPattern((hint) -> hint.includes(locations));
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web;
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
class ResourceChainResourceHandlerRegistrationCustomizer implements ResourceHandlerRegistrationCustomizer {
	private final Resources resourceProperties;
	ResourceChainResourceHandlerRegistrationCustomizer(Resources resources) {
		this.resourceProperties = resources;
	}
	@Override
	public void customize(ResourceHandlerRegistration registration) {
		Resources.Chain properties = this.resourceProperties.getChain();
		configureResourceChain(properties, registration.resourceChain(properties.isCache()));
	}
	private void configureResourceChain(Resources.Chain properties, ResourceChainRegistration chain) {
		Resources.Chain.Strategy strategy = properties.getStrategy();
		if (properties.isCompressed()) {
			chain.addResolver(new EncodedResourceResolver());
		}
		if (strategy.getFixed().isEnabled() || strategy.getContent().isEnabled()) {
			chain.addResolver(getVersionResourceResolver(strategy));
		}
	}
	private ResourceResolver getVersionResourceResolver(Resources.Chain.Strategy properties) {
		VersionResourceResolver resolver = new VersionResourceResolver();
		if (properties.getFixed().isEnabled()) {
			String version = properties.getFixed().getVersion();
			String[] paths = properties.getFixed().getPaths();
			resolver.addFixedVersionStrategy(version, paths);
		}
		if (properties.getContent().isEnabled()) {
			String[] paths = properties.getContent().getPaths();
			resolver.addContentVersionStrategy(paths);
		}
		return resolver;
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
public class TomcatReactiveWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<TomcatReactiveWebServerFactory> {
	private final ServerProperties serverProperties;
	public TomcatReactiveWebServerFactoryCustomizer(ServerProperties serverProperties) {
		this.serverProperties = serverProperties;
	}
	@Override
	public void customize(TomcatReactiveWebServerFactory factory) {
		factory.setDisableMBeanRegistry(!this.serverProperties.getTomcat().getMbeanregistry().isEnabled());
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
final class WelcomePageRouterFunctionFactory {
	private final String staticPathPattern;
	private final Resource welcomePage;
	private final boolean welcomePageTemplateExists;
	WelcomePageRouterFunctionFactory(TemplateAvailabilityProviders templateAvailabilityProviders,
			ApplicationContext applicationContext, String[] staticLocations, String staticPathPattern) {
		this.staticPathPattern = staticPathPattern;
		this.welcomePage = getWelcomePage(applicationContext, staticLocations);
		this.welcomePageTemplateExists = welcomeTemplateExists(templateAvailabilityProviders, applicationContext);
	}
	private Resource getWelcomePage(ResourceLoader resourceLoader, String[] staticLocations) {
		return Arrays.stream(staticLocations)
			.map((location) -> getIndexHtml(resourceLoader, location))
			.filter(this::isReadable)
			.findFirst()
			.orElse(null);
	}
	private Resource getIndexHtml(ResourceLoader resourceLoader, String location) {
		return resourceLoader.getResource(location + 'index.html');
	}
	private boolean isReadable(Resource resource) {
		try {
			return resource.exists() && (resource.getURL() != null);
		}
		catch (Exception ex) {
			return false;
		}
	}
	private boolean welcomeTemplateExists(TemplateAvailabilityProviders templateAvailabilityProviders,
			ApplicationContext applicationContext) {
		return templateAvailabilityProviders.getProvider('index', applicationContext) != null;
	}
	RouterFunction<ServerResponse> createRouterFunction() {
		if (this.welcomePage != null && '/**'.equals(this.staticPathPattern)) {
			return RouterFunctions.route(GET('/').and(accept(MediaType.TEXT_HTML)),
					(req) -> ServerResponse.ok().contentType(MediaType.TEXT_HTML).bodyValue(this.welcomePage));
		}
		else if (this.welcomePageTemplateExists) {
			return RouterFunctions.route(GET('/').and(accept(MediaType.TEXT_HTML)),
					(req) -> ServerResponse.ok().render('index'));
		}
		return null;
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@AutoConfiguration(after = { WebFluxAutoConfiguration.class })
@ConditionalOnClass({ DispatcherHandler.class, HttpHandler.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@ConditionalOnMissingBean(HttpHandler.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
public class HttpHandlerAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	public static class AnnotationConfig {
		private final ApplicationContext applicationContext;
		public AnnotationConfig(ApplicationContext applicationContext) {
			this.applicationContext = applicationContext;
		}
		@Bean
		public HttpHandler httpHandler(ObjectProvider<WebFluxProperties> propsProvider,
				ObjectProvider<WebHttpHandlerBuilderCustomizer> handlerBuilderCustomizers) {
			WebHttpHandlerBuilder handlerBuilder = WebHttpHandlerBuilder.applicationContext(this.applicationContext);
			handlerBuilderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(handlerBuilder));
			HttpHandler httpHandler = handlerBuilder.build();
			WebFluxProperties properties = propsProvider.getIfAvailable();
			if (properties != null && StringUtils.hasText(properties.getBasePath())) {
				Map<String, HttpHandler> handlersMap = Collections.singletonMap(properties.getBasePath(), httpHandler);
				return new ContextPathCompositeHandler(handlersMap);
			}
			return httpHandler;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@AutoConfiguration
@ConditionalOnClass(ReactiveHttpInputMessage.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@EnableConfigurationProperties(ServerProperties.class)
@Import({ ReactiveWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,
		ReactiveWebServerFactoryConfiguration.EmbeddedTomcat.class,
		ReactiveWebServerFactoryConfiguration.EmbeddedJetty.class,
		ReactiveWebServerFactoryConfiguration.EmbeddedUndertow.class,
		ReactiveWebServerFactoryConfiguration.EmbeddedNetty.class })
public class ReactiveWebServerFactoryAutoConfiguration {
	@Bean
	public ReactiveWebServerFactoryCustomizer reactiveWebServerFactoryCustomizer(ServerProperties serverProperties,
			ObjectProvider<SslBundles> sslBundles) {
		return new ReactiveWebServerFactoryCustomizer(serverProperties, sslBundles.getIfAvailable());
	}
	@Bean
	@ConditionalOnClass(name = 'org.apache.catalina.startup.Tomcat')
	public TomcatReactiveWebServerFactoryCustomizer tomcatReactiveWebServerFactoryCustomizer(
			ServerProperties serverProperties) {
		return new TomcatReactiveWebServerFactoryCustomizer(serverProperties);
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(value = 'server.forward-headers-strategy', havingValue = 'framework')
	public ForwardedHeaderTransformer forwardedHeaderTransformer() {
		return new ForwardedHeaderTransformer();
	}
	/**
	 * Registers a {@link WebServerFactoryCustomizerBeanPostProcessor}. Registered via
	 * {@link ImportBeanDefinitionRegistrar} for early registration.
	 */
	public static class BeanPostProcessorsRegistrar implements ImportBeanDefinitionRegistrar, BeanFactoryAware {
		private ConfigurableListableBeanFactory beanFactory;
		@Override
		public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
			if (beanFactory instanceof ConfigurableListableBeanFactory listableBeanFactory) {
				this.beanFactory = listableBeanFactory;
			}
		}
		@Override
		public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
				BeanDefinitionRegistry registry) {
			if (this.beanFactory == null) {
				return;
			}
			registerSyntheticBeanIfMissing(registry, 'webServerFactoryCustomizerBeanPostProcessor',
					WebServerFactoryCustomizerBeanPostProcessor.class);
		}
		private <T> void registerSyntheticBeanIfMissing(BeanDefinitionRegistry registry, String name,
				Class<T> beanClass) {
			if (ObjectUtils.isEmpty(this.beanFactory.getBeanNamesForType(beanClass, true, false))) {
				RootBeanDefinition beanDefinition = new RootBeanDefinition(beanClass);
				beanDefinition.setSynthetic(true);
				registry.registerBeanDefinition(name, beanDefinition);
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@AutoConfiguration
@ConditionalOnClass({ DefaultPartHttpMessageReader.class, WebFluxConfigurer.class })
@ConditionalOnWebApplication(type = Type.REACTIVE)
@EnableConfigurationProperties(ReactiveMultipartProperties.class)
public class ReactiveMultipartAutoConfiguration {
	@Bean
	@Order(0)
	CodecCustomizer defaultPartHttpMessageReaderCustomizer(ReactiveMultipartProperties multipartProperties) {
		return (configurer) -> configurer.defaultCodecs().configureDefaultCodec((codec) -> {
			if (codec instanceof DefaultPartHttpMessageReader defaultPartHttpMessageReader) {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(multipartProperties::getMaxInMemorySize)
					.asInt(DataSize::toBytes)
					.to(defaultPartHttpMessageReader::setMaxInMemorySize);
				map.from(multipartProperties::getMaxHeadersSize)
					.asInt(DataSize::toBytes)
					.to(defaultPartHttpMessageReader::setMaxHeadersSize);
				map.from(multipartProperties::getMaxDiskUsagePerPart)
					.as(DataSize::toBytes)
					.to(defaultPartHttpMessageReader::setMaxDiskUsagePerPart);
				map.from(multipartProperties::getMaxParts).to(defaultPartHttpMessageReader::setMaxParts);
				map.from(multipartProperties::getFileStorageDirectory)
					.as(Paths::get)
					.to((dir) -> configureFileStorageDirectory(defaultPartHttpMessageReader, dir));
				map.from(multipartProperties::getHeadersCharset).to(defaultPartHttpMessageReader::setHeadersCharset);
			}
			else if (codec instanceof PartEventHttpMessageReader partEventHttpMessageReader) {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(multipartProperties::getMaxInMemorySize)
					.asInt(DataSize::toBytes)
					.to(partEventHttpMessageReader::setMaxInMemorySize);
				map.from(multipartProperties::getMaxHeadersSize)
					.asInt(DataSize::toBytes)
					.to(partEventHttpMessageReader::setMaxHeadersSize);
				map.from(multipartProperties::getMaxDiskUsagePerPart)
					.as(DataSize::toBytes)
					.to(partEventHttpMessageReader::setMaxPartSize);
				map.from(multipartProperties::getMaxParts).to(partEventHttpMessageReader::setMaxParts);
				map.from(multipartProperties::getHeadersCharset).to(partEventHttpMessageReader::setHeadersCharset);
			}
		});
	}
	private void configureFileStorageDirectory(DefaultPartHttpMessageReader defaultPartHttpMessageReader,
			Path fileStorageDirectory) {
		try {
			defaultPartHttpMessageReader.setFileStorageDirectory(fileStorageDirectory);
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to configure multipart file storage directory', ex);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.error;
/**
public class DefaultErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {
	private static final MediaType TEXT_HTML_UTF8 = new MediaType('text', 'html', StandardCharsets.UTF_8);
	private static final Map<HttpStatus.Series, String> SERIES_VIEWS;
	static {
		Map<HttpStatus.Series, String> views = new EnumMap<>(HttpStatus.Series.class);
		views.put(HttpStatus.Series.CLIENT_ERROR, '4xx');
		views.put(HttpStatus.Series.SERVER_ERROR, '5xx');
		SERIES_VIEWS = Collections.unmodifiableMap(views);
	}
	private static final ErrorAttributeOptions ONLY_STATUS = ErrorAttributeOptions.of(Include.STATUS);
	private static final DefaultErrorAttributes defaultErrorAttributes = new DefaultErrorAttributes();
	private final ErrorProperties errorProperties;
	/**
	 * Create a new {@code DefaultErrorWebExceptionHandler} instance.
	 * @param errorAttributes the error attributes
	 * @param resources the resources configuration properties
	 * @param errorProperties the error configuration properties
	 * @param applicationContext the current application context
	 * @since 2.4.0
	 */
	public DefaultErrorWebExceptionHandler(ErrorAttributes errorAttributes, Resources resources,
			ErrorProperties errorProperties, ApplicationContext applicationContext) {
		super(errorAttributes, resources, applicationContext);
		this.errorProperties = errorProperties;
	}
	@Override
	protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {
		return route(acceptsTextHtml(), this::renderErrorView).andRoute(all(), this::renderErrorResponse);
	}
	/**
	 * Render the error information as an HTML view.
	 * @param request the current request
	 * @return a {@code Publisher} of the HTTP response
	 */
	protected Mono<ServerResponse> renderErrorView(ServerRequest request) {
		Map<String, Object> errorAttributes = getErrorAttributes(request, MediaType.TEXT_HTML);
		int status = getHttpStatus(request, errorAttributes);
		ServerResponse.BodyBuilder responseBody = ServerResponse.status(status).contentType(TEXT_HTML_UTF8);
		return Flux.just(getData(status).toArray(new String[] {}))
			.flatMap((viewName) -> renderErrorView(viewName, responseBody, errorAttributes))
			.switchIfEmpty(this.errorProperties.getWhitelabel().isEnabled()
					? renderDefaultErrorView(responseBody, errorAttributes) : Mono.error(getError(request)))
			.next();
	}
	private List<String> getData(int errorStatus) {
		List<String> data = new ArrayList<>();
		data.add('error/' + errorStatus);
		HttpStatus.Series series = HttpStatus.Series.resolve(errorStatus);
		if (series != null) {
			data.add('error/' + SERIES_VIEWS.get(series));
		}
		data.add('error/error');
		return data;
	}
	/**
	 * Render the error information as a JSON payload.
	 * @param request the current request
	 * @return a {@code Publisher} of the HTTP response
	 */
	protected Mono<ServerResponse> renderErrorResponse(ServerRequest request) {
		Map<String, Object> errorAttributes = getErrorAttributes(request, MediaType.ALL);
		int status = getHttpStatus(request, errorAttributes);
		return ServerResponse.status(status)
			.contentType(MediaType.APPLICATION_JSON)
			.body(BodyInserters.fromValue(errorAttributes));
	}
	private Map<String, Object> getErrorAttributes(ServerRequest request, MediaType mediaType) {
		return getErrorAttributes(request, getErrorAttributeOptions(request, mediaType));
	}
	protected ErrorAttributeOptions getErrorAttributeOptions(ServerRequest request, MediaType mediaType) {
		ErrorAttributeOptions options = ErrorAttributeOptions.defaults();
		if (this.errorProperties.isIncludeException()) {
			options = options.including(Include.EXCEPTION);
		}
		if (isIncludeStackTrace(request, mediaType)) {
			options = options.including(Include.STACK_TRACE);
		}
		if (isIncludeMessage(request, mediaType)) {
			options = options.including(Include.MESSAGE);
		}
		if (isIncludeBindingErrors(request, mediaType)) {
			options = options.including(Include.BINDING_ERRORS);
		}
		options = isIncludePath(request, mediaType) ? options.including(Include.PATH) : options.excluding(Include.PATH);
		return options;
	}
	/**
	 * Determine if the stacktrace attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the stacktrace attribute should be included
	 */
	protected boolean isIncludeStackTrace(ServerRequest request, MediaType produces) {
		return switch (this.errorProperties.getIncludeStacktrace()) {
			case ALWAYS -> true;
			case ON_PARAM -> isTraceEnabled(request);
			case NEVER -> false;
		};
	}
	/**
	 * Determine if the message attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the message attribute should be included
	 */
	protected boolean isIncludeMessage(ServerRequest request, MediaType produces) {
		return switch (this.errorProperties.getIncludeMessage()) {
			case ALWAYS -> true;
			case ON_PARAM -> isMessageEnabled(request);
			case NEVER -> false;
		};
	}
	/**
	 * Determine if the errors attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the errors attribute should be included
	 */
	protected boolean isIncludeBindingErrors(ServerRequest request, MediaType produces) {
		return switch (this.errorProperties.getIncludeBindingErrors()) {
			case ALWAYS -> true;
			case ON_PARAM -> isBindingErrorsEnabled(request);
			case NEVER -> false;
		};
	}
	/**
	 * Determine if the path attribute should be included.
	 * @param request the source request
	 * @param produces the media type produced (or {@code MediaType.ALL})
	 * @return if the path attribute should be included
	 * @since 3.3.0
	 */
	protected boolean isIncludePath(ServerRequest request, MediaType produces) {
		return switch (this.errorProperties.getIncludePath()) {
			case ALWAYS -> true;
			case ON_PARAM -> isPathEnabled(request);
			case NEVER -> false;
		};
	}
	private int getHttpStatus(ServerRequest request, Map<String, Object> errorAttributes) {
		return getHttpStatus(errorAttributes.containsKey('status') ? errorAttributes
				: defaultErrorAttributes.getErrorAttributes(request, ONLY_STATUS));
	}
	/**
	 * Get the HTTP error status information from the error map.
	 * @param errorAttributes the current error information
	 * @return the error HTTP status
	 */
	protected int getHttpStatus(Map<String, Object> errorAttributes) {
		Object status = errorAttributes.get('status');
		Assert.state(status instanceof Integer, 'ErrorAttributes must contain a status integer');
		return (int) status;
	}
	/**
	 * Predicate that checks whether the current request explicitly support
	 * {@code 'text/html'} media type.
	 * <p>
	 * The 'match-all' media type is not considered here.
	 * @return the request predicate
	 */
	protected RequestPredicate acceptsTextHtml() {
		return (serverRequest) -> {
			try {
				List<MediaType> acceptedMediaTypes = serverRequest.headers().accept();
				acceptedMediaTypes.removeIf(MediaType.ALL::equalsTypeAndSubtype);
				MimeTypeUtils.sortBySpecificity(acceptedMediaTypes);
				return acceptedMediaTypes.stream().anyMatch(MediaType.TEXT_HTML::isCompatibleWith);
			}
			catch (InvalidMediaTypeException ex) {
				return false;
			}
		};
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.error;
/**
public abstract class AbstractErrorWebExceptionHandler implements ErrorWebExceptionHandler, InitializingBean {
	private static final Log logger = HttpLogging.forLogName(AbstractErrorWebExceptionHandler.class);
	private final ApplicationContext applicationContext;
	private final ErrorAttributes errorAttributes;
	private final Resources resources;
	private final TemplateAvailabilityProviders templateAvailabilityProviders;
	private List<HttpMessageReader<?>> messageReaders = Collections.emptyList();
	private List<HttpMessageWriter<?>> messageWriters = Collections.emptyList();
	private List<ViewResolver> viewResolvers = Collections.emptyList();
	/**
	 * Create a new {@code AbstractErrorWebExceptionHandler}.
	 * @param errorAttributes the error attributes
	 * @param resources the resources configuration properties
	 * @param applicationContext the application context
	 * @since 2.4.0
	 */
	public AbstractErrorWebExceptionHandler(ErrorAttributes errorAttributes, Resources resources,
			ApplicationContext applicationContext) {
		Assert.notNull(errorAttributes, 'ErrorAttributes must not be null');
		Assert.notNull(resources, 'Resources must not be null');
		Assert.notNull(applicationContext, 'ApplicationContext must not be null');
		this.errorAttributes = errorAttributes;
		this.resources = resources;
		this.applicationContext = applicationContext;
		this.templateAvailabilityProviders = new TemplateAvailabilityProviders(applicationContext);
	}
	/**
	 * Configure HTTP message writers to serialize the response body with.
	 * @param messageWriters the {@link HttpMessageWriter}s to use
	 */
	public void setMessageWriters(List<HttpMessageWriter<?>> messageWriters) {
		Assert.notNull(messageWriters, '"messageWriters" must not be null');
		this.messageWriters = messageWriters;
	}
	/**
	 * Configure HTTP message readers to deserialize the request body with.
	 * @param messageReaders the {@link HttpMessageReader}s to use
	 */
	public void setMessageReaders(List<HttpMessageReader<?>> messageReaders) {
		Assert.notNull(messageReaders, '"messageReaders" must not be null');
		this.messageReaders = messageReaders;
	}
	/**
	 * Configure the {@link ViewResolver} to use for rendering views.
	 * @param viewResolvers the list of {@link ViewResolver}s to use
	 */
	public void setViewResolvers(List<ViewResolver> viewResolvers) {
		this.viewResolvers = viewResolvers;
	}
	/**
	 * Extract the error attributes from the current request, to be used to populate error
	 * views or JSON payloads.
	 * @param request the source request
	 * @param options options to control error attributes
	 * @return the error attributes as a Map
	 */
	protected Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) {
		return this.errorAttributes.getErrorAttributes(request, options);
	}
	/**
	 * Extract the original error from the current request.
	 * @param request the source request
	 * @return the error
	 */
	protected Throwable getError(ServerRequest request) {
		return this.errorAttributes.getError(request);
	}
	/**
	 * Check whether the trace attribute has been set on the given request.
	 * @param request the source request
	 * @return {@code true} if the error trace has been requested, {@code false} otherwise
	 */
	protected boolean isTraceEnabled(ServerRequest request) {
		return getBooleanParameter(request, 'trace');
	}
	/**
	 * Check whether the message attribute has been set on the given request.
	 * @param request the source request
	 * @return {@code true} if the message attribute has been requested, {@code false}
	 * otherwise
	 */
	protected boolean isMessageEnabled(ServerRequest request) {
		return getBooleanParameter(request, 'message');
	}
	/**
	 * Check whether the errors attribute has been set on the given request.
	 * @param request the source request
	 * @return {@code true} if the errors attribute has been requested, {@code false}
	 * otherwise
	 */
	protected boolean isBindingErrorsEnabled(ServerRequest request) {
		return getBooleanParameter(request, 'errors');
	}
	/**
	 * Check whether the path attribute has been set on the given request.
	 * @param request the source request
	 * @return {@code true} if the path attribute has been requested, {@code false}
	 * otherwise
	 * @since 3.3.0
	 */
	protected boolean isPathEnabled(ServerRequest request) {
		return getBooleanParameter(request, 'path');
	}
	private boolean getBooleanParameter(ServerRequest request, String parameterName) {
		String parameter = request.queryParam(parameterName).orElse('false');
		return !'false'.equalsIgnoreCase(parameter);
	}
	/**
	 * Render the given error data as a view, using a template view if available or a
	 * static HTML file if available otherwise. This will return an empty
	 * {@code Publisher} if none of the above are available.
	 * @param viewName the view name
	 * @param responseBody the error response being built
	 * @param error the error data as a map
	 * @return a Publisher of the {@link ServerResponse}
	 */
	protected Mono<ServerResponse> renderErrorView(String viewName, ServerResponse.BodyBuilder responseBody,
			Map<String, Object> error) {
		if (isTemplateAvailable(viewName)) {
			return responseBody.render(viewName, error);
		}
		Resource resource = resolveResource(viewName);
		if (resource != null) {
			return responseBody.body(BodyInserters.fromResource(resource));
		}
		return Mono.empty();
	}
	private boolean isTemplateAvailable(String viewName) {
		return this.templateAvailabilityProviders.getProvider(viewName, this.applicationContext) != null;
	}
	private Resource resolveResource(String viewName) {
		for (String location : this.resources.getStaticLocations()) {
			try {
				Resource resource = this.applicationContext.getResource(location);
				resource = resource.createRelative(viewName + '.html');
				if (resource.exists()) {
					return resource;
				}
			}
			catch (Exception ex) {
				// Ignore
			}
		}
		return null;
	}
	/**
	 * Render a default HTML 'Whitelabel Error Page'.
	 * <p>
	 * Useful when no other error view is available in the application.
	 * @param responseBody the error response being built
	 * @param error the error data as a map
	 * @return a Publisher of the {@link ServerResponse}
	 */
	protected Mono<ServerResponse> renderDefaultErrorView(ServerResponse.BodyBuilder responseBody,
			Map<String, Object> error) {
		StringBuilder builder = new StringBuilder();
		Date timestamp = (Date) error.get('timestamp');
		Object message = error.get('message');
		Object trace = error.get('trace');
		Object requestId = error.get('requestId');
		builder.append('<html><body><h1>Whitelabel Error Page</h1>')
			.append('<p>This application has no configured error view, so you are seeing this as a fallback.</p>')
			.append('<div id="created">')
			.append(timestamp)
			.append('</div>')
			.append('<div>[')
			.append(requestId)
			.append('] There was an unexpected error (type=')
			.append(htmlEscape(error.get('error')))
			.append(', status=')
			.append(htmlEscape(error.get('status')))
			.append(').</div>');
		if (message != null) {
			builder.append('<div>').append(htmlEscape(message)).append('</div>');
		}
		if (trace != null) {
			builder.append('<div style="white-space:pre-wrap;">').append(htmlEscape(trace)).append('</div>');
		}
		builder.append('</body></html>');
		return responseBody.bodyValue(builder.toString());
	}
	private String htmlEscape(Object input) {
		return (input != null) ? HtmlUtils.htmlEscape(input.toString()) : null;
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		if (CollectionUtils.isEmpty(this.messageWriters)) {
			throw new IllegalArgumentException('Property "messageWriters" is required');
		}
	}
	/**
	 * Create a {@link RouterFunction} that can route and handle errors as JSON responses
	 * or HTML views.
	 * <p>
	 * If the returned {@link RouterFunction} doesn"t route to a {@code HandlerFunction},
	 * the original exception is propagated in the pipeline and can be processed by other
	 * {@link org.springframework.web.server.WebExceptionHandler}s.
	 * @param errorAttributes the {@code ErrorAttributes} instance to use to extract error
	 * information
	 * @return a {@link RouterFunction} that routes and handles errors
	 */
	protected abstract RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes);
	@Override
	public Mono<Void> handle(ServerWebExchange exchange, Throwable throwable) {
		if (exchange.getResponse().isCommitted() || isDisconnectedClientError(throwable)) {
			return Mono.error(throwable);
		}
		this.errorAttributes.storeErrorInformation(throwable, exchange);
		ServerRequest request = ServerRequest.create(exchange, this.messageReaders);
		return getRoutingFunction(this.errorAttributes).route(request)
			.switchIfEmpty(Mono.error(throwable))
			.flatMap((handler) -> handler.handle(request))
			.doOnNext((response) -> logError(request, response, throwable))
			.flatMap((response) -> write(exchange, response));
	}
	private boolean isDisconnectedClientError(Throwable ex) {
		return DisconnectedClientHelper.isClientDisconnectedException(ex);
	}
	/**
	 * Logs the {@code throwable} error for the given {@code request} and {@code response}
	 * exchange. The default implementation logs all errors at debug level. Additionally,
	 * any internal server error (500) is logged at error level.
	 * @param request the request that was being handled
	 * @param response the response that was being sent
	 * @param throwable the error to be logged
	 * @since 2.2.0
	 */
	protected void logError(ServerRequest request, ServerResponse response, Throwable throwable) {
		if (logger.isDebugEnabled()) {
			logger.debug(request.exchange().getLogPrefix() + formatError(throwable, request));
		}
		if (HttpStatus.resolve(response.statusCode().value()) != null
				&& response.statusCode().equals(HttpStatus.INTERNAL_SERVER_ERROR)) {
			logger.error(LogMessage.of(() -> String.format('%s 500 Server Error for %s',
					request.exchange().getLogPrefix(), formatRequest(request))), throwable);
		}
	}
	private String formatError(Throwable ex, ServerRequest request) {
		String reason = ex.getClass().getSimpleName() + ': ' + ex.getMessage();
		return 'Resolved [' + reason + '] for HTTP ' + request.method() + ' ' + request.path();
	}
	private String formatRequest(ServerRequest request) {
		String rawQuery = request.uri().getRawQuery();
		String query = StringUtils.hasText(rawQuery) ? '?' + rawQuery : '';
		return 'HTTP ' + request.method() + ' \'' + request.path() + query + '\'';
	}
	private Mono<? extends Void> write(ServerWebExchange exchange, ServerResponse response) {
		// force content-type since writeTo won"t overwrite response header values
		exchange.getResponse().getHeaders().setContentType(response.headers().getContentType());
		return response.writeTo(exchange, new ResponseContext());
	}
	private final class ResponseContext implements ServerResponse.Context {
		@Override
		public List<HttpMessageWriter<?>> messageWriters() {
			return AbstractErrorWebExceptionHandler.this.messageWriters;
		}
		@Override
		public List<ViewResolver> viewResolvers() {
			return AbstractErrorWebExceptionHandler.this.viewResolvers;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.error;
/**
@AutoConfiguration(before = WebFluxAutoConfiguration.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@ConditionalOnClass(WebFluxConfigurer.class)
@EnableConfigurationProperties({ ServerProperties.class, WebProperties.class })
public class ErrorWebFluxAutoConfiguration {
	private final ServerProperties serverProperties;
	public ErrorWebFluxAutoConfiguration(ServerProperties serverProperties) {
		this.serverProperties = serverProperties;
	}
	@Bean
	@ConditionalOnMissingBean(value = ErrorWebExceptionHandler.class, search = SearchStrategy.CURRENT)
	@Order(-1)
	public ErrorWebExceptionHandler errorWebExceptionHandler(ErrorAttributes errorAttributes,
			WebProperties webProperties, ObjectProvider<ViewResolver> viewResolvers,
			ServerCodecConfigurer serverCodecConfigurer, ApplicationContext applicationContext) {
		DefaultErrorWebExceptionHandler exceptionHandler = new DefaultErrorWebExceptionHandler(errorAttributes,
				webProperties.getResources(), this.serverProperties.getError(), applicationContext);
		exceptionHandler.setViewResolvers(viewResolvers.orderedStream().toList());
		exceptionHandler.setMessageWriters(serverCodecConfigurer.getWriters());
		exceptionHandler.setMessageReaders(serverCodecConfigurer.getReaders());
		return exceptionHandler;
	}
	@Bean
	@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)
	public DefaultErrorAttributes errorAttributes() {
		return new DefaultErrorAttributes();
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.reactive.error;
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@ControllerAdvice
class ProblemDetailsExceptionHandler extends ResponseEntityExceptionHandler {
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@FunctionalInterface
public interface WebHttpHandlerBuilderCustomizer {
	/**
	 * Callback to customize a {@link WebHttpHandlerBuilder} instance.
	 * @param webHttpHandlerBuilder the {@link WebHttpHandlerBuilder} to customize
	 */
	void customize(WebHttpHandlerBuilder webHttpHandlerBuilder);
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@ConfigurationProperties(prefix = 'spring.webflux')
public class WebFluxProperties {
	/**
	 * Base path for all web handlers.
	 */
	private String basePath;
	private final Format format = new Format();
	private final Problemdetails problemdetails = new Problemdetails();
	/**
	 * Path pattern used for static resources.
	 */
	private String staticPathPattern = '/**';
	/**
	 * Path pattern used for WebJar assets.
	 */
	private String webjarsPathPattern = '/webjars/**';
	public String getBasePath() {
		return this.basePath;
	}
	public void setBasePath(String basePath) {
		this.basePath = cleanBasePath(basePath);
	}
	private String cleanBasePath(String basePath) {
		String candidate = null;
		if (StringUtils.hasLength(basePath)) {
			candidate = basePath.strip();
		}
		if (StringUtils.hasText(candidate)) {
			if (!candidate.startsWith('/')) {
				candidate = '/' + candidate;
			}
			if (candidate.endsWith('/')) {
				candidate = candidate.substring(0, candidate.length() - 1);
			}
		}
		return candidate;
	}
	public Format getFormat() {
		return this.format;
	}
	public Problemdetails getProblemdetails() {
		return this.problemdetails;
	}
	public String getStaticPathPattern() {
		return this.staticPathPattern;
	}
	public void setStaticPathPattern(String staticPathPattern) {
		this.staticPathPattern = staticPathPattern;
	}
	public String getWebjarsPathPattern() {
		return this.webjarsPathPattern;
	}
	public void setWebjarsPathPattern(String webjarsPathPattern) {
		this.webjarsPathPattern = webjarsPathPattern;
	}
	public static class Format {
		/**
		 * Date format to use, for example "dd/MM/yyyy". Used for formatting of
		 * java.util.Date and java.time.LocalDate.
		 */
		private String date;
		/**
		 * Time format to use, for example "HH:mm:ss". Used for formatting of java.time"s
		 * LocalTime and OffsetTime.
		 */
		private String time;
		/**
		 * Date-time format to use, for example "yyyy-MM-dd HH:mm:ss". Used for formatting
		 * of java.time"s LocalDateTime, OffsetDateTime, and ZonedDateTime.
		 */
		private String dateTime;
		public String getDate() {
			return this.date;
		}
		public void setDate(String date) {
			this.date = date;
		}
		public String getTime() {
			return this.time;
		}
		public void setTime(String time) {
			this.time = time;
		}
		public String getDateTime() {
			return this.dateTime;
		}
		public void setDateTime(String dateTime) {
			this.dateTime = dateTime;
		}
	}
	public static class Problemdetails {
		/**
		 * Whether RFC 9457 Problem Details support should be enabled.
		 */
		private boolean enabled = false;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
abstract class ReactiveWebServerFactoryConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ReactiveWebServerFactory.class)
	@ConditionalOnClass({ HttpServer.class })
	@Import(ReactorNettyConfigurations.ReactorResourceFactoryConfiguration.class)
	static class EmbeddedNetty {
		@Bean
		NettyReactiveWebServerFactory nettyReactiveWebServerFactory(ReactorResourceFactory resourceFactory,
				ObjectProvider<NettyRouteProvider> routes, ObjectProvider<NettyServerCustomizer> serverCustomizers) {
			NettyReactiveWebServerFactory serverFactory = new NettyReactiveWebServerFactory();
			serverFactory.setResourceFactory(resourceFactory);
			routes.orderedStream().forEach(serverFactory::addRouteProviders);
			serverFactory.getServerCustomizers().addAll(serverCustomizers.orderedStream().toList());
			return serverFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ReactiveWebServerFactory.class)
	@ConditionalOnClass({ org.apache.catalina.startup.Tomcat.class })
	static class EmbeddedTomcat {
		@Bean
		TomcatReactiveWebServerFactory tomcatReactiveWebServerFactory(
				ObjectProvider<TomcatConnectorCustomizer> connectorCustomizers,
				ObjectProvider<TomcatContextCustomizer> contextCustomizers,
				ObjectProvider<TomcatProtocolHandlerCustomizer<?>> protocolHandlerCustomizers) {
			TomcatReactiveWebServerFactory factory = new TomcatReactiveWebServerFactory();
			factory.getTomcatConnectorCustomizers().addAll(connectorCustomizers.orderedStream().toList());
			factory.getTomcatContextCustomizers().addAll(contextCustomizers.orderedStream().toList());
			factory.getTomcatProtocolHandlerCustomizers().addAll(protocolHandlerCustomizers.orderedStream().toList());
			return factory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ReactiveWebServerFactory.class)
	@ConditionalOnClass({ org.eclipse.jetty.server.Server.class, ServletHolder.class })
	static class EmbeddedJetty {
		@Bean
		JettyReactiveWebServerFactory jettyReactiveWebServerFactory(
				ObjectProvider<JettyServerCustomizer> serverCustomizers) {
			JettyReactiveWebServerFactory serverFactory = new JettyReactiveWebServerFactory();
			serverFactory.getServerCustomizers().addAll(serverCustomizers.orderedStream().toList());
			return serverFactory;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ReactiveWebServerFactory.class)
	@ConditionalOnClass({ Undertow.class })
	static class EmbeddedUndertow {
		@Bean
		UndertowReactiveWebServerFactory undertowReactiveWebServerFactory(
				ObjectProvider<UndertowBuilderCustomizer> builderCustomizers) {
			UndertowReactiveWebServerFactory factory = new UndertowReactiveWebServerFactory();
			factory.getBuilderCustomizers().addAll(builderCustomizers.orderedStream().toList());
			return factory;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@ConfigurationProperties(prefix = 'spring.webflux.multipart')
public class ReactiveMultipartProperties {
	/**
	 * Maximum amount of memory allowed per part before it"s written to disk. Set to -1 to
	 * store all contents in memory.
	 */
	private DataSize maxInMemorySize = DataSize.ofKilobytes(256);
	/**
	 * Maximum amount of memory allowed per headers section of each part. Set to -1 to
	 * enforce no limits.
	 */
	private DataSize maxHeadersSize = DataSize.ofKilobytes(10);
	/**
	 * Maximum amount of disk space allowed per part. Default is -1 which enforces no
	 * limits.
	 */
	private DataSize maxDiskUsagePerPart = DataSize.ofBytes(-1);
	/**
	 * Maximum number of parts allowed in a given multipart request. Default is -1 which
	 * enforces no limits.
	 */
	private Integer maxParts = -1;
	/**
	 * Directory used to store file parts larger than "maxInMemorySize". Default is a
	 * directory named "spring-multipart" created under the system temporary directory.
	 * Ignored when using the PartEvent streaming support.
	 */
	private String fileStorageDirectory;
	/**
	 * Character set used to decode headers.
	 */
	private Charset headersCharset = StandardCharsets.UTF_8;
	public DataSize getMaxInMemorySize() {
		return this.maxInMemorySize;
	}
	public void setMaxInMemorySize(DataSize maxInMemorySize) {
		this.maxInMemorySize = maxInMemorySize;
	}
	public DataSize getMaxHeadersSize() {
		return this.maxHeadersSize;
	}
	public void setMaxHeadersSize(DataSize maxHeadersSize) {
		this.maxHeadersSize = maxHeadersSize;
	}
	public DataSize getMaxDiskUsagePerPart() {
		return this.maxDiskUsagePerPart;
	}
	public void setMaxDiskUsagePerPart(DataSize maxDiskUsagePerPart) {
		this.maxDiskUsagePerPart = maxDiskUsagePerPart;
	}
	public Integer getMaxParts() {
		return this.maxParts;
	}
	public void setMaxParts(Integer maxParts) {
		this.maxParts = maxParts;
	}
	public String getFileStorageDirectory() {
		return this.fileStorageDirectory;
	}
	public void setFileStorageDirectory(String fileStorageDirectory) {
		this.fileStorageDirectory = fileStorageDirectory;
	}
	public Charset getHeadersCharset() {
		return this.headersCharset;
	}
	public void setHeadersCharset(Charset headersCharset) {
		this.headersCharset = headersCharset;
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
public interface WebFluxRegistrations {
	/**
	 * Return the custom {@link RequestMappingHandlerMapping} that should be used and
	 * processed by the WebFlux configuration.
	 * @return the custom {@link RequestMappingHandlerMapping} instance
	 */
	default RequestMappingHandlerMapping getRequestMappingHandlerMapping() {
		return null;
	}
	/**
	 * Return the custom {@link RequestMappingHandlerAdapter} that should be used and
	 * processed by the WebFlux configuration.
	 * @return the custom {@link RequestMappingHandlerAdapter} instance
	 */
	default RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {
		return null;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.reactive;
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@AutoConfiguration
@ConditionalOnWebApplication(type = Type.REACTIVE)
@ConditionalOnClass({ WebSessionManager.class, Mono.class })
@EnableConfigurationProperties({ WebFluxProperties.class, ServerProperties.class })
public class WebSessionIdResolverAutoConfiguration {
	private final ServerProperties serverProperties;
	public WebSessionIdResolverAutoConfiguration(ServerProperties serverProperties,
			WebFluxProperties webFluxProperties) {
		this.serverProperties = serverProperties;
	}
	@Bean
	@ConditionalOnMissingBean
	public WebSessionIdResolver webSessionIdResolver() {
		CookieWebSessionIdResolver resolver = new CookieWebSessionIdResolver();
		String cookieName = this.serverProperties.getReactive().getSession().getCookie().getName();
		if (StringUtils.hasText(cookieName)) {
			resolver.setCookieName(cookieName);
		}
		resolver.addCookieInitializer(this::initializeCookie);
		return resolver;
	}
	private void initializeCookie(ResponseCookieBuilder builder) {
		Cookie cookie = this.serverProperties.getReactive().getSession().getCookie();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(cookie::getDomain).to(builder::domain);
		map.from(cookie::getPath).to(builder::path);
		map.from(cookie::getHttpOnly).to(builder::httpOnly);
		map.from(cookie::getSecure).to(builder::secure);
		map.from(cookie::getMaxAge).to(builder::maxAge);
		map.from(cookie::getPartitioned).to(builder::partitioned);
		map.from(getSameSite(cookie)).to(builder::sameSite);
	}
	private String getSameSite(Cookie properties) {
		SameSite sameSite = properties.getSameSite();
		return (sameSite != null) ? sameSite.attributeValue() : null;
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
public interface WebClientSsl {
	/**
	 * Return a {@link Consumer} that will apply SSL configuration for the named
	 * {@link SslBundle} to a
	 * {@link org.springframework.web.reactive.function.client.WebClient.Builder
	 * WebClient.Builder}.
	 * @param bundleName the name of the SSL bundle to apply
	 * @return a {@link Consumer} to apply the configuration
	 * @throws NoSuchSslBundleException if a bundle with the provided name does not exist
	 */
	Consumer<WebClient.Builder> fromBundle(String bundleName) throws NoSuchSslBundleException;
	/**
	 * Return a {@link Consumer} that will apply SSL configuration for the
	 * {@link SslBundle} to a
	 * {@link org.springframework.web.reactive.function.client.WebClient.Builder
	 * WebClient.Builder}.
	 * @param bundle the SSL bundle to apply
	 * @return a {@link Consumer} to apply the configuration
	 */
	Consumer<WebClient.Builder> fromBundle(SslBundle bundle);
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class JdkClientHttpConnectorFactory implements ClientHttpConnectorFactory<JdkClientHttpConnector> {
	@Override
	public JdkClientHttpConnector createClientHttpConnector(SslBundle sslBundle) {
		Builder builder = HttpClient.newBuilder();
		if (sslBundle != null) {
			SslOptions options = sslBundle.getOptions();
			builder.sslContext(sslBundle.createSslContext());
			SSLParameters parameters = new SSLParameters();
			parameters.setCipherSuites(options.getCiphers());
			parameters.setProtocols(options.getEnabledProtocols());
			builder.sslParameters(parameters);
		}
		return new JdkClientHttpConnector(builder.build());
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class ClientHttpConnectorFactoryConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(reactor.netty.http.client.HttpClient.class)
	@ConditionalOnMissingBean(ClientHttpConnectorFactory.class)
	@Import(ReactorNettyConfigurations.ReactorResourceFactoryConfiguration.class)
	static class ReactorNetty {
		@Bean
		ReactorClientHttpConnectorFactory reactorClientHttpConnectorFactory(
				ReactorResourceFactory reactorResourceFactory,
				ObjectProvider<ReactorNettyHttpClientMapper> mapperProvider) {
			return new ReactorClientHttpConnectorFactory(reactorResourceFactory, mapperProvider::orderedStream);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ HttpAsyncClients.class, AsyncRequestProducer.class, ReactiveResponseConsumer.class })
	@ConditionalOnMissingBean(ClientHttpConnectorFactory.class)
	static class HttpClient5 {
		@Bean
		HttpComponentsClientHttpConnectorFactory httpComponentsClientHttpConnectorFactory() {
			return new HttpComponentsClientHttpConnectorFactory();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(java.net.http.HttpClient.class)
	@ConditionalOnMissingBean(ClientHttpConnectorFactory.class)
	static class JdkClient {
		@Bean
		JdkClientHttpConnectorFactory jdkClientHttpConnectorFactory() {
			return new JdkClientHttpConnectorFactory();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class AutoConfiguredWebClientSsl implements WebClientSsl {
	private final ClientHttpConnectorFactory<?> clientHttpConnectorFactory;
	private final SslBundles sslBundles;
	AutoConfiguredWebClientSsl(ClientHttpConnectorFactory<?> clientHttpConnectorFactory, SslBundles sslBundles) {
		this.clientHttpConnectorFactory = clientHttpConnectorFactory;
		this.sslBundles = sslBundles;
	}
	@Override
	public Consumer<WebClient.Builder> fromBundle(String bundleName) {
		return fromBundle(this.sslBundles.getBundle(bundleName));
	}
	@Override
	public Consumer<WebClient.Builder> fromBundle(SslBundle bundle) {
		return (builder) -> {
			ClientHttpConnector connector = this.clientHttpConnectorFactory.createClientHttpConnector(bundle);
			builder.clientConnector(connector);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class HttpComponentsClientHttpConnectorFactory
		implements ClientHttpConnectorFactory<HttpComponentsClientHttpConnector> {
	@Override
	public HttpComponentsClientHttpConnector createClientHttpConnector(SslBundle sslBundle) {
		HttpAsyncClientBuilder builder = HttpAsyncClients.custom().useSystemProperties();
		if (sslBundle != null) {
			SslOptions options = sslBundle.getOptions();
			SSLContext sslContext = sslBundle.createSslContext();
			SSLSessionVerifier sessionVerifier = (endpoint, sslEngine) -> {
				if (options.getCiphers() != null) {
					sslEngine.setEnabledCipherSuites(options.getCiphers());
				}
				if (options.getEnabledProtocols() != null) {
					sslEngine.setEnabledProtocols(options.getEnabledProtocols());
				}
				return null;
			};
			BasicClientTlsStrategy tlsStrategy = new BasicClientTlsStrategy(sslContext, sessionVerifier);
			AsyncClientConnectionManager connectionManager = PoolingAsyncClientConnectionManagerBuilder.create()
				.setTlsStrategy(tlsStrategy)
				.build();
			builder.setConnectionManager(connectionManager);
		}
		return new HttpComponentsClientHttpConnector(builder.build());
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
class ReactorClientHttpConnectorFactory implements ClientHttpConnectorFactory<ReactorClientHttpConnector> {
	private final ReactorResourceFactory reactorResourceFactory;
	private final Supplier<Stream<ReactorNettyHttpClientMapper>> mappers;
	ReactorClientHttpConnectorFactory(ReactorResourceFactory reactorResourceFactory) {
		this(reactorResourceFactory, Stream::empty);
	}
	ReactorClientHttpConnectorFactory(ReactorResourceFactory reactorResourceFactory,
			Supplier<Stream<ReactorNettyHttpClientMapper>> mappers) {
		this.reactorResourceFactory = reactorResourceFactory;
		this.mappers = mappers;
	}
	@Override
	public ReactorClientHttpConnector createClientHttpConnector(SslBundle sslBundle) {
		List<ReactorNettyHttpClientMapper> mappers = this.mappers.get()
			.collect(Collectors.toCollection(ArrayList::new));
		if (sslBundle != null) {
			mappers.add(new SslConfigurer(sslBundle));
		}
		return new ReactorClientHttpConnector(this.reactorResourceFactory,
				ReactorNettyHttpClientMapper.of(mappers)::configure);
	}
	/**
	 * Configures the Netty {@link HttpClient} with SSL.
	 */
	private static class SslConfigurer implements ReactorNettyHttpClientMapper {
		private final SslBundle sslBundle;
		SslConfigurer(SslBundle sslBundle) {
			this.sslBundle = sslBundle;
		}
		@Override
		public HttpClient configure(HttpClient httpClient) {
			return httpClient.secure(ThrowingConsumer.of(this::customizeSsl).throwing(IllegalStateException::new));
		}
		private void customizeSsl(SslContextSpec spec) throws SSLException {
			SslOptions options = this.sslBundle.getOptions();
			SslManagerBundle managers = this.sslBundle.getManagers();
			SslContextBuilder builder = SslContextBuilder.forClient()
				.keyManager(managers.getKeyManagerFactory())
				.trustManager(managers.getTrustManagerFactory())
				.ciphers(SslOptions.asSet(options.getCiphers()))
				.protocols(options.getEnabledProtocols());
			spec.sslContext(builder.build());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
@AutoConfiguration(after = { CodecsAutoConfiguration.class, ClientHttpConnectorAutoConfiguration.class })
@ConditionalOnClass(WebClient.class)
public class WebClientAutoConfiguration {
	@Bean
	@Scope('prototype')
	@ConditionalOnMissingBean
	public WebClient.Builder webClientBuilder(ObjectProvider<WebClientCustomizer> customizerProvider) {
		WebClient.Builder builder = WebClient.builder();
		customizerProvider.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder;
	}
	@Bean
	@ConditionalOnMissingBean(WebClientSsl.class)
	@ConditionalOnBean(SslBundles.class)
	AutoConfiguredWebClientSsl webClientSsl(ClientHttpConnectorFactory<?> clientHttpConnectorFactory,
			SslBundles sslBundles) {
		return new AutoConfiguredWebClientSsl(clientHttpConnectorFactory, sslBundles);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(CodecCustomizer.class)
	protected static class WebClientCodecsConfiguration {
		@Bean
		@ConditionalOnMissingBean
		@Order(0)
		public WebClientCodecCustomizer exchangeStrategiesCustomizer(ObjectProvider<CodecCustomizer> codecCustomizers) {
			return new WebClientCodecCustomizer(codecCustomizers.orderedStream().toList());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
@FunctionalInterface
interface ClientHttpConnectorFactory<T extends ClientHttpConnector> {
	default T createClientHttpConnector() {
		return createClientHttpConnector(null);
	}
	T createClientHttpConnector(SslBundle sslBundle);
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
public class WebClientCodecCustomizer implements WebClientCustomizer {
	private final List<CodecCustomizer> codecCustomizers;
	public WebClientCodecCustomizer(List<CodecCustomizer> codecCustomizers) {
		this.codecCustomizers = codecCustomizers;
	}
	@Override
	public void customize(WebClient.Builder webClientBuilder) {
		webClientBuilder
			.codecs((codecs) -> this.codecCustomizers.forEach((customizer) -> customizer.customize(codecs)));
	}
}
/*
/**
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
@AutoConfiguration
@ConditionalOnClass(WebClient.class)
@AutoConfigureAfter(SslAutoConfiguration.class)
@Import({ ClientHttpConnectorFactoryConfiguration.ReactorNetty.class,
		ClientHttpConnectorFactoryConfiguration.HttpClient5.class,
		ClientHttpConnectorFactoryConfiguration.JdkClient.class })
public class ClientHttpConnectorAutoConfiguration {
	@Bean
	@Lazy
	@ConditionalOnMissingBean(ClientHttpConnector.class)
	ClientHttpConnector webClientHttpConnector(ClientHttpConnectorFactory<?> clientHttpConnectorFactory) {
		return clientHttpConnectorFactory.createClientHttpConnector();
	}
	@Bean
	@Lazy
	@Order(0)
	@ConditionalOnBean(ClientHttpConnector.class)
	public WebClientCustomizer webClientHttpConnectorCustomizer(ClientHttpConnector clientHttpConnector) {
		return (builder) -> builder.clientConnector(clientHttpConnector);
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive.function.client;
/**
@FunctionalInterface
public interface ReactorNettyHttpClientMapper {
	/**
	 * Configure the given {@link HttpClient} and return the newly created instance.
	 * @param httpClient the client to configure
	 * @return the new client instance
	 */
	HttpClient configure(HttpClient httpClient);
	/**
	 * Return a new {@link ReactorNettyHttpClientMapper} composed of the given mappers.
	 * @param mappers the mappers to compose
	 * @return a composed {@link ReactorNettyHttpClientMapper} instance
	 * @since 3.1.1
	 */
	static ReactorNettyHttpClientMapper of(Collection<ReactorNettyHttpClientMapper> mappers) {
		Assert.notNull(mappers, 'Mappers must not be null');
		return of(mappers.toArray(ReactorNettyHttpClientMapper[]::new));
	}
	/**
	 * Return a new {@link ReactorNettyHttpClientMapper} composed of the given mappers.
	 * @param mappers the mappers to compose
	 * @return a composed {@link ReactorNettyHttpClientMapper} instance
	 * @since 3.1.1
	 */
	static ReactorNettyHttpClientMapper of(ReactorNettyHttpClientMapper... mappers) {
		Assert.notNull(mappers, 'Mappers must not be null');
		return (httpClient) -> {
			for (ReactorNettyHttpClientMapper mapper : mappers) {
				httpClient = mapper.configure(httpClient);
			}
			return httpClient;
		};
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@FunctionalInterface
public interface ResourceHandlerRegistrationCustomizer {
	/**
	 * Customize the given {@link ResourceHandlerRegistration}.
	 * @param registration the registration to customize
	 */
	void customize(ResourceHandlerRegistration registration);
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
@AutoConfiguration(after = { ReactiveWebServerFactoryAutoConfiguration.class, CodecsAutoConfiguration.class,
		ReactiveMultipartAutoConfiguration.class, ValidationAutoConfiguration.class,
		WebSessionIdResolverAutoConfiguration.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@ConditionalOnClass(WebFluxConfigurer.class)
@ConditionalOnMissingBean({ WebFluxConfigurationSupport.class })
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@ImportRuntimeHints(WebResourcesRuntimeHints.class)
public class WebFluxAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(HiddenHttpMethodFilter.class)
	@ConditionalOnProperty(prefix = 'spring.webflux.hiddenmethod.filter', name = 'enabled')
	public OrderedHiddenHttpMethodFilter hiddenHttpMethodFilter() {
		return new OrderedHiddenHttpMethodFilter();
	}
	@Configuration(proxyBeanMethods = false)
	public static class WelcomePageConfiguration {
		@Bean
		public RouterFunctionMapping welcomePageRouterFunctionMapping(ApplicationContext applicationContext,
				WebFluxProperties webFluxProperties, WebProperties webProperties) {
			String[] staticLocations = webProperties.getResources().getStaticLocations();
			WelcomePageRouterFunctionFactory factory = new WelcomePageRouterFunctionFactory(
					new TemplateAvailabilityProviders(applicationContext), applicationContext, staticLocations,
					webFluxProperties.getStaticPathPattern());
			RouterFunction<ServerResponse> routerFunction = factory.createRouterFunction();
			if (routerFunction != null) {
				RouterFunctionMapping routerFunctionMapping = new RouterFunctionMapping(routerFunction);
				routerFunctionMapping.setOrder(1);
				return routerFunctionMapping;
			}
			return null;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties({ WebProperties.class, WebFluxProperties.class })
	@Import({ EnableWebFluxConfiguration.class })
	@Order(0)
	public static class WebFluxConfig implements WebFluxConfigurer {
		private static final Log logger = LogFactory.getLog(WebFluxConfig.class);
		private final Environment environment;
		private final Resources resourceProperties;
		private final WebFluxProperties webFluxProperties;
		private final ListableBeanFactory beanFactory;
		private final ObjectProvider<HandlerMethodArgumentResolver> argumentResolvers;
		private final ObjectProvider<CodecCustomizer> codecCustomizers;
		private final ResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer;
		private final ObjectProvider<ViewResolver> viewResolvers;
		public WebFluxConfig(Environment environment, WebProperties webProperties, WebFluxProperties webFluxProperties,
				ListableBeanFactory beanFactory, ObjectProvider<HandlerMethodArgumentResolver> resolvers,
				ObjectProvider<CodecCustomizer> codecCustomizers,
				ObjectProvider<ResourceHandlerRegistrationCustomizer> resourceHandlerRegistrationCustomizer,
				ObjectProvider<ViewResolver> viewResolvers) {
			this.environment = environment;
			this.resourceProperties = webProperties.getResources();
			this.webFluxProperties = webFluxProperties;
			this.beanFactory = beanFactory;
			this.argumentResolvers = resolvers;
			this.codecCustomizers = codecCustomizers;
			this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizer.getIfAvailable();
			this.viewResolvers = viewResolvers;
		}
		@Override
		public void configureArgumentResolvers(ArgumentResolverConfigurer configurer) {
			this.argumentResolvers.orderedStream().forEach(configurer::addCustomResolver);
		}
		@Override
		public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) {
			this.codecCustomizers.orderedStream().forEach((customizer) -> customizer.customize(configurer));
		}
		@Override
		public void configureBlockingExecution(BlockingExecutionConfigurer configurer) {
			if (Threading.VIRTUAL.isActive(this.environment) && this.beanFactory
				.containsBean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)) {
				Object taskExecutor = this.beanFactory
					.getBean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME);
				if (taskExecutor instanceof AsyncTaskExecutor asyncTaskExecutor) {
					configurer.setExecutor(asyncTaskExecutor);
				}
			}
		}
		@Override
		public void addResourceHandlers(ResourceHandlerRegistry registry) {
			if (!this.resourceProperties.isAddMappings()) {
				logger.debug('Default resource handling disabled');
				return;
			}
			String webjarsPathPattern = this.webFluxProperties.getWebjarsPathPattern();
			if (!registry.hasMappingForPattern(webjarsPathPattern)) {
				ResourceHandlerRegistration registration = registry.addResourceHandler(webjarsPathPattern)
					.addResourceLocations('classpath:/META-INF/resources/webjars/');
				configureResourceCaching(registration);
				customizeResourceHandlerRegistration(registration);
			}
			String staticPathPattern = this.webFluxProperties.getStaticPathPattern();
			if (!registry.hasMappingForPattern(staticPathPattern)) {
				ResourceHandlerRegistration registration = registry.addResourceHandler(staticPathPattern)
					.addResourceLocations(this.resourceProperties.getStaticLocations());
				configureResourceCaching(registration);
				customizeResourceHandlerRegistration(registration);
			}
		}
		private void configureResourceCaching(ResourceHandlerRegistration registration) {
			Duration cachePeriod = this.resourceProperties.getCache().getPeriod();
			WebProperties.Resources.Cache.Cachecontrol cacheControl = this.resourceProperties.getCache()
				.getCachecontrol();
			if (cachePeriod != null && cacheControl.getMaxAge() == null) {
				cacheControl.setMaxAge(cachePeriod);
			}
			registration.setCacheControl(cacheControl.toHttpCacheControl());
			registration.setUseLastModified(this.resourceProperties.getCache().isUseLastModified());
		}
		@Override
		public void configureViewResolvers(ViewResolverRegistry registry) {
			this.viewResolvers.orderedStream().forEach(registry::viewResolver);
		}
		@Override
		public void addFormatters(FormatterRegistry registry) {
			ApplicationConversionService.addBeans(registry, this.beanFactory);
		}
		private void customizeResourceHandlerRegistration(ResourceHandlerRegistration registration) {
			if (this.resourceHandlerRegistrationCustomizer != null) {
				this.resourceHandlerRegistrationCustomizer.customize(registration);
			}
		}
	}
	/**
	 * Configuration equivalent to {@code @EnableWebFlux}.
	 */
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties({ WebProperties.class, ServerProperties.class })
	public static class EnableWebFluxConfiguration extends DelegatingWebFluxConfiguration {
		private final WebFluxProperties webFluxProperties;
		private final WebProperties webProperties;
		private final ServerProperties serverProperties;
		private final WebFluxRegistrations webFluxRegistrations;
		public EnableWebFluxConfiguration(WebFluxProperties webFluxProperties, WebProperties webProperties,
				ServerProperties serverProperties, ObjectProvider<WebFluxRegistrations> webFluxRegistrations) {
			this.webFluxProperties = webFluxProperties;
			this.webProperties = webProperties;
			this.serverProperties = serverProperties;
			this.webFluxRegistrations = webFluxRegistrations.getIfUnique();
		}
		@Bean
		@Override
		public FormattingConversionService webFluxConversionService() {
			Format format = this.webFluxProperties.getFormat();
			WebConversionService conversionService = new WebConversionService(
					new DateTimeFormatters().dateFormat(format.getDate())
						.timeFormat(format.getTime())
						.dateTimeFormat(format.getDateTime()));
			addFormatters(conversionService);
			return conversionService;
		}
		@Bean
		@Override
		public Validator webFluxValidator() {
			if (!ClassUtils.isPresent('jakarta.validation.Validator', getClass().getClassLoader())) {
				return super.webFluxValidator();
			}
			return ValidatorAdapter.get(getApplicationContext(), getValidator());
		}
		@Override
		protected RequestMappingHandlerAdapter createRequestMappingHandlerAdapter() {
			if (this.webFluxRegistrations != null) {
				RequestMappingHandlerAdapter adapter = this.webFluxRegistrations.getRequestMappingHandlerAdapter();
				if (adapter != null) {
					return adapter;
				}
			}
			return super.createRequestMappingHandlerAdapter();
		}
		@Override
		protected RequestMappingHandlerMapping createRequestMappingHandlerMapping() {
			if (this.webFluxRegistrations != null) {
				RequestMappingHandlerMapping mapping = this.webFluxRegistrations.getRequestMappingHandlerMapping();
				if (mapping != null) {
					return mapping;
				}
			}
			return super.createRequestMappingHandlerMapping();
		}
		@Bean
		@Override
		@ConditionalOnMissingBean(name = WebHttpHandlerBuilder.LOCALE_CONTEXT_RESOLVER_BEAN_NAME)
		public LocaleContextResolver localeContextResolver() {
			if (this.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) {
				return new FixedLocaleContextResolver(this.webProperties.getLocale());
			}
			AcceptHeaderLocaleContextResolver localeContextResolver = new AcceptHeaderLocaleContextResolver();
			localeContextResolver.setDefaultLocale(this.webProperties.getLocale());
			return localeContextResolver;
		}
		@Bean
		@ConditionalOnMissingBean(name = WebHttpHandlerBuilder.WEB_SESSION_MANAGER_BEAN_NAME)
		public WebSessionManager webSessionManager(ObjectProvider<WebSessionIdResolver> webSessionIdResolver) {
			DefaultWebSessionManager webSessionManager = new DefaultWebSessionManager();
			Duration timeout = this.serverProperties.getReactive().getSession().getTimeout();
			int maxSessions = this.serverProperties.getReactive().getSession().getMaxSessions();
			MaxIdleTimeInMemoryWebSessionStore sessionStore = new MaxIdleTimeInMemoryWebSessionStore(timeout);
			sessionStore.setMaxSessions(maxSessions);
			webSessionManager.setSessionStore(sessionStore);
			webSessionIdResolver.ifAvailable(webSessionManager::setSessionIdResolver);
			return webSessionManager;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnEnabledResourceChain
	static class ResourceChainCustomizerConfiguration {
		@Bean
		ResourceChainResourceHandlerRegistrationCustomizer resourceHandlerRegistrationCustomizer(
				WebProperties webProperties) {
			return new ResourceChainResourceHandlerRegistrationCustomizer(webProperties.getResources());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.webflux.problemdetails', name = 'enabled', havingValue = 'true')
	static class ProblemDetailsErrorHandlingConfiguration {
		@Bean
		@ConditionalOnMissingBean(ResponseEntityExceptionHandler.class)
		@Order(0)
		ProblemDetailsExceptionHandler problemDetailsExceptionHandler() {
			return new ProblemDetailsExceptionHandler();
		}
	}
	static final class MaxIdleTimeInMemoryWebSessionStore extends InMemoryWebSessionStore {
		private final Duration timeout;
		private MaxIdleTimeInMemoryWebSessionStore(Duration timeout) {
			this.timeout = timeout;
		}
		@Override
		public Mono<WebSession> createWebSession() {
			return super.createWebSession().doOnSuccess(this::setMaxIdleTime);
		}
		private void setMaxIdleTime(WebSession session) {
			session.setMaxIdleTime(this.timeout);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.web.reactive;
/**
public class ReactiveWebServerFactoryCustomizer
		implements WebServerFactoryCustomizer<ConfigurableReactiveWebServerFactory>, Ordered {
	private final ServerProperties serverProperties;
	private final SslBundles sslBundles;
	/**
	 * Create a new {@link ReactiveWebServerFactoryCustomizer} instance.
	 * @param serverProperties the server properties
	 */
	public ReactiveWebServerFactoryCustomizer(ServerProperties serverProperties) {
		this(serverProperties, null);
	}
	/**
	 * Create a new {@link ReactiveWebServerFactoryCustomizer} instance.
	 * @param serverProperties the server properties
	 * @param sslBundles the SSL bundles
	 * @since 3.1.0
	 */
	public ReactiveWebServerFactoryCustomizer(ServerProperties serverProperties, SslBundles sslBundles) {
		this.serverProperties = serverProperties;
		this.sslBundles = sslBundles;
	}
	@Override
	public int getOrder() {
		return 0;
	}
	@Override
	public void customize(ConfigurableReactiveWebServerFactory factory) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.serverProperties::getPort).to(factory::setPort);
		map.from(this.serverProperties::getAddress).to(factory::setAddress);
		map.from(this.serverProperties::getSsl).to(factory::setSsl);
		map.from(this.serverProperties::getCompression).to(factory::setCompression);
		map.from(this.serverProperties::getHttp2).to(factory::setHttp2);
		map.from(this.serverProperties.getShutdown()).to(factory::setShutdown);
		map.from(() -> this.sslBundles).to(factory::setSslBundles);
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public class BackgroundPreinitializer implements ApplicationListener<SpringApplicationEvent>, Ordered {
	/**
	 * System property that instructs Spring Boot how to run pre initialization. When the
	 * property is set to {@code true}, no pre-initialization happens and each item is
	 * initialized in the foreground as it needs to. When the property is {@code false}
	 * (default), pre initialization runs in a separate thread in the background.
	 * @since 2.1.0
	 */
	public static final String IGNORE_BACKGROUNDPREINITIALIZER_PROPERTY_NAME = 'spring.backgroundpreinitializer.ignore';
	private static final AtomicBoolean preinitializationStarted = new AtomicBoolean();
	private static final CountDownLatch preinitializationComplete = new CountDownLatch(1);
	private static final boolean ENABLED = !Boolean.getBoolean(IGNORE_BACKGROUNDPREINITIALIZER_PROPERTY_NAME)
			&& Runtime.getRuntime().availableProcessors() > 1;
	@Override
	public int getOrder() {
		return LoggingApplicationListener.DEFAULT_ORDER + 1;
	}
	@Override
	public void onApplicationEvent(SpringApplicationEvent event) {
		if (!ENABLED || NativeDetector.inNativeImage()) {
			return;
		}
		if (event instanceof ApplicationEnvironmentPreparedEvent
				&& preinitializationStarted.compareAndSet(false, true)) {
			performPreinitialization();
		}
		if ((event instanceof ApplicationReadyEvent || event instanceof ApplicationFailedEvent)
				&& preinitializationStarted.get()) {
			try {
				preinitializationComplete.await();
			}
			catch (InterruptedException ex) {
				Thread.currentThread().interrupt();
			}
		}
	}
	private void performPreinitialization() {
		try {
			Thread thread = new Thread(new Runnable() {
				@Override
				public void run() {
					runSafely(new ConversionServiceInitializer());
					runSafely(new ValidationInitializer());
					if (!runSafely(new MessageConverterInitializer())) {
						// If the MessageConverterInitializer fails to run, we still might
						// be able to
						// initialize Jackson
						runSafely(new JacksonInitializer());
					}
					runSafely(new CharsetInitializer());
					runSafely(new TomcatInitializer());
					runSafely(new JdkInitializer());
					preinitializationComplete.countDown();
				}
				boolean runSafely(Runnable runnable) {
					try {
						runnable.run();
						return true;
					}
					catch (Throwable ex) {
						return false;
					}
				}
			}, 'background-preinit');
			thread.start();
		}
		catch (Exception ex) {
			// This will fail on GAE where creating threads is prohibited. We can safely
			// continue but startup will be slightly slower as the initialization will now
			// happen on the main thread.
			preinitializationComplete.countDown();
		}
	}
	/**
	 * Early initializer for Spring MessageConverters.
	 */
	private static final class MessageConverterInitializer implements Runnable {
		@Override
		public void run() {
			new AllEncompassingFormHttpMessageConverter();
		}
	}
	/**
	 * Early initializer for jakarta.validation.
	 */
	private static final class ValidationInitializer implements Runnable {
		@Override
		public void run() {
			Configuration<?> configuration = Validation.byDefaultProvider().configure();
			configuration.buildValidatorFactory().getValidator();
		}
	}
	/**
	 * Early initializer for Jackson.
	 */
	private static final class JacksonInitializer implements Runnable {
		@Override
		public void run() {
			Jackson2ObjectMapperBuilder.json().build();
		}
	}
	/**
	 * Early initializer for Spring"s ConversionService.
	 */
	private static final class ConversionServiceInitializer implements Runnable {
		@Override
		public void run() {
			new DefaultFormattingConversionService();
		}
	}
	private static final class CharsetInitializer implements Runnable {
		@Override
		public void run() {
			StandardCharsets.UTF_8.name();
		}
	}
	private static final class TomcatInitializer implements Runnable {
		@Override
		public void run() {
			new Rfc6265CookieProcessor();
			new NonLoginAuthenticator();
		}
	}
	private static final class JdkInitializer implements Runnable {
		@Override
		public void run() {
			ZoneId.systemDefault();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.integration;
/**
class IntegrationAutoConfigurationScanRegistrar extends IntegrationComponentScanRegistrar implements BeanFactoryAware {
	private BeanFactory beanFactory;
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		this.beanFactory = beanFactory;
	}
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata,
			final BeanDefinitionRegistry registry) {
		super.registerBeanDefinitions(AnnotationMetadata.introspect(IntegrationComponentScanConfiguration.class),
				registry);
	}
	@Override
	protected Collection<String> getBasePackages(AnnotationAttributes componentScan, BeanDefinitionRegistry registry) {
		return (AutoConfigurationPackages.has(this.beanFactory) ? AutoConfigurationPackages.get(this.beanFactory)
				: Collections.emptyList());
	}
	@IntegrationComponentScan
	private static final class IntegrationComponentScanConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.integration;
/**
class IntegrationPropertiesEnvironmentPostProcessor implements EnvironmentPostProcessor, Ordered {
	@Override
	public int getOrder() {
		return Ordered.LOWEST_PRECEDENCE;
	}
	@Override
	public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {
		Resource resource = new ClassPathResource('META-INF/spring.integration.properties');
		if (resource.exists()) {
			registerIntegrationPropertiesPropertySource(environment, resource);
		}
	}
	protected void registerIntegrationPropertiesPropertySource(ConfigurableEnvironment environment, Resource resource) {
		PropertiesPropertySourceLoader loader = new PropertiesPropertySourceLoader();
		try {
			OriginTrackedMapPropertySource propertyFileSource = (OriginTrackedMapPropertySource) loader
				.load('META-INF/spring.integration.properties', resource)
				.get(0);
			environment.getPropertySources().addLast(new IntegrationPropertiesPropertySource(propertyFileSource));
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to load integration properties from ' + resource, ex);
		}
	}
	private static final class IntegrationPropertiesPropertySource extends PropertySource<Map<String, Object>>
			implements OriginLookup<String> {
		private static final String PREFIX = 'spring.integration.';
		private static final Map<String, String> KEYS_MAPPING;
		static {
			Map<String, String> mappings = new HashMap<>();
			mappings.put(PREFIX + 'channel.auto-create', IntegrationProperties.CHANNELS_AUTOCREATE);
			mappings.put(PREFIX + 'channel.max-unicast-subscribers',
					IntegrationProperties.CHANNELS_MAX_UNICAST_SUBSCRIBERS);
			mappings.put(PREFIX + 'channel.max-broadcast-subscribers',
					IntegrationProperties.CHANNELS_MAX_BROADCAST_SUBSCRIBERS);
			mappings.put(PREFIX + 'error.require-subscribers', IntegrationProperties.ERROR_CHANNEL_REQUIRE_SUBSCRIBERS);
			mappings.put(PREFIX + 'error.ignore-failures', IntegrationProperties.ERROR_CHANNEL_IGNORE_FAILURES);
			mappings.put(PREFIX + 'endpoint.default-timeout', IntegrationProperties.ENDPOINTS_DEFAULT_TIMEOUT);
			mappings.put(PREFIX + 'endpoint.throw-exception-on-late-reply',
					IntegrationProperties.THROW_EXCEPTION_ON_LATE_REPLY);
			mappings.put(PREFIX + 'endpoint.read-only-headers', IntegrationProperties.READ_ONLY_HEADERS);
			mappings.put(PREFIX + 'endpoint.no-auto-startup', IntegrationProperties.ENDPOINTS_NO_AUTO_STARTUP);
			KEYS_MAPPING = Collections.unmodifiableMap(mappings);
		}
		private final OriginTrackedMapPropertySource delegate;
		IntegrationPropertiesPropertySource(OriginTrackedMapPropertySource delegate) {
			super('META-INF/spring.integration.properties', delegate.getSource());
			this.delegate = delegate;
		}
		@Override
		public Object getProperty(String name) {
			return this.delegate.getProperty(KEYS_MAPPING.get(name));
		}
		@Override
		public Origin getOrigin(String key) {
			return this.delegate.getOrigin(KEYS_MAPPING.get(key));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.integration;
/**
@AutoConfiguration(after = { DataSourceAutoConfiguration.class, JmxAutoConfiguration.class,
		TaskSchedulingAutoConfiguration.class })
@ConditionalOnClass(EnableIntegration.class)
@EnableConfigurationProperties({ IntegrationProperties.class, JmxProperties.class })
public class IntegrationAutoConfiguration {
	@Bean(name = IntegrationContextUtils.INTEGRATION_GLOBAL_PROPERTIES_BEAN_NAME)
	@ConditionalOnMissingBean(name = IntegrationContextUtils.INTEGRATION_GLOBAL_PROPERTIES_BEAN_NAME)
	public static org.springframework.integration.context.IntegrationProperties integrationGlobalProperties(
			IntegrationProperties properties) {
		org.springframework.integration.context.IntegrationProperties integrationProperties = new org.springframework.integration.context.IntegrationProperties();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties.getChannel().isAutoCreate()).to(integrationProperties::setChannelsAutoCreate);
		map.from(properties.getChannel().getMaxUnicastSubscribers())
			.to(integrationProperties::setChannelsMaxUnicastSubscribers);
		map.from(properties.getChannel().getMaxBroadcastSubscribers())
			.to(integrationProperties::setChannelsMaxBroadcastSubscribers);
		map.from(properties.getError().isRequireSubscribers())
			.to(integrationProperties::setErrorChannelRequireSubscribers);
		map.from(properties.getError().isIgnoreFailures()).to(integrationProperties::setErrorChannelIgnoreFailures);
		map.from(properties.getEndpoint().isThrowExceptionOnLateReply())
			.to(integrationProperties::setMessagingTemplateThrowExceptionOnLateReply);
		map.from(properties.getEndpoint().getDefaultTimeout())
			.as(Duration::toMillis)
			.to(integrationProperties::setEndpointsDefaultTimeout);
		map.from(properties.getEndpoint().getReadOnlyHeaders())
			.as(StringUtils::toStringArray)
			.to(integrationProperties::setReadOnlyHeaders);
		map.from(properties.getEndpoint().getNoAutoStartup())
			.as(StringUtils::toStringArray)
			.to(integrationProperties::setNoAutoStartupEndpoints);
		return integrationProperties;
	}
	/**
	 * Basic Spring Integration configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@EnableIntegration
	protected static class IntegrationConfiguration {
		@Bean(PollerMetadata.DEFAULT_POLLER)
		@ConditionalOnMissingBean(name = PollerMetadata.DEFAULT_POLLER)
		public PollerMetadata defaultPollerMetadata(IntegrationProperties integrationProperties) {
			IntegrationProperties.Poller poller = integrationProperties.getPoller();
			MutuallyExclusiveConfigurationPropertiesException.throwIfMultipleNonNullValuesIn((entries) -> {
				entries.put('spring.integration.poller.cron',
						StringUtils.hasText(poller.getCron()) ? poller.getCron() : null);
				entries.put('spring.integration.poller.fixed-delay', poller.getFixedDelay());
				entries.put('spring.integration.poller.fixed-rate', poller.getFixedRate());
			});
			PollerMetadata pollerMetadata = new PollerMetadata();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(poller::getMaxMessagesPerPoll).to(pollerMetadata::setMaxMessagesPerPoll);
			map.from(poller::getReceiveTimeout).as(Duration::toMillis).to(pollerMetadata::setReceiveTimeout);
			map.from(poller).as(this::asTrigger).to(pollerMetadata::setTrigger);
			return pollerMetadata;
		}
		private Trigger asTrigger(IntegrationProperties.Poller poller) {
			if (StringUtils.hasText(poller.getCron())) {
				return new CronTrigger(poller.getCron());
			}
			if (poller.getFixedDelay() != null) {
				return createPeriodicTrigger(poller.getFixedDelay(), poller.getInitialDelay(), false);
			}
			if (poller.getFixedRate() != null) {
				return createPeriodicTrigger(poller.getFixedRate(), poller.getInitialDelay(), true);
			}
			return null;
		}
		private Trigger createPeriodicTrigger(Duration period, Duration initialDelay, boolean fixedRate) {
			PeriodicTrigger trigger = new PeriodicTrigger(period);
			if (initialDelay != null) {
				trigger.setInitialDelay(initialDelay);
			}
			trigger.setFixedRate(fixedRate);
			return trigger;
		}
	}
	/**
	 * Expose a standard {@link org.springframework.scheduling.TaskScheduler
	 * TaskScheduler} if the user has not enabled task scheduling explicitly. A
	 * {@link SimpleAsyncTaskScheduler} is exposed if the user enables virtual threads via
	 * {@code spring.threads.virtual.enabled=true}, otherwise
	 * {@link ThreadPoolTaskScheduler}.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(name = IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)
	protected static class IntegrationTaskSchedulerConfiguration {
		@Bean(name = IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)
		@ConditionalOnBean(ThreadPoolTaskSchedulerBuilder.class)
		@ConditionalOnThreading(Threading.PLATFORM)
		public ThreadPoolTaskScheduler taskScheduler(ThreadPoolTaskSchedulerBuilder threadPoolTaskSchedulerBuilder) {
			return threadPoolTaskSchedulerBuilder.build();
		}
		@Bean(name = IntegrationContextUtils.TASK_SCHEDULER_BEAN_NAME)
		@ConditionalOnBean(SimpleAsyncTaskSchedulerBuilder.class)
		@ConditionalOnThreading(Threading.VIRTUAL)
		public SimpleAsyncTaskScheduler taskSchedulerVirtualThreads(
				SimpleAsyncTaskSchedulerBuilder simpleAsyncTaskSchedulerBuilder) {
			return simpleAsyncTaskSchedulerBuilder.build();
		}
	}
	/**
	 * Spring Integration JMX configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(EnableIntegrationMBeanExport.class)
	@ConditionalOnMissingBean(value = IntegrationMBeanExporter.class, search = SearchStrategy.CURRENT)
	@ConditionalOnBean(MBeanServer.class)
	@ConditionalOnProperty(prefix = 'spring.jmx', name = 'enabled', havingValue = 'true', matchIfMissing = true)
	protected static class IntegrationJmxConfiguration {
		@Bean
		public IntegrationMBeanExporter integrationMbeanExporter(BeanFactory beanFactory, JmxProperties properties) {
			IntegrationMBeanExporter exporter = new IntegrationMBeanExporter();
			String defaultDomain = properties.getDefaultDomain();
			if (StringUtils.hasLength(defaultDomain)) {
				exporter.setDefaultDomain(defaultDomain);
			}
			exporter.setServer(beanFactory.getBean(properties.getServer(), MBeanServer.class));
			return exporter;
		}
	}
	/**
	 * Integration management configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(EnableIntegrationManagement.class)
	@ConditionalOnMissingBean(value = IntegrationManagementConfigurer.class,
			name = IntegrationManagementConfigurer.MANAGEMENT_CONFIGURER_NAME, search = SearchStrategy.CURRENT)
	protected static class IntegrationManagementConfiguration {
		@Configuration(proxyBeanMethods = false)
		@EnableIntegrationManagement(
				defaultLoggingEnabled = '${spring.integration.management.default-logging-enabled:true}',
				observationPatterns = '${spring.integration.management.observation-patterns:}')
		protected static class EnableIntegrationManagementConfiguration {
		}
	}
	/**
	 * Integration component scan configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(IntegrationComponentScanRegistrar.class)
	@Import(IntegrationAutoConfigurationScanRegistrar.class)
	protected static class IntegrationComponentScanConfiguration {
	}
	/**
	 * Integration JDBC configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(JdbcMessageStore.class)
	@ConditionalOnSingleCandidate(DataSource.class)
	@Conditional(OnIntegrationDatasourceInitializationCondition.class)
	protected static class IntegrationJdbcConfiguration {
		@Bean
		@ConditionalOnMissingBean(IntegrationDataSourceScriptDatabaseInitializer.class)
		public IntegrationDataSourceScriptDatabaseInitializer integrationDataSourceInitializer(DataSource dataSource,
				IntegrationProperties properties) {
			return new IntegrationDataSourceScriptDatabaseInitializer(dataSource, properties.getJdbc());
		}
	}
	/**
	 * Integration RSocket configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ IntegrationRSocketEndpoint.class, RSocketRequester.class, io.rsocket.RSocket.class })
	@Conditional(IntegrationRSocketConfiguration.AnyRSocketChannelAdapterAvailable.class)
	protected static class IntegrationRSocketConfiguration {
		/**
		 * Check if either an {@link IntegrationRSocketEndpoint} or
		 * {@link RSocketOutboundGateway} bean is available.
		 */
		static class AnyRSocketChannelAdapterAvailable extends AnyNestedCondition {
			AnyRSocketChannelAdapterAvailable() {
				super(ConfigurationPhase.REGISTER_BEAN);
			}
			@ConditionalOnBean(IntegrationRSocketEndpoint.class)
			static class IntegrationRSocketEndpointAvailable {
			}
			@ConditionalOnBean(RSocketOutboundGateway.class)
			static class RSocketOutboundGatewayAvailable {
			}
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(TcpServerTransport.class)
		@AutoConfigureBefore(RSocketMessagingAutoConfiguration.class)
		protected static class IntegrationRSocketServerConfiguration {
			@Bean
			@ConditionalOnMissingBean(ServerRSocketMessageHandler.class)
			public RSocketMessageHandler serverRSocketMessageHandler(RSocketStrategies rSocketStrategies,
					IntegrationProperties integrationProperties) {
				RSocketMessageHandler messageHandler = new ServerRSocketMessageHandler(
						integrationProperties.getRsocket().getServer().isMessageMappingEnabled());
				messageHandler.setRSocketStrategies(rSocketStrategies);
				return messageHandler;
			}
			@Bean
			@ConditionalOnMissingBean
			public ServerRSocketConnector serverRSocketConnector(ServerRSocketMessageHandler messageHandler) {
				return new ServerRSocketConnector(messageHandler);
			}
		}
		@Configuration(proxyBeanMethods = false)
		protected static class IntegrationRSocketClientConfiguration {
			@Bean
			@ConditionalOnMissingBean
			@Conditional(RemoteRSocketServerAddressConfigured.class)
			public ClientRSocketConnector clientRSocketConnector(IntegrationProperties integrationProperties,
					RSocketStrategies rSocketStrategies) {
				IntegrationProperties.RSocket.Client client = integrationProperties.getRsocket().getClient();
				ClientRSocketConnector clientRSocketConnector = (client.getUri() != null)
						? new ClientRSocketConnector(client.getUri())
						: new ClientRSocketConnector(client.getHost(), client.getPort());
				clientRSocketConnector.setRSocketStrategies(rSocketStrategies);
				return clientRSocketConnector;
			}
			/**
			 * Check if a remote address is configured for the RSocket Integration client.
			 */
			static class RemoteRSocketServerAddressConfigured extends AnyNestedCondition {
				RemoteRSocketServerAddressConfigured() {
					super(ConfigurationPhase.REGISTER_BEAN);
				}
				@ConditionalOnProperty(prefix = 'spring.integration.rsocket.client', name = 'uri')
				static class WebSocketAddressConfigured {
				}
				@ConditionalOnProperty(prefix = 'spring.integration.rsocket.client', name = { 'host', 'port' })
				static class TcpAddressConfigured {
				}
			}
		}
	}
	static class OnIntegrationDatasourceInitializationCondition extends OnDatabaseInitializationCondition {
		OnIntegrationDatasourceInitializationCondition() {
			super('Integration', 'spring.integration.jdbc.initialize-schema');
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.integration;
/*
package org.springframework.boot.autoconfigure.integration;
/**
public class IntegrationDataSourceScriptDatabaseInitializer extends DataSourceScriptDatabaseInitializer {
	/**
	 * Create a new {@link IntegrationDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Spring Integration data source
	 * @param properties the Spring Integration JDBC properties
	 * @see #getSettings
	 */
	public IntegrationDataSourceScriptDatabaseInitializer(DataSource dataSource,
			IntegrationProperties.Jdbc properties) {
		this(dataSource, getSettings(dataSource, properties));
	}
	/**
	 * Create a new {@link IntegrationDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Spring Integration data source
	 * @param settings the database initialization settings
	 * @see #getSettings
	 */
	public IntegrationDataSourceScriptDatabaseInitializer(DataSource dataSource,
			DatabaseInitializationSettings settings) {
		super(dataSource, settings);
	}
	/**
	 * Adapts {@link IntegrationProperties.Jdbc Spring Integration JDBC properties} to
	 * {@link DatabaseInitializationSettings} replacing any {@literal @@platform@@}
	 * placeholders.
	 * @param dataSource the Spring Integration data source
	 * @param properties the Spring Integration JDBC properties
	 * @return a new {@link DatabaseInitializationSettings} instance
	 * @see #IntegrationDataSourceScriptDatabaseInitializer(DataSource,
	 * DatabaseInitializationSettings)
	 */
	static DatabaseInitializationSettings getSettings(DataSource dataSource, IntegrationProperties.Jdbc properties) {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(resolveSchemaLocations(dataSource, properties));
		settings.setMode(properties.getInitializeSchema());
		settings.setContinueOnError(true);
		return settings;
	}
	private static List<String> resolveSchemaLocations(DataSource dataSource, IntegrationProperties.Jdbc properties) {
		PlatformPlaceholderDatabaseDriverResolver platformResolver = new PlatformPlaceholderDatabaseDriverResolver();
		platformResolver = platformResolver.withDriverPlatform(DatabaseDriver.MARIADB, 'mysql');
		if (StringUtils.hasText(properties.getPlatform())) {
			return platformResolver.resolveAll(properties.getPlatform(), properties.getSchema());
		}
		return platformResolver.resolveAll(dataSource, properties.getSchema());
	}
}
/*
package org.springframework.boot.autoconfigure.integration;
/**
@ConfigurationProperties(prefix = 'spring.integration')
public class IntegrationProperties {
	private final Channel channel = new Channel();
	private final Endpoint endpoint = new Endpoint();
	private final Error error = new Error();
	private final Jdbc jdbc = new Jdbc();
	private final RSocket rsocket = new RSocket();
	private final Poller poller = new Poller();
	private final Management management = new Management();
	public Channel getChannel() {
		return this.channel;
	}
	public Endpoint getEndpoint() {
		return this.endpoint;
	}
	public Error getError() {
		return this.error;
	}
	public Jdbc getJdbc() {
		return this.jdbc;
	}
	public RSocket getRsocket() {
		return this.rsocket;
	}
	public Poller getPoller() {
		return this.poller;
	}
	public Management getManagement() {
		return this.management;
	}
	public static class Channel {
		/**
		 * Whether to create input channels if necessary.
		 */
		private boolean autoCreate = true;
		/**
		 * Default number of subscribers allowed on, for example, a "DirectChannel".
		 */
		private int maxUnicastSubscribers = Integer.MAX_VALUE;
		/**
		 * Default number of subscribers allowed on, for example, a
		 * "PublishSubscribeChannel".
		 */
		private int maxBroadcastSubscribers = Integer.MAX_VALUE;
		public void setAutoCreate(boolean autoCreate) {
			this.autoCreate = autoCreate;
		}
		public boolean isAutoCreate() {
			return this.autoCreate;
		}
		public void setMaxUnicastSubscribers(int maxUnicastSubscribers) {
			this.maxUnicastSubscribers = maxUnicastSubscribers;
		}
		public int getMaxUnicastSubscribers() {
			return this.maxUnicastSubscribers;
		}
		public void setMaxBroadcastSubscribers(int maxBroadcastSubscribers) {
			this.maxBroadcastSubscribers = maxBroadcastSubscribers;
		}
		public int getMaxBroadcastSubscribers() {
			return this.maxBroadcastSubscribers;
		}
	}
	public static class Endpoint {
		/**
		 * Whether to throw an exception when a reply is not expected anymore by a
		 * gateway.
		 */
		private boolean throwExceptionOnLateReply = false;
		/**
		 * List of message header names that should not be populated into Message
		 * instances during a header copying operation.
		 */
		private List<String> readOnlyHeaders = new ArrayList<>();
		/**
		 * List of endpoint bean names patterns that should not be started automatically
		 * during application startup.
		 */
		private List<String> noAutoStartup = new ArrayList<>();
		/**
		 * Default timeout for blocking operations such as sending or receiving messages.
		 */
		private Duration defaultTimeout = Duration.ofSeconds(30);
		public void setThrowExceptionOnLateReply(boolean throwExceptionOnLateReply) {
			this.throwExceptionOnLateReply = throwExceptionOnLateReply;
		}
		public boolean isThrowExceptionOnLateReply() {
			return this.throwExceptionOnLateReply;
		}
		public List<String> getReadOnlyHeaders() {
			return this.readOnlyHeaders;
		}
		public void setReadOnlyHeaders(List<String> readOnlyHeaders) {
			this.readOnlyHeaders = readOnlyHeaders;
		}
		public List<String> getNoAutoStartup() {
			return this.noAutoStartup;
		}
		public void setNoAutoStartup(List<String> noAutoStartup) {
			this.noAutoStartup = noAutoStartup;
		}
		public Duration getDefaultTimeout() {
			return this.defaultTimeout;
		}
		public void setDefaultTimeout(Duration defaultTimeout) {
			this.defaultTimeout = defaultTimeout;
		}
	}
	public static class Error {
		/**
		 * Whether to not silently ignore messages on the global "errorChannel" when there
		 * are no subscribers.
		 */
		private boolean requireSubscribers = true;
		/**
		 * Whether to ignore failures for one or more of the handlers of the global
		 * "errorChannel".
		 */
		private boolean ignoreFailures = true;
		public boolean isRequireSubscribers() {
			return this.requireSubscribers;
		}
		public void setRequireSubscribers(boolean requireSubscribers) {
			this.requireSubscribers = requireSubscribers;
		}
		public boolean isIgnoreFailures() {
			return this.ignoreFailures;
		}
		public void setIgnoreFailures(boolean ignoreFailures) {
			this.ignoreFailures = ignoreFailures;
		}
	}
	public static class Jdbc {
		private static final String DEFAULT_SCHEMA_LOCATION = 'classpath:org/springframework/'
				+ 'integration/jdbc/schema-@@platform@@.sql';
		/**
		 * Path to the SQL file to use to initialize the database schema.
		 */
		private String schema = DEFAULT_SCHEMA_LOCATION;
		/**
		 * Platform to use in initialization scripts if the @@platform@@ placeholder is
		 * used. Auto-detected by default.
		 */
		private String platform;
		/**
		 * Database schema initialization mode.
		 */
		private DatabaseInitializationMode initializeSchema = DatabaseInitializationMode.EMBEDDED;
		public String getSchema() {
			return this.schema;
		}
		public void setSchema(String schema) {
			this.schema = schema;
		}
		public String getPlatform() {
			return this.platform;
		}
		public void setPlatform(String platform) {
			this.platform = platform;
		}
		public DatabaseInitializationMode getInitializeSchema() {
			return this.initializeSchema;
		}
		public void setInitializeSchema(DatabaseInitializationMode initializeSchema) {
			this.initializeSchema = initializeSchema;
		}
	}
	public static class RSocket {
		private final Client client = new Client();
		private final Server server = new Server();
		public Client getClient() {
			return this.client;
		}
		public Server getServer() {
			return this.server;
		}
		public static class Client {
			/**
			 * TCP RSocket server host to connect to.
			 */
			private String host;
			/**
			 * TCP RSocket server port to connect to.
			 */
			private Integer port;
			/**
			 * WebSocket RSocket server uri to connect to.
			 */
			private URI uri;
			public void setHost(String host) {
				this.host = host;
			}
			public String getHost() {
				return this.host;
			}
			public void setPort(Integer port) {
				this.port = port;
			}
			public Integer getPort() {
				return this.port;
			}
			public void setUri(URI uri) {
				this.uri = uri;
			}
			public URI getUri() {
				return this.uri;
			}
		}
		public static class Server {
			/**
			 * Whether to handle message mapping for RSocket through Spring Integration.
			 */
			private boolean messageMappingEnabled;
			public boolean isMessageMappingEnabled() {
				return this.messageMappingEnabled;
			}
			public void setMessageMappingEnabled(boolean messageMappingEnabled) {
				this.messageMappingEnabled = messageMappingEnabled;
			}
		}
	}
	public static class Poller {
		/**
		 * Maximum number of messages to poll per polling cycle.
		 */
		private int maxMessagesPerPoll = Integer.MIN_VALUE; // PollerMetadata.MAX_MESSAGES_UNBOUNDED
		/**
		 * How long to wait for messages on poll.
		 */
		private Duration receiveTimeout = Duration.ofSeconds(1); // PollerMetadata.DEFAULT_RECEIVE_TIMEOUT
		/**
		 * Polling delay period. Mutually exclusive with "cron" and "fixedRate".
		 */
		private Duration fixedDelay;
		/**
		 * Polling rate period. Mutually exclusive with "fixedDelay" and "cron".
		 */
		private Duration fixedRate;
		/**
		 * Polling initial delay. Applied for "fixedDelay" and "fixedRate"; ignored for
		 * "cron".
		 */
		private Duration initialDelay;
		/**
		 * Cron expression for polling. Mutually exclusive with "fixedDelay" and
		 * "fixedRate".
		 */
		private String cron;
		public int getMaxMessagesPerPoll() {
			return this.maxMessagesPerPoll;
		}
		public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {
			this.maxMessagesPerPoll = maxMessagesPerPoll;
		}
		public Duration getReceiveTimeout() {
			return this.receiveTimeout;
		}
		public void setReceiveTimeout(Duration receiveTimeout) {
			this.receiveTimeout = receiveTimeout;
		}
		public Duration getFixedDelay() {
			return this.fixedDelay;
		}
		public void setFixedDelay(Duration fixedDelay) {
			this.fixedDelay = fixedDelay;
		}
		public Duration getFixedRate() {
			return this.fixedRate;
		}
		public void setFixedRate(Duration fixedRate) {
			this.fixedRate = fixedRate;
		}
		public Duration getInitialDelay() {
			return this.initialDelay;
		}
		public void setInitialDelay(Duration initialDelay) {
			this.initialDelay = initialDelay;
		}
		public String getCron() {
			return this.cron;
		}
		public void setCron(String cron) {
			this.cron = cron;
		}
	}
	public static class Management {
		/**
		 * Whether Spring Integration components should perform logging in the main
		 * message flow. When disabled, such logging will be skipped without checking the
		 * logging level. When enabled, such logging is controlled as normal by the
		 * logging system"s log level configuration.
		 */
		private boolean defaultLoggingEnabled = true;
		/**
		 * List of simple patterns to match against the names of Spring Integration
		 * components. When matched, observation instrumentation will be performed for the
		 * component. Please refer to the javadoc of the smartMatch method of Spring
		 * Integration"s PatternMatchUtils for details of the pattern syntax.
		 */
		private List<String> observationPatterns = new ArrayList<>();
		public boolean isDefaultLoggingEnabled() {
			return this.defaultLoggingEnabled;
		}
		public void setDefaultLoggingEnabled(boolean defaultLoggingEnabled) {
			this.defaultLoggingEnabled = defaultLoggingEnabled;
		}
		public List<String> getObservationPatterns() {
			return this.observationPatterns;
		}
		public void setObservationPatterns(List<String> observationPatterns) {
			this.observationPatterns = observationPatterns;
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
@FunctionalInterface
public interface AutoConfigurationImportFilter {
	/**
	 * Apply the filter to the given auto-configuration class candidates.
	 * @param autoConfigurationClasses the auto-configuration classes being considered.
	 * This array may contain {@code null} elements. Implementations should not change the
	 * values in this array.
	 * @param autoConfigurationMetadata access to the meta-data generated by the
	 * auto-configure annotation processor
	 * @return a boolean array indicating which of the auto-configuration classes should
	 * be imported. The returned array must be the same size as the incoming
	 * {@code autoConfigurationClasses} parameter. Entries containing {@code false} will
	 * not be imported.
	 */
	boolean[] match(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata);
}
/*
package org.springframework.boot.autoconfigure;
/**
public interface AutoConfigurationMetadata {
	/**
	 * Return {@code true} if the specified class name was processed by the annotation
	 * processor.
	 * @param className the source class
	 * @return if the class was processed
	 */
	boolean wasProcessed(String className);
	/**
	 * Get an {@link Integer} value from the meta-data.
	 * @param className the source class
	 * @param key the meta-data key
	 * @return the meta-data value or {@code null}
	 */
	Integer getInteger(String className, String key);
	/**
	 * Get an {@link Integer} value from the meta-data.
	 * @param className the source class
	 * @param key the meta-data key
	 * @param defaultValue the default value
	 * @return the meta-data value or {@code defaultValue}
	 */
	Integer getInteger(String className, String key, Integer defaultValue);
	/**
	 * Get a {@link Set} value from the meta-data.
	 * @param className the source class
	 * @param key the meta-data key
	 * @return the meta-data value or {@code null}
	 */
	Set<String> getSet(String className, String key);
	/**
	 * Get a {@link Set} value from the meta-data.
	 * @param className the source class
	 * @param key the meta-data key
	 * @param defaultValue the default value
	 * @return the meta-data value or {@code defaultValue}
	 */
	Set<String> getSet(String className, String key, Set<String> defaultValue);
	/**
	 * Get an {@link String} value from the meta-data.
	 * @param className the source class
	 * @param key the meta-data key
	 * @return the meta-data value or {@code null}
	 */
	String get(String className, String key);
	/**
	 * Get an {@link String} value from the meta-data.
	 * @param className the source class
	 * @param key the meta-data key
	 * @param defaultValue the default value
	 * @return the meta-data value or {@code defaultValue}
	 */
	String get(String className, String key, String defaultValue);
}
/*
package org.springframework.boot.autoconfigure;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration(proxyBeanMethods = false)
@AutoConfigureBefore
@AutoConfigureAfter
public @interface AutoConfiguration {
	/**
	 * Explicitly specify the name of the Spring bean definition associated with the
	 * {@code @AutoConfiguration} class. If left unspecified (the common case), a bean
	 * name will be automatically generated.
	 * <p>
	 * The custom name applies only if the {@code @AutoConfiguration} class is picked up
	 * through component scanning or supplied directly to an
	 * {@link AnnotationConfigApplicationContext}. If the {@code @AutoConfiguration} class
	 * is registered as a traditional XML bean definition, the name/id of the bean element
	 * will take precedence.
	 * @return the explicit component name, if any (or empty String otherwise)
	 * @see AnnotationBeanNameGenerator
	 */
	@AliasFor(annotation = Configuration.class)
	String value() default '';
	/**
	 * The auto-configure classes that should have not yet been applied.
	 * @return the classes
	 */
	@AliasFor(annotation = AutoConfigureBefore.class, attribute = 'value')
	Class<?>[] before() default {};
	/**
	 * The names of the auto-configure classes that should have not yet been applied.
	 * @return the class names
	 */
	@AliasFor(annotation = AutoConfigureBefore.class, attribute = 'name')
	String[] beforeName() default {};
	/**
	 * The auto-configure classes that should have already been applied.
	 * @return the classes
	 */
	@AliasFor(annotation = AutoConfigureAfter.class, attribute = 'value')
	Class<?>[] after() default {};
	/**
	 * The names of the auto-configure classes that should have already been applied.
	 * @return the class names
	 */
	@AliasFor(annotation = AutoConfigureAfter.class, attribute = 'name')
	String[] afterName() default {};
}
/*
package org.springframework.boot.autoconfigure.domain;
/**
public class EntityScanPackages {
	private static final String BEAN = EntityScanPackages.class.getName();
	private static final EntityScanPackages NONE = new EntityScanPackages();
	private final List<String> packageNames;
	EntityScanPackages(String... packageNames) {
		List<String> packages = new ArrayList<>();
		for (String name : packageNames) {
			if (StringUtils.hasText(name)) {
				packages.add(name);
			}
		}
		this.packageNames = Collections.unmodifiableList(packages);
	}
	/**
	 * Return the package names specified from all {@link EntityScan @EntityScan}
	 * annotations.
	 * @return the entity scan package names
	 */
	public List<String> getPackageNames() {
		return this.packageNames;
	}
	/**
	 * Return the {@link EntityScanPackages} for the given bean factory.
	 * @param beanFactory the source bean factory
	 * @return the {@link EntityScanPackages} for the bean factory (never {@code null})
	 */
	public static EntityScanPackages get(BeanFactory beanFactory) {
		// Currently we only store a single base package, but we return a list to
		// allow this to change in the future if needed
		try {
			return beanFactory.getBean(BEAN, EntityScanPackages.class);
		}
		catch (NoSuchBeanDefinitionException ex) {
			return NONE;
		}
	}
	/**
	 * Register the specified entity scan packages with the system.
	 * @param registry the source registry
	 * @param packageNames the package names to register
	 */
	public static void register(BeanDefinitionRegistry registry, String... packageNames) {
		Assert.notNull(registry, 'Registry must not be null');
		Assert.notNull(packageNames, 'PackageNames must not be null');
		register(registry, Arrays.asList(packageNames));
	}
	/**
	 * Register the specified entity scan packages with the system.
	 * @param registry the source registry
	 * @param packageNames the package names to register
	 */
	public static void register(BeanDefinitionRegistry registry, Collection<String> packageNames) {
		Assert.notNull(registry, 'Registry must not be null');
		Assert.notNull(packageNames, 'PackageNames must not be null');
		if (registry.containsBeanDefinition(BEAN)) {
			EntityScanPackagesBeanDefinition beanDefinition = (EntityScanPackagesBeanDefinition) registry
				.getBeanDefinition(BEAN);
			beanDefinition.addPackageNames(packageNames);
		}
		else {
			registry.registerBeanDefinition(BEAN, new EntityScanPackagesBeanDefinition(packageNames));
		}
	}
	/**
	 * {@link ImportBeanDefinitionRegistrar} to store the base package from the importing
	 * configuration.
	 */
	static class Registrar implements ImportBeanDefinitionRegistrar {
		private final Environment environment;
		Registrar(Environment environment) {
			this.environment = environment;
		}
		@Override
		public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {
			register(registry, getPackagesToScan(metadata));
		}
		private Set<String> getPackagesToScan(AnnotationMetadata metadata) {
			AnnotationAttributes attributes = AnnotationAttributes
				.fromMap(metadata.getAnnotationAttributes(EntityScan.class.getName()));
			Set<String> packagesToScan = new LinkedHashSet<>();
			for (String basePackage : attributes.getStringArray('basePackages')) {
				String[] tokenized = StringUtils.tokenizeToStringArray(
						this.environment.resolvePlaceholders(basePackage),
						ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);
				Collections.addAll(packagesToScan, tokenized);
			}
			for (Class<?> basePackageClass : attributes.getClassArray('basePackageClasses')) {
				packagesToScan.add(this.environment.resolvePlaceholders(ClassUtils.getPackageName(basePackageClass)));
			}
			if (packagesToScan.isEmpty()) {
				String packageName = ClassUtils.getPackageName(metadata.getClassName());
				Assert.state(StringUtils.hasLength(packageName), '@EntityScan cannot be used with the default package');
				return Collections.singleton(packageName);
			}
			return packagesToScan;
		}
	}
	static class EntityScanPackagesBeanDefinition extends RootBeanDefinition {
		private final Set<String> packageNames = new LinkedHashSet<>();
		EntityScanPackagesBeanDefinition(Collection<String> packageNames) {
			setBeanClass(EntityScanPackages.class);
			setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
			addPackageNames(packageNames);
		}
		private void addPackageNames(Collection<String> additionalPackageNames) {
			this.packageNames.addAll(additionalPackageNames);
			getConstructorArgumentValues().addIndexedArgumentValue(0, StringUtils.toStringArray(this.packageNames));
		}
	}
}
/*
package org.springframework.boot.autoconfigure.domain;
/**
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(EntityScanPackages.Registrar.class)
public @interface EntityScan {
	/**
	 * Alias for the {@link #basePackages()} attribute. Allows for more concise annotation
	 * declarations e.g.: {@code @EntityScan('org.my.pkg')} instead of
	 * {@code @EntityScan(basePackages='org.my.pkg')}.
	 * @return the base packages to scan
	 */
	@AliasFor('basePackages')
	String[] value() default {};
	/**
	 * Base packages to scan for entities. {@link #value()} is an alias for (and mutually
	 * exclusive with) this attribute.
	 * <p>
	 * Use {@link #basePackageClasses()} for a type-safe alternative to String-based
	 * package names.
	 * @return the base packages to scan
	 */
	@AliasFor('value')
	String[] basePackages() default {};
	/**
	 * Type-safe alternative to {@link #basePackages()} for specifying the packages to
	 * scan for entities. The package of each class specified will be scanned.
	 * <p>
	 * Consider creating a special no-op marker class or interface in each package that
	 * serves no purpose other than being referenced by this attribute.
	 * @return classes from the base packages to scan
	 */
	Class<?>[] basePackageClasses() default {};
}
/*
package org.springframework.boot.autoconfigure.domain;
/**
public class EntityScanner {
	private final ApplicationContext context;
	/**
	 * Create a new {@link EntityScanner} instance.
	 * @param context the source application context
	 */
	public EntityScanner(ApplicationContext context) {
		Assert.notNull(context, 'Context must not be null');
		this.context = context;
	}
	/**
	 * Scan for entities with the specified annotations.
	 * @param annotationTypes the annotation types used on the entities
	 * @return a set of entity classes
	 * @throws ClassNotFoundException if an entity class cannot be loaded
	 */
	@SafeVarargs
	public final Set<Class<?>> scan(Class<? extends Annotation>... annotationTypes) throws ClassNotFoundException {
		List<String> packages = getPackages();
		if (packages.isEmpty()) {
			return Collections.emptySet();
		}
		ClassPathScanningCandidateComponentProvider scanner = createClassPathScanningCandidateComponentProvider(
				this.context);
		for (Class<? extends Annotation> annotationType : annotationTypes) {
			scanner.addIncludeFilter(new AnnotationTypeFilter(annotationType));
		}
		Set<Class<?>> entitySet = new HashSet<>();
		for (String basePackage : packages) {
			if (StringUtils.hasText(basePackage)) {
				for (BeanDefinition candidate : scanner.findCandidateComponents(basePackage)) {
					entitySet.add(ClassUtils.forName(candidate.getBeanClassName(), this.context.getClassLoader()));
				}
			}
		}
		return entitySet;
	}
	/**
	 * Create a {@link ClassPathScanningCandidateComponentProvider} to scan entities based
	 * on the specified {@link ApplicationContext}.
	 * @param context the {@link ApplicationContext} to use
	 * @return a {@link ClassPathScanningCandidateComponentProvider} suitable to scan
	 * entities
	 * @since 2.4.0
	 */
	protected ClassPathScanningCandidateComponentProvider createClassPathScanningCandidateComponentProvider(
			ApplicationContext context) {
		ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);
		scanner.setEnvironment(context.getEnvironment());
		scanner.setResourceLoader(context);
		return scanner;
	}
	private List<String> getPackages() {
		List<String> packages = EntityScanPackages.get(this.context).getPackageNames();
		if (packages.isEmpty() && AutoConfigurationPackages.has(this.context)) {
			packages = AutoConfigurationPackages.get(this.context);
		}
		return packages;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.domain;
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
public interface DriverConfigLoaderBuilderCustomizer {
	/**
	 * Customize the {@linkplain ProgrammaticDriverConfigLoaderBuilder DriverConfigLoader
	 * builder}.
	 * @param builder the builder to customize
	 */
	void customize(ProgrammaticDriverConfigLoaderBuilder builder);
}
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
@AutoConfiguration
@ConditionalOnClass(CqlSession.class)
@EnableConfigurationProperties(CassandraProperties.class)
public class CassandraAutoConfiguration {
	private static final Config SPRING_BOOT_DEFAULTS;
	static {
		CassandraDriverOptions options = new CassandraDriverOptions();
		options.add(DefaultDriverOption.CONTACT_POINTS, Collections.singletonList('127.0.0.1:9042'));
		options.add(DefaultDriverOption.PROTOCOL_COMPRESSION, 'none');
		options.add(DefaultDriverOption.CONTROL_CONNECTION_TIMEOUT, (int) Duration.ofSeconds(5).toMillis());
		SPRING_BOOT_DEFAULTS = options.build();
	}
	private final CassandraProperties properties;
	CassandraAutoConfiguration(CassandraProperties properties) {
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean(CassandraConnectionDetails.class)
	PropertiesCassandraConnectionDetails cassandraConnectionDetails() {
		return new PropertiesCassandraConnectionDetails(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	@Lazy
	public CqlSession cassandraSession(CqlSessionBuilder cqlSessionBuilder) {
		return cqlSessionBuilder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	@Scope('prototype')
	public CqlSessionBuilder cassandraSessionBuilder(DriverConfigLoader driverConfigLoader,
			CassandraConnectionDetails connectionDetails,
			ObjectProvider<CqlSessionBuilderCustomizer> builderCustomizers, ObjectProvider<SslBundles> sslBundles) {
		CqlSessionBuilder builder = CqlSession.builder().withConfigLoader(driverConfigLoader);
		configureAuthentication(builder, connectionDetails);
		configureSsl(builder, sslBundles.getIfAvailable());
		builder.withKeyspace(this.properties.getKeyspaceName());
		builderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder;
	}
	private void configureAuthentication(CqlSessionBuilder builder, CassandraConnectionDetails connectionDetails) {
		String username = connectionDetails.getUsername();
		if (username != null) {
			builder.withAuthCredentials(username, connectionDetails.getPassword());
		}
	}
	private void configureSsl(CqlSessionBuilder builder, SslBundles sslBundles) {
		Ssl properties = this.properties.getSsl();
		if (properties == null || !properties.isEnabled()) {
			return;
		}
		String bundleName = properties.getBundle();
		if (!StringUtils.hasLength(bundleName)) {
			configureDefaultSslContext(builder);
		}
		else {
			configureSsl(builder, sslBundles.getBundle(bundleName));
		}
	}
	private void configureDefaultSslContext(CqlSessionBuilder builder) {
		try {
			builder.withSslContext(SSLContext.getDefault());
		}
		catch (NoSuchAlgorithmException ex) {
			throw new IllegalStateException('Could not setup SSL default context for Cassandra', ex);
		}
	}
	private void configureSsl(CqlSessionBuilder builder, SslBundle sslBundle) {
		SslOptions options = sslBundle.getOptions();
		Assert.state(options.getEnabledProtocols() == null, 'SSL protocol options cannot be specified with Cassandra');
		builder
			.withSslEngineFactory(new ProgrammaticSslEngineFactory(sslBundle.createSslContext(), options.getCiphers()));
	}
	@Bean(destroyMethod = '')
	@ConditionalOnMissingBean
	public DriverConfigLoader cassandraDriverConfigLoader(CassandraConnectionDetails connectionDetails,
			ObjectProvider<DriverConfigLoaderBuilderCustomizer> builderCustomizers) {
		ProgrammaticDriverConfigLoaderBuilder builder = new DefaultProgrammaticDriverConfigLoaderBuilder(
				() -> cassandraConfiguration(connectionDetails), DefaultDriverConfigLoader.DEFAULT_ROOT_PATH);
		builderCustomizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	private Config cassandraConfiguration(CassandraConnectionDetails connectionDetails) {
		ConfigFactory.invalidateCaches();
		Config config = ConfigFactory.defaultOverrides();
		config = config.withFallback(mapConfig(connectionDetails));
		if (this.properties.getConfig() != null) {
			config = config.withFallback(loadConfig(this.properties.getConfig()));
		}
		config = config.withFallback(SPRING_BOOT_DEFAULTS);
		config = config.withFallback(ConfigFactory.defaultReferenceUnresolved());
		return config.resolve();
	}
	private Config loadConfig(Resource resource) {
		try {
			return ConfigFactory.parseURL(resource.getURL());
		}
		catch (IOException ex) {
			throw new IllegalStateException('Failed to load cassandra configuration from ' + resource, ex);
		}
	}
	private Config mapConfig(CassandraConnectionDetails connectionDetails) {
		CassandraDriverOptions options = new CassandraDriverOptions();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(this.properties.getSessionName())
			.whenHasText()
			.to((sessionName) -> options.add(DefaultDriverOption.SESSION_NAME, sessionName));
		map.from(connectionDetails.getUsername())
			.to((value) -> options.add(DefaultDriverOption.AUTH_PROVIDER_USER_NAME, value)
				.add(DefaultDriverOption.AUTH_PROVIDER_PASSWORD, connectionDetails.getPassword()));
		map.from(this.properties::getCompression)
			.to((compression) -> options.add(DefaultDriverOption.PROTOCOL_COMPRESSION, compression));
		mapConnectionOptions(options);
		mapPoolingOptions(options);
		mapRequestOptions(options);
		mapControlConnectionOptions(options);
		map.from(mapContactPoints(connectionDetails))
			.to((contactPoints) -> options.add(DefaultDriverOption.CONTACT_POINTS, contactPoints));
		map.from(connectionDetails.getLocalDatacenter())
			.whenHasText()
			.to((localDatacenter) -> options.add(DefaultDriverOption.LOAD_BALANCING_LOCAL_DATACENTER, localDatacenter));
		return options.build();
	}
	private void mapConnectionOptions(CassandraDriverOptions options) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		Connection connectionProperties = this.properties.getConnection();
		map.from(connectionProperties::getConnectTimeout)
			.asInt(Duration::toMillis)
			.to((connectTimeout) -> options.add(DefaultDriverOption.CONNECTION_CONNECT_TIMEOUT, connectTimeout));
		map.from(connectionProperties::getInitQueryTimeout)
			.asInt(Duration::toMillis)
			.to((initQueryTimeout) -> options.add(DefaultDriverOption.CONNECTION_INIT_QUERY_TIMEOUT, initQueryTimeout));
	}
	private void mapPoolingOptions(CassandraDriverOptions options) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		CassandraProperties.Pool poolProperties = this.properties.getPool();
		map.from(poolProperties::getIdleTimeout)
			.asInt(Duration::toMillis)
			.to((idleTimeout) -> options.add(DefaultDriverOption.HEARTBEAT_TIMEOUT, idleTimeout));
		map.from(poolProperties::getHeartbeatInterval)
			.asInt(Duration::toMillis)
			.to((heartBeatInterval) -> options.add(DefaultDriverOption.HEARTBEAT_INTERVAL, heartBeatInterval));
	}
	private void mapRequestOptions(CassandraDriverOptions options) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		Request requestProperties = this.properties.getRequest();
		map.from(requestProperties::getTimeout)
			.asInt(Duration::toMillis)
			.to(((timeout) -> options.add(DefaultDriverOption.REQUEST_TIMEOUT, timeout)));
		map.from(requestProperties::getConsistency)
			.to(((consistency) -> options.add(DefaultDriverOption.REQUEST_CONSISTENCY, consistency)));
		map.from(requestProperties::getSerialConsistency)
			.to((serialConsistency) -> options.add(DefaultDriverOption.REQUEST_SERIAL_CONSISTENCY, serialConsistency));
		map.from(requestProperties::getPageSize)
			.to((pageSize) -> options.add(DefaultDriverOption.REQUEST_PAGE_SIZE, pageSize));
		Throttler throttlerProperties = requestProperties.getThrottler();
		map.from(throttlerProperties::getType)
			.as(ThrottlerType::type)
			.to((type) -> options.add(DefaultDriverOption.REQUEST_THROTTLER_CLASS, type));
		map.from(throttlerProperties::getMaxQueueSize)
			.to((maxQueueSize) -> options.add(DefaultDriverOption.REQUEST_THROTTLER_MAX_QUEUE_SIZE, maxQueueSize));
		map.from(throttlerProperties::getMaxConcurrentRequests)
			.to((maxConcurrentRequests) -> options.add(DefaultDriverOption.REQUEST_THROTTLER_MAX_CONCURRENT_REQUESTS,
					maxConcurrentRequests));
		map.from(throttlerProperties::getMaxRequestsPerSecond)
			.to((maxRequestsPerSecond) -> options.add(DefaultDriverOption.REQUEST_THROTTLER_MAX_REQUESTS_PER_SECOND,
					maxRequestsPerSecond));
		map.from(throttlerProperties::getDrainInterval)
			.asInt(Duration::toMillis)
			.to((drainInterval) -> options.add(DefaultDriverOption.REQUEST_THROTTLER_DRAIN_INTERVAL, drainInterval));
	}
	private void mapControlConnectionOptions(CassandraDriverOptions options) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		Controlconnection controlProperties = this.properties.getControlconnection();
		map.from(controlProperties::getTimeout)
			.asInt(Duration::toMillis)
			.to((timeout) -> options.add(DefaultDriverOption.CONTROL_CONNECTION_TIMEOUT, timeout));
	}
	private List<String> mapContactPoints(CassandraConnectionDetails connectionDetails) {
		return connectionDetails.getContactPoints().stream().map((node) -> node.host() + ':' + node.port()).toList();
	}
	private static final class CassandraDriverOptions {
		private final Map<String, String> options = new LinkedHashMap<>();
		private CassandraDriverOptions add(DriverOption option, String value) {
			String key = createKeyFor(option);
			this.options.put(key, value);
			return this;
		}
		private CassandraDriverOptions add(DriverOption option, int value) {
			return add(option, String.valueOf(value));
		}
		private CassandraDriverOptions add(DriverOption option, Enum<?> value) {
			return add(option, value.name());
		}
		private CassandraDriverOptions add(DriverOption option, List<String> values) {
			for (int i = 0; i < values.size(); i++) {
				this.options.put(String.format('%s.%s', createKeyFor(option), i), values.get(i));
			}
			return this;
		}
		private Config build() {
			return ConfigFactory.parseMap(this.options, 'Environment');
		}
		private static String createKeyFor(DriverOption option) {
			return String.format('%s.%s', DefaultDriverConfigLoader.DEFAULT_ROOT_PATH, option.getPath());
		}
	}
	/**
	 * Adapts {@link CassandraProperties} to {@link CassandraConnectionDetails}.
	 */
	static final class PropertiesCassandraConnectionDetails implements CassandraConnectionDetails {
		private final CassandraProperties properties;
		private PropertiesCassandraConnectionDetails(CassandraProperties properties) {
			this.properties = properties;
		}
		@Override
		public List<Node> getContactPoints() {
			List<String> contactPoints = this.properties.getContactPoints();
			return (contactPoints != null) ? contactPoints.stream().map(this::asNode).toList()
					: Collections.emptyList();
		}
		@Override
		public String getUsername() {
			return this.properties.getUsername();
		}
		@Override
		public String getPassword() {
			return this.properties.getPassword();
		}
		@Override
		public String getLocalDatacenter() {
			return this.properties.getLocalDatacenter();
		}
		private Node asNode(String contactPoint) {
			int i = contactPoint.lastIndexOf(":");
			if (i >= 0) {
				String portCandidate = contactPoint.substring(i + 1);
				Integer port = asPort(portCandidate);
				if (port != null) {
					return new Node(contactPoint.substring(0, i), port);
				}
			}
			return new Node(contactPoint, this.properties.getPort());
		}
		private Integer asPort(String value) {
			try {
				int i = Integer.parseInt(value);
				return (i > 0 && i < 65535) ? i : null;
			}
			catch (Exception ex) {
				return null;
			}
		}
	}
}
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
@FunctionalInterface
public interface CqlSessionBuilderCustomizer {
	/**
	 * Customize the {@link CqlSessionBuilder}.
	 * @param cqlSessionBuilder the builder to customize
	 */
	void customize(CqlSessionBuilder cqlSessionBuilder);
}
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
public interface CassandraConnectionDetails extends ConnectionDetails {
	/**
	 * Cluster node addresses.
	 * @return the cluster node addresses
	 */
	List<Node> getContactPoints();
	/**
	 * Login user of the server.
	 * @return the login user of the server or {@code null}
	 */
	default String getUsername() {
		return null;
	}
	/**
	 * Login password of the server.
	 * @return the login password of the server or {@code null}
	 */
	default String getPassword() {
		return null;
	}
	/**
	 * Datacenter that is considered 'local'. Contact points should be from this
	 * datacenter.
	 * @return the datacenter that is considered 'local'
	 */
	String getLocalDatacenter();
	/**
	 * A Cassandra node.
	 *
	 * @param host the hostname
	 * @param port the port
	 */
	record Node(String host, int port) {
	}
}
/*
package org.springframework.boot.autoconfigure.cassandra;
/**
@ConfigurationProperties(prefix = 'spring.cassandra')
public class CassandraProperties {
	/**
	 * Location of the configuration file to use.
	 */
	private Resource config;
	/**
	 * Keyspace name to use.
	 */
	private String keyspaceName;
	/**
	 * Name of the Cassandra session.
	 */
	private String sessionName;
	/**
	 * Cluster node addresses in the form "host:port", or a simple "host" to use the
	 * configured port.
	 */
	private List<String> contactPoints;
	/**
	 * Port to use if a contact point does not specify one.
	 */
	private int port = 9042;
	/**
	 * Datacenter that is considered 'local'. Contact points should be from this
	 * datacenter.
	 */
	private String localDatacenter;
	/**
	 * Login user of the server.
	 */
	private String username;
	/**
	 * Login password of the server.
	 */
	private String password;
	/**
	 * Compression supported by the Cassandra binary protocol.
	 */
	private Compression compression;
	/**
	 * Schema action to take at startup.
	 */
	private String schemaAction = 'none';
	/**
	 * SSL configuration.
	 */
	private Ssl ssl = new Ssl();
	/**
	 * Connection configuration.
	 */
	private final Connection connection = new Connection();
	/**
	 * Pool configuration.
	 */
	private final Pool pool = new Pool();
	/**
	 * Request configuration.
	 */
	private final Request request = new Request();
	/**
	 * Control connection configuration.
	 */
	private final Controlconnection controlconnection = new Controlconnection();
	public Resource getConfig() {
		return this.config;
	}
	public void setConfig(Resource config) {
		this.config = config;
	}
	public String getKeyspaceName() {
		return this.keyspaceName;
	}
	public void setKeyspaceName(String keyspaceName) {
		this.keyspaceName = keyspaceName;
	}
	public String getSessionName() {
		return this.sessionName;
	}
	public void setSessionName(String sessionName) {
		this.sessionName = sessionName;
	}
	public List<String> getContactPoints() {
		return this.contactPoints;
	}
	public void setContactPoints(List<String> contactPoints) {
		this.contactPoints = contactPoints;
	}
	public int getPort() {
		return this.port;
	}
	public void setPort(int port) {
		this.port = port;
	}
	public String getLocalDatacenter() {
		return this.localDatacenter;
	}
	public void setLocalDatacenter(String localDatacenter) {
		this.localDatacenter = localDatacenter;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Compression getCompression() {
		return this.compression;
	}
	public void setCompression(Compression compression) {
		this.compression = compression;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public void setSsl(Ssl ssl) {
		this.ssl = ssl;
	}
	public String getSchemaAction() {
		return this.schemaAction;
	}
	public void setSchemaAction(String schemaAction) {
		this.schemaAction = schemaAction;
	}
	public Connection getConnection() {
		return this.connection;
	}
	public Pool getPool() {
		return this.pool;
	}
	public Request getRequest() {
		return this.request;
	}
	public Controlconnection getControlconnection() {
		return this.controlconnection;
	}
	public static class Ssl {
		/**
		 * Whether to enable SSL support.
		 */
		private Boolean enabled;
		/**
		 * SSL bundle name.
		 */
		private String bundle;
		public boolean isEnabled() {
			return (this.enabled != null) ? this.enabled : this.bundle != null;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
	}
	public static class Connection {
		/**
		 * Timeout to use when establishing driver connections.
		 */
		private Duration connectTimeout;
		/**
		 * Timeout to use for internal queries that run as part of the initialization
		 * process, just after a connection is opened.
		 */
		private Duration initQueryTimeout;
		public Duration getConnectTimeout() {
			return this.connectTimeout;
		}
		public void setConnectTimeout(Duration connectTimeout) {
			this.connectTimeout = connectTimeout;
		}
		public Duration getInitQueryTimeout() {
			return this.initQueryTimeout;
		}
		public void setInitQueryTimeout(Duration initQueryTimeout) {
			this.initQueryTimeout = initQueryTimeout;
		}
	}
	public static class Request {
		/**
		 * How long the driver waits for a request to complete.
		 */
		private Duration timeout;
		/**
		 * Queries consistency level.
		 */
		private DefaultConsistencyLevel consistency;
		/**
		 * Queries serial consistency level.
		 */
		private DefaultConsistencyLevel serialConsistency;
		/**
		 * How many rows will be retrieved simultaneously in a single network round-trip.
		 */
		private Integer pageSize;
		private final Throttler throttler = new Throttler();
		public Duration getTimeout() {
			return this.timeout;
		}
		public void setTimeout(Duration timeout) {
			this.timeout = timeout;
		}
		public DefaultConsistencyLevel getConsistency() {
			return this.consistency;
		}
		public void setConsistency(DefaultConsistencyLevel consistency) {
			this.consistency = consistency;
		}
		public DefaultConsistencyLevel getSerialConsistency() {
			return this.serialConsistency;
		}
		public void setSerialConsistency(DefaultConsistencyLevel serialConsistency) {
			this.serialConsistency = serialConsistency;
		}
		public Integer getPageSize() {
			return this.pageSize;
		}
		public void setPageSize(int pageSize) {
			this.pageSize = pageSize;
		}
		public Throttler getThrottler() {
			return this.throttler;
		}
	}
	/**
	 * Pool properties.
	 */
	public static class Pool {
		/**
		 * Idle timeout before an idle connection is removed.
		 */
		private Duration idleTimeout;
		/**
		 * Heartbeat interval after which a message is sent on an idle connection to make
		 * sure it"s still alive.
		 */
		private Duration heartbeatInterval;
		public Duration getIdleTimeout() {
			return this.idleTimeout;
		}
		public void setIdleTimeout(Duration idleTimeout) {
			this.idleTimeout = idleTimeout;
		}
		public Duration getHeartbeatInterval() {
			return this.heartbeatInterval;
		}
		public void setHeartbeatInterval(Duration heartbeatInterval) {
			this.heartbeatInterval = heartbeatInterval;
		}
	}
	public static class Controlconnection {
		/**
		 * Timeout to use for control queries.
		 */
		private Duration timeout;
		public Duration getTimeout() {
			return this.timeout;
		}
		public void setTimeout(Duration timeout) {
			this.timeout = timeout;
		}
	}
	public static class Throttler {
		/**
		 * Request throttling type.
		 */
		private ThrottlerType type;
		/**
		 * Maximum number of requests that can be enqueued when the throttling threshold
		 * is exceeded.
		 */
		private Integer maxQueueSize;
		/**
		 * Maximum number of requests that are allowed to execute in parallel.
		 */
		private Integer maxConcurrentRequests;
		/**
		 * Maximum allowed request rate.
		 */
		private Integer maxRequestsPerSecond;
		/**
		 * How often the throttler attempts to dequeue requests. Set this high enough that
		 * each attempt will process multiple entries in the queue, but not delay requests
		 * too much.
		 */
		private Duration drainInterval;
		public ThrottlerType getType() {
			return this.type;
		}
		public void setType(ThrottlerType type) {
			this.type = type;
		}
		public Integer getMaxQueueSize() {
			return this.maxQueueSize;
		}
		public void setMaxQueueSize(int maxQueueSize) {
			this.maxQueueSize = maxQueueSize;
		}
		public Integer getMaxConcurrentRequests() {
			return this.maxConcurrentRequests;
		}
		public void setMaxConcurrentRequests(int maxConcurrentRequests) {
			this.maxConcurrentRequests = maxConcurrentRequests;
		}
		public Integer getMaxRequestsPerSecond() {
			return this.maxRequestsPerSecond;
		}
		public void setMaxRequestsPerSecond(int maxRequestsPerSecond) {
			this.maxRequestsPerSecond = maxRequestsPerSecond;
		}
		public Duration getDrainInterval() {
			return this.drainInterval;
		}
		public void setDrainInterval(Duration drainInterval) {
			this.drainInterval = drainInterval;
		}
	}
	/**
	 * Name of the algorithm used to compress protocol frames.
	 */
	public enum Compression {
		/**
		 * Requires "net.jpountz.lz4:lz4".
		 */
		LZ4,
		/**
		 * Requires org.xerial.snappy:snappy-java.
		 */
		SNAPPY,
		/**
		 * No compression.
		 */
		NONE
	}
	public enum ThrottlerType {
		/**
		 * Limit the number of requests that can be executed in parallel.
		 */
		CONCURRENCY_LIMITING('ConcurrencyLimitingRequestThrottler'),
		/**
		 * Limits the request rate per second.
		 */
		RATE_LIMITING('RateLimitingRequestThrottler'),
		/**
		 * No request throttling.
		 */
		NONE('PassThroughRequestThrottler');
		private final String type;
		ThrottlerType(String type) {
			this.type = type;
		}
		public String type() {
			return this.type;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.cassandra;
/*
package org.springframework.boot.autoconfigure.sendgrid;
/**
@ConfigurationProperties(prefix = 'spring.sendgrid')
public class SendGridProperties {
	/**
	 * SendGrid API key.
	 */
	private String apiKey;
	/**
	 * Proxy configuration.
	 */
	private Proxy proxy;
	public String getApiKey() {
		return this.apiKey;
	}
	public void setApiKey(String apiKey) {
		this.apiKey = apiKey;
	}
	public Proxy getProxy() {
		return this.proxy;
	}
	public void setProxy(Proxy proxy) {
		this.proxy = proxy;
	}
	public boolean isProxyConfigured() {
		return this.proxy != null && this.proxy.getHost() != null && this.proxy.getPort() != null;
	}
	public static class Proxy {
		/**
		 * SendGrid proxy host.
		 */
		private String host;
		/**
		 * SendGrid proxy port.
		 */
		private Integer port;
		public String getHost() {
			return this.host;
		}
		public void setHost(String host) {
			this.host = host;
		}
		public Integer getPort() {
			return this.port;
		}
		public void setPort(Integer port) {
			this.port = port;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.sendgrid;
/**
@AutoConfiguration
@ConditionalOnClass(SendGrid.class)
@ConditionalOnProperty(prefix = 'spring.sendgrid', value = 'api-key')
@EnableConfigurationProperties(SendGridProperties.class)
public class SendGridAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(SendGridAPI.class)
	public SendGrid sendGrid(SendGridProperties properties) {
		if (properties.isProxyConfigured()) {
			HttpHost proxy = new HttpHost(properties.getProxy().getHost(), properties.getProxy().getPort());
			return new SendGrid(properties.getApiKey(), new Client(HttpClientBuilder.create().setProxy(proxy).build()));
		}
		return new SendGrid(properties.getApiKey());
	}
}
/*
/**
package org.springframework.boot.autoconfigure.sendgrid;
/*
package org.springframework.boot.autoconfigure.thymeleaf;
/**
public class ThymeleafTemplateAvailabilityProvider implements TemplateAvailabilityProvider {
	@Override
	public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader,
			ResourceLoader resourceLoader) {
		if (ClassUtils.isPresent('org.thymeleaf.spring6.SpringTemplateEngine', classLoader)) {
			String prefix = environment.getProperty('spring.thymeleaf.prefix', ThymeleafProperties.DEFAULT_PREFIX);
			String suffix = environment.getProperty('spring.thymeleaf.suffix', ThymeleafProperties.DEFAULT_SUFFIX);
			return resourceLoader.getResource(prefix + view + suffix).exists();
		}
		return false;
	}
}
/*
package org.springframework.boot.autoconfigure.thymeleaf;
/**
@AutoConfiguration(after = { WebMvcAutoConfiguration.class, WebFluxAutoConfiguration.class })
@EnableConfigurationProperties(ThymeleafProperties.class)
@ConditionalOnClass({ TemplateMode.class, SpringTemplateEngine.class })
@Import({ TemplateEngineConfigurations.ReactiveTemplateEngineConfiguration.class,
		TemplateEngineConfigurations.DefaultTemplateEngineConfiguration.class })
public class ThymeleafAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(name = 'defaultTemplateResolver')
	static class DefaultTemplateResolverConfiguration {
		private static final Log logger = LogFactory.getLog(DefaultTemplateResolverConfiguration.class);
		private final ThymeleafProperties properties;
		private final ApplicationContext applicationContext;
		DefaultTemplateResolverConfiguration(ThymeleafProperties properties, ApplicationContext applicationContext) {
			this.properties = properties;
			this.applicationContext = applicationContext;
			checkTemplateLocationExists();
		}
		private void checkTemplateLocationExists() {
			boolean checkTemplateLocation = this.properties.isCheckTemplateLocation();
			if (checkTemplateLocation) {
				TemplateLocation location = new TemplateLocation(this.properties.getPrefix());
				if (!location.exists(this.applicationContext)) {
					logger.warn('Cannot find template location: ' + location
							+ ' (please add some templates, check your Thymeleaf configuration, or set spring.thymeleaf.'
							+ 'check-template-location=false)');
				}
			}
		}
		@Bean
		SpringResourceTemplateResolver defaultTemplateResolver() {
			SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver();
			resolver.setApplicationContext(this.applicationContext);
			resolver.setPrefix(this.properties.getPrefix());
			resolver.setSuffix(this.properties.getSuffix());
			resolver.setTemplateMode(this.properties.getMode());
			if (this.properties.getEncoding() != null) {
				resolver.setCharacterEncoding(this.properties.getEncoding().name());
			}
			resolver.setCacheable(this.properties.isCache());
			Integer order = this.properties.getTemplateResolverOrder();
			if (order != null) {
				resolver.setOrder(order);
			}
			resolver.setCheckExistence(this.properties.isCheckTemplate());
			return resolver;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	@ConditionalOnProperty(name = 'spring.thymeleaf.enabled', matchIfMissing = true)
	static class ThymeleafWebMvcConfiguration {
		@Bean
		@ConditionalOnEnabledResourceChain
		@ConditionalOnMissingFilterBean(ResourceUrlEncodingFilter.class)
		FilterRegistrationBean<ResourceUrlEncodingFilter> resourceUrlEncodingFilter() {
			FilterRegistrationBean<ResourceUrlEncodingFilter> registration = new FilterRegistrationBean<>(
					new ResourceUrlEncodingFilter());
			registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ERROR);
			return registration;
		}
		@Configuration(proxyBeanMethods = false)
		static class ThymeleafViewResolverConfiguration {
			@Bean
			@ConditionalOnMissingBean(name = 'thymeleafViewResolver')
			ThymeleafViewResolver thymeleafViewResolver(ThymeleafProperties properties,
					SpringTemplateEngine templateEngine) {
				ThymeleafViewResolver resolver = new ThymeleafViewResolver();
				resolver.setTemplateEngine(templateEngine);
				resolver.setCharacterEncoding(properties.getEncoding().name());
				resolver.setContentType(
						appendCharset(properties.getServlet().getContentType(), resolver.getCharacterEncoding()));
				resolver.setProducePartialOutputWhileProcessing(
						properties.getServlet().isProducePartialOutputWhileProcessing());
				resolver.setExcludedViewNames(properties.getExcludedViewNames());
				resolver.setViewNames(properties.getViewNames());
				// This resolver acts as a fallback resolver (e.g. like a
				// InternalResourceViewResolver) so it needs to have low precedence
				resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 5);
				resolver.setCache(properties.isCache());
				return resolver;
			}
			private String appendCharset(MimeType type, String charset) {
				if (type.getCharset() != null) {
					return type.toString();
				}
				LinkedHashMap<String, String> parameters = new LinkedHashMap<>();
				parameters.put('charset', charset);
				parameters.putAll(type.getParameters());
				return new MimeType(type, parameters).toString();
			}
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	@ConditionalOnProperty(name = 'spring.thymeleaf.enabled', matchIfMissing = true)
	static class ThymeleafWebFluxConfiguration {
		@Bean
		@ConditionalOnMissingBean(name = 'thymeleafReactiveViewResolver')
		ThymeleafReactiveViewResolver thymeleafViewResolver(ISpringWebFluxTemplateEngine templateEngine,
				ThymeleafProperties properties) {
			ThymeleafReactiveViewResolver resolver = new ThymeleafReactiveViewResolver();
			resolver.setTemplateEngine(templateEngine);
			mapProperties(properties, resolver);
			mapReactiveProperties(properties.getReactive(), resolver);
			// This resolver acts as a fallback resolver (e.g. like a
			// InternalResourceViewResolver) so it needs to have low precedence
			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 5);
			return resolver;
		}
		private void mapProperties(ThymeleafProperties properties, ThymeleafReactiveViewResolver resolver) {
			PropertyMapper map = PropertyMapper.get();
			map.from(properties::getEncoding).to(resolver::setDefaultCharset);
			resolver.setExcludedViewNames(properties.getExcludedViewNames());
			resolver.setViewNames(properties.getViewNames());
		}
		private void mapReactiveProperties(Reactive properties, ThymeleafReactiveViewResolver resolver) {
			PropertyMapper map = PropertyMapper.get();
			map.from(properties::getMediaTypes).whenNonNull().to(resolver::setSupportedMediaTypes);
			map.from(properties::getMaxChunkSize)
				.asInt(DataSize::toBytes)
				.when((size) -> size > 0)
				.to(resolver::setResponseMaxChunkSizeBytes);
			map.from(properties::getFullModeViewNames).to(resolver::setFullModeViewNames);
			map.from(properties::getChunkedModeViewNames).to(resolver::setChunkedModeViewNames);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(LayoutDialect.class)
	static class ThymeleafWebLayoutConfiguration {
		@Bean
		@ConditionalOnMissingBean
		LayoutDialect layoutDialect() {
			return new LayoutDialect();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(DataAttributeDialect.class)
	static class DataAttributeDialectConfiguration {
		@Bean
		@ConditionalOnMissingBean
		DataAttributeDialect dialect() {
			return new DataAttributeDialect();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ SpringSecurityDialect.class, CsrfToken.class })
	static class ThymeleafSecurityDialectConfiguration {
		@Bean
		@ConditionalOnMissingBean
		SpringSecurityDialect securityDialect() {
			return new SpringSecurityDialect();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.thymeleaf;
/**
@ConfigurationProperties(prefix = 'spring.thymeleaf')
public class ThymeleafProperties {
	private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;
	public static final String DEFAULT_PREFIX = 'classpath:/templates/';
	public static final String DEFAULT_SUFFIX = '.html';
	/**
	 * Whether to check that the template exists before rendering it.
	 */
	private boolean checkTemplate = true;
	/**
	 * Whether to check that the templates location exists.
	 */
	private boolean checkTemplateLocation = true;
	/**
	 * Prefix that gets prepended to view names when building a URL.
	 */
	private String prefix = DEFAULT_PREFIX;
	/**
	 * Suffix that gets appended to view names when building a URL.
	 */
	private String suffix = DEFAULT_SUFFIX;
	/**
	 * Template mode to be applied to templates. See also Thymeleaf"s TemplateMode enum.
	 */
	private String mode = 'HTML';
	/**
	 * Template files encoding.
	 */
	private Charset encoding = DEFAULT_ENCODING;
	/**
	 * Whether to enable template caching.
	 */
	private boolean cache = true;
	/**
	 * Order of the template resolver in the chain. By default, the template resolver is
	 * first in the chain. Order start at 1 and should only be set if you have defined
	 * additional 'TemplateResolver' beans.
	 */
	private Integer templateResolverOrder;
	/**
	 * List of view names (patterns allowed) that can be resolved.
	 */
	private String[] viewNames;
	/**
	 * List of view names (patterns allowed) that should be excluded from resolution.
	 */
	private String[] excludedViewNames;
	/**
	 * Enable the SpringEL compiler in SpringEL expressions.
	 */
	private boolean enableSpringElCompiler;
	/**
	 * Whether hidden form inputs acting as markers for checkboxes should be rendered
	 * before the checkbox element itself.
	 */
	private boolean renderHiddenMarkersBeforeCheckboxes = false;
	/**
	 * Whether to enable Thymeleaf view resolution for Web frameworks.
	 */
	private boolean enabled = true;
	private final Servlet servlet = new Servlet();
	private final Reactive reactive = new Reactive();
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public boolean isCheckTemplate() {
		return this.checkTemplate;
	}
	public void setCheckTemplate(boolean checkTemplate) {
		this.checkTemplate = checkTemplate;
	}
	public boolean isCheckTemplateLocation() {
		return this.checkTemplateLocation;
	}
	public void setCheckTemplateLocation(boolean checkTemplateLocation) {
		this.checkTemplateLocation = checkTemplateLocation;
	}
	public String getPrefix() {
		return this.prefix;
	}
	public void setPrefix(String prefix) {
		this.prefix = prefix;
	}
	public String getSuffix() {
		return this.suffix;
	}
	public void setSuffix(String suffix) {
		this.suffix = suffix;
	}
	public String getMode() {
		return this.mode;
	}
	public void setMode(String mode) {
		this.mode = mode;
	}
	public Charset getEncoding() {
		return this.encoding;
	}
	public void setEncoding(Charset encoding) {
		this.encoding = encoding;
	}
	public boolean isCache() {
		return this.cache;
	}
	public void setCache(boolean cache) {
		this.cache = cache;
	}
	public Integer getTemplateResolverOrder() {
		return this.templateResolverOrder;
	}
	public void setTemplateResolverOrder(Integer templateResolverOrder) {
		this.templateResolverOrder = templateResolverOrder;
	}
	public String[] getExcludedViewNames() {
		return this.excludedViewNames;
	}
	public void setExcludedViewNames(String[] excludedViewNames) {
		this.excludedViewNames = excludedViewNames;
	}
	public String[] getViewNames() {
		return this.viewNames;
	}
	public void setViewNames(String[] viewNames) {
		this.viewNames = viewNames;
	}
	public boolean isEnableSpringElCompiler() {
		return this.enableSpringElCompiler;
	}
	public void setEnableSpringElCompiler(boolean enableSpringElCompiler) {
		this.enableSpringElCompiler = enableSpringElCompiler;
	}
	public boolean isRenderHiddenMarkersBeforeCheckboxes() {
		return this.renderHiddenMarkersBeforeCheckboxes;
	}
	public void setRenderHiddenMarkersBeforeCheckboxes(boolean renderHiddenMarkersBeforeCheckboxes) {
		this.renderHiddenMarkersBeforeCheckboxes = renderHiddenMarkersBeforeCheckboxes;
	}
	public Reactive getReactive() {
		return this.reactive;
	}
	public Servlet getServlet() {
		return this.servlet;
	}
	public static class Servlet {
		/**
		 * Content-Type value written to HTTP responses.
		 */
		private MimeType contentType = MimeType.valueOf('text/html');
		/**
		 * Whether Thymeleaf should start writing partial output as soon as possible or
		 * buffer until template processing is finished.
		 */
		private boolean producePartialOutputWhileProcessing = true;
		public MimeType getContentType() {
			return this.contentType;
		}
		public void setContentType(MimeType contentType) {
			this.contentType = contentType;
		}
		public boolean isProducePartialOutputWhileProcessing() {
			return this.producePartialOutputWhileProcessing;
		}
		public void setProducePartialOutputWhileProcessing(boolean producePartialOutputWhileProcessing) {
			this.producePartialOutputWhileProcessing = producePartialOutputWhileProcessing;
		}
	}
	public static class Reactive {
		/**
		 * Maximum size of data buffers used for writing to the response. Templates will
		 * execute in CHUNKED mode by default if this is set.
		 */
		private DataSize maxChunkSize = DataSize.ofBytes(0);
		/**
		 * Media types supported by the view technology.
		 */
		private List<MediaType> mediaTypes;
		/**
		 * Comma-separated list of view names (patterns allowed) that should be executed
		 * in FULL mode even if a max chunk size is set.
		 */
		private String[] fullModeViewNames;
		/**
		 * Comma-separated list of view names (patterns allowed) that should be the only
		 * ones executed in CHUNKED mode when a max chunk size is set.
		 */
		private String[] chunkedModeViewNames;
		public List<MediaType> getMediaTypes() {
			return this.mediaTypes;
		}
		public void setMediaTypes(List<MediaType> mediaTypes) {
			this.mediaTypes = mediaTypes;
		}
		public DataSize getMaxChunkSize() {
			return this.maxChunkSize;
		}
		public void setMaxChunkSize(DataSize maxChunkSize) {
			this.maxChunkSize = maxChunkSize;
		}
		public String[] getFullModeViewNames() {
			return this.fullModeViewNames;
		}
		public void setFullModeViewNames(String[] fullModeViewNames) {
			this.fullModeViewNames = fullModeViewNames;
		}
		public String[] getChunkedModeViewNames() {
			return this.chunkedModeViewNames;
		}
		public void setChunkedModeViewNames(String[] chunkedModeViewNames) {
			this.chunkedModeViewNames = chunkedModeViewNames;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.thymeleaf;
/*
package org.springframework.boot.autoconfigure.thymeleaf;
/**
class TemplateEngineConfigurations {
	@Configuration(proxyBeanMethods = false)
	static class DefaultTemplateEngineConfiguration {
		@Bean
		@ConditionalOnMissingBean(ISpringTemplateEngine.class)
		SpringTemplateEngine templateEngine(ThymeleafProperties properties,
				ObjectProvider<ITemplateResolver> templateResolvers, ObjectProvider<IDialect> dialects) {
			SpringTemplateEngine engine = new SpringTemplateEngine();
			engine.setEnableSpringELCompiler(properties.isEnableSpringElCompiler());
			engine.setRenderHiddenMarkersBeforeCheckboxes(properties.isRenderHiddenMarkersBeforeCheckboxes());
			templateResolvers.orderedStream().forEach(engine::addTemplateResolver);
			dialects.orderedStream().forEach(engine::addDialect);
			return engine;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	@ConditionalOnProperty(name = 'spring.thymeleaf.enabled', matchIfMissing = true)
	static class ReactiveTemplateEngineConfiguration {
		@Bean
		@ConditionalOnMissingBean(ISpringWebFluxTemplateEngine.class)
		SpringWebFluxTemplateEngine templateEngine(ThymeleafProperties properties,
				ObjectProvider<ITemplateResolver> templateResolvers, ObjectProvider<IDialect> dialects) {
			SpringWebFluxTemplateEngine engine = new SpringWebFluxTemplateEngine();
			engine.setEnableSpringELCompiler(properties.isEnableSpringElCompiler());
			engine.setRenderHiddenMarkersBeforeCheckboxes(properties.isRenderHiddenMarkersBeforeCheckboxes());
			templateResolvers.orderedStream().forEach(engine::addTemplateResolver);
			dialects.orderedStream().forEach(engine::addDialect);
			return engine;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
class PrimaryDefaultValidatorPostProcessor implements ImportBeanDefinitionRegistrar, BeanFactoryAware {
	/**
	 * The bean name of the auto-configured Validator.
	 */
	private static final String VALIDATOR_BEAN_NAME = 'defaultValidator';
	private ConfigurableListableBeanFactory beanFactory;
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		if (beanFactory instanceof ConfigurableListableBeanFactory listableBeanFactory) {
			this.beanFactory = listableBeanFactory;
		}
	}
	@Override
	public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
		BeanDefinition definition = getAutoConfiguredValidator(registry);
		if (definition != null) {
			definition.setPrimary(!hasPrimarySpringValidator());
		}
	}
	private BeanDefinition getAutoConfiguredValidator(BeanDefinitionRegistry registry) {
		if (registry.containsBeanDefinition(VALIDATOR_BEAN_NAME)) {
			BeanDefinition definition = registry.getBeanDefinition(VALIDATOR_BEAN_NAME);
			if (definition.getRole() == BeanDefinition.ROLE_INFRASTRUCTURE
					&& isTypeMatch(VALIDATOR_BEAN_NAME, LocalValidatorFactoryBean.class)) {
				return definition;
			}
		}
		return null;
	}
	private boolean isTypeMatch(String name, Class<?> type) {
		return this.beanFactory != null && this.beanFactory.isTypeMatch(name, type);
	}
	private boolean hasPrimarySpringValidator() {
		String[] validatorBeans = this.beanFactory.getBeanNamesForType(Validator.class, false, false);
		for (String validatorBean : validatorBeans) {
			BeanDefinition definition = this.beanFactory.getBeanDefinition(validatorBean);
			if (definition.isPrimary()) {
				return true;
			}
		}
		return false;
	}
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
@FunctionalInterface
public interface ValidationConfigurationCustomizer {
	/**
	 * Customize the given {@code configuration}.
	 * @param configuration the configuration to customize
	 */
	void customize(Configuration<?> configuration);
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
@AutoConfiguration
@ConditionalOnClass(ExecutableValidator.class)
@ConditionalOnResource(resources = 'classpath:META-INF/services/jakarta.validation.spi.ValidationProvider')
@Import(PrimaryDefaultValidatorPostProcessor.class)
public class ValidationAutoConfiguration {
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	@ConditionalOnMissingBean(Validator.class)
	public static LocalValidatorFactoryBean defaultValidator(ApplicationContext applicationContext,
			ObjectProvider<ValidationConfigurationCustomizer> customizers) {
		LocalValidatorFactoryBean factoryBean = new LocalValidatorFactoryBean();
		factoryBean.setConfigurationInitializer((configuration) -> customizers.orderedStream()
			.forEach((customizer) -> customizer.customize(configuration)));
		MessageInterpolatorFactory interpolatorFactory = new MessageInterpolatorFactory(applicationContext);
		factoryBean.setMessageInterpolator(interpolatorFactory.getObject());
		return factoryBean;
	}
	@Bean
	@ConditionalOnMissingBean(search = SearchStrategy.CURRENT)
	public static MethodValidationPostProcessor methodValidationPostProcessor(Environment environment,
			ObjectProvider<Validator> validator, ObjectProvider<MethodValidationExcludeFilter> excludeFilters) {
		FilteredMethodValidationPostProcessor processor = new FilteredMethodValidationPostProcessor(
				excludeFilters.orderedStream());
		boolean proxyTargetClass = environment.getProperty('spring.aop.proxy-target-class', Boolean.class, true);
		processor.setProxyTargetClass(proxyTargetClass);
		processor.setValidatorProvider(validator);
		return processor;
	}
}
/*
package org.springframework.boot.autoconfigure.validation;
/**
public class ValidatorAdapter implements SmartValidator, ApplicationContextAware, InitializingBean, DisposableBean {
	private final SmartValidator target;
	private final boolean existingBean;
	ValidatorAdapter(SmartValidator target, boolean existingBean) {
		this.target = target;
		this.existingBean = existingBean;
	}
	public final Validator getTarget() {
		return this.target;
	}
	@Override
	public boolean supports(Class<?> type) {
		return this.target.supports(type);
	}
	@Override
	public void validate(Object target, Errors errors) {
		this.target.validate(target, errors);
	}
	@Override
	public void validate(Object target, Errors errors, Object... validationHints) {
		this.target.validate(target, errors, validationHints);
	}
	@Override
	public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
		if (!this.existingBean && this.target instanceof ApplicationContextAware contextAwareTarget) {
			contextAwareTarget.setApplicationContext(applicationContext);
		}
	}
	@Override
	public void afterPropertiesSet() throws Exception {
		if (!this.existingBean && this.target instanceof InitializingBean initializingBean) {
			initializingBean.afterPropertiesSet();
		}
	}
	@Override
	public void destroy() throws Exception {
		if (!this.existingBean && this.target instanceof DisposableBean disposableBean) {
			disposableBean.destroy();
		}
	}
	/**
	 * Return a {@link Validator} that only implements the {@link Validator} interface,
	 * wrapping it if necessary.
	 * <p>
	 * If the specified {@link Validator} is not {@code null}, it is wrapped. If not, a
	 * {@link jakarta.validation.Validator} is retrieved from the context and wrapped.
	 * Otherwise, a new default validator is created.
	 * @param applicationContext the application context
	 * @param validator an existing validator to use or {@code null}
	 * @return the validator to use
	 */
	public static Validator get(ApplicationContext applicationContext, Validator validator) {
		if (validator != null) {
			return wrap(validator, false);
		}
		return getExistingOrCreate(applicationContext);
	}
	private static Validator getExistingOrCreate(ApplicationContext applicationContext) {
		Validator existing = getExisting(applicationContext);
		if (existing != null) {
			return wrap(existing, true);
		}
		return create(applicationContext);
	}
	private static Validator getExisting(ApplicationContext applicationContext) {
		try {
			jakarta.validation.Validator validatorBean = applicationContext.getBean(jakarta.validation.Validator.class);
			if (validatorBean instanceof Validator validator) {
				return validator;
			}
			return new SpringValidatorAdapter(validatorBean);
		}
		catch (NoSuchBeanDefinitionException ex) {
			return null;
		}
	}
	private static Validator create(MessageSource messageSource) {
		OptionalValidatorFactoryBean validator = new OptionalValidatorFactoryBean();
		try {
			MessageInterpolatorFactory factory = new MessageInterpolatorFactory(messageSource);
			validator.setMessageInterpolator(factory.getObject());
		}
		catch (ValidationException ex) {
			// Ignore
		}
		return wrap(validator, false);
	}
	private static Validator wrap(Validator validator, boolean existingBean) {
		if (validator instanceof jakarta.validation.Validator jakartaValidator) {
			if (jakartaValidator instanceof SpringValidatorAdapter adapter) {
				return new ValidatorAdapter(adapter, existingBean);
			}
			return new ValidatorAdapter(new SpringValidatorAdapter(jakartaValidator), existingBean);
		}
		return validator;
	}
	@Override
	@SuppressWarnings('unchecked')
	public <T> T unwrap(Class<T> type) {
		if (type.isInstance(this.target)) {
			return (T) this.target;
		}
		return this.target.unwrap(type);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.validation;
/*
package org.springframework.boot.autoconfigure.availability;
/**
@AutoConfiguration
public class ApplicationAvailabilityAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(ApplicationAvailability.class)
	public ApplicationAvailabilityBean applicationAvailability() {
		return new ApplicationAvailabilityBean();
	}
}
/*
/**
package org.springframework.boot.autoconfigure.availability;
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
@ImportRuntimeHints(SqlInitializationScriptsRuntimeHints.class)
public class SqlR2dbcScriptDatabaseInitializer extends R2dbcScriptDatabaseInitializer {
	/**
	 * Create a new {@link SqlDataSourceScriptDatabaseInitializer} instance.
	 * @param connectionFactory the primary SQL connection factory
	 * @param properties the SQL initialization properties
	 * @see #getSettings
	 */
	public SqlR2dbcScriptDatabaseInitializer(ConnectionFactory connectionFactory,
			SqlInitializationProperties properties) {
		super(connectionFactory, getSettings(properties));
	}
	/**
	 * Create a new {@link BatchDataSourceScriptDatabaseInitializer} instance.
	 * @param connectionFactory the primary SQL connection factory
	 * @param settings the database initialization settings
	 * @see #getSettings
	 */
	public SqlR2dbcScriptDatabaseInitializer(ConnectionFactory connectionFactory,
			DatabaseInitializationSettings settings) {
		super(connectionFactory, settings);
	}
	/**
	 * Adapts {@link SqlInitializationProperties SQL initialization properties} to
	 * {@link DatabaseInitializationSettings}.
	 * @param properties the SQL initialization properties
	 * @return a new {@link DatabaseInitializationSettings} instance
	 * @see #SqlR2dbcScriptDatabaseInitializer(ConnectionFactory,
	 * DatabaseInitializationSettings)
	 */
	public static DatabaseInitializationSettings getSettings(SqlInitializationProperties properties) {
		return SettingsCreator.createFrom(properties);
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
final class SettingsCreator {
	private SettingsCreator() {
	}
	static DatabaseInitializationSettings createFrom(SqlInitializationProperties properties) {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings
			.setSchemaLocations(scriptLocations(properties.getSchemaLocations(), 'schema', properties.getPlatform()));
		settings.setDataLocations(scriptLocations(properties.getDataLocations(), 'data', properties.getPlatform()));
		settings.setContinueOnError(properties.isContinueOnError());
		settings.setSeparator(properties.getSeparator());
		settings.setEncoding(properties.getEncoding());
		settings.setMode(properties.getMode());
		return settings;
	}
	private static List<String> scriptLocations(List<String> locations, String fallback, String platform) {
		if (locations != null) {
			return locations;
		}
		List<String> fallbackLocations = new ArrayList<>();
		fallbackLocations.add('optional:classpath*:' + fallback + '-' + platform + '.sql');
		fallbackLocations.add('optional:classpath*:' + fallback + '.sql');
		return fallbackLocations;
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
@ConfigurationProperties('spring.sql.init')
public class SqlInitializationProperties {
	/**
	 * Locations of the schema (DDL) scripts to apply to the database.
	 */
	private List<String> schemaLocations;
	/**
	 * Locations of the data (DML) scripts to apply to the database.
	 */
	private List<String> dataLocations;
	/**
	 * Platform to use in the default schema or data script locations,
	 * schema-${platform}.sql and data-${platform}.sql.
	 */
	private String platform = 'all';
	/**
	 * Username of the database to use when applying initialization scripts (if
	 * different).
	 */
	private String username;
	/**
	 * Password of the database to use when applying initialization scripts (if
	 * different).
	 */
	private String password;
	/**
	 * Whether initialization should continue when an error occurs.
	 */
	private boolean continueOnError = false;
	/**
	 * Statement separator in the schema and data scripts.
	 */
	private String separator = ';';
	/**
	 * Encoding of the schema and data scripts.
	 */
	private Charset encoding;
	/**
	 * Mode to apply when determining whether initialization should be performed.
	 */
	private DatabaseInitializationMode mode = DatabaseInitializationMode.EMBEDDED;
	public List<String> getSchemaLocations() {
		return this.schemaLocations;
	}
	public void setSchemaLocations(List<String> schemaLocations) {
		this.schemaLocations = schemaLocations;
	}
	public List<String> getDataLocations() {
		return this.dataLocations;
	}
	public void setDataLocations(List<String> dataLocations) {
		this.dataLocations = dataLocations;
	}
	public String getPlatform() {
		return this.platform;
	}
	public void setPlatform(String platform) {
		this.platform = platform;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public boolean isContinueOnError() {
		return this.continueOnError;
	}
	public void setContinueOnError(boolean continueOnError) {
		this.continueOnError = continueOnError;
	}
	public String getSeparator() {
		return this.separator;
	}
	public void setSeparator(String separator) {
		this.separator = separator;
	}
	public Charset getEncoding() {
		return this.encoding;
	}
	public void setEncoding(Charset encoding) {
		this.encoding = encoding;
	}
	public DatabaseInitializationMode getMode() {
		return this.mode;
	}
	public void setMode(DatabaseInitializationMode mode) {
		this.mode = mode;
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
@AutoConfiguration
@EnableConfigurationProperties(SqlInitializationProperties.class)
@Import({ DatabaseInitializationDependencyConfigurer.class, R2dbcInitializationConfiguration.class,
		DataSourceInitializationConfiguration.class })
@ConditionalOnProperty(prefix = 'spring.sql.init', name = 'enabled', matchIfMissing = true)
@Conditional(SqlInitializationModeCondition.class)
public class SqlInitializationAutoConfiguration {
	static class SqlInitializationModeCondition extends NoneNestedConditions {
		SqlInitializationModeCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty(prefix = 'spring.sql.init', name = 'mode', havingValue = 'never')
		static class ModeIsNever {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
class SqlInitializationScriptsRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		hints.resources().registerPattern('schema.sql').registerPattern('schema-*.sql');
		hints.resources().registerPattern('data.sql').registerPattern('data-*.sql');
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ ConnectionFactory.class, DatabasePopulator.class })
@ConditionalOnSingleCandidate(ConnectionFactory.class)
@ConditionalOnMissingBean({ SqlR2dbcScriptDatabaseInitializer.class, SqlDataSourceScriptDatabaseInitializer.class })
class R2dbcInitializationConfiguration {
	@Bean
	SqlR2dbcScriptDatabaseInitializer r2dbcScriptDatabaseInitializer(ConnectionFactory connectionFactory,
			SqlInitializationProperties properties) {
		return new SqlR2dbcScriptDatabaseInitializer(
				determineConnectionFactory(connectionFactory, properties.getUsername(), properties.getPassword()),
				properties);
	}
	private static ConnectionFactory determineConnectionFactory(ConnectionFactory connectionFactory, String username,
			String password) {
		if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
			return ConnectionFactoryBuilder.derivedFrom(connectionFactory)
				.username(username)
				.password(password)
				.build();
		}
		return connectionFactory;
	}
}
/*
/**
package org.springframework.boot.autoconfigure.sql.init;
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
@ImportRuntimeHints(SqlInitializationScriptsRuntimeHints.class)
public class SqlDataSourceScriptDatabaseInitializer extends DataSourceScriptDatabaseInitializer {
	/**
	 * Create a new {@link SqlDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the primary SQL data source
	 * @param properties the SQL initialization properties
	 * @see #getSettings
	 */
	public SqlDataSourceScriptDatabaseInitializer(DataSource dataSource, SqlInitializationProperties properties) {
		this(dataSource, getSettings(properties));
	}
	/**
	 * Create a new {@link SqlDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the primary SQL data source
	 * @param settings the database initialization settings
	 * @see #getSettings
	 */
	public SqlDataSourceScriptDatabaseInitializer(DataSource dataSource, DatabaseInitializationSettings settings) {
		super(dataSource, settings);
	}
	/**
	 * Adapts {@link SqlInitializationProperties SQL initialization properties} to
	 * {@link DatabaseInitializationSettings}.
	 * @param properties the SQL initialization properties
	 * @return a new {@link DatabaseInitializationSettings} instance
	 * @see #SqlDataSourceScriptDatabaseInitializer(DataSource,
	 * DatabaseInitializationSettings)
	 */
	public static DatabaseInitializationSettings getSettings(SqlInitializationProperties properties) {
		return SettingsCreator.createFrom(properties);
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
@Configuration(proxyBeanMethods = false)
@ConditionalOnMissingBean({ SqlDataSourceScriptDatabaseInitializer.class, SqlR2dbcScriptDatabaseInitializer.class })
@ConditionalOnSingleCandidate(DataSource.class)
@ConditionalOnClass(DatabasePopulator.class)
class DataSourceInitializationConfiguration {
	@Bean
	SqlDataSourceScriptDatabaseInitializer dataSourceScriptDatabaseInitializer(DataSource dataSource,
			SqlInitializationProperties properties) {
		return new SqlDataSourceScriptDatabaseInitializer(
				determineDataSource(dataSource, properties.getUsername(), properties.getPassword()), properties);
	}
	private static DataSource determineDataSource(DataSource dataSource, String username, String password) {
		if (StringUtils.hasText(username) && StringUtils.hasText(password)) {
			return DataSourceBuilder.derivedFrom(dataSource)
				.username(username)
				.password(password)
				.type(SimpleDriverDataSource.class)
				.build();
		}
		return dataSource;
	}
}
/*
package org.springframework.boot.autoconfigure.sql.init;
/**
public class OnDatabaseInitializationCondition extends SpringBootCondition {
	private final String name;
	private final String[] propertyNames;
	/**
	 * Create a new instance with the name of the component and the property names to
	 * check, in order. If a property is set, its value is used to determine the outcome
	 * and remaining properties are not tested.
	 * @param name the name of the component
	 * @param propertyNames the properties to check (in order)
	 */
	public OnDatabaseInitializationCondition(String name, String... propertyNames) {
		this.name = name;
		this.propertyNames = propertyNames;
	}
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		Environment environment = context.getEnvironment();
		String propertyName = getConfiguredProperty(environment);
		DatabaseInitializationMode mode = getDatabaseInitializationMode(environment, propertyName);
		boolean match = match(mode);
		String messagePrefix = (propertyName != null) ? propertyName : 'default value';
		return new ConditionOutcome(match, ConditionMessage.forCondition(this.name + 'Database Initialization')
			.because(messagePrefix + ' is ' + mode));
	}
	private boolean match(DatabaseInitializationMode mode) {
		return !mode.equals(DatabaseInitializationMode.NEVER);
	}
	private DatabaseInitializationMode getDatabaseInitializationMode(Environment environment, String propertyName) {
		if (StringUtils.hasText(propertyName)) {
			String candidate = environment.getProperty(propertyName, 'embedded').toUpperCase(Locale.ENGLISH);
			if (StringUtils.hasText(candidate)) {
				return DatabaseInitializationMode.valueOf(candidate);
			}
		}
		return DatabaseInitializationMode.EMBEDDED;
	}
	private String getConfiguredProperty(Environment environment) {
		for (String propertyName : this.propertyNames) {
			if (environment.containsProperty(propertyName)) {
				return propertyName;
			}
		}
		return null;
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
class AutoConfigurationSorter {
	private final MetadataReaderFactory metadataReaderFactory;
	private final AutoConfigurationMetadata autoConfigurationMetadata;
	private final UnaryOperator<String> replacementMapper;
	AutoConfigurationSorter(MetadataReaderFactory metadataReaderFactory,
			AutoConfigurationMetadata autoConfigurationMetadata, UnaryOperator<String> replacementMapper) {
		Assert.notNull(metadataReaderFactory, 'MetadataReaderFactory must not be null');
		this.metadataReaderFactory = metadataReaderFactory;
		this.autoConfigurationMetadata = autoConfigurationMetadata;
		this.replacementMapper = replacementMapper;
	}
	List<String> getInPriorityOrder(Collection<String> classNames) {
		// Initially sort alphabetically
		List<String> alphabeticallyOrderedClassNames = new ArrayList<>(classNames);
		Collections.sort(alphabeticallyOrderedClassNames);
		// Then sort by order
		AutoConfigurationClasses classes = new AutoConfigurationClasses(this.metadataReaderFactory,
				this.autoConfigurationMetadata, alphabeticallyOrderedClassNames);
		List<String> orderedClassNames = new ArrayList<>(classNames);
		Collections.sort(orderedClassNames);
		orderedClassNames.sort((o1, o2) -> {
			int i1 = classes.get(o1).getOrder();
			int i2 = classes.get(o2).getOrder();
			return Integer.compare(i1, i2);
		});
		// Then respect @AutoConfigureBefore @AutoConfigureAfter
		orderedClassNames = sortByAnnotation(classes, orderedClassNames);
		return orderedClassNames;
	}
	private List<String> sortByAnnotation(AutoConfigurationClasses classes, List<String> classNames) {
		List<String> toSort = new ArrayList<>(classNames);
		toSort.addAll(classes.getAllNames());
		Set<String> sorted = new LinkedHashSet<>();
		Set<String> processing = new LinkedHashSet<>();
		while (!toSort.isEmpty()) {
			doSortByAfterAnnotation(classes, toSort, sorted, processing, null);
		}
		sorted.retainAll(classNames);
		return new ArrayList<>(sorted);
	}
	private void doSortByAfterAnnotation(AutoConfigurationClasses classes, List<String> toSort, Set<String> sorted,
			Set<String> processing, String current) {
		if (current == null) {
			current = toSort.remove(0);
		}
		processing.add(current);
		Set<String> afters = new TreeSet<>(Comparator.comparing(toSort::indexOf));
		afters.addAll(classes.getClassesRequestedAfter(current));
		for (String after : afters) {
			checkForCycles(processing, current, after);
			if (!sorted.contains(after) && toSort.contains(after)) {
				doSortByAfterAnnotation(classes, toSort, sorted, processing, after);
			}
		}
		processing.remove(current);
		sorted.add(current);
	}
	private void checkForCycles(Set<String> processing, String current, String after) {
		Assert.state(!processing.contains(after),
				() -> 'AutoConfigure cycle detected between ' + current + ' and ' + after);
	}
	private class AutoConfigurationClasses {
		private final Map<String, AutoConfigurationClass> classes = new LinkedHashMap<>();
		AutoConfigurationClasses(MetadataReaderFactory metadataReaderFactory,
				AutoConfigurationMetadata autoConfigurationMetadata, Collection<String> classNames) {
			addToClasses(metadataReaderFactory, autoConfigurationMetadata, classNames, true);
		}
		Set<String> getAllNames() {
			return this.classes.keySet();
		}
		private void addToClasses(MetadataReaderFactory metadataReaderFactory,
				AutoConfigurationMetadata autoConfigurationMetadata, Collection<String> classNames, boolean required) {
			for (String className : classNames) {
				if (!this.classes.containsKey(className)) {
					AutoConfigurationClass autoConfigurationClass = new AutoConfigurationClass(className,
							metadataReaderFactory, autoConfigurationMetadata);
					boolean available = autoConfigurationClass.isAvailable();
					if (required || available) {
						this.classes.put(className, autoConfigurationClass);
					}
					if (available) {
						addToClasses(metadataReaderFactory, autoConfigurationMetadata,
								autoConfigurationClass.getBefore(), false);
						addToClasses(metadataReaderFactory, autoConfigurationMetadata,
								autoConfigurationClass.getAfter(), false);
					}
				}
			}
		}
		AutoConfigurationClass get(String className) {
			return this.classes.get(className);
		}
		Set<String> getClassesRequestedAfter(String className) {
			Set<String> classesRequestedAfter = new LinkedHashSet<>(get(className).getAfter());
			this.classes.forEach((name, autoConfigurationClass) -> {
				if (autoConfigurationClass.getBefore().contains(className)) {
					classesRequestedAfter.add(name);
				}
			});
			return classesRequestedAfter;
		}
	}
	private class AutoConfigurationClass {
		private final String className;
		private final MetadataReaderFactory metadataReaderFactory;
		private final AutoConfigurationMetadata autoConfigurationMetadata;
		private volatile AnnotationMetadata annotationMetadata;
		private volatile Set<String> before;
		private volatile Set<String> after;
		AutoConfigurationClass(String className, MetadataReaderFactory metadataReaderFactory,
				AutoConfigurationMetadata autoConfigurationMetadata) {
			this.className = className;
			this.metadataReaderFactory = metadataReaderFactory;
			this.autoConfigurationMetadata = autoConfigurationMetadata;
		}
		boolean isAvailable() {
			try {
				if (!wasProcessed()) {
					getAnnotationMetadata();
				}
				return true;
			}
			catch (Exception ex) {
				return false;
			}
		}
		Set<String> getBefore() {
			if (this.before == null) {
				this.before = getClassNames('AutoConfigureBefore', AutoConfigureBefore.class);
			}
			return this.before;
		}
		Set<String> getAfter() {
			if (this.after == null) {
				this.after = getClassNames('AutoConfigureAfter', AutoConfigureAfter.class);
			}
			return this.after;
		}
		private Set<String> getClassNames(String metadataKey, Class<? extends Annotation> annotation) {
			Set<String> annotationValue = wasProcessed()
					? this.autoConfigurationMetadata.getSet(this.className, metadataKey, Collections.emptySet())
					: getAnnotationValue(annotation);
			return applyReplacements(annotationValue);
		}
		private Set<String> applyReplacements(Set<String> values) {
			if (AutoConfigurationSorter.this.replacementMapper == null) {
				return values;
			}
			Set<String> replaced = new LinkedHashSet<>(values);
			for (String value : values) {
				replaced.add(AutoConfigurationSorter.this.replacementMapper.apply(value));
			}
			return replaced;
		}
		private int getOrder() {
			if (wasProcessed()) {
				return this.autoConfigurationMetadata.getInteger(this.className, 'AutoConfigureOrder',
						AutoConfigureOrder.DEFAULT_ORDER);
			}
			Map<String, Object> attributes = getAnnotationMetadata()
				.getAnnotationAttributes(AutoConfigureOrder.class.getName());
			return (attributes != null) ? (Integer) attributes.get('value') : AutoConfigureOrder.DEFAULT_ORDER;
		}
		private boolean wasProcessed() {
			return (this.autoConfigurationMetadata != null
					&& this.autoConfigurationMetadata.wasProcessed(this.className));
		}
		private Set<String> getAnnotationValue(Class<?> annotation) {
			Map<String, Object> attributes = getAnnotationMetadata().getAnnotationAttributes(annotation.getName(),
					true);
			if (attributes == null) {
				return Collections.emptySet();
			}
			Set<String> value = new LinkedHashSet<>();
			Collections.addAll(value, (String[]) attributes.get('value'));
			Collections.addAll(value, (String[]) attributes.get('name'));
			return value;
		}
		private AnnotationMetadata getAnnotationMetadata() {
			if (this.annotationMetadata == null) {
				try {
					MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(this.className);
					this.annotationMetadata = metadataReader.getAnnotationMetadata();
				}
				catch (IOException ex) {
					throw new IllegalStateException('Unable to read meta-data for class ' + this.className, ex);
				}
			}
			return this.annotationMetadata;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mail;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(Session.class)
@ConditionalOnProperty(prefix = 'spring.mail', name = 'jndi-name')
@ConditionalOnJndi
class MailSenderJndiConfiguration {
	private final MailProperties properties;
	MailSenderJndiConfiguration(MailProperties properties) {
		this.properties = properties;
	}
	@Bean
	JavaMailSenderImpl mailSender(Session session) {
		JavaMailSenderImpl sender = new JavaMailSenderImpl();
		sender.setDefaultEncoding(this.properties.getDefaultEncoding().name());
		sender.setSession(session);
		return sender;
	}
	@Bean
	@ConditionalOnMissingBean
	Session session() {
		String jndiName = this.properties.getJndiName();
		try {
			return JndiLocatorDelegate.createDefaultResourceRefLocator().lookup(jndiName, Session.class);
		}
		catch (NamingException ex) {
			throw new IllegalStateException(String.format('Unable to find Session in JNDI location %s', jndiName), ex);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mail;
/**
@AutoConfiguration(after = MailSenderAutoConfiguration.class)
@ConditionalOnProperty(prefix = 'spring.mail', value = 'test-connection')
@ConditionalOnSingleCandidate(JavaMailSenderImpl.class)
public class MailSenderValidatorAutoConfiguration {
	private final JavaMailSenderImpl mailSender;
	public MailSenderValidatorAutoConfiguration(JavaMailSenderImpl mailSender) {
		this.mailSender = mailSender;
		validateConnection();
	}
	public void validateConnection() {
		try {
			this.mailSender.testConnection();
		}
		catch (MessagingException ex) {
			throw new IllegalStateException('Mail server is not available', ex);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mail;
/**
@AutoConfiguration
@ConditionalOnClass({ MimeMessage.class, MimeType.class, MailSender.class })
@ConditionalOnMissingBean(MailSender.class)
@Conditional(MailSenderCondition.class)
@EnableConfigurationProperties(MailProperties.class)
@Import({ MailSenderJndiConfiguration.class, MailSenderPropertiesConfiguration.class })
public class MailSenderAutoConfiguration {
	/**
	 * Condition to trigger the creation of a {@link MailSender}. This kicks in if either
	 * the host or jndi name property is set.
	 */
	static class MailSenderCondition extends AnyNestedCondition {
		MailSenderCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnProperty(prefix = 'spring.mail', name = 'host')
		static class HostProperty {
		}
		@ConditionalOnProperty(prefix = 'spring.mail', name = 'jndi-name')
		static class JndiNameProperty {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.mail;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnProperty(prefix = 'spring.mail', name = 'host')
class MailSenderPropertiesConfiguration {
	@Bean
	@ConditionalOnMissingBean(JavaMailSender.class)
	JavaMailSenderImpl mailSender(MailProperties properties, ObjectProvider<SslBundles> sslBundles) {
		JavaMailSenderImpl sender = new JavaMailSenderImpl();
		applyProperties(properties, sender, sslBundles.getIfAvailable());
		return sender;
	}
	private void applyProperties(MailProperties properties, JavaMailSenderImpl sender, SslBundles sslBundles) {
		sender.setHost(properties.getHost());
		if (properties.getPort() != null) {
			sender.setPort(properties.getPort());
		}
		sender.setUsername(properties.getUsername());
		sender.setPassword(properties.getPassword());
		sender.setProtocol(properties.getProtocol());
		if (properties.getDefaultEncoding() != null) {
			sender.setDefaultEncoding(properties.getDefaultEncoding().name());
		}
		Properties javaMailProperties = asProperties(properties.getProperties());
		String protocol = properties.getProtocol();
		protocol = (!StringUtils.hasLength(protocol)) ? 'smtp' : protocol;
		Ssl ssl = properties.getSsl();
		if (ssl.isEnabled()) {
			javaMailProperties.setProperty('mail.' + protocol + '.ssl.enable', 'true');
		}
		if (ssl.getBundle() != null) {
			SslBundle sslBundle = sslBundles.getBundle(ssl.getBundle());
			javaMailProperties.put('mail.' + protocol + '.ssl.socketFactory',
					sslBundle.createSslContext().getSocketFactory());
		}
		if (!javaMailProperties.isEmpty()) {
			sender.setJavaMailProperties(javaMailProperties);
		}
	}
	private Properties asProperties(Map<String, String> source) {
		Properties properties = new Properties();
		properties.putAll(source);
		return properties;
	}
}
/*
package org.springframework.boot.autoconfigure.mail;
/**
@ConfigurationProperties(prefix = 'spring.mail')
public class MailProperties {
	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	/**
	 * SMTP server host. For instance, "smtp.example.com".
	 */
	private String host;
	/**
	 * SMTP server port.
	 */
	private Integer port;
	/**
	 * Login user of the SMTP server.
	 */
	private String username;
	/**
	 * Login password of the SMTP server.
	 */
	private String password;
	/**
	 * Protocol used by the SMTP server.
	 */
	private String protocol = 'smtp';
	/**
	 * Default MimeMessage encoding.
	 */
	private Charset defaultEncoding = DEFAULT_CHARSET;
	/**
	 * Additional JavaMail Session properties.
	 */
	private final Map<String, String> properties = new HashMap<>();
	/**
	 * Session JNDI name. When set, takes precedence over other Session settings.
	 */
	private String jndiName;
	/**
	 * SSL configuration.
	 */
	private final Ssl ssl = new Ssl();
	public String getHost() {
		return this.host;
	}
	public void setHost(String host) {
		this.host = host;
	}
	public Integer getPort() {
		return this.port;
	}
	public void setPort(Integer port) {
		this.port = port;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public String getProtocol() {
		return this.protocol;
	}
	public void setProtocol(String protocol) {
		this.protocol = protocol;
	}
	public Charset getDefaultEncoding() {
		return this.defaultEncoding;
	}
	public void setDefaultEncoding(Charset defaultEncoding) {
		this.defaultEncoding = defaultEncoding;
	}
	public Map<String, String> getProperties() {
		return this.properties;
	}
	public void setJndiName(String jndiName) {
		this.jndiName = jndiName;
	}
	public String getJndiName() {
		return this.jndiName;
	}
	public Ssl getSsl() {
		return this.ssl;
	}
	public static class Ssl {
		/**
		 * Whether to enable SSL support. If enabled, "mail.(protocol).ssl.enable"
		 * property is set to "true".
		 */
		private boolean enabled = false;
		/**
		 * SSL bundle name. If set, "mail.(protocol).ssl.socketFactory" property is set to
		 * an SSLSocketFactory obtained from the corresponding SSL bundle.
		 * <p>
		 * Note that the STARTTLS command can use the corresponding SSLSocketFactory, even
		 * if the "mail.(protocol).ssl.enable" property is not set.
		 */
		private String bundle;
		public boolean isEnabled() {
			return this.enabled;
		}
		public void setEnabled(boolean enabled) {
			this.enabled = enabled;
		}
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.mail;
/*
package org.springframework.boot.autoconfigure.h2;
/**
@AutoConfiguration(after = DataSourceAutoConfiguration.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass(JakartaWebServlet.class)
@ConditionalOnProperty(prefix = 'spring.h2.console', name = 'enabled', havingValue = 'true')
@EnableConfigurationProperties(H2ConsoleProperties.class)
public class H2ConsoleAutoConfiguration {
	private static final Log logger = LogFactory.getLog(H2ConsoleAutoConfiguration.class);
	@Bean
	public ServletRegistrationBean<JakartaWebServlet> h2Console(H2ConsoleProperties properties,
			ObjectProvider<DataSource> dataSource) {
		String path = properties.getPath();
		String urlMapping = path + (path.endsWith('/') ? '*' : '/*');
		ServletRegistrationBean<JakartaWebServlet> registration = new ServletRegistrationBean<>(new JakartaWebServlet(),
				urlMapping);
		configureH2ConsoleSettings(registration, properties.getSettings());
		if (logger.isInfoEnabled()) {
			withThreadContextClassLoader(getClass().getClassLoader(), () -> logDataSources(dataSource, path));
		}
		return registration;
	}
	private void withThreadContextClassLoader(ClassLoader classLoader, Runnable action) {
		ClassLoader previous = Thread.currentThread().getContextClassLoader();
		try {
			Thread.currentThread().setContextClassLoader(classLoader);
			action.run();
		}
		finally {
			Thread.currentThread().setContextClassLoader(previous);
		}
	}
	private void logDataSources(ObjectProvider<DataSource> dataSource, String path) {
		List<String> urls = dataSource.orderedStream().map(this::getConnectionUrl).filter(Objects::nonNull).toList();
		if (!urls.isEmpty()) {
			logger.info(LogMessage.format('H2 console available at "%s". %s available at %s', path,
					(urls.size() > 1) ? 'Databases' : 'Database', String.join(', ', urls)));
		}
	}
	private String getConnectionUrl(DataSource dataSource) {
		try (Connection connection = dataSource.getConnection()) {
			return '"' + connection.getMetaData().getURL() + '"';
		}
		catch (Exception ex) {
			return null;
		}
	}
	private void configureH2ConsoleSettings(ServletRegistrationBean<JakartaWebServlet> registration,
			Settings settings) {
		if (settings.isTrace()) {
			registration.addInitParameter('trace', '');
		}
		if (settings.isWebAllowOthers()) {
			registration.addInitParameter('webAllowOthers', '');
		}
		if (settings.getWebAdminPassword() != null) {
			registration.addInitParameter('webAdminPassword', settings.getWebAdminPassword());
		}
	}
}
/*
package org.springframework.boot.autoconfigure.h2;
/**
@ConfigurationProperties(prefix = 'spring.h2.console')
public class H2ConsoleProperties {
	/**
	 * Path at which the console is available.
	 */
	private String path = '/h2-console';
	/**
	 * Whether to enable the console.
	 */
	private boolean enabled = false;
	private final Settings settings = new Settings();
	public String getPath() {
		return this.path;
	}
	public void setPath(String path) {
		Assert.notNull(path, 'Path must not be null');
		Assert.isTrue(path.length() > 1, 'Path must have length greater than 1');
		Assert.isTrue(path.startsWith('/'), 'Path must start with "/"');
		this.path = path;
	}
	public boolean getEnabled() {
		return this.enabled;
	}
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public Settings getSettings() {
		return this.settings;
	}
	public static class Settings {
		/**
		 * Whether to enable trace output.
		 */
		private boolean trace = false;
		/**
		 * Whether to enable remote access.
		 */
		private boolean webAllowOthers = false;
		/**
		 * Password to access preferences and tools of H2 Console.
		 */
		private String webAdminPassword;
		public boolean isTrace() {
			return this.trace;
		}
		public void setTrace(boolean trace) {
			this.trace = trace;
		}
		public boolean isWebAllowOthers() {
			return this.webAllowOthers;
		}
		public void setWebAllowOthers(boolean webAllowOthers) {
			this.webAllowOthers = webAllowOthers;
		}
		public String getWebAdminPassword() {
			return this.webAdminPassword;
		}
		public void setWebAdminPassword(String webAdminPassword) {
			this.webAdminPassword = webAdminPassword;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.h2;
/*
package org.springframework.boot.autoconfigure.security;
/**
class DefaultWebSecurityCondition extends AllNestedConditions {
	DefaultWebSecurityCondition() {
		super(ConfigurationPhase.REGISTER_BEAN);
	}
	@ConditionalOnClass({ SecurityFilterChain.class, HttpSecurity.class })
	static class Classes {
	}
	@ConditionalOnMissingBean({ SecurityFilterChain.class })
	static class Beans {
	}
}
/*
package org.springframework.boot.autoconfigure.security;
/**
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(DefaultWebSecurityCondition.class)
public @interface ConditionalOnDefaultWebSecurity {
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
@ConfigurationProperties(prefix = 'spring.security.oauth2.authorizationserver')
public class OAuth2AuthorizationServerProperties implements InitializingBean {
	/**
	 * URL of the Authorization Server"s Issuer Identifier.
	 */
	private String issuer;
	/**
	 * Whether multiple issuers are allowed per host. Using path components in the URL of
	 * the issuer identifier enables supporting multiple issuers per host in a
	 * multi-tenant hosting configuration.
	 */
	private boolean multipleIssuersAllowed = false;
	/**
	 * Registered clients of the Authorization Server.
	 */
	private final Map<String, Client> client = new HashMap<>();
	/**
	 * Authorization Server endpoints.
	 */
	private final Endpoint endpoint = new Endpoint();
	public boolean isMultipleIssuersAllowed() {
		return this.multipleIssuersAllowed;
	}
	public void setMultipleIssuersAllowed(boolean multipleIssuersAllowed) {
		this.multipleIssuersAllowed = multipleIssuersAllowed;
	}
	public String getIssuer() {
		return this.issuer;
	}
	public void setIssuer(String issuer) {
		this.issuer = issuer;
	}
	public Map<String, Client> getClient() {
		return this.client;
	}
	public Endpoint getEndpoint() {
		return this.endpoint;
	}
	@Override
	public void afterPropertiesSet() {
		validate();
	}
	public void validate() {
		getClient().values().forEach(this::validateClient);
	}
	private void validateClient(Client client) {
		if (!StringUtils.hasText(client.getRegistration().getClientId())) {
			throw new IllegalStateException('Client id must not be empty.');
		}
		if (CollectionUtils.isEmpty(client.getRegistration().getClientAuthenticationMethods())) {
			throw new IllegalStateException('Client authentication methods must not be empty.');
		}
		if (CollectionUtils.isEmpty(client.getRegistration().getAuthorizationGrantTypes())) {
			throw new IllegalStateException('Authorization grant types must not be empty.');
		}
	}
	/**
	 * Authorization Server endpoints.
	 */
	public static class Endpoint {
		/**
		 * Authorization Server"s OAuth 2.0 Authorization Endpoint.
		 */
		private String authorizationUri = '/oauth2/authorize';
		/**
		 * Authorization Server"s OAuth 2.0 Device Authorization Endpoint.
		 */
		private String deviceAuthorizationUri = '/oauth2/device_authorization';
		/**
		 * Authorization Server"s OAuth 2.0 Device Verification Endpoint.
		 */
		private String deviceVerificationUri = '/oauth2/device_verification';
		/**
		 * Authorization Server"s OAuth 2.0 Token Endpoint.
		 */
		private String tokenUri = '/oauth2/token';
		/**
		 * Authorization Server"s JWK Set Endpoint.
		 */
		private String jwkSetUri = '/oauth2/jwks';
		/**
		 * Authorization Server"s OAuth 2.0 Token Revocation Endpoint.
		 */
		private String tokenRevocationUri = '/oauth2/revoke';
		/**
		 * Authorization Server"s OAuth 2.0 Token Introspection Endpoint.
		 */
		private String tokenIntrospectionUri = '/oauth2/introspect';
		/**
		 * OpenID Connect 1.0 endpoints.
		 */
		@NestedConfigurationProperty
		private final OidcEndpoint oidc = new OidcEndpoint();
		public String getAuthorizationUri() {
			return this.authorizationUri;
		}
		public void setAuthorizationUri(String authorizationUri) {
			this.authorizationUri = authorizationUri;
		}
		public String getDeviceAuthorizationUri() {
			return this.deviceAuthorizationUri;
		}
		public void setDeviceAuthorizationUri(String deviceAuthorizationUri) {
			this.deviceAuthorizationUri = deviceAuthorizationUri;
		}
		public String getDeviceVerificationUri() {
			return this.deviceVerificationUri;
		}
		public void setDeviceVerificationUri(String deviceVerificationUri) {
			this.deviceVerificationUri = deviceVerificationUri;
		}
		public String getTokenUri() {
			return this.tokenUri;
		}
		public void setTokenUri(String tokenUri) {
			this.tokenUri = tokenUri;
		}
		public String getJwkSetUri() {
			return this.jwkSetUri;
		}
		public void setJwkSetUri(String jwkSetUri) {
			this.jwkSetUri = jwkSetUri;
		}
		public String getTokenRevocationUri() {
			return this.tokenRevocationUri;
		}
		public void setTokenRevocationUri(String tokenRevocationUri) {
			this.tokenRevocationUri = tokenRevocationUri;
		}
		public String getTokenIntrospectionUri() {
			return this.tokenIntrospectionUri;
		}
		public void setTokenIntrospectionUri(String tokenIntrospectionUri) {
			this.tokenIntrospectionUri = tokenIntrospectionUri;
		}
		public OidcEndpoint getOidc() {
			return this.oidc;
		}
	}
	/**
	 * OpenID Connect 1.0 endpoints.
	 */
	public static class OidcEndpoint {
		/**
		 * Authorization Server"s OpenID Connect 1.0 Logout Endpoint.
		 */
		private String logoutUri = '/connect/logout';
		/**
		 * Authorization Server"s OpenID Connect 1.0 Client Registration Endpoint.
		 */
		private String clientRegistrationUri = '/connect/register';
		/**
		 * Authorization Server"s OpenID Connect 1.0 UserInfo Endpoint.
		 */
		private String userInfoUri = '/userinfo';
		public String getLogoutUri() {
			return this.logoutUri;
		}
		public void setLogoutUri(String logoutUri) {
			this.logoutUri = logoutUri;
		}
		public String getClientRegistrationUri() {
			return this.clientRegistrationUri;
		}
		public void setClientRegistrationUri(String clientRegistrationUri) {
			this.clientRegistrationUri = clientRegistrationUri;
		}
		public String getUserInfoUri() {
			return this.userInfoUri;
		}
		public void setUserInfoUri(String userInfoUri) {
			this.userInfoUri = userInfoUri;
		}
	}
	/**
	 * A registered client of the Authorization Server.
	 */
	public static class Client {
		/**
		 * Client registration information.
		 */
		@NestedConfigurationProperty
		private final Registration registration = new Registration();
		/**
		 * Whether the client is required to provide a proof key challenge and verifier
		 * when performing the Authorization Code Grant flow.
		 */
		private boolean requireProofKey = false;
		/**
		 * Whether authorization consent is required when the client requests access.
		 */
		private boolean requireAuthorizationConsent = false;
		/**
		 * URL for the client"s JSON Web Key Set.
		 */
		private String jwkSetUri;
		/**
		 * JWS algorithm that must be used for signing the JWT used to authenticate the
		 * client at the Token Endpoint for the {@code private_key_jwt} and
		 * {@code client_secret_jwt} authentication methods.
		 */
		private String tokenEndpointAuthenticationSigningAlgorithm;
		/**
		 * Token settings of the registered client.
		 */
		@NestedConfigurationProperty
		private final Token token = new Token();
		public Registration getRegistration() {
			return this.registration;
		}
		public boolean isRequireProofKey() {
			return this.requireProofKey;
		}
		public void setRequireProofKey(boolean requireProofKey) {
			this.requireProofKey = requireProofKey;
		}
		public boolean isRequireAuthorizationConsent() {
			return this.requireAuthorizationConsent;
		}
		public void setRequireAuthorizationConsent(boolean requireAuthorizationConsent) {
			this.requireAuthorizationConsent = requireAuthorizationConsent;
		}
		public String getJwkSetUri() {
			return this.jwkSetUri;
		}
		public void setJwkSetUri(String jwkSetUri) {
			this.jwkSetUri = jwkSetUri;
		}
		public String getTokenEndpointAuthenticationSigningAlgorithm() {
			return this.tokenEndpointAuthenticationSigningAlgorithm;
		}
		public void setTokenEndpointAuthenticationSigningAlgorithm(String tokenEndpointAuthenticationSigningAlgorithm) {
			this.tokenEndpointAuthenticationSigningAlgorithm = tokenEndpointAuthenticationSigningAlgorithm;
		}
		public Token getToken() {
			return this.token;
		}
	}
	/**
	 * Client registration information.
	 */
	public static class Registration {
		/**
		 * Client ID of the registration.
		 */
		private String clientId;
		/**
		 * Client secret of the registration. May be left blank for a public client.
		 */
		private String clientSecret;
		/**
		 * Name of the client.
		 */
		private String clientName;
		/**
		 * Client authentication method(s) that the client may use.
		 */
		private Set<String> clientAuthenticationMethods = new HashSet<>();
		/**
		 * Authorization grant type(s) that the client may use.
		 */
		private Set<String> authorizationGrantTypes = new HashSet<>();
		/**
		 * Redirect URI(s) that the client may use in redirect-based flows.
		 */
		private Set<String> redirectUris = new HashSet<>();
		/**
		 * Redirect URI(s) that the client may use for logout.
		 */
		private Set<String> postLogoutRedirectUris = new HashSet<>();
		/**
		 * Scope(s) that the client may use.
		 */
		private Set<String> scopes = new HashSet<>();
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public String getClientSecret() {
			return this.clientSecret;
		}
		public void setClientSecret(String clientSecret) {
			this.clientSecret = clientSecret;
		}
		public String getClientName() {
			return this.clientName;
		}
		public void setClientName(String clientName) {
			this.clientName = clientName;
		}
		public Set<String> getClientAuthenticationMethods() {
			return this.clientAuthenticationMethods;
		}
		public void setClientAuthenticationMethods(Set<String> clientAuthenticationMethods) {
			this.clientAuthenticationMethods = clientAuthenticationMethods;
		}
		public Set<String> getAuthorizationGrantTypes() {
			return this.authorizationGrantTypes;
		}
		public void setAuthorizationGrantTypes(Set<String> authorizationGrantTypes) {
			this.authorizationGrantTypes = authorizationGrantTypes;
		}
		public Set<String> getRedirectUris() {
			return this.redirectUris;
		}
		public void setRedirectUris(Set<String> redirectUris) {
			this.redirectUris = redirectUris;
		}
		public Set<String> getPostLogoutRedirectUris() {
			return this.postLogoutRedirectUris;
		}
		public void setPostLogoutRedirectUris(Set<String> postLogoutRedirectUris) {
			this.postLogoutRedirectUris = postLogoutRedirectUris;
		}
		public Set<String> getScopes() {
			return this.scopes;
		}
		public void setScopes(Set<String> scopes) {
			this.scopes = scopes;
		}
	}
	/**
	 * Token settings of the registered client.
	 */
	public static class Token {
		/**
		 * Time-to-live for an authorization code.
		 */
		private Duration authorizationCodeTimeToLive = Duration.ofMinutes(5);
		/**
		 * Time-to-live for an access token.
		 */
		private Duration accessTokenTimeToLive = Duration.ofMinutes(5);
		/**
		 * Token format for an access token.
		 */
		private String accessTokenFormat = 'self-contained';
		/**
		 * Time-to-live for a device code.
		 */
		private Duration deviceCodeTimeToLive = Duration.ofMinutes(5);
		/**
		 * Whether refresh tokens are reused or a new refresh token is issued when
		 * returning the access token response.
		 */
		private boolean reuseRefreshTokens = true;
		/**
		 * Time-to-live for a refresh token.
		 */
		private Duration refreshTokenTimeToLive = Duration.ofMinutes(60);
		/**
		 * JWS algorithm for signing the ID Token.
		 */
		private String idTokenSignatureAlgorithm = 'RS256';
		public Duration getAuthorizationCodeTimeToLive() {
			return this.authorizationCodeTimeToLive;
		}
		public void setAuthorizationCodeTimeToLive(Duration authorizationCodeTimeToLive) {
			this.authorizationCodeTimeToLive = authorizationCodeTimeToLive;
		}
		public Duration getAccessTokenTimeToLive() {
			return this.accessTokenTimeToLive;
		}
		public void setAccessTokenTimeToLive(Duration accessTokenTimeToLive) {
			this.accessTokenTimeToLive = accessTokenTimeToLive;
		}
		public String getAccessTokenFormat() {
			return this.accessTokenFormat;
		}
		public void setAccessTokenFormat(String accessTokenFormat) {
			this.accessTokenFormat = accessTokenFormat;
		}
		public Duration getDeviceCodeTimeToLive() {
			return this.deviceCodeTimeToLive;
		}
		public void setDeviceCodeTimeToLive(Duration deviceCodeTimeToLive) {
			this.deviceCodeTimeToLive = deviceCodeTimeToLive;
		}
		public boolean isReuseRefreshTokens() {
			return this.reuseRefreshTokens;
		}
		public void setReuseRefreshTokens(boolean reuseRefreshTokens) {
			this.reuseRefreshTokens = reuseRefreshTokens;
		}
		public Duration getRefreshTokenTimeToLive() {
			return this.refreshTokenTimeToLive;
		}
		public void setRefreshTokenTimeToLive(Duration refreshTokenTimeToLive) {
			this.refreshTokenTimeToLive = refreshTokenTimeToLive;
		}
		public String getIdTokenSignatureAlgorithm() {
			return this.idTokenSignatureAlgorithm;
		}
		public void setIdTokenSignatureAlgorithm(String idTokenSignatureAlgorithm) {
			this.idTokenSignatureAlgorithm = idTokenSignatureAlgorithm;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
@AutoConfiguration(after = UserDetailsServiceAutoConfiguration.class)
@ConditionalOnClass(OAuth2Authorization.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
public class OAuth2AuthorizationServerJwtAutoConfiguration {
	@Bean
	@ConditionalOnClass(JwtDecoder.class)
	@ConditionalOnMissingBean
	JwtDecoder jwtDecoder(JWKSource<SecurityContext> jwkSource) {
		return OAuth2AuthorizationServerConfiguration.jwtDecoder(jwkSource);
	}
	@Bean
	@Role(BeanDefinition.ROLE_INFRASTRUCTURE)
	@ConditionalOnMissingBean
	JWKSource<SecurityContext> jwkSource() {
		RSAKey rsaKey = getRsaKey();
		JWKSet jwkSet = new JWKSet(rsaKey);
		return new ImmutableJWKSet<>(jwkSet);
	}
	private static RSAKey getRsaKey() {
		KeyPair keyPair = generateRsaKey();
		RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic();
		RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate();
		RSAKey rsaKey = new RSAKey.Builder(publicKey).privateKey(privateKey)
			.keyID(UUID.randomUUID().toString())
			.build();
		return rsaKey;
	}
	private static KeyPair generateRsaKey() {
		KeyPair keyPair;
		try {
			KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance('RSA');
			keyPairGenerator.initialize(2048);
			keyPair = keyPairGenerator.generateKeyPair();
		}
		catch (Exception ex) {
			throw new IllegalStateException(ex);
		}
		return keyPair;
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnDefaultWebSecurity
@ConditionalOnBean({ RegisteredClientRepository.class, AuthorizationServerSettings.class })
class OAuth2AuthorizationServerWebSecurityConfiguration {
	@Bean
	@Order(Ordered.HIGHEST_PRECEDENCE)
	SecurityFilterChain authorizationServerSecurityFilterChain(HttpSecurity http) throws Exception {
		OAuth2AuthorizationServerConfigurer authorizationServer = OAuth2AuthorizationServerConfigurer
			.authorizationServer();
		http.securityMatcher(authorizationServer.getEndpointsMatcher());
		http.with(authorizationServer, withDefaults());
		http.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated());
		http.getConfigurer(OAuth2AuthorizationServerConfigurer.class).oidc(withDefaults());
		http.oauth2ResourceServer((resourceServer) -> resourceServer.jwt(withDefaults()));
		http.exceptionHandling((exceptions) -> exceptions.defaultAuthenticationEntryPointFor(
				new LoginUrlAuthenticationEntryPoint('/login'), createRequestMatcher()));
		return http.build();
	}
	@Bean
	@Order(SecurityProperties.BASIC_AUTH_ORDER)
	SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((authorize) -> authorize.anyRequest().authenticated()).formLogin(withDefaults());
		return http.build();
	}
	private static RequestMatcher createRequestMatcher() {
		MediaTypeRequestMatcher requestMatcher = new MediaTypeRequestMatcher(MediaType.TEXT_HTML);
		requestMatcher.setIgnoredMediaTypes(Set.of(MediaType.ALL));
		return requestMatcher;
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
@AutoConfiguration(before = { OAuth2ResourceServerAutoConfiguration.class, SecurityAutoConfiguration.class,
		UserDetailsServiceAutoConfiguration.class })
@ConditionalOnClass(OAuth2Authorization.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@Import({ OAuth2AuthorizationServerConfiguration.class, OAuth2AuthorizationServerWebSecurityConfiguration.class })
public class OAuth2AuthorizationServerAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(OAuth2AuthorizationServerProperties.class)
class OAuth2AuthorizationServerConfiguration {
	private final OAuth2AuthorizationServerPropertiesMapper propertiesMapper;
	OAuth2AuthorizationServerConfiguration(OAuth2AuthorizationServerProperties properties) {
		this.propertiesMapper = new OAuth2AuthorizationServerPropertiesMapper(properties);
	}
	@Bean
	@ConditionalOnMissingBean
	@Conditional(RegisteredClientsConfiguredCondition.class)
	RegisteredClientRepository registeredClientRepository() {
		return new InMemoryRegisteredClientRepository(this.propertiesMapper.asRegisteredClients());
	}
	@Bean
	@ConditionalOnMissingBean
	AuthorizationServerSettings authorizationServerSettings() {
		return this.propertiesMapper.asAuthorizationServerSettings();
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
class RegisteredClientsConfiguredCondition extends SpringBootCondition {
	private static final Bindable<Map<String, OAuth2AuthorizationServerProperties.Client>> STRING_CLIENT_MAP = Bindable
		.mapOf(String.class, OAuth2AuthorizationServerProperties.Client.class);
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage
			.forCondition('OAuth2 Registered Clients Configured Condition');
		Map<String, OAuth2AuthorizationServerProperties.Client> registrations = getRegistrations(
				context.getEnvironment());
		if (!registrations.isEmpty()) {
			return ConditionOutcome.match(message.foundExactly('registered clients ' + registrations.values()
				.stream()
				.map(OAuth2AuthorizationServerProperties.Client::getRegistration)
				.map(OAuth2AuthorizationServerProperties.Registration::getClientId)
				.collect(Collectors.joining(', '))));
		}
		return ConditionOutcome.noMatch(message.notAvailable('registered clients'));
	}
	private Map<String, OAuth2AuthorizationServerProperties.Client> getRegistrations(Environment environment) {
		return Binder.get(environment)
			.bind('spring.security.oauth2.authorizationserver.client', STRING_CLIENT_MAP)
			.orElse(Collections.emptyMap());
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.server.servlet;
/**
final class OAuth2AuthorizationServerPropertiesMapper {
	private final OAuth2AuthorizationServerProperties properties;
	OAuth2AuthorizationServerPropertiesMapper(OAuth2AuthorizationServerProperties properties) {
		this.properties = properties;
	}
	AuthorizationServerSettings asAuthorizationServerSettings() {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		OAuth2AuthorizationServerProperties.Endpoint endpoint = this.properties.getEndpoint();
		OAuth2AuthorizationServerProperties.OidcEndpoint oidc = endpoint.getOidc();
		AuthorizationServerSettings.Builder builder = AuthorizationServerSettings.builder();
		map.from(this.properties::getIssuer).to(builder::issuer);
		map.from(this.properties::isMultipleIssuersAllowed).to(builder::multipleIssuersAllowed);
		map.from(endpoint::getAuthorizationUri).to(builder::authorizationEndpoint);
		map.from(endpoint::getDeviceAuthorizationUri).to(builder::deviceAuthorizationEndpoint);
		map.from(endpoint::getDeviceVerificationUri).to(builder::deviceVerificationEndpoint);
		map.from(endpoint::getTokenUri).to(builder::tokenEndpoint);
		map.from(endpoint::getJwkSetUri).to(builder::jwkSetEndpoint);
		map.from(endpoint::getTokenRevocationUri).to(builder::tokenRevocationEndpoint);
		map.from(endpoint::getTokenIntrospectionUri).to(builder::tokenIntrospectionEndpoint);
		map.from(oidc::getLogoutUri).to(builder::oidcLogoutEndpoint);
		map.from(oidc::getClientRegistrationUri).to(builder::oidcClientRegistrationEndpoint);
		map.from(oidc::getUserInfoUri).to(builder::oidcUserInfoEndpoint);
		return builder.build();
	}
	List<RegisteredClient> asRegisteredClients() {
		List<RegisteredClient> registeredClients = new ArrayList<>();
		this.properties.getClient()
			.forEach((registrationId, client) -> registeredClients.add(getRegisteredClient(registrationId, client)));
		return registeredClients;
	}
	private RegisteredClient getRegisteredClient(String registrationId, Client client) {
		Registration registration = client.getRegistration();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		RegisteredClient.Builder builder = RegisteredClient.withId(registrationId);
		map.from(registration::getClientId).to(builder::clientId);
		map.from(registration::getClientSecret).to(builder::clientSecret);
		map.from(registration::getClientName).to(builder::clientName);
		registration.getClientAuthenticationMethods()
			.forEach((clientAuthenticationMethod) -> map.from(clientAuthenticationMethod)
				.as(ClientAuthenticationMethod::new)
				.to(builder::clientAuthenticationMethod));
		registration.getAuthorizationGrantTypes()
			.forEach((authorizationGrantType) -> map.from(authorizationGrantType)
				.as(AuthorizationGrantType::new)
				.to(builder::authorizationGrantType));
		registration.getRedirectUris().forEach((redirectUri) -> map.from(redirectUri).to(builder::redirectUri));
		registration.getPostLogoutRedirectUris()
			.forEach((redirectUri) -> map.from(redirectUri).to(builder::postLogoutRedirectUri));
		registration.getScopes().forEach((scope) -> map.from(scope).to(builder::scope));
		builder.clientSettings(getClientSettings(client, map));
		builder.tokenSettings(getTokenSettings(client, map));
		return builder.build();
	}
	private ClientSettings getClientSettings(Client client, PropertyMapper map) {
		ClientSettings.Builder builder = ClientSettings.builder();
		map.from(client::isRequireProofKey).to(builder::requireProofKey);
		map.from(client::isRequireAuthorizationConsent).to(builder::requireAuthorizationConsent);
		map.from(client::getJwkSetUri).to(builder::jwkSetUrl);
		map.from(client::getTokenEndpointAuthenticationSigningAlgorithm)
			.as(this::jwsAlgorithm)
			.to(builder::tokenEndpointAuthenticationSigningAlgorithm);
		return builder.build();
	}
	private TokenSettings getTokenSettings(Client client, PropertyMapper map) {
		OAuth2AuthorizationServerProperties.Token token = client.getToken();
		TokenSettings.Builder builder = TokenSettings.builder();
		map.from(token::getAuthorizationCodeTimeToLive).to(builder::authorizationCodeTimeToLive);
		map.from(token::getAccessTokenTimeToLive).to(builder::accessTokenTimeToLive);
		map.from(token::getAccessTokenFormat).as(OAuth2TokenFormat::new).to(builder::accessTokenFormat);
		map.from(token::getDeviceCodeTimeToLive).to(builder::deviceCodeTimeToLive);
		map.from(token::isReuseRefreshTokens).to(builder::reuseRefreshTokens);
		map.from(token::getRefreshTokenTimeToLive).to(builder::refreshTokenTimeToLive);
		map.from(token::getIdTokenSignatureAlgorithm)
			.as(this::signatureAlgorithm)
			.to(builder::idTokenSignatureAlgorithm);
		return builder.build();
	}
	private JwsAlgorithm jwsAlgorithm(String signingAlgorithm) {
		String name = signingAlgorithm.toUpperCase(Locale.ROOT);
		JwsAlgorithm jwsAlgorithm = SignatureAlgorithm.from(name);
		if (jwsAlgorithm == null) {
			jwsAlgorithm = MacAlgorithm.from(name);
		}
		return jwsAlgorithm;
	}
	private SignatureAlgorithm signatureAlgorithm(String signatureAlgorithm) {
		return SignatureAlgorithm.from(signatureAlgorithm.toUpperCase(Locale.ROOT));
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource;
/**
public class KeyValueCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('Public Key Value Condition');
		Environment environment = context.getEnvironment();
		String publicKeyLocation = environment
			.getProperty('spring.security.oauth2.resourceserver.jwt.public-key-location');
		if (!StringUtils.hasText(publicKeyLocation)) {
			return ConditionOutcome.noMatch(message.didNotFind('public-key-location property').atAll());
		}
		String issuerUri = environment.getProperty('spring.security.oauth2.resourceserver.jwt.issuer-uri');
		String jwkSetUri = environment.getProperty('spring.security.oauth2.resourceserver.jwt.jwk-set-uri');
		if (StringUtils.hasText(jwkSetUri)) {
			return ConditionOutcome.noMatch(message.found('jwk-set-uri property').items(jwkSetUri));
		}
		if (StringUtils.hasText(issuerUri)) {
			return ConditionOutcome.noMatch(message.found('issuer-uri property').items(issuerUri));
		}
		return ConditionOutcome.match(message.foundExactly('public key location property'));
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource;
/**
public class IssuerUriCondition extends SpringBootCondition {
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('OpenID Connect Issuer URI Condition');
		Environment environment = context.getEnvironment();
		String issuerUri = environment.getProperty('spring.security.oauth2.resourceserver.jwt.issuer-uri');
		String jwkSetUri = environment.getProperty('spring.security.oauth2.resourceserver.jwt.jwk-set-uri');
		if (!StringUtils.hasText(issuerUri)) {
			return ConditionOutcome.noMatch(message.didNotFind('issuer-uri property').atAll());
		}
		if (StringUtils.hasText(jwkSetUri)) {
			return ConditionOutcome.noMatch(message.found('jwk-set-uri property').items(jwkSetUri));
		}
		return ConditionOutcome.match(message.foundExactly('issuer-uri property'));
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.servlet;
/**
@Configuration(proxyBeanMethods = false)
class OAuth2ResourceServerOpaqueTokenConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(OpaqueTokenIntrospector.class)
	static class OpaqueTokenIntrospectionClientConfiguration {
		@Bean
		@ConditionalOnProperty(name = 'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri')
		SpringOpaqueTokenIntrospector opaqueTokenIntrospector(OAuth2ResourceServerProperties properties) {
			OAuth2ResourceServerProperties.Opaquetoken opaqueToken = properties.getOpaquetoken();
			return new SpringOpaqueTokenIntrospector(opaqueToken.getIntrospectionUri(), opaqueToken.getClientId(),
					opaqueToken.getClientSecret());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnDefaultWebSecurity
	static class OAuth2SecurityFilterChainConfiguration {
		@Bean
		@ConditionalOnBean(OpaqueTokenIntrospector.class)
		SecurityFilterChain opaqueTokenSecurityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
			http.oauth2ResourceServer((resourceServer) -> resourceServer.opaqueToken(withDefaults()));
			return http.build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.servlet;
/**
@AutoConfiguration(before = { SecurityAutoConfiguration.class, UserDetailsServiceAutoConfiguration.class })
@EnableConfigurationProperties(OAuth2ResourceServerProperties.class)
@ConditionalOnClass(BearerTokenAuthenticationToken.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@Import({ Oauth2ResourceServerConfiguration.JwtConfiguration.class,
		Oauth2ResourceServerConfiguration.OpaqueTokenConfiguration.class })
public class OAuth2ResourceServerAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.servlet;
/**
@Configuration(proxyBeanMethods = false)
class OAuth2ResourceServerJwtConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(JwtDecoder.class)
	static class JwtDecoderConfiguration {
		private final OAuth2ResourceServerProperties.Jwt properties;
		private final List<OAuth2TokenValidator<Jwt>> additionalValidators;
		JwtDecoderConfiguration(OAuth2ResourceServerProperties properties,
				ObjectProvider<OAuth2TokenValidator<Jwt>> additionalValidators) {
			this.properties = properties.getJwt();
			this.additionalValidators = additionalValidators.orderedStream().toList();
		}
		@Bean
		@ConditionalOnProperty(name = 'spring.security.oauth2.resourceserver.jwt.jwk-set-uri')
		JwtDecoder jwtDecoderByJwkKeySetUri(ObjectProvider<JwkSetUriJwtDecoderBuilderCustomizer> customizers) {
			JwkSetUriJwtDecoderBuilder builder = NimbusJwtDecoder.withJwkSetUri(this.properties.getJwkSetUri())
				.jwsAlgorithms(this::jwsAlgorithms);
			customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
			NimbusJwtDecoder nimbusJwtDecoder = builder.build();
			String issuerUri = this.properties.getIssuerUri();
			OAuth2TokenValidator<Jwt> defaultValidator = (issuerUri != null)
					? JwtValidators.createDefaultWithIssuer(issuerUri) : JwtValidators.createDefault();
			nimbusJwtDecoder.setJwtValidator(getValidators(defaultValidator));
			return nimbusJwtDecoder;
		}
		private void jwsAlgorithms(Set<SignatureAlgorithm> signatureAlgorithms) {
			for (String algorithm : this.properties.getJwsAlgorithms()) {
				signatureAlgorithms.add(SignatureAlgorithm.from(algorithm));
			}
		}
		private OAuth2TokenValidator<Jwt> getValidators(OAuth2TokenValidator<Jwt> defaultValidator) {
			List<String> audiences = this.properties.getAudiences();
			if (CollectionUtils.isEmpty(audiences) && this.additionalValidators.isEmpty()) {
				return defaultValidator;
			}
			List<OAuth2TokenValidator<Jwt>> validators = new ArrayList<>();
			validators.add(defaultValidator);
			if (!CollectionUtils.isEmpty(audiences)) {
				validators.add(new JwtClaimValidator<List<String>>(JwtClaimNames.AUD,
						(aud) -> aud != null && !Collections.disjoint(aud, audiences)));
			}
			validators.addAll(this.additionalValidators);
			return new DelegatingOAuth2TokenValidator<>(validators);
		}
		@Bean
		@Conditional(KeyValueCondition.class)
		JwtDecoder jwtDecoderByPublicKeyValue() throws Exception {
			RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance('RSA')
				.generatePublic(new X509EncodedKeySpec(getKeySpec(this.properties.readPublicKey())));
			NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withPublicKey(publicKey)
				.signatureAlgorithm(SignatureAlgorithm.from(exactlyOneAlgorithm()))
				.build();
			jwtDecoder.setJwtValidator(getValidators(JwtValidators.createDefault()));
			return jwtDecoder;
		}
		private byte[] getKeySpec(String keyValue) {
			keyValue = keyValue.replace('-----BEGIN PUBLIC KEY-----', '').replace('-----END PUBLIC KEY-----', '');
			return Base64.getMimeDecoder().decode(keyValue);
		}
		private String exactlyOneAlgorithm() {
			List<String> algorithms = this.properties.getJwsAlgorithms();
			int count = (algorithms != null) ? algorithms.size() : 0;
			if (count != 1) {
				throw new IllegalStateException(
						'Creating a JWT decoder using a public key requires exactly one JWS algorithm but ' + count
								+ ' were configured');
			}
			return algorithms.get(0);
		}
		@Bean
		@Conditional(IssuerUriCondition.class)
		SupplierJwtDecoder jwtDecoderByIssuerUri(ObjectProvider<JwkSetUriJwtDecoderBuilderCustomizer> customizers) {
			return new SupplierJwtDecoder(() -> {
				String issuerUri = this.properties.getIssuerUri();
				JwkSetUriJwtDecoderBuilder builder = NimbusJwtDecoder.withIssuerLocation(issuerUri);
				customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
				NimbusJwtDecoder jwtDecoder = builder.build();
				jwtDecoder.setJwtValidator(getValidators(JwtValidators.createDefaultWithIssuer(issuerUri)));
				return jwtDecoder;
			});
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnDefaultWebSecurity
	static class OAuth2SecurityFilterChainConfiguration {
		@Bean
		@ConditionalOnBean(JwtDecoder.class)
		SecurityFilterChain jwtSecurityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
			http.oauth2ResourceServer((resourceServer) -> resourceServer.jwt(withDefaults()));
			return http.build();
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(JwtAuthenticationConverter.class)
	@Conditional(JwtConverterPropertiesCondition.class)
	static class JwtConverterConfiguration {
		private final OAuth2ResourceServerProperties.Jwt properties;
		JwtConverterConfiguration(OAuth2ResourceServerProperties properties) {
			this.properties = properties.getJwt();
		}
		@Bean
		JwtAuthenticationConverter getJwtAuthenticationConverter() {
			JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(this.properties.getAuthorityPrefix()).to(grantedAuthoritiesConverter::setAuthorityPrefix);
			map.from(this.properties.getAuthoritiesClaimDelimiter())
				.to(grantedAuthoritiesConverter::setAuthoritiesClaimDelimiter);
			map.from(this.properties.getAuthoritiesClaimName())
				.to(grantedAuthoritiesConverter::setAuthoritiesClaimName);
			JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
			map.from(this.properties.getPrincipalClaimName()).to(jwtAuthenticationConverter::setPrincipalClaimName);
			jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
			return jwtAuthenticationConverter;
		}
	}
	private static class JwtConverterPropertiesCondition extends AnyNestedCondition {
		JwtConverterPropertiesCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnProperty(prefix = 'spring.security.oauth2.resourceserver.jwt', name = 'authority-prefix')
		static class OnAuthorityPrefix {
		}
		@ConditionalOnProperty(prefix = 'spring.security.oauth2.resourceserver.jwt', name = 'principal-claim-name')
		static class OnPrincipalClaimName {
		}
		@ConditionalOnProperty(prefix = 'spring.security.oauth2.resourceserver.jwt', name = 'authorities-claim-name')
		static class OnAuthoritiesClaimName {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.servlet;
/**
class Oauth2ResourceServerConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(JwtDecoder.class)
	@Import({ OAuth2ResourceServerJwtConfiguration.JwtConverterConfiguration.class,
			OAuth2ResourceServerJwtConfiguration.JwtDecoderConfiguration.class,
			OAuth2ResourceServerJwtConfiguration.OAuth2SecurityFilterChainConfiguration.class })
	static class JwtConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@Import({ OAuth2ResourceServerOpaqueTokenConfiguration.OpaqueTokenIntrospectionClientConfiguration.class,
			OAuth2ResourceServerOpaqueTokenConfiguration.OAuth2SecurityFilterChainConfiguration.class })
	static class OpaqueTokenConfiguration {
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.oauth2.resource.servlet;
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.servlet;
/**
@FunctionalInterface
public interface JwkSetUriJwtDecoderBuilderCustomizer {
	/**
	 * Customize the given {@code builder}.
	 * @param builder the {@code builder} to customize
	 */
	void customize(JwkSetUriJwtDecoderBuilder builder);
}
/*
/**
package org.springframework.boot.autoconfigure.security.oauth2.resource;
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource;
/**
@ConfigurationProperties(prefix = 'spring.security.oauth2.resourceserver')
public class OAuth2ResourceServerProperties {
	private final Jwt jwt = new Jwt();
	public Jwt getJwt() {
		return this.jwt;
	}
	private final Opaquetoken opaqueToken = new Opaquetoken();
	public Opaquetoken getOpaquetoken() {
		return this.opaqueToken;
	}
	public static class Jwt {
		/**
		 * JSON Web Key URI to use to verify the JWT token.
		 */
		private String jwkSetUri;
		/**
		 * JSON Web Algorithms used for verifying the digital signatures.
		 */
		private List<String> jwsAlgorithms = Arrays.asList('RS256');
		/**
		 * URI that can either be an OpenID Connect discovery endpoint or an OAuth 2.0
		 * Authorization Server Metadata endpoint defined by RFC 8414.
		 */
		private String issuerUri;
		/**
		 * Location of the file containing the public key used to verify a JWT.
		 */
		private Resource publicKeyLocation;
		/**
		 * Identifies the recipients that the JWT is intended for.
		 */
		private List<String> audiences = new ArrayList<>();
		/**
		 * Prefix to use for authorities mapped from JWT.
		 */
		private String authorityPrefix;
		/**
		 * Regex to use for splitting the value of the authorities claim into authorities.
		 */
		private String authoritiesClaimDelimiter;
		/**
		 * Name of token claim to use for mapping authorities from JWT.
		 */
		private String authoritiesClaimName;
		/**
		 * JWT principal claim name.
		 */
		private String principalClaimName;
		public String getJwkSetUri() {
			return this.jwkSetUri;
		}
		public void setJwkSetUri(String jwkSetUri) {
			this.jwkSetUri = jwkSetUri;
		}
		public List<String> getJwsAlgorithms() {
			return this.jwsAlgorithms;
		}
		public void setJwsAlgorithms(List<String> jwsAlgorithms) {
			this.jwsAlgorithms = jwsAlgorithms;
		}
		public String getIssuerUri() {
			return this.issuerUri;
		}
		public void setIssuerUri(String issuerUri) {
			this.issuerUri = issuerUri;
		}
		public Resource getPublicKeyLocation() {
			return this.publicKeyLocation;
		}
		public void setPublicKeyLocation(Resource publicKeyLocation) {
			this.publicKeyLocation = publicKeyLocation;
		}
		public List<String> getAudiences() {
			return this.audiences;
		}
		public void setAudiences(List<String> audiences) {
			this.audiences = audiences;
		}
		public String getAuthorityPrefix() {
			return this.authorityPrefix;
		}
		public void setAuthorityPrefix(String authorityPrefix) {
			this.authorityPrefix = authorityPrefix;
		}
		public String getAuthoritiesClaimDelimiter() {
			return this.authoritiesClaimDelimiter;
		}
		public void setAuthoritiesClaimDelimiter(String authoritiesClaimDelimiter) {
			this.authoritiesClaimDelimiter = authoritiesClaimDelimiter;
		}
		public String getAuthoritiesClaimName() {
			return this.authoritiesClaimName;
		}
		public void setAuthoritiesClaimName(String authoritiesClaimName) {
			this.authoritiesClaimName = authoritiesClaimName;
		}
		public String getPrincipalClaimName() {
			return this.principalClaimName;
		}
		public void setPrincipalClaimName(String principalClaimName) {
			this.principalClaimName = principalClaimName;
		}
		public String readPublicKey() throws IOException {
			String key = 'spring.security.oauth2.resourceserver.public-key-location';
			Assert.notNull(this.publicKeyLocation, 'PublicKeyLocation must not be null');
			if (!this.publicKeyLocation.exists()) {
				throw new InvalidConfigurationPropertyValueException(key, this.publicKeyLocation,
						'Public key location does not exist');
			}
			try (InputStream inputStream = this.publicKeyLocation.getInputStream()) {
				return StreamUtils.copyToString(inputStream, StandardCharsets.UTF_8);
			}
		}
	}
	public static class Opaquetoken {
		/**
		 * Client id used to authenticate with the token introspection endpoint.
		 */
		private String clientId;
		/**
		 * Client secret used to authenticate with the token introspection endpoint.
		 */
		private String clientSecret;
		/**
		 * OAuth 2.0 endpoint through which token introspection is accomplished.
		 */
		private String introspectionUri;
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public String getClientSecret() {
			return this.clientSecret;
		}
		public void setClientSecret(String clientSecret) {
			this.clientSecret = clientSecret;
		}
		public String getIntrospectionUri() {
			return this.introspectionUri;
		}
		public void setIntrospectionUri(String introspectionUri) {
			this.introspectionUri = introspectionUri;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.reactive;
/**
@AutoConfiguration(
		before = { ReactiveSecurityAutoConfiguration.class, ReactiveUserDetailsServiceAutoConfiguration.class })
@EnableConfigurationProperties(OAuth2ResourceServerProperties.class)
@ConditionalOnClass({ EnableWebFluxSecurity.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
@Import({ ReactiveOAuth2ResourceServerConfiguration.JwtConfiguration.class,
		ReactiveOAuth2ResourceServerConfiguration.OpaqueTokenConfiguration.class })
public class ReactiveOAuth2ResourceServerAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.reactive;
/**
class ReactiveOAuth2ResourceServerConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ BearerTokenAuthenticationToken.class, ReactiveJwtDecoder.class })
	@Import({ ReactiveOAuth2ResourceServerJwkConfiguration.JwtConfiguration.class,
			ReactiveOAuth2ResourceServerJwkConfiguration.JwtConverterConfiguration.class,
			ReactiveOAuth2ResourceServerJwkConfiguration.WebSecurityConfiguration.class })
	static class JwtConfiguration {
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass({ BearerTokenAuthenticationToken.class, ReactiveOpaqueTokenIntrospector.class })
	@Import({ ReactiveOAuth2ResourceServerOpaqueTokenConfiguration.OpaqueTokenIntrospectionClientConfiguration.class,
			ReactiveOAuth2ResourceServerOpaqueTokenConfiguration.WebSecurityConfiguration.class })
	static class OpaqueTokenConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.reactive;
/**
@FunctionalInterface
public interface JwkSetUriReactiveJwtDecoderBuilderCustomizer {
	/**
	 * Customize the given {@code builder}.
	 * @param builder the {@code builder} to customize
	 */
	void customize(JwkSetUriReactiveJwtDecoderBuilder builder);
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.reactive;
/**
class ReactiveOAuth2ResourceServerOpaqueTokenConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ReactiveOpaqueTokenIntrospector.class)
	static class OpaqueTokenIntrospectionClientConfiguration {
		@Bean
		@ConditionalOnProperty(name = 'spring.security.oauth2.resourceserver.opaquetoken.introspection-uri')
		SpringReactiveOpaqueTokenIntrospector opaqueTokenIntrospector(OAuth2ResourceServerProperties properties) {
			OAuth2ResourceServerProperties.Opaquetoken opaqueToken = properties.getOpaquetoken();
			return new SpringReactiveOpaqueTokenIntrospector(opaqueToken.getIntrospectionUri(),
					opaqueToken.getClientId(), opaqueToken.getClientSecret());
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(SecurityWebFilterChain.class)
	static class WebSecurityConfiguration {
		@Bean
		@ConditionalOnBean(ReactiveOpaqueTokenIntrospector.class)
		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated());
			http.oauth2ResourceServer((resourceServer) -> resourceServer.opaqueToken(withDefaults()));
			return http.build();
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.oauth2.resource.reactive;
/*
package org.springframework.boot.autoconfigure.security.oauth2.resource.reactive;
/**
@Configuration(proxyBeanMethods = false)
class ReactiveOAuth2ResourceServerJwkConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ReactiveJwtDecoder.class)
	static class JwtConfiguration {
		private final OAuth2ResourceServerProperties.Jwt properties;
		private final List<OAuth2TokenValidator<Jwt>> additionalValidators;
		JwtConfiguration(OAuth2ResourceServerProperties properties,
				ObjectProvider<OAuth2TokenValidator<Jwt>> additionalValidators) {
			this.properties = properties.getJwt();
			this.additionalValidators = additionalValidators.orderedStream().toList();
		}
		@Bean
		@ConditionalOnProperty(name = 'spring.security.oauth2.resourceserver.jwt.jwk-set-uri')
		ReactiveJwtDecoder jwtDecoder(ObjectProvider<JwkSetUriReactiveJwtDecoderBuilderCustomizer> customizers) {
			JwkSetUriReactiveJwtDecoderBuilder builder = NimbusReactiveJwtDecoder
				.withJwkSetUri(this.properties.getJwkSetUri())
				.jwsAlgorithms(this::jwsAlgorithms);
			customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
			NimbusReactiveJwtDecoder nimbusReactiveJwtDecoder = builder.build();
			String issuerUri = this.properties.getIssuerUri();
			OAuth2TokenValidator<Jwt> defaultValidator = (issuerUri != null)
					? JwtValidators.createDefaultWithIssuer(issuerUri) : JwtValidators.createDefault();
			nimbusReactiveJwtDecoder.setJwtValidator(getValidators(defaultValidator));
			return nimbusReactiveJwtDecoder;
		}
		private void jwsAlgorithms(Set<SignatureAlgorithm> signatureAlgorithms) {
			for (String algorithm : this.properties.getJwsAlgorithms()) {
				signatureAlgorithms.add(SignatureAlgorithm.from(algorithm));
			}
		}
		private OAuth2TokenValidator<Jwt> getValidators(OAuth2TokenValidator<Jwt> defaultValidator) {
			List<String> audiences = this.properties.getAudiences();
			if (CollectionUtils.isEmpty(audiences) && this.additionalValidators.isEmpty()) {
				return defaultValidator;
			}
			List<OAuth2TokenValidator<Jwt>> validators = new ArrayList<>();
			validators.add(defaultValidator);
			if (!CollectionUtils.isEmpty(audiences)) {
				validators.add(new JwtClaimValidator<List<String>>(JwtClaimNames.AUD,
						(aud) -> aud != null && !Collections.disjoint(aud, audiences)));
			}
			validators.addAll(this.additionalValidators);
			return new DelegatingOAuth2TokenValidator<>(validators);
		}
		@Bean
		@Conditional(KeyValueCondition.class)
		NimbusReactiveJwtDecoder jwtDecoderByPublicKeyValue() throws Exception {
			RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance('RSA')
				.generatePublic(new X509EncodedKeySpec(getKeySpec(this.properties.readPublicKey())));
			NimbusReactiveJwtDecoder jwtDecoder = NimbusReactiveJwtDecoder.withPublicKey(publicKey)
				.signatureAlgorithm(SignatureAlgorithm.from(exactlyOneAlgorithm()))
				.build();
			jwtDecoder.setJwtValidator(getValidators(JwtValidators.createDefault()));
			return jwtDecoder;
		}
		private byte[] getKeySpec(String keyValue) {
			keyValue = keyValue.replace('-----BEGIN PUBLIC KEY-----', '').replace('-----END PUBLIC KEY-----', '');
			return Base64.getMimeDecoder().decode(keyValue);
		}
		private String exactlyOneAlgorithm() {
			List<String> algorithms = this.properties.getJwsAlgorithms();
			int count = (algorithms != null) ? algorithms.size() : 0;
			if (count != 1) {
				throw new IllegalStateException(
						'Creating a JWT decoder using a public key requires exactly one JWS algorithm but ' + count
								+ ' were configured');
			}
			return algorithms.get(0);
		}
		@Bean
		@Conditional(IssuerUriCondition.class)
		SupplierReactiveJwtDecoder jwtDecoderByIssuerUri(
				ObjectProvider<JwkSetUriReactiveJwtDecoderBuilderCustomizer> customizers) {
			return new SupplierReactiveJwtDecoder(() -> {
				JwkSetUriReactiveJwtDecoderBuilder builder = NimbusReactiveJwtDecoder
					.withIssuerLocation(this.properties.getIssuerUri());
				customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
				NimbusReactiveJwtDecoder jwtDecoder = builder.build();
				jwtDecoder.setJwtValidator(
						getValidators(JwtValidators.createDefaultWithIssuer(this.properties.getIssuerUri())));
				return jwtDecoder;
			});
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(ReactiveJwtAuthenticationConverter.class)
	@Conditional(JwtConverterPropertiesCondition.class)
	static class JwtConverterConfiguration {
		private final OAuth2ResourceServerProperties.Jwt properties;
		JwtConverterConfiguration(OAuth2ResourceServerProperties properties) {
			this.properties = properties.getJwt();
		}
		@Bean
		ReactiveJwtAuthenticationConverter reactiveJwtAuthenticationConverter() {
			JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(this.properties.getAuthorityPrefix()).to(grantedAuthoritiesConverter::setAuthorityPrefix);
			map.from(this.properties.getAuthoritiesClaimDelimiter())
				.to(grantedAuthoritiesConverter::setAuthoritiesClaimDelimiter);
			map.from(this.properties.getAuthoritiesClaimName())
				.to(grantedAuthoritiesConverter::setAuthoritiesClaimName);
			ReactiveJwtAuthenticationConverter jwtAuthenticationConverter = new ReactiveJwtAuthenticationConverter();
			map.from(this.properties.getPrincipalClaimName()).to(jwtAuthenticationConverter::setPrincipalClaimName);
			jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(
					new ReactiveJwtGrantedAuthoritiesConverterAdapter(grantedAuthoritiesConverter));
			return jwtAuthenticationConverter;
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(SecurityWebFilterChain.class)
	static class WebSecurityConfiguration {
		@Bean
		@ConditionalOnBean(ReactiveJwtDecoder.class)
		SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http, ReactiveJwtDecoder jwtDecoder) {
			http.authorizeExchange((exchanges) -> exchanges.anyExchange().authenticated());
			http.oauth2ResourceServer((server) -> customDecoder(server, jwtDecoder));
			return http.build();
		}
		private void customDecoder(OAuth2ResourceServerSpec server, ReactiveJwtDecoder decoder) {
			server.jwt((jwt) -> jwt.jwtDecoder(decoder));
		}
	}
	private static class JwtConverterPropertiesCondition extends AnyNestedCondition {
		JwtConverterPropertiesCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnProperty(prefix = 'spring.security.oauth2.resourceserver.jwt', name = 'authority-prefix')
		static class OnAuthorityPrefix {
		}
		@ConditionalOnProperty(prefix = 'spring.security.oauth2.resourceserver.jwt', name = 'principal-claim-name')
		static class OnPrincipalClaimName {
		}
		@ConditionalOnProperty(prefix = 'spring.security.oauth2.resourceserver.jwt', name = 'authorities-claim-name')
		static class OnAuthoritiesClaimName {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client;
/**
@ConfigurationProperties(prefix = 'spring.security.oauth2.client')
public class OAuth2ClientProperties implements InitializingBean {
	/**
	 * OAuth provider details.
	 */
	private final Map<String, Provider> provider = new HashMap<>();
	/**
	 * OAuth client registrations.
	 */
	private final Map<String, Registration> registration = new HashMap<>();
	public Map<String, Provider> getProvider() {
		return this.provider;
	}
	public Map<String, Registration> getRegistration() {
		return this.registration;
	}
	@Override
	public void afterPropertiesSet() {
		validate();
	}
	public void validate() {
		getRegistration().forEach(this::validateRegistration);
	}
	private void validateRegistration(String id, Registration registration) {
		if (!StringUtils.hasText(registration.getClientId())) {
			throw new IllegalStateException('Client id of registration "%s" must not be empty.'.formatted(id));
		}
	}
	/**
	 * A single client registration.
	 */
	public static class Registration {
		/**
		 * Reference to the OAuth 2.0 provider to use. May reference an element from the
		 * "provider" property or used one of the commonly used providers (google, github,
		 * facebook, okta).
		 */
		private String provider;
		/**
		 * Client ID for the registration.
		 */
		private String clientId;
		/**
		 * Client secret of the registration.
		 */
		private String clientSecret;
		/**
		 * Client authentication method. May be left blank when using a pre-defined
		 * provider.
		 */
		private String clientAuthenticationMethod;
		/**
		 * Authorization grant type. May be left blank when using a pre-defined provider.
		 */
		private String authorizationGrantType;
		/**
		 * Redirect URI. May be left blank when using a pre-defined provider.
		 */
		private String redirectUri;
		/**
		 * Authorization scopes. When left blank the provider"s default scopes, if any,
		 * will be used.
		 */
		private Set<String> scope;
		/**
		 * Client name. May be left blank when using a pre-defined provider.
		 */
		private String clientName;
		public String getProvider() {
			return this.provider;
		}
		public void setProvider(String provider) {
			this.provider = provider;
		}
		public String getClientId() {
			return this.clientId;
		}
		public void setClientId(String clientId) {
			this.clientId = clientId;
		}
		public String getClientSecret() {
			return this.clientSecret;
		}
		public void setClientSecret(String clientSecret) {
			this.clientSecret = clientSecret;
		}
		public String getClientAuthenticationMethod() {
			return this.clientAuthenticationMethod;
		}
		public void setClientAuthenticationMethod(String clientAuthenticationMethod) {
			this.clientAuthenticationMethod = clientAuthenticationMethod;
		}
		public String getAuthorizationGrantType() {
			return this.authorizationGrantType;
		}
		public void setAuthorizationGrantType(String authorizationGrantType) {
			this.authorizationGrantType = authorizationGrantType;
		}
		public String getRedirectUri() {
			return this.redirectUri;
		}
		public void setRedirectUri(String redirectUri) {
			this.redirectUri = redirectUri;
		}
		public Set<String> getScope() {
			return this.scope;
		}
		public void setScope(Set<String> scope) {
			this.scope = scope;
		}
		public String getClientName() {
			return this.clientName;
		}
		public void setClientName(String clientName) {
			this.clientName = clientName;
		}
	}
	public static class Provider {
		/**
		 * Authorization URI for the provider.
		 */
		private String authorizationUri;
		/**
		 * Token URI for the provider.
		 */
		private String tokenUri;
		/**
		 * User info URI for the provider.
		 */
		private String userInfoUri;
		/**
		 * User info authentication method for the provider.
		 */
		private String userInfoAuthenticationMethod;
		/**
		 * Name of the attribute that will be used to extract the username from the call
		 * to "userInfoUri".
		 */
		private String userNameAttribute;
		/**
		 * JWK set URI for the provider.
		 */
		private String jwkSetUri;
		/**
		 * URI that can either be an OpenID Connect discovery endpoint or an OAuth 2.0
		 * Authorization Server Metadata endpoint defined by RFC 8414.
		 */
		private String issuerUri;
		public String getAuthorizationUri() {
			return this.authorizationUri;
		}
		public void setAuthorizationUri(String authorizationUri) {
			this.authorizationUri = authorizationUri;
		}
		public String getTokenUri() {
			return this.tokenUri;
		}
		public void setTokenUri(String tokenUri) {
			this.tokenUri = tokenUri;
		}
		public String getUserInfoUri() {
			return this.userInfoUri;
		}
		public void setUserInfoUri(String userInfoUri) {
			this.userInfoUri = userInfoUri;
		}
		public String getUserInfoAuthenticationMethod() {
			return this.userInfoAuthenticationMethod;
		}
		public void setUserInfoAuthenticationMethod(String userInfoAuthenticationMethod) {
			this.userInfoAuthenticationMethod = userInfoAuthenticationMethod;
		}
		public String getUserNameAttribute() {
			return this.userNameAttribute;
		}
		public void setUserNameAttribute(String userNameAttribute) {
			this.userNameAttribute = userNameAttribute;
		}
		public String getJwkSetUri() {
			return this.jwkSetUri;
		}
		public void setJwkSetUri(String jwkSetUri) {
			this.jwkSetUri = jwkSetUri;
		}
		public String getIssuerUri() {
			return this.issuerUri;
		}
		public void setIssuerUri(String issuerUri) {
			this.issuerUri = issuerUri;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client;
/**
public class ClientsConfiguredCondition extends SpringBootCondition {
	private static final Bindable<Map<String, OAuth2ClientProperties.Registration>> STRING_REGISTRATION_MAP = Bindable
		.mapOf(String.class, OAuth2ClientProperties.Registration.class);
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('OAuth2 Clients Configured Condition');
		Map<String, OAuth2ClientProperties.Registration> registrations = getRegistrations(context.getEnvironment());
		if (!registrations.isEmpty()) {
			return ConditionOutcome.match(message.foundExactly('registered clients ' + registrations.values()
				.stream()
				.map(OAuth2ClientProperties.Registration::getClientId)
				.collect(Collectors.joining(', '))));
		}
		return ConditionOutcome.noMatch(message.notAvailable('registered clients'));
	}
	private Map<String, OAuth2ClientProperties.Registration> getRegistrations(Environment environment) {
		return Binder.get(environment)
			.bind('spring.security.oauth2.client.registration', STRING_REGISTRATION_MAP)
			.orElse(Collections.emptyMap());
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.servlet;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean(ClientRegistrationRepository.class)
class OAuth2WebSecurityConfiguration {
	@Bean
	@ConditionalOnMissingBean
	OAuth2AuthorizedClientService authorizedClientService(ClientRegistrationRepository clientRegistrationRepository) {
		return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
	}
	@Bean
	@ConditionalOnMissingBean
	OAuth2AuthorizedClientRepository authorizedClientRepository(OAuth2AuthorizedClientService authorizedClientService) {
		return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnDefaultWebSecurity
	static class OAuth2SecurityFilterChainConfiguration {
		@Bean
		SecurityFilterChain oauth2SecurityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
			http.oauth2Login(withDefaults());
			http.oauth2Client(withDefaults());
			return http.build();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.servlet;
/**
@AutoConfiguration(before = SecurityAutoConfiguration.class)
@ConditionalOnClass({ EnableWebSecurity.class, ClientRegistration.class })
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@Import({ OAuth2ClientRegistrationRepositoryConfiguration.class, OAuth2WebSecurityConfiguration.class })
public class OAuth2ClientAutoConfiguration {
}
/*
/**
package org.springframework.boot.autoconfigure.security.oauth2.client.servlet;
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.servlet;
/**
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(OAuth2ClientProperties.class)
@Conditional(ClientsConfiguredCondition.class)
class OAuth2ClientRegistrationRepositoryConfiguration {
	@Bean
	@ConditionalOnMissingBean(ClientRegistrationRepository.class)
	InMemoryClientRegistrationRepository clientRegistrationRepository(OAuth2ClientProperties properties) {
		List<ClientRegistration> registrations = new ArrayList<>(
				new OAuth2ClientPropertiesMapper(properties).asClientRegistrations().values());
		return new InMemoryClientRegistrationRepository(registrations);
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.oauth2.client;
/*
package org.springframework.boot.autoconfigure.security.oauth2.client;
/**
public final class OAuth2ClientPropertiesMapper {
	private final OAuth2ClientProperties properties;
	/**
	 * Creates a new mapper for the given {@code properties}.
	 * @param properties the properties to map
	 */
	public OAuth2ClientPropertiesMapper(OAuth2ClientProperties properties) {
		this.properties = properties;
	}
	/**
	 * Maps the properties to {@link ClientRegistration ClientRegistrations}.
	 * @return the mapped {@code ClientRegistrations}
	 */
	public Map<String, ClientRegistration> asClientRegistrations() {
		Map<String, ClientRegistration> clientRegistrations = new HashMap<>();
		this.properties.getRegistration()
			.forEach((key, value) -> clientRegistrations.put(key,
					getClientRegistration(key, value, this.properties.getProvider())));
		return clientRegistrations;
	}
	private static ClientRegistration getClientRegistration(String registrationId,
			OAuth2ClientProperties.Registration properties, Map<String, Provider> providers) {
		Builder builder = getBuilderFromIssuerIfPossible(registrationId, properties.getProvider(), providers);
		if (builder == null) {
			builder = getBuilder(registrationId, properties.getProvider(), providers);
		}
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getClientId).to(builder::clientId);
		map.from(properties::getClientSecret).to(builder::clientSecret);
		map.from(properties::getClientAuthenticationMethod)
			.as(ClientAuthenticationMethod::new)
			.to(builder::clientAuthenticationMethod);
		map.from(properties::getAuthorizationGrantType)
			.as(AuthorizationGrantType::new)
			.to(builder::authorizationGrantType);
		map.from(properties::getRedirectUri).to(builder::redirectUri);
		map.from(properties::getScope).as(StringUtils::toStringArray).to(builder::scope);
		map.from(properties::getClientName).to(builder::clientName);
		return builder.build();
	}
	private static Builder getBuilderFromIssuerIfPossible(String registrationId, String configuredProviderId,
			Map<String, Provider> providers) {
		String providerId = (configuredProviderId != null) ? configuredProviderId : registrationId;
		if (providers.containsKey(providerId)) {
			Provider provider = providers.get(providerId);
			String issuer = provider.getIssuerUri();
			if (issuer != null) {
				Builder builder = ClientRegistrations.fromIssuerLocation(issuer).registrationId(registrationId);
				return getBuilder(builder, provider);
			}
		}
		return null;
	}
	private static Builder getBuilder(String registrationId, String configuredProviderId,
			Map<String, Provider> providers) {
		String providerId = (configuredProviderId != null) ? configuredProviderId : registrationId;
		CommonOAuth2Provider provider = getCommonProvider(providerId);
		if (provider == null && !providers.containsKey(providerId)) {
			throw new IllegalStateException(getErrorMessage(configuredProviderId, registrationId));
		}
		Builder builder = (provider != null) ? provider.getBuilder(registrationId)
				: ClientRegistration.withRegistrationId(registrationId);
		if (providers.containsKey(providerId)) {
			return getBuilder(builder, providers.get(providerId));
		}
		return builder;
	}
	private static String getErrorMessage(String configuredProviderId, String registrationId) {
		return ((configuredProviderId != null) ? 'Unknown provider ID "' + configuredProviderId + '"'
				: 'Provider ID must be specified for client registration "' + registrationId + '"');
	}
	private static Builder getBuilder(Builder builder, Provider provider) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(provider::getAuthorizationUri).to(builder::authorizationUri);
		map.from(provider::getTokenUri).to(builder::tokenUri);
		map.from(provider::getUserInfoUri).to(builder::userInfoUri);
		map.from(provider::getUserInfoAuthenticationMethod)
			.as(AuthenticationMethod::new)
			.to(builder::userInfoAuthenticationMethod);
		map.from(provider::getJwkSetUri).to(builder::jwkSetUri);
		map.from(provider::getUserNameAttribute).to(builder::userNameAttributeName);
		return builder;
	}
	private static CommonOAuth2Provider getCommonProvider(String providerId) {
		try {
			return ApplicationConversionService.getSharedInstance().convert(providerId, CommonOAuth2Provider.class);
		}
		catch (ConversionException ex) {
			return null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.reactive;
/**
@AutoConfiguration(before = ReactiveSecurityAutoConfiguration.class)
@EnableConfigurationProperties(OAuth2ClientProperties.class)
@Conditional(ReactiveOAuth2ClientAutoConfiguration.NonServletApplicationCondition.class)
@ConditionalOnClass({ Flux.class, EnableWebFluxSecurity.class, ClientRegistration.class })
@Import({ ReactiveOAuth2ClientConfigurations.ReactiveClientRegistrationRepositoryConfiguration.class,
		ReactiveOAuth2ClientConfigurations.ReactiveOAuth2ClientConfiguration.class })
public class ReactiveOAuth2ClientAutoConfiguration {
	static class NonServletApplicationCondition extends NoneNestedConditions {
		NonServletApplicationCondition() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
		static class ServletApplicationCondition {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.oauth2.client.reactive;
/**
class ReactiveOAuth2ClientConfigurations {
	@Configuration(proxyBeanMethods = false)
	@Conditional(ClientsConfiguredCondition.class)
	@ConditionalOnMissingBean(ReactiveClientRegistrationRepository.class)
	static class ReactiveClientRegistrationRepositoryConfiguration {
		@Bean
		InMemoryReactiveClientRegistrationRepository clientRegistrationRepository(OAuth2ClientProperties properties) {
			List<ClientRegistration> registrations = new ArrayList<>(
					new OAuth2ClientPropertiesMapper(properties).asClientRegistrations().values());
			return new InMemoryReactiveClientRegistrationRepository(registrations);
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnBean(ReactiveClientRegistrationRepository.class)
	static class ReactiveOAuth2ClientConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ReactiveOAuth2AuthorizedClientService authorizedClientService(
				ReactiveClientRegistrationRepository clientRegistrationRepository) {
			return new InMemoryReactiveOAuth2AuthorizedClientService(clientRegistrationRepository);
		}
		@Bean
		@ConditionalOnMissingBean
		ServerOAuth2AuthorizedClientRepository authorizedClientRepository(
				ReactiveOAuth2AuthorizedClientService authorizedClientService) {
			return new AuthenticatedPrincipalServerOAuth2AuthorizedClientRepository(authorizedClientService);
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
		static class SecurityWebFilterChainConfiguration {
			@Bean
			@ConditionalOnMissingBean
			SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
				http.authorizeExchange((exchange) -> exchange.anyExchange().authenticated());
				http.oauth2Login(withDefaults());
				http.oauth2Client(withDefaults());
				return http.build();
			}
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.oauth2.client.reactive;
/*
package org.springframework.boot.autoconfigure.security;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(SecurityEvaluationContextExtension.class)
public class SecurityDataConfiguration {
	@Bean
	@ConditionalOnMissingBean
	public SecurityEvaluationContextExtension securityEvaluationContextExtension() {
		return new SecurityEvaluationContextExtension();
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
@FunctionalInterface
public interface RequestMatcherProvider {
	/**
	 * Return the {@link RequestMatcher} to be used for the specified pattern.
	 * @param pattern the request pattern
	 * @return a request matcher
	 */
	RequestMatcher getRequestMatcher(String pattern);
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
public class AntPathRequestMatcherProvider implements RequestMatcherProvider {
	private final Function<String, String> pathFactory;
	public AntPathRequestMatcherProvider(Function<String, String> pathFactory) {
		this.pathFactory = pathFactory;
	}
	@Override
	public RequestMatcher getRequestMatcher(String pattern) {
		return new AntPathRequestMatcher(this.pathFactory.apply(pattern));
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
public final class PathRequest {
	private PathRequest() {
	}
	/**
	 * Returns a {@link StaticResourceRequest} that can be used to create a matcher for
	 * {@link StaticResourceLocation locations}.
	 * @return a {@link StaticResourceRequest}
	 */
	public static StaticResourceRequest toStaticResources() {
		return StaticResourceRequest.INSTANCE;
	}
	/**
	 * Returns a matcher that includes the H2 console location. For example:
	 * <pre class='code'>
	 * PathRequest.toH2Console()
	 * </pre>
	 * @return the configured {@link RequestMatcher}
	 */
	public static H2ConsoleRequestMatcher toH2Console() {
		return new H2ConsoleRequestMatcher();
	}
	/**
	 * The request matcher used to match against h2 console path.
	 */
	public static final class H2ConsoleRequestMatcher extends ApplicationContextRequestMatcher<H2ConsoleProperties> {
		private volatile RequestMatcher delegate;
		private H2ConsoleRequestMatcher() {
			super(H2ConsoleProperties.class);
		}
		@Override
		protected boolean ignoreApplicationContext(WebApplicationContext applicationContext) {
			return WebServerApplicationContext.hasServerNamespace(applicationContext, 'management');
		}
		@Override
		protected void initialized(Supplier<H2ConsoleProperties> h2ConsoleProperties) {
			this.delegate = new AntPathRequestMatcher(h2ConsoleProperties.get().getPath() + '/**');
		}
		@Override
		protected boolean matches(HttpServletRequest request, Supplier<H2ConsoleProperties> context) {
			return this.delegate.matches(request);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
@AutoConfiguration(after = SecurityAutoConfiguration.class)
@ConditionalOnWebApplication(type = Type.SERVLET)
@EnableConfigurationProperties(SecurityProperties.class)
@ConditionalOnClass({ AbstractSecurityWebApplicationInitializer.class, SessionCreationPolicy.class })
public class SecurityFilterAutoConfiguration {
	private static final String DEFAULT_FILTER_NAME = AbstractSecurityWebApplicationInitializer.DEFAULT_FILTER_NAME;
	@Bean
	@ConditionalOnBean(name = DEFAULT_FILTER_NAME)
	public DelegatingFilterProxyRegistrationBean securityFilterChainRegistration(
			SecurityProperties securityProperties) {
		DelegatingFilterProxyRegistrationBean registration = new DelegatingFilterProxyRegistrationBean(
				DEFAULT_FILTER_NAME);
		registration.setOrder(securityProperties.getFilter().getOrder());
		registration.setDispatcherTypes(getDispatcherTypes(securityProperties));
		return registration;
	}
	private EnumSet<DispatcherType> getDispatcherTypes(SecurityProperties securityProperties) {
		if (securityProperties.getFilter().getDispatcherTypes() == null) {
			return null;
		}
		return securityProperties.getFilter()
			.getDispatcherTypes()
			.stream()
			.map((type) -> DispatcherType.valueOf(type.name()))
			.collect(Collectors.toCollection(() -> EnumSet.noneOf(DispatcherType.class)));
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
@AutoConfiguration(before = UserDetailsServiceAutoConfiguration.class)
@ConditionalOnClass(DefaultAuthenticationEventPublisher.class)
@EnableConfigurationProperties(SecurityProperties.class)
@Import({ SpringBootWebSecurityConfiguration.class, SecurityDataConfiguration.class })
public class SecurityAutoConfiguration {
	@Bean
	@ConditionalOnMissingBean(AuthenticationEventPublisher.class)
	public DefaultAuthenticationEventPublisher authenticationEventPublisher(ApplicationEventPublisher publisher) {
		return new DefaultAuthenticationEventPublisher(publisher);
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
@AutoConfiguration
@ConditionalOnClass(AuthenticationManager.class)
@Conditional(MissingAlternativeOrUserPropertiesConfigured.class)
@ConditionalOnBean(ObjectPostProcessor.class)
@ConditionalOnMissingBean(value = { AuthenticationManager.class, AuthenticationProvider.class, UserDetailsService.class,
		AuthenticationManagerResolver.class }, type = 'org.springframework.security.oauth2.jwt.JwtDecoder')
public class UserDetailsServiceAutoConfiguration {
	private static final String NOOP_PASSWORD_PREFIX = '{noop}';
	private static final Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile('^\\{.+}.*$');
	private static final Log logger = LogFactory.getLog(UserDetailsServiceAutoConfiguration.class);
	@Bean
	public InMemoryUserDetailsManager inMemoryUserDetailsManager(SecurityProperties properties,
			ObjectProvider<PasswordEncoder> passwordEncoder) {
		SecurityProperties.User user = properties.getUser();
		List<String> roles = user.getRoles();
		return new InMemoryUserDetailsManager(User.withUsername(user.getName())
			.password(getOrDeducePassword(user, passwordEncoder.getIfAvailable()))
			.roles(StringUtils.toStringArray(roles))
			.build());
	}
	private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) {
		String password = user.getPassword();
		if (user.isPasswordGenerated()) {
			logger.warn(String.format(
					'%n%nUsing generated security password: %s%n%nThis generated password is for development use only. '
							+ 'Your security configuration must be updated before running your application in '
							+ 'production.%n',
					user.getPassword()));
		}
		if (encoder != null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) {
			return password;
		}
		return NOOP_PASSWORD_PREFIX + password;
	}
	static final class MissingAlternativeOrUserPropertiesConfigured extends AnyNestedCondition {
		MissingAlternativeOrUserPropertiesConfigured() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnMissingClass({
				'org.springframework.security.oauth2.client.registration.ClientRegistrationRepository',
				'org.springframework.security.oauth2.server.resource.introspection.OpaqueTokenIntrospector',
				'org.springframework.security.saml2.provider.service.registration.RelyingPartyRegistrationRepository' })
		static final class MissingAlternative {
		}
		@ConditionalOnProperty(prefix = 'spring.security.user', name = 'name')
		static final class NameConfigured {
		}
		@ConditionalOnProperty(prefix = 'spring.security.user', name = 'password')
		static final class PasswordConfigured {
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.servlet;
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnWebApplication(type = Type.SERVLET)
class SpringBootWebSecurityConfiguration {
	/**
	 * The default configuration for web security. It relies on Spring Security"s
	 * content-negotiation strategy to determine what sort of authentication to use. If
	 * the user specifies their own {@link SecurityFilterChain} bean, this will back-off
	 * completely and the users should specify all the bits that they want to configure as
	 * part of the custom security configuration.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnDefaultWebSecurity
	static class SecurityFilterChainConfiguration {
		@Bean
		@Order(SecurityProperties.BASIC_AUTH_ORDER)
		SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
			http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
			http.formLogin(withDefaults());
			http.httpBasic(withDefaults());
			return http.build();
		}
	}
	/**
	 * Adds the {@link EnableWebSecurity @EnableWebSecurity} annotation if Spring Security
	 * is on the classpath. This will make sure that the annotation is present with
	 * default security auto-configuration and also if the user adds custom security and
	 * forgets to add the annotation. If {@link EnableWebSecurity @EnableWebSecurity} has
	 * already been added or if a bean with name
	 * {@value BeanIds#SPRING_SECURITY_FILTER_CHAIN} has been configured by the user, this
	 * will back-off.
	 */
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnMissingBean(name = BeanIds.SPRING_SECURITY_FILTER_CHAIN)
	@ConditionalOnClass(EnableWebSecurity.class)
	@EnableWebSecurity
	static class WebSecurityEnablerConfiguration {
	}
}
/*
package org.springframework.boot.autoconfigure.security.servlet;
/**
public final class StaticResourceRequest {
	static final StaticResourceRequest INSTANCE = new StaticResourceRequest();
	private StaticResourceRequest() {
	}
	/**
	 * Returns a matcher that includes all commonly used {@link StaticResourceLocation
	 * Locations}. The
	 * {@link StaticResourceRequestMatcher#excluding(StaticResourceLocation, StaticResourceLocation...)
	 * excluding} method can be used to remove specific locations if required. For
	 * example: <pre class='code'>
	 * PathRequest.toStaticResources().atCommonLocations().excluding(StaticResourceLocation.CSS)
	 * </pre>
	 * @return the configured {@link RequestMatcher}
	 */
	public StaticResourceRequestMatcher atCommonLocations() {
		return at(EnumSet.allOf(StaticResourceLocation.class));
	}
	/**
	 * Returns a matcher that includes the specified {@link StaticResourceLocation
	 * Locations}. For example: <pre class='code'>
	 * PathRequest.toStaticResources().at(StaticResourceLocation.CSS, StaticResourceLocation.JAVA_SCRIPT)
	 * </pre>
	 * @param first the first location to include
	 * @param rest additional locations to include
	 * @return the configured {@link RequestMatcher}
	 */
	public StaticResourceRequestMatcher at(StaticResourceLocation first, StaticResourceLocation... rest) {
		return at(EnumSet.of(first, rest));
	}
	/**
	 * Returns a matcher that includes the specified {@link StaticResourceLocation
	 * Locations}. For example: <pre class='code'>
	 * PathRequest.toStaticResources().at(locations)
	 * </pre>
	 * @param locations the locations to include
	 * @return the configured {@link RequestMatcher}
	 */
	public StaticResourceRequestMatcher at(Set<StaticResourceLocation> locations) {
		Assert.notNull(locations, 'Locations must not be null');
		return new StaticResourceRequestMatcher(new LinkedHashSet<>(locations));
	}
	/**
	 * The request matcher used to match against resource {@link StaticResourceLocation
	 * Locations}.
	 */
	public static final class StaticResourceRequestMatcher
			extends ApplicationContextRequestMatcher<DispatcherServletPath> {
		private final Set<StaticResourceLocation> locations;
		private volatile RequestMatcher delegate;
		private StaticResourceRequestMatcher(Set<StaticResourceLocation> locations) {
			super(DispatcherServletPath.class);
			this.locations = locations;
		}
		/**
		 * Return a new {@link StaticResourceRequestMatcher} based on this one but
		 * excluding the specified locations.
		 * @param first the first location to exclude
		 * @param rest additional locations to exclude
		 * @return a new {@link StaticResourceRequestMatcher}
		 */
		public StaticResourceRequestMatcher excluding(StaticResourceLocation first, StaticResourceLocation... rest) {
			return excluding(EnumSet.of(first, rest));
		}
		/**
		 * Return a new {@link StaticResourceRequestMatcher} based on this one but
		 * excluding the specified locations.
		 * @param locations the locations to exclude
		 * @return a new {@link StaticResourceRequestMatcher}
		 */
		public StaticResourceRequestMatcher excluding(Set<StaticResourceLocation> locations) {
			Assert.notNull(locations, 'Locations must not be null');
			Set<StaticResourceLocation> subset = new LinkedHashSet<>(this.locations);
			subset.removeAll(locations);
			return new StaticResourceRequestMatcher(subset);
		}
		@Override
		protected void initialized(Supplier<DispatcherServletPath> dispatcherServletPath) {
			this.delegate = new OrRequestMatcher(getDelegateMatchers(dispatcherServletPath.get()).toList());
		}
		private Stream<RequestMatcher> getDelegateMatchers(DispatcherServletPath dispatcherServletPath) {
			return getPatterns(dispatcherServletPath).map(AntPathRequestMatcher::new);
		}
		private Stream<String> getPatterns(DispatcherServletPath dispatcherServletPath) {
			return this.locations.stream()
				.flatMap(StaticResourceLocation::getPatterns)
				.map(dispatcherServletPath::getRelativePath);
		}
		@Override
		protected boolean ignoreApplicationContext(WebApplicationContext applicationContext) {
			return WebServerApplicationContext.hasServerNamespace(applicationContext, 'management');
		}
		@Override
		protected boolean matches(HttpServletRequest request, Supplier<DispatcherServletPath> context) {
			return this.delegate.matches(request);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.saml2;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnDefaultWebSecurity
@ConditionalOnBean(RelyingPartyRegistrationRepository.class)
class Saml2LoginConfiguration {
	@Bean
	SecurityFilterChain samlSecurityFilterChain(HttpSecurity http) throws Exception {
		http.authorizeHttpRequests((requests) -> requests.anyRequest().authenticated());
		http.saml2Login(withDefaults());
		http.saml2Logout(withDefaults());
		return http.build();
	}
}
/*
package org.springframework.boot.autoconfigure.security.saml2;
/**
class RegistrationConfiguredCondition extends SpringBootCondition {
	private static final String PROPERTY = 'spring.security.saml2.relyingparty.registration';
	private static final Bindable<Map<String, Registration>> STRING_REGISTRATION_MAP = Bindable.mapOf(String.class,
			Registration.class);
	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ConditionMessage.Builder message = ConditionMessage.forCondition('Relying Party Registration Condition');
		Map<String, Registration> registrations = getRegistrations(context.getEnvironment());
		if (registrations.isEmpty()) {
			return ConditionOutcome.noMatch(message.didNotFind('any registrations').atAll());
		}
		return ConditionOutcome.match(message.found('registration', 'registrations').items(registrations.keySet()));
	}
	private Map<String, Registration> getRegistrations(Environment environment) {
		return Binder.get(environment).bind(PROPERTY, STRING_REGISTRATION_MAP).orElse(Collections.emptyMap());
	}
}
/*
package org.springframework.boot.autoconfigure.security.saml2;
/**
@AutoConfiguration(before = SecurityAutoConfiguration.class)
@ConditionalOnClass(RelyingPartyRegistrationRepository.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@Import({ Saml2RelyingPartyRegistrationConfiguration.class, Saml2LoginConfiguration.class })
@EnableConfigurationProperties(Saml2RelyingPartyProperties.class)
public class Saml2RelyingPartyAutoConfiguration {
}
/*
package org.springframework.boot.autoconfigure.security.saml2;
/**
@ConfigurationProperties('spring.security.saml2.relyingparty')
public class Saml2RelyingPartyProperties {
	/**
	 * SAML2 relying party registrations.
	 */
	private final Map<String, Registration> registration = new LinkedHashMap<>();
	public Map<String, Registration> getRegistration() {
		return this.registration;
	}
	/**
	 * Represents a SAML Relying Party.
	 */
	public static class Registration {
		/**
		 * Relying party"s entity ID. The value may contain a number of placeholders. They
		 * are 'baseUrl', 'registrationId', 'baseScheme', 'baseHost', and 'basePort'.
		 */
		private String entityId = '{baseUrl}/saml2/service-provider-metadata/{registrationId}';
		/**
		 * Assertion Consumer Service.
		 */
		private final Acs acs = new Acs();
		private final Signing signing = new Signing();
		private final Decryption decryption = new Decryption();
		private final Singlelogout singlelogout = new Singlelogout();
		/**
		 * Remote SAML Identity Provider.
		 */
		private final AssertingParty assertingparty = new AssertingParty();
		/**
		 * Name ID format for a relying party registration.
		 */
		private String nameIdFormat;
		public String getEntityId() {
			return this.entityId;
		}
		public void setEntityId(String entityId) {
			this.entityId = entityId;
		}
		public Acs getAcs() {
			return this.acs;
		}
		public Signing getSigning() {
			return this.signing;
		}
		public Decryption getDecryption() {
			return this.decryption;
		}
		public Singlelogout getSinglelogout() {
			return this.singlelogout;
		}
		public AssertingParty getAssertingparty() {
			return this.assertingparty;
		}
		public String getNameIdFormat() {
			return this.nameIdFormat;
		}
		public void setNameIdFormat(String nameIdFormat) {
			this.nameIdFormat = nameIdFormat;
		}
		public static class Acs {
			/**
			 * Assertion Consumer Service location template. Can generate its location
			 * based on possible variables of 'baseUrl', 'registrationId', 'baseScheme',
			 * 'baseHost', and 'basePort'.
			 */
			private String location = '{baseUrl}/login/saml2/sso/{registrationId}';
			/**
			 * Assertion Consumer Service binding.
			 */
			private Saml2MessageBinding binding = Saml2MessageBinding.POST;
			public String getLocation() {
				return this.location;
			}
			public void setLocation(String location) {
				this.location = location;
			}
			public Saml2MessageBinding getBinding() {
				return this.binding;
			}
			public void setBinding(Saml2MessageBinding binding) {
				this.binding = binding;
			}
		}
		public static class Signing {
			/**
			 * Credentials used for signing the SAML authentication request.
			 */
			private List<Credential> credentials = new ArrayList<>();
			public List<Credential> getCredentials() {
				return this.credentials;
			}
			public void setCredentials(List<Credential> credentials) {
				this.credentials = credentials;
			}
			public static class Credential {
				/**
				 * Private key used for signing.
				 */
				private Resource privateKeyLocation;
				/**
				 * Relying Party X509Certificate shared with the identity provider.
				 */
				private Resource certificateLocation;
				public Resource getPrivateKeyLocation() {
					return this.privateKeyLocation;
				}
				public void setPrivateKeyLocation(Resource privateKey) {
					this.privateKeyLocation = privateKey;
				}
				public Resource getCertificateLocation() {
					return this.certificateLocation;
				}
				public void setCertificateLocation(Resource certificate) {
					this.certificateLocation = certificate;
				}
			}
		}
	}
	public static class Decryption {
		/**
		 * Credentials used for decrypting the SAML authentication request.
		 */
		private List<Credential> credentials = new ArrayList<>();
		public List<Credential> getCredentials() {
			return this.credentials;
		}
		public void setCredentials(List<Credential> credentials) {
			this.credentials = credentials;
		}
		public static class Credential {
			/**
			 * Private key used for decrypting.
			 */
			private Resource privateKeyLocation;
			/**
			 * Relying Party X509Certificate shared with the identity provider.
			 */
			private Resource certificateLocation;
			public Resource getPrivateKeyLocation() {
				return this.privateKeyLocation;
			}
			public void setPrivateKeyLocation(Resource privateKey) {
				this.privateKeyLocation = privateKey;
			}
			public Resource getCertificateLocation() {
				return this.certificateLocation;
			}
			public void setCertificateLocation(Resource certificate) {
				this.certificateLocation = certificate;
			}
		}
	}
	/**
	 * Represents a remote Identity Provider.
	 */
	public static class AssertingParty {
		/**
		 * Unique identifier for the identity provider.
		 */
		private String entityId;
		/**
		 * URI to the metadata endpoint for discovery-based configuration.
		 */
		private String metadataUri;
		private final Singlesignon singlesignon = new Singlesignon();
		private final Verification verification = new Verification();
		private final Singlelogout singlelogout = new Singlelogout();
		public String getEntityId() {
			return this.entityId;
		}
		public void setEntityId(String entityId) {
			this.entityId = entityId;
		}
		public String getMetadataUri() {
			return this.metadataUri;
		}
		public void setMetadataUri(String metadataUri) {
			this.metadataUri = metadataUri;
		}
		public Singlesignon getSinglesignon() {
			return this.singlesignon;
		}
		public Verification getVerification() {
			return this.verification;
		}
		public Singlelogout getSinglelogout() {
			return this.singlelogout;
		}
		/**
		 * Single sign on details for an Identity Provider.
		 */
		public static class Singlesignon {
			/**
			 * Remote endpoint to send authentication requests to.
			 */
			private String url;
			/**
			 * Whether to redirect or post authentication requests.
			 */
			private Saml2MessageBinding binding;
			/**
			 * Whether to sign authentication requests.
			 */
			private Boolean signRequest;
			public String getUrl() {
				return this.url;
			}
			public void setUrl(String url) {
				this.url = url;
			}
			public Saml2MessageBinding getBinding() {
				return this.binding;
			}
			public void setBinding(Saml2MessageBinding binding) {
				this.binding = binding;
			}
			public boolean isSignRequest() {
				return this.signRequest;
			}
			public Boolean getSignRequest() {
				return this.signRequest;
			}
			public void setSignRequest(Boolean signRequest) {
				this.signRequest = signRequest;
			}
		}
		/**
		 * Verification details for an Identity Provider.
		 */
		public static class Verification {
			/**
			 * Credentials used for verification of incoming SAML messages.
			 */
			private List<Credential> credentials = new ArrayList<>();
			public List<Credential> getCredentials() {
				return this.credentials;
			}
			public void setCredentials(List<Credential> credentials) {
				this.credentials = credentials;
			}
			public static class Credential {
				/**
				 * Locations of the X.509 certificate used for verification of incoming
				 * SAML messages.
				 */
				private Resource certificate;
				public Resource getCertificateLocation() {
					return this.certificate;
				}
				public void setCertificateLocation(Resource certificate) {
					this.certificate = certificate;
				}
			}
		}
	}
	/**
	 * Single logout details.
	 */
	public static class Singlelogout {
		/**
		 * Location where SAML2 LogoutRequest gets sent to.
		 */
		private String url;
		/**
		 * Location where SAML2 LogoutResponse gets sent to.
		 */
		private String responseUrl;
		/**
		 * Whether to redirect or post logout requests.
		 */
		private Saml2MessageBinding binding;
		public String getUrl() {
			return this.url;
		}
		public void setUrl(String url) {
			this.url = url;
		}
		public String getResponseUrl() {
			return this.responseUrl;
		}
		public void setResponseUrl(String responseUrl) {
			this.responseUrl = responseUrl;
		}
		public Saml2MessageBinding getBinding() {
			return this.binding;
		}
		public void setBinding(Saml2MessageBinding binding) {
			this.binding = binding;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.saml2;
/**
@Configuration(proxyBeanMethods = false)
@Conditional(RegistrationConfiguredCondition.class)
@ConditionalOnMissingBean(RelyingPartyRegistrationRepository.class)
class Saml2RelyingPartyRegistrationConfiguration {
	@Bean
	RelyingPartyRegistrationRepository relyingPartyRegistrationRepository(Saml2RelyingPartyProperties properties) {
		List<RelyingPartyRegistration> registrations = properties.getRegistration()
			.entrySet()
			.stream()
			.map(this::asRegistration)
			.toList();
		return new InMemoryRelyingPartyRegistrationRepository(registrations);
	}
	private RelyingPartyRegistration asRegistration(Map.Entry<String, Registration> entry) {
		return asRegistration(entry.getKey(), entry.getValue());
	}
	private RelyingPartyRegistration asRegistration(String id, Registration properties) {
		boolean usingMetadata = StringUtils.hasText(properties.getAssertingparty().getMetadataUri());
		Builder builder = (!usingMetadata) ? RelyingPartyRegistration.withRegistrationId(id)
				: createBuilderUsingMetadata(properties.getAssertingparty()).registrationId(id);
		builder.assertionConsumerServiceLocation(properties.getAcs().getLocation());
		builder.assertionConsumerServiceBinding(properties.getAcs().getBinding());
		builder.assertingPartyMetadata(mapAssertingParty(properties.getAssertingparty()));
		builder.signingX509Credentials((credentials) -> properties.getSigning()
			.getCredentials()
			.stream()
			.map(this::asSigningCredential)
			.forEach(credentials::add));
		builder.decryptionX509Credentials((credentials) -> properties.getDecryption()
			.getCredentials()
			.stream()
			.map(this::asDecryptionCredential)
			.forEach(credentials::add));
		builder.assertingPartyMetadata(
				(details) -> details.verificationX509Credentials((credentials) -> properties.getAssertingparty()
					.getVerification()
					.getCredentials()
					.stream()
					.map(this::asVerificationCredential)
					.forEach(credentials::add)));
		builder.singleLogoutServiceLocation(properties.getSinglelogout().getUrl());
		builder.singleLogoutServiceResponseLocation(properties.getSinglelogout().getResponseUrl());
		builder.singleLogoutServiceBinding(properties.getSinglelogout().getBinding());
		builder.entityId(properties.getEntityId());
		builder.nameIdFormat(properties.getNameIdFormat());
		RelyingPartyRegistration registration = builder.build();
		boolean signRequest = registration.getAssertingPartyMetadata().getWantAuthnRequestsSigned();
		validateSigningCredentials(properties, signRequest);
		return registration;
	}
	private RelyingPartyRegistration.Builder createBuilderUsingMetadata(AssertingParty properties) {
		String requiredEntityId = properties.getEntityId();
		Collection<Builder> candidates = RelyingPartyRegistrations
			.collectionFromMetadataLocation(properties.getMetadataUri());
		for (RelyingPartyRegistration.Builder candidate : candidates) {
			if (requiredEntityId == null || requiredEntityId.equals(getEntityId(candidate))) {
				return candidate;
			}
		}
		throw new IllegalStateException('No relying party with Entity ID "' + requiredEntityId + '" found');
	}
	private Object getEntityId(RelyingPartyRegistration.Builder candidate) {
		String[] result = new String[1];
		candidate.assertingPartyMetadata((builder) -> result[0] = builder.build().getEntityId());
		return result[0];
	}
	private Consumer<AssertingPartyMetadata.Builder<?>> mapAssertingParty(AssertingParty assertingParty) {
		return (details) -> {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(assertingParty::getEntityId).to(details::entityId);
			map.from(assertingParty.getSinglesignon()::getBinding).to(details::singleSignOnServiceBinding);
			map.from(assertingParty.getSinglesignon()::getUrl).to(details::singleSignOnServiceLocation);
			map.from(assertingParty.getSinglesignon()::getSignRequest).to(details::wantAuthnRequestsSigned);
			map.from(assertingParty.getSinglelogout()::getUrl).to(details::singleLogoutServiceLocation);
			map.from(assertingParty.getSinglelogout()::getResponseUrl).to(details::singleLogoutServiceResponseLocation);
			map.from(assertingParty.getSinglelogout()::getBinding).to(details::singleLogoutServiceBinding);
		};
	}
	private void validateSigningCredentials(Registration properties, boolean signRequest) {
		if (signRequest) {
			Assert.state(!properties.getSigning().getCredentials().isEmpty(),
					'Signing credentials must not be empty when authentication requests require signing.');
		}
	}
	private Saml2X509Credential asSigningCredential(Signing.Credential properties) {
		RSAPrivateKey privateKey = readPrivateKey(properties.getPrivateKeyLocation());
		X509Certificate certificate = readCertificate(properties.getCertificateLocation());
		return new Saml2X509Credential(privateKey, certificate, Saml2X509CredentialType.SIGNING);
	}
	private Saml2X509Credential asDecryptionCredential(Decryption.Credential properties) {
		RSAPrivateKey privateKey = readPrivateKey(properties.getPrivateKeyLocation());
		X509Certificate certificate = readCertificate(properties.getCertificateLocation());
		return new Saml2X509Credential(privateKey, certificate, Saml2X509CredentialType.DECRYPTION);
	}
	private Saml2X509Credential asVerificationCredential(Verification.Credential properties) {
		X509Certificate certificate = readCertificate(properties.getCertificateLocation());
		return new Saml2X509Credential(certificate, Saml2X509Credential.Saml2X509CredentialType.ENCRYPTION,
				Saml2X509Credential.Saml2X509CredentialType.VERIFICATION);
	}
	private RSAPrivateKey readPrivateKey(Resource location) {
		Assert.state(location != null, 'No private key location specified');
		Assert.state(location.exists(), () -> 'Private key location "' + location + '" does not exist');
		try (InputStream inputStream = location.getInputStream()) {
			PemContent pemContent = PemContent.load(inputStream);
			PrivateKey privateKey = pemContent.getPrivateKey();
			Assert.isInstanceOf(RSAPrivateKey.class, privateKey,
					'PrivateKey in resource "' + location + '" must be an RSAPrivateKey');
			return (RSAPrivateKey) privateKey;
		}
		catch (Exception ex) {
			throw new IllegalArgumentException(ex);
		}
	}
	private X509Certificate readCertificate(Resource location) {
		Assert.state(location != null, 'No certificate location specified');
		Assert.state(location.exists(), () -> 'Certificate  location "' + location + '" does not exist');
		try (InputStream inputStream = location.getInputStream()) {
			PemContent pemContent = PemContent.load(inputStream);
			List<X509Certificate> certificates = pemContent.getCertificates();
			return certificates.get(0);
		}
		catch (Exception ex) {
			throw new IllegalArgumentException(ex);
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.saml2;
/*
package org.springframework.boot.autoconfigure.security;
/**
public enum StaticResourceLocation {
	/**
	 * Resources under {@code '/css'}.
	 */
	CSS('/css/**'),
	/**
	 * Resources under {@code '/js'}.
	 */
	JAVA_SCRIPT('/js/**'),
	/**
	 * Resources under {@code '/images'}.
	 */
	IMAGES('/images/**'),
	/**
	 * Resources under {@code '/webjars'}.
	 */
	WEB_JARS('/webjars/**'),
	/**
	 * The {@code 'favicon.ico'} resource.
	 */
	FAVICON('/favicon.*', '/*/icon-*');
	private final String[] patterns;
	StaticResourceLocation(String... patterns) {
		this.patterns = patterns;
	}
	public Stream<String> getPatterns() {
		return Arrays.stream(this.patterns);
	}
}
/*
package org.springframework.boot.autoconfigure.security.rsocket;
/**
@AutoConfiguration
@EnableRSocketSecurity
@ConditionalOnClass(SecuritySocketAcceptorInterceptor.class)
public class RSocketSecurityAutoConfiguration {
	@Bean
	RSocketServerCustomizer springSecurityRSocketSecurity(SecuritySocketAcceptorInterceptor interceptor) {
		return (server) -> server.interceptors((registry) -> registry.forSocketAcceptor(interceptor));
	}
	@ConditionalOnClass(AuthenticationPrincipalArgumentResolver.class)
	@Configuration(proxyBeanMethods = false)
	static class RSocketSecurityMessageHandlerConfiguration {
		@Bean
		RSocketMessageHandlerCustomizer rSocketAuthenticationPrincipalMessageHandlerCustomizer() {
			return (messageHandler) -> messageHandler.getArgumentResolverConfigurer()
				.addCustomResolver(new AuthenticationPrincipalArgumentResolver());
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.rsocket;
/*
/**
package org.springframework.boot.autoconfigure.security;
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
public final class PathRequest {
	private PathRequest() {
	}
	/**
	 * Returns a {@link StaticResourceRequest} that can be used to create a matcher for
	 * {@link StaticResourceLocation locations}.
	 * @return a {@link StaticResourceRequest}
	 */
	public static StaticResourceRequest toStaticResources() {
		return StaticResourceRequest.INSTANCE;
	}
}
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
@AutoConfiguration(before = ReactiveSecurityAutoConfiguration.class, after = RSocketMessagingAutoConfiguration.class)
@ConditionalOnClass({ ReactiveAuthenticationManager.class })
@ConditionalOnMissingBean(
		value = { ReactiveAuthenticationManager.class, ReactiveUserDetailsService.class,
				ReactiveAuthenticationManagerResolver.class },
		type = { 'org.springframework.security.oauth2.jwt.ReactiveJwtDecoder' })
@Conditional({ ReactiveUserDetailsServiceAutoConfiguration.RSocketEnabledOrReactiveWebApplication.class,
		ReactiveUserDetailsServiceAutoConfiguration.MissingAlternativeOrUserPropertiesConfigured.class })
@EnableConfigurationProperties(SecurityProperties.class)
public class ReactiveUserDetailsServiceAutoConfiguration {
	private static final String NOOP_PASSWORD_PREFIX = '{noop}';
	private static final Pattern PASSWORD_ALGORITHM_PATTERN = Pattern.compile('^\\{.+}.*$');
	private static final Log logger = LogFactory.getLog(ReactiveUserDetailsServiceAutoConfiguration.class);
	@Bean
	public MapReactiveUserDetailsService reactiveUserDetailsService(SecurityProperties properties,
			ObjectProvider<PasswordEncoder> passwordEncoder) {
		SecurityProperties.User user = properties.getUser();
		UserDetails userDetails = getUserDetails(user, getOrDeducePassword(user, passwordEncoder.getIfAvailable()));
		return new MapReactiveUserDetailsService(userDetails);
	}
	private UserDetails getUserDetails(SecurityProperties.User user, String password) {
		List<String> roles = user.getRoles();
		return User.withUsername(user.getName()).password(password).roles(StringUtils.toStringArray(roles)).build();
	}
	private String getOrDeducePassword(SecurityProperties.User user, PasswordEncoder encoder) {
		String password = user.getPassword();
		if (user.isPasswordGenerated()) {
			logger.info(String.format('%n%nUsing generated security password: %s%n', user.getPassword()));
		}
		if (encoder != null || PASSWORD_ALGORITHM_PATTERN.matcher(password).matches()) {
			return password;
		}
		return NOOP_PASSWORD_PREFIX + password;
	}
	static class RSocketEnabledOrReactiveWebApplication extends AnyNestedCondition {
		RSocketEnabledOrReactiveWebApplication() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnBean(RSocketMessageHandler.class)
		static class RSocketSecurityEnabledCondition {
		}
		@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
		static class ReactiveWebApplicationCondition {
		}
	}
	static final class MissingAlternativeOrUserPropertiesConfigured extends AnyNestedCondition {
		MissingAlternativeOrUserPropertiesConfigured() {
			super(ConfigurationPhase.PARSE_CONFIGURATION);
		}
		@ConditionalOnMissingClass({
				'org.springframework.security.oauth2.client.registration.ClientRegistrationRepository',
				'org.springframework.security.oauth2.server.resource.introspection.ReactiveOpaqueTokenIntrospector' })
		static final class MissingAlternative {
		}
		@ConditionalOnProperty(prefix = 'spring.security.user', name = 'name')
		static final class NameConfigured {
		}
		@ConditionalOnProperty(prefix = 'spring.security.user', name = 'password')
		static final class PasswordConfigured {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
@AutoConfiguration
@EnableConfigurationProperties(SecurityProperties.class)
@ConditionalOnClass({ Flux.class, EnableWebFluxSecurity.class, WebFilterChainProxy.class, WebFluxConfigurer.class })
public class ReactiveSecurityAutoConfiguration {
	@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.REACTIVE)
	@Configuration(proxyBeanMethods = false)
	class SpringBootWebFluxSecurityConfiguration {
		@Bean
		@ConditionalOnMissingBean({ ReactiveAuthenticationManager.class, ReactiveUserDetailsService.class,
				SecurityWebFilterChain.class })
		ReactiveAuthenticationManager denyAllAuthenticationManager() {
			return (authentication) -> Mono.error(new UsernameNotFoundException(authentication.getName()));
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnMissingBean(WebFilterChainProxy.class)
		@EnableWebFluxSecurity
		static class EnableWebFluxSecurityConfiguration {
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.security.reactive;
/*
package org.springframework.boot.autoconfigure.security.reactive;
/**
public final class StaticResourceRequest {
	static final StaticResourceRequest INSTANCE = new StaticResourceRequest();
	private StaticResourceRequest() {
	}
	/**
	 * Returns a matcher that includes all commonly used {@link StaticResourceLocation
	 * Locations}. The
	 * {@link StaticResourceServerWebExchange#excluding(StaticResourceLocation, StaticResourceLocation...)
	 * excluding} method can be used to remove specific locations if required. For
	 * example: <pre class='code'>
	 * PathRequest.toStaticResources().atCommonLocations().excluding(StaticResourceLocation.CSS)
	 * </pre>
	 * @return the configured {@link ServerWebExchangeMatcher}
	 */
	public StaticResourceServerWebExchange atCommonLocations() {
		return at(EnumSet.allOf(StaticResourceLocation.class));
	}
	/**
	 * Returns a matcher that includes the specified {@link StaticResourceLocation
	 * Locations}. For example: <pre class='code'>
	 * PathRequest.toStaticResources().at(StaticResourceLocation.CSS, StaticResourceLocation.JAVA_SCRIPT)
	 * </pre>
	 * @param first the first location to include
	 * @param rest additional locations to include
	 * @return the configured {@link ServerWebExchangeMatcher}
	 */
	public StaticResourceServerWebExchange at(StaticResourceLocation first, StaticResourceLocation... rest) {
		return at(EnumSet.of(first, rest));
	}
	/**
	 * Returns a matcher that includes the specified {@link StaticResourceLocation
	 * Locations}. For example: <pre class='code'>
	 * PathRequest.toStaticResources().at(locations)
	 * </pre>
	 * @param locations the locations to include
	 * @return the configured {@link ServerWebExchangeMatcher}
	 */
	public StaticResourceServerWebExchange at(Set<StaticResourceLocation> locations) {
		Assert.notNull(locations, 'Locations must not be null');
		return new StaticResourceServerWebExchange(new LinkedHashSet<>(locations));
	}
	/**
	 * The server web exchange matcher used to match against resource
	 * {@link StaticResourceLocation locations}.
	 */
	public static final class StaticResourceServerWebExchange implements ServerWebExchangeMatcher {
		private final Set<StaticResourceLocation> locations;
		private StaticResourceServerWebExchange(Set<StaticResourceLocation> locations) {
			this.locations = locations;
		}
		/**
		 * Return a new {@link StaticResourceServerWebExchange} based on this one but
		 * excluding the specified locations.
		 * @param first the first location to exclude
		 * @param rest additional locations to exclude
		 * @return a new {@link StaticResourceServerWebExchange}
		 */
		public StaticResourceServerWebExchange excluding(StaticResourceLocation first, StaticResourceLocation... rest) {
			return excluding(EnumSet.of(first, rest));
		}
		/**
		 * Return a new {@link StaticResourceServerWebExchange} based on this one but
		 * excluding the specified locations.
		 * @param locations the locations to exclude
		 * @return a new {@link StaticResourceServerWebExchange}
		 */
		public StaticResourceServerWebExchange excluding(Set<StaticResourceLocation> locations) {
			Assert.notNull(locations, 'Locations must not be null');
			Set<StaticResourceLocation> subset = new LinkedHashSet<>(this.locations);
			subset.removeAll(locations);
			return new StaticResourceServerWebExchange(subset);
		}
		private Stream<String> getPatterns() {
			return this.locations.stream().flatMap(StaticResourceLocation::getPatterns);
		}
		@Override
		public Mono<MatchResult> matches(ServerWebExchange exchange) {
			return new OrServerWebExchangeMatcher(getDelegateMatchers().toList()).matches(exchange);
		}
		private Stream<ServerWebExchangeMatcher> getDelegateMatchers() {
			return getPatterns().map(PathPatternParserServerWebExchangeMatcher::new);
		}
	}
}
/*
package org.springframework.boot.autoconfigure.security;
/**
@ConfigurationProperties(prefix = 'spring.security')
public class SecurityProperties {
	/**
	 * Order applied to the {@code SecurityFilterChain} that is used to configure basic
	 * authentication for application endpoints. Create your own
	 * {@code SecurityFilterChain} if you want to add your own authentication for all or
	 * some of those endpoints.
	 */
	public static final int BASIC_AUTH_ORDER = Ordered.LOWEST_PRECEDENCE - 5;
	/**
	 * Order applied to the {@code WebSecurityCustomizer} that ignores standard static
	 * resource paths.
	 */
	public static final int IGNORED_ORDER = Ordered.HIGHEST_PRECEDENCE;
	/**
	 * Default order of Spring Security"s Filter in the servlet container (i.e. amongst
	 * other filters registered with the container). There is no connection between this
	 * and the {@code @Order} on a {@code SecurityFilterChain}.
	 */
	public static final int DEFAULT_FILTER_ORDER = OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER - 100;
	private final Filter filter = new Filter();
	private final User user = new User();
	public User getUser() {
		return this.user;
	}
	public Filter getFilter() {
		return this.filter;
	}
	public static class Filter {
		/**
		 * Security filter chain order for Servlet-based web applications.
		 */
		private int order = DEFAULT_FILTER_ORDER;
		/**
		 * Security filter chain dispatcher types for Servlet-based web applications.
		 */
		private Set<DispatcherType> dispatcherTypes = EnumSet.allOf(DispatcherType.class);
		public int getOrder() {
			return this.order;
		}
		public void setOrder(int order) {
			this.order = order;
		}
		public Set<DispatcherType> getDispatcherTypes() {
			return this.dispatcherTypes;
		}
		public void setDispatcherTypes(Set<DispatcherType> dispatcherTypes) {
			this.dispatcherTypes = dispatcherTypes;
		}
	}
	public static class User {
		/**
		 * Default user name.
		 */
		private String name = 'user';
		/**
		 * Password for the default user name.
		 */
		private String password = UUID.randomUUID().toString();
		/**
		 * Granted roles for the default user name.
		 */
		private List<String> roles = new ArrayList<>();
		private boolean passwordGenerated = true;
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public String getPassword() {
			return this.password;
		}
		public void setPassword(String password) {
			if (!StringUtils.hasLength(password)) {
				return;
			}
			this.passwordGenerated = false;
			this.password = password;
		}
		public List<String> getRoles() {
			return this.roles;
		}
		public void setRoles(List<String> roles) {
			this.roles = new ArrayList<>(roles);
		}
		public boolean isPasswordGenerated() {
			return this.passwordGenerated;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.reactor;
/**
@ConfigurationProperties(prefix = 'spring.reactor')
public class ReactorProperties {
	/**
	 * Context Propagation support mode for Reactor operators.
	 */
	private ContextPropagationMode contextPropagation = ContextPropagationMode.LIMITED;
	public ContextPropagationMode getContextPropagation() {
		return this.contextPropagation;
	}
	public void setContextPropagation(ContextPropagationMode contextPropagation) {
		this.contextPropagation = contextPropagation;
	}
	public enum ContextPropagationMode {
		/**
		 * Context Propagation is applied to all Reactor operators.
		 */
		AUTO,
		/**
		 * Context Propagation is only applied to 'tap' and 'handle' Reactor operators.
		 */
		LIMITED
	}
}
/*
package org.springframework.boot.autoconfigure.reactor;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(Hooks.class)
@EnableConfigurationProperties(ReactorProperties.class)
public class ReactorAutoConfiguration {
	ReactorAutoConfiguration(ReactorProperties properties) {
		if (properties.getContextPropagation() == ReactorProperties.ContextPropagationMode.AUTO) {
			Hooks.enableAutomaticContextPropagation();
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.reactor;
/*
package org.springframework.boot.autoconfigure.reactor.netty;
/**
public final class ReactorNettyConfigurations {
	private ReactorNettyConfigurations() {
	}
	@Configuration(proxyBeanMethods = false)
	@EnableConfigurationProperties(ReactorNettyProperties.class)
	public static class ReactorResourceFactoryConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ReactorResourceFactory reactorResourceFactory(ReactorNettyProperties configurationProperties) {
			ReactorResourceFactory reactorResourceFactory = new ReactorResourceFactory();
			if (configurationProperties.getShutdownQuietPeriod() != null) {
				reactorResourceFactory.setShutdownQuietPeriod(configurationProperties.getShutdownQuietPeriod());
			}
			return reactorResourceFactory;
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.reactor.netty;
/*
package org.springframework.boot.autoconfigure.reactor.netty;
/**
@ConfigurationProperties(prefix = 'spring.reactor.netty')
public class ReactorNettyProperties {
	/**
	 * Amount of time to wait before shutting down resources.
	 */
	private Duration shutdownQuietPeriod;
	public Duration getShutdownQuietPeriod() {
		return this.shutdownQuietPeriod;
	}
	public void setShutdownQuietPeriod(Duration shutdownQuietPeriod) {
		this.shutdownQuietPeriod = shutdownQuietPeriod;
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
public class TemplateAvailabilityProviders {
	private final List<TemplateAvailabilityProvider> providers;
	private static final int CACHE_LIMIT = 1024;
	private static final TemplateAvailabilityProvider NONE = new NoTemplateAvailabilityProvider();
	/**
	 * Resolved template views, returning already cached instances without a global lock.
	 */
	private final Map<String, TemplateAvailabilityProvider> resolved = new ConcurrentHashMap<>(CACHE_LIMIT);
	/**
	 * Map from view name resolve template view, synchronized when accessed.
	 */
	private final Map<String, TemplateAvailabilityProvider> cache = new LinkedHashMap<>(CACHE_LIMIT, 0.75f, true) {
		@Override
		protected boolean removeEldestEntry(Map.Entry<String, TemplateAvailabilityProvider> eldest) {
			if (size() > CACHE_LIMIT) {
				TemplateAvailabilityProviders.this.resolved.remove(eldest.getKey());
				return true;
			}
			return false;
		}
	};
	/**
	 * Create a new {@link TemplateAvailabilityProviders} instance.
	 * @param applicationContext the source application context
	 */
	public TemplateAvailabilityProviders(ApplicationContext applicationContext) {
		this((applicationContext != null) ? applicationContext.getClassLoader() : null);
	}
	/**
	 * Create a new {@link TemplateAvailabilityProviders} instance.
	 * @param classLoader the source class loader
	 */
	public TemplateAvailabilityProviders(ClassLoader classLoader) {
		Assert.notNull(classLoader, 'ClassLoader must not be null');
		this.providers = SpringFactoriesLoader.loadFactories(TemplateAvailabilityProvider.class, classLoader);
	}
	/**
	 * Create a new {@link TemplateAvailabilityProviders} instance.
	 * @param providers the underlying providers
	 */
	protected TemplateAvailabilityProviders(Collection<? extends TemplateAvailabilityProvider> providers) {
		Assert.notNull(providers, 'Providers must not be null');
		this.providers = new ArrayList<>(providers);
	}
	/**
	 * Return the underlying providers being used.
	 * @return the providers being used
	 */
	public List<TemplateAvailabilityProvider> getProviders() {
		return this.providers;
	}
	/**
	 * Get the provider that can be used to render the given view.
	 * @param view the view to render
	 * @param applicationContext the application context
	 * @return a {@link TemplateAvailabilityProvider} or null
	 */
	public TemplateAvailabilityProvider getProvider(String view, ApplicationContext applicationContext) {
		Assert.notNull(applicationContext, 'ApplicationContext must not be null');
		return getProvider(view, applicationContext.getEnvironment(), applicationContext.getClassLoader(),
				applicationContext);
	}
	/**
	 * Get the provider that can be used to render the given view.
	 * @param view the view to render
	 * @param environment the environment
	 * @param classLoader the class loader
	 * @param resourceLoader the resource loader
	 * @return a {@link TemplateAvailabilityProvider} or null
	 */
	public TemplateAvailabilityProvider getProvider(String view, Environment environment, ClassLoader classLoader,
			ResourceLoader resourceLoader) {
		Assert.notNull(view, 'View must not be null');
		Assert.notNull(environment, 'Environment must not be null');
		Assert.notNull(classLoader, 'ClassLoader must not be null');
		Assert.notNull(resourceLoader, 'ResourceLoader must not be null');
		Boolean useCache = environment.getProperty('spring.template.provider.cache', Boolean.class, true);
		if (!useCache) {
			return findProvider(view, environment, classLoader, resourceLoader);
		}
		TemplateAvailabilityProvider provider = this.resolved.get(view);
		if (provider == null) {
			synchronized (this.cache) {
				provider = findProvider(view, environment, classLoader, resourceLoader);
				provider = (provider != null) ? provider : NONE;
				this.resolved.put(view, provider);
				this.cache.put(view, provider);
			}
		}
		return (provider != NONE) ? provider : null;
	}
	private TemplateAvailabilityProvider findProvider(String view, Environment environment, ClassLoader classLoader,
			ResourceLoader resourceLoader) {
		for (TemplateAvailabilityProvider candidate : this.providers) {
			if (candidate.isTemplateAvailable(view, environment, classLoader, resourceLoader)) {
				return candidate;
			}
		}
		return null;
	}
	private static final class NoTemplateAvailabilityProvider implements TemplateAvailabilityProvider {
		@Override
		public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader,
				ResourceLoader resourceLoader) {
			return false;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
public class TemplateLocation {
	private final String path;
	public TemplateLocation(String path) {
		Assert.notNull(path, 'Path must not be null');
		this.path = path;
	}
	/**
	 * Determine if this template location exists using the specified
	 * {@link ResourcePatternResolver}.
	 * @param resolver the resolver used to test if the location exists
	 * @return {@code true} if the location exists.
	 */
	public boolean exists(ResourcePatternResolver resolver) {
		Assert.notNull(resolver, 'Resolver must not be null');
		if (resolver.getResource(this.path).exists()) {
			return true;
		}
		try {
			return anyExists(resolver);
		}
		catch (IOException ex) {
			return false;
		}
	}
	private boolean anyExists(ResourcePatternResolver resolver) throws IOException {
		String searchPath = this.path;
		if (searchPath.startsWith(ResourceLoader.CLASSPATH_URL_PREFIX)) {
			searchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX
					+ searchPath.substring(ResourceLoader.CLASSPATH_URL_PREFIX.length());
		}
		if (searchPath.startsWith(ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX)) {
			Resource[] resources = resolver.getResources(searchPath);
			for (Resource resource : resources) {
				if (resource.exists()) {
					return true;
				}
			}
		}
		return false;
	}
	@Override
	public String toString() {
		return this.path;
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
public abstract class AbstractViewResolverProperties {
	private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf('text/html');
	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;
	/**
	 * Whether to enable MVC view resolution for this technology.
	 */
	private boolean enabled = true;
	/**
	 * Whether to enable template caching.
	 */
	private boolean cache;
	/**
	 * Content-Type value.
	 */
	private MimeType contentType = DEFAULT_CONTENT_TYPE;
	/**
	 * Template encoding.
	 */
	private Charset charset = DEFAULT_CHARSET;
	/**
	 * View names that can be resolved.
	 */
	private String[] viewNames;
	/**
	 * Whether to check that the templates location exists.
	 */
	private boolean checkTemplateLocation = true;
	public void setEnabled(boolean enabled) {
		this.enabled = enabled;
	}
	public boolean isEnabled() {
		return this.enabled;
	}
	public void setCheckTemplateLocation(boolean checkTemplateLocation) {
		this.checkTemplateLocation = checkTemplateLocation;
	}
	public boolean isCheckTemplateLocation() {
		return this.checkTemplateLocation;
	}
	public String[] getViewNames() {
		return this.viewNames;
	}
	public void setViewNames(String[] viewNames) {
		this.viewNames = viewNames;
	}
	public boolean isCache() {
		return this.cache;
	}
	public void setCache(boolean cache) {
		this.cache = cache;
	}
	public MimeType getContentType() {
		if (this.contentType.getCharset() == null) {
			Map<String, String> parameters = new LinkedHashMap<>();
			parameters.put('charset', this.charset.name());
			parameters.putAll(this.contentType.getParameters());
			return new MimeType(this.contentType, parameters);
		}
		return this.contentType;
	}
	public void setContentType(MimeType contentType) {
		this.contentType = contentType;
	}
	public Charset getCharset() {
		return this.charset;
	}
	public String getCharsetName() {
		return (this.charset != null) ? this.charset.name() : null;
	}
	public void setCharset(Charset charset) {
		this.charset = charset;
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
class TemplateRuntimeHints implements RuntimeHintsRegistrar {
	@Override
	public void registerHints(RuntimeHints hints, ClassLoader classLoader) {
		hints.resources().registerPatternIfPresent(classLoader, 'templates', (hint) -> hint.includes('templates/*'));
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
@FunctionalInterface
public interface TemplateAvailabilityProvider {
	/**
	 * Returns {@code true} if a template is available for the given {@code view}.
	 * @param view the view name
	 * @param environment the environment
	 * @param classLoader the class loader
	 * @param resourceLoader the resource loader
	 * @return if the template is available
	 */
	boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader,
			ResourceLoader resourceLoader);
}
/*
/**
package org.springframework.boot.autoconfigure.template;
/*
package org.springframework.boot.autoconfigure.template;
/**
public abstract class AbstractTemplateViewResolverProperties extends AbstractViewResolverProperties {
	/**
	 * Prefix that gets prepended to view names when building a URL.
	 */
	private String prefix;
	/**
	 * Suffix that gets appended to view names when building a URL.
	 */
	private String suffix;
	/**
	 * Name of the RequestContext attribute for all views.
	 */
	private String requestContextAttribute;
	/**
	 * Whether all request attributes should be added to the model prior to merging with
	 * the template.
	 */
	private boolean exposeRequestAttributes = false;
	/**
	 * Whether all HttpSession attributes should be added to the model prior to merging
	 * with the template.
	 */
	private boolean exposeSessionAttributes = false;
	/**
	 * Whether HttpServletRequest attributes are allowed to override (hide) controller
	 * generated model attributes of the same name.
	 */
	private boolean allowRequestOverride = false;
	/**
	 * Whether to expose a RequestContext for use by Spring"s macro library, under the
	 * name 'springMacroRequestContext'.
	 */
	private boolean exposeSpringMacroHelpers = true;
	/**
	 * Whether HttpSession attributes are allowed to override (hide) controller generated
	 * model attributes of the same name.
	 */
	private boolean allowSessionOverride = false;
	protected AbstractTemplateViewResolverProperties(String defaultPrefix, String defaultSuffix) {
		this.prefix = defaultPrefix;
		this.suffix = defaultSuffix;
	}
	public String getPrefix() {
		return this.prefix;
	}
	public void setPrefix(String prefix) {
		this.prefix = prefix;
	}
	public String getSuffix() {
		return this.suffix;
	}
	public void setSuffix(String suffix) {
		this.suffix = suffix;
	}
	public String getRequestContextAttribute() {
		return this.requestContextAttribute;
	}
	public void setRequestContextAttribute(String requestContextAttribute) {
		this.requestContextAttribute = requestContextAttribute;
	}
	public boolean isExposeRequestAttributes() {
		return this.exposeRequestAttributes;
	}
	public void setExposeRequestAttributes(boolean exposeRequestAttributes) {
		this.exposeRequestAttributes = exposeRequestAttributes;
	}
	public boolean isExposeSessionAttributes() {
		return this.exposeSessionAttributes;
	}
	public void setExposeSessionAttributes(boolean exposeSessionAttributes) {
		this.exposeSessionAttributes = exposeSessionAttributes;
	}
	public boolean isAllowRequestOverride() {
		return this.allowRequestOverride;
	}
	public void setAllowRequestOverride(boolean allowRequestOverride) {
		this.allowRequestOverride = allowRequestOverride;
	}
	public boolean isAllowSessionOverride() {
		return this.allowSessionOverride;
	}
	public void setAllowSessionOverride(boolean allowSessionOverride) {
		this.allowSessionOverride = allowSessionOverride;
	}
	public boolean isExposeSpringMacroHelpers() {
		return this.exposeSpringMacroHelpers;
	}
	public void setExposeSpringMacroHelpers(boolean exposeSpringMacroHelpers) {
		this.exposeSpringMacroHelpers = exposeSpringMacroHelpers;
	}
	/**
	 * Apply the given properties to a {@link AbstractTemplateViewResolver}. Use Object in
	 * signature to avoid runtime dependency on MVC, which means that the template engine
	 * can be used in a non-web application.
	 * @param viewResolver the resolver to apply the properties to.
	 */
	public void applyToMvcViewResolver(Object viewResolver) {
		Assert.isInstanceOf(AbstractTemplateViewResolver.class, viewResolver,
				() -> 'ViewResolver is not an instance of AbstractTemplateViewResolver :' + viewResolver);
		AbstractTemplateViewResolver resolver = (AbstractTemplateViewResolver) viewResolver;
		resolver.setPrefix(getPrefix());
		resolver.setSuffix(getSuffix());
		resolver.setCache(isCache());
		if (getContentType() != null) {
			resolver.setContentType(getContentType().toString());
		}
		resolver.setViewNames(getViewNames());
		resolver.setExposeRequestAttributes(isExposeRequestAttributes());
		resolver.setAllowRequestOverride(isAllowRequestOverride());
		resolver.setAllowSessionOverride(isAllowSessionOverride());
		resolver.setExposeSessionAttributes(isExposeSessionAttributes());
		resolver.setExposeSpringMacroHelpers(isExposeSpringMacroHelpers());
		resolver.setRequestContextAttribute(getRequestContextAttribute());
		// The resolver usually acts as a fallback resolver (e.g. like a
		// InternalResourceViewResolver) so it needs to have low precedence
		resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 5);
	}
}
/*
package org.springframework.boot.autoconfigure.template;
/**
public abstract class PathBasedTemplateAvailabilityProvider implements TemplateAvailabilityProvider {
	private final String className;
	private final Class<TemplateAvailabilityProperties> propertiesClass;
	private final String propertyPrefix;
	@SuppressWarnings('unchecked')
	public PathBasedTemplateAvailabilityProvider(String className,
			Class<? extends TemplateAvailabilityProperties> propertiesClass, String propertyPrefix) {
		this.className = className;
		this.propertiesClass = (Class<TemplateAvailabilityProperties>) propertiesClass;
		this.propertyPrefix = propertyPrefix;
	}
	@Override
	public boolean isTemplateAvailable(String view, Environment environment, ClassLoader classLoader,
			ResourceLoader resourceLoader) {
		if (ClassUtils.isPresent(this.className, classLoader)) {
			Binder binder = Binder.get(environment);
			TemplateAvailabilityProperties properties = binder.bindOrCreate(this.propertyPrefix, this.propertiesClass);
			return isTemplateAvailable(view, resourceLoader, properties);
		}
		return false;
	}
	private boolean isTemplateAvailable(String view, ResourceLoader resourceLoader,
			TemplateAvailabilityProperties properties) {
		String location = properties.getPrefix() + view + properties.getSuffix();
		for (String path : properties.getLoaderPath()) {
			if (resourceLoader.getResource(path + location).exists()) {
				return true;
			}
		}
		return false;
	}
	protected abstract static class TemplateAvailabilityProperties {
		private String prefix;
		private String suffix;
		protected TemplateAvailabilityProperties(String prefix, String suffix) {
			this.prefix = prefix;
			this.suffix = suffix;
		}
		protected abstract List<String> getLoaderPath();
		public String getPrefix() {
			return this.prefix;
		}
		public void setPrefix(String prefix) {
			this.prefix = prefix;
		}
		public String getSuffix() {
			return this.suffix;
		}
		public void setSuffix(String suffix) {
			this.suffix = suffix;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
public interface CouchbaseConnectionDetails extends ConnectionDetails {
	/**
	 * Connection string used to locate the Couchbase cluster.
	 * @return the connection string used to locate the Couchbase cluster
	 */
	String getConnectionString();
	/**
	 * Cluster username.
	 * @return the cluster username
	 */
	String getUsername();
	/**
	 * Cluster password.
	 * @return the cluster password
	 */
	String getPassword();
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
@ConfigurationProperties(prefix = 'spring.couchbase')
public class CouchbaseProperties {
	/**
	 * Connection string used to locate the Couchbase cluster.
	 */
	private String connectionString;
	/**
	 * Cluster username.
	 */
	private String username;
	/**
	 * Cluster password.
	 */
	private String password;
	private final Authentication authentication = new Authentication();
	private final Env env = new Env();
	public String getConnectionString() {
		return this.connectionString;
	}
	public void setConnectionString(String connectionString) {
		this.connectionString = connectionString;
	}
	public String getUsername() {
		return this.username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getPassword() {
		return this.password;
	}
	public void setPassword(String password) {
		this.password = password;
	}
	public Authentication getAuthentication() {
		return this.authentication;
	}
	public Env getEnv() {
		return this.env;
	}
	public static class Authentication {
		private final Pem pem = new Pem();
		private final Jks jks = new Jks();
		public Pem getPem() {
			return this.pem;
		}
		public Jks getJks() {
			return this.jks;
		}
		public static class Pem {
			/**
			 * PEM-formatted certificates for certificate-based cluster authentication.
			 */
			private String certificates;
			/**
			 * PEM-formatted private key for certificate-based cluster authentication.
			 */
			private String privateKey;
			/**
			 * Private key password for certificate-based cluster authentication.
			 */
			private String privateKeyPassword;
			public String getCertificates() {
				return this.certificates;
			}
			public void setCertificates(String certificates) {
				this.certificates = certificates;
			}
			public String getPrivateKey() {
				return this.privateKey;
			}
			public void setPrivateKey(String privateKey) {
				this.privateKey = privateKey;
			}
			public String getPrivateKeyPassword() {
				return this.privateKeyPassword;
			}
			public void setPrivateKeyPassword(String privateKeyPassword) {
				this.privateKeyPassword = privateKeyPassword;
			}
		}
		public static class Jks {
			/**
			 * Java KeyStore location for certificate-based cluster authentication.
			 */
			private String location;
			/**
			 * Java KeyStore password for certificate-based cluster authentication.
			 */
			private String password;
			/**
			 * Private key password for certificate-based cluster authentication.
			 */
			private String privateKeyPassword;
			public String getLocation() {
				return this.location;
			}
			public void setLocation(String location) {
				this.location = location;
			}
			public String getPassword() {
				return this.password;
			}
			public void setPassword(String password) {
				this.password = password;
			}
			public String getPrivateKeyPassword() {
				return this.privateKeyPassword;
			}
			public void setPrivateKeyPassword(String privateKeyPassword) {
				this.privateKeyPassword = privateKeyPassword;
			}
		}
	}
	public static class Env {
		private final Io io = new Io();
		private final Ssl ssl = new Ssl();
		private final Timeouts timeouts = new Timeouts();
		public Io getIo() {
			return this.io;
		}
		public Ssl getSsl() {
			return this.ssl;
		}
		public Timeouts getTimeouts() {
			return this.timeouts;
		}
	}
	public static class Io {
		/**
		 * Minimum number of sockets per node.
		 */
		private int minEndpoints = 1;
		/**
		 * Maximum number of sockets per node.
		 */
		private int maxEndpoints = 12;
		/**
		 * Length of time an HTTP connection may remain idle before it is closed and
		 * removed from the pool.
		 */
		private Duration idleHttpConnectionTimeout = Duration.ofSeconds(1);
		public int getMinEndpoints() {
			return this.minEndpoints;
		}
		public void setMinEndpoints(int minEndpoints) {
			this.minEndpoints = minEndpoints;
		}
		public int getMaxEndpoints() {
			return this.maxEndpoints;
		}
		public void setMaxEndpoints(int maxEndpoints) {
			this.maxEndpoints = maxEndpoints;
		}
		public Duration getIdleHttpConnectionTimeout() {
			return this.idleHttpConnectionTimeout;
		}
		public void setIdleHttpConnectionTimeout(Duration idleHttpConnectionTimeout) {
			this.idleHttpConnectionTimeout = idleHttpConnectionTimeout;
		}
	}
	public static class Ssl {
		/**
		 * Whether to enable SSL support. Enabled automatically if a 'bundle' is provided
		 * unless specified otherwise.
		 */
		private Boolean enabled;
		/**
		 * SSL bundle name.
		 */
		private String bundle;
		public Boolean getEnabled() {
			return (this.enabled != null) ? this.enabled : StringUtils.hasText(this.bundle);
		}
		public void setEnabled(Boolean enabled) {
			this.enabled = enabled;
		}
		public String getBundle() {
			return this.bundle;
		}
		public void setBundle(String bundle) {
			this.bundle = bundle;
		}
	}
	public static class Timeouts {
		/**
		 * Bucket connect timeout.
		 */
		private Duration connect = Duration.ofSeconds(10);
		/**
		 * Bucket disconnect timeout.
		 */
		private Duration disconnect = Duration.ofSeconds(10);
		/**
		 * Timeout for operations on a specific key-value.
		 */
		private Duration keyValue = Duration.ofMillis(2500);
		/**
		 * Timeout for operations on a specific key-value with a durability level.
		 */
		private Duration keyValueDurable = Duration.ofSeconds(10);
		/**
		 * N1QL query operations timeout.
		 */
		private Duration query = Duration.ofSeconds(75);
		/**
		 * Regular and geospatial view operations timeout.
		 */
		private Duration view = Duration.ofSeconds(75);
		/**
		 * Timeout for the search service.
		 */
		private Duration search = Duration.ofSeconds(75);
		/**
		 * Timeout for the analytics service.
		 */
		private Duration analytics = Duration.ofSeconds(75);
		/**
		 * Timeout for the management operations.
		 */
		private Duration management = Duration.ofSeconds(75);
		public Duration getConnect() {
			return this.connect;
		}
		public void setConnect(Duration connect) {
			this.connect = connect;
		}
		public Duration getDisconnect() {
			return this.disconnect;
		}
		public void setDisconnect(Duration disconnect) {
			this.disconnect = disconnect;
		}
		public Duration getKeyValue() {
			return this.keyValue;
		}
		public void setKeyValue(Duration keyValue) {
			this.keyValue = keyValue;
		}
		public Duration getKeyValueDurable() {
			return this.keyValueDurable;
		}
		public void setKeyValueDurable(Duration keyValueDurable) {
			this.keyValueDurable = keyValueDurable;
		}
		public Duration getQuery() {
			return this.query;
		}
		public void setQuery(Duration query) {
			this.query = query;
		}
		public Duration getView() {
			return this.view;
		}
		public void setView(Duration view) {
			this.view = view;
		}
		public Duration getSearch() {
			return this.search;
		}
		public void setSearch(Duration search) {
			this.search = search;
		}
		public Duration getAnalytics() {
			return this.analytics;
		}
		public void setAnalytics(Duration analytics) {
			this.analytics = analytics;
		}
		public Duration getManagement() {
			return this.management;
		}
		public void setManagement(Duration management) {
			this.management = management;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
@AutoConfiguration(after = JacksonAutoConfiguration.class)
@ConditionalOnClass(Cluster.class)
@Conditional(CouchbaseCondition.class)
@EnableConfigurationProperties(CouchbaseProperties.class)
public class CouchbaseAutoConfiguration {
	private final ResourceLoader resourceLoader;
	private final CouchbaseProperties properties;
	CouchbaseAutoConfiguration(ResourceLoader resourceLoader, CouchbaseProperties properties) {
		this.resourceLoader = ApplicationResourceLoader.get(resourceLoader);
		this.properties = properties;
	}
	@Bean
	@ConditionalOnMissingBean(CouchbaseConnectionDetails.class)
	PropertiesCouchbaseConnectionDetails couchbaseConnectionDetails() {
		return new PropertiesCouchbaseConnectionDetails(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean
	public ClusterEnvironment couchbaseClusterEnvironment(
			ObjectProvider<ClusterEnvironmentBuilderCustomizer> customizers, ObjectProvider<SslBundles> sslBundles) {
		Builder builder = initializeEnvironmentBuilder(sslBundles.getIfAvailable());
		customizers.orderedStream().forEach((customizer) -> customizer.customize(builder));
		return builder.build();
	}
	@Bean
	@ConditionalOnMissingBean
	public Authenticator couchbaseAuthenticator(CouchbaseConnectionDetails connectionDetails) throws IOException {
		if (connectionDetails.getUsername() != null && connectionDetails.getPassword() != null) {
			return PasswordAuthenticator.create(connectionDetails.getUsername(), connectionDetails.getPassword());
		}
		Pem pem = this.properties.getAuthentication().getPem();
		if (pem.getCertificates() != null) {
			PemSslStoreDetails details = new PemSslStoreDetails(null, pem.getCertificates(), pem.getPrivateKey());
			PemSslStore store = PemSslStore.load(details);
			return CertificateAuthenticator.fromKey(store.privateKey(), pem.getPrivateKeyPassword(),
					store.certificates());
		}
		Jks jks = this.properties.getAuthentication().getJks();
		if (jks.getLocation() != null) {
			Resource resource = this.resourceLoader.getResource(jks.getLocation());
			String keystorePassword = jks.getPassword();
			try (InputStream inputStream = resource.getInputStream()) {
				KeyStore store = KeyStore.getInstance(KeyStore.getDefaultType());
				store.load(inputStream, (keystorePassword != null) ? keystorePassword.toCharArray() : null);
				return CertificateAuthenticator.fromKeyStore(store, keystorePassword);
			}
			catch (GeneralSecurityException ex) {
				throw new IllegalStateException('Error reading Couchbase certificate store', ex);
			}
		}
		throw new IllegalStateException('Couchbase authentication requires username and password, or certificates');
	}
	@Bean(destroyMethod = 'disconnect')
	@ConditionalOnMissingBean
	public Cluster couchbaseCluster(ClusterEnvironment couchbaseClusterEnvironment, Authenticator authenticator,
			CouchbaseConnectionDetails connectionDetails) {
		ClusterOptions options = ClusterOptions.clusterOptions(authenticator).environment(couchbaseClusterEnvironment);
		return Cluster.connect(connectionDetails.getConnectionString(), options);
	}
	private ClusterEnvironment.Builder initializeEnvironmentBuilder(SslBundles sslBundles) {
		ClusterEnvironment.Builder builder = ClusterEnvironment.builder();
		Timeouts timeouts = this.properties.getEnv().getTimeouts();
		builder.timeoutConfig((config) -> config.kvTimeout(timeouts.getKeyValue())
			.analyticsTimeout(timeouts.getAnalytics())
			.kvDurableTimeout(timeouts.getKeyValueDurable())
			.queryTimeout(timeouts.getQuery())
			.viewTimeout(timeouts.getView())
			.searchTimeout(timeouts.getSearch())
			.managementTimeout(timeouts.getManagement())
			.connectTimeout(timeouts.getConnect())
			.disconnectTimeout(timeouts.getDisconnect()));
		CouchbaseProperties.Io io = this.properties.getEnv().getIo();
		builder.ioConfig((config) -> config.maxHttpConnections(io.getMaxEndpoints())
			.numKvConnections(io.getMinEndpoints())
			.idleHttpConnectionTimeout(io.getIdleHttpConnectionTimeout()));
		if (this.properties.getEnv().getSsl().getEnabled()) {
			configureSsl(builder, sslBundles);
		}
		return builder;
	}
	private void configureSsl(Builder builder, SslBundles sslBundles) {
		Ssl sslProperties = this.properties.getEnv().getSsl();
		SslBundle sslBundle = (StringUtils.hasText(sslProperties.getBundle()))
				? sslBundles.getBundle(sslProperties.getBundle()) : null;
		Assert.state(sslBundle == null || !sslBundle.getOptions().isSpecified(),
				'SSL Options cannot be specified with Couchbase');
		builder.securityConfig((config) -> {
			config.enableTls(true);
			TrustManagerFactory trustManagerFactory = getTrustManagerFactory(sslBundle);
			if (trustManagerFactory != null) {
				config.trustManagerFactory(trustManagerFactory);
			}
		});
	}
	private TrustManagerFactory getTrustManagerFactory(SslBundle sslBundle) {
		return (sslBundle != null) ? sslBundle.getManagers().getTrustManagerFactory() : null;
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(ObjectMapper.class)
	static class JacksonConfiguration {
		@Bean
		@ConditionalOnSingleCandidate(ObjectMapper.class)
		ClusterEnvironmentBuilderCustomizer jacksonClusterEnvironmentBuilderCustomizer(ObjectMapper objectMapper) {
			return new JacksonClusterEnvironmentBuilderCustomizer(
					objectMapper.copy().registerModule(new JsonValueModule()));
		}
	}
	private static final class JacksonClusterEnvironmentBuilderCustomizer
			implements ClusterEnvironmentBuilderCustomizer, Ordered {
		private final ObjectMapper objectMapper;
		private JacksonClusterEnvironmentBuilderCustomizer(ObjectMapper objectMapper) {
			this.objectMapper = objectMapper;
		}
		@Override
		public void customize(Builder builder) {
			builder.jsonSerializer(JacksonJsonSerializer.create(this.objectMapper));
		}
		@Override
		public int getOrder() {
			return 0;
		}
	}
	/**
	 * Condition that matches when {@code spring.couchbase.connection-string} has been
	 * configured or there is a {@link CouchbaseConnectionDetails} bean.
	 */
	static final class CouchbaseCondition extends AnyNestedCondition {
		CouchbaseCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnProperty(prefix = 'spring.couchbase', name = 'connection-string')
		private static final class CouchbaseUrlCondition {
		}
		@ConditionalOnBean(CouchbaseConnectionDetails.class)
		private static final class CouchbaseConnectionDetailsCondition {
		}
	}
	/**
	 * Adapts {@link CouchbaseProperties} to {@link CouchbaseConnectionDetails}.
	 */
	static final class PropertiesCouchbaseConnectionDetails implements CouchbaseConnectionDetails {
		private final CouchbaseProperties properties;
		PropertiesCouchbaseConnectionDetails(CouchbaseProperties properties) {
			this.properties = properties;
		}
		@Override
		public String getConnectionString() {
			return this.properties.getConnectionString();
		}
		@Override
		public String getUsername() {
			return this.properties.getUsername();
		}
		@Override
		public String getPassword() {
			return this.properties.getPassword();
		}
	}
}
/*
package org.springframework.boot.autoconfigure.couchbase;
/**
@FunctionalInterface
public interface ClusterEnvironmentBuilderCustomizer {
	/**
	 * Customize the {@link Builder ClusterEnvironment.Builder}.
	 * @param builder the builder to customize
	 */
	void customize(ClusterEnvironment.Builder builder);
}
/*
/**
package org.springframework.boot.autoconfigure.couchbase;
/*
package org.springframework.boot.autoconfigure.session;
/**
@ConfigurationProperties(prefix = 'spring.session.hazelcast')
public class HazelcastSessionProperties {
	/**
	 * Name of the map used to store sessions.
	 */
	private String mapName = 'spring:session:sessions';
	/**
	 * Sessions flush mode. Determines when session changes are written to the session
	 * store.
	 */
	private FlushMode flushMode = FlushMode.ON_SAVE;
	/**
	 * Sessions save mode. Determines how session changes are tracked and saved to the
	 * session store.
	 */
	private SaveMode saveMode = SaveMode.ON_SET_ATTRIBUTE;
	public String getMapName() {
		return this.mapName;
	}
	public void setMapName(String mapName) {
		this.mapName = mapName;
	}
	public FlushMode getFlushMode() {
		return this.flushMode;
	}
	public void setFlushMode(FlushMode flushMode) {
		this.flushMode = flushMode;
	}
	public SaveMode getSaveMode() {
		return this.saveMode;
	}
	public void setSaveMode(SaveMode saveMode) {
		this.saveMode = saveMode;
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@ConfigurationProperties(prefix = 'spring.session.mongodb')
public class MongoSessionProperties {
	/**
	 * Collection name used to store sessions.
	 */
	private String collectionName = 'sessions';
	public String getCollectionName() {
		return this.collectionName;
	}
	public void setCollectionName(String collectionName) {
		this.collectionName = collectionName;
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
public class JdbcSessionDataSourceScriptDatabaseInitializer extends DataSourceScriptDatabaseInitializer {
	/**
	 * Create a new {@link JdbcSessionDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Spring Session JDBC data source
	 * @param properties the Spring Session JDBC properties
	 * @see #getSettings
	 */
	public JdbcSessionDataSourceScriptDatabaseInitializer(DataSource dataSource, JdbcSessionProperties properties) {
		this(dataSource, getSettings(dataSource, properties));
	}
	/**
	 * Create a new {@link JdbcSessionDataSourceScriptDatabaseInitializer} instance.
	 * @param dataSource the Spring Session JDBC data source
	 * @param settings the database initialization settings
	 * @see #getSettings
	 */
	public JdbcSessionDataSourceScriptDatabaseInitializer(DataSource dataSource,
			DatabaseInitializationSettings settings) {
		super(dataSource, settings);
	}
	/**
	 * Adapts {@link JdbcSessionProperties Spring Session JDBC properties} to
	 * {@link DatabaseInitializationSettings} replacing any {@literal @@platform@@}
	 * placeholders.
	 * @param dataSource the Spring Session JDBC data source
	 * @param properties the Spring Session JDBC properties
	 * @return a new {@link DatabaseInitializationSettings} instance
	 * @see #JdbcSessionDataSourceScriptDatabaseInitializer(DataSource,
	 * DatabaseInitializationSettings)
	 */
	static DatabaseInitializationSettings getSettings(DataSource dataSource, JdbcSessionProperties properties) {
		DatabaseInitializationSettings settings = new DatabaseInitializationSettings();
		settings.setSchemaLocations(resolveSchemaLocations(dataSource, properties));
		settings.setMode(properties.getInitializeSchema());
		settings.setContinueOnError(true);
		return settings;
	}
	private static List<String> resolveSchemaLocations(DataSource dataSource, JdbcSessionProperties properties) {
		PlatformPlaceholderDatabaseDriverResolver platformResolver = new PlatformPlaceholderDatabaseDriverResolver();
		platformResolver = platformResolver.withDriverPlatform(DatabaseDriver.MARIADB, 'mysql');
		if (StringUtils.hasText(properties.getPlatform())) {
			return platformResolver.resolveAll(properties.getPlatform(), properties.getSchema());
		}
		return platformResolver.resolveAll(dataSource, properties.getSchema());
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(HazelcastIndexedSessionRepository.class)
@ConditionalOnMissingBean(SessionRepository.class)
@ConditionalOnBean(HazelcastInstance.class)
@EnableConfigurationProperties(HazelcastSessionProperties.class)
@Import(HazelcastHttpSessionConfiguration.class)
class HazelcastSessionConfiguration {
	@Bean
	@Order(Ordered.HIGHEST_PRECEDENCE)
	SessionRepositoryCustomizer<HazelcastIndexedSessionRepository> springBootSessionRepositoryCustomizer(
			SessionProperties sessionProperties, HazelcastSessionProperties hazelcastSessionProperties,
			ServerProperties serverProperties) {
		return (sessionRepository) -> {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(sessionProperties.determineTimeout(() -> serverProperties.getServlet().getSession().getTimeout()))
				.to(sessionRepository::setDefaultMaxInactiveInterval);
			map.from(hazelcastSessionProperties::getMapName).to(sessionRepository::setSessionMapName);
			map.from(hazelcastSessionProperties::getFlushMode).to(sessionRepository::setFlushMode);
			map.from(hazelcastSessionProperties::getSaveMode).to(sessionRepository::setSaveMode);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@ConfigurationProperties(prefix = 'spring.session')
public class SessionProperties {
	/**
	 * Session timeout. If a duration suffix is not specified, seconds will be used.
	 */
	@DurationUnit(ChronoUnit.SECONDS)
	private Duration timeout;
	private Servlet servlet = new Servlet();
	public Duration getTimeout() {
		return this.timeout;
	}
	public void setTimeout(Duration timeout) {
		this.timeout = timeout;
	}
	public Servlet getServlet() {
		return this.servlet;
	}
	public void setServlet(Servlet servlet) {
		this.servlet = servlet;
	}
	/**
	 * Determine the session timeout. If no timeout is configured, the
	 * {@code fallbackTimeout} is used.
	 * @param fallbackTimeout a fallback timeout value if the timeout isn"t configured
	 * @return the session timeout
	 * @since 2.4.0
	 */
	public Duration determineTimeout(Supplier<Duration> fallbackTimeout) {
		return (this.timeout != null) ? this.timeout : fallbackTimeout.get();
	}
	/**
	 * Servlet-related properties.
	 */
	public static class Servlet {
		/**
		 * Session repository filter order.
		 */
		private int filterOrder = SessionRepositoryFilter.DEFAULT_ORDER;
		/**
		 * Session repository filter dispatcher types.
		 */
		private Set<DispatcherType> filterDispatcherTypes = new HashSet<>(
				Arrays.asList(DispatcherType.ASYNC, DispatcherType.ERROR, DispatcherType.REQUEST));
		public int getFilterOrder() {
			return this.filterOrder;
		}
		public void setFilterOrder(int filterOrder) {
			this.filterOrder = filterOrder;
		}
		public Set<DispatcherType> getFilterDispatcherTypes() {
			return this.filterDispatcherTypes;
		}
		public void setFilterDispatcherTypes(Set<DispatcherType> filterDispatcherTypes) {
			this.filterDispatcherTypes = filterDispatcherTypes;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ MongoOperations.class, MongoIndexedSessionRepository.class })
@ConditionalOnMissingBean(SessionRepository.class)
@ConditionalOnBean(MongoOperations.class)
@EnableConfigurationProperties(MongoSessionProperties.class)
@Import(MongoHttpSessionConfiguration.class)
class MongoSessionConfiguration {
	@Bean
	@Order(Ordered.HIGHEST_PRECEDENCE)
	SessionRepositoryCustomizer<MongoIndexedSessionRepository> springBootSessionRepositoryCustomizer(
			SessionProperties sessionProperties, MongoSessionProperties mongoSessionProperties,
			ServerProperties serverProperties) {
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		return (sessionRepository) -> {
			map.from(sessionProperties.determineTimeout(() -> serverProperties.getServlet().getSession().getTimeout()))
				.to(sessionRepository::setDefaultMaxInactiveInterval);
			map.from(mongoSessionProperties::getCollectionName).to(sessionRepository::setCollectionName);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
class JdbcIndexedSessionRepositoryDependsOnDatabaseInitializationDetector
		extends AbstractBeansOfTypeDependsOnDatabaseInitializationDetector {
	@Override
	protected Set<Class<?>> getDependsOnDatabaseInitializationBeanTypes() {
		return Collections.singleton(JdbcIndexedSessionRepository.class);
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ ReactiveRedisConnectionFactory.class, ReactiveRedisSessionRepository.class })
@ConditionalOnMissingBean(ReactiveSessionRepository.class)
@ConditionalOnBean(ReactiveRedisConnectionFactory.class)
@EnableConfigurationProperties(RedisSessionProperties.class)
class RedisReactiveSessionConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.session.redis', name = 'repository-type', havingValue = 'default',
			matchIfMissing = true)
	@Import(RedisWebSessionConfiguration.class)
	static class DefaultRedisSessionConfiguration {
		@Bean
		ReactiveSessionRepositoryCustomizer<ReactiveRedisSessionRepository> springBootSessionRepositoryCustomizer(
				SessionProperties sessionProperties, RedisSessionProperties redisSessionProperties,
				ServerProperties serverProperties) {
			return (sessionRepository) -> {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(sessionProperties
					.determineTimeout(() -> serverProperties.getReactive().getSession().getTimeout()))
					.to(sessionRepository::setDefaultMaxInactiveInterval);
				map.from(redisSessionProperties::getNamespace).to(sessionRepository::setRedisKeyNamespace);
				map.from(redisSessionProperties::getSaveMode).to(sessionRepository::setSaveMode);
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.session.redis', name = 'repository-type', havingValue = 'indexed')
	@Import(RedisIndexedWebSessionConfiguration.class)
	static class IndexedRedisSessionConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ConfigureReactiveRedisAction configureReactiveRedisAction(RedisSessionProperties redisSessionProperties) {
			return switch (redisSessionProperties.getConfigureAction()) {
				case NOTIFY_KEYSPACE_EVENTS -> new ConfigureNotifyKeyspaceEventsReactiveAction();
				case NONE -> ConfigureReactiveRedisAction.NO_OP;
			};
		}
		@Bean
		ReactiveSessionRepositoryCustomizer<ReactiveRedisIndexedSessionRepository> springBootSessionRepositoryCustomizer(
				SessionProperties sessionProperties, RedisSessionProperties redisSessionProperties,
				ServerProperties serverProperties) {
			return (sessionRepository) -> {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(sessionProperties
					.determineTimeout(() -> serverProperties.getReactive().getSession().getTimeout()))
					.to(sessionRepository::setDefaultMaxInactiveInterval);
				map.from(redisSessionProperties::getNamespace).to(sessionRepository::setRedisKeyNamespace);
				map.from(redisSessionProperties::getSaveMode).to(sessionRepository::setSaveMode);
			};
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@ConfigurationProperties(prefix = 'spring.session.jdbc')
public class JdbcSessionProperties {
	private static final String DEFAULT_SCHEMA_LOCATION = 'classpath:org/springframework/'
			+ 'session/jdbc/schema-@@platform@@.sql';
	private static final String DEFAULT_TABLE_NAME = 'SPRING_SESSION';
	private static final String DEFAULT_CLEANUP_CRON = '0 * * * * *';
	/**
	 * Path to the SQL file to use to initialize the database schema.
	 */
	private String schema = DEFAULT_SCHEMA_LOCATION;
	/**
	 * Platform to use in initialization scripts if the @@platform@@ placeholder is used.
	 * Auto-detected by default.
	 */
	private String platform;
	/**
	 * Name of the database table used to store sessions.
	 */
	private String tableName = DEFAULT_TABLE_NAME;
	/**
	 * Cron expression for expired session cleanup job.
	 */
	private String cleanupCron = DEFAULT_CLEANUP_CRON;
	/**
	 * Database schema initialization mode.
	 */
	private DatabaseInitializationMode initializeSchema = DatabaseInitializationMode.EMBEDDED;
	/**
	 * Sessions flush mode. Determines when session changes are written to the session
	 * store.
	 */
	private FlushMode flushMode = FlushMode.ON_SAVE;
	/**
	 * Sessions save mode. Determines how session changes are tracked and saved to the
	 * session store.
	 */
	private SaveMode saveMode = SaveMode.ON_SET_ATTRIBUTE;
	public String getSchema() {
		return this.schema;
	}
	public void setSchema(String schema) {
		this.schema = schema;
	}
	public String getPlatform() {
		return this.platform;
	}
	public void setPlatform(String platform) {
		this.platform = platform;
	}
	public String getTableName() {
		return this.tableName;
	}
	public void setTableName(String tableName) {
		this.tableName = tableName;
	}
	public String getCleanupCron() {
		return this.cleanupCron;
	}
	public void setCleanupCron(String cleanupCron) {
		this.cleanupCron = cleanupCron;
	}
	public DatabaseInitializationMode getInitializeSchema() {
		return this.initializeSchema;
	}
	public void setInitializeSchema(DatabaseInitializationMode initializeSchema) {
		this.initializeSchema = initializeSchema;
	}
	public FlushMode getFlushMode() {
		return this.flushMode;
	}
	public void setFlushMode(FlushMode flushMode) {
		this.flushMode = flushMode;
	}
	public SaveMode getSaveMode() {
		return this.saveMode;
	}
	public void setSaveMode(SaveMode saveMode) {
		this.saveMode = saveMode;
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnBean(SessionRepositoryFilter.class)
@EnableConfigurationProperties(SessionProperties.class)
class SessionRepositoryFilterConfiguration {
	@Bean
	DelegatingFilterProxyRegistrationBean sessionRepositoryFilterRegistration(SessionProperties sessionProperties,
			ListableBeanFactory beanFactory) {
		String[] targetBeanNames = beanFactory.getBeanNamesForType(SessionRepositoryFilter.class, false, false);
		Assert.state(targetBeanNames.length == 1, 'Expected single SessionRepositoryFilter bean');
		DelegatingFilterProxyRegistrationBean registration = new DelegatingFilterProxyRegistrationBean(
				targetBeanNames[0]);
		registration.setDispatcherTypes(getDispatcherTypes(sessionProperties));
		registration.setOrder(sessionProperties.getServlet().getFilterOrder());
		return registration;
	}
	private EnumSet<DispatcherType> getDispatcherTypes(SessionProperties sessionProperties) {
		SessionProperties.Servlet servletProperties = sessionProperties.getServlet();
		if (servletProperties.getFilterDispatcherTypes() == null) {
			return null;
		}
		return servletProperties.getFilterDispatcherTypes()
			.stream()
			.map((type) -> DispatcherType.valueOf(type.name()))
			.collect(Collectors.toCollection(() -> EnumSet.noneOf(DispatcherType.class)));
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ JdbcTemplate.class, JdbcIndexedSessionRepository.class })
@ConditionalOnMissingBean(SessionRepository.class)
@ConditionalOnBean(DataSource.class)
@EnableConfigurationProperties(JdbcSessionProperties.class)
@Import({ DatabaseInitializationDependencyConfigurer.class, JdbcHttpSessionConfiguration.class })
class JdbcSessionConfiguration {
	@Bean
	@ConditionalOnMissingBean(JdbcSessionDataSourceScriptDatabaseInitializer.class)
	@Conditional(OnJdbcSessionDatasourceInitializationCondition.class)
	JdbcSessionDataSourceScriptDatabaseInitializer jdbcSessionDataSourceScriptDatabaseInitializer(
			@SpringSessionDataSource ObjectProvider<DataSource> sessionDataSource,
			ObjectProvider<DataSource> dataSource, JdbcSessionProperties properties) {
		DataSource dataSourceToInitialize = sessionDataSource.getIfAvailable(dataSource::getObject);
		return new JdbcSessionDataSourceScriptDatabaseInitializer(dataSourceToInitialize, properties);
	}
	@Bean
	@Order(Ordered.HIGHEST_PRECEDENCE)
	SessionRepositoryCustomizer<JdbcIndexedSessionRepository> springBootSessionRepositoryCustomizer(
			SessionProperties sessionProperties, JdbcSessionProperties jdbcSessionProperties,
			ServerProperties serverProperties) {
		return (sessionRepository) -> {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(sessionProperties.determineTimeout(() -> serverProperties.getServlet().getSession().getTimeout()))
				.to(sessionRepository::setDefaultMaxInactiveInterval);
			map.from(jdbcSessionProperties::getTableName).to(sessionRepository::setTableName);
			map.from(jdbcSessionProperties::getFlushMode).to(sessionRepository::setFlushMode);
			map.from(jdbcSessionProperties::getSaveMode).to(sessionRepository::setSaveMode);
			map.from(jdbcSessionProperties::getCleanupCron).to(sessionRepository::setCleanupCron);
		};
	}
	static class OnJdbcSessionDatasourceInitializationCondition extends OnDatabaseInitializationCondition {
		OnJdbcSessionDatasourceInitializationCondition() {
			super('Jdbc Session', 'spring.session.jdbc.initialize-schema');
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@AutoConfiguration(
		after = { DataSourceAutoConfiguration.class, HazelcastAutoConfiguration.class,
				JdbcTemplateAutoConfiguration.class, MongoDataAutoConfiguration.class,
				MongoReactiveDataAutoConfiguration.class, RedisAutoConfiguration.class,
				RedisReactiveAutoConfiguration.class, WebSessionIdResolverAutoConfiguration.class },
		before = { HttpHandlerAutoConfiguration.class, WebFluxAutoConfiguration.class })
@ConditionalOnClass(Session.class)
@ConditionalOnWebApplication
@EnableConfigurationProperties({ ServerProperties.class, SessionProperties.class, WebFluxProperties.class })
public class SessionAutoConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.SERVLET)
	@Import(SessionRepositoryFilterConfiguration.class)
	static class ServletSessionConfiguration {
		@Bean
		@Conditional(DefaultCookieSerializerCondition.class)
		DefaultCookieSerializer cookieSerializer(ServerProperties serverProperties,
				ObjectProvider<DefaultCookieSerializerCustomizer> cookieSerializerCustomizers) {
			Cookie cookie = serverProperties.getServlet().getSession().getCookie();
			DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(cookie::getName).to(cookieSerializer::setCookieName);
			map.from(cookie::getDomain).to(cookieSerializer::setDomainName);
			map.from(cookie::getPath).to(cookieSerializer::setCookiePath);
			map.from(cookie::getHttpOnly).to(cookieSerializer::setUseHttpOnlyCookie);
			map.from(cookie::getSecure).to(cookieSerializer::setUseSecureCookie);
			map.from(cookie::getMaxAge).asInt(Duration::getSeconds).to(cookieSerializer::setCookieMaxAge);
			map.from(cookie::getSameSite).as(SameSite::attributeValue).to(cookieSerializer::setSameSite);
			map.from(cookie::getPartitioned).to(cookieSerializer::setPartitioned);
			cookieSerializerCustomizers.orderedStream().forEach((customizer) -> customizer.customize(cookieSerializer));
			return cookieSerializer;
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass(RememberMeServices.class)
		static class RememberMeServicesConfiguration {
			@Bean
			DefaultCookieSerializerCustomizer rememberMeServicesCookieSerializerCustomizer() {
				return (cookieSerializer) -> cookieSerializer
					.setRememberMeRequestAttribute(SpringSessionRememberMeServices.REMEMBER_ME_LOGIN_ATTR);
			}
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnMissingBean(SessionRepository.class)
		@Import({ RedisSessionConfiguration.class, JdbcSessionConfiguration.class, HazelcastSessionConfiguration.class,
				MongoSessionConfiguration.class })
		static class ServletSessionRepositoryConfiguration {
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnWebApplication(type = Type.REACTIVE)
	@ConditionalOnMissingBean(ReactiveSessionRepository.class)
	@Import({ RedisReactiveSessionConfiguration.class, MongoReactiveSessionConfiguration.class })
	static class ReactiveSessionConfiguration {
	}
	/**
	 * Condition to trigger the creation of a {@link DefaultCookieSerializer}. This kicks
	 * in if either no {@link HttpSessionIdResolver} and {@link CookieSerializer} beans
	 * are registered, or if {@link CookieHttpSessionIdResolver} is registered but
	 * {@link CookieSerializer} is not.
	 */
	static class DefaultCookieSerializerCondition extends AnyNestedCondition {
		DefaultCookieSerializerCondition() {
			super(ConfigurationPhase.REGISTER_BEAN);
		}
		@ConditionalOnMissingBean({ HttpSessionIdResolver.class, CookieSerializer.class })
		static class NoComponentsAvailable {
		}
		@ConditionalOnBean(CookieHttpSessionIdResolver.class)
		@ConditionalOnMissingBean(CookieSerializer.class)
		static class CookieHttpSessionIdResolverAvailable {
		}
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@FunctionalInterface
public interface DefaultCookieSerializerCustomizer {
	/**
	 * Customize the cookie serializer.
	 * @param cookieSerializer the {@code DefaultCookieSerializer} to customize
	 */
	void customize(DefaultCookieSerializer cookieSerializer);
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ RedisTemplate.class, RedisIndexedSessionRepository.class })
@ConditionalOnMissingBean(SessionRepository.class)
@ConditionalOnBean(RedisConnectionFactory.class)
@EnableConfigurationProperties(RedisSessionProperties.class)
class RedisSessionConfiguration {
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.session.redis', name = 'repository-type', havingValue = 'default',
			matchIfMissing = true)
	@Import(RedisHttpSessionConfiguration.class)
	static class DefaultRedisSessionConfiguration {
		@Bean
		@Order(Ordered.HIGHEST_PRECEDENCE)
		SessionRepositoryCustomizer<RedisSessionRepository> springBootSessionRepositoryCustomizer(
				SessionProperties sessionProperties, RedisSessionProperties redisSessionProperties,
				ServerProperties serverProperties) {
			String cleanupCron = redisSessionProperties.getCleanupCron();
			if (cleanupCron != null) {
				throw new InvalidConfigurationPropertyValueException('spring.session.redis.cleanup-cron', cleanupCron,
						'Cron-based cleanup is only supported when '
								+ 'spring.session.redis.repository-type is set to indexed.');
			}
			return (sessionRepository) -> {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(sessionProperties
					.determineTimeout(() -> serverProperties.getServlet().getSession().getTimeout()))
					.to(sessionRepository::setDefaultMaxInactiveInterval);
				map.from(redisSessionProperties::getNamespace).to(sessionRepository::setRedisKeyNamespace);
				map.from(redisSessionProperties::getFlushMode).to(sessionRepository::setFlushMode);
				map.from(redisSessionProperties::getSaveMode).to(sessionRepository::setSaveMode);
			};
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnProperty(prefix = 'spring.session.redis', name = 'repository-type', havingValue = 'indexed')
	@Import(RedisIndexedHttpSessionConfiguration.class)
	static class IndexedRedisSessionConfiguration {
		@Bean
		@ConditionalOnMissingBean
		ConfigureRedisAction configureRedisAction(RedisSessionProperties redisSessionProperties) {
			return switch (redisSessionProperties.getConfigureAction()) {
				case NOTIFY_KEYSPACE_EVENTS -> new ConfigureNotifyKeyspaceEventsAction();
				case NONE -> ConfigureRedisAction.NO_OP;
			};
		}
		@Bean
		@Order(Ordered.HIGHEST_PRECEDENCE)
		SessionRepositoryCustomizer<RedisIndexedSessionRepository> springBootSessionRepositoryCustomizer(
				SessionProperties sessionProperties, RedisSessionProperties redisSessionProperties,
				ServerProperties serverProperties) {
			return (sessionRepository) -> {
				PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
				map.from(sessionProperties
					.determineTimeout(() -> serverProperties.getServlet().getSession().getTimeout()))
					.to(sessionRepository::setDefaultMaxInactiveInterval);
				map.from(redisSessionProperties::getNamespace).to(sessionRepository::setRedisKeyNamespace);
				map.from(redisSessionProperties::getFlushMode).to(sessionRepository::setFlushMode);
				map.from(redisSessionProperties::getSaveMode).to(sessionRepository::setSaveMode);
				map.from(redisSessionProperties::getCleanupCron).to(sessionRepository::setCleanupCron);
			};
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.session;
/*
package org.springframework.boot.autoconfigure.session;
/**
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass({ ReactiveMongoOperations.class, ReactiveMongoSessionRepository.class })
@ConditionalOnMissingBean(ReactiveSessionRepository.class)
@ConditionalOnBean(ReactiveMongoOperations.class)
@EnableConfigurationProperties(MongoSessionProperties.class)
@Import(ReactiveMongoWebSessionConfiguration.class)
class MongoReactiveSessionConfiguration {
	@Bean
	ReactiveSessionRepositoryCustomizer<ReactiveMongoSessionRepository> springBootSessionRepositoryCustomizer(
			SessionProperties sessionProperties, MongoSessionProperties mongoSessionProperties,
			ServerProperties serverProperties) {
		return (sessionRepository) -> {
			PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
			map.from(sessionProperties.determineTimeout(() -> serverProperties.getReactive().getSession().getTimeout()))
				.to(sessionRepository::setDefaultMaxInactiveInterval);
			map.from(mongoSessionProperties::getCollectionName).to(sessionRepository::setCollectionName);
		};
	}
}
/*
package org.springframework.boot.autoconfigure.session;
/**
@ConfigurationProperties(prefix = 'spring.session.redis')
public class RedisSessionProperties {
	/**
	 * Namespace for keys used to store sessions.
	 */
	private String namespace = 'spring:session';
	/**
	 * Sessions flush mode. Determines when session changes are written to the session
	 * store. Not supported with a reactive session repository.
	 */
	private FlushMode flushMode = FlushMode.ON_SAVE;
	/**
	 * Sessions save mode. Determines how session changes are tracked and saved to the
	 * session store.
	 */
	private SaveMode saveMode = SaveMode.ON_SET_ATTRIBUTE;
	/**
	 * The configure action to apply when no user-defined ConfigureRedisAction or
	 * ConfigureReactiveRedisAction bean is present.
	 */
	private ConfigureAction configureAction = ConfigureAction.NOTIFY_KEYSPACE_EVENTS;
	/**
	 * Cron expression for expired session cleanup job. Only supported when
	 * repository-type is set to indexed. Not supported with a reactive session
	 * repository.
	 */
	private String cleanupCron;
	/**
	 * Type of Redis session repository to configure.
	 */
	private RepositoryType repositoryType = RepositoryType.DEFAULT;
	public String getNamespace() {
		return this.namespace;
	}
	public void setNamespace(String namespace) {
		this.namespace = namespace;
	}
	public FlushMode getFlushMode() {
		return this.flushMode;
	}
	public void setFlushMode(FlushMode flushMode) {
		this.flushMode = flushMode;
	}
	public SaveMode getSaveMode() {
		return this.saveMode;
	}
	public void setSaveMode(SaveMode saveMode) {
		this.saveMode = saveMode;
	}
	public String getCleanupCron() {
		return this.cleanupCron;
	}
	public void setCleanupCron(String cleanupCron) {
		this.cleanupCron = cleanupCron;
	}
	public ConfigureAction getConfigureAction() {
		return this.configureAction;
	}
	public void setConfigureAction(ConfigureAction configureAction) {
		this.configureAction = configureAction;
	}
	public RepositoryType getRepositoryType() {
		return this.repositoryType;
	}
	public void setRepositoryType(RepositoryType repositoryType) {
		this.repositoryType = repositoryType;
	}
	/**
	 * Strategies for configuring and validating Redis.
	 */
	public enum ConfigureAction {
		/**
		 * Ensure that Redis Keyspace events for Generic commands and Expired events are
		 * enabled.
		 */
		NOTIFY_KEYSPACE_EVENTS,
		/**
		 * No not attempt to apply any custom Redis configuration.
		 */
		NONE
	}
	/**
	 * Type of Redis session repository to auto-configure.
	 */
	public enum RepositoryType {
		/**
		 * Auto-configure a RedisSessionRepository or ReactiveRedisSessionRepository.
		 */
		DEFAULT,
		/**
		 * Auto-configure a RedisIndexedSessionRepository or
		 * ReactiveRedisIndexedSessionRepository.
		 */
		INDEXED
	}
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@FunctionalInterface
public interface ResourceConfigCustomizer {
	/**
	 * Customize the resource config.
	 * @param config the {@link ResourceConfig} to customize
	 */
	void customize(ResourceConfig config);
}
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@AutoConfiguration(before = DispatcherServletAutoConfiguration.class, after = JacksonAutoConfiguration.class)
@ConditionalOnClass({ SpringComponentProvider.class, ServletRegistration.class })
@ConditionalOnBean(type = 'org.glassfish.jersey.server.ResourceConfig')
@ConditionalOnWebApplication(type = Type.SERVLET)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@EnableConfigurationProperties(JerseyProperties.class)
public class JerseyAutoConfiguration implements ServletContextAware {
	private static final Log logger = LogFactory.getLog(JerseyAutoConfiguration.class);
	private final JerseyProperties jersey;
	private final ResourceConfig config;
	public JerseyAutoConfiguration(JerseyProperties jersey, ResourceConfig config,
			ObjectProvider<ResourceConfigCustomizer> customizers) {
		this.jersey = jersey;
		this.config = config;
		customizers.orderedStream().forEach((customizer) -> customizer.customize(this.config));
	}
	@Bean
	@ConditionalOnMissingFilterBean(RequestContextFilter.class)
	public FilterRegistrationBean<RequestContextFilter> requestContextFilter() {
		FilterRegistrationBean<RequestContextFilter> registration = new FilterRegistrationBean<>();
		registration.setFilter(new RequestContextFilter());
		registration.setOrder(this.jersey.getFilter().getOrder() - 1);
		registration.setName('requestContextFilter');
		return registration;
	}
	@Bean
	@ConditionalOnMissingBean
	public JerseyApplicationPath jerseyApplicationPath() {
		return new DefaultJerseyApplicationPath(this.jersey.getApplicationPath(), this.config);
	}
	@Bean
	@ConditionalOnMissingBean(name = 'jerseyFilterRegistration')
	@ConditionalOnProperty(prefix = 'spring.jersey', name = 'type', havingValue = 'filter')
	public FilterRegistrationBean<ServletContainer> jerseyFilterRegistration(JerseyApplicationPath applicationPath) {
		FilterRegistrationBean<ServletContainer> registration = new FilterRegistrationBean<>();
		registration.setFilter(new ServletContainer(this.config));
		registration.setUrlPatterns(Collections.singletonList(applicationPath.getUrlMapping()));
		registration.setOrder(this.jersey.getFilter().getOrder());
		registration.addInitParameter(ServletProperties.FILTER_CONTEXT_PATH, stripPattern(applicationPath.getPath()));
		addInitParameters(registration);
		registration.setName('jerseyFilter');
		registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
		return registration;
	}
	private String stripPattern(String path) {
		if (path.endsWith('/*')) {
			path = path.substring(0, path.lastIndexOf('/*'));
		}
		return path;
	}
	@Bean
	@ConditionalOnMissingBean(name = 'jerseyServletRegistration')
	@ConditionalOnProperty(prefix = 'spring.jersey', name = 'type', havingValue = 'servlet', matchIfMissing = true)
	public ServletRegistrationBean<ServletContainer> jerseyServletRegistration(JerseyApplicationPath applicationPath) {
		ServletRegistrationBean<ServletContainer> registration = new ServletRegistrationBean<>(
				new ServletContainer(this.config), applicationPath.getUrlMapping());
		addInitParameters(registration);
		registration.setName(getServletRegistrationName());
		registration.setLoadOnStartup(this.jersey.getServlet().getLoadOnStartup());
		registration.setIgnoreRegistrationFailure(true);
		return registration;
	}
	private String getServletRegistrationName() {
		return ClassUtils.getUserClass(this.config.getClass()).getName();
	}
	private void addInitParameters(DynamicRegistrationBean<?> registration) {
		this.jersey.getInit().forEach(registration::addInitParameter);
	}
	@Override
	public void setServletContext(ServletContext servletContext) {
		String servletRegistrationName = getServletRegistrationName();
		ServletRegistration registration = servletContext.getServletRegistration(servletRegistrationName);
		if (registration != null) {
			if (logger.isInfoEnabled()) {
				logger.info('Configuring existing registration for Jersey servlet "' + servletRegistrationName + '"');
			}
			registration.setInitParameters(this.jersey.getInit());
		}
	}
	@Order(Ordered.HIGHEST_PRECEDENCE)
	public static final class JerseyWebApplicationInitializer implements WebApplicationInitializer {
		@Override
		public void onStartup(ServletContext servletContext) throws ServletException {
			// We need to switch *off* the Jersey WebApplicationInitializer because it
			// will try and register a ContextLoaderListener which we don"t need
			servletContext.setInitParameter('contextConfigLocation', '<NONE>');
		}
	}
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(JacksonFeature.class)
	@ConditionalOnSingleCandidate(ObjectMapper.class)
	static class JacksonResourceConfigCustomizer {
		@Bean
		ResourceConfigCustomizer jacksonResourceConfigCustomizer(ObjectMapper objectMapper) {
			return (ResourceConfig config) -> {
				config.register(JacksonFeature.class);
				config.register(new ObjectMapperContextResolver(objectMapper), ContextResolver.class);
			};
		}
		@Configuration(proxyBeanMethods = false)
		@ConditionalOnClass({ JakartaXmlBindAnnotationIntrospector.class, XmlElement.class })
		static class JaxbObjectMapperCustomizer {
			@Autowired
			void addJaxbAnnotationIntrospector(ObjectMapper objectMapper) {
				JakartaXmlBindAnnotationIntrospector jaxbAnnotationIntrospector = new JakartaXmlBindAnnotationIntrospector(
						objectMapper.getTypeFactory());
				objectMapper.setAnnotationIntrospectors(
						createPair(objectMapper.getSerializationConfig(), jaxbAnnotationIntrospector),
						createPair(objectMapper.getDeserializationConfig(), jaxbAnnotationIntrospector));
			}
			private AnnotationIntrospector createPair(MapperConfig<?> config,
					JakartaXmlBindAnnotationIntrospector jaxbAnnotationIntrospector) {
				return AnnotationIntrospector.pair(config.getAnnotationIntrospector(), jaxbAnnotationIntrospector);
			}
		}
		private static final class ObjectMapperContextResolver implements ContextResolver<ObjectMapper> {
			private final ObjectMapper objectMapper;
			private ObjectMapperContextResolver(ObjectMapper objectMapper) {
				this.objectMapper = objectMapper;
			}
			@Override
			public ObjectMapper getContext(Class<?> type) {
				return this.objectMapper;
			}
		}
	}
}
/*
/**
package org.springframework.boot.autoconfigure.jersey;
/*
package org.springframework.boot.autoconfigure.jersey;
/**
@ConfigurationProperties(prefix = 'spring.jersey')
public class JerseyProperties {
	/**
	 * Jersey integration type.
	 */
	private Type type = Type.SERVLET;
	/**
	 * Init parameters to pass to Jersey through the servlet or filter.
	 */
	private Map<String, String> init = new HashMap<>();
	private final Filter filter = new Filter();
	private final Servlet servlet = new Servlet();
	/**
	 * Path that serves as the base URI for the application. If specified, overrides the
	 * value of '@ApplicationPath'.
	 */
	private String applicationPath;
	public Filter getFilter() {
		return this.filter;
	}
	public Servlet getServlet() {
		return this.servlet;
	}
	public Type getType() {
		return this.type;
	}
	public void setType(Type type) {
		this.type = type;
	}
	public Map<String, String> getInit() {
		return this.init;
	}
	public void setInit(Map<String, String> init) {
		this.init = init;
	}
	public String getApplicationPath() {
		return this.applicationPath;
	}
	public void setApplicationPath(String applicationPath) {
		this.applicationPath = applicationPath;
	}
	public enum Type {
		SERVLET, FILTER
	}
	public static class Filter {
		/**
		 * Jersey filter chain order.
		 */
		private int order;
		public int getOrder() {
			return this.order;
		}
		public void setOrder(int order) {
			this.order = order;
		}
	}
	public static class Servlet {
		/**
		 * Load on startup priority of the Jersey servlet.
		 */
		private int loadOnStartup = -1;
		public int getLoadOnStartup() {
			return this.loadOnStartup;
		}
		public void setLoadOnStartup(int loadOnStartup) {
			this.loadOnStartup = loadOnStartup;
		}
	}
}
/*
package org.springframework.boot.autoconfigure;
/**
public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,
		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	static final int ORDER = Ordered.LOWEST_PRECEDENCE - 1;
	private static final AutoConfigurationEntry EMPTY_ENTRY = new AutoConfigurationEntry();
	private static final String[] NO_IMPORTS = {};
	private static final Log logger = LogFactory.getLog(AutoConfigurationImportSelector.class);
	private static final String PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE = 'spring.autoconfigure.exclude';
	private final Class<?> autoConfigurationAnnotation;
	private ConfigurableListableBeanFactory beanFactory;
	private Environment environment;
	private ClassLoader beanClassLoader;
	private ResourceLoader resourceLoader;
	private volatile ConfigurationClassFilter configurationClassFilter;
	private volatile AutoConfigurationReplacements autoConfigurationReplacements;
	public AutoConfigurationImportSelector() {
		this(null);
	}
	AutoConfigurationImportSelector(Class<?> autoConfigurationAnnotation) {
		this.autoConfigurationAnnotation = (autoConfigurationAnnotation != null) ? autoConfigurationAnnotation
				: AutoConfiguration.class;
	}
	@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
	}
	@Override
	public Predicate<String> getExclusionFilter() {
		return this::shouldExclude;
	}
	private boolean shouldExclude(String configurationClassName) {
		return getConfigurationClassFilter().filter(Collections.singletonList(configurationClassName)).isEmpty();
	}
	/**
	 * Return the {@link AutoConfigurationEntry} based on the {@link AnnotationMetadata}
	 * of the importing {@link Configuration @Configuration} class.
	 * @param annotationMetadata the annotation metadata of the configuration class
	 * @return the auto-configurations that should be imported
	 */
	protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return EMPTY_ENTRY;
		}
		AnnotationAttributes attributes = getAttributes(annotationMetadata);
		List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
		configurations = removeDuplicates(configurations);
		Set<String> exclusions = getExclusions(annotationMetadata, attributes);
		checkExcludedClasses(configurations, exclusions);
		configurations.removeAll(exclusions);
		configurations = getConfigurationClassFilter().filter(configurations);
		fireAutoConfigurationImportEvents(configurations, exclusions);
		return new AutoConfigurationEntry(configurations, exclusions);
	}
	@Override
	public Class<? extends Group> getImportGroup() {
		return AutoConfigurationGroup.class;
	}
	protected boolean isEnabled(AnnotationMetadata metadata) {
		if (getClass() == AutoConfigurationImportSelector.class) {
			return getEnvironment().getProperty(EnableAutoConfiguration.ENABLED_OVERRIDE_PROPERTY, Boolean.class, true);
		}
		return true;
	}
	/**
	 * Return the appropriate {@link AnnotationAttributes} from the
	 * {@link AnnotationMetadata}. By default this method will return attributes for
	 * {@link #getAnnotationClass()}.
	 * @param metadata the annotation metadata
	 * @return annotation attributes
	 */
	protected AnnotationAttributes getAttributes(AnnotationMetadata metadata) {
		String name = getAnnotationClass().getName();
		AnnotationAttributes attributes = AnnotationAttributes.fromMap(metadata.getAnnotationAttributes(name, true));
		Assert.notNull(attributes, () -> 'No auto-configuration attributes found. Is ' + metadata.getClassName()
				+ ' annotated with ' + ClassUtils.getShortName(name) + '?');
		return attributes;
	}
	/**
	 * Return the source annotation class used by the selector.
	 * @return the annotation class
	 */
	protected Class<?> getAnnotationClass() {
		return EnableAutoConfiguration.class;
	}
	/**
	 * Return the auto-configuration class names that should be considered. By default,
	 * this method will load candidates using {@link ImportCandidates}.
	 * @param metadata the source metadata
	 * @param attributes the {@link #getAttributes(AnnotationMetadata) annotation
	 * attributes}
	 * @return a list of candidate configurations
	 */
	protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		ImportCandidates importCandidates = ImportCandidates.load(this.autoConfigurationAnnotation,
				getBeanClassLoader());
		List<String> configurations = importCandidates.getCandidates();
		Assert.notEmpty(configurations,
				'No auto configuration classes found in ' + 'META-INF/spring/'
						+ this.autoConfigurationAnnotation.getName() + '.imports. If you '
						+ 'are using a custom packaging, make sure that file is correct.');
		return configurations;
	}
	private void checkExcludedClasses(List<String> configurations, Set<String> exclusions) {
		List<String> invalidExcludes = new ArrayList<>(exclusions.size());
		for (String exclusion : exclusions) {
			if (ClassUtils.isPresent(exclusion, getClass().getClassLoader()) && !configurations.contains(exclusion)) {
				invalidExcludes.add(exclusion);
			}
		}
		if (!invalidExcludes.isEmpty()) {
			handleInvalidExcludes(invalidExcludes);
		}
	}
	/**
	 * Handle any invalid excludes that have been specified.
	 * @param invalidExcludes the list of invalid excludes (will always have at least one
	 * element)
	 */
	protected void handleInvalidExcludes(List<String> invalidExcludes) {
		StringBuilder message = new StringBuilder();
		for (String exclude : invalidExcludes) {
			message.append('\t- ').append(exclude).append(String.format('%n'));
		}
		throw new IllegalStateException(String.format(
				'The following classes could not be excluded because they are not auto-configuration classes:%n%s',
				message));
	}
	/**
	 * Return any exclusions that limit the candidate configurations.
	 * @param metadata the source metadata
	 * @param attributes the {@link #getAttributes(AnnotationMetadata) annotation
	 * attributes}
	 * @return exclusions or an empty set
	 */
	protected Set<String> getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		Set<String> excluded = new LinkedHashSet<>();
		excluded.addAll(asList(attributes, 'exclude'));
		excluded.addAll(asList(attributes, 'excludeName'));
		excluded.addAll(getExcludeAutoConfigurationsProperty());
		return getAutoConfigurationReplacements().replaceAll(excluded);
	}
	/**
	 * Returns the auto-configurations excluded by the
	 * {@code spring.autoconfigure.exclude} property.
	 * @return excluded auto-configurations
	 * @since 2.3.2
	 */
	protected List<String> getExcludeAutoConfigurationsProperty() {
		Environment environment = getEnvironment();
		if (environment == null) {
			return Collections.emptyList();
		}
		if (environment instanceof ConfigurableEnvironment) {
			Binder binder = Binder.get(environment);
			return binder.bind(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class)
				.map(Arrays::asList)
				.orElse(Collections.emptyList());
		}
		String[] excludes = environment.getProperty(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class);
		return (excludes != null) ? Arrays.asList(excludes) : Collections.emptyList();
	}
	protected List<AutoConfigurationImportFilter> getAutoConfigurationImportFilters() {
		return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader);
	}
	private ConfigurationClassFilter getConfigurationClassFilter() {
		ConfigurationClassFilter configurationClassFilter = this.configurationClassFilter;
		if (configurationClassFilter == null) {
			List<AutoConfigurationImportFilter> filters = getAutoConfigurationImportFilters();
			for (AutoConfigurationImportFilter filter : filters) {
				invokeAwareMethods(filter);
			}
			configurationClassFilter = new ConfigurationClassFilter(this.beanClassLoader, filters);
			this.configurationClassFilter = configurationClassFilter;
		}
		return configurationClassFilter;
	}
	private AutoConfigurationReplacements getAutoConfigurationReplacements() {
		AutoConfigurationReplacements autoConfigurationReplacements = this.autoConfigurationReplacements;
		if (autoConfigurationReplacements == null) {
			autoConfigurationReplacements = AutoConfigurationReplacements.load(this.autoConfigurationAnnotation,
					this.beanClassLoader);
			this.autoConfigurationReplacements = autoConfigurationReplacements;
		}
		return autoConfigurationReplacements;
	}
	protected final <T> List<T> removeDuplicates(List<T> list) {
		return new ArrayList<>(new LinkedHashSet<>(list));
	}
	protected final List<String> asList(AnnotationAttributes attributes, String name) {
		String[] value = attributes.getStringArray(name);
		return Arrays.asList(value);
	}
	private void fireAutoConfigurationImportEvents(List<String> configurations, Set<String> exclusions) {
		List<AutoConfigurationImportListener> listeners = getAutoConfigurationImportListeners();
		if (!listeners.isEmpty()) {
			AutoConfigurationImportEvent event = new AutoConfigurationImportEvent(this, configurations, exclusions);
			for (AutoConfigurationImportListener listener : listeners) {
				invokeAwareMethods(listener);
				listener.onAutoConfigurationImportEvent(event);
			}
		}
	}
	protected List<AutoConfigurationImportListener> getAutoConfigurationImportListeners() {
		return SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class, this.beanClassLoader);
	}
	private void invokeAwareMethods(Object instance) {
		if (instance instanceof Aware) {
			if (instance instanceof BeanClassLoaderAware beanClassLoaderAwareInstance) {
				beanClassLoaderAwareInstance.setBeanClassLoader(this.beanClassLoader);
			}
			if (instance instanceof BeanFactoryAware beanFactoryAwareInstance) {
				beanFactoryAwareInstance.setBeanFactory(this.beanFactory);
			}
			if (instance instanceof EnvironmentAware environmentAwareInstance) {
				environmentAwareInstance.setEnvironment(this.environment);
			}
			if (instance instanceof ResourceLoaderAware resourceLoaderAwareInstance) {
				resourceLoaderAwareInstance.setResourceLoader(this.resourceLoader);
			}
		}
	}
	@Override
	public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
		Assert.isInstanceOf(ConfigurableListableBeanFactory.class, beanFactory);
		this.beanFactory = (ConfigurableListableBeanFactory) beanFactory;
	}
	protected final ConfigurableListableBeanFactory getBeanFactory() {
		return this.beanFactory;
	}
	@Override
	public void setBeanClassLoader(ClassLoader classLoader) {
		this.beanClassLoader = classLoader;
	}
	protected ClassLoader getBeanClassLoader() {
		return this.beanClassLoader;
	}
	@Override
	public void setEnvironment(Environment environment) {
		this.environment = environment;
	}
	protected final Environment getEnvironment() {
		return this.environment;
	}
	@Override
	public void setResourceLoader(ResourceLoader resourceLoader) {
		this.resourceLoader = resourceLoader;
	}
	protected final ResourceLoader getResourceLoader() {
		return this.resourceLoader;
	}
	@Override
	public int getOrder() {
		return ORDER;
	}
	private static class ConfigurationClassFilter {
		private final AutoConfigurationMetadata autoConfigurationMetadata;
		private final List<AutoConfigurationImportFilter> filters;
		ConfigurationClassFilter(ClassLoader classLoader, List<AutoConfigurationImportFilter> filters) {
			this.autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(classLoader);
			this.filters = filters;
		}
		List<String> filter(List<String> configurations) {
			long startTime = System.nanoTime();
			String[] candidates = StringUtils.toStringArray(configurations);
			boolean skipped = false;
			for (AutoConfigurationImportFilter filter : this.filters) {
				boolean[] match = filter.match(candidates, this.autoConfigurationMetadata);
				for (int i = 0; i < match.length; i++) {
					if (!match[i]) {
						candidates[i] = null;
						skipped = true;
					}
				}
			}
			if (!skipped) {
				return configurations;
			}
			List<String> result = new ArrayList<>(candidates.length);
			for (String candidate : candidates) {
				if (candidate != null) {
					result.add(candidate);
				}
			}
			if (logger.isTraceEnabled()) {
				int numberFiltered = configurations.size() - result.size();
				logger.trace('Filtered ' + numberFiltered + ' auto configuration class in '
						+ TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + ' ms');
			}
			return result;
		}
	}
	private static final class AutoConfigurationGroup
			implements DeferredImportSelector.Group, BeanClassLoaderAware, BeanFactoryAware, ResourceLoaderAware {
		private final Map<String, AnnotationMetadata> entries = new LinkedHashMap<>();
		private final List<AutoConfigurationEntry> autoConfigurationEntries = new ArrayList<>();
		private ClassLoader beanClassLoader;
		private BeanFactory beanFactory;
		private ResourceLoader resourceLoader;
		private AutoConfigurationMetadata autoConfigurationMetadata;
		private AutoConfigurationReplacements autoConfigurationReplacements;
		@Override
		public void setBeanClassLoader(ClassLoader classLoader) {
			this.beanClassLoader = classLoader;
		}
		@Override
		public void setBeanFactory(BeanFactory beanFactory) {
			this.beanFactory = beanFactory;
		}
		@Override
		public void setResourceLoader(ResourceLoader resourceLoader) {
			this.resourceLoader = resourceLoader;
		}
		@Override
		public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) {
			Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector,
					() -> String.format('Only %s implementations are supported, got %s',
							AutoConfigurationImportSelector.class.getSimpleName(),
							deferredImportSelector.getClass().getName()));
			AutoConfigurationImportSelector autoConfigurationImportSelector = (AutoConfigurationImportSelector) deferredImportSelector;
			AutoConfigurationReplacements autoConfigurationReplacements = autoConfigurationImportSelector
				.getAutoConfigurationReplacements();
			Assert.state(
					this.autoConfigurationReplacements == null
							|| this.autoConfigurationReplacements.equals(autoConfigurationReplacements),
					'Auto-configuration replacements must be the same for each call to process');
			this.autoConfigurationReplacements = autoConfigurationReplacements;
			AutoConfigurationEntry autoConfigurationEntry = autoConfigurationImportSelector
				.getAutoConfigurationEntry(annotationMetadata);
			this.autoConfigurationEntries.add(autoConfigurationEntry);
			for (String importClassName : autoConfigurationEntry.getConfigurations()) {
				this.entries.putIfAbsent(importClassName, annotationMetadata);
			}
		}
		@Override
		public Iterable<Entry> selectImports() {
			if (this.autoConfigurationEntries.isEmpty()) {
				return Collections.emptyList();
			}
			Set<String> allExclusions = this.autoConfigurationEntries.stream()
				.map(AutoConfigurationEntry::getExclusions)
				.flatMap(Collection::stream)
				.collect(Collectors.toSet());
			Set<String> processedConfigurations = this.autoConfigurationEntries.stream()
				.map(AutoConfigurationEntry::getConfigurations)
				.flatMap(Collection::stream)
				.collect(Collectors.toCollection(LinkedHashSet::new));
			processedConfigurations.removeAll(allExclusions);
			return sortAutoConfigurations(processedConfigurations, getAutoConfigurationMetadata()).stream()
				.map((importClassName) -> new Entry(this.entries.get(importClassName), importClassName))
				.toList();
		}
		private AutoConfigurationMetadata getAutoConfigurationMetadata() {
			if (this.autoConfigurationMetadata == null) {
				this.autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
			}
			return this.autoConfigurationMetadata;
		}
		private List<String> sortAutoConfigurations(Set<String> configurations,
				AutoConfigurationMetadata autoConfigurationMetadata) {
			return new AutoConfigurationSorter(getMetadataReaderFactory(), autoConfigurationMetadata,
					this.autoConfigurationReplacements::replace)
				.getInPriorityOrder(configurations);
		}
		private MetadataReaderFactory getMetadataReaderFactory() {
			try {
				return this.beanFactory.getBean(SharedMetadataReaderFactoryContextInitializer.BEAN_NAME,
						MetadataReaderFactory.class);
			}
			catch (NoSuchBeanDefinitionException ex) {
				return new CachingMetadataReaderFactory(this.resourceLoader);
			}
		}
	}
	protected static class AutoConfigurationEntry {
		private final List<String> configurations;
		private final Set<String> exclusions;
		private AutoConfigurationEntry() {
			this.configurations = Collections.emptyList();
			this.exclusions = Collections.emptySet();
		}
		/**
		 * Create an entry with the configurations that were contributed and their
		 * exclusions.
		 * @param configurations the configurations that should be imported
		 * @param exclusions the exclusions that were applied to the original list
		 */
		AutoConfigurationEntry(Collection<String> configurations, Collection<String> exclusions) {
			this.configurations = new ArrayList<>(configurations);
			this.exclusions = new HashSet<>(exclusions);
		}
		public List<String> getConfigurations() {
			return this.configurations;
		}
		public Set<String> getExclusions() {
			return this.exclusions;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.service.connection;
/**
public class ConnectionDetailsFactoryNotFoundException extends RuntimeException {
	<S> ConnectionDetailsFactoryNotFoundException(S source) {
		this('No ConnectionDetailsFactory found for source "%s"'.formatted(source));
	}
	public ConnectionDetailsFactoryNotFoundException(String message) {
		super(message);
	}
	public ConnectionDetailsFactoryNotFoundException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.autoconfigure.service.connection;
/**
public class ConnectionDetailsFactories {
	private static final Log logger = LogFactory.getLog(ConnectionDetailsFactories.class);
	private final List<Registration<?, ?>> registrations = new ArrayList<>();
	public ConnectionDetailsFactories() {
		this(SpringFactoriesLoader.forDefaultResourceLocation(ConnectionDetailsFactory.class.getClassLoader()));
	}
	@SuppressWarnings({ 'rawtypes', 'unchecked' })
	ConnectionDetailsFactories(SpringFactoriesLoader loader) {
		List<ConnectionDetailsFactory> factories = loader.load(ConnectionDetailsFactory.class,
				FailureHandler.logging(logger));
		Stream<Registration<?, ?>> registrations = factories.stream().map(Registration::get);
		registrations.filter(Objects::nonNull).forEach(this.registrations::add);
	}
	/**
	 * Return a {@link Map} of {@link ConnectionDetails} interface type to
	 * {@link ConnectionDetails} instance created from the factories associated with the
	 * given source.
	 * @param <S> the source type
	 * @param source the source
	 * @param required if a connection details result is required
	 * @return a map of {@link ConnectionDetails} instances
	 * @throws ConnectionDetailsFactoryNotFoundException if a result is required but no
	 * connection details factory is registered for the source
	 * @throws ConnectionDetailsNotFoundException if a result is required but no
	 * connection details instance was created from a registered factory
	 */
	public <S> Map<Class<?>, ConnectionDetails> getConnectionDetails(S source, boolean required)
			throws ConnectionDetailsFactoryNotFoundException, ConnectionDetailsNotFoundException {
		List<Registration<S, ?>> registrations = getRegistrations(source, required);
		Map<Class<?>, ConnectionDetails> result = new LinkedHashMap<>();
		for (Registration<S, ?> registration : registrations) {
			ConnectionDetails connectionDetails = registration.factory().getConnectionDetails(source);
			if (connectionDetails != null) {
				Class<?> connectionDetailsType = registration.connectionDetailsType();
				ConnectionDetails previous = result.put(connectionDetailsType, connectionDetails);
				Assert.state(previous == null, () -> 'Duplicate connection details supplied for %s'
					.formatted(connectionDetailsType.getName()));
			}
		}
		if (required && result.isEmpty()) {
			throw new ConnectionDetailsNotFoundException(source);
		}
		return Map.copyOf(result);
	}
	@SuppressWarnings('unchecked')
	<S> List<Registration<S, ?>> getRegistrations(S source, boolean required) {
		Class<S> sourceType = (Class<S>) source.getClass();
		List<Registration<S, ?>> result = new ArrayList<>();
		for (Registration<?, ?> candidate : this.registrations) {
			if (candidate.sourceType().isAssignableFrom(sourceType)) {
				result.add((Registration<S, ?>) candidate);
			}
		}
		if (required && result.isEmpty()) {
			throw new ConnectionDetailsFactoryNotFoundException(source);
		}
		result.sort(Comparator.comparing(Registration::factory, AnnotationAwareOrderComparator.INSTANCE));
		return List.copyOf(result);
	}
	/**
	 * A {@link ConnectionDetailsFactory} registration.
	 *
	 * @param <S> the source type
	 * @param <D> the connection details type
	 * @param sourceType the source type
	 * @param connectionDetailsType the connection details type
	 * @param factory the factory
	 */
	record Registration<S, D extends ConnectionDetails>(Class<S> sourceType, Class<D> connectionDetailsType,
			ConnectionDetailsFactory<S, D> factory) {
		@SuppressWarnings('unchecked')
		private static <S, D extends ConnectionDetails> Registration<S, D> get(ConnectionDetailsFactory<S, D> factory) {
			ResolvableType type = ResolvableType.forClass(ConnectionDetailsFactory.class, factory.getClass());
			Class<?>[] generics = type.resolveGenerics();
			Class<S> sourceType = (Class<S>) generics[0];
			Class<D> connectionDetailsType = (Class<D>) generics[1];
			return (sourceType != null && connectionDetailsType != null)
					? new Registration<>(sourceType, connectionDetailsType, factory) : null;
		}
	}
}
/*
package org.springframework.boot.autoconfigure.service.connection;
/**
public interface ConnectionDetails {
}
/*
package org.springframework.boot.autoconfigure.service.connection;
/**
public interface ConnectionDetailsFactory<S, D extends ConnectionDetails> {
	/**
	 * Get the {@link ConnectionDetails} from the given {@code source}. May return
	 * {@code null} if no details can be created.
	 * @param source the source
	 * @return the connection details or {@code null}
	 */
	D getConnectionDetails(S source);
}
/*
/**
package org.springframework.boot.autoconfigure.service.connection;
/*
package org.springframework.boot.autoconfigure.service.connection;
/**
public class ConnectionDetailsNotFoundException extends RuntimeException {
	<S> ConnectionDetailsNotFoundException(S source) {
		this('No ConnectionDetails found for source "%s"'.formatted(source));
	}
	public ConnectionDetailsNotFoundException(String message) {
		super(message);
	}
	public ConnectionDetailsNotFoundException(String message, Throwable cause) {
		super(message, cause);
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
@Configuration(proxyBeanMethods = false)
@EnableConfigurationProperties(PulsarProperties.class)
class PulsarConfiguration {
	private final PulsarProperties properties;
	private final PulsarPropertiesMapper propertiesMapper;
	PulsarConfiguration(PulsarProperties properties) {
		this.properties = properties;
		this.propertiesMapper = new PulsarPropertiesMapper(properties);
	}
	@Bean
	@ConditionalOnMissingBean(PulsarConnectionDetails.class)
	PropertiesPulsarConnectionDetails pulsarConnectionDetails() {
		return new PropertiesPulsarConnectionDetails(this.properties);
	}
	@Bean
	@ConditionalOnMissingBean(PulsarClientFactory.class)
	DefaultPulsarClientFactory pulsarClientFactory(PulsarConnectionDetails connectionDetails,
			ObjectProvider<PulsarClientBuilderCustomizer> customizersProvider) {
		List<PulsarClientBuilderCustomizer> allCustomizers = new ArrayList<>();
		allCustomizers.add((builder) -> this.propertiesMapper.customizeClientBuilder(builder, connectionDetails));
		allCustomizers.addAll(customizersProvider.orderedStream().toList());
		DefaultPulsarClientFactory clientFactory = new DefaultPulsarClientFactory(
				(clientBuilder) -> applyClientBuilderCustomizers(allCustomizers, clientBuilder));
		return clientFactory;
	}
	private void applyClientBuilderCustomizers(List<PulsarClientBuilderCustomizer> customizers,
			ClientBuilder clientBuilder) {
		customizers.forEach((customizer) -> customizer.customize(clientBuilder));
	}
	@Bean
	@ConditionalOnMissingBean
	PulsarClient pulsarClient(PulsarClientFactory clientFactory) {
		return clientFactory.createClient();
	}
	@Bean
	@ConditionalOnMissingBean
	PulsarAdministration pulsarAdministration(PulsarConnectionDetails connectionDetails,
			ObjectProvider<PulsarAdminBuilderCustomizer> pulsarAdminBuilderCustomizers) {
		List<PulsarAdminBuilderCustomizer> allCustomizers = new ArrayList<>();
		allCustomizers.add((builder) -> this.propertiesMapper.customizeAdminBuilder(builder, connectionDetails));
		allCustomizers.addAll(pulsarAdminBuilderCustomizers.orderedStream().toList());
		return new PulsarAdministration((adminBuilder) -> applyAdminBuilderCustomizers(allCustomizers, adminBuilder));
	}
	private void applyAdminBuilderCustomizers(List<PulsarAdminBuilderCustomizer> customizers,
			PulsarAdminBuilder adminBuilder) {
		customizers.forEach((customizer) -> customizer.customize(adminBuilder));
	}
	@Bean
	@ConditionalOnMissingBean(SchemaResolver.class)
	DefaultSchemaResolver pulsarSchemaResolver(ObjectProvider<SchemaResolverCustomizer<?>> schemaResolverCustomizers) {
		DefaultSchemaResolver schemaResolver = new DefaultSchemaResolver();
		addCustomSchemaMappings(schemaResolver, this.properties.getDefaults().getTypeMappings());
		applySchemaResolverCustomizers(schemaResolverCustomizers.orderedStream().toList(), schemaResolver);
		return schemaResolver;
	}
	private void addCustomSchemaMappings(DefaultSchemaResolver schemaResolver, List<TypeMapping> typeMappings) {
		if (typeMappings != null) {
			typeMappings.forEach((typeMapping) -> addCustomSchemaMapping(schemaResolver, typeMapping));
		}
	}
	private void addCustomSchemaMapping(DefaultSchemaResolver schemaResolver, TypeMapping typeMapping) {
		SchemaInfo schemaInfo = typeMapping.schemaInfo();
		if (schemaInfo != null) {
			Class<?> messageType = typeMapping.messageType();
			SchemaType schemaType = schemaInfo.schemaType();
			Class<?> messageKeyType = schemaInfo.messageKeyType();
			Schema<?> schema = schemaResolver.resolveSchema(schemaType, messageType, messageKeyType).orElseThrow();
			schemaResolver.addCustomSchemaMapping(typeMapping.messageType(), schema);
		}
	}
	@SuppressWarnings('unchecked')
	private void applySchemaResolverCustomizers(List<SchemaResolverCustomizer<?>> customizers,
			DefaultSchemaResolver schemaResolver) {
		LambdaSafe.callbacks(SchemaResolverCustomizer.class, customizers, schemaResolver)
			.invoke((customizer) -> customizer.customize(schemaResolver));
	}
	@Bean
	@ConditionalOnMissingBean(TopicResolver.class)
	DefaultTopicResolver pulsarTopicResolver() {
		DefaultTopicResolver topicResolver = new DefaultTopicResolver();
		List<TypeMapping> typeMappings = this.properties.getDefaults().getTypeMappings();
		if (typeMappings != null) {
			typeMappings.forEach((typeMapping) -> addCustomTopicMapping(topicResolver, typeMapping));
		}
		return topicResolver;
	}
	private void addCustomTopicMapping(DefaultTopicResolver topicResolver, TypeMapping typeMapping) {
		String topicName = typeMapping.topicName();
		if (topicName != null) {
			topicResolver.addCustomTopicMapping(typeMapping.messageType(), topicName);
		}
	}
	@Bean
	@ConditionalOnMissingBean
	@ConditionalOnProperty(name = 'spring.pulsar.function.enabled', havingValue = 'true', matchIfMissing = true)
	PulsarFunctionAdministration pulsarFunctionAdministration(PulsarAdministration pulsarAdministration,
			ObjectProvider<PulsarFunction> pulsarFunctions, ObjectProvider<PulsarSink> pulsarSinks,
			ObjectProvider<PulsarSource> pulsarSources) {
		PulsarProperties.Function properties = this.properties.getFunction();
		return new PulsarFunctionAdministration(pulsarAdministration, pulsarFunctions, pulsarSinks, pulsarSources,
				properties.isFailFast(), properties.isPropagateFailures(), properties.isPropagateStopFailures());
	}
	@Bean
	@Scope('prototype')
	@ConditionalOnMissingBean
	@ConditionalOnProperty(name = 'spring.pulsar.defaults.topic.enabled', havingValue = 'true', matchIfMissing = true)
	PulsarTopicBuilder pulsarTopicBuilder() {
		return new PulsarTopicBuilder(TopicDomain.persistent, this.properties.getDefaults().getTopic().getTenant(),
				this.properties.getDefaults().getTopic().getNamespace());
	}
	@Bean
	@ConditionalOnMissingBean
	PulsarContainerFactoryCustomizers pulsarContainerFactoryCustomizers(
			ObjectProvider<PulsarContainerFactoryCustomizer<?>> customizers) {
		return new PulsarContainerFactoryCustomizers(customizers.orderedStream().toList());
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
final class PulsarPropertiesMapper {
	private static final JsonWriter<Map<String, String>> jsonWriter = JsonWriter
		.of((members) -> members.add().as(TreeMap::new).usingPairs(Map::forEach));
	private final PulsarProperties properties;
	PulsarPropertiesMapper(PulsarProperties properties) {
		this.properties = properties;
	}
	void customizeClientBuilder(ClientBuilder clientBuilder, PulsarConnectionDetails connectionDetails) {
		PulsarProperties.Client properties = this.properties.getClient();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getConnectionTimeout).to(timeoutProperty(clientBuilder::connectionTimeout));
		map.from(properties::getOperationTimeout).to(timeoutProperty(clientBuilder::operationTimeout));
		map.from(properties::getLookupTimeout).to(timeoutProperty(clientBuilder::lookupTimeout));
		map.from(properties.getThreads()::getIo).to(clientBuilder::ioThreads);
		map.from(properties.getThreads()::getListener).to(clientBuilder::listenerThreads);
		map.from(this.properties.getTransaction()::isEnabled).whenTrue().to(clientBuilder::enableTransaction);
		customizeAuthentication(properties.getAuthentication(), clientBuilder::authentication);
		customizeServiceUrlProviderBuilder(clientBuilder::serviceUrl, clientBuilder::serviceUrlProvider, properties,
				connectionDetails);
	}
	private void customizeServiceUrlProviderBuilder(Consumer<String> serviceUrlConsumer,
			Consumer<ServiceUrlProvider> serviceUrlProviderConsumer, PulsarProperties.Client properties,
			PulsarConnectionDetails connectionDetails) {
		PulsarProperties.Failover failoverProperties = properties.getFailover();
		if (failoverProperties.getBackupClusters().isEmpty()) {
			serviceUrlConsumer.accept(connectionDetails.getBrokerUrl());
			return;
		}
		Map<String, Authentication> secondaryAuths = getSecondaryAuths(failoverProperties);
		AutoClusterFailoverBuilder autoClusterFailoverBuilder = new AutoClusterFailoverBuilderImpl();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(connectionDetails::getBrokerUrl).to(autoClusterFailoverBuilder::primary);
		map.from(secondaryAuths::keySet).as(ArrayList::new).to(autoClusterFailoverBuilder::secondary);
		map.from(failoverProperties::getPolicy).to(autoClusterFailoverBuilder::failoverPolicy);
		map.from(failoverProperties::getDelay).to(timeoutProperty(autoClusterFailoverBuilder::failoverDelay));
		map.from(failoverProperties::getSwitchBackDelay)
			.to(timeoutProperty(autoClusterFailoverBuilder::switchBackDelay));
		map.from(failoverProperties::getCheckInterval).to(timeoutProperty(autoClusterFailoverBuilder::checkInterval));
		map.from(secondaryAuths).to(autoClusterFailoverBuilder::secondaryAuthentication);
		serviceUrlProviderConsumer.accept(autoClusterFailoverBuilder.build());
	}
	private Map<String, Authentication> getSecondaryAuths(PulsarProperties.Failover properties) {
		Map<String, Authentication> secondaryAuths = new LinkedHashMap<>();
		properties.getBackupClusters().forEach((backupCluster) -> {
			PulsarProperties.Authentication authenticationProperties = backupCluster.getAuthentication();
			if (authenticationProperties.getPluginClassName() == null) {
				secondaryAuths.put(backupCluster.getServiceUrl(), null);
			}
			else {
				customizeAuthentication(authenticationProperties, (authPluginClassName, authParams) -> {
					Authentication authentication = AuthenticationFactory.create(authPluginClassName, authParams);
					secondaryAuths.put(backupCluster.getServiceUrl(), authentication);
				});
			}
		});
		return secondaryAuths;
	}
	void customizeAdminBuilder(PulsarAdminBuilder adminBuilder, PulsarConnectionDetails connectionDetails) {
		PulsarProperties.Admin properties = this.properties.getAdmin();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(connectionDetails::getAdminUrl).to(adminBuilder::serviceHttpUrl);
		map.from(properties::getConnectionTimeout).to(timeoutProperty(adminBuilder::connectionTimeout));
		map.from(properties::getReadTimeout).to(timeoutProperty(adminBuilder::readTimeout));
		map.from(properties::getRequestTimeout).to(timeoutProperty(adminBuilder::requestTimeout));
		customizeAuthentication(properties.getAuthentication(), adminBuilder::authentication);
	}
	private void customizeAuthentication(PulsarProperties.Authentication properties, AuthenticationConsumer action) {
		String pluginClassName = properties.getPluginClassName();
		if (StringUtils.hasText(pluginClassName)) {
			try {
				action.accept(pluginClassName, jsonWriter.writeToString(properties.getParam()));
			}
			catch (UnsupportedAuthenticationException ex) {
				throw new IllegalStateException('Unable to configure Pulsar authentication', ex);
			}
		}
	}
	<T> void customizeProducerBuilder(ProducerBuilder<T> producerBuilder) {
		PulsarProperties.Producer properties = this.properties.getProducer();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(producerBuilder::producerName);
		map.from(properties::getTopicName).to(producerBuilder::topic);
		map.from(properties::getSendTimeout).to(timeoutProperty(producerBuilder::sendTimeout));
		map.from(properties::getMessageRoutingMode).to(producerBuilder::messageRoutingMode);
		map.from(properties::getHashingScheme).to(producerBuilder::hashingScheme);
		map.from(properties::isBatchingEnabled).to(producerBuilder::enableBatching);
		map.from(properties::isChunkingEnabled).to(producerBuilder::enableChunking);
		map.from(properties::getCompressionType).to(producerBuilder::compressionType);
		map.from(properties::getAccessMode).to(producerBuilder::accessMode);
	}
	<T> void customizeTemplate(PulsarTemplate<T> template) {
		template.transactions().setEnabled(this.properties.getTransaction().isEnabled());
	}
	<T> void customizeConsumerBuilder(ConsumerBuilder<T> consumerBuilder) {
		PulsarProperties.Consumer properties = this.properties.getConsumer();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(consumerBuilder::consumerName);
		map.from(properties::getTopics).as(ArrayList::new).to(consumerBuilder::topics);
		map.from(properties::getTopicsPattern).to(consumerBuilder::topicsPattern);
		map.from(properties::getPriorityLevel).to(consumerBuilder::priorityLevel);
		map.from(properties::isReadCompacted).to(consumerBuilder::readCompacted);
		map.from(properties::getDeadLetterPolicy).as(DeadLetterPolicyMapper::map).to(consumerBuilder::deadLetterPolicy);
		map.from(properties::isRetryEnable).to(consumerBuilder::enableRetry);
		customizeConsumerBuilderSubscription(consumerBuilder);
	}
	private void customizeConsumerBuilderSubscription(ConsumerBuilder<?> consumerBuilder) {
		PulsarProperties.Consumer.Subscription properties = this.properties.getConsumer().getSubscription();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(consumerBuilder::subscriptionName);
		map.from(properties::getInitialPosition).to(consumerBuilder::subscriptionInitialPosition);
		map.from(properties::getMode).to(consumerBuilder::subscriptionMode);
		map.from(properties::getTopicsMode).to(consumerBuilder::subscriptionTopicsMode);
		map.from(properties::getType).to(consumerBuilder::subscriptionType);
	}
	void customizeContainerProperties(PulsarContainerProperties containerProperties) {
		customizePulsarContainerConsumerSubscriptionProperties(containerProperties);
		customizePulsarContainerListenerProperties(containerProperties);
		containerProperties.transactions().setEnabled(this.properties.getTransaction().isEnabled());
	}
	private void customizePulsarContainerConsumerSubscriptionProperties(PulsarContainerProperties containerProperties) {
		PulsarProperties.Consumer.Subscription properties = this.properties.getConsumer().getSubscription();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getType).to(containerProperties::setSubscriptionType);
		map.from(properties::getName).to(containerProperties::setSubscriptionName);
	}
	private void customizePulsarContainerListenerProperties(PulsarContainerProperties containerProperties) {
		PulsarProperties.Listener properties = this.properties.getListener();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getSchemaType).to(containerProperties::setSchemaType);
		map.from(properties::getConcurrency).to(containerProperties::setConcurrency);
		map.from(properties::isObservationEnabled).to(containerProperties::setObservationEnabled);
	}
	<T> void customizeReaderBuilder(ReaderBuilder<T> readerBuilder) {
		PulsarProperties.Reader properties = this.properties.getReader();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getName).to(readerBuilder::readerName);
		map.from(properties::getTopics).to(readerBuilder::topics);
		map.from(properties::getSubscriptionName).to(readerBuilder::subscriptionName);
		map.from(properties::getSubscriptionRolePrefix).to(readerBuilder::subscriptionRolePrefix);
		map.from(properties::isReadCompacted).to(readerBuilder::readCompacted);
	}
	void customizeReaderContainerProperties(PulsarReaderContainerProperties readerContainerProperties) {
		PulsarProperties.Reader properties = this.properties.getReader();
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		map.from(properties::getTopics).to(readerContainerProperties::setTopics);
	}
	private Consumer<Duration> timeoutProperty(BiConsumer<Integer, TimeUnit> setter) {
		return (duration) -> setter.accept((int) duration.toMillis(), TimeUnit.MILLISECONDS);
	}
	private interface AuthenticationConsumer {
		void accept(String authPluginClassName, String authParamString) throws UnsupportedAuthenticationException;
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
final class DeadLetterPolicyMapper {
	private DeadLetterPolicyMapper() {
	}
	static DeadLetterPolicy map(PulsarProperties.Consumer.DeadLetterPolicy policy) {
		Assert.state(policy.getMaxRedeliverCount() > 0,
				'Pulsar DeadLetterPolicy must have a positive "max-redelivery-count" property value');
		PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();
		DeadLetterPolicyBuilder builder = DeadLetterPolicy.builder();
		map.from(policy::getMaxRedeliverCount).to(builder::maxRedeliverCount);
		map.from(policy::getRetryLetterTopic).to(builder::retryLetterTopic);
		map.from(policy::getDeadLetterTopic).to(builder::deadLetterTopic);
		map.from(policy::getInitialSubscriptionName).to(builder::initialSubscriptionName);
		return builder.build();
	}
}
/*
package org.springframework.boot.autoconfigure.pulsar;
/**
@ConfigurationProperties('spring.pulsar')
public class PulsarProperties {
	private final Client client = new Client();
	private final Admin admin = new Admin();
	private final Defaults defaults = new Defaults();
	private final Function function = new Function();
	private final Producer producer = new Producer();
	private final Consumer consumer = new Consumer();
	private final Listener listener = new Listener();
	private final Reader reader = new Reader();
	private final Template template = new Template();
	private final Transaction transaction = new Transaction();
	public Client getClient() {
		return this.client;
	}
	public Admin getAdmin() {
		return this.admin;
	}
	public Defaults getDefaults() {
		return this.defaults;
	}
	public Producer getProducer() {
		return this.producer;
	}
	public Consumer getConsumer() {
		return this.consumer;
	}
	public Listener getListener() {
		return this.listener;
	}
	public Reader getReader() {
		return this.reader;
	}
	public Function getFunction() {
		return this.function;
	}
	public Template getTemplate() {
		return this.template;
	}
	public Transaction getTransaction() {
		return this.transaction;
	}
	public static class Client {
		/**
		 * Pulsar service URL in the format "(pulsar|pulsar+ssl)://host:port".
		 */
		private String serviceUrl = 'pulsar://localhost:6650';
		/**
		 * Client operation timeout.
		 */
		private Duration operationTimeout = Duration.ofSeconds(30);
		/**
		 * Client lookup timeout.
		 */
		private Duration lookupTimeout;
		/**
		 * Duration to wait for a connection to a broker to be established.
		 */
		private Duration connectionTimeout = Duration.ofSeconds(10);
		/**
		 * Authentication settings.
		 */
		private final Authentication authentication = new Authentication();
		/**
		 * Thread related configuration.
		 */
		private final Threads threads = new Threads();
		/**
		 * Failover settings.
		 */
		private final Failover failover = new Failover();
		public String getServiceUrl() {
			return this.serviceUrl;
		}
		public void setServiceUrl(String serviceUrl) {
			this.serviceUrl = serviceUrl;
		}
		public Duration getOperationTimeout() {
			return this.operationTimeout;
		}
		public void setOperationTimeout(Duration operationTimeout) {
			this.operationTimeout = operationTimeout;
		}
		public Duration getLookupTimeout() {
			return this.lookupTimeout;
		}
		public void setLookupTimeout(Duration lookupTimeout) {
			this.lookupTimeout = lookupTimeout;
		}
		public Duration getConnectionTimeout() {
			return this.connectionTimeout;
		}
		public void setConnectionTimeout(Duration connectionTimeout) {
			this.connectionTimeout = connectionTimeout;
		}
		public Authentication getAuthentication() {
			return this.authentication;
		}
		public Threads getThreads() {
			return this.threads;
		}
		public Failover getFailover() {
			return this.failover;
		}
	}
	public static class Admin {
		/**
		 * Pulsar web URL for the admin endpoint in the format "(http|https)://host:port".
		 */
		private String serviceUrl = 'http://localhost:8080';
		/**
		 * Duration to wait for a connection to server to be established.
		 */
		private Duration connectionTimeout = Duration.ofMinutes(1);
		/**
		 * Server response read time out for any request.
		 */
		private Duration readTimeout = Duration.ofMinutes(1);
		/**
		 * Server request time out for any request.
		 */
		private Duration requestTimeout = Duration.ofMinutes(5);
		/**
		 * Authentication settings.
		 */
		private final Authentication authentication = new Authentication();
		public String getServiceUrl() {
			return this.serviceUrl;
		}
		public void setServiceUrl(String serviceUrl) {
			this.serviceUrl = serviceUrl;
		}
		public Duration getConnectionTimeout() {
			return this.connectionTimeout;
		}
		public void setConnectionTimeout(Duration connectionTimeout) {
			this.connectionTimeout = connectionTimeout;
		}
		public Duration getReadTimeout() {
			return this.readTimeout;
		}
		public void setReadTimeout(Duration readTimeout) {
			this.readTimeout = readTimeout;
		}
		public Duration getRequestTimeout() {
			return this.requestTimeout;
		}
		public void setRequestTimeout(Duration requestTimeout) {
			this.requestTimeout = requestTimeout;
		}
		public Authentication getAuthentication() {
			return this.authentication;
		}
	}
	public static class Defaults {
		/**
		 * List of mappings from message type to topic name and schema info to use as a
		 * defaults when a topic name and/or schema is not explicitly specified when
		 * producing or consuming messages of the mapped type.
		 */
		private List<TypeMapping> typeMappings = new ArrayList<>();
		private final Topic topic = new Topic();
		public List<TypeMapping> getTypeMappings() {
			return this.typeMappings;
		}
		public void setTypeMappings(List<TypeMapping> typeMappings) {
			this.typeMappings = typeMappings;
		}
		public Topic getTopic() {
			return this.topic;
		}
		/**
		 * A mapping from message type to topic and/or schema info to use (at least one of
		 * {@code topicName} or {@code schemaInfo} must be specified.
		 *
		 * @param messageType the message type
		 * @param topicName the topic name
		 * @param schemaInfo the schema info
		 */
		public record TypeMapping(Class<?> messageType, String topicName, SchemaInfo schemaInfo) {
			public TypeMapping {
				Assert.notNull(messageType, 'messageType must not be null');
				Assert.isTrue(topicName != null || schemaInfo != null,
						'At least one of topicName or schemaInfo must not be null');
			}
		}
		/**
		 * Represents a schema - holds enough information to construct an actual schema
		 * instance.
		 *
		 * @param schemaType schema type
		 * @param messageKeyType message key type (required for key value type)
		 */
		public record SchemaInfo(SchemaType schemaType, Class<?> messageKeyType) {
			public SchemaInfo {
				Assert.notNull(schemaType, 'schemaType must not be null');
				Assert.isTrue(schemaType != SchemaType.NONE, 'schemaType "NONE" not supported');
				Assert.isTrue(messageKeyType == null || schemaType == SchemaType.KEY_VALUE,
						'messageKeyType can only be set when schemaType is KEY_VALUE');
			}
		}
		public static class Topic {
			/**
			 * Default tenant to use when producing or consuming messages against a
			 * non-fully-qualified topic URL.
			 */
			private String tenant = 'public';
			/**
			 * Default namespace to use when producing or consuming messages against a
			 * non-fully-qualified topic URL.
			 */
			private String namespace = 'default';
			public String getTenant() {
				return this.tenant;
			}
			public void setTenant(String tenant) {
				this.tenant = tenant;
			}
			public String getNamespace() {
				return this.namespace;
			}
			public void setNamespace(String namespace) {
				this.namespace = namespace;
			}
		}
	}
	public static class Function {
		/**
		 * Whether to stop processing further function creates/updates when a failure
		 * occurs.
		 */
		private boolean failFast = true;
		/**
		 * Whether to throw an exception if any failure is encountered during server
		 * startup while creating/updating functions.
		 */
		private boolean propagateFailures = true;
		/**
		 * Whether to throw an exception if any failure is encountered during server
		 * shutdown while enforcing stop policy on functions.
		 */
		private boolean propagateStopFailures = false;
		public boolean isFailFast() {
			return this.failFast;
		}
		public void setFailFast(boolean failFast) {
			this.failFast = failFast;
		}
		public boolean isPropagateFailures() {
			return this.propagateFailures;
		}
		public void setPropagateFailures(boolean propagateFailures) {
			this.propagateFailures = propagateFailures;
		}
		public boolean isPropagateStopFailures() {
			return this.propagateStopFailures;
		}
		public void setPropagateStopFailures(boolean propagateStopFailures) {
			this.propagateStopFailures = propagateStopFailures;
		}
	}
	public static class Producer {
		/**
		 * Name for the producer. If not assigned, a unique name is generated.
		 */
		private String name;
		/**
		 * Topic the producer will publish to.
		 */
		private String topicName;
		/**
		 * Time before a message has to be acknowledged by the broker.
		 */
		private Duration sendTimeout = Duration.ofSeconds(30);
		/**
		 * Message routing mode for a partitioned producer.
		 */
		private MessageRoutingMode messageRoutingMode = MessageRoutingMode.RoundRobinPartition;
		/**
		 * Message hashing scheme to choose the partition to which the message is
		 * published.
		 */
		private HashingScheme hashingScheme = HashingScheme.JavaStringHash;
		/**
		 * Whether to automatically batch messages.
		 */
		private boolean batchingEnabled = true;
		/**
		 * Whether to split large-size messages into multiple chunks.
		 */
		private boolean chunkingEnabled;
		/**
		 * Message compression type.
		 */
		private CompressionType compressionType;
		/**
		 * Type of access to the topic the producer requires.
		 */
		private ProducerAccessMode accessMode = ProducerAccessMode.Shared;
		private final Cache cache = new Cache();
		public String getName() {
			return this.name;
		}
		public void setName(String name) {
			this.name = name;
		}
		public String getTopicName() {
			return this.topicName;
		}
		public void setTopicName(String topicName) {
			this.topicName = topicName;
		}
		public Duration getSendTimeout() {
			return this.sendTimeout;
		}
		public void setSendTimeout(Duration sendTimeout) {
			this.sendTimeout = sendTimeout;
		}
		public MessageRoutingMode getMessageRoutingMode() {
			return this.messageRoutingMode;
		}
		public void setMessageRoutingMode(MessageRoutingMode messageRoutingMode) {
			this.messageRoutingMode = messageRoutingMode;
		}
		public HashingScheme getHashingScheme() {
			return this.hashingScheme;
		}
		public void setHashingScheme(HashingScheme hashingScheme) {
			this.hashingScheme = hashingScheme;
		}
		public boolean isBatchingEnabled() {
			return this.batchingEnabled;
		}
		public void setBatchingEnabled(boolean batchingEnabled) {
			this.batchingEnabled = batchingEnabled;
		}
		public boolean isChunkingEnabled() {
			return this.chunkingEnabled;
		}
		public void setChunkingEnabled(boolean chunkingEnabled) {
			this.chunkingEnabled = chunkingEnabled;
		}
		public CompressionType getCompressionType() {
			return this.compressionType;
		}
		public void setCompressionType(CompressionType compressionType) {
			this.compressionType = compressionType;
		}
		public ProducerAccessMode getAccessMode() {
			return this.accessMode;
		}
		public void setAccessMode(ProducerAccessMode accessMode) {
			this.accessMode = accessMode;
		}
		public Cache getCache() {
			return this.cache;
		}
		public static class Cache {
			/**
			 * Time period to expire unused entries in the cache.
			 */
			private Duration expireAfterAccess = Duration.ofMinutes(1);
			/**
			 * Maximum size of cache (entries).
			 */
			private long maximumSize = 1000L;
			/**
			 * Initial size of cache.
			 */
			private int initialCapacity = 50;
			public Duration getExpireAfterAccess() {
				return this.expireAfterAccess;
			}
			public void setExpireAfterAccess(Duration expireAfterAccess) {
				this.expireAfterAccess = expireAfterAccess;
			}
			public long